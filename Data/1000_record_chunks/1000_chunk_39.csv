record_number,buggy_code,fixed_code,code_similarity
38001,"@SuppressWarnings(""String_Node_Str"") @Override protected <P>void listen(Class<P> type,Consumer<P> handler,Channel<ByteBuf> baseChannel){
  FieldWrapper wrapper=FieldWrapper.clazz(type);
  ByteCodec<P> codec=(ByteCodec<P>)codecs.getCodec(wrapper).orElseThrow(() -> new UnsupportedOperationException(""String_Node_Str"" + wrapper.name())).toByteCodec();
  baseChannel.subscribe(buf -> {
    P message=codec.decode(buf);
    handler.accept(message);
  }
);
}","@SuppressWarnings(""String_Node_Str"") @Override protected <P>void listen(Class<P> type,Consumer<P> handler,Channel<ByteBuf> baseChannel){
  FieldWrapper wrapper=FieldWrapper.clazz(type);
  ByteCodec<P> codec=(ByteCodec<P>)codecs.getCodecOrThrow(wrapper).toByteCodec();
  baseChannel.subscribe(buf -> {
    P message=codec.decode(buf);
    handler.accept(message);
  }
);
}",0.6480582524271845
38002,"/** 
 * Get a mutable set of entries that lie behind the given connection.
 */
private Set<T> getTheirEntriesMut(Connection connection){
  return getChannelProperty(PROPERTY_THEIR_ENTRIES,connection,HashSet::new);
}","/** 
 * Get a mutable set of entries that lie behind the given connection.
 */
private Set<T> getTheirEntriesMut(Connection connection){
  return getChannelProperty(PROPERTY_THEIR_ENTRIES,connection,GraphCollectionSynchronizer::newConcurrentSet);
}",0.8984881209503239
38003,"/** 
 * Get a mutable set of entries that we have sent to the given connection.
 */
private Set<T> getTransmittedEntries(Connection connection){
  return getChannelProperty(PROPERTY_TRANSMITTED_ENTRIES,connection,HashSet::new);
}","/** 
 * Get a mutable set of entries that we have sent to the given connection.
 */
private Set<T> getTransmittedEntries(Connection connection){
  return getChannelProperty(PROPERTY_TRANSMITTED_ENTRIES,connection,GraphCollectionSynchronizer::newConcurrentSet);
}",0.9042769857433808
38004,"/** 
 * Compiles and runs the specified   {@code .java} class. If a filename is setin the engine scope bindings via the  {@link ScriptEngine#FILENAME} key,this method compiles that file and runs the resulting main class instead. <p> The currently active  {@link JavaService} is responsible for running theclass. </p>
 * @param reader the reader producing the source code for a Java class
 * @return null
 */
@Override public Object eval(Reader reader) throws ScriptException {
  String script;
  try {
    script=getReaderContentsAsString(reader);
  }
 catch (  IOException e) {
    throw new ScriptException(e);
  }
  return eval(script);
}","/** 
 * Compiles and runs the specified   {@code .java} class. If a filename is setin the engine scope bindings via the  {@link ScriptEngine#FILENAME} key,this method compiles that file and runs the resulting main class instead. <p> The currently active  {@link RunService} is responsible for running theclass. </p>
 * @param reader the reader producing the source code for a Java class
 * @return null
 */
@Override public Object eval(Reader reader) throws ScriptException {
  String script;
  try {
    script=getReaderContentsAsString(reader);
  }
 catch (  IOException e) {
    throw new ScriptException(e);
  }
  return eval(script);
}",0.994535519125683
38005,"/** 
 * Read complete contents of a Reader and return as String.
 * @param reader {@link Reader} whose output should be returned as String.
 * @return contents of reader as String.
 */
private static String getReaderContentsAsString(Reader reader) throws IOException {
  if (reader == null) {
    return null;
  }
  CharBuffer buffer=CharBuffer.allocate(1024);
  StringBuilder builder=new StringBuilder();
  int read;
  while ((read=reader.read(buffer)) != -1) {
    builder.append(buffer,0,read);
  }
  return builder.toString();
}","/** 
 * Read complete contents of a Reader and return as String.
 * @param reader {@link Reader} whose output should be returned as String.
 * @return contents of reader as String.
 */
private static String getReaderContentsAsString(Reader reader) throws IOException {
  if (reader == null) {
    return null;
  }
  char[] buffer=new char[1024];
  StringBuilder builder=new StringBuilder();
  int read;
  while ((read=reader.read(buffer)) != -1) {
    builder.append(buffer,0,read);
  }
  return builder.toString();
}",0.9666348903717826
38006,"public static String getPlayerPrefix(Player player){
  PermissionUser user=pex.getUser(player);
  String s=user.getPrefix().replaceAll(""String_Node_Str"",""String_Node_Str"");
  return s;
}","public static String getPlayerPrefix(Player player){
  PermissionUser user=pex.getUser(player);
  String s=user.getPrefix().replaceAll(""String_Node_Str"",""String_Node_Str"");
  if (s.length() > 16) {
    s=s.substring(0,15);
  }
  return s;
}",0.8262910798122066
38007,"@Override public void onEnable(){
  if (Bukkit.getServer().getPluginManager().getPlugin(""String_Node_Str"").equals(null)) {
    this.getLogger().info(ChatColor.RED + ""String_Node_Str"");
    Bukkit.getServer().getPluginManager().disablePlugin(this);
  }
 else {
    Bukkit.getServer().getPluginManager().registerEvents(new Listeners(),this);
    this.saveConfig();
    config=new Config(this);
    config.update();
    config.updateColors();
  }
}","@Override public void onEnable(){
  if (Bukkit.getServer().getPluginManager().getPlugin(""String_Node_Str"") == null) {
    this.getLogger().info(ChatColor.RED + ""String_Node_Str"");
    Bukkit.getServer().getPluginManager().disablePlugin(this);
  }
 else {
    Bukkit.getServer().getPluginManager().registerEvents(new Listeners(),this);
    this.saveConfig();
    config=new Config(this);
    config.update();
    config.updateColors();
  }
}",0.976271186440678
38008,"@Override public void onDisable(){
  config=null;
  Pex.pex=null;
  Config.groupColors=null;
}","@Override public void onDisable(){
  Teams.shutdown();
  config=null;
  Pex.pex=null;
  Config.groupColors=null;
}",0.903846153846154
38009,"public static String getPlayerPrefix(Player player){
  PermissionUser user=pex.getUser(player);
  return user.getPrefix();
}","public static String getPlayerPrefix(Player player){
  PermissionUser user=pex.getUser(player);
  String s=user.getPrefix().replaceAll(""String_Node_Str"",""String_Node_Str"");
  return s;
}",0.7741935483870968
38010,"public static void addColor(Player player){
  ScoreboardManager scoreboardManager=Bukkit.getScoreboardManager();
  Team team=scoreboardManager.getMainScoreboard().registerNewTeam(player.getName());
  team.setPrefix(Pex.getPlayerPrefix(player));
  team.addPlayer(player);
  teams.put(player.getName(),team);
}","public static void addColor(Player player){
  ScoreboardManager scoreboardManager=Bukkit.getScoreboardManager();
  Team team=scoreboardManager.getMainScoreboard().getTeam(player.getName());
  if (team == null) {
    Team t=scoreboardManager.getMainScoreboard().registerNewTeam(player.getName());
    t.setPrefix(Pex.getPlayerPrefix(player) + ""String_Node_Str"");
    t.addPlayer(player);
  }
 else {
    team.setPrefix(Pex.getPlayerPrefix(player) + ""String_Node_Str"");
  }
}",0.614596670934699
38011,"@Override public void onEnable(){
  if (Bukkit.getServer().getPluginManager().getPlugin(""String_Node_Str"").equals(null)) {
    this.getLogger().info(ChatColor.RED + ""String_Node_Str"");
    Bukkit.getServer().getPluginManager().disablePlugin(this);
  }
 else {
    Bukkit.getServer().getPluginManager().registerEvents(new Listeners(),this);
    this.saveDefaultConfig();
    config=new Config(this);
    config.update();
    config.updateColors();
  }
}","@Override public void onEnable(){
  if (Bukkit.getServer().getPluginManager().getPlugin(""String_Node_Str"").equals(null)) {
    this.getLogger().info(ChatColor.RED + ""String_Node_Str"");
    Bukkit.getServer().getPluginManager().disablePlugin(this);
  }
 else {
    Bukkit.getServer().getPluginManager().registerEvents(new Listeners(),this);
    this.saveConfig();
    config=new Config(this);
    config.update();
    config.updateColors();
  }
}",0.992196209587514
38012,"private void println(final String text){
  textArea.appendText(text + System.lineSeparator());
}","private void println(final String text){
  GUIHelper.runSafe(() -> textArea.appendText(text + System.lineSeparator()));
}",0.8847926267281107
38013,"private void refreshAllStats(final Game game){
  textArea.clear();
  println(""String_Node_Str"" + game.getActivePlayer().get().getName());
  println();
  game.getPlayers().forEach(this::showPlayerStats);
}","private void refreshAllStats(final Game game){
  clear();
  println(""String_Node_Str"" + game.getActivePlayer().get().getName());
  println();
  game.getPlayers().forEach(this::showPlayerStats);
}",0.9774436090225564
38014,"public MonsterCard fuseWith(final MonsterCard fuserMonsterCard,final FusionCard fusionCard){
  Objects.requireNonNull(fuserMonsterCard);
  Objects.requireNonNull(fusionCard);
  return fusionCard.getFusionStat().createBuilder(this,fuserMonsterCard,fusionCard).name(getName() + ""String_Node_Str"" + fuserMonsterCard.getName()).build();
}","public MonsterCard fuseWith(final MonsterCard fuserMonsterCard,final FusionCard fusionCard){
  Objects.requireNonNull(fuserMonsterCard);
  Objects.requireNonNull(fusionCard);
  if (fuserMonsterCard.equals(this)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return fusionCard.getFusionStat().createBuilder(this,fuserMonsterCard,fusionCard).name(getName() + ""String_Node_Str"" + fuserMonsterCard.getName()).build();
}",0.612987012987013
38015,"public MonsterCard fuseWith(final MonsterCard fuserMonsterCard,final FusionCard fusionCard){
  Objects.requireNonNull(fuserMonsterCard);
  Objects.requireNonNull(fusionCard);
  return fusionCard.getFusionStat().createBuilder(this,fuserMonsterCard,fusionCard).name(getName() + ""String_Node_Str"" + fuserMonsterCard.getName()).build();
}","public MonsterCard fuseWith(final MonsterCard fuserMonsterCard,final FusionCard fusionCard){
  Objects.requireNonNull(fuserMonsterCard);
  Objects.requireNonNull(fusionCard);
  if (fuserMonsterCard.equals(this)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return fusionCard.getFusionStat().createBuilder(this,fuserMonsterCard,fusionCard).name(getName() + ""String_Node_Str"" + fuserMonsterCard.getName()).build();
}",0.612987012987013
38016,"private void println(final String text){
  textArea.appendText(text + System.lineSeparator());
}","private void println(final String text){
  GUIHelper.runSafe(() -> textArea.appendText(text + System.lineSeparator()));
}",0.8847926267281107
38017,"private void refreshAllStats(final Game game){
  textArea.clear();
  println(""String_Node_Str"" + game.getActivePlayer().get().getName());
  println();
  game.getPlayers().forEach(this::showPlayerStats);
}","private void refreshAllStats(final Game game){
  clear();
  println(""String_Node_Str"" + game.getActivePlayer().get().getName());
  println();
  game.getPlayers().forEach(this::showPlayerStats);
}",0.9774436090225564
38018,"@Override public void onReceive(Context context,Intent intent){
  if (Connection.isConnected(context)) {
    Intent serviceIntent=new Intent();
    serviceIntent.setClass(context,UpdateFeedCountService.class);
    if (intent.getStringExtra(Consts.UPDATE_SOURCE) != null) {
      serviceIntent.putExtra(Consts.UPDATE_SOURCE,intent.getStringExtra(Consts.UPDATE_SOURCE));
    }
    context.startService(serviceIntent);
  }
}","@Override public void onReceive(Context context,Intent intent){
  if (Connection.isConnected(context)) {
    Intent serviceIntent=new Intent();
    serviceIntent.setClass(context,UpdateFeedCountService.class);
    if (intent.getStringExtra(Consts.UPDATE_SOURCE) != null) {
      Log.v(App.TAG,""String_Node_Str"" + intent.getStringExtra(Consts.UPDATE_SOURCE));
      serviceIntent.putExtra(Consts.UPDATE_SOURCE,intent.getStringExtra(Consts.UPDATE_SOURCE));
    }
    context.startService(serviceIntent);
  }
}",0.8362068965517241
38019,"public void cancel(){
  GetAlarmManager(context).cancel(GetPendingIntent(context,UPDATESOURCE.ALARM));
}","public void cancel(){
  GetAlarmManager(context).cancel(GetPendingIntentAlarm(context,UPDATESOURCE.ALARM));
}",0.976525821596244
38020,"public boolean DoesAlarmExist(){
  PendingIntent existingIntent=PendingIntent.getBroadcast(context,REQUEST_CODE,GetAlarmIntent(UPDATESOURCE.ALARM),PendingIntent.FLAG_NO_CREATE);
  if (existingIntent != null) {
    Log.d(App.TAG,""String_Node_Str"");
    return true;
  }
  Log.d(App.TAG,""String_Node_Str"");
  return false;
}","public boolean DoesAlarmExist(){
  PendingIntent existingIntent=PendingIntent.getBroadcast(context,REQUEST_CODE,GetIntent(UPDATESOURCE.ALARM),PendingIntent.FLAG_NO_CREATE);
  if (existingIntent != null) {
    Log.d(App.TAG,""String_Node_Str"");
    return true;
  }
  Log.d(App.TAG,""String_Node_Str"");
  return false;
}",0.9921752738654148
38021,"public void Schedule(){
  AlarmManager alarmManager=GetAlarmManager(context);
  long recurInterval=LOWEST_RECUR_INTERVAL * 60 * 60* 1000;
  alarmManager.setInexactRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP,0,recurInterval,GetPendingIntent(context,UPDATESOURCE.ALARM));
}","public void Schedule(){
  AlarmManager alarmManager=GetAlarmManager(context);
  long recurInterval=LOWEST_RECUR_INTERVAL * 60 * 60* 1000;
  alarmManager.setInexactRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP,0,recurInterval,GetPendingIntentAlarm(context,UPDATESOURCE.ALARM));
}",0.9909584086799276
38022,"@Override protected void doWakefulWork(Intent intent){
  String source=intent.getStringExtra(Consts.UPDATE_SOURCE);
  if (!TextUtils.isEmpty(source)) {
    Log.d(App.TAG,""String_Node_Str"" + source);
    if (source.equalsIgnoreCase(UPDATESOURCE.WIDGET_REFRESH_BUTTON.key)) {
      Handler mHandler=new Handler(getMainLooper());
      mHandler.post(new Runnable(){
        @Override public void run(){
          Toast.makeText(getApplicationContext(),getString(R.string.sync_started),Toast.LENGTH_SHORT).show();
        }
      }
);
    }
  }
  appPreferences=new AppPreferences(this);
  if (!appPreferences.IsTokenPresent()) {
    Log.d(App.TAG,""String_Node_Str"");
    SendUpdateBroadcast();
    return;
  }
 else {
    if (!Connection.isConnected(this))     return;
    RefreshTokenIfRequired();
    if (source != null) {
      if (source.equalsIgnoreCase(UPDATESOURCE.ALARM.key) || source.equalsIgnoreCase(UPDATESOURCE.NETWORK_CHANGE.key)) {
        if (!CheckLastSync()) {
          Log.d(App.TAG,""String_Node_Str"");
          return;
        }
      }
    }
    if (!GetUnreadCountsAndSave())     return;
    appPreferences.SaveSuccessfulSync();
    SendUpdateBroadcast();
    if (appPreferences.GetBoolPreferences(Keys.ENABLE_NOTIFICATIONS)) {
      PrepareAndSendNotifications();
    }
  }
}","@Override protected void doWakefulWork(Intent intent){
  Log.d(App.TAG,""String_Node_Str"");
  String source=intent.getStringExtra(Consts.UPDATE_SOURCE);
  if (!TextUtils.isEmpty(source)) {
    Log.d(App.TAG,""String_Node_Str"" + source);
    if (source.equalsIgnoreCase(UPDATESOURCE.WIDGET_REFRESH_BUTTON.key)) {
      Handler mHandler=new Handler(getMainLooper());
      mHandler.post(new Runnable(){
        @Override public void run(){
          Toast.makeText(getApplicationContext(),getString(R.string.sync_started),Toast.LENGTH_SHORT).show();
        }
      }
);
    }
  }
  appPreferences=new AppPreferences(this);
  if (!appPreferences.IsTokenPresent()) {
    Log.d(App.TAG,""String_Node_Str"");
    SendUpdateBroadcast();
    return;
  }
 else {
    if (!Connection.isConnected(this))     return;
    RefreshTokenIfRequired();
    if (source != null) {
      if (source.equalsIgnoreCase(UPDATESOURCE.ALARM.key) || source.equalsIgnoreCase(UPDATESOURCE.NETWORK_CHANGE.key)) {
        if (!CheckLastSync()) {
          Log.d(App.TAG,""String_Node_Str"");
          return;
        }
      }
    }
    if (!GetUnreadCountsAndSave())     return;
    appPreferences.SaveSuccessfulSync();
    SendUpdateBroadcast();
    if (appPreferences.GetBoolPreferences(Keys.ENABLE_NOTIFICATIONS)) {
      PrepareAndSendNotifications();
    }
  }
}",0.9863013698630136
38023,"@Override public void onDestroy(){
  Log.v(App.TAG,""String_Node_Str"");
}","@Override public void onDestroy(){
}",0.6666666666666666
38024,"@Override public void onDataSetChanged(){
  Log.v(App.TAG,""String_Node_Str"");
  PullData();
}","@Override public void onDataSetChanged(){
  PullData();
}",0.76
38025,"@TargetApi(Build.VERSION_CODES.JELLY_BEAN) private void SetupLookAndFeel(Context context,RemoteViews remoteViews,AppPreferences appPreferences){
  remoteViews.setInt(R.id.widget_host,""String_Node_Str"",appPreferences.GetColor(Keys.WIDGET_BACKGROUND_COLOR));
  if (appPreferences.GetTheme() == 0) {
    remoteViews.setImageViewResource(R.id.widget_icon,R.drawable.ic_notification);
    remoteViews.setImageViewResource(R.id.widget_refresh,R.drawable.ic_action_refresh);
    remoteViews.setImageViewResource(R.id.widget_settings,R.drawable.ic_action_settings);
  }
 else   if (appPreferences.GetTheme() == 1) {
    remoteViews.setImageViewResource(R.id.widget_icon,R.drawable.ic_notification_light);
    remoteViews.setImageViewResource(R.id.widget_refresh,R.drawable.ic_action_refresh_light);
    remoteViews.setImageViewResource(R.id.widget_settings,R.drawable.ic_action_settings_light);
  }
  if (appPreferences.IsWidgetHeaderEnabled()) {
    remoteViews.setViewVisibility(R.id.widget_icon,View.VISIBLE);
    remoteViews.setViewVisibility(R.id.updatedTextView,View.VISIBLE);
    remoteViews.setViewVisibility(R.id.widget_refresh,View.VISIBLE);
    remoteViews.setViewVisibility(R.id.widget_settings,View.VISIBLE);
    remoteViews.setOnClickPendingIntent(R.id.widget_icon,GetPendingIntent(context.getPackageManager().getLaunchIntentForPackage(context.getPackageName()),context));
    remoteViews.setOnClickPendingIntent(R.id.widget_refresh,new Alarms(context).GetPendingIntent(context,UPDATESOURCE.WIDGET_REFRESH_BUTTON));
    remoteViews.setOnClickPendingIntent(R.id.widget_settings,GetSettingsPendingIntent(context));
  }
 else {
    remoteViews.setViewVisibility(R.id.widget_icon,View.GONE);
    remoteViews.setViewVisibility(R.id.updatedTextView,View.GONE);
    remoteViews.setViewVisibility(R.id.widget_refresh,View.GONE);
    remoteViews.setViewVisibility(R.id.widget_settings,View.GONE);
  }
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
    remoteViews.setTextViewTextSize(R.id.updatedTextView,TypedValue.COMPLEX_UNIT_SP,appPreferences.GetFontSize());
  }
 else {
    remoteViews.setFloat(R.id.updatedTextView,""String_Node_Str"",appPreferences.GetFontSize());
  }
  remoteViews.setTextColor(R.id.updatedTextView,appPreferences.GetColor(Keys.WIDGET_TITLE_COLOR));
}","@TargetApi(Build.VERSION_CODES.JELLY_BEAN) private void SetupLookAndFeel(Context context,RemoteViews remoteViews,AppPreferences appPreferences){
  remoteViews.setInt(R.id.widget_host,""String_Node_Str"",appPreferences.GetColor(Keys.WIDGET_BACKGROUND_COLOR));
  if (appPreferences.GetTheme() == 0) {
    remoteViews.setImageViewResource(R.id.widget_icon,R.drawable.ic_notification);
    remoteViews.setImageViewResource(R.id.widget_refresh,R.drawable.ic_action_refresh);
    remoteViews.setImageViewResource(R.id.widget_settings,R.drawable.ic_action_settings);
  }
 else   if (appPreferences.GetTheme() == 1) {
    remoteViews.setImageViewResource(R.id.widget_icon,R.drawable.ic_notification_light);
    remoteViews.setImageViewResource(R.id.widget_refresh,R.drawable.ic_action_refresh_light);
    remoteViews.setImageViewResource(R.id.widget_settings,R.drawable.ic_action_settings_light);
  }
  if (appPreferences.IsWidgetHeaderEnabled()) {
    remoteViews.setViewVisibility(R.id.widget_icon,View.VISIBLE);
    remoteViews.setViewVisibility(R.id.updatedTextView,View.VISIBLE);
    remoteViews.setViewVisibility(R.id.widget_refresh,View.VISIBLE);
    remoteViews.setViewVisibility(R.id.widget_settings,View.VISIBLE);
    remoteViews.setOnClickPendingIntent(R.id.widget_icon,GetPendingIntent(context.getPackageManager().getLaunchIntentForPackage(context.getPackageName()),context));
    remoteViews.setOnClickPendingIntent(R.id.widget_refresh,new Alarms(context).GetPendingIntentWidget(context));
    remoteViews.setOnClickPendingIntent(R.id.widget_settings,GetSettingsPendingIntent(context));
  }
 else {
    remoteViews.setViewVisibility(R.id.widget_icon,View.GONE);
    remoteViews.setViewVisibility(R.id.updatedTextView,View.GONE);
    remoteViews.setViewVisibility(R.id.widget_refresh,View.GONE);
    remoteViews.setViewVisibility(R.id.widget_settings,View.GONE);
  }
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
    remoteViews.setTextViewTextSize(R.id.updatedTextView,TypedValue.COMPLEX_UNIT_SP,appPreferences.GetFontSize());
  }
 else {
    remoteViews.setFloat(R.id.updatedTextView,""String_Node_Str"",appPreferences.GetFontSize());
  }
  remoteViews.setTextColor(R.id.updatedTextView,appPreferences.GetColor(Keys.WIDGET_TITLE_COLOR));
}",0.9909870301165092
38026,"public PendingIntent GetPendingIntent(Context context,UPDATESOURCE source){
  Intent updateIntent=new Intent();
  updateIntent.setAction(Consts.UPDATE_COUNT_ACTION);
  updateIntent.putExtra(Consts.UPDATE_SOURCE,source.key);
  return PendingIntent.getBroadcast(context,REQUEST_CODE,updateIntent,PendingIntent.FLAG_UPDATE_CURRENT);
}","public PendingIntent GetPendingIntent(Context context,UPDATESOURCE source){
  return PendingIntent.getBroadcast(context,REQUEST_CODE,GetAlarmIntent(source),PendingIntent.FLAG_UPDATE_CURRENT);
}",0.6793893129770993
38027,"public void Schedule(){
  AlarmManager alarmManager=GetAlarmManager(context);
  int prefInterval=appPreferences.GetSyncInterval();
  long recurInterval=prefInterval * 60 * 60* 1000;
  alarmManager.setInexactRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP,0,recurInterval,GetPendingIntent(context,UPDATESOURCE.ALARM));
}","public void Schedule(){
  AlarmManager alarmManager=GetAlarmManager(context);
  long recurInterval=LOWEST_RECUR_INTERVAL * 60 * 60* 1000;
  alarmManager.setInexactRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP,0,recurInterval,GetPendingIntent(context,UPDATESOURCE.ALARM));
}",0.8209459459459459
38028,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setHasOptionsMenu(true);
  Bundle data=getArguments();
  if (data != null) {
    forceRefresh=data.getBoolean(""String_Node_Str"");
  }
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setHasOptionsMenu(true);
  Bundle data=getArguments();
  if (data != null) {
    forceRefresh=data.getBoolean(""String_Node_Str"");
  }
  Alarms alarms=new Alarms(getActivity());
  if (!alarms.DoesAlarmExist()) {
    if (alarms.ShouldSchedule())     alarms.Schedule();
  }
}",0.7735537190082644
38029,"public static Intent getIntentValue(String value,Intent defaultIntent){
  try {
    if (TextUtils.isEmpty(value)) {
      return defaultIntent;
    }
    Log.v(App.TAG,value);
    Log.v(App.TAG,Intent.parseUri(value,Intent.URI_INTENT_SCHEME).toString());
    return Intent.parseUri(value,Intent.URI_INTENT_SCHEME);
  }
 catch (  URISyntaxException e) {
    Log.e(App.TAG,""String_Node_Str"");
    return defaultIntent;
  }
}","public static Intent getIntentValue(String value,Intent defaultIntent){
  try {
    if (TextUtils.isEmpty(value)) {
      return defaultIntent;
    }
    return Intent.parseUri(value,Intent.URI_INTENT_SCHEME);
  }
 catch (  URISyntaxException e) {
    Log.e(App.TAG,""String_Node_Str"");
    return defaultIntent;
  }
}",0.857916102841678
38030,"@Override public int onStartCommand(Intent intent,int flags,int startId){
  super.onStartCommand(intent,flags,startId);
  Intent launchIntent;
  launchIntent=new AppPreferences(this).GetWidgetIntent();
  if (launchIntent != null) {
    Log.v(App.TAG,launchIntent.getAction());
    launchIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    try {
      startActivity(launchIntent);
    }
 catch (    Exception e) {
      Log.e(App.TAG,e.getMessage());
      Crittercism.logHandledException(e);
    }
  }
  stopSelf();
  return START_NOT_STICKY;
}","@Override public int onStartCommand(Intent intent,int flags,int startId){
  super.onStartCommand(intent,flags,startId);
  Intent launchIntent;
  launchIntent=new AppPreferences(this).GetNotificationIntent();
  if (launchIntent != null) {
    Log.v(App.TAG,launchIntent.getAction());
    launchIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    try {
      startActivity(launchIntent);
    }
 catch (    Exception e) {
      Log.e(App.TAG,e.getMessage());
      Crittercism.logHandledException(e);
    }
  }
  stopSelf();
  return START_NOT_STICKY;
}",0.9835466179159048
38031,"private void PullData(){
  data=new StringFormatter(context).GetResultData(context);
  if (data != null)   widgetData=data.getWidgetData();
 else   widgetData=new ArrayList<WidgetData>();
  if (widgetConfig.getSortOrder() == 0)   Collections.sort(widgetData,new CountSorter());
 else   if (widgetConfig.getSortOrder() == 1)   Collections.sort(widgetData,new NameSorter());
  widgetConfig.RefreshData(new AppPreferences(context));
}","private void PullData(){
  ResultData data=new StringFormatter(context).GetResultData(context);
  if (data != null)   widgetData=data.getWidgetData();
 else   widgetData=new ArrayList<WidgetData>();
  widgetConfig.RefreshData(new AppPreferences(context));
  if (widgetConfig.getSortOrder() == 0)   Collections.sort(widgetData,Collections.reverseOrder(new CountSorter()));
 else   if (widgetConfig.getSortOrder() == 1)   Collections.sort(widgetData,new NameSorter());
}",0.5472747497219133
38032,"public static Feedly getInstance(String token){
  if (feedly == null) {
    RestAdapter restAdapter=new RestAdapter.Builder().setEndpoint(Consts.FEEDLY_API_URL).build();
    feedlyApi=restAdapter.create(FeedlyApi.class);
    feedly=new Feedly();
    Feedly.token=token;
    return feedly;
  }
 else   return feedly;
}","public static Feedly getInstance(String token){
  if (feedly == null || Feedly.token == null || !Feedly.token.equalsIgnoreCase(token)) {
    RestAdapter restAdapter=new RestAdapter.Builder().setEndpoint(Consts.FEEDLY_API_URL).build();
    feedlyApi=restAdapter.create(FeedlyApi.class);
    feedly=new Feedly();
    Feedly.token=token;
    return feedly;
  }
 else   return feedly;
}",0.9070100143061516
38033,"@Override public void Login(){
  getSupportFragmentManager().beginTransaction().replace(android.R.id.content,new MainFragment()).commit();
}","@Override public void Login(){
  MainFragment mainFragment=new MainFragment();
  Bundle data=new Bundle();
  data.putBoolean(""String_Node_Str"",true);
  mainFragment.setArguments(data);
  getSupportFragmentManager().beginTransaction().replace(android.R.id.content,mainFragment).commit();
}",0.5560747663551402
38034,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setHasOptionsMenu(true);
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  Log.v(App.TAG,""String_Node_Str"");
  setHasOptionsMenu(true);
  Bundle data=getArguments();
  if (data != null) {
    forceRefresh=data.getBoolean(""String_Node_Str"");
  }
}",0.6329113924050633
38035,"private void GetFeedlyData(){
  GetFeedlyData(false);
}","private void GetFeedlyData(boolean forceRefresh){
  String token=appPreferences.GetToken();
  Feedly feedly=Feedly.getInstance(token);
  new GetFeedlyDataTask(feedly,forceRefresh).execute(0);
}",0.4354838709677419
38036,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.activity_main,container,false);
  progressBar=(ProgressBar)v.findViewById(R.id.pbHeaderProgress);
  listView=(ExpandableListView)v.findViewById(R.id.listview);
  statusText=(TextView)v.findViewById(R.id.statusMessage);
  listView.setOnGroupClickListener(new OnGroupClickListener(){
    @Override public boolean onGroupClick(    ExpandableListView parent,    View clickedView,    int groupPosition,    long rowId){
      ImageView groupIndicator=(ImageView)clickedView.findViewById(R.id.group_indicator);
      if (parent.isGroupExpanded(groupPosition)) {
        parent.collapseGroup(groupPosition);
        groupIndicator.setImageResource(R.drawable.expander_open_holo_dark);
      }
 else {
        parent.expandGroup(groupPosition);
        groupIndicator.setImageResource(R.drawable.expander_close_holo_dark);
      }
      return true;
    }
  }
);
  appPreferences=new AppPreferences(getActivity());
  if (!appPreferences.IsTokenPresent()) {
    StartLoginProcedure();
  }
 else {
    WebApiHelper.register(getActivity());
    apiHelper=WebApiHelper.getInstance();
    if (apiHelper.shouldRefreshAccesToken()) {
      apiHelper.refreshAccessTokenIfNeeded();
    }
    GetFeedlyData();
  }
  return v;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  Log.v(App.TAG,""String_Node_Str"");
  View v=inflater.inflate(R.layout.activity_main,container,false);
  progressBar=(ProgressBar)v.findViewById(R.id.pbHeaderProgress);
  listView=(ExpandableListView)v.findViewById(R.id.listview);
  statusText=(TextView)v.findViewById(R.id.statusMessage);
  listView.setOnGroupClickListener(new OnGroupClickListener(){
    @Override public boolean onGroupClick(    ExpandableListView parent,    View clickedView,    int groupPosition,    long rowId){
      ImageView groupIndicator=(ImageView)clickedView.findViewById(R.id.group_indicator);
      if (parent.isGroupExpanded(groupPosition)) {
        parent.collapseGroup(groupPosition);
        groupIndicator.setImageResource(R.drawable.expander_open_holo_dark);
      }
 else {
        parent.expandGroup(groupPosition);
        groupIndicator.setImageResource(R.drawable.expander_close_holo_dark);
      }
      return true;
    }
  }
);
  appPreferences=new AppPreferences(getActivity());
  if (!appPreferences.IsTokenPresent()) {
    StartLoginProcedure();
  }
 else {
    WebApiHelper.register(getActivity());
    apiHelper=WebApiHelper.getInstance();
    if (apiHelper.shouldRefreshAccesToken()) {
      apiHelper.refreshAccessTokenIfNeeded();
    }
    GetFeedlyData(forceRefresh);
  }
  return v;
}",0.982532751091703
38037,"/** 
 * Creates Grid resources
 */
protected void createMETAGridResources(double bandwidth,double cost,String data_set){
  LinkedList<String> lines=new LinkedList();
  Input r=new Input();
  BufferedReader br=null;
  br=r.openFile(new File(ExperimentSetup.data_sets + ""String_Node_Str"" + data_set+ ""String_Node_Str""));
  r.getLines(lines,br);
  r.closeFile(br);
  LinkedList<String> cpu_types=new LinkedList();
  LinkedList<Double> cpu_bench=new LinkedList();
  LinkedList<Double> cpu_speed=new LinkedList();
  cpu_types.add(""String_Node_Str"");
  cpu_types.add(""String_Node_Str"");
  cpu_types.add(""String_Node_Str"");
  cpu_types.add(""String_Node_Str"");
  cpu_types.add(""String_Node_Str"");
  cpu_types.add(""String_Node_Str"");
  cpu_types.add(""String_Node_Str"");
  cpu_types.add(""String_Node_Str"");
  cpu_bench.add((1.0));
  cpu_bench.add((1.771666667));
  cpu_bench.add((2.88));
  cpu_bench.add((3.643333333));
  cpu_bench.add((4.743333333));
  cpu_bench.add((6.844));
  cpu_bench.add((1.79));
  cpu_bench.add((1.0));
  cpu_speed.add(1000.0);
  cpu_speed.add(1800.0);
  cpu_speed.add(2400.0);
  cpu_speed.add(3060.0);
  cpu_speed.add(2200.0);
  cpu_speed.add(1500.0);
  cpu_speed.add(1000.0);
  cpu_speed.add(1000.0);
  String[] last_machine=null;
  int machine_id=0;
  MachineList mList=new MachineList();
  String name=""String_Node_Str"";
  int name_id=0;
  String cpu_ids=""String_Node_Str"";
  LinkedList<String> names=new LinkedList();
  for (int j=0; j < lines.size(); j++) {
    String[] values=((String)lines.get(j)).split(""String_Node_Str"");
    name=values[1];
    int MachCount=Integer.parseInt(values[7]);
    String PEs[]=values[9].split(""String_Node_Str"");
    String PEids[]=values[10].split(""String_Node_Str"");
    for (int id=0; id < PEids.length; id++) {
      if (Integer.parseInt(PEids[id]) > total_CPUs) {
        total_CPUs=Integer.parseInt(PEids[id]);
      }
    }
    for (int ma=0; ma < MachCount; ma++) {
      int totalPE=Integer.parseInt(PEs[ma]);
      PEList peList=new PEList();
      Double rel_speed=1.0 + ((Double.parseDouble(values[2]) - cpu_speed.get(cpu_types.indexOf(values[4]))) / cpu_speed.get(cpu_types.indexOf(values[4])));
      String pokus=Long.toString(Math.round(rel_speed * 100000 * cpu_bench.get(cpu_types.indexOf(values[4]))));
      int peRating=Integer.parseInt(pokus);
      if (!ExperimentSetup.use_speeds) {
        peRating=1;
      }
      if (peRating > ExperimentSetup.maxPErating) {
        ExperimentSetup.maxPErating=peRating;
      }
      for (int k=0; k < totalPE; k++) {
        peList.add(new PE(k,peRating));
      }
      mList.add(new Machine(machine_id,peList));
      machine_id++;
    }
    names.addLast(values[1]);
    last_machine=((String)lines.get(j)).split(""String_Node_Str"");
    String arch=last_machine[4];
    String os=last_machine[5];
    double time_zone=0.0;
    int ram=0;
    if (last_machine[3].equals(""String_Node_Str"")) {
      ram=1000000;
    }
 else {
      ram=Integer.parseInt(last_machine[3]);
    }
    String properties=last_machine[6];
    ExperimentSetup.clusterNames.addLast(name);
    LinkedList mach_names=new LinkedList(names);
    ExperimentSetup.machineNames.addLast(mach_names);
    names.clear();
    ComplexResourceCharacteristics resConfig=new ComplexResourceCharacteristics(arch,os,mList,ResourceCharacteristics.SPACE_SHARED,time_zone,cost,ram,properties,cpu_ids);
    long seed=11L * 13 * 17* 19* 23 + 1;
    double peakLoad=0.0;
    double offPeakLoad=0.0;
    double holidayLoad=0.0;
    LinkedList Weekends=new LinkedList();
    Weekends.add(new Integer(Calendar.SATURDAY));
    Weekends.add(new Integer(Calendar.SUNDAY));
    LinkedList Holidays=new LinkedList();
    AllocPolicy apolicy=null;
    try {
      if (ExperimentSetup.use_RAM) {
        AdvancedSpaceSharedWithRAM policy=null;
        policy=new AdvancedSpaceSharedWithRAM(name,""String_Node_Str"",resConfig);
        ExperimentSetup.local_schedulers.add(policy);
        apolicy=policy;
      }
 else {
        AdvancedSpaceShared policy=null;
        policy=new AdvancedSpaceShared(name,""String_Node_Str"",resConfig);
        ExperimentSetup.local_schedulers.add(policy);
        apolicy=policy;
      }
    }
 catch (    Exception ex) {
      ex.printStackTrace();
    }
    try {
      ResourceCalendar resCalendar=new ResourceCalendar(time_zone,peakLoad,offPeakLoad,holidayLoad,Weekends,Holidays,seed);
      ComplexGridResource gridRes=new ComplexGridResource(name,bandwidth,resConfig,resCalendar,apolicy);
      int max=gridRes.getResourceCharacteristics().getNumPE();
      if (max > ExperimentSetup.maxPE) {
        ExperimentSetup.maxPE=max;
      }
    }
 catch (    Exception e) {
      System.out.println(""String_Node_Str"");
      System.out.println(e.getMessage());
    }
    machine_id=0;
    mList=new MachineList();
    cpu_ids=""String_Node_Str"";
    name=""String_Node_Str"";
  }
}","/** 
 * Creates Grid resources
 */
protected void createMETAGridResources(double bandwidth,double cost,String data_set){
  LinkedList<String> lines=new LinkedList();
  Input r=new Input();
  BufferedReader br=null;
  br=r.openFile(new File(ExperimentSetup.data_sets + ""String_Node_Str"" + data_set+ ""String_Node_Str""));
  r.getLines(lines,br);
  r.closeFile(br);
  LinkedList<String> cpu_types=new LinkedList();
  LinkedList<Double> cpu_bench=new LinkedList();
  LinkedList<Double> cpu_speed=new LinkedList();
  cpu_types.add(""String_Node_Str"");
  cpu_types.add(""String_Node_Str"");
  cpu_types.add(""String_Node_Str"");
  cpu_types.add(""String_Node_Str"");
  cpu_types.add(""String_Node_Str"");
  cpu_types.add(""String_Node_Str"");
  cpu_types.add(""String_Node_Str"");
  cpu_types.add(""String_Node_Str"");
  cpu_bench.add((1.0));
  cpu_bench.add((1.771666667));
  cpu_bench.add((2.88));
  cpu_bench.add((3.643333333));
  cpu_bench.add((4.743333333));
  cpu_bench.add((6.844));
  cpu_bench.add((1.79));
  cpu_bench.add((1.0));
  cpu_speed.add(1000.0);
  cpu_speed.add(1800.0);
  cpu_speed.add(2400.0);
  cpu_speed.add(3060.0);
  cpu_speed.add(2200.0);
  cpu_speed.add(1500.0);
  cpu_speed.add(1000.0);
  cpu_speed.add(1000.0);
  String[] last_machine=null;
  int machine_id=0;
  MachineList mList=new MachineList();
  String name=""String_Node_Str"";
  int name_id=0;
  String cpu_ids=""String_Node_Str"";
  LinkedList<String> names=new LinkedList();
  for (int j=0; j < lines.size(); j++) {
    String[] values=((String)lines.get(j)).split(""String_Node_Str"");
    name=values[1];
    int MachCount=Integer.parseInt(values[7]);
    String PEs[]=values[9].split(""String_Node_Str"");
    String PEids[]=values[10].split(""String_Node_Str"");
    for (int id=0; id < PEids.length; id++) {
      if (Integer.parseInt(PEids[id]) > total_CPUs) {
        total_CPUs=Integer.parseInt(PEids[id]);
      }
    }
    for (int ma=0; ma < MachCount; ma++) {
      int totalPE=Integer.parseInt(PEs[ma]);
      PEList peList=new PEList();
      Double rel_speed=1.0 + ((Double.parseDouble(values[2]) - cpu_speed.get(cpu_types.indexOf(values[4]))) / cpu_speed.get(cpu_types.indexOf(values[4])));
      String pokus=Long.toString(Math.round(rel_speed * 100000 * cpu_bench.get(cpu_types.indexOf(values[4]))));
      int peRating=Integer.parseInt(pokus);
      if (!ExperimentSetup.use_speeds) {
        peRating=1;
      }
      if (peRating > ExperimentSetup.maxPErating) {
        ExperimentSetup.maxPErating=peRating;
      }
      for (int k=0; k < totalPE; k++) {
        peList.add(new PE(k,peRating));
      }
      mList.add(new MachineWithRAM(machine_id,peList,1000));
      machine_id++;
    }
    names.addLast(values[1]);
    last_machine=((String)lines.get(j)).split(""String_Node_Str"");
    String arch=last_machine[4];
    String os=last_machine[5];
    double time_zone=0.0;
    int ram=0;
    if (last_machine[3].equals(""String_Node_Str"")) {
      ram=1000000;
    }
 else {
      ram=Integer.parseInt(last_machine[3]);
    }
    String properties=last_machine[6];
    ExperimentSetup.clusterNames.addLast(name);
    LinkedList mach_names=new LinkedList(names);
    ExperimentSetup.machineNames.addLast(mach_names);
    names.clear();
    ComplexResourceCharacteristics resConfig=new ComplexResourceCharacteristics(arch,os,mList,ResourceCharacteristics.SPACE_SHARED,time_zone,cost,ram,properties,cpu_ids);
    long seed=11L * 13 * 17* 19* 23 + 1;
    double peakLoad=0.0;
    double offPeakLoad=0.0;
    double holidayLoad=0.0;
    LinkedList Weekends=new LinkedList();
    Weekends.add(new Integer(Calendar.SATURDAY));
    Weekends.add(new Integer(Calendar.SUNDAY));
    LinkedList Holidays=new LinkedList();
    AllocPolicy apolicy=null;
    try {
      if (ExperimentSetup.use_RAM) {
        AdvancedSpaceSharedWithRAM policy=null;
        policy=new AdvancedSpaceSharedWithRAM(name,""String_Node_Str"",resConfig);
        ExperimentSetup.local_schedulers.add(policy);
        apolicy=policy;
      }
 else {
        AdvancedSpaceShared policy=null;
        policy=new AdvancedSpaceShared(name,""String_Node_Str"",resConfig);
        ExperimentSetup.local_schedulers.add(policy);
        apolicy=policy;
      }
    }
 catch (    Exception ex) {
      ex.printStackTrace();
    }
    try {
      ResourceCalendar resCalendar=new ResourceCalendar(time_zone,peakLoad,offPeakLoad,holidayLoad,Weekends,Holidays,seed);
      ComplexGridResource gridRes=new ComplexGridResource(name,bandwidth,resConfig,resCalendar,apolicy);
      int max=gridRes.getResourceCharacteristics().getNumPE();
      if (max > ExperimentSetup.maxPE) {
        ExperimentSetup.maxPE=max;
      }
    }
 catch (    Exception e) {
      System.out.println(""String_Node_Str"");
      System.out.println(e.getMessage());
    }
    machine_id=0;
    mList=new MachineList();
    cpu_ids=""String_Node_Str"";
    name=""String_Node_Str"";
  }
}",0.998769735493131
38038,"/** 
 * Returns the number of working (non-failed) PEs on given resource.
 */
private int printRunningPEsOnResource(int resId){
  ResourceInfo ri=null;
  for (int i=0; i < resourceInfoList.size(); i++) {
    ri=(ResourceInfo)resourceInfoList.get(i);
    if (ri.resource.getResourceID() == resId) {
      break;
    }
  }
  return ri.getNumRunningPE();
}","/** 
 * Returns the number of working (non-failed) PEs on given resource.
 */
private int printRunningPEsOnResource(int resId){
  ResourceInfo ri=null;
  for (int i=0; i < resourceInfoList.size(); i++) {
    ri=(ResourceInfo)resourceInfoList.get(i);
    if (ri.resource.getResourceID() == resId) {
      break;
    }
  }
  ri.stable_free=false;
  return ri.getNumRunningPE();
}",0.9671232876712328
38039,"@Override boolean onJobEnqueued(ComplexGridlet event){
  dynamic_mgr.notifyJobSubmit(Integer.toString(event.getGridletID()),GridSim.clock());
  next_job=null;
  latest_submit=GridSim.clock();
  latest_runtime=event.getJobLimit();
  latest_CPUs=event.getNumPE();
  latest_gid=event.getGridletID();
  return true;
}","@Override boolean onJobEnqueued(ComplexGridlet event){
  dynamic_mgr.notifyJobSubmit(Integer.toString(event.getGridletID()),GridSim.clock());
  next_job=null;
  if (previous_job != null) {
    double actual_wait=GridSim.clock() - latest_submit;
    if (acceptable_wait >= actual_wait) {
      acceptable_wait-=actual_wait;
    }
 else {
      if (job_count > 0) {
        ExperimentSetup.result_collector.recordLongUserComplain(latest_gid,user_id,this.getEntityName(),GridSim.clock(),(actual_wait / acceptable_wait),job_count);
      }
      acceptable_wait=0;
    }
    if (job_count < 1) {
      acceptable_wait=0;
    }
  }
  job_count++;
  latest_submit=GridSim.clock();
  latest_runtime=event.getJobLimit();
  latest_CPUs=event.getNumPE();
  latest_gid=event.getGridletID();
  acceptable_wait+=((Math.log(latest_CPUs) + 1) * calculateAcceptableWaitingFromWalltime(latest_runtime));
  previous_job=event;
  return true;
}",0.505654281098546
38040,"@Override boolean onJobCompleted(ComplexGridlet event){
  dynamic_mgr.notifyJobCompletion(event,GridSim.clock());
  double feedback=Math.max(0,GridSim.clock() - latest_submit);
  double acceptable_wait=Math.max((think_time * latest_CPUs),latest_runtime * 2);
  if (feedback > acceptable_wait) {
    ExperimentSetup.result_collector.recordUserComplain(latest_gid,user_id,this.getEntityName(),GridSim.clock(),(feedback / acceptable_wait));
  }
  return true;
}","@Override boolean onJobCompleted(ComplexGridlet event){
  dynamic_mgr.notifyJobCompletion(event,GridSim.clock());
  return true;
}",0.4421768707482993
38041,"/** 
 * Creates a new instance of JobLoader
 */
public AgentDynamicWithSatisfactionModel(String name,String loader_name,double baudRate,String data_set,int maxPE,int minPErating,int maxPErating,int user_id) throws Exception {
  super(name,loader_name,baudRate);
  dynamic_mgr=new DynamicBatchMgr(name,data_set,maxPE,minPErating,maxPErating);
  this.user_id=user_id;
}","/** 
 * Creates a new instance of AgentDynamicWithSatisfactionModel
 */
public AgentDynamicWithSatisfactionModel(String name,String loader_name,double baudRate,String data_set,int maxPE,int minPErating,int maxPErating,int user_id) throws Exception {
  super(name,loader_name,baudRate);
  dynamic_mgr=new DynamicBatchMgr(name,data_set,maxPE,minPErating,maxPErating);
  this.user_id=user_id;
}",0.9445910290237468
38042,"@Override boolean onJobStarted(ComplexGridlet event){
  dynamic_mgr.notifyJobStart(event,GridSim.clock());
  return false;
}","@Override boolean onJobStarted(ComplexGridlet event){
  dynamic_mgr.notifyJobStart(event,GridSim.clock());
  job_count--;
  double actual_wait=GridSim.clock() - latest_submit;
  if (acceptable_wait >= actual_wait) {
  }
 else {
    ExperimentSetup.result_collector.recordLongUserComplain(latest_gid,user_id,this.getEntityName(),GridSim.clock(),(actual_wait / acceptable_wait),job_count);
  }
  return false;
}",0.424015009380863
38043,"/** 
 * Creates a new instance of Dynamic Job Loader
 * @param name Name of this grid sim object.
 * @param baudRate ....
 * @param total_jobs IGNORED
 * @param data_set Name of base configuration file.
 * @param maxPE ...
 * @param minPErating ...
 * @param maxPErating ...
 */
public DynamicLoader(String name,double baudRate,int total_jobs,String data_set,int maxPE,int minPErating,int maxPErating) throws Exception {
  super(name,baudRate);
  System.out.println(name + ""String_Node_Str"" + data_set+ ""String_Node_Str"");
  Input r=new Input();
  BufferedReader br=r.openFile(new File(get_dataset_filename(data_set)));
  String line;
  int user_id=0;
  while ((line=br.readLine()) != null) {
    String values[]=line.split(""String_Node_Str"");
    String agent_name=values[0];
    if (values[1].equalsIgnoreCase(""String_Node_Str"")) {
      agents.add(new AgentStatic(agent_name,this.getEntityName(),baudRate,data_set,maxPE,minPErating,maxPErating));
      agent_names.add(agent_name);
      agents_total++;
    }
 else     if (values[1].equalsIgnoreCase(""String_Node_Str"") && !ExperimentSetup.complain) {
      agents.add(new AgentDynamic(agent_name,this.getEntityName(),baudRate,data_set,maxPE,minPErating,maxPErating));
      agent_names.add(agent_name);
      agents_total++;
    }
 else     if (values[1].equalsIgnoreCase(""String_Node_Str"") && ExperimentSetup.complain) {
      user_id++;
      agents.add(new AgentDynamicWithComplexSatisfactionModel(agent_name,this.getEntityName(),baudRate,data_set,maxPE,minPErating,maxPErating,user_id));
      agent_names.add(agent_name);
      agents_total++;
    }
  }
  this.total_jobs=total_jobs;
  this.maxPE=maxPE;
  this.minPErating=minPErating;
  this.maxPErating=maxPErating;
  this.data_set=data_set;
  this.norm=new Sim_normal_obj(""String_Node_Str"",0.0,5.0,(121 + ExperimentSetup.rnd_seed));
}","/** 
 * Creates a new instance of Dynamic Job Loader
 * @param name Name of this grid sim object.
 * @param baudRate ....
 * @param total_jobs IGNORED
 * @param data_set Name of base configuration file.
 * @param maxPE ...
 * @param minPErating ...
 * @param maxPErating ...
 */
public DynamicLoader(String name,double baudRate,int total_jobs,String data_set,int maxPE,int minPErating,int maxPErating) throws Exception {
  super(name,baudRate);
  System.out.println(name + ""String_Node_Str"" + data_set+ ""String_Node_Str"");
  Input r=new Input();
  BufferedReader br=r.openFile(new File(get_dataset_filename(data_set)));
  String line;
  int user_id=0;
  while ((line=br.readLine()) != null) {
    String values[]=line.split(""String_Node_Str"");
    String agent_name=values[0];
    if (values[1].equalsIgnoreCase(""String_Node_Str"")) {
      agents.add(new AgentStatic(agent_name,this.getEntityName(),baudRate,data_set,maxPE,minPErating,maxPErating));
      agent_names.add(agent_name);
      agents_total++;
    }
 else     if (values[1].equalsIgnoreCase(""String_Node_Str"") && !ExperimentSetup.complain) {
      agents.add(new AgentDynamic(agent_name,this.getEntityName(),baudRate,data_set,maxPE,minPErating,maxPErating));
      agent_names.add(agent_name);
      agents_total++;
    }
 else     if (values[1].equalsIgnoreCase(""String_Node_Str"") && ExperimentSetup.complain) {
      user_id++;
      agents.add(new AgentDynamicWithSatisfactionModel(agent_name,this.getEntityName(),baudRate,data_set,maxPE,minPErating,maxPErating,user_id));
      agent_names.add(agent_name);
      agents_total++;
    }
  }
  this.total_jobs=total_jobs;
  this.maxPE=maxPE;
  this.minPErating=minPErating;
  this.maxPErating=maxPErating;
  this.data_set=data_set;
  this.norm=new Sim_normal_obj(""String_Node_Str"",0.0,5.0,(121 + ExperimentSetup.rnd_seed));
}",0.998100407055631
38044,"/** 
 * Oversee the execution of spawned agents Once all agents are finished processing, signal end of simulation.
 */
public void body(){
  super.gridSimHold(10.0);
  for (int i=0; i < agents.size(); i++) {
    super.sim_schedule(GridSim.getEntityId(agents.get(i).getEntityName()),60,AleaSimTags.EVENT_WAKE);
  }
  while (agents_finished != agents_total) {
    Sim_event ev=new Sim_event();
    sim_get_next(ev);
    if (ev.get_tag() == AleaSimTags.AGENT_DONE) {
      Integer total_jobs=(Integer)ev.get_data();
      jobs_finished+=total_jobs;
      agents_finished++;
      System.out.println(""String_Node_Str"" + GridSim.getEntityName(ev.get_src()) + ""String_Node_Str""+ total_jobs+ ""String_Node_Str"");
      agent_names.remove(GridSim.getEntityName(ev.get_src()));
      for (      String i : agent_names) {
        System.out.printf(""String_Node_Str"",i);
      }
      System.out.printf(""String_Node_Str"");
    }
 else     if (ev.get_tag() == AleaSimTags.AGENT_ONJOBSTART) {
    }
 else     if (ev.get_tag() == AleaSimTags.AGENT_ONJOBCOMPL) {
    }
 else     if (ev.get_tag() == AleaSimTags.AGENT_ONJOBFAIL) {
    }
  }
  super.sim_schedule(this.getEntityId(""String_Node_Str""),super.clock(),AleaSimTags.SUBMISSION_DONE,new Integer(jobs_finished));
  while (true) {
    Sim_event ev_local=new Sim_event();
    sim_get_next(ev_local);
    if (ev_local.get_tag() == GridSimTags.END_OF_SIMULATION) {
      System.out.println(""String_Node_Str"" + data_set + ""String_Node_Str""+ fail+ ""String_Node_Str"");
      shutdownUserEntity();
      break;
    }
  }
  super.terminateIOEntities();
}","/** 
 * Oversee the execution of spawned agents Once all agents are finished processing, signal end of simulation.
 */
public void body(){
  Calendar myCal=Calendar.getInstance();
  myCal.setTimeInMillis(ExperimentSetup.firstArrival * 1000L);
  if (!(myCal.get(Calendar.HOUR_OF_DAY) == 0 && myCal.get(Calendar.MINUTE) == 0 && myCal.get(Calendar.SECOND) == 0 && myCal.get(Calendar.MILLISECOND) == 0)) {
    throw new RuntimeException(""String_Node_Str"" + Integer.toString(myCal.get(Calendar.HOUR_OF_DAY)) + ""String_Node_Str""+ Integer.toString(myCal.get(Calendar.MINUTE))+ ""String_Node_Str""+ Integer.toString(myCal.get(Calendar.SECOND))+ ""String_Node_Str""+ ""String_Node_Str"");
  }
  super.gridSimHold(10.0);
  for (int i=0; i < agents.size(); i++) {
    super.sim_schedule(GridSim.getEntityId(agents.get(i).getEntityName()),60,AleaSimTags.EVENT_WAKE);
  }
  while (agents_finished != agents_total) {
    Sim_event ev=new Sim_event();
    sim_get_next(ev);
    if (ev.get_tag() == AleaSimTags.AGENT_DONE) {
      Integer total_jobs=(Integer)ev.get_data();
      jobs_finished+=total_jobs;
      agents_finished++;
      System.out.println(""String_Node_Str"" + GridSim.getEntityName(ev.get_src()) + ""String_Node_Str""+ total_jobs+ ""String_Node_Str"");
      agent_names.remove(GridSim.getEntityName(ev.get_src()));
      for (      String i : agent_names) {
        System.out.printf(""String_Node_Str"",i);
      }
      System.out.printf(""String_Node_Str"");
    }
 else     if (ev.get_tag() == AleaSimTags.AGENT_ONJOBSTART) {
    }
 else     if (ev.get_tag() == AleaSimTags.AGENT_ONJOBCOMPL) {
    }
 else     if (ev.get_tag() == AleaSimTags.AGENT_ONJOBFAIL) {
    }
  }
  System.out.println(""String_Node_Str"" + data_set + ""String_Node_Str"");
  super.sim_schedule(this.getEntityId(""String_Node_Str""),0.0,AleaSimTags.SUBMISSION_DONE,new Integer(jobs_finished));
  while (true) {
    Sim_event ev_local=new Sim_event();
    sim_get_next(ev_local);
    if (ev_local.get_tag() == GridSimTags.END_OF_SIMULATION) {
      System.out.println(""String_Node_Str"" + data_set + ""String_Node_Str""+ fail+ ""String_Node_Str"");
      shutdownUserEntity();
      break;
    }
  }
  super.terminateIOEntities();
}",0.8336428760944548
38045,"/** 
 * The main method - create all entities and start the simulation. <br> It is also capable of multiple starts of the simulation with different setup (machine count, job parameters, data sets).
 */
public static void main(String[] args){
  String user_dir=System.getProperty(""String_Node_Str"");
  File activatedFile=new File(""String_Node_Str"");
  if (!activatedFile.exists()) {
    System.out.println(""String_Node_Str"");
    try {
      URL aleaHomePage=new URL(""String_Node_Str"");
      HttpURLConnection conn=(HttpURLConnection)aleaHomePage.openConnection();
      InputStream is=conn.getInputStream();
      java.util.Scanner s=new java.util.Scanner(is).useDelimiter(""String_Node_Str"");
      String str=s.hasNext() ? s.next() : ""String_Node_Str"";
      System.out.println(""String_Node_Str"" + str);
      if (!str.contains(""String_Node_Str"")) {
        throw new Exception(""String_Node_Str"");
      }
      activatedFile.mkdir();
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
 else {
    System.out.println(""String_Node_Str"");
  }
  try {
    aCfg=new AleaConfiguration();
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + e);
    return;
  }
  baudRate=aCfg.getDouble(""String_Node_Str"");
  entities=aCfg.getInt(""String_Node_Str"");
  maxPE=1;
  visualize=aCfg.getBoolean(""String_Node_Str"");
  data=aCfg.getBoolean(""String_Node_Str"");
  use_heap=aCfg.getBoolean(""String_Node_Str"");
  sld_tresh=aCfg.getDouble(""String_Node_Str"");
  algID=0;
  prevAlgID=-1;
  name=""String_Node_Str"";
  use_tsafrir=aCfg.getBoolean(""String_Node_Str"");
  use_speeds=aCfg.getBoolean(""String_Node_Str"");
  arrival_rate_multiplier=aCfg.getDouble(""String_Node_Str"");
  runtime_minimizer=aCfg.getDouble(""String_Node_Str"");
  use_RAM=aCfg.getBoolean(""String_Node_Str"");
  use_fairshare_WAIT=aCfg.getBoolean(""String_Node_Str"");
  use_fairshare_RAM=aCfg.getBoolean(""String_Node_Str"");
  use_fairshare=aCfg.getBoolean(""String_Node_Str"");
  multiply_sums=aCfg.getBoolean(""String_Node_Str"");
  use_MAX=aCfg.getBoolean(""String_Node_Str"");
  use_SQRT=aCfg.getBoolean(""String_Node_Str"");
  sum_multiplications=aCfg.getBoolean(""String_Node_Str"");
  useEventOpt=aCfg.getBoolean(""String_Node_Str"");
  avail_RAM=0.0;
  avail_CPUs=0.0;
  backfilled=0;
  use_queues=aCfg.getBoolean(""String_Node_Str"");
  by_queue=aCfg.getBoolean(""String_Node_Str"");
  data_sets=aCfg.getString(""String_Node_Str"");
  if (args.length > 0) {
    if (args[0].equals(""String_Node_Str"")) {
      visualize=true;
    }
  }
  LinkedList results=new LinkedList();
  String data_sets[]=aCfg.getStringArray(""String_Node_Str"");
  int total_gridlet[]=aCfg.getIntArray(""String_Node_Str"");
  LinkedList<Visualizator> windows=new LinkedList();
  if (visualize) {
    Visualizator.createGUI(windows);
  }
  failures=aCfg.getBoolean(""String_Node_Str"");
  reqs=aCfg.getBoolean(""String_Node_Str"");
  estimates=aCfg.getBoolean(""String_Node_Str"");
  use_AvgLength=aCfg.getBoolean(""String_Node_Str"");
  use_LastLength=aCfg.getBoolean(""String_Node_Str"");
  gap_length=aCfg.getInt(""String_Node_Str"");
  int weight_of_fairness[]=aCfg.getIntArray(""String_Node_Str"");
  String problem=""String_Node_Str"";
  if (!failures && !reqs) {
    problem+=""String_Node_Str"";
  }
  if (reqs) {
    problem+=""String_Node_Str"";
  }
  if (failures) {
    problem+=""String_Node_Str"";
  }
  if (estimates) {
    problem+=""String_Node_Str"";
  }
 else {
    problem+=""String_Node_Str"";
  }
  if (use_AvgLength) {
    problem+=""String_Node_Str"";
  }
  if (use_LastLength) {
    problem+=""String_Node_Str"";
  }
  if (useEventOpt) {
    problem+=""String_Node_Str"";
  }
  multiplicator=aCfg.getInt(""String_Node_Str"");
  on_demand_time_limit=aCfg.getInt(""String_Node_Str"");
  time_limit=aCfg.getInt(""String_Node_Str"");
  runtime_multiplicator=aCfg.getInt(""String_Node_Str"");
  path=aCfg.getString(""String_Node_Str"");
  meta=aCfg.getBoolean(""String_Node_Str"");
  if (meta) {
    data=false;
    String date=""String_Node_Str"" + new Date().toString();
    date=date.replace(""String_Node_Str"",""String_Node_Str"");
    date=date.replace(""String_Node_Str"",""String_Node_Str"");
    date=date.replace(""String_Node_Str"",""String_Node_Str"");
    System.out.println(date);
    problem+=date;
  }
  ResultCollector result_collector=new ResultCollector(results,problem);
  System.out.println(""String_Node_Str"" + System.getProperty(""String_Node_Str""));
  dir[0]=""String_Node_Str"";
  File resultsFile=new File(ExperimentSetup.getDir(DirectoryLevel.RESULT_ROOT));
  if (!resultsFile.exists()) {
    resultsFile.mkdir();
  }
  dir[1]=getDate();
  File runDirF=new File(ExperimentSetup.getDir(DirectoryLevel.EXPERIMENT_ROOT));
  runDirF.mkdir();
  System.out.println(""String_Node_Str"" + runDirF.getPath());
  File configurationF=aCfg.getFile();
  File destinationF=new File(ExperimentSetup.getDir(DirectoryLevel.EXPERIMENT_ROOT) + File.separator + aCfg.getFileName());
  try {
    FileUtil.copyFile(configurationF,destinationF);
  }
 catch (  IOException ex) {
    Logger.getLogger(ExperimentSetup.class.getName()).log(Level.WARNING,null,ex);
  }
  if (visualize) {
    File graphs=new File(user_dir + File.separator + ExperimentSetup.getDir(DirectoryLevel.EXPERIMENT_ROOT)+ File.separator+ ""String_Node_Str"");
    graphs.mkdir();
  }
  String[] pluginsString=aCfg.getStringArray(""String_Node_Str"");
  List<Map<String,String>> pluginConfigurations=new ArrayList<Map<String,String>>();
  String[] pluginHeaders=new String[pluginsString.length];
  for (int i=0; i < pluginsString.length; i++) {
    Map<String,String> plugincfg=aCfg.getPluginConfiguration(i);
    String header=plugincfg.get(PluginConfiguration.RESULT_HEADER);
    pluginHeaders[i]=header;
    pluginConfigurations.add(plugincfg);
  }
  for (int set=0; set < data_sets.length; set++) {
    String date=getDate();
    dir[2]=data_sets[set] + ""String_Node_Str"" + date;
    File dataSetDirF=new File(ExperimentSetup.getDir(DirectoryLevel.DATA_SET));
    dataSetDirF.mkdir();
    String prob=problem;
    fair_weight=weight_of_fairness[set];
    max_estim=0;
    result_collector.generateHeader(data_sets[set] + ""String_Node_Str"" + prob,pluginHeaders);
    prevAlgID=-1;
    boolean use_anti_starvation[]=aCfg.getBooleanArray(""String_Node_Str"");
    boolean use_resource_spec_packing[]=aCfg.getBooleanArray(""String_Node_Str"");
    int skip[]=aCfg.getIntArray(""String_Node_Str"");
    int timeskip[]=aCfg.getIntArray(""String_Node_Str"");
    for (int i=0; i < timeskip.length; i++) {
      Calendar myCal=Calendar.getInstance();
      myCal.setTimeInMillis(timeskip[i] * 1000L);
      if (!(myCal.get(Calendar.HOUR_OF_DAY) == 0 && myCal.get(Calendar.MINUTE) == 0 && myCal.get(Calendar.SECOND) == 0 && myCal.get(Calendar.MILLISECOND) == 0)) {
        throw new RuntimeException(""String_Node_Str"" + Integer.toString(myCal.get(Calendar.HOUR_OF_DAY)) + ""String_Node_Str""+ Integer.toString(myCal.get(Calendar.MINUTE))+ ""String_Node_Str""+ Integer.toString(myCal.get(Calendar.SECOND))+ ""String_Node_Str"");
      }
    }
    int algorithms[]=aCfg.getIntArray(""String_Node_Str"");
    for (int sel_alg=0; sel_alg < algorithms.length; sel_alg++) {
      anti_starvation=use_anti_starvation[sel_alg];
      resource_spec_packing=use_resource_spec_packing[sel_alg];
      skipJob=skip[set];
      firstArrival=timeskip[set];
      use_compresion=false;
      opt_alg=null;
      fix_alg=null;
      int alg=algorithms[sel_alg];
      int experiment_count=1;
      backfilled=0;
      name=data_sets[set];
      algID=alg;
      if (sel_alg > 0) {
        prevAlgID=algorithms[sel_alg - 1];
      }
      String suff=""String_Node_Str"";
      Scheduler scheduler=null;
      String scheduler_name=""String_Node_Str"";
      try {
        Calendar calendar=Calendar.getInstance();
        boolean trace_flag=false;
        String[] exclude_from_file={""String_Node_Str""};
        String[] exclude_from_processing={""String_Node_Str""};
        String report_name=null;
        GridSim.init(entities,calendar,trace_flag,exclude_from_file,exclude_from_processing,report_name);
        int rnd=new Random().nextInt();
        scheduler=new Scheduler(scheduler_name,baudRate,entities,results,alg,data_sets[set],total_gridlet[set],suff,windows,result_collector,sel_alg);
      }
 catch (      Exception ex) {
        Logger.getLogger(ExperimentSetup.class.getName()).log(Level.SEVERE,null,ex);
      }
      if (alg == 0) {
        policy=new FCFS(scheduler);
        suff=""String_Node_Str"";
        if (resource_spec_packing) {
          suff+=""String_Node_Str"";
        }
      }
      if (alg == 1) {
        policy=new EDF(scheduler);
        suff=""String_Node_Str"";
      }
      if (alg == 2) {
        policy=new EASY_Backfilling(scheduler);
        suff=""String_Node_Str"";
      }
      if (alg == 3) {
        policy=new AggressiveBackfilling(scheduler);
        suff=""String_Node_Str"";
      }
      if (alg == 4) {
        policy=new CONS(scheduler);
        use_compresion=true;
        suff=""String_Node_Str"";
      }
      if (alg == 5) {
        policy=new PBS_PRO(scheduler);
        suff=""String_Node_Str"";
      }
      if (alg == 6) {
        policy=new SJF(scheduler);
        suff=""String_Node_Str"";
      }
      if (alg == 7) {
        policy=new FairshareFCFS(scheduler);
        suff=""String_Node_Str"";
      }
      if (alg == 8) {
        policy=new FairshareMetaBackfilling(scheduler);
        suff=""String_Node_Str"";
        if (anti_starvation) {
          suff+=""String_Node_Str"";
        }
        if (resource_spec_packing) {
          suff+=""String_Node_Str"";
        }
      }
      if (alg == 12) {
        policy=new FairshareOptimizedMetaBackfilling(scheduler);
        suff=""String_Node_Str"";
        if (anti_starvation) {
          suff+=""String_Node_Str"";
        }
        if (resource_spec_packing) {
          suff+=""String_Node_Str"";
        }
      }
      if (alg == 9) {
        policy=new FairshareCONS(scheduler);
        use_compresion=true;
        suff=""String_Node_Str"";
      }
      if (alg == 10) {
        policy=new BestGap(scheduler);
        suff=""String_Node_Str"";
      }
      if (alg == 11) {
        suff=""String_Node_Str"" + multiplicator + ""String_Node_Str"";
        policy=new BestGap(scheduler);
        opt_alg=new RandomSearch();
        if (useEventOpt) {
          fix_alg=new GapSearch();
          suff+=""String_Node_Str"";
        }
      }
      if (alg == 18) {
        suff=""String_Node_Str"" + multiplicator + ""String_Node_Str"";
        policy=new CONS(scheduler);
        opt_alg=new TabuSearch();
        if (useEventOpt) {
          fix_alg=new TabuSearch();
          suff+=""String_Node_Str"";
        }
      }
      if (alg == 19) {
        suff=""String_Node_Str"" + multiplicator + ""String_Node_Str"";
        use_compresion=false;
        policy=new CONS(scheduler);
        opt_alg=new GapSearch();
        if (useEventOpt) {
          fix_alg=new GapSearch();
          suff+=""String_Node_Str"";
        }
      }
      if (alg == 20) {
        suff=""String_Node_Str"" + multiplicator + ""String_Node_Str"";
        use_compresion=false;
        policy=new CONS(scheduler);
        opt_alg=new RandomSearch();
        if (useEventOpt) {
          fix_alg=new RandomSearch();
          suff+=""String_Node_Str"";
        }
      }
      if (alg == 201 || alg == 202 || alg == 203) {
        suff=""String_Node_Str"" + multiplicator + ""String_Node_Str"";
        use_compresion=false;
        policy=new CONS(scheduler);
        opt_alg=new RandomSearch();
        if (useEventOpt) {
          fix_alg=new RandomSearch();
          suff+=""String_Node_Str"";
        }
      }
      if (alg == 204 || alg == 205 || alg == 206) {
        suff=""String_Node_Str"" + multiplicator + ""String_Node_Str"";
        use_compresion=false;
        policy=new CONS(scheduler);
        opt_alg=new RandomSearch();
        if (useEventOpt) {
          fix_alg=new GapSearch();
          suff+=""String_Node_Str"";
        }
      }
      if (alg == 207 || alg == 208 || alg == 209) {
        suff=""String_Node_Str"" + multiplicator + ""String_Node_Str"";
        use_compresion=false;
        policy=new CONS(scheduler);
        opt_alg=new WeightedRandomSearch();
        if (useEventOpt) {
          fix_alg=new WeightedRandomSearch();
          suff+=""String_Node_Str"";
        }
      }
      if (alg == 21) {
        suff=""String_Node_Str"";
        policy=new CONS(scheduler);
      }
      if (alg == 22) {
        policy=new Fairshare_EASY_Backfilling(scheduler);
        suff=""String_Node_Str"";
      }
      if (alg == 23) {
        policy=new BF_CONS_Fair(scheduler);
        use_compresion=true;
        suff=""String_Node_Str"";
      }
      dir[3]=(sel_alg + 1) + ""String_Node_Str"" + suff;
      File algDirF=new File(ExperimentSetup.getDir(DirectoryLevel.ALGORITHM));
      algDirF.mkdir();
      result_collector.deleteSchedResults(suff);
      System.out.println(""String_Node_Str"" + total_gridlet[set] + ""String_Node_Str""+ suff+ ""String_Node_Str""+ data_sets[set]+ ""String_Node_Str"");
      suff+=""String_Node_Str"" + data_sets[set];
      for (int pass_count=1; pass_count <= experiment_count; pass_count++) {
        List<Plugin> plugins=new ArrayList<Plugin>();
        for (int i=0; i < pluginsString.length; i++) {
          String pluginString=pluginsString[i];
          if (!pluginString.contains(""String_Node_Str"")) {
            pluginString=""String_Node_Str"" + pluginString;
          }
          Plugin pl=PluginFactory.createPlugin(pluginString);
          pl.init(pluginConfigurations.get(i));
          plugins.add(pl);
        }
        result_collector.setPlugins(plugins);
        avail_RAM=0;
        avail_CPUs=0;
        try {
          String job_loader_name=data_sets[set] + ""String_Node_Str"";
          if (use_queues) {
            QueueLoader q_loader=new QueueLoader(data_sets[set]);
          }
 else {
            Scheduler.all_queues.addLast(new LinkedList<GridletInfo>());
          }
          MachineLoader m_loader=new MachineLoader(10000,3.0,data_sets[set]);
          rnd_seed=sel_alg;
          System.out.println(avail_CPUs + ""String_Node_Str"" + avail_RAM);
          JobLoader job_loader=new JobLoader(job_loader_name,baudRate,total_gridlet[set],data_sets[set],maxPE,minPErating,maxPErating,arrival_rate_multiplier,pass_count,m_loader.total_CPUs,estimates);
          if (failures) {
            String failure_loader_name=data_sets[set] + ""String_Node_Str"";
            FailureLoaderNew failure=new FailureLoaderNew(failure_loader_name,baudRate,data_sets[set],clusterNames,machineNames,0);
          }
          System.out.println(""String_Node_Str"");
          GridSim.startGridSimulation();
        }
 catch (        Exception e) {
          System.out.println(""String_Node_Str"");
          System.out.println(e.getMessage());
          e.printStackTrace();
        }
        System.out.println(""String_Node_Str"" + pass_count + ""String_Node_Str"");
        Scheduler.load=0.0;
        Scheduler.classic_load=0.0;
        Scheduler.max_load=0.0;
        Scheduler.classic_activePEs=0.0;
        Scheduler.classic_availPEs=0.0;
        Scheduler.activePEs=0.0;
        Scheduler.availPEs=0.0;
        Scheduler.requestedPEs=0.0;
        Scheduler.last_event=0.0;
        Scheduler.start_event=-10.0;
        Scheduler.runtime=0.0;
        Sim_system.setInComplete(true);
        result_collector.generateResults(suff,experiment_count);
        result_collector.reset();
        results.clear();
        System.out.println(""String_Node_Str"" + max_estim + ""String_Node_Str""+ backfilled);
        System.gc();
      }
    }
  }
}","/** 
 * The main method - create all entities and start the simulation. <br> It is also capable of multiple starts of the simulation with different setup (machine count, job parameters, data sets).
 */
public static void main(String[] args){
  String user_dir=System.getProperty(""String_Node_Str"");
  Registration.register();
  try {
    aCfg=new AleaConfiguration();
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + e);
    return;
  }
  baudRate=aCfg.getDouble(""String_Node_Str"");
  entities=aCfg.getInt(""String_Node_Str"");
  maxPE=1;
  visualize=aCfg.getBoolean(""String_Node_Str"");
  data=aCfg.getBoolean(""String_Node_Str"");
  use_heap=aCfg.getBoolean(""String_Node_Str"");
  sld_tresh=aCfg.getDouble(""String_Node_Str"");
  algID=0;
  prevAlgID=-1;
  name=""String_Node_Str"";
  use_tsafrir=aCfg.getBoolean(""String_Node_Str"");
  use_speeds=aCfg.getBoolean(""String_Node_Str"");
  arrival_rate_multiplier=aCfg.getDouble(""String_Node_Str"");
  runtime_minimizer=aCfg.getDouble(""String_Node_Str"");
  use_RAM=aCfg.getBoolean(""String_Node_Str"");
  use_fairshare_WAIT=aCfg.getBoolean(""String_Node_Str"");
  use_fairshare_RAM=aCfg.getBoolean(""String_Node_Str"");
  use_fairshare=aCfg.getBoolean(""String_Node_Str"");
  multiply_sums=aCfg.getBoolean(""String_Node_Str"");
  use_MAX=aCfg.getBoolean(""String_Node_Str"");
  use_SQRT=aCfg.getBoolean(""String_Node_Str"");
  sum_multiplications=aCfg.getBoolean(""String_Node_Str"");
  useEventOpt=aCfg.getBoolean(""String_Node_Str"");
  avail_RAM=0.0;
  avail_CPUs=0.0;
  backfilled=0;
  use_queues=aCfg.getBoolean(""String_Node_Str"");
  by_queue=aCfg.getBoolean(""String_Node_Str"");
  data_sets=aCfg.getString(""String_Node_Str"");
  if (args.length > 0) {
    if (args[0].equals(""String_Node_Str"")) {
      visualize=true;
    }
  }
  LinkedList results=new LinkedList();
  String data_sets[]=aCfg.getStringArray(""String_Node_Str"");
  int total_gridlet[]=aCfg.getIntArray(""String_Node_Str"");
  LinkedList<Visualizator> windows=new LinkedList();
  if (visualize) {
    Visualizator.createGUI(windows);
  }
  failures=aCfg.getBoolean(""String_Node_Str"");
  reqs=aCfg.getBoolean(""String_Node_Str"");
  estimates=aCfg.getBoolean(""String_Node_Str"");
  use_AvgLength=aCfg.getBoolean(""String_Node_Str"");
  use_LastLength=aCfg.getBoolean(""String_Node_Str"");
  gap_length=aCfg.getInt(""String_Node_Str"");
  int weight_of_fairness[]=aCfg.getIntArray(""String_Node_Str"");
  String problem=""String_Node_Str"";
  if (!failures && !reqs) {
    problem+=""String_Node_Str"";
  }
  if (reqs) {
    problem+=""String_Node_Str"";
  }
  if (failures) {
    problem+=""String_Node_Str"";
  }
  if (estimates) {
    problem+=""String_Node_Str"";
  }
 else {
    problem+=""String_Node_Str"";
  }
  if (use_AvgLength) {
    problem+=""String_Node_Str"";
  }
  if (use_LastLength) {
    problem+=""String_Node_Str"";
  }
  if (useEventOpt) {
    problem+=""String_Node_Str"";
  }
  multiplicator=aCfg.getInt(""String_Node_Str"");
  on_demand_time_limit=aCfg.getInt(""String_Node_Str"");
  time_limit=aCfg.getInt(""String_Node_Str"");
  runtime_multiplicator=aCfg.getInt(""String_Node_Str"");
  path=aCfg.getString(""String_Node_Str"");
  meta=aCfg.getBoolean(""String_Node_Str"");
  if (meta) {
    data=false;
    String date=""String_Node_Str"" + new Date().toString();
    date=date.replace(""String_Node_Str"",""String_Node_Str"");
    date=date.replace(""String_Node_Str"",""String_Node_Str"");
    date=date.replace(""String_Node_Str"",""String_Node_Str"");
    System.out.println(date);
    problem+=date;
  }
  ResultCollector result_collector=new ResultCollector(results,problem);
  System.out.println(""String_Node_Str"" + System.getProperty(""String_Node_Str""));
  dir[0]=""String_Node_Str"";
  File resultsFile=new File(ExperimentSetup.getDir(DirectoryLevel.RESULT_ROOT));
  if (!resultsFile.exists()) {
    resultsFile.mkdir();
  }
  dir[1]=getDate();
  File runDirF=new File(ExperimentSetup.getDir(DirectoryLevel.EXPERIMENT_ROOT));
  runDirF.mkdir();
  System.out.println(""String_Node_Str"" + runDirF.getPath());
  File configurationF=aCfg.getFile();
  File destinationF=new File(ExperimentSetup.getDir(DirectoryLevel.EXPERIMENT_ROOT) + File.separator + aCfg.getFileName());
  try {
    FileUtil.copyFile(configurationF,destinationF);
  }
 catch (  IOException ex) {
    Logger.getLogger(ExperimentSetup.class.getName()).log(Level.WARNING,null,ex);
  }
  if (visualize) {
    File graphs=new File(user_dir + File.separator + ExperimentSetup.getDir(DirectoryLevel.EXPERIMENT_ROOT)+ File.separator+ ""String_Node_Str"");
    graphs.mkdir();
  }
  String[] pluginsString=aCfg.getStringArray(""String_Node_Str"");
  List<Map<String,String>> pluginConfigurations=new ArrayList<Map<String,String>>();
  String[] pluginHeaders=new String[pluginsString.length];
  for (int i=0; i < pluginsString.length; i++) {
    Map<String,String> plugincfg=aCfg.getPluginConfiguration(i);
    String header=plugincfg.get(PluginConfiguration.RESULT_HEADER);
    pluginHeaders[i]=header;
    pluginConfigurations.add(plugincfg);
  }
  for (int set=0; set < data_sets.length; set++) {
    String date=getDate();
    dir[2]=data_sets[set] + ""String_Node_Str"" + date;
    File dataSetDirF=new File(ExperimentSetup.getDir(DirectoryLevel.DATA_SET));
    dataSetDirF.mkdir();
    String prob=problem;
    fair_weight=weight_of_fairness[set];
    max_estim=0;
    result_collector.generateHeader(data_sets[set] + ""String_Node_Str"" + prob,pluginHeaders);
    prevAlgID=-1;
    boolean use_anti_starvation[]=aCfg.getBooleanArray(""String_Node_Str"");
    boolean use_resource_spec_packing[]=aCfg.getBooleanArray(""String_Node_Str"");
    int skip[]=aCfg.getIntArray(""String_Node_Str"");
    int timeskip[]=aCfg.getIntArray(""String_Node_Str"");
    int algorithms[]=aCfg.getIntArray(""String_Node_Str"");
    for (int sel_alg=0; sel_alg < algorithms.length; sel_alg++) {
      anti_starvation=use_anti_starvation[sel_alg];
      resource_spec_packing=use_resource_spec_packing[sel_alg];
      skipJob=skip[set];
      firstArrival=timeskip[set];
      use_compresion=false;
      opt_alg=null;
      fix_alg=null;
      int alg=algorithms[sel_alg];
      int experiment_count=1;
      backfilled=0;
      name=data_sets[set];
      algID=alg;
      if (sel_alg > 0) {
        prevAlgID=algorithms[sel_alg - 1];
      }
      String suff=""String_Node_Str"";
      Scheduler scheduler=null;
      String scheduler_name=""String_Node_Str"";
      try {
        Calendar calendar=Calendar.getInstance();
        boolean trace_flag=false;
        String[] exclude_from_file={""String_Node_Str""};
        String[] exclude_from_processing={""String_Node_Str""};
        String report_name=null;
        GridSim.init(entities,calendar,trace_flag,exclude_from_file,exclude_from_processing,report_name);
        int rnd=new Random().nextInt();
        scheduler=new Scheduler(scheduler_name,baudRate,entities,results,alg,data_sets[set],total_gridlet[set],suff,windows,result_collector,sel_alg);
      }
 catch (      Exception ex) {
        Logger.getLogger(ExperimentSetup.class.getName()).log(Level.SEVERE,null,ex);
      }
      if (alg == 0) {
        policy=new FCFS(scheduler);
        suff=""String_Node_Str"";
        if (resource_spec_packing) {
          suff+=""String_Node_Str"";
        }
      }
      if (alg == 1) {
        policy=new EDF(scheduler);
        suff=""String_Node_Str"";
      }
      if (alg == 2) {
        policy=new EASY_Backfilling(scheduler);
        suff=""String_Node_Str"";
      }
      if (alg == 3) {
        policy=new AggressiveBackfilling(scheduler);
        suff=""String_Node_Str"";
      }
      if (alg == 4) {
        policy=new CONS(scheduler);
        use_compresion=true;
        suff=""String_Node_Str"";
      }
      if (alg == 5) {
        policy=new PBS_PRO(scheduler);
        suff=""String_Node_Str"";
      }
      if (alg == 6) {
        policy=new SJF(scheduler);
        suff=""String_Node_Str"";
      }
      if (alg == 7) {
        policy=new FairshareFCFS(scheduler);
        suff=""String_Node_Str"";
      }
      if (alg == 8) {
        policy=new FairshareMetaBackfilling(scheduler);
        suff=""String_Node_Str"";
        if (anti_starvation) {
          suff+=""String_Node_Str"";
        }
        if (resource_spec_packing) {
          suff+=""String_Node_Str"";
        }
      }
      if (alg == 12) {
        policy=new FairshareOptimizedMetaBackfilling(scheduler);
        suff=""String_Node_Str"";
        if (anti_starvation) {
          suff+=""String_Node_Str"";
        }
        if (resource_spec_packing) {
          suff+=""String_Node_Str"";
        }
      }
      if (alg == 9) {
        policy=new FairshareCONS(scheduler);
        use_compresion=true;
        suff=""String_Node_Str"";
      }
      if (alg == 10) {
        policy=new BestGap(scheduler);
        suff=""String_Node_Str"";
      }
      if (alg == 11) {
        suff=""String_Node_Str"" + multiplicator + ""String_Node_Str"";
        policy=new BestGap(scheduler);
        opt_alg=new RandomSearch();
        if (useEventOpt) {
          fix_alg=new GapSearch();
          suff+=""String_Node_Str"";
        }
      }
      if (alg == 18) {
        suff=""String_Node_Str"" + multiplicator + ""String_Node_Str"";
        policy=new CONS(scheduler);
        opt_alg=new TabuSearch();
        if (useEventOpt) {
          fix_alg=new TabuSearch();
          suff+=""String_Node_Str"";
        }
      }
      if (alg == 19) {
        suff=""String_Node_Str"" + multiplicator + ""String_Node_Str"";
        use_compresion=false;
        policy=new CONS(scheduler);
        opt_alg=new GapSearch();
        if (useEventOpt) {
          fix_alg=new GapSearch();
          suff+=""String_Node_Str"";
        }
      }
      if (alg == 20) {
        suff=""String_Node_Str"" + multiplicator + ""String_Node_Str"";
        use_compresion=false;
        policy=new CONS(scheduler);
        opt_alg=new RandomSearch();
        if (useEventOpt) {
          fix_alg=new RandomSearch();
          suff+=""String_Node_Str"";
        }
      }
      if (alg == 201 || alg == 202 || alg == 203) {
        suff=""String_Node_Str"" + multiplicator + ""String_Node_Str"";
        use_compresion=false;
        policy=new CONS(scheduler);
        opt_alg=new RandomSearch();
        if (useEventOpt) {
          fix_alg=new RandomSearch();
          suff+=""String_Node_Str"";
        }
      }
      if (alg == 204 || alg == 205 || alg == 206) {
        suff=""String_Node_Str"" + multiplicator + ""String_Node_Str"";
        use_compresion=false;
        policy=new CONS(scheduler);
        opt_alg=new RandomSearch();
        if (useEventOpt) {
          fix_alg=new GapSearch();
          suff+=""String_Node_Str"";
        }
      }
      if (alg == 207 || alg == 208 || alg == 209) {
        suff=""String_Node_Str"" + multiplicator + ""String_Node_Str"";
        use_compresion=false;
        policy=new CONS(scheduler);
        opt_alg=new WeightedRandomSearch();
        if (useEventOpt) {
          fix_alg=new WeightedRandomSearch();
          suff+=""String_Node_Str"";
        }
      }
      if (alg == 21) {
        suff=""String_Node_Str"";
        policy=new CONS(scheduler);
      }
      if (alg == 22) {
        policy=new Fairshare_EASY_Backfilling(scheduler);
        suff=""String_Node_Str"";
      }
      if (alg == 23) {
        policy=new BF_CONS_Fair(scheduler);
        use_compresion=true;
        suff=""String_Node_Str"";
      }
      dir[3]=(sel_alg + 1) + ""String_Node_Str"" + suff;
      File algDirF=new File(ExperimentSetup.getDir(DirectoryLevel.ALGORITHM));
      algDirF.mkdir();
      result_collector.deleteSchedResults(suff);
      System.out.println(""String_Node_Str"" + total_gridlet[set] + ""String_Node_Str""+ suff+ ""String_Node_Str""+ data_sets[set]+ ""String_Node_Str"");
      suff+=""String_Node_Str"" + data_sets[set];
      for (int pass_count=1; pass_count <= experiment_count; pass_count++) {
        List<Plugin> plugins=new ArrayList<Plugin>();
        for (int i=0; i < pluginsString.length; i++) {
          String pluginString=pluginsString[i];
          if (!pluginString.contains(""String_Node_Str"")) {
            pluginString=""String_Node_Str"" + pluginString;
          }
          Plugin pl=PluginFactory.createPlugin(pluginString);
          pl.init(pluginConfigurations.get(i));
          plugins.add(pl);
        }
        result_collector.setPlugins(plugins);
        avail_RAM=0;
        avail_CPUs=0;
        try {
          String job_loader_name=data_sets[set] + ""String_Node_Str"";
          if (use_queues) {
            QueueLoader q_loader=new QueueLoader(data_sets[set]);
          }
 else {
            Scheduler.all_queues.addLast(new LinkedList<GridletInfo>());
          }
          MachineLoader m_loader=new MachineLoader(10000,3.0,data_sets[set]);
          rnd_seed=sel_alg;
          System.out.println(avail_CPUs + ""String_Node_Str"" + avail_RAM);
          JobLoader job_loader=new JobLoader(job_loader_name,baudRate,total_gridlet[set],data_sets[set],maxPE,minPErating,maxPErating,arrival_rate_multiplier,pass_count,m_loader.total_CPUs,estimates);
          if (failures) {
            String failure_loader_name=data_sets[set] + ""String_Node_Str"";
            FailureLoaderNew failure=new FailureLoaderNew(failure_loader_name,baudRate,data_sets[set],clusterNames,machineNames,0);
          }
          System.out.println(""String_Node_Str"" + alea_version);
          GridSim.startGridSimulation();
        }
 catch (        Exception e) {
          System.out.println(""String_Node_Str"");
          System.out.println(e.getMessage());
          e.printStackTrace();
        }
        System.out.println(""String_Node_Str"" + pass_count + ""String_Node_Str"");
        Scheduler.load=0.0;
        Scheduler.classic_load=0.0;
        Scheduler.max_load=0.0;
        Scheduler.classic_activePEs=0.0;
        Scheduler.classic_availPEs=0.0;
        Scheduler.activePEs=0.0;
        Scheduler.availPEs=0.0;
        Scheduler.requestedPEs=0.0;
        Scheduler.last_event=0.0;
        Scheduler.start_event=-10.0;
        Scheduler.runtime=0.0;
        Sim_system.setInComplete(true);
        result_collector.generateResults(suff,experiment_count);
        result_collector.reset();
        results.clear();
        System.out.println(""String_Node_Str"" + max_estim + ""String_Node_Str""+ backfilled);
        System.gc();
      }
    }
  }
}",0.9540676263809844
38046,"public PerformanceResult answer(Reasoner r){
  System.err.println(""String_Node_Str"");
  PerformanceResult res=this.performanceResultFactory();
  ProductsQuestion pq=this.productsQuestionFactory();
  allFeats=this.getAllFeatures();
  products=(Collection<Product>)pq.getAllProducts();
  deadFeatures=new ArrayList<GenericFeature>();
  Iterator<GenericFeature> it=allFeats.iterator();
  while (it.hasNext()) {
    GenericFeature feat=it.next();
    Iterator<Product> pit=products.iterator();
    boolean isDead=true;
    while (pit.hasNext() && isDead) {
      Product p=pit.next();
      if (p.getFeatures().contains(feat)) {
        isDead=false;
      }
    }
    if (isDead) {
      deadFeatures.add(feat);
    }
  }
  return res;
}","public PerformanceResult answer(Reasoner r){
  System.err.println(""String_Node_Str"");
  PerformanceResult res=this.performanceResultFactory();
  ProductsQuestion pq=this.productsQuestionFactory();
  allFeats=this.getAllFeatures();
  r.ask(pq);
  products=(Collection<Product>)pq.getAllProducts();
  deadFeatures=new ArrayList<GenericFeature>();
  Iterator<GenericFeature> it=allFeats.iterator();
  while (it.hasNext()) {
    GenericFeature feat=it.next();
    Iterator<Product> pit=products.iterator();
    boolean isDead=true;
    while (pit.hasNext() && isDead) {
      Product p=pit.next();
      if (p.getFeatures().contains(feat)) {
        isDead=false;
      }
    }
    if (isDead) {
      deadFeatures.add(feat);
    }
  }
  return res;
}",0.9912221471978392
38047,"/** 
 * Constructor that takes min and max extents. No checking is done that min <= max for all dim i.
 */
public Extents(final long[] min,final long[] max){
  super(min,max);
  numElements=calcNumElements();
}","/** 
 * Constructor that takes min and max extents. No checking is done that  {@code min <= max} for all dim i.
 */
public Extents(final long[] min,final long[] max){
  super(min,max);
  numElements=calcNumElements();
}",0.9790209790209792
38048,"/** 
 * Private utility method used to compute the square root of a BigDecimal.
 * @author Luciano Culacciatti
 * @url http://www.codeproject.com/Tips/257031/Implementing-SqrtRoot-in-BigDecimal
 * @param c
 * @param xn
 * @param precision
 */
private static PreciseFixedFloatType sqrtNewtonRaphson(PreciseFixedFloatType c,PreciseFixedFloatType xn,PreciseFixedFloatType precision){
  PreciseFixedFloatType negC=new PreciseFixedFloatType(c);
  negC.negate();
  PreciseFixedFloatType fx=new PreciseFixedFloatType(xn);
  fx.pow(2);
  fx.add(negC);
  PreciseFixedFloatType fpx=new PreciseFixedFloatType();
  fpx.mul(xn,TWO);
  PreciseFixedFloatType xn1=new PreciseFixedFloatType();
  xn1.div(fx,fpx);
  PreciseFixedFloatType negXn1=new PreciseFixedFloatType(xn1);
  negXn1.negate();
  xn1.add(xn,negXn1);
  PreciseFixedFloatType currentSquare=new PreciseFixedFloatType(xn1);
  currentSquare.pow(2);
  PreciseFixedFloatType currentPrecision=new PreciseFixedFloatType();
  currentPrecision.sub(currentSquare,c);
  currentPrecision.abs();
  if (xn.compareTo(xn1) == 0) {
    return xn;
  }
 else   if (currentPrecision.compareTo(precision) > 0) {
    return sqrtNewtonRaphson(c,xn1,precision);
  }
  return xn1;
}","/** 
 * Private utility method used to compute the square root of a BigDecimal.
 * @author Luciano Culacciatti
 * @see <a href=""https://www.codeproject.com/tips/257031/implementing-sqrtroot-in-bigdecimal"">Implementing SqrtRoot in BigDecimal</a>
 * @param c
 * @param xn
 * @param precision
 */
private static PreciseFixedFloatType sqrtNewtonRaphson(PreciseFixedFloatType c,PreciseFixedFloatType xn,PreciseFixedFloatType precision){
  PreciseFixedFloatType negC=new PreciseFixedFloatType(c);
  negC.negate();
  PreciseFixedFloatType fx=new PreciseFixedFloatType(xn);
  fx.pow(2);
  fx.add(negC);
  PreciseFixedFloatType fpx=new PreciseFixedFloatType();
  fpx.mul(xn,TWO);
  PreciseFixedFloatType xn1=new PreciseFixedFloatType();
  xn1.div(fx,fpx);
  PreciseFixedFloatType negXn1=new PreciseFixedFloatType(xn1);
  negXn1.negate();
  xn1.add(xn,negXn1);
  PreciseFixedFloatType currentSquare=new PreciseFixedFloatType(xn1);
  currentSquare.pow(2);
  PreciseFixedFloatType currentPrecision=new PreciseFixedFloatType();
  currentPrecision.sub(currentSquare,c);
  currentPrecision.abs();
  if (xn.compareTo(xn1) == 0) {
    return xn;
  }
 else   if (currentPrecision.compareTo(precision) > 0) {
    return sqrtNewtonRaphson(c,xn1,precision);
  }
  return xn1;
}",0.9695245835026411
38049,"/** 
 * Uses Newton Raphson to compute the square root of a BigDecimal.
 * @author Luciano Culacciatti
 * @url http://www.codeproject.com/Tips/257031/Implementing-SqrtRoot-in-BigDecimal
 * @param c
 */
public static PreciseFixedFloatType sqrt(PreciseFixedFloatType c){
  PreciseFixedFloatType precision=new PreciseFixedFloatType();
  precision.div(ONE,SQRT_PRE);
  return sqrtNewtonRaphson(c,ONE,precision);
}","/** 
 * Uses Newton Raphson to compute the square root of a BigDecimal.
 * @author Luciano Culacciatti
 * @see <a href=""https://www.codeproject.com/tips/257031/implementing-sqrtroot-in-bigdecimal"">Implementing SqrtRoot in BigDecimal</a>
 * @param c
 */
public static PreciseFixedFloatType sqrt(PreciseFixedFloatType c){
  PreciseFixedFloatType precision=new PreciseFixedFloatType();
  precision.div(ONE,SQRT_PRE);
  return sqrtNewtonRaphson(c,ONE,precision);
}",0.9090909090909092
38050,"/** 
 * Finds   {@link URL}s of resources known to ImageJ. <p> Each of the given   {@link URL}s is recursively scanned using SciJava Common's   {@link FileUtils#listContents(URL)}, and anything matching the given   {@code regex} pattern is added to the output map.</li>
 * @param regex The regex to use when matching resources, or null to matcheverything.
 * @param urls Paths to search for resources.
 * @return A map of URLs referencing the matched resources.
 */
public static Map<String,URL> findResources(final String regex,final Iterable<URL> urls){
  final HashMap<String,URL> result=new HashMap<>();
  final Pattern pattern=regex == null ? null : Pattern.compile(regex);
  for (  final URL url : urls) {
    getResources(pattern,result,url);
  }
  return result;
}","/** 
 * Finds   {@link URL}s of resources known to ImageJ. <p> Each of the given   {@link URL}s is recursively scanned using SciJava Common's   {@link FileUtils#listContents(URL)}, and anything matching the given   {@code regex} pattern is added to the output map.</p>
 * @param regex The regex to use when matching resources, or null to matcheverything.
 * @param urls Paths to search for resources.
 * @return A map of URLs referencing the matched resources.
 */
public static Map<String,URL> findResources(final String regex,final Iterable<URL> urls){
  final HashMap<String,URL> result=new HashMap<>();
  final Pattern pattern=regex == null ? null : Pattern.compile(regex);
  for (  final URL url : urls) {
    getResources(pattern,result,url);
  }
  return result;
}",0.9980557355800388
38051,"/** 
 * Computes a likely-to-be-unique string for this axis. 
 */
private String hashString(final CalibratedAxis axis){
  return axis.type() + ""String_Node_Str"" + axis.unit()+ ""String_Node_Str""+ axis.particularEquation();
}","/** 
 * Computes a likely-to-be-unique string for this axis. 
 */
private String hashString(final CalibratedAxis axis){
  return axis.type().hashCode() + ""String_Node_Str"" + axis.unit()+ ""String_Node_Str""+ axis.particularEquation();
}",0.975929978118162
38052,"/** 
 * @return an array of {@code AxisType}s corresponding to all currently defined axes.
 */
public static AxisType[] knownTypes(){
  return axes.values().toArray(null);
}","/** 
 * @return an array of {@code AxisType}s corresponding to all currently defined axes.
 */
public static AxisType[] knownTypes(){
  return axes.values().toArray(new AxisType[0]);
}",0.9523809523809524
38053,"@Override public double averageScale(final int d){
  return averageScale(d);
}","@Override public double averageScale(final int d){
  return axis(d).averageScale(0,1);
}",0.927710843373494
38054,"private void assignDefaultAxes(){
  for (int d=0; d < numDimensions(); d++) {
    setAxis(new IdentityAxis(),d);
  }
}","private void assignDefaultAxes(final int numDimensions){
  for (int d=0; d < numDimensions; d++) {
    setAxis(new IdentityAxis(),d);
  }
}",0.9027237354085604
38055,"@Override public String calibratedEquation(){
  return ""String_Node_Str"" + a + ""String_Node_Str""+ b+ ""String_Node_Str""+ a+ ""String_Node_Str""+ c+ ""String_Node_Str""+ c+ ""String_Node_Str""+ d+ ""String_Node_Str"";
}","@Override public String calibratedEquation(){
  return ""String_Node_Str"" + a + ""String_Node_Str""+ b+ ""String_Node_Str""+ a+ ""String_Node_Str""+ c+ ""String_Node_Str""+ d+ ""String_Node_Str"";
}",0.9444444444444444
38056,"@Override public double calibratedValue(double rawValue){
  return a + Math.pow((b - a),c) * Math.exp(-(rawValue - c) * (rawValue - c) / (2 * d * d));
}","@Override public double calibratedValue(double rawValue){
  return a + (b - a) * Math.exp(-(rawValue - c) * (rawValue - c) / (2 * d * d));
}",0.958904109589041
38057,"private double calValue(double raw,GaussianAxis axis){
  return axis.a() + Math.pow((axis.b() - axis.a()),axis.c()) * Math.exp(-(raw - axis.c()) * (raw - axis.c()) / (2 * axis.d() * axis.d()));
}","private double calValue(double raw,GaussianAxis axis){
  return axis.a() + (axis.b() - axis.a()) * Math.exp(-(raw - axis.c()) * (raw - axis.c()) / (2 * axis.d() * axis.d()));
}",0.9487870619946092
38058,"@Override public double rawValue(double calibratedValue){
  return a + (b - a) / (1 + Math.pow((calibratedValue / c),d));
}","@Override public double rawValue(double calibratedValue){
  double yToTheD=Math.pow(calibratedValue,d);
  double aToTheD=Math.pow(a,d);
  return ((c * yToTheD) + (aToTheD * b)) / (aToTheD + yToTheD);
}",0.5617283950617284
38059,"@Override public boolean update(CalibratedAxis other){
  if (other instanceof ExponentialRecoveryAxis) {
    ExponentialRecoveryAxis axis=(ExponentialRecoveryAxis)other;
    setType(axis.type());
    setUnit(axis.unit());
    setA(axis.a());
    setB(axis.b());
    setC(axis.c());
    setD(axis.d());
  }
  return false;
}","@Override public boolean update(CalibratedAxis other){
  if (other instanceof ExponentialRecoveryAxis) {
    ExponentialRecoveryAxis axis=(ExponentialRecoveryAxis)other;
    setType(axis.type());
    setUnit(axis.unit());
    setA(axis.a());
    setB(axis.b());
    setC(axis.c());
    setD(axis.d());
    return true;
  }
  return false;
}",0.9743589743589745
38060,"@Test public void test2(){
  RealInterval interval=new FinalRealInterval(new double[]{7,13});
  double[] extents=IntervalUtils.getExtents(interval);
  assertEquals(6,extents[0],0);
  assertEquals(12,extents[1],0);
}","@Test public void test2(){
  final RealInterval interval=new FinalRealInterval(new double[]{0,0},new double[]{7,13});
  final double[] extents=IntervalUtils.getExtents(interval);
  assertEquals(7,extents[0],0);
  assertEquals(13,extents[1],0);
}",0.9260869565217392
38061,"@Test public void test3(){
  DefaultCalibratedRealInterval interval=new DefaultCalibratedRealInterval(new double[]{10,20});
  DefaultCalibratedAxis axis0=new DefaultCalibratedAxis(Axes.X,null,7);
  DefaultCalibratedAxis axis1=new DefaultCalibratedAxis(Axes.Y,null,9);
  interval.setAxis(axis0,0);
  interval.setAxis(axis1,1);
  double[] extents=IntervalUtils.getCalibratedExtents(interval);
  assertEquals(9 * axis0.calibration(),extents[0],0);
  assertEquals(19 * axis1.calibration(),extents[1],0);
}","@Test public void test3(){
  final DefaultCalibratedRealInterval interval=new DefaultCalibratedRealInterval(new double[]{10,20});
  final DefaultCalibratedAxis axis0=new DefaultCalibratedAxis(Axes.X,null,7);
  final DefaultCalibratedAxis axis1=new DefaultCalibratedAxis(Axes.Y,null,9);
  interval.setAxis(axis0,0);
  interval.setAxis(axis1,1);
  final double[] extents=IntervalUtils.getCalibratedExtents(interval);
  assertEquals(9 * axis0.calibration(),extents[0],0);
  assertEquals(19 * axis1.calibration(),extents[1],0);
}",0.9766081871345028
38062,"@Test public void test1(){
  Interval interval=new FinalInterval(new long[]{10,20});
  long[] dims=IntervalUtils.getDims(interval);
  assertEquals(10,dims[0]);
  assertEquals(20,dims[1]);
}","@Test public void test1(){
  final Interval interval=new FinalInterval(new long[]{10,20});
  final long[] dims=IntervalUtils.getDims(interval);
  assertEquals(10,dims[0]);
  assertEquals(20,dims[1]);
}",0.9692307692307692
38063,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup parent,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.location_fragment,parent,false);
  LinearLayout firstPage=(LinearLayout)v.findViewById(R.id.onePage);
  LinearLayout.LayoutParams params=(LinearLayout.LayoutParams)firstPage.getLayoutParams();
  params.height=mForecastApplication.getHeight();
  firstPage.setLayoutParams(params);
  TextView textView=(TextView)v.findViewById(R.id.location);
  textView.setText(mLocation.getName());
  Weather weather=mLocation.getWeather();
  textView=(TextView)v.findViewById(R.id.temp);
  textView.setText(""String_Node_Str"" + Math.round(weather.getTemperature()));
  textView=(TextView)v.findViewById(R.id.summary);
  textView.setText(""String_Node_Str"" + weather.getSummary());
  GraphView.GraphViewData[] points;
  int length=24;
  points=new GraphView.GraphViewData[length];
  for (int x=0; x < length; x++) {
    int time=weather.getHourly().get(x).getTime();
    double temp=weather.getHourly().get(x).getTemperature();
    points[x]=new GraphView.GraphViewData(time,temp);
  }
  GraphView graphView=new LineGraphView(mContext,""String_Node_Str"");
  graphView.getGraphViewStyle().setNumHorizontalLabels(1);
  graphView.getGraphViewStyle().setGridColor(Color.TRANSPARENT);
  graphView.getGraphViewStyle().setNumVerticalLabels(5);
  graphView.addSeries(new GraphViewSeries(points));
  LinearLayout layout=(LinearLayout)v.findViewById(R.id.graph);
  layout.addView(graphView);
  return v;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup parent,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.location_fragment,parent,false);
  LinearLayout firstPage=(LinearLayout)v.findViewById(R.id.onePage);
  LinearLayout.LayoutParams params=(LinearLayout.LayoutParams)firstPage.getLayoutParams();
  params.height=mForecastApplication.getHeight();
  firstPage.setLayoutParams(params);
  TextView textView=(TextView)v.findViewById(R.id.location);
  textView.setText(mLocation.getName());
  Weather weather=mLocation.getWeather();
  textView=(TextView)v.findViewById(R.id.temp);
  textView.setText(Integer.toString((int)Math.round(weather.getTemperature())) + (char)0x00B0);
  textView=(TextView)v.findViewById(R.id.summary);
  textView.setText(weather.getSummary());
  GraphView.GraphViewData[] points;
  int length=24;
  points=new GraphView.GraphViewData[length];
  for (int x=0; x < length; x++) {
    int time=weather.getHourly().get(x).getTime();
    double temp=weather.getHourly().get(x).getTemperature();
    points[x]=new GraphView.GraphViewData(time,temp);
  }
  GraphView graphView=new LineGraphView(mContext,""String_Node_Str"");
  graphView.getGraphViewStyle().setNumHorizontalLabels(1);
  graphView.getGraphViewStyle().setGridColor(Color.TRANSPARENT);
  graphView.getGraphViewStyle().setNumVerticalLabels(5);
  graphView.addSeries(new GraphViewSeries(points));
  LinearLayout layout=(LinearLayout)v.findViewById(R.id.graph);
  layout.addView(graphView);
  return v;
}",0.9120951751487112
38064,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.locations);
  mContext=this;
  DatabaseHandler databaseHandler=new DatabaseHandler(this);
  List<Location> locations=databaseHandler.getAllLocations();
  List<String> locationsArry=new ArrayList<String>();
  for (int x=0; x < locations.size(); x++) {
    locationsArry.add(locations.get(0).getName());
    setListAdapter(new ArrayAdapter<String>(this,android.R.layout.simple_list_item_1,locationsArry));
  }
  addLocationEditText=(EditText)findViewById(R.id.add_location);
  setupListeners();
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.locations);
  mContext=this;
  DatabaseHandler databaseHandler=new DatabaseHandler(this);
  List<Location> locations=databaseHandler.getAllLocations();
  List<String> locationsArry=new ArrayList<String>();
  for (int x=0; x < locations.size(); x++) {
    locationsArry.add(locations.get(x).getName());
    setListAdapter(new ArrayAdapter<String>(this,android.R.layout.simple_list_item_1,locationsArry));
  }
  addLocationEditText=(EditText)findViewById(R.id.add_location);
  setupListeners();
}",0.9983792544570502
38065,"protected static KloudlessResponse _request(APIResource.RequestMethod method,String path,Map<String,Object> params,Map<String,String> keys) throws AuthenticationException, InvalidRequestException, APIConnectionException, APIException {
  if (keys == null) {
    keys=new HashMap<String,String>();
  }
  if ((Kloudless.apiKey == null || Kloudless.apiKey.length() == 0) && (keys.get(""String_Node_Str"") == null || keys.get(""String_Node_Str"").length() == 0) && (Kloudless.developerKey == null || Kloudless.developerKey.length() == 0)&& (keys.get(""String_Node_Str"") == null || keys.get(""String_Node_Str"").length() == 0)&& (keys.get(""String_Node_Str"") == null || keys.get(""String_Node_Str"").length() == 0)) {
    throw new AuthenticationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  }
  if (Kloudless.apiKey != null) {
    keys.put(""String_Node_Str"",Kloudless.apiKey);
  }
 else   if (Kloudless.developerKey != null) {
    keys.put(""String_Node_Str"",Kloudless.developerKey);
  }
 else   if (Kloudless.bearerToken != null) {
    keys.put(""String_Node_Str"",Kloudless.bearerToken);
  }
  String query;
  String url=String.format(""String_Node_Str"",Kloudless.getApiBase(),Kloudless.apiVersion,path);
  try {
    query=createQuery(method,params);
  }
 catch (  UnsupportedEncodingException e) {
    throw new InvalidRequestException(""String_Node_Str"" + CHARSET + ""String_Node_Str"",null,e);
  }
  KloudlessResponse response;
  try {
    response=makeURLConnectionRequest(method,params,url,query,keys);
  }
 catch (  ClassCastException ce) {
    String appEngineEnv=System.getProperty(""String_Node_Str"",null);
    if (appEngineEnv != null) {
      response=makeAppEngineRequest(method,params,url,query,keys);
    }
 else {
      throw ce;
    }
  }
  return response;
}","protected static KloudlessResponse _request(APIResource.RequestMethod method,String path,Map<String,Object> params,Map<String,String> keys) throws AuthenticationException, InvalidRequestException, APIConnectionException, APIException {
  if (keys == null) {
    keys=new HashMap<String,String>();
  }
  if ((Kloudless.apiKey == null || Kloudless.apiKey.length() == 0) && (keys.get(""String_Node_Str"") == null || keys.get(""String_Node_Str"").length() == 0) && (Kloudless.developerKey == null || Kloudless.developerKey.length() == 0)&& (keys.get(""String_Node_Str"") == null || keys.get(""String_Node_Str"").length() == 0)&& (Kloudless.bearerToken == null || Kloudless.bearerToken.length() == 0)&& (keys.get(""String_Node_Str"") == null || keys.get(""String_Node_Str"").length() == 0)) {
    throw new AuthenticationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  }
  if (Kloudless.apiKey != null) {
    keys.put(""String_Node_Str"",Kloudless.apiKey);
  }
 else   if (Kloudless.developerKey != null) {
    keys.put(""String_Node_Str"",Kloudless.developerKey);
  }
 else   if (Kloudless.bearerToken != null) {
    keys.put(""String_Node_Str"",Kloudless.bearerToken);
  }
  String query;
  String url=String.format(""String_Node_Str"",Kloudless.getApiBase(),Kloudless.apiVersion,path);
  try {
    query=createQuery(method,params);
  }
 catch (  UnsupportedEncodingException e) {
    throw new InvalidRequestException(""String_Node_Str"" + CHARSET + ""String_Node_Str"",null,e);
  }
  KloudlessResponse response;
  try {
    response=makeURLConnectionRequest(method,params,url,query,keys);
  }
 catch (  ClassCastException ce) {
    String appEngineEnv=System.getProperty(""String_Node_Str"",null);
    if (appEngineEnv != null) {
      response=makeAppEngineRequest(method,params,url,query,keys);
    }
 else {
      throw ce;
    }
  }
  return response;
}",0.980328752357855
38066,"/** 
 * The all() method is a ""mixin"" that allows for a list of objects to be returned. By passing in a class and path url, the list of objects is abstracted away along with the http requests.  A JSON object will be returned with 
 * @param path -- url path for the list resource
 * @param params -- url query parameters
 * @param clazz -- class of the resource object to be returned
 * @param apiKey -- optional parameter if you want to override apiKey
 * @return <Resource>Collection of type class that you pass in
 * @throws APIException
 * @throws AuthenticationException
 * @throws InvalidRequestException
 * @throws APIConnectionException
 */
protected static <T>T all(String path,Map<String,Object> params,Class<T> clazz,Map<String,String> keys) throws APIException, AuthenticationException, InvalidRequestException, APIConnectionException {
  System.out.println(path);
  KloudlessResponse response=request(RequestMethod.GET,path,params,keys);
  int rCode=response.responseCode;
  String rBody=response.responseBody;
  if (rCode < 200 || rCode >= 300) {
    handleAPIError(rBody,rCode);
  }
  return GSON.fromJson(rBody,clazz);
}","/** 
 * The all() method is a ""mixin"" that allows for a list of objects to be returned. By passing in a class and path url, the list of objects is abstracted away along with the http requests.  A JSON object will be returned with 
 * @param path -- url path for the list resource
 * @param params -- url query parameters
 * @param clazz -- class of the resource object to be returned
 * @param apiKey -- optional parameter if you want to override apiKey
 * @return <Resource>Collection of type class that you pass in
 * @throws APIException
 * @throws AuthenticationException
 * @throws InvalidRequestException
 * @throws APIConnectionException
 */
protected static <T>T all(String path,Map<String,Object> params,Class<T> clazz,Map<String,String> keys) throws APIException, AuthenticationException, InvalidRequestException, APIConnectionException {
  KloudlessResponse response=request(RequestMethod.GET,path,params,keys);
  int rCode=response.responseCode;
  String rBody=response.responseBody;
  if (rCode < 200 || rCode >= 300) {
    handleAPIError(rBody,rCode);
  }
  return GSON.fromJson(rBody,clazz);
}",0.9875222816399288
38067,"private static KloudlessResponse makeAppEngineRequest(RequestMethod method,Map<String,Object> params,String url,String query,Map<String,String> keys) throws APIException {
  String unknownErrorMessage=""String_Node_Str"" + ""String_Node_Str"";
  try {
    if (method == RequestMethod.GET || method == RequestMethod.DELETE) {
      url=String.format(""String_Node_Str"",url,query);
    }
    URL fetchURL=new URL(url);
    Class<?> requestMethodClass=Class.forName(""String_Node_Str"");
    Object httpMethod=requestMethodClass.getDeclaredField(method.name()).get(null);
    Class<?> fetchOptionsBuilderClass=Class.forName(""String_Node_Str"");
    Object fetchOptions=null;
    try {
      fetchOptions=fetchOptionsBuilderClass.getDeclaredMethod(""String_Node_Str"").invoke(null);
    }
 catch (    NoSuchMethodException e) {
      System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      fetchOptions=fetchOptionsBuilderClass.getDeclaredMethod(""String_Node_Str"").invoke(null);
    }
    Class<?> fetchOptionsClass=Class.forName(""String_Node_Str"");
    fetchOptionsClass.getDeclaredMethod(""String_Node_Str"",java.lang.Double.class).invoke(fetchOptions,new Double(55));
    Class<?> requestClass=Class.forName(""String_Node_Str"");
    Object request=requestClass.getDeclaredConstructor(URL.class,requestMethodClass,fetchOptionsClass).newInstance(fetchURL,httpMethod,fetchOptions);
    Map<String,String> extraHeaders=getHeaders(keys,url);
    if (query == null || query.length() == 0) {
      requestClass.getDeclaredMethod(""String_Node_Str"",byte[].class).invoke(request,GSON.toJson(params).getBytes());
      extraHeaders.put(""String_Node_Str"",String.format(""String_Node_Str"",CHARSET));
    }
 else {
      requestClass.getDeclaredMethod(""String_Node_Str"",byte[].class).invoke(request,query.getBytes());
    }
    for (    Map.Entry<String,String> header : extraHeaders.entrySet()) {
      Class<?> httpHeaderClass=Class.forName(""String_Node_Str"");
      Object reqHeader=httpHeaderClass.getDeclaredConstructor(String.class,String.class).newInstance(header.getKey(),header.getValue());
      requestClass.getDeclaredMethod(""String_Node_Str"",httpHeaderClass).invoke(request,reqHeader);
    }
    for (    Map.Entry<String,String> header : Kloudless.customHeaders.entrySet()) {
      Class<?> httpHeaderClass=Class.forName(""String_Node_Str"");
      Object reqHeader=httpHeaderClass.getDeclaredConstructor(String.class,String.class).newInstance(header.getKey(),header.getValue());
      requestClass.getDeclaredMethod(""String_Node_Str"",httpHeaderClass).invoke(request,reqHeader);
    }
    Class<?> urlFetchFactoryClass=Class.forName(""String_Node_Str"");
    Object urlFetchService=urlFetchFactoryClass.getDeclaredMethod(""String_Node_Str"").invoke(null);
    Method fetchMethod=urlFetchService.getClass().getDeclaredMethod(""String_Node_Str"",requestClass);
    fetchMethod.setAccessible(true);
    Object response=fetchMethod.invoke(urlFetchService,request);
    Map<String,List<String>> headers=new HashMap<String,List<String>>();
    int responseCode=(Integer)response.getClass().getDeclaredMethod(""String_Node_Str"").invoke(response);
    String body;
    byte[] responseBytes=(byte[])response.getClass().getDeclaredMethod(""String_Node_Str"").invoke(response);
    if (responseBytes == null)     body=""String_Node_Str"";
 else     body=new String(responseBytes,CHARSET);
    ByteArrayOutputStream responseStream=new ByteArrayOutputStream(responseBytes.length);
    responseStream.write(responseBytes,0,responseBytes.length);
    return new KloudlessResponse(responseCode,body,headers,responseStream);
  }
 catch (  InvocationTargetException e) {
    throw new APIException(unknownErrorMessage,e);
  }
catch (  MalformedURLException e) {
    throw new APIException(unknownErrorMessage,e);
  }
catch (  NoSuchFieldException e) {
    throw new APIException(unknownErrorMessage,e);
  }
catch (  SecurityException e) {
    throw new APIException(unknownErrorMessage,e);
  }
catch (  NoSuchMethodException e) {
    throw new APIException(unknownErrorMessage,e);
  }
catch (  ClassNotFoundException e) {
    throw new APIException(unknownErrorMessage,e);
  }
catch (  IllegalArgumentException e) {
    throw new APIException(unknownErrorMessage,e);
  }
catch (  IllegalAccessException e) {
    throw new APIException(unknownErrorMessage,e);
  }
catch (  InstantiationException e) {
    throw new APIException(unknownErrorMessage,e);
  }
catch (  UnsupportedEncodingException e) {
    throw new APIException(unknownErrorMessage,e);
  }
}","private static KloudlessResponse makeAppEngineRequest(RequestMethod method,Map<String,Object> params,String url,String query,Map<String,String> keys) throws APIException {
  String unknownErrorMessage=""String_Node_Str"" + ""String_Node_Str"";
  try {
    if (method == RequestMethod.GET || method == RequestMethod.DELETE) {
      url=String.format(""String_Node_Str"",url,query);
    }
    URL fetchURL=new URL(url);
    Class<?> requestMethodClass=Class.forName(""String_Node_Str"");
    Object httpMethod=requestMethodClass.getDeclaredField(method.name()).get(null);
    Class<?> fetchOptionsBuilderClass=Class.forName(""String_Node_Str"");
    Object fetchOptions=null;
    try {
      fetchOptions=fetchOptionsBuilderClass.getDeclaredMethod(""String_Node_Str"").invoke(null);
    }
 catch (    NoSuchMethodException e) {
      System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      fetchOptions=fetchOptionsBuilderClass.getDeclaredMethod(""String_Node_Str"").invoke(null);
    }
    Class<?> fetchOptionsClass=Class.forName(""String_Node_Str"");
    fetchOptionsClass.getDeclaredMethod(""String_Node_Str"",java.lang.Double.class).invoke(fetchOptions,new Double(55));
    Class<?> requestClass=Class.forName(""String_Node_Str"");
    Object request=requestClass.getDeclaredConstructor(URL.class,requestMethodClass,fetchOptionsClass).newInstance(fetchURL,httpMethod,fetchOptions);
    Map<String,String> extraHeaders=getHeaders(keys,url);
    if (query == null || query.length() == 0) {
      requestClass.getDeclaredMethod(""String_Node_Str"",byte[].class).invoke(request,GSON.toJson(params).getBytes());
      extraHeaders.put(""String_Node_Str"",String.format(""String_Node_Str"",CHARSET));
    }
 else {
      requestClass.getDeclaredMethod(""String_Node_Str"",byte[].class).invoke(request,query.getBytes());
    }
    for (    Map.Entry<String,String> header : extraHeaders.entrySet()) {
      Class<?> httpHeaderClass=Class.forName(""String_Node_Str"");
      Object reqHeader=httpHeaderClass.getDeclaredConstructor(String.class,String.class).newInstance(header.getKey(),header.getValue());
      requestClass.getDeclaredMethod(""String_Node_Str"",httpHeaderClass).invoke(request,reqHeader);
    }
    for (    Map.Entry<String,String> header : Kloudless.customHeaders.entrySet()) {
      Class<?> httpHeaderClass=Class.forName(""String_Node_Str"");
      Object reqHeader=httpHeaderClass.getDeclaredConstructor(String.class,String.class).newInstance(header.getKey(),header.getValue());
      requestClass.getDeclaredMethod(""String_Node_Str"",httpHeaderClass).invoke(request,reqHeader);
    }
    Class<?> urlFetchFactoryClass=Class.forName(""String_Node_Str"");
    Object urlFetchService=urlFetchFactoryClass.getDeclaredMethod(""String_Node_Str"").invoke(null);
    Method fetchMethod=urlFetchService.getClass().getDeclaredMethod(""String_Node_Str"",requestClass);
    fetchMethod.setAccessible(true);
    Object response=fetchMethod.invoke(urlFetchService,request);
    Map<String,List<String>> headers=new HashMap<String,List<String>>();
    int responseCode=(Integer)response.getClass().getDeclaredMethod(""String_Node_Str"").invoke(response);
    String body=""String_Node_Str"";
    byte[] responseBytes=(byte[])response.getClass().getDeclaredMethod(""String_Node_Str"").invoke(response);
    ByteArrayOutputStream responseStream=new ByteArrayOutputStream(0);
    if (responseBytes != null) {
      body=new String(responseBytes,CHARSET);
      responseStream=new ByteArrayOutputStream(responseBytes.length);
      responseStream.write(responseBytes,0,responseBytes.length);
    }
    return new KloudlessResponse(responseCode,body,headers,responseStream);
  }
 catch (  InvocationTargetException e) {
    throw new APIException(unknownErrorMessage,e);
  }
catch (  MalformedURLException e) {
    throw new APIException(unknownErrorMessage,e);
  }
catch (  NoSuchFieldException e) {
    throw new APIException(unknownErrorMessage,e);
  }
catch (  SecurityException e) {
    throw new APIException(unknownErrorMessage,e);
  }
catch (  NoSuchMethodException e) {
    throw new APIException(unknownErrorMessage,e);
  }
catch (  ClassNotFoundException e) {
    throw new APIException(unknownErrorMessage,e);
  }
catch (  IllegalArgumentException e) {
    throw new APIException(unknownErrorMessage,e);
  }
catch (  IllegalAccessException e) {
    throw new APIException(unknownErrorMessage,e);
  }
catch (  InstantiationException e) {
    throw new APIException(unknownErrorMessage,e);
  }
catch (  UnsupportedEncodingException e) {
    throw new APIException(unknownErrorMessage,e);
  }
}",0.9645872163140008
38068,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  appContext=getApplicationContext();
  Toolbar toolbar=(Toolbar)findViewById(R.id.toolbar);
  setSupportActionBar(toolbar);
  settings=PreferenceManager.getDefaultSharedPreferences(getApplicationContext());
  if (!settings.contains(""String_Node_Str"")) {
    if (BuildConfig.FIXED_SCHOOL == null) {
      Intent intent=new Intent(this,SelectSchoolActivity.class);
      startActivity(intent);
      finish();
    }
 else {
      settings.edit().putString(""String_Node_Str"",BuildConfig.FIXED_SCHOOL).commit();
    }
  }
  if (!isTablet()) {
    vertretungFragment=new VertretungFragment();
    nachrichtenFragment=new NachrichtenFragment();
    addTab(""String_Node_Str"",vertretungFragment);
    addTab(""String_Node_Str"",nachrichtenFragment);
    tabs=(PagerSlidingTabStrip)findViewById(R.id.tabs);
    tabs.setViewPager(mViewPager);
    tabs.setOnPageChangeListener(adapter);
  }
 else {
    vertretungFragment=(VertretungFragment)getSupportFragmentManager().findFragmentById(R.id.vertretung_fragment);
    nachrichtenFragment=(NachrichtenFragment)getSupportFragmentManager().findFragmentById(R.id.nachrichten_fragment);
  }
  content=findViewById(R.id.content);
  pBar=(ProgressBar)findViewById(R.id.progressBar);
  showDialogs();
  if (savedInstanceState == null) {
    if (gcmRegistered) {
      new GetVertretungsplanTask().execute();
    }
    created=true;
  }
 else {
    Log.d(""String_Node_Str"",""String_Node_Str"");
    vertretungsplan=new Gson().fromJson(savedInstanceState.getString(""String_Node_Str""),Vertretungsplan.class);
  }
  FontUtils.setRobotoFont(this,findViewById(android.R.id.content));
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  appContext=getApplicationContext();
  Toolbar toolbar=(Toolbar)findViewById(R.id.toolbar);
  setSupportActionBar(toolbar);
  settings=PreferenceManager.getDefaultSharedPreferences(getApplicationContext());
  if (!settings.contains(""String_Node_Str"")) {
    if (BuildConfig.FIXED_SCHOOL == null) {
      Intent intent=new Intent(this,SelectSchoolActivity.class);
      startActivity(intent);
      finish();
    }
 else {
      settings.edit().putString(""String_Node_Str"",BuildConfig.FIXED_SCHOOL).commit();
    }
  }
  if (!isTablet()) {
    vertretungFragment=new VertretungFragment();
    nachrichtenFragment=new NachrichtenFragment();
    addTab(""String_Node_Str"",vertretungFragment);
    addTab(""String_Node_Str"",nachrichtenFragment);
    tabs=(PagerSlidingTabStrip)findViewById(R.id.tabs);
    tabs.setViewPager(mViewPager);
    tabs.setOnPageChangeListener(adapter);
  }
 else {
    vertretungFragment=(VertretungFragment)getSupportFragmentManager().findFragmentById(R.id.vertretung_fragment);
    nachrichtenFragment=(NachrichtenFragment)getSupportFragmentManager().findFragmentById(R.id.nachrichten_fragment);
  }
  content=findViewById(R.id.content);
  pBar=(ProgressBar)findViewById(R.id.progressBar);
  showDialogs();
  if (savedInstanceState == null) {
    if (gcmRegistered) {
      new GetVertretungsplanTask().execute();
    }
    created=true;
  }
 else {
    Log.d(""String_Node_Str"",""String_Node_Str"");
    vertretungsplan=new Gson().fromJson(savedInstanceState.getString(""String_Node_Str""),Vertretungsplan.class);
    if (vertretungsplan != null)     setVertretungsplan(vertretungsplan);
  }
  FontUtils.setRobotoFont(this,findViewById(android.R.id.content));
}",0.9787478460654796
38069,"/** 
 * Erzeugt einen Text, der die Vertretung beschreibt (ohne die Art und die Stunde).
 */
public String toString(){
  String string=""String_Node_Str"";
  if (containsInformation(subject)) {
    string+=subject;
    if (containsInformation(teacher))     string+=""String_Node_Str"" + teacher + ""String_Node_Str"";
  }
 else   if (containsInformation(teacher))   string+=teacher;
  if (containsInformation(previousSubject) && !(previousSubject.equals(subject) && (previousTeacher != null && previousTeacher.equals(teacher) || (previousTeacher == null && teacher == null)))) {
    if (containsInformation(subject))     string+=""String_Node_Str"" + previousSubject;
 else     string+=previousSubject;
    if (containsInformation(previousTeacher))     string+=""String_Node_Str"" + previousTeacher + ""String_Node_Str"";
  }
 else   if (!containsInformation(previousSubject) && containsInformation(previousTeacher)) {
    if (containsInformation(subject) || containsInformation(teacher))     string+=""String_Node_Str"" + previousTeacher;
 else     string+=previousTeacher;
  }
  if (containsInformation(room))   string+=""String_Node_Str"" + room;
  if (containsInformation(previousRoom) && !previousRoom.equals(room)) {
    if (containsInformation(room))     string+=""String_Node_Str"" + previousRoom;
 else     string+=""String_Node_Str"" + previousRoom;
  }
  if (containsInformation(desc)) {
    if (!string.equals(""String_Node_Str""))     string+=""String_Node_Str"";
    string+=desc;
  }
  return string;
}","/** 
 * Erzeugt einen Text, der die Vertretung beschreibt (ohne die Art und die Stunde).
 */
public String toString(){
  String string=""String_Node_Str"";
  if (containsInformation(subject)) {
    string+=subject;
    if (containsInformation(teacher))     string+=""String_Node_Str"" + teacher + ""String_Node_Str"";
  }
 else   if (containsInformation(teacher))   string+=teacher;
  if (containsInformation(previousSubject) && !(previousSubject.equals(subject) && (previousTeacher != null && previousTeacher.equals(teacher) || (previousTeacher == null && teacher == null)))) {
    if (containsInformation(subject) || containsInformation(teacher))     string+=""String_Node_Str"" + previousSubject;
 else     string+=previousSubject;
    if (containsInformation(previousTeacher))     string+=""String_Node_Str"" + previousTeacher + ""String_Node_Str"";
  }
 else   if (!containsInformation(previousSubject) && containsInformation(previousTeacher)) {
    if (containsInformation(subject) || containsInformation(teacher))     string+=""String_Node_Str"" + previousTeacher;
 else     string+=previousTeacher;
  }
  if (containsInformation(room))   string+=""String_Node_Str"" + room;
  if (containsInformation(previousRoom) && !previousRoom.equals(room)) {
    if (containsInformation(room))     string+=""String_Node_Str"" + previousRoom;
 else     string+=""String_Node_Str"" + previousRoom;
  }
  if (containsInformation(desc)) {
    if (!string.equals(""String_Node_Str""))     string+=""String_Node_Str"";
    string+=desc;
  }
  return string;
}",0.9893969516235918
38070,"private void insertDeviceInfo(String deviceInfo,String klasse,String schoolId,String login,String password,String registration) throws IOException {
  String url=BASE_URL + ""String_Node_Str"" + registration+ ""String_Node_Str""+ klasse+ ""String_Node_Str""+ schoolId+ ""String_Node_Str""+ deviceInfo+ ""String_Node_Str""+ URLEncoder.encode(login,""String_Node_Str"")+ ""String_Node_Str""+ URLEncoder.encode(password,""String_Node_Str"");
  Response response=new Request(url).getResource(""String_Node_Str"");
  if (response.getResponseCode() == 200) {
    Log.d(""String_Node_Str"",""String_Node_Str"");
  }
}","private void insertDeviceInfo(String deviceInfo,String klasse,String schoolId,String login,String password,String registration) throws IOException {
  String url=BASE_URL + ""String_Node_Str"" + URLEncoder.encode(registration,""String_Node_Str"")+ ""String_Node_Str""+ URLEncoder.encode(klasse,""String_Node_Str"")+ ""String_Node_Str""+ URLEncoder.encode(schoolId,""String_Node_Str"")+ ""String_Node_Str""+ URLEncoder.encode(deviceInfo,""String_Node_Str"")+ ""String_Node_Str""+ URLEncoder.encode(login,""String_Node_Str"")+ ""String_Node_Str""+ URLEncoder.encode(password,""String_Node_Str"");
  Response response=new Request(url).getResource(""String_Node_Str"");
  if (response.getResponseCode() == 200) {
    Log.d(""String_Node_Str"",""String_Node_Str"");
  }
}",0.7930513595166163
38071,"@Override protected void onHandleIntent(Intent intent){
  context=this;
  settings=PreferenceManager.getDefaultSharedPreferences(getApplicationContext());
  extras=intent.getExtras();
  Gson gson=new Gson();
  boolean autoSync;
  try {
    autoSync=extras.getBoolean(""String_Node_Str"");
  }
 catch (  NullPointerException e) {
    autoSync=false;
  }
  ConnectivityManager conMan=(ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE);
  State wifi=conMan.getNetworkInfo(1).getState();
  if (wifi == NetworkInfo.State.CONNECTED || autoSync == false || settings.getBoolean(""String_Node_Str"",false) == false) {
    Log.d(""String_Node_Str"",""String_Node_Str"" + wifi);
    Log.d(""String_Node_Str"",""String_Node_Str"" + autoSync);
    Log.d(""String_Node_Str"",""String_Node_Str"" + Boolean.valueOf(settings.getBoolean(""String_Node_Str"",false)));
    Log.d(""String_Node_Str"",""String_Node_Str"");
    try {
      BaseParser parser=((VertretungsplanApplication)getApplication()).getParser();
      if (parser == null)       return;
      Vertretungsplan v=parser.getVertretungsplan();
      int result=RESULT_OK;
      if (extras != null && extras.get(""String_Node_Str"") != null) {
        nachrichtAnApp(extras,result,v);
      }
      if ((extras == null || extras.getBoolean(KEY_NOTIFICATION,true)) && settings.getBoolean(""String_Node_Str"",true) && !settings.getBoolean(""String_Node_Str"",false)) {
        String klasse=settings.getString(""String_Node_Str"",null);
        String vAltJson=settings.getString(""String_Node_Str"",null);
        if (klasse != null && vAltJson != null) {
          Vertretungsplan vAlt=gson.fromJson(vAltJson,Vertretungsplan.class);
          if (somethingChanged(vAlt,v,klasse)) {
            benachrichtigung();
          }
        }
      }
      settings.edit().putString(""String_Node_Str"",gson.toJson(v)).commit();
      AppWidgetManager mgr=AppWidgetManager.getInstance(this);
      int[] ids=mgr.getAppWidgetIds(new ComponentName(this,VertretungsplanWidgetProvider.class));
      new VertretungsplanWidgetProvider().onUpdate(this,mgr,ids);
    }
 catch (    IOException|JSONException e) {
      e.printStackTrace();
      int result=RESULT_ERROR;
      if (extras != null && extras.get(""String_Node_Str"") != null) {
        nachrichtAnApp(extras,result,null);
      }
    }
catch (    VersionException e) {
      int result=RESULT_VERSION_ERROR;
      if (extras != null && extras.get(""String_Node_Str"") != null) {
        nachrichtAnApp(extras,result,null);
      }
    }
catch (    UnauthorizedException e) {
      int result=RESULT_UNAUTHORIZED_ERROR;
      if (extras != null && extras.get(""String_Node_Str"") != null) {
        nachrichtAnApp(extras,result,null);
      }
    }
  }
}","@Override protected void onHandleIntent(Intent intent){
  context=this;
  settings=PreferenceManager.getDefaultSharedPreferences(getApplicationContext());
  extras=intent.getExtras();
  Gson gson=new Gson();
  boolean autoSync;
  try {
    autoSync=extras.getBoolean(""String_Node_Str"");
  }
 catch (  NullPointerException e) {
    autoSync=false;
  }
  ConnectivityManager conMan=(ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE);
  State wifi=conMan.getNetworkInfo(1).getState();
  if (wifi == NetworkInfo.State.CONNECTED || autoSync == false || settings.getBoolean(""String_Node_Str"",false) == false) {
    Log.d(""String_Node_Str"",""String_Node_Str"" + wifi);
    Log.d(""String_Node_Str"",""String_Node_Str"" + autoSync);
    Log.d(""String_Node_Str"",""String_Node_Str"" + Boolean.valueOf(settings.getBoolean(""String_Node_Str"",false)));
    Log.d(""String_Node_Str"",""String_Node_Str"");
    try {
      BaseParser parser=((VertretungsplanApplication)getApplication()).getParser();
      if (parser == null)       return;
      Vertretungsplan v=parser.getVertretungsplan();
      settings.edit().putString(""String_Node_Str"",gson.toJson(v)).commit();
      AppWidgetManager mgr=AppWidgetManager.getInstance(this);
      int[] ids=mgr.getAppWidgetIds(new ComponentName(this,VertretungsplanWidgetProvider.class));
      new VertretungsplanWidgetProvider().onUpdate(this,mgr,ids);
    }
 catch (    IOException|JSONException e) {
      e.printStackTrace();
    }
catch (    VersionException e) {
    }
catch (    UnauthorizedException e) {
    }
  }
}",0.7274427302477794
38072,"public void refresh(){
  if (ready && v != null && getView() != null) {
    listadapter.clear();
    for (    VertretungsplanTag tag : v.getTage()) {
      listadapter.addSeparatorItem(tag.getDatum());
      for (      String message : tag.getNachrichten()) {
        listadapter.addItem(Html.fromHtml(message));
      }
      if (tag.getNachrichten().size() == 0)       listadapter.addItem(getResources().getString(R.string.no_info));
    }
    for (    AdditionalInfo info : v.getAdditionalInfos()) {
      listadapter.addSeparatorItem(info.getTitle());
      listadapter.addItem(info.getText());
    }
    progress(false);
  }
}","public void refresh(){
  progress(false);
  if (ready && v != null && getView() != null) {
    listadapter.clear();
    for (    VertretungsplanTag tag : v.getTage()) {
      listadapter.addSeparatorItem(tag.getDatum());
      for (      String message : tag.getNachrichten()) {
        listadapter.addItem(Html.fromHtml(message));
      }
      if (tag.getNachrichten().size() == 0)       listadapter.addItem(getResources().getString(R.string.no_info));
    }
    for (    AdditionalInfo info : v.getAdditionalInfos()) {
      listadapter.addSeparatorItem(info.getTitle());
      listadapter.addItem(info.getText());
    }
    progress(false);
  }
}",0.985167837626854
38073,"@Override public void onViewCreated(View view,Bundle savedInstanceState){
  progress(showProgress);
  ready=true;
  refresh();
  super.onViewCreated(view,savedInstanceState);
}","@Override public void onViewCreated(View view,Bundle savedInstanceState){
  progress(showProgress);
  ready=true;
  if (mCallback.getVertretungsplan() != null)   setVertretungsplan(mCallback.getVertretungsplan());
  super.onViewCreated(view,savedInstanceState);
}",0.724373576309795
38074,"public void refresh(){
  if (ready && v != null) {
    listadapter.clear();
    for (    VertretungsplanTag tag : v.getTage()) {
      listadapter.addSeparatorItem(tag.getDatum());
      for (      String message : tag.getNachrichten()) {
        listadapter.addItem(Html.fromHtml(message));
      }
      if (tag.getNachrichten().size() == 0)       listadapter.addItem(getResources().getString(R.string.no_info));
    }
    for (    AdditionalInfo info : v.getAdditionalInfos()) {
      listadapter.addSeparatorItem(info.getTitle());
      listadapter.addItem(info.getText());
    }
    progress(false);
  }
}","public void refresh(){
  if (ready && v != null && getView() != null) {
    listadapter.clear();
    for (    VertretungsplanTag tag : v.getTage()) {
      listadapter.addSeparatorItem(tag.getDatum());
      for (      String message : tag.getNachrichten()) {
        listadapter.addItem(Html.fromHtml(message));
      }
      if (tag.getNachrichten().size() == 0)       listadapter.addItem(getResources().getString(R.string.no_info));
    }
    for (    AdditionalInfo info : v.getAdditionalInfos()) {
      listadapter.addSeparatorItem(info.getTitle());
      listadapter.addItem(info.getText());
    }
    progress(false);
  }
}",0.983078162771958
38075,"public void refresh(){
  if (ready && v != null) {
    txtStand.setText(v.getTage().get(0).getStand());
    listadapter.clear();
    klasse=(String)klassen.getSelectedItem();
    for (    VertretungsplanTag tag : v.getTage()) {
      listadapter.addSeparatorItem(tag.getDatum());
      if (tag.getKlassen().get(klasse) != null) {
        if (tag.getKlassen().get(klasse).getVertretung().size() > 0) {
          for (          Vertretung item : tag.getKlassen().get(klasse).getVertretung()) {
            listadapter.addItem(item);
          }
        }
 else {
          listadapter.addTextItem(getResources().getString(R.string.no_info));
        }
      }
 else {
        listadapter.addTextItem(getResources().getString(R.string.no_info));
      }
    }
  }
}","public void refresh(){
  if (ready && v != null && getView() != null) {
    txtStand.setText(v.getTage().get(0).getStand());
    listadapter.clear();
    klasse=(String)klassen.getSelectedItem();
    for (    VertretungsplanTag tag : v.getTage()) {
      listadapter.addSeparatorItem(tag.getDatum());
      if (tag.getKlassen().get(klasse) != null) {
        if (tag.getKlassen().get(klasse).getVertretung().size() > 0) {
          for (          Vertretung item : tag.getKlassen().get(klasse).getVertretung()) {
            listadapter.addItem(item);
          }
        }
 else {
          listadapter.addTextItem(getResources().getString(R.string.no_info));
        }
      }
 else {
        listadapter.addTextItem(getResources().getString(R.string.no_info));
      }
    }
  }
}",0.6317152103559871
38076,"@Override protected void onPostExecute(List<String> result){
  if (result != null)   settings.edit().putString(""String_Node_Str"",new Gson().toJson(result)).commit();
 else   result=new Gson().fromJson(settings.getString(""String_Node_Str"",null),new TypeToken<List<String>>(){
  }
.getType());
  klasse=settings.getString(""String_Node_Str"",""String_Node_Str"");
  klassen.setAdapter(new ArrayAdapter<String>(getActivity(),android.R.layout.simple_spinner_dropdown_item,result));
  for (int i=0; i < klassen.getAdapter().getCount(); i++) {
    if (klassen.getAdapter().getItem(i).toString().equals(klasse)) {
      klassen.setSelection(i);
      break;
    }
  }
}","@Override protected void onPostExecute(List<String> result){
  if (getActivity() == null)   return;
  if (result != null)   settings.edit().putString(""String_Node_Str"",new Gson().toJson(result)).commit();
 else   result=new Gson().fromJson(settings.getString(""String_Node_Str"",null),new TypeToken<List<String>>(){
  }
.getType());
  klasse=settings.getString(""String_Node_Str"",""String_Node_Str"");
  klassen.setAdapter(new ArrayAdapter<String>(getActivity(),android.R.layout.simple_spinner_dropdown_item,result));
  for (int i=0; i < klassen.getAdapter().getCount(); i++) {
    if (klassen.getAdapter().getItem(i).toString().equals(klasse)) {
      klassen.setSelection(i);
      break;
    }
  }
}",0.9712177121771216
38077,"@Override public boolean onCommand(CommandPerformEvent event){
  if (event.getArgs().length == 1) {
    String username=event.getArgs()[0];
    if (!username.matches(""String_Node_Str"")) {
      event.respondWithPing(Colors.RED + ""String_Node_Str"");
      return true;
    }
    String uuid=""String_Node_Str"";
    boolean isValid;
    boolean hasPaid;
    try {
      UserProfile[] profiles=getProfiles(username);
      if (profiles.length > 0) {
        uuid=profiles[0].id;
      }
      isValid=getPageContents(""String_Node_Str"" + username).equalsIgnoreCase(""String_Node_Str"");
      hasPaid=getPageContents(""String_Node_Str"" + username).equalsIgnoreCase(""String_Node_Str"");
    }
 catch (    UnirestException e) {
      throw new GenericUrlConnectionException(""String_Node_Str"" + username + ""String_Node_Str"",e);
    }
    String valid=isValid ? Colors.RED + ""String_Node_Str"" + Colors.NORMAL+ ""String_Node_Str"" : Colors.GREEN + ""String_Node_Str"" + Colors.NORMAL+ ""String_Node_Str"";
    String paid=hasPaid ? ""String_Node_Str"" + Colors.GREEN + ""String_Node_Str""+ Colors.NORMAL : Colors.RED + ""String_Node_Str"" + Colors.NORMAL;
    event.respond(""String_Node_Str"" + valid + ""String_Node_Str""+ paid+ ""String_Node_Str"",username,uuid);
    return true;
  }
  return false;
}","@Override public boolean onCommand(CommandPerformEvent event){
  if (event.getArgs().length == 1) {
    String username=event.getArgs()[0];
    if (!username.matches(""String_Node_Str"")) {
      event.respondWithPing(Colors.RED + ""String_Node_Str"");
      return true;
    }
    if (username.length() > 16) {
      event.respondWithPing(Colors.RED + ""String_Node_Str"");
      return true;
    }
    if (username.length() < 2) {
      event.respondWithPing(Colors.RED + ""String_Node_Str"");
      return true;
    }
    try {
      UserProfile[] profiles=getProfiles(username);
      if (profiles.length > 0) {
        String uuid=profiles[0].id;
        boolean hasPaid=getPageContents(""String_Node_Str"" + username).equalsIgnoreCase(""String_Node_Str"");
        String paid=hasPaid ? ""String_Node_Str"" + Colors.GREEN + ""String_Node_Str""+ Colors.NORMAL : Colors.RED + ""String_Node_Str"" + Colors.NORMAL;
        event.respond(""String_Node_Str"" + Colors.GREEN + ""String_Node_Str""+ Colors.NORMAL+ ""String_Node_Str""+ paid+ ""String_Node_Str"",username,uuid);
      }
 else {
        event.respond(""String_Node_Str"" + Colors.RED + ""String_Node_Str"",username);
      }
    }
 catch (    UnirestException e) {
      throw new GenericUrlConnectionException(""String_Node_Str"" + username + ""String_Node_Str"",e);
    }
    return true;
  }
  return false;
}",0.549559892843475
38078,"@Override public boolean onCommand(CommandPerformEvent event){
  if (event.getArgs().length == 1) {
    CommandModule module=event.getManager().getModuleFor(event.getArgs()[0]);
    if (module == null) {
      ArrayList<CommandModule> groupMatch=event.getManager().matchGroup(event.getArgs()[0]);
      if (groupMatch != null && !groupMatch.isEmpty()) {
        if (!event.isInPrivateMessage()) {
          event.respondWithPing(""String_Node_Str"");
        }
        event.respond(""String_Node_Str"" + StringUtil.combineSplit(0,groupMatch.toArray(new String[0]),""String_Node_Str""),event.getArgs()[0].toUpperCase());
        event.respond(""String_Node_Str"",event.getCommandPrefix() + ""String_Node_Str"");
        return true;
      }
      module=event.getManager().matchModule(event.getArgs()[0]);
      if (module == null) {
        event.errorWithPing(""String_Node_Str"",event.getArgs()[0]);
        return true;
      }
    }
    if (!event.isInPrivateMessage()) {
      event.respondWithPing(""String_Node_Str"");
    }
    event.respond(""String_Node_Str"",true,event.getCommandPrefix(),module.info().command(),module.info().help());
    event.respond(""String_Node_Str"",true,module.info().command(),StringUtil.combineSplit(0,module.info().aliases(),""String_Node_Str""));
    for (    String part : module.info().extendedHelp()) {
      event.respond(event.getManager().format(module,part),true);
    }
    return true;
  }
  if (!event.isInPrivateMessage()) {
    event.respondWithPing(""String_Node_Str"");
  }
  List<String> commands=new ArrayList<>();
  for (  CommandModule module : event.getManager().getRegisteredCommands()) {
    List<CommandGroup> groups=Arrays.asList(module.info().groups());
    if (!groups.contains(CommandGroup.ALL)) {
      continue;
    }
    commands.add(module.info().command());
  }
  event.respond(""String_Node_Str"" + StringUtil.combineSplit(0,commands.toArray(new String[0]),""String_Node_Str""));
  event.respond(""String_Node_Str"",event.getCommandPrefix() + ""String_Node_Str"");
  for (  Map.Entry<CommandGroup,ArrayList<CommandModule>> entry : event.getManager().getGroupsMap().entrySet()) {
    if (entry.getKey().exclude()) {
      continue;
    }
    ArrayList<CommandModule> modules=entry.getValue();
    if (!modules.isEmpty()) {
      event.respond(event.getManager().format(null,""String_Node_Str"" + entry.getKey() + ""String_Node_Str""+ (modules.size() > 1 ? ""String_Node_Str"" : ""String_Node_Str"")),true,modules.size() + ""String_Node_Str"");
    }
  }
  return true;
}","@Override public boolean onCommand(CommandPerformEvent event){
  if (event.getArgs().length == 1) {
    CommandModule module=event.getManager().getModuleFor(event.getArgs()[0]);
    if (module == null) {
      ArrayList<CommandModule> groupMatch=event.getManager().matchGroup(event.getArgs()[0]);
      if (groupMatch != null && !groupMatch.isEmpty()) {
        if (!event.isInPrivateMessage()) {
          event.respondWithPing(""String_Node_Str"");
        }
        ArrayList<String> groupCommands=new ArrayList<>();
        for (        CommandModule groupModule : groupMatch) {
          groupCommands.add(groupModule.info().command());
        }
        event.respond(""String_Node_Str"" + StringUtil.combineSplit(0,groupCommands.toArray(new String[0]),""String_Node_Str""),true,event.getArgs()[0].toUpperCase());
        event.respond(""String_Node_Str"",true,event.getCommandPrefix() + ""String_Node_Str"");
        return true;
      }
      module=event.getManager().matchModule(event.getArgs()[0]);
      if (module == null) {
        event.errorWithPing(""String_Node_Str"",event.getArgs()[0]);
        return true;
      }
    }
    if (!event.isInPrivateMessage()) {
      event.respondWithPing(""String_Node_Str"");
    }
    event.respond(""String_Node_Str"",true,event.getCommandPrefix(),module.info().command(),module.info().help());
    event.respond(""String_Node_Str"",true,module.info().command(),StringUtil.combineSplit(0,module.info().aliases(),""String_Node_Str""));
    for (    String part : module.info().extendedHelp()) {
      event.respond(event.getManager().format(module,part),true);
    }
    return true;
  }
  if (!event.isInPrivateMessage()) {
    event.respondWithPing(""String_Node_Str"");
  }
  List<String> commands=new ArrayList<>();
  for (  CommandModule module : event.getManager().getRegisteredCommands()) {
    List<CommandGroup> groups=Arrays.asList(module.info().groups());
    if (!groups.contains(CommandGroup.ALL)) {
      continue;
    }
    commands.add(module.info().command());
  }
  event.respond(""String_Node_Str"" + StringUtil.combineSplit(0,commands.toArray(new String[0]),""String_Node_Str""),true);
  event.respond(""String_Node_Str"",true,event.getCommandPrefix() + ""String_Node_Str"");
  for (  Map.Entry<CommandGroup,ArrayList<CommandModule>> entry : event.getManager().getGroupsMap().entrySet()) {
    if (entry.getKey().exclude()) {
      continue;
    }
    ArrayList<CommandModule> modules=entry.getValue();
    if (!modules.isEmpty()) {
      event.respond(event.getManager().format(null,""String_Node_Str"" + entry.getKey() + ""String_Node_Str""+ (modules.size() > 1 ? ""String_Node_Str"" : ""String_Node_Str"")),true,modules.size() + ""String_Node_Str"");
    }
  }
  return true;
}",0.9570716749712532
38079,"@Override public void publish(LogRecord record){
  if (Nexus.getInstance() == null || this.channelName == null) {
    return;
  }
  if (Nexus.getInstance().getChannel(this.channelName) == null) {
    return;
  }
  if (!isLoggable(record)) {
    return;
  }
  String[] parts=record.getMessage().split(""String_Node_Str"");
  for (int i=0; i < parts.length; i++) {
    String part=parts[i];
    Iterator<User> iter=Nexus.getInstance().getChannel(this.channelName).getUsers().iterator();
    while (iter.hasNext()) {
      User u=iter.next();
      part=part.replace(u.getNick(),StringUtil.removePing(u.getNick())).replace(u.getNick().toLowerCase(),StringUtil.removePing(u.getNick().toLowerCase()));
    }
    parts[i]=part;
  }
  String message=StringUtil.join(parts,""String_Node_Str"");
  for (  String exc : EXCLUSIONS) {
    if (message.toLowerCase().contains(exc.toLowerCase())) {
      return;
    }
  }
  Nexus.getInstance().send(this.channelName,message);
}","@Override public void publish(LogRecord record){
  if (Nexus.getInstance() == null || this.channelName == null) {
    return;
  }
  if (Nexus.getInstance().getChannel(this.channelName) == null) {
    return;
  }
  if (!isLoggable(record)) {
    return;
  }
  String[] parts=record.getMessage().split(""String_Node_Str"");
  for (int i=0; i < parts.length; i++) {
    String part=parts[i];
    Iterator<User> iter=Nexus.getInstance().getChannel(this.channelName).getUsers().iterator();
    while (iter.hasNext()) {
      User u=iter.next();
      part=part.replace(u.getNick(),StringUtil.removePing(u.getNick())).replace(u.getNick().toLowerCase(),StringUtil.removePing(u.getNick().toLowerCase()));
    }
    parts[i]=part;
  }
  String message=StringUtil.join(parts,""String_Node_Str"");
  for (  String exc : EXCLUSIONS) {
    if (message.toLowerCase().contains(exc.toLowerCase())) {
      return;
    }
  }
  Nexus.getInstance().sendIRC().message(this.channelName,message);
}",0.9932677369238736
38080,"@Override public void run(){
  while (running) {
    try {
      reader=new jline.console.ConsoleReader();
      reader.addCompleter(new FileNameCompleter());
      reader.setPrompt(""String_Node_Str"");
      String line;
      PrintWriter out=new PrintWriter(System.out);
      while ((line=reader.readLine(""String_Node_Str"")) != null) {
        if (Nexus.getInstance() != null) {
          if (line.equalsIgnoreCase(""String_Node_Str"") || line.equalsIgnoreCase(""String_Node_Str"") || line.equalsIgnoreCase(""String_Node_Str"")|| line.equalsIgnoreCase(""String_Node_Str"")) {
            Nexus.getInstance().endProcess();
          }
 else           if (line.toLowerCase().startsWith(""String_Node_Str"")) {
            if (line.contains(""String_Node_Str"")) {
              String[] parts=line.split(""String_Node_Str"");
              String channel=parts[1];
              Nexus.LOGGER.info(""String_Node_Str"" + channel);
              Nexus.getInstance().sendRaw().rawLineNow(""String_Node_Str"" + channel);
            }
 else {
              Nexus.LOGGER.info(""String_Node_Str"");
            }
          }
        }
        out.flush();
      }
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
 finally {
      if (reader != null) {
        try {
          reader.getTerminal().restore();
        }
 catch (        Exception e) {
          e.printStackTrace();
        }
      }
    }
  }
}","@Override public void run(){
  while (running) {
    try {
      reader=new jline.console.ConsoleReader();
      reader.addCompleter(new FileNameCompleter());
      reader.setPrompt(""String_Node_Str"");
      String line;
      PrintWriter out=new PrintWriter(System.out);
      while ((line=reader.readLine(""String_Node_Str"")) != null) {
        if (Nexus.getInstance() != null) {
          if (line.equalsIgnoreCase(""String_Node_Str"") || line.equalsIgnoreCase(""String_Node_Str"") || line.equalsIgnoreCase(""String_Node_Str"")|| line.equalsIgnoreCase(""String_Node_Str"")) {
            Nexus.getInstance().endProcess();
          }
 else           if (line.toLowerCase().startsWith(""String_Node_Str"")) {
            if (line.contains(""String_Node_Str"")) {
              String[] parts=line.split(""String_Node_Str"");
              String channel=parts[1];
              Nexus.LOGGER.info(""String_Node_Str"" + channel);
              Nexus.getInstance().sendIRC().joinChannel(channel);
            }
 else {
              Nexus.LOGGER.info(""String_Node_Str"");
            }
          }
        }
        out.flush();
      }
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
 finally {
      if (reader != null) {
        try {
          reader.getTerminal().restore();
        }
 catch (        Exception e) {
          e.printStackTrace();
        }
      }
    }
  }
}",0.9809558030901904
38081,"private void prepare(){
  Unirest.setTimeouts(10000,10000);
  Unirest.setDefaultHeader(""String_Node_Str"",getConfig().get(""String_Node_Str"",""String_Node_Str""));
  this.registerLogger();
  LOGGER.info(""String_Node_Str"");
  commandManager=new CommandManager();
  commandManager.registerDefaults();
  LOGGER.info(""String_Node_Str"");
  responseManager=new ResponseManager();
  responseManager.load();
  if (!this.config.getJenkinsUrl().isEmpty()) {
    LOGGER.info(""String_Node_Str"");
    this.jenkins=new Jenkins();
  }
  LOGGER.info(""String_Node_Str"");
  this.github=new GitHub();
  RemindCommand remindCommand=this.getCommandManager().getModuleOfType(RemindCommand.class);
  if (remindCommand != null) {
    LOGGER.info(""String_Node_Str"");
    remindCommand.loadReminders();
  }
  LOGGER.info(""String_Node_Str"");
  LOGGER.info(""String_Node_Str"");
  this.prepareConsoleReader();
  LOGGER.info(""String_Node_Str"");
  LOGGER.info(""String_Node_Str"" + config.getServer() + ""String_Node_Str""+ config.getChannels().size()+ ""String_Node_Str"");
  try {
    this.startBot();
  }
 catch (  IrcException|IOException ignored) {
  }
}","private void prepare(){
  Unirest.setTimeouts(10000,10000);
  Unirest.setDefaultHeader(""String_Node_Str"",getConfig().get(""String_Node_Str"",""String_Node_Str""));
  this.registerLogger();
  LOGGER.info(""String_Node_Str"");
  commandManager=new CommandManager();
  commandManager.registerDefaults();
  LOGGER.info(""String_Node_Str"");
  responseManager=new ResponseManager();
  responseManager.load();
  if (!this.config.getJenkinsUrl().isEmpty()) {
    LOGGER.info(""String_Node_Str"");
    this.jenkins=new Jenkins();
  }
  LOGGER.info(""String_Node_Str"");
  this.github=new GitHub();
  RemindCommand remindCommand=this.getCommandManager().getModuleOfType(RemindCommand.class);
  if (remindCommand != null) {
    LOGGER.info(""String_Node_Str"");
    remindCommand.loadReminders();
  }
  LOGGER.info(""String_Node_Str"");
  LOGGER.info(""String_Node_Str"");
  this.prepareConsoleReader();
  ColorUtil.validColours();
  LOGGER.info(""String_Node_Str"");
  LOGGER.info(""String_Node_Str"" + config.getServer() + ""String_Node_Str""+ config.getChannels().size()+ ""String_Node_Str"");
  try {
    this.startBot();
  }
 catch (  IrcException|IOException ignored) {
  }
}",0.9876215738284704
38082,"public static void endProcess(){
  if (INSTANCE != null) {
    try {
      LOGGER.info(""String_Node_Str"");
      INSTANCE.saveAll();
      try {
        if (Jenkins.getJenkins() != null && Jenkins.getJenkins().TASK != null) {
          Jenkins.getJenkins().TASK.cancel();
        }
        if (GitHub.getGitHub().TASK != null) {
          GitHub.getGitHub().TASK.cancel();
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
      try {
        Unirest.shutdown();
      }
 catch (      Exception e) {
        LOGGER.severe(""String_Node_Str"");
        e.printStackTrace();
      }
      LOGGER.info(""String_Node_Str"");
      TimeoutUtil.timeout(new Thread(){
        @Override public void run(){
          while (INSTANCE.sendRaw().getOutgoingQueueSize() > 0)           ;
        }
      }
,TimeUtil.convert(5,'s'));
      INSTANCE.shutdown(true);
      try {
        INSTANCE.consoleReader.reader.getTerminal().restore();
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
      INSTANCE.consoleReader.setRunning(false);
      INSTANCE.channelLogHandler.close();
      INSTANCE=null;
      LOGGER.info(""String_Node_Str"");
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
 finally {
      System.exit(-1);
      LOGGER.info(""String_Node_Str"");
    }
  }
}","public static void endProcess(){
  if (INSTANCE != null) {
    try {
      LOGGER.info(""String_Node_Str"");
      INSTANCE.channelLogHandler.close();
      INSTANCE.saveAll();
      try {
        if (Jenkins.getJenkins() != null && Jenkins.getJenkins().TASK != null) {
          Jenkins.getJenkins().TASK.cancel();
        }
        if (GitHub.getGitHub().TASK != null) {
          GitHub.getGitHub().TASK.cancel();
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
      try {
        Unirest.shutdown();
      }
 catch (      Exception e) {
        LOGGER.severe(""String_Node_Str"");
        e.printStackTrace();
      }
      try {
        INSTANCE.consoleReader.reader.getTerminal().restore();
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
      INSTANCE.consoleReader.setRunning(false);
      INSTANCE.shutdown(true);
      INSTANCE=null;
      LOGGER.info(""String_Node_Str"");
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
 finally {
      System.exit(-1);
    }
  }
}",0.634453781512605
38083,"@Override public void run(){
  while (INSTANCE.sendRaw().getOutgoingQueueSize() > 0)   ;
}","@Override public void run(){
  for (  String channel : getConfig().getChannels()) {
    if (getChannel(channel) == null) {
      sendIRC().joinChannel(channel);
    }
  }
}",0.4122137404580153
38084,"public void onConnect(){
  registerChannelLogger();
  for (  String channel : getConfig().getChannels()) {
    if (getChannel(channel) == null) {
      sendRaw().rawLineNow(""String_Node_Str"" + channel);
    }
  }
  if (!getConfig().getStartupMessage().isEmpty()) {
    send(getConfig().getAdminChannel(),getConfig().getStartupMessage());
  }
}","public void onConnect(){
  registerChannelLogger();
  new Thread(new Runnable(){
    @Override public void run(){
      for (      String channel : getConfig().getChannels()) {
        if (getChannel(channel) == null) {
          sendIRC().joinChannel(channel);
        }
      }
    }
  }
).start();
  if (!getConfig().getStartupMessage().isEmpty()) {
    sendIRC().message(getConfig().getAdminChannel(),getConfig().getStartupMessage());
  }
}",0.7445997458703939
38085,"public boolean onCommand(CommandPerformEvent event){
  try {
    CommandModule module=this.getModuleFor(event.getCommand());
    if (module == null) {
      ArrayList<CommandModule> dynamicModules=getGroupsMap().get(CommandGroup.DYNAMIC);
      if (dynamicModules != null && !dynamicModules.isEmpty()) {
        module=matchModule(dynamicModules,event.getCommand());
      }
    }
    if (module != null) {
      ChannelConfiguration channelConfiguration=Nexus.getInstance().getChannelConfiguration();
      if (channelConfiguration.getChannel(""String_Node_Str"").isDisabled(module.info().command())) {
        return true;
      }
      if (!event.isInPrivateMessage() && !Arrays.asList(module.info().groups()).contains(CommandGroup.ADMIN)) {
        if (channelConfiguration.getChannel(event.getChannel().getName()).isDisabled(module.info().command())) {
          return true;
        }
      }
      if (module.checkPerm(event.getChannel(),event.getSender())) {
        if (module.info().needsChannel() && event.isInPrivateMessage()) {
          event.respond(""String_Node_Str"",event.getCommandPrefix() + module.info().command() + ""String_Node_Str""+ StringUtil.combineSplit(0,event.getArgs(),""String_Node_Str""));
          return true;
        }
        if (!module.onCommand(event)) {
          event.errorWithPing(""String_Node_Str"" + Nexus.getInstance().getConfig().getCommandPrefix() + ""String_Node_Str""+ formatHelp(module)+ ""String_Node_Str"",Nexus.getInstance().getConfig().getCommandPrefix() + ""String_Node_Str"" + event.getCommand());
        }
        Nexus.LOGGER.info(event.getSender().getNick() + ""String_Node_Str"" + (event.isInPrivateMessage() ? ""String_Node_Str"" : event.getChannel().getName())+ ""String_Node_Str""+ event.getCommand()+ ""String_Node_Str""+ StringUtil.combineSplit(0,event.getArgs(),""String_Node_Str""));
        return true;
      }
    }
  }
 catch (  Exception e) {
    if (e instanceof GitHubAPIKeyInvalidException) {
      event.errorWithPing(e.getMessage() + ""String_Node_Str"",Nexus.getInstance().getConfig().getCommandPrefix() + ""String_Node_Str"");
    }
 else     if (e instanceof DateParseException) {
      event.errorWithPing(e.getMessage());
    }
 else     if (e instanceof GitHubRateLimitExceededException) {
      event.errorWithPing(""String_Node_Str"");
    }
 else     if (e instanceof GitHubHookNotFoundException) {
      event.errorWithPing(e.getMessage());
    }
 else     if (e instanceof NumberFormatException) {
      event.errorWithPing(""String_Node_Str"");
    }
 else {
      if (Nexus.getInstance().getGitHubConfig().getNexusGitHubApiKey().isEmpty()) {
        e.printStackTrace();
        event.errorWithPing(""String_Node_Str"");
        return true;
      }
      event.errorWithPing(""String_Node_Str"" + GitHub.getGitHub().createGist(e));
    }
    return true;
  }
  return false;
}","public boolean onCommand(CommandPerformEvent event){
  try {
    CommandModule module=this.getModuleFor(event.getCommand());
    if (module == null) {
      ArrayList<CommandModule> dynamicModules=getGroupsMap().get(CommandGroup.DYNAMIC);
      if (dynamicModules != null && !dynamicModules.isEmpty()) {
        module=matchModule(dynamicModules,event.getCommand());
      }
    }
    if (module != null) {
      ChannelConfiguration channelConfiguration=Nexus.getInstance().getChannelConfiguration();
      if (channelConfiguration.getChannel(""String_Node_Str"").isDisabled(module.info().command())) {
        return true;
      }
      if (!event.isInPrivateMessage() && !Arrays.asList(module.info().groups()).contains(CommandGroup.ADMIN)) {
        if (channelConfiguration.getChannel(event.getChannel().getName()).isDisabled(module.info().command())) {
          return true;
        }
      }
      if (module.checkPerm(event.getChannel(),event.getSender())) {
        if (module.info().needsChannel() && event.isInPrivateMessage()) {
          Nexus.LOGGER.info(event.getSender().getNick() + ""String_Node_Str"" + (event.isInPrivateMessage() ? ""String_Node_Str"" : event.getChannel().getName())+ ""String_Node_Str""+ event.getCommand()+ ""String_Node_Str""+ StringUtil.combineSplit(0,event.getArgs(),""String_Node_Str""));
          event.respond(""String_Node_Str"",event.getCommandPrefix() + module.info().command() + ""String_Node_Str""+ StringUtil.combineSplit(0,event.getArgs(),""String_Node_Str""));
          return true;
        }
        Nexus.LOGGER.info(event.getSender().getNick() + ""String_Node_Str"" + (event.isInPrivateMessage() ? ""String_Node_Str"" : event.getChannel().getName())+ ""String_Node_Str""+ event.getCommand()+ ""String_Node_Str""+ StringUtil.combineSplit(0,event.getArgs(),""String_Node_Str""));
        if (!module.onCommand(event)) {
          event.errorWithPing(""String_Node_Str"" + Nexus.getInstance().getConfig().getCommandPrefix() + ""String_Node_Str""+ formatHelp(module)+ ""String_Node_Str"",Nexus.getInstance().getConfig().getCommandPrefix() + ""String_Node_Str"" + event.getCommand());
        }
        return true;
      }
    }
  }
 catch (  Exception e) {
    if (e instanceof GitHubAPIKeyInvalidException) {
      event.errorWithPing(e.getMessage() + ""String_Node_Str"",Nexus.getInstance().getConfig().getCommandPrefix() + ""String_Node_Str"");
    }
 else     if (e instanceof DateParseException) {
      event.errorWithPing(e.getMessage());
    }
 else     if (e instanceof GitHubRateLimitExceededException) {
      event.errorWithPing(""String_Node_Str"");
    }
 else     if (e instanceof GitHubHookNotFoundException) {
      event.errorWithPing(e.getMessage());
    }
 else     if (e instanceof NumberFormatException) {
      event.errorWithPing(""String_Node_Str"");
    }
 else {
      if (Nexus.getInstance().getGitHubConfig().getNexusGitHubApiKey().isEmpty()) {
        e.printStackTrace();
        event.errorWithPing(""String_Node_Str"");
        return true;
      }
      try {
        event.errorWithPing(""String_Node_Str"" + GitHub.getGitHub().createGist(e));
      }
 catch (      Exception e1) {
        event.errorWithPing(""String_Node_Str"");
        e.printStackTrace();
      }
    }
    return true;
  }
  return false;
}",0.7550517496303598
38086,"protected boolean checkPerm(Channel channel,User sender){
  if (Nexus.getInstance().isAdmin(sender)) {
    return true;
  }
  if (adminOnly()) {
    Nexus.getInstance().send(sender.getNick(),Colors.RED + ""String_Node_Str"");
    return false;
  }
  return true;
}","protected boolean checkPerm(Channel channel,User sender){
  if (Nexus.getInstance().isAdmin(sender)) {
    return true;
  }
  if (adminOnly()) {
    Nexus.getInstance().sendIRC().message(sender.getNick(),Colors.RED + ""String_Node_Str"");
    return false;
  }
  return true;
}",0.9757914338919924
38087,"public CommandPerformEvent(Channel channel,User sender,String command,String... args){
  if (channel == null) {
    this.sender=sender;
    this.command=command;
    this.args=args;
    this.inPrivateMessage=true;
  }
 else {
    this.channel=channel;
    this.sender=sender;
    this.command=command;
    this.args=args;
  }
}","public CommandPerformEvent(Channel channel,User sender,String command,String... args){
  if (channel == null) {
    this.inPrivateMessage=true;
  }
 else {
    this.channel=channel;
  }
  this.sender=sender;
  this.command=command;
  this.args=args;
}",0.6470588235294118
38088,"public void respond(String message,boolean forcePrivateMessage){
  if (this.inPrivateMessage || forcePrivateMessage) {
    Nexus.getInstance().send(sender.getNick(),message);
  }
 else {
    Nexus.getInstance().send(channel.getName(),message);
  }
}","public void respond(String message,boolean forcePrivateMessage){
  if (this.inPrivateMessage || forcePrivateMessage) {
    Nexus.getInstance().sendIRC().message(sender.getNick(),message);
  }
 else {
    Nexus.getInstance().sendIRC().message(channel.getName(),message);
  }
}",0.950381679389313
38089,"public String getActionText(String... args){
  Validate.notNull(args);
  if (args.length < 1) {
    throw new InvalidInputException(""String_Node_Str"");
  }
  String sentenceList=StringUtil.buildSentenceList(args[0].split(""String_Node_Str""));
  String additional=""String_Node_Str"";
  if (args.length > 1) {
    additional+=StringUtil.join(Arrays.copyOfRange(args,1,args.length),""String_Node_Str"");
  }
  return verb + (isOverriden() ? ""String_Node_Str"" : ""String_Node_Str"") + sentenceList+ additional;
}","public String getActionText(String... args){
  Validate.notNull(args);
  if (args.length < 1) {
    throw new InvalidInputException(""String_Node_Str"");
  }
  String sentenceList=StringUtil.buildSentenceList(args[0].split(""String_Node_Str""));
  String additional=""String_Node_Str"";
  if (args.length > 1) {
    additional+=StringUtil.join(Arrays.copyOfRange(args,1,args.length),""String_Node_Str"");
  }
  return verb + (isOverriden() ? ""String_Node_Str"" : ""String_Node_Str"") + sentenceList+ prefix+ additional;
}",0.9920948616600792
38090,"public WhipCommand(){
  this.setVerb(""String_Node_Str"");
}","public WhipCommand(){
  this.setVerb(""String_Node_Str"");
  this.setPrefix(""String_Node_Str"");
}",0.7581699346405228
38091,"@Override public boolean onCommand(CommandPerformEvent event){
  if (event.getArgs().length != 1) {
    return false;
  }
  String channelName=event.getArgs()[0];
  if (!channelName.startsWith(""String_Node_Str"")) {
    channelName=""String_Node_Str"" + channelName;
  }
  event.respondWithPing(""String_Node_Str"" + channelName);
  Nexus.getInstance().sendRaw().rawLineNow(""String_Node_Str"" + channelName);
  return true;
}","@Override public boolean onCommand(CommandPerformEvent event){
  if (event.getArgs().length != 1) {
    return false;
  }
  String channelName=event.getArgs()[0];
  if (!channelName.startsWith(""String_Node_Str"")) {
    channelName=""String_Node_Str"" + channelName;
  }
  event.respondWithPing(""String_Node_Str"" + channelName);
  Nexus.getInstance().sendIRC().joinChannel(channelName);
  return true;
}",0.9352869352869352
38092,"@Override public boolean onCommand(CommandPerformEvent event){
  if (event.getArgs().length < 2) {
    return false;
  }
 else {
    String message=StringUtil.combineSplit(1,event.getArgs(),""String_Node_Str"");
    Nexus.getInstance().send(event.getArgs()[0],message);
    return true;
  }
}","@Override public boolean onCommand(CommandPerformEvent event){
  if (event.getArgs().length < 2) {
    return false;
  }
 else {
    String message=StringUtil.combineSplit(1,event.getArgs(),""String_Node_Str"");
    Nexus.getInstance().sendIRC().message(event.getArgs()[0],message);
    return true;
  }
}",0.9780775716694772
38093,"public String appendReplacements(CommandPerformEvent event){
  String response=ResponseFormatter.appendReplacements(this.response,event.getSender(),event.getChannel());
  Matcher matcher=Pattern.compile(""String_Node_Str"").matcher(response);
  while (matcher.find()) {
    int index=StringUtil.toInteger(matcher.group(1));
    response=response.replace(matcher.group(),(index >= event.getArgs().length ? matcher.group(2) : event.getArgs()[index]));
  }
  return event.getManager().format(null,response);
}","public String appendReplacements(CommandPerformEvent event){
  String response=ResponseFormatter.appendReplacements(this.response,event.getSender(),event.getChannel());
  StringBuffer buffer=new StringBuffer();
  Matcher matcher=Pattern.compile(""String_Node_Str"").matcher(response);
  while (matcher.find()) {
    int index=StringUtil.toInteger(matcher.group(1));
    matcher.appendReplacement(buffer,(index >= event.getArgs().length ? matcher.group(2) : event.getArgs()[index]));
  }
  matcher.appendTail(buffer);
  return event.getManager().format(null,buffer.toString());
}",0.8425925925925926
38094,"public void save(){
  PrintWriter writer=null;
  try {
    File commandsFolder=new File(""String_Node_Str"");
    if (!commandsFolder.exists()) {
      commandsFolder.mkdirs();
    }
    File saveFile=new File(commandsFolder,command + ""String_Node_Str"");
    if (saveFile.exists()) {
      saveFile.delete();
    }
    saveFile.createNewFile();
    HashMap<String,Object> valueMap=new HashMap<>();
    valueMap.put(""String_Node_Str"",command);
    valueMap.put(""String_Node_Str"",response);
    valueMap.put(""String_Node_Str"",needsChannel);
    valueMap.put(""String_Node_Str"",help);
    valueMap.put(""String_Node_Str"",extendedHelp);
    valueMap.put(""String_Node_Str"",aliases);
    valueMap.put(""String_Node_Str"",action);
    valueMap.put(""String_Node_Str"",commandResponse);
    writer=new PrintWriter(saveFile);
    Yaml yaml=new Yaml();
    writer.write(yaml.dump(valueMap));
  }
 catch (  IOException e) {
    Nexus.LOGGER.severe(""String_Node_Str"" + command + ""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (writer != null) {
      writer.close();
    }
  }
}","public void save(){
  PrintWriter writer=null;
  try {
    File commandsFolder=new File(""String_Node_Str"");
    if (!commandsFolder.exists()) {
      commandsFolder.mkdirs();
    }
    File saveFile=new File(commandsFolder,command + ""String_Node_Str"");
    if (saveFile.exists()) {
      saveFile.delete();
    }
    saveFile.createNewFile();
    HashMap<String,Object> valueMap=new HashMap<>();
    valueMap.put(""String_Node_Str"",ColorUtil.serialise(command));
    valueMap.put(""String_Node_Str"",ColorUtil.serialise(response));
    valueMap.put(""String_Node_Str"",needsChannel);
    valueMap.put(""String_Node_Str"",ColorUtil.serialise(help));
    valueMap.put(""String_Node_Str"",ColorUtil.serialise(extendedHelp));
    valueMap.put(""String_Node_Str"",aliases.length <= 0 ? new String[0] : ColorUtil.serialise(aliases)[0]);
    valueMap.put(""String_Node_Str"",action);
    valueMap.put(""String_Node_Str"",commandResponse);
    writer=new PrintWriter(saveFile);
    Yaml yaml=new Yaml();
    writer.write(yaml.dump(valueMap));
  }
 catch (  IOException e) {
    Nexus.LOGGER.severe(""String_Node_Str"" + command + ""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (writer != null) {
      writer.close();
    }
  }
}",0.9235447437011296
38095,"public static void loadCommands(){
  File commandsFolder=new File(""String_Node_Str"");
  if (!commandsFolder.exists()) {
    commandsFolder.mkdirs();
  }
  for (  File file : commandsFolder.listFiles()) {
    int extIndex=file.getName().lastIndexOf(""String_Node_Str"");
    String extension=""String_Node_Str"";
    if (extIndex > 0) {
      extension=file.getName().substring(extIndex + 1);
    }
    if (extension.equalsIgnoreCase(""String_Node_Str"")) {
      try {
        FileInputStream input=new FileInputStream(file);
        Yaml yaml=new Yaml();
        Map<String,Object> data=(Map<String,Object>)yaml.load(input);
        if (data != null && !data.isEmpty()) {
          try {
            ArrayList<String> extendedHelp=(ArrayList<String>)data.get(""String_Node_Str"");
            ArrayList<String> aliases=(ArrayList<String>)data.get(""String_Node_Str"");
            Nexus.getInstance().getCommandManager().register(new DynamicCommand((String)data.get(""String_Node_Str""),(String)data.get(""String_Node_Str""),(Boolean)data.get(""String_Node_Str""),(String)data.get(""String_Node_Str""),extendedHelp.toArray(new String[extendedHelp.size()]),aliases.toArray(new String[aliases.size()]),(Boolean)data.get(""String_Node_Str""),(Boolean)data.get(""String_Node_Str"")));
          }
 catch (          Exception e) {
            e.printStackTrace();
          }
        }
      }
 catch (      FileNotFoundException e) {
        Nexus.LOGGER.severe(""String_Node_Str"" + file.getName().substring(0) + ""String_Node_Str"");
        e.printStackTrace();
      }
    }
  }
}","public static void loadCommands(){
  File commandsFolder=new File(""String_Node_Str"");
  if (!commandsFolder.exists()) {
    commandsFolder.mkdirs();
  }
  for (  File file : commandsFolder.listFiles()) {
    int extIndex=file.getName().lastIndexOf(""String_Node_Str"");
    String extension=""String_Node_Str"";
    if (extIndex > 0) {
      extension=file.getName().substring(extIndex + 1);
    }
    if (extension.equalsIgnoreCase(""String_Node_Str"")) {
      try {
        FileInputStream input=new FileInputStream(file);
        Yaml yaml=new Yaml();
        Map<String,Object> data=(Map<String,Object>)yaml.load(input);
        if (data != null && !data.isEmpty()) {
          try {
            Nexus.getInstance().getCommandManager().register(new DynamicCommand(ColorUtil.deserialise((String)data.get(""String_Node_Str"")),ColorUtil.deserialise((String)data.get(""String_Node_Str"")),(Boolean)data.get(""String_Node_Str""),ColorUtil.deserialise((String)data.get(""String_Node_Str"")),ColorUtil.deserialise(((ArrayList<String>)data.get(""String_Node_Str"")).toArray(new String[0])),ColorUtil.deserialise(((ArrayList<String>)data.get(""String_Node_Str"")).toArray(new String[0])),(Boolean)data.get(""String_Node_Str""),(Boolean)data.get(""String_Node_Str"")));
          }
 catch (          Exception e) {
            Nexus.LOGGER.warning(""String_Node_Str"" + file.getName());
            e.printStackTrace();
          }
        }
      }
 catch (      FileNotFoundException e) {
        Nexus.LOGGER.severe(""String_Node_Str"" + file.getName().substring(0) + ""String_Node_Str"");
        e.printStackTrace();
      }
    }
  }
}",0.6643489254108723
38096,"@Override public void run(){
  Nexus.getInstance().send(channelName.isEmpty() ? userToRemind : channelName,""String_Node_Str"" + userToRemind + ""String_Node_Str""+ Colors.BOLD+ reminder+ Colors.NORMAL+ ""String_Node_Str""+ (from.equals(userToRemind) ? ""String_Node_Str"" : ""String_Node_Str"" + StringUtil.removePing(from) + ""String_Node_Str""));
  this.cancel(true);
}","@Override public void run(){
  Nexus.getInstance().sendIRC().message(channelName.isEmpty() ? userToRemind : channelName,""String_Node_Str"" + userToRemind + ""String_Node_Str""+ Colors.BOLD+ reminder+ Colors.NORMAL+ ""String_Node_Str""+ (from.equals(userToRemind) ? ""String_Node_Str"" : ""String_Node_Str"" + StringUtil.removePing(from) + ""String_Node_Str""));
  this.cancel(true);
}",0.9822646657571624
38097,"protected GitHubUser getReporterOf(GitHubIssue issue,String userLogin){
  try {
    HttpResponse<JsonNode> response=makeRequest(getIssuesUrl(issue.getRepo().getFullName(),issue.getNumber()),userLogin);
    return getUser(response.getBody().getObject().getJSONObject(""String_Node_Str"").getString(""String_Node_Str""),userLogin);
  }
 catch (  UnirestException e) {
    if (e.getCause() instanceof FileNotFoundException) {
      throw new GitHubNotFoundException(""String_Node_Str"" + issue.getRepo().getFullName(),e);
    }
    throw new GitHubException(""String_Node_Str"",e);
  }
}","protected GitHubUser getReporterOf(GitHubIssue issue,String userLogin){
  try {
    String issueUrl=issue instanceof GitHubPullRequest ? getPullsUrl(issue.getRepo().getFullName(),issue.getNumber()) : getIssuesUrl(issue.getRepo().getFullName(),issue.getNumber());
    HttpResponse<JsonNode> response=makeRequest(issueUrl,userLogin);
    return getUser(response.getBody().getObject().getJSONObject(""String_Node_Str"").getString(""String_Node_Str""),userLogin);
  }
 catch (  UnirestException e) {
    if (e.getCause() instanceof FileNotFoundException) {
      throw new GitHubNotFoundException(""String_Node_Str"" + issue.getRepo().getFullName(),e);
    }
    throw new GitHubException(""String_Node_Str"",e);
  }
}",0.3260530421216848
38098,"protected String getNestedUsage(String[] args,int level,Method method,User user) throws CommandException {
  StringBuilder command=new StringBuilder();
  command.append(Nexus.getInstance().getConfig().getCommandPrefix());
  for (int i=0; i <= level; ++i) {
    command.append(args[i] + ""String_Node_Str"");
  }
  Map<String,Method> map=commands.get(method);
  boolean found=false;
  command.append(""String_Node_Str"");
  Set<String> allowedCommands=new HashSet<String>();
  for (  Map.Entry<String,Method> entry : map.entrySet()) {
    Method childMethod=entry.getValue();
    found=true;
    if (hasPermission(user,childMethod)) {
      Command childCmd=childMethod.getAnnotation(Command.class);
      allowedCommands.add(childCmd.aliases()[0]);
    }
  }
  if (allowedCommands.size() > 0) {
    command.append(StringUtils.join(allowedCommands,""String_Node_Str""));
  }
 else {
    if (!found) {
      command.append(""String_Node_Str"");
    }
 else {
      throw new CommandPermissionsException();
    }
  }
  command.append(""String_Node_Str"");
  return command.toString();
}","protected String getNestedUsage(String[] args,int level,Method method,User user) throws CommandException {
  StringBuilder command=new StringBuilder();
  command.append(Nexus.getInstance().getConfig().getCommandPrefix());
  for (int i=0; i <= level; ++i) {
    command.append(args[i] + ""String_Node_Str"");
  }
  Map<String,Method> map=commands.get(method);
  boolean found=false;
  command.append(""String_Node_Str"");
  Set<String> allowedCommands=new HashSet<String>();
  for (  Map.Entry<String,Method> entry : map.entrySet()) {
    Method childMethod=entry.getValue();
    found=true;
    if (hasPermission(user,childMethod)) {
      Command childCmd=childMethod.getAnnotation(Command.class);
      allowedCommands.add(childCmd.aliases()[0]);
    }
  }
  if (allowedCommands.size() > 0) {
    command.append(StringUtil.join(allowedCommands,""String_Node_Str""));
  }
 else {
    if (!found) {
      command.append(""String_Node_Str"");
    }
 else {
      throw new CommandPermissionsException();
    }
  }
  command.append(""String_Node_Str"");
  return command.toString();
}",0.9995337995337996
38099,"@Test public void convertShouldSucceed() throws ValidateException, InterruptedException, IOException {
  String res=Pyicos.runConvert(inSamFile.getCanonicalPath(),outWigFile.getCanonicalPath());
  assertTrue(outWigFile.exists());
  assertTrue(new File(res).exists());
}","@Test public void convertShouldSucceed() throws ValidateException, InterruptedException, IOException {
  String res=Pyicos.runConvert(inSamFile.getCanonicalPath(),outWigFile.getCanonicalPath(),true);
  assertTrue(outWigFile.exists());
  assertTrue(new File(res).exists());
}",0.990791896869245
38100,"@Test public void shouldRunStaticCall() throws ProcessException, IOException, InterruptedException {
  String inFile=""String_Node_Str"";
  String outFile=""String_Node_Str"";
  RawToProfileConverter.procedureRaw(bowtieParams,inFile,outFile,true,true,""String_Node_Str"",genomeBowtie2,""String_Node_Str"",""String_Node_Str"");
}","@Test public void shouldRunStaticCall() throws ProcessException, IOException, InterruptedException {
  String inFile=""String_Node_Str"";
  String outFile=""String_Node_Str"";
  RawToProfileConverter.procedureRaw(bowtieParams,inFile,outFile,true,true,true,""String_Node_Str"",genomeBowtie2,""String_Node_Str"",""String_Node_Str"");
}",0.9921996879875196
38101,"/** 
 * This method might be deleted or edited to be the new procedure. Work in progress atm with Adam
 * @param params Bowtie parameters
 * @param fastqFile The raw file which is to be processed.
 * @param sgrFile The name of the output file produced
 * @param keepSam Boolean telling whether intermediate .sam file should besaved.
 * @param genomeVersion Version of genome, not used at the moment.
 * @param referenceGenome Path to reference genome.
 * @param filepathRaw File path to experiment raw file directory
 * @param filepathProfile File path to experiment profile file directory
 * @return Processed files to save to database.
 * @throws ProcessException
 */
public static File[] procedureRaw(String params,String fastqFile,String sgrFile,boolean keepSam,boolean removeDups,String genomeVersion,String referenceGenome,String filepathRaw,String filepathProfile) throws ProcessException, InterruptedException, IOException {
  ArrayList<File> returnFiles=new ArrayList<>();
  new File(filepathProfile).mkdirs();
  Stack<String> toBeRemoved=new Stack<>();
  Stack<Map.Entry<String,String>> filesToSaveToExperiment=new Stack<>();
  String tmpDirPath=tempFolder + ""String_Node_Str"" + Thread.currentThread().getId()+ ""String_Node_Str"";
  createDirectory(tmpDirPath);
  filepathRaw=fixEndOfPath(filepathRaw);
  filepathProfile=fixEndOfPath(filepathProfile);
  fastqFile=filepathRaw + fastqFile;
  String samFile=tmpDirPath + FilenameUtils.getBaseName(sgrFile) + ""String_Node_Str"";
  String sortedSam=FilenameUtils.removeExtension(samFile) + ""String_Node_Str"";
  String sortedSamWithoutDups=FilenameUtils.removeExtension(samFile) + ""String_Node_Str"";
  ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
  Bowtie2 bowtieProcess=new Bowtie2(referenceGenome,null,null,fastqFile,samFile,params.split(""String_Node_Str""));
  try {
    bowtieProcess.validate();
  }
 catch (  ValidateException e) {
    ErrorLogger.log(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + bowtieProcess.toString() + ""String_Node_Str"");
    throw new ProcessException(e);
  }
  String bowtieReturnMessage=""String_Node_Str"";
  try {
    bowtieReturnMessage=bowtieProcess.execute();
    ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
  }
 catch (  InterruptedException|IOException e) {
    ErrorLogger.log(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + bowtieReturnMessage + ""String_Node_Str"");
    throw e;
  }
  try {
    ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
    Picard.runSortSam(samFile,sortedSam);
    toBeRemoved.push(samFile);
    ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
  }
 catch (  ValidateException e) {
    ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
    throw new ProcessException(e);
  }
catch (  InterruptedException|IOException e) {
    ErrorLogger.log(""String_Node_Str"",""String_Node_Str"" + e.getMessage());
    throw e;
  }
  if (removeDups) {
    try {
      ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      Picard.runRemoveDuplicates(sortedSam,sortedSamWithoutDups);
      ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      toBeRemoved.push(sortedSam);
    }
 catch (    ValidateException e) {
      ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      throw new ProcessException(e);
    }
catch (    IOException|InterruptedException e) {
      ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      ErrorLogger.log(""String_Node_Str"",e.getMessage());
      throw e;
    }
  }
 else {
    sortedSamWithoutDups=sortedSam;
  }
  try {
    ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
    Pyicos.runConvert(sortedSamWithoutDups,tmpDirPath + FilenameUtils.getBaseName(sgrFile) + ""String_Node_Str"");
    ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
  }
 catch (  ValidateException e) {
    ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
    ErrorLogger.log(""String_Node_Str"",e.getMessage());
    throw new ProcessException(e);
  }
catch (  InterruptedException|IOException e) {
    ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
    throw e;
  }
  ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
  ProfileDataConverter pdc=new ProfileDataConverter();
  String testSgrFile=pdc.wigToSgr(""String_Node_Str"",tmpDirPath + FilenameUtils.getBaseName(sgrFile) + ""String_Node_Str"");
  ErrorLogger.log(""String_Node_Str"",""String_Node_Str"" + testSgrFile + ""String_Node_Str""+ sgrFile);
  filesToSaveToExperiment.push(new AbstractMap.SimpleEntry<>(sgrFile,filepathProfile + FilenameUtils.getName(sgrFile)));
  if (keepSam) {
    ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
    filesToSaveToExperiment.push(new AbstractMap.SimpleEntry<>(sortedSamWithoutDups,filepathProfile + FilenameUtils.getName(sortedSamWithoutDups)));
  }
 else {
    toBeRemoved.push(sortedSamWithoutDups);
  }
  ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
  ErrorLogger.log(""String_Node_Str"",""String_Node_Str"" + filepathProfile + ""String_Node_Str"");
  for (  Map.Entry<String,String> filePair : filesToSaveToExperiment) {
    try {
      Debug.log(""String_Node_Str"" + filePair.getKey());
      Files.move(Paths.get(filePair.getKey()),Paths.get(filePair.getValue()));
      returnFiles.add(new File(filePair.getValue()));
    }
 catch (    IOException e) {
      ErrorLogger.log(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + filePair + ""String_Node_Str""+ filepathProfile);
      throw e;
    }
  }
  for (  String fileName : toBeRemoved) {
    File file=new File(fileName);
    Debug.log(""String_Node_Str"" + file.getCanonicalPath());
    file.delete();
  }
  return returnFiles.toArray(new File[returnFiles.size()]);
}","/** 
 * This method might be deleted or edited to be the new procedure. Work in progress atm with Adam
 * @param params Bowtie parameters
 * @param fastqFile The raw file which is to be processed.
 * @param sgrFile The name of the output file produced
 * @param keepSam Boolean telling whether intermediate .sam file should besaved.
 * @param genomeVersion Version of genome, not used at the moment.
 * @param referenceGenome Path to reference genome.
 * @param filepathRaw File path to experiment raw file directory
 * @param filepathProfile File path to experiment profile file directory
 * @return Processed files to save to database.
 * @throws ProcessException
 */
public static File[] procedureRaw(String params,String fastqFile,String sgrFile,boolean keepSam,boolean removeDups,String genomeVersion,String referenceGenome,String filepathRaw,String filepathProfile) throws ProcessException, InterruptedException, IOException {
  ArrayList<File> returnFiles=new ArrayList<>();
  new File(filepathProfile).mkdirs();
  Stack<String> toBeRemoved=new Stack<>();
  Stack<Map.Entry<String,String>> filesToSaveToExperiment=new Stack<>();
  String tmpDirPath=tempFolder + ""String_Node_Str"" + Thread.currentThread().getId()+ ""String_Node_Str"";
  createDirectory(tmpDirPath);
  filepathRaw=fixEndOfPath(filepathRaw);
  filepathProfile=fixEndOfPath(filepathProfile);
  fastqFile=filepathRaw + fastqFile;
  String samFile=tmpDirPath + FilenameUtils.getBaseName(sgrFile) + ""String_Node_Str"";
  String sortedSam=FilenameUtils.removeExtension(samFile) + ""String_Node_Str"";
  String sortedSamWithoutDups=FilenameUtils.removeExtension(samFile) + ""String_Node_Str"";
  ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
  Bowtie2 bowtieProcess=new Bowtie2(referenceGenome,null,null,fastqFile,samFile,params.split(""String_Node_Str""));
  try {
    bowtieProcess.validate();
  }
 catch (  ValidateException e) {
    ErrorLogger.log(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + bowtieProcess.toString() + ""String_Node_Str"");
    throw new ProcessException(e);
  }
  String bowtieReturnMessage=""String_Node_Str"";
  try {
    bowtieReturnMessage=bowtieProcess.execute();
    ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
  }
 catch (  InterruptedException|IOException e) {
    ErrorLogger.log(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + bowtieReturnMessage + ""String_Node_Str"");
    throw e;
  }
  try {
    ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
    Picard.runSortSam(samFile,sortedSam);
    toBeRemoved.push(samFile);
    ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
  }
 catch (  ValidateException e) {
    ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
    throw new ProcessException(e);
  }
catch (  InterruptedException|IOException e) {
    ErrorLogger.log(""String_Node_Str"",""String_Node_Str"" + e.getMessage());
    throw e;
  }
  if (removeDups) {
    try {
      ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      Picard.runRemoveDuplicates(sortedSam,sortedSamWithoutDups);
      ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      toBeRemoved.push(sortedSam);
    }
 catch (    ValidateException e) {
      ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      throw new ProcessException(e);
    }
catch (    IOException|InterruptedException e) {
      ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      ErrorLogger.log(""String_Node_Str"",e.getMessage());
      throw e;
    }
  }
 else {
    sortedSamWithoutDups=sortedSam;
  }
  try {
    ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
    Pyicos.runConvert(sortedSamWithoutDups,tmpDirPath + FilenameUtils.getBaseName(sgrFile) + ""String_Node_Str"");
    ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
  }
 catch (  ValidateException e) {
    ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
    ErrorLogger.log(""String_Node_Str"",e.getMessage());
    throw new ProcessException(e);
  }
catch (  InterruptedException|IOException e) {
    ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
    throw e;
  }
  ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
  ProfileDataConverter pdc=new ProfileDataConverter();
  String testSgrFile=pdc.wigToSgr(""String_Node_Str"",tmpDirPath + FilenameUtils.getBaseName(sgrFile) + ""String_Node_Str"");
  ErrorLogger.log(""String_Node_Str"",""String_Node_Str"" + testSgrFile + ""String_Node_Str""+ sgrFile);
  filesToSaveToExperiment.push(new AbstractMap.SimpleEntry<>(tmpDirPath + sgrFile,filepathProfile + FilenameUtils.getName(sgrFile)));
  if (keepSam) {
    ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
    filesToSaveToExperiment.push(new AbstractMap.SimpleEntry<>(sortedSamWithoutDups,filepathProfile + FilenameUtils.getName(sortedSamWithoutDups)));
  }
 else {
    toBeRemoved.push(sortedSamWithoutDups);
  }
  ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
  ErrorLogger.log(""String_Node_Str"",""String_Node_Str"" + filepathProfile + ""String_Node_Str"");
  for (  Map.Entry<String,String> filePair : filesToSaveToExperiment) {
    try {
      Debug.log(""String_Node_Str"" + filePair.getKey());
      Files.move(Paths.get(filePair.getKey()),Paths.get(filePair.getValue()));
      returnFiles.add(new File(filePair.getValue()));
    }
 catch (    IOException e) {
      ErrorLogger.log(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + filePair + ""String_Node_Str""+ filepathProfile);
      throw e;
    }
  }
  for (  String fileName : toBeRemoved) {
    File file=new File(fileName);
    Debug.log(""String_Node_Str"" + file.getCanonicalPath());
    file.delete();
  }
  return returnFiles.toArray(new File[returnFiles.size()]);
}",0.998847211137714
38102,"public String execute() throws IOException, InterruptedException {
  Debug.log(""String_Node_Str"" + outfileName);
  File profileFilesDir=new File(infile1).getParentFile();
  Debug.log(""String_Node_Str"" + profileFilesDir.getAbsolutePath());
  File workingDir=new File(""String_Node_Str"" + infile1.replaceAll(""String_Node_Str"",""String_Node_Str""));
  File resultsDir=new File(workingDir.getAbsolutePath() + ""String_Node_Str"");
  File ratioWrapper=new File(""String_Node_Str"");
  String output;
  try {
    output=executeCommand(new String[]{""String_Node_Str"",ratioWrapper.getAbsolutePath(),workingDir.getAbsolutePath() + ""String_Node_Str"",infile1,infile2,outfileName,mean.meanParam,""String_Node_Str"" + readsCutOff,chromosomes});
  }
 catch (  RuntimeException rte) {
    rte.printStackTrace();
    throw rte;
  }
  for (  File outFile : resultsDir.listFiles()) {
    if (outFile.getName().contains(""String_Node_Str"")) {
      File movedFile=new File(outfileName);
      Debug.log(""String_Node_Str"" + outFile.getAbsolutePath() + ""String_Node_Str""+ movedFile.getAbsolutePath());
      outFile.renameTo(movedFile);
    }
  }
  Debug.log(""String_Node_Str"" + workingDir.getAbsolutePath());
  FileUtils.deleteDirectory(workingDir);
  return output;
}","public String execute() throws IOException, InterruptedException {
  Debug.log(""String_Node_Str"" + outfileName);
  File profileFilesDir=new File(infile1).getParentFile();
  Debug.log(""String_Node_Str"" + profileFilesDir.getAbsolutePath());
  File workingDir=new File(""String_Node_Str"" + infile1.replaceAll(""String_Node_Str"",""String_Node_Str""));
  File resultsDir=new File(workingDir.getAbsolutePath() + ""String_Node_Str"");
  File ratioWrapper=new File(""String_Node_Str"");
  String output;
  try {
    output=executeCommand(new String[]{""String_Node_Str"",ratioWrapper.getAbsolutePath(),workingDir.getAbsolutePath() + ""String_Node_Str"",infile1,infile2,outfileName,mean.meanParam,""String_Node_Str"" + readsCutOff,chromosomes});
  }
 catch (  RuntimeException rte) {
    rte.printStackTrace();
    throw rte;
  }
  for (  File outFile : resultsDir.listFiles()) {
    if (outFile.getName().contains(""String_Node_Str"")) {
      File movedFile=new File(outfileName);
      Debug.log(""String_Node_Str"" + outFile.getAbsolutePath() + ""String_Node_Str""+ movedFile.getAbsolutePath());
      FileUtils.moveFile(outFile,movedFile);
    }
  }
  Debug.log(""String_Node_Str"" + workingDir.getAbsolutePath());
  FileUtils.deleteDirectory(workingDir);
  return output;
}",0.9823008849557522
38103,"@Override public void execute(){
  try {
    CommandTester.conn.sendRequest(new GetGenomeSpecieReleasesRequest(specie),CommandTester.token,Constants.TEXT_PLAIN);
    if (CommandTester.conn.getResponseCode() == 200) {
      String respBody=CommandTester.conn.getResponseBody();
      for (      String expectedStr : expected)       super.finalResult=respBody.contains(expectedStr);
    }
  }
 catch (  RequestException e) {
    if (super.expectedResult)     ErrorLogger.log(e);
  }
}","@Override public void execute(){
  try {
    CommandTester.conn.sendRequest(new GetGenomeSpecieReleasesRequest(specie),CommandTester.token,Constants.TEXT_PLAIN);
    if (CommandTester.conn.getResponseCode() == 200) {
      String respBody=CommandTester.conn.getResponseBody();
      super.finalResult=true;
      for (      String expectedStr : expected)       super.finalResult=(super.finalResult && respBody.contains(expectedStr));
    }
  }
 catch (  RequestException e) {
    if (super.expectedResult)     ErrorLogger.log(e);
  }
}",0.9478859390363816
38104,"@Ignore @Test @Ignore public void shouldProduceNewSamFile() throws ProcessException {
  String inFolder=""String_Node_Str"";
  String outFilePath=""String_Node_Str"";
  rtp.procedure(parameters,inFolder,outFilePath);
}","@Test @Ignore public void shouldProduceNewSamFile() throws ProcessException {
  String inFolder=""String_Node_Str"";
  String outFilePath=""String_Node_Str"";
  rtp.procedure(parameters,inFolder,outFilePath);
}",0.9523809523809524
38105,"@Override public Response execute(){
  Response response;
  try (DatabaseAccessor db=initDB()){
    if (!buildAnnotationList().containsAll(db.getAllForcedAnnotationLabels())) {
      response=new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + name + ""String_Node_Str""+ ""String_Node_Str"");
    }
 else {
      db.addExperiment(name);
      for (      Annotation annotation : annotations) {
        db.annotateExperiment(name,annotation.getName(),annotation.getValue());
      }
      response=new MinimalResponse(HttpStatusCode.OK);
    }
  }
 catch (  SQLException e) {
    response=new ErrorResponse(HttpStatusCode.INTERNAL_SERVER_ERROR,""String_Node_Str"" + name + ""String_Node_Str""+ ""String_Node_Str"");
    Debug.log(""String_Node_Str"" + e.getMessage());
  }
catch (  IOException e) {
    removeExperiment();
    response=new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + name + ""String_Node_Str""+ e.getMessage());
  }
  return response;
}","@Override public Response execute(){
  Response response;
  try (DatabaseAccessor db=initDB()){
    if (!buildAnnotationList().containsAll(db.getAllForcedAnnotationLabels())) {
      response=new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + name + ""String_Node_Str""+ ""String_Node_Str"");
    }
 else {
      db.addExperiment(name);
      try {
        for (        Annotation annotation : annotations) {
          db.annotateExperiment(name,annotation.getName(),annotation.getValue());
        }
      }
 catch (      IOException ie) {
        removeExperiment();
        throw ie;
      }
      response=new MinimalResponse(HttpStatusCode.OK);
    }
  }
 catch (  SQLException e) {
    response=new ErrorResponse(HttpStatusCode.INTERNAL_SERVER_ERROR,""String_Node_Str"" + name + ""String_Node_Str""+ ""String_Node_Str"");
    Debug.log(""String_Node_Str"" + e.getMessage());
  }
catch (  IOException e) {
    response=new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + name + ""String_Node_Str""+ e.getMessage());
  }
  return response;
}",0.9318854886475816
38106,"private String fetchRawFilesDirFromDB(String expId) throws IOException, SQLException {
  return initDB().getFilePathGenerator().getProfileFolderPath(expId);
}","private String fetchRawFilesDirFromDB(String expId) throws IOException, SQLException {
  return initDB().getFilePathGenerator().getRawFolderPath(expId);
}",0.967948717948718
38107,"/** 
 * Updates values of multiple annotations of a unique experiment.
 * @param expID the name of the experiment to annotate.
 * @param annotations the list of annotations to set. Should consist of objects of type Entry<String1, String2> where String1 is the label and key of the entry, and String2 is the value to assign to that label as well as the value of the entry.
 * @return the number of tuples updated in the database.
 * @throws SQLException if the query does not succeed
 * @throws IOException if the value is invalid for the annotation type.
 */
public int updateExperiment(String expID,HashMap<String,String> annotations) throws SQLException, IOException {
  for (  Entry<String,String> e : annotations.entrySet()) {
    String key=e.getKey();
    String value=e.getValue();
    validateAnnotation(key,value);
  }
  String query=""String_Node_Str"" + ""String_Node_Str"";
  int rs=0;
  try (PreparedStatement stmt=conn.prepareStatement(query)){
    conn.setAutoCommit(false);
    for (    Entry<String,String> e : annotations.entrySet()) {
      String key=e.getKey();
      String value=e.getValue();
      stmt.setString(1,value);
      stmt.setString(2,key);
      stmt.setString(3,expID);
      stmt.addBatch();
    }
    int arr[]=stmt.executeBatch();
    for (int i=0; i < arr.length; i++) {
      rs+=arr[i];
    }
    conn.commit();
  }
 catch (  SQLException e) {
    conn.rollback();
    throw e;
  }
 finally {
    conn.setAutoCommit(true);
  }
  return rs;
}","/** 
 * Updates values of multiple annotations of a unique experiment.
 * @param expID the name of the experiment to annotate.
 * @param annotations the list of annotations to set. Should consist of objects of type Entry<String1, String2> where String1 is the label and key of the entry, and String2 is the value to assign to that label as well as the value of the entry.
 * @return the number of tuples updated in the database.
 * @throws SQLException if the query does not succeed
 * @throws IOException if the value is invalid for the annotation type.
 */
public int updateExperiment(String expID,HashMap<String,String> annotations) throws SQLException, IOException {
  for (  Entry<String,String> e : annotations.entrySet()) {
    String key=e.getKey();
    String value=e.getValue();
    e.setValue(validateAnnotation(key,value));
  }
  String query=""String_Node_Str"" + ""String_Node_Str"";
  int rs=0;
  try (PreparedStatement stmt=conn.prepareStatement(query)){
    conn.setAutoCommit(false);
    for (    Entry<String,String> e : annotations.entrySet()) {
      String key=e.getKey();
      String value=e.getValue();
      stmt.setString(1,value);
      stmt.setString(2,key);
      stmt.setString(3,expID);
      stmt.addBatch();
    }
    int arr[]=stmt.executeBatch();
    for (int i=0; i < arr.length; i++) {
      rs+=arr[i];
    }
    conn.commit();
  }
 catch (  SQLException e) {
    conn.rollback();
    throw e;
  }
 finally {
    conn.setAutoCommit(true);
  }
  return rs;
}",0.9959623149394348
38108,"/** 
 * Updates values of multiple annotations of a unique experiment.
 * @param expID the name of the experiment to annotate.
 * @param annotations the list of annotations to set. Should consist of objects of type Entry<String1, String2> where String1 is the label and key of the entry, and String2 is the value to assign to that label as well as the value of the entry.
 * @return the number of tuples updated in the database.
 * @throws SQLException if the query does not succeed
 * @throws IOException if the value is invalid for the annotation type.
 */
public int updateExperiment(String expID,HashMap<String,String> annotations) throws SQLException, IOException {
  for (  Entry<String,String> e : annotations.entrySet()) {
    String key=e.getKey();
    String value=e.getValue();
    validateAnnotation(key,value);
  }
  String query=""String_Node_Str"" + ""String_Node_Str"";
  int rs=0;
  try (PreparedStatement stmt=conn.prepareStatement(query)){
    conn.setAutoCommit(false);
    for (    Entry<String,String> e : annotations.entrySet()) {
      String key=e.getKey();
      String value=e.getValue();
      stmt.setString(1,value);
      stmt.setString(2,key);
      stmt.setString(3,expID);
      stmt.addBatch();
    }
    int arr[]=stmt.executeBatch();
    for (int i=0; i < arr.length; i++) {
      rs+=arr[i];
    }
    conn.commit();
  }
 catch (  SQLException e) {
    conn.rollback();
    throw e;
  }
 finally {
    conn.setAutoCommit(true);
  }
  return rs;
}","/** 
 * Updates values of multiple annotations of a unique experiment.
 * @param expID the name of the experiment to annotate.
 * @param annotations the list of annotations to set. Should consist of objects of type Entry<String1, String2> where String1 is the label and key of the entry, and String2 is the value to assign to that label as well as the value of the entry.
 * @return the number of tuples updated in the database.
 * @throws SQLException if the query does not succeed
 * @throws IOException if the value is invalid for the annotation type.
 */
public int updateExperiment(String expID,HashMap<String,String> annotations) throws SQLException, IOException {
  for (  Entry<String,String> e : annotations.entrySet()) {
    String key=e.getKey();
    String value=e.getValue();
    e.setValue(validateAnnotation(key,value));
  }
  String query=""String_Node_Str"" + ""String_Node_Str"";
  int rs=0;
  try (PreparedStatement stmt=conn.prepareStatement(query)){
    conn.setAutoCommit(false);
    for (    Entry<String,String> e : annotations.entrySet()) {
      String key=e.getKey();
      String value=e.getValue();
      stmt.setString(1,value);
      stmt.setString(2,key);
      stmt.setString(3,expID);
      stmt.addBatch();
    }
    int arr[]=stmt.executeBatch();
    for (int i=0; i < arr.length; i++) {
      rs+=arr[i];
    }
    conn.commit();
  }
 catch (  SQLException e) {
    conn.rollback();
    throw e;
  }
 finally {
    conn.setAutoCommit(true);
  }
  return rs;
}",0.9959623149394348
38109,"@Override public void handle(HttpExchange exchange){
  Debug.log(""String_Node_Str"" + exchange.getRequestMethod() + ""String_Node_Str""+ exchange.getRequestURI().toString());
  String key=exchange.getRequestMethod() + ""String_Node_Str"" + exchange.getHttpContext().getPath();
  Class<? extends Command> commandClass=CommandClasses.get(key);
  Debug.log(""String_Node_Str"" + commandClass);
  String uuid=Authenticate.performAuthentication(exchange);
  if (uuid == null && !commandClass.equals(PostLoginCommand.class)) {
    Debug.log(""String_Node_Str"");
    respond(new ErrorResponse(HttpStatusCode.UNAUTHORIZED,""String_Node_Str""),exchange);
    return;
  }
 else   if (commandClass == null && !key.equals(""String_Node_Str"") && !key.equals(""String_Node_Str"") && !key.equals(""String_Node_Str"")) {
    Debug.log(""String_Node_Str"" + exchange.getRequestMethod() + ""String_Node_Str""+ exchange.getRequestURI());
    respond(new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + ""String_Node_Str""),exchange);
    return;
  }
  try {
switch (key) {
case (""String_Node_Str""):
      downloadHandler.handleGET(exchange);
    return;
case (""String_Node_Str""):
  uploadHandler.handleGET(exchange);
return;
case (""String_Node_Str""):
uploadHandler.handlePOST(exchange);
return;
}
}
 catch (Exception e) {
Debug.log(""String_Node_Str"");
return;
}
String json=readBody(exchange);
if (json.isEmpty()) json=""String_Node_Str"";
Debug.log(""String_Node_Str"" + json);
Command command=null;
try {
command=gson.fromJson(json,commandClass);
}
 catch (Exception e) {
Debug.log(""String_Node_Str"");
respond(new ErrorResponse(HttpStatusCode.INTERNAL_SERVER_ERROR,""String_Node_Str""),exchange);
return;
}
Debug.log(""String_Node_Str"" + command);
HashMap<String,String> query=new HashMap<>();
String uri;
try {
uri=Util.parseURI(exchange.getRequestURI(),query);
}
 catch (Exception e) {
Debug.log(""String_Node_Str"");
respond(new ErrorResponse(HttpStatusCode.INTERNAL_SERVER_ERROR,""String_Node_Str""),exchange);
return;
}
if (command.getExpectedNumberOfURIFields() != calculateURILength(uri)) {
Debug.log(""String_Node_Str"" + exchange.getRequestMethod() + ""String_Node_Str""+ exchange.getRequestURI());
Debug.log(""String_Node_Str"" + command.getExpectedNumberOfURIFields() + ""String_Node_Str""+ calculateURILength(uri));
respond(new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + ""String_Node_Str""),exchange);
return;
}
UserType userType=UserType.UNKNOWN;
if (!commandClass.equals(PostLoginCommand.class)) {
try (DatabaseAccessor db=Command.initDB()){
userType=db.getRole(Authenticate.getUsernameByID(uuid));
}
 catch (SQLException|IOException e) {
Debug.log(e.toString());
ErrorResponse errorResponse=new ErrorResponse(HttpStatusCode.INTERNAL_SERVER_ERROR,""String_Node_Str"" + ""String_Node_Str"");
respond(errorResponse,exchange);
}
}
command.setFields(uri,query,Authenticate.getUsernameByID(uuid),userType);
try {
command.validate();
}
 catch (ValidateException e) {
Debug.log(e.getMessage());
ErrorLogger.log(""String_Node_Str"",e.getMessage());
respond(new ErrorResponse(e.getCode(),e.getMessage()),exchange);
return;
}
if (commandClass.equals(ProcessCommands.class)) {
respond(new ProcessResponse(HttpStatusCode.NOT_IMPLEMENTED),exchange);
}
 else {
respond(command.execute(),exchange);
}
}","@Override public void handle(HttpExchange exchange){
  Debug.log(""String_Node_Str"" + exchange.getRequestMethod() + ""String_Node_Str""+ exchange.getRequestURI().toString());
  String key=exchange.getRequestMethod() + ""String_Node_Str"" + exchange.getHttpContext().getPath();
  Class<? extends Command> commandClass=CommandClasses.get(key);
  Debug.log(commandClass.getName());
  String uuid=Authenticate.performAuthentication(exchange);
  if (uuid == null && !commandClass.equals(PostLoginCommand.class)) {
    Debug.log(""String_Node_Str"");
    respond(new ErrorResponse(HttpStatusCode.UNAUTHORIZED,""String_Node_Str""),exchange);
    return;
  }
 else   if (commandClass == null && !key.equals(""String_Node_Str"") && !key.equals(""String_Node_Str"") && !key.equals(""String_Node_Str"")) {
    Debug.log(""String_Node_Str"" + exchange.getRequestMethod() + ""String_Node_Str""+ exchange.getRequestURI());
    respond(new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + ""String_Node_Str""),exchange);
    return;
  }
  try {
switch (key) {
case (""String_Node_Str""):
      downloadHandler.handleGET(exchange);
    return;
case (""String_Node_Str""):
  uploadHandler.handleGET(exchange);
return;
case (""String_Node_Str""):
uploadHandler.handlePOST(exchange);
return;
}
}
 catch (Exception e) {
Debug.log(""String_Node_Str"");
return;
}
String json=readBody(exchange);
if (json.isEmpty()) json=""String_Node_Str"";
Debug.log(""String_Node_Str"" + json);
Command command=null;
try {
command=gson.fromJson(json,commandClass);
}
 catch (Exception e) {
Debug.log(""String_Node_Str"");
respond(new ErrorResponse(HttpStatusCode.INTERNAL_SERVER_ERROR,""String_Node_Str""),exchange);
return;
}
Debug.log(command.getClass().getName());
HashMap<String,String> query=new HashMap<>();
String uri;
try {
uri=Util.parseURI(exchange.getRequestURI(),query);
}
 catch (Exception e) {
Debug.log(""String_Node_Str"");
respond(new ErrorResponse(HttpStatusCode.INTERNAL_SERVER_ERROR,""String_Node_Str""),exchange);
return;
}
if (command.getExpectedNumberOfURIFields() != calculateURILength(uri)) {
Debug.log(""String_Node_Str"" + exchange.getRequestMethod() + ""String_Node_Str""+ exchange.getRequestURI());
Debug.log(""String_Node_Str"" + command.getExpectedNumberOfURIFields() + ""String_Node_Str""+ calculateURILength(uri));
respond(new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + ""String_Node_Str""),exchange);
return;
}
UserType userType=UserType.UNKNOWN;
if (!commandClass.equals(PostLoginCommand.class)) {
try (DatabaseAccessor db=Command.initDB()){
userType=db.getRole(Authenticate.getUsernameByID(uuid));
}
 catch (SQLException|IOException e) {
Debug.log(e.toString());
ErrorResponse errorResponse=new ErrorResponse(HttpStatusCode.INTERNAL_SERVER_ERROR,""String_Node_Str"" + ""String_Node_Str"");
respond(errorResponse,exchange);
}
}
command.setFields(uri,query,Authenticate.getUsernameByID(uuid),userType);
try {
command.validate();
}
 catch (ValidateException e) {
Debug.log(e.getMessage());
ErrorLogger.log(""String_Node_Str"",e.getMessage());
respond(new ErrorResponse(e.getCode(),e.getMessage()),exchange);
return;
}
if (commandClass.equals(ProcessCommands.class)) {
respond(new ProcessResponse(HttpStatusCode.NOT_IMPLEMENTED),exchange);
}
 else {
respond(command.execute(),exchange);
}
}",0.9869771717481232
38110,"/** 
 * 1. runs the bowtie program to get a .sam file. 2. runs a linux shell command to sort the sam file. 3. runs a perl script that creates a .ggf file from the sam file. 4. runs a perl script that creates a .sgr file from the .gff file. 6. runs a converted method of the smoothing and stepping scripts. 7. runs a perl script that converts the .sgr file to .wig file. 8. runs a perl script that does ratio calculation on the files, also runs smoothing on these files. All these steps have to be run in order but the clients can specify how many steps they want to run by sending parameters for the steps they want to run.
 * @param parameters String array with execution parameters
 * @param inFolder The filepath to the file to create a wig from
 * @param outFilePath Filepath to where the .wig file should be placed.
 * @throws ProcessException
 */
public String procedure(String[] parameters,String inFolder,String outFilePath) throws ProcessException {
  File[] inFiles=initiateProcedure(parameters,inFolder,outFilePath);
  ErrorLogger.log(""String_Node_Str"",Arrays.toString(parameters));
  if (fileDir.exists()) {
    if (checker.shouldRunBowTie()) {
      ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      logString=runBowTie(rawFile1,rawFile_1_Name);
      ErrorLogger.log(""String_Node_Str"",""String_Node_Str"" + logString);
      ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      checkBowTieFile(""String_Node_Str"" + dir + rawFile_1_Name+ ""String_Node_Str"",rawFile_1_Name);
      toBeRemoved.push(remoteExecution + ""String_Node_Str"" + dir);
      filesToBeMoved=dir;
      toBeRemoved.push(filesToBeMoved);
    }
    if (checker.shouldRunSortSam()) {
      ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      try {
        Picard.runSortSam(dir + rawFile_1_Name + ""String_Node_Str"",dir + rawFile_1_Name + ""String_Node_Str"");
      }
 catch (      ValidateException e) {
        ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      }
catch (      InterruptedException|IOException e) {
        ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
        ErrorLogger.log(""String_Node_Str"",e.getMessage());
      }
    }
    if (checker.shouldRunRemoveDuplicates()) {
      ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      try {
        Picard.runRemoveDuplicates(dir + rawFile_1_Name + ""String_Node_Str"",dir + rawFile_1_Name + ""String_Node_Str"");
      }
 catch (      ValidateException e) {
        ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      }
catch (      IOException|InterruptedException e) {
        ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
        ErrorLogger.log(""String_Node_Str"",e.getMessage());
      }
    }
    if (checker.shouldRunConvert()) {
      ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      try {
        Pyicos.runConvert(dir + rawFile_1_Name + ""String_Node_Str"");
        filesToBeMoved=dir;
        toBeRemoved.push(filesToBeMoved);
      }
 catch (      ValidateException e) {
        ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
        ErrorLogger.log(""String_Node_Str"",e.getMessage());
      }
catch (      InterruptedException|IOException e) {
        ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      }
    }
    if (checker.shouldRunSamToGff()) {
      runSamToGff();
    }
    if (checker.shouldRunGffToAllnusgr()) {
      runGffToAllnusgr();
    }
    if (checker.shouldRunSmoothing()) {
      ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      runSmoothing(parameters,false);
      filesToBeMoved=sortedDirForFile + ""String_Node_Str"";
      toBeRemoved.push(filesToBeMoved);
    }
    if (checker.shouldRunRatioCalc()) {
      ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      doRatioCalculation(sortedDirForCommands + ""String_Node_Str"",parameters);
      runSmoothing(parameters,true);
      toBeRemoved.push(sortedDirForFile + ""String_Node_Str"");
      filesToBeMoved=sortedDirForFile + ""String_Node_Str"";
      toBeRemoved.push(filesToBeMoved);
    }
    try {
      ErrorLogger.log(""String_Node_Str"",""String_Node_Str"" + filesToBeMoved + ""String_Node_Str"");
      ErrorLogger.log(""String_Node_Str"",""String_Node_Str"" + outFilePath + ""String_Node_Str"");
      moveEndFiles(""String_Node_Str"" + filesToBeMoved,outFilePath);
    }
 catch (    ProcessException e) {
      cleanUp(toBeRemoved);
      throw e;
    }
  }
 else {
    logString=logString + ""String_Node_Str"" + ""String_Node_Str""+ fileDir.toString();
  }
  return logString;
}","/** 
 * 1. runs the bowtie program to get a .sam file. 2. runs a linux shell command to sort the sam file. 3. runs a perl script that creates a .ggf file from the sam file. 4. runs a perl script that creates a .sgr file from the .gff file. 6. runs a converted method of the smoothing and stepping scripts. 7. runs a perl script that converts the .sgr file to .wig file. 8. runs a perl script that does ratio calculation on the files, also runs smoothing on these files. All these steps have to be run in order but the clients can specify how many steps they want to run by sending parameters for the steps they want to run.
 * @param parameters String array with execution parameters
 * @param inFolder The filepath to the file to create a wig from
 * @param outFilePath Filepath to where the .wig file should be placed.
 * @throws ProcessException
 */
public String procedure(String[] parameters,String inFolder,String outFilePath) throws ProcessException {
  File[] inFiles=initiateProcedure(parameters,inFolder,outFilePath);
  ErrorLogger.log(""String_Node_Str"",Arrays.toString(parameters));
  if (fileDir.exists()) {
    if (checker.shouldRunBowTie()) {
      ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      logString=runBowTie(rawFile1,rawFile_1_Name);
      ErrorLogger.log(""String_Node_Str"",""String_Node_Str"" + logString);
      ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      checkBowTieFile(dir + rawFile_1_Name + ""String_Node_Str"",rawFile_1_Name);
      toBeRemoved.push(remoteExecution + ""String_Node_Str"" + dir);
      filesToBeMoved=dir;
      toBeRemoved.push(filesToBeMoved);
    }
    if (checker.shouldRunSortSam()) {
      ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      try {
        Picard.runSortSam(dir + rawFile_1_Name + ""String_Node_Str"",dir + rawFile_1_Name + ""String_Node_Str"");
      }
 catch (      ValidateException e) {
        ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      }
catch (      InterruptedException|IOException e) {
        ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
        ErrorLogger.log(""String_Node_Str"",e.getMessage());
      }
    }
    if (checker.shouldRunRemoveDuplicates()) {
      ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      try {
        Picard.runRemoveDuplicates(dir + rawFile_1_Name + ""String_Node_Str"",dir + rawFile_1_Name + ""String_Node_Str"");
      }
 catch (      ValidateException e) {
        ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      }
catch (      IOException|InterruptedException e) {
        ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
        ErrorLogger.log(""String_Node_Str"",e.getMessage());
      }
    }
    if (checker.shouldRunConvert()) {
      ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      try {
        Pyicos.runConvert(dir + rawFile_1_Name + ""String_Node_Str"");
        filesToBeMoved=dir;
        toBeRemoved.push(filesToBeMoved);
      }
 catch (      ValidateException e) {
        ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
        ErrorLogger.log(""String_Node_Str"",e.getMessage());
      }
catch (      InterruptedException|IOException e) {
        ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      }
    }
    if (checker.shouldRunSamToGff()) {
      runSamToGff();
    }
    if (checker.shouldRunGffToAllnusgr()) {
      runGffToAllnusgr();
    }
    if (checker.shouldRunSmoothing()) {
      ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      runSmoothing(parameters,false);
      filesToBeMoved=sortedDirForFile + ""String_Node_Str"";
      toBeRemoved.push(filesToBeMoved);
    }
    if (checker.shouldRunRatioCalc()) {
      ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      doRatioCalculation(sortedDirForCommands + ""String_Node_Str"",parameters);
      runSmoothing(parameters,true);
      toBeRemoved.push(sortedDirForFile + ""String_Node_Str"");
      filesToBeMoved=sortedDirForFile + ""String_Node_Str"";
      toBeRemoved.push(filesToBeMoved);
    }
    try {
      ErrorLogger.log(""String_Node_Str"",""String_Node_Str"" + filesToBeMoved + ""String_Node_Str"");
      ErrorLogger.log(""String_Node_Str"",""String_Node_Str"" + outFilePath + ""String_Node_Str"");
      moveEndFiles(filesToBeMoved,outFilePath);
    }
 catch (    ProcessException e) {
      cleanUp(toBeRemoved);
      throw e;
    }
  }
 else {
    logString=logString + ""String_Node_Str"" + ""String_Node_Str""+ fileDir.toString();
  }
  return logString;
}",0.9954215522054718
38111,"/** 
 * Checks that bowtie created the files it should create and that the size is bigger then zero.
 * @param dir The directory where the files bowtie creates should be placed
 * @param fileName The name of the file bowtie should create.
 * @throws ProcessException
 */
private void checkBowTieFile(String dir,String fileName) throws ProcessException {
  File bowTie=new File(dir);
  if (!bowTie.exists() || bowTie.length() == 0) {
    throw new ProcessException(""String_Node_Str"" + fileName + bowTie.exists()+ bowTie.length());
  }
}","/** 
 * Checks that bowtie created the files it should create and that the size is bigger then zero.
 * @param dir The directory where the files bowtie creates should be placed
 * @param fileName The name of the file bowtie should create.
 * @throws ProcessException
 */
private void checkBowTieFile(String dir,String fileName) throws ProcessException {
  File bowTie=new File(dir);
  if (!bowTie.exists() || bowTie.length() == 0) {
    throw new ProcessException(""String_Node_Str"" + fileName + bowTie.exists()+ bowTie.length()+ ""String_Node_Str""+ dir);
  }
}",0.9780621572212066
38112,"@Override public Response execute(){
  return new MinimalResponse(HttpStatusCode.METHOD_NOT_YET_IMPLEMENTED);
}","@Override public Response execute(){
  return new MinimalResponse(HttpStatusCode.NOT_IMPLEMENTED);
}",0.9478672985781992
38113,"@Override public Response call(){
  Response response=null;
  if (processCommand != null && process != null) {
    Debug.log(""String_Node_Str"" + processCommand.getPID() + ""String_Node_Str""+ processCommand.getExpId()+ ""String_Node_Str"");
    process.status=Process.STATUS_STARTED;
    try {
      processCommand.setFilePaths();
    }
 catch (    SQLException|IOException e) {
      Debug.log(e.getMessage());
      ErrorLogger.log(process.author,""String_Node_Str"" + e.getMessage());
      process.status=Process.STATUS_CRASHED;
      return null;
    }
    process.outputFiles=processCommand.getFilePaths();
    process.timeStarted=System.currentTimeMillis();
    try {
      response=processCommand.execute();
      if (response.getCode() == HttpStatusCode.CREATED || response.getCode() == HttpStatusCode.OK) {
        process.status=Process.STATUS_FINISHED;
        String successMsg=""String_Node_Str"" + processCommand.getPID() + ""String_Node_Str""+ processCommand.getExpId()+ ""String_Node_Str"";
        Debug.log(successMsg);
        ErrorLogger.log(""String_Node_Str"",successMsg);
      }
 else {
        System.out.println(""String_Node_Str"" + response.getCode());
        process.status=Process.STATUS_CRASHED;
        String crashedMsg=""String_Node_Str"" + processCommand.getPID() + ""String_Node_Str""+ processCommand.getExpId()+ ""String_Node_Str"";
        Debug.log(crashedMsg);
        ErrorLogger.log(""String_Node_Str"",crashedMsg);
      }
    }
 catch (    NullPointerException e) {
      process.status=Process.STATUS_CRASHED;
    }
    if (simulateLongProcess) {
      ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      Debug.log(""String_Node_Str"" + processCommand.getPID());
      try {
        Thread.sleep(30000);
      }
 catch (      InterruptedException ex) {
        Debug.log(""String_Node_Str"");
      }
      Debug.log(""String_Node_Str"" + processCommand.getPID());
    }
    process.timeFinished=System.currentTimeMillis();
    String timeMsg=""String_Node_Str"" + processCommand.getPID() + ""String_Node_Str""+ formatTimeDifference((process.timeFinished - process.timeStarted) / 1000);
    Debug.log(timeMsg);
    ErrorLogger.log(""String_Node_Str"",timeMsg);
  }
  Debug.log(""String_Node_Str"" + processCommand.getPID());
  Debug.log(""String_Node_Str"" + ((ProcessResponse)response).getMessage());
  return response;
}","@Override public Response call(){
  Response response=null;
  if (processCommand != null && process != null) {
    Debug.log(""String_Node_Str"" + processCommand.getPID() + ""String_Node_Str""+ processCommand.getExpId()+ ""String_Node_Str"");
    process.status=Process.STATUS_STARTED;
    try {
      processCommand.setFilePaths();
    }
 catch (    SQLException|IOException e) {
      Debug.log(e.getMessage());
      ErrorLogger.log(process.author,""String_Node_Str"" + e.getMessage());
      process.status=Process.STATUS_CRASHED;
      return null;
    }
    process.outputFiles=processCommand.getFilePaths();
    process.timeStarted=System.currentTimeMillis();
    try {
      response=processCommand.execute();
      if (response.getCode() == HttpStatusCode.CREATED || response.getCode() == HttpStatusCode.OK) {
        process.status=Process.STATUS_FINISHED;
        String successMsg=""String_Node_Str"" + processCommand.getPID() + ""String_Node_Str""+ processCommand.getExpId()+ ""String_Node_Str"";
        Debug.log(successMsg);
        ErrorLogger.log(""String_Node_Str"",successMsg);
      }
 else {
        System.out.println(""String_Node_Str"" + response.getCode());
        process.status=Process.STATUS_CRASHED;
        String crashedMsg=""String_Node_Str"" + processCommand.getPID() + ""String_Node_Str""+ processCommand.getExpId()+ ""String_Node_Str"";
        Debug.log(crashedMsg);
        ErrorLogger.log(""String_Node_Str"",crashedMsg);
      }
    }
 catch (    NullPointerException e) {
      process.status=Process.STATUS_CRASHED;
    }
    if (simulateLongProcess) {
      ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      Debug.log(""String_Node_Str"" + processCommand.getPID());
      try {
        Thread.sleep(30000);
      }
 catch (      InterruptedException ex) {
        Debug.log(""String_Node_Str"");
      }
      Debug.log(""String_Node_Str"" + processCommand.getPID());
    }
    process.timeFinished=System.currentTimeMillis();
    String timeMsg=""String_Node_Str"" + processCommand.getPID() + ""String_Node_Str""+ formatTimeDifference((process.timeFinished - process.timeStarted) / 1000);
    Debug.log(timeMsg);
    ErrorLogger.log(""String_Node_Str"",timeMsg);
  }
  Debug.log(""String_Node_Str"" + processCommand.getPID());
  Debug.log(""String_Node_Str"" + response.getMessage());
  return response;
}",0.9924812030075189
38114,"private String formatTimeDifference(long diffMillis){
  long seconds=diffMillis / 1000;
  long minutes=seconds / 60;
  long hours=minutes / 60;
  long days=hours / 24;
  if (days > 0) {
    return new String(days + ""String_Node_Str"" + hours+ ""String_Node_Str""+ minutes+ ""String_Node_Str""+ seconds+ ""String_Node_Str"");
  }
  if (hours > 0) {
    return new String(hours + ""String_Node_Str"" + minutes+ ""String_Node_Str""+ seconds+ ""String_Node_Str"");
  }
  if (minutes > 0) {
    return new String(minutes + ""String_Node_Str"" + seconds+ ""String_Node_Str"");
  }
  return new String(seconds + ""String_Node_Str"");
}","private String formatTimeDifference(long diffMillis){
  long seconds=diffMillis / 1000;
  long minutes=seconds / 60;
  long hours=minutes / 60;
  long days=hours / 24;
  if (days > 0) {
    return (days + ""String_Node_Str"" + hours+ ""String_Node_Str""+ minutes+ ""String_Node_Str""+ seconds+ ""String_Node_Str"");
  }
  if (hours > 0) {
    return (hours + ""String_Node_Str"" + minutes+ ""String_Node_Str""+ seconds+ ""String_Node_Str"");
  }
  if (minutes > 0) {
    return (minutes + ""String_Node_Str"" + seconds+ ""String_Node_Str"");
  }
  return (seconds + ""String_Node_Str"");
}",0.966044142614601
38115,"public Response execute(){
  try {
    Thread.sleep(1000);
    if (this.getUsername().equals(""String_Node_Str"")) {
      return new ErrorResponse(HttpStatusCode.METHOD_NOT_YET_IMPLEMENTED,""String_Node_Str"");
    }
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  return new MinimalResponse(HttpStatusCode.OK);
}","public Response execute(){
  try {
    Thread.sleep(1000);
    if (this.getUsername().equals(""String_Node_Str"")) {
      return new ErrorResponse(HttpStatusCode.NOT_IMPLEMENTED,""String_Node_Str"");
    }
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  return new MinimalResponse(HttpStatusCode.OK);
}",0.983206106870229
38116,"/** 
 * 1. runs the bowtie program to get a .sam file. 2. runs a linux shell command to sort the sam file. 3. runs a perl script that creates a .ggf file from the sam file. 4. runs a perl script that creates a .sgr file from the .gff file. 6. runs a converted method of the smoothing and stepping scripts. 7. runs a perl script that converts the .sgr file to .wig file. 8. runs a perl script that does ratio calculation on the files, also runs smoothing on these files. All these steps have to be run in order but the clients can specify how many steps they want to run by sending parameters for the steps they want to run.
 * @param parameters String array with execution parameters
 * @param inFolder The filepath to the file to create a wig from
 * @param outFilePath Filepath to where the .wig file should be placed.
 * @throws ProcessException
 */
public String procedure(String[] parameters,String inFolder,String outFilePath) throws ProcessException {
  File[] inFiles=initiateProcedure(parameters,inFolder,outFilePath);
  System.out.println(Arrays.toString(parameters));
  if (fileDir.exists()) {
    if (checker.shouldRunBowTie()) {
      ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      logString=runBowTie(rawFile1,rawFile_1_Name);
      checkBowTieFile(""String_Node_Str"" + dir + rawFile_1_Name+ ""String_Node_Str"",rawFile_1_Name);
      ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      if (inFiles.length == 2) {
        logString=logString + ""String_Node_Str"" + runBowTie(rawFile2,rawFile_2_Name);
        checkBowTieFile(remoteExecution + ""String_Node_Str"" + dir+ rawFile_2_Name+ ""String_Node_Str"",rawFile_2_Name);
        sortSamFile(rawFile_2_Name);
      }
      toBeRemoved.push(remoteExecution + ""String_Node_Str"" + dir);
      filesToBeMoved=sortedDirForFile;
      toBeRemoved.push(filesToBeMoved);
    }
    if (checker.shouldRunSortSam()) {
      try {
        Picard.runSortSam(dir + rawFile_1_Name + ""String_Node_Str"",dir + rawFile_1_Name + ""String_Node_Str"");
      }
 catch (      ValidateException e) {
        e.printStackTrace();
      }
catch (      InterruptedException e) {
        e.printStackTrace();
      }
catch (      IOException e) {
        e.printStackTrace();
      }
    }
    if (checker.shouldRunRemoveDuplicates()) {
      try {
        Picard.runRemoveDuplicates(dir + rawFile_1_Name + ""String_Node_Str"",dir + rawFile_1_Name + ""String_Node_Str"");
      }
 catch (      ValidateException e) {
        e.printStackTrace();
      }
catch (      IOException e) {
        e.printStackTrace();
      }
catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
    if (checker.shouldRunConvert()) {
      try {
        System.out.println(""String_Node_Str"" + dir);
        Pyicos.runConvert(dir + rawFile_1_Name + ""String_Node_Str"");
        filesToBeMoved=sortedDirForFile;
        toBeRemoved.push(filesToBeMoved);
      }
 catch (      ValidateException e) {
        e.printStackTrace();
      }
catch (      InterruptedException e) {
        e.printStackTrace();
      }
catch (      IOException e) {
        e.printStackTrace();
      }
    }
    if (checker.shouldRunSamToGff()) {
      runSamToGff();
    }
    if (checker.shouldRunGffToAllnusgr()) {
      runGffToAllnusgr();
    }
    if (checker.shouldRunSmoothing()) {
      ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      runSmoothing(parameters,false);
      filesToBeMoved=sortedDirForFile + ""String_Node_Str"";
      toBeRemoved.push(filesToBeMoved);
    }
    if (checker.shouldRunRatioCalc()) {
      ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      doRatioCalculation(sortedDirForCommands + ""String_Node_Str"",parameters);
      runSmoothing(parameters,true);
      toBeRemoved.push(sortedDirForFile + ""String_Node_Str"");
      filesToBeMoved=sortedDirForFile + ""String_Node_Str"";
      toBeRemoved.push(filesToBeMoved);
    }
    try {
      moveEndFiles(filesToBeMoved,outFilePath);
    }
 catch (    ProcessException e) {
      cleanUp(toBeRemoved);
      throw e;
    }
    cleanUp(toBeRemoved);
  }
 else {
    logString=logString + ""String_Node_Str"" + ""String_Node_Str""+ fileDir.toString();
  }
  return logString;
}","/** 
 * 1. runs the bowtie program to get a .sam file. 2. runs a linux shell command to sort the sam file. 3. runs a perl script that creates a .ggf file from the sam file. 4. runs a perl script that creates a .sgr file from the .gff file. 6. runs a converted method of the smoothing and stepping scripts. 7. runs a perl script that converts the .sgr file to .wig file. 8. runs a perl script that does ratio calculation on the files, also runs smoothing on these files. All these steps have to be run in order but the clients can specify how many steps they want to run by sending parameters for the steps they want to run.
 * @param parameters String array with execution parameters
 * @param inFolder The filepath to the file to create a wig from
 * @param outFilePath Filepath to where the .wig file should be placed.
 * @throws ProcessException
 */
public String procedure(String[] parameters,String inFolder,String outFilePath) throws ProcessException {
  File[] inFiles=initiateProcedure(parameters,inFolder,outFilePath);
  ErrorLogger.log(""String_Node_Str"",Arrays.toString(parameters));
  if (fileDir.exists()) {
    if (checker.shouldRunBowTie()) {
      ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      logString=runBowTie(rawFile1,rawFile_1_Name);
      checkBowTieFile(""String_Node_Str"" + dir + rawFile_1_Name+ ""String_Node_Str"",rawFile_1_Name);
      toBeRemoved.push(remoteExecution + ""String_Node_Str"" + dir);
      filesToBeMoved=sortedDirForFile;
      toBeRemoved.push(filesToBeMoved);
    }
    if (checker.shouldRunSortSam()) {
      ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      try {
        Picard.runSortSam(dir + rawFile_1_Name + ""String_Node_Str"",dir + rawFile_1_Name + ""String_Node_Str"");
      }
 catch (      ValidateException e) {
        ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      }
catch (      InterruptedException|IOException e) {
        ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      }
    }
    if (checker.shouldRunRemoveDuplicates()) {
      ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      try {
        Picard.runRemoveDuplicates(dir + rawFile_1_Name + ""String_Node_Str"",dir + rawFile_1_Name + ""String_Node_Str"");
      }
 catch (      ValidateException e) {
        ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      }
catch (      IOException|InterruptedException e) {
        ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      }
    }
    if (checker.shouldRunConvert()) {
      ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      try {
        Pyicos.runConvert(dir + rawFile_1_Name + ""String_Node_Str"");
        filesToBeMoved=sortedDirForFile;
        toBeRemoved.push(filesToBeMoved);
      }
 catch (      ValidateException e) {
        ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      }
catch (      InterruptedException|IOException e) {
        ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      }
    }
    if (checker.shouldRunSamToGff()) {
      runSamToGff();
    }
    if (checker.shouldRunGffToAllnusgr()) {
      runGffToAllnusgr();
    }
    if (checker.shouldRunSmoothing()) {
      ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      runSmoothing(parameters,false);
      filesToBeMoved=sortedDirForFile + ""String_Node_Str"";
      toBeRemoved.push(filesToBeMoved);
    }
    if (checker.shouldRunRatioCalc()) {
      ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
      doRatioCalculation(sortedDirForCommands + ""String_Node_Str"",parameters);
      runSmoothing(parameters,true);
      toBeRemoved.push(sortedDirForFile + ""String_Node_Str"");
      filesToBeMoved=sortedDirForFile + ""String_Node_Str"";
      toBeRemoved.push(filesToBeMoved);
    }
    try {
      moveEndFiles(filesToBeMoved,outFilePath);
    }
 catch (    ProcessException e) {
      cleanUp(toBeRemoved);
      throw e;
    }
    cleanUp(toBeRemoved);
  }
 else {
    logString=logString + ""String_Node_Str"" + ""String_Node_Str""+ fileDir.toString();
  }
  return logString;
}",0.7598784194528876
38117,"@Override public void validate() throws ValidateException {
  hasRights(UserRights.getRights(this.getClass()));
  validateName(name,MaxLength.ANNOTATION_LABEL,""String_Node_Str"");
  defaults=""String_Node_Str"";
  if (forced == null) {
    throw new ValidateException(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + ""String_Node_Str"");
  }
  if (type == null || type.size() < 1) {
    throw new ValidateException(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + ""String_Node_Str"");
  }
  for (int i=0; i < type.size(); i++) {
    validateName(type.get(i),MaxLength.ANNOTATION_VALUE,""String_Node_Str"");
    if (type.get(i).equals(""String_Node_Str"")) {
      type.remove(i);
      i--;
    }
  }
  type.add(0,""String_Node_Str"");
}","@Override public void validate() throws ValidateException {
  hasRights(UserRights.getRights(this.getClass()));
  validateName(name,MaxLength.ANNOTATION_LABEL,""String_Node_Str"");
  defaults=""String_Node_Str"";
  if (forced == null) {
    throw new ValidateException(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + ""String_Node_Str"");
  }
  if (type == null || type.size() < 1) {
    throw new ValidateException(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + ""String_Node_Str"");
  }
  for (int i=0; i < type.size(); i++) {
    validateName(type.get(i),MaxLength.ANNOTATION_VALUE,""String_Node_Str"");
    if (type.get(i).equals(""String_Node_Str"")) {
      type.remove(i);
      i--;
    }
  }
  if (!(type.size() == 1 && type.get(0).equals(""String_Node_Str""))) {
    type.add(0,""String_Node_Str"");
  }
}",0.95
38118,"@Override public Response execute(){
  DatabaseAccessor db=null;
  ProcessHandler processHandler;
  try {
    db=initDB();
    processHandler=new ProcessHandler();
switch (processtype) {
case PutProcessCommand.CMD_RAW_TO_PROFILE:
      Genome g=db.getGenomeRelease(genomeVersion);
    if (g == null) {
      return new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + genomeVersion);
    }
 else {
      String genomeFolderPath=g.folderPath;
      String genomeFilePrefix=g.getFilePrefix();
      if (genomeFilePrefix == null) {
        return processError(db,""String_Node_Str"" + genomeFilePrefix,""String_Node_Str"" + ""String_Node_Str"");
      }
      if (genomeFolderPath == null) {
        return processError(db,""String_Node_Str"" + genomeFolderPath,""String_Node_Str"" + ""String_Node_Str"");
      }
      parameters[1]=genomeFolderPath + genomeFilePrefix;
    }
  try {
    processHandler.executeProcess(PutProcessCommand.CMD_RAW_TO_PROFILE,parameters,filepaths.getKey(),filepaths.getValue());
  }
 catch (  ProcessException e) {
    return processError(db,e.getMessage(),""String_Node_Str"" + ""String_Node_Str"");
  }
break;
case PutProcessCommand.CMD_CANCEL_PROCESS:
try {
processHandler.executeProcess(CMD_CANCEL_PROCESS,parameters,null,null);
return new MinimalResponse(HttpStatusCode.OK);
}
 catch (ProcessException e) {
return processError(db,e.getMessage(),""String_Node_Str"" + ""String_Node_Str"");
}
default :
return processError(db,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
}
}
 catch (SQLException e) {
return processError(db,e.getMessage(),""String_Node_Str"" + ""String_Node_Str"");
}
catch (IOException e1) {
return processError(db,e1.getMessage(),""String_Node_Str"" + ""String_Node_Str"");
}
try {
if (!db.isConnected()) {
db=initDB();
}
db.addGeneratedProfiles(expid,filepaths.getValue(),filepaths.getKey(),metadata,genomeVersion,username,false);
}
 catch (SQLException e) {
return processError(db,e.getMessage(),""String_Node_Str"" + ""String_Node_Str"");
}
catch (IOException e) {
return processError(db,e.getMessage(),""String_Node_Str"" + ""String_Node_Str"");
}
db.close();
Debug.log(username + ""String_Node_Str"" + ""String_Node_Str""+ processtype+ ""String_Node_Str""+ expid+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ genomeVersion+ ""String_Node_Str""+ ""String_Node_Str""+ PID+ ""String_Node_Str"");
return new ProcessResponse(HttpStatusCode.OK,""String_Node_Str"" + ""String_Node_Str"" + processtype + ""String_Node_Str""+ expid+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ genomeVersion+ ""String_Node_Str""+ ""String_Node_Str""+ PID+ ""String_Node_Str"");
}","@Override public Response execute(){
  DatabaseAccessor db=null;
  ProcessHandler processHandler;
  try {
    db=initDB();
    processHandler=new ProcessHandler();
switch (processtype) {
case PutProcessCommand.CMD_RAW_TO_PROFILE:
      Genome g=db.getGenomeRelease(genomeVersion);
    if (g == null) {
      return new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + genomeVersion);
    }
 else {
      String genomeFolderPath=g.folderPath;
      String genomeFilePrefix=g.getFilePrefix();
      if (genomeFilePrefix == null) {
        return processError(db,""String_Node_Str"" + genomeFilePrefix,""String_Node_Str"" + ""String_Node_Str"");
      }
      if (genomeFolderPath == null) {
        return processError(db,""String_Node_Str"" + genomeFolderPath,""String_Node_Str"" + ""String_Node_Str"");
      }
      parameters[1]=genomeFolderPath + genomeFilePrefix;
    }
  try {
    processHandler.executeProcess(PutProcessCommand.CMD_RAW_TO_PROFILE,parameters,filepaths.getKey(),filepaths.getValue());
  }
 catch (  ProcessException e) {
    return processError(db,e.getMessage(),""String_Node_Str"" + ""String_Node_Str"");
  }
break;
case PutProcessCommand.CMD_CANCEL_PROCESS:
try {
processHandler.executeProcess(CMD_CANCEL_PROCESS,parameters,null,null);
return new MinimalResponse(HttpStatusCode.OK);
}
 catch (ProcessException e) {
return processError(db,e.getMessage(),""String_Node_Str"" + ""String_Node_Str"");
}
default :
return processError(db,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
}
}
 catch (SQLException e) {
return processError(db,e.getMessage(),""String_Node_Str"" + ""String_Node_Str"");
}
catch (IOException e1) {
return processError(db,e1.getMessage(),""String_Node_Str"" + ""String_Node_Str"");
}
try {
if (!db.isConnected()) {
db=initDB();
}
db.addGeneratedProfiles(expid,filepaths.getValue(),filepaths.getKey(),metadata,genomeVersion,username,false);
}
 catch (SQLException e) {
return processError(db,e.getMessage(),""String_Node_Str"" + ""String_Node_Str"");
}
catch (IOException e) {
return processError(db,e.getMessage(),""String_Node_Str"" + ""String_Node_Str"");
}
db.close();
Debug.log(username + ""String_Node_Str"" + ""String_Node_Str""+ processtype+ ""String_Node_Str""+ expid+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ arrayToString(parameters,parameters.length)+ ""String_Node_Str""+ ""String_Node_Str""+ genomeVersion+ ""String_Node_Str""+ ""String_Node_Str""+ PID+ ""String_Node_Str"");
return new ProcessResponse(HttpStatusCode.OK,""String_Node_Str"" + ""String_Node_Str"" + processtype + ""String_Node_Str""+ expid+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ arrayToString(parameters,parameters.length)+ ""String_Node_Str""+ ""String_Node_Str""+ genomeVersion+ ""String_Node_Str""+ ""String_Node_Str""+ PID+ ""String_Node_Str"");
}",0.9809899569583932
38119,"/** 
 * Used to execute the actual password change of the user.
 */
@Override public Response execute(){
  DatabaseAccessor db=null;
  try {
    db=initDB();
  }
 catch (  SQLException|IOException e) {
    Debug.log(""String_Node_Str"" + username + ""String_Node_Str""+ e.getMessage());
    return new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + username + ""String_Node_Str""+ e.getMessage());
  }
  String hash=BCrypt.hashpw(password,BCrypt.gensalt());
  try {
    db.resetPassword(username,hash);
  }
 catch (  SQLException|IOException e) {
    return new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + e.getMessage());
  }
  return new MinimalResponse(HttpStatusCode.OK);
}","/** 
 * Used to execute the actual password change of the user.
 */
@Override public Response execute(){
  DatabaseAccessor db;
  try {
    db=initDB();
  }
 catch (  SQLException|IOException e) {
    Debug.log(""String_Node_Str"" + username + ""String_Node_Str""+ e.getMessage());
    return new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + username + ""String_Node_Str""+ e.getMessage());
  }
  String hash=BCrypt.hashpw(password,BCrypt.gensalt());
  try {
    db.resetPassword(username,hash);
  }
 catch (  SQLException|IOException e) {
    return new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + e.getMessage());
  }
  return new MinimalResponse(HttpStatusCode.OK);
}",0.9964260185847034
38120,"private void createContextsAndSetExecutor(HttpServer server){
  RequestHandler requestHandler=new RequestHandler();
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.setExecutor(new Executor(){
    @Override public void execute(    Runnable command){
      try {
        new Thread(command).start();
      }
 catch (      Exception e) {
        System.err.println(""String_Node_Str"" + e.getMessage());
        ErrorLogger.log(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + e.getMessage());
      }
    }
  }
);
}","private void createContextsAndSetExecutor(HttpServer server){
  RequestHandler requestHandler=new RequestHandler();
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.setExecutor(new Executor(){
    @Override public void execute(    Runnable command){
      try {
        new Thread(command).start();
      }
 catch (      Exception e) {
        System.err.println(""String_Node_Str"" + e.getMessage());
        ErrorLogger.log(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + e.getMessage());
      }
    }
  }
);
}",0.8825231481481481
38121,"/** 
 * Constructs a HTTP server (but doesn't start it) which listens on the given port.
 * @throws IOException
 */
public Doorman(ProcessPool processPool,int port) throws IOException {
  Doorman.processPool=processPool;
  httpServer=HttpServer.create(new InetSocketAddress(ServerSettings.genomizerPort),0);
  createContextsAndSetExecutor(httpServer);
}","/** 
 * Constructs a HTTP server (but doesn't start it) which listens on the given port.
 * @throws IOException
 */
public Doorman(ProcessPool processPool) throws IOException {
  Doorman.processPool=processPool;
  httpServer=HttpServer.create(new InetSocketAddress(ServerSettings.genomizerPort),0);
  createContextsAndSetExecutor(httpServer);
}",0.9870875179340028
38122,"private void createContextsAndSetExecutor(HttpServer server){
  RequestHandler requestHandler=new RequestHandler();
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"");
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.setExecutor(new Executor(){
    @Override public void execute(    Runnable command){
      try {
        new Thread(command).start();
      }
 catch (      Exception e) {
        System.err.println(""String_Node_Str"" + e.getMessage());
        ErrorLogger.log(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + e.getMessage());
      }
    }
  }
);
}","private void createContextsAndSetExecutor(HttpServer server){
  RequestHandler requestHandler=new RequestHandler();
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.createContext(""String_Node_Str"",requestHandler);
  server.setExecutor(new Executor(){
    @Override public void execute(    Runnable command){
      try {
        new Thread(command).start();
      }
 catch (      Exception e) {
        System.err.println(""String_Node_Str"" + e.getMessage());
        ErrorLogger.log(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + e.getMessage());
      }
    }
  }
);
}",0.9952396064741352
38123,"/** 
 * Creates a Json representation of the body
 * @return The response body as a String
 */
@Override public String getBody(){
  if (getProcessStatuses.size() > 0) {
    ErrorLogger.log(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
    return ""String_Node_Str"";
  }
  Collections.sort(getProcessStatuses);
  Gson gson=new GsonBuilder().setPrettyPrinting().create();
  JsonArray arr=new JsonArray();
  for (  Process p : getProcessStatuses) {
    JsonElement elem=gson.toJsonTree(p,Process.class);
    arr.add(elem);
  }
  return toPrettyFormat(arr.toString());
}","/** 
 * Creates a Json representation of the body
 * @return The response body as a String
 */
@Override public String getBody(){
  if (getProcessStatuses.size() == 0) {
    ErrorLogger.log(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
    return ""String_Node_Str"";
  }
  Collections.sort(getProcessStatuses);
  Gson gson=new GsonBuilder().setPrettyPrinting().create();
  JsonArray arr=new JsonArray();
  for (  Process p : getProcessStatuses) {
    JsonElement elem=gson.toJsonTree(p,Process.class);
    arr.add(elem);
  }
  return toPrettyFormat(arr.toString());
}",0.9974025974025974
38124,"@Override public void setFields(String uri,String uuid,UserType userType){
  super.setFields(uri,uuid,userType);
  username=uri.split(""String_Node_Str"")[2];
}","/** 
 * Set the UserType Uri and Uuid. Username also set from uri.
 * @param uri the URI from the http request.
 * @param uuid the uuid from the http request.
 * @param userType the userType
 */
@Override public void setFields(String uri,String uuid,UserType userType){
  super.setFields(uri,uuid,userType);
  username=uri.split(""String_Node_Str"")[2];
}",0.6183953033268101
38125,"@Override public Response execute(){
  DatabaseAccessor db;
  System.out.println(""String_Node_Str"" + username);
  try {
    db=initDB();
  }
 catch (  SQLException e) {
    return new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + ""String_Node_Str"" + e.getMessage());
  }
catch (  IOException e) {
    return new ErrorResponse(HttpStatusCode.BAD_REQUEST,e.getMessage());
  }
  try {
    db.deleteUser(username);
  }
 catch (  SQLException e) {
    return new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + ""String_Node_Str"" + e.getMessage());
  }
  return new MinimalResponse(HttpStatusCode.OK);
}","@Override public Response execute(){
  DatabaseAccessor db;
  try {
    db=initDB();
  }
 catch (  SQLException|IOException e) {
    Debug.log(""String_Node_Str"" + username + ""String_Node_Str""+ e.getMessage());
    return new ErrorResponse(HttpStatusCode.INTERNAL_SERVER_ERROR,""String_Node_Str"" + username + ""String_Node_Str"");
  }
  try {
    db.deleteUser(username);
  }
 catch (  SQLException e) {
    Debug.log(""String_Node_Str"" + username + ""String_Node_Str""+ e.getMessage());
    return new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + ""String_Node_Str"");
  }
 finally {
    db.close();
  }
  return new MinimalResponse(HttpStatusCode.OK);
}",0.4366744366744367
38126,"/** 
 * Runs the command. The user gets added to the database.
 * @return a MinimalResponse or ErrorResponse
 */
@Override public Response execute(){
  DatabaseAccessor db;
  try {
    db=initDB();
  }
 catch (  SQLException e) {
    return new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + ""String_Node_Str"" + e.getMessage());
  }
catch (  IOException e) {
    return new ErrorResponse(HttpStatusCode.BAD_REQUEST,e.getMessage());
  }
  try {
    String hash=BCrypt.hashpw(password,BCrypt.gensalt());
    db.addUser(username,hash,""String_Node_Str"",privileges,name,email);
  }
 catch (  SQLException|IOException e) {
    return new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + ""String_Node_Str"" + e.getMessage());
  }
  return new MinimalResponse(HttpStatusCode.CREATED);
}","/** 
 * Runs the command. The user gets added to the database.
 * @return a MinimalResponse or ErrorResponse
 */
@Override public Response execute(){
  DatabaseAccessor db;
  try {
    db=initDB();
  }
 catch (  SQLException|IOException e) {
    Debug.log(""String_Node_Str"" + username + ""String_Node_Str""+ e.getMessage());
    return new ErrorResponse(HttpStatusCode.INTERNAL_SERVER_ERROR,""String_Node_Str"" + username + ""String_Node_Str"");
  }
  try {
    String hash=BCrypt.hashpw(password,BCrypt.gensalt());
    db.addUser(username,hash,""String_Node_Str"",privileges,name,email);
  }
 catch (  SQLException|IOException e) {
    Debug.log(""String_Node_Str"" + username + ""String_Node_Str""+ e.getMessage());
    return new ErrorResponse(HttpStatusCode.INTERNAL_SERVER_ERROR,""String_Node_Str"" + username + ""String_Node_Str"");
  }
 finally {
    db.close();
  }
  return new MinimalResponse(HttpStatusCode.CREATED);
}",0.7062937062937062
38127,"/** 
 * Set the UserType. Uri and Uuid not used in this command.
 * @param uri the URI from the http request.
 * @param uuid
 * @param userType
 */
@Override public void setFields(String uri,String uuid,UserMethods.UserType userType){
  this.userType=userType;
}","/** 
 * Set the UserType. Uri and Uuid not used in this command.
 * @param uri the URI from the http request.
 * @param uuid the uuid from the http request.
 * @param userType the userType
 */
@Override public void setFields(String uri,String uuid,UserMethods.UserType userType){
  this.userType=userType;
}",0.92091388400703
38128,"/** 
 * Perform the action of the command and return a response. A connection to the database is established and the user is updated with the information given.
 * @return a response of the result of the command.
 */
@Override public Response execute(){
  DatabaseAccessor db;
  try {
    db=initDB();
  }
 catch (  SQLException|IOException e) {
    Debug.log(""String_Node_Str"" + username + ""String_Node_Str""+ e.getMessage());
    return new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + ""String_Node_Str"" + e.getMessage());
  }
  try {
    String hash=BCrypt.hashpw(password,BCrypt.gensalt());
    db.updateUser(username,hash,privileges,name,email);
  }
 catch (  SQLException|IOException e) {
    Debug.log(""String_Node_Str"" + username + ""String_Node_Str""+ e.getMessage());
    return new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + ""String_Node_Str"" + username + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ e.getMessage());
  }
  return new MinimalResponse(HttpStatusCode.OK);
}","/** 
 * Perform the action of the command and return a response. A connection to the database is established and the user is updated with the information given.
 * @return a response of the result of the command.
 */
@Override public Response execute(){
  DatabaseAccessor db;
  try {
    db=initDB();
  }
 catch (  SQLException|IOException e) {
    Debug.log(""String_Node_Str"" + username + ""String_Node_Str""+ e.getMessage());
    return new ErrorResponse(HttpStatusCode.INTERNAL_SERVER_ERROR,""String_Node_Str"" + username + ""String_Node_Str"");
  }
  try {
    String hash=BCrypt.hashpw(password,BCrypt.gensalt());
    db.updateUser(username,hash,privileges,name,email);
  }
 catch (  SQLException|IOException e) {
    Debug.log(""String_Node_Str"" + username + ""String_Node_Str""+ e.getMessage());
    return new ErrorResponse(HttpStatusCode.INTERNAL_SERVER_ERROR,""String_Node_Str"" + ""String_Node_Str"" + username + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  }
 finally {
    db.close();
  }
  return new MinimalResponse(HttpStatusCode.OK);
}",0.9187890437289764
38129,"/** 
 * Used to make sure the strings of the command are correct
 * @throws command.ValidateException
 */
@Override public void validate() throws ValidateException {
  validateName(username,MaxLength.USERNAME,""String_Node_Str"");
  validateName(password,MaxLength.PASSWORD,""String_Node_Str"");
  validateName(privileges,MaxLength.ROLE,""String_Node_Str"");
  validateExists(name,MaxLength.FULLNAME,""String_Node_Str"");
  validateExists(email,MaxLength.EMAIL,""String_Node_Str"");
}","/** 
 * Used to make sure the strings of the command are correct
 * @throws command.ValidateException
 */
@Override public void validate() throws ValidateException {
  hasRights(UserRights.getRights(this.getClass()));
  validateName(username,MaxLength.USERNAME,""String_Node_Str"");
  validateName(password,MaxLength.PASSWORD,""String_Node_Str"");
  validateName(privileges,MaxLength.ROLE,""String_Node_Str"");
  validateExists(name,MaxLength.FULLNAME,""String_Node_Str"");
  validateExists(email,MaxLength.EMAIL,""String_Node_Str"");
}",0.948
38130,"@Override public Response execute(){
  DatabaseAccessor db=null;
  try {
    db=initDB();
    ArrayList<String> annotations=db.getAllAnnotationLabels();
    if (annotations.contains(name)) {
      db.deleteAnnotation(name);
      return new MinimalResponse(200);
    }
 else {
      return new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + name + ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
 catch (  SQLException e) {
    e.printStackTrace();
    return new ErrorResponse(HttpStatusCode.BAD_REQUEST,e.getMessage());
  }
catch (  IOException e) {
    e.printStackTrace();
    return new ErrorResponse(HttpStatusCode.SERVICE_UNAVAILABLE,e.getMessage());
  }
 finally {
    if (db != null) {
      db.close();
    }
  }
}","@Override public Response execute(){
  DatabaseAccessor db=null;
  try {
    db=initDB();
    ArrayList<String> annotations=db.getAllAnnotationLabels();
    if (annotations.contains(name)) {
      db.deleteAnnotation(name);
      return new MinimalResponse(200);
    }
 else {
      return new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + name + ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
 catch (  SQLException|IOException e) {
    Debug.log(""String_Node_Str"" + name + ""String_Node_Str""+ e.getMessage());
    return new ErrorResponse(HttpStatusCode.INTERNAL_SERVER_ERROR,""String_Node_Str"" + name + ""String_Node_Str"");
  }
 finally {
    if (db != null) {
      db.close();
    }
  }
}",0.7330567081604425
38131,"@Override public Response execute(){
  DatabaseAccessor db=null;
  try {
    db=initDB();
    List<String> values=db.getChoices(name);
    if (values.contains(value)) {
      db.removeDropDownAnnotationValue(name,value);
    }
 else {
      return new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + value + ""String_Node_Str""+ name+ ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
 catch (  SQLException e) {
    e.printStackTrace();
    return new ErrorResponse(HttpStatusCode.NO_CONTENT,e.getMessage());
  }
catch (  IOException e) {
    e.printStackTrace();
    return new ErrorResponse(HttpStatusCode.SERVICE_UNAVAILABLE,e.getMessage());
  }
 finally {
    if (db != null) {
      db.close();
    }
  }
  return new MinimalResponse(HttpStatusCode.OK);
}","@Override public Response execute(){
  DatabaseAccessor db=null;
  try {
    db=initDB();
    List<String> values=db.getChoices(name);
    if (values.contains(value)) {
      db.removeDropDownAnnotationValue(name,value);
    }
 else {
      return new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + value + ""String_Node_Str""+ name+ ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
 catch (  IOException|SQLException e) {
    Debug.log(""String_Node_Str"" + value + ""String_Node_Str""+ name+ ""String_Node_Str""+ e.getMessage());
    return new ErrorResponse(HttpStatusCode.INTERNAL_SERVER_ERROR,""String_Node_Str"" + value + ""String_Node_Str""+ name+ ""String_Node_Str"");
  }
 finally {
    if (db != null) {
      db.close();
    }
  }
  return new MinimalResponse(HttpStatusCode.OK);
}",0.7012156110044786
38132,"@Override public Response execute(){
  ArrayList<AnnotationInformation> annotations=new ArrayList<AnnotationInformation>();
  DatabaseAccessor db=null;
  Map<String,Integer> a;
  try {
    db=initDB();
    a=db.getAnnotations();
    List<String> list=new ArrayList<String>(a.keySet());
    for (    String label : list) {
      database.containers.Annotation annotationObject;
      ArrayList<String> values=new ArrayList<String>();
      annotationObject=db.getAnnotationObject(label);
      if (annotationObject.dataType == database.containers.Annotation.FREETEXT) {
        values.add(""String_Node_Str"");
      }
 else       if (annotationObject.dataType == database.containers.Annotation.DROPDOWN) {
        values=(ArrayList<String>)annotationObject.getPossibleValues();
      }
      AnnotationInformation annotation=new AnnotationInformation(annotationObject.label,values,annotationObject.isRequired);
      annotations.add(annotation);
    }
    return new GetAnnotationInformationResponse(HttpStatusCode.OK,annotations);
  }
 catch (  SQLException|IOException e) {
    return new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + e.getMessage());
  }
 finally {
    if (db != null) {
      db.close();
    }
  }
}","@Override public Response execute(){
  ArrayList<AnnotationInformation> annotations=new ArrayList<>();
  DatabaseAccessor db=null;
  Map<String,Integer> a;
  try {
    db=initDB();
    a=db.getAnnotations();
    List<String> list=new ArrayList<>(a.keySet());
    for (    String label : list) {
      database.containers.Annotation annotationObject;
      ArrayList<String> values=new ArrayList<>();
      annotationObject=db.getAnnotationObject(label);
      if (annotationObject.dataType == database.containers.Annotation.FREETEXT) {
        values.add(""String_Node_Str"");
      }
 else       if (annotationObject.dataType == database.containers.Annotation.DROPDOWN) {
        values=(ArrayList<String>)annotationObject.getPossibleValues();
      }
      AnnotationInformation annotation=new AnnotationInformation(annotationObject.label,values,annotationObject.isRequired);
      annotations.add(annotation);
    }
    return new GetAnnotationInformationResponse(HttpStatusCode.OK,annotations);
  }
 catch (  SQLException|IOException e) {
    Debug.log(""String_Node_Str"" + e.getMessage());
    return new ErrorResponse(HttpStatusCode.INTERNAL_SERVER_ERROR,""String_Node_Str"" + ""String_Node_Str"");
  }
 finally {
    if (db != null) {
      db.close();
    }
  }
}",0.9443331998398078
38133,"@Override public Response execute(){
  int addedAnnotations;
  int defaultValueIndex=0;
  DatabaseAccessor db=null;
  try {
    db=initDB();
    for (int i=0; i < type.size(); i++) {
      if (type.get(i).equals(defaults)) {
        defaultValueIndex=i;
        break;
      }
    }
    if (type.size() == 1 && type.get(0).equals(""String_Node_Str"")) {
      addedAnnotations=db.addFreeTextAnnotation(name,defaults,forced);
    }
 else {
      addedAnnotations=db.addDropDownAnnotation(name,type,defaultValueIndex,forced);
    }
    if (addedAnnotations != 0) {
      return new AddAnnotationFieldResponse(HttpStatusCode.CREATED);
    }
 else {
      return new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + ""String_Node_Str"");
    }
  }
 catch (  SQLException e) {
    e.printStackTrace();
    if (e.getErrorCode() == 0) {
      return new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + ""String_Node_Str"" + name + ""String_Node_Str"");
    }
 else {
      return new ErrorResponse(HttpStatusCode.SERVICE_UNAVAILABLE,e.getMessage());
    }
  }
catch (  IOException e) {
    e.printStackTrace();
    return new ErrorResponse(HttpStatusCode.BAD_REQUEST,e.getMessage());
  }
 finally {
    if (db != null) {
      db.close();
    }
  }
}","@Override public Response execute(){
  int addedAnnotations;
  int defaultValueIndex=0;
  DatabaseAccessor db=null;
  try {
    db=initDB();
    for (int i=0; i < type.size(); i++) {
      if (type.get(i).equals(defaults)) {
        defaultValueIndex=i;
        break;
      }
    }
    if (type.size() == 1 && type.get(0).equals(""String_Node_Str"")) {
      addedAnnotations=db.addFreeTextAnnotation(name,defaults,forced);
    }
 else {
      addedAnnotations=db.addDropDownAnnotation(name,type,defaultValueIndex,forced);
    }
    if (addedAnnotations != 0) {
      return new AddAnnotationFieldResponse(HttpStatusCode.CREATED);
    }
 else {
      return new ErrorResponse(HttpStatusCode.INTERNAL_SERVER_ERROR,""String_Node_Str"" + name + ""String_Node_Str"");
    }
  }
 catch (  SQLException e) {
    if (e.getErrorCode() == 0) {
      Debug.log(""String_Node_Str"" + name + ""String_Node_Str""+ e.getMessage());
      return new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + ""String_Node_Str"" + name + ""String_Node_Str"");
    }
 else {
      Debug.log(""String_Node_Str"" + name + ""String_Node_Str""+ e.getMessage());
      return new ErrorResponse(HttpStatusCode.INTERNAL_SERVER_ERROR,""String_Node_Str"" + name + ""String_Node_Str"");
    }
  }
catch (  IOException e) {
    Debug.log(""String_Node_Str"" + name + ""String_Node_Str""+ e.getMessage());
    return new ErrorResponse(HttpStatusCode.INTERNAL_SERVER_ERROR,""String_Node_Str"" + ""String_Node_Str"" + name + ""String_Node_Str"");
  }
 finally {
    if (db != null) {
      db.close();
    }
  }
}",0.6517412935323383
38134,"@Override public Response execute(){
  DatabaseAccessor db;
  String dbHash;
  try {
    db=initDB();
    dbHash=db.getPasswordHash(username);
  }
 catch (  SQLException|IOException e) {
    Debug.log(""String_Node_Str"" + username + ""String_Node_Str""+ e.getMessage());
    return new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + username + ""String_Node_Str""+ e.getMessage());
  }
  if (dbHash == null || dbHash.isEmpty()) {
    return new ErrorResponse(HttpStatusCode.UNAUTHORIZED,""String_Node_Str"");
  }
  LoginAttempt login=Authenticate.login(username,password,dbHash);
  if (login.wasSuccessful()) {
    Debug.log(""String_Node_Str"" + username + ""String_Node_Str""+ Authenticate.getID(username));
    return new LoginResponse(200,login.getUUID());
  }
  Debug.log(""String_Node_Str"" + username + ""String_Node_Str""+ login.getErrorMessage());
  return new ErrorResponse(HttpStatusCode.UNAUTHORIZED,login.getErrorMessage());
}","@Override public Response execute(){
  DatabaseAccessor db=null;
  String dbHash;
  try {
    db=initDB();
    dbHash=db.getPasswordHash(username);
  }
 catch (  SQLException|IOException e) {
    Debug.log(""String_Node_Str"" + username + ""String_Node_Str""+ e.getMessage());
    return new ErrorResponse(HttpStatusCode.INTERNAL_SERVER_ERROR,""String_Node_Str"" + username + ""String_Node_Str"");
  }
 finally {
    if (db != null) {
      db.close();
    }
  }
  if (dbHash == null || dbHash.isEmpty()) {
    return new ErrorResponse(HttpStatusCode.UNAUTHORIZED,""String_Node_Str"");
  }
  LoginAttempt login=Authenticate.login(username,password,dbHash);
  if (login.wasSuccessful()) {
    Debug.log(""String_Node_Str"" + username + ""String_Node_Str""+ Authenticate.getID(username));
    return new LoginResponse(200,login.getUUID());
  }
  Debug.log(""String_Node_Str"" + username + ""String_Node_Str""+ login.getErrorMessage());
  return new ErrorResponse(HttpStatusCode.UNAUTHORIZED,login.getErrorMessage());
}",0.9400826446280992
38135,"public Response execute(){
  DatabaseAccessor db=null;
  try {
    db=initDB();
    int tuples=db.deleteExperiment(expID);
    if (tuples == 0) {
      return new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + expID + ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
 catch (  SQLException e) {
    return new ErrorResponse(HttpStatusCode.BAD_REQUEST,Integer.toString(e.getErrorCode()));
  }
catch (  IOException e) {
    return new ErrorResponse(HttpStatusCode.BAD_REQUEST,e.getMessage());
  }
 finally {
    if (db != null) {
      db.close();
    }
  }
  return new MinimalResponse(HttpStatusCode.OK);
}","public Response execute(){
  DatabaseAccessor db=null;
  try {
    db=initDB();
    int tuples=db.deleteExperiment(expID);
    if (tuples == 0) {
      return new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + expID + ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
 catch (  SQLException|IOException e) {
    Debug.log(""String_Node_Str"" + expID + ""String_Node_Str""+ e.getMessage());
    return new ErrorResponse(HttpStatusCode.INTERNAL_SERVER_ERROR,""String_Node_Str"" + expID + ""String_Node_Str"");
  }
 finally {
    if (db != null) {
      db.close();
    }
  }
  return new MinimalResponse(HttpStatusCode.OK);
}",0.7756410256410257
38136,"@Override public Response execute(){
  Experiment exp;
  DatabaseAccessor db;
  try {
    db=initDB();
  }
 catch (  SQLException|IOException e) {
    return new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + ""String_Node_Str"" + e.getMessage());
  }
  try {
    exp=db.getExperiment(expID);
  }
 catch (  SQLException e) {
    return new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + ""String_Node_Str"" + e.getMessage());
  }
  db.close();
  if (exp == null) {
    return new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  return new GetExperimentResponse(HttpStatusCode.OK,getInfo(exp),exp.getAnnotations(),exp.getFiles());
}","@Override public Response execute(){
  Experiment exp;
  DatabaseAccessor db;
  try {
    db=initDB();
  }
 catch (  SQLException|IOException e) {
    Debug.log(""String_Node_Str"" + expID + ""String_Node_Str""+ e.getMessage());
    return new ErrorResponse(HttpStatusCode.INTERNAL_SERVER_ERROR,""String_Node_Str"" + ""String_Node_Str"");
  }
  try {
    exp=db.getExperiment(expID);
  }
 catch (  SQLException e) {
    Debug.log(""String_Node_Str"" + expID + ""String_Node_Str""+ e.getMessage());
    return new ErrorResponse(HttpStatusCode.INTERNAL_SERVER_ERROR,""String_Node_Str"" + ""String_Node_Str"" + expID + ""String_Node_Str"");
  }
 finally {
    if (db != null) {
      db.close();
    }
  }
  if (exp == null) {
    return new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  return new GetExperimentResponse(HttpStatusCode.OK,getInfo(exp),exp.getAnnotations(),exp.getFiles());
}",0.4522796352583587
38137,"@Override public Response execute(){
  DatabaseAccessor db=null;
  try {
    db=initDB();
    db.addExperiment(name);
    for (    Annotation annotation : annotations) {
      db.annotateExperiment(name,annotation.getName(),annotation.getValue());
    }
    return new MinimalResponse(HttpStatusCode.CREATED);
  }
 catch (  IOException|SQLException e) {
    e.printStackTrace();
    return new ErrorResponse(HttpStatusCode.BAD_REQUEST,e.getMessage());
  }
 finally {
    if (db != null) {
      db.close();
    }
  }
}","@Override public Response execute(){
  DatabaseAccessor db=null;
  try {
    db=initDB();
    db.addExperiment(name);
    for (    Annotation annotation : annotations) {
      db.annotateExperiment(name,annotation.getName(),annotation.getValue());
    }
    return new MinimalResponse(HttpStatusCode.CREATED);
  }
 catch (  IOException|SQLException e) {
    e.printStackTrace();
    Debug.log(""String_Node_Str"" + name + ""String_Node_Str""+ e.getMessage());
    return new ErrorResponse(HttpStatusCode.INTERNAL_SERVER_ERROR,""String_Node_Str"" + name + ""String_Node_Str"");
  }
 finally {
    if (db != null) {
      db.close();
    }
  }
}",0.8568950563746748
38138,"@Override public Response execute(){
  DatabaseAccessor db=null;
  try {
    db=initDB();
    try {
      if (db.deleteFile(Integer.parseInt(fileID)) == 1) {
        return new MinimalResponse(HttpStatusCode.OK);
      }
 else {
        return new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + fileID + ""String_Node_Str""+ ""String_Node_Str"");
      }
    }
 catch (    NumberFormatException e) {
      if (db.deleteFile(fileID) > 0) {
        return new MinimalResponse(HttpStatusCode.OK);
      }
 else {
        return new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + fileID + ""String_Node_Str""+ ""String_Node_Str"");
      }
    }
  }
 catch (  SQLException e) {
    e.printStackTrace();
    return new ErrorResponse(HttpStatusCode.SERVICE_UNAVAILABLE,e.getMessage());
  }
catch (  IOException e) {
    return new ErrorResponse(HttpStatusCode.BAD_REQUEST,e.getMessage());
  }
 finally {
    if (db != null) {
      db.close();
    }
  }
}","@Override public Response execute(){
  DatabaseAccessor db=null;
  try {
    db=initDB();
    try {
      if (db.deleteFile(Integer.parseInt(fileID)) == 1) {
        return new MinimalResponse(HttpStatusCode.OK);
      }
 else {
        return new ErrorResponse(HttpStatusCode.NOT_FOUND,""String_Node_Str"" + fileID + ""String_Node_Str""+ ""String_Node_Str"");
      }
    }
 catch (    NumberFormatException e) {
      if (db.deleteFile(fileID) > 0) {
        return new MinimalResponse(HttpStatusCode.OK);
      }
 else {
        return new ErrorResponse(HttpStatusCode.NOT_FOUND,""String_Node_Str"" + fileID + ""String_Node_Str""+ ""String_Node_Str"");
      }
    }
  }
 catch (  SQLException|IOException e) {
    Debug.log(""String_Node_Str"" + fileID + ""String_Node_Str""+ e.getMessage());
    return new ErrorResponse(HttpStatusCode.INTERNAL_SERVER_ERROR,""String_Node_Str"" + fileID + ""String_Node_Str"");
  }
 finally {
    if (db != null) {
      db.close();
    }
  }
}",0.8306576903158985
38139,"/** 
 * Adds all attributes to an ArrayList and passes that and the experimentID to the database. A file path is returned and sent to the client as an URL.
 */
@Override public Response execute(){
  DatabaseAccessor db=null;
  int fileType;
  if (type.equalsIgnoreCase(""String_Node_Str"")) {
    fileType=FileTuple.RAW;
  }
 else   if (type.equalsIgnoreCase(""String_Node_Str"")) {
    fileType=FileTuple.PROFILE;
  }
 else   if (type.equalsIgnoreCase(""String_Node_Str"")) {
    fileType=FileTuple.REGION;
  }
 else {
    fileType=FileTuple.OTHER;
  }
  try {
    db=initDB();
    FileTuple ft=db.addNewInProgressFile(experimentID,fileType,fileName,null,metaData,author,uploader,false,grVersion,checkSumMD5);
    return new AddFileToExperimentResponse(HttpStatusCode.OK,ft.getUploadURL());
  }
 catch (  SQLException e) {
    e.printStackTrace();
    return new ErrorResponse(HttpStatusCode.BAD_REQUEST,e.getMessage());
  }
catch (  IOException e) {
    e.printStackTrace();
    return new ErrorResponse(HttpStatusCode.SERVICE_UNAVAILABLE,e.getMessage());
  }
 finally {
    if (db != null) {
      db.close();
    }
  }
}","/** 
 * Adds all attributes to an ArrayList and passes that and the experimentID to the database. A file path is returned and sent to the client as an URL.
 */
@Override public Response execute(){
  DatabaseAccessor db=null;
  int fileType;
  if (type.equalsIgnoreCase(""String_Node_Str"")) {
    fileType=FileTuple.RAW;
  }
 else   if (type.equalsIgnoreCase(""String_Node_Str"")) {
    fileType=FileTuple.PROFILE;
  }
 else   if (type.equalsIgnoreCase(""String_Node_Str"")) {
    fileType=FileTuple.REGION;
  }
 else {
    fileType=FileTuple.OTHER;
  }
  try {
    db=initDB();
    FileTuple ft=db.addNewInProgressFile(experimentID,fileType,fileName,null,metaData,author,uploader,false,grVersion,checkSumMD5);
    return new AddFileToExperimentResponse(HttpStatusCode.OK,ft.getUploadURL());
  }
 catch (  SQLException|IOException e) {
    Debug.log(""String_Node_Str"" + fileName + ""String_Node_Str""+ experimentID+ ""String_Node_Str""+ e.getMessage());
    return new ErrorResponse(HttpStatusCode.INTERNAL_SERVER_ERROR,""String_Node_Str"" + fileName + ""String_Node_Str""+ experimentID+ ""String_Node_Str"");
  }
 finally {
    if (db != null) {
      db.close();
    }
  }
}",0.8366988586479368
38140,"@Override public Response execute(){
  DatabaseAccessor db=null;
  List<Experiment> searchResult=null;
  try {
    annotations=URLDecoder.decode(annotations,""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
    e.printStackTrace();
    return new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + ""String_Node_Str"");
  }
  try {
    db=initDB();
    searchResult=db.search(annotations);
  }
 catch (  SQLException|IOException e) {
    return new ErrorResponse(HttpStatusCode.SERVICE_UNAVAILABLE,e.getMessage());
  }
catch (  ParseException e) {
    return new ErrorResponse(HttpStatusCode.BAD_REQUEST,e.getMessage());
  }
 finally {
    if (db != null)     db.close();
  }
  SearchResponse response=new SearchResponse(searchResult);
  return response;
}","@Override public Response execute(){
  DatabaseAccessor db=null;
  List<Experiment> searchResult=null;
  try {
    annotations=URLDecoder.decode(annotations,""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
    Debug.log(""String_Node_Str"" + annotations + ""String_Node_Str""+ e.getMessage());
    return new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + annotations + ""String_Node_Str"");
  }
  try {
    db=initDB();
    searchResult=db.search(annotations);
  }
 catch (  SQLException|IOException e) {
    Debug.log(""String_Node_Str"" + annotations + ""String_Node_Str""+ e.getMessage());
    return new ErrorResponse(HttpStatusCode.INTERNAL_SERVER_ERROR,""String_Node_Str"" + annotations + ""String_Node_Str"");
  }
catch (  ParseException e) {
    Debug.log(""String_Node_Str"" + annotations + ""String_Node_Str""+ e.getMessage());
    return new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + ""String_Node_Str"");
  }
 finally {
    if (db != null)     db.close();
  }
  SearchResponse response=new SearchResponse(searchResult);
  return response;
}",0.7520085698982325
38141,"/** 
 * Perform the action of the command and return a response. A connection to the database is established, authentication is performed and a response is return of the result.
 * @return a response of the result of the command.
 */
@Override public Response execute(){
  DatabaseAccessor db;
  String dbHash;
  try {
    db=initDB();
    dbHash=db.getPasswordHash(username);
  }
 catch (  SQLException|IOException e) {
    Debug.log(""String_Node_Str"" + username + ""String_Node_Str""+ e.getMessage());
    return new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + username + ""String_Node_Str""+ e.getMessage());
  }
  if (dbHash == null || dbHash.isEmpty()) {
    return new ErrorResponse(HttpStatusCode.UNAUTHORIZED,""String_Node_Str"" + username);
  }
  LoginAttempt login=Authenticate.login(username,oldPassword,dbHash);
  if (login.wasSuccessful()) {
    try {
      String hash=BCrypt.hashpw(newPassword,BCrypt.gensalt());
      db.updateUser(username,hash,name,email);
    }
 catch (    SQLException|IOException e) {
      Debug.log(""String_Node_Str"" + username + ""String_Node_Str""+ e.getMessage());
      return new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + ""String_Node_Str"" + username + ""String_Node_Str""+ e.getMessage());
    }
    return new MinimalResponse(HttpStatusCode.OK);
  }
  Debug.log(""String_Node_Str"" + username + ""String_Node_Str"");
  return new ErrorResponse(HttpStatusCode.UNAUTHORIZED,""String_Node_Str"" + username + ""String_Node_Str""+ login.getErrorMessage());
}","/** 
 * Perform the action of the command and return a response. A connection to the database is established, authentication is performed and a response is return of the result.
 * @return a response of the result of the command.
 */
@Override public Response execute(){
  DatabaseAccessor db;
  String dbHash;
  try {
    db=initDB();
    dbHash=db.getPasswordHash(username);
  }
 catch (  SQLException|IOException e) {
    Debug.log(""String_Node_Str"" + username + ""String_Node_Str""+ e.getMessage());
    return new ErrorResponse(HttpStatusCode.INTERNAL_SERVER_ERROR,""String_Node_Str"" + ""String_Node_Str"");
  }
  if (dbHash == null || dbHash.isEmpty()) {
    return new ErrorResponse(HttpStatusCode.UNAUTHORIZED,""String_Node_Str"" + username);
  }
  LoginAttempt login=Authenticate.login(username,oldPassword,dbHash);
  if (login.wasSuccessful()) {
    try {
      String hash=BCrypt.hashpw(newPassword,BCrypt.gensalt());
      db.updateUser(username,hash,name,email);
    }
 catch (    SQLException|IOException e) {
      Debug.log(""String_Node_Str"" + username + ""String_Node_Str""+ e.getMessage());
      return new ErrorResponse(HttpStatusCode.INTERNAL_SERVER_ERROR,""String_Node_Str"" + ""String_Node_Str"");
    }
 finally {
      if (db != null)       db.close();
    }
    return new MinimalResponse(HttpStatusCode.OK);
  }
  Debug.log(""String_Node_Str"" + username + ""String_Node_Str"");
  return new ErrorResponse(HttpStatusCode.UNAUTHORIZED,""String_Node_Str"" + ""String_Node_Str"");
}",0.9017649017649018
38142,"/** 
 * Used to execute the actual password change of the user.
 */
@Override public Response execute(){
  DatabaseAccessor db=null;
  try {
    db=initDB();
  }
 catch (  SQLException|IOException e) {
    Debug.log(""String_Node_Str"" + username + ""String_Node_Str""+ e.getMessage());
    return new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + username + ""String_Node_Str""+ e.getMessage());
  }
  String hash=BCrypt.hashpw(password,BCrypt.gensalt());
  try {
    db.resetPassword(username,hash);
  }
 catch (  SQLException|IOException e) {
    return new ErrorResponse(HttpStatusCode.BAD_REQUEST,""String_Node_Str"" + e.getMessage());
  }
  return new MinimalResponse(HttpStatusCode.CREATED);
}","/** 
 * Used to execute the actual password change of the user.
 */
@Override public Response execute(){
  DatabaseAccessor db;
  try {
    db=initDB();
  }
 catch (  SQLException|IOException e) {
    Debug.log(""String_Node_Str"" + username + ""String_Node_Str""+ e.getMessage());
    return new ErrorResponse(HttpStatusCode.INTERNAL_SERVER_ERROR,""String_Node_Str"" + username + ""String_Node_Str"");
  }
  String hash=BCrypt.hashpw(password,BCrypt.gensalt());
  try {
    db.resetPassword(username,hash);
  }
 catch (  SQLException|IOException e) {
    Debug.log(""String_Node_Str"" + username + ""String_Node_Str""+ e.getMessage());
    return new ErrorResponse(HttpStatusCode.INTERNAL_SERVER_ERROR,""String_Node_Str"" + username + ""String_Node_Str"");
  }
 finally {
    if (db != null)     db.close();
  }
  return new MinimalResponse(HttpStatusCode.CREATED);
}",0.8364336112892881
38143,"/** 
 * Validates that all parameters procedure takes is valid.
 * @param parameters
 * @param inFolder
 * @param outFilePath
 * @return
 */
private boolean verifyInData(String[] parameters,String inFolder,String outFilePath){
  if (parameters == null) {
    System.out.println(""String_Node_Str"");
    return false;
  }
  if (parameters.length < 0) {
    System.out.println(""String_Node_Str"");
    return false;
  }
 else   if (parameters.length > 8) {
    System.out.println(""String_Node_Str"");
    return false;
  }
  if (inFolder == null || outFilePath == null) {
    System.out.println(""String_Node_Str"");
    return false;
  }
  if (!checkIfFolderExists(outFilePath) || !checkIfFolderExists(inFolder)) {
    System.out.println(""String_Node_Str"");
    return false;
  }
  return true;
}","/** 
 * Validates that all parameters procedure takes is valid.
 * @param parameters
 * @param inFolder
 * @param outFilePath
 * @return
 */
private boolean verifyInData(String[] parameters,String inFolder,String outFilePath){
  if (parameters == null) {
    ErrorLogger.log(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
    return false;
  }
  if (parameters.length < 0) {
    ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
    return false;
  }
 else   if (parameters.length > 8) {
    ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
    return false;
  }
  if (inFolder == null || outFilePath == null) {
    ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
    return false;
  }
  if (!checkIfFolderExists(outFilePath) || !checkIfFolderExists(inFolder)) {
    ErrorLogger.log(""String_Node_Str"",""String_Node_Str"");
    return false;
  }
  return true;
}",0.7343283582089553
38144,"/** 
 * Initiates strings using the incoming parameters and executes the two scripts to do the ratio calculation.
 * @param dirPath the path to where the files used to run ratio calculation is
 * @param parameters contains the parameters for the two scripts
 * @throws ProcessException
 */
private void doRatioCalculation(String dirPath,String[] parameters) throws ProcessException {
  String ratioCalc=""String_Node_Str"" + dirPath + ""String_Node_Str""+ parameters[6];
  try {
    logString=logString + executeScript(parse(ratioCalc));
    System.out.println(""String_Node_Str"" + logString);
  }
 catch (  InterruptedException e) {
    throw new ProcessException(""String_Node_Str"" + dirPath);
  }
catch (  IOException e) {
    throw new ProcessException(""String_Node_Str"" + dirPath);
  }
}","/** 
 * Initiates strings using the incoming parameters and executes the two scripts to do the ratio calculation.
 * @param dirPath the path to where the files used to run ratio calculation is
 * @param parameters contains the parameters for the two scripts
 * @throws ProcessException
 */
private void doRatioCalculation(String dirPath,String[] parameters) throws ProcessException {
  String ratioCalc=""String_Node_Str"" + dirPath + ""String_Node_Str""+ parameters[6];
  try {
    logString=logString + executeScript(parse(ratioCalc));
    ErrorLogger.log(""String_Node_Str"",""String_Node_Str"" + logString);
  }
 catch (  InterruptedException e) {
    throw new ProcessException(""String_Node_Str"" + dirPath);
  }
catch (  IOException e) {
    throw new ProcessException(""String_Node_Str"" + dirPath);
  }
}",0.9691241335853812
38145,"/** 
 * Constructs a string array with the values to run bowtie on the file that comes as parameter.
 * @param fileOne the name of the file with the file extension.
 * @param fileOneName the name of the file without the file extension.
 * @return the value that bowtie returns.ckIfFolderExists(outFilePath)
 * @throws InterruptedException
 * @throws IOException
 * @throws ProcessException
 */
private String runBowTie(String fileOne,String fileOneName) throws ProcessException {
  String bowTieParams=checkBowTieProcessors(parameters[0]);
  String[] bowTieParameters=parse(ServerSettings.bowtieLocation + ""String_Node_Str"" + bowTieParams+ ""String_Node_Str""+ parameters[1]+ ""String_Node_Str""+ inFolder+ ""String_Node_Str""+ fileOne+ ""String_Node_Str""+ dir+ fileOneName+ ""String_Node_Str"");
  try {
    return executeProgram(bowTieParameters);
  }
 catch (  InterruptedException e) {
    throw new ProcessException(""String_Node_Str"" + fileOneName);
  }
catch (  IOException e) {
    throw new ProcessException(""String_Node_Str"" + fileOneName + ""String_Node_Str"");
  }
}","/** 
 * Constructs a string array with the values to run bowtie on the file that comes as parameter.
 * @param fileOne the name of the file with the file extension.
 * @param fileOneName the name of the file without the file extension.
 * @return the value that bowtie returns.ckIfFolderExists(outFilePath)
 * @throws InterruptedException
 * @throws IOException
 * @throws ProcessException
 */
private String runBowTie(String fileOne,String fileOneName) throws ProcessException {
  String bowTieParams=checkBowTieProcessors(parameters[0]);
  String[] bowTieParameters=parse(""String_Node_Str"" + ServerSettings.bowtieLocation + ""String_Node_Str""+ bowTieParams+ ""String_Node_Str""+ parameters[1]+ ""String_Node_Str""+ inFolder+ ""String_Node_Str""+ fileOne+ ""String_Node_Str""+ dir+ fileOneName+ ""String_Node_Str"");
  try {
    return executeProgram(bowTieParameters);
  }
 catch (  InterruptedException e) {
    throw new ProcessException(""String_Node_Str"" + fileOneName);
  }
catch (  IOException e) {
    throw new ProcessException(""String_Node_Str"" + fileOneName + ""String_Node_Str"");
  }
}",0.99023709902371
38146,"/** 
 * Method used to create command objects together with CommandFactory.
 * @param json the JSON part of the request as a string.
 * @param uri the URI found in the request line of the request..
 * @param cmdt the assumed command type of the JSON object.
 * @return an executable Command object of the correct type.
 */
private Command createCommand(String json,String uri,String uuid,CommandType cmdt){
  if (RestfulSizes.getSize(cmdt) != calculateURISize(uri)) {
    return null;
  }
  Command newCommand=null;
  String parsedURI=parseRequestURI(uri);
  String username=Authenticate.getUsernameByID(uuid);
  String[] rest;
switch (cmdt) {
case DELETE_ANNOTATION_VALUE_COMMAND:
    rest=uri.split(""String_Node_Str"");
  newCommand=cmdFactory.createDeleteAnnotationValueCommand(rest[3],rest[4]);
break;
case LOGIN_COMMAND:
newCommand=cmdFactory.createLoginCommand(json);
break;
case LOGOUT_COMMAND:
newCommand=cmdFactory.createLogoutCommand(username);
break;
case GET_EXPERIMENT_COMMAND:
newCommand=cmdFactory.createGetExperimentCommand(parsedURI);
break;
case ADD_EXPERIMENT_COMMAND:
newCommand=cmdFactory.createAddExperimentCommand(json);
break;
case UPDATE_EXPERIMENT_COMMAND:
newCommand=cmdFactory.createUpdateExperimentCommand(json,parsedURI);
break;
case DELETE_EXPERIMENT_COMMAND:
newCommand=cmdFactory.createDeleteExperimentCommand(parsedURI);
break;
case GET_FILE_FROM_EXPERIMENT_COMMAND:
newCommand=cmdFactory.createGetFileFromExperimentCommand(parsedURI);
break;
case ADD_FILE_TO_EXPERIMENT_COMMAND:
newCommand=cmdFactory.createAddFileToExperimentCommand(json);
break;
case UPDATE_FILE_IN_EXPERIMENT_COMMAND:
newCommand=cmdFactory.createUpdateFileInExperimentCommand(json,parsedURI);
break;
case DELETE_FILE_FROM_EXPERIMENT_COMMAND:
newCommand=cmdFactory.createDeleteFileFromExperimentCommand(parsedURI);
break;
case SEARCH_FOR_EXPERIMENTS_COMMAND:
newCommand=cmdFactory.createSearchForExperimentCommand(parsedURI);
break;
case DELETE_USER_COMMAND:
newCommand=cmdFactory.createDeleteUserCommand(parsedURI);
break;
case PROCESS_COMMAND:
newCommand=cmdFactory.createProcessCommand(json,username,parsedURI);
break;
case GET_PROCESS_STATUS_COMMAND:
newCommand=cmdFactory.createGetProcessStatusCommand(workPool);
break;
case GET_ANNOTATION_INFORMATION_COMMAND:
newCommand=cmdFactory.createGetAnnotationInformationCommand(json);
break;
case ADD_ANNOTATION_FIELD_COMMAND:
newCommand=cmdFactory.createAddAnnotationFieldCommand(parsedURI);
break;
case ADD_ANNOTATION_VALUE_COMMAND:
newCommand=cmdFactory.createAddAnnotationValueCommand(json);
break;
case RENAME_ANNOTATION_VALUE_COMMAND:
newCommand=cmdFactory.creatRenameAnnotationValueCommand(json);
break;
case RENAME_ANNOTATION_FIELD_COMMAND:
newCommand=cmdFactory.createEditAnnotationFieldCommand(json);
break;
case REMOVE_ANNOTATION_FIELD_COMMAND:
newCommand=cmdFactory.createRemoveAnnotationFieldCommand(parsedURI);
break;
case GET_ANNOTATION_PRIVILEGES_COMMAND:
newCommand=cmdFactory.createGetAnnotationPrivilegesCommand(json);
break;
case UPDATE_ANNOTATION_PRIVILEGES_COMMAND:
newCommand=cmdFactory.createUpdateAnnotationPrivilegesCommand(json,parsedURI);
break;
case ADD_GENOME_RELEASE_COMMAND:
newCommand=cmdFactory.createAddGenomeReleaseCommand(json);
break;
case DELETE_GENOME_RELEASE_COMMAND:
rest=uri.split(""String_Node_Str"");
newCommand=cmdFactory.createDeleteGenomeReleaseCommand(rest[2],rest[3]);
break;
case GET_ALL_GENOME_RELEASE_COMMAND:
newCommand=cmdFactory.createGetAllGenomeReleasesCommand();
break;
case GET_GENOME_RELEASE_SPECIES_COMMAND:
newCommand=cmdFactory.createGetGenomeReleasesSpeciesCommand(parsedURI);
break;
case CREATE_USER_COMMAND:
newCommand=cmdFactory.createCreateUserCommand(json);
break;
case IS_TOKEN_VALID_COMMAND:
newCommand=cmdFactory.createIsTokenValidCommand(uuid);
break;
}
return newCommand;
}","/** 
 * Method used to create command objects together with CommandFactory.
 * @param json the JSON part of the request as a string.
 * @param uri the URI found in the request line of the request..
 * @param cmdt the assumed command type of the JSON object.
 * @return an executable Command object of the correct type.
 */
private Command createCommand(String json,String uri,String uuid,CommandType cmdt){
  if (RestfulSizes.getSize(cmdt) != calculateURISize(uri)) {
    return null;
  }
  Command newCommand=null;
  String parsedURI=parseRequestURI(uri);
  String username=Authenticate.getUsernameByID(uuid);
  String[] rest;
switch (cmdt) {
case DELETE_ANNOTATION_VALUE_COMMAND:
    rest=uri.split(""String_Node_Str"");
  newCommand=cmdFactory.createDeleteAnnotationValueCommand(rest[3],rest[4]);
break;
case LOGIN_COMMAND:
newCommand=cmdFactory.createLoginCommand(json);
break;
case LOGOUT_COMMAND:
newCommand=cmdFactory.createLogoutCommand(username);
break;
case GET_EXPERIMENT_COMMAND:
newCommand=cmdFactory.createGetExperimentCommand(parsedURI);
break;
case ADD_EXPERIMENT_COMMAND:
newCommand=cmdFactory.createAddExperimentCommand(json);
break;
case UPDATE_EXPERIMENT_COMMAND:
newCommand=cmdFactory.createUpdateExperimentCommand(json,parsedURI);
break;
case DELETE_EXPERIMENT_COMMAND:
newCommand=cmdFactory.createDeleteExperimentCommand(parsedURI);
break;
case GET_FILE_FROM_EXPERIMENT_COMMAND:
newCommand=cmdFactory.createGetFileFromExperimentCommand(parsedURI);
break;
case ADD_FILE_TO_EXPERIMENT_COMMAND:
newCommand=cmdFactory.createAddFileToExperimentCommand(json);
break;
case UPDATE_FILE_IN_EXPERIMENT_COMMAND:
newCommand=cmdFactory.createUpdateFileInExperimentCommand(json,parsedURI);
break;
case DELETE_FILE_FROM_EXPERIMENT_COMMAND:
newCommand=cmdFactory.createDeleteFileFromExperimentCommand(parsedURI);
break;
case SEARCH_FOR_EXPERIMENTS_COMMAND:
newCommand=cmdFactory.createSearchForExperimentCommand(parsedURI);
break;
case DELETE_USER_COMMAND:
newCommand=cmdFactory.createDeleteUserCommand(parsedURI);
break;
case PROCESS_COMMAND:
newCommand=cmdFactory.createProcessCommand(json,username,parsedURI);
break;
case GET_PROCESS_STATUS_COMMAND:
newCommand=cmdFactory.createGetProcessStatusCommand(workPool);
break;
case GET_ANNOTATION_INFORMATION_COMMAND:
newCommand=cmdFactory.createGetAnnotationInformationCommand(json);
break;
case ADD_ANNOTATION_FIELD_COMMAND:
newCommand=cmdFactory.createAddAnnotationFieldCommand(json);
break;
case ADD_ANNOTATION_VALUE_COMMAND:
newCommand=cmdFactory.createAddAnnotationValueCommand(json);
break;
case RENAME_ANNOTATION_VALUE_COMMAND:
newCommand=cmdFactory.creatRenameAnnotationValueCommand(json);
break;
case RENAME_ANNOTATION_FIELD_COMMAND:
newCommand=cmdFactory.createEditAnnotationFieldCommand(json);
break;
case REMOVE_ANNOTATION_FIELD_COMMAND:
newCommand=cmdFactory.createRemoveAnnotationFieldCommand(parsedURI);
break;
case GET_ANNOTATION_PRIVILEGES_COMMAND:
newCommand=cmdFactory.createGetAnnotationPrivilegesCommand(json);
break;
case UPDATE_ANNOTATION_PRIVILEGES_COMMAND:
newCommand=cmdFactory.createUpdateAnnotationPrivilegesCommand(json,parsedURI);
break;
case ADD_GENOME_RELEASE_COMMAND:
newCommand=cmdFactory.createAddGenomeReleaseCommand(json);
break;
case DELETE_GENOME_RELEASE_COMMAND:
rest=uri.split(""String_Node_Str"");
newCommand=cmdFactory.createDeleteGenomeReleaseCommand(rest[2],rest[3]);
break;
case GET_ALL_GENOME_RELEASE_COMMAND:
newCommand=cmdFactory.createGetAllGenomeReleasesCommand();
break;
case GET_GENOME_RELEASE_SPECIES_COMMAND:
newCommand=cmdFactory.createGetGenomeReleasesSpeciesCommand(parsedURI);
break;
case CREATE_USER_COMMAND:
newCommand=cmdFactory.createCreateUserCommand(json);
break;
case IS_TOKEN_VALID_COMMAND:
newCommand=cmdFactory.createIsTokenValidCommand(uuid);
break;
}
return newCommand;
}",0.9982869943339044
38147,"public synchronized HashMap<ProcessCommand,ProcessStatus> getProcesses(){
  return processStatus;
}","public synchronized HashMap<ProcessCommand,ProcessStatus> getProcesses(){
  return new HashMap<>(processStatus);
}",0.9295774647887324
38148,"/** 
 * Used when first adding a new experiment. Creates a folder for the experiment and subfolders for files
 * @param String expID, the ID for the experiment
 */
public void generateExperimentFolders(String expID){
  File file=new File(getRawFolderPath(expID));
  file.mkdirs();
  file=new File(getProfileFolderPath(expID));
  file.mkdirs();
  file=new File(getRegionFolderPath(expID));
  file.mkdirs();
  file=new File(getUnknownFolderPath(expID));
  file.mkdirs();
}","/** 
 * Used when first adding a new experiment. Creates a folder for the experiment and subfolders for files
 * @param String expID, the ID for the experiment
 */
public void generateExperimentFolders(String expID){
  File file=new File(getRawFolderPath(expID));
  file.mkdirs();
  file=new File(getProfileFolderPath(expID));
  file.mkdirs();
  file=new File(getRegionFolderPath(expID));
  file.mkdirs();
  file=new File(getUnknownFolderPath(expID));
  file.mkdirs();
  Runtime.getRuntime().exec(""String_Node_Str"" + ServerSettings.fileLocation);
}",0.9233791748526524
38149,"/** 
 * Used when first adding a new experiment. Creates a folder for the experiment and subfolders for files
 * @param String expID, the ID for the experiment
 */
public void generateExperimentFolders(String expID){
  File file=new File(getRawFolderPath(expID));
  file.mkdirs();
  file=new File(getProfileFolderPath(expID));
  file.mkdirs();
  file=new File(getRegionFolderPath(expID));
  file.mkdirs();
  file=new File(getUnknownFolderPath(expID));
  file.mkdirs();
}","/** 
 * Used when first adding a new experiment. Creates a folder for the experiment and subfolders for files
 * @param String expID, the ID for the experiment
 */
public void generateExperimentFolders(String expID){
  File file=new File(getRawFolderPath(expID));
  file.setReadable();
  file.setWritable();
  file.setExecutable();
  file.mkdirs();
  file=new File(getProfileFolderPath(expID));
  file.mkdirs();
  file=new File(getRegionFolderPath(expID));
  file.mkdirs();
  file=new File(getUnknownFolderPath(expID));
  file.mkdirs();
  Runtime.getRuntime().exec(""String_Node_Str"" + ServerSettings.fileLocation);
}",0.8655616942909761
38150,"@Before public void setup(){
  this.hasher=new PasswordHash();
}","@Before public void setup(){
}",0.6382978723404256
38151,"/** 
 * @return If the hashing returns null if a empty string is given.
 */
@Test public void toSaltedSHA256HashTestEmpty(){
  assertNull(hasher.toSaltedSHA256Hash(""String_Node_Str""));
}","/** 
 * @return If the hashing returns null if a empty string is given.
 */
@Test public void toSaltedSHA256HashTestEmpty(){
  assertNull(PasswordHash.toSaltedSHA256Hash(""String_Node_Str""));
}",0.9682539682539684
38152,"/** 
 * @return If the hashing is the same for the same string.
 */
@Test public void toSaltedSHA256HashTestEquals(){
  assertEquals(hasher.toSaltedSHA256Hash(""String_Node_Str""),(hasher.toSaltedSHA256Hash(""String_Node_Str"")));
}","/** 
 * @return If the hashing is the same for the same string.
 */
@Test public void toSaltedSHA256HashTestEquals(){
  assertEquals(PasswordHash.toSaltedSHA256Hash(""String_Node_Str""),(PasswordHash.toSaltedSHA256Hash(""String_Node_Str"")));
}",0.9230769230769232
38153,"/** 
 * @return If the hashing is different for different strings.
 */
@Test public void toSaltedSHA256HashTestNotEquals(){
  assertNotEquals(hasher.toSaltedSHA256Hash(""String_Node_Str""),(hasher.toSaltedSHA256Hash(""String_Node_Str"")));
}","/** 
 * @return If the hashing is different for different strings.
 */
@Test public void toSaltedSHA256HashTestNotEquals(){
  assertNotEquals(PasswordHash.toSaltedSHA256Hash(""String_Node_Str""),(PasswordHash.toSaltedSHA256Hash(""String_Node_Str"")));
}",0.925925925925926
38154,"/** 
 * @param args
 * @throws ParseException
 * @throws FileNotFoundException
 */
public static void main(String[] args) throws ParseException, FileNotFoundException {
  CommandLine com=loadSettingsFile(args);
  StartUpCleaner.removeOldTempDirectories(""String_Node_Str"");
  printDatabaseInformation();
  try {
    new Doorman(new CommandHandler(),ServerSettings.genomizerPort).start();
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"");
    Debug.log(e.getMessage());
    System.exit(1);
  }
  if (!com.hasOption(""String_Node_Str"")) {
    (new Thread(new InactiveUuidsRemover())).start();
  }
}","/** 
 * @param args
 * @throws ParseException
 * @throws FileNotFoundException
 */
public static void main(String[] args) throws ParseException, FileNotFoundException {
  System.out.println(""String_Node_Str"");
  CommandLine com=loadSettingsFile(args);
  StartUpCleaner.removeOldTempDirectories(""String_Node_Str"");
  printDatabaseInformation();
  try {
    new Doorman(new CommandHandler(),ServerSettings.genomizerPort).start();
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"");
    Debug.log(e.getMessage());
    System.exit(1);
  }
  if (!com.hasOption(""String_Node_Str"")) {
    (new Thread(new InactiveUuidsRemover())).start();
  }
}",0.9678935003915426
38155,"/** 
 * Print the database settings currently loaded into ServerSettings.
 */
private void printDatabaseInformation(){
  System.out.println(""String_Node_Str"" + ServerSettings.genomizerPort);
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + ServerSettings.databaseUsername);
  System.out.println(""String_Node_Str"" + ServerSettings.databasePassword);
  System.out.println(""String_Node_Str"" + ServerSettings.databaseName);
  System.out.println(""String_Node_Str"" + ServerSettings.databaseHost);
}","/** 
 * Print the database settings currently loaded into ServerSettings.
 */
private static void printDatabaseInformation(){
  System.out.println(""String_Node_Str"" + ServerSettings.genomizerPort);
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + ServerSettings.databaseUsername);
  System.out.println(""String_Node_Str"" + ServerSettings.databasePassword);
  System.out.println(""String_Node_Str"" + ServerSettings.databaseName);
  System.out.println(""String_Node_Str"" + ServerSettings.databaseHost);
}",0.9933774834437086
38156,"/** 
 * Builds a list of strings from a sql file so that they can be executed with jdbc.
 * @param path The path to the sql file
 * @return A list of sql strings from the file
 * @throws UnsupportedEncodingException
 * @throws IOException
 */
private List<String> buildSqlStringsFromFile(String path) throws UnsupportedEncodingException, IOException {
  List<String> sqlStrings=new ArrayList<String>();
  URL sqlFileUrl=SearchDatabaseTests.class.getResource(path);
  if (sqlFileUrl != null) {
    BufferedReader in=new BufferedReader(new InputStreamReader(sqlFileUrl.openStream(),""String_Node_Str""));
    String line=in.readLine();
    StringBuilder statement=new StringBuilder();
    while (line != null) {
      statement.append(line);
      if (line.endsWith(""String_Node_Str"")) {
        statement.deleteCharAt(statement.length() - 1);
        sqlStrings.add(statement.toString());
        statement.delete(0,statement.length());
      }
      line=in.readLine();
    }
  }
 else {
    throw new IOException(""String_Node_Str"" + path);
  }
  return sqlStrings;
}","/** 
 * Builds a list of strings from a sql file so that they can be executed with jdbc.
 * @param path The path to the sql file
 * @return A list of sql strings from the file
 * @throws UnsupportedEncodingException
 * @throws IOException
 */
private List<String> buildSqlStringsFromFile(String path) throws UnsupportedEncodingException, IOException {
  List<String> sqlStrings=new ArrayList<String>();
  URL sqlFileUrl=new File(path).toURI().toURL();
  if (sqlFileUrl != null) {
    BufferedReader in=new BufferedReader(new InputStreamReader(sqlFileUrl.openStream(),""String_Node_Str""));
    String line=in.readLine();
    StringBuilder statement=new StringBuilder();
    while (line != null) {
      statement.append(line);
      if (line.endsWith(""String_Node_Str"")) {
        statement.deleteCharAt(statement.length() - 1);
        sqlStrings.add(statement.toString());
        statement.delete(0,statement.length());
      }
      line=in.readLine();
    }
  }
 else {
    throw new IOException(""String_Node_Str"" + path);
  }
  return sqlStrings;
}",0.9674067076051016
38157,"public void testAnnotation(){
  ArrayList<AnnotationInformation> arraylist=new ArrayList<AnnotationInformation>();
  ArrayList<String> gender=new ArrayList<String>();
  gender.add(""String_Node_Str"");
  gender.add(""String_Node_Str"");
  gender.add(""String_Node_Str"");
  AnnotationInformation ai=new AnnotationInformation(1,""String_Node_Str"",AnnotationInformation.TYPE_DROP_DOWN,gender,true);
  arraylist.add(ai);
  ArrayList<String> cellLine=new ArrayList<String>();
  cellLine.add(""String_Node_Str"");
  cellLine.add(""String_Node_Str"");
  cellLine.add(""String_Node_Str"");
  AnnotationInformation ai2=new AnnotationInformation(2,""String_Node_Str"",AnnotationInformation.TYPE_DROP_DOWN,cellLine,true);
  arraylist.add(ai2);
  GetAnnotationInformationResponse air=new GetAnnotationInformationResponse(200,arraylist);
  System.out.println(air.getBody());
  assertEquals(air.getBody(),""String_Node_Str"");
}","public void testAnnotation(){
  ArrayList<AnnotationInformation> arraylist=new ArrayList<AnnotationInformation>();
  ArrayList<String> gender=new ArrayList<String>();
  gender.add(""String_Node_Str"");
  gender.add(""String_Node_Str"");
  gender.add(""String_Node_Str"");
  AnnotationInformation ai=new AnnotationInformation(""String_Node_Str"",gender,true);
  arraylist.add(ai);
  ArrayList<String> cellLine=new ArrayList<String>();
  cellLine.add(""String_Node_Str"");
  cellLine.add(""String_Node_Str"");
  cellLine.add(""String_Node_Str"");
  AnnotationInformation ai2=new AnnotationInformation(""String_Node_Str"",cellLine,true);
  arraylist.add(ai2);
  GetAnnotationInformationResponse air=new GetAnnotationInformationResponse(200,arraylist);
  System.out.println(air.getBody());
  assertEquals(air.getBody(),""String_Node_Str"");
}",0.9545983701979044
38158,"@Test public void testPrintResponse(){
  ArrayList<Genome> genomeList;
  try {
    DatabaseAccessor db=new DatabaseAccessor(ServerSettings.databaseUsername,ServerSettings.databasePassword,ServerSettings.databaseHost,ServerSettings.databaseName);
    genomeList=db.getAllGenomReleases();
    GetGenomeReleaseRespons gResp=new GetGenomeReleaseRespons(StatusCode.OK,genomeList);
    System.out.println(gResp.getBody());
  }
 catch (  SQLException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
}","@Test public void testPrintResponse(){
  ArrayList<database.containers.Genome> genomeList;
  try {
    DatabaseAccessor db=new DatabaseAccessor(ServerSettings.databaseUsername,ServerSettings.databasePassword,ServerSettings.databaseHost,ServerSettings.databaseName);
    genomeList=(ArrayList<database.containers.Genome>)db.getAllGenomReleases();
    GetGenomeReleaseRespons gResp=new GetGenomeReleaseRespons(StatusCode.OK,genomeList);
    System.out.println(gResp.getBody());
  }
 catch (  SQLException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
}",0.9476486246672582
38159,"@Test public void shouldLogBADREQUESTError(){
  String username=""String_Node_Str"";
  Response r=new MinimalResponse(StatusCode.BAD_REQUEST);
  if (ErrorLogger.log(username,r)) {
    assertEquals(StatusCode.BAD_REQUEST,ErrorLogger.getUserLog(username).get(0).getCode());
  }
 else {
    fail();
  }
  ErrorLogger.printUserLog(""String_Node_Str"");
}","@Test public void shouldLogBADREQUESTError(){
  String username=""String_Node_Str"";
  Response r=new MinimalResponse(StatusCode.BAD_REQUEST);
  ErrorLogger.printUserLog(""String_Node_Str"");
}",0.7065420560747664
38160,"@Test public void shouldLog2BADREQUESTErrors(){
  String username=""String_Node_Str"";
  Response r1=new MinimalResponse(StatusCode.BAD_REQUEST);
  Response r2=new MinimalResponse(StatusCode.BAD_REQUEST);
  if (ErrorLogger.log(username,r1) && ErrorLogger.log(username,r2)) {
    assertEquals(StatusCode.BAD_REQUEST,ErrorLogger.getUserLog(username).get(0).getCode());
    assertEquals(StatusCode.BAD_REQUEST,ErrorLogger.getUserLog(username).get(1).getCode());
  }
 else {
    fail();
  }
  ErrorLogger.printUserLog(""String_Node_Str"");
}","@Test public void shouldLog2BADREQUESTErrors(){
  String username=""String_Node_Str"";
  Response r1=new MinimalResponse(StatusCode.BAD_REQUEST);
  Response r2=new MinimalResponse(StatusCode.BAD_REQUEST);
  ErrorLogger.printUserLog(""String_Node_Str"");
}",0.5663265306122449
38161,"@Test public void shouldLogBADREQUESTandOKResponse(){
  String username=""String_Node_Str"";
  Authenticate.addUser(username);
  Response r1=new MinimalResponse(StatusCode.BAD_REQUEST);
  Response r2=new MinimalResponse(StatusCode.OK);
  if (ErrorLogger.log(username,r1) && ErrorLogger.log(username,r2)) {
    assertEquals(StatusCode.BAD_REQUEST,ErrorLogger.getUserLog(username).get(0).getCode());
    assertEquals(StatusCode.OK,ErrorLogger.getUserLog(username).get(1).getCode());
    ErrorLogger.printUserLog(""String_Node_Str"");
  }
 else {
    fail();
  }
}","@Test public void shouldLogBADREQUESTandOKResponse(){
  String username=""String_Node_Str"";
  Authenticate.addUser(username);
  Response r1=new MinimalResponse(StatusCode.BAD_REQUEST);
  Response r2=new MinimalResponse(StatusCode.OK);
}",0.5934343434343434
38162,"@Test public void shouldValidateFalseWithoutAuthor(){
  String username=""String_Node_Str"";
  String expid=""String_Node_Str"";
  String processtype=""String_Node_Str"";
  String parameters=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String metadata=""String_Node_Str"";
  String genomeRelease=""String_Node_Str"";
  String author=""String_Node_Str"";
  CommandFactory cmdf=new CommandFactory();
  String json=""String_Node_Str"" + ""String_Node_Str"" + expid + ""String_Node_Str""+ ""String_Node_Str""+ processtype+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ genomeRelease+ ""String_Node_Str"";
  ProcessCommand processCommand=(ProcessCommand)cmdf.createProcessCommand(json,username);
  assertFalse(processCommand.validate());
}","@Test public void shouldValidateFalseWithoutAuthor(){
  String username=""String_Node_Str"";
  String expid=""String_Node_Str"";
  String processtype=""String_Node_Str"";
  String parameters=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String metadata=""String_Node_Str"";
  String genomeRelease=""String_Node_Str"";
  String author=""String_Node_Str"";
  CommandFactory cmdf=new CommandFactory();
  String json=""String_Node_Str"" + ""String_Node_Str"" + expid + ""String_Node_Str""+ ""String_Node_Str""+ processtype+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ genomeRelease+ ""String_Node_Str"";
  ProcessCommand processCommand=(ProcessCommand)cmdf.createProcessCommand(json,username,""String_Node_Str"");
  assertFalse(processCommand.validate());
}",0.990238611713666
38163,"@Test public void shouldValidateToFalseWhenEmptyGRversion(){
  String username=""String_Node_Str"";
  String expid=""String_Node_Str"";
  String processtype=""String_Node_Str"";
  String parameters=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String metadata=""String_Node_Str"";
  String genomeRelease=""String_Node_Str"";
  String author=""String_Node_Str"";
  CommandFactory cmdf=new CommandFactory();
  String json=""String_Node_Str"" + ""String_Node_Str"" + expid + ""String_Node_Str""+ ""String_Node_Str""+ processtype+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ genomeRelease+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str"";
  ProcessCommand processCommand=(ProcessCommand)cmdf.createProcessCommand(json,username);
  assertFalse(processCommand.validate());
}","@Test public void shouldValidateToFalseWhenEmptyGRversion(){
  String username=""String_Node_Str"";
  String expid=""String_Node_Str"";
  String processtype=""String_Node_Str"";
  String parameters=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String metadata=""String_Node_Str"";
  String genomeRelease=""String_Node_Str"";
  String author=""String_Node_Str"";
  CommandFactory cmdf=new CommandFactory();
  String json=""String_Node_Str"" + ""String_Node_Str"" + expid + ""String_Node_Str""+ ""String_Node_Str""+ processtype+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ genomeRelease+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str"";
  ProcessCommand processCommand=(ProcessCommand)cmdf.createProcessCommand(json,username,""String_Node_Str"");
  assertFalse(processCommand.validate());
}",0.9907692307692308
38164,"@Test public void shouldValidateToFalseWhenRawToProfileandNot8ParametersGRversion(){
  String username=""String_Node_Str"";
  String expid=""String_Node_Str"";
  String processtype=""String_Node_Str"";
  String parameters=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String metadata=""String_Node_Str"";
  String genomeRelease=""String_Node_Str"";
  String author=""String_Node_Str"";
  CommandFactory cmdf=new CommandFactory();
  String json=""String_Node_Str"" + ""String_Node_Str"" + expid + ""String_Node_Str""+ ""String_Node_Str""+ processtype+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ genomeRelease+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str"";
  ProcessCommand processCommand=(ProcessCommand)cmdf.createProcessCommand(json,username);
  assertFalse(processCommand.validate());
}","@Test public void shouldValidateToFalseWhenRawToProfileandNot8ParametersGRversion(){
  String username=""String_Node_Str"";
  String expid=""String_Node_Str"";
  String processtype=""String_Node_Str"";
  String parameters=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String metadata=""String_Node_Str"";
  String genomeRelease=""String_Node_Str"";
  String author=""String_Node_Str"";
  CommandFactory cmdf=new CommandFactory();
  String json=""String_Node_Str"" + ""String_Node_Str"" + expid + ""String_Node_Str""+ ""String_Node_Str""+ processtype+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ genomeRelease+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str"";
  ProcessCommand processCommand=(ProcessCommand)cmdf.createProcessCommand(json,username,""String_Node_Str"");
  assertFalse(processCommand.validate());
}",0.9908163265306122
38165,"@Test public void shouldValidateFalseWithoutMetadata(){
  String username=""String_Node_Str"";
  String expid=""String_Node_Str"";
  String processtype=""String_Node_Str"";
  String parameters=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String metadata=""String_Node_Str"";
  String genomeRelease=""String_Node_Str"";
  String author=""String_Node_Str"";
  CommandFactory cmdf=new CommandFactory();
  String json=""String_Node_Str"" + ""String_Node_Str"" + expid + ""String_Node_Str""+ ""String_Node_Str""+ processtype+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ genomeRelease+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str"";
  ProcessCommand processCommand=(ProcessCommand)cmdf.createProcessCommand(json,username);
  assertFalse(processCommand.validate());
}","@Test public void shouldValidateFalseWithoutMetadata(){
  String username=""String_Node_Str"";
  String expid=""String_Node_Str"";
  String processtype=""String_Node_Str"";
  String parameters=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String metadata=""String_Node_Str"";
  String genomeRelease=""String_Node_Str"";
  String author=""String_Node_Str"";
  CommandFactory cmdf=new CommandFactory();
  String json=""String_Node_Str"" + ""String_Node_Str"" + expid + ""String_Node_Str""+ ""String_Node_Str""+ processtype+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ genomeRelease+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str"";
  ProcessCommand processCommand=(ProcessCommand)cmdf.createProcessCommand(json,username,""String_Node_Str"");
  assertFalse(processCommand.validate());
}",0.990238611713666
38166,"@Test public void shouldValidateToTrueWhenEmptyMetadata(){
  String username=""String_Node_Str"";
  String expid=""String_Node_Str"";
  String processtype=""String_Node_Str"";
  String parameters=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String metadata=""String_Node_Str"";
  String genomeRelease=""String_Node_Str"";
  String author=""String_Node_Str"";
  CommandFactory cmdf=new CommandFactory();
  String json=""String_Node_Str"" + ""String_Node_Str"" + expid + ""String_Node_Str""+ ""String_Node_Str""+ processtype+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ genomeRelease+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str"";
  ProcessCommand processCommand=(ProcessCommand)cmdf.createProcessCommand(json,username);
  assertTrue(processCommand.validate());
}","@Test public void shouldValidateToTrueWhenEmptyMetadata(){
  String username=""String_Node_Str"";
  String expid=""String_Node_Str"";
  String processtype=""String_Node_Str"";
  String parameters=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String metadata=""String_Node_Str"";
  String genomeRelease=""String_Node_Str"";
  String author=""String_Node_Str"";
  CommandFactory cmdf=new CommandFactory();
  String json=""String_Node_Str"" + ""String_Node_Str"" + expid + ""String_Node_Str""+ ""String_Node_Str""+ processtype+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ genomeRelease+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str"";
  ProcessCommand processCommand=(ProcessCommand)cmdf.createProcessCommand(json,username,""String_Node_Str"");
  assertTrue(processCommand.validate());
}",0.9907407407407408
38167,"@Test public void shouldValidateToTrueWhenRawToProfileand8ParametersGRversion(){
  String username=""String_Node_Str"";
  String expid=""String_Node_Str"";
  String processtype=""String_Node_Str"";
  String parameters=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String metadata=""String_Node_Str"";
  String genomeRelease=""String_Node_Str"";
  String author=""String_Node_Str"";
  CommandFactory cmdf=new CommandFactory();
  String json=""String_Node_Str"" + ""String_Node_Str"" + expid + ""String_Node_Str""+ ""String_Node_Str""+ processtype+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ genomeRelease+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str"";
  ProcessCommand processCommand=(ProcessCommand)cmdf.createProcessCommand(json,username);
  assertTrue(processCommand.validate());
}","@Test public void shouldValidateToTrueWhenRawToProfileand8ParametersGRversion(){
  String username=""String_Node_Str"";
  String expid=""String_Node_Str"";
  String processtype=""String_Node_Str"";
  String parameters=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String metadata=""String_Node_Str"";
  String genomeRelease=""String_Node_Str"";
  String author=""String_Node_Str"";
  CommandFactory cmdf=new CommandFactory();
  String json=""String_Node_Str"" + ""String_Node_Str"" + expid + ""String_Node_Str""+ ""String_Node_Str""+ processtype+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ genomeRelease+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str"";
  ProcessCommand processCommand=(ProcessCommand)cmdf.createProcessCommand(json,username,""String_Node_Str"");
  assertTrue(processCommand.validate());
}",0.9909456740442656
38168,"@Test public void shouldValidateToFalseWhenEmptyUsername(){
  String username=""String_Node_Str"";
  String expid=""String_Node_Str"";
  String processtype=""String_Node_Str"";
  String parameters=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String metadata=""String_Node_Str"";
  String genomeRelease=""String_Node_Str"";
  String author=""String_Node_Str"";
  CommandFactory cmdf=new CommandFactory();
  String json=""String_Node_Str"" + ""String_Node_Str"" + expid + ""String_Node_Str""+ ""String_Node_Str""+ processtype+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ genomeRelease+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str"";
  ProcessCommand processCommand=(ProcessCommand)cmdf.createProcessCommand(json,username);
  assertFalse(processCommand.validate());
}","@Test public void shouldValidateToFalseWhenEmptyUsername(){
  String username=""String_Node_Str"";
  String expid=""String_Node_Str"";
  String processtype=""String_Node_Str"";
  String parameters=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String metadata=""String_Node_Str"";
  String genomeRelease=""String_Node_Str"";
  String author=""String_Node_Str"";
  CommandFactory cmdf=new CommandFactory();
  String json=""String_Node_Str"" + ""String_Node_Str"" + expid + ""String_Node_Str""+ ""String_Node_Str""+ processtype+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ genomeRelease+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str"";
  ProcessCommand processCommand=(ProcessCommand)cmdf.createProcessCommand(json,username,""String_Node_Str"");
  assertFalse(processCommand.validate());
}",0.9907597535934292
38169,"@Test public void shouldValidateFalseWithoutGenomeRelease(){
  String username=""String_Node_Str"";
  String expid=""String_Node_Str"";
  String processtype=""String_Node_Str"";
  String parameters=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String metadata=""String_Node_Str"";
  String genomeRelease=""String_Node_Str"";
  String author=""String_Node_Str"";
  CommandFactory cmdf=new CommandFactory();
  String json=""String_Node_Str"" + ""String_Node_Str"" + expid + ""String_Node_Str""+ ""String_Node_Str""+ processtype+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str"";
  ProcessCommand processCommand=(ProcessCommand)cmdf.createProcessCommand(json,username);
  assertFalse(processCommand.validate());
}","@Test public void shouldValidateFalseWithoutGenomeRelease(){
  String username=""String_Node_Str"";
  String expid=""String_Node_Str"";
  String processtype=""String_Node_Str"";
  String parameters=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String metadata=""String_Node_Str"";
  String genomeRelease=""String_Node_Str"";
  String author=""String_Node_Str"";
  CommandFactory cmdf=new CommandFactory();
  String json=""String_Node_Str"" + ""String_Node_Str"" + expid + ""String_Node_Str""+ ""String_Node_Str""+ processtype+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str"";
  ProcessCommand processCommand=(ProcessCommand)cmdf.createProcessCommand(json,username,""String_Node_Str"");
  assertFalse(processCommand.validate());
}",0.990238611713666
38170,"@Test public void shouldValidateToTrueWhenEmptyAuthor(){
  String username=""String_Node_Str"";
  String expid=""String_Node_Str"";
  String processtype=""String_Node_Str"";
  String parameters=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String metadata=""String_Node_Str"";
  String genomeRelease=""String_Node_Str"";
  String author=""String_Node_Str"";
  CommandFactory cmdf=new CommandFactory();
  String json=""String_Node_Str"" + ""String_Node_Str"" + expid + ""String_Node_Str""+ ""String_Node_Str""+ processtype+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ genomeRelease+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str"";
  ProcessCommand processCommand=(ProcessCommand)cmdf.createProcessCommand(json,username);
  assertTrue(processCommand.validate());
}","@Test public void shouldValidateToTrueWhenEmptyAuthor(){
  String username=""String_Node_Str"";
  String expid=""String_Node_Str"";
  String processtype=""String_Node_Str"";
  String parameters=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String metadata=""String_Node_Str"";
  String genomeRelease=""String_Node_Str"";
  String author=""String_Node_Str"";
  CommandFactory cmdf=new CommandFactory();
  String json=""String_Node_Str"" + ""String_Node_Str"" + expid + ""String_Node_Str""+ ""String_Node_Str""+ processtype+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ genomeRelease+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str"";
  ProcessCommand processCommand=(ProcessCommand)cmdf.createProcessCommand(json,username,""String_Node_Str"");
  assertTrue(processCommand.validate());
}",0.990721649484536
38171,"@Test public void shouldValidateFalseWithoutParameters(){
  String username=""String_Node_Str"";
  String expid=""String_Node_Str"";
  String processtype=""String_Node_Str"";
  String parameters=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String metadata=""String_Node_Str"";
  String genomeRelease=""String_Node_Str"";
  String author=""String_Node_Str"";
  CommandFactory cmdf=new CommandFactory();
  String json=""String_Node_Str"" + ""String_Node_Str"" + expid + ""String_Node_Str""+ ""String_Node_Str""+ processtype+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ genomeRelease+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str"";
  ProcessCommand processCommand=(ProcessCommand)cmdf.createProcessCommand(json,username);
  assertFalse(processCommand.validate());
}","@Test public void shouldValidateFalseWithoutParameters(){
  String username=""String_Node_Str"";
  String expid=""String_Node_Str"";
  String processtype=""String_Node_Str"";
  String parameters=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String metadata=""String_Node_Str"";
  String genomeRelease=""String_Node_Str"";
  String author=""String_Node_Str"";
  CommandFactory cmdf=new CommandFactory();
  String json=""String_Node_Str"" + ""String_Node_Str"" + expid + ""String_Node_Str""+ ""String_Node_Str""+ processtype+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ genomeRelease+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str"";
  ProcessCommand processCommand=(ProcessCommand)cmdf.createProcessCommand(json,username,""String_Node_Str"");
  assertFalse(processCommand.validate());
}",0.990238611713666
38172,"@Test public void shouldValidateFalseWithoutProcesstype(){
  String username=""String_Node_Str"";
  String expid=""String_Node_Str"";
  String processtype=""String_Node_Str"";
  String parameters=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String metadata=""String_Node_Str"";
  String genomeRelease=""String_Node_Str"";
  String author=""String_Node_Str"";
  CommandFactory cmdf=new CommandFactory();
  String json=""String_Node_Str"" + ""String_Node_Str"" + expid + ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ genomeRelease+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str"";
  ProcessCommand processCommand=(ProcessCommand)cmdf.createProcessCommand(json,username);
  assertFalse(processCommand.validate());
}","@Test public void shouldValidateFalseWithoutProcesstype(){
  String username=""String_Node_Str"";
  String expid=""String_Node_Str"";
  String processtype=""String_Node_Str"";
  String parameters=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String metadata=""String_Node_Str"";
  String genomeRelease=""String_Node_Str"";
  String author=""String_Node_Str"";
  CommandFactory cmdf=new CommandFactory();
  String json=""String_Node_Str"" + ""String_Node_Str"" + expid + ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ genomeRelease+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str"";
  ProcessCommand processCommand=(ProcessCommand)cmdf.createProcessCommand(json,username,""String_Node_Str"");
  assertFalse(processCommand.validate());
}",0.990238611713666
38173,"@Test public void shouldValidateToTrue(){
  String username=""String_Node_Str"";
  String expid=""String_Node_Str"";
  String processtype=""String_Node_Str"";
  String parameters=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String metadata=""String_Node_Str"";
  String genomeRelease=""String_Node_Str"";
  String author=""String_Node_Str"";
  CommandFactory cmdf=new CommandFactory();
  String json=""String_Node_Str"" + ""String_Node_Str"" + expid + ""String_Node_Str""+ ""String_Node_Str""+ processtype+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ genomeRelease+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str"";
  ProcessCommand processCommand=(ProcessCommand)cmdf.createProcessCommand(json,username);
  assertTrue(processCommand.validate());
}","@Test public void shouldValidateToTrue(){
  String username=""String_Node_Str"";
  String expid=""String_Node_Str"";
  String processtype=""String_Node_Str"";
  String parameters=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String metadata=""String_Node_Str"";
  String genomeRelease=""String_Node_Str"";
  String author=""String_Node_Str"";
  CommandFactory cmdf=new CommandFactory();
  String json=""String_Node_Str"" + ""String_Node_Str"" + expid + ""String_Node_Str""+ ""String_Node_Str""+ processtype+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ genomeRelease+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str"";
  ProcessCommand processCommand=(ProcessCommand)cmdf.createProcessCommand(json,username,""String_Node_Str"");
  assertTrue(processCommand.validate());
}",0.9905759162303664
38174,"@Test public void shouldValidateFalseWithoutExpid(){
  String username=""String_Node_Str"";
  String expid=""String_Node_Str"";
  String processtype=""String_Node_Str"";
  String parameters=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String metadata=""String_Node_Str"";
  String genomeRelease=""String_Node_Str"";
  String author=""String_Node_Str"";
  CommandFactory cmdf=new CommandFactory();
  String json=""String_Node_Str"" + ""String_Node_Str"" + processtype + ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ genomeRelease+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str"";
  ProcessCommand processCommand=(ProcessCommand)cmdf.createProcessCommand(json,username);
  assertFalse(processCommand.validate());
}","@Test public void shouldValidateFalseWithoutExpid(){
  String username=""String_Node_Str"";
  String expid=""String_Node_Str"";
  String processtype=""String_Node_Str"";
  String parameters=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String metadata=""String_Node_Str"";
  String genomeRelease=""String_Node_Str"";
  String author=""String_Node_Str"";
  CommandFactory cmdf=new CommandFactory();
  String json=""String_Node_Str"" + ""String_Node_Str"" + processtype + ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ genomeRelease+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str"";
  ProcessCommand processCommand=(ProcessCommand)cmdf.createProcessCommand(json,username,""String_Node_Str"");
  assertFalse(processCommand.validate());
}",0.990238611713666
38175,"/** 
 * Adds all attributes to an arraylist and pass that and the experimentID to the database. A filepath is returned and sent to the client as a URL.
 */
@Override public Response execute(){
  DatabaseAccessor db=null;
  int filetype;
  if (type.equalsIgnoreCase(""String_Node_Str"")) {
    filetype=FileTuple.RAW;
  }
 else   if (type.equalsIgnoreCase(""String_Node_Str"")) {
    filetype=FileTuple.PROFILE;
  }
 else   if (type.equalsIgnoreCase(""String_Node_Str"")) {
    filetype=FileTuple.REGION;
  }
 else {
    filetype=FileTuple.OTHER;
  }
  try {
    db=initDB();
    FileTuple ft=db.addNewFile(experimentID,filetype,fileName,""String_Node_Str"",metaData,author,uploader,isPrivate,grVersion);
    return new AddFileToExperimentResponse(StatusCode.OK,ft.getUploadURL());
  }
 catch (  SQLException e) {
    e.printStackTrace();
    return new ErrorResponse(StatusCode.BAD_REQUEST,e.getMessage());
  }
catch (  IOException e) {
    e.printStackTrace();
    return new ErrorResponse(StatusCode.SERVICE_UNAVAILABLE,e.getMessage());
  }
 finally {
    db.close();
  }
}","/** 
 * Adds all attributes to an arraylist and pass that and the experimentID to the database. A filepath is returned and sent to the client as a URL.
 */
@Override public Response execute(){
  DatabaseAccessor db=null;
  int filetype;
  if (type.equalsIgnoreCase(""String_Node_Str"")) {
    filetype=FileTuple.RAW;
  }
 else   if (type.equalsIgnoreCase(""String_Node_Str"")) {
    filetype=FileTuple.PROFILE;
  }
 else   if (type.equalsIgnoreCase(""String_Node_Str"")) {
    filetype=FileTuple.REGION;
  }
 else {
    filetype=FileTuple.OTHER;
  }
  try {
    db=initDB();
    FileTuple ft=db.addNewFile(experimentID,filetype,fileName,null,metaData,author,uploader,isPrivate,grVersion);
    return new AddFileToExperimentResponse(StatusCode.OK,ft.getUploadURL());
  }
 catch (  SQLException e) {
    e.printStackTrace();
    return new ErrorResponse(StatusCode.BAD_REQUEST,e.getMessage());
  }
catch (  IOException e) {
    e.printStackTrace();
    return new ErrorResponse(StatusCode.SERVICE_UNAVAILABLE,e.getMessage());
  }
 finally {
    db.close();
  }
}",0.99009900990099
38176,"public void setFilePaths(){
  DatabaseAccessor db=null;
  try {
    db=initDB();
    filepaths=db.processRawToProfile(expid);
  }
 catch (  SQLException|IOException e) {
    e.printStackTrace();
  }
 finally {
    db.close();
  }
}","public void setFilePaths() throws SQLException, IOException {
  DatabaseAccessor db=null;
  db=initDB();
  filepaths=db.processRawToProfile(expid);
  if (db.isConnected()) {
    db.close();
  }
}",0.6995305164319249
38177,"@Override public void run(){
  Debug.log(Thread.currentThread().getName());
  while (true) {
    if (!workQueue.isEmpty()) {
      ProcessCommand work=workQueue.poll();
      Debug.log(""String_Node_Str"");
      ProcessStatus stat=processStatus.get(work);
      stat.status=""String_Node_Str"";
      work.setFilePaths();
      stat.outputFiles=work.getFilePaths();
      stat.timeStarted=System.currentTimeMillis();
      try {
        Response resp=work.execute();
        Debug.log(""String_Node_Str"");
        if (resp.getCode() == StatusCode.CREATED) {
          stat.status=""String_Node_Str"";
        }
 else {
          stat.status=""String_Node_Str"";
        }
      }
 catch (      NullPointerException e) {
        stat.status=""String_Node_Str"";
      }
      stat.timeFinished=System.currentTimeMillis();
      ResponseLogger.printLog();
    }
 else {
      try {
        Thread.sleep(1000);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
  }
}","@Override public void run(){
  Debug.log(Thread.currentThread().getName());
  while (true) {
    if (!workQueue.isEmpty()) {
      ProcessCommand work=workQueue.poll();
      Debug.log(""String_Node_Str"");
      ProcessStatus stat=processStatus.get(work);
      stat.status=""String_Node_Str"";
      try {
        work.setFilePaths();
      }
 catch (      SQLException|IOException e) {
        Debug.log(e.getMessage());
        ResponseLogger.log(stat.author,e.getMessage());
        stat.status=""String_Node_Str"";
        continue;
      }
      stat.outputFiles=work.getFilePaths();
      stat.timeStarted=System.currentTimeMillis();
      try {
        Response resp=work.execute();
        Debug.log(""String_Node_Str"");
        if (resp.getCode() == StatusCode.CREATED) {
          stat.status=""String_Node_Str"";
        }
 else {
          stat.status=""String_Node_Str"";
        }
      }
 catch (      NullPointerException e) {
        stat.status=""String_Node_Str"";
      }
      stat.timeFinished=System.currentTimeMillis();
    }
 else {
      try {
        Thread.sleep(1000);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
        Debug.log(""String_Node_Str"");
        ResponseLogger.log(""String_Node_Str"",""String_Node_Str"");
      }
    }
  }
}",0.8429824561403508
38178,"/** 
 * Method used to execute the command and add the annotation field.
 */
@Override public Response execute(){
  int addedAnnotations=0;
  int defaultValueIndex=0;
  DatabaseAccessor db=null;
  try {
    db=initDB();
    for (int i=0; i < type.size(); i++) {
      if (type.get(i).equals(defaults)) {
        defaultValueIndex=i;
        break;
      }
    }
    if (type.size() == 1 && type.get(0).equals(""String_Node_Str"")) {
      addedAnnotations=db.addFreeTextAnnotation(name,defaults,forced);
    }
 else {
      addedAnnotations=db.addDropDownAnnotation(name,type,defaultValueIndex,forced);
    }
    if (addedAnnotations != 0) {
      return new AddAnnotationFieldResponse(StatusCode.CREATED);
    }
 else {
      return new ErrorResponse(StatusCode.BAD_REQUEST,""String_Node_Str"");
    }
  }
 catch (  SQLException e) {
    e.printStackTrace();
    if (e.getErrorCode() == 0) {
      return new ErrorResponse(StatusCode.BAD_REQUEST,""String_Node_Str"" + name + ""String_Node_Str"");
    }
 else {
      return new ErrorResponse(StatusCode.SERVICE_UNAVAILABLE,""String_Node_Str"");
    }
  }
catch (  IOException e) {
    e.printStackTrace();
    return new MinimalResponse(StatusCode.BAD_REQUEST);
  }
 finally {
    db.close();
  }
}","/** 
 * Method used to execute the command and add the annotation field.
 */
@Override public Response execute(){
  int addedAnnotations=0;
  int defaultValueIndex=0;
  DatabaseAccessor db=null;
  try {
    db=initDB();
    for (int i=0; i < type.size(); i++) {
      if (type.get(i).equals(defaults)) {
        defaultValueIndex=i;
        break;
      }
    }
    if (type.size() == 1 && type.get(0).equals(""String_Node_Str"")) {
      addedAnnotations=db.addFreeTextAnnotation(name,defaults,forced);
    }
 else {
      addedAnnotations=db.addDropDownAnnotation(name,type,defaultValueIndex,forced);
    }
    if (addedAnnotations != 0) {
      return new AddAnnotationFieldResponse(StatusCode.CREATED);
    }
 else {
      return new ErrorResponse(StatusCode.BAD_REQUEST,""String_Node_Str"");
    }
  }
 catch (  SQLException e) {
    e.printStackTrace();
    if (e.getErrorCode() == 0) {
      return new ErrorResponse(StatusCode.BAD_REQUEST,""String_Node_Str"" + name + ""String_Node_Str"");
    }
 else {
      return new ErrorResponse(StatusCode.SERVICE_UNAVAILABLE,""String_Node_Str"");
    }
  }
catch (  IOException e) {
    e.printStackTrace();
    return new ErrorResponse(StatusCode.BAD_REQUEST,e.getMessage());
  }
 finally {
    db.close();
  }
}",0.9891609795262948
38179,"@Override public Response execute(){
  ArrayList<AnnotationInformation> annotations=new ArrayList<AnnotationInformation>();
  DatabaseAccessor db=null;
  Map<String,Integer> a=null;
  try {
    db=initDB();
    a=db.getAnnotations();
    List<String> list=new ArrayList<String>(a.keySet());
    System.out.println(""String_Node_Str"" + list.toString());
    Iterator<String> keys=a.keySet().iterator();
    ArrayList<String> annotation_names=new ArrayList<String>();
    while (keys.hasNext()) {
      annotation_names.add(keys.next());
    }
    for (int i=0; i < annotation_names.size(); i++) {
      database.containers.Annotation annotationObject=null;
      ArrayList<String> values=new ArrayList<String>();
      annotationObject=db.getAnnotationObject(annotation_names.get(i));
      if (annotationObject.dataType == database.containers.Annotation.FREETEXT) {
        values.add(""String_Node_Str"");
      }
 else       if (annotationObject.dataType == database.containers.Annotation.DROPDOWN) {
        values=(ArrayList<String>)annotationObject.getPossibleValues();
      }
      AnnotationInformation annotation=new AnnotationInformation(annotationObject.label,values,annotationObject.isRequired);
      annotations.add(annotation);
    }
    db.close();
    return new GetAnnotationInformationResponse(StatusCode.OK,annotations);
  }
 catch (  SQLException|IOException e) {
    return new ErrorResponse(StatusCode.BAD_REQUEST,""String_Node_Str"" + e.getMessage());
  }
}","@Override public Response execute(){
  ArrayList<AnnotationInformation> annotations=new ArrayList<AnnotationInformation>();
  DatabaseAccessor db=null;
  Map<String,Integer> a=null;
  try {
    db=initDB();
    a=db.getAnnotations();
    List<String> list=new ArrayList<String>(a.keySet());
    Iterator<String> keys=a.keySet().iterator();
    ArrayList<String> annotation_names=new ArrayList<String>();
    while (keys.hasNext()) {
      annotation_names.add(keys.next());
    }
    for (    String label : list) {
      database.containers.Annotation annotationObject=null;
      ArrayList<String> values=new ArrayList<String>();
      annotationObject=db.getAnnotationObject(label);
      if (annotationObject.dataType == database.containers.Annotation.FREETEXT) {
        values.add(""String_Node_Str"");
      }
 else       if (annotationObject.dataType == database.containers.Annotation.DROPDOWN) {
        values=(ArrayList<String>)annotationObject.getPossibleValues();
      }
      AnnotationInformation annotation=new AnnotationInformation(annotationObject.label,values,annotationObject.isRequired);
      annotations.add(annotation);
    }
    db.close();
    return new GetAnnotationInformationResponse(StatusCode.OK,annotations);
  }
 catch (  SQLException|IOException e) {
    return new ErrorResponse(StatusCode.BAD_REQUEST,""String_Node_Str"" + e.getMessage());
  }
}",0.8539404553415061
38180,"public static void main(String args[]) throws Exception {
  Login.login(""String_Node_Str"",""String_Node_Str"");
  GenomeRelease.sendGetGenomeRelease();
  Login.logout();
}","public static void main(String args[]) throws Exception {
  Login.login(""String_Node_Str"",""String_Node_Str"");
  Login.logout();
}",0.8657718120805369
38181,"public boolean validateRatioCalculation(String string) throws ProcessException {
  String[] ratio=parse(string);
  String firstParam=ratio[0];
  float[] ratioFloat=new float[2];
  int[] ratioInt=new int[2];
  for (int i=0; i < ratio.length - 1; i++) {
    try {
      ratioFloat[i]=Float.parseFloat(ratio[i + 1]);
    }
 catch (    NumberFormatException e) {
      throw new ProcessException(""String_Node_Str"" + (i + 1) + ""String_Node_Str"");
    }
  }
  for (int i=0; i < ratioFloat.length; i++) {
    if (ratioFloat[i] % 1 == 0) {
      ratioInt[i]=(int)ratioFloat[i];
    }
 else {
      throw new ProcessException(""String_Node_Str"" + (i + 1) + ""String_Node_Str"");
    }
    if (ratioFloat[i] < 0) {
      throw new ProcessException(""String_Node_Str"" + i + 1+ ""String_Node_Str"");
    }
  }
  if ((!firstParam.equals(""String_Node_Str"")) && (!firstParam.equals(""String_Node_Str""))) {
    throw new ProcessException(""String_Node_Str"");
  }
  return true;
}","public boolean validateRatioCalculation(String string) throws ProcessException {
  String[] ratio=parse(string);
  System.out.println(""String_Node_Str"" + ratio.length);
  String firstParam=ratio[0];
  float[] ratioFloat=new float[2];
  int[] ratioInt=new int[2];
  for (int i=0; i < ratio.length - 1; i++) {
    try {
      ratioFloat[i]=Float.parseFloat(ratio[i + 1]);
    }
 catch (    NumberFormatException e) {
      throw new ProcessException(""String_Node_Str"" + (i + 1) + ""String_Node_Str"");
    }
  }
  for (int i=0; i < ratioFloat.length; i++) {
    if (ratioFloat[i] % 1 == 0) {
      ratioInt[i]=(int)ratioFloat[i];
    }
 else {
      throw new ProcessException(""String_Node_Str"" + (i + 1) + ""String_Node_Str"");
    }
    if (ratioFloat[i] < 0) {
      throw new ProcessException(""String_Node_Str"" + i + 1+ ""String_Node_Str"");
    }
  }
  if ((!firstParam.equals(""String_Node_Str"")) && (!firstParam.equals(""String_Node_Str""))) {
    throw new ProcessException(""String_Node_Str"");
  }
  return true;
}",0.9715157680569684
38182,"private boolean ValidateParameters(String[] parameters) throws ProcessException {
  boolean isOk=true;
  if (!validator.validateSmoothing(parameters[4])) {
    isOk=false;
  }
 else   if (!validator.validateStep(parameters[5])) {
    isOk=false;
  }
 else   if (!validator.validateRatioCalculation(parameters[6])) {
    isOk=false;
  }
 else   if (!validator.validateSmoothing(parameters[7])) {
    isOk=false;
  }
  return isOk;
}","private boolean ValidateParameters(String[] parameters) throws ProcessException {
  boolean isOk=true;
  if (checker.shouldRunSmoothing() && !validator.validateSmoothing(parameters[4])) {
    isOk=false;
  }
  if (checker.shouldRunStep() && !validator.validateStep(parameters[5])) {
    isOk=false;
  }
  if (checker.shouldRunRatioCalc() && !validator.validateRatioCalculation(parameters[6])) {
    isOk=false;
  }
  if (checker.shouldRunRatioCalc() && !validator.validateSmoothing(parameters[7])) {
    isOk=false;
  }
  return isOk;
}",0.8231644260599793
38183,"/** 
 * Runs the smoothing and step procedures. Checks if its smoothing after ratio calculation or (parameters[5])[1])just normal smoothing. Changes some parameters depending on ratio calculation or not. runs smoothing with the incoming parameters  and runs stepping if it should.
 * @param parameters Contains all parameters needed to run smoothing snd step
 * @param isRatioCalc If ratio calculation or not.
 * @throws ProcessException
 */
private void runSmoothing(String[] parameters,boolean isRatioCalc) throws ProcessException {
  String[] parameterArray;
  int stepSize=0;
  File[] filesToSmooth;
  File file;
  if (isRatioCalc) {
    parameterArray=parse(parameters[7]);
    stepSize=1;
    filesToSmooth=new File(sortedDirForFile + ""String_Node_Str"").listFiles();
    file=new File(sortedDirForFile + ""String_Node_Str"");
  }
 else {
    filesToSmooth=new File(sortedDirForFile + ""String_Node_Str"").listFiles();
    file=new File(sortedDirForFile + ""String_Node_Str"");
    if (parameters[6].equals(""String_Node_Str"")) {
      stepSize=1;
    }
 else {
      try {
        stepSize=Integer.parseInt(parse(parameters[5])[1]);
      }
 catch (      NumberFormatException e) {
        throw new ProcessException(""String_Node_Str"");
      }
    }
    parameterArray=parse(parameters[4]);
  }
  int[] intParams=new int[parameterArray.length];
  for (int i=0; i < parameterArray.length; i++) {
    try {
      intParams[i]=Integer.parseInt(parameterArray[i]);
    }
 catch (    NumberFormatException e) {
      throw new ProcessException(""String_Node_Str"");
    }
  }
  if (!file.exists()) {
    file.mkdirs();
  }
  SmoothingAndStep smooth=new SmoothingAndStep();
  if (filesToSmooth != null) {
    for (int i=0; i < filesToSmooth.length; i++) {
      if (filesToSmooth[i].isFile() && isSgr(filesToSmooth[i].getName())) {
        String inFile=filesToSmooth[i].getAbsoluteFile().toString();
        String outFile=filesToSmooth[i].getName();
        if (stepSize != 1) {
          outFile=outFile.substring(0,outFile.length() - 4) + ""String_Node_Str"" + stepSize+ ""String_Node_Str"";
        }
 else {
        }
        outFile=file.toString() + ""String_Node_Str"" + outFile;
        smooth.smoothing(intParams,inFile,outFile,stepSize);
      }
    }
  }
}","/** 
 * Runs the smoothing and step procedures. Checks if its smoothing after ratio calculation or (parameters[5])[1])just normal smoothing. Changes some parameters depending on ratio calculation or not. runs smoothing with the incoming parameters  and runs stepping if it should.
 * @param parameters Contains all parameters needed to run smoothing snd step
 * @param isRatioCalc If ratio calculation or not.
 * @throws ProcessException
 */
private void runSmoothing(String[] parameters,boolean isRatioCalc) throws ProcessException {
  String[] parameterArray;
  int stepSize=0;
  File[] filesToSmooth;
  File file;
  if (isRatioCalc) {
    parameterArray=parse(parameters[7]);
    stepSize=1;
    filesToSmooth=new File(sortedDirForFile + ""String_Node_Str"").listFiles();
    file=new File(sortedDirForFile + ""String_Node_Str"");
  }
 else {
    filesToSmooth=new File(sortedDirForFile + ""String_Node_Str"").listFiles();
    file=new File(sortedDirForFile + ""String_Node_Str"");
    if (parameters[6].equals(""String_Node_Str"")) {
      stepSize=1;
    }
 else {
      try {
        stepSize=Integer.parseInt(parse(parameters[5])[1]);
      }
 catch (      NumberFormatException e) {
        throw new ProcessException(""String_Node_Str"");
      }
    }
    parameterArray=parse(parameters[4]);
  }
  int[] intParams=new int[parameterArray.length];
  for (int i=0; i < parameterArray.length; i++) {
    try {
      intParams[i]=Integer.parseInt(parameterArray[i]);
    }
 catch (    NumberFormatException e) {
      throw new ProcessException(""String_Node_Str"");
    }
  }
  if (!file.exists()) {
    file.mkdirs();
  }
  SmoothingAndStep smooth=new SmoothingAndStep();
  if (filesToSmooth != null) {
    for (int i=0; i < filesToSmooth.length; i++) {
      if (filesToSmooth[i].isFile() && isSgr(filesToSmooth[i].getName())) {
        String inFile=filesToSmooth[i].getAbsoluteFile().toString();
        String outFile=filesToSmooth[i].getName();
        SmoothingParameterChecker smoothChecker=SmoothingParameterChecker.SmoothingParameterCheckerFactory(parameters[4]);
        outFile=outFile.substring(0,outFile.length() - 4) + ""String_Node_Str"" + smoothChecker.getSmoothType()+ ""String_Node_Str""+ smoothChecker.getWindowSize()+ ""String_Node_Str""+ smoothChecker.getMinProbe();
        if (stepSize != 1) {
          outFile=outFile + ""String_Node_Str"" + stepSize+ ""String_Node_Str"";
        }
 else {
          outFile=outFile + ""String_Node_Str"";
        }
        outFile=file.toString() + ""String_Node_Str"" + outFile;
        smooth.smoothing(intParams,inFile,outFile,stepSize);
      }
    }
  }
}",0.9149330587023689
38184,"/** 
 * Adds all the files in the specified folder to the database's File table. They will all be treated as profile files.
 * @param String expId - The ID name of the experiment
 * @param String folderPath - The path to the folder containing the profile files. (This should be exactly the same path as returned by the processRawToProfile(expId) method)
 * @param String inputFileName - The name of the input file or null if no input file was generated
 * @param String metaData - A String specifying the parameters used for processing the raw file.
 * @param String genomeReleaseVersion - The genome release version used in processing. OBS! this is a reference to a genome release stored in the database/on the server and must therefore be valid.
 * @param String uploader - The user that commissioned the processing
 * @param boolean isPrivate - True if the files are to be private to theuploader, otherwise false.
 * @throws SQLException - If the request uses invalid arguments or the database could not be reached. Possible reasons: invalid genomeRelease.
 * @throws IOException
 */
public void addGeneratedProfiles(String expId,String folderPath,String inputFileName,String metaData,String grVersion,String uploader,boolean isPrivate) throws SQLException, IOException {
  Experiment e=expMethods.getExperiment(expId);
  File profileFolder=new File(folderPath);
  if (!profileFolder.exists()) {
    throw new IOException(""String_Node_Str"");
  }
  for (  File f : profileFolder.listFiles()) {
    if (!f.getName().equals(inputFileName)) {
      FileTuple ft=fileMethods.addNewFile(e.getID(),FileTuple.PROFILE,f.getName(),inputFileName,metaData,""String_Node_Str"",uploader,isPrivate,grVersion);
      fileMethods.fileReadyForDownload(ft.id);
    }
  }
}","/** 
 * Adds all the files in the specified folder to the database's File table. They will all be treated as profile files.
 * @param String expId - The ID name of the experiment
 * @param String folderPath - The path to the folder containing the profile files. (This should be exactly the same path as returned by the processRawToProfile(expId) method)
 * @param String inputFileName - The name of the input file or null if no input file was generated
 * @param String metaData - A String specifying the parameters used for processing the raw file.
 * @param String genomeReleaseVersion - The genome release version used in processing. OBS! this is a reference to a genome release stored in the database/on the server and must therefore be valid.
 * @param String uploader - The user that commissioned the processing
 * @param boolean isPrivate - True if the files are to be private to theuploader, otherwise false.
 * @throws SQLException - If the request uses invalid arguments or the database could not be reached. Possible reasons: invalid genomeRelease.
 * @throws IOException
 */
public void addGeneratedProfiles(String expId,String folderPath,String inputFileName,String metaData,String grVersion,String uploader,boolean isPrivate) throws SQLException, IOException {
  Experiment e=expMethods.getExperiment(expId);
  File profileFolder=new File(folderPath);
  if (!profileFolder.exists()) {
    throw new IOException(""String_Node_Str"");
  }
  for (  File f : profileFolder.listFiles()) {
    if (!f.getName().equals(inputFileName)) {
      FileTuple ft=fileMethods.addGeneratedFile(e.getID(),FileTuple.PROFILE,f.getPath(),inputFileName,metaData,uploader,isPrivate,grVersion);
      fileMethods.fileReadyForDownload(ft.id);
    }
  }
}",0.9891304347826086
38185,"private void isValidArgument(String arg) throws IOException {
  if (arg.contentEquals(""String_Node_Str"") || arg == null) {
    throw new IOException(""String_Node_Str"");
  }
}","private void isValidArgument(String arg) throws IOException {
  if (arg == null || arg.contentEquals(""String_Node_Str"")) {
    throw new IOException(""String_Node_Str"");
  }
}",0.913793103448276
38186,"public String toString(){
  if ((newSignal == Math.floor(newSignal))) {
    return chromosome + ""String_Node_Str"" + position+ ""String_Node_Str""+ (int)newSignal+ ""String_Node_Str"";
  }
 else {
    return chromosome + ""String_Node_Str"" + position+ ""String_Node_Str""+ ((double)Math.round(newSignal * 100000) / 100000)+ ""String_Node_Str"";
  }
}","public String toString(){
  if (chromosome == null) {
    return ""String_Node_Str"";
  }
  if ((newSignal == Math.floor(newSignal))) {
    return chromosome + ""String_Node_Str"" + position+ ""String_Node_Str""+ (int)newSignal+ ""String_Node_Str"";
  }
 else {
    return chromosome + ""String_Node_Str"" + position+ ""String_Node_Str""+ ((double)Math.round(newSignal * 100000) / 100000)+ ""String_Node_Str"";
  }
}",0.9164420485175202
38187,"public Tuple(String strLine) throws NumberFormatException {
  String[] tokens=strLine.split(""String_Node_Str"");
  chromosome=tokens[0];
  position=Integer.parseInt(tokens[1]);
  signal=Double.parseDouble(tokens[2]);
  newSignal=signal;
}","public Tuple(String strLine) throws NumberFormatException {
  String[] tokens=strLine.split(""String_Node_Str"");
  if (tokens.length == 3) {
    chromosome=tokens[0];
    position=Integer.parseInt(tokens[1]);
    signal=Double.parseDouble(tokens[2]);
    newSignal=signal;
  }
}",0.9221789883268484
38188,"/** 
 * method used to execute the actual command.
 */
@Override public Response execute(){
  Response rsp=null;
  DatabaseAccessor db=null;
  try {
    db=initDB();
    boolean result=db.removeGenomeRelease(genomeVersion);
    if (result) {
      rsp=new DeleteGenomeReleaseResponse(StatusCode.OK);
    }
 else {
      rsp=new ErrorResponse(StatusCode.BAD_REQUEST,""String_Node_Str"");
    }
  }
 catch (  SQLException e) {
    return new ErrorResponse(StatusCode.BAD_REQUEST,""String_Node_Str"");
  }
catch (  IOException e) {
    return new ErrorResponse(StatusCode.BAD_REQUEST,""String_Node_Str"");
  }
 finally {
    try {
      if (db.isConnected()) {
        db.close();
      }
    }
 catch (    SQLException e) {
      return new ErrorResponse(StatusCode.SERVICE_UNAVAILABLE,""String_Node_Str"");
    }
  }
  return rsp;
}","/** 
 * method used to execute the actual command.
 */
@Override public Response execute(){
  Response rsp=null;
  DatabaseAccessor db=null;
  try {
    db=initDB();
    boolean result=db.removeGenomeRelease(genomeVersion);
    if (result) {
      rsp=new DeleteGenomeReleaseResponse(StatusCode.OK);
    }
 else {
      rsp=new ErrorResponse(StatusCode.BAD_REQUEST,""String_Node_Str"");
    }
  }
 catch (  SQLException e) {
    return new ErrorResponse(StatusCode.BAD_REQUEST,""String_Node_Str"");
  }
catch (  IOException e) {
    return new ErrorResponse(StatusCode.BAD_REQUEST,""String_Node_Str"");
  }
 finally {
    if (db.isConnected()) {
      db.close();
    }
  }
  return rsp;
}",0.8579017264276229
38189,"/** 
 * method used to execute the actual command.
 */
@Override public Response execute(){
  Response rsp=null;
  DatabaseAccessor db=null;
  try {
    db=initDB();
    String filePath=db.addGenomeRelease(genomeVersion,specie,fileName);
    rsp=new AddGenomeReleaseResponse(StatusCode.CREATED,filePath);
  }
 catch (  SQLException e) {
    if (e.getErrorCode() == 0) {
      rsp=new ErrorResponse(StatusCode.BAD_REQUEST,""String_Node_Str"");
    }
 else {
      rsp=new ErrorResponse(StatusCode.SERVICE_UNAVAILABLE,""String_Node_Str"");
    }
  }
catch (  IOException e) {
    rsp=new ErrorResponse(StatusCode.BAD_REQUEST,""String_Node_Str"");
  }
 finally {
    try {
      if (db.isConnected()) {
        db.close();
      }
    }
 catch (    SQLException e) {
      rsp=new ErrorResponse(StatusCode.SERVICE_UNAVAILABLE,""String_Node_Str"");
    }
  }
  return rsp;
}","/** 
 * method used to execute the actual command.
 */
@Override public Response execute(){
  Response rsp=null;
  DatabaseAccessor db=null;
  try {
    db=initDB();
    String filePath=db.addGenomeRelease(genomeVersion,specie,fileName);
    rsp=new AddGenomeReleaseResponse(StatusCode.CREATED,filePath);
  }
 catch (  SQLException e) {
    if (e.getErrorCode() == 0) {
      rsp=new ErrorResponse(StatusCode.BAD_REQUEST,""String_Node_Str"");
    }
 else {
      rsp=new ErrorResponse(StatusCode.SERVICE_UNAVAILABLE,""String_Node_Str"");
    }
  }
catch (  IOException e) {
    rsp=new ErrorResponse(StatusCode.BAD_REQUEST,""String_Node_Str"");
  }
 finally {
    if (db.isConnected()) {
      db.close();
    }
  }
  return rsp;
}",0.8594833018273472
38190,"@Override public void run(){
  System.out.println(Thread.currentThread().getName());
  while (true) {
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e1) {
      e1.printStackTrace();
    }
    if (!workQueue.isEmpty()) {
      ProcessCommand work=workQueue.poll();
      System.out.println(""String_Node_Str"");
      ProcessStatus stat=processStatus.get(work);
      try {
        stat.status=""String_Node_Str"";
        work.setFilePaths();
        stat.outputFiles=work.getFilePaths();
        stat.timeStarted=System.currentTimeMillis();
        Response resp=work.execute();
        System.err.println(""String_Node_Str"");
        if (resp.getCode() == StatusCode.CREATED) {
          stat.status=""String_Node_Str"";
        }
 else {
          stat.status=""String_Node_Str"";
        }
        stat.timeFinished=System.currentTimeMillis();
      }
 catch (      NullPointerException e) {
        e.printStackTrace();
      }
      ResponseLogger.printLog();
    }
 else {
      try {
        Thread.sleep(500);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
  }
}","@Override public void run(){
  System.out.println(Thread.currentThread().getName());
  while (true) {
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e1) {
      e1.printStackTrace();
    }
    if (!workQueue.isEmpty()) {
      ProcessCommand work=workQueue.poll();
      System.out.println(""String_Node_Str"");
      ProcessStatus stat=processStatus.get(work);
      stat.status=""String_Node_Str"";
      work.setFilePaths();
      stat.outputFiles=work.getFilePaths();
      stat.timeStarted=System.currentTimeMillis();
      try {
        Response resp=work.execute();
        System.err.println(""String_Node_Str"");
        if (resp.getCode() == StatusCode.CREATED) {
          stat.status=""String_Node_Str"";
        }
 else {
          stat.status=""String_Node_Str"";
        }
      }
 catch (      NullPointerException e) {
        stat.status=""String_Node_Str"";
      }
      stat.timeFinished=System.currentTimeMillis();
      ResponseLogger.printLog();
    }
 else {
      try {
        Thread.sleep(500);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
  }
}",0.9110132158590308
38191,"/** 
 * Changes the label of annotation oldName to newName. All database entries will be affected by the change. Will return a bad request response if either parameter is invalid, and an OK response if the modification succeeded.
 */
@Override public Response execute(){
  DatabaseAccessor db=null;
  try {
    db=initDB();
    Map<String,Integer> anno=db.getAnnotations();
    if (!anno.containsKey(oldName)) {
      return new ErrorResponse(StatusCode.BAD_REQUEST,""String_Node_Str"" + oldName + ""String_Node_Str"");
    }
 else     if (anno.containsKey(newName)) {
      return new ErrorResponse(StatusCode.BAD_REQUEST,""String_Node_Str"" + newName + ""String_Node_Str"");
    }
    db.changeAnnotationLabel(oldName,newName);
  }
 catch (  IOException|SQLException e) {
    return new ErrorResponse(StatusCode.SERVICE_UNAVAILABLE,e.getMessage());
  }
 finally {
    try {
      db.close();
    }
 catch (    SQLException e) {
      return new ErrorResponse(StatusCode.SERVICE_UNAVAILABLE,e.getMessage());
    }
  }
  return new MinimalResponse(StatusCode.OK);
}","/** 
 * Changes the label of annotation oldName to newName. All database entries will be affected by the change. Will return a bad request response if either parameter is invalid, and an OK response if the modification succeeded.
 */
@Override public Response execute(){
  DatabaseAccessor db=null;
  try {
    db=initDB();
  }
 catch (  SQLException|IOException e) {
    return new ErrorResponse(StatusCode.BAD_REQUEST,""String_Node_Str"" + e.getMessage());
  }
  try {
    Map<String,Integer> anno=db.getAnnotations();
    if (!anno.containsKey(oldName)) {
      return new ErrorResponse(StatusCode.BAD_REQUEST,""String_Node_Str"" + oldName + ""String_Node_Str"");
    }
 else     if (anno.containsKey(newName)) {
      return new ErrorResponse(StatusCode.BAD_REQUEST,""String_Node_Str"" + newName + ""String_Node_Str"");
    }
    try {
      db.changeAnnotationLabel(oldName,newName);
    }
 catch (    IOException|SQLException e) {
      return new ErrorResponse(StatusCode.BAD_REQUEST,""String_Node_Str"" + e.getMessage());
    }
  }
 catch (  SQLException e) {
    return new ErrorResponse(StatusCode.BAD_REQUEST,""String_Node_Str"" + e.getMessage());
  }
 finally {
    db.close();
  }
  return new MinimalResponse(StatusCode.OK);
}",0.7498904949627683
38192,"@Override public Response execute(){
  ArrayList<AnnotationInformation> annotations=new ArrayList<AnnotationInformation>();
  DatabaseAccessor db=null;
  Map<String,Integer> a=null;
  try {
    db=initDB();
    a=db.getAnnotations();
  }
 catch (  SQLException e) {
    e.printStackTrace();
    return new ErrorResponse(StatusCode.BAD_REQUEST,""String_Node_Str"");
  }
catch (  IOException e) {
    e.printStackTrace();
    return new ErrorResponse(StatusCode.SERVICE_UNAVAILABLE,""String_Node_Str"");
  }
  Iterator<String> keys=a.keySet().iterator();
  ArrayList<String> annotation_names=new ArrayList<String>();
  while (keys.hasNext()) {
    annotation_names.add(keys.next());
  }
  for (int i=0; i < annotation_names.size(); i++) {
    database.Annotation annotationObject=null;
    ArrayList<String> values=new ArrayList<String>();
    try {
      annotationObject=db.getAnnotationObject(annotation_names.get(i));
    }
 catch (    SQLException e) {
      e.printStackTrace();
    }
    if (annotationObject.dataType == database.Annotation.FREETEXT) {
      values.add(""String_Node_Str"");
    }
 else     if (annotationObject.dataType == database.Annotation.DROPDOWN) {
      values=(ArrayList<String>)annotationObject.getPossibleValues();
    }
    AnnotationInformation annotation=new AnnotationInformation(annotationObject.label,values,annotationObject.isRequired);
    annotations.add(annotation);
  }
  try {
    db.close();
  }
 catch (  SQLException e) {
    e.printStackTrace();
    return new ErrorResponse(StatusCode.SERVICE_UNAVAILABLE,""String_Node_Str"");
  }
  return new GetAnnotationInformationResponse(200,annotations);
}","@Override public Response execute(){
  ArrayList<AnnotationInformation> annotations=new ArrayList<AnnotationInformation>();
  DatabaseAccessor db=null;
  Map<String,Integer> a=null;
  try {
    db=initDB();
  }
 catch (  SQLException|IOException e) {
    return new ErrorResponse(StatusCode.BAD_REQUEST,""String_Node_Str"" + e.getMessage());
  }
  try {
    a=db.getAnnotations();
  }
 catch (  SQLException e) {
    return new ErrorResponse(StatusCode.BAD_REQUEST,""String_Node_Str"" + e.getMessage());
  }
  Iterator<String> keys=a.keySet().iterator();
  ArrayList<String> annotation_names=new ArrayList<String>();
  while (keys.hasNext()) {
    annotation_names.add(keys.next());
  }
  for (int i=0; i < annotation_names.size(); i++) {
    database.Annotation annotationObject=null;
    ArrayList<String> values=new ArrayList<String>();
    try {
      annotationObject=db.getAnnotationObject(annotation_names.get(i));
    }
 catch (    SQLException e) {
      e.printStackTrace();
    }
    if (annotationObject.dataType == database.Annotation.FREETEXT) {
      values.add(""String_Node_Str"");
    }
 else     if (annotationObject.dataType == database.Annotation.DROPDOWN) {
      values=(ArrayList<String>)annotationObject.getPossibleValues();
    }
    AnnotationInformation annotation=new AnnotationInformation(annotationObject.label,values,annotationObject.isRequired);
    annotations.add(annotation);
  }
  db.close();
  return new GetAnnotationInformationResponse(StatusCode.OK,annotations);
}",0.8154287535862289
38193,"@Override public Response execute(){
  Experiment exp;
  DatabaseAccessor db=null;
  try {
    db=initDB();
    exp=db.getExperiment(header);
  }
 catch (  SQLException|IOException e) {
    return new ErrorResponse(StatusCode.BAD_REQUEST,e.getMessage());
  }
 finally {
    try {
      db.close();
    }
 catch (    SQLException e) {
      e.printStackTrace();
      return new ErrorResponse(StatusCode.SERVICE_UNAVAILABLE,""String_Node_Str"");
    }
  }
  if (exp == null) {
    return new ErrorResponse(StatusCode.BAD_REQUEST,""String_Node_Str"");
  }
  return new GetExperimentResponse(getInfo(exp),exp.getAnnotations(),exp.getFiles(),StatusCode.OK);
}","@Override public Response execute(){
  Experiment exp;
  DatabaseAccessor db=null;
  try {
    db=initDB();
  }
 catch (  SQLException|IOException e) {
    return new ErrorResponse(StatusCode.BAD_REQUEST,""String_Node_Str"" + e.getMessage());
  }
  try {
    exp=db.getExperiment(header);
  }
 catch (  SQLException e) {
    return new ErrorResponse(StatusCode.BAD_REQUEST,""String_Node_Str"" + e.getMessage());
  }
  db.close();
  if (exp == null) {
    return new ErrorResponse(StatusCode.BAD_REQUEST,""String_Node_Str"");
  }
  return new GetExperimentResponse(StatusCode.OK,getInfo(exp),exp.getAnnotations(),exp.getFiles());
}",0.6227450980392157
38194,"/** 
 * Connects to the database, retrieves all the genomeReleases and creates a response depending on the database return value.
 * @return Object of the response class depending on result.
 */
@Override public Response execute(){
  DatabaseAccessor db=null;
  try {
    db=new DatabaseAccessor(DatabaseSettings.username,DatabaseSettings.password,DatabaseSettings.host,DatabaseSettings.database);
    ArrayList<Genome> genomeReleases=db.getAllGenomReleases();
    return new GetGenomeReleaseRespons(StatusCode.OK,genomeReleases);
  }
 catch (  SQLException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
 finally {
    try {
      db.close();
    }
 catch (    SQLException e) {
      e.printStackTrace();
    }
  }
  return new ErrorResponse(StatusCode.BAD_REQUEST,""String_Node_Str"");
}","/** 
 * Connects to the database, retrieves all the genomeReleases and creates a response depending on the database return value.
 * @return Object of the response class depending on result.
 */
@Override public Response execute(){
  DatabaseAccessor db=null;
  try {
    db=new DatabaseAccessor(DatabaseSettings.username,DatabaseSettings.password,DatabaseSettings.host,DatabaseSettings.database);
    try {
      ArrayList<Genome> genomeReleases=(ArrayList<Genome>)db.getAllGenomReleases();
      return new GetGenomeReleaseRespons(StatusCode.OK,genomeReleases);
    }
 catch (    SQLException e) {
      return new ErrorResponse(StatusCode.SERVICE_UNAVAILABLE,""String_Node_Str"" + e.getMessage());
    }
  }
 catch (  SQLException e) {
    return new ErrorResponse(StatusCode.SERVICE_UNAVAILABLE,""String_Node_Str"" + e.getMessage());
  }
catch (  IOException e) {
    return new ErrorResponse(StatusCode.SERVICE_UNAVAILABLE,""String_Node_Str"" + e.getMessage());
  }
 finally {
    db.close();
  }
}",0.6776135741652983
38195,"/** 
 * Connects to the database, retrieves all the genomeReleases for a specific species from the db and creates a response depending on the return value from the database If the species asked for doesn't exist in the database, a bad request respons is returned
 */
@Override public Response execute(){
  DatabaseAccessor db=null;
  try {
    db=new DatabaseAccessor(DatabaseSettings.username,DatabaseSettings.password,DatabaseSettings.host,DatabaseSettings.database);
    if (db.getChoices(""String_Node_Str"").contains(species)) {
      ArrayList<Genome> genomeReleases=db.getAllGenomReleasesForSpecies(species);
      return new GetGenomeReleaseRespons(StatusCode.OK,genomeReleases);
    }
 else {
      return new ErrorResponse(StatusCode.BAD_REQUEST,""String_Node_Str"");
    }
  }
 catch (  SQLException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
 finally {
    try {
      db.close();
    }
 catch (    SQLException e) {
      e.printStackTrace();
    }
  }
  return null;
}","/** 
 * Connects to the database, retrieves all the genomeReleases for a specific species from the db and creates a response depending on the return value from the database If the species asked for doesn't exist in the database, a bad request respons is returned
 */
@Override public Response execute(){
  DatabaseAccessor db=null;
  try {
    db=new DatabaseAccessor(DatabaseSettings.username,DatabaseSettings.password,DatabaseSettings.host,DatabaseSettings.database);
    try {
      if (db.getChoices(""String_Node_Str"").contains(species)) {
        ArrayList<Genome> genomeReleases=db.getAllGenomReleasesForSpecies(species);
        return new GetGenomeReleaseRespons(StatusCode.OK,genomeReleases);
      }
 else {
        return new ErrorResponse(StatusCode.BAD_REQUEST,""String_Node_Str"");
      }
    }
 catch (    SQLException e) {
      return new ErrorResponse(StatusCode.SERVICE_UNAVAILABLE,""String_Node_Str"" + e.getMessage());
    }
  }
 catch (  SQLException e) {
    return new ErrorResponse(StatusCode.SERVICE_UNAVAILABLE,""String_Node_Str"" + e.getMessage());
  }
catch (  IOException e) {
    return new ErrorResponse(StatusCode.SERVICE_UNAVAILABLE,""String_Node_Str"");
  }
 finally {
    db.close();
  }
}",0.7957181088314005
38196,"public void setFilePaths(){
  DatabaseAccessor db=null;
  try {
    db=initDB();
    filepaths=db.processRawToProfile(expid);
  }
 catch (  SQLException|IOException e) {
    e.printStackTrace();
  }
 finally {
    try {
      db.close();
    }
 catch (    SQLException e) {
      e.printStackTrace();
    }
  }
}","public void setFilePaths(){
  DatabaseAccessor db=null;
  try {
    db=initDB();
    filepaths=db.processRawToProfile(expid);
  }
 catch (  SQLException|IOException e) {
    e.printStackTrace();
  }
 finally {
    db.close();
  }
}",0.8397790055248618
38197,"/** 
 * Method that runs when the processCommand is executed.
 */
@Override public Response execute(){
  System.out.println(""String_Node_Str"");
  DatabaseAccessor db=null;
  ProcessHandler processHandler;
  try {
    db=new DatabaseAccessor(DatabaseSettings.username,DatabaseSettings.password,DatabaseSettings.host,DatabaseSettings.database);
    processHandler=new ProcessHandler();
switch (processtype) {
case ""String_Node_Str"":
      filepaths=db.processRawToProfile(expid);
    if (!db.isConnected()) {
      db=new DatabaseAccessor(DatabaseSettings.username,DatabaseSettings.password,DatabaseSettings.host,DatabaseSettings.database);
    }
  Genome g=db.getGenomeRelease(genomeVersion);
parameters[1]=g.path;
try {
processHandler.executeProcess(""String_Node_Str"",parameters,filepaths.getKey(),filepaths.getValue());
System.out.println(""String_Node_Str"");
for (String s : parameters) {
  System.out.println(""String_Node_Str"" + s);
}
}
 catch (ProcessException e) {
e.printStackTrace();
ResponseLogger.log(username,""String_Node_Str"" + processtype + ""String_Node_Str""+ expid+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ genomeVersion+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str""+ e.getMessage());
db.close();
return new ProcessResponse(StatusCode.SERVICE_UNAVAILABLE,e.getMessage());
}
break;
default :
System.err.println(""String_Node_Str"");
db.close();
ResponseLogger.log(username,""String_Node_Str"" + processtype + ""String_Node_Str""+ expid+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ genomeVersion+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str"");
return new ProcessResponse(StatusCode.BAD_REQUEST,""String_Node_Str"" + processtype + ""String_Node_Str""+ expid+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ genomeVersion+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str"");
}
}
 catch (SQLException e) {
e.printStackTrace();
ResponseLogger.log(username,""String_Node_Str"" + processtype + ""String_Node_Str""+ expid+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ genomeVersion+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str""+ e.getMessage());
try {
db.close();
}
 catch (SQLException e1) {
ResponseLogger.log(username,""String_Node_Str"" + processtype + ""String_Node_Str""+ expid+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ genomeVersion+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str""+ e1.getMessage());
e1.printStackTrace();
return new ProcessResponse(StatusCode.SERVICE_UNAVAILABLE,""String_Node_Str"" + processtype + ""String_Node_Str""+ expid+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ genomeVersion+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str""+ e.getMessage());
}
}
catch (IOException e1) {
e1.printStackTrace();
ResponseLogger.log(username,""String_Node_Str"" + processtype + ""String_Node_Str""+ expid+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ genomeVersion+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str""+ e1.getMessage());
try {
db.close();
}
 catch (SQLException e) {
ResponseLogger.log(username,""String_Node_Str"" + processtype + ""String_Node_Str""+ expid+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ genomeVersion+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str""+ e.getMessage());
e.printStackTrace();
}
return new ProcessResponse(StatusCode.SERVICE_UNAVAILABLE,""String_Node_Str"" + processtype + ""String_Node_Str""+ expid+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ genomeVersion+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str""+ e1.getMessage());
}
try {
if (!db.isConnected()) {
db=new DatabaseAccessor(DatabaseSettings.username,DatabaseSettings.password,DatabaseSettings.host,DatabaseSettings.database);
}
db.addGeneratedProfiles(expid,filepaths.getValue(),filepaths.getKey(),metadata,genomeVersion,username,false);
}
 catch (SQLException e) {
e.printStackTrace();
ResponseLogger.log(username,""String_Node_Str"" + processtype + ""String_Node_Str""+ expid+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ genomeVersion+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str""+ e.getMessage());
try {
db.close();
}
 catch (SQLException e1) {
ResponseLogger.log(username,""String_Node_Str"" + processtype + ""String_Node_Str""+ expid+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ genomeVersion+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str""+ e1.getMessage());
e1.printStackTrace();
}
return new ProcessResponse(StatusCode.SERVICE_UNAVAILABLE,""String_Node_Str"" + processtype + ""String_Node_Str""+ expid+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ genomeVersion+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str""+ e.getMessage());
}
catch (IOException e) {
e.printStackTrace();
ResponseLogger.log(username,""String_Node_Str"" + processtype + ""String_Node_Str""+ expid+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ genomeVersion+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str""+ e.getMessage());
try {
db.close();
}
 catch (SQLException e1) {
ResponseLogger.log(username,""String_Node_Str"" + processtype + ""String_Node_Str""+ expid+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ genomeVersion+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str""+ e1.getMessage());
e1.printStackTrace();
}
return new ProcessResponse(StatusCode.SERVICE_UNAVAILABLE,""String_Node_Str"" + processtype + ""String_Node_Str""+ expid+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ genomeVersion+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str""+ e.getMessage());
}
try {
db.close();
}
 catch (SQLException e) {
ResponseLogger.log(username,""String_Node_Str"" + processtype + ""String_Node_Str""+ expid+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ genomeVersion+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str""+ e.getMessage());
e.printStackTrace();
}
ResponseLogger.log(username,""String_Node_Str"" + processtype + ""String_Node_Str""+ expid+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ genomeVersion+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str"");
return new ProcessResponse(StatusCode.CREATED,""String_Node_Str"" + processtype + ""String_Node_Str""+ expid+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ genomeVersion+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str"");
}","/** 
 * Method that runs when the processCommand is executed.
 */
@Override public Response execute(){
  System.out.println(""String_Node_Str"");
  DatabaseAccessor db=null;
  ProcessHandler processHandler;
  try {
    db=new DatabaseAccessor(DatabaseSettings.username,DatabaseSettings.password,DatabaseSettings.host,DatabaseSettings.database);
    processHandler=new ProcessHandler();
switch (processtype) {
case ""String_Node_Str"":
      filepaths=db.processRawToProfile(expid);
    if (!db.isConnected()) {
      db=new DatabaseAccessor(DatabaseSettings.username,DatabaseSettings.password,DatabaseSettings.host,DatabaseSettings.database);
    }
  Genome g=db.getGenomeRelease(genomeVersion);
parameters[1]=g.folderPath;
try {
processHandler.executeProcess(""String_Node_Str"",parameters,filepaths.getKey(),filepaths.getValue());
System.out.println(""String_Node_Str"");
for (String s : parameters) {
  System.out.println(""String_Node_Str"" + s);
}
}
 catch (ProcessException e) {
e.printStackTrace();
ResponseLogger.log(username,""String_Node_Str"" + processtype + ""String_Node_Str""+ expid+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ genomeVersion+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str""+ e.getMessage());
db.close();
return new ProcessResponse(StatusCode.SERVICE_UNAVAILABLE,e.getMessage());
}
break;
default :
System.err.println(""String_Node_Str"");
db.close();
ResponseLogger.log(username,""String_Node_Str"" + processtype + ""String_Node_Str""+ expid+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ genomeVersion+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str"");
return new ProcessResponse(StatusCode.BAD_REQUEST,""String_Node_Str"" + processtype + ""String_Node_Str""+ expid+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ genomeVersion+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str"");
}
}
 catch (SQLException e) {
e.printStackTrace();
ResponseLogger.log(username,""String_Node_Str"" + processtype + ""String_Node_Str""+ expid+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ genomeVersion+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str""+ e.getMessage());
db.close();
}
catch (IOException e1) {
e1.printStackTrace();
ResponseLogger.log(username,""String_Node_Str"" + processtype + ""String_Node_Str""+ expid+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ genomeVersion+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str""+ e1.getMessage());
db.close();
return new ProcessResponse(StatusCode.SERVICE_UNAVAILABLE,""String_Node_Str"" + processtype + ""String_Node_Str""+ expid+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ genomeVersion+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str""+ e1.getMessage());
}
try {
if (!db.isConnected()) {
db=new DatabaseAccessor(DatabaseSettings.username,DatabaseSettings.password,DatabaseSettings.host,DatabaseSettings.database);
}
db.addGeneratedProfiles(expid,filepaths.getValue(),filepaths.getKey(),metadata,genomeVersion,username,false);
}
 catch (SQLException e) {
e.printStackTrace();
ResponseLogger.log(username,""String_Node_Str"" + processtype + ""String_Node_Str""+ expid+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ genomeVersion+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str""+ e.getMessage());
db.close();
return new ProcessResponse(StatusCode.SERVICE_UNAVAILABLE,""String_Node_Str"" + processtype + ""String_Node_Str""+ expid+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ genomeVersion+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str""+ e.getMessage());
}
catch (IOException e) {
e.printStackTrace();
ResponseLogger.log(username,""String_Node_Str"" + processtype + ""String_Node_Str""+ expid+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ genomeVersion+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str""+ e.getMessage());
db.close();
return new ProcessResponse(StatusCode.SERVICE_UNAVAILABLE,""String_Node_Str"" + processtype + ""String_Node_Str""+ expid+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ genomeVersion+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str""+ e.getMessage());
}
db.close();
ResponseLogger.log(username,""String_Node_Str"" + processtype + ""String_Node_Str""+ expid+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ genomeVersion+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str"");
return new ProcessResponse(StatusCode.CREATED,""String_Node_Str"" + processtype + ""String_Node_Str""+ expid+ ""String_Node_Str""+ ""String_Node_Str""+ metadata+ ""String_Node_Str""+ ""String_Node_Str""+ parameters+ ""String_Node_Str""+ ""String_Node_Str""+ genomeVersion+ ""String_Node_Str""+ ""String_Node_Str""+ author+ ""String_Node_Str"");
}",0.6941263940520446
38198,"/** 
 * Runs the actual code needed to search the database.
 */
@Override public Response execute(){
  DatabaseAccessor db=null;
  List<Experiment> searchResult=null;
  System.out.println(annotations);
  if (annotations.equals(""String_Node_Str"")) {
    return new ErrorResponse(StatusCode.BAD_REQUEST,""String_Node_Str"");
  }
  try {
    annotations=URLDecoder.decode(annotations,""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
    e.printStackTrace();
    return new ErrorResponse(StatusCode.BAD_REQUEST,e.getMessage());
  }
  try {
    db=initDB();
    searchResult=db.search(annotations);
  }
 catch (  SQLException|IOException e) {
    return new ErrorResponse(StatusCode.SERVICE_UNAVAILABLE,e.getMessage());
  }
 finally {
    try {
      db.close();
    }
 catch (    SQLException e) {
      e.printStackTrace();
      return new MinimalResponse(StatusCode.SERVICE_UNAVAILABLE);
    }
  }
  SearchResponse response=new SearchResponse(searchResult);
  return response;
}","/** 
 * Runs the actual code needed to search the database.
 */
@Override public Response execute(){
  DatabaseAccessor db=null;
  List<Experiment> searchResult=null;
  System.out.println(annotations);
  if (annotations.equals(""String_Node_Str"")) {
    return new ErrorResponse(StatusCode.BAD_REQUEST,""String_Node_Str"");
  }
  try {
    annotations=URLDecoder.decode(annotations,""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
    e.printStackTrace();
    return new ErrorResponse(StatusCode.BAD_REQUEST,e.getMessage());
  }
  try {
    db=initDB();
    searchResult=db.search(annotations);
  }
 catch (  SQLException|IOException e) {
    return new ErrorResponse(StatusCode.SERVICE_UNAVAILABLE,e.getMessage());
  }
catch (  ParseException e) {
    return new ErrorResponse(StatusCode.SERVICE_UNAVAILABLE,e.getMessage());
  }
 finally {
    db.close();
  }
  SearchResponse response=new SearchResponse(searchResult);
  return response;
}",0.903126601742696
38199,"public GetExperimentResponse(ArrayList<String> info,Map<String,String> annotations,List<FileTuple> list,int code){
  this.code=code;
  obj=new JsonObject();
  obj.addProperty(""String_Node_Str"",info.get(0));
  obj.addProperty(""String_Node_Str"",""String_Node_Str"");
  JsonArray fileArray=new JsonArray();
  for (  FileTuple ft : list) {
    GsonBuilder gsonBuilder=new GsonBuilder();
    Gson gson=gsonBuilder.setPrettyPrinting().create();
    FileInformation fileInfo=new FileInformation(ft);
    JsonElement fileJson=gson.toJsonTree(fileInfo);
    fileArray.add(fileJson);
  }
  obj.add(""String_Node_Str"",fileArray);
  JsonArray annotationArray=new JsonArray();
  for (  String key : annotations.keySet()) {
    JsonObject anno=new JsonObject();
    anno.addProperty(""String_Node_Str"",key);
    anno.addProperty(""String_Node_Str"",annotations.get(key));
    annotationArray.add(anno);
  }
  obj.add(""String_Node_Str"",annotationArray);
}","public GetExperimentResponse(int code,ArrayList<String> info,Map<String,String> annotations,List<FileTuple> list){
  this.code=code;
  obj=new JsonObject();
  obj.addProperty(""String_Node_Str"",info.get(0));
  obj.addProperty(""String_Node_Str"",""String_Node_Str"");
  JsonArray fileArray=new JsonArray();
  for (  FileTuple ft : list) {
    GsonBuilder gsonBuilder=new GsonBuilder();
    Gson gson=gsonBuilder.setPrettyPrinting().create();
    FileInformation fileInfo=new FileInformation(ft);
    JsonElement fileJson=gson.toJsonTree(fileInfo);
    fileArray.add(fileJson);
  }
  obj.add(""String_Node_Str"",fileArray);
  JsonArray annotationArray=new JsonArray();
  for (  String key : annotations.keySet()) {
    JsonObject anno=new JsonObject();
    anno.addProperty(""String_Node_Str"",key);
    anno.addProperty(""String_Node_Str"",annotations.get(key));
    annotationArray.add(anno);
  }
  obj.add(""String_Node_Str"",annotationArray);
}",0.9903640256959316
38200,"private void validateInput(int[] params,int stepSize) throws ProcessException {
  if (!(params[1] == 0 || params[1] == 1)) {
    throw new ProcessException(""String_Node_Str"");
  }
  if (params == null) {
    throw new ProcessException(""String_Node_Str"");
  }
  if (params[0] <= params[2]) {
    throw new ProcessException(""String_Node_Str"");
  }
  if (stepSize < 1) {
    throw new ProcessException(""String_Node_Str"");
  }
  if (params[0] < 1) {
    throw new ProcessException(""String_Node_Str"");
  }
  if (params[2] < 0) {
    throw new ProcessException(""String_Node_Str"");
  }
  if (!(params[3] == 0 || params[1] == 1)) {
    throw new ProcessException(""String_Node_Str"");
  }
  if (!(params[4] == 0 || params[1] == 1)) {
    throw new ProcessException(""String_Node_Str"");
  }
}","private void validateInput(int[] params,int stepSize) throws ProcessException {
  if (!(params[1] == 0 || params[1] == 1)) {
    throw new ProcessException(""String_Node_Str"");
  }
  if (params == null) {
    throw new ProcessException(""String_Node_Str"");
  }
  if (params[0] <= params[2]) {
    throw new ProcessException(""String_Node_Str"");
  }
  if (stepSize < 1) {
    throw new ProcessException(""String_Node_Str"");
  }
  if (params[0] < 1) {
    throw new ProcessException(""String_Node_Str"");
  }
  if (params[2] < 0) {
    throw new ProcessException(""String_Node_Str"");
  }
  if (!(params[3] == 0 || params[3] == 1)) {
    throw new ProcessException(""String_Node_Str"");
  }
  if (!(params[4] == 0 || params[4] == 1)) {
    throw new ProcessException(""String_Node_Str"");
  }
}",0.9910256410256412
38201,"/** 
 * Used to execute the logout command.
 */
@Override public Response execute(){
  DatabaseAccessor db=null;
  try {
    db=initDB();
    ArrayList<String> annotations=db.getAllAnnotationLabels();
    if (annotations.contains(header)) {
      db.deleteAnnotation(header);
      return new MinimalResponse(200);
    }
 else {
      return new ErrorResponse(StatusCode.BAD_REQUEST,""String_Node_Str"" + header + ""String_Node_Str"");
    }
  }
 catch (  SQLException e) {
    e.printStackTrace();
    return new ErrorResponse(StatusCode.BAD_REQUEST,e.getMessage());
  }
catch (  IOException e) {
    e.printStackTrace();
    return new ErrorResponse(StatusCode.SERVICE_UNAVAILABLE,e.getMessage());
  }
 finally {
    try {
      db.close();
    }
 catch (    SQLException e) {
      e.printStackTrace();
      return new ErrorResponse(StatusCode.SERVICE_UNAVAILABLE,""String_Node_Str"");
    }
  }
}","/** 
 * Used to execute the logout command.
 */
@Override public Response execute(){
  DatabaseAccessor db=null;
  try {
    db=initDB();
    ArrayList<String> annotations=db.getAllAnnotationLabels();
    if (annotations.contains(header)) {
      db.deleteAnnotation(header);
      return new MinimalResponse(200);
    }
 else {
      return new ErrorResponse(StatusCode.BAD_REQUEST,""String_Node_Str"" + header + ""String_Node_Str"");
    }
  }
 catch (  SQLException e) {
    e.printStackTrace();
    return new ErrorResponse(StatusCode.BAD_REQUEST,e.getMessage());
  }
catch (  IOException e) {
    e.printStackTrace();
    return new ErrorResponse(StatusCode.SERVICE_UNAVAILABLE,e.getMessage());
  }
 finally {
    db.close();
  }
}",0.8998156115550092
38202,"private void validateInput(int[] params,int stepSize) throws ProcessException {
  if (!(params[1] == 0 || params[1] == 1)) {
    throw new ProcessException(""String_Node_Str"");
  }
  if (params == null) {
    throw new ProcessException(""String_Node_Str"");
  }
  if (params[0] <= params[2]) {
    throw new ProcessException(""String_Node_Str"");
  }
  if (stepSize < 1) {
    throw new ProcessException(""String_Node_Str"");
  }
  if (params[0] < 1) {
    throw new ProcessException(""String_Node_Str"");
  }
  if (params[2] < 0) {
    throw new ProcessException(""String_Node_Str"");
  }
  if (!(params[3] == 0 || params[1] == 1)) {
    throw new ProcessException(""String_Node_Str"");
  }
  if (!(params[4] == 0 || params[1] == 1)) {
    throw new ProcessException(""String_Node_Str"");
  }
}","private void validateInput(int[] params,int stepSize) throws ProcessException {
  if (!(params[1] == 0 || params[1] == 1)) {
    throw new ProcessException(""String_Node_Str"");
  }
  if (params == null) {
    throw new ProcessException(""String_Node_Str"");
  }
  if (params[0] <= params[2]) {
    throw new ProcessException(""String_Node_Str"");
  }
  if (stepSize < 1) {
    throw new ProcessException(""String_Node_Str"");
  }
  if (params[0] < 1) {
    throw new ProcessException(""String_Node_Str"");
  }
  if (params[2] < 0) {
    throw new ProcessException(""String_Node_Str"");
  }
  if (!(params[3] == 0 || params[3] == 1)) {
    throw new ProcessException(""String_Node_Str"");
  }
  if (!(params[4] == 0 || params[4] == 1)) {
    throw new ProcessException(""String_Node_Str"");
  }
}",0.9910256410256412
38203,"/** 
 * Method used to execute the command and add the annotation field.
 */
@Override public Response execute(){
  int addedAnnotations=0;
  int defaultValueIndex=0;
  DatabaseAccessor db=null;
  try {
    db=initDB();
    for (int i=0; i < type.size(); i++) {
      if (type.get(i).equals(defaults)) {
        defaultValueIndex=i;
        break;
      }
    }
    if (type.size() == 1 && type.get(0).equals(""String_Node_Str"")) {
      addedAnnotations=db.addFreeTextAnnotation(name,defaults,forced);
    }
 else {
      addedAnnotations=db.addDropDownAnnotation(name,type,defaultValueIndex,forced);
    }
    if (addedAnnotations != 0) {
      return new AddAnnotationFieldResponse(StatusCode.CREATED);
    }
 else {
      return new ErrorResponse(StatusCode.BAD_REQUEST,""String_Node_Str"");
    }
  }
 catch (  SQLException e) {
    e.printStackTrace();
    if (e.getErrorCode() == 0) {
      return new ErrorResponse(StatusCode.BAD_REQUEST,""String_Node_Str"" + name + ""String_Node_Str"");
    }
 else {
      return new ErrorResponse(StatusCode.SERVICE_UNAVAILABLE,""String_Node_Str"");
    }
  }
catch (  IOException e) {
    e.printStackTrace();
    return new MinimalResponse(StatusCode.BAD_REQUEST);
  }
 finally {
    try {
      db.close();
    }
 catch (    SQLException e) {
      e.printStackTrace();
    }
  }
}","/** 
 * Method used to execute the command and add the annotation field.
 */
@Override public Response execute(){
  int addedAnnotations=0;
  int defaultValueIndex=0;
  DatabaseAccessor db=null;
  try {
    db=initDB();
    for (int i=0; i < type.size(); i++) {
      if (type.get(i).equals(defaults)) {
        defaultValueIndex=i;
        break;
      }
    }
    if (type.size() == 1 && type.get(0).equals(""String_Node_Str"")) {
      addedAnnotations=db.addFreeTextAnnotation(name,defaults,forced);
    }
 else {
      addedAnnotations=db.addDropDownAnnotation(name,type,defaultValueIndex,forced);
    }
    if (addedAnnotations != 0) {
      return new AddAnnotationFieldResponse(StatusCode.CREATED);
    }
 else {
      return new ErrorResponse(StatusCode.BAD_REQUEST,""String_Node_Str"");
    }
  }
 catch (  SQLException e) {
    e.printStackTrace();
    if (e.getErrorCode() == 0) {
      return new ErrorResponse(StatusCode.BAD_REQUEST,""String_Node_Str"" + name + ""String_Node_Str"");
    }
 else {
      return new ErrorResponse(StatusCode.SERVICE_UNAVAILABLE,""String_Node_Str"");
    }
  }
catch (  IOException e) {
    e.printStackTrace();
    return new MinimalResponse(StatusCode.BAD_REQUEST);
  }
 finally {
    db.close();
  }
}",0.9683470105509964
38204,"private String moveNegatedConstraint(String s,StringBuilder sb) throws IOException {
  SimpleEntry<String,String> labelValue=getLabelValuePair(s);
  String label=labelValue.getKey();
  String value=labelValue.getValue();
  if (fileAttributes.contains(label)) {
    sb.append(sqlFragmentForFileAttr);
    sb.append(label);
    sb.append(""String_Node_Str"");
    parametersResult.add(value);
  }
 else {
    sb.append(sqlFragmentForExpAttrInFileSearchNegated);
    parametersResult.add(label);
    parametersResult.add(value);
  }
  return removeLeadingConstraint(s);
}","private String moveNegatedConstraint(String s,StringBuilder sb) throws IOException {
  SimpleEntry<String,String> labelValue=getLabelValuePair(s);
  String label=labelValue.getKey();
  String value=labelValue.getValue();
  if (fileAttributes.contains(label.toLowerCase())) {
    sb.append(sqlFragmentForFileAttr);
    sb.append(label);
    sb.append(""String_Node_Str"");
    parametersResult.add(value);
  }
 else {
    sb.append(sqlFragmentForExpAttrInFileSearchNegated);
    parametersResult.add(label);
    parametersResult.add(value);
  }
  return removeLeadingConstraint(s);
}",0.987783595113438
38205,"public boolean hasFileConstraint(String pubMedString){
  while (pubMedString.indexOf('[') != -1) {
    pubMedString=pubMedString.substring(pubMedString.indexOf('[') + 1);
    String label=pubMedString.substring(0,pubMedString.indexOf(']'));
    if (fileAttributes.contains(label)) {
      return true;
    }
  }
  return false;
}","public boolean hasFileConstraint(String pubMedString){
  while (pubMedString.indexOf('[') != -1) {
    pubMedString=pubMedString.substring(pubMedString.indexOf('[') + 1);
    String label=pubMedString.substring(0,pubMedString.indexOf(']'));
    if (fileAttributes.contains(label.toLowerCase())) {
      return true;
    }
  }
  return false;
}",0.9791666666666666
38206,"private String moveConstraint(String s,StringBuilder sb) throws IOException {
  SimpleEntry<String,String> labelValue=getLabelValuePair(s);
  String label=labelValue.getKey();
  String value=labelValue.getValue();
  if (fileAttributes.contains(label)) {
    sb.append(sqlFragmentForFileAttr);
    sb.append(label);
    sb.append(""String_Node_Str"");
    parametersResult.add(value);
  }
 else {
    sb.append(sqlFragmentForExpAttrInFileSearch);
    parametersResult.add(label);
    parametersResult.add(value);
  }
  return removeLeadingConstraint(s);
}","private String moveConstraint(String s,StringBuilder sb) throws IOException {
  SimpleEntry<String,String> labelValue=getLabelValuePair(s);
  String label=labelValue.getKey();
  String value=labelValue.getValue();
  if (fileAttributes.contains(label.toLowerCase())) {
    sb.append(sqlFragmentForFileAttr);
    sb.append(label);
    sb.append(""String_Node_Str"");
    parametersResult.add(value);
  }
 else {
    sb.append(sqlFragmentForExpAttrInFileSearch);
    parametersResult.add(label);
    parametersResult.add(value);
  }
  return removeLeadingConstraint(s);
}",0.9874776386404294
38207,"/** 
 * Method used to create command objects together with CommandFactory.
 * @param a JSON string.
 * @param a RESTful-header.
 * @param a enumeration that determines command type.
 * @return a Command of the correct type.
 */
private Command createCommand(String json,String restful,String username,CommandType cmdt){
  Command newCommand=null;
  if (cmdt == CommandType.DELETE_ANNOTATION_VALUE_COMMAND) {
    String[] rest=restful.split(""String_Node_Str"");
    newCommand=cmdFactory.createDeleteAnnotationValueCommand(json,rest[3],rest[4]);
  }
  String parsedRest=parseRest(restful);
  if (cmdt == CommandType.LOGIN_COMMAND) {
    newCommand=cmdFactory.createLoginCommand(json);
  }
 else   if (cmdt == CommandType.LOGOUT_COMMAND) {
    newCommand=cmdFactory.createLogoutCommand(username);
  }
 else   if (cmdt == CommandType.RETRIEVE_EXPERIMENT_COMMAND) {
    newCommand=cmdFactory.createRetrieveExperimentCommand(json,parsedRest);
  }
 else   if (cmdt == CommandType.ADD_EXPERIMENT_COMMAND) {
    newCommand=cmdFactory.createAddExperimentCommand(json);
  }
 else   if (cmdt == CommandType.UPDATE_EXPERIMENT_COMMAND) {
    newCommand=cmdFactory.createUpdateExperimentCommand(json,parsedRest);
  }
 else   if (cmdt == CommandType.REMOVE_EXPERIMENT_COMMAND) {
    newCommand=cmdFactory.createRemoveExperimentCommand(json,parsedRest);
  }
 else   if (cmdt == CommandType.GET_FILE_FROM_EXPERIMENT_COMMAND) {
    newCommand=cmdFactory.createGetFileFromExperimentCommand(json,parsedRest);
  }
 else   if (cmdt == CommandType.ADD_FILE_TO_EXPERIMENT_COMMAND) {
    newCommand=cmdFactory.createAddFileToExperimentCommand(json);
  }
 else   if (cmdt == CommandType.UPDATE_FILE_IN_EXPERIMENT_COMMAND) {
    newCommand=cmdFactory.createUpdateFileInExperimentCommand(json,parsedRest);
  }
 else   if (cmdt == CommandType.DELETE_FILE_FROM_EXPERIMENT_COMMAND) {
    newCommand=cmdFactory.createDeleteFileFromExperimentCommand(json,parsedRest);
  }
 else   if (cmdt == CommandType.SEARCH_FOR_EXPERIMENTS_COMMAND) {
    newCommand=cmdFactory.createSearchForExperimentCommand(parsedRest);
  }
 else   if (cmdt == CommandType.UPDATE_USER_COMMAND) {
    newCommand=cmdFactory.createUpdateUserCommand(json,parsedRest);
  }
 else   if (cmdt == CommandType.DELETE_USER_COMMAND) {
    newCommand=cmdFactory.createDeleteUserCommand(json,parsedRest);
  }
 else   if (cmdt == CommandType.PROCESS_COMMAND) {
    newCommand=cmdFactory.createProcessCommand(json,username);
  }
 else   if (cmdt == CommandType.GET_ANNOTATION_INFORMATION_COMMAND) {
    newCommand=cmdFactory.createGetAnnotationInformationCommand(json);
  }
 else   if (cmdt == CommandType.ADD_ANNOTATION_FIELD_COMMAND) {
    newCommand=cmdFactory.createAddAnnotationFieldCommand(json,parsedRest);
  }
 else   if (cmdt == CommandType.ADD_ANNOTATION_VALUE_COMMAND) {
    newCommand=cmdFactory.createAddAnnotationValueCommand(json,parsedRest);
  }
 else   if (cmdt == CommandType.RENAME_ANNOTATION_VALUE_COMMAND) {
    newCommand=cmdFactory.creatRenameAnnotationValueCommand(json);
  }
 else   if (cmdt == CommandType.REMOVE_ANNOTATION_FIELD_COMMAND) {
    newCommand=cmdFactory.createRemoveAnnotationFieldCommand(json,parsedRest);
  }
 else   if (cmdt == CommandType.GET_ANNOTATION_PRIVILEGES_COMMAND) {
    newCommand=cmdFactory.createGetAnnotationPrivilegesCommand(json);
  }
 else   if (cmdt == CommandType.UPDATE_ANNOTATION_PRIVILEGES_COMMAND) {
    newCommand=cmdFactory.createUpdateAnnotationPrivilegesCommand(json,parsedRest);
  }
 else   if (cmdt == CommandType.ADD_GENOME_RELEASE_COMMAND) {
    newCommand=cmdFactory.createAddGenomeReleaseCommand(json);
  }
 else   if (cmdt == CommandType.DELETE_GENOME_RELEASE_COMMAND) {
    newCommand=cmdFactory.createDeleteGenomeReleaseCommand(json);
  }
  return newCommand;
}","/** 
 * Method used to create command objects together with CommandFactory.
 * @param a JSON string.
 * @param a RESTful-header.
 * @param a enumeration that determines command type.
 * @return a Command of the correct type.
 */
private Command createCommand(String json,String restful,String username,CommandType cmdt){
  Command newCommand=null;
  if (cmdt == CommandType.DELETE_ANNOTATION_VALUE_COMMAND) {
    String[] rest=restful.split(""String_Node_Str"");
    newCommand=cmdFactory.createDeleteAnnotationValueCommand(json,rest[3],rest[4]);
  }
  String parsedRest=parseRest(restful);
  if (cmdt == CommandType.LOGIN_COMMAND) {
    newCommand=cmdFactory.createLoginCommand(json);
  }
 else   if (cmdt == CommandType.LOGOUT_COMMAND) {
    newCommand=cmdFactory.createLogoutCommand(username);
  }
 else   if (cmdt == CommandType.RETRIEVE_EXPERIMENT_COMMAND) {
    newCommand=cmdFactory.createRetrieveExperimentCommand(json,parsedRest);
  }
 else   if (cmdt == CommandType.ADD_EXPERIMENT_COMMAND) {
    newCommand=cmdFactory.createAddExperimentCommand(json);
  }
 else   if (cmdt == CommandType.UPDATE_EXPERIMENT_COMMAND) {
    newCommand=cmdFactory.createUpdateExperimentCommand(json,parsedRest);
  }
 else   if (cmdt == CommandType.REMOVE_EXPERIMENT_COMMAND) {
    newCommand=cmdFactory.createRemoveExperimentCommand(json,parsedRest);
  }
 else   if (cmdt == CommandType.GET_FILE_FROM_EXPERIMENT_COMMAND) {
    newCommand=cmdFactory.createGetFileFromExperimentCommand(json,parsedRest);
  }
 else   if (cmdt == CommandType.ADD_FILE_TO_EXPERIMENT_COMMAND) {
    newCommand=cmdFactory.createAddFileToExperimentCommand(json);
  }
 else   if (cmdt == CommandType.UPDATE_FILE_IN_EXPERIMENT_COMMAND) {
    newCommand=cmdFactory.createUpdateFileInExperimentCommand(json,parsedRest);
  }
 else   if (cmdt == CommandType.DELETE_FILE_FROM_EXPERIMENT_COMMAND) {
    newCommand=cmdFactory.createDeleteFileFromExperimentCommand(json,parsedRest);
  }
 else   if (cmdt == CommandType.SEARCH_FOR_EXPERIMENTS_COMMAND) {
    newCommand=cmdFactory.createSearchForExperimentCommand(parsedRest);
  }
 else   if (cmdt == CommandType.UPDATE_USER_COMMAND) {
    newCommand=cmdFactory.createUpdateUserCommand(json,parsedRest);
  }
 else   if (cmdt == CommandType.DELETE_USER_COMMAND) {
    newCommand=cmdFactory.createDeleteUserCommand(json,parsedRest);
  }
 else   if (cmdt == CommandType.PROCESS_COMMAND) {
    newCommand=cmdFactory.createProcessCommand(json,username);
  }
 else   if (cmdt == CommandType.GET_ANNOTATION_INFORMATION_COMMAND) {
    newCommand=cmdFactory.createGetAnnotationInformationCommand(json);
  }
 else   if (cmdt == CommandType.ADD_ANNOTATION_FIELD_COMMAND) {
    newCommand=cmdFactory.createAddAnnotationFieldCommand(json,parsedRest);
  }
 else   if (cmdt == CommandType.ADD_ANNOTATION_VALUE_COMMAND) {
    newCommand=cmdFactory.createAddAnnotationValueCommand(json,parsedRest);
  }
 else   if (cmdt == CommandType.RENAME_ANNOTATION_VALUE_COMMAND) {
    newCommand=cmdFactory.creatRenameAnnotationValueCommand(json);
  }
 else   if (cmdt == CommandType.RENAME_ANNOTATION_FIELD_COMMAND) {
    newCommand=cmdFactory.createEditAnnotationFieldCommand(json);
  }
 else   if (cmdt == CommandType.REMOVE_ANNOTATION_FIELD_COMMAND) {
    newCommand=cmdFactory.createRemoveAnnotationFieldCommand(json,parsedRest);
  }
 else   if (cmdt == CommandType.GET_ANNOTATION_PRIVILEGES_COMMAND) {
    newCommand=cmdFactory.createGetAnnotationPrivilegesCommand(json);
  }
 else   if (cmdt == CommandType.UPDATE_ANNOTATION_PRIVILEGES_COMMAND) {
    newCommand=cmdFactory.createUpdateAnnotationPrivilegesCommand(json,parsedRest);
  }
 else   if (cmdt == CommandType.ADD_GENOME_RELEASE_COMMAND) {
    newCommand=cmdFactory.createAddGenomeReleaseCommand(json);
  }
 else   if (cmdt == CommandType.DELETE_GENOME_RELEASE_COMMAND) {
    newCommand=cmdFactory.createDeleteGenomeReleaseCommand(json);
  }
  return newCommand;
}",0.982121884379486
38208,"@Override public void handle(HttpExchange exchange) throws IOException {
  System.out.println(""String_Node_Str"" + exchange.getHttpContext().getPath());
switch (exchange.getRequestMethod()) {
case ""String_Node_Str"":
switch (exchange.getHttpContext().getPath()) {
case ""String_Node_Str"":
      exchange(exchange,CommandType.RETRIEVE_EXPERIMENT_COMMAND);
    break;
case ""String_Node_Str"":
  exchange(exchange,CommandType.GET_FILE_FROM_EXPERIMENT_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.SEARCH_FOR_EXPERIMENTS_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.GET_ANNOTATION_INFORMATION_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.GET_ANNOTATION_PRIVILEGES_COMMAND);
break;
}
break;
case ""String_Node_Str"":
switch (exchange.getHttpContext().getPath()) {
case ""String_Node_Str"":
exchange(exchange,CommandType.UPDATE_EXPERIMENT_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.UPDATE_FILE_IN_EXPERIMENT_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.UPDATE_USER_COMMAND);
break;
case ""String_Node_Str"":
System.out.println(""String_Node_Str"");
exchange(exchange,CommandType.PROCESS_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.RENAME_ANNOTATION_FIELD_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.RENAME_ANNOTATION_VALUE_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.UPDATE_ANNOTATION_PRIVILEGES_COMMAND);
break;
}
break;
case ""String_Node_Str"":
switch (exchange.getHttpContext().getPath()) {
case ""String_Node_Str"":
exchange(exchange,CommandType.LOGIN_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.ADD_EXPERIMENT_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.ADD_FILE_TO_EXPERIMENT_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.CREATE_USER_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.ADD_ANNOTATION_FIELD_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.ADD_ANNOTATION_VALUE_COMMAND);
break;
}
break;
case ""String_Node_Str"":
switch (exchange.getHttpContext().getPath()) {
case ""String_Node_Str"":
exchange(exchange,CommandType.LOGOUT_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.REMOVE_EXPERIMENT_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.DELETE_FILE_FROM_EXPERIMENT_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.DELETE_USER_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.REMOVE_ANNOTATION_FIELD_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.DELETE_ANNOTATION_VALUE_COMMAND);
break;
}
break;
}
}","@Override public void handle(HttpExchange exchange) throws IOException {
  System.out.println(""String_Node_Str"" + exchange.getHttpContext().getPath());
switch (exchange.getRequestMethod()) {
case ""String_Node_Str"":
switch (exchange.getHttpContext().getPath()) {
case ""String_Node_Str"":
      exchange(exchange,CommandType.RETRIEVE_EXPERIMENT_COMMAND);
    break;
case ""String_Node_Str"":
  exchange(exchange,CommandType.GET_FILE_FROM_EXPERIMENT_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.SEARCH_FOR_EXPERIMENTS_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.GET_ANNOTATION_INFORMATION_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.GET_ANNOTATION_PRIVILEGES_COMMAND);
break;
}
break;
case ""String_Node_Str"":
switch (exchange.getHttpContext().getPath()) {
case ""String_Node_Str"":
exchange(exchange,CommandType.UPDATE_EXPERIMENT_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.UPDATE_FILE_IN_EXPERIMENT_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.UPDATE_USER_COMMAND);
break;
case ""String_Node_Str"":
System.out.println(""String_Node_Str"");
exchange(exchange,CommandType.PROCESS_COMMAND);
break;
case ""String_Node_Str"":
String fullPath=exchange.getRequestURI().toString();
if (fullPath.startsWith(""String_Node_Str"")) {
System.out.println(""String_Node_Str"");
exchange(exchange,CommandType.RENAME_ANNOTATION_FIELD_COMMAND);
}
 else if (fullPath.startsWith(""String_Node_Str"")) {
exchange(exchange,CommandType.RENAME_ANNOTATION_VALUE_COMMAND);
}
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.UPDATE_ANNOTATION_PRIVILEGES_COMMAND);
break;
}
break;
case ""String_Node_Str"":
switch (exchange.getHttpContext().getPath()) {
case ""String_Node_Str"":
exchange(exchange,CommandType.LOGIN_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.ADD_EXPERIMENT_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.ADD_FILE_TO_EXPERIMENT_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.CREATE_USER_COMMAND);
break;
case ""String_Node_Str"":
String fullPath=exchange.getRequestURI().toString();
if (fullPath.startsWith(""String_Node_Str"")) {
exchange(exchange,CommandType.ADD_ANNOTATION_FIELD_COMMAND);
}
 else if (fullPath.startsWith(""String_Node_Str"")) {
exchange(exchange,CommandType.ADD_ANNOTATION_VALUE_COMMAND);
}
break;
}
break;
case ""String_Node_Str"":
switch (exchange.getHttpContext().getPath()) {
case ""String_Node_Str"":
exchange(exchange,CommandType.LOGOUT_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.REMOVE_EXPERIMENT_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.DELETE_FILE_FROM_EXPERIMENT_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.DELETE_USER_COMMAND);
break;
case ""String_Node_Str"":
String fullPath=exchange.getRequestURI().toString();
if (fullPath.startsWith(""String_Node_Str"")) {
exchange(exchange,CommandType.REMOVE_ANNOTATION_FIELD_COMMAND);
}
 else if (fullPath.startsWith(""String_Node_Str"")) {
exchange(exchange,CommandType.DELETE_ANNOTATION_VALUE_COMMAND);
}
break;
}
break;
}
}",0.8997455470737914
38209,"HttpHandler createHandler(){
  return new HttpHandler(){
    @Override public void handle(    HttpExchange exchange) throws IOException {
      System.out.println(""String_Node_Str"" + exchange.getHttpContext().getPath());
switch (exchange.getRequestMethod()) {
case ""String_Node_Str"":
switch (exchange.getHttpContext().getPath()) {
case ""String_Node_Str"":
          exchange(exchange,CommandType.RETRIEVE_EXPERIMENT_COMMAND);
        break;
case ""String_Node_Str"":
      exchange(exchange,CommandType.GET_FILE_FROM_EXPERIMENT_COMMAND);
    break;
case ""String_Node_Str"":
  exchange(exchange,CommandType.SEARCH_FOR_EXPERIMENTS_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.GET_ANNOTATION_INFORMATION_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.GET_ANNOTATION_PRIVILEGES_COMMAND);
break;
}
break;
case ""String_Node_Str"":
switch (exchange.getHttpContext().getPath()) {
case ""String_Node_Str"":
exchange(exchange,CommandType.UPDATE_EXPERIMENT_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.UPDATE_FILE_IN_EXPERIMENT_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.UPDATE_USER_COMMAND);
break;
case ""String_Node_Str"":
System.out.println(""String_Node_Str"");
exchange(exchange,CommandType.PROCESS_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.RENAME_ANNOTATION_FIELD_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.RENAME_ANNOTATION_VALUE_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.UPDATE_ANNOTATION_PRIVILEGES_COMMAND);
break;
}
break;
case ""String_Node_Str"":
switch (exchange.getHttpContext().getPath()) {
case ""String_Node_Str"":
exchange(exchange,CommandType.LOGIN_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.ADD_EXPERIMENT_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.ADD_FILE_TO_EXPERIMENT_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.CREATE_USER_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.ADD_ANNOTATION_FIELD_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.ADD_ANNOTATION_VALUE_COMMAND);
break;
}
break;
case ""String_Node_Str"":
switch (exchange.getHttpContext().getPath()) {
case ""String_Node_Str"":
exchange(exchange,CommandType.LOGOUT_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.REMOVE_EXPERIMENT_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.DELETE_FILE_FROM_EXPERIMENT_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.DELETE_USER_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.REMOVE_ANNOTATION_FIELD_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.DELETE_ANNOTATION_VALUE_COMMAND);
break;
}
break;
}
}
}
;
}","HttpHandler createHandler(){
  return new HttpHandler(){
    @Override public void handle(    HttpExchange exchange) throws IOException {
      System.out.println(""String_Node_Str"" + exchange.getHttpContext().getPath());
switch (exchange.getRequestMethod()) {
case ""String_Node_Str"":
switch (exchange.getHttpContext().getPath()) {
case ""String_Node_Str"":
          exchange(exchange,CommandType.RETRIEVE_EXPERIMENT_COMMAND);
        break;
case ""String_Node_Str"":
      exchange(exchange,CommandType.GET_FILE_FROM_EXPERIMENT_COMMAND);
    break;
case ""String_Node_Str"":
  exchange(exchange,CommandType.SEARCH_FOR_EXPERIMENTS_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.GET_ANNOTATION_INFORMATION_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.GET_ANNOTATION_PRIVILEGES_COMMAND);
break;
}
break;
case ""String_Node_Str"":
switch (exchange.getHttpContext().getPath()) {
case ""String_Node_Str"":
exchange(exchange,CommandType.UPDATE_EXPERIMENT_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.UPDATE_FILE_IN_EXPERIMENT_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.UPDATE_USER_COMMAND);
break;
case ""String_Node_Str"":
System.out.println(""String_Node_Str"");
exchange(exchange,CommandType.PROCESS_COMMAND);
break;
case ""String_Node_Str"":
String fullPath=exchange.getRequestURI().toString();
if (fullPath.startsWith(""String_Node_Str"")) {
System.out.println(""String_Node_Str"");
exchange(exchange,CommandType.RENAME_ANNOTATION_FIELD_COMMAND);
}
 else if (fullPath.startsWith(""String_Node_Str"")) {
exchange(exchange,CommandType.RENAME_ANNOTATION_VALUE_COMMAND);
}
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.UPDATE_ANNOTATION_PRIVILEGES_COMMAND);
break;
}
break;
case ""String_Node_Str"":
switch (exchange.getHttpContext().getPath()) {
case ""String_Node_Str"":
exchange(exchange,CommandType.LOGIN_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.ADD_EXPERIMENT_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.ADD_FILE_TO_EXPERIMENT_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.CREATE_USER_COMMAND);
break;
case ""String_Node_Str"":
String fullPath=exchange.getRequestURI().toString();
if (fullPath.startsWith(""String_Node_Str"")) {
exchange(exchange,CommandType.ADD_ANNOTATION_FIELD_COMMAND);
}
 else if (fullPath.startsWith(""String_Node_Str"")) {
exchange(exchange,CommandType.ADD_ANNOTATION_VALUE_COMMAND);
}
break;
}
break;
case ""String_Node_Str"":
switch (exchange.getHttpContext().getPath()) {
case ""String_Node_Str"":
exchange(exchange,CommandType.LOGOUT_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.REMOVE_EXPERIMENT_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.DELETE_FILE_FROM_EXPERIMENT_COMMAND);
break;
case ""String_Node_Str"":
exchange(exchange,CommandType.DELETE_USER_COMMAND);
break;
case ""String_Node_Str"":
String fullPath=exchange.getRequestURI().toString();
if (fullPath.startsWith(""String_Node_Str"")) {
exchange(exchange,CommandType.REMOVE_ANNOTATION_FIELD_COMMAND);
}
 else if (fullPath.startsWith(""String_Node_Str"")) {
exchange(exchange,CommandType.DELETE_ANNOTATION_VALUE_COMMAND);
}
break;
}
break;
}
}
}
;
}",0.9028120374938332
38210,"/** 
 * Creates a list of Annotation objects from a list of annotation labels.
 * @param labels the list of labels.
 * @return will return a list with all the annotations with valid labels. Ifthe list with labels is empty or none of the labels are valid, then it will return null.
 * @throws SQLException if the query does not succeed.
 */
public List<Annotation> getAnnotationObject(List<String> labels) throws SQLException {
  List<Annotation> annotations=null;
  Annotation annotation=null;
  for (  String label : labels) {
    annotation=getAnnotationObject(label);
    if (annotation != null) {
      if (annotations == null) {
        annotations=new ArrayList<Annotation>();
      }
      annotations.add(annotation);
    }
  }
  return annotations;
}","/** 
 * Creates an Annotation object from an annotation label.
 * @param label the name of the annotation to create the object for.
 * @return the Annotation object. If the label does not exist, then nullwill be returned.
 * @throws SQLException if the query does not succeed.
 */
public Annotation getAnnotationObject(String label) throws SQLException {
  String query=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
  PreparedStatement stmt=conn.prepareStatement(query);
  stmt.setString(1,label);
  ResultSet rs=stmt.executeQuery();
  if (rs.next()) {
    return new Annotation(rs);
  }
 else {
    return null;
  }
}",0.3080198722498226
38211,"@Test public void shouldGetNullWhenSendingInEmptyList() throws Exception {
  List<String> labels=new ArrayList<String>();
  List<Annotation> annotations=dbac.getAnnotationObject(labels);
  assertEquals(null,annotations);
}","@Test public void shouldGetNullWhenSendingInEmptyList() throws Exception {
  List<String> labels=new ArrayList<String>();
  List<Annotation> annotations=dbac.getAnnotationObjects(labels);
  assertEquals(null,annotations);
}",0.997752808988764
38212,"@Test public void shouldBeAbleToGetMultipleAnnotations() throws Exception {
  List<String> labels=new ArrayList<String>();
  labels.add(""String_Node_Str"");
  labels.add(""String_Node_Str"");
  List<Annotation> annotations=dbac.getAnnotationObject(labels);
  assertEquals(""String_Node_Str"",annotations.get(0).label);
  assertEquals(""String_Node_Str"",annotations.get(1).label);
}","@Test public void shouldBeAbleToGetMultipleAnnotations() throws Exception {
  List<String> labels=new ArrayList<String>();
  labels.add(""String_Node_Str"");
  labels.add(""String_Node_Str"");
  List<Annotation> annotations=dbac.getAnnotationObjects(labels);
  assertEquals(""String_Node_Str"",annotations.get(0).label);
  assertEquals(""String_Node_Str"",annotations.get(1).label);
}",0.9986684420772304
38213,"@Test public void shouldGetAnnotationsWhenMixingValidWithInvalidLabels() throws Exception {
  List<String> labels=new ArrayList<String>();
  labels.add(""String_Node_Str"");
  labels.add(""String_Node_Str"");
  labels.add(""String_Node_Str"");
  labels.add(""String_Node_Str"");
  List<Annotation> annotations=dbac.getAnnotationObject(labels);
  assertTrue(annotations.size() == 2);
  assertEquals(""String_Node_Str"",annotations.get(0).label);
  assertEquals(""String_Node_Str"",annotations.get(1).label);
}","@Test public void shouldGetAnnotationsWhenMixingValidWithInvalidLabels() throws Exception {
  List<String> labels=new ArrayList<String>();
  labels.add(""String_Node_Str"");
  labels.add(""String_Node_Str"");
  labels.add(""String_Node_Str"");
  labels.add(""String_Node_Str"");
  List<Annotation> annotations=dbac.getAnnotationObjects(labels);
  assertTrue(annotations.size() == 2);
  assertEquals(""String_Node_Str"",annotations.get(0).label);
  assertEquals(""String_Node_Str"",annotations.get(1).label);
}",0.998992950654582
38214,"@Before public void setUp(){
  final GsonBuilder builder=new GsonBuilder();
  builder.excludeFieldsWithoutExposeAnnotation();
  gson=builder.create();
}","/** 
 * Setup method to initiate gson builder.
 */
@Before public void setUp(){
  final GsonBuilder builder=new GsonBuilder();
  builder.excludeFieldsWithoutExposeAnnotation();
  gson=builder.create();
}",0.856338028169014
38215,"/** 
 * Adds all attributes an arraylist and pass that and the experimentID to the database. A filepath is returned and sent to the client as a URL.
 */
@Override public Response execute(){
  System.out.println(""String_Node_Str"" + metaData);
  DatabaseAccessor accessor=null;
  String response_url=null;
  try {
    accessor=new DatabaseAccessor(DatabaseSettings.username,DatabaseSettings.password,DatabaseSettings.host,DatabaseSettings.database);
    response_url=accessor.addFileURL(type,fileName,metaData,author,uploader,false,experimentID,grVersion);
    return new AddFileToExperimentResponse(StatusCode.OK,response_url);
  }
 catch (  SQLException e) {
    e.printStackTrace();
  }
  return new MinimalResponse(StatusCode.BAD_REQUEST);
}","/** 
 * Adds all attributes an arraylist and pass that and the experimentID to the database. A filepath is returned and sent to the client as a URL.
 */
@Override public Response execute(){
  DatabaseAccessor accessor=null;
  String response_url=null;
  try {
    accessor=new DatabaseAccessor(DatabaseSettings.username,DatabaseSettings.password,DatabaseSettings.host,DatabaseSettings.database);
    response_url=accessor.addFileURL(type,fileName,metaData,author,uploader,false,experimentID,grVersion);
    return new AddFileToExperimentResponse(StatusCode.OK,response_url);
  }
 catch (  SQLException e) {
    e.printStackTrace();
  }
  return new MinimalResponse(StatusCode.BAD_REQUEST);
}",0.9637377963737797
38216,"@Override public Response execute(){
  ArrayList<AnnotationInformation> annotations=new ArrayList<AnnotationInformation>();
  DatabaseAccessor accessor=null;
  Map<String,Integer> a=null;
  try {
    accessor=new DatabaseAccessor(DatabaseSettings.username,DatabaseSettings.password,DatabaseSettings.host,DatabaseSettings.database);
    a=accessor.getAnnotations();
    System.out.println(""String_Node_Str"");
  }
 catch (  SQLException e) {
    e.printStackTrace();
  }
  Iterator<String> keys=a.keySet().iterator();
  ArrayList<String> annotation_names=new ArrayList<String>();
  while (keys.hasNext()) {
    annotation_names.add(keys.next());
  }
  for (int i=0; i < annotation_names.size(); i++) {
    ArrayList<String> values=null;
    try {
      if (accessor.getAnnotationType(annotation_names.get(i)) == DatabaseAccessor.FREETEXT) {
        values=new ArrayList<String>();
        values.add(""String_Node_Str"");
      }
 else       if (accessor.getAnnotationType(annotation_names.get(i)) == DatabaseAccessor.DROPDOWN) {
        values=(ArrayList<String>)accessor.getChoices(annotation_names.get(i));
      }
 else {
      }
    }
 catch (    SQLException e1) {
      e1.printStackTrace();
    }
    AnnotationInformation annotation=new AnnotationInformation(0,annotation_names.get(i),values,true);
    annotations.add(annotation);
  }
  ArrayList<String> vals=new ArrayList<String>();
  vals.add(""String_Node_Str"");
  AnnotationInformation expId=new AnnotationInformation(0,""String_Node_Str"",vals,false);
  annotations.add(expId);
  Collections.sort(annotations,new compareAnnotations());
  for (int i=0; i < annotations.size(); i++) {
    annotations.get(i).setId(i);
  }
  for (int i=0; i < annotations.size(); i++) {
    System.out.println(""String_Node_Str"" + annotations.get(i));
  }
  return new GetAnnotationInformationResponse(200,annotations);
}","@Override public Response execute(){
  ArrayList<AnnotationInformation> annotations=new ArrayList<AnnotationInformation>();
  DatabaseAccessor accessor=null;
  Map<String,Integer> a=null;
  try {
    accessor=new DatabaseAccessor(DatabaseSettings.username,DatabaseSettings.password,DatabaseSettings.host,DatabaseSettings.database);
    a=accessor.getAnnotations();
    System.out.println(""String_Node_Str"");
  }
 catch (  SQLException e) {
    e.printStackTrace();
  }
  Iterator<String> keys=a.keySet().iterator();
  ArrayList<String> annotation_names=new ArrayList<String>();
  while (keys.hasNext()) {
    annotation_names.add(keys.next());
  }
  for (int i=0; i < annotation_names.size(); i++) {
    ArrayList<String> values=null;
    try {
      if (accessor.getAnnotationType(annotation_names.get(i)) == DatabaseAccessor.FREETEXT) {
        values=new ArrayList<String>();
        values.add(""String_Node_Str"");
      }
 else       if (accessor.getAnnotationType(annotation_names.get(i)) == DatabaseAccessor.DROPDOWN) {
        values=(ArrayList<String>)accessor.getChoices(annotation_names.get(i));
      }
 else {
      }
    }
 catch (    SQLException e1) {
      e1.printStackTrace();
    }
    AnnotationInformation annotation=new AnnotationInformation(0,annotation_names.get(i),values,true);
    annotations.add(annotation);
  }
  ArrayList<String> vals=new ArrayList<String>();
  vals.add(""String_Node_Str"");
  AnnotationInformation expId=new AnnotationInformation(0,""String_Node_Str"",vals,false);
  annotations.add(expId);
  Collections.sort(annotations,new compareAnnotations());
  for (int i=0; i < annotations.size(); i++) {
    annotations.get(i).setId(i);
  }
  return new GetAnnotationInformationResponse(200,annotations);
}",0.9680821537607548
38217,"private void exchange(HttpExchange exchange,CommandType type){
  InputStream bodyStream=exchange.getRequestBody();
  Scanner scanner=new Scanner(bodyStream);
  String body=""String_Node_Str"";
  String uuid=null;
  String username=null;
  System.out.println(""String_Node_Str"" + type);
  if (type != CommandType.LOGIN_COMMAND) {
    try {
      uuid=exchange.getRequestHeaders().get(""String_Node_Str"").get(0);
    }
 catch (    NullPointerException e) {
      System.out.println(""String_Node_Str"");
      Response errorResponse=new MinimalResponse(StatusCode.UNAUTHORIZED);
      try {
        respond(exchange,errorResponse);
      }
 catch (      IOException e1) {
        e1.printStackTrace();
      }
      scanner.close();
      return;
    }
  }
 else {
    System.out.println(""String_Node_Str"");
  }
  while (scanner.hasNext()) {
    body=body.concat(scanner.next());
  }
  scanner.close();
  Response response=null;
  try {
    username=Authenticate.getUsername(uuid);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  System.out.println(""String_Node_Str"" + body);
  System.out.println(""String_Node_Str"");
  try {
    response=commandHandler.processNewCommand(body,exchange.getRequestURI().toString(),username,type);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  System.out.println(""String_Node_Str"");
  try {
    respond(exchange,response);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","private void exchange(HttpExchange exchange,CommandType type){
  InputStream bodyStream=exchange.getRequestBody();
  Scanner scanner=new Scanner(bodyStream);
  String body=""String_Node_Str"";
  String uuid=null;
  String username=null;
  System.out.println(""String_Node_Str"" + type);
  if (type != CommandType.LOGIN_COMMAND) {
    try {
      uuid=exchange.getRequestHeaders().get(""String_Node_Str"").get(0);
    }
 catch (    NullPointerException e) {
      System.out.println(""String_Node_Str"");
      Response errorResponse=new MinimalResponse(StatusCode.UNAUTHORIZED);
      try {
        respond(exchange,errorResponse);
      }
 catch (      IOException e1) {
        e1.printStackTrace();
      }
      scanner.close();
      return;
    }
  }
 else {
    System.out.println(""String_Node_Str"");
  }
  while (scanner.hasNext()) {
    body=body.concat(""String_Node_Str"" + scanner.next());
  }
  scanner.close();
  Response response=null;
  try {
    username=Authenticate.getUsername(uuid);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  System.out.println(""String_Node_Str"" + body);
  System.out.println(""String_Node_Str"");
  try {
    response=commandHandler.processNewCommand(body,exchange.getRequestURI().toString(),username,type);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  System.out.println(""String_Node_Str"");
  try {
    respond(exchange,response);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.9930651872399444
38218,"/** 
 * Method used to validate all attributes.
 */
@Override public boolean validate(){
  if (name == null || type == null || defaults == null || forced == null) {
    return false;
  }
  if (name.length() > 10 || type.length < 1) {
    return false;
  }
  return true;
}","/** 
 * Method used to validate all attributes.
 */
@Override public boolean validate(){
  if (name == null || type == null || defaults == null || forced == null) {
    return false;
  }
  if (name.length() > 10 || type.size() < 1) {
    return false;
  }
  return true;
}",0.9779411764705882
38219,"/** 
 * Runs the actual code needed to search the database.
 */
@Override public Response execute(){
  DatabaseAccessor db=null;
  List<Experiment> searchResult=null;
  try {
    db=new DatabaseAccessor(DatabaseSettings.database,DatabaseSettings.password,DatabaseSettings.host,DatabaseSettings.database);
    searchResult=db.search(annotations);
  }
 catch (  SQLException e) {
    return new MinimalResponse(StatusCode.SERVICE_UNAVAILABLE);
  }
catch (  IOException e) {
    return new MinimalResponse(StatusCode.BAD_REQUEST);
  }
  SearchResponse response=new SearchResponse(searchResult);
  return response;
}","/** 
 * Runs the actual code needed to search the database.
 */
@Override public Response execute(){
  DatabaseAccessor db=null;
  List<Experiment> searchResult=null;
  try {
    db=new DatabaseAccessor(DatabaseSettings.username,DatabaseSettings.password,DatabaseSettings.host,DatabaseSettings.database);
    searchResult=db.search(annotations);
  }
 catch (  SQLException e) {
    return new MinimalResponse(StatusCode.SERVICE_UNAVAILABLE);
  }
catch (  IOException e) {
    return new MinimalResponse(StatusCode.BAD_REQUEST);
  }
  SearchResponse response=new SearchResponse(searchResult);
  return response;
}",0.988562091503268
38220,"@Override public Response execute(){
  ArrayList<AnnotationInformation> annotations=new ArrayList<AnnotationInformation>();
  DatabaseAccessor accessor=null;
  Map<String,Integer> a=null;
  try {
    accessor=new DatabaseAccessor(DatabaseSettings.mc333_username,DatabaseSettings.mc333_password,DatabaseSettings.mc333_host,DatabaseSettings.mc333_database);
    a=accessor.getAnnotations();
    System.out.println(""String_Node_Str"");
  }
 catch (  SQLException e) {
    e.printStackTrace();
    System.exit(1);
  }
  Iterator<String> keys=a.keySet().iterator();
  ArrayList<String> annotation_names=new ArrayList<String>();
  while (keys.hasNext()) {
    annotation_names.add(keys.next());
  }
  for (int i=0; i < annotation_names.size(); i++) {
    ArrayList<String> values=null;
    try {
      if (accessor.getAnnotationType(annotation_names.get(i)).equals(""String_Node_Str"")) {
        values=new ArrayList<String>();
        values.add(""String_Node_Str"");
      }
 else       if (accessor.getAnnotationType(annotation_names.get(i)).equals(""String_Node_Str"")) {
        values=(ArrayList<String>)accessor.getChoices(annotation_names.get(i));
      }
    }
 catch (    SQLException e1) {
      e1.printStackTrace();
    }
    AnnotationInformation annotation=new AnnotationInformation(0,annotation_names.get(i),values,true);
    annotations.add(annotation);
  }
  Collections.sort(annotations,new compareAnnotations());
  for (int i=0; i < annotations.size(); i++) {
    annotations.get(i).setId(i);
  }
  for (int i=0; i < annotations.size(); i++) {
    System.out.println(""String_Node_Str"" + annotations.get(i));
  }
  return new GetAnnotationInformationResponse(200,annotations);
}","@Override public Response execute(){
  ArrayList<AnnotationInformation> annotations=new ArrayList<AnnotationInformation>();
  DatabaseAccessor accessor=null;
  Map<String,Integer> a=null;
  try {
    accessor=new DatabaseAccessor(DatabaseSettings.mc333_username,DatabaseSettings.mc333_password,DatabaseSettings.mc333_host,DatabaseSettings.mc333_database);
    a=accessor.getAnnotations();
    System.out.println(""String_Node_Str"");
  }
 catch (  SQLException e) {
    e.printStackTrace();
    System.exit(1);
  }
  Iterator<String> keys=a.keySet().iterator();
  ArrayList<String> annotation_names=new ArrayList<String>();
  while (keys.hasNext()) {
    annotation_names.add(keys.next());
  }
  for (int i=0; i < annotation_names.size(); i++) {
    ArrayList<String> values=null;
    try {
      if (accessor.getAnnotationType(annotation_names.get(i)) == DatabaseAccessor.FREETEXT) {
        values=new ArrayList<String>();
        values.add(""String_Node_Str"");
      }
 else       if (accessor.getAnnotationType(annotation_names.get(i)) == DatabaseAccessor.DROPDOWN) {
        values=(ArrayList<String>)accessor.getChoices(annotation_names.get(i));
      }
 else {
      }
    }
 catch (    SQLException e1) {
      e1.printStackTrace();
    }
    AnnotationInformation annotation=new AnnotationInformation(0,annotation_names.get(i),values,true);
    annotations.add(annotation);
  }
  Collections.sort(annotations,new compareAnnotations());
  for (int i=0; i < annotations.size(); i++) {
    annotations.get(i).setId(i);
  }
  for (int i=0; i < annotations.size(); i++) {
    System.out.println(""String_Node_Str"" + annotations.get(i));
  }
  return new GetAnnotationInformationResponse(200,annotations);
}",0.9634433962264152
38221,"public String toString(){
  String returnstring=""String_Node_Str"" + id + ""String_Node_Str""+ name+ ""String_Node_Str""+ forced+ ""String_Node_Str"";
  for (int i=0; i < values.size(); i++) {
    returnstring=returnstring + ""String_Node_Str"" + values.get(i)+ ""String_Node_Str"";
  }
  return returnstring;
}","public String toString(){
  String returnstring=""String_Node_Str"" + id + ""String_Node_Str""+ name+ ""String_Node_Str""+ forced+ ""String_Node_Str"";
  if (values != null) {
    for (int i=0; i < values.size(); i++) {
      returnstring=returnstring + ""String_Node_Str"" + values.get(i)+ ""String_Node_Str"";
    }
  }
  return returnstring;
}",0.8801261829652997
38222,"static public String getID(String username){
  Iterator<String> keys=activeUsersID.keySet().iterator();
  String key;
  while (keys.hasNext()) {
    key=activeUsersID.get(keys.next());
    if (key.equals(username)) {
      return key;
    }
  }
  return null;
}","static public String getID(String username){
  Iterator<String> keys=activeUsersID.keySet().iterator();
  String key=null;
  String temp_username;
  while (keys.hasNext()) {
    key=keys.next();
    temp_username=activeUsersID.get(key);
    if (temp_username.equals(username)) {
      return key;
    }
  }
  return null;
}",0.8561643835616438
38223,"/** 
 * Used to create the command needed for retrieving experiments.
 * @param json string to initiate class.
 * @param restful tag to put into class.
 * @return the actual command.
 */
public Command createRetrieveExperimentCommand(String json,String restful){
  return new GetExperimentCommand();
}","/** 
 * Used to create the command needed for retrieving experiments.
 * @param json string to initiate class.
 * @param restful tag to put into class.
 * @return the actual command.
 */
public Command createRetrieveExperimentCommand(String json,String restful){
  return null;
}",0.9517241379310344
38224,"/** 
 * Used to create the command needed for converting raw to profile.
 * @param json string to initiate class.
 * @param restful tag to put into class.
 * @param uuid
 * @return the actual command.
 */
public Command createProcessCommand(String json,String[] restful,String uuid){
  ProcessCommand processCommand=gson.fromJson(json,ProcessCommand.class);
  processCommand.setProcessType(restful[2]);
  processCommand.setFileID(restful[3]);
  processCommand.setUserID(uuid);
  return processCommand;
}","/** 
 * Used to create the command needed for converting raw to profile.
 * @param json string to initiate class.
 * @param restful tag to put into class.
 * @param uuid
 * @return the actual command.
 */
public Command createProcessCommand(String json,String restful,String uuid){
  ProcessCommand processCommand=gson.fromJson(json,ProcessCommand.class);
  processCommand.setUserID(uuid);
  return processCommand;
}",0.8422198041349293
38225,"public Doorman(CommandHandler commandHandler,int port) throws IOException {
  this.commandHandler=commandHandler;
  httpServer=HttpServer.create(new InetSocketAddress(port),0);
  httpServer.createContext(""String_Node_Str"",createHandler());
  httpServer.createContext(""String_Node_Str"",createHandler());
  httpServer.createContext(""String_Node_Str"",createHandler());
  httpServer.createContext(""String_Node_Str"",createHandler());
  httpServer.createContext(""String_Node_Str"",createHandler());
  httpServer.createContext(""String_Node_Str"",createHandler());
  httpServer.createContext(""String_Node_Str"",createHandler());
  httpServer.setExecutor(new Executor(){
    @Override public void execute(    Runnable command){
      new Thread(command).start();
    }
  }
);
}","public Doorman(CommandHandler commandHandler,int port) throws IOException {
  this.commandHandler=commandHandler;
  httpServer=HttpServer.create(new InetSocketAddress(port),0);
  httpServer.createContext(""String_Node_Str"",createHandler());
  httpServer.createContext(""String_Node_Str"",createHandler());
  httpServer.createContext(""String_Node_Str"",createHandler());
  httpServer.createContext(""String_Node_Str"",createHandler());
  httpServer.createContext(""String_Node_Str"",createHandler());
  httpServer.createContext(""String_Node_Str"",createHandler());
  httpServer.createContext(""String_Node_Str"",createHandler());
  httpServer.createContext(""String_Node_Str"",createHandler());
  httpServer.setExecutor(new Executor(){
    @Override public void execute(    Runnable command){
      new Thread(command).start();
    }
  }
);
}",0.96045197740113
38226,"/** 
 * Method used to create commands together with CommandFactory.
 * @param cmdt
 * @param json
 * @param restful
 * @return
 */
private Command createCommand(CommandType cmdt,String json,String restful){
  Command newCommand=null;
  if (cmdt == CommandType.LOGIN_COMMAND) {
    newCommand=cmdFactory.createLoginCommand(json,restful);
  }
 else   if (cmdt == CommandType.LOGOUT_COMMAND) {
    newCommand=cmdFactory.createLogoutCommand(restful);
  }
 else   if (cmdt == CommandType.RETRIEVE_EXPERIMENT_COMMAND) {
    newCommand=cmdFactory.createRetrieveExperimentCommand(json,restful);
  }
 else   if (cmdt == CommandType.EXPERIMENT_COMMAND) {
    newCommand=cmdFactory.createExperimentCommand(json,restful);
  }
 else   if (cmdt == CommandType.FILE_COMMAND) {
  }
 else   if (cmdt == CommandType.SEARCH_COMMAND) {
    newCommand=cmdFactory.createSearchCommand(json,restful);
  }
 else   if (cmdt == CommandType.USER_COMMAND) {
    newCommand=cmdFactory.createUserCommand(json,restful);
  }
 else   if (cmdt == CommandType.PROCESS_COMMAND) {
    newCommand=cmdFactory.createProcessCommand(json,restful);
  }
 else   if (cmdt == CommandType.SYSADM_COMMAND) {
    newCommand=cmdFactory.createSysadmCommand(json,restful);
  }
  return newCommand;
}","/** 
 * Method used to create commands together with CommandFactory.
 * @param cmdt
 * @param json
 * @param restful
 * @return
 */
private Command createCommand(CommandType cmdt,String json,String restful){
  Command newCommand=null;
  if (cmdt == CommandType.LOGIN_COMMAND) {
    newCommand=cmdFactory.createLoginCommand(json,restful);
  }
 else   if (cmdt == CommandType.LOGOUT_COMMAND) {
    newCommand=cmdFactory.createLogoutCommand(restful);
  }
 else   if (cmdt == CommandType.RETRIEVE_EXPERIMENT_COMMAND) {
    newCommand=cmdFactory.createRetrieveExperimentCommand(json,restful);
  }
 else   if (cmdt == CommandType.ADD_EXPERIMENT_COMMAND) {
    newCommand=null;
  }
 else   if (cmdt == CommandType.UPDATE_EXPERIMENT_COMMAND) {
    newCommand=null;
  }
 else   if (cmdt == CommandType.REMOVE_EXPERIMENT_COMMAND) {
    newCommand=null;
  }
 else   if (cmdt == CommandType.GET_FILE_FROM_EXPERIMENT_COMMAND) {
    newCommand=null;
  }
 else   if (cmdt == CommandType.ADD_FILE_TO_EXPERIMENT_COMMAND) {
    newCommand=null;
  }
 else   if (cmdt == CommandType.UPDATE_FILE_IN_EXPERIMENT_COMMAND) {
    newCommand=null;
  }
 else   if (cmdt == CommandType.DELETE_FILE_FROM_EXPERIMENT_COMMAND) {
    newCommand=null;
  }
 else   if (cmdt == CommandType.SEARCH_FOR_EXPERIMENT_COMMAND) {
    newCommand=null;
  }
 else   if (cmdt == CommandType.CREATE_USER_COMMAND) {
    newCommand=null;
  }
 else   if (cmdt == CommandType.UPDATE_USER_COMMAND) {
    newCommand=null;
  }
 else   if (cmdt == CommandType.DELETE_USER_COMMAND) {
    newCommand=null;
  }
 else   if (cmdt == CommandType.CONVERT_RAW_TO_PROFILE_COMMAND) {
    newCommand=null;
  }
 else   if (cmdt == CommandType.GET_ANNOTATION_INFORMATION_COMMAND) {
    newCommand=null;
  }
 else   if (cmdt == CommandType.ADD_ANNOTATION_FIELD_COMMAND) {
    newCommand=null;
  }
 else   if (cmdt == CommandType.ADD_ANNOTATION_VALUE_COMMAND) {
    newCommand=null;
  }
 else   if (cmdt == CommandType.REMOVE_ANNOTATION_FIELD_COMMAND) {
    newCommand=null;
  }
 else   if (cmdt == CommandType.GET_ANNOTATION_PRIVILEGES_COMMAND) {
    newCommand=null;
  }
 else   if (cmdt == CommandType.UPDATE_ANNOTATION_PRIVILEGES_COMMAND) {
    newCommand=null;
  }
  return newCommand;
}",0.5399480819152005
38227,"@Test public void testSearchByPubMed(){
  String searchPubMed=""String_Node_Str"";
  SearchResult queryRes=new SearchResult();
  PreparedStatement pStatement;
  String query=""String_Node_Str"" + ""String_Node_Str"";
  PubMedParser theParser=new PubMedParser();
  ParsedPubMed queryMaterial=theParser.parsePubMed(searchPubMed);
  query=query + queryMaterial.getWhereString() + ""String_Node_Str"";
  System.out.println(""String_Node_Str"" + query + ""String_Node_Str"");
  try {
    pStatement=dbCon.prepareStatement(query);
    for (int i=1; i <= queryMaterial.getValues().size(); i++) {
      pStatement.setString(i,queryMaterial.getValues().get(i - 1));
    }
    ResultSet res=pStatement.executeQuery();
    queryRes.setResultData(res);
    ArrayList<String> result=queryRes.getRowValues(0);
    ArrayList<String> resultHeader=queryRes.getColHeaders();
    for (int i=0; i < resultHeader.size(); i++) {
      System.out.print(resultHeader.get(i) + ""String_Node_Str"");
    }
    System.out.println(""String_Node_Str"");
    for (int i=0; i < result.size(); i++) {
      System.out.print(result.get(i) + ""String_Node_Str"");
    }
  }
 catch (  SQLException e) {
    System.out.println(""String_Node_Str"");
  }
}","@Test public void testSearchByPubMed(){
  String searchPubMed=""String_Node_Str"";
  SearchResult queryRes=new SearchResult();
  PreparedStatement pStatement;
  String query=""String_Node_Str"" + ""String_Node_Str"";
  PubMedParser theParser=new PubMedParser();
  ParsedPubMed queryMaterial=theParser.parsePubMed(searchPubMed);
  query=query + queryMaterial.getWhereString() + ""String_Node_Str"";
  System.out.println(""String_Node_Str"" + query + ""String_Node_Str"");
  try {
    pStatement=dbCon.prepareStatement(query);
    for (int i=1; i <= queryMaterial.getValues().size(); i++) {
      pStatement.setString(i,queryMaterial.getValues().get(i - 1));
    }
    ResultSet res=pStatement.executeQuery();
    queryRes.setResultData(res);
    ArrayList<String> result=queryRes.getRowValues(0);
    ArrayList<String> resultHeader=queryRes.getColHeaders();
    for (int i=0; i < resultHeader.size(); i++) {
      System.out.print(resultHeader.get(i) + ""String_Node_Str"");
    }
    System.out.println(""String_Node_Str"");
    if (result != null) {
      for (int i=0; i < result.size(); i++) {
        System.out.print(result.get(i) + ""String_Node_Str"");
      }
    }
  }
 catch (  SQLException e) {
    System.out.println(""String_Node_Str"");
  }
}",0.9843878389482332
38228,"/** 
 * Returns the values of a row. Parameters: row number
 * @param int rowNr
 * @return ArrayList<String>
 */
public ArrayList<String> getRowValues(int rowNr){
  ArrayList<String> valuesList=new ArrayList<String>();
  HashMap<String,String> rowData=resultList.get(rowNr);
  for (int i=0; i < nameList.size(); i++) {
    valuesList.add(rowData.get(nameList.get(i)));
  }
  return valuesList;
}","/** 
 * Returns the values of a row. Parameters: row number
 * @param int rowNr
 * @return ArrayList<String> or null if failed.
 */
public ArrayList<String> getRowValues(int rowNr){
  ArrayList<String> valuesList=new ArrayList<String>();
  if (rowCount > 0) {
    HashMap<String,String> rowData=resultList.get(rowNr);
    for (int i=0; i < nameList.size(); i++) {
      valuesList.add(rowData.get(nameList.get(i)));
    }
    return valuesList;
  }
  return null;
}",0.9186046511627908
38229,"public static void main(String args[]){
  System.out.println(""String_Node_Str"");
  final GsonBuilder builder=new GsonBuilder();
  builder.excludeFieldsWithoutExposeAnnotation();
  final Gson gson=builder.create();
  CommandHandler cmdh=new CommandHandler();
  CommandType cmdt=CommandType.LOGIN_COMMAND;
  String json=""String_Node_Str"";
  String restful=""String_Node_Str"";
  Response rsp=cmdh.doStuff(json,restful,cmdt);
  if (rsp == null) {
    System.out.println(""String_Node_Str"");
  }
 else {
    System.out.println(""String_Node_Str"");
  }
}","public static void main(String args[]){
  System.out.println(""String_Node_Str"");
  final GsonBuilder builder=new GsonBuilder();
  builder.excludeFieldsWithoutExposeAnnotation();
  final Gson gson=builder.create();
  CommandHandler cmdh=new CommandHandler();
  CommandType cmdt=CommandType.LOGIN_COMMAND;
  String json=""String_Node_Str"";
  String restful=""String_Node_Str"";
  String uuid=""String_Node_Str"";
  Response rsp=cmdh.doStuff(json,restful,uuid,cmdt);
  if (rsp == null) {
    System.out.println(""String_Node_Str"");
  }
 else {
    System.out.println(""String_Node_Str"");
  }
}",0.9663120567375888
38230,"public void loadPaintingGui(){
  try {
    ResourceLocation loc=new ResourceLocation(""String_Node_Str"" + ConfigurationHandler.instance.texture + ""String_Node_Str"");
    InputStream in=Minecraft.getMinecraft().getResourceManager().getResource(loc).getInputStream();
    BufferedReader reader=new BufferedReader(new InputStreamReader(in));
    Gson gson=new Gson();
    JsonElement je=gson.fromJson(reader,JsonElement.class);
    JsonObject json=je.getAsJsonObject();
    PaintingsPatternLoader loader=gson.fromJson(json,PaintingsPatternLoader.class);
    loader.loadPatterns();
  }
 catch (  IOException e) {
    FMLLog.log.warn(e.getLocalizedMessage());
  }
  try {
    Class altClass=Class.forName(CLASS_LOC);
    paintingGuiTextureHelper(altClass,""String_Node_Str"",new ResourceLocation(""String_Node_Str"" + ConfigurationHandler.instance.texture + ""String_Node_Str""));
    paintingGuiHelper(altClass,""String_Node_Str"",(int)RenderPaintingLate.getSize());
    paintingGuiHelper(altClass,""String_Node_Str"",(int)RenderPaintingLate.getSize());
  }
 catch (  Exception e) {
  }
}","public void loadPaintingGui(){
  try {
    ResourceLocation loc=new ResourceLocation(""String_Node_Str"" + ConfigurationHandler.instance.texture + ""String_Node_Str"");
    InputStream in=Minecraft.getMinecraft().getResourceManager().getResource(loc).getInputStream();
    BufferedReader reader=new BufferedReader(new InputStreamReader(in));
    Gson gson=new Gson();
    JsonElement je=gson.fromJson(reader,JsonElement.class);
    JsonObject json=je.getAsJsonObject();
    PaintingsPatternLoader loader=gson.fromJson(json,PaintingsPatternLoader.class);
    PaintingsIgnore.ignoreVanillaPaintings();
    loader.loadPatterns();
  }
 catch (  IOException e) {
    FMLLog.log.warn(e.getLocalizedMessage());
  }
  try {
    Class altClass=Class.forName(CLASS_LOC);
    paintingGuiTextureHelper(altClass,""String_Node_Str"",new ResourceLocation(""String_Node_Str"" + ConfigurationHandler.instance.texture + ""String_Node_Str""));
    paintingGuiHelper(altClass,""String_Node_Str"",(int)RenderPaintingLate.getSize());
    paintingGuiHelper(altClass,""String_Node_Str"",(int)RenderPaintingLate.getSize());
  }
 catch (  Exception e) {
    FMLLog.log.error(e);
  }
}",0.9679747406405051
38231,"public void loadPatterns() throws IllegalFormatException {
  Integer width=this.pattern[0].length();
  Integer height=this.pattern.length;
  try {
    for (int offsetY=0; offsetY < height; offsetY++) {
      for (int offsetX=0; offsetX < width; offsetX++) {
        String symbol=this.pattern[offsetY].substring(offsetX,offsetX + 1);
        if (symbol.equals(""String_Node_Str"")) {
          continue;
        }
        HashMap size=this.key.get(symbol);
        if (size != null) {
          Integer sizeX=this.key.get(symbol).get(""String_Node_Str"");
          Integer sizeY=this.key.get(symbol).get(""String_Node_Str"");
          this.addPatternSection(sizeX,sizeY,offsetX,offsetY);
          this.updatePattern(sizeX,sizeY,offsetX,offsetY);
        }
 else {
          StringBuilder error=new StringBuilder();
          error.append(String.format(""String_Node_Str"",offsetX,offsetY));
          error.append(""String_Node_Str"");
          for (int i=0; i < this.pattern.length; i++) {
            error.append(String.format(""String_Node_Str"",this.pattern[i]));
          }
          error.append(String.format(""String_Node_Str"",this.key.toString()));
          FMLLog.log.error(error);
        }
      }
    }
  }
 catch (  Exception e) {
    FMLLog.log.error(e);
  }
}","public void loadPatterns() throws IllegalFormatException {
  Integer width=this.pattern[0].length();
  Integer height=this.pattern.length;
  try {
    for (int offsetY=0; offsetY < height; offsetY++) {
      for (int offsetX=0; offsetX < width; offsetX++) {
        String symbol=this.pattern[offsetY].substring(offsetX,offsetX + 1);
        if (symbol.equals(""String_Node_Str"")) {
          continue;
        }
        HashMap size=this.key.get(symbol);
        if (size != null) {
          Integer sizeX=this.key.get(symbol).get(""String_Node_Str"");
          Integer sizeY=this.key.get(symbol).get(""String_Node_Str"");
          FMLLog.log.debug(String.format(""String_Node_Str"",sizeX,sizeY,offsetX,offsetY));
          this.addPatternSection(sizeX,sizeY,offsetX,offsetY);
          this.updatePattern(sizeX,sizeY,offsetX,offsetY);
        }
 else {
          StringBuilder error=new StringBuilder();
          error.append(String.format(""String_Node_Str"",offsetX,offsetY));
          error.append(""String_Node_Str"");
          for (int i=0; i < this.pattern.length; i++) {
            error.append(String.format(""String_Node_Str"",this.pattern[i]));
          }
          error.append(String.format(""String_Node_Str"",this.key.toString()));
          FMLLog.log.error(error);
        }
      }
    }
  }
 catch (  Exception e) {
    FMLLog.log.error(e);
  }
}",0.528158295281583
38232,"public static void addPaintings(){
  PaintingIgnore.ignoreVanillaPaintings();
  for (int y=0; y <= 1; y++) {
    for (int x=1; x <= 23; x++) {
      EnumHelper.addArt(""String_Node_Str"" + i,""String_Node_Str"" + (x + (y * 23)),16,16,16 * (x - 1),16 * y);
      i++;
    }
  }
  for (int y=0; y <= 1; y++) {
    for (int x=1; x <= 3; x++) {
      EnumHelper.addArt(""String_Node_Str"" + i,""String_Node_Str"" + (x + (y * 23)),32,16,400 + (32 * x),16 * y);
      i++;
    }
  }
  for (int x=1; x <= 16; x++) {
    EnumHelper.addArt(""String_Node_Str"" + i,""String_Node_Str"" + (x + 6),32,16,32 * (x - 1),32);
    i++;
  }
  for (int y=0; y <= 3; y++) {
    for (int x=1; x <= 16; x++) {
      EnumHelper.addArt(""String_Node_Str"" + i,""String_Node_Str"" + (x + (y * 16)),32,32,32 * (x - 1),48 + (32 * y));
      i++;
    }
  }
  for (int y=0; y <= 1; y++) {
    for (int x=1; x <= 5; x++) {
      EnumHelper.addArt(""String_Node_Str"" + i,""String_Node_Str"" + (x + (y * 5)),16,32,16 * (x - 1),176 + (32 * y));
      i++;
    }
  }
  for (int y=0; y <= 1; y++) {
    for (int x=1; x <= 9; x++) {
      EnumHelper.addArt(""String_Node_Str"" + i,""String_Node_Str"" + (x + (y * 9)),48,32,32 + (48 * x),176 + (32 * y));
      i++;
    }
  }
  for (int x=1; x <= 16; x++) {
    EnumHelper.addArt(""String_Node_Str"" + i,""String_Node_Str"" + (x),32,48,32 * (x - 1),240);
    i++;
  }
  for (int x=1; x <= 6; x++) {
    EnumHelper.addArt(""String_Node_Str"" + i,""String_Node_Str"" + (x),32,64,32 * (x - 1),288);
    i++;
  }
  for (int y=0; y <= 1; y++) {
    for (int x=1; x <= 5; x++) {
      EnumHelper.addArt(""String_Node_Str"" + i,""String_Node_Str"" + (x + (y * 5)),64,32,128 + (64 * x),288 + (32 * y));
      i++;
    }
  }
  for (int x=1; x <= 5; x++) {
    EnumHelper.addArt(""String_Node_Str"" + i,""String_Node_Str"" + (x),16,48,16 * (x - 1),352);
    i++;
  }
  for (int x=1; x <= 9; x++) {
    EnumHelper.addArt(""String_Node_Str"" + i,""String_Node_Str"" + (x),48,48,32 + (48 * x),352);
    i++;
  }
  for (int x=1; x <= 8; x++) {
    EnumHelper.addArt(""String_Node_Str"" + i,""String_Node_Str"" + (x),64,48,64 * (x - 1),400);
    i++;
  }
  for (int x=1; x <= 8; x++) {
    EnumHelper.addArt(""String_Node_Str"" + i,""String_Node_Str"" + (x),64,64,64 * (x - 1),488);
    i++;
  }
}","public static void addPaintings(){
  PaintingIgnore.ignoreVanillaPaintings();
  for (int y=0; y <= 1; y++) {
    for (int x=1; x <= 23; x++) {
      EnumHelper.addArt(""String_Node_Str"" + i,""String_Node_Str"" + (x + (y * 23)),16,16,16 * (x - 1),16 * y);
      i++;
    }
  }
  for (int y=0; y <= 1; y++) {
    for (int x=1; x <= 3; x++) {
      EnumHelper.addArt(""String_Node_Str"" + i,""String_Node_Str"" + (x + (y * 23)),32,16,384 + (32 * x),16 * y);
      i++;
    }
  }
  for (int x=1; x <= 16; x++) {
    EnumHelper.addArt(""String_Node_Str"" + i,""String_Node_Str"" + (x + 6),32,16,32 * (x - 1),32);
    i++;
  }
  for (int y=0; y <= 3; y++) {
    for (int x=1; x <= 16; x++) {
      EnumHelper.addArt(""String_Node_Str"" + i,""String_Node_Str"" + (x + (y * 16)),32,32,32 * (x - 1),48 + (32 * y));
      i++;
    }
  }
  for (int y=0; y <= 1; y++) {
    for (int x=1; x <= 5; x++) {
      EnumHelper.addArt(""String_Node_Str"" + i,""String_Node_Str"" + (x + (y * 5)),16,32,16 * (x - 1),176 + (32 * y));
      i++;
    }
  }
  for (int y=0; y <= 1; y++) {
    for (int x=1; x <= 9; x++) {
      EnumHelper.addArt(""String_Node_Str"" + i,""String_Node_Str"" + (x + (y * 9)),48,32,32 + (48 * x),176 + (32 * y));
      i++;
    }
  }
  for (int x=1; x <= 16; x++) {
    EnumHelper.addArt(""String_Node_Str"" + i,""String_Node_Str"" + (x),32,48,32 * (x - 1),240);
    i++;
  }
  for (int x=1; x <= 6; x++) {
    EnumHelper.addArt(""String_Node_Str"" + i,""String_Node_Str"" + (x),32,64,32 * (x - 1),288);
    i++;
  }
  for (int y=0; y <= 1; y++) {
    for (int x=1; x <= 5; x++) {
      EnumHelper.addArt(""String_Node_Str"" + i,""String_Node_Str"" + (x + (y * 5)),64,32,128 + (64 * x),288 + (32 * y));
      i++;
    }
  }
  for (int x=1; x <= 5; x++) {
    EnumHelper.addArt(""String_Node_Str"" + i,""String_Node_Str"" + (x),16,48,16 * (x - 1),352);
    i++;
  }
  for (int x=1; x <= 9; x++) {
    EnumHelper.addArt(""String_Node_Str"" + i,""String_Node_Str"" + (x),48,48,32 + (48 * x),352);
    i++;
  }
  for (int x=1; x <= 8; x++) {
    EnumHelper.addArt(""String_Node_Str"" + i,""String_Node_Str"" + (x),64,48,64 * (x - 1),400);
    i++;
  }
  for (int x=1; x <= 8; x++) {
    EnumHelper.addArt(""String_Node_Str"" + i,""String_Node_Str"" + (x),64,64,64 * (x - 1),448);
    i++;
  }
}",0.2429781542576906
38233,"@Override public void onComplete(TaskResult rs){
  if (rs.code == TaskResult.CODE_ERROR) {
    Toast.makeText(getApplicationContext(),R.string.error_submit,Toast.LENGTH_LONG).show();
    downloadCaptcha();
  }
 else   if (rs.code == TaskResult.CODE_SUCCESS) {
    NotificationManager notificationManager=(NotificationManager)getApplicationContext().getSystemService(getApplicationContext().NOTIFICATION_SERVICE);
    notificationManager.cancel(Aero.NOTIFICATION_ID);
    Toast.makeText(getApplicationContext(),R.string.success,Toast.LENGTH_LONG).show();
    State.turnOnDataConnection(false,getApplicationContext());
    int restartDelay=Integer.parseInt(sharedPref.getString(""String_Node_Str"",""String_Node_Str""));
    new Handler().postDelayed(new Runnable(){
      public void run(){
        State.turnOnDataConnection(true,getApplicationContext());
      }
    }
,restartDelay);
  }
}","@Override public void onComplete(TaskResult rs){
  if (rs.code == TaskResult.CODE_ERROR) {
    Log.e(TAG,rs.message);
    Toast.makeText(getApplicationContext(),R.string.error_submit,Toast.LENGTH_LONG).show();
    downloadCaptcha();
  }
 else   if (rs.code == TaskResult.CODE_SUCCESS) {
    NotificationManager notificationManager=(NotificationManager)getApplicationContext().getSystemService(getApplicationContext().NOTIFICATION_SERVICE);
    notificationManager.cancel(Aero.NOTIFICATION_ID);
    Toast.makeText(getApplicationContext(),R.string.success,Toast.LENGTH_LONG).show();
    State.turnOnDataConnection(false,getApplicationContext());
    int restartDelay=Integer.parseInt(sharedPref.getString(""String_Node_Str"",""String_Node_Str""));
    new Handler().postDelayed(new Runnable(){
      public void run(){
        State.turnOnDataConnection(true,getApplicationContext());
      }
    }
,restartDelay);
  }
}",0.9850083287062744
38234,"/** 
 * Initiates the fetch operation. 
 */
public String parseInputStream(InputStream stream) throws IOException {
  String str;
  try {
    BufferedReader r=new BufferedReader(new InputStreamReader(stream));
    StringBuilder total=new StringBuilder();
    String line;
    while ((line=r.readLine()) != null) {
      total.append(line);
    }
    str=total.toString();
  }
  finally {
    if (stream != null) {
      stream.close();
    }
  }
  return str;
}","/** 
 * Initiates the fetch operation. 
 */
public String parseInputStream(InputStream stream) throws IOException {
  String str;
  try {
    BufferedReader r=new BufferedReader(new InputStreamReader(stream));
    StringBuilder total=new StringBuilder();
    String line;
    while ((line=r.readLine()) != null) {
      total.append(line);
    }
    str=total.toString();
    Log.e(""String_Node_Str"",str);
  }
  finally {
    if (stream != null) {
      stream.close();
    }
  }
  return str;
}",0.9644351464435148
38235,"@Override public TaskResult parse(InputStream in){
  TaskResult result=new TaskResult();
  String message=""String_Node_Str"";
  try {
    String str=parseInputStream(in);
    Log.e(""String_Node_Str"",str);
    Pattern jsonPattern=Pattern.compile(""String_Node_Str"");
    Matcher jsonMatcher=jsonPattern.matcher(str);
    if (jsonMatcher.find()) {
      JSONObject json=new JSONObject(jsonMatcher.group(1));
      result.setResultData(json);
      result.code=TaskResult.CODE_SUCCESS;
    }
    if (str.indexOf(""String_Node_Str"") != -1) {
      result.message=""String_Node_Str"";
      result.code=TaskResult.CODE_ERROR;
    }
    if (str.indexOf(""String_Node_Str"") != -1) {
      result.code=TaskResult.CODE_SUCCESS;
    }
  }
 catch (  Exception e) {
    result.message=e.getMessage();
    result.code=TaskResult.CODE_ERROR;
  }
  return result;
}","@Override public TaskResult parse(InputStream in){
  TaskResult result=new TaskResult();
  result.code=TaskResult.CODE_ERROR;
  result.message=""String_Node_Str"";
  try {
    String str=parseInputStream(in);
    Pattern jsonPattern=Pattern.compile(""String_Node_Str"");
    Matcher jsonMatcher=jsonPattern.matcher(str);
    if (jsonMatcher.find()) {
      JSONObject json=new JSONObject(jsonMatcher.group(1));
      result.setResultData(json);
      result.code=TaskResult.CODE_SUCCESS;
    }
    if (str.indexOf(""String_Node_Str"") != -1) {
      result.message=""String_Node_Str"";
    }
    if (str.indexOf(""String_Node_Str"") != -1) {
      result.code=TaskResult.CODE_SUCCESS;
    }
  }
 catch (  Exception e) {
    result.message=e.getMessage();
  }
  return result;
}",0.8975791433891993
38236,"@Override public void onEnable(){
  setupPermissions();
  File backupDir=new File(""String_Node_Str"".concat(FILE_SEPARATOR).concat(""String_Node_Str""));
  if (!backupDir.exists())   backupDir.mkdirs();
  backupDir=new File(""String_Node_Str"");
  if (!backupDir.exists())   backupDir.mkdirs();
  backupDir=new File(""String_Node_Str"".concat(FILE_SEPARATOR).concat(""String_Node_Str""));
  if (!backupDir.exists())   backupDir.mkdirs();
  PropertiesSystem pSystem=new PropertiesSystem(this);
  Server server=getServer();
  PluginManager pm=server.getPluginManager();
  run=new PrepareBackupTask(server,pSystem);
  pm.registerEvent(Type.PLAYER_COMMAND_PREPROCESS,new CommandListener(run,pSystem,this),Priority.Normal,this);
  if (pSystem.getBooleanProperty(BOOL_BACKUP_ONLY_PLAYER)) {
    LoginListener ll=new LoginListener(this,pSystem);
    pm.registerEvent(Type.PLAYER_LOGIN,ll,Priority.Normal,this);
    pm.registerEvent(Type.PLAYER_QUIT,ll,Priority.Normal,this);
  }
  int intervall=pSystem.getIntProperty(INT_BACKUP_INTERVALL);
  server.getScheduler().scheduleSyncRepeatingTask(this,run,intervall,intervall);
  System.out.println(this.getDescription().getFullName() + ""String_Node_Str"");
}","@Override public void onEnable(){
  setupPermissions();
  File backupDir=new File(""String_Node_Str"".concat(FILE_SEPARATOR).concat(""String_Node_Str""));
  if (!backupDir.exists())   backupDir.mkdirs();
  backupDir=new File(""String_Node_Str"");
  if (!backupDir.exists())   backupDir.mkdirs();
  backupDir=new File(""String_Node_Str"".concat(FILE_SEPARATOR).concat(""String_Node_Str""));
  if (!backupDir.exists())   backupDir.mkdirs();
  PropertiesSystem pSystem=new PropertiesSystem(this);
  Server server=getServer();
  PluginManager pm=server.getPluginManager();
  run=new PrepareBackupTask(server,pSystem);
  pm.registerEvent(Type.PLAYER_COMMAND_PREPROCESS,new CommandListener(run,pSystem,this),Priority.Normal,this);
  if (pSystem.getBooleanProperty(BOOL_BACKUP_ONLY_PLAYER)) {
    LoginListener ll=new LoginListener(this,pSystem);
    pm.registerEvent(Type.PLAYER_LOGIN,ll,Priority.Normal,this);
    pm.registerEvent(Type.PLAYER_QUIT,ll,Priority.Normal,this);
  }
  int intervall=pSystem.getIntProperty(INT_BACKUP_INTERVALL);
  if (intervall != -1)   server.getScheduler().scheduleSyncRepeatingTask(this,run,intervall,intervall);
 else   System.out.println(""String_Node_Str"");
  System.out.println(this.getDescription().getFullName() + ""String_Node_Str"");
}",0.9713349713349714
38237,"/** 
 * Check whethere there are more backups as allowed to store. When this case is true, it deletes oldest ones
 */
private void deleteOldBackups(){
  try {
    File backupDir=new File(pSystem.getStringProperty(STRING_BACKUP_FOLDER));
    File[] tempArray=backupDir.listFiles();
    final int maxBackups=pSystem.getIntProperty(INT_MAX_BACKUPS);
    if (tempArray.length > maxBackups) {
      System.out.println(""String_Node_Str"");
      ArrayList<File> backups=new ArrayList<File>(tempArray.length);
      backups.addAll(Arrays.asList(tempArray));
      int maxModifiedIndex;
      long maxModified;
      for (int i=0; i < maxBackups; ++i) {
        maxModifiedIndex=0;
        maxModified=backups.get(0).lastModified();
        for (int j=1; j < backups.size(); ++j) {
          File currentFile=backups.get(j);
          if (currentFile.lastModified() > maxModified) {
            maxModified=currentFile.lastModified();
            maxModifiedIndex=j;
          }
        }
        backups.remove(maxModifiedIndex);
      }
      System.out.println(""String_Node_Str"");
      System.out.println(Arrays.toString(backups.toArray()));
      for (      File backupToDelete : backups)       backupToDelete.delete();
    }
  }
 catch (  Exception e) {
    e.printStackTrace(System.out);
  }
}","/** 
 * Check whethere there are more backups as allowed to store. When this case is true, it deletes oldest ones
 */
private void deleteOldBackups(){
  try {
    File backupDir=new File(pSystem.getStringProperty(STRING_BACKUP_FOLDER));
    File[] tempArray=backupDir.listFiles();
    File[] array=new File[tempArray.length - 1];
    for (int i=0, j=0; i < tempArray.length; ++i) {
      File file=tempArray[i];
      if (file.isDirectory() && file.getName().equals(""String_Node_Str""))       continue;
      array[j++]=tempArray[i];
    }
    tempArray=array;
    final int maxBackups=pSystem.getIntProperty(INT_MAX_BACKUPS);
    if (tempArray.length > maxBackups) {
      System.out.println(""String_Node_Str"");
      ArrayList<File> backups=new ArrayList<File>(tempArray.length);
      backups.addAll(Arrays.asList(tempArray));
      int maxModifiedIndex;
      long maxModified;
      for (int i=0; i < maxBackups; ++i) {
        maxModifiedIndex=0;
        maxModified=backups.get(0).lastModified();
        for (int j=1; j < backups.size(); ++j) {
          File currentFile=backups.get(j);
          if (currentFile.lastModified() > maxModified) {
            maxModified=currentFile.lastModified();
            maxModifiedIndex=j;
          }
        }
        backups.remove(maxModifiedIndex);
      }
      System.out.println(""String_Node_Str"");
      System.out.println(Arrays.toString(backups.toArray()));
      for (      File backupToDelete : backups)       backupToDelete.delete();
    }
  }
 catch (  Exception e) {
    e.printStackTrace(System.out);
  }
}",0.9024816497728068
38238,"/** 
 * Backups the complete server. At first messages were sent to the console and to every player, so everyone know, a Backup is running. After this it deactivates all world saves and then saves every player position. Is this done, every world getting zipped and stored.
 */
protected void backup(){
  String startBackupMessage=pSystem.getStringProperty(STRING_START_BACKUP_MESSAGE);
  System.out.println(startBackupMessage);
  server.broadcastMessage(startBackupMessage);
  ConsoleCommandSender ccs=new ConsoleCommandSender(server);
  server.dispatchCommand(ccs,""String_Node_Str"");
  server.dispatchCommand(ccs,""String_Node_Str"");
  server.savePlayers();
  String[] worldNames=pSystem.getStringProperty(STRING_NO_BACKUP_WORLDNAMES).split(""String_Node_Str"");
  if (worldNames.length > 0 && !worldNames[0].isEmpty()) {
    System.out.println(""String_Node_Str"");
    System.out.println(Arrays.toString(worldNames));
  }
  try {
    boolean hasToZIP=pSystem.getBooleanProperty(BOOL_ZIP);
    if (hasToZIP)     System.out.println(""String_Node_Str"");
    outter:     for (    World world : server.getWorlds()) {
      inner:       for (      String worldName : worldNames)       if (worldName.equalsIgnoreCase(world.getName()))       continue outter;
      String backupDir=""String_Node_Str"".concat(FILE_SEPARATOR).concat(world.getName());
      if (!hasToZIP)       backupDir=backupDir.concat(this.getDate());
      world.save();
      FileUtils.copyDirectory(new File(world.getName()),new File(backupDir));
      String targetName=world.getName();
      String targetDir=""String_Node_Str"".concat(FILE_SEPARATOR);
      if (backupName != null) {
        targetName=backupName;
        targetDir=targetDir.concat(""String_Node_Str"").concat(FILE_SEPARATOR);
      }
      if (hasToZIP) {
        FileUtils.zipDirectory(backupDir,targetDir.concat(targetName).concat(getDate()));
        FileUtils.deleteDirectory(new File(backupDir));
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace(System.out);
  }
  server.dispatchCommand(ccs,""String_Node_Str"");
  String completedBackupMessage=pSystem.getStringProperty(STRING_FINISH_BACKUP_MESSAGE);
  server.broadcastMessage(completedBackupMessage);
  System.out.println(completedBackupMessage);
  deleteOldBackups();
  backupName=null;
  isManuelBackup=false;
}","/** 
 * Backups the complete server. At first messages were sent to the console and to every player, so everyone know, a Backup is running. After this it deactivates all world saves and then saves every player position. Is this done, every world getting zipped and stored.
 */
protected void backup(){
  String startBackupMessage=pSystem.getStringProperty(STRING_START_BACKUP_MESSAGE);
  System.out.println(startBackupMessage);
  server.broadcastMessage(startBackupMessage);
  ConsoleCommandSender ccs=new ConsoleCommandSender(server);
  server.dispatchCommand(ccs,""String_Node_Str"");
  server.dispatchCommand(ccs,""String_Node_Str"");
  server.savePlayers();
  String[] worldNames=pSystem.getStringProperty(STRING_NO_BACKUP_WORLDNAMES).split(""String_Node_Str"");
  if (worldNames.length > 0 && !worldNames[0].isEmpty()) {
    System.out.println(""String_Node_Str"");
    System.out.println(Arrays.toString(worldNames));
  }
  try {
    boolean hasToZIP=pSystem.getBooleanProperty(BOOL_ZIP);
    if (!hasToZIP)     System.out.println(""String_Node_Str"");
    outter:     for (    World world : server.getWorlds()) {
      inner:       for (      String worldName : worldNames)       if (worldName.equalsIgnoreCase(world.getName()))       continue outter;
      String backupDir=""String_Node_Str"".concat(FILE_SEPARATOR).concat(world.getName());
      if (!hasToZIP)       backupDir=backupDir.concat(this.getDate());
      world.save();
      FileUtils.copyDirectory(new File(world.getName()),new File(backupDir));
      String targetName=world.getName();
      String targetDir=""String_Node_Str"".concat(FILE_SEPARATOR);
      if (backupName != null) {
        targetName=backupName;
        targetDir=targetDir.concat(""String_Node_Str"").concat(FILE_SEPARATOR);
      }
      if (hasToZIP) {
        FileUtils.zipDirectory(backupDir,targetDir.concat(targetName).concat(getDate()));
        FileUtils.deleteDirectory(new File(backupDir));
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace(System.out);
  }
  server.dispatchCommand(ccs,""String_Node_Str"");
  String completedBackupMessage=pSystem.getStringProperty(STRING_FINISH_BACKUP_MESSAGE);
  server.broadcastMessage(completedBackupMessage);
  System.out.println(completedBackupMessage);
  deleteOldBackups();
  backupName=null;
  isManuelBackup=false;
}",0.9997837837837836
38239,"@Override public void performVerboseAction(){
  super.performVerboseAction();
  if (DEBUG_MEMORY) {
    DEBUG_MEM_COUNTER++;
    if (DEBUG_MEM_COUNTER % DEBUG_MEM_INTERVAL == 0) {
      DEBUG_MEM_COUNTER=0;
      ReferenceCleanser.clearSoftCaches();
      System.err.println(flowGraph.spaceReport());
      System.err.println(""String_Node_Str"");
      HeapTracer.traceHeap(Collections.singleton(this),true);
      System.err.println(""String_Node_Str"");
    }
  }
  if (getFixedPointSystem() instanceof VerboseAction) {
    ((VerboseAction)getFixedPointSystem()).performVerboseAction();
  }
  AbstractStatement s=workList.takeStatement();
  System.err.println(printRHSInstances(s));
  workList.insertStatement(s);
  System.err.println(""String_Node_Str"" + cg.getNumberOfNodes());
}","@Override public void performVerboseAction(){
  super.performVerboseAction();
  if (DEBUG_MEMORY) {
    DEBUG_MEM_COUNTER++;
    if (DEBUG_MEM_COUNTER % DEBUG_MEM_INTERVAL == 0) {
      DEBUG_MEM_COUNTER=0;
      ReferenceCleanser.clearSoftCaches();
      System.err.println(flowGraph.spaceReport());
      System.err.println(""String_Node_Str"");
      HeapTracer.traceHeap(Collections.singleton(this),true);
      System.err.println(""String_Node_Str"");
    }
  }
  if (getFixedPointSystem() instanceof VerboseAction) {
    ((VerboseAction)getFixedPointSystem()).performVerboseAction();
  }
  if (!workList.isEmpty()) {
    AbstractStatement s=workList.takeStatement();
    System.err.println(printRHSInstances(s));
    workList.insertStatement(s);
    System.err.println(""String_Node_Str"" + cg.getNumberOfNodes());
  }
}",0.9743589743589745
38240,"public CAstNode translateDoLoop(CAstNode loopTest,CAstNode loopBody,CAstNode continueNode,CAstNode breakNode,WalkContext<?,?> wc){
  if (replicateForDoLoops) {
    loopBody=Ast.makeNode(CAstNode.BLOCK_STMT,loopBody,continueNode);
    CAstRewriter.Rewrite x=(new CAstCloner(Ast,false)).copy(loopBody,wc.cfg(),wc.pos(),wc.getNodeTypeMap(),null);
    CAstNode otherBody=x.newRoot();
    wc.cfg().addAll(x.newCfg());
    wc.pos().addAll(x.newPos());
    wc.getNodeTypeMap().addAll(x.newTypes());
    return Ast.makeNode(CAstNode.BLOCK_STMT,loopBody,Ast.makeNode(CAstNode.LOOP,loopTest,otherBody),breakNode);
  }
 else {
    CAstNode header=Ast.makeNode(CAstNode.EMPTY);
    CAstNode loopGoto=Ast.makeNode(CAstNode.IFGOTO,loopTest);
    wc.cfg().map(header,header);
    wc.cfg().map(loopGoto,loopGoto);
    wc.cfg().add(loopGoto,header,Boolean.TRUE);
    return Ast.makeNode(CAstNode.BLOCK_STMT,header,Ast.makeNode(CAstNode.BLOCK_STMT,loopBody,continueNode),loopGoto,breakNode);
  }
}","public CAstNode translateDoLoop(CAstNode loopTest,CAstNode loopBody,CAstNode continueNode,CAstNode breakNode,WalkContext<?,?> wc){
  if (replicateForDoLoops) {
    loopBody=Ast.makeNode(CAstNode.BLOCK_STMT,loopBody,continueNode);
    CAstRewriter.Rewrite x=(new CAstCloner(Ast,false)).copy(loopBody,wc.cfg(),wc.pos(),wc.getNodeTypeMap(),null);
    CAstNode otherBody=x.newRoot();
    wc.cfg().addAll(x.newCfg());
    wc.pos().addAll(x.newPos());
    wc.getNodeTypeMap().addAll(x.newTypes());
    return Ast.makeNode(CAstNode.BLOCK_STMT,loopBody,Ast.makeNode(CAstNode.LOOP,loopTest,otherBody),breakNode);
  }
 else {
    CAstNode header=Ast.makeNode(CAstNode.LABEL_STMT,Ast.makeConstant(""String_Node_Str""),Ast.makeNode(CAstNode.EMPTY));
    CAstNode loopGoto=Ast.makeNode(CAstNode.IFGOTO,loopTest);
    wc.cfg().map(header,header);
    wc.cfg().map(loopGoto,loopGoto);
    wc.cfg().add(loopGoto,header,Boolean.TRUE);
    return Ast.makeNode(CAstNode.BLOCK_STMT,header,Ast.makeNode(CAstNode.BLOCK_STMT,loopBody,continueNode),loopGoto,breakNode);
  }
}",0.965483234714004
38241,"/** 
 * Given a calling node and a call site, return the set of parameters based on which this selector may choose  to specialize contexts.   {@inheritDoc}
 */
@Override public IntSet getRelevantParameters(CGNode caller,CallSiteReference site){
  IntSet ret;
  if (this.parent != null) {
    ret=this.parent.getRelevantParameters(caller,site);
  }
 else {
    ret=EmptyIntSet.instance;
  }
  final MethodReference target=site.getDeclaredTarget();
  if (intentStarters.isStarter(target)) {
    final StartInfo info=intentStarters.getInfo(target);
    final int[] relevant=info.getRelevant();
    if (relevant != null) {
      for (int i=0; i < relevant.length; ++i) {
        ret=IntSetUtil.add(ret,relevant[i]);
      }
    }
    logger.debug(""String_Node_Str"",site,ret);
  }
 else   if (site.isSpecial() && target.getDeclaringClass().getName().equals(AndroidTypes.IntentName)) {
    final MethodReference mRef=site.getDeclaredTarget();
    final int numArgs=mRef.getNumberOfParameters();
switch (numArgs) {
case 0:
      return EmptyIntSet.instance;
case 1:
    return IntSetUtil.make(new int[]{0,1});
case 2:
  logger.debug(""String_Node_Str"",site.getDeclaredTarget().getSelector());
return IntSetUtil.make(new int[]{0,1,2});
case 3:
logger.debug(""String_Node_Str"",site.getDeclaredTarget().getSelector());
return IntSetUtil.make(new int[]{0,1,2,3});
case 4:
logger.debug(""String_Node_Str"",site.getDeclaredTarget().getSelector());
return IntSetUtil.make(new int[]{0,1,2,3,4});
default :
logger.debug(""String_Node_Str"",site.getDeclaredTarget().getSelector());
return IntSetUtil.make(new int[]{0,1,2,3,4,5});
}
}
 else if (site.isSpecial() && target.getDeclaringClass().getName().equals(AndroidTypes.IntentSenderName)) {
logger.warn(""String_Node_Str"");
return IntSetUtil.make(new int[]{0,1});
}
 else if (target.getSelector().equals(Selector.make(""String_Node_Str""))) {
logger.debug(""String_Node_Str"");
return IntSetUtil.make(new int[]{0,1});
}
 else if (target.getSelector().equals(Selector.make(""String_Node_Str""))) {
return IntSetUtil.make(new int[]{0,1});
}
 else if (target.getSelector().equals(Selector.make(""String_Node_Str""))) {
return IntSetUtil.make(new int[]{0});
}
 else if (target.getSelector().equals(Selector.make(""String_Node_Str""))) {
return IntSetUtil.make(new int[]{0,2});
}
 else if (target.getSelector().equals(Selector.make(""String_Node_Str""))) {
return IntSetUtil.make(new int[]{0,2});
}
 else if (target.getSelector().equals(Selector.make(""String_Node_Str""))) {
return IntSetUtil.make(new int[]{0,2});
}
return ret;
}","/** 
 * Given a calling node and a call site, return the set of parameters based on which this selector may choose  to specialize contexts.   {@inheritDoc}
 */
@Override public IntSet getRelevantParameters(CGNode caller,CallSiteReference site){
  IntSet ret;
  if (this.parent != null) {
    ret=this.parent.getRelevantParameters(caller,site);
  }
 else {
    ret=EmptyIntSet.instance;
  }
  final MethodReference target=site.getDeclaredTarget();
  if (intentStarters.isStarter(target)) {
    final StartInfo info=intentStarters.getInfo(target);
    final int[] relevant=info.getRelevant();
    if (relevant != null) {
      for (int i=0; i < relevant.length; ++i) {
        ret=IntSetUtil.add(ret,relevant[i]);
      }
    }
    logger.debug(""String_Node_Str"",site,ret);
  }
 else   if (site.isSpecial() && target.getDeclaringClass().getName().equals(AndroidTypes.IntentName)) {
    final MethodReference mRef=site.getDeclaredTarget();
    final int numArgs=mRef.getNumberOfParameters();
switch (numArgs) {
case 0:
      return EmptyIntSet.instance;
case 1:
    return IntSetUtil.make(new int[]{0,1});
case 2:
  logger.debug(""String_Node_Str"",site.getDeclaredTarget().getSelector());
return IntSetUtil.make(new int[]{0,1,2});
case 3:
logger.debug(""String_Node_Str"",site.getDeclaredTarget().getSelector());
return IntSetUtil.make(new int[]{0,1,2,3});
case 4:
logger.debug(""String_Node_Str"",site.getDeclaredTarget().getSelector());
return IntSetUtil.make(new int[]{0,1,2,3,4});
default :
logger.debug(""String_Node_Str"",site.getDeclaredTarget().getSelector());
return IntSetUtil.make(new int[]{0,1,2,3,4,5});
}
}
 else if (site.isSpecial() && target.getDeclaringClass().getName().equals(AndroidTypes.IntentSenderName)) {
logger.warn(""String_Node_Str"",target);
if (target.getNumberOfParameters() == 0) {
return IntSetUtil.make(new int[]{0});
}
 else {
return IntSetUtil.make(new int[]{0,1});
}
}
 else if (target.getSelector().equals(Selector.make(""String_Node_Str""))) {
logger.debug(""String_Node_Str"");
return IntSetUtil.make(new int[]{0,1});
}
 else if (target.getSelector().equals(Selector.make(""String_Node_Str""))) {
return IntSetUtil.make(new int[]{0,1});
}
 else if (target.getSelector().equals(Selector.make(""String_Node_Str""))) {
return IntSetUtil.make(new int[]{0});
}
 else if (target.getSelector().equals(Selector.make(""String_Node_Str""))) {
return IntSetUtil.make(new int[]{0,2});
}
 else if (target.getSelector().equals(Selector.make(""String_Node_Str""))) {
return IntSetUtil.make(new int[]{0,2});
}
 else if (target.getSelector().equals(Selector.make(""String_Node_Str""))) {
return IntSetUtil.make(new int[]{0,2});
}
return ret;
}",0.9799150251062186
38242,"private ClassWriter.Element[] makeMethodAttributes(int m,ClassWriter w,CodeReader oldCode,Compiler.Output output,MethodData md) throws InvalidClassFileException {
  CodeWriter code=makeNewCode(w,output);
  int codeAttrCount=0;
  LineNumberTableWriter lines=null;
  LocalVariableTableWriter locals=null;
  StackMapTableWriter stacks=null;
  if (oldCode != null) {
    lines=makeNewLines(w,oldCode,output);
    if (lines != null) {
      codeAttrCount++;
    }
    locals=makeNewLocals(w,oldCode,output);
    if (locals != null) {
      codeAttrCount++;
    }
    if (oldCode.getClassReader().getMajorVersion() > 50) {
      try {
        List<StackMapFrame> sm=StackMapTableReader.readStackMap(oldCode);
        String[][] varTypes=null;
        int[] newToOld=output.getNewBytecodesToOldBytecodes();
        int[][] vars=LocalVariableTableReader.makeVarMap(oldCode);
        if (vars != null) {
          varTypes=new String[newToOld.length][];
          for (int i=0; i < newToOld.length; i++) {
            int idx=newToOld[i];
            if (idx != -1 && vars[idx] != null) {
              varTypes[i]=new String[vars[idx].length / 2];
              for (int j=1; j < vars[idx].length; j+=2) {
                int type=vars[idx][j];
                varTypes[i][j / 2]=type == 0 ? null : oldCode.getClassReader().getCP().getCPUtf8(type);
              }
            }
          }
        }
        stacks=new StackMapTableWriter(w,md,output,cha,varTypes,sm);
        codeAttrCount++;
      }
 catch (      IOException|FailureException e) {
        e.printStackTrace();
      }
    }
  }
  ClassWriter.Element[] codeAttributes=new ClassWriter.Element[codeAttrCount];
  int codeAttrIndex=0;
  if (lines != null) {
    codeAttributes[codeAttrIndex++]=lines;
  }
  if (locals != null) {
    codeAttributes[codeAttrIndex++]=locals;
  }
  if (stacks != null) {
    codeAttributes[codeAttrIndex++]=stacks;
  }
  code.setAttributes(codeAttributes);
  ClassReader.AttrIterator iter=new ClassReader.AttrIterator();
  cr.initMethodAttributeIterator(m,iter);
  int methodAttrCount=iter.getRemainingAttributesCount();
  if (oldCode == null) {
    methodAttrCount++;
  }
  ClassWriter.Element[] methodAttributes=new ClassWriter.Element[methodAttrCount];
  for (int i=0; iter.isValid(); iter.advance()) {
    if (iter.getName().equals(""String_Node_Str"")) {
      methodAttributes[i]=code;
      code=null;
      if (oldCode == null) {
        throw new Error(""String_Node_Str"");
      }
    }
 else {
      methodAttributes[i]=new ClassWriter.RawElement(cr.getBytes(),iter.getRawOffset(),iter.getRawSize());
    }
    i++;
  }
  if (oldCode == null) {
    if (code == null) {
      throw new Error(""String_Node_Str"");
    }
    methodAttributes[methodAttrCount - 1]=code;
  }
  return methodAttributes;
}","private ClassWriter.Element[] makeMethodAttributes(int m,ClassWriter w,CodeReader oldCode,Compiler.Output output,MethodData md) throws InvalidClassFileException {
  CodeWriter code=makeNewCode(w,output);
  int codeAttrCount=0;
  LineNumberTableWriter lines=null;
  LocalVariableTableWriter locals=null;
  StackMapTableWriter stacks=null;
  if (oldCode != null) {
    lines=makeNewLines(w,oldCode,output);
    if (lines != null) {
      codeAttrCount++;
    }
    locals=makeNewLocals(w,oldCode,output);
    if (locals != null) {
      codeAttrCount++;
    }
    if (oldCode.getClassReader().getMajorVersion() > 50) {
      try {
        List<StackMapFrame> sm=StackMapTableReader.readStackMap(oldCode);
        String[][] varTypes=null;
        int[] newToOld=output.getNewBytecodesToOldBytecodes();
        int[][] vars=LocalVariableTableReader.makeVarMap(oldCode);
        if (vars != null) {
          varTypes=new String[newToOld.length][];
          for (int i=0; i < newToOld.length; i++) {
            int idx=newToOld[i];
            if (idx != -1 && vars[idx] != null) {
              varTypes[i]=new String[vars[idx].length / 2];
              for (int j=1; j < vars[idx].length; j+=2) {
                int type=vars[idx][j];
                varTypes[i][j / 2]=type == 0 ? null : oldCode.getClassReader().getCP().getCPUtf8(type);
              }
            }
          }
        }
        stacks=new StackMapTableWriter(w,md,output,cha,varTypes);
        codeAttrCount++;
      }
 catch (      IOException|FailureException e) {
        e.printStackTrace();
      }
    }
  }
  ClassWriter.Element[] codeAttributes=new ClassWriter.Element[codeAttrCount];
  int codeAttrIndex=0;
  if (lines != null) {
    codeAttributes[codeAttrIndex++]=lines;
  }
  if (locals != null) {
    codeAttributes[codeAttrIndex++]=locals;
  }
  if (stacks != null) {
    codeAttributes[codeAttrIndex++]=stacks;
  }
  code.setAttributes(codeAttributes);
  ClassReader.AttrIterator iter=new ClassReader.AttrIterator();
  cr.initMethodAttributeIterator(m,iter);
  int methodAttrCount=iter.getRemainingAttributesCount();
  if (oldCode == null) {
    methodAttrCount++;
  }
  ClassWriter.Element[] methodAttributes=new ClassWriter.Element[methodAttrCount];
  for (int i=0; iter.isValid(); iter.advance()) {
    if (iter.getName().equals(""String_Node_Str"")) {
      methodAttributes[i]=code;
      code=null;
      if (oldCode == null) {
        throw new Error(""String_Node_Str"");
      }
    }
 else {
      methodAttributes[i]=new ClassWriter.RawElement(cr.getBytes(),iter.getRawOffset(),iter.getRawSize());
    }
    i++;
  }
  if (oldCode == null) {
    if (code == null) {
      throw new Error(""String_Node_Str"");
    }
    methodAttributes[methodAttrCount - 1]=code;
  }
  return methodAttributes;
}",0.9994624619243864
38243,"@Override public SSAAbstractInvokeInstruction addDirectCall(int function,int[] params,CallSiteReference site){
  CallSiteReference newSite=new JSCallSiteReference(statements.size());
  JavaScriptInvoke s=new JavaScriptInvoke(function,nextLocal++,params,nextLocal++,newSite);
  statements.add(s);
  return s;
}","@Override public SSAAbstractInvokeInstruction addDirectCall(int function,int[] params,CallSiteReference site){
  CallSiteReference newSite=new JSCallSiteReference(statements.size());
  JavaScriptInvoke s=new JavaScriptInvoke(statements.size(),function,nextLocal++,params,nextLocal++,newSite);
  statements.add(s);
  return s;
}",0.9716981132075472
38244,"private int passActualPropertyValsAsParams(JSInstructionFactory insts,int nargs,JavaScriptSummary S,int[] paramsToPassToInvoked){
  int curValNum=nargs + 2;
  for (int i=1; i < paramsToPassToInvoked.length; i++) {
    final int constVN=curValNum++;
    S.addConstant(constVN,new ConstantValue(i - 1));
    int propertyReadResult=curValNum++;
    S.addStatement(insts.PropertyRead(S.getNextProgramCounter(),propertyReadResult,4,constVN));
    paramsToPassToInvoked[i]=propertyReadResult;
  }
  return curValNum;
}","private int passActualPropertyValsAsParams(JSInstructionFactory insts,int nargs,JavaScriptSummary S,int[] paramsToPassToInvoked){
  int curValNum=nargs + 2;
  for (int i=1; i < paramsToPassToInvoked.length; i++) {
    final int constVN=curValNum++;
    S.addConstant(constVN,new ConstantValue(i - 1));
    int propertyReadResult=curValNum++;
    S.addStatement(insts.PropertyRead(S.getNumberOfStatements(),propertyReadResult,4,constVN));
    S.getNextProgramCounter();
    paramsToPassToInvoked[i]=propertyReadResult;
  }
  return curValNum;
}",0.9118483412322276
38245,"private IR makeIRForArgList(CGNode node){
  MethodReference ref=node.getMethod().getReference();
  IClass declaringClass=node.getMethod().getDeclaringClass();
  JSInstructionFactory insts=(JSInstructionFactory)declaringClass.getClassLoader().getInstructionFactory();
  int nargs=4;
  JavaScriptSummary S=new JavaScriptSummary(ref,nargs);
  int numParamsToPass=10;
  int[] paramsToPassToInvoked=new int[numParamsToPass + 1];
  paramsToPassToInvoked[0]=3;
  int curValNum=passActualPropertyValsAsParams(insts,nargs,S,paramsToPassToInvoked);
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  int resultVal=curValNum++;
  int excVal=curValNum++;
  S.addStatement(insts.Invoke(S.getNextProgramCounter(),2,resultVal,paramsToPassToInvoked,excVal,cs));
  S.addStatement(insts.ReturnInstruction(S.getNextProgramCounter(),resultVal,false));
  JavaScriptSummarizedFunction t=new JavaScriptSummarizedFunction(ref,S,declaringClass);
  return t.makeIR(node.getContext(),null);
}","private IR makeIRForArgList(CGNode node){
  MethodReference ref=node.getMethod().getReference();
  IClass declaringClass=node.getMethod().getDeclaringClass();
  JSInstructionFactory insts=(JSInstructionFactory)declaringClass.getClassLoader().getInstructionFactory();
  int nargs=4;
  JavaScriptSummary S=new JavaScriptSummary(ref,nargs);
  int numParamsToPass=10;
  int[] paramsToPassToInvoked=new int[numParamsToPass + 1];
  paramsToPassToInvoked[0]=3;
  int curValNum=passActualPropertyValsAsParams(insts,nargs,S,paramsToPassToInvoked);
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  int resultVal=curValNum++;
  int excVal=curValNum++;
  S.addStatement(insts.Invoke(S.getNumberOfStatements(),2,resultVal,paramsToPassToInvoked,excVal,cs));
  S.getNextProgramCounter();
  S.addStatement(insts.ReturnInstruction(S.getNumberOfStatements(),resultVal,false));
  S.getNextProgramCounter();
  JavaScriptSummarizedFunction t=new JavaScriptSummarizedFunction(ref,S,declaringClass);
  return t.makeIR(node.getContext(),null);
}",0.7147058823529412
38246,"private IR makeIRForNoArgList(CGNode node){
  MethodReference ref=node.getMethod().getReference();
  IClass declaringClass=node.getMethod().getDeclaringClass();
  JSInstructionFactory insts=(JSInstructionFactory)declaringClass.getClassLoader().getInstructionFactory();
  int nargs=4;
  JavaScriptSummary S=new JavaScriptSummary(ref,nargs);
  int resultVal=nargs + 2;
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  int[] params=new int[1];
  params[0]=3;
  S.addStatement(insts.Invoke(S.getNextProgramCounter(),2,resultVal,params,resultVal + 1,cs));
  S.addStatement(insts.ReturnInstruction(S.getNextProgramCounter(),resultVal,false));
  JavaScriptSummarizedFunction t=new JavaScriptSummarizedFunction(ref,S,declaringClass);
  return t.makeIR(node.getContext(),null);
}","private IR makeIRForNoArgList(CGNode node){
  MethodReference ref=node.getMethod().getReference();
  IClass declaringClass=node.getMethod().getDeclaringClass();
  JSInstructionFactory insts=(JSInstructionFactory)declaringClass.getClassLoader().getInstructionFactory();
  int nargs=4;
  JavaScriptSummary S=new JavaScriptSummary(ref,nargs);
  int resultVal=nargs + 2;
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  int[] params=new int[1];
  params[0]=3;
  S.addStatement(insts.Invoke(S.getNumberOfStatements(),2,resultVal,params,resultVal + 1,cs));
  S.getNextProgramCounter();
  S.addStatement(insts.ReturnInstruction(S.getNumberOfStatements(),resultVal,false));
  S.getNextProgramCounter();
  JavaScriptSummarizedFunction t=new JavaScriptSummarizedFunction(ref,S,declaringClass);
  return t.makeIR(node.getContext(),null);
}",0.8585247883917775
38247,"@SuppressWarnings(""String_Node_Str"") private int passArbitraryPropertyValAsParams(JSInstructionFactory insts,int nargs,JavaScriptSummary S,int[] paramsToPassToInvoked){
  int curValNum=nargs + 2;
  int eachElementGetResult=curValNum++;
  S.addStatement(insts.EachElementGetInstruction(S.getNextProgramCounter(),eachElementGetResult,4));
  int propertyReadResult=curValNum++;
  S.addStatement(insts.PropertyRead(S.getNextProgramCounter(),propertyReadResult,4,eachElementGetResult));
  for (int i=1; i < paramsToPassToInvoked.length; i++) {
    paramsToPassToInvoked[i]=propertyReadResult;
  }
  return curValNum;
}","@SuppressWarnings(""String_Node_Str"") private int passArbitraryPropertyValAsParams(JSInstructionFactory insts,int nargs,JavaScriptSummary S,int[] paramsToPassToInvoked){
  int curValNum=nargs + 2;
  int eachElementGetResult=curValNum++;
  S.addStatement(insts.EachElementGetInstruction(S.getNumberOfStatements(),eachElementGetResult,4));
  S.getNextProgramCounter();
  int propertyReadResult=curValNum++;
  S.addStatement(insts.PropertyRead(S.getNumberOfStatements(),propertyReadResult,4,eachElementGetResult));
  S.getNextProgramCounter();
  for (int i=1; i < paramsToPassToInvoked.length; i++) {
    paramsToPassToInvoked[i]=propertyReadResult;
  }
  return curValNum;
}",0.9018691588785048
38248,"/** 
 * generate a synthetic method modeling the invocation of Function.call() at the site
 * @param caller
 * @param site
 * @param receiver
 * @return
 */
private IMethod getFunctionCallTarget(CGNode caller,CallSiteReference site,IClass receiver){
  int nargs=getNumberOfArgsPassed(caller,site);
  if (nargs < 2)   return null;
  String key=getKey(nargs,caller,site);
  if (callModels.containsKey(key)) {
    return callModels.get(key);
  }
  JSInstructionFactory insts=(JSInstructionFactory)receiver.getClassLoader().getInstructionFactory();
  MethodReference ref=genSyntheticMethodRef(receiver,nargs,key);
  JavaScriptSummary S=new JavaScriptSummary(ref,nargs);
  if (WARN_ABOUT_IMPRECISE_CALLGRAPH && caller.getMethod().getName().toString().contains(SYNTHETIC_CALL_METHOD_PREFIX))   warnAboutImpreciseCallGraph(caller,site);
  if (DEBUG_SYNTHETIC_CALL_METHODS) {
    IMethod method=caller.getMethod();
    if (method instanceof AstMethod) {
      int line=((AstMethod)method).getLineNumber(caller.getIR().getCallInstructionIndices(site).intIterator().next());
      System.err.println(""String_Node_Str"" + ref.getName() + ""String_Node_Str""+ line+ ""String_Node_Str""+ caller);
    }
 else {
      System.err.println(""String_Node_Str"" + ref.getName() + ""String_Node_Str""+ method.getName());
    }
  }
  int resultVal=nargs + 2;
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  int[] params=new int[nargs - 2];
  for (int i=0; i < params.length; i++) {
    params[i]=i + 3;
  }
  S.addStatement(insts.Invoke(S.getNextProgramCounter(),2,resultVal,params,resultVal + 1,cs));
  S.addStatement(insts.ReturnInstruction(S.getNextProgramCounter(),resultVal,false));
  JavaScriptSummarizedFunction t=new JavaScriptSummarizedFunction(ref,S,receiver);
  callModels.put(key,t);
  return t;
}","/** 
 * generate a synthetic method modeling the invocation of Function.call() at the site
 * @param caller
 * @param site
 * @param receiver
 * @return
 */
private IMethod getFunctionCallTarget(CGNode caller,CallSiteReference site,IClass receiver){
  int nargs=getNumberOfArgsPassed(caller,site);
  if (nargs < 2)   return null;
  String key=getKey(nargs,caller,site);
  if (callModels.containsKey(key)) {
    return callModels.get(key);
  }
  JSInstructionFactory insts=(JSInstructionFactory)receiver.getClassLoader().getInstructionFactory();
  MethodReference ref=genSyntheticMethodRef(receiver,nargs,key);
  JavaScriptSummary S=new JavaScriptSummary(ref,nargs);
  if (WARN_ABOUT_IMPRECISE_CALLGRAPH && caller.getMethod().getName().toString().contains(SYNTHETIC_CALL_METHOD_PREFIX))   warnAboutImpreciseCallGraph(caller,site);
  if (DEBUG_SYNTHETIC_CALL_METHODS) {
    IMethod method=caller.getMethod();
    if (method instanceof AstMethod) {
      int line=((AstMethod)method).getLineNumber(caller.getIR().getCallInstructionIndices(site).intIterator().next());
      System.err.println(""String_Node_Str"" + ref.getName() + ""String_Node_Str""+ line+ ""String_Node_Str""+ caller);
    }
 else {
      System.err.println(""String_Node_Str"" + ref.getName() + ""String_Node_Str""+ method.getName());
    }
  }
  int resultVal=nargs + 2;
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  int[] params=new int[nargs - 2];
  for (int i=0; i < params.length; i++) {
    params[i]=i + 3;
  }
  S.addStatement(insts.Invoke(S.getNumberOfStatements(),2,resultVal,params,resultVal + 1,cs));
  S.getNextProgramCounter();
  S.addStatement(insts.ReturnInstruction(S.getNumberOfStatements(),resultVal,false));
  S.getNextProgramCounter();
  JavaScriptSummarizedFunction t=new JavaScriptSummarizedFunction(ref,S,receiver);
  callModels.put(key,t);
  return t;
}",0.965160587915079
38249,"private IMethod makeUnaryNumberCall(IClass cls){
  JSInstructionFactory insts=(JSInstructionFactory)cls.getClassLoader().getInstructionFactory();
  MethodReference ref=AstMethodReference.fnReference(JavaScriptTypes.Number);
  JavaScriptSummary S=new JavaScriptSummary(ref,2);
  S.addStatement(insts.GetInstruction(S.getNumberOfStatements(),4,2,""String_Node_Str""));
  S.getNextProgramCounter();
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  S.addStatement(insts.Invoke(4,5,new int[]{2},6,cs));
  S.addStatement(insts.ReturnInstruction(S.getNumberOfStatements(),5,false));
  S.getNextProgramCounter();
  return new JavaScriptConstructor(ref,S,cls,cha.lookupClass(JavaScriptTypes.Number));
}","private IMethod makeUnaryNumberCall(IClass cls){
  JSInstructionFactory insts=(JSInstructionFactory)cls.getClassLoader().getInstructionFactory();
  MethodReference ref=AstMethodReference.fnReference(JavaScriptTypes.Number);
  JavaScriptSummary S=new JavaScriptSummary(ref,2);
  S.addStatement(insts.GetInstruction(S.getNumberOfStatements(),4,2,""String_Node_Str""));
  S.getNextProgramCounter();
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  S.addStatement(insts.Invoke(S.getNumberOfStatements(),4,5,new int[]{2},6,cs));
  S.addStatement(insts.ReturnInstruction(S.getNumberOfStatements(),5,false));
  S.getNextProgramCounter();
  return new JavaScriptConstructor(ref,S,cls,cha.lookupClass(JavaScriptTypes.Number));
}",0.98224043715847
38250,"private IMethod makeUnaryStringCall(IClass cls){
  JSInstructionFactory insts=(JSInstructionFactory)cls.getClassLoader().getInstructionFactory();
  MethodReference ref=AstMethodReference.fnReference(JavaScriptTypes.String);
  JavaScriptSummary S=new JavaScriptSummary(ref,2);
  S.addStatement(insts.GetInstruction(S.getNumberOfStatements(),4,2,""String_Node_Str""));
  S.getNextProgramCounter();
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  S.addStatement(insts.Invoke(4,5,new int[]{2},6,cs));
  S.addStatement(insts.ReturnInstruction(S.getNumberOfStatements(),5,false));
  S.getNextProgramCounter();
  return new JavaScriptConstructor(ref,S,cls,cha.lookupClass(JavaScriptTypes.String));
}","private IMethod makeUnaryStringCall(IClass cls){
  JSInstructionFactory insts=(JSInstructionFactory)cls.getClassLoader().getInstructionFactory();
  MethodReference ref=AstMethodReference.fnReference(JavaScriptTypes.String);
  JavaScriptSummary S=new JavaScriptSummary(ref,2);
  S.addStatement(insts.GetInstruction(S.getNumberOfStatements(),4,2,""String_Node_Str""));
  S.getNextProgramCounter();
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  S.addStatement(insts.Invoke(S.getNumberOfStatements(),4,5,new int[]{2},6,cs));
  S.addStatement(insts.ReturnInstruction(S.getNumberOfStatements(),5,false));
  S.getNextProgramCounter();
  return new JavaScriptConstructor(ref,S,cls,cha.lookupClass(JavaScriptTypes.String));
}",0.98224043715847
38251,"private IMethod makeFunctionObjectConstructor(IClass cls,int nargs){
  JSInstructionFactory insts=(JSInstructionFactory)cls.getClassLoader().getInstructionFactory();
  Object key=Pair.make(cls,new Integer(nargs));
  if (constructors.containsKey(key))   return constructors.get(key);
  MethodReference ref=JavaScriptMethods.makeCtorReference(cls.getReference());
  JavaScriptSummary S=new JavaScriptSummary(ref,nargs + 1);
  S.addStatement(insts.GetInstruction(S.getNumberOfStatements(),nargs + 4,1,""String_Node_Str""));
  S.getNextProgramCounter();
  S.addStatement(insts.NewInstruction(S.getNumberOfStatements(),nargs + 5,NewSiteReference.make(S.getNextProgramCounter(),JavaScriptTypes.Object)));
  S.addStatement(insts.SetPrototype(S.getNumberOfStatements(),nargs + 5,nargs + 4));
  S.getNextProgramCounter();
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  int[] args=new int[nargs + 1];
  args[0]=nargs + 5;
  for (int i=0; i < nargs; i++)   args[i + 1]=i + 2;
  S.addStatement(insts.Invoke(1,nargs + 7,args,nargs + 8,cs));
  int pc=S.getNextProgramCounter();
  S.addConstant(nargs + 9,null);
  S.addStatement(insts.ConditionalBranchInstruction(S.getNumberOfStatements(),Operator.EQ,JavaScriptTypes.Root,nargs + 7,nargs + 9,pc + 2));
  S.getNextProgramCounter();
  S.addStatement(insts.ReturnInstruction(S.getNumberOfStatements(),nargs + 7,false));
  S.getNextProgramCounter();
  S.addStatement(insts.ReturnInstruction(S.getNumberOfStatements(),nargs + 5,false));
  S.getNextProgramCounter();
  return record(key,new JavaScriptConstructor(ref,S,cls,cls));
}","private IMethod makeFunctionObjectConstructor(IClass cls,int nargs){
  JSInstructionFactory insts=(JSInstructionFactory)cls.getClassLoader().getInstructionFactory();
  Object key=Pair.make(cls,new Integer(nargs));
  if (constructors.containsKey(key))   return constructors.get(key);
  MethodReference ref=JavaScriptMethods.makeCtorReference(cls.getReference());
  JavaScriptSummary S=new JavaScriptSummary(ref,nargs + 1);
  S.addStatement(insts.GetInstruction(S.getNumberOfStatements(),nargs + 4,1,""String_Node_Str""));
  S.getNextProgramCounter();
  S.addStatement(insts.NewInstruction(S.getNumberOfStatements(),nargs + 5,NewSiteReference.make(S.getNextProgramCounter(),JavaScriptTypes.Object)));
  S.addStatement(insts.SetPrototype(S.getNumberOfStatements(),nargs + 5,nargs + 4));
  S.getNextProgramCounter();
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  int[] args=new int[nargs + 1];
  args[0]=nargs + 5;
  for (int i=0; i < nargs; i++)   args[i + 1]=i + 2;
  S.addStatement(insts.Invoke(S.getNumberOfStatements(),1,nargs + 7,args,nargs + 8,cs));
  int pc=S.getNextProgramCounter();
  S.addConstant(nargs + 9,null);
  S.addStatement(insts.ConditionalBranchInstruction(S.getNumberOfStatements(),Operator.EQ,JavaScriptTypes.Root,nargs + 7,nargs + 9,pc + 2));
  S.getNextProgramCounter();
  S.addStatement(insts.ReturnInstruction(S.getNumberOfStatements(),nargs + 7,false));
  S.getNextProgramCounter();
  S.addStatement(insts.ReturnInstruction(S.getNumberOfStatements(),nargs + 5,false));
  S.getNextProgramCounter();
  return record(key,new JavaScriptConstructor(ref,S,cls,cls));
}",0.9918851435705368
38252,"protected void parseBytecode(){
  logger.debug(""String_Node_Str"" + eMethod.getClass().getSimpleName() + ""String_Node_Str""+ eMethod.method.getMethodString());
  org.jf.dexlib.Code.Instruction[] instrucs=eMethod.codeItem.getInstructions();
  logger.debug(""String_Node_Str"" + eMethod.method.getMethodString() + ""String_Node_Str""+ instrucs.length);
  instructions=new InstructionArray();
  int instLoc=0;
  int instCounter=-1;
  int currentCodeAddress=0;
  for (  org.jf.dexlib.Code.Instruction inst : instrucs) {
    totalInsts++;
    instCounter++;
    instLoc=currentCodeAddress;
    logger.debug(""String_Node_Str"" + instCounter + ""String_Node_Str""+ instLoc+ ""String_Node_Str""+ inst.opcode.name()+ ""String_Node_Str""+ inst.getFormat());
switch (inst.opcode) {
case NOP:
switch (inst.getFormat()) {
case ArrayData:
{
          for (int i=0; i < instructions.size(); i++) {
            if (instructions.getFromId(i) instanceof ArrayFill)             if (instLoc == (((ArrayFill)getInstructionFromIndex(i)).tableAddressOffset + getAddressFromIndex(i))) {
              ((ArrayFill)getInstructionFromIndex(i)).setArrayDataTable((ArrayDataPseudoInstruction)inst);
              break;
            }
          }
          break;
        }
case PackedSwitchData:
      for (int i=0; i < instructions.size(); i++) {
        if (instructions.getFromId(i) instanceof Switch)         if (instLoc == (((Switch)getInstructionFromIndex(i)).tableAddressOffset + getAddressFromIndex(i))) {
          ((Switch)getInstructionFromIndex(i)).setSwitchPad(new PackedSwitchPad(((PackedSwitchDataPseudoInstruction)inst),getAddressFromIndex(i + 1) - getAddressFromIndex(i)));
          break;
        }
      }
    break;
case SparseSwitchData:
{
    for (int i=0; i < instructions.size(); i++) {
      if (instructions.getFromId(i) instanceof Switch)       if (instLoc == (((Switch)getInstructionFromIndex(i)).tableAddressOffset + getAddressFromIndex(i))) {
        ((Switch)getInstructionFromIndex(i)).setSwitchPad(new SparseSwitchPad(((SparseSwitchDataPseudoInstruction)inst),getAddressFromIndex(i + 1) - getAddressFromIndex(i)));
        break;
      }
    }
    break;
  }
case UnresolvedOdexInstruction:
throw new RuntimeException(""String_Node_Str"" + inst.opcode.toString() + inst.getFormat());
default :
break;
}
break;
case MOVE:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_FROM16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction22x)inst).getRegisterA(),((Instruction22x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction32x)inst).getRegisterA(),((Instruction32x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_WIDE:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_WIDE_FROM16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction22x)inst).getRegisterA(),((Instruction22x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_WIDE_16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction32x)inst).getRegisterA(),((Instruction32x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_OBJECT:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_OBJECT_FROM16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction22x)inst).getRegisterA(),((Instruction22x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_OBJECT_16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction32x)inst).getRegisterA(),((Instruction32x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_RESULT:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction11x)inst).getRegisterA(),getReturnReg(),inst.opcode,this));
break;
case MOVE_RESULT_WIDE:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction11x)inst).getRegisterA(),getReturnReg(),inst.opcode,this));
break;
case MOVE_RESULT_OBJECT:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction11x)inst).getRegisterA(),getReturnReg(),inst.opcode,this));
break;
case MOVE_EXCEPTION:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction11x)inst).getRegisterA(),getExceptionReg(),inst.opcode,this));
break;
case RETURN_VOID:
instructions.add(new Return.ReturnVoid(instLoc,inst.opcode,this));
break;
case RETURN:
instructions.add(new Return.ReturnSingle(instLoc,((Instruction11x)inst).getRegisterA(),true,inst.opcode,this));
break;
case RETURN_WIDE:
instructions.add(new Return.ReturnDouble(instLoc,((Instruction11x)inst).getRegisterA(),((Instruction11x)inst).getRegisterA() + 1,inst.opcode,this));
break;
case RETURN_OBJECT:
instructions.add(new Return.ReturnSingle(instLoc,((Instruction11x)inst).getRegisterA(),false,inst.opcode,this));
break;
case CONST_4:
{
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction11n)inst).getLiteral(),((Instruction11n)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction11n)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction11n)inst).getLiteral());
break;
}
case CONST_16:
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction21s)inst).getLiteral(),((Instruction21s)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21s)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21s)inst).getLiteral());
break;
case CONST:
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction31i)inst).getLiteral(),((Instruction31i)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction31i)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction31i)inst).getLiteral());
break;
case CONST_HIGH16:
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction21h)inst).getLiteral(),((Instruction21h)inst).getRegisterA(),inst.opcode,this));
break;
case CONST_WIDE_16:
instructions.add(new Constant.LongConstant(instLoc,((Instruction21s)inst).getLiteral(),((Instruction21s)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21s)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21s)inst).getLiteral());
break;
case CONST_WIDE_32:
instructions.add(new Constant.LongConstant(instLoc,((Instruction31i)inst).getLiteral(),((Instruction31i)inst).getRegisterA(),inst.opcode,this));
break;
case CONST_WIDE:
instructions.add(new Constant.LongConstant(instLoc,((Instruction51l)inst).getLiteral(),((Instruction51l)inst).getRegisterA(),inst.opcode,this));
break;
case CONST_WIDE_HIGH16:
instructions.add(new Constant.LongConstant(instLoc,((Instruction21h)inst).getLiteral(),((Instruction21h)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21h)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21h)inst).getLiteral());
break;
case CONST_STRING:
instructions.add(new Constant.StringConstant(instLoc,((StringIdItem)((Instruction21c)inst).getReferencedItem()).getStringValue(),((Instruction21c)inst).getRegisterA(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((StringIdItem)((Instruction21c)inst).getReferencedItem()).getStringValue());
break;
case CONST_STRING_JUMBO:
instructions.add(new Constant.StringConstant(instLoc,((StringIdItem)((Instruction31c)inst).getReferencedItem()).getStringValue(),((Instruction31c)inst).getRegisterA(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((StringIdItem)((Instruction31c)inst).getReferencedItem()).getStringValue());
break;
case CONST_CLASS:
{
String cname=((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
TypeReference typeRef=TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname);
instructions.add(new Constant.ClassConstant(instLoc,typeRef,((Instruction21c)inst).getRegisterA(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + cname+ ""String_Node_Str""+ this.myClass.getClassLoader().lookupClass(TypeName.findOrCreate(cname)));
break;
}
case MONITOR_ENTER:
instructions.add(new Monitor(instLoc,true,((Instruction11x)inst).getRegisterA(),inst.opcode,this));
break;
case MONITOR_EXIT:
instructions.add(new Monitor(instLoc,false,((Instruction11x)inst).getRegisterA(),inst.opcode,this));
break;
case CHECK_CAST:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new CheckCast(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname),((Instruction21c)inst).getRegisterA(),inst.opcode,this));
break;
}
case INSTANCE_OF:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new InstanceOf(instLoc,((Instruction22c)inst).getRegisterA(),TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname),((Instruction22c)inst).getRegisterB(),inst.opcode,this));
break;
}
case ARRAY_LENGTH:
instructions.add(new ArrayLength(instLoc,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEW_INSTANCE:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
logger.info(""String_Node_Str"" + ((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor());
instructions.add(new New(instLoc,((Instruction21c)inst).getRegisterA(),NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname)),inst.opcode,this));
break;
}
case NEW_ARRAY:
{
int[] params=new int[1];
params[0]=((Instruction22c)inst).getRegisterB();
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new NewArray(instLoc,((Instruction22c)inst).getRegisterA(),NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname)),params,inst.opcode,this));
break;
}
case FILLED_NEW_ARRAY:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] params=new int[1];
params[0]=registerCount;
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction35c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction35c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
NewSiteReference newSiteRef=NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname));
TypeReference myTypeRef=TypeReference.findOrCreate(myClass.getClassLoader().getReference(),newSiteRef.getDeclaredType().getArrayElementType().getName().toString());
instructions.add(new NewArrayFilled(instLoc,getReturnReg(),newSiteRef,myTypeRef,params,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + ((TypeIdItem)((Instruction35c)inst).getReferencedItem()).getTypeDescriptor() + ""String_Node_Str""+ ((Instruction35c)inst).getRegCount());
logger.debug(registerCount + ""String_Node_Str"");
for (int temp_i=0; temp_i < registerCount; temp_i++) logger.debug(""String_Node_Str"" + args[temp_i]);
break;
}
case FILLED_NEW_ARRAY_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] params=new int[1];
params[0]=registerCount;
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction3rc)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction3rc)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
NewSiteReference newSiteRef=NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname));
TypeReference myTypeRef=TypeReference.findOrCreate(myClass.getClassLoader().getReference(),newSiteRef.getDeclaredType().getArrayElementType().getName().toString());
instructions.add(new NewArrayFilled(instLoc,getReturnReg(),newSiteRef,myTypeRef,params,args,inst.opcode,this));
break;
}
case FILL_ARRAY_DATA:
TypeReference arrayElementType=findOutArrayElementType(instrucs,instructions.toArray(new Instruction[0]),instCounter);
instructions.add(new ArrayFill(instLoc,((Instruction31t)inst).getRegisterA(),((Instruction31t)inst).getTargetAddressOffset(),TypeReference.findOrCreate(myClass.getClassLoader().getReference(),arrayElementType.getName().toString()),inst.opcode,this));
break;
case THROW:
instructions.add(new Throw(instLoc,((Instruction11x)inst).getRegisterA(),inst.opcode,this));
break;
case GOTO:
instructions.add(new Goto(instLoc,((Instruction10t)inst).getTargetAddressOffset(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction10t)inst).getTargetAddressOffset());
break;
case GOTO_16:
instructions.add(new Goto(instLoc,((Instruction20t)inst).getTargetAddressOffset(),inst.opcode,this));
break;
case GOTO_32:
instructions.add(new Goto(instLoc,((Instruction30t)inst).getTargetAddressOffset(),inst.opcode,this));
break;
case PACKED_SWITCH:
case SPARSE_SWITCH:
instructions.add(new Switch(instLoc,((Instruction31t)inst).getRegisterA(),((Instruction31t)inst).getTargetAddressOffset(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + inst.getFormat());
break;
case CMPL_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPL_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMPG_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPG_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMPL_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPL_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMPG_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPG_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMP_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPL_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case IF_EQ:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.EQ,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_NE:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.NE,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_LT:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.LT,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_GE:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.GE,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_GT:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.GT,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_LE:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.LE,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_EQZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.EQZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_NEZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.NEZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_LTZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.LTZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_GEZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.GEZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_GTZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.GTZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_LEZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.LEZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case AGET:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_int,inst.opcode,this));
break;
case AGET_WIDE:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_wide,inst.opcode,this));
break;
case AGET_OBJECT:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_object,inst.opcode,this));
break;
case AGET_BOOLEAN:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_boolean,inst.opcode,this));
break;
case AGET_BYTE:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_byte,inst.opcode,this));
break;
case AGET_CHAR:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_char,inst.opcode,this));
break;
case AGET_SHORT:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_short,inst.opcode,this));
break;
case APUT:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_int,inst.opcode,this));
break;
case APUT_WIDE:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_wide,inst.opcode,this));
break;
case APUT_OBJECT:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_object,inst.opcode,this));
break;
case APUT_BOOLEAN:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_boolean,inst.opcode,this));
break;
case APUT_BYTE:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_byte,inst.opcode,this));
break;
case APUT_CHAR:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_char,inst.opcode,this));
break;
case APUT_SHORT:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_short,inst.opcode,this));
break;
case IGET:
case IGET_WIDE:
case IGET_OBJECT:
case IGET_BOOLEAN:
case IGET_BYTE:
case IGET_CHAR:
case IGET_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new GetField.GetInstanceField(instLoc,((Instruction22c)inst).getRegisterA(),((Instruction22c)inst).getRegisterB(),cname,fname,ftname,inst.opcode,this));
break;
}
case IPUT:
case IPUT_WIDE:
case IPUT_OBJECT:
case IPUT_BOOLEAN:
case IPUT_BYTE:
case IPUT_CHAR:
case IPUT_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new PutField.PutInstanceField(instLoc,((Instruction22c)inst).getRegisterA(),((Instruction22c)inst).getRegisterB(),cname,fname,ftname,inst.opcode,this));
break;
}
case SGET:
case SGET_WIDE:
case SGET_OBJECT:
case SGET_BOOLEAN:
case SGET_BYTE:
case SGET_CHAR:
case SGET_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new GetField.GetStaticField(instLoc,((Instruction21c)inst).getRegisterA(),cname,fname,ftname,inst.opcode,this));
break;
}
case SPUT:
case SPUT_WIDE:
case SPUT_OBJECT:
case SPUT_BOOLEAN:
case SPUT_BYTE:
case SPUT_CHAR:
case SPUT_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new PutField.PutStaticField(instLoc,((Instruction21c)inst).getRegisterA(),cname,fname,ftname,inst.opcode,this));
break;
}
case INVOKE_VIRTUAL:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
handleINVOKE_VIRTUAL(instLoc,cname,mname,pname,args,inst.opcode);
break;
}
case INVOKE_SUPER:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeSuper(instLoc,cname,mname,pname,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + cname + ""String_Node_Str""+ mname+ ""String_Node_Str""+ pname);
break;
}
case INVOKE_DIRECT:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeDirect(instLoc,cname,mname,pname,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor() + ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString()+ ""String_Node_Str""+ ((Instruction35c)inst).getRegCount());
break;
}
case INVOKE_STATIC:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeStatic(instLoc,cname,mname,pname,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor() + ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString()+ ""String_Node_Str""+ ((Instruction35c)inst).getRegCount());
break;
}
case INVOKE_INTERFACE:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeInterface(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_VIRTUAL_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeVirtual(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_SUPER_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeSuper(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_DIRECT_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeDirect(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_STATIC_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeStatic(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_INTERFACE_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeInterface(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case NEG_INT:
instructions.add(new UnaryOperation(instLoc,OpID.NEGINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NOT_INT:
instructions.add(new UnaryOperation(instLoc,OpID.NOTINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEG_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.NEGLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NOT_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.NOTLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEG_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.NEGFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEG_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.NEGDOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.INTTODOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case LONG_TO_INT:
instructions.add(new UnaryOperation(instLoc,OpID.LONGTOINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case LONG_TO_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.LONGTOFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case LONG_TO_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.LONGTODOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case FLOAT_TO_INT:
instructions.add(new UnaryOperation(instLoc,OpID.FLOATTOINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case FLOAT_TO_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.FLOATTOLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case FLOAT_TO_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.FLOATTODOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DOUBLE_TO_INT:
instructions.add(new UnaryOperation(instLoc,OpID.DOUBLETOINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DOUBLE_TO_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.DOUBLETOLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DOUBLE_TO_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.DOUBLETOFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_BYTE:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOBYTE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_CHAR:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOCHAR,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_SHORT:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOSHORT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case AND_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case OR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case XOR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHL_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case USHR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case AND_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case OR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case XOR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHL_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case USHR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case AND_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case OR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case XOR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHL_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case USHR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case AND_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case OR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case XOR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHL_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case USHR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.ADD_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case RSUB_INT:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.RSUB_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case MUL_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.MUL_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case DIV_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.DIV_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case REM_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.REM_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case AND_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.AND_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case OR_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.OR_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case XOR_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.XOR_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case ADD_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.ADD_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case RSUB_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.RSUB_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case MUL_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.MUL_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case DIV_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.DIV_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case REM_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.REM_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case AND_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.AND_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case OR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.OR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case XOR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.XOR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case SHL_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.SHL_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case SHR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.SHR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case USHR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.USHR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
default :
throw new RuntimeException(""String_Node_Str"" + inst.opcode.toString());
}
currentCodeAddress+=inst.getSize(currentCodeAddress);
}
logger.debug(""String_Node_Str"" + this.toString() + ""String_Node_Str"");
}","protected void parseBytecode(){
  logger.debug(""String_Node_Str"" + eMethod.getClass().getSimpleName() + ""String_Node_Str""+ eMethod.method.getMethodString());
  org.jf.dexlib.Code.Instruction[] instrucs=eMethod.codeItem.getInstructions();
  logger.debug(""String_Node_Str"" + eMethod.method.getMethodString() + ""String_Node_Str""+ instrucs.length);
  instructions=new InstructionArray();
  int instLoc=0;
  int instCounter=-1;
  int currentCodeAddress=0;
  for (  org.jf.dexlib.Code.Instruction inst : instrucs) {
    totalInsts++;
    instCounter++;
    instLoc=currentCodeAddress;
    logger.debug(""String_Node_Str"" + instCounter + ""String_Node_Str""+ instLoc+ ""String_Node_Str""+ inst.opcode.name()+ ""String_Node_Str""+ inst.getFormat());
switch (inst.opcode) {
case NOP:
switch (inst.getFormat()) {
case ArrayData:
{
          for (int i=0; i < instructions.size(); i++) {
            if (instructions.getFromId(i) instanceof ArrayFill)             if (instLoc == (((ArrayFill)getInstructionFromIndex(i)).tableAddressOffset + getAddressFromIndex(i))) {
              ((ArrayFill)getInstructionFromIndex(i)).setArrayDataTable((ArrayDataPseudoInstruction)inst);
              break;
            }
          }
          break;
        }
case PackedSwitchData:
      for (int i=0; i < instructions.size(); i++) {
        if (instructions.getFromId(i) instanceof Switch)         if (instLoc == (((Switch)getInstructionFromIndex(i)).tableAddressOffset + getAddressFromIndex(i))) {
          ((Switch)getInstructionFromIndex(i)).setSwitchPad(new PackedSwitchPad(((PackedSwitchDataPseudoInstruction)inst),getAddressFromIndex(i + 1) - getAddressFromIndex(i)));
          break;
        }
      }
    break;
case SparseSwitchData:
{
    for (int i=0; i < instructions.size(); i++) {
      if (instructions.getFromId(i) instanceof Switch)       if (instLoc == (((Switch)getInstructionFromIndex(i)).tableAddressOffset + getAddressFromIndex(i))) {
        ((Switch)getInstructionFromIndex(i)).setSwitchPad(new SparseSwitchPad(((SparseSwitchDataPseudoInstruction)inst),getAddressFromIndex(i + 1) - getAddressFromIndex(i)));
        break;
      }
    }
    break;
  }
case UnresolvedOdexInstruction:
throw new RuntimeException(""String_Node_Str"" + inst.opcode.toString() + inst.getFormat());
default :
break;
}
break;
case MOVE:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_FROM16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction22x)inst).getRegisterA(),((Instruction22x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction32x)inst).getRegisterA(),((Instruction32x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_WIDE:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_WIDE_FROM16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction22x)inst).getRegisterA(),((Instruction22x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_WIDE_16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction32x)inst).getRegisterA(),((Instruction32x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_OBJECT:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_OBJECT_FROM16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction22x)inst).getRegisterA(),((Instruction22x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_OBJECT_16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction32x)inst).getRegisterA(),((Instruction32x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_RESULT:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction11x)inst).getRegisterA(),getReturnReg(),inst.opcode,this));
break;
case MOVE_RESULT_WIDE:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction11x)inst).getRegisterA(),getReturnReg(),inst.opcode,this));
break;
case MOVE_RESULT_OBJECT:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction11x)inst).getRegisterA(),getReturnReg(),inst.opcode,this));
break;
case MOVE_EXCEPTION:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction11x)inst).getRegisterA(),getExceptionReg(),inst.opcode,this));
break;
case RETURN_VOID:
instructions.add(new Return.ReturnVoid(instLoc,inst.opcode,this));
break;
case RETURN:
instructions.add(new Return.ReturnSingle(instLoc,((Instruction11x)inst).getRegisterA(),true,inst.opcode,this));
break;
case RETURN_WIDE:
instructions.add(new Return.ReturnDouble(instLoc,((Instruction11x)inst).getRegisterA(),((Instruction11x)inst).getRegisterA() + 1,inst.opcode,this));
break;
case RETURN_OBJECT:
instructions.add(new Return.ReturnSingle(instLoc,((Instruction11x)inst).getRegisterA(),false,inst.opcode,this));
break;
case CONST_4:
{
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction11n)inst).getLiteral(),((Instruction11n)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction11n)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction11n)inst).getLiteral());
break;
}
case CONST_16:
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction21s)inst).getLiteral(),((Instruction21s)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21s)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21s)inst).getLiteral());
break;
case CONST:
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction31i)inst).getLiteral(),((Instruction31i)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction31i)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction31i)inst).getLiteral());
break;
case CONST_HIGH16:
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction21h)inst).getLiteral() << 16,((Instruction21h)inst).getRegisterA(),inst.opcode,this));
break;
case CONST_WIDE_16:
instructions.add(new Constant.LongConstant(instLoc,((Instruction21s)inst).getLiteral(),((Instruction21s)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21s)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21s)inst).getLiteral());
break;
case CONST_WIDE_32:
instructions.add(new Constant.LongConstant(instLoc,((Instruction31i)inst).getLiteral(),((Instruction31i)inst).getRegisterA(),inst.opcode,this));
break;
case CONST_WIDE:
instructions.add(new Constant.LongConstant(instLoc,((Instruction51l)inst).getLiteral(),((Instruction51l)inst).getRegisterA(),inst.opcode,this));
break;
case CONST_WIDE_HIGH16:
instructions.add(new Constant.LongConstant(instLoc,((Instruction21h)inst).getLiteral() << 16,((Instruction21h)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21h)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21h)inst).getLiteral());
break;
case CONST_STRING:
instructions.add(new Constant.StringConstant(instLoc,((StringIdItem)((Instruction21c)inst).getReferencedItem()).getStringValue(),((Instruction21c)inst).getRegisterA(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((StringIdItem)((Instruction21c)inst).getReferencedItem()).getStringValue());
break;
case CONST_STRING_JUMBO:
instructions.add(new Constant.StringConstant(instLoc,((StringIdItem)((Instruction31c)inst).getReferencedItem()).getStringValue(),((Instruction31c)inst).getRegisterA(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((StringIdItem)((Instruction31c)inst).getReferencedItem()).getStringValue());
break;
case CONST_CLASS:
{
String cname=((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
TypeReference typeRef=TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname);
instructions.add(new Constant.ClassConstant(instLoc,typeRef,((Instruction21c)inst).getRegisterA(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + cname+ ""String_Node_Str""+ this.myClass.getClassLoader().lookupClass(TypeName.findOrCreate(cname)));
break;
}
case MONITOR_ENTER:
instructions.add(new Monitor(instLoc,true,((Instruction11x)inst).getRegisterA(),inst.opcode,this));
break;
case MONITOR_EXIT:
instructions.add(new Monitor(instLoc,false,((Instruction11x)inst).getRegisterA(),inst.opcode,this));
break;
case CHECK_CAST:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new CheckCast(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname),((Instruction21c)inst).getRegisterA(),inst.opcode,this));
break;
}
case INSTANCE_OF:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new InstanceOf(instLoc,((Instruction22c)inst).getRegisterA(),TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname),((Instruction22c)inst).getRegisterB(),inst.opcode,this));
break;
}
case ARRAY_LENGTH:
instructions.add(new ArrayLength(instLoc,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEW_INSTANCE:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
logger.info(""String_Node_Str"" + ((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor());
instructions.add(new New(instLoc,((Instruction21c)inst).getRegisterA(),NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname)),inst.opcode,this));
break;
}
case NEW_ARRAY:
{
int[] params=new int[1];
params[0]=((Instruction22c)inst).getRegisterB();
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new NewArray(instLoc,((Instruction22c)inst).getRegisterA(),NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname)),params,inst.opcode,this));
break;
}
case FILLED_NEW_ARRAY:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] params=new int[1];
params[0]=registerCount;
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction35c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction35c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
NewSiteReference newSiteRef=NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname));
TypeReference myTypeRef=TypeReference.findOrCreate(myClass.getClassLoader().getReference(),newSiteRef.getDeclaredType().getArrayElementType().getName().toString());
instructions.add(new NewArrayFilled(instLoc,getReturnReg(),newSiteRef,myTypeRef,params,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + ((TypeIdItem)((Instruction35c)inst).getReferencedItem()).getTypeDescriptor() + ""String_Node_Str""+ ((Instruction35c)inst).getRegCount());
logger.debug(registerCount + ""String_Node_Str"");
for (int temp_i=0; temp_i < registerCount; temp_i++) logger.debug(""String_Node_Str"" + args[temp_i]);
break;
}
case FILLED_NEW_ARRAY_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] params=new int[1];
params[0]=registerCount;
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction3rc)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction3rc)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
NewSiteReference newSiteRef=NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname));
TypeReference myTypeRef=TypeReference.findOrCreate(myClass.getClassLoader().getReference(),newSiteRef.getDeclaredType().getArrayElementType().getName().toString());
instructions.add(new NewArrayFilled(instLoc,getReturnReg(),newSiteRef,myTypeRef,params,args,inst.opcode,this));
break;
}
case FILL_ARRAY_DATA:
TypeReference arrayElementType=findOutArrayElementType(instrucs,instructions.toArray(new Instruction[0]),instCounter);
instructions.add(new ArrayFill(instLoc,((Instruction31t)inst).getRegisterA(),((Instruction31t)inst).getTargetAddressOffset(),TypeReference.findOrCreate(myClass.getClassLoader().getReference(),arrayElementType.getName().toString()),inst.opcode,this));
break;
case THROW:
instructions.add(new Throw(instLoc,((Instruction11x)inst).getRegisterA(),inst.opcode,this));
break;
case GOTO:
instructions.add(new Goto(instLoc,((Instruction10t)inst).getTargetAddressOffset(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction10t)inst).getTargetAddressOffset());
break;
case GOTO_16:
instructions.add(new Goto(instLoc,((Instruction20t)inst).getTargetAddressOffset(),inst.opcode,this));
break;
case GOTO_32:
instructions.add(new Goto(instLoc,((Instruction30t)inst).getTargetAddressOffset(),inst.opcode,this));
break;
case PACKED_SWITCH:
case SPARSE_SWITCH:
instructions.add(new Switch(instLoc,((Instruction31t)inst).getRegisterA(),((Instruction31t)inst).getTargetAddressOffset(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + inst.getFormat());
break;
case CMPL_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPL_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMPG_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPG_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMPL_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPL_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMPG_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPG_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMP_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPL_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case IF_EQ:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.EQ,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_NE:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.NE,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_LT:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.LT,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_GE:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.GE,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_GT:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.GT,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_LE:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.LE,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_EQZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.EQZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_NEZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.NEZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_LTZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.LTZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_GEZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.GEZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_GTZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.GTZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_LEZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.LEZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case AGET:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_int,inst.opcode,this));
break;
case AGET_WIDE:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_wide,inst.opcode,this));
break;
case AGET_OBJECT:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_object,inst.opcode,this));
break;
case AGET_BOOLEAN:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_boolean,inst.opcode,this));
break;
case AGET_BYTE:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_byte,inst.opcode,this));
break;
case AGET_CHAR:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_char,inst.opcode,this));
break;
case AGET_SHORT:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_short,inst.opcode,this));
break;
case APUT:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_int,inst.opcode,this));
break;
case APUT_WIDE:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_wide,inst.opcode,this));
break;
case APUT_OBJECT:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_object,inst.opcode,this));
break;
case APUT_BOOLEAN:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_boolean,inst.opcode,this));
break;
case APUT_BYTE:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_byte,inst.opcode,this));
break;
case APUT_CHAR:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_char,inst.opcode,this));
break;
case APUT_SHORT:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_short,inst.opcode,this));
break;
case IGET:
case IGET_WIDE:
case IGET_OBJECT:
case IGET_BOOLEAN:
case IGET_BYTE:
case IGET_CHAR:
case IGET_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new GetField.GetInstanceField(instLoc,((Instruction22c)inst).getRegisterA(),((Instruction22c)inst).getRegisterB(),cname,fname,ftname,inst.opcode,this));
break;
}
case IPUT:
case IPUT_WIDE:
case IPUT_OBJECT:
case IPUT_BOOLEAN:
case IPUT_BYTE:
case IPUT_CHAR:
case IPUT_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new PutField.PutInstanceField(instLoc,((Instruction22c)inst).getRegisterA(),((Instruction22c)inst).getRegisterB(),cname,fname,ftname,inst.opcode,this));
break;
}
case SGET:
case SGET_WIDE:
case SGET_OBJECT:
case SGET_BOOLEAN:
case SGET_BYTE:
case SGET_CHAR:
case SGET_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new GetField.GetStaticField(instLoc,((Instruction21c)inst).getRegisterA(),cname,fname,ftname,inst.opcode,this));
break;
}
case SPUT:
case SPUT_WIDE:
case SPUT_OBJECT:
case SPUT_BOOLEAN:
case SPUT_BYTE:
case SPUT_CHAR:
case SPUT_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new PutField.PutStaticField(instLoc,((Instruction21c)inst).getRegisterA(),cname,fname,ftname,inst.opcode,this));
break;
}
case INVOKE_VIRTUAL:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
handleINVOKE_VIRTUAL(instLoc,cname,mname,pname,args,inst.opcode);
break;
}
case INVOKE_SUPER:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeSuper(instLoc,cname,mname,pname,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + cname + ""String_Node_Str""+ mname+ ""String_Node_Str""+ pname);
break;
}
case INVOKE_DIRECT:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeDirect(instLoc,cname,mname,pname,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor() + ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString()+ ""String_Node_Str""+ ((Instruction35c)inst).getRegCount());
break;
}
case INVOKE_STATIC:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeStatic(instLoc,cname,mname,pname,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor() + ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString()+ ""String_Node_Str""+ ((Instruction35c)inst).getRegCount());
break;
}
case INVOKE_INTERFACE:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeInterface(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_VIRTUAL_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeVirtual(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_SUPER_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeSuper(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_DIRECT_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeDirect(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_STATIC_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeStatic(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_INTERFACE_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeInterface(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case NEG_INT:
instructions.add(new UnaryOperation(instLoc,OpID.NEGINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NOT_INT:
instructions.add(new UnaryOperation(instLoc,OpID.NOTINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEG_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.NEGLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NOT_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.NOTLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEG_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.NEGFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEG_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.NEGDOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.INTTODOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case LONG_TO_INT:
instructions.add(new UnaryOperation(instLoc,OpID.LONGTOINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case LONG_TO_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.LONGTOFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case LONG_TO_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.LONGTODOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case FLOAT_TO_INT:
instructions.add(new UnaryOperation(instLoc,OpID.FLOATTOINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case FLOAT_TO_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.FLOATTOLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case FLOAT_TO_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.FLOATTODOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DOUBLE_TO_INT:
instructions.add(new UnaryOperation(instLoc,OpID.DOUBLETOINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DOUBLE_TO_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.DOUBLETOLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DOUBLE_TO_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.DOUBLETOFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_BYTE:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOBYTE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_CHAR:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOCHAR,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_SHORT:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOSHORT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case AND_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case OR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case XOR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHL_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case USHR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case AND_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case OR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case XOR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHL_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case USHR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case AND_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case OR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case XOR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHL_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case USHR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case AND_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case OR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case XOR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHL_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case USHR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.ADD_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case RSUB_INT:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.RSUB_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case MUL_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.MUL_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case DIV_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.DIV_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case REM_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.REM_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case AND_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.AND_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case OR_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.OR_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case XOR_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.XOR_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case ADD_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.ADD_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case RSUB_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.RSUB_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case MUL_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.MUL_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case DIV_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.DIV_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case REM_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.REM_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case AND_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.AND_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case OR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.OR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case XOR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.XOR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case SHL_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.SHL_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case SHR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.SHR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case USHR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.USHR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
default :
throw new RuntimeException(""String_Node_Str"" + inst.opcode.toString());
}
currentCodeAddress+=inst.getSize(currentCodeAddress);
}
logger.debug(""String_Node_Str"" + this.toString() + ""String_Node_Str"");
}",0.999909412084428
38253,"/** 
 * Add flows from the special primitive functions to the corresponding global variables.
 * @param flowgraph the flow graph under construction
 */
private void addPrimitives(FlowGraph flowgraph){
  VertexFactory factory=flowgraph.getVertexFactory();
  for (  String pf : primitiveFunctions) {
    TypeReference typeref=TypeReference.findOrCreate(JavaScriptTypes.jsLoader,""String_Node_Str"" + pf);
    IClass klass=cha.lookupClass(typeref);
    flowgraph.addEdge(factory.makeFuncVertex(klass),factory.makePropVertex(pf));
  }
}","/** 
 * Add flows from the special primitive functions to the corresponding global variables.
 * @param flowgraph the flow graph under construction
 */
private void addPrimitives(FlowGraph flowgraph){
  VertexFactory factory=flowgraph.getVertexFactory();
  for (  String pf : primitiveFunctions) {
    TypeReference typeref=TypeReference.findOrCreate(JavaScriptTypes.jsLoader,""String_Node_Str"" + pf);
    IClass klass=cha.lookupClass(typeref);
    String prop=pf.endsWith(""String_Node_Str"") ? pf.substring(0,pf.length() - 6) : pf;
    flowgraph.addEdge(factory.makeFuncVertex(klass),factory.makePropVertex(prop));
  }
}",0.9208006962576152
38254,"@Override public int getLastCol(){
  return e.getSource().getRowColumnVector(e.getEnd()).getColumn();
}","@Override public int getLastCol(){
  return -1;
}",0.618421052631579
38255,"private Position getPosition(final Segment e){
  return new AbstractSourcePosition(){
    @Override public int getFirstLine(){
      return e.getSource().getRowColumnVector(e.getBegin()).getRow();
    }
    @Override public int getLastLine(){
      return e.getSource().getRowColumnVector(e.getEnd()).getRow();
    }
    @Override public int getFirstCol(){
      return e.getSource().getRowColumnVector(e.getBegin()).getColumn();
    }
    @Override public int getLastCol(){
      return e.getSource().getRowColumnVector(e.getEnd()).getColumn();
    }
    @Override public int getFirstOffset(){
      return e.getBegin();
    }
    @Override public int getLastOffset(){
      return e.getEnd();
    }
    @Override public URL getURL(){
      try {
        return new URL(""String_Node_Str"" + sourceFile);
      }
 catch (      MalformedURLException e) {
        return null;
      }
    }
    @Override public InputStream getInputStream() throws IOException {
      return new FileInputStream(sourceFile);
    }
  }
;
}","private Position getPosition(final Segment e){
  return new AbstractSourcePosition(){
    @Override public int getFirstLine(){
      return e.getSource().getRowColumnVector(e.getBegin()).getRow();
    }
    @Override public int getLastLine(){
      return e.getSource().getRowColumnVector(e.getEnd()).getRow();
    }
    @Override public int getFirstCol(){
      return -1;
    }
    @Override public int getLastCol(){
      return -1;
    }
    @Override public int getFirstOffset(){
      return e.getBegin();
    }
    @Override public int getLastOffset(){
      return e.getEnd();
    }
    @Override public URL getURL(){
      try {
        return new URL(""String_Node_Str"" + sourceFile);
      }
 catch (      MalformedURLException e) {
        return null;
      }
    }
    @Override public Reader getReader() throws IOException {
      return new FileReader(sourceFile);
    }
  }
;
}",0.847723704866562
38256,"public Pair<Integer,String> getBodyText(){
  Segment content=innerElement.getContent();
  Integer lineNum=innerElement.getSource().getRow(content.getBegin());
  String body=content.toString();
  return Pair.make(lineNum,body);
}","public Pair<Integer,String> getBodyText(){
  Segment content=innerElement.getContent();
  Integer lineNum=innerElement.getSource().getRow(content.getBegin());
  String body=content.toString().replace(content.getSource().getNewLine(),""String_Node_Str"");
  return Pair.make(lineNum,body);
}",0.8837209302325582
38257,"@Override public int getFirstCol(){
  return e.getSource().getRowColumnVector(e.getBegin()).getColumn();
}","@Override public int getFirstCol(){
  return -1;
}",0.6153846153846154
38258,"public SourceBuffer(Position p) throws IOException {
  this.p=p;
  BufferedReader reader=new BufferedReader(new InputStreamReader(p.getInputStream()));
  String currentLine=null;
  List<String> lines=new ArrayList<String>();
  int offset=0, line=0;
  do {
    currentLine=reader.readLine();
    if (currentLine == null) {
      this.lines=new String[0];
      return;
    }
    offset+=(currentLine.length() + 1);
    line++;
  }
 while (p.getLastOffset() >= 0 ? p.getFirstOffset() > offset : p.getFirstLine() > line);
  if (p.getLastOffset() >= 0) {
    if (p.getFirstOffset() == offset) {
      lines.add(""String_Node_Str"");
    }
 else {
      lines.add(currentLine.substring(p.getFirstOffset() - (offset - currentLine.length() - 1)));
    }
  }
 else {
    lines.add(currentLine.substring(p.getFirstCol()));
  }
  while (p.getLastOffset() >= 0 ? p.getLastOffset() >= offset : p.getLastLine() >= line) {
    currentLine=reader.readLine();
    if (currentLine == null) {
      offset=p.getLastOffset();
      break;
    }
 else {
      offset+=currentLine.length() + 1;
    }
    line++;
    if (p.getLastOffset() >= 0) {
      if (offset > p.getLastOffset()) {
        lines.add(currentLine.substring(0,currentLine.length() - (offset - p.getLastOffset()) + 1));
      }
 else {
        lines.add(currentLine);
      }
    }
 else {
      if (p.getLastLine() == line) {
        lines.add(currentLine.substring(0,p.getLastCol()));
      }
 else {
        lines.add(currentLine);
      }
    }
  }
  this.lines=lines.toArray(new String[lines.size()]);
}","public SourceBuffer(Position p) throws IOException {
  this.p=p;
  BufferedReader reader=new BufferedReader(p.getReader());
  String currentLine=null;
  List<String> lines=new ArrayList<String>();
  int offset=0, line=0;
  do {
    currentLine=reader.readLine();
    if (currentLine == null) {
      this.lines=new String[0];
      return;
    }
    offset+=(currentLine.length() + 1);
    line++;
  }
 while (p.getLastOffset() >= 0 ? p.getFirstOffset() > offset : p.getFirstLine() > line);
  if (p.getLastOffset() >= 0) {
    if (p.getFirstOffset() == offset) {
      lines.add(""String_Node_Str"");
    }
 else {
      int startOffset=p.getFirstOffset() - (offset - currentLine.length() - 1);
      if (offset > p.getLastOffset()) {
        int endOffset=p.getLastOffset() - (offset - currentLine.length() - 1);
        lines.add(currentLine.substring(startOffset,endOffset));
      }
 else {
        lines.add(currentLine.substring(startOffset));
      }
    }
  }
 else {
    lines.add(currentLine.substring(p.getFirstCol()));
  }
  while (p.getLastOffset() >= 0 ? p.getLastOffset() >= offset : p.getLastLine() >= line) {
    currentLine=reader.readLine();
    if (currentLine == null) {
      offset=p.getLastOffset();
      break;
    }
 else {
      offset+=currentLine.length() + 1;
    }
    line++;
    if (p.getLastOffset() >= 0) {
      if (offset > p.getLastOffset()) {
        lines.add(currentLine.substring(0,currentLine.length() - (offset - p.getLastOffset()) + 1));
      }
 else {
        lines.add(currentLine);
      }
    }
 else {
      if (p.getLastLine() == line) {
        lines.add(currentLine.substring(0,p.getLastCol()));
      }
 else {
        lines.add(currentLine);
      }
    }
  }
  this.lines=lines.toArray(new String[lines.size()]);
}",0.8793259103219982
38259,"public void substitute(Position range,String newText){
  int startLine=range.getFirstLine() - p.getFirstLine();
  int endLine=range.getLastLine() - p.getFirstLine();
  if (startLine != endLine) {
    String newLines[]=new String[lines.length - (endLine - startLine)];
    int i=0;
    while (i < startLine) {
      newLines[i]=lines[i];
      i++;
    }
    newLines[i++]=lines[startLine].substring(0,range.getFirstCol()) + lines[endLine].substring(range.getLastCol());
    while (i < newLines.length) {
      newLines[i]=lines[i + (endLine - startLine)];
      i++;
    }
    lines=newLines;
    endLine=startLine;
    final Position hack=range;
    range=new AbstractSourcePosition(){
      @Override public int getFirstLine(){
        return hack.getFirstLine();
      }
      @Override public int getLastLine(){
        return hack.getFirstLine();
      }
      @Override public int getFirstCol(){
        return hack.getFirstCol();
      }
      @Override public int getLastCol(){
        return hack.getFirstCol();
      }
      @Override public int getFirstOffset(){
        return hack.getFirstOffset();
      }
      @Override public int getLastOffset(){
        return hack.getFirstOffset();
      }
      @Override public URL getURL(){
        return hack.getURL();
      }
      @Override public InputStream getInputStream() throws IOException {
        return hack.getInputStream();
      }
    }
;
  }
  String[] newTextLines=newText.split(""String_Node_Str"");
  if (newTextLines.length == 1) {
    lines[startLine]=lines[startLine].substring(0,range.getFirstCol()) + newTextLines[0] + lines[startLine].substring(range.getLastCol() + 1);
  }
 else {
    String[] newLines=new String[lines.length + newTextLines.length - 1];
    int i=0;
    while (i < startLine) {
      newLines[i]=lines[i];
      i++;
    }
    newLines[i++]=lines[startLine].substring(0,range.getFirstCol()) + newTextLines[0];
    for (int j=1; j < newTextLines.length - 1; j++) {
      lines[i++]=newTextLines[j];
    }
    newLines[i++]=newTextLines[newTextLines.length - 1] + lines[endLine].substring(range.getLastCol() + 1);
    while (i < newLines.length) {
      newLines[i]=lines[i - newTextLines.length + 1];
      i++;
    }
    lines=newLines;
  }
}","public void substitute(Position range,String newText){
  int startLine=range.getFirstLine() - p.getFirstLine();
  int endLine=range.getLastLine() - p.getFirstLine();
  if (startLine != endLine) {
    String newLines[]=new String[lines.length - (endLine - startLine)];
    int i=0;
    while (i < startLine) {
      newLines[i]=lines[i];
      i++;
    }
    newLines[i++]=lines[startLine].substring(0,range.getFirstCol()) + lines[endLine].substring(range.getLastCol());
    while (i < newLines.length) {
      newLines[i]=lines[i + (endLine - startLine)];
      i++;
    }
    lines=newLines;
    endLine=startLine;
    final Position hack=range;
    range=new AbstractSourcePosition(){
      @Override public int getFirstLine(){
        return hack.getFirstLine();
      }
      @Override public int getLastLine(){
        return hack.getFirstLine();
      }
      @Override public int getFirstCol(){
        return hack.getFirstCol();
      }
      @Override public int getLastCol(){
        return hack.getFirstCol();
      }
      @Override public int getFirstOffset(){
        return hack.getFirstOffset();
      }
      @Override public int getLastOffset(){
        return hack.getFirstOffset();
      }
      @Override public URL getURL(){
        return hack.getURL();
      }
      @Override public Reader getReader() throws IOException {
        return hack.getReader();
      }
    }
;
  }
  String[] newTextLines=newText.split(""String_Node_Str"");
  if (newTextLines.length == 1) {
    lines[startLine]=lines[startLine].substring(0,range.getFirstCol()) + newTextLines[0] + lines[startLine].substring(range.getLastCol() + 1);
  }
 else {
    String[] newLines=new String[lines.length + newTextLines.length - 1];
    int i=0;
    while (i < startLine) {
      newLines[i]=lines[i];
      i++;
    }
    newLines[i++]=lines[startLine].substring(0,range.getFirstCol()) + newTextLines[0];
    for (int j=1; j < newTextLines.length - 1; j++) {
      lines[i++]=newTextLines[j];
    }
    newLines[i++]=newTextLines[newTextLines.length - 1] + lines[endLine].substring(range.getLastCol() + 1);
    while (i < newLines.length) {
      newLines[i]=lines[i - newTextLines.length + 1];
      i++;
    }
    lines=newLines;
  }
}",0.9867979413739092
38260,"@Override public int getLastCol(){
  return e.getSource().getRowColumnVector(e.getEnd()).getColumn();
}","@Override public int getLastCol(){
  return -1;
}",0.618421052631579
38261,"private Position getPosition(final Segment e){
  return new AbstractSourcePosition(){
    @Override public int getFirstLine(){
      return e.getSource().getRowColumnVector(e.getBegin()).getRow();
    }
    @Override public int getLastLine(){
      return e.getSource().getRowColumnVector(e.getEnd()).getRow();
    }
    @Override public int getFirstCol(){
      return e.getSource().getRowColumnVector(e.getBegin()).getColumn();
    }
    @Override public int getLastCol(){
      return e.getSource().getRowColumnVector(e.getEnd()).getColumn();
    }
    @Override public int getFirstOffset(){
      return e.getBegin();
    }
    @Override public int getLastOffset(){
      return e.getEnd();
    }
    @Override public URL getURL(){
      try {
        return new URL(""String_Node_Str"" + sourceFile);
      }
 catch (      MalformedURLException e) {
        return null;
      }
    }
    @Override public InputStream getInputStream() throws IOException {
      return new FileInputStream(sourceFile);
    }
  }
;
}","private Position getPosition(final Segment e){
  return new AbstractSourcePosition(){
    @Override public int getFirstLine(){
      return e.getSource().getRowColumnVector(e.getBegin()).getRow();
    }
    @Override public int getLastLine(){
      return e.getSource().getRowColumnVector(e.getEnd()).getRow();
    }
    @Override public int getFirstCol(){
      return -1;
    }
    @Override public int getLastCol(){
      return -1;
    }
    @Override public int getFirstOffset(){
      return e.getBegin();
    }
    @Override public int getLastOffset(){
      return e.getEnd();
    }
    @Override public URL getURL(){
      try {
        return new URL(""String_Node_Str"" + sourceFile);
      }
 catch (      MalformedURLException e) {
        return null;
      }
    }
    @Override public Reader getReader() throws IOException {
      return new FileReader(sourceFile);
    }
  }
;
}",0.847723704866562
38262,"public Pair<Integer,String> getBodyText(){
  Segment content=innerElement.getContent();
  Integer lineNum=innerElement.getSource().getRow(content.getBegin());
  String body=content.toString();
  return Pair.make(lineNum,body);
}","public Pair<Integer,String> getBodyText(){
  Segment content=innerElement.getContent();
  Integer lineNum=innerElement.getSource().getRow(content.getBegin());
  String body=content.toString().replace(content.getSource().getNewLine(),""String_Node_Str"");
  return Pair.make(lineNum,body);
}",0.8837209302325582
38263,"@Override public int getFirstCol(){
  return e.getSource().getRowColumnVector(e.getBegin()).getColumn();
}","@Override public int getFirstCol(){
  return -1;
}",0.6153846153846154
38264,"public SourceBuffer(Position p) throws IOException {
  this.p=p;
  BufferedReader reader=new BufferedReader(new InputStreamReader(p.getInputStream()));
  String currentLine=null;
  List<String> lines=new ArrayList<String>();
  int offset=0, line=0;
  do {
    currentLine=reader.readLine();
    if (currentLine == null) {
      this.lines=new String[0];
      return;
    }
    offset+=(currentLine.length() + 1);
    line++;
  }
 while (p.getLastOffset() >= 0 ? p.getFirstOffset() > offset : p.getFirstLine() > line);
  if (p.getLastOffset() >= 0) {
    if (p.getFirstOffset() == offset) {
      lines.add(""String_Node_Str"");
    }
 else {
      lines.add(currentLine.substring(p.getFirstOffset() - (offset - currentLine.length() - 1)));
    }
  }
 else {
    lines.add(currentLine.substring(p.getFirstCol()));
  }
  while (p.getLastOffset() >= 0 ? p.getLastOffset() >= offset : p.getLastLine() >= line) {
    currentLine=reader.readLine();
    if (currentLine == null) {
      offset=p.getLastOffset();
      break;
    }
 else {
      offset+=currentLine.length() + 1;
    }
    line++;
    if (p.getLastOffset() >= 0) {
      if (offset > p.getLastOffset()) {
        lines.add(currentLine.substring(0,currentLine.length() - (offset - p.getLastOffset()) + 1));
      }
 else {
        lines.add(currentLine);
      }
    }
 else {
      if (p.getLastLine() == line) {
        lines.add(currentLine.substring(0,p.getLastCol()));
      }
 else {
        lines.add(currentLine);
      }
    }
  }
  this.lines=lines.toArray(new String[lines.size()]);
}","public SourceBuffer(Position p) throws IOException {
  this.p=p;
  BufferedReader reader=new BufferedReader(p.getReader());
  String currentLine=null;
  List<String> lines=new ArrayList<String>();
  int offset=0, line=0;
  do {
    currentLine=reader.readLine();
    if (currentLine == null) {
      this.lines=new String[0];
      return;
    }
    offset+=(currentLine.length() + 1);
    line++;
  }
 while (p.getLastOffset() >= 0 ? p.getFirstOffset() > offset : p.getFirstLine() > line);
  if (p.getLastOffset() >= 0) {
    if (p.getFirstOffset() == offset) {
      lines.add(""String_Node_Str"");
    }
 else {
      int startOffset=p.getFirstOffset() - (offset - currentLine.length() - 1);
      if (offset > p.getLastOffset()) {
        int endOffset=p.getLastOffset() - (offset - currentLine.length() - 1);
        lines.add(currentLine.substring(startOffset,endOffset));
      }
 else {
        lines.add(currentLine.substring(startOffset));
      }
    }
  }
 else {
    lines.add(currentLine.substring(p.getFirstCol()));
  }
  while (p.getLastOffset() >= 0 ? p.getLastOffset() >= offset : p.getLastLine() >= line) {
    currentLine=reader.readLine();
    if (currentLine == null) {
      offset=p.getLastOffset();
      break;
    }
 else {
      offset+=currentLine.length() + 1;
    }
    line++;
    if (p.getLastOffset() >= 0) {
      if (offset > p.getLastOffset()) {
        lines.add(currentLine.substring(0,currentLine.length() - (offset - p.getLastOffset()) + 1));
      }
 else {
        lines.add(currentLine);
      }
    }
 else {
      if (p.getLastLine() == line) {
        lines.add(currentLine.substring(0,p.getLastCol()));
      }
 else {
        lines.add(currentLine);
      }
    }
  }
  this.lines=lines.toArray(new String[lines.size()]);
}",0.8793259103219982
38265,"public void substitute(Position range,String newText){
  int startLine=range.getFirstLine() - p.getFirstLine();
  int endLine=range.getLastLine() - p.getFirstLine();
  if (startLine != endLine) {
    String newLines[]=new String[lines.length - (endLine - startLine)];
    int i=0;
    while (i < startLine) {
      newLines[i]=lines[i];
      i++;
    }
    newLines[i++]=lines[startLine].substring(0,range.getFirstCol()) + lines[endLine].substring(range.getLastCol());
    while (i < newLines.length) {
      newLines[i]=lines[i + (endLine - startLine)];
      i++;
    }
    lines=newLines;
    endLine=startLine;
    final Position hack=range;
    range=new AbstractSourcePosition(){
      @Override public int getFirstLine(){
        return hack.getFirstLine();
      }
      @Override public int getLastLine(){
        return hack.getFirstLine();
      }
      @Override public int getFirstCol(){
        return hack.getFirstCol();
      }
      @Override public int getLastCol(){
        return hack.getFirstCol();
      }
      @Override public int getFirstOffset(){
        return hack.getFirstOffset();
      }
      @Override public int getLastOffset(){
        return hack.getFirstOffset();
      }
      @Override public URL getURL(){
        return hack.getURL();
      }
      @Override public InputStream getInputStream() throws IOException {
        return hack.getInputStream();
      }
    }
;
  }
  String[] newTextLines=newText.split(""String_Node_Str"");
  if (newTextLines.length == 1) {
    lines[startLine]=lines[startLine].substring(0,range.getFirstCol()) + newTextLines[0] + lines[startLine].substring(range.getLastCol() + 1);
  }
 else {
    String[] newLines=new String[lines.length + newTextLines.length - 1];
    int i=0;
    while (i < startLine) {
      newLines[i]=lines[i];
      i++;
    }
    newLines[i++]=lines[startLine].substring(0,range.getFirstCol()) + newTextLines[0];
    for (int j=1; j < newTextLines.length - 1; j++) {
      lines[i++]=newTextLines[j];
    }
    newLines[i++]=newTextLines[newTextLines.length - 1] + lines[endLine].substring(range.getLastCol() + 1);
    while (i < newLines.length) {
      newLines[i]=lines[i - newTextLines.length + 1];
      i++;
    }
    lines=newLines;
  }
}","public void substitute(Position range,String newText){
  int startLine=range.getFirstLine() - p.getFirstLine();
  int endLine=range.getLastLine() - p.getFirstLine();
  if (startLine != endLine) {
    String newLines[]=new String[lines.length - (endLine - startLine)];
    int i=0;
    while (i < startLine) {
      newLines[i]=lines[i];
      i++;
    }
    newLines[i++]=lines[startLine].substring(0,range.getFirstCol()) + lines[endLine].substring(range.getLastCol());
    while (i < newLines.length) {
      newLines[i]=lines[i + (endLine - startLine)];
      i++;
    }
    lines=newLines;
    endLine=startLine;
    final Position hack=range;
    range=new AbstractSourcePosition(){
      @Override public int getFirstLine(){
        return hack.getFirstLine();
      }
      @Override public int getLastLine(){
        return hack.getFirstLine();
      }
      @Override public int getFirstCol(){
        return hack.getFirstCol();
      }
      @Override public int getLastCol(){
        return hack.getFirstCol();
      }
      @Override public int getFirstOffset(){
        return hack.getFirstOffset();
      }
      @Override public int getLastOffset(){
        return hack.getFirstOffset();
      }
      @Override public URL getURL(){
        return hack.getURL();
      }
      @Override public Reader getReader() throws IOException {
        return hack.getReader();
      }
    }
;
  }
  String[] newTextLines=newText.split(""String_Node_Str"");
  if (newTextLines.length == 1) {
    lines[startLine]=lines[startLine].substring(0,range.getFirstCol()) + newTextLines[0] + lines[startLine].substring(range.getLastCol() + 1);
  }
 else {
    String[] newLines=new String[lines.length + newTextLines.length - 1];
    int i=0;
    while (i < startLine) {
      newLines[i]=lines[i];
      i++;
    }
    newLines[i++]=lines[startLine].substring(0,range.getFirstCol()) + newTextLines[0];
    for (int j=1; j < newTextLines.length - 1; j++) {
      lines[i++]=newTextLines[j];
    }
    newLines[i++]=newTextLines[newTextLines.length - 1] + lines[endLine].substring(range.getLastCol() + 1);
    while (i < newLines.length) {
      newLines[i]=lines[i - newTextLines.length + 1];
      i++;
    }
    lines=newLines;
  }
}",0.9867979413739092
38266,"/** 
 * Add flows from the special primitive functions to the corresponding global variables.
 * @param flowgraph the flow graph under construction
 */
private void addPrimitives(FlowGraph flowgraph){
  VertexFactory factory=flowgraph.getVertexFactory();
  for (  String pf : primitiveFunctions) {
    TypeReference typeref=TypeReference.findOrCreate(JavaScriptTypes.jsLoader,""String_Node_Str"" + pf);
    IClass klass=cha.lookupClass(typeref);
    flowgraph.addEdge(factory.makeFuncVertex(klass),factory.makePropVertex(pf));
  }
}","/** 
 * Add flows from the special primitive functions to the corresponding global variables.
 * @param flowgraph the flow graph under construction
 */
private void addPrimitives(FlowGraph flowgraph){
  VertexFactory factory=flowgraph.getVertexFactory();
  for (  String pf : primitiveFunctions) {
    TypeReference typeref=TypeReference.findOrCreate(JavaScriptTypes.jsLoader,""String_Node_Str"" + pf);
    IClass klass=cha.lookupClass(typeref);
    String prop=pf.endsWith(""String_Node_Str"") ? pf.substring(0,pf.length() - 6) : pf;
    flowgraph.addEdge(factory.makeFuncVertex(klass),factory.makePropVertex(prop));
  }
}",0.9208006962576152
38267,"public final Set<TypeReference> getUnresolvedClasses(){
  return unresolved;
}","@Override public final Set<TypeReference> getUnresolvedClasses(){
  return unresolved;
}",0.9397590361445785
38268,"/** 
 * Find a class in this class hierarchy.
 * @return the {@link IClass} for a if found; null if can't find the class.
 * @throws IllegalArgumentException if A is null
 */
@Override public IClass lookupClass(TypeReference a){
  if (a == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ClassLoaderReference loader=a.getClassLoader();
  ClassLoaderReference parent=loader.getParent();
  if (parent != null) {
    TypeReference p=TypeReference.findOrCreate(parent,a.getName());
    IClass c=lookupClass(p);
    if (c != null) {
      return c;
    }
  }
  if (a.isArrayType()) {
    TypeReference elt=a.getInnermostElementType();
    if (elt.isPrimitiveType()) {
      return getRootClass().getClassLoader().lookupClass(a.getName());
    }
 else {
      IClass c=lookupClass(elt);
      if (c == null) {
        unresolved.add(elt);
        return null;
      }
 else {
        return c.getClassLoader().lookupClass(a.getName());
      }
    }
  }
 else {
    Node n=map.get(a);
    if (n != null) {
      return n.klass;
    }
 else {
      unresolved.add(a);
      return null;
    }
  }
}","/** 
 * Find a class in this class hierarchy.
 * @return the {@link IClass} for a if found; null if can't find the class.
 * @throws IllegalArgumentException if A is null
 */
@Override public IClass lookupClass(TypeReference a){
  if (a == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final IClass cls=lookupClassRecursive(a);
  if (cls == null) {
    unresolved.add(a);
  }
  return cls;
}",0.4928292046936114
38269,"protected void parseBytecode(){
  logger.debug(""String_Node_Str"" + eMethod.getClass().getSimpleName() + ""String_Node_Str""+ eMethod.method.getMethodString());
  org.jf.dexlib.Code.Instruction[] instrucs=eMethod.codeItem.getInstructions();
  logger.debug(""String_Node_Str"" + eMethod.method.getMethodString() + ""String_Node_Str""+ instrucs.length);
  instructions=new InstructionArray();
  int instLoc=0;
  int instCounter=-1;
  int currentCodeAddress=0;
  for (  org.jf.dexlib.Code.Instruction inst : instrucs) {
    totalInsts++;
    instCounter++;
    instLoc=currentCodeAddress;
    logger.debug(""String_Node_Str"" + instCounter + ""String_Node_Str""+ instLoc+ ""String_Node_Str""+ inst.opcode.name()+ ""String_Node_Str""+ inst.getFormat());
switch (inst.opcode) {
case NOP:
switch (inst.getFormat()) {
case ArrayData:
{
          for (int i=0; i < instructions.size(); i++) {
            if (instructions.getFromId(i) instanceof ArrayFill)             if (instLoc == (((ArrayFill)getInstructionFromIndex(i)).tableAddressOffset + getAddressFromIndex(i))) {
              ((ArrayFill)getInstructionFromIndex(i)).setArrayDataTable((ArrayDataPseudoInstruction)inst);
              break;
            }
          }
          break;
        }
case PackedSwitchData:
      for (int i=0; i < instructions.size(); i++) {
        if (instructions.getFromId(i) instanceof Switch)         if (instLoc == (((Switch)getInstructionFromIndex(i)).tableAddressOffset + getAddressFromIndex(i))) {
          ((Switch)getInstructionFromIndex(i)).setSwitchPad(new PackedSwitchPad(((PackedSwitchDataPseudoInstruction)inst),getAddressFromIndex(i + 1) - getAddressFromIndex(i)));
          break;
        }
      }
    break;
case SparseSwitchData:
{
    for (int i=0; i < instructions.size(); i++) {
      if (instructions.getFromId(i) instanceof Switch)       if (instLoc == (((Switch)getInstructionFromIndex(i)).tableAddressOffset + getAddressFromIndex(i))) {
        ((Switch)getInstructionFromIndex(i)).setSwitchPad(new SparseSwitchPad(((SparseSwitchDataPseudoInstruction)inst),getAddressFromIndex(i + 1) - getAddressFromIndex(i)));
        break;
      }
    }
    break;
  }
case UnresolvedOdexInstruction:
throw new RuntimeException(""String_Node_Str"" + inst.opcode.toString() + inst.getFormat());
default :
break;
}
break;
case MOVE:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_FROM16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction22x)inst).getRegisterA(),((Instruction22x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction32x)inst).getRegisterA(),((Instruction32x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_WIDE:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_WIDE_FROM16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction22x)inst).getRegisterA(),((Instruction22x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_WIDE_16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction32x)inst).getRegisterA(),((Instruction32x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_OBJECT:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_OBJECT_FROM16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction22x)inst).getRegisterA(),((Instruction22x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_OBJECT_16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction32x)inst).getRegisterA(),((Instruction32x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_RESULT:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction11x)inst).getRegisterA(),getReturnReg(),inst.opcode,this));
break;
case MOVE_RESULT_WIDE:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction11x)inst).getRegisterA(),getReturnReg(),inst.opcode,this));
break;
case MOVE_RESULT_OBJECT:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction11x)inst).getRegisterA(),getReturnReg(),inst.opcode,this));
break;
case MOVE_EXCEPTION:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction11x)inst).getRegisterA(),getExceptionReg(),inst.opcode,this));
break;
case RETURN_VOID:
instructions.add(new Return.ReturnVoid(instLoc,inst.opcode,this));
break;
case RETURN:
instructions.add(new Return.ReturnSingle(instLoc,((Instruction11x)inst).getRegisterA(),true,inst.opcode,this));
break;
case RETURN_WIDE:
instructions.add(new Return.ReturnDouble(instLoc,((Instruction11x)inst).getRegisterA(),((Instruction11x)inst).getRegisterA() + 1,inst.opcode,this));
break;
case RETURN_OBJECT:
instructions.add(new Return.ReturnSingle(instLoc,((Instruction11x)inst).getRegisterA(),false,inst.opcode,this));
break;
case CONST_4:
{
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction11n)inst).getLiteral(),((Instruction11n)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction11n)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction11n)inst).getLiteral());
break;
}
case CONST_16:
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction21s)inst).getLiteral(),((Instruction21s)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21s)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21s)inst).getLiteral());
break;
case CONST:
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction31i)inst).getLiteral(),((Instruction31i)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction31i)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction31i)inst).getLiteral());
break;
case CONST_HIGH16:
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction21h)inst).getLiteral(),((Instruction21h)inst).getRegisterA(),inst.opcode,this));
break;
case CONST_WIDE_16:
instructions.add(new Constant.LongConstant(instLoc,((Instruction21s)inst).getLiteral(),((Instruction21s)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21s)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21s)inst).getLiteral());
break;
case CONST_WIDE_32:
instructions.add(new Constant.LongConstant(instLoc,((Instruction31i)inst).getLiteral(),((Instruction31i)inst).getRegisterA(),inst.opcode,this));
break;
case CONST_WIDE:
instructions.add(new Constant.LongConstant(instLoc,((Instruction51l)inst).getLiteral(),((Instruction51l)inst).getRegisterA(),inst.opcode,this));
break;
case CONST_WIDE_HIGH16:
instructions.add(new Constant.LongConstant(instLoc,((Instruction21h)inst).getLiteral(),((Instruction21h)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21h)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21h)inst).getLiteral());
break;
case CONST_STRING:
instructions.add(new Constant.StringConstant(instLoc,((StringIdItem)((Instruction21c)inst).getReferencedItem()).getStringValue(),((Instruction21c)inst).getRegisterA(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((StringIdItem)((Instruction21c)inst).getReferencedItem()).getStringValue());
break;
case CONST_STRING_JUMBO:
instructions.add(new Constant.StringConstant(instLoc,((StringIdItem)((Instruction31c)inst).getReferencedItem()).getStringValue(),((Instruction31c)inst).getRegisterA(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((StringIdItem)((Instruction31c)inst).getReferencedItem()).getStringValue());
break;
case CONST_CLASS:
{
String cname=((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
TypeReference typeRef=TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname);
instructions.add(new Constant.ClassConstant(instLoc,typeRef,((Instruction21c)inst).getRegisterA(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + cname+ ""String_Node_Str""+ this.myClass.getClassLoader().lookupClass(TypeName.findOrCreate(cname)));
break;
}
case MONITOR_ENTER:
instructions.add(new Monitor(instLoc,true,((Instruction11x)inst).getRegisterA(),inst.opcode,this));
break;
case MONITOR_EXIT:
instructions.add(new Monitor(instLoc,false,((Instruction11x)inst).getRegisterA(),inst.opcode,this));
break;
case CHECK_CAST:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new CheckCast(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname),((Instruction21c)inst).getRegisterA(),inst.opcode,this));
break;
}
case INSTANCE_OF:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new InstanceOf(instLoc,((Instruction22c)inst).getRegisterA(),TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname),((Instruction22c)inst).getRegisterB(),inst.opcode,this));
break;
}
case ARRAY_LENGTH:
instructions.add(new ArrayLength(instLoc,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEW_INSTANCE:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
logger.info(""String_Node_Str"" + ((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor());
instructions.add(new New(instLoc,((Instruction21c)inst).getRegisterA(),NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname)),inst.opcode,this));
break;
}
case NEW_ARRAY:
{
int[] params=new int[1];
params[0]=((Instruction22c)inst).getRegisterB();
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new NewArray(instLoc,((Instruction22c)inst).getRegisterA(),NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname)),params,inst.opcode,this));
break;
}
case FILLED_NEW_ARRAY:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] params=new int[1];
params[0]=registerCount;
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction35c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction35c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
NewSiteReference newSiteRef=NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname));
TypeReference myTypeRef=TypeReference.findOrCreate(myClass.getClassLoader().getReference(),newSiteRef.getDeclaredType().getArrayElementType().getName().toString());
instructions.add(new NewArrayFilled(instLoc,getReturnReg(),newSiteRef,myTypeRef,params,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + ((TypeIdItem)((Instruction35c)inst).getReferencedItem()).getTypeDescriptor() + ""String_Node_Str""+ ((Instruction35c)inst).getRegCount());
logger.debug(registerCount + ""String_Node_Str"");
for (int temp_i=0; temp_i < registerCount; temp_i++) logger.debug(""String_Node_Str"" + args[temp_i]);
break;
}
case FILLED_NEW_ARRAY_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] params=new int[1];
params[0]=registerCount;
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction3rc)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction3rc)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
NewSiteReference newSiteRef=NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname));
TypeReference myTypeRef=TypeReference.findOrCreate(myClass.getClassLoader().getReference(),newSiteRef.getDeclaredType().getArrayElementType().getName().toString());
instructions.add(new NewArrayFilled(instLoc,getReturnReg(),newSiteRef,myTypeRef,params,args,inst.opcode,this));
break;
}
case FILL_ARRAY_DATA:
Instruction prev_inst=getInstructionFromIndex(instCounter - 1);
if (prev_inst instanceof NewArray && ((NewArray)prev_inst).destination == ((Instruction31t)inst).getRegisterA()) {
instructions.add(new ArrayFill(instLoc,((Instruction31t)inst).getRegisterA(),((Instruction31t)inst).getTargetAddressOffset(),TypeReference.findOrCreate(myClass.getClassLoader().getReference(),((NewArray)prev_inst).newSiteRef.getDeclaredType().getArrayElementType().getName().toString()),inst.opcode,this));
}
 else {
throw new UnsupportedOperationException(""String_Node_Str"");
}
break;
case THROW:
instructions.add(new Throw(instLoc,((Instruction11x)inst).getRegisterA(),inst.opcode,this));
break;
case GOTO:
instructions.add(new Goto(instLoc,((Instruction10t)inst).getTargetAddressOffset(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction10t)inst).getTargetAddressOffset());
break;
case GOTO_16:
instructions.add(new Goto(instLoc,((Instruction20t)inst).getTargetAddressOffset(),inst.opcode,this));
break;
case GOTO_32:
instructions.add(new Goto(instLoc,((Instruction30t)inst).getTargetAddressOffset(),inst.opcode,this));
break;
case PACKED_SWITCH:
case SPARSE_SWITCH:
instructions.add(new Switch(instLoc,((Instruction31t)inst).getRegisterA(),((Instruction31t)inst).getTargetAddressOffset(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + inst.getFormat());
break;
case CMPL_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPL_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMPG_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPG_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMPL_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPL_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMPG_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPG_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMP_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPL_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case IF_EQ:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.EQ,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_NE:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.NE,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_LT:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.LT,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_GE:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.GE,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_GT:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.GT,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_LE:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.LE,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_EQZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.EQZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_NEZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.NEZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_LTZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.LTZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_GEZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.GEZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_GTZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.GTZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_LEZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.LEZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case AGET:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_int,inst.opcode,this));
break;
case AGET_WIDE:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_wide,inst.opcode,this));
break;
case AGET_OBJECT:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_object,inst.opcode,this));
break;
case AGET_BOOLEAN:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_boolean,inst.opcode,this));
break;
case AGET_BYTE:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_byte,inst.opcode,this));
break;
case AGET_CHAR:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_char,inst.opcode,this));
break;
case AGET_SHORT:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_short,inst.opcode,this));
break;
case APUT:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_int,inst.opcode,this));
break;
case APUT_WIDE:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_wide,inst.opcode,this));
break;
case APUT_OBJECT:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_object,inst.opcode,this));
break;
case APUT_BOOLEAN:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_boolean,inst.opcode,this));
break;
case APUT_BYTE:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_byte,inst.opcode,this));
break;
case APUT_CHAR:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_char,inst.opcode,this));
break;
case APUT_SHORT:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_short,inst.opcode,this));
break;
case IGET:
case IGET_WIDE:
case IGET_OBJECT:
case IGET_BOOLEAN:
case IGET_BYTE:
case IGET_CHAR:
case IGET_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new GetField.GetInstanceField(instLoc,((Instruction22c)inst).getRegisterA(),((Instruction22c)inst).getRegisterB(),cname,fname,ftname,inst.opcode,this));
break;
}
case IPUT:
case IPUT_WIDE:
case IPUT_OBJECT:
case IPUT_BOOLEAN:
case IPUT_BYTE:
case IPUT_CHAR:
case IPUT_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new PutField.PutInstanceField(instLoc,((Instruction22c)inst).getRegisterA(),((Instruction22c)inst).getRegisterB(),cname,fname,ftname,inst.opcode,this));
break;
}
case SGET:
case SGET_WIDE:
case SGET_OBJECT:
case SGET_BOOLEAN:
case SGET_BYTE:
case SGET_CHAR:
case SGET_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new GetField.GetStaticField(instLoc,((Instruction21c)inst).getRegisterA(),cname,fname,ftname,inst.opcode,this));
break;
}
case SPUT:
case SPUT_WIDE:
case SPUT_OBJECT:
case SPUT_BOOLEAN:
case SPUT_BYTE:
case SPUT_CHAR:
case SPUT_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new PutField.PutStaticField(instLoc,((Instruction21c)inst).getRegisterA(),cname,fname,ftname,inst.opcode,this));
break;
}
case INVOKE_VIRTUAL:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
handleINVOKE_VIRTUAL(instLoc,cname,mname,pname,args,inst.opcode);
break;
}
case INVOKE_SUPER:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeSuper(instLoc,cname,mname,pname,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + cname + ""String_Node_Str""+ mname+ ""String_Node_Str""+ pname);
break;
}
case INVOKE_DIRECT:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeDirect(instLoc,cname,mname,pname,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor() + ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString()+ ""String_Node_Str""+ ((Instruction35c)inst).getRegCount());
break;
}
case INVOKE_STATIC:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeStatic(instLoc,cname,mname,pname,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor() + ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString()+ ""String_Node_Str""+ ((Instruction35c)inst).getRegCount());
break;
}
case INVOKE_INTERFACE:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeInterface(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_VIRTUAL_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeVirtual(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_SUPER_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeSuper(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_DIRECT_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeDirect(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_STATIC_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeStatic(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_INTERFACE_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeInterface(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case NEG_INT:
instructions.add(new UnaryOperation(instLoc,OpID.NEGINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NOT_INT:
instructions.add(new UnaryOperation(instLoc,OpID.NOTINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEG_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.NEGLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NOT_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.NOTLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEG_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.NEGFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEG_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.NEGDOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.INTTODOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case LONG_TO_INT:
instructions.add(new UnaryOperation(instLoc,OpID.LONGTOINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case LONG_TO_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.LONGTOFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case LONG_TO_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.LONGTODOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case FLOAT_TO_INT:
instructions.add(new UnaryOperation(instLoc,OpID.FLOATTOINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case FLOAT_TO_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.FLOATTOLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case FLOAT_TO_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.FLOATTODOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DOUBLE_TO_INT:
instructions.add(new UnaryOperation(instLoc,OpID.DOUBLETOINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DOUBLE_TO_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.DOUBLETOLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DOUBLE_TO_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.DOUBLETOFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_BYTE:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOBYTE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_CHAR:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOCHAR,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_SHORT:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOSHORT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case AND_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case OR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case XOR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHL_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case USHR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case AND_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case OR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case XOR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHL_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case USHR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case AND_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case OR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case XOR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHL_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case USHR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case AND_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case OR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case XOR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHL_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case USHR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.ADD_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case RSUB_INT:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.RSUB_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case MUL_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.MUL_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case DIV_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.DIV_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case REM_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.REM_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case AND_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.AND_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case OR_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.OR_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case XOR_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.XOR_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case ADD_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.ADD_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case RSUB_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.RSUB_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case MUL_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.MUL_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case DIV_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.DIV_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case REM_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.REM_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case AND_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.AND_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case OR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.OR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case XOR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.XOR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case SHL_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.SHL_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case SHR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.SHR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case USHR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.USHR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
default :
throw new RuntimeException(""String_Node_Str"" + inst.opcode.toString());
}
currentCodeAddress+=inst.getSize(currentCodeAddress);
}
logger.debug(""String_Node_Str"" + this.toString() + ""String_Node_Str"");
}","protected void parseBytecode(){
  logger.debug(""String_Node_Str"" + eMethod.getClass().getSimpleName() + ""String_Node_Str""+ eMethod.method.getMethodString());
  org.jf.dexlib.Code.Instruction[] instrucs=eMethod.codeItem.getInstructions();
  logger.debug(""String_Node_Str"" + eMethod.method.getMethodString() + ""String_Node_Str""+ instrucs.length);
  instructions=new InstructionArray();
  int instLoc=0;
  int instCounter=-1;
  int currentCodeAddress=0;
  for (  org.jf.dexlib.Code.Instruction inst : instrucs) {
    totalInsts++;
    instCounter++;
    instLoc=currentCodeAddress;
    logger.debug(""String_Node_Str"" + instCounter + ""String_Node_Str""+ instLoc+ ""String_Node_Str""+ inst.opcode.name()+ ""String_Node_Str""+ inst.getFormat());
switch (inst.opcode) {
case NOP:
switch (inst.getFormat()) {
case ArrayData:
{
          for (int i=0; i < instructions.size(); i++) {
            if (instructions.getFromId(i) instanceof ArrayFill)             if (instLoc == (((ArrayFill)getInstructionFromIndex(i)).tableAddressOffset + getAddressFromIndex(i))) {
              ((ArrayFill)getInstructionFromIndex(i)).setArrayDataTable((ArrayDataPseudoInstruction)inst);
              break;
            }
          }
          break;
        }
case PackedSwitchData:
      for (int i=0; i < instructions.size(); i++) {
        if (instructions.getFromId(i) instanceof Switch)         if (instLoc == (((Switch)getInstructionFromIndex(i)).tableAddressOffset + getAddressFromIndex(i))) {
          ((Switch)getInstructionFromIndex(i)).setSwitchPad(new PackedSwitchPad(((PackedSwitchDataPseudoInstruction)inst),getAddressFromIndex(i + 1) - getAddressFromIndex(i)));
          break;
        }
      }
    break;
case SparseSwitchData:
{
    for (int i=0; i < instructions.size(); i++) {
      if (instructions.getFromId(i) instanceof Switch)       if (instLoc == (((Switch)getInstructionFromIndex(i)).tableAddressOffset + getAddressFromIndex(i))) {
        ((Switch)getInstructionFromIndex(i)).setSwitchPad(new SparseSwitchPad(((SparseSwitchDataPseudoInstruction)inst),getAddressFromIndex(i + 1) - getAddressFromIndex(i)));
        break;
      }
    }
    break;
  }
case UnresolvedOdexInstruction:
throw new RuntimeException(""String_Node_Str"" + inst.opcode.toString() + inst.getFormat());
default :
break;
}
break;
case MOVE:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_FROM16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction22x)inst).getRegisterA(),((Instruction22x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction32x)inst).getRegisterA(),((Instruction32x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_WIDE:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_WIDE_FROM16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction22x)inst).getRegisterA(),((Instruction22x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_WIDE_16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction32x)inst).getRegisterA(),((Instruction32x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_OBJECT:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_OBJECT_FROM16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction22x)inst).getRegisterA(),((Instruction22x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_OBJECT_16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction32x)inst).getRegisterA(),((Instruction32x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_RESULT:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction11x)inst).getRegisterA(),getReturnReg(),inst.opcode,this));
break;
case MOVE_RESULT_WIDE:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction11x)inst).getRegisterA(),getReturnReg(),inst.opcode,this));
break;
case MOVE_RESULT_OBJECT:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction11x)inst).getRegisterA(),getReturnReg(),inst.opcode,this));
break;
case MOVE_EXCEPTION:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction11x)inst).getRegisterA(),getExceptionReg(),inst.opcode,this));
break;
case RETURN_VOID:
instructions.add(new Return.ReturnVoid(instLoc,inst.opcode,this));
break;
case RETURN:
instructions.add(new Return.ReturnSingle(instLoc,((Instruction11x)inst).getRegisterA(),true,inst.opcode,this));
break;
case RETURN_WIDE:
instructions.add(new Return.ReturnDouble(instLoc,((Instruction11x)inst).getRegisterA(),((Instruction11x)inst).getRegisterA() + 1,inst.opcode,this));
break;
case RETURN_OBJECT:
instructions.add(new Return.ReturnSingle(instLoc,((Instruction11x)inst).getRegisterA(),false,inst.opcode,this));
break;
case CONST_4:
{
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction11n)inst).getLiteral(),((Instruction11n)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction11n)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction11n)inst).getLiteral());
break;
}
case CONST_16:
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction21s)inst).getLiteral(),((Instruction21s)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21s)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21s)inst).getLiteral());
break;
case CONST:
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction31i)inst).getLiteral(),((Instruction31i)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction31i)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction31i)inst).getLiteral());
break;
case CONST_HIGH16:
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction21h)inst).getLiteral(),((Instruction21h)inst).getRegisterA(),inst.opcode,this));
break;
case CONST_WIDE_16:
instructions.add(new Constant.LongConstant(instLoc,((Instruction21s)inst).getLiteral(),((Instruction21s)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21s)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21s)inst).getLiteral());
break;
case CONST_WIDE_32:
instructions.add(new Constant.LongConstant(instLoc,((Instruction31i)inst).getLiteral(),((Instruction31i)inst).getRegisterA(),inst.opcode,this));
break;
case CONST_WIDE:
instructions.add(new Constant.LongConstant(instLoc,((Instruction51l)inst).getLiteral(),((Instruction51l)inst).getRegisterA(),inst.opcode,this));
break;
case CONST_WIDE_HIGH16:
instructions.add(new Constant.LongConstant(instLoc,((Instruction21h)inst).getLiteral(),((Instruction21h)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21h)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21h)inst).getLiteral());
break;
case CONST_STRING:
instructions.add(new Constant.StringConstant(instLoc,((StringIdItem)((Instruction21c)inst).getReferencedItem()).getStringValue(),((Instruction21c)inst).getRegisterA(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((StringIdItem)((Instruction21c)inst).getReferencedItem()).getStringValue());
break;
case CONST_STRING_JUMBO:
instructions.add(new Constant.StringConstant(instLoc,((StringIdItem)((Instruction31c)inst).getReferencedItem()).getStringValue(),((Instruction31c)inst).getRegisterA(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((StringIdItem)((Instruction31c)inst).getReferencedItem()).getStringValue());
break;
case CONST_CLASS:
{
String cname=((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
TypeReference typeRef=TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname);
instructions.add(new Constant.ClassConstant(instLoc,typeRef,((Instruction21c)inst).getRegisterA(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + cname+ ""String_Node_Str""+ this.myClass.getClassLoader().lookupClass(TypeName.findOrCreate(cname)));
break;
}
case MONITOR_ENTER:
instructions.add(new Monitor(instLoc,true,((Instruction11x)inst).getRegisterA(),inst.opcode,this));
break;
case MONITOR_EXIT:
instructions.add(new Monitor(instLoc,false,((Instruction11x)inst).getRegisterA(),inst.opcode,this));
break;
case CHECK_CAST:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new CheckCast(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname),((Instruction21c)inst).getRegisterA(),inst.opcode,this));
break;
}
case INSTANCE_OF:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new InstanceOf(instLoc,((Instruction22c)inst).getRegisterA(),TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname),((Instruction22c)inst).getRegisterB(),inst.opcode,this));
break;
}
case ARRAY_LENGTH:
instructions.add(new ArrayLength(instLoc,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEW_INSTANCE:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
logger.info(""String_Node_Str"" + ((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor());
instructions.add(new New(instLoc,((Instruction21c)inst).getRegisterA(),NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname)),inst.opcode,this));
break;
}
case NEW_ARRAY:
{
int[] params=new int[1];
params[0]=((Instruction22c)inst).getRegisterB();
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new NewArray(instLoc,((Instruction22c)inst).getRegisterA(),NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname)),params,inst.opcode,this));
break;
}
case FILLED_NEW_ARRAY:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] params=new int[1];
params[0]=registerCount;
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction35c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction35c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
NewSiteReference newSiteRef=NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname));
TypeReference myTypeRef=TypeReference.findOrCreate(myClass.getClassLoader().getReference(),newSiteRef.getDeclaredType().getArrayElementType().getName().toString());
instructions.add(new NewArrayFilled(instLoc,getReturnReg(),newSiteRef,myTypeRef,params,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + ((TypeIdItem)((Instruction35c)inst).getReferencedItem()).getTypeDescriptor() + ""String_Node_Str""+ ((Instruction35c)inst).getRegCount());
logger.debug(registerCount + ""String_Node_Str"");
for (int temp_i=0; temp_i < registerCount; temp_i++) logger.debug(""String_Node_Str"" + args[temp_i]);
break;
}
case FILLED_NEW_ARRAY_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] params=new int[1];
params[0]=registerCount;
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction3rc)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction3rc)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
NewSiteReference newSiteRef=NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname));
TypeReference myTypeRef=TypeReference.findOrCreate(myClass.getClassLoader().getReference(),newSiteRef.getDeclaredType().getArrayElementType().getName().toString());
instructions.add(new NewArrayFilled(instLoc,getReturnReg(),newSiteRef,myTypeRef,params,args,inst.opcode,this));
break;
}
case FILL_ARRAY_DATA:
TypeReference arrayElementType=findOutArrayElementType(instrucs,instructions.toArray(new Instruction[0]),instCounter);
instructions.add(new ArrayFill(instLoc,((Instruction31t)inst).getRegisterA(),((Instruction31t)inst).getTargetAddressOffset(),TypeReference.findOrCreate(myClass.getClassLoader().getReference(),arrayElementType.getName().toString()),inst.opcode,this));
break;
case THROW:
instructions.add(new Throw(instLoc,((Instruction11x)inst).getRegisterA(),inst.opcode,this));
break;
case GOTO:
instructions.add(new Goto(instLoc,((Instruction10t)inst).getTargetAddressOffset(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction10t)inst).getTargetAddressOffset());
break;
case GOTO_16:
instructions.add(new Goto(instLoc,((Instruction20t)inst).getTargetAddressOffset(),inst.opcode,this));
break;
case GOTO_32:
instructions.add(new Goto(instLoc,((Instruction30t)inst).getTargetAddressOffset(),inst.opcode,this));
break;
case PACKED_SWITCH:
case SPARSE_SWITCH:
instructions.add(new Switch(instLoc,((Instruction31t)inst).getRegisterA(),((Instruction31t)inst).getTargetAddressOffset(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + inst.getFormat());
break;
case CMPL_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPL_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMPG_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPG_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMPL_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPL_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMPG_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPG_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMP_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPL_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case IF_EQ:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.EQ,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_NE:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.NE,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_LT:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.LT,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_GE:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.GE,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_GT:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.GT,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_LE:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.LE,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_EQZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.EQZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_NEZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.NEZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_LTZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.LTZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_GEZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.GEZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_GTZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.GTZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_LEZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.LEZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case AGET:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_int,inst.opcode,this));
break;
case AGET_WIDE:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_wide,inst.opcode,this));
break;
case AGET_OBJECT:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_object,inst.opcode,this));
break;
case AGET_BOOLEAN:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_boolean,inst.opcode,this));
break;
case AGET_BYTE:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_byte,inst.opcode,this));
break;
case AGET_CHAR:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_char,inst.opcode,this));
break;
case AGET_SHORT:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_short,inst.opcode,this));
break;
case APUT:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_int,inst.opcode,this));
break;
case APUT_WIDE:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_wide,inst.opcode,this));
break;
case APUT_OBJECT:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_object,inst.opcode,this));
break;
case APUT_BOOLEAN:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_boolean,inst.opcode,this));
break;
case APUT_BYTE:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_byte,inst.opcode,this));
break;
case APUT_CHAR:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_char,inst.opcode,this));
break;
case APUT_SHORT:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_short,inst.opcode,this));
break;
case IGET:
case IGET_WIDE:
case IGET_OBJECT:
case IGET_BOOLEAN:
case IGET_BYTE:
case IGET_CHAR:
case IGET_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new GetField.GetInstanceField(instLoc,((Instruction22c)inst).getRegisterA(),((Instruction22c)inst).getRegisterB(),cname,fname,ftname,inst.opcode,this));
break;
}
case IPUT:
case IPUT_WIDE:
case IPUT_OBJECT:
case IPUT_BOOLEAN:
case IPUT_BYTE:
case IPUT_CHAR:
case IPUT_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new PutField.PutInstanceField(instLoc,((Instruction22c)inst).getRegisterA(),((Instruction22c)inst).getRegisterB(),cname,fname,ftname,inst.opcode,this));
break;
}
case SGET:
case SGET_WIDE:
case SGET_OBJECT:
case SGET_BOOLEAN:
case SGET_BYTE:
case SGET_CHAR:
case SGET_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new GetField.GetStaticField(instLoc,((Instruction21c)inst).getRegisterA(),cname,fname,ftname,inst.opcode,this));
break;
}
case SPUT:
case SPUT_WIDE:
case SPUT_OBJECT:
case SPUT_BOOLEAN:
case SPUT_BYTE:
case SPUT_CHAR:
case SPUT_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new PutField.PutStaticField(instLoc,((Instruction21c)inst).getRegisterA(),cname,fname,ftname,inst.opcode,this));
break;
}
case INVOKE_VIRTUAL:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
handleINVOKE_VIRTUAL(instLoc,cname,mname,pname,args,inst.opcode);
break;
}
case INVOKE_SUPER:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeSuper(instLoc,cname,mname,pname,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + cname + ""String_Node_Str""+ mname+ ""String_Node_Str""+ pname);
break;
}
case INVOKE_DIRECT:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeDirect(instLoc,cname,mname,pname,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor() + ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString()+ ""String_Node_Str""+ ((Instruction35c)inst).getRegCount());
break;
}
case INVOKE_STATIC:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeStatic(instLoc,cname,mname,pname,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor() + ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString()+ ""String_Node_Str""+ ((Instruction35c)inst).getRegCount());
break;
}
case INVOKE_INTERFACE:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeInterface(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_VIRTUAL_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeVirtual(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_SUPER_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeSuper(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_DIRECT_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeDirect(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_STATIC_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeStatic(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_INTERFACE_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeInterface(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case NEG_INT:
instructions.add(new UnaryOperation(instLoc,OpID.NEGINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NOT_INT:
instructions.add(new UnaryOperation(instLoc,OpID.NOTINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEG_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.NEGLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NOT_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.NOTLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEG_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.NEGFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEG_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.NEGDOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.INTTODOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case LONG_TO_INT:
instructions.add(new UnaryOperation(instLoc,OpID.LONGTOINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case LONG_TO_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.LONGTOFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case LONG_TO_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.LONGTODOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case FLOAT_TO_INT:
instructions.add(new UnaryOperation(instLoc,OpID.FLOATTOINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case FLOAT_TO_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.FLOATTOLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case FLOAT_TO_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.FLOATTODOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DOUBLE_TO_INT:
instructions.add(new UnaryOperation(instLoc,OpID.DOUBLETOINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DOUBLE_TO_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.DOUBLETOLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DOUBLE_TO_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.DOUBLETOFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_BYTE:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOBYTE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_CHAR:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOCHAR,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_SHORT:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOSHORT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case AND_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case OR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case XOR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHL_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case USHR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case AND_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case OR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case XOR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHL_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case USHR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case AND_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case OR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case XOR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHL_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case USHR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case AND_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case OR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case XOR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHL_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case USHR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.ADD_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case RSUB_INT:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.RSUB_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case MUL_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.MUL_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case DIV_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.DIV_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case REM_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.REM_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case AND_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.AND_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case OR_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.OR_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case XOR_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.XOR_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case ADD_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.ADD_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case RSUB_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.RSUB_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case MUL_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.MUL_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case DIV_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.DIV_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case REM_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.REM_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case AND_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.AND_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case OR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.OR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case XOR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.XOR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case SHL_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.SHL_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case SHR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.SHR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case USHR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.USHR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
default :
throw new RuntimeException(""String_Node_Str"" + inst.opcode.toString());
}
currentCodeAddress+=inst.getSize(currentCodeAddress);
}
logger.debug(""String_Node_Str"" + this.toString() + ""String_Node_Str"");
}",0.9969844093965804
38270,"/** 
 * set up the methodMap mapping
 */
protected void computeMethodMapIfNeeded() throws InvalidClassFileException {
  if (methodMap == null) {
synchronized (this) {
      if (methodMap == null) {
        IMethod[] methods=computeDeclaredMethods();
        if (methods.length > 5) {
          methodMap=HashMapFactory.make(methods.length);
        }
 else {
          methodMap=new SmallMap<Selector,IMethod>();
        }
        for (int i=0; i < methods.length; i++) {
          IMethod m=methods[i];
          methodMap.put(m.getReference().getSelector(),m);
        }
      }
    }
  }
}","/** 
 * set up the methodMap mapping
 */
protected void computeMethodMapIfNeeded() throws InvalidClassFileException {
  if (methodMap == null) {
synchronized (this) {
      if (methodMap == null) {
        IMethod[] methods=computeDeclaredMethods();
        final Map<Selector,IMethod> tmpMethodMap;
        if (methods.length > 5) {
          tmpMethodMap=HashMapFactory.make(methods.length);
        }
 else {
          tmpMethodMap=new SmallMap<Selector,IMethod>();
        }
        for (int i=0; i < methods.length; i++) {
          IMethod m=methods[i];
          tmpMethodMap.put(m.getReference().getSelector(),m);
        }
        methodMap=tmpMethodMap;
      }
    }
  }
}",0.9223529411764706
38271,"public void unary1(){
}","@Override public void unary1(){
}",0.8214285714285714
38272,"public void unary2(){
  unary1();
}","@Override public void unary2(){
  unary1();
}",0.875
38273,"public void binary(Whatever arg){
  this.unary1();
  arg.unary2();
}","@Override public void binary(Whatever arg){
  this.unary1();
  arg.unary2();
}",0.9315068493150684
38274,"public static void main(String[] args){
  Whatever x=new This();
  Whatever y=new That();
  Whatever z=choice() ? x : y;
  if (z instanceof This)   x.binary(z);
 else   y.binary(z);
}","public static void main(String[] args){
  Whatever x=new This();
  Whatever y=new That();
  Whatever z=choice() ? x : y;
  if (z instanceof This)   x.binary(z);
 else   y.binary(z);
  localCast();
}",0.9606299212598424
38275,"private void checkCallAssertions(CallGraph cg,int desiredNumberOfTargets,int desiredNumberOfCalls){
}","private void checkCallAssertions(CallGraph cg,int desiredNumberOfTargets,int desiredNumberOfCalls,int numLocalCastCallees){
}",0.8938053097345132
38276,"@Test public void testNoPiNodes() throws ClassHierarchyException, IllegalArgumentException, CancelException, IOException {
  checkCallAssertions(doGraph(false),2,2);
}","@Test public void testNoPiNodes() throws ClassHierarchyException, IllegalArgumentException, CancelException, IOException {
  checkCallAssertions(doGraph(false),2,2,2);
}",0.9940476190476192
38277,"@Test public void testPiNodes() throws ClassHierarchyException, IllegalArgumentException, CancelException, IOException {
  checkCallAssertions(doGraph(true),1,2);
}","@Test public void testPiNodes() throws ClassHierarchyException, IllegalArgumentException, CancelException, IOException {
  checkCallAssertions(doGraph(true),1,2,1);
}",0.993939393939394
38278,"public void defineFunction(CAstEntity n,IClass owner,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,TypeReference[][] catchTypes,boolean hasMonitorOp,AstLexicalInformation lexicalInfo,DebuggingInformation debugInfo){
  ((JavaClass)owner).addMethod(n,owner,cfg,symtab,hasCatchBlock,catchTypes,hasMonitorOp,lexicalInfo,debugInfo);
}","public void defineFunction(CAstEntity n,IClass owner,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,Map<IBasicBlock,TypeReference[]> caughtTypes,boolean hasMonitorOp,AstLexicalInformation lexicalInfo,DebuggingInformation debugInfo){
  ((JavaClass)owner).addMethod(n,owner,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,lexicalInfo,debugInfo);
}",0.9440459110473458
38279,"public ConcreteJavaMethod(CAstEntity methodEntity,IClass owner,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,TypeReference[][] catchTypes,boolean hasMonitorOp,AstLexicalInformation lexicalInfo,DebuggingInformation debugInfo){
  super(methodEntity,owner,cfg,symtab,hasCatchBlock,catchTypes,hasMonitorOp,lexicalInfo,debugInfo);
}","public ConcreteJavaMethod(CAstEntity methodEntity,IClass owner,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,Map<IBasicBlock,TypeReference[]> caughtTypes,boolean hasMonitorOp,AstLexicalInformation lexicalInfo,DebuggingInformation debugInfo){
  super(methodEntity,owner,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,lexicalInfo,debugInfo);
}",0.9437229437229436
38280,"protected void defineFunction(CAstEntity N,WalkContext definingContext,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,TypeReference[][] caughtTypes,boolean hasMonitorOp,AstLexicalInformation lexicalInfo,DebuggingInformation debugInfo){
}","protected void defineFunction(CAstEntity N,WalkContext definingContext,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,Map<IBasicBlock,TypeReference[]> caughtTypes,boolean hasMonitorOp,AstLexicalInformation lexicalInfo,DebuggingInformation debugInfo){
}",0.962671905697446
38281,"@Override protected void defineFunction(CAstEntity N,WalkContext definingContext,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,TypeReference[][] caughtTypes,boolean hasMonitorOp,AstLexicalInformation LI,DebuggingInformation debugInfo){
  if (N == codeBodyEntity) {
    specializedCode=myloader.makeCodeBodyCode(cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo,method.getDeclaringClass());
  }
 else {
    super.defineFunction(N,definingContext,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo);
  }
}","@Override protected void defineFunction(CAstEntity N,WalkContext definingContext,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,Map<IBasicBlock,TypeReference[]> caughtTypes,boolean hasMonitorOp,AstLexicalInformation LI,DebuggingInformation debugInfo){
  if (N == codeBodyEntity) {
    specializedCode=myloader.makeCodeBodyCode(cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo,method.getDeclaringClass());
  }
 else {
    super.defineFunction(N,definingContext,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo);
  }
}",0.9826166514181152
38282,"@Override public IR makeIR(final IMethod method,Context context,SSAOptions options){
  if (method instanceof Retranslatable) {
    @SuppressWarnings(""String_Node_Str"") final Value<Integer> v=(Value<Integer>)context.get(ArgumentCountContext.ARGUMENT_COUNT);
    final Retranslatable m=(Retranslatable)method;
    if (v != null) {
      final JavaScriptLoader myloader=(JavaScriptLoader)method.getDeclaringClass().getClassLoader();
class FixedArgumentsRewriter extends CAstBasicRewriter {
        private final CAstEntity e;
        Map<String,CAstNode> argRefs=HashMapFactory.make();
        public FixedArgumentsRewriter(        CAst Ast){
          super(Ast,false);
          this.e=m.getEntity();
          for (          Segments s : CAstPattern.findAll(destructuredAccessPattern,m.getEntity())) {
            argRefs.put(s.getSingle(""String_Node_Str"").getValue().toString(),s.getSingle(""String_Node_Str""));
          }
        }
        private CAstNode handleArgumentRef(        CAstNode n){
          Object x=n.getValue();
          if (x != null) {
            if (x instanceof Number && ((Number)x).intValue() < v.getValue() - 2) {
              int arg=((Number)x).intValue() + 2;
              if (arg < e.getArgumentCount()) {
                return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(e.getArgumentNames()[arg]));
              }
 else {
                return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(""String_Node_Str"" + arg));
              }
            }
 else             if (x instanceof String && ""String_Node_Str"".equals(x)) {
              return Ast.makeConstant(v.getValue());
            }
          }
          return null;
        }
        @Override protected CAstNode copyNodes(        CAstNode root,        CAstControlFlowMap cfg,        NonCopyingContext context,        Map<Pair<CAstNode,NoKey>,CAstNode> nodeMap){
          CAstNode result=null;
          Segments s;
          if ((s=CAstPattern.match(directAccessPattern,root)) != null) {
            result=handleArgumentRef(s.getSingle(""String_Node_Str""));
          }
 else           if ((s=CAstPattern.match(destructuredCallPattern,root)) != null) {
            if (argRefs.containsKey(s.getSingle(""String_Node_Str"").getValue().toString())) {
              List<CAstNode> x=new ArrayList<CAstNode>();
              CAstNode ref=handleArgumentRef(argRefs.get(s.getSingle(""String_Node_Str"").getValue().toString()));
              if (ref != null) {
                x.add(ref);
                x.add(Ast.makeConstant(""String_Node_Str""));
                x.add(Ast.makeNode(CAstNode.VAR,Ast.makeConstant(""String_Node_Str"")));
                for (                CAstNode c : s.getMultiple(""String_Node_Str"")) {
                  x.add(copyNodes(c,cfg,context,nodeMap));
                }
                result=Ast.makeNode(CAstNode.CALL,x.toArray(new CAstNode[x.size()]));
              }
            }
          }
 else           if (root.getKind() == CAstNode.CONSTANT) {
            result=Ast.makeConstant(root.getValue());
          }
 else           if (root.getKind() == CAstNode.OPERATOR) {
            result=root;
          }
          if (result == null) {
            CAstNode children[]=new CAstNode[root.getChildCount()];
            for (int i=0; i < children.length; i++) {
              children[i]=copyNodes(root.getChild(i),cfg,context,nodeMap);
            }
            for (            Object label : cfg.getTargetLabels(root)) {
              if (label instanceof CAstNode) {
                copyNodes((CAstNode)label,cfg,context,nodeMap);
              }
            }
            CAstNode copy=Ast.makeNode(root.getKind(),children);
            result=copy;
          }
          nodeMap.put(Pair.make(root,context.key()),result);
          return result;
        }
      }
      final FixedArgumentsRewriter args=new FixedArgumentsRewriter(new CAstImpl());
      final JSConstantFoldingRewriter fold=new JSConstantFoldingRewriter(new CAstImpl());
class ArgumentativeTranslator extends JSAstTranslator {
        public ArgumentativeTranslator(        JavaScriptLoader loader){
          super(loader);
        }
        private CAstEntity codeBodyEntity;
        private IMethod specializedCode;
        @Override protected int getArgumentCount(        CAstEntity f){
          return Math.max(super.getArgumentCount(f),v.getValue());
        }
        @Override protected String[] getArgumentNames(        CAstEntity f){
          if (super.getArgumentCount(f) >= v.getValue()) {
            return super.getArgumentNames(f);
          }
 else {
            String[] argNames=new String[v.getValue()];
            System.arraycopy(super.getArgumentNames(f),0,argNames,0,super.getArgumentCount(f));
            for (int i=super.getArgumentCount(f); i < argNames.length; i++) {
              argNames[i]=""String_Node_Str"" + i;
            }
            return argNames;
          }
        }
        @Override protected String composeEntityName(        WalkContext parent,        CAstEntity f){
          if (f == codeBodyEntity) {
            return super.composeEntityName(parent,f) + ""String_Node_Str"" + v.getValue().intValue();
          }
 else {
            return super.composeEntityName(parent,f);
          }
        }
        @Override protected void defineFunction(        CAstEntity N,        WalkContext definingContext,        AbstractCFG cfg,        SymbolTable symtab,        boolean hasCatchBlock,        TypeReference[][] caughtTypes,        boolean hasMonitorOp,        AstLexicalInformation LI,        DebuggingInformation debugInfo){
          if (N == codeBodyEntity) {
            specializedCode=myloader.makeCodeBodyCode(cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo,method.getDeclaringClass());
          }
 else {
            super.defineFunction(N,definingContext,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo);
          }
        }
        @Override public void translate(        CAstEntity N,        WalkContext context){
          if (N == m.getEntity()) {
            codeBodyEntity=fold.rewrite(args.rewrite(N));
            super.translate(codeBodyEntity,context);
          }
 else {
            super.translate(N,context);
          }
        }
      }
      ArgumentativeTranslator a=new ArgumentativeTranslator(myloader);
      m.retranslate(a);
      return super.makeIR(a.specializedCode,context,options);
    }
  }
  return super.makeIR(method,context,options);
}","@Override public IR makeIR(final IMethod method,Context context,SSAOptions options){
  if (method instanceof Retranslatable) {
    @SuppressWarnings(""String_Node_Str"") final Value<Integer> v=(Value<Integer>)context.get(ArgumentCountContext.ARGUMENT_COUNT);
    final Retranslatable m=(Retranslatable)method;
    if (v != null) {
      final JavaScriptLoader myloader=(JavaScriptLoader)method.getDeclaringClass().getClassLoader();
class FixedArgumentsRewriter extends CAstBasicRewriter {
        private final CAstEntity e;
        Map<String,CAstNode> argRefs=HashMapFactory.make();
        public FixedArgumentsRewriter(        CAst Ast){
          super(Ast,false);
          this.e=m.getEntity();
          for (          Segments s : CAstPattern.findAll(destructuredAccessPattern,m.getEntity())) {
            argRefs.put(s.getSingle(""String_Node_Str"").getValue().toString(),s.getSingle(""String_Node_Str""));
          }
        }
        private CAstNode handleArgumentRef(        CAstNode n){
          Object x=n.getValue();
          if (x != null) {
            if (x instanceof Number && ((Number)x).intValue() < v.getValue() - 2) {
              int arg=((Number)x).intValue() + 2;
              if (arg < e.getArgumentCount()) {
                return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(e.getArgumentNames()[arg]));
              }
 else {
                return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(""String_Node_Str"" + arg));
              }
            }
 else             if (x instanceof String && ""String_Node_Str"".equals(x)) {
              return Ast.makeConstant(v.getValue());
            }
          }
          return null;
        }
        @Override protected CAstNode copyNodes(        CAstNode root,        CAstControlFlowMap cfg,        NonCopyingContext context,        Map<Pair<CAstNode,NoKey>,CAstNode> nodeMap){
          CAstNode result=null;
          Segments s;
          if ((s=CAstPattern.match(directAccessPattern,root)) != null) {
            result=handleArgumentRef(s.getSingle(""String_Node_Str""));
          }
 else           if ((s=CAstPattern.match(destructuredCallPattern,root)) != null) {
            if (argRefs.containsKey(s.getSingle(""String_Node_Str"").getValue().toString())) {
              List<CAstNode> x=new ArrayList<CAstNode>();
              CAstNode ref=handleArgumentRef(argRefs.get(s.getSingle(""String_Node_Str"").getValue().toString()));
              if (ref != null) {
                x.add(ref);
                x.add(Ast.makeConstant(""String_Node_Str""));
                x.add(Ast.makeNode(CAstNode.VAR,Ast.makeConstant(""String_Node_Str"")));
                for (                CAstNode c : s.getMultiple(""String_Node_Str"")) {
                  x.add(copyNodes(c,cfg,context,nodeMap));
                }
                result=Ast.makeNode(CAstNode.CALL,x.toArray(new CAstNode[x.size()]));
              }
            }
          }
 else           if (root.getKind() == CAstNode.CONSTANT) {
            result=Ast.makeConstant(root.getValue());
          }
 else           if (root.getKind() == CAstNode.OPERATOR) {
            result=root;
          }
          if (result == null) {
            CAstNode children[]=new CAstNode[root.getChildCount()];
            for (int i=0; i < children.length; i++) {
              children[i]=copyNodes(root.getChild(i),cfg,context,nodeMap);
            }
            for (            Object label : cfg.getTargetLabels(root)) {
              if (label instanceof CAstNode) {
                copyNodes((CAstNode)label,cfg,context,nodeMap);
              }
            }
            CAstNode copy=Ast.makeNode(root.getKind(),children);
            result=copy;
          }
          nodeMap.put(Pair.make(root,context.key()),result);
          return result;
        }
      }
      final FixedArgumentsRewriter args=new FixedArgumentsRewriter(new CAstImpl());
      final JSConstantFoldingRewriter fold=new JSConstantFoldingRewriter(new CAstImpl());
class ArgumentativeTranslator extends JSAstTranslator {
        public ArgumentativeTranslator(        JavaScriptLoader loader){
          super(loader);
        }
        private CAstEntity codeBodyEntity;
        private IMethod specializedCode;
        @Override protected int getArgumentCount(        CAstEntity f){
          return Math.max(super.getArgumentCount(f),v.getValue());
        }
        @Override protected String[] getArgumentNames(        CAstEntity f){
          if (super.getArgumentCount(f) >= v.getValue()) {
            return super.getArgumentNames(f);
          }
 else {
            String[] argNames=new String[v.getValue()];
            System.arraycopy(super.getArgumentNames(f),0,argNames,0,super.getArgumentCount(f));
            for (int i=super.getArgumentCount(f); i < argNames.length; i++) {
              argNames[i]=""String_Node_Str"" + i;
            }
            return argNames;
          }
        }
        @Override protected String composeEntityName(        WalkContext parent,        CAstEntity f){
          if (f == codeBodyEntity) {
            return super.composeEntityName(parent,f) + ""String_Node_Str"" + v.getValue().intValue();
          }
 else {
            return super.composeEntityName(parent,f);
          }
        }
        @Override protected void defineFunction(        CAstEntity N,        WalkContext definingContext,        AbstractCFG cfg,        SymbolTable symtab,        boolean hasCatchBlock,        Map<IBasicBlock,TypeReference[]> caughtTypes,        boolean hasMonitorOp,        AstLexicalInformation LI,        DebuggingInformation debugInfo){
          if (N == codeBodyEntity) {
            specializedCode=myloader.makeCodeBodyCode(cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo,method.getDeclaringClass());
          }
 else {
            super.defineFunction(N,definingContext,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo);
          }
        }
        @Override public void translate(        CAstEntity N,        WalkContext context){
          if (N == m.getEntity()) {
            codeBodyEntity=fold.rewrite(args.rewrite(N));
            super.translate(codeBodyEntity,context);
          }
 else {
            super.translate(N,context);
          }
        }
      }
      ArgumentativeTranslator a=new ArgumentativeTranslator(myloader);
      m.retranslate(a);
      return super.makeIR(a.specializedCode,context,options);
    }
  }
  return super.makeIR(method,context,options);
}",0.998531117124082
38283,"@Override protected void defineFunction(CAstEntity N,WalkContext definingContext,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,TypeReference[][] caughtTypes,boolean hasMonitorOp,AstLexicalInformation LI,DebuggingInformation debugInfo){
  String fnName=""String_Node_Str"" + composeEntityName(definingContext,N);
  names.add(fnName);
  super.defineFunction(N,definingContext,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo);
}","@Override protected void defineFunction(CAstEntity N,WalkContext definingContext,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,Map<IBasicBlock,TypeReference[]> caughtTypes,boolean hasMonitorOp,AstLexicalInformation LI,DebuggingInformation debugInfo){
  String fnName=""String_Node_Str"" + composeEntityName(definingContext,N);
  names.add(fnName);
  super.defineFunction(N,definingContext,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo);
}",0.9791894852135816
38284,"/** 
 * @param cha
 * @param cl
 * @param fileName
 * @param url
 * @return The set of class names that where defined in the CHA as a resultloading process.
 * @throws IOException
 */
public static Set<String> loadAdditionalFile(IClassHierarchy cha,JavaScriptLoader cl,String fileName,URL url) throws IOException {
  try {
    SourceURLModule M=new SourceURLModule(url);
    TranslatorToCAst toCAst=getTranslatorFactory().make(new CAstImpl(),M);
    final Set<String> names=new HashSet<String>();
    JSAstTranslator toIR=new JSAstTranslator(cl){
      @Override protected void defineFunction(      CAstEntity N,      WalkContext definingContext,      AbstractCFG cfg,      SymbolTable symtab,      boolean hasCatchBlock,      TypeReference[][] caughtTypes,      boolean hasMonitorOp,      AstLexicalInformation LI,      DebuggingInformation debugInfo){
        String fnName=""String_Node_Str"" + composeEntityName(definingContext,N);
        names.add(fnName);
        super.defineFunction(N,definingContext,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo);
      }
      @Override protected void leaveFunctionStmt(      CAstNode n,      WalkContext c,      CAstVisitor<WalkContext> visitor){
        CAstEntity fn=(CAstEntity)n.getChild(0).getValue();
        Scope cs=c.currentScope();
        if (!cs.contains(fn.getName()) || cs.lookup(fn.getName()).getDefiningScope().getEntity().getKind() == CAstEntity.SCRIPT_ENTITY) {
          int result=processFunctionExpr(n,c);
          assignValue(n,c,cs.lookup(fn.getName()),fn.getName(),result);
        }
 else {
          super.leaveFunctionStmt(n,c,visitor);
        }
      }
    }
;
    CAstEntity tree;
    try {
      tree=toCAst.translateToCAst();
      if (DEBUG) {
        CAstPrinter.printTo(tree,new PrintWriter(System.err));
      }
      toIR.translate(tree,M);
      for (      String name : names) {
        IClass fcls=cl.lookupClass(name,cha);
        cha.addClass(fcls);
      }
      return names;
    }
 catch (    Error e) {
      return Collections.emptySet();
    }
  }
 catch (  RuntimeException e) {
    return Collections.emptySet();
  }
}","/** 
 * @param cha
 * @param cl
 * @param fileName
 * @param url
 * @return The set of class names that where defined in the CHA as a resultloading process.
 * @throws IOException
 */
public static Set<String> loadAdditionalFile(IClassHierarchy cha,JavaScriptLoader cl,String fileName,URL url) throws IOException {
  try {
    SourceURLModule M=new SourceURLModule(url);
    TranslatorToCAst toCAst=getTranslatorFactory().make(new CAstImpl(),M);
    final Set<String> names=new HashSet<String>();
    JSAstTranslator toIR=new JSAstTranslator(cl){
      @Override protected void defineFunction(      CAstEntity N,      WalkContext definingContext,      AbstractCFG cfg,      SymbolTable symtab,      boolean hasCatchBlock,      Map<IBasicBlock,TypeReference[]> caughtTypes,      boolean hasMonitorOp,      AstLexicalInformation LI,      DebuggingInformation debugInfo){
        String fnName=""String_Node_Str"" + composeEntityName(definingContext,N);
        names.add(fnName);
        super.defineFunction(N,definingContext,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo);
      }
      @Override protected void leaveFunctionStmt(      CAstNode n,      WalkContext c,      CAstVisitor<WalkContext> visitor){
        CAstEntity fn=(CAstEntity)n.getChild(0).getValue();
        Scope cs=c.currentScope();
        if (!cs.contains(fn.getName()) || cs.lookup(fn.getName()).getDefiningScope().getEntity().getKind() == CAstEntity.SCRIPT_ENTITY) {
          int result=processFunctionExpr(n,c);
          assignValue(n,c,cs.lookup(fn.getName()),fn.getName(),result);
        }
 else {
          super.leaveFunctionStmt(n,c,visitor);
        }
      }
    }
;
    CAstEntity tree;
    try {
      tree=toCAst.translateToCAst();
      if (DEBUG) {
        CAstPrinter.printTo(tree,new PrintWriter(System.err));
      }
      toIR.translate(tree,M);
      for (      String name : names) {
        IClass fcls=cl.lookupClass(name,cha);
        cha.addClass(fcls);
      }
      return names;
    }
 catch (    Error e) {
      return Collections.emptySet();
    }
  }
 catch (  RuntimeException e) {
    return Collections.emptySet();
  }
}",0.9955555555555556
38285,"public JavaScriptMethodObject makeCodeBodyCode(AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,TypeReference[][] caughtTypes,boolean hasMonitorOp,AstLexicalInformation lexicalInfo,DebuggingInformation debugInfo,IClass C){
  return new JavaScriptMethodObject(C,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,lexicalInfo,debugInfo);
}","public JavaScriptMethodObject makeCodeBodyCode(AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,Map<IBasicBlock,TypeReference[]> caughtTypes,boolean hasMonitorOp,AstLexicalInformation lexicalInfo,DebuggingInformation debugInfo,IClass C){
  return new JavaScriptMethodObject(C,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,lexicalInfo,debugInfo);
}",0.972972972972973
38286,"public IMethod defineCodeBodyCode(String clsName,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,TypeReference[][] caughtTypes,boolean hasMonitorOp,AstLexicalInformation lexicalInfo,DebuggingInformation debugInfo){
}","public IMethod defineCodeBodyCode(String clsName,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,Map<IBasicBlock,TypeReference[]> caughtTypes,boolean hasMonitorOp,AstLexicalInformation lexicalInfo,DebuggingInformation debugInfo){
}",0.9591397849462364
38287,"JavaScriptMethodObject(IClass cls,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,TypeReference[][] caughtTypes,boolean hasMonitorOp,AstLexicalInformation lexicalInfo,DebuggingInformation debugInfo){
  super(cls,functionQualifiers,cfg,symtab,AstMethodReference.fnReference(cls.getReference()),hasCatchBlock,caughtTypes,hasMonitorOp,lexicalInfo,debugInfo,null);
  symtab.getNullConstant();
}","JavaScriptMethodObject(IClass cls,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,Map<IBasicBlock,TypeReference[]> caughtTypes,boolean hasMonitorOp,AstLexicalInformation lexicalInfo,DebuggingInformation debugInfo){
  super(cls,functionQualifiers,cfg,symtab,AstMethodReference.fnReference(cls.getReference()),hasCatchBlock,caughtTypes,hasMonitorOp,lexicalInfo,debugInfo,null);
  symtab.getNullConstant();
}",0.976629766297663
38288,"protected void defineFunction(CAstEntity N,WalkContext definingContext,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,TypeReference[][] caughtTypes,boolean hasMonitorOp,AstLexicalInformation LI,DebuggingInformation debugInfo){
  if (DEBUG)   System.err.println((""String_Node_Str"" + N));
  String fnName=composeEntityName(definingContext,N);
  if (DEBUG)   System.err.println(cfg);
  ((JavaScriptLoader)loader).defineCodeBodyCode(""String_Node_Str"" + fnName,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo);
}","protected void defineFunction(CAstEntity N,WalkContext definingContext,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,Map<IBasicBlock,TypeReference[]> caughtTypes,boolean hasMonitorOp,AstLexicalInformation LI,DebuggingInformation debugInfo){
  if (DEBUG)   System.err.println((""String_Node_Str"" + N));
  String fnName=composeEntityName(definingContext,N);
  if (DEBUG)   System.err.println(cfg);
  ((JavaScriptLoader)loader).defineCodeBodyCode(""String_Node_Str"" + fnName,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo);
}",0.9823911028730306
38289,"private void setupCatchTypes(SSACFG cfg,TypeReference[][] catchTypes){
  for (int i=0; i < catchTypes.length; i++) {
    if (catchTypes[i] != null) {
      ExceptionHandlerBasicBlock bb=(ExceptionHandlerBasicBlock)cfg.getNode(i);
      for (int j=0; j < catchTypes[i].length; j++) {
        bb.addCaughtExceptionType(catchTypes[i][j]);
      }
    }
  }
}","private void setupCatchTypes(SSACFG cfg,Map<IBasicBlock,TypeReference[]> map){
  for (  Map.Entry<IBasicBlock,TypeReference[]> e : map.entrySet()) {
    if (e.getKey().getNumber() != -1) {
      ExceptionHandlerBasicBlock bb=(ExceptionHandlerBasicBlock)cfg.getNode(e.getKey().getNumber());
      for (int j=0; j < e.getValue().length; j++) {
        bb.addCaughtExceptionType(e.getValue()[j]);
      }
    }
  }
}",0.6432291666666666
38290,"/** 
 * When adding an edge from source to target, it is possible that certain exception-handling code needs to be executed before the control is actually transfered to target. This method determines if this is the case, and if so, it generates the exception handler blocks and adds an appropriate edge to the target. It returns the basic block that should be the target of the edge from source (target itself if there is no exception-handling code, the initial catch block otherwise)
 */
public PreBasicBlock findOrCreateCode(PreBasicBlock source,PreBasicBlock target,final boolean exception){
  UnwindState sourceContext=unwindData.get(source);
  final CAstNode dummy=exception ? (new CAstImpl()).makeNode(CAstNode.EMPTY) : null;
  if (sourceContext == null)   return target;
  WalkContext astContext=sourceContext.astContext;
  UnwindState targetContext=null;
  if (target != null)   targetContext=unwindData.get(target);
  if (targetContext != null && targetContext.covers(sourceContext))   return target;
  Pair<UnwindState,Pair<PreBasicBlock,Boolean>> key=Pair.make(sourceContext,Pair.make(target,exception));
  if (code.containsKey(key)) {
    return code.get(key);
  }
 else {
    int e=-1;
    PreBasicBlock currentBlock=getCurrentBlock();
    if (!isDeadBlock(currentBlock)) {
      addInstruction(insts.GotoInstruction());
      newBlock(false);
    }
    PreBasicBlock startBlock=getCurrentBlock();
    if (exception) {
      setCurrentBlockAsHandler();
      e=sourceContext.astContext.currentScope().allocateTempValue();
      addInstruction(insts.GetCaughtExceptionInstruction(startBlock.getNumber(),e));
      sourceContext.astContext.setCatchType(startBlock.getNumber(),defaultCatchType());
    }
    while (sourceContext != null && (targetContext == null || !targetContext.covers(sourceContext))) {
      final CAstRewriter.Rewrite ast=(new CAstCloner(new CAstImpl()){
        protected CAstNode flowOutTo(        Map<Pair<CAstNode,NoKey>,CAstNode> nodeMap,        CAstNode oldSource,        Object label,        CAstNode oldTarget,        CAstControlFlowMap orig,        CAstSourcePositionMap src){
          if (exception && !isExceptionLabel(label)) {
            return dummy;
          }
 else {
            return oldTarget;
          }
        }
      }
).copy(sourceContext.unwindAst,sourceContext.astContext.getControlFlow(),sourceContext.astContext.getSourceMap(),sourceContext.astContext.top().getNodeTypeMap(),sourceContext.astContext.top().getAllScopedEntities());
      sourceContext.astVisitor.visit(ast.newRoot(),new DelegatingContext(sourceContext.astContext){
        public CAstSourcePositionMap getSourceMap(){
          return ast.newPos();
        }
        public CAstControlFlowMap getControlFlow(){
          return ast.newCfg();
        }
      }
,sourceContext.astVisitor);
      sourceContext=sourceContext.getParent();
    }
    PreBasicBlock endBlock=getCurrentBlock();
    if (exception) {
      addPreNode(dummy);
      doThrow(astContext,e);
    }
 else {
      addInstruction(insts.GotoInstruction());
    }
    newBlock(false);
    addEdge(currentBlock,getCurrentBlock());
    if (target != null) {
      addEdge(endBlock,target);
    }
 else {
      addDelayedEdge(endBlock,exitMarker,exception);
    }
    code.put(key,startBlock);
    return startBlock;
  }
}","/** 
 * When adding an edge from source to target, it is possible that certain exception-handling code needs to be executed before the control is actually transfered to target. This method determines if this is the case, and if so, it generates the exception handler blocks and adds an appropriate edge to the target. It returns the basic block that should be the target of the edge from source (target itself if there is no exception-handling code, the initial catch block otherwise)
 */
public PreBasicBlock findOrCreateCode(PreBasicBlock source,PreBasicBlock target,final boolean exception){
  UnwindState sourceContext=unwindData.get(source);
  final CAstNode dummy=exception ? (new CAstImpl()).makeNode(CAstNode.EMPTY) : null;
  if (sourceContext == null)   return target;
  WalkContext astContext=sourceContext.astContext;
  UnwindState targetContext=null;
  if (target != null)   targetContext=unwindData.get(target);
  if (targetContext != null && targetContext.covers(sourceContext))   return target;
  Pair<UnwindState,Pair<PreBasicBlock,Boolean>> key=Pair.make(sourceContext,Pair.make(target,exception));
  if (code.containsKey(key)) {
    return code.get(key);
  }
 else {
    int e=-1;
    PreBasicBlock currentBlock=getCurrentBlock();
    if (!isDeadBlock(currentBlock)) {
      addInstruction(insts.GotoInstruction());
      newBlock(false);
    }
    PreBasicBlock startBlock=getCurrentBlock();
    if (exception) {
      setCurrentBlockAsHandler();
      e=sourceContext.astContext.currentScope().allocateTempValue();
      addInstruction(insts.GetCaughtExceptionInstruction(startBlock.getNumber(),e));
      sourceContext.astContext.setCatchType(startBlock,defaultCatchType());
    }
    while (sourceContext != null && (targetContext == null || !targetContext.covers(sourceContext))) {
      final CAstRewriter.Rewrite ast=(new CAstCloner(new CAstImpl()){
        protected CAstNode flowOutTo(        Map<Pair<CAstNode,NoKey>,CAstNode> nodeMap,        CAstNode oldSource,        Object label,        CAstNode oldTarget,        CAstControlFlowMap orig,        CAstSourcePositionMap src){
          if (exception && !isExceptionLabel(label)) {
            return dummy;
          }
 else {
            return oldTarget;
          }
        }
      }
).copy(sourceContext.unwindAst,sourceContext.astContext.getControlFlow(),sourceContext.astContext.getSourceMap(),sourceContext.astContext.top().getNodeTypeMap(),sourceContext.astContext.top().getAllScopedEntities());
      sourceContext.astVisitor.visit(ast.newRoot(),new DelegatingContext(sourceContext.astContext){
        public CAstSourcePositionMap getSourceMap(){
          return ast.newPos();
        }
        public CAstControlFlowMap getControlFlow(){
          return ast.newCfg();
        }
      }
,sourceContext.astVisitor);
      sourceContext=sourceContext.getParent();
    }
    PreBasicBlock endBlock=getCurrentBlock();
    if (exception) {
      addPreNode(dummy);
      doThrow(astContext,e);
    }
 else {
      addInstruction(insts.GotoInstruction());
    }
    newBlock(false);
    addEdge(currentBlock,getCurrentBlock());
    if (target != null) {
      addEdge(endBlock,target);
    }
 else {
      addDelayedEdge(endBlock,exitMarker,exception);
    }
    code.put(key,startBlock);
    return startBlock;
  }
}",0.99818676337262
38291,"/** 
 * fully define a function. invoked after all the code of the function has been processed
 */
protected abstract void defineFunction(CAstEntity N,WalkContext definingContext,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,TypeReference[][] caughtTypes,boolean hasMonitorOp,AstLexicalInformation lexicalInfo,DebuggingInformation debugInfo);","/** 
 * fully define a function. invoked after all the code of the function has been processed
 */
protected abstract void defineFunction(CAstEntity N,WalkContext definingContext,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,Map<IBasicBlock,TypeReference[]> catchTypes,boolean hasMonitorOp,AstLexicalInformation lexicalInfo,DebuggingInformation debugInfo);",0.9555555555555556
38292,"public TypeReference[][] getCatchTypes(){
  return null;
}","public Map<IBasicBlock,TypeReference[]> getCatchTypes(){
  return null;
}",0.8549618320610687
38293,"public void closeFunctionEntity(final CAstEntity n,WalkContext parentContext,WalkContext functionContext){
  functionContext.cfg().makeExitBlock(functionContext.cfg().newBlock(true));
  SymbolTable symtab=((AbstractScope)functionContext.currentScope()).getUnderlyingSymtab();
  TypeReference[][] catchTypes=functionContext.getCatchTypes();
  AstCFG cfg=new AstCFG(n,functionContext.cfg(),symtab);
  Position[] line=functionContext.cfg().getLinePositionMap();
  boolean katch=functionContext.cfg().hasCatchBlock();
  boolean monitor=functionContext.cfg().hasMonitorOp();
  String[] nms=makeNameMap(n,functionContext.entityScopes());
  patchLexicalAccesses(cfg.getInstructions(),functionContext.getAccesses(n));
  AstLexicalInformation LI=new AstLexicalInformation(functionContext.getEntityName(n),(AbstractScope)functionContext.currentScope(),cfg.getInstructions(),functionContext.exposeNameSet(n,false),functionContext.exposeNameSet(n,true),functionContext.getAccesses(n));
  DebuggingInformation DBG=new AstDebuggingInformation(n.getPosition(),line,nms);
  defineFunction(n,parentContext,cfg,symtab,katch,catchTypes,monitor,LI,DBG);
}","public void closeFunctionEntity(final CAstEntity n,WalkContext parentContext,WalkContext functionContext){
  functionContext.cfg().makeExitBlock(functionContext.cfg().newBlock(true));
  SymbolTable symtab=((AbstractScope)functionContext.currentScope()).getUnderlyingSymtab();
  Map<IBasicBlock,TypeReference[]> catchTypes=functionContext.getCatchTypes();
  AstCFG cfg=new AstCFG(n,functionContext.cfg(),symtab);
  Position[] line=functionContext.cfg().getLinePositionMap();
  boolean katch=functionContext.cfg().hasCatchBlock();
  boolean monitor=functionContext.cfg().hasMonitorOp();
  String[] nms=makeNameMap(n,functionContext.entityScopes());
  patchLexicalAccesses(cfg.getInstructions(),functionContext.getAccesses(n));
  AstLexicalInformation LI=new AstLexicalInformation(functionContext.getEntityName(n),(AbstractScope)functionContext.currentScope(),cfg.getInstructions(),functionContext.exposeNameSet(n,false),functionContext.exposeNameSet(n,true),functionContext.getAccesses(n));
  DebuggingInformation DBG=new AstDebuggingInformation(n.getPosition(),line,nms);
  defineFunction(n,parentContext,cfg,symtab,katch,catchTypes,monitor,LI,DBG);
}",0.9916849015317286
38294,"@TestAnnotation(doSomething=""String_Node_Str"",count=1,date=""String_Node_Str"") public void mymethod(){
}","@TestAnnotation(doSomething=""String_Node_Str"",count=1,date=""String_Node_Str"",stuff={}) public int mymethod(){
  @AnotherTestAnnotation(""String_Node_Str"") int i=0;
  return i;
}",0.7168458781362007
38295,"@TestAnnotation(doSomething=""String_Node_Str"",count=0,date=""String_Node_Str"") public static void main(String[] args){
  (new Annotations()).mymethod();
}","@TestAnnotation(doSomething=""String_Node_Str"",count=0,date=""String_Node_Str"",stuff={1,2,3,4,5}) public static void main(String[] args){
  (new Annotations()).mymethod();
}",0.9444444444444444
38296,"public void check(CallGraph cg){
  classes:   for (  ClassAnnotation ca : classAnnotations) {
    IClass cls=cg.getClassHierarchy().lookupClass(TypeReference.findOrCreate(ClassLoaderReference.Application,ca.className));
    IClass at=cg.getClassHierarchy().lookupClass(TypeReference.findOrCreate(ClassLoaderReference.Application,ca.annotationTypeName));
    for (    Annotation a : cls.getAnnotations()) {
      if (a.getType().equals(at.getReference())) {
        continue classes;
      }
    }
    Assert.assertFalse(""String_Node_Str"" + at + ""String_Node_Str""+ cls,false);
  }
  for (  MethodAnnotation ma : methodAnnotations) {
    IClass at=cg.getClassHierarchy().lookupClass(TypeReference.findOrCreate(ClassLoaderReference.Application,ma.annotationTypeName));
    annot:     for (    CGNode n : cg) {
      if (n.getMethod().getSignature().equals(ma.methodSig)) {
        for (        Annotation a : n.getMethod().getAnnotations()) {
          if (a.getType().equals(at.getReference())) {
            continue annot;
          }
        }
        Assert.assertFalse(""String_Node_Str"" + at,false);
      }
    }
  }
}","public void check(CallGraph cg){
  classes:   for (  ClassAnnotation ca : classAnnotations) {
    IClass cls=cg.getClassHierarchy().lookupClass(TypeReference.findOrCreate(ClassLoaderReference.Application,ca.className));
    IClass at=cg.getClassHierarchy().lookupClass(TypeReference.findOrCreate(ClassLoaderReference.Application,ca.annotationTypeName));
    for (    Annotation a : cls.getAnnotations()) {
      if (a.getType().equals(at.getReference())) {
        continue classes;
      }
    }
    Assert.assertFalse(""String_Node_Str"" + at + ""String_Node_Str""+ cls,false);
  }
  annot:   for (  MethodAnnotation ma : methodAnnotations) {
    IClass at=cg.getClassHierarchy().lookupClass(TypeReference.findOrCreate(ClassLoaderReference.Application,ma.annotationTypeName));
    for (    CGNode n : cg) {
      if (n.getMethod().getSignature().equals(ma.methodSig)) {
        for (        Annotation a : n.getMethod().getAnnotations()) {
          if (a.getType().equals(at.getReference())) {
            continue annot;
          }
        }
        Assert.assertFalse(""String_Node_Str"" + at,false);
      }
    }
  }
}",0.9910793933987512
38297,"protected CAstEntity parseJS(CAstImpl ast,SourceModule module) throws IOException {
  RhinoToAstTranslator translator=new RhinoToAstTranslator(ast,module,module.getName(),false);
  CAstEntity entity=translator.translateToCAst();
  return entity;
}","protected CAstEntity parseJS(CAstImpl ast,SourceModule module) throws IOException {
}",0.5120481927710844
38298,"protected CAstEntity parseJS(CAstImpl ast,SourceModule module) throws IOException {
  RhinoToAstTranslator translator=new RhinoToAstTranslator(ast,module,module.getName(),false);
  CAstEntity entity=translator.translateToCAst();
  return entity;
}","protected CAstEntity parseJS(CAstImpl ast,SourceModule module) throws IOException {
}",0.5120481927710844
38299,"public static void main(String args[]) throws ClassHierarchyException, IllegalArgumentException, IOException, CancelException {
  if (args.length != 1) {
    System.out.println(""String_Node_Str"");
    System.exit(1);
  }
  boolean domless=false;
  URL url=new URL(args[0]);
  JSCallGraphBuilderUtil.setTranslatorFactory(new CAstRhinoTranslatorFactory());
  JavaScriptLoader.addBootstrapFile(WebUtil.preamble);
  SourceModule[] sources=getSources(domless,url);
  JSCFABuilder builder=makeCGBuilder(new WebPageLoaderFactory(translatorFactory),sources,CGBuilderType.ZERO_ONE_CFA,AstIRFactory.makeDefaultFactory());
  builder.setBaseURL(url);
  CallGraph cg=builder.makeCallGraph(builder.getOptions());
  PointerAnalysis pa=builder.getPointerAnalysis();
  new JsViewer(cg,pa);
}","public static void main(String args[]) throws ClassHierarchyException, IllegalArgumentException, IOException, CancelException, Error {
  if (args.length != 1) {
    System.out.println(""String_Node_Str"");
    System.exit(1);
  }
  boolean domless=false;
  URL url=new URL(args[0]);
  JSCallGraphBuilderUtil.setTranslatorFactory(new CAstRhinoTranslatorFactory());
  JavaScriptLoader.addBootstrapFile(WebUtil.preamble);
  SourceModule[] sources=getSources(domless,url);
  JSCFABuilder builder=makeCGBuilder(new WebPageLoaderFactory(translatorFactory),sources,CGBuilderType.ZERO_ONE_CFA,AstIRFactory.makeDefaultFactory());
  builder.setBaseURL(url);
  CallGraph cg=builder.makeCallGraph(builder.getOptions());
  PointerAnalysis pa=builder.getPointerAnalysis();
  new JsViewer(cg,pa);
}",0.9954983922829582
38300,"private static SourceModule[] getSources(boolean domless,URL url) throws IOException {
  JSSourceExtractor sourceExtractor;
  if (domless) {
    sourceExtractor=new DomLessSourceExtractor();
  }
 else {
    sourceExtractor=new DefaultSourceExtractor();
  }
  Set<MappedSourceModule> sourcesMap=sourceExtractor.extractSources(url,new JerichoHtmlParser(),new IdentityUrlResolver());
  SourceModule[] sources=new SourceFileModule[sourcesMap.size()];
  int i=0;
  for (  SourceModule m : sourcesMap) {
    sources[i++]=m;
  }
  return sources;
}","private static SourceModule[] getSources(boolean domless,URL url) throws IOException, Error {
  JSSourceExtractor sourceExtractor;
  if (domless) {
    sourceExtractor=new DomLessSourceExtractor();
  }
 else {
    sourceExtractor=new DefaultSourceExtractor();
  }
  Set<MappedSourceModule> sourcesMap=sourceExtractor.extractSources(url,new JerichoHtmlParser(),new IdentityUrlResolver());
  SourceModule[] sources=new SourceFileModule[sourcesMap.size()];
  int i=0;
  for (  SourceModule m : sourcesMap) {
    sources[i++]=m;
  }
  return sources;
}",0.9935720844811754
38301,"public void copyState(BitVectorVariable other){
  if (other == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (V == null) {
    if (other.V == null) {
      return;
    }
 else {
      V=new MutableSharedBitVectorIntSet(other.V);
      return;
    }
  }
  if (other.V != null) {
    V.copySet(other.V);
  }
}","public void copyState(BitVectorVariable other){
  if (other == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (V == null) {
    if (other.V == null) {
      return;
    }
 else {
      V=new MutableSharedBitVectorIntSet(other.V);
      return;
    }
  }
  if (other.V != null) {
    V.copySet(other.V);
  }
 else {
    V=null;
  }
}",0.9627507163323782
38302,"/** 
 * Properly creates the String file name of a   {@link URL}. This works around a bug in the Sun implementation of   {@link URL#getFile()}, which doesn't properly handle file paths with spaces (see <a href= ""http://sourceforge.net/tracker/index.php?func=detail&aid=1565842&group_id=176742&atid=878458"" >bug report</a>). For now, fails with an assertion if the url is malformed.
 * @param url
 * @return the path name for the url
 * @throws IllegalArgumentException if url is null
 */
public String filePathFromURL(URL url){
  if (url == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  URI uri=new File(url.getPath()).toURI();
  String filePath=uri.getPath();
  return filePath;
}","/** 
 * Properly creates the String file name of a   {@link URL}. This works around a bug in the Sun implementation of   {@link URL#getFile()}, which doesn't properly handle file paths with spaces (see <a href= ""http://sourceforge.net/tracker/index.php?func=detail&aid=1565842&group_id=176742&atid=878458"" >bug report</a>). For now, fails with an assertion if the url is malformed.
 * @param url
 * @return the path name for the url
 * @throws IllegalArgumentException if url is null
 */
public String filePathFromURL(URL url){
  if (url == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  URI uri=new File(url.getPath()).toURI();
  try {
    return URLDecoder.decode(uri.getPath(),""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
    Assertions.UNREACHABLE();
    return null;
  }
}",0.8748370273794003
38303,"/** 
 * Properly creates the String file name of a   {@link URL}. This works around a bug in the Sun implementation of   {@link URL#getFile()}, which doesn't properly handle file paths with spaces (see <a href= ""http://sourceforge.net/tracker/index.php?func=detail&aid=1565842&group_id=176742&atid=878458"" >bug report</a>). For now, fails with an assertion if the url is malformed.
 * @param url
 * @return the path name for the url
 * @throws IllegalArgumentException if url is null
 */
public String filePathFromURL(URL url){
  if (url == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  URI uri=new File(url.getPath()).toURI();
  try {
    return URLDecoder.decode(uri.getPath(),""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
    Assertions.UNREACHABLE();
    return null;
  }
}","/** 
 * Properly creates the String file name of a   {@link URL}. This works around a bug in the Sun implementation of   {@link URL#getFile()}, which doesn't properly handle file paths with spaces (see <a href= ""http://sourceforge.net/tracker/index.php?func=detail&aid=1565842&group_id=176742&atid=878458"" >bug report</a>). For now, fails with an assertion if the url is malformed.
 * @param url
 * @return the path name for the url
 * @throws IllegalArgumentException if url is null
 */
public String filePathFromURL(URL url){
  if (url == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  try {
    URI uri=new File(URLDecoder.decode(url.getPath(),""String_Node_Str"")).toURI();
    return uri.getPath();
  }
 catch (  UnsupportedEncodingException e) {
    Assertions.UNREACHABLE();
    return null;
  }
}",0.9455864570737604
38304,"@Override public byte evaluate(final BitVectorVariable lhs,final BitVectorVariable[] rhs){
  IntSet intersect=lhs.getValue();
  if (intersect == null || intersect.isEmpty()) {
    return NOT_CHANGED_AND_FIXED;
  }
  for (  final BitVectorVariable bv : rhs) {
    final IntSet vlhs=bv.getValue();
    intersect=intersect.intersection(vlhs);
  }
  if (intersect.sameValue(lhs.getValue())) {
    return NOT_CHANGED;
  }
 else {
    final BitVectorVariable bvv=new BitVectorVariable();
    intersect.foreach(new IntSetAction(){
      @Override public void act(      final int x){
        bvv.set(x);
      }
    }
);
    lhs.copyState(bvv);
    return CHANGED;
  }
}","@Override public byte evaluate(final BitVectorVariable lhs,final BitVectorVariable[] rhs){
  IntSet intersect=lhs.getValue();
  if (intersect == null || intersect.isEmpty()) {
    intersect=rhs[0].getValue();
  }
  for (  final BitVectorVariable bv : rhs) {
    final IntSet vlhs=bv.getValue();
    intersect=intersect.intersection(vlhs);
  }
  if (lhs.getValue() != null && intersect.sameValue(lhs.getValue())) {
    return NOT_CHANGED;
  }
 else {
    final BitVectorVariable bvv=new BitVectorVariable();
    intersect.foreach(new IntSetAction(){
      @Override public void act(      final int x){
        bvv.set(x);
      }
    }
);
    lhs.copyState(bvv);
    return CHANGED;
  }
}",0.3261675315048183
38305,"private int passActualPropertyValsAsParams(JSInstructionFactory insts,int nargs,JavaScriptSummary S,int[] paramsToPassToInvoked){
  int curValNum=nargs + 2;
  for (int i=1; i < paramsToPassToInvoked.length; i++) {
    final int constVN=curValNum++;
    S.addConstant(constVN,new ConstantValue(i - 1));
    int propertyReadResult=curValNum++;
    S.addStatement(insts.PropertyRead(propertyReadResult,4,constVN));
    paramsToPassToInvoked[i]=propertyReadResult;
  }
  return curValNum;
}","private int passActualPropertyValsAsParams(JSInstructionFactory insts,int nargs,JavaScriptSummary S,int[] paramsToPassToInvoked){
  int curValNum=nargs + 2;
  for (int i=1; i < paramsToPassToInvoked.length; i++) {
    final int constVN=curValNum++;
    S.addConstant(constVN,new ConstantValue(i - 1));
    int propertyReadResult=curValNum++;
    S.addStatement(insts.PropertyRead(propertyReadResult,4,constVN));
    S.getNextProgramCounter();
    paramsToPassToInvoked[i]=propertyReadResult;
  }
  return curValNum;
}",0.9690927218344964
38306,"@Override public void run(){
  try {
    boolean repeat=true;
    while (repeat) {
      try {
        Thread.sleep(SLEEP_MS);
      }
 catch (      InterruptedException e1) {
      }
      drain();
      try {
        p.exitValue();
        repeat=false;
        drain();
        if (logger != null) {
          logger.fine(""String_Node_Str"" + p.exitValue());
        }
      }
 catch (      IllegalThreadStateException e) {
        repeat=true;
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","@Override public void run(){
  try {
    boolean repeat=true;
    while (repeat) {
      try {
        Thread.sleep(SLEEP_MS);
      }
 catch (      InterruptedException e1) {
      }
      drain();
      try {
        p.exitValue();
        repeat=false;
        blockingDrain();
        if (logger != null) {
          logger.fine(""String_Node_Str"" + p.exitValue());
        }
      }
 catch (      IllegalThreadStateException e) {
        repeat=true;
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.9904942965779469
38307,abstract void drain() throws IOException ;,"/** 
 * Drain data from the stream, but don't block.
 */
abstract void drain() throws IOException ;",0.5957446808510638
38308,"protected Drainer captureStdErr(Process p){
  final BufferedInputStream out=new BufferedInputStream(p.getErrorStream(),BUFFER_SIZE);
  final ByteArrayOutputStream b=new ByteArrayOutputStream(BUFFER_SIZE);
  Drainer result=new Drainer(p){
    @Override void drain() throws IOException {
      drainAndCatch(out,b);
    }
  }
;
  result.setCapture(b);
  result.start();
  return result;
}","protected Drainer captureStdErr(Process p){
  final BufferedInputStream out=new BufferedInputStream(p.getErrorStream(),BUFFER_SIZE);
  final ByteArrayOutputStream b=new ByteArrayOutputStream(BUFFER_SIZE);
  Drainer result=new Drainer(p){
    @Override void drain() throws IOException {
      drainAndCatch(out,b);
    }
    @Override void blockingDrain() throws IOException {
      blockingDrainAndCatch(out,b);
    }
  }
;
  result.setCapture(b);
  result.start();
  return result;
}",0.8873563218390804
38309,"private void drainAndCatch(BufferedInputStream s,ByteArrayOutputStream b) throws IOException {
  try {
    while (s.available() > 0) {
      byte[] data=new byte[s.available()];
      int nRead=s.read(data);
      b.write(data,0,nRead);
    }
  }
 catch (  IOException e) {
  }
}","/** 
 * Drain some data from the input stream, and append said data to b.  Do not block.
 */
private void drainAndCatch(BufferedInputStream s,ByteArrayOutputStream b) throws IOException {
  try {
    while (s.available() > 0) {
      byte[] data=new byte[s.available()];
      int nRead=s.read(data);
      b.write(data,0,nRead);
    }
  }
 catch (  IOException e) {
  }
}",0.8571428571428571
38310,"protected Thread drainStdErr(Process p){
  final BufferedInputStream err=new BufferedInputStream(p.getErrorStream(),BUFFER_SIZE);
  Thread result=new Drainer(p){
    @Override void drain() throws IOException {
      drainAndPrint(err,System.err);
    }
  }
;
  result.start();
  return result;
}","protected Thread drainStdErr(Process p){
  final BufferedInputStream err=new BufferedInputStream(p.getErrorStream(),BUFFER_SIZE);
  Thread result=new Drainer(p){
    @Override void drain() throws IOException {
      drainAndPrint(err,System.err);
    }
    @Override void blockingDrain() throws IOException {
      blockingDrainAndPrint(err,System.err);
    }
  }
;
  result.start();
  return result;
}",0.8464849354375896
38311,"protected Thread drainStdOut(Process p){
  final BufferedInputStream out=new BufferedInputStream(p.getInputStream(),BUFFER_SIZE);
  Thread result=new Drainer(p){
    @Override void drain() throws IOException {
      drainAndPrint(out,System.out);
    }
  }
;
  result.start();
  return result;
}","protected Thread drainStdOut(Process p){
  final BufferedInputStream out=new BufferedInputStream(p.getInputStream(),BUFFER_SIZE);
  Thread result=new Drainer(p){
    @Override void drain() throws IOException {
      drainAndPrint(out,System.out);
    }
    @Override void blockingDrain() throws IOException {
      blockingDrainAndPrint(out,System.out);
    }
  }
;
  result.start();
  return result;
}",0.8464849354375896
38312,"protected Drainer captureStdOut(Process p){
  final BufferedInputStream out=new BufferedInputStream(p.getInputStream(),BUFFER_SIZE);
  final ByteArrayOutputStream b=new ByteArrayOutputStream(BUFFER_SIZE);
  Drainer result=new Drainer(p){
    @Override void drain() throws IOException {
      drainAndCatch(out,b);
    }
  }
;
  result.setCapture(b);
  result.start();
  return result;
}","protected Drainer captureStdOut(Process p){
  final BufferedInputStream out=new BufferedInputStream(p.getInputStream(),BUFFER_SIZE);
  final ByteArrayOutputStream b=new ByteArrayOutputStream(BUFFER_SIZE);
  Drainer result=new Drainer(p){
    @Override void drain() throws IOException {
      drainAndCatch(out,b);
    }
    @Override void blockingDrain() throws IOException {
      blockingDrainAndCatch(out,b);
    }
  }
;
  result.setCapture(b);
  result.start();
  return result;
}",0.8873563218390804
38313,"private void drainAndPrint(BufferedInputStream s,PrintStream p) throws IOException {
  try {
    while (s.available() > 0) {
      byte[] data=new byte[s.available()];
      s.read(data);
      p.print(new String(data));
    }
  }
 catch (  IOException e) {
  }
}","/** 
 * Drain some data from the input stream, and print said data to p.  Do not block.
 */
private void drainAndPrint(BufferedInputStream s,PrintStream p) throws IOException {
  try {
    while (s.available() > 0) {
      byte[] data=new byte[s.available()];
      s.read(data);
      p.print(new String(data));
    }
  }
 catch (  IOException e) {
  }
}",0.8511326860841424
38314,"/** 
 * Process an element indicating a new allocation site.
 * @param atts
 */
private void processAllocation(Attributes atts){
  Language lang=scope.getLanguage(governingLoader.getLanguage());
  SSAInstructionFactory insts=lang.instructionFactory();
  String classString=atts.getValue(A_CLASS);
  final TypeReference type=TypeReference.findOrCreate(governingLoader,TypeName.string2TypeName(classString));
  String defVar=atts.getValue(A_DEF);
  if (symbolTable.keySet().contains(defVar)) {
    Assertions.UNREACHABLE(""String_Node_Str"" + defVar + ""String_Node_Str""+ governingMethod);
  }
  if (defVar == null) {
    defVar=""String_Node_Str"" + nextLocal;
  }
  int defNum=nextLocal;
  symbolTable.put(defVar,new Integer(nextLocal++));
  NewSiteReference ref=NewSiteReference.make(governingMethod.getNextProgramCounter(),type);
  SSANewInstruction a=null;
  if (type.isArrayType()) {
    String size=atts.getValue(A_SIZE);
    Assertions.productionAssertion(size != null);
    Integer sNumber=symbolTable.get(size);
    Assertions.productionAssertion(sNumber != null);
    Assertions.productionAssertion(type.getDerivedMask() == ArrayMask || type.getDerivedMask() == ((ArrayMask << 2) | PrimitiveMask));
    a=insts.NewInstruction(defNum,ref,new int[]{sNumber.intValue()});
  }
 else {
    a=insts.NewInstruction(defNum,ref);
  }
  governingMethod.addStatement(a);
}","/** 
 * Process an element indicating a new allocation site.
 * @param atts
 */
private void processAllocation(Attributes atts){
  Language lang=scope.getLanguage(governingLoader.getLanguage());
  SSAInstructionFactory insts=lang.instructionFactory();
  String classString=atts.getValue(A_CLASS);
  final TypeReference type=TypeReference.findOrCreate(governingLoader,TypeName.string2TypeName(classString));
  String defVar=atts.getValue(A_DEF);
  if (symbolTable.keySet().contains(defVar)) {
    Assertions.UNREACHABLE(""String_Node_Str"" + defVar + ""String_Node_Str""+ governingMethod);
  }
  if (defVar == null) {
    defVar=""String_Node_Str"" + nextLocal;
  }
  int defNum=nextLocal;
  symbolTable.put(defVar,new Integer(nextLocal++));
  NewSiteReference ref=NewSiteReference.make(governingMethod.getNextProgramCounter(),type);
  SSANewInstruction a=null;
  if (type.isArrayType()) {
    String size=atts.getValue(A_SIZE);
    Assertions.productionAssertion(size != null);
    Integer sNumber=symbolTable.get(size);
    Assertions.productionAssertion(sNumber != null);
    Assertions.productionAssertion(type.getDerivedMask() == ArrayMask || type.getDerivedMask() == ((ArrayMask << ElementBits) | PrimitiveMask));
    a=insts.NewInstruction(defNum,ref,new int[]{sNumber.intValue()});
  }
 else {
    a=insts.NewInstruction(defNum,ref);
  }
  governingMethod.addStatement(a);
}",0.9956204379562044
38315,"/** 
 * @throws FileNotFoundException
 */
public static File getFileFromClassLoader(String fileName,ClassLoader loader) throws FileNotFoundException {
  if (loader == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  URL url=loader.getResource(fileName);
  if (DEBUG_LEVEL > 0) {
    System.err.println((""String_Node_Str"" + url + ""String_Node_Str""+ fileName));
  }
  if (url == null) {
    File f=new File(fileName);
    if (f.exists()) {
      return f;
    }
    throw new FileNotFoundException(fileName);
  }
 else {
    return new File(filePathFromURL(url));
  }
}","/** 
 * @throws FileNotFoundException
 */
public static File getFileFromClassLoader(String fileName,ClassLoader loader) throws FileNotFoundException {
  if (loader == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  URL url=null;
  try {
    url=loader.getResource(fileName);
  }
 catch (  Exception e) {
  }
  if (DEBUG_LEVEL > 0) {
    System.err.println((""String_Node_Str"" + url + ""String_Node_Str""+ fileName));
  }
  if (url == null) {
    File f=new File(fileName);
    if (f.exists()) {
      return f;
    }
    throw new FileNotFoundException(fileName);
  }
 else {
    return new File(filePathFromURL(url));
  }
}",0.96113074204947
38316,"protected void iterateCrossProduct(final CGNode caller,final CallSiteReference site,IntSet parameters,final InstanceKey[][] invariants,final VoidFunction<InstanceKey[]> f){
  final IR ir=caller.getIR();
  final int params[]=IntSetUtil.toArray(parameters);
  for (  final SSAAbstractInvokeInstruction call : ir.getCalls(site)) {
    final InstanceKey[] keys=new InstanceKey[call.getNumberOfParameters()];
    new Object(){
      private void rec(      final int pi){
        if (pi == params.length) {
          f.apply(keys);
        }
 else {
          final int p=params[pi];
          int vn=call.getUse(p);
          PointerKey var=getPointerKeyForLocal(caller,vn);
          InstanceKey[] ik=invariants != null ? invariants[p] : null;
          if (ik != null) {
            if (ik.length > 0) {
              for (int i=0; i < ik.length; i++) {
                system.findOrCreateIndexForInstanceKey(ik[i]);
                keys[p]=ik[i];
                rec(pi + 1);
              }
            }
 else {
              if (!site.isDispatch() || p != 0) {
                keys[p]=null;
                rec(pi + 1);
              }
            }
          }
 else {
            IntSet s=system.findOrCreatePointsToSet(var).getValue();
            if (s != null && !s.isEmpty()) {
              s.foreach(new IntSetAction(){
                public void act(                int x){
                  keys[p]=system.getInstanceKey(x);
                  rec(pi + 1);
                }
              }
);
            }
 else {
              if (!site.isDispatch() || p != 0) {
                keys[p]=null;
                rec(pi + 1);
              }
            }
          }
        }
      }
    }
.rec(0);
  }
}","protected void iterateCrossProduct(final CGNode caller,final SSAAbstractInvokeInstruction call,IntSet parameters,final InstanceKey[][] invariants,final VoidFunction<InstanceKey[]> f){
  final int params[]=IntSetUtil.toArray(parameters);
  final InstanceKey[] keys=new InstanceKey[call.getNumberOfParameters()];
  final CallSiteReference site=call.getCallSite();
  new Object(){
    private void rec(    final int pi){
      if (pi == params.length) {
        f.apply(keys);
      }
 else {
        final int p=params[pi];
        int vn=call.getUse(p);
        PointerKey var=getPointerKeyForLocal(caller,vn);
        InstanceKey[] ik=invariants != null ? invariants[p] : null;
        if (ik != null) {
          if (ik.length > 0) {
            for (int i=0; i < ik.length; i++) {
              system.findOrCreateIndexForInstanceKey(ik[i]);
              keys[p]=ik[i];
              rec(pi + 1);
            }
          }
 else {
            if (!site.isDispatch() || p != 0) {
              keys[p]=null;
              rec(pi + 1);
            }
          }
        }
 else {
          IntSet s=system.findOrCreatePointsToSet(var).getValue();
          if (s != null && !s.isEmpty()) {
            s.foreach(new IntSetAction(){
              public void act(              int x){
                keys[p]=system.getInstanceKey(x);
                rec(pi + 1);
              }
            }
);
          }
 else {
            if (!site.isDispatch() || p != 0) {
              keys[p]=null;
              rec(pi + 1);
            }
          }
        }
      }
    }
  }
.rec(0);
}",0.8460606060606061
38317,"protected void visitInvokeInternal(final SSAAbstractInvokeInstruction instruction,InvariantComputer invs){
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + instruction);
  }
  PointerKey uniqueCatch=null;
  if (hasUniqueCatchBlock(instruction,ir)) {
    uniqueCatch=getBuilder().getUniqueCatchKey(instruction,ir,node);
  }
  InstanceKey[][] invariantParameters=invs.computeInvariantParameters(instruction);
  if (instruction.getCallSite().isStatic()) {
    for (    CGNode n : getBuilder().getTargetsForCall(node,instruction.getCallSite(),invariantParameters)) {
      getBuilder().processResolvedCall(node,instruction,n,invariantParameters,uniqueCatch);
      if (DEBUG) {
        System.err.println(""String_Node_Str"" + n);
      }
      processClassInitializer(n.getMethod().getDeclaringClass());
    }
  }
 else {
    IntSet params=getBuilder().getContextSelector().getRelevantParameters(node,instruction.getCallSite());
    if (!params.contains(0)) {
      params=IntSetUtil.makeMutableCopy(params);
      ((MutableIntSet)params).add(0);
    }
    final int vns[]=new int[params.size()];
    params.foreach(new IntSetAction(){
      private int i=0;
      public void act(      int x){
        vns[i++]=instruction.getUse(x);
      }
    }
);
    if (contentsAreInvariant(symbolTable,du,vns)) {
      for (      CGNode n : getBuilder().getTargetsForCall(node,instruction.getCallSite(),invariantParameters)) {
        getBuilder().processResolvedCall(node,instruction,n,invariantParameters,uniqueCatch);
        processClassInitializer(n.getMethod().getDeclaringClass());
      }
    }
 else {
      if (DEBUG) {
        System.err.println(""String_Node_Str"" + instruction + ""String_Node_Str""+ params);
      }
      final List<PointerKey> pks=new ArrayList<PointerKey>(params.size());
      params.foreach(new IntSetAction(){
        public void act(        int x){
          if (!contentsAreInvariant(symbolTable,du,instruction.getUse(x))) {
            pks.add(getBuilder().getPointerKeyForLocal(node,instruction.getUse(x)));
          }
        }
      }
);
      DispatchOperator dispatchOperator=getBuilder().new DispatchOperator(instruction,node,invariantParameters,uniqueCatch,params);
      system.newSideEffect(dispatchOperator,pks.toArray(new PointerKey[pks.size()]));
    }
  }
}","protected void visitInvokeInternal(final SSAAbstractInvokeInstruction instruction,InvariantComputer invs){
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + instruction);
  }
  PointerKey uniqueCatch=null;
  if (hasUniqueCatchBlock(instruction,ir)) {
    uniqueCatch=getBuilder().getUniqueCatchKey(instruction,ir,node);
  }
  InstanceKey[][] invariantParameters=invs.computeInvariantParameters(instruction);
  if (instruction.getCallSite().isStatic()) {
    for (    CGNode n : getBuilder().getTargetsForCall(node,instruction,invariantParameters)) {
      getBuilder().processResolvedCall(node,instruction,n,invariantParameters,uniqueCatch);
      if (DEBUG) {
        System.err.println(""String_Node_Str"" + n);
      }
      processClassInitializer(n.getMethod().getDeclaringClass());
    }
  }
 else {
    IntSet params=getBuilder().getContextSelector().getRelevantParameters(node,instruction.getCallSite());
    if (!params.contains(0)) {
      params=IntSetUtil.makeMutableCopy(params);
      ((MutableIntSet)params).add(0);
    }
    final int vns[]=new int[params.size()];
    params.foreach(new IntSetAction(){
      private int i=0;
      public void act(      int x){
        vns[i++]=instruction.getUse(x);
      }
    }
);
    if (contentsAreInvariant(symbolTable,du,vns)) {
      for (      CGNode n : getBuilder().getTargetsForCall(node,instruction,invariantParameters)) {
        getBuilder().processResolvedCall(node,instruction,n,invariantParameters,uniqueCatch);
        processClassInitializer(n.getMethod().getDeclaringClass());
      }
    }
 else {
      if (DEBUG) {
        System.err.println(""String_Node_Str"" + instruction + ""String_Node_Str""+ params);
      }
      final List<PointerKey> pks=new ArrayList<PointerKey>(params.size());
      params.foreach(new IntSetAction(){
        public void act(        int x){
          if (!contentsAreInvariant(symbolTable,du,instruction.getUse(x))) {
            pks.add(getBuilder().getPointerKeyForLocal(node,instruction.getUse(x)));
          }
        }
      }
);
      DispatchOperator dispatchOperator=getBuilder().new DispatchOperator(instruction,node,invariantParameters,uniqueCatch,params);
      system.newSideEffect(dispatchOperator,pks.toArray(new PointerKey[pks.size()]));
    }
  }
}",0.9938811188811189
38318,"protected Set<CGNode> getTargetsForCall(final CGNode caller,final CallSiteReference site,InstanceKey[][] invs){
  IntSet params=contextSelector.getRelevantParameters(caller,site);
  if (!site.isStatic() && !params.contains(0)) {
    params=IntSetUtil.makeMutableCopy(params);
    ((MutableIntSet)params).add(0);
  }
  final Set<CGNode> targets=HashSetFactory.make();
  VoidFunction<InstanceKey[]> f=new VoidFunction<InstanceKey[]>(){
    public void apply(    InstanceKey[] v){
      IClass recv=null;
      if (site.isDispatch()) {
        recv=v[0].getConcreteType();
      }
      CGNode target=getTargetForCall(caller,site,recv,v);
      if (target != null) {
        targets.add(target);
      }
    }
  }
;
  iterateCrossProduct(caller,site,params,invs,f);
  return targets;
}","protected Set<CGNode> getTargetsForCall(final CGNode caller,final SSAAbstractInvokeInstruction instruction,InstanceKey[][] invs){
  final CallSiteReference site=instruction.getCallSite();
  IntSet params=contextSelector.getRelevantParameters(caller,site);
  if (!site.isStatic() && !params.contains(0)) {
    params=IntSetUtil.makeMutableCopy(params);
    ((MutableIntSet)params).add(0);
  }
  final Set<CGNode> targets=HashSetFactory.make();
  VoidFunction<InstanceKey[]> f=new VoidFunction<InstanceKey[]>(){
    public void apply(    InstanceKey[] v){
      IClass recv=null;
      if (site.isDispatch()) {
        recv=v[0].getConcreteType();
      }
      CGNode target=getTargetForCall(caller,site,recv,v);
      if (target != null) {
        targets.add(target);
      }
    }
  }
;
  iterateCrossProduct(caller,instruction,params,invs,f);
  return targets;
}",0.918032786885246
38319,"public IField getField(Atom name){
  if (declaredFields.containsKey(name)) {
    return declaredFields.get(name);
  }
 else   if (getSuperclass() != null) {
    return getSuperclass().getField(name);
  }
 else {
    return null;
  }
}","public IField getField(Atom name,TypeName type){
  return getField(name);
}",0.3948220064724919
38320,"public IField getField(Atom name){
  return loader.lookupClass(superReference.getName()).getField(name);
}","public IField getField(Atom name,TypeName type){
  return loader.lookupClass(superReference.getName()).getField(name);
}",0.9380530973451328
38321,"private boolean isNamedVar(CAstNode n,String name){
  if (n.getKind() == CAstNode.VAR) {
    String nm=(String)n.getChild(0).getValue();
    return nm.equals(name);
  }
  return false;
}","private boolean isNamedVar(CAstNode n,Pattern namePattern){
  if (n.getKind() == CAstNode.VAR) {
    String nm=(String)n.getChild(0).getValue();
    return namePattern.matcher(nm).matches();
  }
  return false;
}",0.7135678391959799
38322,"@Override protected String[] getArgumentNames(CAstEntity f){
  if (super.getArgumentCount(f) >= v.getValue()) {
    return super.getArgumentNames(f);
  }
 else {
    String[] argNames=new String[v.getValue()];
    System.arraycopy(super.getArgumentNames(f),0,argNames,0,super.getArgumentCount(f));
    for (int i=super.getArgumentCount(f); i < argNames.length; i++) {
      argNames[i]=""String_Node_Str"" + (i + 1);
    }
    return argNames;
  }
}","@Override protected String[] getArgumentNames(CAstEntity f){
  if (super.getArgumentCount(f) >= v.getValue()) {
    return super.getArgumentNames(f);
  }
 else {
    String[] argNames=new String[v.getValue()];
    System.arraycopy(super.getArgumentNames(f),0,argNames,0,super.getArgumentCount(f));
    for (int i=super.getArgumentCount(f); i < argNames.length; i++) {
      argNames[i]=""String_Node_Str"" + i;
    }
    return argNames;
  }
}",0.990990990990991
38323,"@Override public IR makeIR(final IMethod method,Context context,SSAOptions options){
  if (method instanceof Retranslatable) {
    @SuppressWarnings(""String_Node_Str"") final Value<Integer> v=(Value<Integer>)context.get(ArgumentCountContext.ARGUMENT_COUNT);
    final Retranslatable m=(Retranslatable)method;
    if (v != null) {
      final JavaScriptLoader myloader=(JavaScriptLoader)method.getDeclaringClass().getClassLoader();
class FixedArgumentsRewriter extends CAstBasicRewriter {
        private final CAstEntity e=m.getEntity();
        public FixedArgumentsRewriter(        CAst Ast){
          super(Ast,false);
        }
        private boolean isNamedVar(        CAstNode n,        String name){
          if (n.getKind() == CAstNode.VAR) {
            String nm=(String)n.getChild(0).getValue();
            return nm.equals(name);
          }
          return false;
        }
        private Object getIndexFromArgumentRef(        CAstNode n){
          if (n.getKind() == CAstNode.OBJECT_REF || n.getKind() == CAstNode.ARRAY_REF) {
            if (isNamedVar(n.getChild(0),""String_Node_Str"")) {
              return n.getChild(1).getValue();
            }
          }
          return null;
        }
        private Object getIndexFromBaseVar(        CAstNode n){
          if (n.getKind() == CAstNode.BLOCK_EXPR) {
            if (n.getChildCount() == 2) {
              CAstNode c1=n.getChild(0);
              if (c1.getKind() == CAstNode.ASSIGN) {
                if (isNamedVar(c1.getChild(0),""String_Node_Str"")) {
                  if (isNamedVar(c1.getChild(1),""String_Node_Str"")) {
                    CAstNode c2=n.getChild(1);
                    if (c2.getKind() == CAstNode.OBJECT_REF || c2.getKind() == CAstNode.ARRAY_REF) {
                      if (isNamedVar(c2.getChild(0),""String_Node_Str"")) {
                        return c2.getChild(1).getValue();
                      }
                    }
                  }
                }
              }
            }
          }
          return null;
        }
        private Object getStaticArgumentIndex(        CAstNode n){
          Object x=getIndexFromArgumentRef(n);
          if (x != null) {
            return x;
          }
 else {
            return getIndexFromBaseVar(n);
          }
        }
        private CAstNode handleArgumentRef(        CAstNode n){
          Object x=getStaticArgumentIndex(n);
          if (x != null) {
            if (x instanceof Number && ((Number)x).intValue() < v.getValue() - 2) {
              int arg=((Number)x).intValue() + 3;
              if (arg < e.getArgumentCount()) {
                return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(e.getArgumentNames()[arg]));
              }
 else {
                return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(""String_Node_Str"" + arg));
              }
            }
 else             if (x instanceof String && ""String_Node_Str"".equals(x)) {
              return Ast.makeConstant(v.getValue());
            }
          }
          return null;
        }
        @Override protected CAstNode copyNodes(        CAstNode root,        CAstControlFlowMap cfg,        NonCopyingContext context,        Map<Pair<CAstNode,NoKey>,CAstNode> nodeMap){
          CAstNode result=null;
          if (root.getKind() == CAstNode.ARRAY_REF || root.getKind() == CAstNode.OBJECT_REF || root.getKind() == CAstNode.BLOCK_EXPR) {
            result=handleArgumentRef(root);
          }
 else           if (root.getKind() == CAstNode.CONSTANT) {
            result=Ast.makeConstant(root.getValue());
          }
 else           if (root.getKind() == CAstNode.OPERATOR) {
            result=root;
          }
          if (result == null) {
            CAstNode children[]=new CAstNode[root.getChildCount()];
            for (int i=0; i < children.length; i++) {
              children[i]=copyNodes(root.getChild(i),cfg,context,nodeMap);
            }
            for (            Object label : cfg.getTargetLabels(root)) {
              if (label instanceof CAstNode) {
                copyNodes((CAstNode)label,cfg,context,nodeMap);
              }
            }
            CAstNode copy=Ast.makeNode(root.getKind(),children);
            result=copy;
          }
          nodeMap.put(Pair.make(root,context.key()),result);
          return result;
        }
      }
      final FixedArgumentsRewriter args=new FixedArgumentsRewriter(new CAstImpl());
      final JSConstantFoldingRewriter fold=new JSConstantFoldingRewriter(new CAstImpl());
class ArgumentativeTranslator extends JSAstTranslator {
        public ArgumentativeTranslator(        JavaScriptLoader loader){
          super(loader);
        }
        private CAstEntity codeBodyEntity;
        private IMethod specializedCode;
        @Override protected int getArgumentCount(        CAstEntity f){
          return Math.max(super.getArgumentCount(f),v.getValue());
        }
        @Override protected String[] getArgumentNames(        CAstEntity f){
          if (super.getArgumentCount(f) >= v.getValue()) {
            return super.getArgumentNames(f);
          }
 else {
            String[] argNames=new String[v.getValue()];
            System.arraycopy(super.getArgumentNames(f),0,argNames,0,super.getArgumentCount(f));
            for (int i=super.getArgumentCount(f); i < argNames.length; i++) {
              argNames[i]=""String_Node_Str"" + (i + 1);
            }
            return argNames;
          }
        }
        @Override protected String composeEntityName(        WalkContext parent,        CAstEntity f){
          if (f == codeBodyEntity) {
            return super.composeEntityName(parent,f) + ""String_Node_Str"" + v.getValue().intValue();
          }
 else {
            return super.composeEntityName(parent,f);
          }
        }
        @Override protected void defineFunction(        CAstEntity N,        WalkContext definingContext,        AbstractCFG cfg,        SymbolTable symtab,        boolean hasCatchBlock,        TypeReference[][] caughtTypes,        boolean hasMonitorOp,        AstLexicalInformation LI,        DebuggingInformation debugInfo){
          if (N == codeBodyEntity) {
            specializedCode=myloader.makeCodeBodyCode(cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo,method.getDeclaringClass());
          }
 else {
            super.defineFunction(N,definingContext,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo);
          }
        }
        @Override public void translate(        CAstEntity N,        WalkContext context){
          if (N == m.getEntity()) {
            codeBodyEntity=fold.rewrite(args.rewrite(N));
            super.translate(codeBodyEntity,context);
          }
 else {
            super.translate(N,context);
          }
        }
      }
      ArgumentativeTranslator a=new ArgumentativeTranslator(myloader);
      m.retranslate(a);
      return super.makeIR(a.specializedCode,context,options);
    }
  }
  return super.makeIR(method,context,options);
}","@Override public IR makeIR(final IMethod method,Context context,SSAOptions options){
  if (method instanceof Retranslatable) {
    @SuppressWarnings(""String_Node_Str"") final Value<Integer> v=(Value<Integer>)context.get(ArgumentCountContext.ARGUMENT_COUNT);
    final Retranslatable m=(Retranslatable)method;
    if (v != null) {
      final JavaScriptLoader myloader=(JavaScriptLoader)method.getDeclaringClass().getClassLoader();
class FixedArgumentsRewriter extends CAstBasicRewriter {
        private final CAstEntity e=m.getEntity();
        public FixedArgumentsRewriter(        CAst Ast){
          super(Ast,false);
        }
        private boolean isNamedVar(        CAstNode n,        String name){
          if (n.getKind() == CAstNode.VAR) {
            String nm=(String)n.getChild(0).getValue();
            return nm.equals(name);
          }
          return false;
        }
        private boolean isNamedVar(        CAstNode n,        Pattern namePattern){
          if (n.getKind() == CAstNode.VAR) {
            String nm=(String)n.getChild(0).getValue();
            return namePattern.matcher(nm).matches();
          }
          return false;
        }
        private Object getIndexFromArgumentRef(        CAstNode n){
          if (n.getKind() == CAstNode.OBJECT_REF || n.getKind() == CAstNode.ARRAY_REF) {
            if (isNamedVar(n.getChild(0),""String_Node_Str"")) {
              return n.getChild(1).getValue();
            }
          }
          return null;
        }
        private Object getIndexFromBaseVar(        CAstNode n){
          if (n.getKind() == CAstNode.BLOCK_EXPR) {
            if (n.getChildCount() == 2) {
              CAstNode c1=n.getChild(0);
              if (c1.getKind() == CAstNode.ASSIGN) {
                if (isNamedVar(c1.getChild(0),baseNameRegex)) {
                  if (isNamedVar(c1.getChild(1),""String_Node_Str"")) {
                    CAstNode c2=n.getChild(1);
                    if (c2.getKind() == CAstNode.OBJECT_REF || c2.getKind() == CAstNode.ARRAY_REF) {
                      if (isNamedVar(c2.getChild(0),baseNameRegex)) {
                        return c2.getChild(1).getValue();
                      }
                    }
                  }
                }
              }
            }
          }
          return null;
        }
        private Object getStaticArgumentIndex(        CAstNode n){
          Object x=getIndexFromArgumentRef(n);
          if (x != null) {
            return x;
          }
 else {
            return getIndexFromBaseVar(n);
          }
        }
        private CAstNode handleArgumentRef(        CAstNode n){
          Object x=getStaticArgumentIndex(n);
          if (x != null) {
            if (x instanceof Number && ((Number)x).intValue() < v.getValue() - 2) {
              int arg=((Number)x).intValue() + 2;
              if (arg < e.getArgumentCount()) {
                return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(e.getArgumentNames()[arg]));
              }
 else {
                return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(""String_Node_Str"" + arg));
              }
            }
 else             if (x instanceof String && ""String_Node_Str"".equals(x)) {
              return Ast.makeConstant(v.getValue());
            }
          }
          return null;
        }
        @Override protected CAstNode copyNodes(        CAstNode root,        CAstControlFlowMap cfg,        NonCopyingContext context,        Map<Pair<CAstNode,NoKey>,CAstNode> nodeMap){
          CAstNode result=null;
          if (root.getKind() == CAstNode.ARRAY_REF || root.getKind() == CAstNode.OBJECT_REF || root.getKind() == CAstNode.BLOCK_EXPR) {
            result=handleArgumentRef(root);
          }
 else           if (root.getKind() == CAstNode.CONSTANT) {
            result=Ast.makeConstant(root.getValue());
          }
 else           if (root.getKind() == CAstNode.OPERATOR) {
            result=root;
          }
          if (result == null) {
            CAstNode children[]=new CAstNode[root.getChildCount()];
            for (int i=0; i < children.length; i++) {
              children[i]=copyNodes(root.getChild(i),cfg,context,nodeMap);
            }
            for (            Object label : cfg.getTargetLabels(root)) {
              if (label instanceof CAstNode) {
                copyNodes((CAstNode)label,cfg,context,nodeMap);
              }
            }
            CAstNode copy=Ast.makeNode(root.getKind(),children);
            result=copy;
          }
          nodeMap.put(Pair.make(root,context.key()),result);
          return result;
        }
      }
      final FixedArgumentsRewriter args=new FixedArgumentsRewriter(new CAstImpl());
      final JSConstantFoldingRewriter fold=new JSConstantFoldingRewriter(new CAstImpl());
class ArgumentativeTranslator extends JSAstTranslator {
        public ArgumentativeTranslator(        JavaScriptLoader loader){
          super(loader);
        }
        private CAstEntity codeBodyEntity;
        private IMethod specializedCode;
        @Override protected int getArgumentCount(        CAstEntity f){
          return Math.max(super.getArgumentCount(f),v.getValue());
        }
        @Override protected String[] getArgumentNames(        CAstEntity f){
          if (super.getArgumentCount(f) >= v.getValue()) {
            return super.getArgumentNames(f);
          }
 else {
            String[] argNames=new String[v.getValue()];
            System.arraycopy(super.getArgumentNames(f),0,argNames,0,super.getArgumentCount(f));
            for (int i=super.getArgumentCount(f); i < argNames.length; i++) {
              argNames[i]=""String_Node_Str"" + i;
            }
            return argNames;
          }
        }
        @Override protected String composeEntityName(        WalkContext parent,        CAstEntity f){
          if (f == codeBodyEntity) {
            return super.composeEntityName(parent,f) + ""String_Node_Str"" + v.getValue().intValue();
          }
 else {
            return super.composeEntityName(parent,f);
          }
        }
        @Override protected void defineFunction(        CAstEntity N,        WalkContext definingContext,        AbstractCFG cfg,        SymbolTable symtab,        boolean hasCatchBlock,        TypeReference[][] caughtTypes,        boolean hasMonitorOp,        AstLexicalInformation LI,        DebuggingInformation debugInfo){
          if (N == codeBodyEntity) {
            specializedCode=myloader.makeCodeBodyCode(cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo,method.getDeclaringClass());
          }
 else {
            super.defineFunction(N,definingContext,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo);
          }
        }
        @Override public void translate(        CAstEntity N,        WalkContext context){
          if (N == m.getEntity()) {
            codeBodyEntity=fold.rewrite(args.rewrite(N));
            super.translate(codeBodyEntity,context);
          }
 else {
            super.translate(N,context);
          }
        }
      }
      ArgumentativeTranslator a=new ArgumentativeTranslator(myloader);
      m.retranslate(a);
      return super.makeIR(a.specializedCode,context,options);
    }
  }
  return super.makeIR(method,context,options);
}",0.9751522362987332
38324,"private CAstNode handleArgumentRef(CAstNode n){
  Object x=getStaticArgumentIndex(n);
  if (x != null) {
    if (x instanceof Number && ((Number)x).intValue() < v.getValue() - 2) {
      int arg=((Number)x).intValue() + 3;
      if (arg < e.getArgumentCount()) {
        return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(e.getArgumentNames()[arg]));
      }
 else {
        return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(""String_Node_Str"" + arg));
      }
    }
 else     if (x instanceof String && ""String_Node_Str"".equals(x)) {
      return Ast.makeConstant(v.getValue());
    }
  }
  return null;
}","private CAstNode handleArgumentRef(CAstNode n){
  Object x=getStaticArgumentIndex(n);
  if (x != null) {
    if (x instanceof Number && ((Number)x).intValue() < v.getValue() - 2) {
      int arg=((Number)x).intValue() + 2;
      if (arg < e.getArgumentCount()) {
        return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(e.getArgumentNames()[arg]));
      }
 else {
        return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(""String_Node_Str"" + arg));
      }
    }
 else     if (x instanceof String && ""String_Node_Str"".equals(x)) {
      return Ast.makeConstant(v.getValue());
    }
  }
  return null;
}",0.9983443708609272
38325,"private Object getIndexFromBaseVar(CAstNode n){
  if (n.getKind() == CAstNode.BLOCK_EXPR) {
    if (n.getChildCount() == 2) {
      CAstNode c1=n.getChild(0);
      if (c1.getKind() == CAstNode.ASSIGN) {
        if (isNamedVar(c1.getChild(0),""String_Node_Str"")) {
          if (isNamedVar(c1.getChild(1),""String_Node_Str"")) {
            CAstNode c2=n.getChild(1);
            if (c2.getKind() == CAstNode.OBJECT_REF || c2.getKind() == CAstNode.ARRAY_REF) {
              if (isNamedVar(c2.getChild(0),""String_Node_Str"")) {
                return c2.getChild(1).getValue();
              }
            }
          }
        }
      }
    }
  }
  return null;
}","private Object getIndexFromBaseVar(CAstNode n){
  if (n.getKind() == CAstNode.BLOCK_EXPR) {
    if (n.getChildCount() == 2) {
      CAstNode c1=n.getChild(0);
      if (c1.getKind() == CAstNode.ASSIGN) {
        if (isNamedVar(c1.getChild(0),baseNameRegex)) {
          if (isNamedVar(c1.getChild(1),""String_Node_Str"")) {
            CAstNode c2=n.getChild(1);
            if (c2.getKind() == CAstNode.OBJECT_REF || c2.getKind() == CAstNode.ARRAY_REF) {
              if (isNamedVar(c2.getChild(0),baseNameRegex)) {
                return c2.getChild(1).getValue();
              }
            }
          }
        }
      }
    }
  }
  return null;
}",0.9542682926829268
38326,"@Before public void setUp(){
  com.ibm.wala.cast.js.ipa.callgraph.Util.setTranslatorFactory(new CAstRhinoTranslatorFactory());
}","@Before public void setUp(){
  JSCallGraphUtil.setTranslatorFactory(new CAstRhinoTranslatorFactory());
}",0.8620689655172413
38327,"@Before public void setUp(){
  com.ibm.wala.cast.js.ipa.callgraph.Util.setTranslatorFactory(new CAstRhinoTranslatorFactory());
}","@Before public void setUp(){
  JSCallGraphUtil.setTranslatorFactory(new CAstRhinoTranslatorFactory());
}",0.8620689655172413
38328,"@Test public void testTranslateToCAstCrash3() throws IllegalArgumentException, IOException, CancelException {
  Util.makeScriptCG(""String_Node_Str"",""String_Node_Str"");
}","@Test public void testTranslateToCAstCrash3() throws IllegalArgumentException, IOException, CancelException {
  JSCallGraphBuilderUtil.makeScriptCG(""String_Node_Str"",""String_Node_Str"");
}",0.949438202247191
38329,"@Test public void testArgs() throws IOException, IllegalArgumentException, CancelException, ClassHierarchyException {
  JavaScriptLoaderFactory loaders=Util.makeLoaders();
  AnalysisScope scope=Util.makeScriptScope(""String_Node_Str"",""String_Node_Str"",loaders);
  IClassHierarchy cha=Util.makeHierarchy(scope,loaders);
  com.ibm.wala.cast.js.util.Util.checkForFrontEndErrors(cha);
  Iterable<Entrypoint> roots=Util.makeScriptRoots(cha);
  JSAnalysisOptions options=Util.makeOptions(scope,cha,roots);
  AnalysisCache cache=Util.makeCache(new ArgumentSpecialization.ArgumentCountIRFactory(options.getSSAOptions()));
  JSCFABuilder builder=new JSZeroOrOneXCFABuilder(cha,options,cache,null,null,ZeroXInstanceKeys.ALLOCATIONS,false);
  builder.setContextSelector(new ArgumentSpecialization.ArgumentCountContextSelector(builder.getContextSelector()));
  builder.setContextInterpreter(new ArgumentSpecialization.ArgumentSpecializationContextIntepreter(options,cache));
  CallGraph CG=builder.makeCallGraph(options);
  Util.AVOID_DUMP=false;
  Util.dumpCG(builder.getPointerAnalysis(),CG);
  verifyGraphAssertions(CG,assertionsForArgs);
}","@Test public void testArgs() throws IOException, IllegalArgumentException, CancelException, ClassHierarchyException {
  JavaScriptLoaderFactory loaders=JSCallGraphBuilderUtil.makeLoaders();
  AnalysisScope scope=JSCallGraphBuilderUtil.makeScriptScope(""String_Node_Str"",""String_Node_Str"",loaders);
  IClassHierarchy cha=JSCallGraphBuilderUtil.makeHierarchy(scope,loaders);
  com.ibm.wala.cast.js.util.Util.checkForFrontEndErrors(cha);
  Iterable<Entrypoint> roots=JSCallGraphBuilderUtil.makeScriptRoots(cha);
  JSAnalysisOptions options=JSCallGraphBuilderUtil.makeOptions(scope,cha,roots);
  AnalysisCache cache=JSCallGraphBuilderUtil.makeCache(new ArgumentSpecialization.ArgumentCountIRFactory(options.getSSAOptions()));
  JSCFABuilder builder=new JSZeroOrOneXCFABuilder(cha,options,cache,null,null,ZeroXInstanceKeys.ALLOCATIONS,false);
  builder.setContextSelector(new ArgumentSpecialization.ArgumentCountContextSelector(builder.getContextSelector()));
  builder.setContextInterpreter(new ArgumentSpecialization.ArgumentSpecializationContextIntepreter(options,cache));
  CallGraph CG=builder.makeCallGraph(options);
  CAstCallGraphUtil.AVOID_DUMP=false;
  CAstCallGraphUtil.dumpCG(builder.getPointerAnalysis(),CG);
  verifyGraphAssertions(CG,assertionsForArgs);
}",0.9440267335004175
38330,"@Test public void testEx1() throws IOException, IllegalArgumentException, CancelException {
  URL url=getClass().getClassLoader().getResource(""String_Node_Str"");
  JSCFABuilder builder=Util.makeHTMLCGBuilder(url);
  CallGraph CG=builder.makeCallGraph(builder.getOptions());
  Util.dumpCG(builder.getPointerAnalysis(),CG);
}","@Test public void testEx1() throws IOException, IllegalArgumentException, CancelException {
  URL url=getClass().getClassLoader().getResource(""String_Node_Str"");
  JSCFABuilder builder=JSCallGraphBuilderUtil.makeHTMLCGBuilder(url);
  CallGraph CG=builder.makeCallGraph(builder.getOptions());
  CAstCallGraphUtil.dumpCG(builder.getPointerAnalysis(),CG);
}",0.9542097488921714
38331,"@Test public void testSwineFlu() throws IOException, IllegalArgumentException, CancelException {
  URL url=new URL(""String_Node_Str"");
  CallGraph CG=JSCallGraphBuilderUtil.makeHTMLCG(url);
  verifyGraphAssertions(CG,assertionsForSwineFlu);
}","@Ignore(""String_Node_Str"") @Test public void testSwineFlu() throws IOException, IllegalArgumentException, CancelException {
  URL url=new URL(""String_Node_Str"");
  CallGraph CG=JSCallGraphBuilderUtil.makeHTMLCG(url);
  verifyGraphAssertions(CG,assertionsForSwineFlu);
}",0.9471624266144814
38332,"@Test public void testArgs() throws IOException, IllegalArgumentException, CancelException {
  CallGraph CG=Util.makeScriptCG(""String_Node_Str"",""String_Node_Str"");
  verifyGraphAssertions(CG,assertionsForArgs);
}","@Test public void testArgs() throws IOException, IllegalArgumentException, CancelException {
  CallGraph CG=JSCallGraphBuilderUtil.makeScriptCG(""String_Node_Str"",""String_Node_Str"");
  verifyGraphAssertions(CG,assertionsForArgs);
}",0.9592760180995475
38333,"@Test public void testCrawlPage17() throws IOException, IllegalArgumentException, CancelException {
}","@Test public void testCrawlPage17() throws IOException, IllegalArgumentException, CancelException {
  URL url=getClass().getClassLoader().getResource(""String_Node_Str"");
  CallGraph CG=JSCallGraphBuilderUtil.makeHTMLCG(url);
  verifyGraphAssertions(CG,assertionsForPage17);
}",0.5372340425531915
38334,"@Test public void testCrawlPage12() throws IOException, IllegalArgumentException, CancelException {
}","@Test public void testCrawlPage12() throws IOException, IllegalArgumentException, CancelException {
  URL url=getClass().getClassLoader().getResource(""String_Node_Str"");
  CallGraph CG=JSCallGraphBuilderUtil.makeHTMLCG(url);
  verifyGraphAssertions(CG,assertionsForPage12);
}",0.5372340425531915
38335,"public void translate(final CAstEntity N,final WalkContext context){
  walkEntities(N,context);
}","public void translate(final CAstEntity N,final WalkContext context){
  final ExposedNamesCollector exposedNamesCollector=new ExposedNamesCollector();
  exposedNamesCollector.run(N);
  entity2ExposedNames=exposedNamesCollector.getEntity2ExposedNames();
  walkEntities(N,context);
}",0.5145888594164456
38336,"public Context getCalleeTarget(CGNode caller,CallSiteReference site,IMethod callee,InstanceKey[] receiver){
  IClass declaringClass=callee.getDeclaringClass();
  IMethod method=declaringClass.getMethod(AstMethodReference.fnSelector);
  Context baseCtxt=base.getCalleeTarget(caller,site,callee,receiver);
  if (method != null) {
    String s=method.getReference().getDeclaringClass().getName().toString();
    if (s.equals(""String_Node_Str"")) {
      boolean isNonNullArray=false;
      if (receiver.length >= 4) {
        InstanceKey argsList=receiver[3];
        if (argsList != null && argsList.getConcreteType().equals(caller.getClassHierarchy().lookupClass(JavaScriptTypes.Array))) {
          isNonNullArray=true;
        }
      }
      if (USE_ONE_LEVEL_CALLSTRING)       baseCtxt=new DelegatingContext(oneLevel.getCalleeTarget(caller,site,callee,receiver),baseCtxt);
      return new ApplyContext(baseCtxt,isNonNullArray);
    }
  }
  return baseCtxt;
}","public Context getCalleeTarget(CGNode caller,CallSiteReference site,IMethod callee,InstanceKey[] receiver){
  IClass declaringClass=callee.getDeclaringClass();
  IMethod method=declaringClass.getMethod(AstMethodReference.fnSelector);
  Context baseCtxt=base.getCalleeTarget(caller,site,callee,receiver);
  if (method != null) {
    String s=method.getReference().getDeclaringClass().getName().toString();
    if (s.equals(""String_Node_Str"")) {
      boolean isNonNullArray=false;
      if (receiver.length >= 4) {
        InstanceKey argsList=receiver[3];
        if (argsList != null && argsList.getConcreteType().equals(caller.getClassHierarchy().lookupClass(JavaScriptTypes.Array))) {
          isNonNullArray=true;
        }
      }
      if (USE_ONE_LEVEL)       baseCtxt=oneLevel.getCalleeTarget(caller,site,callee,receiver);
      return new ApplyContext(baseCtxt,isNonNullArray);
    }
  }
  return baseCtxt;
}",0.9079297498669504
38337,"@Override public IMethod getCalleeTarget(CGNode caller,CallSiteReference site,IClass receiver){
  IMethod method=receiver.getMethod(AstMethodReference.fnSelector);
  if (method != null) {
    String s=method.getReference().getDeclaringClass().getName().toString();
    if (s.equals(""String_Node_Str"")) {
      final MethodReference ref=genSyntheticMethodRef(receiver);
      JavaScriptSummary S=new JavaScriptSummary(ref,1);
      return new JavaScriptSummarizedFunction(ref,S,receiver);
    }
  }
  return base.getCalleeTarget(caller,site,receiver);
}","@Override public IMethod getCalleeTarget(CGNode caller,CallSiteReference site,IClass receiver){
  IMethod method=receiver.getMethod(AstMethodReference.fnSelector);
  if (method != null) {
    String s=method.getReference().getDeclaringClass().getName().toString();
    if (s.equals(""String_Node_Str"")) {
      if (applyMethod == null) {
        applyMethod=createApplyDummyMethod(receiver);
      }
      return applyMethod;
    }
  }
  return base.getCalleeTarget(caller,site,receiver);
}",0.6416906820365034
38338,"@SuppressWarnings(""String_Node_Str"") public static void dumpCG(PointerAnalysis PA,CallGraph CG){
  if (AVOID_DUMP)   return;
  for (Iterator x=CG.iterator(); x.hasNext(); ) {
    CGNode N=(CGNode)x.next();
    System.err.print(""String_Node_Str"" + getShortName(N) + ""String_Node_Str"");
    boolean fst=true;
    for (Iterator<? extends CGNode> ns=CG.getSuccNodes(N); ns.hasNext(); ) {
      if (fst)       fst=false;
 else       System.err.print(""String_Node_Str"");
      System.err.print(getShortName(ns.next()));
    }
    System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"" + N.getGraphNodeId());
    IR ir=N.getIR();
    if (ir != null) {
      System.err.println(ir);
    }
 else {
      System.err.println(""String_Node_Str"");
    }
  }
  System.err.println(""String_Node_Str"");
  for (Iterator x=PA.getPointerKeys().iterator(); x.hasNext(); ) {
    PointerKey n=(PointerKey)x.next();
    try {
      System.err.println((n + ""String_Node_Str"" + PA.getPointsToSet(n)));
    }
 catch (    Throwable e) {
      System.err.println((""String_Node_Str"" + n));
    }
  }
}","@SuppressWarnings(""String_Node_Str"") public static void dumpCG(PointerAnalysis PA,CallGraph CG){
  if (AVOID_DUMP)   return;
  for (Iterator x=CG.iterator(); x.hasNext(); ) {
    CGNode N=(CGNode)x.next();
    System.err.print(""String_Node_Str"" + getShortName(N) + ""String_Node_Str"");
    boolean fst=true;
    for (Iterator<? extends CGNode> ns=CG.getSuccNodes(N); ns.hasNext(); ) {
      if (fst)       fst=false;
 else       System.err.print(""String_Node_Str"");
      System.err.print(getShortName(ns.next()));
    }
    System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"" + N.getGraphNodeId() + ""String_Node_Str""+ N.getContext());
    IR ir=N.getIR();
    if (ir != null) {
      System.err.println(ir);
    }
 else {
      System.err.println(""String_Node_Str"");
    }
  }
  System.err.println(""String_Node_Str"");
  for (Iterator x=PA.getPointerKeys().iterator(); x.hasNext(); ) {
    PointerKey n=(PointerKey)x.next();
    try {
      System.err.println((n + ""String_Node_Str"" + PA.getPointsToSet(n)));
    }
 catch (    Throwable e) {
      System.err.println((""String_Node_Str"" + n));
    }
  }
}",0.9838274932614556
38339,"private boolean forInOnFirstArg(IMethod method){
  MethodReference mref=method.getReference();
  if (method.getNumberOfParameters() < index)   return false;
  Boolean b=forInOnFirstArg_cache.get(mref);
  if (b != null)   return b;
  DefUse du=getDefUse(method);
  for (  SSAInstruction use : Iterator2Iterable.make(du.getUses(3))) {
    if (use instanceof EachElementGetInstruction) {
      forInOnFirstArg_cache.put(mref,true);
      return true;
    }
  }
  forInOnFirstArg_cache.put(mref,false);
  return false;
}","private boolean forInOnFirstArg(IMethod method){
  MethodReference mref=method.getReference();
  if (method.getNumberOfParameters() < index)   return false;
  Boolean b=forInOnFirstArg_cache.get(mref);
  if (b != null)   return b;
  DefUse du=getDefUse(method);
  for (  SSAInstruction use : Iterator2Iterable.make(du.getUses(index + 1))) {
    if (use instanceof EachElementGetInstruction) {
      forInOnFirstArg_cache.put(mref,true);
      return true;
    }
  }
  forInOnFirstArg_cache.put(mref,false);
  return false;
}",0.9903846153846154
38340,"private Frequency usesFirstArgAsPropertyName(IMethod method){
  MethodReference mref=method.getReference();
  if (method.getNumberOfParameters() < index)   return Frequency.NEVER;
  Frequency f=usesFirstArgAsPropertyName_cache.get(mref);
  if (f != null)   return f;
  boolean usedAsPropertyName=false, usedAsSomethingElse=false;
  DefUse du=getDefUse(method);
  for (  SSAInstruction use : Iterator2Iterable.make(du.getUses(3))) {
    if (use instanceof ReflectiveMemberAccess) {
      ReflectiveMemberAccess rma=(ReflectiveMemberAccess)use;
      if (rma.getMemberRef() == 3) {
        usedAsPropertyName=true;
        continue;
      }
    }
 else     if (use instanceof AstIsDefinedInstruction) {
      AstIsDefinedInstruction aidi=(AstIsDefinedInstruction)use;
      if (aidi.getNumberOfUses() > 1 && aidi.getUse(1) == 3) {
        usedAsPropertyName=true;
        continue;
      }
    }
    usedAsSomethingElse=true;
  }
  if (!usedAsPropertyName)   f=Frequency.NEVER;
 else   if (usedAsSomethingElse)   f=Frequency.SOMETIMES;
 else   f=Frequency.ALWAYS;
  usesFirstArgAsPropertyName_cache.put(mref,f);
  return f;
}","private Frequency usesFirstArgAsPropertyName(IMethod method){
  MethodReference mref=method.getReference();
  if (method.getNumberOfParameters() < index)   return Frequency.NEVER;
  Frequency f=usesFirstArgAsPropertyName_cache.get(mref);
  if (f != null)   return f;
  boolean usedAsPropertyName=false, usedAsSomethingElse=false;
  DefUse du=getDefUse(method);
  for (  SSAInstruction use : Iterator2Iterable.make(du.getUses(index + 1))) {
    if (use instanceof ReflectiveMemberAccess) {
      ReflectiveMemberAccess rma=(ReflectiveMemberAccess)use;
      if (rma.getMemberRef() == index + 1) {
        usedAsPropertyName=true;
        continue;
      }
    }
 else     if (use instanceof AstIsDefinedInstruction) {
      AstIsDefinedInstruction aidi=(AstIsDefinedInstruction)use;
      if (aidi.getNumberOfUses() > 1 && aidi.getUse(1) == index + 1) {
        usedAsPropertyName=true;
        continue;
      }
    }
    usedAsSomethingElse=true;
  }
  if (!usedAsPropertyName)   f=Frequency.NEVER;
 else   if (usedAsSomethingElse)   f=Frequency.SOMETIMES;
 else   f=Frequency.ALWAYS;
  usesFirstArgAsPropertyName_cache.put(mref,f);
  return f;
}",0.986784140969163
38341,"public JSZeroOrOneXCFABuilder(IClassHierarchy cha,JSAnalysisOptions options,AnalysisCache cache,ContextSelector appContextSelector,SSAContextInterpreter appContextInterpreter,int instancePolicy,boolean doOneCFA){
  super(cha,options,cache);
  SSAContextInterpreter contextInterpreter=makeDefaultContextInterpreters(appContextInterpreter,options,cha);
  if (options.handleCallApply()) {
    contextInterpreter=new DelegatingSSAContextInterpreter(new JavaScriptFunctionApplyContextInterpreter(options,cache),contextInterpreter);
  }
  setContextInterpreter(contextInterpreter);
  MethodTargetSelector targetSelector=new JavaScriptConstructTargetSelector(cha,options.getMethodTargetSelector());
  if (options.handleCallApply()) {
    targetSelector=new JavaScriptFunctionDotCallTargetSelector(targetSelector);
  }
  if (options.useLoadFileTargetSelector()) {
    targetSelector=new LoadFileTargetSelector(targetSelector,this);
  }
  options.setSelector(targetSelector);
  ContextSelector def=new ContextInsensitiveSelector();
  ContextSelector contextSelector=appContextSelector == null ? def : new DelegatingContextSelector(appContextSelector,def);
  contextSelector=new ScopeMappingKeysContextSelector(contextSelector);
  contextSelector=new JavaScriptConstructorContextSelector(contextSelector);
  if (USE_OBJECT_SENSITIVITY) {
    contextSelector=new ObjectSensitivityContextSelector(contextSelector);
  }
  if (options.handleCallApply()) {
    contextSelector=new JavaScriptFunctionApplyContextSelector(contextSelector);
  }
  contextSelector=new LexicalScopingResolverContexts(this,contextSelector);
  if (doOneCFA) {
    contextSelector=new nCFAContextSelector(1,contextSelector);
  }
  setContextSelector(contextSelector);
  setInstanceKeys(new JavaScriptScopeMappingInstanceKeys(cha,this,new JavaScriptConstructorInstanceKeys(new ZeroXInstanceKeys(options,cha,contextInterpreter,instancePolicy))));
}","public JSZeroOrOneXCFABuilder(IClassHierarchy cha,JSAnalysisOptions options,AnalysisCache cache,ContextSelector appContextSelector,SSAContextInterpreter appContextInterpreter,int instancePolicy,boolean doOneCFA){
  super(cha,options,cache);
  SSAContextInterpreter contextInterpreter=makeDefaultContextInterpreters(appContextInterpreter,options,cha);
  if (options.handleCallApply()) {
    contextInterpreter=new DelegatingSSAContextInterpreter(new JavaScriptFunctionApplyContextInterpreter(options,cache),contextInterpreter);
  }
  setContextInterpreter(contextInterpreter);
  MethodTargetSelector targetSelector=new JavaScriptConstructTargetSelector(cha,options.getMethodTargetSelector());
  if (options.handleCallApply()) {
    targetSelector=new JavaScriptFunctionApplyTargetSelector(new JavaScriptFunctionDotCallTargetSelector(targetSelector));
  }
  if (options.useLoadFileTargetSelector()) {
    targetSelector=new LoadFileTargetSelector(targetSelector,this);
  }
  options.setSelector(targetSelector);
  ContextSelector def=new ContextInsensitiveSelector();
  ContextSelector contextSelector=appContextSelector == null ? def : new DelegatingContextSelector(appContextSelector,def);
  contextSelector=new ScopeMappingKeysContextSelector(contextSelector);
  contextSelector=new JavaScriptConstructorContextSelector(contextSelector);
  if (USE_OBJECT_SENSITIVITY) {
    contextSelector=new ObjectSensitivityContextSelector(contextSelector);
  }
  if (options.handleCallApply()) {
    contextSelector=new JavaScriptFunctionApplyContextSelector(contextSelector);
  }
  contextSelector=new LexicalScopingResolverContexts(this,contextSelector);
  if (doOneCFA) {
    contextSelector=new nCFAContextSelector(1,contextSelector);
  }
  setContextSelector(contextSelector);
  setInstanceKeys(new JavaScriptScopeMappingInstanceKeys(cha,this,new JavaScriptConstructorInstanceKeys(new ZeroXInstanceKeys(options,cha,contextInterpreter,instancePolicy))));
}",0.988845654993515
38342,"protected boolean useLexicalAccessesForExposedVars(){
  return false;
}","protected boolean useLexicalAccessesForExposedVars(){
  return NEW_LEXICAL;
}",0.8918918918918919
38343,"protected boolean useLocalValuesForLexicalVars(){
  return true;
}","protected boolean useLocalValuesForLexicalVars(){
  return !NEW_LEXICAL;
}",0.8857142857142857
38344,"/** 
 * generate instructions for a write of a global
 */
protected void doGlobalWrite(WalkContext context,String name,int rval){
  Symbol S=context.currentScope().lookup(name);
  if (treatGlobalsAsLexicallyScoped()) {
    if (useLocalValuesForLexicalVars()) {
      int vn=S.valueNumber();
      Access A=new Access(name,null,vn);
      addExposedName(context.top(),null,name,vn,true,context);
      addAccess(context,context.top(),A);
      context.cfg().addInstruction(new AssignInstruction(vn,rval));
      context.cfg().addInstruction(new AstLexicalWrite(A));
    }
 else {
      Access A=new Access(name,null,rval);
      context.cfg().addInstruction(new AstLexicalWrite(A));
    }
  }
 else {
    FieldReference global=makeGlobalRef(name);
    context.cfg().addInstruction(new AstGlobalWrite(global,rval));
  }
}","/** 
 * generate instructions for a write of a global
 */
protected void doGlobalWrite(WalkContext context,String name,int rval){
  Symbol S=context.currentScope().lookup(name);
  if (treatGlobalsAsLexicallyScoped()) {
    if (useLocalValuesForLexicalVars()) {
      int vn=S.valueNumber();
      Access A=new Access(name,null,vn);
      addExposedName(context.top(),null,name,vn,true,context);
      addAccess(context,context.top(),A);
      context.cfg().addInstruction(new AssignInstruction(vn,rval));
      context.cfg().addInstruction(new AstLexicalWrite(A));
    }
 else {
      Access A=new Access(name,null,rval);
      context.cfg().addInstruction(new AstLexicalWrite(A));
      addAccess(context,context.top(),A);
    }
  }
 else {
    FieldReference global=makeGlobalRef(name);
    context.cfg().addInstruction(new AstGlobalWrite(global,rval));
  }
}",0.975
38345,"/** 
 * Note that the caller is responsible for ensuring that name is defined in a lexical scope.
 */
protected void doLexicallyScopedWrite(WalkContext context,String name,int rval){
  Symbol S=context.currentScope().lookup(name);
  Scope definingScope=S.getDefiningScope();
  CAstEntity E=definingScope.getEntity();
  addExposedName(E,E,name,definingScope.lookup(name).valueNumber(),true,context);
  if (useLocalValuesForLexicalVars()) {
    markExposedInEnclosingEntities(context,name,definingScope,E,context.getEntityName(E),true);
    context.cfg().addInstruction(new AssignInstruction(S.valueNumber(),rval));
    Access A=new Access(name,context.getEntityName(E),rval);
    context.cfg().addInstruction(new AstLexicalWrite(A));
  }
 else {
    Access A=new Access(name,context.getEntityName(E),rval);
    context.cfg().addInstruction(new AstLexicalWrite(A));
  }
}","/** 
 * Note that the caller is responsible for ensuring that name is defined in a lexical scope.
 */
protected void doLexicallyScopedWrite(WalkContext context,String name,int rval){
  Symbol S=context.currentScope().lookup(name);
  Scope definingScope=S.getDefiningScope();
  CAstEntity E=definingScope.getEntity();
  addExposedName(E,E,name,definingScope.lookup(name).valueNumber(),true,context);
  if (useLocalValuesForLexicalVars()) {
    markExposedInEnclosingEntities(context,name,definingScope,E,context.getEntityName(E),true);
    context.cfg().addInstruction(new AssignInstruction(S.valueNumber(),rval));
    Access A=new Access(name,context.getEntityName(E),rval);
    context.cfg().addInstruction(new AstLexicalWrite(A));
  }
 else {
    Access A=new Access(name,context.getEntityName(E),rval);
    context.cfg().addInstruction(new AstLexicalWrite(A));
    addAccess(context,context.top(),A);
  }
}",0.9775028121484814
38346,"/** 
 * generate instructions for a read of a global
 */
protected int doGlobalRead(CAstNode node,WalkContext context,String name){
  Symbol S=context.currentScope().lookup(name);
  if (treatGlobalsAsLexicallyScoped()) {
    if (useLocalValuesForLexicalVars()) {
      int vn=S.valueNumber();
      Access A=new Access(name,null,vn);
      addExposedName(context.top(),null,name,vn,false,context);
      addAccess(context,context.top(),A);
      return vn;
    }
 else {
      int result=context.currentScope().allocateTempValue();
      Access A=new Access(name,null,result);
      context.cfg().addInstruction(new AstLexicalRead(A));
      return result;
    }
  }
 else {
    int result=context.currentScope().allocateTempValue();
    FieldReference global=makeGlobalRef(name);
    context.cfg().addInstruction(new AstGlobalRead(result,global));
    return result;
  }
}","/** 
 * generate instructions for a read of a global
 */
protected int doGlobalRead(CAstNode node,WalkContext context,String name){
  Symbol S=context.currentScope().lookup(name);
  if (treatGlobalsAsLexicallyScoped()) {
    if (useLocalValuesForLexicalVars()) {
      int vn=S.valueNumber();
      Access A=new Access(name,null,vn);
      addExposedName(context.top(),null,name,vn,false,context);
      addAccess(context,context.top(),A);
      return vn;
    }
 else {
      int result=context.currentScope().allocateTempValue();
      Access A=new Access(name,null,result);
      context.cfg().addInstruction(new AstLexicalRead(A));
      addAccess(context,context.top(),A);
      return result;
    }
  }
 else {
    int result=context.currentScope().allocateTempValue();
    FieldReference global=makeGlobalRef(name);
    context.cfg().addInstruction(new AstGlobalRead(result,global));
    return result;
  }
}",0.976510067114094
38347,"/** 
 * we only have this method to avoid having to pass a node parameter at other call sites, as would be required for  {@link #doLexicallyScopedRead(CAstNode,WalkContext,String)}
 */
private int doLexReadHelper(WalkContext context,final String name){
  Symbol S=context.currentScope().lookup(name);
  Scope definingScope=S.getDefiningScope();
  CAstEntity E=definingScope.getEntity();
  addExposedName(E,E,name,definingScope.lookup(name).valueNumber(),false,context);
  final String entityName=context.getEntityName(E);
  if (useLocalValuesForLexicalVars()) {
    markExposedInEnclosingEntities(context,name,definingScope,E,entityName,false);
    return S.valueNumber();
  }
 else {
    int result=context.currentScope().allocateTempValue();
    Access A=new Access(name,entityName,result);
    context.cfg().addInstruction(new AstLexicalRead(A));
    return result;
  }
}","/** 
 * we only have this method to avoid having to pass a node parameter at other call sites, as would be required for  {@link #doLexicallyScopedRead(CAstNode,WalkContext,String)}
 */
private int doLexReadHelper(WalkContext context,final String name){
  Symbol S=context.currentScope().lookup(name);
  Scope definingScope=S.getDefiningScope();
  CAstEntity E=definingScope.getEntity();
  addExposedName(E,E,name,definingScope.lookup(name).valueNumber(),false,context);
  final String entityName=context.getEntityName(E);
  if (useLocalValuesForLexicalVars()) {
    markExposedInEnclosingEntities(context,name,definingScope,E,entityName,false);
    return S.valueNumber();
  }
 else {
    int result=context.currentScope().allocateTempValue();
    Access A=new Access(name,entityName,result);
    context.cfg().addInstruction(new AstLexicalRead(A));
    addAccess(context,context.top(),A);
    return result;
  }
}",0.977628635346756
38348,"/** 
 * record that in entity e, the access is performed using a local variable. in  {@link #patchLexicalAccesses(SSAInstruction[],Set)}, this information is used to update an instruction that performs all the accesses at the beginning of the method and defines the locals.
 */
private void addAccess(WalkContext context,CAstEntity e,Access access){
}","/** 
 * record that in entity e, the access is performed. If   {@link #useLocalValuesForLexicalVars()} is true, the access is performedusing a local variable. in {@link #patchLexicalAccesses(SSAInstruction[],Set)}, this information is used to update an instruction that performs all the accesses at the beginning of the method and defines the locals.
 */
private void addAccess(WalkContext context,CAstEntity e,Access access){
  context.getAccesses(e).add(access);
}",0.8543451652386781
38349,"private Set<CGNode> getLexicalDefiners(final CGNode opNode,final Pair<String,String> definer){
  if (definer == null) {
    return Collections.singleton(getBuilder().getCallGraph().getFakeRootNode());
  }
 else {
    final Set<CGNode> result=HashSetFactory.make();
    PointerKey F=getBuilder().getPointerKeyForLocal(opNode,1);
    IR ir=getBuilder().getCFAContextInterpreter().getIR(opNode);
    SymbolTable symtab=ir.getSymbolTable();
    DefUse du=getAnalysisCache().getSSACache().findOrCreateDU(ir,opNode.getContext());
    if (contentsAreInvariant(symtab,du,1)) {
      system.recordImplicitPointsToSet(F);
      final InstanceKey[] functionKeys=getInvariantContents(symtab,du,opNode,1);
      for (int f=0; f < functionKeys.length; f++) {
        system.findOrCreateIndexForInstanceKey(functionKeys[f]);
        ScopeMappingInstanceKey K=(ScopeMappingInstanceKey)functionKeys[f];
        Iterator<CGNode> x=K.getFunargNodes(definer);
        while (x.hasNext()) {
          result.add(x.next());
        }
      }
    }
 else {
      PointsToSetVariable FV=system.findOrCreatePointsToSet(F);
      if (FV.getValue() != null) {
        FV.getValue().foreach(new IntSetAction(){
          public void act(          int ptr){
            InstanceKey iKey=system.getInstanceKey(ptr);
            if (iKey instanceof ScopeMappingInstanceKey) {
              ScopeMappingInstanceKey K=(ScopeMappingInstanceKey)iKey;
              Iterator<CGNode> x=K.getFunargNodes(definer);
              while (x.hasNext()) {
                result.add(x.next());
              }
            }
 else {
              Assertions.UNREACHABLE(""String_Node_Str"" + iKey);
            }
          }
        }
);
      }
    }
    return result;
  }
}","private Set<CGNode> getLexicalDefiners(final CGNode opNode,final Pair<String,String> definer){
}",0.1052054794520548
38350,"@Override public CAstNode visitVariableDeclaration(VariableDeclaration node,WalkContext arg){
  List<VariableInitializer> inits=node.getVariables();
  CAstNode[] children=new CAstNode[inits.size()];
  int i=0;
  for (  VariableInitializer init : inits) {
    arg.addNameDecl(noteSourcePosition(arg,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new CAstSymbolImpl(init.getTarget().getString())),readName(arg,""String_Node_Str"")),node));
    children[i++]=Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(init.getTarget().getString())),visit(init,arg));
  }
  return Ast.makeNode(CAstNode.BLOCK_STMT,children);
}","@Override public CAstNode visitVariableDeclaration(VariableDeclaration node,WalkContext arg){
  List<VariableInitializer> inits=node.getVariables();
  CAstNode[] children=new CAstNode[inits.size()];
  int i=0;
  for (  VariableInitializer init : inits) {
    arg.addNameDecl(noteSourcePosition(arg,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new CAstSymbolImpl(init.getTarget().getString())),readName(arg,""String_Node_Str"")),node));
    if (init.getInitializer() == null) {
      children[i++]=Ast.makeNode(CAstNode.EMPTY);
    }
 else {
      children[i++]=Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(init.getTarget().getString())),visit(init,arg));
    }
  }
  return Ast.makeNode(CAstNode.BLOCK_STMT,children);
}",0.918293564714389
38351,"@Override public CAstNode visitBreakStatement(BreakStatement node,WalkContext arg){
  CAstNode breakStmt;
  if (node.getBreakLabel() != null) {
    breakStmt=Ast.makeNode(CAstNode.GOTO,Ast.makeConstant(node.getBreakLabel().getIdentifier()));
  }
 else {
    breakStmt=Ast.makeNode(CAstNode.GOTO);
  }
  arg.cfg().map(node,breakStmt);
  Node target=node.getBreakTarget();
  arg.cfg().add(node,target,null);
  return breakStmt;
}","@Override public CAstNode visitBreakStatement(BreakStatement node,WalkContext arg){
  CAstNode breakStmt;
  Node target;
  if (node.getBreakLabel() != null) {
    breakStmt=Ast.makeNode(CAstNode.GOTO,Ast.makeConstant(node.getBreakLabel().getIdentifier()));
    target=arg.getBreakFor(node.getBreakLabel().getIdentifier());
  }
 else {
    breakStmt=Ast.makeNode(CAstNode.GOTO);
    target=arg.getBreakFor(null);
  }
  arg.cfg().map(node,breakStmt);
  arg.cfg().add(node,target,null);
  return breakStmt;
}",0.8369098712446352
38352,"@Override public CAstNode visitSwitchStatement(SwitchStatement node,WalkContext context){
  int i=0;
  CAstNode[] children=new CAstNode[node.getCases().size() * 2];
  for (  SwitchCase sc : node.getCases()) {
    CAstNode label=Ast.makeNode(CAstNode.LABEL_STMT,Ast.makeConstant(String.valueOf(i / 2)),Ast.makeNode(CAstNode.EMPTY));
    context.cfg().map(label,label);
    children[i++]=label;
    if (sc.isDefault()) {
      context.cfg().add(node,label,CAstControlFlowMap.SWITCH_DEFAULT);
    }
 else {
      CAstNode labelCAst=visit(sc.getExpression(),context);
      context.cfg().add(node,label,labelCAst);
    }
    children[i++]=visit(sc,context);
  }
  CAstNode s=Ast.makeNode(CAstNode.SWITCH,visit(node.getExpression(),context),Ast.makeNode(CAstNode.BLOCK_STMT,children));
  context.cfg().map(node,s);
  return s;
}","@Override public CAstNode visitSwitchStatement(SwitchStatement node,WalkContext context){
  AstNode breakStmt=makeEmptyLabelStmt(""String_Node_Str"");
  CAstNode breakLabel=visit(breakStmt,context);
  WalkContext switchBodyContext=makeBreakContext(node,context,breakStmt);
  int i=0;
  CAstNode[] children=new CAstNode[node.getCases().size() * 2];
  for (  SwitchCase sc : node.getCases()) {
    CAstNode label=Ast.makeNode(CAstNode.LABEL_STMT,Ast.makeConstant(String.valueOf(i / 2)),Ast.makeNode(CAstNode.EMPTY));
    context.cfg().map(label,label);
    children[i++]=label;
    if (sc.isDefault()) {
      context.cfg().add(node,label,CAstControlFlowMap.SWITCH_DEFAULT);
    }
 else {
      CAstNode labelCAst=visit(sc.getExpression(),context);
      context.cfg().add(node,label,labelCAst);
    }
    children[i++]=visit(sc,switchBodyContext);
  }
  CAstNode s=Ast.makeNode(CAstNode.SWITCH,visit(node.getExpression(),context),Ast.makeNode(CAstNode.BLOCK_STMT,children));
  context.cfg().map(node,s);
  return Ast.makeNode(CAstNode.BLOCK_STMT,s,breakLabel);
}",0.8724760892667375
38353,"@Override public CAstNode visitFunctionCall(FunctionCall n,WalkContext context){
  if (!isPrimitiveCall(context,n)) {
    CAstNode base=Ast.makeNode(CAstNode.VAR,Ast.makeConstant(""String_Node_Str""));
    AstNode callee=n.getTarget();
    WalkContext child=new BaseCollectingContext(context,callee,base);
    CAstNode fun=visit(callee,child);
    CAstNode[] args=gatherCallArguments(n,context);
    if (child.foundBase(callee))     return Ast.makeNode(CAstNode.LOCAL_SCOPE,Ast.makeNode(CAstNode.BLOCK_EXPR,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new CAstSymbolImpl(""String_Node_Str"")),Ast.makeConstant(null)),makeCall(fun,base,args,context)));
 else     return makeCall(fun,makeVarRef(JSSSAPropagationCallGraphBuilder.GLOBAL_OBJ_VAR_NAME),args,context);
  }
 else {
    return Ast.makeNode(CAstNode.PRIMITIVE,gatherCallArguments(n,context));
  }
}","@Override public CAstNode visitFunctionCall(FunctionCall n,WalkContext context){
  if (!isPrimitiveCall(context,n)) {
    CAstNode base=Ast.makeNode(CAstNode.VAR,Ast.makeConstant(baseVarName));
    AstNode callee=n.getTarget();
    WalkContext child=new BaseCollectingContext(context,callee,base);
    CAstNode fun=visit(callee,child);
    CAstNode[] args=gatherCallArguments(n,context);
    if (child.foundBase(callee))     return Ast.makeNode(CAstNode.LOCAL_SCOPE,Ast.makeNode(CAstNode.BLOCK_EXPR,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new CAstSymbolImpl(baseVarName)),Ast.makeConstant(null)),makeCall(fun,base,args,context)));
 else     return makeCall(fun,makeVarRef(JSSSAPropagationCallGraphBuilder.GLOBAL_OBJ_VAR_NAME),args,context);
  }
 else {
    return Ast.makeNode(CAstNode.PRIMITIVE,gatherCallArguments(n,context));
  }
}",0.967020023557126
38354,"@Override public CAstNode visitLabeledStatement(LabeledStatement node,WalkContext arg){
  CAstNode result=visit(node.getStatement(),arg);
  for (  Label label : node.getLabels()) {
    result=Ast.makeNode(CAstNode.LABEL_STMT,visit(label,arg),result);
    arg.cfg().map(label,result);
  }
  return result;
}","@Override public CAstNode visitLabeledStatement(LabeledStatement node,WalkContext arg){
  CAstNode result=visit(node.getStatement(),arg);
  AstNode prev=node;
  for (  Label label : node.getLabels()) {
    result=Ast.makeNode(CAstNode.LABEL_STMT,visit(label,arg),result);
    arg.cfg().map(prev,result);
    prev=label;
  }
  return result;
}",0.904320987654321
38355,"private AbstractScope makeScriptScope(final CAstEntity s,Scope parent){
  return new AbstractScope(parent){
    SymbolTable scriptGlobalSymtab=new SymbolTable(s.getArgumentCount());
    public SymbolTable getUnderlyingSymtab(){
      return scriptGlobalSymtab;
    }
    protected AbstractScope getEntityScope(){
      return this;
    }
    public boolean isLexicallyScoped(    Symbol s){
      if (isGlobal(s))       return false;
 else       return ((AbstractScope)s.getDefiningScope()).getEntityScope() != this;
    }
    public CAstEntity getEntity(){
      return s;
    }
    public ScopeType type(){
      return ScopeType.SCRIPT;
    }
    protected Symbol makeSymbol(    final String nm,    final boolean isFinal,    final boolean isInternalName,    final Object defaultInitValue,    int vn,    Scope definer){
      final int v=vn == -1 ? getUnderlyingSymtab().newSymbol() : vn;
      if (useDefaultInitValues() && defaultInitValue != null) {
        if (getUnderlyingSymtab().getValue(v) == null) {
          setDefaultValue(getUnderlyingSymtab(),v,defaultInitValue);
        }
      }
      return new AbstractSymbol(definer,isFinal,defaultInitValue){
        public String toString(){
          return nm + ""String_Node_Str"" + System.identityHashCode(this);
        }
        public int valueNumber(){
          return v;
        }
        public boolean isInternalName(){
          return isInternalName;
        }
        public boolean isParameter(){
          return false;
        }
      }
;
    }
  }
;
}","private AbstractScope makeScriptScope(final CAstEntity s,Scope parent){
  return new AbstractScope(parent){
    SymbolTable scriptGlobalSymtab=new SymbolTable(s.getArgumentCount());
    public SymbolTable getUnderlyingSymtab(){
      return scriptGlobalSymtab;
    }
    protected AbstractScope getEntityScope(){
      return this;
    }
    public boolean isLexicallyScoped(    Symbol s){
      if (isGlobal(s))       return false;
 else       return ((AbstractScope)s.getDefiningScope()).getEntity() != getEntity();
    }
    public CAstEntity getEntity(){
      return s;
    }
    public ScopeType type(){
      return ScopeType.SCRIPT;
    }
    protected Symbol makeSymbol(    final String nm,    final boolean isFinal,    final boolean isInternalName,    final Object defaultInitValue,    int vn,    Scope definer){
      final int v=vn == -1 ? getUnderlyingSymtab().newSymbol() : vn;
      if (useDefaultInitValues() && defaultInitValue != null) {
        if (getUnderlyingSymtab().getValue(v) == null) {
          setDefaultValue(getUnderlyingSymtab(),v,defaultInitValue);
        }
      }
      return new AbstractSymbol(definer,isFinal,defaultInitValue){
        public String toString(){
          return nm + ""String_Node_Str"" + System.identityHashCode(this);
        }
        public int valueNumber(){
          return v;
        }
        public boolean isInternalName(){
          return isInternalName;
        }
        public boolean isParameter(){
          return false;
        }
      }
;
    }
  }
;
}",0.9934469200524246
38356,"/** 
 * record name as exposed for the current entity and for all enclosing entities up to that of the defining scope, since if the name is updated via a call to a nested function, SSA for these entities may need to be updated with the new definition
 * @param context
 * @param name
 * @param definingScope
 * @param E
 * @param entityName
 * @param isWrite
 */
private void markExposedInEnclosingEntities(WalkContext context,final String name,Scope definingScope,CAstEntity E,final String entityName,boolean isWrite){
  Scope curScope=context.currentScope();
  while (!curScope.equals(definingScope)) {
    final Symbol curSymbol=curScope.lookup(name);
    final int vn=curSymbol.valueNumber();
    final Access A=new Access(name,entityName,vn);
    final CAstEntity entity=curScope.getEntity();
    addExposedName(entity,E,name,vn,isWrite);
    addAccess(entity,A);
    curScope=curScope.getParent();
  }
}","/** 
 * record name as exposed for the current entity and for all enclosing entities up to that of the defining scope, since if the name is updated via a call to a nested function, SSA for these entities may need to be updated with the new definition
 * @param context
 * @param name
 * @param definingScope
 * @param E
 * @param entityName
 * @param isWrite
 */
private void markExposedInEnclosingEntities(WalkContext context,final String name,Scope definingScope,CAstEntity E,final String entityName,boolean isWrite){
  Scope curScope=context.currentScope();
  while (!curScope.equals(definingScope)) {
    final Symbol curSymbol=curScope.lookup(name);
    final int vn=curSymbol.valueNumber();
    final Access A=new Access(name,entityName,vn);
    final CAstEntity entity=curScope.getEntity();
    if (entity != definingScope.getEntity()) {
      addExposedName(entity,E,name,vn,isWrite);
      addAccess(entity,A);
    }
    curScope=curScope.getParent();
  }
}",0.9696
38357,"public Context getCalleeTarget(CGNode caller,CallSiteReference site,IMethod callee,final InstanceKey[] receiver){
  Context baseContext=base.getCalleeTarget(caller,site,callee,receiver);
  String calleeFullName=callee.getDeclaringClass().getName().toString();
  String calleeShortName=calleeFullName.substring(calleeFullName.lastIndexOf('/') + 1);
  if (USE_NAME_TO_SELECT_CONTEXT) {
    if (calleeShortName.contains(HACK_METHOD_STR) && receiver.length > index) {
      return new ForInContext(baseContext,simulateToString(caller.getClassHierarchy(),receiver[index]));
    }
  }
 else   if (receiver.length > index) {
    Frequency f=usesFirstArgAsPropertyName(callee);
    if (f == Frequency.ALWAYS) {
      return new ForInContext(baseContext,simulateToString(caller.getClassHierarchy(),receiver[index]));
    }
 else     if (receiver[index] != null && (f == Frequency.SOMETIMES || forInOnFirstArg(callee))) {
      return new ForInContext(baseContext,receiver[index]);
    }
  }
  if (USE_CPA_IN_BODIES && FORIN_MARKER.equals(caller.getContext().get(FORIN_KEY))) {
    return new SelectiveCPAContext(baseContext,receiver);
  }
 else   if (USE_1LEVEL_IN_BODIES && FORIN_MARKER.equals(caller.getContext().get(FORIN_KEY))) {
    if (!identifyDependentParameters(caller,site).isEmpty()) {
      return oneLevel.getCalleeTarget(caller,site,callee,receiver);
    }
 else {
      return baseContext;
    }
  }
  return baseContext;
}","public Context getCalleeTarget(CGNode caller,CallSiteReference site,IMethod callee,final InstanceKey[] receiver){
  Context baseContext=base.getCalleeTarget(caller,site,callee,receiver);
  String calleeFullName=callee.getDeclaringClass().getName().toString();
  String calleeShortName=calleeFullName.substring(calleeFullName.lastIndexOf('/') + 1);
  if (USE_NAME_TO_SELECT_CONTEXT) {
    if (calleeShortName.contains(HACK_METHOD_STR) && receiver.length > index) {
      return new ForInContext(baseContext,simulateToString(caller.getClassHierarchy(),receiver[index]));
    }
  }
 else   if (receiver.length > index) {
    Frequency f=usesFirstArgAsPropertyName(callee);
    if (f == Frequency.ALWAYS) {
      return new ForInContext(baseContext,simulateToString(caller.getClassHierarchy(),receiver[index]));
    }
 else     if (f == Frequency.SOMETIMES || forInOnFirstArg(callee)) {
      if (receiver[index] == null) {
        IClass undef=caller.getClassHierarchy().lookupClass(JavaScriptTypes.Undefined);
        return new ForInContext(baseContext,new ConcreteTypeKey(undef));
      }
 else {
        return new ForInContext(baseContext,receiver[index]);
      }
    }
  }
  if (USE_CPA_IN_BODIES && FORIN_MARKER.equals(caller.getContext().get(FORIN_KEY))) {
    return new SelectiveCPAContext(baseContext,receiver);
  }
 else   if (USE_1LEVEL_IN_BODIES && FORIN_MARKER.equals(caller.getContext().get(FORIN_KEY))) {
    if (!identifyDependentParameters(caller,site).isEmpty()) {
      return oneLevel.getCalleeTarget(caller,site,callee,receiver);
    }
 else {
      return baseContext;
    }
  }
  return baseContext;
}",0.9171306911234852
38358,"@SuppressWarnings(""String_Node_Str"") AstLexicalInformation(String entityName,Scope scope,SSAInstruction[] instrs,Set<Pair<Pair<String,String>,Integer>> exposedNamesForReadSet,Set<Pair<Pair<String,String>,Integer>> exposedNamesForWriteSet,Set<Access> accesses){
  this.functionLexicalName=entityName;
  Pair<Pair<String,String>,Integer>[] EN=null;
  if (exposedNamesForReadSet != null || exposedNamesForWriteSet != null) {
    Set<Pair<Pair<String,String>,Integer>> exposedNamesSet=new HashSet<Pair<Pair<String,String>,Integer>>();
    if (exposedNamesForReadSet != null) {
      exposedNamesSet.addAll(exposedNamesForReadSet);
    }
    if (exposedNamesForWriteSet != null) {
      exposedNamesSet.addAll(exposedNamesForWriteSet);
    }
    EN=exposedNamesSet.toArray(new Pair[exposedNamesSet.size()]);
  }
  if (exposedNamesForReadSet != null) {
    Set<String> readOnlyNames=new HashSet<String>();
    for (    Pair<Pair<String,String>,Integer> v : exposedNamesForReadSet) {
      if (entityName != null && entityName.equals(v.fst.snd)) {
        readOnlyNames.add(v.fst.fst);
      }
    }
    if (exposedNamesForWriteSet != null) {
      for (      Pair<Pair<String,String>,Integer> v : exposedNamesForWriteSet) {
        if (entityName != null && entityName.equals(v.fst.snd)) {
          readOnlyNames.remove(v.fst.fst);
        }
      }
    }
    this.readOnlyNames=readOnlyNames;
  }
 else {
    this.readOnlyNames=null;
  }
  this.exposedNames=buildLexicalNamesArray(EN);
  this.exitLexicalUses=buildLexicalUseArray(EN,entityName);
  this.instructionLexicalUses=new int[instrs.length][];
  for (int i=0; i < instrs.length; i++) {
    if (instrs[i] instanceof SSAAbstractInvokeInstruction) {
      this.instructionLexicalUses[i]=buildLexicalUseArray(EN,null);
    }
  }
  if (accesses != null) {
    Set<String> parents=new LinkedHashSet<String>();
    for (Iterator<Access> ACS=accesses.iterator(); ACS.hasNext(); ) {
      Access AC=ACS.next();
      if (AC.variableDefiner != null) {
        parents.add(AC.variableDefiner);
      }
    }
    scopingParents=parents.toArray(new String[parents.size()]);
    if (DEBUG_LEXICAL) {
      System.err.println((""String_Node_Str"" + scope.getEntity()));
      System.err.println(parents.toString());
    }
  }
 else {
    scopingParents=null;
  }
  if (DEBUG_NAMES) {
    System.err.println((""String_Node_Str"" + scope.getEntity()));
    for (int i=0; i < instructionLexicalUses.length; i++) {
      if (instructionLexicalUses[i] != null) {
        System.err.println((""String_Node_Str"" + instrs[i]));
        for (int j=0; j < instructionLexicalUses[i].length; j++) {
          System.err.println((""String_Node_Str"" + this.exposedNames[j].fst + ""String_Node_Str""+ instructionLexicalUses[i][j]));
        }
      }
    }
  }
}","@SuppressWarnings(""String_Node_Str"") AstLexicalInformation(String entityName,Scope scope,SSAInstruction[] instrs,Set<Pair<Pair<String,String>,Integer>> exposedNamesForReadSet,Set<Pair<Pair<String,String>,Integer>> exposedNamesForWriteSet,Set<Access> accesses){
  if (entityName.contains(""String_Node_Str"")) {
    System.err.println(""String_Node_Str"");
  }
  this.functionLexicalName=entityName;
  Pair<Pair<String,String>,Integer>[] EN=null;
  if (exposedNamesForReadSet != null || exposedNamesForWriteSet != null) {
    Set<Pair<Pair<String,String>,Integer>> exposedNamesSet=new HashSet<Pair<Pair<String,String>,Integer>>();
    if (exposedNamesForReadSet != null) {
      exposedNamesSet.addAll(exposedNamesForReadSet);
    }
    if (exposedNamesForWriteSet != null) {
      exposedNamesSet.addAll(exposedNamesForWriteSet);
    }
    EN=exposedNamesSet.toArray(new Pair[exposedNamesSet.size()]);
  }
  if (exposedNamesForReadSet != null) {
    Set<String> readOnlyNames=new HashSet<String>();
    for (    Pair<Pair<String,String>,Integer> v : exposedNamesForReadSet) {
      if (entityName != null && entityName.equals(v.fst.snd)) {
        readOnlyNames.add(v.fst.fst);
      }
    }
    if (exposedNamesForWriteSet != null) {
      for (      Pair<Pair<String,String>,Integer> v : exposedNamesForWriteSet) {
        if (entityName != null && entityName.equals(v.fst.snd)) {
          readOnlyNames.remove(v.fst.fst);
        }
      }
    }
    this.readOnlyNames=readOnlyNames;
  }
 else {
    this.readOnlyNames=null;
  }
  this.exposedNames=buildLexicalNamesArray(EN);
  this.exitLexicalUses=buildLexicalUseArray(EN,entityName);
  this.instructionLexicalUses=new int[instrs.length][];
  for (int i=0; i < instrs.length; i++) {
    if (instrs[i] instanceof SSAAbstractInvokeInstruction) {
      this.instructionLexicalUses[i]=buildLexicalUseArray(EN,null);
    }
  }
  if (accesses != null) {
    Set<String> parents=new LinkedHashSet<String>();
    for (Iterator<Access> ACS=accesses.iterator(); ACS.hasNext(); ) {
      Access AC=ACS.next();
      if (AC.variableDefiner != null) {
        parents.add(AC.variableDefiner);
      }
    }
    scopingParents=parents.toArray(new String[parents.size()]);
    if (DEBUG_LEXICAL) {
      System.err.println((""String_Node_Str"" + scope.getEntity()));
      System.err.println(parents.toString());
    }
  }
 else {
    scopingParents=null;
  }
  if (DEBUG_NAMES) {
    System.err.println((""String_Node_Str"" + scope.getEntity()));
    for (int i=0; i < instructionLexicalUses.length; i++) {
      if (instructionLexicalUses[i] != null) {
        System.err.println((""String_Node_Str"" + instrs[i]));
        for (int j=0; j < instructionLexicalUses[i].length; j++) {
          System.err.println((""String_Node_Str"" + this.exposedNames[j].fst + ""String_Node_Str""+ instructionLexicalUses[i][j]));
        }
      }
    }
  }
}",0.9831888161387364
38359,"/** 
 * Note that the caller is responsible for ensuring that name is defined in a lexical scope.
 * @param node the AST node representing the read
 * @param context
 * @param name
 * @return
 */
protected int doLexicallyScopedRead(CAstNode node,WalkContext context,String name){
  Symbol S=context.currentScope().lookup(name);
  CAstEntity E=S.getDefiningScope().getEntity();
  addExposedName(E,E,name,S.getDefiningScope().lookup(name).valueNumber(),false);
  int vn=S.valueNumber();
  if (useLocalValuesForLexicalVars()) {
    Access A=new Access(name,getEntityName(E),vn);
    addExposedName(context.top(),E,name,vn,false);
    addAccess(context.top(),A);
    return vn;
  }
 else {
    int result=context.currentScope().allocateTempValue();
    Access A=new Access(name,getEntityName(E),result);
    context.cfg().addInstruction(new AstLexicalRead(A));
    return result;
  }
}","/** 
 * Note that the caller is responsible for ensuring that name is defined in a lexical scope.
 * @param node the AST node representing the read
 * @param context
 * @param name
 * @return
 */
protected int doLexicallyScopedRead(CAstNode node,WalkContext context,final String name){
  if (name.equals(""String_Node_Str"")) {
    System.err.println(""String_Node_Str"");
  }
  Symbol S=context.currentScope().lookup(name);
  Scope definingScope=S.getDefiningScope();
  CAstEntity E=definingScope.getEntity();
  addExposedName(E,E,name,definingScope.lookup(name).valueNumber(),false);
  String entityName=getEntityName(E);
  if (useLocalValuesForLexicalVars()) {
    Scope curScope=context.currentScope();
    while (!curScope.equals(definingScope)) {
      Symbol curSymbol=curScope.lookup(name);
      final int vn=curSymbol.valueNumber();
      Access A=new Access(name,entityName,vn);
      CAstEntity entity=curScope.getEntity();
      addExposedName(entity,E,name,vn,false);
      addAccess(entity,A);
      curScope=curScope.getParent();
    }
    return S.valueNumber();
  }
 else {
    int result=context.currentScope().allocateTempValue();
    Access A=new Access(name,entityName,result);
    context.cfg().addInstruction(new AstLexicalRead(A));
    return result;
  }
}",0.4865616311399444
38360,"public Context getCalleeTarget(CGNode caller,CallSiteReference site,IMethod callee,final InstanceKey[] receiver){
  Context baseContext=base.getCalleeTarget(caller,site,callee,receiver);
  if (useForInContext(callee,receiver)) {
    InstanceKey loopVar=receiver[2];
    IClass stringClass=caller.getClassHierarchy().lookupClass(JavaScriptTypes.String);
    if (loopVar instanceof ConstantKey) {
      Object value=((ConstantKey)loopVar).getValue();
      if (value instanceof String) {
        return new ForInContext(baseContext,loopVar);
      }
 else       if (value instanceof Number) {
        Integer ival=((Number)value).intValue();
        return new ForInContext(baseContext,new ConstantKey<String>(ival.toString(),stringClass));
      }
 else       if (value instanceof Boolean) {
        Boolean bval=(Boolean)value;
        return new ForInContext(baseContext,new ConstantKey<String>(bval.toString(),stringClass));
      }
 else       if (value == null) {
        return new ForInContext(baseContext,new ConstantKey<String>(""String_Node_Str"",stringClass));
      }
    }
    ConcreteTypeKey stringKey=new ConcreteTypeKey(stringClass);
    return new ForInContext(baseContext,stringKey);
  }
 else   if (USE_CPA_IN_BODIES && FORIN_MARKER.equals(caller.getContext().get(FORIN_KEY))) {
    return new SelectiveCPAContext(baseContext,receiver);
  }
 else   if (USE_1LEVEL_IN_BODIES && FORIN_MARKER.equals(caller.getContext().get(FORIN_KEY))) {
    if (!identifyDependentParameters(caller,site).isEmpty()) {
      return oneLevel.getCalleeTarget(caller,site,callee,receiver);
    }
 else {
      return baseContext;
    }
  }
 else {
    return baseContext;
  }
}","public Context getCalleeTarget(CGNode caller,CallSiteReference site,IMethod callee,final InstanceKey[] receiver){
  Context baseContext=base.getCalleeTarget(caller,site,callee,receiver);
  String calleeFullName=callee.getDeclaringClass().getName().toString();
  String calleeShortName=calleeFullName.substring(calleeFullName.lastIndexOf('/') + 1);
  if (USE_NAME_TO_SELECT_CONTEXT) {
    if (calleeShortName.contains(HACK_METHOD_STR)) {
      return new ForInContext(baseContext,simulateToString(caller.getClassHierarchy(),receiver[2]));
    }
  }
 else   if (receiver.length > 2 && receiver[2] != null) {
    Frequency f=usesFirstArgAsPropertyName(callee);
    if (f == Frequency.ALWAYS) {
      return new ForInContext(baseContext,simulateToString(caller.getClassHierarchy(),receiver[2]));
    }
 else     if (f == Frequency.SOMETIMES || forInOnFirstArg(callee)) {
      return new ForInContext(baseContext,receiver[2]);
    }
  }
  if (USE_CPA_IN_BODIES && FORIN_MARKER.equals(caller.getContext().get(FORIN_KEY))) {
    return new SelectiveCPAContext(baseContext,receiver);
  }
 else   if (USE_1LEVEL_IN_BODIES && FORIN_MARKER.equals(caller.getContext().get(FORIN_KEY))) {
    if (!identifyDependentParameters(caller,site).isEmpty()) {
      return oneLevel.getCalleeTarget(caller,site,callee,receiver);
    }
 else {
      return baseContext;
    }
  }
  return baseContext;
}",0.5068852459016393
38361,"private boolean usesFirstArgAsPropertyName(IMethod method){
  if (method.getNumberOfParameters() < 2)   return false;
  Boolean b=usesFirstArgAsPropertyName_cache.get(method);
  if (b != null)   return b;
  DefUse du=getDefUse(method);
  for (  SSAInstruction use : Iterator2Iterable.make(du.getUses(3))) {
    if (use instanceof ReflectiveMemberAccess) {
      ReflectiveMemberAccess rma=(ReflectiveMemberAccess)use;
      if (rma.getMemberRef() == 3) {
        usesFirstArgAsPropertyName_cache.put(method,true);
        return true;
      }
    }
  }
  usesFirstArgAsPropertyName_cache.put(method,false);
  return false;
}","private Frequency usesFirstArgAsPropertyName(IMethod method){
  if (method.getNumberOfParameters() < 2)   return Frequency.NEVER;
  Frequency f=usesFirstArgAsPropertyName_cache.get(method);
  if (f != null)   return f;
  boolean usedAsPropertyName=false, usedAsSomethingElse=false;
  DefUse du=getDefUse(method);
  for (  SSAInstruction use : Iterator2Iterable.make(du.getUses(3))) {
    if (use instanceof ReflectiveMemberAccess) {
      ReflectiveMemberAccess rma=(ReflectiveMemberAccess)use;
      if (rma.getMemberRef() == 3) {
        usedAsPropertyName=true;
        continue;
      }
    }
    usedAsSomethingElse=true;
  }
  if (!usedAsPropertyName)   f=Frequency.NEVER;
 else   if (usedAsSomethingElse)   f=Frequency.SOMETIMES;
 else   f=Frequency.ALWAYS;
  usesFirstArgAsPropertyName_cache.put(method,f);
  return f;
}",0.5840220385674931
38362,"/** 
 * get the CGNode representing the lexical parent of   {@link #creator} withname definer
 * @param definer
 * @return
 */
Iterator<CGNode> getFunargNodes(Pair<String,String> name){
  Iterator<CGNode> result=EmptyIterator.instance();
  LexicalScopingResolver r=(LexicalScopingResolver)creator.getContext().get(LexicalScopingResolverContexts.RESOLVER);
  if (r != null) {
    CGNode def=r.getOriginalDefiner(name);
    if (def != null) {
      result=new NonNullSingletonIterator<CGNode>(def);
    }
  }
  PointerKey funcKey=builder.getPointerKeyForLocal(creator,1);
  OrdinalSet<InstanceKey> funcPtrs=builder.getPointerAnalysis().getPointsToSet(funcKey);
  for (  InstanceKey x : funcPtrs) {
    if (x instanceof ScopeMappingInstanceKey) {
      result=new CompoundIterator<CGNode>(result,((ScopeMappingInstanceKey)x).getFunargNodes(name));
    }
  }
  return result;
}","/** 
 * get the CGNode representing the lexical parent of   {@link #creator} withname definer
 * @param definer
 * @return
 */
Iterator<CGNode> getFunargNodes(Pair<String,String> name){
  Iterator<CGNode> result=EmptyIterator.instance();
  LexicalScopingResolver r=(LexicalScopingResolver)creator.getContext().get(LexicalScopingResolverContexts.RESOLVER);
  if (r != null) {
    CGNode def=r.getOriginalDefiner(name);
    if (def != null) {
      result=new NonNullSingletonIterator<CGNode>(def);
    }
  }
  ContextItem nested=creator.getContext().get(ScopeMappingKeysContextSelector.scopeKey);
  if (nested != null) {
    result=new CompoundIterator<CGNode>(result,((ScopeMappingInstanceKey)nested).getFunargNodes(name));
  }
  PointerKey funcKey=builder.getPointerKeyForLocal(creator,1);
  OrdinalSet<InstanceKey> funcPtrs=builder.getPointerAnalysis().getPointsToSet(funcKey);
  for (  InstanceKey x : funcPtrs) {
    if (x instanceof ScopeMappingInstanceKey) {
      result=new CompoundIterator<CGNode>(result,((ScopeMappingInstanceKey)x).getFunargNodes(name));
    }
  }
  return result;
}",0.887646161667514
38363,"/** 
 * compute the   {@link CGNode} correspond to each specified{@link LexicalParent} of {@link #base}, populating   {@link #scopeMap}
 */
private ScopeMappingInstanceKey(CGNode creator,InstanceKey base){
  this.creator=creator;
  this.base=base;
}","private ScopeMappingInstanceKey(CGNode creator,InstanceKey base){
  this.creator=creator;
  this.base=base;
}",0.6089385474860335
38364,"/** 
 * Note that the caller is responsible for ensuring that name is defined in a lexical scope.
 * @param node the AST node representing the read
 * @param context
 * @param name
 * @return
 */
protected int doLexicallyScopedRead(CAstNode node,WalkContext context,final String name){
  if (name.equals(""String_Node_Str"")) {
    System.err.println(""String_Node_Str"");
  }
  Symbol S=context.currentScope().lookup(name);
  Scope definingScope=S.getDefiningScope();
  CAstEntity E=definingScope.getEntity();
  addExposedName(E,E,name,definingScope.lookup(name).valueNumber(),false);
  String entityName=getEntityName(E);
  if (useLocalValuesForLexicalVars()) {
    Scope curScope=context.currentScope();
    while (!curScope.equals(definingScope)) {
      Symbol curSymbol=curScope.lookup(name);
      final int vn=curSymbol.valueNumber();
      Access A=new Access(name,entityName,vn);
      CAstEntity entity=curScope.getEntity();
      addExposedName(entity,E,name,vn,false);
      addAccess(entity,A);
      curScope=curScope.getParent();
    }
    return S.valueNumber();
  }
 else {
    int result=context.currentScope().allocateTempValue();
    Access A=new Access(name,entityName,result);
    context.cfg().addInstruction(new AstLexicalRead(A));
    return result;
  }
}","/** 
 * Note that the caller is responsible for ensuring that name is defined in a lexical scope.
 * @param node the AST node representing the read
 * @param context
 * @param name
 * @return
 */
protected int doLexicallyScopedRead(CAstNode node,WalkContext context,final String name){
  Symbol S=context.currentScope().lookup(name);
  Scope definingScope=S.getDefiningScope();
  CAstEntity E=definingScope.getEntity();
  addExposedName(E,E,name,definingScope.lookup(name).valueNumber(),false);
  final String entityName=getEntityName(E);
  if (useLocalValuesForLexicalVars()) {
    markExposedInEnclosingEntities(context,name,definingScope,E,entityName,false);
    return S.valueNumber();
  }
 else {
    int result=context.currentScope().allocateTempValue();
    Access A=new Access(name,entityName,result);
    context.cfg().addInstruction(new AstLexicalRead(A));
    return result;
  }
}",0.5987084870848709
38365,"/** 
 * Note that the caller is responsible for ensuring that name is defined in a lexical scope.
 */
protected void doLexicallyScopedWrite(WalkContext context,String name,int rval){
  Symbol S=context.currentScope().lookup(name);
  CAstEntity E=S.getDefiningScope().getEntity();
  addExposedName(E,E,name,S.getDefiningScope().lookup(name).valueNumber(),true);
  if (useLocalValuesForLexicalVars()) {
    int vn=S.valueNumber();
    Access A=new Access(name,getEntityName(E),vn);
    addExposedName(context.top(),E,name,vn,true);
    addAccess(context.top(),A);
    context.cfg().addInstruction(new AssignInstruction(vn,rval));
    context.cfg().addInstruction(new AstLexicalWrite(A));
  }
 else {
    Access A=new Access(name,getEntityName(E),rval);
    context.cfg().addInstruction(new AstLexicalWrite(A));
  }
}","/** 
 * Note that the caller is responsible for ensuring that name is defined in a lexical scope.
 */
protected void doLexicallyScopedWrite(WalkContext context,String name,int rval){
  Symbol S=context.currentScope().lookup(name);
  Scope definingScope=S.getDefiningScope();
  CAstEntity E=definingScope.getEntity();
  addExposedName(E,E,name,definingScope.lookup(name).valueNumber(),true);
  if (useLocalValuesForLexicalVars()) {
    markExposedInEnclosingEntities(context,name,definingScope,E,getEntityName(E),true);
    int vn=S.valueNumber();
    Access A=new Access(name,getEntityName(E),vn);
    context.cfg().addInstruction(new AssignInstruction(vn,rval));
    context.cfg().addInstruction(new AstLexicalWrite(A));
  }
 else {
    Access A=new Access(name,getEntityName(E),rval);
    context.cfg().addInstruction(new AstLexicalWrite(A));
  }
}",0.6009615384615384
38366,"public void setLexicallyMutatedIR(IR ir){
  lexicalScopingChanges=true;
  cachedIR=ir;
  cachedDU=new DefUse(ir);
}","public void setLexicallyMutatedIR(IR ir){
  lexicalScopingChanges=true;
  cachedIR=ir;
  cachedDU=null;
}",0.9272727272727272
38367,"public DefUse getLexicallyMutatedDU(){
  if (lexicalScopingChanges) {
    return cachedDU;
  }
 else {
    return null;
  }
}","public DefUse getLexicallyMutatedDU(){
  if (lexicalScopingChanges) {
    if (cachedDU == null) {
      cachedDU=new DefUse(cachedIR);
    }
    return cachedDU;
  }
 else {
    return null;
  }
}",0.778816199376947
38368,"protected CAstNode copyNodes(CAstNode root,RewriteContext context,Map<Pair<CAstNode,ExpanderKey>,CAstNode> nodeMap){
  int kind=root.getKind();
  if (kind == CAstNode.OBJECT_REF && context.inRead()) {
    CAstNode readLoop;
    CAstNode receiver=copyNodes(root.getChild(0),READ,nodeMap);
    CAstNode element=copyNodes(root.getChild(1),READ,nodeMap);
    if (element.getKind() == CAstNode.CONSTANT && element.getValue() instanceof String) {
      readLoop=makeConstRead(root,receiver,element,context,nodeMap);
    }
 else {
      readLoop=makeVarRead(root,receiver,element,context,nodeMap);
    }
    return readLoop;
  }
 else   if (kind == CAstNode.ASSIGN_PRE_OP || kind == CAstNode.ASSIGN_POST_OP) {
    AssignPreOrPostOpContext ctxt=new AssignPreOrPostOpContext();
    CAstNode lval=copyNodes(root.getChild(0),ctxt,nodeMap);
    CAstNode rval=copyNodes(root.getChild(1),READ,nodeMap);
    CAstNode op=copyNodes(root.getChild(2),READ,nodeMap);
    if (ctxt.receiverTemp != null) {
      String temp1=TEMP_NAME + (readTempCounter++);
      String temp2=TEMP_NAME + (readTempCounter++);
      CAstNode copy=Ast.makeNode(CAstNode.BLOCK_EXPR,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new InternalCAstSymbol(temp1,true,false)),lval),rval,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new InternalCAstSymbol(temp2,true,false)),Ast.makeNode(CAstNode.BINARY_EXPR,op,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(temp1)),rval)),Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.OBJECT_REF,ctxt.receiverTemp,ctxt.elementTemp),Ast.makeNode(CAstNode.VAR,Ast.makeConstant(temp2))),Ast.makeNode(CAstNode.VAR,Ast.makeConstant((kind == CAstNode.ASSIGN_PRE_OP) ? temp2 : temp1)));
      nodeMap.put(Pair.make(root,context.key()),copy);
      return copy;
    }
 else {
      CAstNode copy=Ast.makeNode(kind,lval,rval,op);
      nodeMap.put(Pair.make(root,context.key()),copy);
      return copy;
    }
  }
 else   if (kind == CAstNode.ASSIGN) {
    CAstNode copy=Ast.makeNode(CAstNode.ASSIGN,copyNodes(root.getChild(0),ASSIGN,nodeMap),copyNodes(root.getChild(1),READ,nodeMap));
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
 else   if (kind == CAstNode.BLOCK_EXPR) {
    CAstNode children[]=new CAstNode[root.getChildCount()];
    int last=(children.length - 1);
    for (int i=0; i < last; i++) {
      children[i]=copyNodes(root.getChild(i),READ,nodeMap);
    }
    children[last]=copyNodes(root.getChild(last),context,nodeMap);
    CAstNode copy=Ast.makeNode(CAstNode.BLOCK_EXPR,children);
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
 else   if (root.getKind() == CAstNode.CONSTANT) {
    CAstNode copy=Ast.makeConstant(root.getValue());
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
 else   if (root.getKind() == CAstNode.OPERATOR) {
    nodeMap.put(Pair.make(root,context.key()),root);
    return root;
  }
 else {
    CAstNode children[]=new CAstNode[root.getChildCount()];
    for (int i=0; i < children.length; i++) {
      children[i]=copyNodes(root.getChild(i),READ,nodeMap);
    }
    CAstNode copy=Ast.makeNode(kind,children);
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
}","protected CAstNode copyNodes(CAstNode root,RewriteContext context,Map<Pair<CAstNode,ExpanderKey>,CAstNode> nodeMap){
  int kind=root.getKind();
  if (kind == CAstNode.OBJECT_REF && context.inRead()) {
    CAstNode readLoop;
    CAstNode receiver=copyNodes(root.getChild(0),READ,nodeMap);
    CAstNode element=copyNodes(root.getChild(1),READ,nodeMap);
    if (element.getKind() == CAstNode.CONSTANT && element.getValue() instanceof String) {
      readLoop=makeConstRead(root,receiver,element,context,nodeMap);
    }
 else {
      readLoop=makeVarRead(root,receiver,element,context,nodeMap);
    }
    return readLoop;
  }
 else   if (kind == CAstNode.ASSIGN_PRE_OP || kind == CAstNode.ASSIGN_POST_OP) {
    AssignPreOrPostOpContext ctxt=new AssignPreOrPostOpContext();
    CAstNode lval=copyNodes(root.getChild(0),ctxt,nodeMap);
    CAstNode rval=copyNodes(root.getChild(1),READ,nodeMap);
    CAstNode op=copyNodes(root.getChild(2),READ,nodeMap);
    if (ctxt.receiverTemp != null) {
      String temp1=TEMP_NAME + (readTempCounter++);
      String temp2=TEMP_NAME + (readTempCounter++);
      CAstNode copy=Ast.makeNode(CAstNode.BLOCK_EXPR,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new InternalCAstSymbol(temp1,true,false)),lval),Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new InternalCAstSymbol(temp2,true,false)),Ast.makeNode(CAstNode.BINARY_EXPR,op,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(temp1)),rval)),Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.OBJECT_REF,ctxt.receiverTemp,ctxt.elementTemp),Ast.makeNode(CAstNode.VAR,Ast.makeConstant(temp2))),Ast.makeNode(CAstNode.VAR,Ast.makeConstant((kind == CAstNode.ASSIGN_PRE_OP) ? temp2 : temp1)));
      nodeMap.put(Pair.make(root,context.key()),copy);
      return copy;
    }
 else {
      CAstNode copy=Ast.makeNode(kind,lval,rval,op);
      nodeMap.put(Pair.make(root,context.key()),copy);
      return copy;
    }
  }
 else   if (kind == CAstNode.ASSIGN) {
    CAstNode copy=Ast.makeNode(CAstNode.ASSIGN,copyNodes(root.getChild(0),ASSIGN,nodeMap),copyNodes(root.getChild(1),READ,nodeMap));
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
 else   if (kind == CAstNode.BLOCK_EXPR) {
    CAstNode children[]=new CAstNode[root.getChildCount()];
    int last=(children.length - 1);
    for (int i=0; i < last; i++) {
      children[i]=copyNodes(root.getChild(i),READ,nodeMap);
    }
    children[last]=copyNodes(root.getChild(last),context,nodeMap);
    CAstNode copy=Ast.makeNode(CAstNode.BLOCK_EXPR,children);
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
 else   if (root.getKind() == CAstNode.CONSTANT) {
    CAstNode copy=Ast.makeConstant(root.getValue());
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
 else   if (root.getKind() == CAstNode.OPERATOR) {
    nodeMap.put(Pair.make(root,context.key()),root);
    return root;
  }
 else {
    CAstNode children[]=new CAstNode[root.getChildCount()];
    for (int i=0; i < children.length; i++) {
      children[i]=copyNodes(root.getChild(i),READ,nodeMap);
    }
    CAstNode copy=Ast.makeNode(kind,children);
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
}",0.9992166692777692
38369,"public boolean inRead(){
  return false;
}","public boolean inRead(){
  return true;
}",0.9156626506024096
38370,"public void setAssign(CAstNode receiverTemp,CAstNode elementTemp){
  Assertions.UNREACHABLE();
}","/** 
 * store the CAstNodes used to represent the loop variable for the prototype-chain traversal (receiverTemp) and the desired property (elementTemp)
 */
public void setAssign(CAstNode receiverTemp,CAstNode elementTemp){
  this.receiverTemp=receiverTemp;
  this.elementTemp=elementTemp;
}",0.3834196891191709
38371,"/** 
 * @return the indices i s.t. x[i] == y, or null if none found.
 */
private int[] extractIndices(int[] x,int y){
  int count=0;
  for (int i=0; i < x.length; i++) {
    if (x[i] == y) {
      count++;
    }
  }
  if (count == 0) {
    return null;
  }
 else {
    int[] result=new int[count];
    int j=0;
    for (int i=0; i < x.length; i++) {
      if (x[i] == y) {
        result[j++]=i;
      }
    }
    return result;
  }
}","/** 
 * @return the indices i s.t. x[i] == y, or null if none found.
 */
private int[] extractIndices(int[] x,int y){
}",0.430379746835443
38372,"/** 
 * @param pc a program counter (index into ShrikeBT instruction array)
 * @param vn a value number
 * @return if we know that immediately after the given program counter, v_vn corresponds to some set of locals, then return anarray of the local numbers. else return null.
 */
private int[] findLocalsForValueNumber(int pc,int vn){
  IBasicBlock bb=shrikeCFG.getBlockForInstruction(pc);
  int firstInstruction=bb.getFirstInstructionIndex();
  int[] locals=block2LocalState[bb.getNumber()];
  for (int i=firstInstruction; i <= pc; i++) {
    if (localStoreMap[i] != null) {
      IntPair p=localStoreMap[i];
      setLocal(locals,p.getY(),p.getX());
    }
  }
  return extractIndices(locals,vn);
}","/** 
 * @param pc a program counter (index into ShrikeBT instruction array)
 * @param vn a value number
 * @return if we know that immediately after the given program counter, v_vn corresponds to some set of locals, then return anarray of the local numbers. else return null.
 */
private int[] findLocalsForValueNumber(int pc,int vn){
  if (vn < 0) {
    return null;
  }
  IBasicBlock bb=shrikeCFG.getBlockForInstruction(pc);
  int firstInstruction=bb.getFirstInstructionIndex();
  int[] locals=block2LocalState[bb.getNumber()];
  for (int i=firstInstruction; i <= pc; i++) {
    if (localStoreMap[i] != null) {
      IntPair p=localStoreMap[i];
      locals=setLocal(locals,p.getY(),p.getX());
    }
  }
  return locals == null ? null : extractIndices(locals,vn);
}",0.9536152796725784
38373,"private static String composeString(Collection<String> s){
  StringBuffer result=new StringBuffer();
  Iterator<String> it=s.iterator();
  for (int i=0; i < s.size() - 1; i++) {
    result.append(it.next());
    result.append(';');
  }
  if (it.hasNext()) {
    result.append(it.next());
  }
  return result.toString();
}","private static String composeString(Collection<String> s){
  StringBuffer result=new StringBuffer();
  Iterator<String> it=s.iterator();
  for (int i=0; i < s.size() - 1; i++) {
    result.append(it.next());
    result.append(File.pathSeparator);
  }
  if (it.hasNext()) {
    result.append(it.next());
  }
  return result.toString();
}",0.9680365296803652
38374,"public void copyState(IVariable v){
  MachineState other=(MachineState)v;
  if (other.stack == null) {
    stack=null;
  }
 else {
    stack=new int[other.stack.length];
    System.arraycopy(other.stack,0,stack,0,other.stack.length);
  }
  if (other.locals == null) {
    locals=null;
  }
 else {
    locals=new int[other.locals.length];
    System.arraycopy(other.locals,0,locals,0,other.locals.length);
  }
  stackHeight=other.stackHeight;
}","public void copyState(MachineState other){
  if (other.stack == null) {
    stack=null;
  }
 else {
    stack=new int[other.stack.length];
    System.arraycopy(other.stack,0,stack,0,other.stack.length);
  }
  if (other.locals == null) {
    locals=null;
  }
 else {
    locals=new int[other.locals.length];
    System.arraycopy(other.locals,0,locals,0,other.locals.length);
  }
  stackHeight=other.stackHeight;
}",0.0912280701754386
38375,"/** 
 * @return the state at the entry to a given block
 */
public MachineState getIn(ShrikeCFG.BasicBlock bb){
  return (MachineState)solver.getIn(bb);
}","/** 
 * @return the state at the entry to a given block
 */
public MachineState getIn(ShrikeCFG.BasicBlock bb){
  return solver.getIn(bb);
}",0.9523809523809524
38376,"public MachineState getEntryState(){
  return (MachineState)solver.getIn(cfg.entry());
}","public MachineState getEntryState(){
  return solver.getIn(cfg.entry());
}",0.9135802469135802
38377,"public nCFABuilder(int n,IClassHierarchy cha,AnalysisOptions options,AnalysisCache cache,ContextSelector appContextSelector,SSAContextInterpreter appContextInterpreter){
  super(cha,options,cache,new DefaultPointerKeyFactory());
  if (options == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  setInstanceKeys(new ClassBasedInstanceKeys(options,cha));
  ContextSelector def=new DefaultContextSelector(options,cha);
  ContextSelector contextSelector=new DelegatingContextSelector(appContextSelector,def);
  contextSelector=new nCFAContextSelector(n,contextSelector);
  setContextSelector(contextSelector);
  SSAContextInterpreter defI=new DefaultSSAInterpreter(options,cache);
  defI=new DelegatingSSAContextInterpreter(ReflectionContextInterpreter.createReflectionContextInterpreter(cha,options,getAnalysisCache()),defI);
  SSAContextInterpreter contextInterpreter=new DelegatingSSAContextInterpreter(appContextInterpreter,defI);
  setContextInterpreter(contextInterpreter);
}","public nCFABuilder(int n,IClassHierarchy cha,AnalysisOptions options,AnalysisCache cache,ContextSelector appContextSelector,SSAContextInterpreter appContextInterpreter){
  super(cha,options,cache,new DefaultPointerKeyFactory());
  if (options == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  setInstanceKeys(new ClassBasedInstanceKeys(options,cha));
  ContextSelector def=new DefaultContextSelector(options,cha);
  ContextSelector contextSelector=appContextSelector == null ? def : new DelegatingContextSelector(appContextSelector,def);
  contextSelector=new nCFAContextSelector(n,contextSelector);
  setContextSelector(contextSelector);
  SSAContextInterpreter defI=new DefaultSSAInterpreter(options,cache);
  defI=new DelegatingSSAContextInterpreter(ReflectionContextInterpreter.createReflectionContextInterpreter(cha,options,getAnalysisCache()),defI);
  SSAContextInterpreter contextInterpreter=appContextInterpreter == null ? defI : new DelegatingSSAContextInterpreter(appContextInterpreter,defI);
  setContextInterpreter(contextInterpreter);
}",0.964354527938343
38378,"protected CAstNode copyNodes(CAstNode root,RewriteContext context,Map<Pair<CAstNode,NoKey>,CAstNode> nodeMap){
  int kind=root.getKind();
  if (kind == CAstNode.OBJECT_REF && context.inRead()) {
    CAstNode readLoop;
    CAstNode receiver=copyNodes(root.getChild(0),READ,nodeMap);
    CAstNode element=copyNodes(root.getChild(1),READ,nodeMap);
    if (element.getKind() == CAstNode.CONSTANT && element.getValue() instanceof String) {
      readLoop=makeConstRead(root,receiver,element,context,nodeMap);
    }
 else {
      readLoop=makeVarRead(root,receiver,element,context,nodeMap);
    }
    return readLoop;
  }
 else   if (kind == CAstNode.ASSIGN_PRE_OP || kind == CAstNode.ASSIGN_POST_OP) {
    AssignPreOrPostOpContext ctxt=new AssignPreOrPostOpContext();
    CAstNode lval=copyNodes(root.getChild(0),ctxt,nodeMap);
    CAstNode rval=copyNodes(root.getChild(1),READ,nodeMap);
    CAstNode op=copyNodes(root.getChild(2),READ,nodeMap);
    if (ctxt.receiverTemp != null) {
      String temp1=TEMP_NAME + (readTempCounter++);
      String temp2=TEMP_NAME + (readTempCounter++);
      CAstNode copy=Ast.makeNode(CAstNode.BLOCK_EXPR,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new InternalCAstSymbol(temp1,true,false)),lval),rval,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new InternalCAstSymbol(temp2,true,false)),Ast.makeNode(CAstNode.BINARY_EXPR,op,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(temp1)),rval)),Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.OBJECT_REF,ctxt.receiverTemp,ctxt.elementTemp),Ast.makeNode(CAstNode.VAR,Ast.makeConstant(temp2))),Ast.makeNode(CAstNode.VAR,Ast.makeConstant((kind == CAstNode.ASSIGN_PRE_OP) ? temp2 : temp1)));
      nodeMap.put(Pair.make(root,context.key()),copy);
      return copy;
    }
 else {
      CAstNode copy=Ast.makeNode(kind,lval,rval,op);
      nodeMap.put(Pair.make(root,context.key()),copy);
      return copy;
    }
  }
 else   if (kind == CAstNode.ASSIGN) {
    CAstNode copy=Ast.makeNode(CAstNode.ASSIGN,copyNodes(root.getChild(0),ASSIGN,nodeMap),copyNodes(root.getChild(1),READ,nodeMap));
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
 else   if (kind == CAstNode.BLOCK_EXPR) {
    CAstNode children[]=new CAstNode[root.getChildCount()];
    int last=(children.length - 1);
    for (int i=0; i < last; i++) {
      children[i]=copyNodes(root.getChild(i),READ,nodeMap);
    }
    children[last]=copyNodes(root.getChild(last),context,nodeMap);
    CAstNode copy=Ast.makeNode(CAstNode.BLOCK_EXPR,children);
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
 else   if (root.getKind() == CAstNode.CONSTANT) {
    CAstNode copy=Ast.makeConstant(root.getValue());
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
 else   if (root.getKind() == CAstNode.OPERATOR) {
    nodeMap.put(Pair.make(root,context.key()),root);
    return root;
  }
 else {
    CAstNode children[]=new CAstNode[root.getChildCount()];
    for (int i=0; i < children.length; i++) {
      children[i]=copyNodes(root.getChild(i),READ,nodeMap);
    }
    CAstNode copy=Ast.makeNode(kind,children);
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
}","protected CAstNode copyNodes(CAstNode root,RewriteContext context,Map<Pair<CAstNode,ExpanderKey>,CAstNode> nodeMap){
  int kind=root.getKind();
  if (kind == CAstNode.OBJECT_REF && context.inRead()) {
    CAstNode readLoop;
    CAstNode receiver=copyNodes(root.getChild(0),READ,nodeMap);
    CAstNode element=copyNodes(root.getChild(1),READ,nodeMap);
    if (element.getKind() == CAstNode.CONSTANT && element.getValue() instanceof String) {
      readLoop=makeConstRead(root,receiver,element,context,nodeMap);
    }
 else {
      readLoop=makeVarRead(root,receiver,element,context,nodeMap);
    }
    return readLoop;
  }
 else   if (kind == CAstNode.ASSIGN_PRE_OP || kind == CAstNode.ASSIGN_POST_OP) {
    AssignPreOrPostOpContext ctxt=new AssignPreOrPostOpContext();
    CAstNode lval=copyNodes(root.getChild(0),ctxt,nodeMap);
    CAstNode rval=copyNodes(root.getChild(1),READ,nodeMap);
    CAstNode op=copyNodes(root.getChild(2),READ,nodeMap);
    if (ctxt.receiverTemp != null) {
      String temp1=TEMP_NAME + (readTempCounter++);
      String temp2=TEMP_NAME + (readTempCounter++);
      CAstNode copy=Ast.makeNode(CAstNode.BLOCK_EXPR,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new InternalCAstSymbol(temp1,true,false)),lval),rval,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new InternalCAstSymbol(temp2,true,false)),Ast.makeNode(CAstNode.BINARY_EXPR,op,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(temp1)),rval)),Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.OBJECT_REF,ctxt.receiverTemp,ctxt.elementTemp),Ast.makeNode(CAstNode.VAR,Ast.makeConstant(temp2))),Ast.makeNode(CAstNode.VAR,Ast.makeConstant((kind == CAstNode.ASSIGN_PRE_OP) ? temp2 : temp1)));
      nodeMap.put(Pair.make(root,context.key()),copy);
      return copy;
    }
 else {
      CAstNode copy=Ast.makeNode(kind,lval,rval,op);
      nodeMap.put(Pair.make(root,context.key()),copy);
      return copy;
    }
  }
 else   if (kind == CAstNode.ASSIGN) {
    CAstNode copy=Ast.makeNode(CAstNode.ASSIGN,copyNodes(root.getChild(0),ASSIGN,nodeMap),copyNodes(root.getChild(1),READ,nodeMap));
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
 else   if (kind == CAstNode.BLOCK_EXPR) {
    CAstNode children[]=new CAstNode[root.getChildCount()];
    int last=(children.length - 1);
    for (int i=0; i < last; i++) {
      children[i]=copyNodes(root.getChild(i),READ,nodeMap);
    }
    children[last]=copyNodes(root.getChild(last),context,nodeMap);
    CAstNode copy=Ast.makeNode(CAstNode.BLOCK_EXPR,children);
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
 else   if (root.getKind() == CAstNode.CONSTANT) {
    CAstNode copy=Ast.makeConstant(root.getValue());
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
 else   if (root.getKind() == CAstNode.OPERATOR) {
    nodeMap.put(Pair.make(root,context.key()),root);
    return root;
  }
 else {
    CAstNode children[]=new CAstNode[root.getChildCount()];
    for (int i=0; i < children.length; i++) {
      children[i]=copyNodes(root.getChild(i),READ,nodeMap);
    }
    CAstNode copy=Ast.makeNode(kind,children);
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
}",0.9984330930742714
38379,"/** 
 * create a CAstNode l representing a loop that traverses the prototype chain from receiver searching for the constant property element. update nodeMap to map root to an expression that reads the property from the right node.
 * @param root
 * @param receiver
 * @param element
 * @param context
 * @param nodeMap
 * @return
 */
private CAstNode makeConstRead(CAstNode root,CAstNode receiver,CAstNode element,RewriteContext context,Map<Pair<CAstNode,NoKey>,CAstNode> nodeMap){
  CAstNode get, result;
  String receiverTemp=TEMP_NAME + (readTempCounter++);
  String elt=(String)element.getValue();
  if (elt.equals(""String_Node_Str"") || elt.equals(""String_Node_Str"")) {
    result=Ast.makeNode(CAstNode.BLOCK_EXPR,get=Ast.makeNode(CAstNode.OBJECT_REF,receiver,Ast.makeConstant(elt)));
  }
 else {
    if (context.inAssignment()) {
      context.setAssign(Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeConstant(elt));
    }
    result=Ast.makeNode(CAstNode.BLOCK_EXPR,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new InternalCAstSymbol(receiverTemp,false,false)),receiver),Ast.makeNode(CAstNode.LOOP,Ast.makeNode(CAstNode.UNARY_EXPR,CAstOperator.OP_NOT,Ast.makeNode(CAstNode.IS_DEFINED_EXPR,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeConstant(elt))),Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeNode(CAstNode.OBJECT_REF,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeConstant(""String_Node_Str"")))),get=Ast.makeNode(CAstNode.OBJECT_REF,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeConstant(elt)));
  }
  nodeMap.put(Pair.make(root,context.key()),get);
  return result;
}","/** 
 * create a CAstNode l representing a loop that traverses the prototype chain from receiver searching for the constant property element. update nodeMap to map root to an expression that reads the property from the right node.
 * @param root
 * @param receiver
 * @param element
 * @param context
 * @param nodeMap
 * @return
 */
private CAstNode makeConstRead(CAstNode root,CAstNode receiver,CAstNode element,RewriteContext context,Map<Pair<CAstNode,ExpanderKey>,CAstNode> nodeMap){
  CAstNode get, result;
  String receiverTemp=TEMP_NAME + (readTempCounter++);
  String elt=(String)element.getValue();
  if (elt.equals(""String_Node_Str"") || elt.equals(""String_Node_Str"")) {
    result=Ast.makeNode(CAstNode.BLOCK_EXPR,get=Ast.makeNode(CAstNode.OBJECT_REF,receiver,Ast.makeConstant(elt)));
  }
 else {
    if (context.inAssignment()) {
      context.setAssign(Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeConstant(elt));
    }
    result=Ast.makeNode(CAstNode.BLOCK_EXPR,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new InternalCAstSymbol(receiverTemp,false,false)),receiver),Ast.makeNode(CAstNode.LOOP,Ast.makeNode(CAstNode.UNARY_EXPR,CAstOperator.OP_NOT,Ast.makeNode(CAstNode.IS_DEFINED_EXPR,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeConstant(elt))),Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeNode(CAstNode.OBJECT_REF,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeConstant(""String_Node_Str"")))),get=Ast.makeNode(CAstNode.OBJECT_REF,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeConstant(elt)));
  }
  nodeMap.put(Pair.make(root,context.key()),result);
  nodeMap.put(Pair.make(root,ExpanderKey.EXTRA),get);
  return result;
}",0.98075265728239
38380,"/** 
 * similar to makeConstRead(), but desired property is some expression instead of a constant
 * @see #makeConstRead(CAstNode,CAstNode,CAstNode,RewriteContext,Map)
 */
private CAstNode makeVarRead(CAstNode root,CAstNode receiver,CAstNode element,RewriteContext context,Map<Pair<CAstNode,NoKey>,CAstNode> nodeMap){
  String receiverTemp=TEMP_NAME + (readTempCounter++);
  String elementTemp=TEMP_NAME + (readTempCounter++);
  if (context.inAssignment()) {
    context.setAssign(Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeNode(CAstNode.VAR,Ast.makeConstant(elementTemp)));
  }
  CAstNode get;
  CAstNode result=Ast.makeNode(CAstNode.BLOCK_EXPR,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new InternalCAstSymbol(receiverTemp,false,false)),receiver),Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new InternalCAstSymbol(elementTemp,false,false)),element),Ast.makeNode(CAstNode.LOOP,Ast.makeNode(CAstNode.UNARY_EXPR,CAstOperator.OP_NOT,Ast.makeNode(CAstNode.IS_DEFINED_EXPR,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeNode(CAstNode.VAR,Ast.makeConstant(elementTemp)))),Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeNode(CAstNode.OBJECT_REF,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeConstant(""String_Node_Str"")))),get=Ast.makeNode(CAstNode.OBJECT_REF,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeNode(CAstNode.VAR,Ast.makeConstant(elementTemp))));
  nodeMap.put(Pair.make(root,context.key()),get);
  return result;
}","/** 
 * similar to makeConstRead(), but desired property is some expression instead of a constant
 * @see #makeConstRead(CAstNode,CAstNode,CAstNode,RewriteContext,Map)
 */
private CAstNode makeVarRead(CAstNode root,CAstNode receiver,CAstNode element,RewriteContext context,Map<Pair<CAstNode,ExpanderKey>,CAstNode> nodeMap){
  String receiverTemp=TEMP_NAME + (readTempCounter++);
  String elementTemp=TEMP_NAME + (readTempCounter++);
  if (context.inAssignment()) {
    context.setAssign(Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeNode(CAstNode.VAR,Ast.makeConstant(elementTemp)));
  }
  CAstNode get;
  CAstNode result=Ast.makeNode(CAstNode.BLOCK_EXPR,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new InternalCAstSymbol(receiverTemp,false,false)),receiver),Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new InternalCAstSymbol(elementTemp,false,false)),element),Ast.makeNode(CAstNode.LOOP,Ast.makeNode(CAstNode.UNARY_EXPR,CAstOperator.OP_NOT,Ast.makeNode(CAstNode.IS_DEFINED_EXPR,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeNode(CAstNode.VAR,Ast.makeConstant(elementTemp)))),Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeNode(CAstNode.OBJECT_REF,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeConstant(""String_Node_Str"")))),get=Ast.makeNode(CAstNode.OBJECT_REF,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeNode(CAstNode.VAR,Ast.makeConstant(elementTemp))));
  nodeMap.put(Pair.make(root,context.key()),get);
  return result;
}",0.9968010236724248
38381,"protected void visitInvokeInternal(final SSAAbstractInvokeInstruction instruction){
  super.visitInvokeInternal(instruction);
  if (instruction instanceof AbstractLexicalInvoke) {
    AbstractLexicalInvoke I=(AbstractLexicalInvoke)instruction;
    for (int wi=0; wi < I.getNumberOfDefs(); wi++) {
      if (I.isLexicalDef(wi)) {
        Access w=I.getLexicalDef(wi);
        for (int ri=0; ri < I.getNumberOfUses(); ri++) {
          if (I.isLexicalUse(ri)) {
            Access r=I.getLexicalUse(ri);
            if (w.variableName.equals(r.variableName)) {
              if (w.variableDefiner == null ? r.variableDefiner == null : w.variableDefiner.equals(r.variableDefiner)) {
                PointerKey rk=getBuilder().getPointerKeyForLocal(node,r.valueNumber);
                PointerKey wk=getBuilder().getPointerKeyForLocal(node,w.valueNumber);
                system.newConstraint(wk,assignOperator,rk);
              }
            }
          }
        }
      }
    }
  }
}","protected void visitInvokeInternal(final SSAAbstractInvokeInstruction instruction){
  super.visitInvokeInternal(instruction);
  if (instruction instanceof AbstractLexicalInvoke) {
    AbstractLexicalInvoke I=(AbstractLexicalInvoke)instruction;
    for (int wi=0; wi < I.getNumberOfDefs(); wi++) {
      if (I.isLexicalDef(wi)) {
        Access w=I.getLexicalDef(wi);
        for (int ri=0; ri < I.getNumberOfUses(); ri++) {
          if (I.isLexicalUse(ri)) {
            Access r=I.getLexicalUse(ri);
            if (w.variableName.equals(r.variableName)) {
              if (w.variableDefiner == null ? r.variableDefiner == null : w.variableDefiner.equals(r.variableDefiner)) {
                PointerKey rk=getBuilder().getPointerKeyForLocal(node,r.valueNumber);
                PointerKey wk=getBuilder().getPointerKeyForLocal(node,w.valueNumber);
                if (contentsAreInvariant(symbolTable,du,r.valueNumber)) {
                  system.recordImplicitPointsToSet(rk);
                  for (                  InstanceKey ik : getInvariantContents(r.valueNumber)) {
                    system.newConstraint(wk,ik);
                  }
                }
 else {
                  system.newConstraint(wk,assignOperator,rk);
                }
              }
            }
          }
        }
      }
    }
  }
}",0.8518197573656846
38382,"private static void getMethodInClassOrSuperclass(IMethodBinding met,ITypeBinding klass,boolean superclassonly,HashMap<ITypeBinding,IMethodBinding> overridden){
  if (!superclassonly) {
    for (    IMethodBinding ourmet : klass.getDeclaredMethods())     if (met.isSubsignature(ourmet) && (met.getModifiers() & Modifier.PRIVATE) == 0) {
      overridden.put(ourmet.getMethodDeclaration().getReturnType(),ourmet.getMethodDeclaration());
      break;
    }
  }
  for (  ITypeBinding iface : klass.getInterfaces())   getMethodInClassOrSuperclass(met,iface,false,overridden);
  ITypeBinding superclass=klass.getSuperclass();
  if (superclass != null)   getMethodInClassOrSuperclass(met,superclass,false,overridden);
}","private static void getMethodInClassOrSuperclass(IMethodBinding met,ITypeBinding klass,boolean superclassonly,HashMap<ITypeBinding,IMethodBinding> overridden){
  if (!superclassonly) {
    for (    IMethodBinding ourmet : klass.getDeclaredMethods())     if (met.overrides(ourmet)) {
      overridden.put(ourmet.getMethodDeclaration().getReturnType(),ourmet.getMethodDeclaration());
      break;
    }
  }
  for (  ITypeBinding iface : klass.getInterfaces())   getMethodInClassOrSuperclass(met,iface,false,overridden);
  ITypeBinding superclass=klass.getSuperclass();
  if (superclass != null)   getMethodInClassOrSuperclass(met,superclass,false,overridden);
}",0.936542669584245
38383,"/** 
 * Make a ""fake"" function (it doesn't exist in source code but it does in bytecode) for covariant return types.
 * @param overriding Declaration of the overriding method.
 * @param overridden Binding of the overridden method, in a a superclass or implemented interface.
 * @param oldContext
 * @return
 */
private CAstEntity makeSyntheticCovariantRedirect(MethodDeclaration overriding,IMethodBinding overridingBinding,IMethodBinding overridden,WalkContext oldContext){
  final Map<CAstNode,CAstEntity> memberEntities=new LinkedHashMap<CAstNode,CAstEntity>();
  final MethodContext context=new MethodContext(oldContext,memberEntities);
  CAstNode calltarget;
  if ((overridingBinding.getModifiers() & Modifier.STATIC) == 0)   calltarget=makeNode(context,fFactory,null,CAstNode.THIS);
 else   calltarget=makeNode(context,fFactory,null,CAstNode.VOID);
  ITypeBinding paramTypes[]=overridden.getParameterTypes();
  ArrayList<CAstNode> arguments=new ArrayList<CAstNode>();
  int i=0;
  for (  Object o : overriding.parameters()) {
    SingleVariableDeclaration svd=(SingleVariableDeclaration)o;
    CAstNode varNode=makeNode(context,fFactory,null,CAstNode.VAR,fFactory.makeConstant(svd.getName().getIdentifier()));
    ITypeBinding fromType=JDT2CAstUtils.getErasedType(paramTypes[i],ast);
    ITypeBinding toType=JDT2CAstUtils.getErasedType(overridingBinding.getParameterTypes()[i],ast);
    if (fromType.equals(toType))     arguments.add(varNode);
 else     arguments.add(createCast(null,varNode,fromType,toType,context));
    i++;
  }
  CAstNode callnode=createMethodInvocation(null,overridingBinding,calltarget,arguments,context);
  CAstNode mdast=makeNode(context,fFactory,null,CAstNode.LOCAL_SCOPE,makeNode(context,fFactory,null,CAstNode.BLOCK_STMT,makeNode(context,fFactory,null,CAstNode.RETURN,callnode)));
  ArrayList<CAstType> paramCAstTypes=new ArrayList<CAstType>(overridden.getParameterTypes().length);
  for (  ITypeBinding paramType : overridden.getParameterTypes())   paramCAstTypes.add(fTypeDict.getCAstTypeFor(paramType));
  return new ProcedureEntity(mdast,overriding,overridingBinding.getDeclaringClass(),memberEntities,context,paramCAstTypes,overridden.getReturnType());
}","/** 
 * Make a ""fake"" function (it doesn't exist in source code but it does in bytecode) for covariant return types.
 * @param overriding Declaration of the overriding method.
 * @param overridden Binding of the overridden method, in a a superclass or implemented interface.
 * @param oldContext
 * @return
 */
private CAstEntity makeSyntheticCovariantRedirect(MethodDeclaration overriding,IMethodBinding overridingBinding,IMethodBinding overridden,WalkContext oldContext){
  final Map<CAstNode,CAstEntity> memberEntities=new LinkedHashMap<CAstNode,CAstEntity>();
  final MethodContext context=new MethodContext(oldContext,memberEntities);
  CAstNode calltarget;
  if ((overridingBinding.getModifiers() & Modifier.STATIC) == 0)   calltarget=makeNode(context,fFactory,null,CAstNode.SUPER);
 else   calltarget=makeNode(context,fFactory,null,CAstNode.VOID);
  ITypeBinding paramTypes[]=overridden.getParameterTypes();
  ArrayList<CAstNode> arguments=new ArrayList<CAstNode>();
  int i=0;
  for (  Object o : overriding.parameters()) {
    SingleVariableDeclaration svd=(SingleVariableDeclaration)o;
    CAstNode varNode=makeNode(context,fFactory,null,CAstNode.VAR,fFactory.makeConstant(svd.getName().getIdentifier()));
    ITypeBinding fromType=JDT2CAstUtils.getErasedType(paramTypes[i],ast);
    ITypeBinding toType=JDT2CAstUtils.getErasedType(overridingBinding.getParameterTypes()[i],ast);
    if (fromType.equals(toType)) {
      arguments.add(varNode);
    }
 else {
      arguments.add(createCast(null,varNode,fromType,toType,context));
    }
    i++;
  }
  CAstNode callnode=createMethodInvocation(null,overridingBinding,calltarget,arguments,context);
  CAstNode mdast=makeNode(context,fFactory,null,CAstNode.LOCAL_SCOPE,makeNode(context,fFactory,null,CAstNode.BLOCK_STMT,makeNode(context,fFactory,null,CAstNode.RETURN,callnode)));
  ArrayList<CAstType> paramCAstTypes=new ArrayList<CAstType>(overridden.getParameterTypes().length);
  for (  ITypeBinding paramType : overridden.getParameterTypes())   paramCAstTypes.add(fTypeDict.getCAstTypeFor(paramType));
  return new ProcedureEntity(mdast,overriding,overridingBinding.getDeclaringClass(),memberEntities,context,paramCAstTypes,overridden.getReturnType());
}",0.9920544835414302
38384,"/** 
 * @param n
 * @param bodyDecls
 * @param enumConstants
 * @param typeBinding
 * @param name Used in creating default constructor, and passed into new ClassEntity()
 * @param context
 * @return
 */
private CAstEntity createClassDeclaration(ASTNode n,List bodyDecls,List enumConstants,ITypeBinding typeBinding,String name,int modifiers,boolean isInterface,boolean isAnnotation,WalkContext context){
  final List<CAstEntity> memberEntities=new ArrayList<CAstEntity>();
  ArrayList<ASTNode> inits=new ArrayList<ASTNode>();
  ArrayList<ASTNode> staticInits=new ArrayList<ASTNode>();
  if (enumConstants != null) {
    for (    Object decl : enumConstants) {
      EnumConstantDeclaration ecd=(EnumConstantDeclaration)decl;
      staticInits.add(ecd);
    }
  }
  for (  Object decl : bodyDecls) {
    if (decl instanceof Initializer) {
      Initializer initializer=(Initializer)decl;
      boolean isStatic=((initializer.getModifiers() & Modifier.STATIC) != 0);
      (isStatic ? staticInits : inits).add(initializer);
    }
 else     if (decl instanceof FieldDeclaration) {
      FieldDeclaration fd=(FieldDeclaration)decl;
      for (      Object f : fd.fragments()) {
        VariableDeclarationFragment frag=(VariableDeclarationFragment)f;
        if (frag.getInitializer() != null) {
          boolean isStatic=((fd.getModifiers() & Modifier.STATIC) != 0);
          (isStatic ? staticInits : inits).add(frag);
        }
      }
    }
  }
  if (enumConstants != null) {
    for (    Object decl : enumConstants) {
      memberEntities.add(visit((EnumConstantDeclaration)decl,context));
    }
  }
  for (  Object d : bodyDecls) {
    BodyDeclaration decl=(BodyDeclaration)d;
    if (decl instanceof FieldDeclaration) {
      FieldDeclaration fieldDecl=(FieldDeclaration)decl;
      Collection<CAstQualifier> quals=JDT2CAstUtils.mapModifiersToQualifiers(fieldDecl.getModifiers(),false,false);
      for (      Object f : fieldDecl.fragments()) {
        VariableDeclarationFragment fieldFrag=(VariableDeclarationFragment)f;
        memberEntities.add(new FieldEntity(fieldFrag.getName().getIdentifier(),fieldFrag.resolveBinding().getType(),quals,makePosition(fieldFrag.getStartPosition(),fieldFrag.getStartPosition() + fieldFrag.getLength())));
      }
    }
 else     if (decl instanceof Initializer) {
    }
 else     if (decl instanceof MethodDeclaration) {
      MethodDeclaration metDecl=(MethodDeclaration)decl;
      if (typeBinding.isEnum() && metDecl.isConstructor())       memberEntities.add(createEnumConstructorWithParameters(metDecl.resolveBinding(),metDecl,context,inits,metDecl));
 else {
        memberEntities.add(visit(metDecl,typeBinding,context,inits));
        Collection<IMethodBinding> overriddenMets=JDT2CAstUtils.getOverriddenMethod(metDecl.resolveBinding());
        if (overriddenMets != null) {
          for (          IMethodBinding overridden : overriddenMets)           if (!JDT2CAstUtils.sameSignatureAndReturnType(metDecl.resolveBinding(),overridden))           memberEntities.add(makeSyntheticCovariantRedirect(metDecl,metDecl.resolveBinding(),overridden,context));
        }
      }
    }
 else     if (decl instanceof AbstractTypeDeclaration) {
      memberEntities.add(visit((AbstractTypeDeclaration)decl,context));
    }
 else     if (decl instanceof AnnotationTypeMemberDeclaration) {
    }
 else {
      Assertions.UNREACHABLE(""String_Node_Str"");
    }
  }
  for (  Object m : typeBinding.getDeclaredMethods()) {
    IMethodBinding met=(IMethodBinding)m;
    if (met.isDefaultConstructor()) {
      if (typeBinding.isEnum())       memberEntities.add(createEnumConstructorWithParameters(met,n,context,inits,null));
 else       if (met.getParameterTypes().length > 0)       memberEntities.add(createDefaultConstructorWithParameters(met,n,context,inits));
 else       memberEntities.add(createDefaultConstructor(name,typeBinding,context,inits,n));
    }
  }
  if (typeBinding.isEnum() && !typeBinding.isAnonymous())   doEnumHiddenEntities(typeBinding,staticInits,memberEntities,context);
  if (!staticInits.isEmpty()) {
    Map<CAstNode,CAstEntity> childEntities=HashMapFactory.make();
    final MethodContext newContext=new MethodContext(context,childEntities);
    CAstNode[] bodyNodes=new CAstNode[staticInits.size()];
    for (int i=0; i < staticInits.size(); i++)     bodyNodes[i]=visitFieldInitNode(staticInits.get(i),newContext);
    CAstNode staticInitAst=makeNode(newContext,fFactory,n,CAstNode.BLOCK_STMT,bodyNodes);
    memberEntities.add(new ProcedureEntity(staticInitAst,typeBinding,childEntities,newContext));
  }
  Collection<CAstQualifier> quals=JDT2CAstUtils.mapModifiersToQualifiers(modifiers,isInterface,isAnnotation);
  return new ClassEntity(typeBinding,name,quals,memberEntities,makePosition(n));
}","/** 
 * @param n
 * @param bodyDecls
 * @param enumConstants
 * @param typeBinding
 * @param name Used in creating default constructor, and passed into new ClassEntity()
 * @param context
 * @return
 */
private CAstEntity createClassDeclaration(ASTNode n,List bodyDecls,List enumConstants,ITypeBinding typeBinding,String name,int modifiers,boolean isInterface,boolean isAnnotation,WalkContext context){
  final List<CAstEntity> memberEntities=new ArrayList<CAstEntity>();
  ArrayList<ASTNode> inits=new ArrayList<ASTNode>();
  ArrayList<ASTNode> staticInits=new ArrayList<ASTNode>();
  if (enumConstants != null) {
    for (    Object decl : enumConstants) {
      EnumConstantDeclaration ecd=(EnumConstantDeclaration)decl;
      staticInits.add(ecd);
    }
  }
  for (  Object decl : bodyDecls) {
    if (decl instanceof Initializer) {
      Initializer initializer=(Initializer)decl;
      boolean isStatic=((initializer.getModifiers() & Modifier.STATIC) != 0);
      (isStatic ? staticInits : inits).add(initializer);
    }
 else     if (decl instanceof FieldDeclaration) {
      FieldDeclaration fd=(FieldDeclaration)decl;
      for (      Object f : fd.fragments()) {
        VariableDeclarationFragment frag=(VariableDeclarationFragment)f;
        if (frag.getInitializer() != null) {
          boolean isStatic=((fd.getModifiers() & Modifier.STATIC) != 0);
          (isStatic ? staticInits : inits).add(frag);
        }
      }
    }
  }
  if (enumConstants != null) {
    for (    Object decl : enumConstants) {
      memberEntities.add(visit((EnumConstantDeclaration)decl,context));
    }
  }
  for (  Object d : bodyDecls) {
    BodyDeclaration decl=(BodyDeclaration)d;
    if (decl instanceof FieldDeclaration) {
      FieldDeclaration fieldDecl=(FieldDeclaration)decl;
      Collection<CAstQualifier> quals=JDT2CAstUtils.mapModifiersToQualifiers(fieldDecl.getModifiers(),false,false);
      for (      Object f : fieldDecl.fragments()) {
        VariableDeclarationFragment fieldFrag=(VariableDeclarationFragment)f;
        memberEntities.add(new FieldEntity(fieldFrag.getName().getIdentifier(),fieldFrag.resolveBinding().getType(),quals,makePosition(fieldFrag.getStartPosition(),fieldFrag.getStartPosition() + fieldFrag.getLength())));
      }
    }
 else     if (decl instanceof Initializer) {
    }
 else     if (decl instanceof MethodDeclaration) {
      MethodDeclaration metDecl=(MethodDeclaration)decl;
      if (typeBinding.isEnum() && metDecl.isConstructor())       memberEntities.add(createEnumConstructorWithParameters(metDecl.resolveBinding(),metDecl,context,inits,metDecl));
 else {
        memberEntities.add(visit(metDecl,typeBinding,context,inits));
        Collection<IMethodBinding> overriddenMets=JDT2CAstUtils.getOverriddenMethod(metDecl.resolveBinding());
        if (overriddenMets != null) {
          for (          IMethodBinding overridden : overriddenMets)           if (!JDT2CAstUtils.sameErasedSignatureAndReturnType(metDecl.resolveBinding(),overridden))           memberEntities.add(makeSyntheticCovariantRedirect(metDecl,metDecl.resolveBinding(),overridden,context));
        }
      }
    }
 else     if (decl instanceof AbstractTypeDeclaration) {
      memberEntities.add(visit((AbstractTypeDeclaration)decl,context));
    }
 else     if (decl instanceof AnnotationTypeMemberDeclaration) {
    }
 else {
      Assertions.UNREACHABLE(""String_Node_Str"");
    }
  }
  for (  Object m : typeBinding.getDeclaredMethods()) {
    IMethodBinding met=(IMethodBinding)m;
    if (met.isDefaultConstructor()) {
      if (typeBinding.isEnum())       memberEntities.add(createEnumConstructorWithParameters(met,n,context,inits,null));
 else       if (met.getParameterTypes().length > 0)       memberEntities.add(createDefaultConstructorWithParameters(met,n,context,inits));
 else       memberEntities.add(createDefaultConstructor(name,typeBinding,context,inits,n));
    }
  }
  if (typeBinding.isEnum() && !typeBinding.isAnonymous())   doEnumHiddenEntities(typeBinding,staticInits,memberEntities,context);
  if (!staticInits.isEmpty()) {
    Map<CAstNode,CAstEntity> childEntities=HashMapFactory.make();
    final MethodContext newContext=new MethodContext(context,childEntities);
    CAstNode[] bodyNodes=new CAstNode[staticInits.size()];
    for (int i=0; i < staticInits.size(); i++)     bodyNodes[i]=visitFieldInitNode(staticInits.get(i),newContext);
    CAstNode staticInitAst=makeNode(newContext,fFactory,n,CAstNode.BLOCK_STMT,bodyNodes);
    memberEntities.add(new ProcedureEntity(staticInitAst,typeBinding,childEntities,newContext));
  }
  Collection<CAstQualifier> quals=JDT2CAstUtils.mapModifiersToQualifiers(modifiers,isInterface,isAnnotation);
  return new ClassEntity(typeBinding,name,quals,memberEntities,makePosition(n));
}",0.9993705413344524
38385,"/** 
 * @param fileName
 * @return the jar file packaged with this plug-in of the given name, or null if not found.
 */
private static JarFileModule getFromPlugin(Plugin p,String fileName) throws IOException {
  URL url=getFileURLFromPlugin(p,fileName);
  return (url == null) ? null : new JarFileModule(new JarFile(filePathFromURL(url)));
}","/** 
 * @param fileName
 * @return the jar file packaged with this plug-in of the given name, or nullif not found.
 */
private static JarFileModule getFromPlugin(Plugin p,String fileName) throws IOException {
  URL url=getFileURLFromPlugin(p,fileName);
  return (url == null) ? null : new JarFileModule(new JarFile(filePathFromURL(url)));
}",0.998531571218796
38386,"/** 
 * Properly creates the String file name of a   {@link URL}. This works around a bug in the Sun implementation of  {@link URL#getFile()}, which doesn't properly handle file paths with spaces (see <a href=""http://sourceforge.net/tracker/index.php?func=detail&aid=1565842&group_id=176742&atid=878458"">bug report</a>). For now, fails with an assertion if the url is malformed.
 * @param url
 * @return the path name for the url
 * @throws IllegalArgumentException if url is null
 */
public static String filePathFromURL(URL url){
  if (url == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  URI uri=null;
  try {
    uri=new URI(url.toString());
  }
 catch (  URISyntaxException e) {
    Assertions.UNREACHABLE();
  }
  String filePath=uri.getPath();
  return filePath;
}","/** 
 * Properly creates the String file name of a   {@link URL}. This works around a bug in the Sun implementation of   {@link URL#getFile()}, which doesn't properly handle file paths with spaces (see <a href= ""http://sourceforge.net/tracker/index.php?func=detail&aid=1565842&group_id=176742&atid=878458"" >bug report</a>). For now, fails with an assertion if the url is malformed.
 * @param url
 * @return the path name for the url
 * @throws IllegalArgumentException if url is null
 */
public static String filePathFromURL(URL url){
  if (url == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  URI uri=new File(url.getPath()).toURI();
  String filePath=uri.getPath();
  return filePath;
}",0.8433575677461996
38387,"/** 
 * @param fileName
 * @return the jar file packaged with this plug-in of the given name, or null if not found.
 * @throws IllegalArgumentException if p is null
 */
public static File getFileFromPlugin(Plugin p,String fileName) throws IOException {
  if (p == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  URL url=getFileURLFromPlugin(p,fileName);
  if (url == null) {
    throw new FileNotFoundException(fileName);
  }
  return new File(filePathFromURL(url));
}","/** 
 * @param fileName
 * @return the jar file packaged with this plug-in of the given name, or nullif not found.
 * @throws IllegalArgumentException if p is null
 */
public static File getFileFromPlugin(Plugin p,String fileName) throws IOException {
  if (p == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  URL url=getFileURLFromPlugin(p,fileName);
  if (url == null) {
    throw new FileNotFoundException(fileName);
  }
  return new File(filePathFromURL(url));
}",0.999140154772141
38388,"/** 
 * escape spaces in a URL, primarily to work around a bug in   {@link File#toURL()}
 * @param url
 * @return an escaped version of the URL
 */
private static URL fixupFileURLSpaces(URL url){
  String urlString=url.toExternalForm();
  StringBuffer fixedUpUrl=new StringBuffer();
  int lastIndex=0;
  while (true) {
    int spaceIndex=urlString.indexOf(' ',lastIndex);
    if (spaceIndex < 0) {
      fixedUpUrl.append(urlString.substring(lastIndex));
      break;
    }
    fixedUpUrl.append(urlString.substring(lastIndex,spaceIndex));
    fixedUpUrl.append(""String_Node_Str"");
    lastIndex=spaceIndex + 1;
  }
  try {
    return new URL(fixedUpUrl.toString());
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
    Assertions.UNREACHABLE();
  }
  return null;
}","/** 
 * escape spaces in a URL, primarily to work around a bug in  {@link File#toURL()}
 * @param url
 * @return an escaped version of the URL
 */
private static URL fixupFileURLSpaces(URL url){
  String urlString=url.toExternalForm();
  StringBuffer fixedUpUrl=new StringBuffer();
  int lastIndex=0;
  while (true) {
    int spaceIndex=urlString.indexOf(' ',lastIndex);
    if (spaceIndex < 0) {
      fixedUpUrl.append(urlString.substring(lastIndex));
      break;
    }
    fixedUpUrl.append(urlString.substring(lastIndex,spaceIndex));
    fixedUpUrl.append(""String_Node_Str"");
    lastIndex=spaceIndex + 1;
  }
  try {
    return new URL(fixedUpUrl.toString());
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
    Assertions.UNREACHABLE();
  }
  return null;
}",0.9993610223642172
38389,"/** 
 * @return the jar file packaged with this plug-in of the given name, or null if not found: wrapped as a JarFileModule or aNestedJarFileModule
 * @throws IOException
 */
public static Module getJarFileFromClassLoader(String fileName,ClassLoader loader) throws IOException {
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (loader == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  URL url=loader.getResource(fileName);
  if (DEBUG_LEVEL > 0) {
    System.err.println(""String_Node_Str"" + url + ""String_Node_Str""+ fileName);
  }
  if (url == null) {
    try {
      return new JarFileModule(new JarFile(fileName,false));
    }
 catch (    ZipException e) {
      throw new IOException(""String_Node_Str"" + fileName);
    }
  }
  if (url.getProtocol().equals(""String_Node_Str"")) {
    JarURLConnection jc=(JarURLConnection)url.openConnection();
    JarFile f=jc.getJarFile();
    JarEntry entry=jc.getJarEntry();
    JarFileModule parent=new JarFileModule(f);
    return new NestedJarFileModule(parent,entry);
  }
 else {
    String filePath=filePathFromURL(url);
    return new JarFileModule(new JarFile(filePath,false));
  }
}","/** 
 * @return the jar file packaged with this plug-in of the given name, or nullif not found: wrapped as a JarFileModule or a NestedJarFileModule
 * @throws IOException
 */
public static Module getJarFileFromClassLoader(String fileName,ClassLoader loader) throws IOException {
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (loader == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  URL url=loader.getResource(fileName);
  if (DEBUG_LEVEL > 0) {
    System.err.println(""String_Node_Str"" + url + ""String_Node_Str""+ fileName);
  }
  if (url == null) {
    try {
      return new JarFileModule(new JarFile(fileName,false));
    }
 catch (    ZipException e) {
      throw new IOException(""String_Node_Str"" + fileName);
    }
  }
  if (url.getProtocol().equals(""String_Node_Str"")) {
    JarURLConnection jc=(JarURLConnection)url.openConnection();
    JarFile f=jc.getJarFile();
    JarEntry entry=jc.getJarEntry();
    JarFileModule parent=new JarFileModule(f);
    return new NestedJarFileModule(parent,entry);
  }
 else {
    String filePath=filePathFromURL(url);
    return new JarFileModule(new JarFile(filePath,false));
  }
}",0.9991666666666666
38390,"@Override protected JavaSourceAnalysisEngine getAnalysisEngine(final String[] mainClassDescriptors){
  JavaSourceAnalysisEngine engine=new JDTJavaSourceAnalysisEngine(){
    protected Iterable<Entrypoint> makeDefaultEntrypoints(    AnalysisScope scope,    IClassHierarchy cha){
      return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
    }
  }
;
  try {
    engine.setExclusionsFile(FileProvider.getFileFromPlugin(CoreTestsPlugin.getDefault(),CallGraphTestUtil.REGRESSION_EXCLUSIONS).getAbsolutePath());
  }
 catch (  IOException e) {
    Assert.assertFalse(""String_Node_Str"",true);
  }
  return engine;
}","@Override protected JavaSourceAnalysisEngine getAnalysisEngine(final String[] mainClassDescriptors){
  JavaSourceAnalysisEngine engine=new JDTJavaSourceAnalysisEngine(JDTJavaIRTests.PROJECT_NAME){
    @Override protected Iterable<Entrypoint> makeDefaultEntrypoints(    AnalysisScope scope,    IClassHierarchy cha){
      return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
    }
  }
;
  try {
    engine.setExclusionsFile(FileProvider.getFileFromPlugin(CoreTestsPlugin.getDefault(),CallGraphTestUtil.REGRESSION_EXCLUSIONS).getAbsolutePath());
  }
 catch (  IOException e) {
    Assert.assertFalse(""String_Node_Str"",true);
  }
  return engine;
}",0.9721175584024114
38391,"protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
}","@Override protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
}",0.9742268041237112
38392,"protected void populateScope(JavaSourceAnalysisEngine engine,Collection<String> sources,List<String> libs) throws IOException {
  IDEIRTestUtil.populateScope(projectName,engine,sources,libs);
}","@Override protected void populateScope(JavaSourceAnalysisEngine engine,Collection<String> sources,List<String> libs) throws IOException {
  IDEIRTestUtil.populateScope(projectName,(JDTJavaSourceAnalysisEngine)engine,sources,libs);
}",0.908235294117647
38393,"@Override protected JavaSourceAnalysisEngine getAnalysisEngine(final String[] mainClassDescriptors){
  JavaSourceAnalysisEngine engine=new JDTJavaSourceAnalysisEngine(){
    protected Iterable<Entrypoint> makeDefaultEntrypoints(    AnalysisScope scope,    IClassHierarchy cha){
      return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
    }
  }
;
  try {
    engine.setExclusionsFile(FileProvider.getFileFromPlugin(CoreTestsPlugin.getDefault(),CallGraphTestUtil.REGRESSION_EXCLUSIONS).getAbsolutePath());
  }
 catch (  IOException e) {
    Assert.assertFalse(""String_Node_Str"",true);
  }
  return engine;
}","@Override protected JavaSourceAnalysisEngine getAnalysisEngine(final String[] mainClassDescriptors){
  JavaSourceAnalysisEngine engine=new JDTJavaSourceAnalysisEngine(PROJECT_NAME){
    @Override protected Iterable<Entrypoint> makeDefaultEntrypoints(    AnalysisScope scope,    IClassHierarchy cha){
      return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
    }
  }
;
  try {
    engine.setExclusionsFile(FileProvider.getFileFromPlugin(CoreTestsPlugin.getDefault(),CallGraphTestUtil.REGRESSION_EXCLUSIONS).getAbsolutePath());
  }
 catch (  IOException e) {
    Assert.assertFalse(""String_Node_Str"",true);
  }
  return engine;
}",0.9832317073170732
38394,"protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
}","@Override protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
}",0.9742268041237112
38395,"protected void populateScope(JavaSourceAnalysisEngine engine,Collection<String> sources,List<String> libs) throws IOException {
  IDEIRTestUtil.populateScope(projectName,engine,sources,libs);
}","@Override protected void populateScope(JavaSourceAnalysisEngine engine,Collection<String> sources,List<String> libs) throws IOException {
  IDEIRTestUtil.populateScope(projectName,(JDTJavaSourceAnalysisEngine)engine,sources,libs);
}",0.908235294117647
38396,"public static void populateScope(String projectName,JavaSourceAnalysisEngine engine,Collection<String> sources,List<String> libs) throws IOException {
}","public static void populateScope(String projectName,JDTJavaSourceAnalysisEngine engine,Collection<String> sources,List<String> libs) throws IOException {
}",0.990228013029316
38397,"protected IClassLoader makeNewClassLoader(ClassLoaderReference classLoaderReference,IClassHierarchy cha,IClassLoader parent,AnalysisScope scope) throws IOException {
  if (classLoaderReference.equals(JavaSourceAnalysisScope.SOURCE)) {
    ClassLoaderImpl cl=new JDTSourceLoaderImpl(classLoaderReference,parent,getExclusions(),cha);
    cl.init(scope.getModules(classLoaderReference));
    return cl;
  }
 else {
    return super.makeNewClassLoader(classLoaderReference,cha,parent,scope);
  }
}","protected IClassLoader makeNewClassLoader(ClassLoaderReference classLoaderReference,IClassHierarchy cha,IClassLoader parent,AnalysisScope scope) throws IOException {
  if (classLoaderReference.equals(JavaSourceAnalysisScope.SOURCE)) {
    ClassLoaderImpl cl=makeSourceLoader(classLoaderReference,cha,parent);
    cl.init(scope.getModules(classLoaderReference));
    return cl;
  }
 else {
    return super.makeNewClassLoader(classLoaderReference,cha,parent,scope);
  }
}",0.909657320872274
38398,"@SuppressWarnings(""String_Node_Str"") public void loadAllSources(Set modules){
}","public void loadAllSources(Set modules){
}",0.6942148760330579
38399,"protected void loadAllSources(Set<ModuleEntry> modules){
  getTranslator().loadAllSources(modules);
  fTypeMap=null;
}","protected void loadAllSources(Set<ModuleEntry> modules){
  getTranslator().loadAllSources(modules);
}",0.9223744292237442
38400,"/** 
 * Add any exceptional edges generated by the last instruction in a basic block.
 * @param last the last instruction in a basic block.
 */
protected void addExceptionalEdges(IInstruction last){
  IClassHierarchy cha=getMethod().getClassHierarchy();
  if (last.isPEI()) {
    Collection<TypeReference> exceptionTypes=null;
    boolean goToAllHandlers=false;
    ExceptionHandler[] hs=getExceptionHandlers();
    if (last instanceof ThrowInstruction) {
      goToAllHandlers=true;
    }
 else {
      if (hs != null && hs.length > 0) {
        IClassLoader loader=getMethod().getDeclaringClass().getClassLoader();
        BytecodeLanguage l=(BytecodeLanguage)loader.getLanguage();
        exceptionTypes=l.getImplicitExceptionTypes(last);
        if (last instanceof IInvokeInstruction) {
          IInvokeInstruction call=(IInvokeInstruction)last;
          exceptionTypes=HashSetFactory.make(exceptionTypes);
          MethodReference target=MethodReference.findOrCreate(l,loader.getReference(),call.getClassType(),call.getMethodName(),call.getMethodSignature());
          try {
            exceptionTypes.addAll(l.inferInvokeExceptions(target,cha));
          }
 catch (          InvalidClassFileException e) {
            e.printStackTrace();
            Assertions.UNREACHABLE();
          }
        }
      }
    }
    if (hs != null && hs.length > 0) {
      if (!goToAllHandlers) {
        exceptionTypes=HashSetFactory.make(exceptionTypes);
      }
      boolean needEdgeToExitForAllHandlers=true;
      for (int j=0; j < hs.length; j++) {
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + hs[j]);
        }
        BasicBlock b=getBlockForInstruction(hs[j].getHandler());
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + b);
        }
        if (goToAllHandlers) {
          if (DEBUG) {
            System.err.println(""String_Node_Str"" + b);
          }
          addExceptionalEdgeTo(b);
          if (hs[j].getCatchClass() == null) {
            needEdgeToExitForAllHandlers=false;
          }
        }
 else {
          TypeReference caughtException=null;
          if (hs[j].getCatchClass() != null) {
            ClassLoaderReference loader=ShrikeCFG.this.getMethod().getDeclaringClass().getReference().getClassLoader();
            caughtException=ShrikeUtil.makeTypeReference(loader,hs[j].getCatchClass());
            if (DEBUG) {
              System.err.println(""String_Node_Str"" + caughtException);
            }
            IClass caughtClass=cha.lookupClass(caughtException);
            if (caughtClass == null) {
              addExceptionalEdgeTo(b);
              Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
              caughtException=null;
            }
          }
 else {
            if (DEBUG) {
              System.err.println(""String_Node_Str"");
            }
            if (!exceptionTypes.isEmpty()) {
              addExceptionalEdgeTo(b);
              exceptionTypes.clear();
              caughtException=null;
            }
          }
          if (caughtException != null) {
            IClass caughtClass=cha.lookupClass(caughtException);
            ArrayList<TypeReference> caught=new ArrayList<TypeReference>(exceptionTypes.size());
            for (            TypeReference t : exceptionTypes) {
              if (t != null) {
                IClass klass=cha.lookupClass(t);
                if (klass == null) {
                  Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
                  addExceptionalEdgeTo(b);
                }
 else {
                  boolean subtype1=cha.isSubclassOf(klass,caughtClass);
                  if (subtype1 || cha.isSubclassOf(caughtClass,klass)) {
                    addExceptionalEdgeTo(b);
                    if (subtype1) {
                      caught.add(t);
                    }
                  }
                }
              }
            }
            exceptionTypes.removeAll(caught);
          }
        }
      }
      if ((exceptionTypes == null && needEdgeToExitForAllHandlers) || (exceptionTypes != null && !exceptionTypes.isEmpty())) {
        BasicBlock exit=exit();
        addExceptionalEdgeTo(exit);
      }
    }
 else {
      BasicBlock exit=exit();
      addExceptionalEdgeTo(exit);
    }
  }
}","/** 
 * Add any exceptional edges generated by the last instruction in a basic block.
 * @param last the last instruction in a basic block.
 */
protected void addExceptionalEdges(IInstruction last){
  IClassHierarchy cha=getMethod().getClassHierarchy();
  if (last.isPEI()) {
    Collection<TypeReference> exceptionTypes=null;
    boolean goToAllHandlers=false;
    ExceptionHandler[] hs=getExceptionHandlers();
    if (last instanceof ThrowInstruction) {
      goToAllHandlers=true;
    }
 else {
      if (hs != null && hs.length > 0) {
        IClassLoader loader=getMethod().getDeclaringClass().getClassLoader();
        BytecodeLanguage l=(BytecodeLanguage)loader.getLanguage();
        exceptionTypes=l.getImplicitExceptionTypes(last);
        if (last instanceof IInvokeInstruction) {
          IInvokeInstruction call=(IInvokeInstruction)last;
          exceptionTypes=HashSetFactory.make(exceptionTypes);
          MethodReference target=MethodReference.findOrCreate(l,loader.getReference(),call.getClassType(),call.getMethodName(),call.getMethodSignature());
          try {
            exceptionTypes.addAll(l.inferInvokeExceptions(target,cha));
          }
 catch (          InvalidClassFileException e) {
            e.printStackTrace();
            Assertions.UNREACHABLE();
          }
        }
      }
    }
    if (hs != null && hs.length > 0) {
      if (!goToAllHandlers) {
        exceptionTypes=HashSetFactory.make(exceptionTypes);
      }
      boolean needEdgeToExitForAllHandlers=true;
      for (int j=0; j < hs.length; j++) {
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + hs[j]);
        }
        BasicBlock b=getBlockForInstruction(hs[j].getHandler());
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + b);
        }
        if (goToAllHandlers) {
          if (DEBUG) {
            System.err.println(""String_Node_Str"" + b);
          }
          addExceptionalEdgeTo(b);
          if (hs[j].getCatchClass() == null) {
            needEdgeToExitForAllHandlers=false;
            break;
          }
        }
 else {
          TypeReference caughtException=null;
          if (hs[j].getCatchClass() != null) {
            ClassLoaderReference loader=ShrikeCFG.this.getMethod().getDeclaringClass().getReference().getClassLoader();
            caughtException=ShrikeUtil.makeTypeReference(loader,hs[j].getCatchClass());
            if (DEBUG) {
              System.err.println(""String_Node_Str"" + caughtException);
            }
            IClass caughtClass=cha.lookupClass(caughtException);
            if (caughtClass == null) {
              addExceptionalEdgeTo(b);
              Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
              caughtException=null;
            }
          }
 else {
            if (DEBUG) {
              System.err.println(""String_Node_Str"");
            }
            if (!exceptionTypes.isEmpty()) {
              addExceptionalEdgeTo(b);
              exceptionTypes.clear();
              caughtException=null;
            }
          }
          if (caughtException != null) {
            IClass caughtClass=cha.lookupClass(caughtException);
            ArrayList<TypeReference> caught=new ArrayList<TypeReference>(exceptionTypes.size());
            for (            TypeReference t : exceptionTypes) {
              if (t != null) {
                IClass klass=cha.lookupClass(t);
                if (klass == null) {
                  Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
                  addExceptionalEdgeTo(b);
                }
 else {
                  boolean subtype1=cha.isSubclassOf(klass,caughtClass);
                  if (subtype1 || cha.isSubclassOf(caughtClass,klass)) {
                    addExceptionalEdgeTo(b);
                    if (subtype1) {
                      caught.add(t);
                    }
                  }
                }
              }
            }
            exceptionTypes.removeAll(caught);
          }
        }
      }
      if ((exceptionTypes == null && needEdgeToExitForAllHandlers) || (exceptionTypes != null && !exceptionTypes.isEmpty())) {
        BasicBlock exit=exit();
        addExceptionalEdgeTo(exit);
      }
    }
 else {
      BasicBlock exit=exit();
      addExceptionalEdgeTo(exit);
    }
  }
}",0.9978067644003232
38401,"/** 
 * Build an IR, then check integrity on two flavors of CFG
 */
private void doMethod(String methodSig){
  try {
    AnalysisScope scope=AnalysisScopeReader.makePrimordialScope(FileProvider.getFile(CallGraphTestUtil.REGRESSION_EXCLUSIONS));
    ClassHierarchy cha=ClassHierarchy.make(scope);
    MethodReference mr=StringStuff.makeMethodReference(Language.JAVA,methodSig);
    IMethod m=cha.resolveMethod(mr);
    if (m == null) {
      Assertions.UNREACHABLE(""String_Node_Str"" + mr);
    }
    AnalysisOptions options=new AnalysisOptions();
    AnalysisCache cache=new AnalysisCache();
    options.getSSAOptions().setPiNodePolicy(SSAOptions.getAllBuiltInPiNodes());
    IR ir=cache.getSSACache().findOrCreateIR(m,Everywhere.EVERYWHERE,options.getSSAOptions());
    ControlFlowGraph<SSAInstruction,ISSABasicBlock> cfg=ir.getControlFlowGraph();
    try {
      GraphIntegrity.check(cfg);
    }
 catch (    UnsoundGraphException e) {
      e.printStackTrace();
      System.err.println(ir);
      Assert.assertTrue(""String_Node_Str"" + methodSig,false);
    }
    try {
      GraphIntegrity.check(cfg);
    }
 catch (    UnsoundGraphException e) {
      e.printStackTrace();
      System.err.println(ir);
      System.err.println(cfg);
      Assert.assertTrue(""String_Node_Str"" + methodSig,false);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    Assertions.UNREACHABLE();
  }
}","/** 
 * Build an IR, then check integrity on two flavors of CFG
 */
private void doMethod(String methodSig){
  try {
    MethodReference mr=StringStuff.makeMethodReference(Language.JAVA,methodSig);
    IMethod m=cha.resolveMethod(mr);
    if (m == null) {
      Assertions.UNREACHABLE(""String_Node_Str"" + mr);
    }
    AnalysisOptions options=new AnalysisOptions();
    AnalysisCache cache=new AnalysisCache();
    options.getSSAOptions().setPiNodePolicy(SSAOptions.getAllBuiltInPiNodes());
    IR ir=cache.getSSACache().findOrCreateIR(m,Everywhere.EVERYWHERE,options.getSSAOptions());
    ControlFlowGraph<SSAInstruction,ISSABasicBlock> cfg=ir.getControlFlowGraph();
    try {
      GraphIntegrity.check(cfg);
    }
 catch (    UnsoundGraphException e) {
      e.printStackTrace();
      System.err.println(ir);
      Assert.assertTrue(""String_Node_Str"" + methodSig,false);
    }
    try {
      GraphIntegrity.check(cfg);
    }
 catch (    UnsoundGraphException e) {
      e.printStackTrace();
      System.err.println(ir);
      System.err.println(cfg);
      Assert.assertTrue(""String_Node_Str"" + methodSig,false);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    Assertions.UNREACHABLE();
  }
}",0.931391337677271
38402,"/** 
 * Add any exceptional edges generated by the last instruction in a basic block.
 * @param last the last instruction in a basic block.
 */
protected void addExceptionalEdges(IInstruction last){
  IClassHierarchy cha=getMethod().getClassHierarchy();
  if (last.isPEI()) {
    Collection<TypeReference> exceptionTypes=null;
    boolean goToAllHandlers=false;
    ExceptionHandler[] hs=getExceptionHandlers();
    if (last instanceof ThrowInstruction) {
      goToAllHandlers=true;
    }
 else {
      if (hs != null && hs.length > 0) {
        IClassLoader loader=getMethod().getDeclaringClass().getClassLoader();
        BytecodeLanguage l=(BytecodeLanguage)loader.getLanguage();
        exceptionTypes=l.getImplicitExceptionTypes(last);
        if (last instanceof IInvokeInstruction) {
          IInvokeInstruction call=(IInvokeInstruction)last;
          exceptionTypes=HashSetFactory.make(exceptionTypes);
          MethodReference target=MethodReference.findOrCreate(l,loader.getReference(),call.getClassType(),call.getMethodName(),call.getMethodSignature());
          try {
            exceptionTypes.addAll(l.inferInvokeExceptions(target,cha));
          }
 catch (          InvalidClassFileException e) {
            e.printStackTrace();
            Assertions.UNREACHABLE();
          }
        }
      }
    }
    if (hs != null && hs.length > 0) {
      if (!goToAllHandlers) {
        exceptionTypes=HashSetFactory.make(exceptionTypes);
      }
      for (int j=0; j < hs.length; j++) {
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + hs[j]);
        }
        BasicBlock b=getBlockForInstruction(hs[j].getHandler());
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + b);
        }
        if (goToAllHandlers) {
          if (DEBUG) {
            System.err.println(""String_Node_Str"" + b);
          }
          addExceptionalEdgeTo(b);
        }
 else {
          TypeReference caughtException=null;
          if (hs[j].getCatchClass() != null) {
            ClassLoaderReference loader=ShrikeCFG.this.getMethod().getDeclaringClass().getReference().getClassLoader();
            caughtException=ShrikeUtil.makeTypeReference(loader,hs[j].getCatchClass());
            if (DEBUG) {
              System.err.println(""String_Node_Str"" + caughtException);
            }
            IClass caughtClass=cha.lookupClass(caughtException);
            if (caughtClass == null) {
              addExceptionalEdgeTo(b);
              Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
              caughtException=null;
            }
          }
 else {
            if (DEBUG) {
              System.err.println(""String_Node_Str"");
            }
            if (!exceptionTypes.isEmpty()) {
              addExceptionalEdgeTo(b);
              exceptionTypes.clear();
              caughtException=null;
            }
          }
          if (caughtException != null) {
            IClass caughtClass=cha.lookupClass(caughtException);
            ArrayList<TypeReference> caught=new ArrayList<TypeReference>(exceptionTypes.size());
            for (            TypeReference t : exceptionTypes) {
              if (t != null) {
                IClass klass=cha.lookupClass(t);
                if (klass == null) {
                  Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
                  addExceptionalEdgeTo(b);
                }
 else {
                  boolean subtype1=cha.isSubclassOf(klass,caughtClass);
                  if (subtype1 || cha.isSubclassOf(caughtClass,klass)) {
                    addExceptionalEdgeTo(b);
                    if (subtype1) {
                      caught.add(t);
                    }
                  }
                }
              }
            }
            exceptionTypes.removeAll(caught);
          }
        }
      }
      if (exceptionTypes == null || !exceptionTypes.isEmpty()) {
        BasicBlock exit=exit();
        addExceptionalEdgeTo(exit);
      }
    }
 else {
      BasicBlock exit=exit();
      addExceptionalEdgeTo(exit);
    }
  }
}","/** 
 * Add any exceptional edges generated by the last instruction in a basic block.
 * @param last the last instruction in a basic block.
 */
protected void addExceptionalEdges(IInstruction last){
  IClassHierarchy cha=getMethod().getClassHierarchy();
  if (last.isPEI()) {
    Collection<TypeReference> exceptionTypes=null;
    boolean goToAllHandlers=false;
    ExceptionHandler[] hs=getExceptionHandlers();
    if (last instanceof ThrowInstruction) {
      goToAllHandlers=true;
    }
 else {
      if (hs != null && hs.length > 0) {
        IClassLoader loader=getMethod().getDeclaringClass().getClassLoader();
        BytecodeLanguage l=(BytecodeLanguage)loader.getLanguage();
        exceptionTypes=l.getImplicitExceptionTypes(last);
        if (last instanceof IInvokeInstruction) {
          IInvokeInstruction call=(IInvokeInstruction)last;
          exceptionTypes=HashSetFactory.make(exceptionTypes);
          MethodReference target=MethodReference.findOrCreate(l,loader.getReference(),call.getClassType(),call.getMethodName(),call.getMethodSignature());
          try {
            exceptionTypes.addAll(l.inferInvokeExceptions(target,cha));
          }
 catch (          InvalidClassFileException e) {
            e.printStackTrace();
            Assertions.UNREACHABLE();
          }
        }
      }
    }
    if (hs != null && hs.length > 0) {
      if (!goToAllHandlers) {
        exceptionTypes=HashSetFactory.make(exceptionTypes);
      }
      boolean needEdgeToExitForAllHandlers=true;
      for (int j=0; j < hs.length; j++) {
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + hs[j]);
        }
        BasicBlock b=getBlockForInstruction(hs[j].getHandler());
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + b);
        }
        if (goToAllHandlers) {
          if (DEBUG) {
            System.err.println(""String_Node_Str"" + b);
          }
          addExceptionalEdgeTo(b);
          if (hs[j].getCatchClass() == null) {
            needEdgeToExitForAllHandlers=false;
          }
        }
 else {
          TypeReference caughtException=null;
          if (hs[j].getCatchClass() != null) {
            ClassLoaderReference loader=ShrikeCFG.this.getMethod().getDeclaringClass().getReference().getClassLoader();
            caughtException=ShrikeUtil.makeTypeReference(loader,hs[j].getCatchClass());
            if (DEBUG) {
              System.err.println(""String_Node_Str"" + caughtException);
            }
            IClass caughtClass=cha.lookupClass(caughtException);
            if (caughtClass == null) {
              addExceptionalEdgeTo(b);
              Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
              caughtException=null;
            }
          }
 else {
            if (DEBUG) {
              System.err.println(""String_Node_Str"");
            }
            if (!exceptionTypes.isEmpty()) {
              addExceptionalEdgeTo(b);
              exceptionTypes.clear();
              caughtException=null;
            }
          }
          if (caughtException != null) {
            IClass caughtClass=cha.lookupClass(caughtException);
            ArrayList<TypeReference> caught=new ArrayList<TypeReference>(exceptionTypes.size());
            for (            TypeReference t : exceptionTypes) {
              if (t != null) {
                IClass klass=cha.lookupClass(t);
                if (klass == null) {
                  Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
                  addExceptionalEdgeTo(b);
                }
 else {
                  boolean subtype1=cha.isSubclassOf(klass,caughtClass);
                  if (subtype1 || cha.isSubclassOf(caughtClass,klass)) {
                    addExceptionalEdgeTo(b);
                    if (subtype1) {
                      caught.add(t);
                    }
                  }
                }
              }
            }
            exceptionTypes.removeAll(caught);
          }
        }
      }
      if ((exceptionTypes == null && needEdgeToExitForAllHandlers) || (exceptionTypes != null && !exceptionTypes.isEmpty())) {
        BasicBlock exit=exit();
        addExceptionalEdgeTo(exit);
      }
    }
 else {
      BasicBlock exit=exit();
      addExceptionalEdgeTo(exit);
    }
  }
}",0.9586992641822928
38403,"/** 
 * Return a view of the   {@link ControlFlowGraph} for an {@link IR}, which elides all exceptional exits from PEIs in the IR.
 */
public static Graph<ISSABasicBlock> sanitize(IR ir,IClassHierarchy cha) throws IllegalArgumentException, WalaException {
  if (ir == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ControlFlowGraph<SSAInstruction,ISSABasicBlock> cfg=ir.getControlFlowGraph();
  Graph<ISSABasicBlock> g=SlowSparseNumberedGraph.make();
  for (Iterator<? extends ISSABasicBlock> it=cfg.iterator(); it.hasNext(); ) {
    g.addNode(it.next());
  }
  for (Iterator it=cfg.iterator(); it.hasNext(); ) {
    ISSABasicBlock b=(ISSABasicBlock)it.next();
    for (Iterator it2=cfg.getSuccNodes(b); it2.hasNext(); ) {
      ISSABasicBlock b2=(ISSABasicBlock)it2.next();
      if (!b2.isExitBlock()) {
        g.addEdge(b,b2);
      }
    }
  }
  ISSABasicBlock exit=cfg.exit();
  for (Iterator it=cfg.getPredNodes(exit); it.hasNext(); ) {
    ISSABasicBlock b=(ISSABasicBlock)it.next();
    SSAInstruction s=ir.getInstructions()[b.getLastInstructionIndex()];
    if (s == null) {
      continue;
    }
    if (s instanceof SSAReturnInstruction || s instanceof SSAThrowInstruction) {
      g.addEdge(b,exit);
    }
 else {
      TypeReference[] exceptions=null;
      try {
        exceptions=computeExceptions(cha,ir,s);
      }
 catch (      InvalidClassFileException e1) {
        e1.printStackTrace();
        Assertions.UNREACHABLE();
      }
      for (Iterator it2=cfg.getSuccNodes(b); it2.hasNext(); ) {
        IBasicBlock c=(IBasicBlock)it2.next();
        if (c.isCatchBlock()) {
          SSACFG.ExceptionHandlerBasicBlock cb=(ExceptionHandlerBasicBlock)c;
          for (Iterator it3=cb.getCaughtExceptionTypes(); it3.hasNext(); ) {
            TypeReference ex=(TypeReference)it3.next();
            IClass exClass=cha.lookupClass(ex);
            if (exClass == null) {
              throw new WalaException(""String_Node_Str"" + ex);
            }
            for (int i=0; i < exceptions.length; i++) {
              if (exceptions[i] != null) {
                IClass exi=cha.lookupClass(exceptions[i]);
                if (exi == null) {
                  throw new WalaException(""String_Node_Str"" + exceptions[i]);
                }
                if (cha.isSubclassOf(exi,exClass)) {
                  exceptions[i]=null;
                }
              }
            }
          }
        }
      }
      TypeReference[] declared=null;
      try {
        declared=ir.getMethod().getDeclaredExceptions();
      }
 catch (      InvalidClassFileException e) {
        e.printStackTrace();
        Assertions.UNREACHABLE();
      }
      if (declared != null && exceptions != null) {
        for (int i=0; i < exceptions.length; i++) {
          boolean isDeclared=false;
          if (exceptions[i] != null) {
            IClass exi=cha.lookupClass(exceptions[i]);
            if (exi == null) {
              throw new WalaException(""String_Node_Str"" + exceptions[i]);
            }
            for (int j=0; j < declared.length; j++) {
              IClass dc=cha.lookupClass(declared[j]);
              if (dc == null) {
                throw new WalaException(""String_Node_Str"" + declared[j]);
              }
              if (cha.isSubclassOf(exi,dc)) {
                isDeclared=true;
                break;
              }
            }
            if (isDeclared) {
              g.addEdge(b,exit);
            }
          }
        }
      }
    }
  }
  return g;
}","/** 
 * Return a view of the   {@link ControlFlowGraph} for an {@link IR}, which elides all exceptional exits from PEIs in the IR.
 */
public static Graph<ISSABasicBlock> sanitize(IR ir,IClassHierarchy cha) throws IllegalArgumentException, WalaException {
  if (ir == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ControlFlowGraph<SSAInstruction,ISSABasicBlock> cfg=ir.getControlFlowGraph();
  Graph<ISSABasicBlock> g=SlowSparseNumberedGraph.make();
  for (Iterator<? extends ISSABasicBlock> it=cfg.iterator(); it.hasNext(); ) {
    g.addNode(it.next());
  }
  for (Iterator it=cfg.iterator(); it.hasNext(); ) {
    ISSABasicBlock b=(ISSABasicBlock)it.next();
    for (Iterator it2=cfg.getSuccNodes(b); it2.hasNext(); ) {
      ISSABasicBlock b2=(ISSABasicBlock)it2.next();
      if (!b2.isExitBlock()) {
        g.addEdge(b,b2);
      }
    }
  }
  ISSABasicBlock exit=cfg.exit();
  for (Iterator it=cfg.getPredNodes(exit); it.hasNext(); ) {
    ISSABasicBlock b=(ISSABasicBlock)it.next();
    SSAInstruction s=ir.getInstructions()[b.getLastInstructionIndex()];
    if (s == null) {
      continue;
    }
    if (s instanceof SSAReturnInstruction || s instanceof SSAThrowInstruction || cfg.getSuccNodeCount(b) == 1) {
      g.addEdge(b,exit);
    }
 else {
      TypeReference[] exceptions=null;
      try {
        exceptions=computeExceptions(cha,ir,s);
      }
 catch (      InvalidClassFileException e1) {
        e1.printStackTrace();
        Assertions.UNREACHABLE();
      }
      for (Iterator it2=cfg.getSuccNodes(b); it2.hasNext(); ) {
        IBasicBlock c=(IBasicBlock)it2.next();
        if (c.isCatchBlock()) {
          SSACFG.ExceptionHandlerBasicBlock cb=(ExceptionHandlerBasicBlock)c;
          for (Iterator it3=cb.getCaughtExceptionTypes(); it3.hasNext(); ) {
            TypeReference ex=(TypeReference)it3.next();
            IClass exClass=cha.lookupClass(ex);
            if (exClass == null) {
              throw new WalaException(""String_Node_Str"" + ex);
            }
            for (int i=0; i < exceptions.length; i++) {
              if (exceptions[i] != null) {
                IClass exi=cha.lookupClass(exceptions[i]);
                if (exi == null) {
                  throw new WalaException(""String_Node_Str"" + exceptions[i]);
                }
                if (cha.isSubclassOf(exi,exClass)) {
                  exceptions[i]=null;
                }
              }
            }
          }
        }
      }
      TypeReference[] declared=null;
      try {
        declared=ir.getMethod().getDeclaredExceptions();
      }
 catch (      InvalidClassFileException e) {
        e.printStackTrace();
        Assertions.UNREACHABLE();
      }
      if (declared != null && exceptions != null) {
        for (int i=0; i < exceptions.length; i++) {
          boolean isDeclared=false;
          if (exceptions[i] != null) {
            IClass exi=cha.lookupClass(exceptions[i]);
            if (exi == null) {
              throw new WalaException(""String_Node_Str"" + exceptions[i]);
            }
            for (int j=0; j < declared.length; j++) {
              IClass dc=cha.lookupClass(declared[j]);
              if (dc == null) {
                throw new WalaException(""String_Node_Str"" + declared[j]);
              }
              if (cha.isSubclassOf(exi,dc)) {
                isDeclared=true;
                break;
              }
            }
            if (isDeclared) {
              g.addEdge(b,exit);
            }
          }
        }
      }
    }
  }
  return g;
}",0.995481502400452
38404,"/** 
 * Initialize internal data structures
 * @throws IllegalArgumentException if modules is null
 */
public void init(List<Module> modules) throws IOException {
  if (modules == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Set<ModuleEntry> classModuleEntries=HashSetFactory.make();
  Set<ModuleEntry> sourceModuleEntries=HashSetFactory.make();
  for (Iterator<Module> it=modules.iterator(); it.hasNext(); ) {
    Module archive=it.next();
    Set<ModuleEntry> classFiles=getClassFiles(archive);
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + archive);
    }
    removeClassFiles(classFiles,classModuleEntries);
    for (Iterator<ModuleEntry> it2=classFiles.iterator(); it2.hasNext(); ) {
      ModuleEntry file=it2.next();
      classModuleEntries.add(file);
    }
    Set<ModuleEntry> sourceFiles=getSourceFiles(archive);
    for (Iterator<ModuleEntry> it2=sourceFiles.iterator(); it2.hasNext(); ) {
      ModuleEntry file=it2.next();
      sourceModuleEntries.add(file);
    }
  }
  loadAllClasses(classModuleEntries);
  loadAllSources(sourceModuleEntries);
}","/** 
 * Initialize internal data structures
 * @throws IllegalArgumentException if modules is null
 */
public void init(List<Module> modules) throws IOException {
  if (modules == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Set<ModuleEntry> classModuleEntries=HashSetFactory.make();
  Set<ModuleEntry> sourceModuleEntries=HashSetFactory.make();
  for (Iterator<Module> it=modules.iterator(); it.hasNext(); ) {
    Module archive=it.next();
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + archive);
    }
    if (OPTIMIZE_JAR_FILE_IO && archive instanceof JarFileModule) {
      getJarFileContents((JarFileModule)archive);
    }
    Set<ModuleEntry> classFiles=getClassFiles(archive);
    removeClassFiles(classFiles,classModuleEntries);
    Set<ModuleEntry> sourceFiles=getSourceFiles(archive);
    Map<String,Object> allClassAndSourceFileContents=null;
    if (OPTIMIZE_JAR_FILE_IO) {
    }
    loadAllClasses(classFiles,allClassAndSourceFileContents);
    loadAllSources(sourceFiles);
    for (Iterator<ModuleEntry> it2=classFiles.iterator(); it2.hasNext(); ) {
      ModuleEntry file=it2.next();
      classModuleEntries.add(file);
    }
    for (Iterator<ModuleEntry> it2=sourceFiles.iterator(); it2.hasNext(); ) {
      ModuleEntry file=it2.next();
      sourceModuleEntries.add(file);
    }
  }
}",0.6871711857547551
38405,"/** 
 * Set up the set of classes loaded by this object.
 */
private void loadAllClasses(Collection<ModuleEntry> moduleEntries){
  for (Iterator<ModuleEntry> it=moduleEntries.iterator(); it.hasNext(); ) {
    ModuleEntry entry=it.next();
    if (!entry.isClassFile()) {
      continue;
    }
    String className=entry.getClassName().replace('.','/');
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + className);
    }
    if (exclusions != null && exclusions.contains(className)) {
      if (DEBUG_LEVEL > 0) {
        System.err.println(""String_Node_Str"" + className);
      }
      continue;
    }
    ShrikeClassReaderHandle reader=new ShrikeClassReaderHandle(entry);
    className=""String_Node_Str"" + className;
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + className);
    }
    try {
      TypeName T=TypeName.string2TypeName(className);
      if (loadedClasses.get(T) != null) {
        Warnings.add(MultipleImplementationsWarning.create(className));
      }
 else       if (parent != null && parent.lookupClass(T) != null) {
        Warnings.add(MultipleImplementationsWarning.create(className));
      }
 else {
        ShrikeClass klass=new ShrikeClass(reader,this,cha);
        if (klass.getReference().getName().equals(T)) {
          loadedClasses.put(T,klass);
          if (DEBUG_LEVEL > 1) {
            System.err.println(""String_Node_Str"" + T + ""String_Node_Str"");
          }
        }
 else {
          Warnings.add(InvalidClassFile.create(className));
        }
      }
    }
 catch (    InvalidClassFileException e) {
      if (DEBUG_LEVEL > 0) {
        System.err.println(""String_Node_Str"" + className + ""String_Node_Str"");
      }
      Warnings.add(InvalidClassFile.create(className));
    }
  }
}","/** 
 * Set up the set of classes loaded by this object.
 */
private void loadAllClasses(Collection<ModuleEntry> moduleEntries,Map<String,Object> fileContents){
  for (Iterator<ModuleEntry> it=moduleEntries.iterator(); it.hasNext(); ) {
    ModuleEntry entry=it.next();
    if (!entry.isClassFile()) {
      continue;
    }
    String className=entry.getClassName().replace('.','/');
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + className);
    }
    if (exclusions != null && exclusions.contains(className)) {
      if (DEBUG_LEVEL > 0) {
        System.err.println(""String_Node_Str"" + className);
      }
      continue;
    }
    ShrikeClassReaderHandle entryReader=new ShrikeClassReaderHandle(entry);
    className=""String_Node_Str"" + className;
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + className);
    }
    try {
      TypeName T=TypeName.string2TypeName(className);
      if (loadedClasses.get(T) != null) {
        Warnings.add(MultipleImplementationsWarning.create(className));
      }
 else       if (parent != null && parent.lookupClass(T) != null) {
        Warnings.add(MultipleImplementationsWarning.create(className));
      }
 else {
        ShrikeClassReaderHandle reader=entryReader;
        if (fileContents != null) {
          final Object contents=fileContents.get(entry.getName());
          if (contents != null) {
            reader=new ByteArrayReaderHandle(entry,(byte[])contents);
          }
        }
        ShrikeClass tmpKlass=new ShrikeClass(reader,this,cha);
        if (tmpKlass.getReference().getName().equals(T)) {
          loadedClasses.put(T,new ShrikeClass(entryReader,this,cha));
          if (DEBUG_LEVEL > 1) {
            System.err.println(""String_Node_Str"" + T + ""String_Node_Str"");
          }
        }
 else {
          Warnings.add(InvalidClassFile.create(className));
        }
      }
    }
 catch (    InvalidClassFileException e) {
      if (DEBUG_LEVEL > 0) {
        System.err.println(""String_Node_Str"" + className + ""String_Node_Str"");
      }
      Warnings.add(InvalidClassFile.create(className));
    }
  }
}",0.9051768323936444
38406,"protected void defineFunction(CAstEntity N,WalkContext definingContext,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,TypeReference[][] caughtTypes,boolean hasMonitorOp,AstLexicalInformation LI,DebuggingInformation debugInfo){
  if (DEBUG)   System.err.println((""String_Node_Str"" + N));
  String fnName=composeEntityName(definingContext,N);
  if (DEBUG)   System.err.println(cfg);
  symtab.getConstant(""String_Node_Str"");
  symtab.getConstant(""String_Node_Str"");
  for (int i=0; i < 15; i++) {
    symtab.getConstant(i);
  }
  ((JavaScriptLoader)loader).defineCodeBodyCode(""String_Node_Str"" + fnName,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo);
}","protected void defineFunction(CAstEntity N,WalkContext definingContext,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,TypeReference[][] caughtTypes,boolean hasMonitorOp,AstLexicalInformation LI,DebuggingInformation debugInfo){
  if (DEBUG)   System.err.println((""String_Node_Str"" + N));
  String fnName=composeEntityName(definingContext,N);
  if (DEBUG)   System.err.println(cfg);
  symtab.getConstant(""String_Node_Str"");
  symtab.getConstant(""String_Node_Str"");
  for (int i=0; i < 20; i++) {
    symtab.getConstant(i);
  }
  ((JavaScriptLoader)loader).defineCodeBodyCode(""String_Node_Str"" + fnName,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo);
}",0.9970414201183432
38407,"protected void doFieldWrite(WalkContext context,int receiver,CAstNode elt,CAstNode parent,int rval){
  this.visit(elt,context,this);
  if (elt.getKind() == CAstNode.CONSTANT && elt.getValue() instanceof String) {
    context.cfg().addInstruction(((JSInstructionFactory)insts).PutInstruction(receiver,rval,(String)elt.getValue()));
  }
 else {
    context.cfg().addInstruction(((JSInstructionFactory)insts).PropertyWrite(receiver,getValue(elt),rval));
  }
}","protected void doFieldWrite(WalkContext context,int receiver,CAstNode elt,CAstNode parent,int rval){
}",0.3655913978494624
38408,"@SuppressWarnings(""String_Node_Str"") void processJSCall(CGNode caller,JavaScriptInvoke instruction,CGNode target,InstanceKey function,InstanceKey constParams[][],PointerKey uniqueCatchKey){
  caller.addTarget(instruction.getCallSite(),target);
  if (!getBuilder().haveAlreadyVisited(target)) {
    getBuilder().markDiscovered(target);
  }
  IR sourceIR=getBuilder().getCFAContextInterpreter().getIR(caller);
  SymbolTable sourceST=sourceIR.getSymbolTable();
  IR targetIR=getBuilder().getCFAContextInterpreter().getIR(target);
  SymbolTable targetST=targetIR.getSymbolTable();
  int av=-1;
  for (int v=0; v <= targetST.getMaxValueNumber(); v++) {
    String[] vns=targetIR.getLocalNames(1,v);
    for (int n=0; vns != null && n < vns.length; n++) {
      if (""String_Node_Str"".equals(vns[n])) {
        av=v;
        break;
      }
    }
  }
  int paramCount=targetST.getParameterValueNumbers().length;
  int argCount=instruction.getNumberOfParameters();
  for (int i=0; i < Math.min(paramCount,argCount); i++) {
    int fn=targetST.getConstant(i);
    PointerKey F=(i == 0) ? getBuilder().getFilteredPointerKeyForLocal(target,targetST.getParameter(i),function) : getBuilder().getPointerKeyForLocal(target,targetST.getParameter(i));
    if (constParams != null && constParams[i] != null) {
      for (int j=0; j < constParams[i].length; j++) {
        system.newConstraint(F,constParams[i][j]);
      }
      if (av != -1)       newFieldWrite(target,av,fn,constParams[i]);
    }
 else {
      PointerKey A=getBuilder().getPointerKeyForLocal(caller,instruction.getUse(i));
      system.newConstraint(F,(F instanceof FilteredPointerKey) ? getBuilder().filterOperator : assignOperator,A);
      if (av != -1)       newFieldWrite(target,av,fn,F);
    }
  }
  if (paramCount < argCount) {
    if (av != -1) {
      for (int i=paramCount; i < argCount; i++) {
        int fn=targetST.getConstant(i);
        if (constParams != null && constParams[i] != null) {
          newFieldWrite(target,av,fn,constParams[i]);
        }
 else {
          PointerKey A=getBuilder().getPointerKeyForLocal(caller,instruction.getUse(i));
          newFieldWrite(target,av,fn,A);
        }
      }
    }
  }
 else   if (argCount < paramCount) {
    int nullvn=sourceST.getNullConstant();
    DefUse sourceDU=getBuilder().getCFAContextInterpreter().getDU(caller);
    InstanceKey[] nullkeys=getInvariantContents(sourceST,sourceDU,caller,nullvn);
    for (int i=argCount; i < paramCount; i++) {
      PointerKey F=getBuilder().getPointerKeyForLocal(target,targetST.getParameter(i));
      for (int k=0; k < nullkeys.length; k++) {
        system.newConstraint(F,nullkeys[k]);
      }
    }
  }
  if (av != -1) {
    int svn=targetST.getConstant(argCount);
    int lnv=targetST.getConstant(""String_Node_Str"");
    newFieldWrite(target,av,lnv,svn);
  }
  if (instruction.getDef(0) != -1) {
    PointerKey RF=getBuilder().getPointerKeyForReturnValue(target);
    PointerKey RA=getBuilder().getPointerKeyForLocal(caller,instruction.getDef(0));
    system.newConstraint(RA,assignOperator,RF);
  }
  PointerKey EF=getBuilder().getPointerKeyForExceptionalReturnValue(target);
  if (SHORT_CIRCUIT_SINGLE_USES && uniqueCatchKey != null) {
    system.newConstraint(uniqueCatchKey,assignOperator,EF);
  }
 else {
    PointerKey EA=getBuilder().getPointerKeyForLocal(caller,instruction.getDef(1));
    system.newConstraint(EA,assignOperator,EF);
  }
}","@SuppressWarnings(""String_Node_Str"") void processJSCall(CGNode caller,JavaScriptInvoke instruction,CGNode target,InstanceKey function,InstanceKey constParams[][],PointerKey uniqueCatchKey){
  caller.addTarget(instruction.getCallSite(),target);
  if (!getBuilder().haveAlreadyVisited(target)) {
    getBuilder().markDiscovered(target);
  }
  IR sourceIR=getBuilder().getCFAContextInterpreter().getIR(caller);
  SymbolTable sourceST=sourceIR.getSymbolTable();
  IR targetIR=getBuilder().getCFAContextInterpreter().getIR(target);
  SymbolTable targetST=targetIR.getSymbolTable();
  int av=-1;
  for (int v=0; v <= targetST.getMaxValueNumber(); v++) {
    String[] vns=targetIR.getLocalNames(1,v);
    for (int n=0; vns != null && n < vns.length; n++) {
      if (""String_Node_Str"".equals(vns[n])) {
        av=v;
        break;
      }
    }
  }
  int paramCount=targetST.getParameterValueNumbers().length;
  int argCount=instruction.getNumberOfParameters();
  for (int i=0; i < Math.min(paramCount,argCount); i++) {
    int fn=targetST.getConstant(i);
    PointerKey F=(i == 0) ? getBuilder().getFilteredPointerKeyForLocal(target,targetST.getParameter(i),function.getConcreteType()) : getBuilder().getPointerKeyForLocal(target,targetST.getParameter(i));
    if (constParams != null && constParams[i] != null) {
      for (int j=0; j < constParams[i].length; j++) {
        system.newConstraint(F,constParams[i][j]);
      }
      if (av != -1)       newFieldWrite(target,av,fn,constParams[i]);
    }
 else {
      PointerKey A=getBuilder().getPointerKeyForLocal(caller,instruction.getUse(i));
      system.newConstraint(F,(F instanceof FilteredPointerKey) ? getBuilder().filterOperator : assignOperator,A);
      if (av != -1)       newFieldWrite(target,av,fn,F);
    }
  }
  if (paramCount < argCount) {
    if (av != -1) {
      for (int i=paramCount; i < argCount; i++) {
        int fn=targetST.getConstant(i);
        if (constParams != null && constParams[i] != null) {
          newFieldWrite(target,av,fn,constParams[i]);
        }
 else {
          PointerKey A=getBuilder().getPointerKeyForLocal(caller,instruction.getUse(i));
          newFieldWrite(target,av,fn,A);
        }
      }
    }
  }
 else   if (argCount < paramCount) {
    int nullvn=sourceST.getNullConstant();
    DefUse sourceDU=getBuilder().getCFAContextInterpreter().getDU(caller);
    InstanceKey[] nullkeys=getInvariantContents(sourceST,sourceDU,caller,nullvn);
    for (int i=argCount; i < paramCount; i++) {
      PointerKey F=getBuilder().getPointerKeyForLocal(target,targetST.getParameter(i));
      for (int k=0; k < nullkeys.length; k++) {
        system.newConstraint(F,nullkeys[k]);
      }
    }
  }
  if (av != -1) {
    int svn=targetST.getConstant(argCount);
    int lnv=targetST.getConstant(""String_Node_Str"");
    newFieldWrite(target,av,lnv,svn);
  }
  if (instruction.getDef(0) != -1) {
    PointerKey RF=getBuilder().getPointerKeyForReturnValue(target);
    PointerKey RA=getBuilder().getPointerKeyForLocal(caller,instruction.getDef(0));
    system.newConstraint(RA,assignOperator,RF);
  }
  PointerKey EF=getBuilder().getPointerKeyForExceptionalReturnValue(target);
  if (SHORT_CIRCUIT_SINGLE_USES && uniqueCatchKey != null) {
    system.newConstraint(uniqueCatchKey,assignOperator,EF);
  }
 else {
    PointerKey EA=getBuilder().getPointerKeyForLocal(caller,instruction.getDef(1));
    system.newConstraint(EA,assignOperator,EF);
  }
}",0.9973714953271028
38409,"public void setPc(int pc){
  Integer lineNum=pcToLine.get(pc);
  if (lineNum != null) {
    irLines.ensureIndexIsVisible(lineNum);
    irLines.setSelectedIndex(lineNum);
  }
}","public void setPc(int pc){
  Integer lineNum=pcToLine.get(pc);
  if (lineNum != null) {
    irLines.ensureIndexIsVisible(lineNum);
    irLines.setSelectedIndex(lineNum);
  }
 else {
    removeSelection();
  }
}",0.9090909090909092
38410,"public void setIRAndPc(IR ir,int pc){
  setIR(ir);
  if (pc != NA) {
    setPc(pc);
  }
 else {
    int curSelectedIndex=irLines.getSelectedIndex();
    irLines.removeSelectionInterval(curSelectedIndex,curSelectedIndex);
  }
}","public void setIRAndPc(IR ir,int pc){
  setIR(ir);
  if (pc != NA) {
    setPc(pc);
  }
 else {
    removeSelection();
  }
}",0.7085714285714285
38411,"public void setSource(URL url,int sourceLine){
  sourceCodeLocation.setText(""String_Node_Str"" + url);
  loadSource(url);
  if (sourceLine != IrViewer.NA) {
    sourceCodeLines.ensureIndexIsVisible(sourceLine - 1);
    sourceCodeLines.setSelectedIndex(sourceLine - 1);
    sourceCodeLines.validate();
  }
}","public void setSource(URL url,int sourceLine){
  boolean succsess=loadSource(url);
  if (succsess) {
    sourceCodeLocation.setText(""String_Node_Str"" + url);
    if (sourceLine != IrViewer.NA) {
      sourceCodeLines.ensureIndexIsVisible(sourceLine - 1);
      sourceCodeLines.setSelectedIndex(sourceLine - 1);
      sourceCodeLines.validate();
    }
  }
 else {
    sourceCodeLocation.setText(""String_Node_Str"" + url);
  }
}",0.7890410958904109
38412,"public void removeSource(){
  sourceURL=null;
  sourceCodeLocation=new JTextField(""String_Node_Str"");
  sourceCodeLinesList.clear();
  sourceCodeLines.validate();
}","public void removeSource(){
  sourceURL=null;
  sourceCodeLocation.setText(""String_Node_Str"");
  sourceCodeLinesList.clear();
  sourceCodeLines.validate();
}",0.9595015576323987
38413,"@Test public void testTestCD5() throws ClassHierarchyException, IllegalArgumentException, CancelException, IOException {
  AnalysisScope scope=findOrCreateAnalysisScope();
  IClassHierarchy cha=findOrCreateCHA(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.SLICE_TESTCD5);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  CallGraphBuilder builder=Util.makeZeroOneCFABuilder(options,new AnalysisCache(),cha,scope);
  CallGraph cg=builder.makeCallGraph(options,null);
  CGNode main=findMainMethod(cg);
  Statement s=new MethodEntryStatement(main);
  System.err.println(""String_Node_Str"" + s);
  Collection<Statement> slice=Slicer.computeForwardSlice(s,cg,builder.getPointerAnalysis(),DataDependenceOptions.NONE,ControlDependenceOptions.FULL);
  dumpSlice(slice);
  Assert.assertTrue(slice.size() > 1);
}","@Test public void testTestCD5() throws ClassHierarchyException, IllegalArgumentException, CancelException, IOException {
  AnalysisScope scope=findOrCreateAnalysisScope();
  IClassHierarchy cha=findOrCreateCHA(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.SLICE_TESTCD5);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  CallGraphBuilder builder=Util.makeZeroOneCFABuilder(options,new AnalysisCache(),cha,scope);
  CallGraph cg=builder.makeCallGraph(options,null);
  CGNode main=findMainMethod(cg);
  Statement s=new MethodEntryStatement(main);
  System.err.println(""String_Node_Str"" + s);
  Collection<Statement> slice=Slicer.computeForwardSlice(s,cg,builder.getPointerAnalysis(),DataDependenceOptions.NONE,ControlDependenceOptions.NO_EXCEPTIONAL_EDGES);
  dumpSlice(slice);
  Assert.assertTrue(slice.size() > 1);
}",0.9880823401950164
38414,"@Override public void visitCheckCast(SSACheckCastInstruction instruction){
  TypeAbstraction typeAbs=null;
  for (  TypeReference type : instruction.getDeclaredResultTypes()) {
    IClass klass=cha.lookupClass(type);
    if (klass == null) {
      typeAbs=BOTTOM;
    }
 else {
      if (typeAbs == null) {
        typeAbs=new ConeType(klass);
      }
 else {
        typeAbs=typeAbs.meet(new ConeType(klass));
      }
    }
  }
}","@Override public void visitCheckCast(SSACheckCastInstruction instruction){
  TypeAbstraction typeAbs=null;
  for (  TypeReference type : instruction.getDeclaredResultTypes()) {
    IClass klass=cha.lookupClass(type);
    if (klass == null) {
      typeAbs=BOTTOM;
    }
 else {
      if (typeAbs == null) {
        typeAbs=new ConeType(klass);
      }
 else {
        typeAbs=typeAbs.meet(new ConeType(klass));
      }
    }
  }
  result=new DeclaredTypeOperator(typeAbs);
}",0.9491150442477876
38415,"public static int countNormals(Collection<Statement> slice){
  int count=0;
  for (  Statement s : slice) {
    if (s.getKind().equals(Statement.Kind.NORMAL)) {
      NormalStatement ns=(NormalStatement)s;
      count++;
    }
  }
  return count;
}","public static int countNormals(Collection<Statement> slice){
  int count=0;
  for (  Statement s : slice) {
    if (s.getKind().equals(Statement.Kind.NORMAL)) {
      count++;
    }
  }
  return count;
}",0.9002217294900222
38416,"public void handleSimpleTag(HTML.Tag t,MutableAttributeSet a,int pos){
  System.out.println(""String_Node_Str"" + t);
  if (script) {
    try {
      writeEmbeddedScript(""String_Node_Str"" + t);
      Enumeration names=a.getAttributeNames();
      while (names.hasMoreElements()) {
        Object name=names.nextElement();
        Object val=a.getAttribute(name);
        writeEmbeddedScript(""String_Node_Str"" + name + ""String_Node_Str""+ val+ ""String_Node_Str"");
      }
      writeEmbeddedScript(""String_Node_Str"" + t + ""String_Node_Str"");
    }
 catch (    IOException e) {
    }
  }
 else {
    String nm=createElement(t,a);
    endElement(nm);
  }
}","public void handleSimpleTag(HTML.Tag t,MutableAttributeSet a,int pos){
  System.out.println(""String_Node_Str"" + t);
  if (script) {
  }
 else {
    String nm=createElement(t,a,pos);
    endElement(nm);
  }
}",0.4737456242707117
38417,"protected String createElement(HTML.Tag t,MutableAttributeSet a){
  String tag=t.toString().toUpperCase();
  if (tag.equals(""String_Node_Str"")) {
    Object l=a.getAttribute(HTML.Attribute.LANGUAGE);
    if (l == null || l.toString().toUpperCase().indexOf(""String_Node_Str"") < 0) {
      Object value=a.getAttribute(HTML.Attribute.SRC);
      if (value != null) {
        try {
          URL scriptSrc=new URL(input,value.toString());
          InputStreamReader scriptReader=new InputStreamReader(scriptSrc.openConnection().getInputStream());
          int read;
          char[] buffer=new char[1024];
          while ((read=scriptReader.read(buffer)) != -1) {
            writeEmbeddedScript(buffer,read);
          }
          embeddedScriptFile.flush();
          scriptReader.close();
        }
 catch (        IOException e) {
          System.out.println(""String_Node_Str"" + value);
        }
      }
 else {
        System.out.println(""String_Node_Str"");
        script=true;
      }
    }
  }
  String varName=null;
  Enumeration enu=a.getAttributeNames();
  while (enu.hasMoreElements()) {
    Object attrObj=enu.nextElement();
    String attr=attrObj.toString();
    String value=a.getAttribute(attrObj).toString();
    if (attr.equalsIgnoreCase(""String_Node_Str"")) {
      varName=value;
      break;
    }
  }
  if (varName == null) {
    varName=""String_Node_Str"" + (counter++);
  }
  String cons=constructors.get(tag);
  if (cons == null)   cons=""String_Node_Str"";
  try {
    writeElement(t,a,tag,cons,varName);
    domTreeFile.write(""String_Node_Str"");
  }
 catch (  IOException e) {
    System.out.println(""String_Node_Str"");
    System.exit(1);
  }
  return varName;
}","protected String createElement(HTML.Tag t,MutableAttributeSet a,int pos){
  String tag=t.toString().toUpperCase();
  if (tag.equals(""String_Node_Str"")) {
    Object l=a.getAttribute(HTML.Attribute.LANGUAGE);
    if (l == null || l.toString().toUpperCase().indexOf(""String_Node_Str"") < 0) {
      Object value=a.getAttribute(HTML.Attribute.SRC);
      if (value != null) {
        try {
          URL scriptSrc=new URL(input,value.toString());
          InputStreamReader scriptReader=new InputStreamReader(scriptSrc.openConnection().getInputStream());
          int read;
          char[] buffer=new char[1024];
          while ((read=scriptReader.read(buffer)) != -1) {
            writeEmbeddedScript(buffer,read);
          }
          embeddedScriptFile.flush();
          scriptReader.close();
        }
 catch (        IOException e) {
          System.out.println(""String_Node_Str"" + value);
        }
      }
 else {
        System.out.println(""String_Node_Str"");
        script=true;
        scriptStart=pos;
      }
    }
  }
  String varName=null;
  Enumeration enu=a.getAttributeNames();
  while (enu.hasMoreElements()) {
    Object attrObj=enu.nextElement();
    String attr=attrObj.toString();
    String value=a.getAttribute(attrObj).toString();
    if (attr.equalsIgnoreCase(""String_Node_Str"")) {
      varName=value;
      break;
    }
  }
  if (varName == null) {
    varName=""String_Node_Str"" + (counter++);
  }
  String cons=constructors.get(tag);
  if (cons == null)   cons=""String_Node_Str"";
  try {
    writeElement(t,a,tag,cons,varName);
    domTreeFile.write(""String_Node_Str"");
  }
 catch (  IOException e) {
    System.out.println(""String_Node_Str"");
    System.exit(1);
  }
  return varName;
}",0.9903197418597828
38418,"public void handleEndTag(HTML.Tag t,int pos){
  if (t.toString().toUpperCase().equals(""String_Node_Str"")) {
    System.out.println(""String_Node_Str"");
    try {
      writeEmbeddedScript(""String_Node_Str"");
    }
 catch (    IOException e) {
    }
    script=false;
  }
  endElement(stack.pop());
}","public void handleEndTag(HTML.Tag t,int pos){
  if (t.toString().toUpperCase().equals(""String_Node_Str"")) {
    System.out.println(""String_Node_Str"");
    if (script)     try {
      int scriptEnd=pos;
      InputStreamReader script=new InputStreamReader(input.openStream());
      char[] buf=new char[scriptEnd];
      script.read(buf);
      String s=String.valueOf(buf,scriptStart,scriptEnd - scriptStart);
      writeEmbeddedScript(s.substring(s.indexOf('>') + 1));
    }
 catch (    IOException e) {
    }
    script=false;
  }
  endElement(stack.pop());
}",0.6542491268917345
38419,"private void writeEmbeddedScript(String text) throws IOException {
  embeddedScriptFile.write(text);
  embeddedScriptFile.write(""String_Node_Str"");
}","private void writeEmbeddedScript(String text) throws IOException {
  embeddedScriptFile.write(text);
}",0.8127490039840638
38420,"public void handleStartTag(HTML.Tag t,MutableAttributeSet a,int pos){
  String varName=createElement(t,a);
  stack.push(varName);
}","public void handleStartTag(HTML.Tag t,MutableAttributeSet a,int pos){
  String varName=createElement(t,a,pos);
  stack.push(varName);
}",0.9849624060150376
38421,"public HTMLEditorKit.ParserCallback createCallback(URL input,FileWriter domTreeFile,FileWriter embeddedScriptFile,FileWriter entrypointFile){
  return new HTMLCallback(input,domTreeFile,embeddedScriptFile,entrypointFile);
}","public HTMLCallback createCallback(URL input,FileWriter domTreeFile,FileWriter embeddedScriptFile,FileWriter entrypointFile){
  return new HTMLCallback(input,domTreeFile,embeddedScriptFile,entrypointFile);
}",0.9627906976744186
38422,"public void generate(URL input,File outFile) throws IOException {
  InputStreamReader fr=getStream(input);
  FileWriter out=new FileWriter(outFile);
  FileWriter out1=new FileWriter(temp1);
  FileWriter out2=new FileWriter(temp2);
  FileWriter out3=new FileWriter(temp3);
  ParserDelegator pd=new ParserDelegator();
  HTMLEditorKit.ParserCallback cb=callbackFactory.createCallback(input,out1,out2,out3);
  pd.parse(fr,cb,ignoreCharset);
  out1.close();
  out2.close();
  out3.close();
  out.write(""String_Node_Str"" + input + ""String_Node_Str"");
  writeRegion(out,""String_Node_Str"",temp2);
  writeRegion(out,""String_Node_Str"",temp1);
  out.write(""String_Node_Str"");
  writeRegion(out,""String_Node_Str"",temp3);
  out.write(""String_Node_Str"");
  generateTrailer(out,cb);
  out.close();
}","public void generate(URL input,File outFile) throws IOException {
  InputStreamReader fr=getStream(input);
  FileWriter out=new FileWriter(outFile);
  FileWriter out1=new FileWriter(temp1);
  FileWriter out2=new FileWriter(temp2);
  FileWriter out3=new FileWriter(temp3);
  ParserDelegator pd=new ParserDelegator();
  HTMLCallback cb=callbackFactory.createCallback(input,out1,out2,out3);
  pd.parse(fr,cb,ignoreCharset);
  out1.flush();
  out1.close();
  out2.flush();
  out2.close();
  out3.flush();
  out3.close();
  out.write(""String_Node_Str"" + input + ""String_Node_Str"");
  writeRegion(out,""String_Node_Str"",temp2);
  writeRegion(out,""String_Node_Str"",temp1);
  out.write(""String_Node_Str"");
  writeRegion(out,""String_Node_Str"",temp3);
  out.write(""String_Node_Str"");
  generateTrailer(out,cb);
  out.close();
}",0.96
38423,"protected String createElement(HTML.Tag t,MutableAttributeSet a){
  String tag=t.toString().toUpperCase();
  if (tag.equals(""String_Node_Str"")) {
    Object l=a.getAttribute(HTML.Attribute.LANGUAGE);
    if (l == null || l.toString().toUpperCase().indexOf(""String_Node_Str"") < 0) {
      Object value=a.getAttribute(HTML.Attribute.SRC);
      if (value != null) {
        try {
          URL scriptSrc=new URL(input,value.toString());
          InputStreamReader scriptReader=new InputStreamReader(scriptSrc.openConnection().getInputStream());
          int read;
          char[] buffer=new char[1024];
          while ((read=scriptReader.read(buffer)) != -1) {
            writeEmbeddedScript(buffer);
            writeEmbeddedScript(""String_Node_Str"");
          }
          scriptReader.close();
        }
 catch (        IOException e) {
          System.out.println(""String_Node_Str"" + value);
        }
      }
 else {
        System.out.println(""String_Node_Str"");
        script=true;
      }
    }
  }
  String varName=null;
  Enumeration enu=a.getAttributeNames();
  while (enu.hasMoreElements()) {
    Object attrObj=enu.nextElement();
    String attr=attrObj.toString();
    String value=a.getAttribute(attrObj).toString();
    if (attr.equalsIgnoreCase(""String_Node_Str"")) {
      varName=value;
      break;
    }
  }
  if (varName == null) {
    varName=""String_Node_Str"" + (counter++);
  }
  String cons=constructors.get(tag);
  if (cons == null)   cons=""String_Node_Str"";
  try {
    writeElement(t,a,tag,cons,varName);
    domTreeFile.write(""String_Node_Str"");
  }
 catch (  IOException e) {
    System.out.println(""String_Node_Str"");
    System.exit(1);
  }
  return varName;
}","protected String createElement(HTML.Tag t,MutableAttributeSet a){
  String tag=t.toString().toUpperCase();
  if (tag.equals(""String_Node_Str"")) {
    Object l=a.getAttribute(HTML.Attribute.LANGUAGE);
    if (l == null || l.toString().toUpperCase().indexOf(""String_Node_Str"") < 0) {
      Object value=a.getAttribute(HTML.Attribute.SRC);
      if (value != null) {
        try {
          URL scriptSrc=new URL(input,value.toString());
          InputStreamReader scriptReader=new InputStreamReader(scriptSrc.openConnection().getInputStream());
          int read;
          char[] buffer=new char[1024];
          while ((read=scriptReader.read(buffer)) != -1) {
            writeEmbeddedScript(buffer,read);
          }
          embeddedScriptFile.flush();
          scriptReader.close();
        }
 catch (        IOException e) {
          System.out.println(""String_Node_Str"" + value);
        }
      }
 else {
        System.out.println(""String_Node_Str"");
        script=true;
      }
    }
  }
  String varName=null;
  Enumeration enu=a.getAttributeNames();
  while (enu.hasMoreElements()) {
    Object attrObj=enu.nextElement();
    String attr=attrObj.toString();
    String value=a.getAttribute(attrObj).toString();
    if (attr.equalsIgnoreCase(""String_Node_Str"")) {
      varName=value;
      break;
    }
  }
  if (varName == null) {
    varName=""String_Node_Str"" + (counter++);
  }
  String cons=constructors.get(tag);
  if (cons == null)   cons=""String_Node_Str"";
  try {
    writeElement(t,a,tag,cons,varName);
    domTreeFile.write(""String_Node_Str"");
  }
 catch (  IOException e) {
    System.out.println(""String_Node_Str"");
    System.exit(1);
  }
  return varName;
}",0.9719350073855244
38424,"private void getScript(char[] data){
  if (script) {
    try {
      writeEmbeddedScript(data);
    }
 catch (    IOException e) {
      System.out.println(""String_Node_Str"");
    }
  }
}","private void getScript(char[] data){
  if (script) {
    try {
      writeEmbeddedScript(data,data.length);
    }
 catch (    IOException e) {
      System.out.println(""String_Node_Str"");
    }
  }
}",0.9689119170984456
38425,"/** 
 * Figure out what a classpath entry means and add it to the appropriate set of modules
 */
private void resolveClasspathEntry(IClasspathEntry entry,Loader loader,boolean includeSource,boolean cpeFromMainProject) throws JavaModelException, IOException {
  IClasspathEntry e=JavaCore.getResolvedClasspathEntry(entry);
  if (alreadyResolved.contains(e)) {
    return;
  }
 else {
    alreadyResolved.add(e);
  }
  if (e.getEntryKind() == IClasspathEntry.CPE_CONTAINER) {
    IClasspathContainer cont=JavaCore.getClasspathContainer(entry.getPath(),project);
    IClasspathEntry[] entries=cont.getClasspathEntries();
    resolveClasspathEntries(entries,cont.getKind() == IClasspathContainer.K_APPLICATION ? loader : Loader.PRIMORDIAL,includeSource,false);
  }
 else   if (e.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {
    File file=makeAbsolute(e.getPath()).toFile();
    JarFile j;
    try {
      j=new JarFile(file);
    }
 catch (    ZipException z) {
      return;
    }
catch (    FileNotFoundException z) {
      return;
    }
    if (isPrimordialJarFile(j)) {
      List<Module> s=MapUtil.findOrCreateList(modules,loader);
      s.add(file.isDirectory() ? (Module)new BinaryDirectoryTreeModule(file) : (Module)new JarFileModule(j));
    }
  }
 else   if (e.getEntryKind() == IClasspathEntry.CPE_SOURCE) {
    if (includeSource) {
      List<Module> s=MapUtil.findOrCreateList(modules,Loader.APPLICATION);
      s.add(new EclipseSourceDirectoryTreeModule(e.getPath()));
    }
 else     if (e.getOutputLocation() != null) {
      File output=makeAbsolute(e.getOutputLocation()).toFile();
      List<Module> s=MapUtil.findOrCreateList(modules,cpeFromMainProject ? Loader.APPLICATION : loader);
      s.add(new BinaryDirectoryTreeModule(output));
    }
  }
 else   if (e.getEntryKind() == IClasspathEntry.CPE_PROJECT) {
    IPath projectPath=makeAbsolute(e.getPath());
    IWorkspace ws=ResourcesPlugin.getWorkspace();
    IWorkspaceRoot root=ws.getRoot();
    IProject project=(IProject)root.getContainerForLocation(projectPath);
    try {
      if (project.hasNature(JavaCore.NATURE_ID)) {
        IJavaProject javaProject=JavaCore.create(project);
        if (isPluginProject(javaProject)) {
          resolvePluginClassPath(javaProject.getProject(),includeSource);
        }
        resolveClasspathEntries(javaProject.getRawClasspath(),loader,scopeType == AnalysisScopeType.SOURCE_FOR_PROJ_AND_LINKED_PROJS ? includeSource : false,false);
        File output=makeAbsolute(javaProject.getOutputLocation()).toFile();
        List<Module> s=MapUtil.findOrCreateList(modules,loader);
        if (!includeSource) {
          s.add(new BinaryDirectoryTreeModule(output));
        }
      }
    }
 catch (    CoreException e1) {
      e1.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + e);
  }
}","/** 
 * Figure out what a classpath entry means and add it to the appropriate set of modules
 */
private void resolveClasspathEntry(IClasspathEntry entry,Loader loader,boolean includeSource,boolean cpeFromMainProject) throws JavaModelException, IOException {
  IClasspathEntry e=JavaCore.getResolvedClasspathEntry(entry);
  if (alreadyResolved.contains(e)) {
    return;
  }
 else {
    alreadyResolved.add(e);
  }
  if (e.getEntryKind() == IClasspathEntry.CPE_CONTAINER) {
    IClasspathContainer cont=JavaCore.getClasspathContainer(entry.getPath(),project);
    IClasspathEntry[] entries=cont.getClasspathEntries();
    resolveClasspathEntries(entries,cont.getKind() == IClasspathContainer.K_APPLICATION ? loader : Loader.PRIMORDIAL,includeSource,false);
  }
 else   if (e.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {
    File file=makeAbsolute(e.getPath()).toFile();
    JarFile j;
    try {
      j=new JarFile(file);
    }
 catch (    ZipException z) {
      return;
    }
catch (    FileNotFoundException z) {
      return;
    }
    if (isPrimordialJarFile(j)) {
      List<Module> s=MapUtil.findOrCreateList(modules,loader);
      s.add(file.isDirectory() ? (Module)new BinaryDirectoryTreeModule(file) : (Module)new JarFileModule(j));
    }
  }
 else   if (e.getEntryKind() == IClasspathEntry.CPE_SOURCE) {
    if (includeSource) {
      List<Module> s=MapUtil.findOrCreateList(modules,Loader.APPLICATION);
      s.add(new EclipseSourceDirectoryTreeModule(e.getPath()));
    }
 else     if (e.getOutputLocation() != null) {
      File output=makeAbsolute(e.getOutputLocation()).toFile();
      List<Module> s=MapUtil.findOrCreateList(modules,cpeFromMainProject ? Loader.APPLICATION : loader);
      s.add(new BinaryDirectoryTreeModule(output));
    }
  }
 else   if (e.getEntryKind() == IClasspathEntry.CPE_PROJECT) {
    IPath projectPath=makeAbsolute(e.getPath());
    IWorkspace ws=ResourcesPlugin.getWorkspace();
    IWorkspaceRoot root=ws.getRoot();
    IProject project=(IProject)root.getContainerForLocation(projectPath);
    try {
      if (project.hasNature(JavaCore.NATURE_ID)) {
        IJavaProject javaProject=JavaCore.create(project);
        if (isPluginProject(javaProject)) {
          resolvePluginClassPath(javaProject.getProject(),includeSource);
        }
        resolveClasspathEntries(javaProject.getRawClasspath(),loader,scopeType == AnalysisScopeType.SOURCE_FOR_PROJ_AND_LINKED_PROJS ? includeSource : false,false);
        File output=makeAbsolute(javaProject.getOutputLocation()).toFile();
        List<Module> s=MapUtil.findOrCreateList(modules,loader);
        if (!includeSource) {
          if (output.exists()) {
            s.add(new BinaryDirectoryTreeModule(output));
          }
        }
      }
    }
 catch (    CoreException e1) {
      e1.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + e);
  }
}",0.9918923581162672
38426,"public boolean isExit(Statement n){
switch (n.getKind()) {
case PARAM_CALLEE:
case HEAP_PARAM_CALLEE:
case PHI:
case PI:
case NORMAL_RET_CALLER:
case PARAM_CALLER:
case HEAP_RET_CALLER:
case NORMAL:
case EXC_RET_CALLER:
case METHOD_ENTRY:
case CATCH:
    return false;
case HEAP_RET_CALLEE:
case EXC_RET_CALLEE:
case NORMAL_RET_CALLEE:
case METHOD_EXIT:
  return true;
default :
Assertions.UNREACHABLE(n.toString());
return false;
}
}","public boolean isExit(Statement n){
switch (n.getKind()) {
case PARAM_CALLEE:
case HEAP_PARAM_CALLEE:
case HEAP_PARAM_CALLER:
case PHI:
case PI:
case NORMAL_RET_CALLER:
case PARAM_CALLER:
case HEAP_RET_CALLER:
case NORMAL:
case EXC_RET_CALLER:
case METHOD_ENTRY:
case CATCH:
    return false;
case HEAP_RET_CALLEE:
case EXC_RET_CALLEE:
case NORMAL_RET_CALLEE:
case METHOD_EXIT:
  return true;
default :
Assertions.UNREACHABLE(n.toString());
return false;
}
}",0.9730941704035876
38427,"public static CGNode findMainMethod(CallGraph cg){
  Descriptor d=Descriptor.findOrCreateUTF8(""String_Node_Str"");
  Atom name=Atom.findOrCreateUnicodeAtom(""String_Node_Str"");
  for (Iterator<? extends CGNode> it=cg.getSuccNodes(cg.getFakeRootNode()); it.hasNext(); ) {
    CGNode n=it.next();
    if (n.getMethod().getName().equals(name) && n.getMethod().getDescriptor().equals(d)) {
      return n;
    }
  }
  Assertions.UNREACHABLE(""String_Node_Str"");
  return null;
}","public static CGNode findMainMethod(CallGraph cg){
  Descriptor d=Descriptor.findOrCreateUTF8(""String_Node_Str"");
  Atom name=Atom.findOrCreateUnicodeAtom(""String_Node_Str"");
  return findMethod(cg,d,name);
}",0.5331369661266568
38428,"/** 
 * Create nodes corresponding to <ul> <li> phi instructions <li> getCaughtExceptions </ul>
 */
private void createSpecialStatements(IR ir){
  for (Iterator<SSAInstruction> it=ir.iterateAllInstructions(); it.hasNext(); ) {
    SSAInstruction s=it.next();
    if (s instanceof SSAPhiInstruction) {
      delegate.addNode(new PhiStatement(node,(SSAPhiInstruction)s));
    }
 else     if (s instanceof SSAGetCaughtExceptionInstruction) {
      delegate.addNode(new GetCaughtExceptionStatement(node,(SSAGetCaughtExceptionInstruction)s));
    }
 else     if (s instanceof SSAPiInstruction) {
      delegate.addNode(new PiStatement(node,(SSAPiInstruction)s));
    }
  }
}","/** 
 * Create nodes corresponding to <ul> <li>phi instructions <li>getCaughtExceptions </ul>
 */
private void createSpecialStatements(IR ir){
  for (Iterator<SSAInstruction> it=ir.iterateAllInstructions(); it.hasNext(); ) {
    SSAInstruction s=it.next();
    if (s instanceof SSAPhiInstruction) {
      delegate.addNode(new PhiStatement(node,(SSAPhiInstruction)s));
    }
 else     if (s instanceof SSAGetCaughtExceptionInstruction) {
      delegate.addNode(new GetCaughtExceptionStatement(node,(SSAGetCaughtExceptionInstruction)s));
    }
 else     if (s instanceof SSAPiInstruction) {
      delegate.addNode(new PiStatement(node,(SSAPiInstruction)s));
    }
  }
}",0.998502994011976
38429,"/** 
 * Create nodes in the graph corresponding to ""normal"" (bytecode) instructions
 */
private void createNormalStatements(IR ir,Map<CGNode,OrdinalSet<PointerKey>> ref){
  SSAInstruction[] instructions=ir.getInstructions();
  for (int i=0; i < instructions.length; i++) {
    SSAInstruction s=instructions[i];
    if (s instanceof SSAGetCaughtExceptionInstruction) {
      continue;
    }
    if (s != null) {
      delegate.addNode(new NormalStatement(node,i));
    }
    if (s instanceof SSAAbstractInvokeInstruction) {
      addParamPassingStatements(i,ref,ir);
    }
  }
}","/** 
 * Create nodes in the graph corresponding to ""normal"" (bytecode) instructions
 */
private void createNormalStatements(IR ir,Map<CGNode,OrdinalSet<PointerKey>> ref){
  SSAInstruction[] instructions=ir.getInstructions();
  for (int i=0; i < instructions.length; i++) {
    SSAInstruction s=instructions[i];
    if (s instanceof SSAGetCaughtExceptionInstruction) {
      continue;
    }
    if (s != null) {
      final NormalStatement statement=new NormalStatement(node,i);
      delegate.addNode(statement);
      if (s instanceof SSAAbstractInvokeInstruction) {
        callSite2Statement.put(((SSAAbstractInvokeInstruction)s).getCallSite(),statement);
        addParamPassingStatements(i,ref,ir);
      }
    }
  }
}",0.8323076923076923
38430,"public Iterator<? extends Statement> getCallSites(Statement r,PDG callee){
switch (r.getKind()) {
case EXC_RET_CALLER:
{
      ExceptionalReturnCaller n=(ExceptionalReturnCaller)r;
      SSAAbstractInvokeInstruction call=n.getInstruction();
      PDG pdg=getProcOf(r);
      return pdg.getCallerParamStatements(call).iterator();
    }
case NORMAL_RET_CALLER:
{
    NormalReturnCaller n=(NormalReturnCaller)r;
    SSAAbstractInvokeInstruction call=n.getInstruction();
    PDG pdg=getProcOf(r);
    return pdg.getCallerParamStatements(call).iterator();
  }
case HEAP_RET_CALLER:
{
  HeapStatement.HeapReturnCaller n=(HeapStatement.HeapReturnCaller)r;
  SSAAbstractInvokeInstruction call=n.getCall();
  PDG pdg=getProcOf(r);
  return pdg.getCallerParamStatements(call).iterator();
}
default :
Assertions.UNREACHABLE(r.getKind().toString());
return null;
}
}","public Iterator<? extends Statement> getCallSites(Statement r,PDG callee){
switch (r.getKind()) {
case EXC_RET_CALLER:
{
      ExceptionalReturnCaller n=(ExceptionalReturnCaller)r;
      SSAAbstractInvokeInstruction call=n.getInstruction();
      PDG pdg=getProcOf(r);
      return pdg.getCallStatements(call).iterator();
    }
case NORMAL_RET_CALLER:
{
    NormalReturnCaller n=(NormalReturnCaller)r;
    SSAAbstractInvokeInstruction call=n.getInstruction();
    PDG pdg=getProcOf(r);
    return pdg.getCallStatements(call).iterator();
  }
case HEAP_RET_CALLER:
{
  HeapStatement.HeapReturnCaller n=(HeapStatement.HeapReturnCaller)r;
  SSAAbstractInvokeInstruction call=n.getCall();
  PDG pdg=getProcOf(r);
  return pdg.getCallStatements(call).iterator();
}
default :
Assertions.UNREACHABLE(r.getKind().toString());
return null;
}
}",0.9875518672199172
38431,"/** 
 * create a demand points-to analysis runner using a   {@link DemandPointerFlowGraph} as the underlying flow graph.
 * @see #make(CallGraph,HeapModel,MemoryAccessMap,IClassHierarchy,AnalysisOptions,StateMachineFactory,IFlowGraph)
 */
public static DemandRefinementPointsTo makeWithDefaultFlowGraph(CallGraph cg,HeapModel model,MemoryAccessMap mam,IClassHierarchy cha,AnalysisOptions options,StateMachineFactory<IFlowLabel> stateMachineFactory){
  return make(cg,new ThisFilteringHeapModel(model,cha),mam,cha,options,stateMachineFactory,new DemandPointerFlowGraph(cg,model,mam,cha));
}","/** 
 * create a demand points-to analysis runner
 * @param cg the underlying call graph for the analysis
 * @param model the heap model to be used for the analysis
 * @param mam indicates what code reads or writes each field
 * @param cha
 * @param options
 * @param stateMachineFactory factory for state machines to track additional properties like calling context
 */
public static DemandRefinementPointsTo makeWithDefaultFlowGraph(CallGraph cg,HeapModel model,MemoryAccessMap mam,IClassHierarchy cha,AnalysisOptions options,StateMachineFactory<IFlowLabel> stateMachineFactory){
  final ThisFilteringHeapModel thisFilteringHeapModel=new ThisFilteringHeapModel(model,cha);
  return new DemandRefinementPointsTo(cg,thisFilteringHeapModel,mam,cha,options,stateMachineFactory,new DemandPointerFlowGraph(cg,thisFilteringHeapModel,mam,cha));
}",0.2729181245626312
38432,"@Test public void testFlowsToLocals() throws ClassHierarchyException, IllegalArgumentException, CancelException, IOException {
  doFlowsToSizeTest(TestInfo.FLOWSTO_TEST_LOCALS,1);
}","@Test public void testFlowsToLocals() throws ClassHierarchyException, IllegalArgumentException, CancelException, IOException {
  doFlowsToSizeTest(TestInfo.FLOWSTO_TEST_LOCALS,4);
}",0.994475138121547
38433,"/** 
 * get all the pointer keys that some instance key can flow to
 */
public Pair<PointsToResult,Collection<PointerKey>> getFlowsTo(InstanceKey ik){
}","/** 
 * get all the pointer keys that some instance key can flow to
 * @return a pair consisting of (1) a {@link PointsToResult} indicating whether a flows-to set was computed, and (2) the lastcomputed flows-to set for the instance key (possibly <code>null</code> if no flows-to set could be computed in the budget)
 */
public Pair<PointsToResult,Collection<PointerKey>> getFlowsTo(InstanceKey ik){
}",0.5507246376811594
38434,"/** 
 * returns the instance key corresponding to the single allocation site of type FlowsToType
 */
private static InstanceKey getFlowsToInstanceKey(CGNode mainMethod,HeapModel heapModel){
}","/** 
 * returns the instance key corresponding to the single allocation site of type FlowsToType
 */
private InstanceKey getFlowsToInstanceKey(CGNode mainMethod,HeapModel heapModel){
}",0.9813333333333332
38435,"private Collection<PointerKey> getFlowsToSetToTest(String mainClass) throws ClassHierarchyException, IllegalArgumentException, CancelException, IOException {
  final DemandRefinementPointsTo dmp=makeDemandPointerAnalysis(mainClass);
  CGNode mainMethod=AbstractPtrTest.findMainMethod(dmp.getBaseCallGraph());
  InstanceKey keyToQuery=AbstractPtrTest.getFlowsToInstanceKey(mainMethod,dmp.getHeapModel());
  Collection<PointerKey> flowsTo=dmp.getFlowsTo(keyToQuery).snd;
  return flowsTo;
}","private Collection<PointerKey> getFlowsToSetToTest(String mainClass) throws ClassHierarchyException, IllegalArgumentException, CancelException, IOException {
  final DemandRefinementPointsTo dmp=makeDemandPointerAnalysis(mainClass);
  CGNode mainMethod=AbstractPtrTest.findMainMethod(dmp.getBaseCallGraph());
  InstanceKey keyToQuery=getFlowsToInstanceKey(mainMethod,dmp.getHeapModel());
  Collection<PointerKey> flowsTo=dmp.getFlowsTo(keyToQuery).snd;
  return flowsTo;
}",0.9833333333333332
38436,"@Override protected void compute(){
  InstanceKey ik=queriedIkAndState.getInstanceKey();
  g.addSubgraphForNode(((InstanceKeyWithNode)ik).getNode());
  for (  Object pred : Iterator2Iterable.make(g.getPredNodes(ik,NewLabel.v()))) {
    PointerKey predPk=(PointerKey)pred;
    PointerKeyAndState predPkAndState=new PointerKeyAndState(predPk,queriedIkAndState.getState());
    theFlowsToSet.add(predPkAndState);
    findOrCreate(pkToP2Set,predPkAndState).add(queriedIkAndStateNum);
    addToPToWorklist(predPkAndState);
  }
  worklistLoop();
}","@Override protected void compute(){
  InstanceKey ik=queriedIkAndState.getInstanceKey();
  g.addSubgraphForNode(((InstanceKeyWithNode)ik).getNode());
  for (  Object pred : Iterator2Iterable.make(g.getPredNodes(ik,NewLabel.v()))) {
    PointerKey predPk=(PointerKey)pred;
    PointerKeyAndState predPkAndState=new PointerKeyAndState(predPk,queriedIkAndState.getState());
    theFlowsToSet.add(predPkAndState);
    findOrCreate(pkToTrackedSet,predPkAndState).add(queriedIkAndStateNum);
    addToTrackedPToWorklist(predPkAndState);
  }
  worklistLoop();
}",0.9835466179159048
38437,"/** 
 * here, we want to add the graph unconditionally if pkAndState can point to the queried instance key
 */
@Override protected boolean calleeSubGraphMissingAndShouldNotBeAdded(boolean addGraphs,CGNode callee,PointerKeyAndState pkAndState){
  if (find(pkToP2Set,pkAndState).contains(queriedIkAndStateNum)) {
    return false;
  }
 else {
    return super.calleeSubGraphMissingAndShouldNotBeAdded(addGraphs,callee,pkAndState);
  }
}","/** 
 * when doing backward interprocedural propagation, is it true that we should not add a graph representation for a callee _and_ that the subgraph for the callee is missing?
 * @param addGraphs whether graphs should always be added
 * @param callee
 * @param pkAndState
 * @return
 */
protected boolean calleeSubGraphMissingAndShouldNotBeAdded(boolean addGraphs,CGNode callee,PointerKeyAndState pkAndState){
  return !addGraphs && !g.hasSubgraphForNode(callee);
}",0.3596004439511653
38438,"@Override protected void handleBackCopy(PointerKeyAndState curPkAndState,PointerKey predPk,IFlowLabel label){
  final MutableIntSet curPkP2Set=find(pkToP2Set,curPkAndState);
  if (curPkP2Set.contains(queriedIkAndStateNum)) {
    PointerKeyAndState predPkAndState=new PointerKeyAndState(predPk,stateMachine.transition(curPkAndState.getState(),label));
    if (addAllToP2Set(pkToP2Set,predPkAndState,curPkP2Set,label)) {
      theFlowsToSet.add(predPkAndState);
      addToPToWorklist(predPkAndState);
    }
  }
 else {
    super.handleBackCopy(curPkAndState,predPk,label);
  }
}","protected void handleBackCopy(PointerKeyAndState curPkAndState,PointerKey predPk,IFlowLabel label){
  for (  PointerKeyAndState predPkAndState : matchingPToQueried(curPkAndState,predPk,label)) {
    if (addAllToP2Set(pkToP2Set,predPkAndState,find(pkToP2Set,curPkAndState),label)) {
      addToPToWorklist(predPkAndState);
    }
  }
}",0.2967032967032967
38439,"public JDTJava15IRTests(){
  super(""String_Node_Str"",""String_Node_Str"");
}","public JDTJava15IRTests(){
  super(""String_Node_Str"");
}",0.8615384615384616
38440,"public JDTJavaIRTests(){
  super(""String_Node_Str"",""String_Node_Str"");
}","public JDTJavaIRTests(){
  super(""String_Node_Str"");
}",0.8571428571428571
38441,"public PolyglotJavaIRTests(){
  super(""String_Node_Str"");
}","public PolyglotJavaIRTests(){
  super(null);
}",0.819047619047619
38442,"protected String singleJavaPkgInputForTest(String pkgName){
  return pkgName + File.separator + getName().substring(4)+ ""String_Node_Str"";
}","protected String singleJavaPkgInputForTest(String pkgName){
  return pkgName + File.separator + getTestName().substring(4)+ ""String_Node_Str"";
}",0.9859154929577464
38443,"protected String singleInputForTest(){
  return getName().substring(4);
}","protected String singleInputForTest(){
  return getTestName().substring(4);
}",0.9733333333333334
38444,"protected String singleJavaInputForTest(){
  return getName().substring(4) + ""String_Node_Str"";
}","protected String singleJavaInputForTest(){
  return getTestName().substring(4) + ""String_Node_Str"";
}",0.9797979797979798
38445,"public IRTests(String name,String projectName){
  this.name=name;
  this.projectName=projectName;
}","protected IRTests(String projectName){
  this.projectName=projectName;
}",0.7602339181286549
38446,"protected String[] simplePkgTestEntryPoint(String pkgName){
  return new String[]{""String_Node_Str"" + pkgName + ""String_Node_Str""+ getName().substring(4)};
}","protected String[] simplePkgTestEntryPoint(String pkgName){
  return new String[]{""String_Node_Str"" + pkgName + ""String_Node_Str""+ getTestName().substring(4)};
}",0.9874213836477987
38447,"protected String[] simpleTestEntryPoint(){
  return new String[]{""String_Node_Str"" + getName().substring(4)};
}","protected String[] simpleTestEntryPoint(){
  return new String[]{""String_Node_Str"" + getTestName().substring(4)};
}",0.9823008849557522
38448,"public JLexTest(String name){
  super(name,null);
}","public JLexTest(){
  super(null);
}",0.813953488372093
38449,"public JavaIRTests(String name){
  this(name,null);
}","public JavaIRTests(){
  this(null);
}",0.8222222222222222
38450,"public NameAwareTestClassRunner(Class<?> klass) throws InitializationError {
  super(klass);
}","public NameAwareTestClassRunner(Class<?> klass){
  super(klass);
}",0.825
38451,"public SyncDuplicatorTest(String name){
  super(name,null);
}","public SyncDuplicatorTest(){
  super(null);
}",0.8490566037735849
38452,"/** 
 * Does the file name represent a .java file?
 * @param fileName name of a file
 * @return boolean
 * @throws IllegalArgumentException  if fileName is null
 */
public static boolean isSourceFile(String fileName){
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int suffixIndex=fileName.indexOf(""String_Node_Str"");
  if (suffixIndex > -1 && fileName.indexOf(CLASSPATH) == -1) {
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Does the file name represent a .java file?
 * @param fileName name of a file
 * @return boolean
 * @throws IllegalArgumentException if fileName is null
 */
public static boolean isSourceFile(String fileName){
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return fileName.endsWith(""String_Node_Str"");
}",0.7990373044524669
38453,"/** 
 * Does the file name represent a .class file?
 * @param fileName name of a file
 * @return boolean
 * @throws IllegalArgumentException  if fileName is null
 */
public static boolean isClassFile(String fileName){
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int suffixIndex=fileName.indexOf(CLASS_SUFFIX);
  if (suffixIndex > -1 && fileName.indexOf(CLASSPATH) == -1) {
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Does the file name represent a .class file?
 * @param fileName name of a file
 * @return boolean
 * @throws IllegalArgumentException if fileName is null
 */
public static boolean isClassFile(String fileName){
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return fileName.endsWith(CLASS_SUFFIX);
}",0.7965895249695494
38454,"/** 
 * Strip the "".class"" or "".java"" suffix from a file name TODO: generalize for all suffixes
 * @param fileName the file name
 * @throws IllegalArgumentException  if fileName is null
 */
public static String stripSuffix(String fileName){
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int suffixIndex=fileName.indexOf(CLASS_SUFFIX);
  suffixIndex=(suffixIndex > -1) ? suffixIndex : fileName.indexOf(""String_Node_Str"");
  if (suffixIndex > -1) {
    return fileName.substring(0,suffixIndex);
  }
 else {
    return fileName;
  }
}","/** 
 * Strip the "".class"" or "".java"" suffix from a file name TODO: generalize for all suffixes
 * @param fileName the file name
 * @throws IllegalArgumentException if fileName is null
 */
public static String stripSuffix(String fileName){
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int suffixIndex=fileName.indexOf(CLASS_SUFFIX);
  suffixIndex=(suffixIndex > -1) ? suffixIndex : fileName.indexOf(""String_Node_Str"");
  if (suffixIndex > -1) {
    return fileName.substring(0,suffixIndex);
  }
 else {
    return fileName;
  }
}",0.9991311902693312
38455,"/** 
 * Does the file name represent a .jar file?
 * @param fileName name of a file
 * @return boolean
 * @throws IllegalArgumentException  if fileName is null
 */
public static boolean isJarFile(String fileName){
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int suffixIndex=fileName.indexOf(JAR_SUFFIX);
  if (suffixIndex > -1) {
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Does the file name represent a .jar file?
 * @param fileName name of a file
 * @return boolean
 * @throws IllegalArgumentException if fileName is null
 */
public static boolean isJarFile(String fileName){
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return fileName.endsWith(JAR_SUFFIX);
}",0.8316062176165803
38456,"/** 
 * Does the file name represent a .war file?
 * @param fileName name of a file
 * @return boolean
 * @throws IllegalArgumentException  if fileName is null
 */
public static boolean isWarFile(String fileName){
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int suffixIndex=fileName.indexOf(WAR_SUFFIX);
  if (suffixIndex > -1) {
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Does the file name represent a .war file?
 * @param fileName name of a file
 * @return boolean
 * @throws IllegalArgumentException if fileName is null
 */
public static boolean isWarFile(String fileName){
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return fileName.endsWith(WAR_SUFFIX);
}",0.8316062176165803
38457,"private DeclaredTypeOperator getPointerTypeOperator(TypeReference type){
  if (type.isPrimitiveType()) {
    return new DeclaredTypeOperator(PrimitiveType.getPrimitive(type));
  }
 else {
    IClass klass=cha.lookupClass(type);
    if (klass == null) {
      return new DeclaredTypeOperator(BOTTOM);
    }
 else {
      return new DeclaredTypeOperator(new ConeType(klass));
    }
  }
}","private DeclaredTypeOperator getPointerTypeOperator(TypeReference type){
  if (type.isPrimitiveType()) {
    return new DeclaredTypeOperator(language.getPrimitive(type));
  }
 else {
    IClass klass=cha.lookupClass(type);
    if (klass == null) {
      return new DeclaredTypeOperator(BOTTOM);
    }
 else {
      return new DeclaredTypeOperator(new ConeType(klass));
    }
  }
}",0.9751633986928104
38458,"@Override public void visitInvoke(SSAInvokeInstruction instruction){
  TypeReference type=instruction.getDeclaredResultType();
  if (type.isReferenceType()) {
    IClass klass=cha.lookupClass(type);
    if (klass == null) {
      result=new DeclaredTypeOperator(BOTTOM);
    }
 else {
      result=new DeclaredTypeOperator(new ConeType(klass));
    }
  }
 else   if (doPrimitives && type.isPrimitiveType()) {
    result=new DeclaredTypeOperator(PrimitiveType.getPrimitive(type));
  }
 else {
    result=null;
  }
}","@Override public void visitInvoke(SSAInvokeInstruction instruction){
  TypeReference type=instruction.getDeclaredResultType();
  if (type.isReferenceType()) {
    IClass klass=cha.lookupClass(type);
    if (klass == null) {
      result=new DeclaredTypeOperator(BOTTOM);
    }
 else {
      result=new DeclaredTypeOperator(new ConeType(klass));
    }
  }
 else   if (doPrimitives && type.isPrimitiveType()) {
    result=new DeclaredTypeOperator(language.getPrimitive(type));
  }
 else {
    result=null;
  }
}",0.981427174975562
38459,"@Override protected void initializeVariables(){
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + ir.getMethod());
  }
  int[] parameterValueNumbers=ir.getParameterValueNumbers();
  for (int i=0; i < parameterValueNumbers.length; i++) {
    TypeVariable v=getVariable(parameterValueNumbers[i]);
    TypeReference t=ir.getParameterType(i);
    if (DEBUG) {
      System.err.println(""String_Node_Str"" + parameterValueNumbers[i] + ""String_Node_Str""+ t);
    }
    if (t.isReferenceType()) {
      IClass klass=cha.lookupClass(t);
      if (DEBUG) {
        System.err.println(""String_Node_Str"" + klass);
      }
      if (klass != null) {
        v.setType(new ConeType(klass));
      }
 else {
        v.setType(BOTTOM);
      }
    }
 else     if (doPrimitives) {
      v.setType(PrimitiveType.getPrimitive(t));
    }
  }
  SymbolTable st=ir.getSymbolTable();
  if (st != null) {
    for (int i=0; i <= st.getMaxValueNumber(); i++) {
      if (st.isConstant(i)) {
        TypeVariable v=getVariable(i);
        v.setType(getConstantType(i));
      }
    }
  }
  for (Iterator<SSAInstruction> it=ir.iterateNormalInstructions(); it.hasNext(); ) {
    SSAInstruction s=it.next();
    if (s instanceof SSAAbstractInvokeInstruction) {
      SSAAbstractInvokeInstruction call=(SSAAbstractInvokeInstruction)s;
      TypeVariable v=getVariable(call.getException());
      Collection<TypeReference> defaultExceptions=call.getExceptionTypes();
      if (defaultExceptions.size() == 0) {
        continue;
      }
      Iterator<TypeReference> types=defaultExceptions.iterator();
      TypeReference t=types.next();
      IClass klass=cha.lookupClass(t);
      if (klass == null) {
        v.setType(BOTTOM);
      }
 else {
        v.setType(new PointType(klass));
      }
      while (types.hasNext()) {
        t=types.next();
        klass=cha.lookupClass(t);
        if (klass != null) {
          v.setType(v.getType().meet(new PointType(klass)));
        }
      }
      IMethod m=cha.resolveMethod(call.getDeclaredTarget());
      if (m != null) {
        TypeReference[] x=null;
        try {
          x=m.getDeclaredExceptions();
        }
 catch (        InvalidClassFileException e) {
          e.printStackTrace();
          Assertions.UNREACHABLE();
        }
catch (        UnsupportedOperationException e) {
          x=new TypeReference[]{language.getThrowableType()};
        }
        if (x != null) {
          for (int i=0; i < x.length; i++) {
            TypeReference tx=x[i];
            IClass tc=cha.lookupClass(tx);
            if (tc != null) {
              v.setType(v.getType().meet(new ConeType(tc)));
            }
          }
        }
      }
    }
  }
}","@Override protected void initializeVariables(){
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + ir.getMethod());
  }
  int[] parameterValueNumbers=ir.getParameterValueNumbers();
  for (int i=0; i < parameterValueNumbers.length; i++) {
    TypeVariable v=getVariable(parameterValueNumbers[i]);
    TypeReference t=ir.getParameterType(i);
    if (DEBUG) {
      System.err.println(""String_Node_Str"" + parameterValueNumbers[i] + ""String_Node_Str""+ t);
    }
    if (t.isReferenceType()) {
      IClass klass=cha.lookupClass(t);
      if (DEBUG) {
        System.err.println(""String_Node_Str"" + klass);
      }
      if (klass != null) {
        v.setType(new ConeType(klass));
      }
 else {
        v.setType(BOTTOM);
      }
    }
 else     if (doPrimitives) {
      v.setType(language.getPrimitive(t));
    }
  }
  SymbolTable st=ir.getSymbolTable();
  if (st != null) {
    for (int i=0; i <= st.getMaxValueNumber(); i++) {
      if (st.isConstant(i)) {
        TypeVariable v=getVariable(i);
        v.setType(getConstantType(i));
      }
    }
  }
  for (Iterator<SSAInstruction> it=ir.iterateNormalInstructions(); it.hasNext(); ) {
    SSAInstruction s=it.next();
    if (s instanceof SSAAbstractInvokeInstruction) {
      SSAAbstractInvokeInstruction call=(SSAAbstractInvokeInstruction)s;
      TypeVariable v=getVariable(call.getException());
      Collection<TypeReference> defaultExceptions=call.getExceptionTypes();
      if (defaultExceptions.size() == 0) {
        continue;
      }
      Iterator<TypeReference> types=defaultExceptions.iterator();
      TypeReference t=types.next();
      IClass klass=cha.lookupClass(t);
      if (klass == null) {
        v.setType(BOTTOM);
      }
 else {
        v.setType(new PointType(klass));
      }
      while (types.hasNext()) {
        t=types.next();
        klass=cha.lookupClass(t);
        if (klass != null) {
          v.setType(v.getType().meet(new PointType(klass)));
        }
      }
      IMethod m=cha.resolveMethod(call.getDeclaredTarget());
      if (m != null) {
        TypeReference[] x=null;
        try {
          x=m.getDeclaredExceptions();
        }
 catch (        InvalidClassFileException e) {
          e.printStackTrace();
          Assertions.UNREACHABLE();
        }
catch (        UnsupportedOperationException e) {
          x=new TypeReference[]{language.getThrowableType()};
        }
        if (x != null) {
          for (int i=0; i < x.length; i++) {
            TypeReference tx=x[i];
            IClass tc=cha.lookupClass(tx);
            if (tc != null) {
              v.setType(v.getType().meet(new ConeType(tc)));
            }
          }
        }
      }
    }
  }
}",0.9964611659526914
38460,"@Override public void visitGet(SSAGetInstruction instruction){
  TypeReference type=instruction.getDeclaredFieldType();
  if (doPrimitives && type.isPrimitiveType()) {
    result=new DeclaredTypeOperator(PrimitiveType.getPrimitive(type));
  }
 else {
    IClass klass=cha.lookupClass(type);
    if (klass == null) {
      result=new DeclaredTypeOperator(BOTTOM);
    }
 else {
      result=new DeclaredTypeOperator(new ConeType(klass));
    }
  }
}","@Override public void visitGet(SSAGetInstruction instruction){
  TypeReference type=instruction.getDeclaredFieldType();
  if (doPrimitives && type.isPrimitiveType()) {
    result=new DeclaredTypeOperator(language.getPrimitive(type));
  }
 else {
    IClass klass=cha.lookupClass(type);
    if (klass == null) {
      result=new DeclaredTypeOperator(BOTTOM);
    }
 else {
      result=new DeclaredTypeOperator(new ConeType(klass));
    }
  }
}",0.978675645342312
38461,"/** 
 * traverse the bundle description for an Eclipse project and populate the analysis scope accordingly
 */
private void resolvePluginClassPath(IProject p,boolean includeSource) throws CoreException, IOException {
  BundleDescription bd=findModel(p).getBundleDescription();
  for (int i=0; i < 3 && bd == null; i++) {
    try {
      Thread.sleep(5000);
    }
 catch (    InterruptedException e) {
    }
    bd=findModel(p).getBundleDescription();
  }
  if (bd == null) {
    throw new IllegalStateException(""String_Node_Str"" + p);
  }
  resolveBundleDescriptionClassPath(bd,Loader.APPLICATION,includeSource);
}","/** 
 * traverse the bundle description for an Eclipse project and populate the analysis scope accordingly
 */
private void resolvePluginClassPath(IProject p,boolean includeSource) throws CoreException, IOException {
  IPluginModelBase model=findModel(p);
  if (!model.isInSync() || model.isDisposed()) {
    model.load();
  }
  BundleDescription bd=model.getBundleDescription();
  for (int i=0; i < 3 && bd == null; i++) {
    try {
      Thread.sleep(5000);
    }
 catch (    InterruptedException e) {
    }
    bd=findModel(p).getBundleDescription();
  }
  if (bd == null) {
    throw new IllegalStateException(""String_Node_Str"" + p);
  }
  resolveBundleDescriptionClassPath(bd,Loader.APPLICATION,includeSource);
}",0.8940646130728775
38462,"/** 
 * Add any exceptional edges generated by the last instruction in a basic block.
 * @param last the last instruction in a basic block.
 */
protected void addExceptionalEdges(IInstruction last){
  IClassHierarchy cha=getMethod().getClassHierarchy();
  if (last.isPEI()) {
    Collection<TypeReference> exceptionTypes=null;
    boolean goToAllHandlers=false;
    ExceptionHandler[] hs=getExceptionHandlers();
    if (last instanceof ThrowInstruction) {
      goToAllHandlers=true;
    }
 else {
      if (hs != null && hs.length > 0) {
        IClassLoader loader=getMethod().getDeclaringClass().getClassLoader();
        BytecodeLanguage l=(BytecodeLanguage)loader.getLanguage();
        exceptionTypes=l.getImplicitExceptionTypes(last);
        if (last instanceof IInvokeInstruction) {
          IInvokeInstruction call=(IInvokeInstruction)last;
          exceptionTypes=HashSetFactory.make(exceptionTypes);
          MethodReference target=MethodReference.findOrCreate(l,loader.getReference(),call.getClassType(),call.getMethodName(),call.getMethodSignature());
          try {
            exceptionTypes.addAll(l.inferInvokeExceptions(target,cha));
          }
 catch (          InvalidClassFileException e) {
            e.printStackTrace();
            Assertions.UNREACHABLE();
          }
        }
      }
    }
    if (hs != null && hs.length > 0) {
      if (!goToAllHandlers) {
        exceptionTypes=HashSetFactory.make(exceptionTypes);
      }
      for (int j=0; j < hs.length; j++) {
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + hs[j]);
        }
        BasicBlock b=getBlockForInstruction(hs[j].getHandler());
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + b);
        }
        if (goToAllHandlers) {
          addExceptionalEdgeTo(b);
        }
 else {
          TypeReference caughtException=null;
          if (hs[j].getCatchClass() != null) {
            ClassLoaderReference loader=ShrikeCFG.this.getMethod().getDeclaringClass().getReference().getClassLoader();
            caughtException=ShrikeUtil.makeTypeReference(loader,hs[j].getCatchClass());
            if (DEBUG) {
              System.err.println(""String_Node_Str"" + caughtException);
            }
            IClass caughtClass=cha.lookupClass(caughtException);
            if (caughtClass == null) {
              addExceptionalEdgeTo(b);
              Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
              caughtException=null;
            }
          }
 else {
            addExceptionalEdgeTo(b);
            exceptionTypes.clear();
            caughtException=null;
          }
          if (caughtException != null) {
            IClass caughtClass=cha.lookupClass(caughtException);
            ArrayList<TypeReference> caught=new ArrayList<TypeReference>(exceptionTypes.size());
            for (            TypeReference t : exceptionTypes) {
              if (t != null) {
                IClass klass=cha.lookupClass(t);
                if (klass == null) {
                  Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
                  addExceptionalEdgeTo(b);
                }
 else {
                  boolean subtype1=cha.isSubclassOf(klass,caughtClass);
                  if (subtype1 || cha.isSubclassOf(caughtClass,klass)) {
                    addExceptionalEdgeTo(b);
                    if (subtype1) {
                      caught.add(t);
                    }
                  }
                }
              }
            }
            exceptionTypes.removeAll(caught);
          }
        }
      }
      if (exceptionTypes == null || !exceptionTypes.isEmpty()) {
        BasicBlock exit=exit();
        addExceptionalEdgeTo(exit);
      }
    }
 else {
      BasicBlock exit=exit();
      addExceptionalEdgeTo(exit);
    }
  }
}","/** 
 * Add any exceptional edges generated by the last instruction in a basic block.
 * @param last the last instruction in a basic block.
 */
protected void addExceptionalEdges(IInstruction last){
  IClassHierarchy cha=getMethod().getClassHierarchy();
  if (last.isPEI()) {
    Collection<TypeReference> exceptionTypes=null;
    boolean goToAllHandlers=false;
    ExceptionHandler[] hs=getExceptionHandlers();
    if (last instanceof ThrowInstruction) {
      goToAllHandlers=true;
    }
 else {
      if (hs != null && hs.length > 0) {
        IClassLoader loader=getMethod().getDeclaringClass().getClassLoader();
        BytecodeLanguage l=(BytecodeLanguage)loader.getLanguage();
        exceptionTypes=l.getImplicitExceptionTypes(last);
        if (last instanceof IInvokeInstruction) {
          IInvokeInstruction call=(IInvokeInstruction)last;
          exceptionTypes=HashSetFactory.make(exceptionTypes);
          MethodReference target=MethodReference.findOrCreate(l,loader.getReference(),call.getClassType(),call.getMethodName(),call.getMethodSignature());
          try {
            exceptionTypes.addAll(l.inferInvokeExceptions(target,cha));
          }
 catch (          InvalidClassFileException e) {
            e.printStackTrace();
            Assertions.UNREACHABLE();
          }
        }
      }
    }
    if (hs != null && hs.length > 0) {
      if (!goToAllHandlers) {
        exceptionTypes=HashSetFactory.make(exceptionTypes);
      }
      for (int j=0; j < hs.length; j++) {
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + hs[j]);
        }
        BasicBlock b=getBlockForInstruction(hs[j].getHandler());
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + b);
        }
        if (goToAllHandlers) {
          if (DEBUG) {
            System.err.println(""String_Node_Str"" + b);
          }
          addExceptionalEdgeTo(b);
        }
 else {
          TypeReference caughtException=null;
          if (hs[j].getCatchClass() != null) {
            ClassLoaderReference loader=ShrikeCFG.this.getMethod().getDeclaringClass().getReference().getClassLoader();
            caughtException=ShrikeUtil.makeTypeReference(loader,hs[j].getCatchClass());
            if (DEBUG) {
              System.err.println(""String_Node_Str"" + caughtException);
            }
            IClass caughtClass=cha.lookupClass(caughtException);
            if (caughtClass == null) {
              addExceptionalEdgeTo(b);
              Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
              caughtException=null;
            }
          }
 else {
            if (DEBUG) {
              System.err.println(""String_Node_Str"");
            }
            if (!exceptionTypes.isEmpty()) {
              addExceptionalEdgeTo(b);
              exceptionTypes.clear();
              caughtException=null;
            }
          }
          if (caughtException != null) {
            IClass caughtClass=cha.lookupClass(caughtException);
            ArrayList<TypeReference> caught=new ArrayList<TypeReference>(exceptionTypes.size());
            for (            TypeReference t : exceptionTypes) {
              if (t != null) {
                IClass klass=cha.lookupClass(t);
                if (klass == null) {
                  Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
                  addExceptionalEdgeTo(b);
                }
 else {
                  boolean subtype1=cha.isSubclassOf(klass,caughtClass);
                  if (subtype1 || cha.isSubclassOf(caughtClass,klass)) {
                    addExceptionalEdgeTo(b);
                    if (subtype1) {
                      caught.add(t);
                    }
                  }
                }
              }
            }
            exceptionTypes.removeAll(caught);
          }
        }
      }
      if (exceptionTypes == null || !exceptionTypes.isEmpty()) {
        BasicBlock exit=exit();
        addExceptionalEdgeTo(exit);
      }
    }
 else {
      BasicBlock exit=exit();
      addExceptionalEdgeTo(exit);
    }
  }
}",0.9644517020474814
38463,"public Collection<IMethod> getAllMethods() throws ClassHierarchyException {
  Collection<IMethod> result=new LinkedList<IMethod>();
  Iterator<IMethod> declaredMethods=getDeclaredMethods().iterator();
  while (declaredMethods.hasNext()) {
    result.add(declaredMethods.next());
  }
  IClass s=getSuperclass();
  while (s != null) {
    Iterator<IMethod> superDeclaredMethods=s.getDeclaredMethods().iterator();
    while (superDeclaredMethods.hasNext()) {
      result.add(superDeclaredMethods.next());
    }
    s=s.getSuperclass();
  }
  return result;
}","public Collection<IMethod> getAllMethods() throws ClassHierarchyException {
  Collection<IMethod> result=new LinkedList<IMethod>();
  Iterator<IMethod> declaredMethods=getDeclaredMethods().iterator();
  while (declaredMethods.hasNext()) {
    result.add(declaredMethods.next());
  }
  if (isInterface()) {
    for (    IClass i : getDirectInterfaces()) {
      result.addAll(i.getAllMethods());
    }
  }
  IClass s=getSuperclass();
  while (s != null) {
    Iterator<IMethod> superDeclaredMethods=s.getDeclaredMethods().iterator();
    while (superDeclaredMethods.hasNext()) {
      result.add(superDeclaredMethods.next());
    }
    s=s.getSuperclass();
  }
  return result;
}",0.9011345218800648
38464,"public void performVerboseAction(){
  System.err.println(""String_Node_Str"" + nEvaluated);
  System.err.println(""String_Node_Str"" + nCreated);
  System.err.println(""String_Node_Str"" + workList.size());
  if (MORE_VERBOSE) {
    AbstractStatement s=workList.takeStatement();
    System.err.println(""String_Node_Str"" + lineBreak(s.toString(),132));
    if (s instanceof VerboseAction) {
      ((VerboseAction)s).performVerboseAction();
    }
    workList.insertStatement(s);
  }
}","public void performVerboseAction(){
  System.err.println(""String_Node_Str"" + nEvaluated);
  System.err.println(""String_Node_Str"" + nCreated);
  System.err.println(""String_Node_Str"" + workList.size());
  if (MORE_VERBOSE) {
    if (!workList.isEmpty()) {
      AbstractStatement s=workList.takeStatement();
      System.err.println(""String_Node_Str"" + lineBreak(s.toString(),132));
      if (s instanceof VerboseAction) {
        ((VerboseAction)s).performVerboseAction();
      }
      workList.insertStatement(s);
    }
  }
}",0.9511465603190428
38465,"/** 
 * Solve the set of dataflow graph. <p> PRECONDITION: graph is set up
 * @return true iff the evaluation of some equation caused a change in thevalue of some variable.
 */
@SuppressWarnings(""String_Node_Str"") public boolean solve(IProgressMonitor monitor) throws CancelException {
  boolean globalChange=false;
  if (firstSolve) {
    initForFirstSolve();
  }
  while (!workList.isEmpty()) {
    MonitorUtil.throwExceptionIfCanceled(monitor);
    orderStatements();
    AbstractStatement s=workList.takeStatement();
    if (DEBUG) {
      Trace.println(""String_Node_Str"" + s);
    }
    byte code=s.evaluate();
    if (verbose) {
      nEvaluated++;
      if (nEvaluated % getVerboseInterval() == 0) {
        performVerboseAction();
      }
      if (nEvaluated % getPeriodicMaintainInterval() == 0) {
        periodicMaintenance();
      }
    }
    if (DEBUG) {
      Trace.println(""String_Node_Str"" + s + ""String_Node_Str""+ isChanged(code));
    }
    if (isChanged(code)) {
      globalChange=true;
      updateWorkList(s);
    }
    if (isFixed(code)) {
      removeStatement(s);
    }
  }
  return globalChange;
}","/** 
 * Solve the set of dataflow graph. <p> PRECONDITION: graph is set up
 * @return true iff the evaluation of some equation caused a change in the value of some variable.
 */
@SuppressWarnings(""String_Node_Str"") public boolean solve(IProgressMonitor monitor) throws CancelException {
  boolean globalChange=false;
  if (firstSolve) {
    initForFirstSolve();
  }
  while (!workList.isEmpty()) {
    MonitorUtil.throwExceptionIfCanceled(monitor);
    orderStatements();
    AbstractStatement s=workList.takeStatement();
    if (DEBUG) {
      Trace.println(""String_Node_Str"" + s);
    }
    byte code=s.evaluate();
    if (verbose) {
      nEvaluated++;
      if (nEvaluated % getVerboseInterval() == 0) {
        performVerboseAction();
      }
      if (nEvaluated % getPeriodicMaintainInterval() == 0) {
        periodicMaintenance();
      }
    }
    if (DEBUG) {
      Trace.println(""String_Node_Str"" + s + ""String_Node_Str""+ isChanged(code));
    }
    if (isChanged(code)) {
      globalChange=true;
      updateWorkList(s);
    }
    if (isFixed(code)) {
      removeStatement(s);
    }
  }
  return globalChange;
}",0.9995557529986672
38466,"public static void main(String[] args) throws Exception, IllegalArgumentException {
  if (args.length < 2) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  String in=args[0];
  String out=args[1];
  String[] match=new String[args.length - 2];
  System.arraycopy(args,2,match,0,match.length);
  JarFile inJar=new JarFile(in);
  JarOutputStream outJar=new JarOutputStream(new FileOutputStream(out));
  JarFile[] matches=new JarFile[match.length];
  for (int i=0; i < match.length; i++) {
    matches[i]=new JarFile(match[i]);
  }
  for (Enumeration<JarEntry> e=inJar.entries(); e.hasMoreElements(); ) {
    JarEntry entry=e.nextElement();
    if (matchEntry(matches,entry)) {
      outJar.putNextEntry(entry);
      byte[] data=new byte[(int)entry.getSize()];
      InputStream stream=inJar.getInputStream(entry);
      readFully(stream,data);
      outJar.write(data);
      outJar.flush();
    }
  }
  outJar.close();
}","public static void main(String[] args) throws Exception, IllegalArgumentException {
  if (args.length < 2) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  String in=args[0];
  String out=args[1];
  if (in == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (out == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  String[] match=new String[args.length - 2];
  System.arraycopy(args,2,match,0,match.length);
  JarFile inJar=new JarFile(in);
  JarOutputStream outJar=new JarOutputStream(new FileOutputStream(out));
  JarFile[] matches=new JarFile[match.length];
  for (int i=0; i < match.length; i++) {
    matches[i]=new JarFile(match[i]);
  }
  for (Enumeration<JarEntry> e=inJar.entries(); e.hasMoreElements(); ) {
    JarEntry entry=e.nextElement();
    if (matchEntry(matches,entry)) {
      outJar.putNextEntry(entry);
      byte[] data=new byte[(int)entry.getSize()];
      InputStream stream=inJar.getInputStream(entry);
      readFully(stream,data);
      outJar.write(data);
      outJar.flush();
    }
  }
  outJar.close();
}",0.9181773640372366
38467,"@Override final public int hashCode(){
  return getType().hashCode() + 14411 * getValue().hashCode();
}","@Override final public int hashCode(){
  int v=getValue() == null ? 0 : getValue().hashCode();
  return getType().hashCode() + 14411 * v;
}",0.6776859504132231
38468,"/** 
 * @return the constant value pushed: an Integer, a Long, a Float, a Double, aString, or null
 */
public abstract Object getValue();","/** 
 * @return the constant value pushed: an Integer, a Long, a Float, a Double, a String, or null
 */
public abstract Object getValue();",0.9963636363636365
38469,"@Override final public boolean equals(Object o){
  if (o instanceof ConstantInstruction) {
    ConstantInstruction i=(ConstantInstruction)o;
    return i.getType().equals(getType()) && i.getValue().equals(getValue());
  }
 else {
    return false;
  }
}","@Override final public boolean equals(Object o){
  if (o instanceof ConstantInstruction) {
    ConstantInstruction i=(ConstantInstruction)o;
    if (!i.getType().equals(getType())) {
      return false;
    }
    if (i.getValue() == null) {
      if (getValue() == null) {
        return true;
      }
 else {
        return false;
      }
    }
 else {
      if (getValue() == null) {
        return false;
      }
 else {
        return i.getValue().equals(getValue());
      }
    }
  }
 else {
    return false;
  }
}",0.5400516795865633
38470,"protected InstanceofInstruction(String type){
  super(OP_instanceof);
  this.type=type;
}","protected InstanceofInstruction(String type){
  super(OP_instanceof);
  this.type=type;
  if (type == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}",0.6768060836501901
38471,"/** 
 * Build an editor for specific method data. After patching the code you can retrieve the new code, handlers and instructions-to-bytecode-offsets map.
 */
public MethodEditor(Instruction[] instructions,ExceptionHandler[][] handlers,int[] instructionsToBytecodes){
  methodInfo=null;
  this.instructionsToBytecodes=instructionsToBytecodes;
  this.instructions=instructions;
  this.handlers=handlers;
}","/** 
 * Build an editor for specific method data. After patching the code you can retrieve the new code, handlers and instructions-to-bytecode-offsets map.
 */
public MethodEditor(Instruction[] instructions,ExceptionHandler[][] handlers,int[] instructionsToBytecodes){
  if (instructions == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  methodInfo=null;
  this.instructionsToBytecodes=instructionsToBytecodes;
  this.instructions=instructions;
  this.handlers=handlers;
}",0.8970099667774086
38472,"/** 
 * Compute the promoted type that the JVM uses to manipulate values of type ""t"" on its working stack.
 * @throws IllegalArgumentException  if t is null
 */
public static String getStackType(String t){
  if (t == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
switch (t.charAt(0)) {
case 'Z':
case 'C':
case 'B':
case 'S':
    return ""String_Node_Str"";
default :
  return t;
}
}","/** 
 * Compute the promoted type that the JVM uses to manipulate values of type ""t"" on its working stack.
 * @throws IllegalArgumentException  if t is null
 */
public static String getStackType(String t){
  if (t == null || t.length() < 1) {
    throw new IllegalArgumentException(""String_Node_Str"" + t);
  }
switch (t.charAt(0)) {
case 'Z':
case 'C':
case 'B':
case 'S':
    return ""String_Node_Str"";
default :
  return t;
}
}",0.973621103117506
38473,"/** 
 * Compute the number of parameters given by method signature ""type"". Any ""this"" parameter is not included.
 * @throws IllegalArgumentException  if type == null
 */
static int getParamsCount(String type) throws IllegalArgumentException {
  if (type == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int index=1;
  int count=0;
  while (type.charAt(index) != ')') {
    count++;
    index+=getTypeLength(type,index);
  }
  return count;
}","/** 
 * Compute the number of parameters given by method signature ""type"". Any ""this"" parameter is not included.
 * @throws IllegalArgumentException  if type == null
 */
static int getParamsCount(String type) throws IllegalArgumentException {
  if (type == null || type.length() < 2) {
    throw new IllegalArgumentException(""String_Node_Str"" + type);
  }
  int index=1;
  int count=0;
  while (type.charAt(index) != ')') {
    count++;
    index+=getTypeLength(type,index);
  }
  return count;
}",0.970954356846473
38474,"/** 
 * @return true iff t is a primitive type
 */
public static boolean isPrimitiveType(String t){
  if (t == null) {
    return false;
  }
 else {
switch (t.charAt(0)) {
case 'L':
case '[':
      return false;
default :
    return true;
}
}
}","/** 
 * @return true iff t is a primitive type
 */
public static boolean isPrimitiveType(String t){
  if (t == null || t.length() == 0) {
    return false;
  }
 else {
switch (t.charAt(0)) {
case 'L':
case '[':
      return false;
default :
    return true;
}
}
}",0.9625246548323472
38475,"/** 
 * Initialize a verifier.
 * @throws NullPointerException  if info is null
 */
public Verifier(MethodData info) throws NullPointerException {
  super(info);
}","/** 
 * Initialize a verifier.
 * @throws NullPointerException if info is null
 */
public Verifier(MethodData info) throws NullPointerException {
  super(info);
}",0.9969230769230768
38476,"public static void main(String[] args){
  for (int i=0; i < args.length; i++) {
    try {
      byte[] data=Util.readFully(new FileInputStream(args[i]));
      ClassReader r=new ClassReader(data);
      System.out.println(Util.makeClass(r.getName()) + ""String_Node_Str"" + computeSerialVersionUID(r));
    }
 catch (    FileNotFoundException e) {
      System.err.println(""String_Node_Str"" + args[i]);
    }
catch (    IOException e) {
      System.err.println(""String_Node_Str"" + args[i]);
    }
catch (    InvalidClassFileException e) {
      System.err.println(""String_Node_Str"" + args[i]);
    }
  }
}","public static void main(String[] args){
  for (int i=0; i < args.length; i++) {
    if (args[i] == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
    }
    try {
      byte[] data=Util.readFully(new FileInputStream(args[i]));
      ClassReader r=new ClassReader(data);
      System.out.println(Util.makeClass(r.getName()) + ""String_Node_Str"" + computeSerialVersionUID(r));
    }
 catch (    FileNotFoundException e) {
      System.err.println(""String_Node_Str"" + args[i]);
    }
catch (    IOException e) {
      System.err.println(""String_Node_Str"" + args[i]);
    }
catch (    InvalidClassFileException e) {
      System.err.println(""String_Node_Str"" + args[i]);
    }
  }
}",0.9110105580693816
38477,"/** 
 * Call this when you're done modifying classes.
 */
final public void close() throws IOException {
  if (passUnmodifiedClasses) {
    writeUnmodifiedClasses();
  }
  if (outputJar != null) {
    outputJar.close();
  }
  if (cachedJar != null) {
    cachedJar.close();
  }
}","/** 
 * Call this when you're done modifying classes.
 */
final public void close() throws IOException, IllegalStateException {
  if (passUnmodifiedClasses) {
    writeUnmodifiedClasses();
  }
  if (outputJar != null) {
    outputJar.close();
  }
  if (cachedJar != null) {
    cachedJar.close();
  }
}",0.9604130808950088
38478,"/** 
 * Parse an argument list to find elements to instrument and the name of the output file. The ""-o filename"" option selects the output JAR file name. Any other argument not starting with ""-"" is added to the list of elements to instrument, if it appears to be the name of a class file, JAR file, or directory. If any argument starting with ""--"" is encountered, the rest of the command-line is considered leftover
 * @return the arguments that were not understood
 * @throws IllegalArgumentException  if args == null
 */
final public String[] parseStandardArgs(String[] args) throws IllegalArgumentException, IOException {
  if (args == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ArrayList<String> leftover=new ArrayList<String>();
  for (int i=0; i < args.length; i++) {
    String a=args[i];
    if (a.equals(""String_Node_Str"") && i + 1 < args.length) {
      setOutputJar(new File(args[i + 1]));
      i++;
      continue;
    }
 else     if (!a.startsWith(""String_Node_Str"")) {
      if (addInputElement(a)) {
        continue;
      }
    }
 else     if (a.startsWith(""String_Node_Str"")) {
      for (int j=i; j < args.length; j++) {
        leftover.add(args[j]);
      }
      break;
    }
    leftover.add(a);
  }
  String[] r=new String[leftover.size()];
  leftover.toArray(r);
  return r;
}","/** 
 * Parse an argument list to find elements to instrument and the name of the output file. The ""-o filename"" option selects the output JAR file name. Any other argument not starting with ""-"" is added to the list of elements to instrument, if it appears to be the name of a class file, JAR file, or directory. If any argument starting with ""--"" is encountered, the rest of the command-line is considered leftover
 * @return the arguments that were not understood
 * @throws IllegalArgumentException  if args == null
 */
final public String[] parseStandardArgs(String[] args) throws IllegalArgumentException, IOException {
  if (args == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ArrayList<String> leftover=new ArrayList<String>();
  for (int i=0; i < args.length; i++) {
    String a=args[i];
    if (a == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
    }
    if (a.equals(""String_Node_Str"") && i + 1 < args.length) {
      setOutputJar(new File(args[i + 1]));
      i++;
      continue;
    }
 else     if (!a.startsWith(""String_Node_Str"")) {
      if (addInputElement(a)) {
        continue;
      }
    }
 else     if (a.startsWith(""String_Node_Str"")) {
      for (int j=i; j < args.length; j++) {
        leftover.add(args[j]);
      }
      break;
    }
    leftover.add(a);
  }
  String[] r=new String[leftover.size()];
  leftover.toArray(r);
  return r;
}",0.9596541786743517
38479,"/** 
 * Set the 4 bytes at offset 'offset' in 'buf' to the signed 32-bit value in v.
 * @throws IllegalArgumentException if buf is null
 */
public static void setInt(byte[] buf,int offset,int v) throws IllegalArgumentException {
  if (buf == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (offset >= buf.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + offset);
  }
  buf[offset]=(byte)(v >> 24);
  buf[offset + 1]=(byte)(v >> 16);
  buf[offset + 2]=(byte)(v >> 8);
  buf[offset + 3]=(byte)v;
}","/** 
 * Set the 4 bytes at offset 'offset' in 'buf' to the signed 32-bit value in v.
 * @throws IllegalArgumentException if buf is null
 */
public static void setInt(byte[] buf,int offset,int v) throws IllegalArgumentException {
  if (buf == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  try {
    buf[offset]=(byte)(v >> 24);
    buf[offset + 1]=(byte)(v >> 16);
    buf[offset + 2]=(byte)(v >> 8);
    buf[offset + 3]=(byte)v;
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    throw new IllegalArgumentException(""String_Node_Str"" + offset);
  }
}",0.7985739750445633
38480,"/** 
 * Set the 2 bytes at offset 'offset' in 'buf' to the unsigned 16-bit value in v.
 * @throws IllegalArgumentException if buf is null
 */
public static void setUShort(byte[] buf,int offset,int v) throws IllegalArgumentException {
  if (buf == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (offset + 1 >= buf.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + buf.length + ""String_Node_Str""+ offset);
  }
  buf[offset]=(byte)(v >> 8);
  buf[offset + 1]=(byte)v;
}","/** 
 * Set the 2 bytes at offset 'offset' in 'buf' to the unsigned 16-bit value in v.
 * @throws IllegalArgumentException if buf is null
 */
public static void setUShort(byte[] buf,int offset,int v) throws IllegalArgumentException {
  if (buf == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (offset < 0 || offset + 1 >= buf.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + buf.length + ""String_Node_Str""+ offset);
  }
  try {
    buf[offset]=(byte)(v >> 8);
    buf[offset + 1]=(byte)v;
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    throw new IllegalArgumentException(""String_Node_Str"" + offset);
  }
}",0.8741496598639455
38481,"/** 
 * @param bytes the raw class file data
 * @param offset the start of the constant pool data
 * @param itemCount the number of items in the pool
 */
public ConstantPoolParser(byte[] bytes,int offset,int itemCount) throws InvalidClassFileException {
  this.bytes=bytes;
  if (offset < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + offset);
  }
  if (itemCount < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + itemCount);
  }
  parseConstantPool(offset,itemCount);
}","/** 
 * @param bytes the raw class file data
 * @param offset the start of the constant pool data
 * @param itemCount the number of items in the pool
 */
public ConstantPoolParser(byte[] bytes,int offset,int itemCount) throws InvalidClassFileException {
  this.bytes=bytes;
  if (offset < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + offset);
  }
  if (itemCount < 0 || itemCount > MAX_CP_ITEMS) {
    throw new IllegalArgumentException(""String_Node_Str"" + itemCount);
  }
  parseConstantPool(offset,itemCount);
}",0.972972972972973
38482,"public boolean isPEI(){
  return true;
}","public boolean isPEI(){
  return !isStatic();
}",0.8505747126436781
38483,"public boolean isPEI(){
  return true;
}","public boolean isPEI(){
  return !isStatic();
}",0.8505747126436781
38484,"@Override protected JavaSourceAnalysisEngine getAnalysisEngine(final String[] mainClassDescriptors){
  JavaSourceAnalysisEngine engine=new PolyglotJavaSourceAnalysisEngine(){
    protected Iterable<Entrypoint> makeDefaultEntrypoints(    AnalysisScope scope,    IClassHierarchy cha){
      return Util.makeMainEntrypoints(EclipseProjectPath.SOURCE_REF,cha,new String[]{""String_Node_Str""});
    }
  }
;
  engine.setExclusionsFile(CallGraphTestUtil.REGRESSION_EXCLUSIONS);
  return engine;
}","@Override protected JavaSourceAnalysisEngine getAnalysisEngine(final String[] mainClassDescriptors){
  JavaSourceAnalysisEngine engine=new PolyglotJavaSourceAnalysisEngine(){
    protected Iterable<Entrypoint> makeDefaultEntrypoints(    AnalysisScope scope,    IClassHierarchy cha){
      return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,new String[]{""String_Node_Str""});
    }
  }
;
  engine.setExclusionsFile(CallGraphTestUtil.REGRESSION_EXCLUSIONS);
  return engine;
}",0.9539406345957012
38485,"protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(EclipseProjectPath.SOURCE_REF,cha,new String[]{""String_Node_Str""});
}","protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,new String[]{""String_Node_Str""});
}",0.8872180451127819
38486,"@Override protected JavaSourceAnalysisEngine getAnalysisEngine(final String[] mainClassDescriptors){
  JavaSourceAnalysisEngine engine=new PolyglotJavaSourceAnalysisEngine(){
    protected Iterable<Entrypoint> makeDefaultEntrypoints(    AnalysisScope scope,    IClassHierarchy cha){
      return Util.makeMainEntrypoints(EclipseProjectPath.SOURCE_REF,cha,mainClassDescriptors);
    }
  }
;
  engine.setExclusionsFile(CallGraphTestUtil.REGRESSION_EXCLUSIONS);
  return engine;
}","@Override protected JavaSourceAnalysisEngine getAnalysisEngine(final String[] mainClassDescriptors){
  JavaSourceAnalysisEngine engine=new PolyglotJavaSourceAnalysisEngine(){
    protected Iterable<Entrypoint> makeDefaultEntrypoints(    AnalysisScope scope,    IClassHierarchy cha){
      return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
    }
  }
;
  engine.setExclusionsFile(CallGraphTestUtil.REGRESSION_EXCLUSIONS);
  return engine;
}",0.9528795811518324
38487,"protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(EclipseProjectPath.SOURCE_REF,cha,mainClassDescriptors);
}","protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
}",0.9071618037135278
38488,"protected JavaSourceAnalysisEngine getAnalysisEngine(final String[] mainClassDescriptors){
  JavaSourceAnalysisEngine engine=new PolyglotJavaSourceAnalysisEngine(){
    protected Iterable<Entrypoint> makeDefaultEntrypoints(    AnalysisScope scope,    IClassHierarchy cha){
      return Util.makeMainEntrypoints(EclipseProjectPath.SOURCE_REF,cha,mainClassDescriptors);
    }
    public IRTranslatorExtension getTranslatorExtension(){
      JavaIRTranslatorExtension ext=new JavaIRTranslatorExtension();
      ext.setCAstRewriterFactory(new CAstRewriterFactory(){
        public CAstRewriter createCAstRewriter(        CAst ast){
          return new SynchronizedBlockDuplicator(ast,true,testMethod);
        }
      }
);
      return ext;
    }
  }
;
  engine.setExclusionsFile(CallGraphTestUtil.REGRESSION_EXCLUSIONS);
  return engine;
}","protected JavaSourceAnalysisEngine getAnalysisEngine(final String[] mainClassDescriptors){
  JavaSourceAnalysisEngine engine=new PolyglotJavaSourceAnalysisEngine(){
    protected Iterable<Entrypoint> makeDefaultEntrypoints(    AnalysisScope scope,    IClassHierarchy cha){
      return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
    }
    public IRTranslatorExtension getTranslatorExtension(){
      JavaIRTranslatorExtension ext=new JavaIRTranslatorExtension();
      ext.setCAstRewriterFactory(new CAstRewriterFactory(){
        public CAstRewriter createCAstRewriter(        CAst ast){
          return new SynchronizedBlockDuplicator(ast,true,testMethod);
        }
      }
);
      return ext;
    }
  }
;
  engine.setExclusionsFile(CallGraphTestUtil.REGRESSION_EXCLUSIONS);
  return engine;
}",0.9731343283582088
38489,"protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(EclipseProjectPath.SOURCE_REF,cha,mainClassDescriptors);
}","protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
}",0.9071618037135278
38490,"@Override protected void buildAnalysisScope(){
  try {
    scope=makeSourceAnalysisScope();
    if (getExclusionsFile() != null) {
      scope.setExclusions(new FileOfClasses(new File(getExclusionsFile())));
    }
    EclipseProjectPath epath=getEclipseProjectPath();
    for (    Module m : epath.getModules(Loader.PRIMORDIAL,true)) {
      scope.addToScope(scope.getPrimordialLoader(),m);
    }
    ClassLoaderReference app=scope.getApplicationLoader();
    for (    Module m : epath.getModules(Loader.APPLICATION,true)) {
      scope.addToScope(app,m);
    }
    for (    Module m : epath.getModules(Loader.EXTENSION,true)) {
      if (!(m instanceof BinaryDirectoryTreeModule))       scope.addToScope(app,m);
    }
    ClassLoaderReference src=((JavaSourceAnalysisScope)scope).getSourceLoader();
    for (    Module m : epath.getModules(Loader.SOURCE,false)) {
      scope.addToScope(src,m);
    }
  }
 catch (  IOException e) {
    Assertions.UNREACHABLE(e.toString());
  }
}","@Override protected void buildAnalysisScope(){
  try {
    scope=makeSourceAnalysisScope();
    if (getExclusionsFile() != null) {
      scope.setExclusions(FileOfClasses.createFileOfClasses(new File(getExclusionsFile())));
    }
    EclipseProjectPath epath=getEclipseProjectPath();
    for (    Module m : epath.getModules(Loader.PRIMORDIAL,true)) {
      scope.addToScope(scope.getPrimordialLoader(),m);
    }
    ClassLoaderReference app=scope.getApplicationLoader();
    for (    Module m : epath.getModules(Loader.APPLICATION,true)) {
      scope.addToScope(app,m);
    }
    for (    Module m : epath.getModules(Loader.EXTENSION,true)) {
      if (!(m instanceof BinaryDirectoryTreeModule))       scope.addToScope(app,m);
    }
    ClassLoaderReference src=((JavaSourceAnalysisScope)scope).getSourceLoader();
    for (    Module m : epath.getModules(Loader.APPLICATION,false)) {
      scope.addToScope(src,m);
    }
  }
 catch (  IOException e) {
    Assertions.UNREACHABLE(e.toString());
  }
}",0.9803129732458354
38491,"@Override protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(EclipseProjectPath.SOURCE_REF,cha);
}","@Override protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha);
}",0.9014084507042254
38492,"protected IClassLoader makeNewClassLoader(ClassLoaderReference classLoaderReference,IClassHierarchy cha,IClassLoader parent,AnalysisScope scope) throws IOException {
  if (classLoaderReference.equals(EclipseProjectPath.SOURCE_REF)) {
    ClassLoaderImpl cl=new PolyglotSourceLoaderImpl(classLoaderReference,parent,getExclusions(),cha,getExtensionFor(classLoaderReference));
    cl.init(scope.getModules(classLoaderReference));
    return cl;
  }
 else {
    return super.makeNewClassLoader(classLoaderReference,cha,parent,scope);
  }
}","protected IClassLoader makeNewClassLoader(ClassLoaderReference classLoaderReference,IClassHierarchy cha,IClassLoader parent,AnalysisScope scope) throws IOException {
  if (classLoaderReference.equals(JavaSourceAnalysisScope.SOURCE)) {
    ClassLoaderImpl cl=new PolyglotSourceLoaderImpl(classLoaderReference,parent,getExclusions(),cha,getExtensionFor(classLoaderReference));
    cl.init(scope.getModules(classLoaderReference));
    return cl;
  }
 else {
    return super.makeNewClassLoader(classLoaderReference,cha,parent,scope);
  }
}",0.957983193277311
38493,"public PolyglotClassLoaderFactory(SetOfClasses exclusions,IRTranslatorExtension javaExtInfo){
  super(exclusions);
  fExtensionMap.put(EclipseProjectPath.SOURCE_REF,javaExtInfo);
}","public PolyglotClassLoaderFactory(SetOfClasses exclusions,IRTranslatorExtension javaExtInfo){
  super(exclusions);
  fExtensionMap.put(JavaSourceAnalysisScope.SOURCE,javaExtInfo);
}",0.9030470914127424
38494,"public Iterator<T> iterator(){
  return new ArrayIterator<T>(entries);
}","public Iterator<T> iterator(){
  if (entries.length == 0) {
    return EmptyIterator.instance();
  }
  return new ArrayIterator<T>(entries);
}",0.6728971962616822
38495,"public boolean containsValue(Object value){
  if (keysAndValues == null) {
    return false;
  }
  for (int i=size(); i < keysAndValues.length; i++) {
    if (keysAndValues[i].equals(value)) {
      return true;
    }
  }
  return false;
}","public boolean containsValue(Object value){
  if (keysAndValues == null) {
    return false;
  }
  for (int i=size(); i < keysAndValues.length; i++) {
    Object v=keysAndValues[i];
    if (v == null) {
      if (value == null) {
        return true;
      }
    }
 else {
      if (v.equals(value)) {
        return true;
      }
    }
  }
  return false;
}",0.6532663316582915
38496,"@Override protected JavaSourceAnalysisEngine getAnalysisEngine(final String[] mainClassDescriptors){
  JavaSourceAnalysisEngine engine=new JDTJavaSourceAnalysisEngine(){
    protected Iterable<Entrypoint> makeDefaultEntrypoints(    AnalysisScope scope,    IClassHierarchy cha){
      return Util.makeMainEntrypoints(EclipseProjectPath.SOURCE_REF,cha,mainClassDescriptors);
    }
  }
;
  try {
    engine.setExclusionsFile(FileProvider.getFileFromPlugin(CoreTestsPlugin.getDefault(),CallGraphTestUtil.REGRESSION_EXCLUSIONS).getAbsolutePath());
  }
 catch (  IOException e) {
    Assert.assertFalse(""String_Node_Str"",true);
  }
  return engine;
}","@Override protected JavaSourceAnalysisEngine getAnalysisEngine(final String[] mainClassDescriptors){
  JavaSourceAnalysisEngine engine=new JDTJavaSourceAnalysisEngine(){
    protected Iterable<Entrypoint> makeDefaultEntrypoints(    AnalysisScope scope,    IClassHierarchy cha){
      return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
    }
  }
;
  try {
    engine.setExclusionsFile(FileProvider.getFileFromPlugin(CoreTestsPlugin.getDefault(),CallGraphTestUtil.REGRESSION_EXCLUSIONS).getAbsolutePath());
  }
 catch (  IOException e) {
    Assert.assertFalse(""String_Node_Str"",true);
  }
  return engine;
}",0.965089216446858
38497,"protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(EclipseProjectPath.SOURCE_REF,cha,mainClassDescriptors);
}","protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
}",0.9071618037135278
38498,"@Override protected JavaSourceAnalysisEngine getAnalysisEngine(final String[] mainClassDescriptors){
  JavaSourceAnalysisEngine engine=new JDTJavaSourceAnalysisEngine(){
    protected Iterable<Entrypoint> makeDefaultEntrypoints(    AnalysisScope scope,    IClassHierarchy cha){
      return Util.makeMainEntrypoints(EclipseProjectPath.SOURCE_REF,cha,mainClassDescriptors);
    }
  }
;
  try {
    engine.setExclusionsFile(FileProvider.getFileFromPlugin(CoreTestsPlugin.getDefault(),CallGraphTestUtil.REGRESSION_EXCLUSIONS).getAbsolutePath());
  }
 catch (  IOException e) {
    Assert.assertFalse(""String_Node_Str"",true);
  }
  return engine;
}","@Override protected JavaSourceAnalysisEngine getAnalysisEngine(final String[] mainClassDescriptors){
  JavaSourceAnalysisEngine engine=new JDTJavaSourceAnalysisEngine(){
    protected Iterable<Entrypoint> makeDefaultEntrypoints(    AnalysisScope scope,    IClassHierarchy cha){
      return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
    }
  }
;
  try {
    engine.setExclusionsFile(FileProvider.getFileFromPlugin(CoreTestsPlugin.getDefault(),CallGraphTestUtil.REGRESSION_EXCLUSIONS).getAbsolutePath());
  }
 catch (  IOException e) {
    Assert.assertFalse(""String_Node_Str"",true);
  }
  return engine;
}",0.965089216446858
38499,"protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(EclipseProjectPath.SOURCE_REF,cha,mainClassDescriptors);
}","protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
}",0.9071618037135278
38500,"protected IClassLoader makeNewClassLoader(ClassLoaderReference classLoaderReference,IClassHierarchy cha,IClassLoader parent,AnalysisScope scope) throws IOException {
  if (classLoaderReference.equals(EclipseProjectPath.SOURCE_REF)) {
    ClassLoaderImpl cl=new JDTSourceLoaderImpl(classLoaderReference,parent,getExclusions(),cha);
    cl.init(scope.getModules(classLoaderReference));
    return cl;
  }
 else {
    return super.makeNewClassLoader(classLoaderReference,cha,parent,scope);
  }
}","protected IClassLoader makeNewClassLoader(ClassLoaderReference classLoaderReference,IClassHierarchy cha,IClassLoader parent,AnalysisScope scope) throws IOException {
  if (classLoaderReference.equals(JavaSourceAnalysisScope.SOURCE)) {
    ClassLoaderImpl cl=new JDTSourceLoaderImpl(classLoaderReference,parent,getExclusions(),cha);
    cl.init(scope.getModules(classLoaderReference));
    return cl;
  }
 else {
    return super.makeNewClassLoader(classLoaderReference,cha,parent,scope);
  }
}",0.9543147208121828
38501,"protected static void dumpIR(CallGraph cg,boolean assertReachable) throws IOException {
  Set<IMethod> unreachable=HashSetFactory.make();
  IClassHierarchy cha=cg.getClassHierarchy();
  IClassLoader sourceLoader=cha.getLoader(EclipseProjectPath.SOURCE_REF);
  for (Iterator iter=sourceLoader.iterateAllClasses(); iter.hasNext(); ) {
    IClass clazz=(IClass)iter.next();
    Trace.println(clazz);
    if (clazz.isInterface())     continue;
    for (    IMethod m : clazz.getDeclaredMethods()) {
      if (m.isAbstract()) {
        Trace.println(m);
      }
 else {
        Iterator nodeIter=cg.getNodes(m.getReference()).iterator();
        if (!nodeIter.hasNext()) {
          Trace.println(""String_Node_Str"" + m.getReference() + ""String_Node_Str"");
          unreachable.add(m);
          continue;
        }
        CGNode node=(CGNode)nodeIter.next();
        Trace.println(node.getIR());
      }
    }
  }
  if (assertReachable) {
    Assert.assertTrue(""String_Node_Str"" + unreachable.toString(),unreachable.isEmpty());
  }
}","protected static void dumpIR(CallGraph cg,boolean assertReachable) throws IOException {
  Set<IMethod> unreachable=HashSetFactory.make();
  IClassHierarchy cha=cg.getClassHierarchy();
  IClassLoader sourceLoader=cha.getLoader(JavaSourceAnalysisScope.SOURCE);
  for (Iterator iter=sourceLoader.iterateAllClasses(); iter.hasNext(); ) {
    IClass clazz=(IClass)iter.next();
    Trace.println(clazz);
    if (clazz.isInterface())     continue;
    for (    IMethod m : clazz.getDeclaredMethods()) {
      if (m.isAbstract()) {
        Trace.println(m);
      }
 else {
        Iterator nodeIter=cg.getNodes(m.getReference()).iterator();
        if (!nodeIter.hasNext()) {
          Trace.println(""String_Node_Str"" + m.getReference() + ""String_Node_Str"");
          unreachable.add(m);
          continue;
        }
        CGNode node=(CGNode)nodeIter.next();
        Trace.println(node.getIR());
      }
    }
  }
  if (assertReachable) {
    Assert.assertTrue(""String_Node_Str"" + unreachable.toString(),unreachable.isEmpty());
  }
}",0.9791363415817564
38502,"private MethodReference getSliceRootReference(String className,String methodName,String methodDescriptor){
  TypeName clsName=TypeName.string2TypeName(""String_Node_Str"" + className.replace('.','/'));
  TypeReference clsRef=TypeReference.findOrCreate(EclipseProjectPath.SOURCE_REF,clsName);
  Atom nameAtom=Atom.findOrCreateUnicodeAtom(methodName);
  Descriptor descr=Descriptor.findOrCreateUTF8(methodDescriptor);
  return MethodReference.findOrCreate(clsRef,nameAtom,descr);
}","private MethodReference getSliceRootReference(String className,String methodName,String methodDescriptor){
  TypeName clsName=TypeName.string2TypeName(""String_Node_Str"" + className.replace('.','/'));
  TypeReference clsRef=TypeReference.findOrCreate(JavaSourceAnalysisScope.SOURCE,clsName);
  Atom nameAtom=Atom.findOrCreateUnicodeAtom(methodName);
  Descriptor descr=Descriptor.findOrCreateUTF8(methodDescriptor);
  return MethodReference.findOrCreate(clsRef,nameAtom,descr);
}",0.9528795811518324
38503,"protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(EclipseProjectPath.SOURCE_REF,cha);
}","protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha);
}",0.8955223880597015
38504,"public ClassLoaderReference getSourceLoader(){
  return getLoader(EclipseProjectPath.SOURCE);
}","public ClassLoaderReference getSourceLoader(){
  return SOURCE;
}",0.8125
38505,"public JavaSourceAnalysisScope(Collection<Language> languages){
  super(languages);
  initForJava();
  EclipseProjectPath.SOURCE_REF.setParent(getLoader(APPLICATION));
  getLoader(SYNTHETIC).setParent(EclipseProjectPath.SOURCE_REF);
  loadersByName.put(EclipseProjectPath.SOURCE,EclipseProjectPath.SOURCE_REF);
  setLoaderImpl(getLoader(SYNTHETIC),""String_Node_Str"");
  setLoaderImpl(EclipseProjectPath.SOURCE_REF,""String_Node_Str"");
}","public JavaSourceAnalysisScope(Collection<Language> languages){
  super(languages);
  initForJava();
  loadersByName.put(SOURCE.getName(),SOURCE);
  setLoaderImpl(getLoader(SYNTH_SOURCE.getName()),""String_Node_Str"");
  setLoaderImpl(SOURCE,""String_Node_Str"");
}",0.4310344827586206
38506,"/** 
 * create a new field-element
 * @param fld - field element to serve as part of a path
 */
public FieldPathElement(IField fld){
  Assertions.precondition(fld != null,""String_Node_Str"");
  this.fld=fld;
}","/** 
 * create a new field-element
 * @param fld - field element to serve as part of a path
 */
public FieldPathElement(IField fld){
  if (fld == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.fld=fld;
}",0.8099547511312217
38507,"/** 
 * create a new anchor element
 * @param lpk -anchor element to serve as head of path
 */
public LocalPathElement(AbstractPointerKey lpk){
  this.lpk=lpk;
  if (Assertions.verifyAssertions) {
    Assertions._assert(lpk != null);
  }
}","/** 
 * create a new anchor element
 * @param lpk - anchor element to serve as head of path
 */
public LocalPathElement(AbstractPointerKey lpk){
  this.lpk=lpk;
  if (lpk == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}",0.7257731958762886
38508,"protected HeapGraph(PointerAnalysis pa){
  this.pa=pa;
}","protected HeapGraph(PointerAnalysis pa){
  if (pa == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.pa=pa;
}",0.5743589743589743
38509,"public FieldImpl(IClass declaringClass,FieldReference canonicalRef,int accessFlags,Collection<Annotation> annotations){
  this.declaringClass=declaringClass;
  this.fieldRef=canonicalRef;
  this.accessFlags=accessFlags;
  this.annotations=annotations;
  if (Assertions.verifyAssertions) {
    Assertions._assert(declaringClass != null);
    Assertions._assert(fieldRef != null);
  }
}","public FieldImpl(IClass declaringClass,FieldReference canonicalRef,int accessFlags,Collection<Annotation> annotations){
  this.declaringClass=declaringClass;
  this.fieldRef=canonicalRef;
  this.accessFlags=accessFlags;
  this.annotations=annotations;
  if (declaringClass == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (fieldRef == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}",0.6528623629719854
38510,"/** 
 * @return StringBuffer holding dot output representing G
 * @throws WalaException
 */
private static <T>StringBuffer dotOutput(Graph<T> g,NodeDecorator labels,String title) throws WalaException {
  StringBuffer result=new StringBuffer(""String_Node_Str"");
  if (title != null) {
    result.append(""String_Node_Str"" + title + ""String_Node_Str"");
  }
 else {
    result.append(""String_Node_Str"");
  }
  String rankdir=getRankDir();
  if (rankdir != null) {
    result.append(""String_Node_Str"" + rankdir + ""String_Node_Str"");
  }
  String fontsizeStr=""String_Node_Str"" + fontSize;
  String fontcolorStr=(fontColor != null) ? ""String_Node_Str"" + fontColor : ""String_Node_Str"";
  String fontnameStr=(fontName != null) ? ""String_Node_Str"" + fontName : ""String_Node_Str"";
  result.append(""String_Node_Str"");
  result.append(fontsizeStr);
  result.append(""String_Node_Str"");
  result.append(fontsizeStr);
  result.append(""String_Node_Str"");
  result.append(fontcolorStr);
  result.append(fontnameStr);
  result.append(""String_Node_Str"");
  result.append(fontsizeStr);
  result.append(fontcolorStr);
  result.append(fontnameStr);
  result.append(""String_Node_Str"");
  Collection dotNodes=computeDotNodes(g);
  outputNodes(labels,result,dotNodes);
  for (Iterator<? extends T> it=g.iterator(); it.hasNext(); ) {
    T n=it.next();
    for (Iterator<? extends T> it2=g.getSuccNodes(n); it2.hasNext(); ) {
      T s=it2.next();
      result.append(""String_Node_Str"");
      result.append(getPort(n,labels));
      result.append(""String_Node_Str"");
      result.append(getPort(s,labels));
      result.append(""String_Node_Str"");
    }
  }
  result.append(""String_Node_Str"");
  return result;
}","/** 
 * @return StringBuffer holding dot output representing G
 * @throws WalaException
 */
private static <T>StringBuffer dotOutput(Graph<T> g,NodeDecorator labels,String title) throws WalaException {
  StringBuffer result=new StringBuffer(""String_Node_Str"");
  if (title != null) {
    result.append(""String_Node_Str"" + title + ""String_Node_Str"");
  }
 else {
    result.append(""String_Node_Str"");
  }
  String rankdir=getRankDir();
  if (rankdir != null) {
    result.append(""String_Node_Str"" + rankdir + ""String_Node_Str"");
  }
  String fontsizeStr=""String_Node_Str"" + fontSize;
  String fontcolorStr=(fontColor != null) ? ""String_Node_Str"" + fontColor : ""String_Node_Str"";
  String fontnameStr=(fontName != null) ? ""String_Node_Str"" + fontName : ""String_Node_Str"";
  result.append(""String_Node_Str"");
  result.append(fontsizeStr);
  result.append(""String_Node_Str"");
  result.append(fontsizeStr);
  result.append(fontcolorStr);
  result.append(fontnameStr);
  result.append(""String_Node_Str"");
  result.append(fontsizeStr);
  result.append(fontcolorStr);
  result.append(fontnameStr);
  result.append(""String_Node_Str"");
  Collection dotNodes=computeDotNodes(g);
  outputNodes(labels,result,dotNodes);
  for (Iterator<? extends T> it=g.iterator(); it.hasNext(); ) {
    T n=it.next();
    for (Iterator<? extends T> it2=g.getSuccNodes(n); it2.hasNext(); ) {
      T s=it2.next();
      result.append(""String_Node_Str"");
      result.append(getPort(n,labels));
      result.append(""String_Node_Str"");
      result.append(getPort(s,labels));
      result.append(""String_Node_Str"");
    }
  }
  result.append(""String_Node_Str"");
  return result;
}",0.9892021595680864
38511,"private void resolvePluginClassPath(IProject p) throws CoreException, IOException {
  BundleDescription bd=findModel(p).getBundleDescription();
  resolveBundleDescriptionClassPath(bd,Loader.APPLICATION);
}","private void resolvePluginClassPath(IProject p) throws CoreException, IOException {
  BundleDescription bd=findModel(p).getBundleDescription();
  if (bd == null) {
    throw new IllegalStateException(""String_Node_Str"" + p);
  }
  resolveBundleDescriptionClassPath(bd,Loader.APPLICATION);
}",0.8299595141700404
38512,"/** 
 * If file extension is not provided, use system default
 * @throws JavaModelException
 * @throws IOException
 */
private void resolveProjectClasspathEntries() throws JavaModelException, IOException {
  resolveClasspathEntries(project.getRawClasspath(),Loader.EXTENSION);
}","private void resolveProjectClasspathEntries() throws JavaModelException, IOException {
  resolveClasspathEntries(project.getRawClasspath(),Loader.EXTENSION);
}",0.7276887871853547
38513,"@Override public int getNextD(int current,DIdentifier target,Random rand,Node[] nodes){
  double currentDist=this.idSpaceD.getPartitions()[current].distance(target);
  double minDist=this.idSpaceD.getMaxDistance();
  int minNode=-1;
  for (  int out : nodes[current].getOutgoingEdges()) {
    double dist=this.pD[out].distance(target);
    if (dist < minDist && !done[out]) {
      minDist=dist;
      minNode=out;
    }
  }
  if (minNode == -1 && from.containsKey(current)) {
    done[current]=true;
    return from.get(current);
  }
  if (minNode == -1) {
    return minNode;
  }
  if (!from.containsKey(minNode)) {
    from.put(minNode,current);
  }
  if (minDist >= currentDist) {
    done[current]=true;
  }
  return minNode;
}","@Override public int getNextD(int current,DIdentifier target,Random rand,Node[] nodes){
  if (!from.containsKey(current)) {
    from.put(current,-1);
  }
  double currentDist=this.idSpaceD.getPartitions()[current].distance(target);
  double minDist=this.idSpaceD.getMaxDistance();
  int minNode=-1;
  for (  int out : nodes[current].getOutgoingEdges()) {
    double dist=this.pD[out].distance(target);
    if (dist < minDist && !done[out]) {
      minDist=dist;
      minNode=out;
    }
  }
  if (minNode == -1 && from.containsKey(current)) {
    done[current]=true;
    return from.get(current);
  }
  if (minNode == -1) {
    return minNode;
  }
  if (!from.containsKey(minNode)) {
    from.put(minNode,current);
  }
  if (minDist >= currentDist) {
    done[current]=true;
  }
  return minNode;
}",0.9568627450980391
38514,"@Override public int getNextD(int current,DIdentifier target,Random rand,Node[] nodes){
  double currentDist=this.idSpaceD.getPartitions()[current].distance(target);
  double minDist=this.idSpaceD.getMaxDistance();
  int minNode=-1;
  for (  int out : nodes[current].getOutgoingEdges()) {
    double dist=this.pD[out].distance(target);
    if (dist < minDist && !done[out]) {
      minDist=dist;
      minNode=out;
    }
  }
  if (minNode == -1 && from.containsKey(current)) {
    return from.get(current);
  }
  if (minNode == -1) {
    return minNode;
  }
  if (!from.containsKey(minNode)) {
    from.put(minNode,current);
  }
  if (minDist >= currentDist) {
    done[current]=true;
  }
  return minNode;
}","@Override public int getNextD(int current,DIdentifier target,Random rand,Node[] nodes){
  double currentDist=this.idSpaceD.getPartitions()[current].distance(target);
  double minDist=this.idSpaceD.getMaxDistance();
  int minNode=-1;
  for (  int out : nodes[current].getOutgoingEdges()) {
    double dist=this.pD[out].distance(target);
    if (dist < minDist && !done[out]) {
      minDist=dist;
      minNode=out;
    }
  }
  if (minNode == -1 && from.containsKey(current)) {
    done[current]=true;
    return from.get(current);
  }
  if (minNode == -1) {
    return minNode;
  }
  if (!from.containsKey(minNode)) {
    from.put(minNode,current);
  }
  if (minDist >= currentDist) {
    done[current]=true;
  }
  return minNode;
}",0.9833333333333332
38515,"/** 
 * @return
 */
public String[] getConfigKeys();","/** 
 * Getter for all the configuration keys.
 * @return A string array containing all the configuration values.
 */
public String[] getConfigKeys();",0.5148514851485149
38516,"/** 
 * @return
 */
public String getKey();","/** 
 * Getter for the key of the particular placement model.
 * @return The key of the placement model.
 */
public String getKey();",0.4914285714285714
38517,"/** 
 * @return
 */
public double getHeight();","/** 
 * Getter for the height of the field in which the positions are to be determined.
 * @return The height of the field.
 */
public double getHeight();",0.46
38518,"/** 
 * @return
 */
public String[] getConfigValues();","/** 
 * Getter for all the configuration values.
 * @return A string array containing all the configuration values.
 */
public String[] getConfigValues();",0.5192307692307693
38519,"/** 
 * @param hotspots
 * @return
 */
public Point[] place(int hotspots);","/** 
 * Finds and returns <code>number</code> positions.
 * @param number The number of positions to be returned.
 * @return An array of positions.
 */
public Point[] place(int number);",0.4942084942084942
38520,"/** 
 * @return
 */
public double getWidth();","/** 
 * Getter for the width of the field in which the positions are to be determined.
 * @return The width of the field.
 */
public double getWidth();",0.4591836734693877
38521,"public PlacementModelContainer(int nodes,int hotspots,PlacementModel hotspotPlacer,PlacementModel nodePlacer,Partitioner partitioner,NodeConnector nodeConnector,RoutingAlgorithm r,Transformation[] t){
  super(""String_Node_Str"",nodes,getConfigKeys(hotspotPlacer,nodePlacer,nodeConnector,partitioner),getConfigValues(hotspotPlacer,nodePlacer,nodeConnector,partitioner),r,t);
  this.nodes=nodes;
  this.hotspots=hotspots;
  this.hotspotPlacer=hotspotPlacer;
  this.nodePlacer=nodePlacer;
  this.partitioner=partitioner;
  this.connector=nodeConnector;
  idSpace=new PlaneIdentifierSpaceSimple(null,hotspotPlacer.getWidth(),hotspotPlacer.getHeight(),false);
}","/** 
 * Standard and only constructor for this class, gets all needed classes and all the needed information.
 * @param nodes The number of nodes in the network.
 * @param hotspots The number of hotspots in the network.
 * @param hotspotPlacer The <code>PlacementModel</code> used to place the hotspots.
 * @param nodePlacer The <code>PlacementModel</code> used to place the nodes within the hotspots.
 * @param partitioner The <code>Partitioner</code> used to determine how much nodes are placed in each hotspot.
 * @param nodeConnector The <code>NodeConnector</code> used to connect nodes depending on their position.
 * @param r The routing to be used in the network.
 * @param t The transformations that should be applied to the graph of the network.
 */
public PlacementModelContainer(int nodes,int hotspots,PlacementModel hotspotPlacer,PlacementModel nodePlacer,Partitioner partitioner,NodeConnector nodeConnector,RoutingAlgorithm r,Transformation[] t){
  super(""String_Node_Str"",nodes,getConfigKeys(hotspotPlacer,nodePlacer,nodeConnector,partitioner),getConfigValues(hotspotPlacer,nodePlacer,nodeConnector,partitioner),r,t);
  this.nodes=nodes;
  this.hotspots=hotspots;
  this.hotspotPlacer=hotspotPlacer;
  this.nodePlacer=nodePlacer;
  this.partitioner=partitioner;
  this.connector=nodeConnector;
  idSpace=new PlaneIdentifierSpaceSimple(null,hotspotPlacer.getWidth(),hotspotPlacer.getHeight(),false);
}",0.6331561140647656
38522,"/** 
 * @param hotspotPlacer
 * @param nodePlacer
 * @return
 */
private static String[] getConfigKeys(PlacementModel hotspotPlacer,PlacementModel nodePlacer,NodeConnector connector,Partitioner partitioner){
  return Util.mergeArrays(new String[]{getKey(hotspotPlacer,nodePlacer)},Util.mergeArrays(Util.addPrefix(""String_Node_Str"",partitioner.getConfigKeys()),Util.mergeArrays(Util.addPrefix(""String_Node_Str"",connector.getConfigKeys()),Util.mergeArrays(Util.addPrefix(""String_Node_Str"",hotspotPlacer.getConfigKeys()),Util.addPrefix(""String_Node_Str"",nodePlacer.getConfigKeys())))));
}","/** 
 * Constructs an array containing all the configuration keys used for the particular <code>PlacementModelContainer</code>. Basically combines all the configuration keys of both <code>PlacementModels</code> (prefixed by ""HP_"" and ""NP_"" respectively), the <code>Partitioner</code> (prefixed by ""PART_"") and the <code>NodeConnector</code> (prefixed by ""NC_"") into one big string array and adds ""KEY"" without a prefix to it.
 * @param hotspotPlacer The <code>PlacementModel</code> used to place the hotspots.
 * @param nodePlacer The <code>PlacementModel</code> used to place the nodes within the hotspots.
 * @param partitioner The <code>Partitioner</code> used to determine the number of nodes in each hotspot.
 * @param nodeConnector The <code>NodeConnector</code> used to connect the nodes after placing them.
 * @return A string array containg all the configuration keys.
 */
private static String[] getConfigKeys(PlacementModel hotspotPlacer,PlacementModel nodePlacer,NodeConnector connector,Partitioner partitioner){
  return Util.mergeArrays(new String[]{""String_Node_Str""},Util.mergeArrays(Util.addPrefix(""String_Node_Str"",partitioner.getConfigKeys()),Util.mergeArrays(Util.addPrefix(""String_Node_Str"",connector.getConfigKeys()),Util.mergeArrays(Util.addPrefix(""String_Node_Str"",hotspotPlacer.getConfigKeys()),Util.addPrefix(""String_Node_Str"",nodePlacer.getConfigKeys())))));
}",0.5557809330628803
38523,"/** 
 * @param hotspotPlacer
 * @param nodePlacer
 * @return
 */
private static String getKey(PlacementModel hotspotPlacer,PlacementModel nodePlacer){
  return ""String_Node_Str"" + hotspotPlacer.getKey() + ""String_Node_Str""+ nodePlacer.getKey();
}","/** 
 * Constructs the key of this network, which will be HSM_<hotspotPlacer.getKey()>_<nodePlacer.getKey()>.
 * @param hotspotPlacer The <code>PlacementModel</code> used to place the hotspots.
 * @param nodePlacer The <code>PlacementModel</code> used to place the nodes within the hotspots.
 * @return The key of this network.
 */
private static String getKey(PlacementModel hotspotPlacer,PlacementModel nodePlacer){
  return ""String_Node_Str"" + hotspotPlacer.getKey() + ""String_Node_Str""+ nodePlacer.getKey();
}",0.6482213438735178
38524,"/** 
 * @param hotspotPlacer
 * @param nodePlacer
 * @param partitioner2
 * @param nodeConnector
 * @return
 */
private static String[] getConfigValues(PlacementModel hotspotPlacer,PlacementModel nodePlacer,NodeConnector connector,Partitioner partitioner){
  return Util.mergeArrays(new String[]{""String_Node_Str""},Util.mergeArrays(partitioner.getConfigValues(),Util.mergeArrays(connector.getConfigValues(),Util.mergeArrays(hotspotPlacer.getConfigValues(),nodePlacer.getConfigValues()))));
}","/** 
 * Constructs an array containing all the configuration values used for the particular <code>PlacementModelContainer</code>. Basically combines all the configuration values of both <code>PlacementModels</code>, the <code>Partitioner</code> and the <code>NodeConnector</code> into one big string array and adds the key of the <code>PlacementModelContainer</code> to this array.
 * @param hotspotPlacer The <code>PlacementModel</code> used to place the hotspots.
 * @param nodePlacer The <code>PlacementModel</code> used to place the nodes within the hotspots.
 * @param partitioner The <code>Partitioner</code> used to determine the number of nodes in each hotspot.
 * @param nodeConnector The <code>NodeConnector</code> used to connect the nodes after placing them.
 * @return A string array containg all the configuration values.
 */
private static String[] getConfigValues(PlacementModel hotspotPlacer,PlacementModel nodePlacer,NodeConnector connector,Partitioner partitioner){
  return Util.mergeArrays(new String[]{getKey(hotspotPlacer,nodePlacer)},Util.mergeArrays(partitioner.getConfigValues(),Util.mergeArrays(connector.getConfigValues(),Util.mergeArrays(hotspotPlacer.getConfigValues(),nodePlacer.getConfigValues()))));
}",0.5484057971014493
38525,"@Override public Graph generate(){
  Point[] hotspotCoords=hotspotPlacer.place(hotspots);
  PlanePartitionSimple[] coords=new PlanePartitionSimple[nodes];
  int[] nodesPerSpot=partitioner.partition(nodes,hotspots);
  int temp=0;
  int curNodes;
  for (int i=0; i < hotspots; i++) {
    curNodes=nodesPerSpot[i];
    addNodeCoords(coords,nodePlacer.place(curNodes),hotspotCoords[i],temp);
    temp+=curNodes;
  }
  Graph g=new Graph(description());
  idSpace.setPartitions(coords);
  g.addProperty(""String_Node_Str"",idSpace);
  Node[] nodes=Node.init(this.nodes(),g);
  connector.connect(nodes,idSpace);
  g.setNodes(nodes);
  return g;
}","/** 
 * Creates the graph for this network by first placing the hotspots, then placing the nodes within those hotspots. The coordinates of the nodes are stored in an <code>IdentifierSpace</code>, which is added as ""id_space_0"" to the attributes of the graph. In the end, the nodes are connected based on that id-space.
 */
@Override public Graph generate(){
  Point[] hotspotCoords=hotspotPlacer.place(hotspots);
  PlanePartitionSimple[] coords=new PlanePartitionSimple[nodes];
  int[] nodesPerSpot=partitioner.partition(nodes,hotspots);
  int temp=0;
  int curNodes;
  for (int i=0; i < hotspots; i++) {
    curNodes=nodesPerSpot[i];
    addNodeCoords(coords,nodePlacer.place(curNodes),hotspotCoords[i],temp);
    temp+=curNodes;
  }
  Graph g=new Graph(description());
  idSpace.setPartitions(coords);
  g.addProperty(""String_Node_Str"",idSpace);
  Node[] nodes=Node.init(this.nodes(),g);
  connector.connect(nodes,idSpace);
  g.setNodes(nodes);
  return g;
}",0.7977457733249843
38526,"/** 
 * @param pps
 * @param nodeCoords
 * @param ds
 */
private void addNodeCoords(PlanePartitionSimple[] pps,Point[] nodeCoords,Point coordOffset,int arrayOffset){
  for (int i=0; i < nodeCoords.length; i++) {
    pps[i + arrayOffset]=new PlanePartitionSimple(new PlaneIdentifier(nodeCoords[i].getX() + coordOffset.getX(),nodeCoords[i].getY() + coordOffset.getY(),idSpace));
  }
}","/** 
 * Convenience method to convert all the node coordinates from <code>Point</code> objects to <code>PlanePartitionSimple</code> objects. In the process, the supplied offset is added to all those coordinates. Instead of returning a newly created array, the <code>PlanePartitionSimple</code>s are stored in the supplied array, starting from the supplied offset. If the array is shorter than required, an Exception will be thrown.
 * @param pps The array to which the resulting <code>PlanePartitionSimple</code>s are to be written, starting at <code>arrayOffset</code>.
 * @param nodeCoords The coordinates at which nodes are to be placed.
 * @param coordOffset The offset for the coordinates.
 * @param arrayOffset The offset for the array, pointing to the first EMPTY element.
 */
private void addNodeCoords(PlanePartitionSimple[] pps,Point[] nodeCoords,Point coordOffset,int arrayOffset){
  for (int i=0; i < nodeCoords.length; i++) {
    pps[i + arrayOffset]=new PlanePartitionSimple(new PlaneIdentifier(nodeCoords[i].getX() + coordOffset.getX(),nodeCoords[i].getY() + coordOffset.getY(),idSpace));
  }
}",0.5097250167672703
38527,"/** 
 * @return
 */
public String[] getConfigKeys(){
  return Util.mergeArrays(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},additionalConfigKeys);
}","/** 
 * Getter for the configuration keys. Returns ""KEY"", ""WIDTH"", ""HEIGHT"" as well as any additional configuration keys set by <code>setAdditionalConfigKeys()</code>.
 * @return A string array containing all the configuration keys.
 */
public String[] getConfigKeys(){
  return Util.mergeArrays(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},additionalConfigKeys);
}",0.6118067978533095
38528,"/** 
 * @return
 */
public String getKey(){
  return key;
}","/** 
 * Getter for the key of the particular <code>PlacementModel</code>.
 * @return The key of the <code>PlacementModel</code>.
 */
public String getKey(){
  return key;
}",0.5108225108225108
38529,"public void setAdditionalConfigKeys(String[] arr){
  additionalConfigKeys=arr;
}","/** 
 * Setter for the additional configuration keys. Those will be returned in addition to ""KEY"", ""WIDTH"", ""HEIGHT"" by <code>getConfigKeys()</code>.
 * @param arr The new additional configuration keys.
 */
public void setAdditionalConfigKeys(String[] arr){
  additionalConfigKeys=arr;
}",0.4359673024523161
38530,"/** 
 * @return
 */
public double getHeight(){
  return height;
}","/** 
 * Getter for the height of the field.
 * @return The height of field.
 */
public double getHeight(){
  return height;
}",0.6842105263157895
38531,"/** 
 * @return
 */
public String[] getConfigValues(){
  return Util.mergeArrays(new String[]{getKey(),Double.toString(getWidth()),Double.toString(getHeight())},additionalConfigValues);
}","/** 
 * Getter for the configuration values. Returns key, width and height as well as any additional configuration keys set by <code>setAdditionalConfigValues()</code>.
 * @return A string array containing all the configuration values.
 */
public String[] getConfigValues(){
  return Util.mergeArrays(new String[]{getKey(),Double.toString(getWidth()),Double.toString(getHeight())},additionalConfigValues);
}",0.6296296296296297
38532,"public void setAdditionalConfigValues(String[] arr){
  additionalConfigValues=arr;
}","/** 
 * Setter for the additional configuration values. Those will be returned in addition to the key, the width and the height by <code>getConfigValues()</code>.
 * @param arr The new additional configuration values.
 */
public void setAdditionalConfigValues(String[] arr){
  additionalConfigValues=arr;
}",0.4307692307692308
38533,"/** 
 * @return
 */
public double getWidth(){
  return width;
}","/** 
 * Getter for the width of the field.
 * @return The width of the field.
 */
public double getWidth(){
  return width;
}",0.6702127659574468
38534,"public void setHeight(double height){
  this.height=height;
}","/** 
 * Setter for the height of the field.
 * @param height The new height of the field.
 */
public void setHeight(double height){
  this.height=height;
}",0.5648148148148148
38535,"public void setWidth(double width){
  this.width=width;
}","/** 
 * Setter for the width of the field.
 * @param width The new width of the field.
 */
public void setWidth(double width){
  this.width=width;
}",0.5560975609756098
38536,"public void setKey(String key){
  this.key=key;
}","/** 
 * Setter for the key of the particular <code>PlacementModel</code>.
 * @param key The new key of the <code>PlacementModel</code>.
 */
public void setKey(String key){
  this.key=key;
}",0.4117647058823529
38537,"private void firstWalk(int node){
  np[node]=new NodeParameter();
  np[node].d=0;
  double s=0;
  int[] sons=tree.getChildren(node);
  for (  int k : sons) {
    firstWalk(k);
    np[node].d=Math.max(np[node].d,np[k].r);
    np[k].alpha=Math.atan(np[k].r / (np[node].d + np[k].r));
    s+=np[k].alpha;
  }
  adjustChildren(node,s);
  setRadius(node);
}","private void firstWalk(int node){
  np[node]=new NodeParameter();
  np[node].d=0;
  double s=0;
  int[] sons=tree.getChildren(node);
  for (  int k : sons) {
    firstWalk(k);
    np[node].d=Math.max(np[node].d,np[k].r);
  }
  for (  int k : sons) {
    np[k].alpha=Math.atan(np[k].r / (np[node].d + np[k].r));
    s+=np[k].alpha;
  }
  adjustChildren(node,s);
  setRadius(node);
}",0.96043656207367
38538,"private void secondWalk(int node,double x,double y,double lambda,double theta){
  nodePositionsX[node]=x;
  nodePositionsY[node]=y;
  double dd=lambda * np[node].d;
  double gamma=theta + Math.PI;
  double freeSpace=np[node].f / (tree.getChildren(node).length + 1);
  double previous=0;
  double currAlpha, currRadius;
  for (  int singleSon : tree.getChildren(node)) {
    currAlpha=np[node].c * np[singleSon].alpha;
    currRadius=np[node].d * (Math.tan(currAlpha) / (1 - Math.tan(currAlpha)));
    gamma=(gamma + previous + np[singleSon].alpha+ freeSpace);
    double kX=(lambda * currRadius + dd) * Math.cos(gamma);
    double kY=(lambda * currRadius + dd) * Math.sin(gamma);
    previous=np[singleSon].alpha;
    secondWalk(singleSon,kX + x,kY + y,lambda * (currRadius / np[singleSon].r),gamma);
  }
}","private void secondWalk(int node,double x,double y,double lambda,double theta){
  nodePositionsX[node]=x;
  nodePositionsY[node]=y;
  int[] children=tree.getChildren(node);
  double dd=lambda * np[node].d;
  double gamma=theta + Math.PI;
  double freeSpace=np[node].f / children.length;
  double previous=0;
  double currAlpha, currRadius;
  for (  int singleSon : children) {
    currAlpha=np[node].c * np[singleSon].alpha;
    currRadius=np[node].d * (Math.tan(currAlpha) / (1 - Math.tan(currAlpha)));
    gamma=gamma + previous + np[singleSon].alpha+ freeSpace;
    double kX=(lambda * currRadius + dd) * Math.cos(gamma);
    double kY=(lambda * currRadius + dd) * Math.sin(gamma);
    previous=np[singleSon].alpha;
    secondWalk(singleSon,kX + x,kY + y,lambda * (currRadius / np[singleSon].r),gamma);
  }
}",0.608534322820037
38539,"@Override public Graph transform(Graph graph){
  Random rand=new Random();
  ChordIdentifierSpace idSpace=new ChordIdentifierSpace(this.bits);
  for (int r=0; r < this.realities; r++) {
    ChordIdentifier[] ids=new ChordIdentifier[graph.getNodes().length];
    if (this.uniform) {
      BigInteger stepSize=idSpace.getModulus().divide(new BigInteger(""String_Node_Str"" + graph.getNodes().length));
      for (int i=0; i < ids.length; i++) {
        ids[i]=new ChordIdentifier(idSpace,stepSize.multiply(new BigInteger(""String_Node_Str"" + i)));
      }
    }
 else {
      HashSet<String> idSet=new HashSet<String>();
      for (int i=0; i < ids.length; i++) {
        ChordIdentifier id=(ChordIdentifier)idSpace.randomID(rand);
        while (idSet.contains(id.toString())) {
          id=(ChordIdentifier)idSpace.randomID(rand);
        }
        ids[i]=id;
        idSet.add(id.toString());
      }
    }
    Arrays.sort(ids);
    ChordPartition[] partitions=new ChordPartition[ids.length];
    partitions[0]=new ChordPartition(ids[ids.length - 1],ids[0]);
    for (int i=1; i < partitions.length; i++) {
      partitions[i]=new ChordPartition(ids[i - 1],ids[i]);
    }
    idSpace.setPartitions(partitions);
    graph.addProperty(graph.getNextKey(""String_Node_Str""),idSpace);
  }
  return graph;
}","@Override public Graph transform(Graph graph){
  Random rand=new Random();
  for (int r=0; r < this.realities; r++) {
    ChordIdentifierSpace idSpace=new ChordIdentifierSpace(this.bits);
    ChordIdentifier[] ids=new ChordIdentifier[graph.getNodes().length];
    if (this.uniform) {
      BigInteger stepSize=idSpace.getModulus().divide(new BigInteger(""String_Node_Str"" + graph.getNodes().length));
      for (int i=0; i < ids.length; i++) {
        ids[i]=new ChordIdentifier(idSpace,stepSize.multiply(new BigInteger(""String_Node_Str"" + i)));
      }
    }
 else {
      HashSet<String> idSet=new HashSet<String>();
      for (int i=0; i < ids.length; i++) {
        ChordIdentifier id=(ChordIdentifier)idSpace.randomID(rand);
        while (idSet.contains(id.toString())) {
          id=(ChordIdentifier)idSpace.randomID(rand);
        }
        ids[i]=id;
        idSet.add(id.toString());
      }
    }
    Arrays.sort(ids);
    ChordPartition[] partitions=new ChordPartition[ids.length];
    partitions[0]=new ChordPartition(ids[ids.length - 1],ids[0]);
    for (int i=1; i < partitions.length; i++) {
      partitions[i]=new ChordPartition(ids[i - 1],ids[i]);
    }
    idSpace.setPartitions(partitions);
    graph.addProperty(graph.getNextKey(""String_Node_Str""),idSpace);
  }
  return graph;
}",0.946923076923077
38540,"public static void main(String[] args){
  Stats stats=new Stats();
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  Config.overwrite(""String_Node_Str"",""String_Node_Str"" + true);
  Transformation[] sTArray;
  BFS bfs=new BFS(""String_Node_Str"");
  RoutingAlgorithm rA=new GreedyBacktracking(25);
  Transformation[] t=new Transformation[]{new CanonicalCircularCrossing(1,100,true,null),new SixTollis(1,100,true,null),new WetherellShannon(100,100,null),new Knuth(100,100,null),new MelanconHerman(100,100,null),new BubbleTree(100,100,null),new FruchtermanReingold(1,new double[]{100,100},false,100,null)};
  for (  Transformation sT : t) {
    if (sT instanceof HierarchicalAbstract) {
      sTArray=new Transformation[]{bfs,sT};
    }
 else {
      sTArray=new Transformation[]{sT};
    }
    Network[] nw=new Network[]{new ErdosRenyi(500,10,true,rA,sTArray),new BarabasiAlbert(500,10,rA,sTArray),new ReadableFile(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",rA,sTArray)};
    for (    Network sN : nw) {
      Series[] s=Series.generate(nw,50);
    }
  }
  stats.end();
}","public static void main(String[] args){
  Stats stats=new Stats();
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  Config.overwrite(""String_Node_Str"",""String_Node_Str"" + true);
  Transformation[] sTArray;
  BFS bfs=new BFS(""String_Node_Str"");
  RoutingAlgorithm rA=new GreedyBacktracking(25);
  Transformation[] t=new Transformation[]{new CanonicalCircularCrossing(1,100,true,null),new SixTollis(1,100,true,null),new WetherellShannon(100,100,null),new Knuth(100,100,null),new MelanconHerman(100,100,null),new BubbleTree(100,100,null),new FruchtermanReingold(1,new double[]{100,100},false,100,null)};
  for (  Transformation sT : t) {
    if (sT instanceof HierarchicalAbstract) {
      sTArray=new Transformation[]{bfs,sT};
    }
 else {
      sTArray=new Transformation[]{sT};
    }
    Network[] nw=new Network[]{new ErdosRenyi(500,10,true,rA,sTArray),new BarabasiAlbert(500,10,rA,sTArray),new ReadableFile(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",rA,sTArray)};
    Series[] s=Series.generate(nw,50);
  }
  stats.end();
}",0.9733441033925686
38541,"public Graph generate(){
  Graph graph=new Graph(this.description());
  Random rand=new Random(System.currentTimeMillis());
  Node[] nodes=Node.init(this.nodes(),graph);
  int[] in=new int[nodes.length];
  int[] out=new int[nodes.length];
  int initNodes=Math.max(this.INIT_NETWORK_SIZE,this.EDGES_PER_NODE + 5);
  int initEdges=initNodes * this.EDGES_PER_NODE;
  Graph temp=new ErdosRenyi(initNodes,initEdges,true,this.routingAlgorithm(),this.transformations()).generate();
  Edges edges=new Edges(nodes,initEdges + (nodes.length - initNodes) * this.EDGES_PER_NODE);
  for (int i=0; i < temp.getNodes().length; i++) {
    in[i]=temp.getNodes()[i].getInDegree();
    out[i]=temp.getNodes()[i].getOutDegree();
    int[] Out=temp.getNodes()[i].getOutgoingEdges();
    for (int j=0; j < Out.length; j++) {
      edges.add(i,Out[j]);
    }
  }
  int edgeCounter=initEdges;
  for (int i=initNodes; i < nodes.length; i++) {
    int added=0;
    while (added < this.EDGES_PER_NODE) {
      int dest=rand.nextInt(i);
      if (edges.contains(i,dest)) {
        continue;
      }
      double pi=(double)(in[i] + out[i]) / (double)(2 * edgeCounter);
      if (rand.nextDouble() <= pi) {
        in[i]++;
        out[i]++;
        in[dest]++;
        out[dest]++;
        edgeCounter++;
        added++;
      }
    }
  }
  edges.fill();
  graph.setNodes(nodes);
  return graph;
}","public Graph generate(){
  System.out.println(""String_Node_Str"");
  Graph graph=new Graph(this.description());
  Random rand=new Random(System.currentTimeMillis());
  Node[] nodes=Node.init(this.nodes(),graph);
  int[] in=new int[nodes.length];
  int[] out=new int[nodes.length];
  int initNodes=Math.max(this.INIT_NETWORK_SIZE,this.EDGES_PER_NODE + 5);
  int initEdges=initNodes * this.EDGES_PER_NODE;
  Graph temp=new ErdosRenyi(initNodes,this.EDGES_PER_NODE,true,this.routingAlgorithm(),this.transformations()).generate();
  Edges edges=new Edges(nodes,initEdges + (nodes.length - initNodes) * this.EDGES_PER_NODE);
  for (int i=0; i < temp.getNodes().length; i++) {
    in[i]=temp.getNodes()[i].getInDegree();
    out[i]=temp.getNodes()[i].getOutDegree();
    int[] Out=temp.getNodes()[i].getOutgoingEdges();
    for (int j=0; j < Out.length; j++) {
      edges.add(i,Out[j]);
    }
  }
  int edgeCounter=initEdges;
  for (int i=initNodes; i < nodes.length; i++) {
    int added=0;
    double[] rands=new double[this.EDGES_PER_NODE];
    for (int j=0; j < rands.length; j++) {
      rands[j]=rand.nextDouble() * 2 * edgeCounter;
    }
    Arrays.sort(rands);
    double sum2=0;
    int current=0;
    while (added < rands.length && current < i) {
      sum2=sum2 + (double)(in[current] + out[current]);
      if (sum2 >= rands[added]) {
        edges.add(i,current);
        edges.add(current,i);
        added++;
        in[i]++;
        out[i]++;
        in[current]++;
        out[current]++;
        edgeCounter++;
      }
      current++;
    }
  }
  edges.fill();
  graph.setNodes(nodes);
  return graph;
}",0.3328868050904219
38542,"public int calculateCrossings(Node n,Node m,IdentifierSpace idSpace){
  int numCross=0;
  Edge[] nEdges=n.generateAllEdges();
  Edge[] mEdges=m.generateAllEdges();
  handledEdges=new HashSet<String>();
  for (  Edge nEdge : nEdges) {
    for (    Edge mEdge : mEdges) {
      if (hasCrossing(nEdge,mEdge,idSpace,true))       numCross++;
    }
  }
  return numCross;
}","public int calculateCrossings(Node n,Node m,IdentifierSpace idSpace){
  int numCross=0;
  Edge[] nEdges=n.generateAllEdges();
  Edge[] mEdges=m.generateAllEdges();
  handledEdges=new HashSet<String>();
  partitions=idSpace.getPartitions();
  for (  Edge nEdge : nEdges) {
    for (    Edge mEdge : mEdges) {
      if (hasCrossing(nEdge,mEdge,idSpace,true))       numCross++;
    }
  }
  return numCross;
}",0.9507772020725388
38543,"@Override public Graph transform(Graph g){
  initIDSpace(g);
  if (graphPlotter != null)   graphPlotter.plotStartGraph(g,idSpace);
  EdgeCrossings ec=new EdgeCrossings();
  int countCrossings;
  countCrossings=ec.calculateCrossings(g.generateEdges(),idSpace,true);
  System.out.println(""String_Node_Str"" + countCrossings);
  this.g=g;
  edges=new Edge[g.getNodes().length][];
  Node tempNode=null;
  Node currentNode=null;
  Node lastNode=null;
  Node randDst1, randDst2;
  Edge tempEdge;
  String tempEdgeString;
  removalList=new HashMap<String,Edge>();
  HashMap<String,Edge> pairEdges=null;
  removedNodes=new ArrayList<Node>();
  waveCenterNodes=new TreeSet<Node>(new NodeComparator());
  waveFrontNodes=new TreeSet<Node>(new NodeComparator());
  additionalEdges=new HashMap[g.getNodes().length];
  for (int i=0; i < g.getNodes().length; i++) {
    additionalEdges[i]=new HashMap<String,Edge>();
  }
  nodeList=Arrays.asList(g.getNodes().clone());
  Collections.sort(nodeList,new NodeDegreeComparator());
  for (int counter=1; counter < (nodeList.size() - 3); counter++) {
    currentNode=getNode();
    pairEdges=getPairEdges(currentNode);
    for (    Edge singleEdge : pairEdges.values()) {
      removalList.put(getEdgeString(singleEdge),singleEdge);
    }
    HashMap<String,Edge> currentNodeConnections=getEdges(currentNode);
    int currentNodeDegree=currentNodeConnections.size();
    int triangulationEdgesCount=(currentNodeDegree - 1) - pairEdges.size();
    int[] outgoingEdges=filterOutgoingEdges(currentNode,currentNodeConnections);
    int firstCounter=0;
    int secondCounter=1;
    while (triangulationEdgesCount > 0) {
      randDst1=g.getNode(outgoingEdges[firstCounter]);
      randDst2=g.getNode(outgoingEdges[secondCounter]);
      if (randDst1.equals(randDst2))       continue;
      if (removedNodes.contains(randDst1) || removedNodes.contains(randDst2)) {
        continue;
      }
      if (!connected(randDst1,randDst2)) {
        tempEdge=new Edge(Math.min(randDst1.getIndex(),randDst2.getIndex()),Math.max(randDst1.getIndex(),randDst2.getIndex()));
        tempEdgeString=getEdgeString(tempEdge);
        if (randDst1.getIndex() != randDst2.getIndex() && !additionalEdges[randDst1.getIndex()].containsKey(tempEdgeString)) {
          additionalEdges[randDst1.getIndex()].put(tempEdgeString,tempEdge);
          additionalEdges[randDst2.getIndex()].put(tempEdgeString,tempEdge);
          triangulationEdgesCount--;
        }
      }
 else {
      }
      secondCounter++;
      if (secondCounter == (currentNodeDegree - 1)) {
        firstCounter++;
        secondCounter=firstCounter + 1;
      }
      if (firstCounter == (currentNodeDegree - 1))       throw new RuntimeException(""String_Node_Str"" + currentNode.getIndex());
    }
    waveFrontNodes=new TreeSet<Node>(new NodeComparator());
    for (    Edge i : getEdges(currentNode).values()) {
      int otherEnd;
      if (i.getDst() == currentNode.getIndex()) {
        otherEnd=i.getSrc();
      }
 else {
        otherEnd=i.getDst();
      }
      tempNode=g.getNode(otherEnd);
      if (removedNodes.contains(tempNode)) {
        continue;
      }
      waveFrontNodes.add(tempNode);
      waveCenterNodes.add(tempNode);
    }
    lastNode=currentNode;
    removedNodes.add(currentNode);
  }
  LinkedList<Node> longestPath=longestPath();
  ArrayList<Node> todoList=new ArrayList<Node>();
  todoList.addAll(nodeList);
  todoList.removeAll(longestPath);
  Node neighbor, singleNode;
  int neighborPosition=-1;
  int errors=0;
  int modCounter=0;
  while (!todoList.isEmpty()) {
    singleNode=todoList.get(modCounter % todoList.size());
    for (    int singleNeighbor : singleNode.getOutgoingEdges()) {
      neighbor=g.getNode(singleNeighbor);
      neighborPosition=longestPath.indexOf(neighbor);
      if (neighborPosition > -1) {
        break;
      }
    }
    if (neighborPosition != -1) {
      todoList.remove(singleNode);
      longestPath.add(neighborPosition,singleNode);
    }
 else {
      modCounter=(modCounter + 1) % todoList.size();
      if (errors++ == 50) {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
  }
  double lastPos=0;
  double posDiff=modulus / partitions.length;
  RingIdentifier[] ids=new RingIdentifier[g.getNodes().length];
  for (  Node n : longestPath) {
    ids[n.getIndex()]=new RingIdentifier(lastPos,idSpace);
    lastPos+=posDiff;
  }
  lastNode=longestPath.getLast();
  for (  Node n : longestPath) {
    partitions[n.getIndex()]=new RingPartition(ids[lastNode.getIndex()],ids[n.getIndex()]);
    lastNode=n;
  }
  countCrossings=ec.calculateCrossings(g.generateEdges(),idSpace,true);
  System.out.println(""String_Node_Str"" + countCrossings);
  if (graphPlotter != null)   graphPlotter.plot(g,idSpace,graphPlotter.getBasename() + ""String_Node_Str"");
  reduceCrossingsBySwapping(g);
  writeIDSpace(g);
  if (graphPlotter != null)   graphPlotter.plotFinalGraph(g,idSpace);
  countCrossings=ec.calculateCrossings(g.generateEdges(),idSpace,true);
  System.out.println(""String_Node_Str"" + countCrossings);
  return g;
}","@Override public Graph transform(Graph g){
  initIDSpace(g);
  if (graphPlotter != null)   graphPlotter.plotStartGraph(g,idSpace);
  EdgeCrossings ec=new EdgeCrossings();
  int countCrossings=-1;
  System.out.println(""String_Node_Str"" + countCrossings);
  this.g=g;
  edges=new Edge[g.getNodes().length][];
  Node tempNode=null;
  Node currentNode=null;
  Node lastNode=null;
  Node randDst1, randDst2;
  Edge tempEdge;
  String tempEdgeString;
  removalList=new HashMap<String,Edge>();
  HashMap<String,Edge> pairEdges=null;
  removedNodes=new ArrayList<Node>();
  waveCenterNodes=new TreeSet<Node>(new NodeComparator());
  waveFrontNodes=new TreeSet<Node>(new NodeComparator());
  additionalEdges=new HashMap[g.getNodes().length];
  for (int i=0; i < g.getNodes().length; i++) {
    additionalEdges[i]=new HashMap<String,Edge>();
  }
  nodeList=Arrays.asList(g.getNodes().clone());
  Collections.sort(nodeList,new NodeDegreeComparator());
  for (int counter=1; counter < (nodeList.size() - 3); counter++) {
    currentNode=getNode();
    pairEdges=getPairEdges(currentNode);
    for (    Edge singleEdge : pairEdges.values()) {
      removalList.put(getEdgeString(singleEdge),singleEdge);
    }
    HashMap<String,Edge> currentNodeConnections=getEdges(currentNode);
    int currentNodeDegree=currentNodeConnections.size();
    int triangulationEdgesCount=(currentNodeDegree - 1) - pairEdges.size();
    int[] outgoingEdges=filterOutgoingEdges(currentNode,currentNodeConnections);
    int firstCounter=0;
    int secondCounter=0;
    while (triangulationEdgesCount > 0) {
      secondCounter++;
      if (secondCounter == currentNodeDegree) {
        firstCounter++;
        secondCounter=firstCounter;
      }
      if (firstCounter == (currentNodeDegree - 1))       throw new RuntimeException(""String_Node_Str"" + currentNode.getIndex() + ""String_Node_Str""+ currentNodeDegree);
      randDst1=g.getNode(outgoingEdges[firstCounter]);
      randDst2=g.getNode(outgoingEdges[secondCounter]);
      if (randDst1.equals(randDst2)) {
        continue;
      }
      if (removedNodes.contains(randDst1) || removedNodes.contains(randDst2)) {
        continue;
      }
      if (!connected(randDst1,randDst2)) {
        tempEdge=new Edge(Math.min(randDst1.getIndex(),randDst2.getIndex()),Math.max(randDst1.getIndex(),randDst2.getIndex()));
        tempEdgeString=getEdgeString(tempEdge);
        if (randDst1.getIndex() != randDst2.getIndex() && !additionalEdges[randDst1.getIndex()].containsKey(tempEdgeString)) {
          additionalEdges[randDst1.getIndex()].put(tempEdgeString,tempEdge);
          additionalEdges[randDst2.getIndex()].put(tempEdgeString,tempEdge);
          triangulationEdgesCount--;
        }
      }
 else {
      }
    }
    waveFrontNodes=new TreeSet<Node>(new NodeComparator());
    for (    Edge i : getEdges(currentNode).values()) {
      int otherEnd;
      if (i.getDst() == currentNode.getIndex()) {
        otherEnd=i.getSrc();
      }
 else {
        otherEnd=i.getDst();
      }
      tempNode=g.getNode(otherEnd);
      if (removedNodes.contains(tempNode)) {
        continue;
      }
      waveFrontNodes.add(tempNode);
      waveCenterNodes.add(tempNode);
    }
    lastNode=currentNode;
    removedNodes.add(currentNode);
    System.out.println(""String_Node_Str"" + currentNode.getIndex() + ""String_Node_Str"");
  }
  LinkedList<Node> longestPath=longestPath();
  ArrayList<Node> todoList=new ArrayList<Node>();
  todoList.addAll(nodeList);
  todoList.removeAll(longestPath);
  Node neighbor, singleNode;
  int neighborPosition=-1;
  int errors=0;
  int modCounter=0;
  while (!todoList.isEmpty()) {
    singleNode=todoList.get(modCounter % todoList.size());
    for (    int singleNeighbor : singleNode.getOutgoingEdges()) {
      neighbor=g.getNode(singleNeighbor);
      neighborPosition=longestPath.indexOf(neighbor);
      if (neighborPosition > -1) {
        break;
      }
    }
    if (neighborPosition != -1) {
      todoList.remove(singleNode);
      longestPath.add(neighborPosition,singleNode);
    }
 else {
      modCounter=(modCounter + 1) % todoList.size();
      if (errors++ == 50) {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
  }
  double lastPos=0;
  double posDiff=modulus / partitions.length;
  RingIdentifier[] ids=new RingIdentifier[g.getNodes().length];
  for (  Node n : longestPath) {
    ids[n.getIndex()]=new RingIdentifier(lastPos,idSpace);
    lastPos+=posDiff;
  }
  lastNode=longestPath.getLast();
  for (  Node n : longestPath) {
    partitions[n.getIndex()]=new RingPartition(ids[lastNode.getIndex()],ids[n.getIndex()]);
    lastNode=n;
  }
  System.out.println(""String_Node_Str"" + countCrossings);
  if (graphPlotter != null)   graphPlotter.plot(g,idSpace,graphPlotter.getBasename() + ""String_Node_Str"");
  reduceCrossingsBySwapping(g);
  writeIDSpace(g);
  if (graphPlotter != null)   graphPlotter.plotFinalGraph(g,idSpace);
  System.out.println(""String_Node_Str"" + countCrossings);
  return g;
}",0.8169350029815146
38544,"@Override public Graph transform(Graph g){
  initIDSpace(g);
  if (graphPlotter != null)   graphPlotter.plotStartGraph(g,idSpace);
  EdgeCrossings ec=new EdgeCrossings();
  int countCrossings=-1;
  System.out.println(""String_Node_Str"" + countCrossings);
  this.g=g;
  edges=new Edge[g.getNodes().length][];
  Node tempNode=null;
  Node currentNode=null;
  Node lastNode=null;
  Node randDst1, randDst2;
  Edge tempEdge;
  String tempEdgeString;
  removalList=new HashMap<String,Edge>();
  HashMap<String,Edge> pairEdges=null;
  removedNodes=new ArrayList<Node>();
  waveCenterNodes=new TreeSet<Node>(new NodeComparator());
  waveFrontNodes=new TreeSet<Node>(new NodeComparator());
  additionalEdges=new HashMap[g.getNodes().length];
  for (int i=0; i < g.getNodes().length; i++) {
    additionalEdges[i]=new HashMap<String,Edge>();
  }
  nodeList=Arrays.asList(g.getNodes().clone());
  Collections.sort(nodeList,new NodeDegreeComparator());
  for (int counter=1; counter < (nodeList.size() - 3); counter++) {
    currentNode=getNode();
    pairEdges=getPairEdges(currentNode);
    for (    Edge singleEdge : pairEdges.values()) {
      removalList.put(getEdgeString(singleEdge),singleEdge);
    }
    HashMap<String,Edge> currentNodeConnections=getEdges(currentNode);
    int currentNodeDegree=currentNodeConnections.size();
    int triangulationEdgesCount=(currentNodeDegree - 1) - pairEdges.size();
    int[] outgoingEdges=filterOutgoingEdges(currentNode,currentNodeConnections);
    int firstCounter=0;
    int secondCounter=1;
    while (triangulationEdgesCount > 0) {
      randDst1=g.getNode(outgoingEdges[firstCounter]);
      randDst2=g.getNode(outgoingEdges[secondCounter]);
      if (!randDst1.equals(randDst2) && !removedNodes.contains(randDst1) && !removedNodes.contains(randDst2)) {
        if (!connected(randDst1,randDst2)) {
          tempEdge=new Edge(Math.min(randDst1.getIndex(),randDst2.getIndex()),Math.max(randDst1.getIndex(),randDst2.getIndex()));
          tempEdgeString=getEdgeString(tempEdge);
          if (randDst1.getIndex() != randDst2.getIndex() && !additionalEdges[randDst1.getIndex()].containsKey(tempEdgeString)) {
            additionalEdges[randDst1.getIndex()].put(tempEdgeString,tempEdge);
            additionalEdges[randDst2.getIndex()].put(tempEdgeString,tempEdge);
            triangulationEdgesCount--;
          }
        }
 else {
        }
      }
      secondCounter++;
      if (secondCounter == (currentNodeDegree)) {
        firstCounter++;
        secondCounter=firstCounter + 1;
      }
      if (firstCounter == (currentNodeDegree - 1) && triangulationEdgesCount > 0)       throw new RuntimeException(""String_Node_Str"" + currentNode.getIndex());
    }
    waveFrontNodes=new TreeSet<Node>(new NodeComparator());
    for (    Edge i : getEdges(currentNode).values()) {
      int otherEnd;
      if (i.getDst() == currentNode.getIndex()) {
        otherEnd=i.getSrc();
      }
 else {
        otherEnd=i.getDst();
      }
      tempNode=g.getNode(otherEnd);
      if (removedNodes.contains(tempNode)) {
        continue;
      }
      waveFrontNodes.add(tempNode);
      waveCenterNodes.add(tempNode);
    }
    lastNode=currentNode;
    removedNodes.add(currentNode);
  }
  LinkedList<Node> longestPath=longestPath();
  ArrayList<Node> todoList=new ArrayList<Node>();
  todoList.addAll(nodeList);
  todoList.removeAll(longestPath);
  Node neighbor, singleNode;
  int neighborPosition=-1;
  int errors=0;
  int modCounter=0;
  while (!todoList.isEmpty()) {
    singleNode=todoList.get(modCounter % todoList.size());
    for (    int singleNeighbor : singleNode.getOutgoingEdges()) {
      neighbor=g.getNode(singleNeighbor);
      neighborPosition=longestPath.indexOf(neighbor);
      if (neighborPosition > -1) {
        break;
      }
    }
    if (neighborPosition != -1) {
      todoList.remove(singleNode);
      longestPath.add(neighborPosition,singleNode);
    }
 else {
      modCounter=(modCounter + 1) % todoList.size();
      if (errors++ == 50) {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
  }
  double lastPos=0;
  double posDiff=modulus / partitions.length;
  RingIdentifier[] ids=new RingIdentifier[g.getNodes().length];
  for (  Node n : longestPath) {
    ids[n.getIndex()]=new RingIdentifier(lastPos,idSpace);
    lastPos+=posDiff;
  }
  lastNode=longestPath.getLast();
  for (  Node n : longestPath) {
    partitions[n.getIndex()]=new RingPartition(ids[lastNode.getIndex()],ids[n.getIndex()]);
    lastNode=n;
  }
  System.out.println(""String_Node_Str"" + countCrossings);
  if (graphPlotter != null)   graphPlotter.plot(g,idSpace,graphPlotter.getBasename() + ""String_Node_Str"");
  reduceCrossingsBySwapping(g);
  writeIDSpace(g);
  if (graphPlotter != null)   graphPlotter.plotFinalGraph(g,idSpace);
  System.out.println(""String_Node_Str"" + countCrossings);
  return g;
}","@Override public Graph transform(Graph g){
  useOriginalGraphWithoutRemovalList=false;
  initIDSpace(g);
  if (graphPlotter != null)   graphPlotter.plotStartGraph(g,idSpace);
  EdgeCrossings ec=new EdgeCrossings();
  int countCrossings=-1;
  System.out.println(""String_Node_Str"" + countCrossings);
  this.g=g;
  edges=new Edge[g.getNodes().length][];
  Node tempNode=null;
  Node currentNode=null;
  Node lastNode=null;
  Node randDst1, randDst2;
  Edge tempEdge;
  String tempEdgeString;
  removalList=new HashMap<String,Edge>();
  HashMap<String,Edge> pairEdges=null;
  removedNodes=new ArrayList<Node>();
  waveCenterNodes=new TreeSet<Node>(new NodeComparator());
  waveFrontNodes=new TreeSet<Node>(new NodeComparator());
  additionalEdges=new HashMap[g.getNodes().length];
  for (int i=0; i < g.getNodes().length; i++) {
    additionalEdges[i]=new HashMap<String,Edge>();
  }
  nodeList=Arrays.asList(g.getNodes().clone());
  Collections.sort(nodeList,new NodeDegreeComparator());
  for (int counter=1; counter < (nodeList.size() - 3); counter++) {
    currentNode=getNode();
    pairEdges=getPairEdges(currentNode);
    for (    Edge singleEdge : pairEdges.values()) {
      removalList.put(getEdgeString(singleEdge),singleEdge);
    }
    HashMap<String,Edge> currentNodeConnections=getEdges(currentNode);
    int currentNodeDegree=currentNodeConnections.size();
    int triangulationEdgesCount=(currentNodeDegree - 1) - pairEdges.size();
    int[] outgoingEdges=filterOutgoingEdges(currentNode,currentNodeConnections);
    int firstCounter=0;
    int secondCounter=1;
    while (triangulationEdgesCount > 0) {
      randDst1=g.getNode(outgoingEdges[firstCounter]);
      randDst2=g.getNode(outgoingEdges[secondCounter]);
      if (!randDst1.equals(randDst2) && !removedNodes.contains(randDst1) && !removedNodes.contains(randDst2)) {
        if (!connected(randDst1,randDst2)) {
          tempEdge=new Edge(Math.min(randDst1.getIndex(),randDst2.getIndex()),Math.max(randDst1.getIndex(),randDst2.getIndex()));
          tempEdgeString=getEdgeString(tempEdge);
          if (randDst1.getIndex() != randDst2.getIndex() && !additionalEdges[randDst1.getIndex()].containsKey(tempEdgeString)) {
            additionalEdges[randDst1.getIndex()].put(tempEdgeString,tempEdge);
            additionalEdges[randDst2.getIndex()].put(tempEdgeString,tempEdge);
            triangulationEdgesCount--;
          }
        }
 else {
        }
      }
      secondCounter++;
      if (secondCounter == (currentNodeDegree)) {
        firstCounter++;
        secondCounter=firstCounter + 1;
      }
      if (firstCounter == (currentNodeDegree - 1) && triangulationEdgesCount > 0)       throw new RuntimeException(""String_Node_Str"" + currentNode.getIndex());
    }
    waveFrontNodes=new TreeSet<Node>(new NodeComparator());
    for (    Edge i : getEdges(currentNode).values()) {
      int otherEnd;
      if (i.getDst() == currentNode.getIndex()) {
        otherEnd=i.getSrc();
      }
 else {
        otherEnd=i.getDst();
      }
      tempNode=g.getNode(otherEnd);
      if (removedNodes.contains(tempNode)) {
        continue;
      }
      waveFrontNodes.add(tempNode);
      waveCenterNodes.add(tempNode);
    }
    lastNode=currentNode;
    removedNodes.add(currentNode);
  }
  LinkedList<Node> longestPath=longestPath();
  ArrayList<Node> todoList=new ArrayList<Node>();
  todoList.addAll(nodeList);
  todoList.removeAll(longestPath);
  Node neighbor, singleNode;
  int neighborPosition=-1;
  int errors=0;
  int modCounter=0;
  while (!todoList.isEmpty()) {
    singleNode=todoList.get(modCounter % todoList.size());
    for (    int singleNeighbor : singleNode.getOutgoingEdges()) {
      neighbor=g.getNode(singleNeighbor);
      neighborPosition=longestPath.indexOf(neighbor);
      if (neighborPosition > -1) {
        break;
      }
    }
    if (neighborPosition != -1) {
      todoList.remove(singleNode);
      longestPath.add(neighborPosition,singleNode);
    }
 else {
      modCounter=(modCounter + 1) % todoList.size();
      if (errors++ == 50) {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
  }
  double lastPos=0;
  double posDiff=modulus / partitions.length;
  RingIdentifier[] ids=new RingIdentifier[g.getNodes().length];
  for (  Node n : longestPath) {
    ids[n.getIndex()]=new RingIdentifier(lastPos,idSpace);
    lastPos+=posDiff;
  }
  lastNode=longestPath.getLast();
  for (  Node n : longestPath) {
    partitions[n.getIndex()]=new RingPartition(ids[lastNode.getIndex()],ids[n.getIndex()]);
    lastNode=n;
  }
  System.out.println(""String_Node_Str"" + countCrossings);
  if (graphPlotter != null)   graphPlotter.plot(g,idSpace,graphPlotter.getBasename() + ""String_Node_Str"");
  reduceCrossingsBySwapping(g);
  writeIDSpace(g);
  if (graphPlotter != null)   graphPlotter.plotFinalGraph(g,idSpace);
  System.out.println(""String_Node_Str"" + countCrossings);
  return g;
}",0.9955010224948876
38545,"private void fill(int nodes,ArrayList<ParentChild> pcs){
  this.parent=Util.initIntArray(nodes,-1);
  this.children=new int[nodes][];
  this.depth=Util.initIntArray(nodes,-1);
  this.src=-1;
  int[] counter=new int[nodes];
  for (  ParentChild pc : pcs) {
    this.parent[pc.getChild()]=pc.getParent();
    this.depth[pc.getChild()]=pc.getDepth();
    counter[pc.getParent()]++;
  }
  for (int i=0; i < this.children.length; i++) {
    this.children[i]=new int[counter[i]];
  }
  for (  ParentChild pc : pcs) {
    this.children[pc.getParent()][this.children[pc.getParent()].length - counter[pc.getParent()]]=pc.getChild();
    counter[pc.getParent()]--;
  }
  for (int i=0; i < this.parent.length; i++) {
    if (this.parent[i] == -1) {
      this.src=i;
      this.depth[i]=0;
      break;
    }
  }
}","private void fill(int nodes,ArrayList<ParentChild> pcs){
  this.parent=Util.initIntArray(nodes,-1);
  this.children=new int[nodes][];
  this.depth=Util.initIntArray(nodes,-1);
  this.src=-1;
  int[] counter=new int[nodes];
  for (  ParentChild pc : pcs) {
    if (pc.getParent() == -1)     continue;
    this.parent[pc.getChild()]=pc.getParent();
    this.depth[pc.getChild()]=pc.getDepth();
    counter[pc.getParent()]++;
  }
  for (int i=0; i < this.children.length; i++) {
    this.children[i]=new int[counter[i]];
  }
  for (  ParentChild pc : pcs) {
    if (pc.getParent() == -1)     continue;
    this.children[pc.getParent()][this.children[pc.getParent()].length - counter[pc.getParent()]]=pc.getChild();
    counter[pc.getParent()]--;
  }
  for (int i=0; i < this.parent.length; i++) {
    if (this.parent[i] == -1) {
      this.src=i;
      this.depth[i]=0;
      break;
    }
  }
}",0.948051948051948
38546,"@Override public Graph transform(Graph graph){
  Node root=selectRoot(graph,rootSelector);
  Node tempNodeFromList;
  Integer[] edges;
  Node[] nodes=graph.getNodes();
  int depth;
  LinkedList<Node> todoList=new LinkedList<Node>();
  LinkedList<Integer> linkedNodes=new LinkedList<Integer>();
  HashMap<Integer,ParentChild> parentChildMap=new HashMap<Integer,ParentChild>();
  todoList.add(root);
  while (!todoList.isEmpty()) {
    tempNodeFromList=todoList.pop();
    if (linkedNodes.contains(tempNodeFromList.getIndex())) {
      continue;
    }
    ParentChild parent=parentChildMap.get(tempNodeFromList.getIndex());
    if (parent == null) {
      depth=1;
    }
 else {
      depth=parent.getDepth() + 1;
    }
    edges=tempNodeFromList.generateOutgoingEdgesByDegree();
    for (    int e : edges) {
      if (!linkedNodes.contains(e)) {
        todoList.add(nodes[e]);
        parentChildMap.put(e,new ParentChild(tempNodeFromList.getIndex(),e,depth));
      }
    }
    linkedNodes.add(tempNodeFromList.getIndex());
  }
  int graphNodeSize=graph.getNodes().length;
  int spanningTreeSize=parentChildMap.size();
  if ((spanningTreeSize + 1) < graphNodeSize) {
    throw new RuntimeException(""String_Node_Str"" + graphNodeSize + ""String_Node_Str""+ spanningTreeSize+ ""String_Node_Str"");
  }
  ArrayList<ParentChild> parentChildList=new ArrayList<ParentChild>();
  parentChildList.addAll(parentChildMap.values());
  SpanningTree result=new SpanningTree(graph,parentChildList);
  graph.addProperty(""String_Node_Str"",result);
  return graph;
}","@Override public Graph transform(Graph graph){
  Node root=selectRoot(graph,rootSelector);
  Node tempNodeFromList;
  Integer[] edges;
  Node[] nodes=graph.getNodes();
  int depth;
  LinkedList<Node> todoList=new LinkedList<Node>();
  HashMap<Integer,ParentChild> parentChildMap=new HashMap<Integer,ParentChild>();
  todoList.add(root);
  parentChildMap.put(root.getIndex(),new ParentChild(-1,root.getIndex(),0));
  while (!todoList.isEmpty()) {
    tempNodeFromList=todoList.pop();
    ParentChild parent=parentChildMap.get(tempNodeFromList.getIndex());
    if (parent == null) {
      depth=1;
    }
 else {
      depth=parent.getDepth() + 1;
    }
    edges=tempNodeFromList.generateOutgoingEdgesByDegree();
    for (    int e : edges) {
      if (!parentChildMap.containsKey(e)) {
        todoList.add(nodes[e]);
        parentChildMap.put(e,new ParentChild(tempNodeFromList.getIndex(),e,depth));
      }
    }
  }
  int graphNodeSize=graph.getNodes().length;
  int spanningTreeSize=parentChildMap.size();
  if ((spanningTreeSize + 1) < graphNodeSize) {
    throw new RuntimeException(""String_Node_Str"" + graphNodeSize + ""String_Node_Str""+ spanningTreeSize+ ""String_Node_Str"");
  }
  ArrayList<ParentChild> parentChildList=new ArrayList<ParentChild>();
  parentChildList.addAll(parentChildMap.values());
  SpanningTree result=new SpanningTree(graph,parentChildList);
  graph.addProperty(""String_Node_Str"",result);
  return graph;
}",0.8721905400872191
38547,"private void fill(int nodes,ArrayList<ParentChild> pcs){
  this.parent=Util.initIntArray(nodes,-1);
  this.children=new int[nodes][];
  this.depth=Util.initIntArray(nodes,0);
  this.src=-1;
  int[] counter=new int[nodes];
  for (  ParentChild pc : pcs) {
    this.parent[pc.getChild()]=pc.getParent();
    this.depth[pc.getChild()]=pc.getDepth();
    counter[pc.getParent()]++;
  }
  for (int i=0; i < this.children.length; i++) {
    this.children[i]=new int[counter[i]];
  }
  for (  ParentChild pc : pcs) {
    this.children[pc.getParent()][this.children[pc.getParent()].length - counter[pc.getParent()]]=pc.getChild();
    counter[pc.getParent()]--;
  }
  for (int i=0; i < this.parent.length; i++) {
    if (this.parent[i] == -1) {
      this.src=i;
      break;
    }
  }
}","private void fill(int nodes,ArrayList<ParentChild> pcs){
  this.parent=Util.initIntArray(nodes,-1);
  this.children=new int[nodes][];
  this.depth=Util.initIntArray(nodes,-1);
  this.src=-1;
  int[] counter=new int[nodes];
  for (  ParentChild pc : pcs) {
    this.parent[pc.getChild()]=pc.getParent();
    this.depth[pc.getChild()]=pc.getDepth();
    counter[pc.getParent()]++;
  }
  for (int i=0; i < this.children.length; i++) {
    this.children[i]=new int[counter[i]];
  }
  for (  ParentChild pc : pcs) {
    this.children[pc.getParent()][this.children[pc.getParent()].length - counter[pc.getParent()]]=pc.getChild();
    counter[pc.getParent()]--;
  }
  for (int i=0; i < this.parent.length; i++) {
    if (this.parent[i] == -1) {
      this.src=i;
      this.depth[i]=0;
      break;
    }
  }
}",0.965865992414665
38548,"@Override public Graph transform(Graph graph){
  Node root=selectRoot(graph,rootSelector);
  Node tempNodeFromList;
  int[] edges;
  Node[] nodes=graph.getNodes();
  int depth;
  LinkedList<Node> todoList=new LinkedList<Node>();
  LinkedList<Integer> handledNodes=new LinkedList<Integer>();
  LinkedList<Integer> linkedNodes=new LinkedList<Integer>();
  HashMap<Integer,ParentChild> parentChildMap=new HashMap<Integer,ParentChild>();
  todoList.add(root);
  linkedNodes.add(root.getIndex());
  while (!todoList.isEmpty()) {
    tempNodeFromList=todoList.pop();
    if (handledNodes.contains(tempNodeFromList.getIndex())) {
      continue;
    }
    ParentChild parent=parentChildMap.get(tempNodeFromList.getIndex());
    if (parent == null) {
      depth=0;
    }
 else {
      depth=parent.getDepth();
    }
    edges=tempNodeFromList.getOutgoingEdges();
    for (    int e : edges) {
      if (!linkedNodes.contains(e)) {
        todoList.add(nodes[e]);
        linkedNodes.add(e);
        parentChildMap.put(e,new ParentChild(tempNodeFromList.getIndex(),e,depth + 1));
      }
    }
    handledNodes.add(tempNodeFromList.getIndex());
  }
  int graphNodeSize=graph.getNodes().length;
  int spanningTreeSize=parentChildMap.size() + 1;
  if (spanningTreeSize < graphNodeSize) {
    throw new RuntimeException(""String_Node_Str"" + graphNodeSize + ""String_Node_Str""+ spanningTreeSize+ ""String_Node_Str"");
  }
  ArrayList<ParentChild> parentChildList=new ArrayList<ParentChild>();
  parentChildList.addAll(parentChildMap.values());
  SpanningTree result=new SpanningTree(graph,parentChildList);
  graph.addProperty(""String_Node_Str"",result);
  return graph;
}","@Override public Graph transform(Graph graph){
  Node root=selectRoot(graph,rootSelector);
  Node tempNodeFromList;
  int[] edges;
  Node[] nodes=graph.getNodes();
  int depth;
  LinkedList<Node> todoList=new LinkedList<Node>();
  LinkedList<Integer> handledNodes=new LinkedList<Integer>();
  LinkedList<Integer> linkedNodes=new LinkedList<Integer>();
  HashMap<Integer,ParentChild> parentChildMap=new HashMap<Integer,ParentChild>();
  todoList.add(root);
  linkedNodes.add(root.getIndex());
  while (!todoList.isEmpty()) {
    tempNodeFromList=todoList.pop();
    if (handledNodes.contains(tempNodeFromList.getIndex())) {
      continue;
    }
    ParentChild parent=parentChildMap.get(tempNodeFromList.getIndex());
    if (parent == null) {
      depth=1;
    }
 else {
      depth=parent.getDepth() + 1;
    }
    edges=tempNodeFromList.getOutgoingEdges();
    for (    int e : edges) {
      if (!linkedNodes.contains(e)) {
        todoList.add(nodes[e]);
        linkedNodes.add(e);
        parentChildMap.put(e,new ParentChild(tempNodeFromList.getIndex(),e,depth));
      }
    }
    handledNodes.add(tempNodeFromList.getIndex());
  }
  int graphNodeSize=graph.getNodes().length;
  int spanningTreeSize=parentChildMap.size() + 1;
  if (spanningTreeSize < graphNodeSize) {
    throw new RuntimeException(""String_Node_Str"" + graphNodeSize + ""String_Node_Str""+ spanningTreeSize+ ""String_Node_Str"");
  }
  ArrayList<ParentChild> parentChildList=new ArrayList<ParentChild>();
  parentChildList.addAll(parentChildMap.values());
  SpanningTree result=new SpanningTree(graph,parentChildList);
  graph.addProperty(""String_Node_Str"",result);
  return graph;
}",0.9969788519637462
38549,"@Override public Graph transform(Graph g){
  System.err.println(""String_Node_Str"");
  initIDSpace(g);
  this.g=g;
  Node tempNode=null;
  Node currentNode=null;
  Node lastNode=null;
  Node randDst1, randDst2;
  Edge tempEdge;
  String tempEdgeString;
  removalList=new HashMap<String,Edge>();
  HashMap<String,Edge> pairEdges=null;
  removedNodes=new TreeSet<Node>(new NodeComparator());
  waveCenterNodes=new TreeSet<Node>(new NodeComparator());
  waveFrontNodes=new TreeSet<Node>(new NodeComparator());
  additionalEdges=new HashMap[g.getNodes().length];
  for (int i=0; i < g.getNodes().length; i++) {
    additionalEdges[i]=new HashMap<String,Edge>();
  }
  nodeList=Arrays.asList(g.getNodes().clone());
  Collections.sort(nodeList,new NodeDegreeComparator());
  for (int counter=1; counter < (nodeList.size() - 3); counter++) {
    currentNode=getNode(lastNode);
    pairEdges=getPairEdges(currentNode);
    for (    Edge singleEdge : pairEdges.values()) {
      removalList.put(getEdgeString(singleEdge),singleEdge);
    }
    HashMap<String,Edge> currentNodeConnections=getEdges(currentNode);
    int currentNodeDegree=currentNodeConnections.size();
    int triangulationEdgesCount=(currentNodeDegree - 1) - pairEdges.size();
    int[] outgoingEdges=filterOutgoingEdges(currentNode,currentNodeConnections);
    int firstCounter=0;
    int secondCounter=1;
    while (triangulationEdgesCount > 0) {
      randDst1=g.getNode(outgoingEdges[firstCounter]);
      randDst2=g.getNode(outgoingEdges[secondCounter]);
      if (randDst1.equals(randDst2))       continue;
      if (removedNodes.contains(randDst1) || removedNodes.contains(randDst2)) {
        continue;
      }
      if (!connected(randDst1,randDst2)) {
        tempEdge=new Edge(Math.min(randDst1.getIndex(),randDst2.getIndex()),Math.max(randDst1.getIndex(),randDst2.getIndex()));
        tempEdgeString=getEdgeString(tempEdge);
        if (randDst1.getIndex() != randDst2.getIndex() && !additionalEdges[randDst1.getIndex()].containsKey(tempEdgeString)) {
          additionalEdges[randDst1.getIndex()].put(tempEdgeString,tempEdge);
          additionalEdges[randDst2.getIndex()].put(tempEdgeString,tempEdge);
          triangulationEdgesCount--;
        }
      }
 else {
      }
      secondCounter++;
      if (secondCounter == (currentNodeDegree - 1)) {
        firstCounter++;
        secondCounter=firstCounter + 1;
      }
      if (firstCounter == (currentNodeDegree - 1))       throw new RuntimeException(""String_Node_Str"" + currentNode.getIndex());
    }
    for (    Edge i : getEdges(currentNode).values()) {
      int otherEnd;
      if (i.getDst() == currentNode.getIndex()) {
        otherEnd=i.getSrc();
      }
 else {
        otherEnd=i.getDst();
      }
      tempNode=g.getNode(otherEnd);
      if (removedNodes.contains(tempNode)) {
        continue;
      }
      waveFrontNodes.add(tempNode);
      waveCenterNodes.add(tempNode);
    }
    lastNode=currentNode;
    removedNodes.add(currentNode);
  }
  LinkedList<Node> longestPath=longestPath();
  if (longestPath == null)   throw new RuntimeException(""String_Node_Str"");
  for (  Node n : nodeList)   System.out.println(n + ""String_Node_Str"" + n.getDegree());
  writeIDSpace(g);
  return g;
}","@Override public Graph transform(Graph g){
  System.err.println(""String_Node_Str"");
  initIDSpace(g);
  this.g=g;
  Node tempNode=null;
  Node currentNode=null;
  Node lastNode=null;
  Node randDst1, randDst2;
  Edge tempEdge;
  String tempEdgeString;
  removalList=new HashMap<String,Edge>();
  HashMap<String,Edge> pairEdges=null;
  removedNodes=new TreeSet<Node>(new NodeComparator());
  waveCenterNodes=new TreeSet<Node>(new NodeComparator());
  waveFrontNodes=new TreeSet<Node>(new NodeComparator());
  additionalEdges=new HashMap[g.getNodes().length];
  for (int i=0; i < g.getNodes().length; i++) {
    additionalEdges[i]=new HashMap<String,Edge>();
  }
  nodeList=Arrays.asList(g.getNodes().clone());
  Collections.sort(nodeList,new NodeDegreeComparator());
  for (int counter=1; counter < (nodeList.size() - 3); counter++) {
    currentNode=getNode(lastNode);
    pairEdges=getPairEdges(currentNode);
    for (    Edge singleEdge : pairEdges.values()) {
      removalList.put(getEdgeString(singleEdge),singleEdge);
    }
    HashMap<String,Edge> currentNodeConnections=getEdges(currentNode);
    int currentNodeDegree=currentNodeConnections.size();
    int triangulationEdgesCount=(currentNodeDegree - 1) - pairEdges.size();
    int[] outgoingEdges=filterOutgoingEdges(currentNode,currentNodeConnections);
    int firstCounter=0;
    int secondCounter=1;
    while (triangulationEdgesCount > 0) {
      randDst1=g.getNode(outgoingEdges[firstCounter]);
      randDst2=g.getNode(outgoingEdges[secondCounter]);
      if (randDst1.equals(randDst2))       continue;
      if (removedNodes.contains(randDst1) || removedNodes.contains(randDst2)) {
        continue;
      }
      if (!connected(randDst1,randDst2)) {
        tempEdge=new Edge(Math.min(randDst1.getIndex(),randDst2.getIndex()),Math.max(randDst1.getIndex(),randDst2.getIndex()));
        tempEdgeString=getEdgeString(tempEdge);
        if (randDst1.getIndex() != randDst2.getIndex() && !additionalEdges[randDst1.getIndex()].containsKey(tempEdgeString)) {
          additionalEdges[randDst1.getIndex()].put(tempEdgeString,tempEdge);
          additionalEdges[randDst2.getIndex()].put(tempEdgeString,tempEdge);
          triangulationEdgesCount--;
        }
      }
 else {
      }
      secondCounter++;
      if (secondCounter == (currentNodeDegree - 1)) {
        firstCounter++;
        secondCounter=firstCounter + 1;
      }
      if (firstCounter == (currentNodeDegree - 1))       throw new RuntimeException(""String_Node_Str"" + currentNode.getIndex());
    }
    waveFrontNodes=new TreeSet<Node>(new NodeComparator());
    for (    Edge i : getEdges(currentNode).values()) {
      int otherEnd;
      if (i.getDst() == currentNode.getIndex()) {
        otherEnd=i.getSrc();
      }
 else {
        otherEnd=i.getDst();
      }
      tempNode=g.getNode(otherEnd);
      if (removedNodes.contains(tempNode)) {
        continue;
      }
      waveFrontNodes.add(tempNode);
      waveCenterNodes.add(tempNode);
    }
    lastNode=currentNode;
    removedNodes.add(currentNode);
  }
  LinkedList<Node> longestPath=longestPath();
  if (longestPath == null)   throw new RuntimeException(""String_Node_Str"");
  for (  Node n : nodeList)   System.out.println(n + ""String_Node_Str"" + n.getDegree());
  writeIDSpace(g);
  return g;
}",0.9908060067422616
38550,"/** 
 * @return
 */
private Node getNode(Node lastNode){
  if (waveFrontNodes != null) {
    for (    Node tempNode : waveFrontNodes) {
      if (!removedNodes.contains(tempNode)) {
        return tempNode;
      }
    }
  }
  if (waveCenterNodes != null) {
    for (    Node tempNode : waveCenterNodes) {
      if (!removedNodes.contains(tempNode)) {
        return tempNode;
      }
    }
  }
  for (  Node tempNode : nodeList) {
    if (!removedNodes.contains(tempNode)) {
      return tempNode;
    }
  }
  throw new RuntimeException(""String_Node_Str"");
}","/** 
 * @return
 */
private Node getNode(Node lastNode){
  if (waveFrontNodes != null) {
    for (    Node tempNode : waveFrontNodes) {
      if (!removedNodes.contains(tempNode)) {
        waveFrontNodes.remove(tempNode);
        return tempNode;
      }
    }
  }
  if (waveCenterNodes != null) {
    for (    Node tempNode : waveCenterNodes) {
      if (!removedNodes.contains(tempNode)) {
        waveCenterNodes.remove(tempNode);
        return tempNode;
      }
    }
  }
  for (  Node tempNode : nodeList) {
    if (!removedNodes.contains(tempNode)) {
      return tempNode;
    }
  }
  throw new RuntimeException(""String_Node_Str"");
}",0.9308909242298083
38551,"private LinkedList<Node> longestPath(Graph g){
  TreeNode root=new TreeNode(null,0,0);
  deepestNode=root;
  dfs(g,g.getNode(0),root,new ArrayList<Integer>());
  return null;
}","private LinkedList<Node> longestPath(){
  filterRemovalList=true;
  TreeNode root=new TreeNode(null,0,0);
  deepestNode=root;
  dfs(g.getNode(0),root,new ArrayList<Integer>());
  return null;
}",0.9051490514905148
38552,"private void dfs(Graph g,Node n,TreeNode root,ArrayList<Integer> visited){
  int otherEnd;
  if (visited.contains(n.getIndex())) {
    return;
  }
  visited.add(n.getIndex());
  TreeNode current=new TreeNode(root,n.getIndex(),root.depth + 1);
  root.children.add(current);
  if (current.depth > deepestNode.depth) {
    deepestNode=current;
  }
  for (  Edge mEdge : getEdges(g,n).values()) {
    if (removalList.containsKey(mEdge.toString())) {
      continue;
    }
    if (mEdge.getDst() == n.getIndex()) {
      otherEnd=mEdge.getSrc();
    }
 else {
      otherEnd=mEdge.getDst();
    }
    Node mNode=g.getNode(otherEnd);
    dfs(g,mNode,current,visited);
  }
}","private void dfs(Node n,TreeNode root,ArrayList<Integer> visited){
  int otherEnd;
  if (visited.contains(n.getIndex())) {
    return;
  }
  visited.add(n.getIndex());
  TreeNode current=new TreeNode(root,n.getIndex(),root.depth + 1);
  root.children.add(current);
  if (current.depth > deepestNode.depth) {
    deepestNode=current;
  }
  for (  Edge mEdge : getEdges(n).values()) {
    if (filterRemovalList && removalList.containsKey(mEdge.toString())) {
      continue;
    }
    if (mEdge.getDst() == n.getIndex()) {
      otherEnd=mEdge.getSrc();
    }
 else {
      otherEnd=mEdge.getDst();
    }
    Node mNode=g.getNode(otherEnd);
    dfs(mNode,current,visited);
  }
}",0.9560685033507074
38553,"@Override public Graph transform(Graph g){
  System.err.println(""String_Node_Str"");
  initIDSpace(g);
  Node tempNode=null;
  Node currentNode=null;
  Node lastNode=null;
  Node randDst1, randDst2;
  Edge tempEdge;
  String tempEdgeString;
  removalList=new HashMap<String,Edge>();
  HashMap<String,Edge> pairEdges=null;
  removedNodes=new TreeSet<Node>(new NodeComparator());
  waveCenterNodes=new TreeSet<Node>(new NodeComparator());
  waveFrontNodes=new TreeSet<Node>(new NodeComparator());
  additionalEdges=new HashMap[g.getNodes().length];
  for (int i=0; i < g.getNodes().length; i++) {
    additionalEdges[i]=new HashMap<String,Edge>();
  }
  nodeList=Arrays.asList(g.getNodes().clone());
  Collections.sort(nodeList,new NodeDegreeComparator());
  for (int counter=1; counter < (nodeList.size() - 3); counter++) {
    currentNode=getNode(lastNode);
    pairEdges=getPairEdges(g,currentNode);
    for (    Edge singleEdge : pairEdges.values()) {
      removalList.put(getEdgeString(singleEdge),singleEdge);
    }
    int currentNodeDegree=getEdges(g,currentNode).size();
    int triangulationEdgesCount=(currentNodeDegree - 1) - pairEdges.size();
    int[] outgoingEdges=currentNode.getOutgoingEdges();
    int loopCounter=0;
    while (triangulationEdgesCount > 0) {
      if (currentNodeDegree == 2) {
        randDst1=g.getNode(outgoingEdges[0]);
        randDst2=g.getNode(outgoingEdges[1]);
      }
 else {
        randDst1=g.getNode(outgoingEdges[rand.nextInt(outgoingEdges.length)]);
        randDst2=g.getNode(outgoingEdges[rand.nextInt(outgoingEdges.length)]);
      }
      if (!randDst1.isConnectedTo(randDst2)) {
        tempEdge=new Edge(Math.min(randDst1.getIndex(),randDst2.getIndex()),Math.max(randDst1.getIndex(),randDst2.getIndex()));
        tempEdgeString=getEdgeString(tempEdge);
        if (randDst1.getIndex() != randDst2.getIndex() && !additionalEdges[randDst1.getIndex()].containsKey(tempEdgeString)) {
          additionalEdges[randDst1.getIndex()].put(tempEdgeString,tempEdge);
          additionalEdges[randDst2.getIndex()].put(tempEdgeString,tempEdge);
          triangulationEdgesCount--;
          loopCounter=0;
        }
 else {
        }
      }
      if (loopCounter++ > 10)       throw new RuntimeException(""String_Node_Str"");
    }
    for (    Edge i : getEdges(g,currentNode).values()) {
      int otherEnd;
      if (i.getDst() == currentNode.getIndex()) {
        otherEnd=i.getSrc();
      }
 else {
        otherEnd=i.getDst();
      }
      tempNode=g.getNode(otherEnd);
      if (removedNodes.contains(tempNode)) {
        continue;
      }
      waveFrontNodes.add(tempNode);
      waveCenterNodes.add(tempNode);
    }
    lastNode=currentNode;
    removedNodes.add(currentNode);
  }
  LinkedList<Node> longestPath=longestPath(g);
  if (longestPath == null)   throw new RuntimeException(""String_Node_Str"");
  for (  Node n : nodeList)   System.out.println(n + ""String_Node_Str"" + n.getDegree());
  writeIDSpace(g);
  return g;
}","@Override public Graph transform(Graph g){
  System.err.println(""String_Node_Str"");
  initIDSpace(g);
  this.g=g;
  Node tempNode=null;
  Node currentNode=null;
  Node lastNode=null;
  Node randDst1, randDst2;
  Edge tempEdge;
  String tempEdgeString;
  removalList=new HashMap<String,Edge>();
  HashMap<String,Edge> pairEdges=null;
  removedNodes=new TreeSet<Node>(new NodeComparator());
  waveCenterNodes=new TreeSet<Node>(new NodeComparator());
  waveFrontNodes=new TreeSet<Node>(new NodeComparator());
  additionalEdges=new HashMap[g.getNodes().length];
  for (int i=0; i < g.getNodes().length; i++) {
    additionalEdges[i]=new HashMap<String,Edge>();
  }
  nodeList=Arrays.asList(g.getNodes().clone());
  Collections.sort(nodeList,new NodeDegreeComparator());
  for (int counter=1; counter < (nodeList.size() - 3); counter++) {
    currentNode=getNode(lastNode);
    pairEdges=getPairEdges(currentNode);
    for (    Edge singleEdge : pairEdges.values()) {
      removalList.put(getEdgeString(singleEdge),singleEdge);
    }
    HashMap<String,Edge> currentNodeConnections=getEdges(currentNode);
    int currentNodeDegree=currentNodeConnections.size();
    int triangulationEdgesCount=(currentNodeDegree - 1) - pairEdges.size();
    int[] outgoingEdges=filterOutgoingEdges(currentNode,currentNodeConnections);
    int firstCounter=0;
    int secondCounter=1;
    while (triangulationEdgesCount > 0) {
      randDst1=g.getNode(outgoingEdges[firstCounter]);
      randDst2=g.getNode(outgoingEdges[secondCounter]);
      if (randDst1.equals(randDst2))       continue;
      if (removedNodes.contains(randDst1) || removedNodes.contains(randDst2)) {
        continue;
      }
      if (!connected(randDst1,randDst2)) {
        tempEdge=new Edge(Math.min(randDst1.getIndex(),randDst2.getIndex()),Math.max(randDst1.getIndex(),randDst2.getIndex()));
        tempEdgeString=getEdgeString(tempEdge);
        if (randDst1.getIndex() != randDst2.getIndex() && !additionalEdges[randDst1.getIndex()].containsKey(tempEdgeString)) {
          additionalEdges[randDst1.getIndex()].put(tempEdgeString,tempEdge);
          additionalEdges[randDst2.getIndex()].put(tempEdgeString,tempEdge);
          triangulationEdgesCount--;
        }
      }
 else {
      }
      secondCounter++;
      if (secondCounter == (currentNodeDegree - 1)) {
        firstCounter++;
        secondCounter=firstCounter + 1;
      }
      if (firstCounter == (currentNodeDegree - 1))       throw new RuntimeException(""String_Node_Str"" + currentNode.getIndex());
    }
    for (    Edge i : getEdges(currentNode).values()) {
      int otherEnd;
      if (i.getDst() == currentNode.getIndex()) {
        otherEnd=i.getSrc();
      }
 else {
        otherEnd=i.getDst();
      }
      tempNode=g.getNode(otherEnd);
      if (removedNodes.contains(tempNode)) {
        continue;
      }
      waveFrontNodes.add(tempNode);
      waveCenterNodes.add(tempNode);
    }
    lastNode=currentNode;
    removedNodes.add(currentNode);
  }
  LinkedList<Node> longestPath=longestPath();
  if (longestPath == null)   throw new RuntimeException(""String_Node_Str"");
  for (  Node n : nodeList)   System.out.println(n + ""String_Node_Str"" + n.getDegree());
  writeIDSpace(g);
  return g;
}",0.7843579015127132
38554,"private HashMap<String,Edge> getPairEdges(Graph g,Node n){
  HashMap<String,Edge> result=new HashMap<String,Edge>();
  Node tempInnerNode;
  Edge tempEdge;
  int otherOuterEnd, otherInnerEnd;
  HashMap<String,Edge> allOuterEdges=getEdges(g,n);
  for (  Edge tempOuterEdge : allOuterEdges.values()) {
    if (tempOuterEdge.getDst() == n.getIndex()) {
      otherOuterEnd=tempOuterEdge.getSrc();
    }
 else {
      otherOuterEnd=tempOuterEdge.getDst();
    }
    HashMap<String,Edge> allInnerEdges=getEdges(g,g.getNode(otherOuterEnd));
    for (    Edge tempInnerEdge : allInnerEdges.values()) {
      if (tempInnerEdge.getDst() == otherOuterEnd) {
        otherInnerEnd=tempInnerEdge.getSrc();
      }
 else {
        otherInnerEnd=tempInnerEdge.getDst();
      }
      if (otherInnerEnd == n.getIndex()) {
        continue;
      }
      tempInnerNode=g.getNode(otherInnerEnd);
      if (tempInnerNode.isConnectedTo(n)) {
        tempEdge=new Edge(Math.min(otherInnerEnd,otherOuterEnd),Math.max(otherInnerEnd,otherOuterEnd));
        result.put(getEdgeString(tempEdge),tempEdge);
      }
 else {
      }
    }
  }
  return result;
}","private HashMap<String,Edge> getPairEdges(Node n){
  HashMap<String,Edge> result=new HashMap<String,Edge>();
  Node tempInnerNode;
  Edge tempEdge;
  int otherOuterEnd, otherInnerEnd;
  HashMap<String,Edge> allOuterEdges=getEdges(n);
  for (  Edge tempOuterEdge : allOuterEdges.values()) {
    if (tempOuterEdge.getDst() == n.getIndex()) {
      otherOuterEnd=tempOuterEdge.getSrc();
    }
 else {
      otherOuterEnd=tempOuterEdge.getDst();
    }
    HashMap<String,Edge> allInnerEdges=getEdges(g.getNode(otherOuterEnd));
    for (    Edge tempInnerEdge : allInnerEdges.values()) {
      if (tempInnerEdge.getDst() == otherOuterEnd) {
        otherInnerEnd=tempInnerEdge.getSrc();
      }
 else {
        otherInnerEnd=tempInnerEdge.getDst();
      }
      if (otherInnerEnd == n.getIndex()) {
        continue;
      }
      tempInnerNode=g.getNode(otherInnerEnd);
      if (connected(n,tempInnerNode)) {
        tempEdge=new Edge(Math.min(otherInnerEnd,otherOuterEnd),Math.max(otherInnerEnd,otherOuterEnd));
        result.put(getEdgeString(tempEdge),tempEdge);
      }
 else {
      }
    }
  }
  return result;
}",0.6373333333333333
38555,"private ArrayList<Edge> getAllEdges(Graph g,Node n){
  ArrayList<Edge> edges=new ArrayList<Edge>();
  for (  Edge e : n.generateAllEdges())   edges.add(e);
  edges.addAll(additionalEdges[n.getIndex()].values());
  return edges;
}","private ArrayList<Edge> getAllEdges(Node n){
  ArrayList<Edge> edges=new ArrayList<Edge>();
  for (  Edge e : n.generateAllEdges())   edges.add(e);
  edges.addAll(additionalEdges[n.getIndex()].values());
  return edges;
}",0.9822222222222222
38556,"private HashMap<String,Edge> getEdges(Graph g,Node n){
  Node tempNode=null;
  HashMap<String,Edge> edges=new HashMap<String,Edge>();
  for (  Edge i : getAllEdges(g,n)) {
    int otherEnd;
    if (i.getDst() == n.getIndex()) {
      otherEnd=i.getSrc();
    }
 else {
      otherEnd=i.getDst();
    }
    tempNode=g.getNode(otherEnd);
    if (removedNodes.contains(tempNode)) {
      continue;
    }
    edges.put(getEdgeString(i),i);
  }
  return edges;
}","private HashMap<String,Edge> getEdges(Node n){
  Node tempNode=null;
  HashMap<String,Edge> edges=new HashMap<String,Edge>();
  for (  Edge i : getAllEdges(n)) {
    int otherEnd;
    if (i.getDst() == n.getIndex()) {
      otherEnd=i.getSrc();
    }
 else {
      otherEnd=i.getDst();
    }
    tempNode=g.getNode(otherEnd);
    if (removedNodes.contains(tempNode)) {
      continue;
    }
    edges.put(getEdgeString(i),i);
  }
  return edges;
}",0.3606194690265487
38557,"@Override public Graph transform(Graph g){
  initIDSpace(g);
  if (graphPlotter != null)   graphPlotter.plotStartGraph(g,idSpace);
  EdgeCrossings ec=new EdgeCrossings();
  int countCrossings;
  this.g=g;
  Node tempNode=null;
  Node currentNode=null;
  Node lastNode=null;
  Node randDst1, randDst2;
  Edge tempEdge;
  String tempEdgeString;
  removalList=new HashMap<String,Edge>();
  HashMap<String,Edge> pairEdges=null;
  removedNodes=new ArrayList<Node>();
  waveCenterNodes=new TreeSet<Node>(new NodeComparator());
  waveFrontNodes=new TreeSet<Node>(new NodeComparator());
  additionalEdges=new HashMap[g.getNodes().length];
  for (int i=0; i < g.getNodes().length; i++) {
    additionalEdges[i]=new HashMap<String,Edge>();
  }
  nodeList=Arrays.asList(g.getNodes().clone());
  Collections.sort(nodeList,new NodeDegreeComparator());
  for (int counter=1; counter < (nodeList.size() - 3); counter++) {
    currentNode=getNode();
    pairEdges=getPairEdges(currentNode);
    for (    Edge singleEdge : pairEdges.values()) {
      removalList.put(getEdgeString(singleEdge),singleEdge);
    }
    HashMap<String,Edge> currentNodeConnections=getEdges(currentNode);
    int currentNodeDegree=currentNodeConnections.size();
    int triangulationEdgesCount=(currentNodeDegree - 1) - pairEdges.size();
    int[] outgoingEdges=filterOutgoingEdges(currentNode,currentNodeConnections);
    int firstCounter=0;
    int secondCounter=1;
    while (triangulationEdgesCount > 0) {
      randDst1=g.getNode(outgoingEdges[firstCounter]);
      randDst2=g.getNode(outgoingEdges[secondCounter]);
      if (randDst1.equals(randDst2))       continue;
      if (removedNodes.contains(randDst1) || removedNodes.contains(randDst2)) {
        continue;
      }
      if (!connected(randDst1,randDst2)) {
        tempEdge=new Edge(Math.min(randDst1.getIndex(),randDst2.getIndex()),Math.max(randDst1.getIndex(),randDst2.getIndex()));
        tempEdgeString=getEdgeString(tempEdge);
        if (randDst1.getIndex() != randDst2.getIndex() && !additionalEdges[randDst1.getIndex()].containsKey(tempEdgeString)) {
          additionalEdges[randDst1.getIndex()].put(tempEdgeString,tempEdge);
          additionalEdges[randDst2.getIndex()].put(tempEdgeString,tempEdge);
          triangulationEdgesCount--;
        }
      }
 else {
      }
      secondCounter++;
      if (secondCounter == (currentNodeDegree - 1)) {
        firstCounter++;
        secondCounter=firstCounter + 1;
      }
      if (firstCounter == (currentNodeDegree - 1))       throw new RuntimeException(""String_Node_Str"" + currentNode.getIndex());
    }
    waveFrontNodes=new TreeSet<Node>(new NodeComparator());
    for (    Edge i : getEdges(currentNode).values()) {
      int otherEnd;
      if (i.getDst() == currentNode.getIndex()) {
        otherEnd=i.getSrc();
      }
 else {
        otherEnd=i.getDst();
      }
      tempNode=g.getNode(otherEnd);
      if (removedNodes.contains(tempNode)) {
        continue;
      }
      waveFrontNodes.add(tempNode);
      waveCenterNodes.add(tempNode);
    }
    lastNode=currentNode;
    removedNodes.add(currentNode);
  }
  LinkedList<Node> longestPath=longestPath();
  ArrayList<Node> todoList=new ArrayList<Node>();
  todoList.addAll(nodeList);
  todoList.removeAll(longestPath);
  Node neighbor, singleNode;
  int neighborPosition=-1;
  int errors=0;
  int modCounter=0;
  while (!todoList.isEmpty()) {
    singleNode=todoList.get(modCounter % todoList.size());
    for (    int singleNeighbor : singleNode.getOutgoingEdges()) {
      neighbor=g.getNode(singleNeighbor);
      neighborPosition=longestPath.indexOf(neighbor);
      if (neighborPosition > -1) {
        break;
      }
    }
    if (neighborPosition != -1) {
      todoList.remove(singleNode);
      longestPath.add(neighborPosition,singleNode);
    }
 else {
      modCounter=(modCounter + 1) % todoList.size();
      System.err.println(""String_Node_Str"" + singleNode + ""String_Node_Str""+ errors);
      if (errors++ == 50) {
        System.exit(0);
      }
    }
  }
  partitions=new RingPartition[g.getNodes().length];
  idSpace=new RingIdentifierSpace(partitions,this.modulus,this.wrapAround);
  RingIdentifier[] ids=new RingIdentifier[partitions.length];
  double lastPos=0;
  double posDiff=modulus / partitions.length;
  for (int i=0; i < partitions.length; i++) {
    ids[i]=new RingIdentifier(lastPos,idSpace);
    lastPos+=posDiff;
  }
  for (int i=0; i < partitions.length; i++) {
    partitions[i]=new RingPartition(ids[i],ids[(i + 1) % ids.length]);
  }
  writeIDSpace(g);
  if (graphPlotter != null)   graphPlotter.plotFinalGraph(g,idSpace);
  return g;
}","@Override public Graph transform(Graph g){
  initIDSpace(g);
  if (graphPlotter != null)   graphPlotter.plotStartGraph(g,idSpace);
  EdgeCrossings ec=new EdgeCrossings();
  int countCrossings;
  this.g=g;
  Node tempNode=null;
  Node currentNode=null;
  Node lastNode=null;
  Node randDst1, randDst2;
  Edge tempEdge;
  String tempEdgeString;
  removalList=new HashMap<String,Edge>();
  HashMap<String,Edge> pairEdges=null;
  removedNodes=new ArrayList<Node>();
  waveCenterNodes=new TreeSet<Node>(new NodeComparator());
  waveFrontNodes=new TreeSet<Node>(new NodeComparator());
  additionalEdges=new HashMap[g.getNodes().length];
  for (int i=0; i < g.getNodes().length; i++) {
    additionalEdges[i]=new HashMap<String,Edge>();
  }
  nodeList=Arrays.asList(g.getNodes().clone());
  Collections.sort(nodeList,new NodeDegreeComparator());
  for (int counter=1; counter < (nodeList.size() - 3); counter++) {
    currentNode=getNode();
    pairEdges=getPairEdges(currentNode);
    for (    Edge singleEdge : pairEdges.values()) {
      removalList.put(getEdgeString(singleEdge),singleEdge);
    }
    HashMap<String,Edge> currentNodeConnections=getEdges(currentNode);
    int currentNodeDegree=currentNodeConnections.size();
    int triangulationEdgesCount=(currentNodeDegree - 1) - pairEdges.size();
    int[] outgoingEdges=filterOutgoingEdges(currentNode,currentNodeConnections);
    int firstCounter=0;
    int secondCounter=1;
    while (triangulationEdgesCount > 0) {
      randDst1=g.getNode(outgoingEdges[firstCounter]);
      randDst2=g.getNode(outgoingEdges[secondCounter]);
      if (randDst1.equals(randDst2))       continue;
      if (removedNodes.contains(randDst1) || removedNodes.contains(randDst2)) {
        continue;
      }
      if (!connected(randDst1,randDst2)) {
        tempEdge=new Edge(Math.min(randDst1.getIndex(),randDst2.getIndex()),Math.max(randDst1.getIndex(),randDst2.getIndex()));
        tempEdgeString=getEdgeString(tempEdge);
        if (randDst1.getIndex() != randDst2.getIndex() && !additionalEdges[randDst1.getIndex()].containsKey(tempEdgeString)) {
          additionalEdges[randDst1.getIndex()].put(tempEdgeString,tempEdge);
          additionalEdges[randDst2.getIndex()].put(tempEdgeString,tempEdge);
          triangulationEdgesCount--;
        }
      }
 else {
      }
      secondCounter++;
      if (secondCounter == (currentNodeDegree - 1)) {
        firstCounter++;
        secondCounter=firstCounter + 1;
      }
      if (firstCounter == (currentNodeDegree - 1))       throw new RuntimeException(""String_Node_Str"" + currentNode.getIndex());
    }
    waveFrontNodes=new TreeSet<Node>(new NodeComparator());
    for (    Edge i : getEdges(currentNode).values()) {
      int otherEnd;
      if (i.getDst() == currentNode.getIndex()) {
        otherEnd=i.getSrc();
      }
 else {
        otherEnd=i.getDst();
      }
      tempNode=g.getNode(otherEnd);
      if (removedNodes.contains(tempNode)) {
        continue;
      }
      waveFrontNodes.add(tempNode);
      waveCenterNodes.add(tempNode);
    }
    lastNode=currentNode;
    removedNodes.add(currentNode);
  }
  LinkedList<Node> longestPath=longestPath();
  ArrayList<Node> todoList=new ArrayList<Node>();
  todoList.addAll(nodeList);
  todoList.removeAll(longestPath);
  Node neighbor, singleNode;
  int neighborPosition=-1;
  int errors=0;
  int modCounter=0;
  while (!todoList.isEmpty()) {
    singleNode=todoList.get(modCounter % todoList.size());
    for (    int singleNeighbor : singleNode.getOutgoingEdges()) {
      neighbor=g.getNode(singleNeighbor);
      neighborPosition=longestPath.indexOf(neighbor);
      if (neighborPosition > -1) {
        break;
      }
    }
    if (neighborPosition != -1) {
      todoList.remove(singleNode);
      longestPath.add(neighborPosition,singleNode);
    }
 else {
      modCounter=(modCounter + 1) % todoList.size();
      System.err.println(""String_Node_Str"" + singleNode + ""String_Node_Str""+ errors);
      if (errors++ == 50) {
        System.exit(0);
      }
    }
  }
  partitions=new RingPartition[g.getNodes().length];
  idSpace=new RingIdentifierSpace(partitions,this.modulus,this.wrapAround);
  RingIdentifier[] ids=new RingIdentifier[partitions.length];
  double lastPos=0;
  double posDiff=modulus / partitions.length;
  for (  Node n : longestPath) {
    ids[n.getIndex()]=new RingIdentifier(lastPos,idSpace);
    lastPos+=posDiff;
  }
  for (int i=0; i < partitions.length; i++) {
    partitions[i]=new RingPartition(ids[i],ids[(i + 1) % ids.length]);
  }
  writeIDSpace(g);
  if (graphPlotter != null)   graphPlotter.plotFinalGraph(g,idSpace);
  return g;
}",0.992437337942956
38558,"@Override public Graph transform(Graph g){
  initIDSpace(g);
  if (graphPlotter != null)   graphPlotter.plotStartGraph(g,idSpace);
  EdgeCrossings ec=new EdgeCrossings();
  int countCrossings=-1;
  System.out.println(""String_Node_Str"" + countCrossings);
  this.g=g;
  edges=new Edge[g.getNodes().length][];
  Node tempNode=null;
  Node currentNode=null;
  Node lastNode=null;
  Node randDst1, randDst2;
  Edge tempEdge;
  String tempEdgeString;
  removalList=new HashMap<String,Edge>();
  HashMap<String,Edge> pairEdges=null;
  removedNodes=new ArrayList<Node>();
  waveCenterNodes=new TreeSet<Node>(new NodeComparator());
  waveFrontNodes=new TreeSet<Node>(new NodeComparator());
  additionalEdges=new HashMap[g.getNodes().length];
  for (int i=0; i < g.getNodes().length; i++) {
    additionalEdges[i]=new HashMap<String,Edge>();
  }
  nodeList=Arrays.asList(g.getNodes().clone());
  Collections.sort(nodeList,new NodeDegreeComparator());
  for (int counter=1; counter < (nodeList.size() - 3); counter++) {
    currentNode=getNode();
    pairEdges=getPairEdges(currentNode);
    for (    Edge singleEdge : pairEdges.values()) {
      removalList.put(getEdgeString(singleEdge),singleEdge);
    }
    HashMap<String,Edge> currentNodeConnections=getEdges(currentNode);
    int currentNodeDegree=currentNodeConnections.size();
    int triangulationEdgesCount=(currentNodeDegree - 1) - pairEdges.size();
    int[] outgoingEdges=filterOutgoingEdges(currentNode,currentNodeConnections);
    int firstCounter=0;
    int secondCounter=0;
    while (triangulationEdgesCount > 0) {
      secondCounter++;
      if (secondCounter == currentNodeDegree) {
        firstCounter++;
        secondCounter=firstCounter;
      }
      if (firstCounter == (currentNodeDegree - 1))       throw new RuntimeException(""String_Node_Str"" + currentNode.getIndex() + ""String_Node_Str""+ currentNodeDegree);
      randDst1=g.getNode(outgoingEdges[firstCounter]);
      randDst2=g.getNode(outgoingEdges[secondCounter]);
      if (randDst1.equals(randDst2)) {
        continue;
      }
      if (removedNodes.contains(randDst1) || removedNodes.contains(randDst2)) {
        continue;
      }
      if (!connected(randDst1,randDst2)) {
        tempEdge=new Edge(Math.min(randDst1.getIndex(),randDst2.getIndex()),Math.max(randDst1.getIndex(),randDst2.getIndex()));
        tempEdgeString=getEdgeString(tempEdge);
        if (randDst1.getIndex() != randDst2.getIndex() && !additionalEdges[randDst1.getIndex()].containsKey(tempEdgeString)) {
          additionalEdges[randDst1.getIndex()].put(tempEdgeString,tempEdge);
          additionalEdges[randDst2.getIndex()].put(tempEdgeString,tempEdge);
          triangulationEdgesCount--;
        }
      }
 else {
      }
    }
    waveFrontNodes=new TreeSet<Node>(new NodeComparator());
    for (    Edge i : getEdges(currentNode).values()) {
      int otherEnd;
      if (i.getDst() == currentNode.getIndex()) {
        otherEnd=i.getSrc();
      }
 else {
        otherEnd=i.getDst();
      }
      tempNode=g.getNode(otherEnd);
      if (removedNodes.contains(tempNode)) {
        continue;
      }
      waveFrontNodes.add(tempNode);
      waveCenterNodes.add(tempNode);
    }
    lastNode=currentNode;
    removedNodes.add(currentNode);
    System.out.println(""String_Node_Str"" + currentNode.getIndex() + ""String_Node_Str"");
  }
  LinkedList<Node> longestPath=longestPath();
  ArrayList<Node> todoList=new ArrayList<Node>();
  todoList.addAll(nodeList);
  todoList.removeAll(longestPath);
  Node neighbor, singleNode;
  int neighborPosition=-1;
  int errors=0;
  int modCounter=0;
  while (!todoList.isEmpty()) {
    singleNode=todoList.get(modCounter % todoList.size());
    for (    int singleNeighbor : singleNode.getOutgoingEdges()) {
      neighbor=g.getNode(singleNeighbor);
      neighborPosition=longestPath.indexOf(neighbor);
      if (neighborPosition > -1) {
        break;
      }
    }
    if (neighborPosition != -1) {
      todoList.remove(singleNode);
      longestPath.add(neighborPosition,singleNode);
    }
 else {
      modCounter=(modCounter + 1) % todoList.size();
      if (errors++ == 50) {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
  }
  double lastPos=0;
  double posDiff=modulus / partitions.length;
  RingIdentifier[] ids=new RingIdentifier[g.getNodes().length];
  for (  Node n : longestPath) {
    ids[n.getIndex()]=new RingIdentifier(lastPos,idSpace);
    lastPos+=posDiff;
  }
  lastNode=longestPath.getLast();
  for (  Node n : longestPath) {
    partitions[n.getIndex()]=new RingPartition(ids[lastNode.getIndex()],ids[n.getIndex()]);
    lastNode=n;
  }
  System.out.println(""String_Node_Str"" + countCrossings);
  if (graphPlotter != null)   graphPlotter.plot(g,idSpace,graphPlotter.getBasename() + ""String_Node_Str"");
  reduceCrossingsBySwapping(g);
  writeIDSpace(g);
  if (graphPlotter != null)   graphPlotter.plotFinalGraph(g,idSpace);
  System.out.println(""String_Node_Str"" + countCrossings);
  return g;
}","@Override public Graph transform(Graph g){
  initIDSpace(g);
  if (graphPlotter != null)   graphPlotter.plotStartGraph(g,idSpace);
  EdgeCrossings ec=new EdgeCrossings();
  int countCrossings=-1;
  System.out.println(""String_Node_Str"" + countCrossings);
  this.g=g;
  edges=new Edge[g.getNodes().length][];
  Node tempNode=null;
  Node currentNode=null;
  Node lastNode=null;
  Node randDst1, randDst2;
  Edge tempEdge;
  String tempEdgeString;
  removalList=new HashMap<String,Edge>();
  HashMap<String,Edge> pairEdges=null;
  removedNodes=new ArrayList<Node>();
  waveCenterNodes=new TreeSet<Node>(new NodeComparator());
  waveFrontNodes=new TreeSet<Node>(new NodeComparator());
  additionalEdges=new HashMap[g.getNodes().length];
  for (int i=0; i < g.getNodes().length; i++) {
    additionalEdges[i]=new HashMap<String,Edge>();
  }
  nodeList=Arrays.asList(g.getNodes().clone());
  Collections.sort(nodeList,new NodeDegreeComparator());
  for (int counter=1; counter < (nodeList.size() - 3); counter++) {
    currentNode=getNode();
    pairEdges=getPairEdges(currentNode);
    for (    Edge singleEdge : pairEdges.values()) {
      removalList.put(getEdgeString(singleEdge),singleEdge);
    }
    HashMap<String,Edge> currentNodeConnections=getEdges(currentNode);
    int currentNodeDegree=currentNodeConnections.size();
    int triangulationEdgesCount=(currentNodeDegree - 1) - pairEdges.size();
    int[] outgoingEdges=filterOutgoingEdges(currentNode,currentNodeConnections);
    int firstCounter=0;
    int secondCounter=1;
    while (triangulationEdgesCount > 0) {
      randDst1=g.getNode(outgoingEdges[firstCounter]);
      randDst2=g.getNode(outgoingEdges[secondCounter]);
      if (!randDst1.equals(randDst2) && !removedNodes.contains(randDst1) && !removedNodes.contains(randDst2)) {
        if (!connected(randDst1,randDst2)) {
          tempEdge=new Edge(Math.min(randDst1.getIndex(),randDst2.getIndex()),Math.max(randDst1.getIndex(),randDst2.getIndex()));
          tempEdgeString=getEdgeString(tempEdge);
          if (randDst1.getIndex() != randDst2.getIndex() && !additionalEdges[randDst1.getIndex()].containsKey(tempEdgeString)) {
            additionalEdges[randDst1.getIndex()].put(tempEdgeString,tempEdge);
            additionalEdges[randDst2.getIndex()].put(tempEdgeString,tempEdge);
            triangulationEdgesCount--;
          }
        }
 else {
        }
      }
      secondCounter++;
      if (secondCounter == (currentNodeDegree)) {
        firstCounter++;
        secondCounter=firstCounter + 1;
      }
      if (firstCounter == (currentNodeDegree - 1) && triangulationEdgesCount > 0)       throw new RuntimeException(""String_Node_Str"" + currentNode.getIndex());
    }
    waveFrontNodes=new TreeSet<Node>(new NodeComparator());
    for (    Edge i : getEdges(currentNode).values()) {
      int otherEnd;
      if (i.getDst() == currentNode.getIndex()) {
        otherEnd=i.getSrc();
      }
 else {
        otherEnd=i.getDst();
      }
      tempNode=g.getNode(otherEnd);
      if (removedNodes.contains(tempNode)) {
        continue;
      }
      waveFrontNodes.add(tempNode);
      waveCenterNodes.add(tempNode);
    }
    lastNode=currentNode;
    removedNodes.add(currentNode);
  }
  LinkedList<Node> longestPath=longestPath();
  ArrayList<Node> todoList=new ArrayList<Node>();
  todoList.addAll(nodeList);
  todoList.removeAll(longestPath);
  Node neighbor, singleNode;
  int neighborPosition=-1;
  int errors=0;
  int modCounter=0;
  while (!todoList.isEmpty()) {
    singleNode=todoList.get(modCounter % todoList.size());
    for (    int singleNeighbor : singleNode.getOutgoingEdges()) {
      neighbor=g.getNode(singleNeighbor);
      neighborPosition=longestPath.indexOf(neighbor);
      if (neighborPosition > -1) {
        break;
      }
    }
    if (neighborPosition != -1) {
      todoList.remove(singleNode);
      longestPath.add(neighborPosition,singleNode);
    }
 else {
      modCounter=(modCounter + 1) % todoList.size();
      if (errors++ == 50) {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
  }
  double lastPos=0;
  double posDiff=modulus / partitions.length;
  RingIdentifier[] ids=new RingIdentifier[g.getNodes().length];
  for (  Node n : longestPath) {
    ids[n.getIndex()]=new RingIdentifier(lastPos,idSpace);
    lastPos+=posDiff;
  }
  lastNode=longestPath.getLast();
  for (  Node n : longestPath) {
    partitions[n.getIndex()]=new RingPartition(ids[lastNode.getIndex()],ids[n.getIndex()]);
    lastNode=n;
  }
  System.out.println(""String_Node_Str"" + countCrossings);
  if (graphPlotter != null)   graphPlotter.plot(g,idSpace,graphPlotter.getBasename() + ""String_Node_Str"");
  reduceCrossingsBySwapping(g);
  writeIDSpace(g);
  if (graphPlotter != null)   graphPlotter.plotFinalGraph(g,idSpace);
  System.out.println(""String_Node_Str"" + countCrossings);
  return g;
}",0.7099523181495384
38559,"@Override public Graph transform(Graph g){
  tree=(SpanningTree)g.getProperty(""String_Node_Str"");
  int source=tree.getSrc();
  radiuses=new double[g.getNodes().length];
  delta=new double[g.getNodes().length];
  angularSector=new double[g.getNodes().length];
  calculateRadius(tree,source);
  Point center=new Point(0,0);
  coordAssign(tree,source,center);
  return g;
}","@Override public Graph transform(Graph g){
  tree=(SpanningTree)g.getProperty(""String_Node_Str"");
  int source=tree.getSrc();
  int numNodes=g.getNodes().length;
  nodePositionsX=new double[numNodes];
  nodePositionsY=new double[numNodes];
  radiuses=new double[numNodes];
  delta=new double[numNodes];
  angularSector=new double[numNodes];
  calculateRadius(tree,source);
  Point center=new Point(0,0);
  coordAssign(tree,source,center);
  writeIDSpace(g);
  if (graphPlotter != null)   graphPlotter.plotFinalGraph(g,idSpace);
  if (graphPlotter != null)   graphPlotter.plotSpanningTree(g,idSpace);
  return g;
}",0.5853658536585366
38560,"@Override public Partition<Double>[] getPartitions(){
  return this.partitions;
}","@Override public DPartition[] getPartitions(){
  return this.partitions;
}",0.9419354838709676
38561,"@Override public Partition<Double>[] getPartitions(){
  return this.partitions;
}","@Override public DPartition[] getPartitions(){
  return this.partitions;
}",0.9419354838709676
38562,"public void computeData(Graph graph,Network nw,HashMap<String,Metric> m){
  this.runtime=new Timer();
  Edge[] edges=graph.generateEdges();
  DIdentifierSpace idSpace=(DIdentifierSpace)graph.getProperty(""String_Node_Str"");
  int result=calculateCrossings(edges,idSpace,false);
  double[] finalCD=new double[maxCrossingNumber];
  for (int i=0; i < maxCrossingNumber; i++) {
    finalCD[i]=cd[i] / result;
  }
  this.crossingDistribution=new Distribution(finalCD);
  this.runtime.end();
}","public void computeData(Graph graph,Network nw,HashMap<String,Metric> m){
  this.runtime=new Timer();
  Edge[] edges=graph.generateEdges();
  DIdentifierSpace idSpace=(DIdentifierSpace)graph.getProperty(""String_Node_Str"");
  int result=calculateCrossings(edges,idSpace,false);
  double[] finalCD=new double[maxCrossingNumber + 1];
  for (int i=0; i < maxCrossingNumber + 1; i++) {
    finalCD[i]=cd[i] / edges.length;
  }
  this.crossingDistribution=new Distribution(finalCD);
  this.runtime.end();
}",0.973630831643002
38563,"private boolean hasCrossingMD(Edge x,Edge y){
  return hasCrossing(getPlaneEdgeFromMD(x),getPlaneEdgeFromMD(y));
}","private boolean hasCrossingMD(Edge x,Edge y,Boolean useShortcut){
  return hasCrossing(getPlaneEdgeFromMD(x),getPlaneEdgeFromMD(y),useShortcut);
}",0.8769230769230769
38564,"public int calculateCrossings(Node n,Node m,IdentifierSpace idSpace){
  int numCross=0;
  Edge[] nEdges=n.generateAllEdges();
  Edge[] mEdges=m.generateAllEdges();
  handledEdges=new HashSet<String>();
  for (  Edge nEdge : nEdges) {
    for (    Edge mEdge : mEdges) {
      if (hasCrossing(nEdge,mEdge,idSpace))       numCross++;
    }
  }
  return numCross;
}","public int calculateCrossings(Node n,Node m,IdentifierSpace idSpace){
  int numCross=0;
  Edge[] nEdges=n.generateAllEdges();
  Edge[] mEdges=m.generateAllEdges();
  handledEdges=new HashSet<String>();
  for (  Edge nEdge : nEdges) {
    for (    Edge mEdge : mEdges) {
      if (hasCrossing(nEdge,mEdge,idSpace,true))       numCross++;
    }
  }
  return numCross;
}",0.9931412894375856
38565,"private boolean hasCrossingPlane(Edge x,Edge y){
  return hasCrossing(getPlaneEdgeFromPI(x),getPlaneEdgeFromPI(y));
}","private boolean hasCrossingPlane(Edge x,Edge y,Boolean useShortcut){
  return hasCrossing(getPlaneEdgeFromPI(x),getPlaneEdgeFromPI(y),useShortcut);
}",0.8796992481203008
38566,"private boolean hasCrossing(PlaneEdge x,PlaneEdge y){
  String edgeString=x + ""String_Node_Str"" + y;
  if (y.startX < x.startX) {
    edgeString=y + ""String_Node_Str"" + x;
  }
  if (handledEdges.contains(edgeString)) {
    return false;
  }
  handledEdges.add(edgeString);
  double d=(x.startX - x.endX) * (y.startY - y.endY) - (x.startY - x.endY) * (y.startX - y.endX);
  if (d == 0) {
    return false;
  }
  double xi=((y.startX - y.endX) * (x.startX * x.endY - x.startY * x.endX) - (x.startX - x.endX) * (y.startX * y.endY - y.startY * y.endX)) / d;
  double yi=((y.startY - y.endY) * (x.startX * x.endY - x.startY * x.endX) - (x.startY - x.endY) * (y.startX * y.endY - y.startY * y.endX)) / d;
  if (isBetween(x.startX,x.endX,xi) && isBetween(x.startY,x.endY,yi) && isBetween(y.startX,y.endX,xi)&& isBetween(y.startY,y.endY,yi)) {
    return true;
  }
  return false;
}","private boolean hasCrossing(PlaneEdge x,PlaneEdge y,Boolean useShortcut){
  String edgeString=x + ""String_Node_Str"" + y;
  if (y.startX < x.startX) {
    edgeString=y + ""String_Node_Str"" + x;
  }
  if (useShortcut) {
    if (handledEdges.contains(edgeString)) {
      return false;
    }
    handledEdges.add(edgeString);
  }
  double d=(x.startX - x.endX) * (y.startY - y.endY) - (x.startY - x.endY) * (y.startX - y.endX);
  if (d == 0) {
    return false;
  }
  double xi=((y.startX - y.endX) * (x.startX * x.endY - x.startY * x.endX) - (x.startX - x.endX) * (y.startX * y.endY - y.startY * y.endX)) / d;
  double yi=((y.startY - y.endY) * (x.startX * x.endY - x.startY * x.endX) - (x.startY - x.endY) * (y.startX * y.endY - y.startY * y.endX)) / d;
  if (isBetween(x.startX,x.endX,xi) && isBetween(x.startY,x.endY,yi) && isBetween(y.startX,y.endX,xi)&& isBetween(y.startY,y.endY,yi)) {
    return true;
  }
  return false;
}",0.9705719044975014
38567,"public Edge[] getAllEdges(){
  ArrayList<Edge> edgeList=new ArrayList<Edge>();
  for (  int dst : getOutgoingEdges()) {
    edgeList.add(new Edge(this.index,dst));
  }
  for (  int src : getIncomingEdges()) {
    edgeList.add(new Edge(src,this.index));
  }
  return (Edge[])edgeList.toArray();
}","public Edge[] getAllEdges(){
  ArrayList<Edge> edgeList=new ArrayList<Edge>();
  for (  int dst : getOutgoingEdges()) {
    edgeList.add(new Edge(this.index,dst));
  }
  for (  int src : getIncomingEdges()) {
    edgeList.add(new Edge(src,this.index));
  }
  Edge[] arrayEdgeList=new Edge[edgeList.size()];
  for (int i=0; i < arrayEdgeList.length; i++) {
    arrayEdgeList[i]=edgeList.get(i);
  }
  return arrayEdgeList;
}",0.7437325905292479
38568,"protected int countAllCrossings(Graph g){
  int numCross=0;
  Edge[] edgeList=g.generateEdges();
  handledEdges=new ArrayList<String>();
  for (  Edge e : edgeList) {
    numCross+=countCrossings(e,edgeList);
  }
  System.out.println(""String_Node_Str"" + numCross + ""String_Node_Str"");
  return numCross;
}","protected int countAllCrossings(Graph g){
  int numCross=0;
  Edge[] edgeList=g.generateEdges();
  handledEdges=new ArrayList<String>();
  for (  Edge e : edgeList) {
    numCross+=countCrossings(e,edgeList);
  }
  return numCross;
}",0.8327137546468402
38569,"private Boolean hasCrossing(Edge x,Edge y){
  if (x.equals(y))   return false;
  double xStart=Math.min(getPosition(x.getSrc()),getPosition(x.getDst()));
  double xEnd=Math.max(getPosition(x.getSrc()),getPosition(x.getDst()));
  String xString=xStart + ""String_Node_Str"" + xEnd;
  double yStart=Math.min(getPosition(y.getSrc()),getPosition(y.getDst()));
  double yEnd=Math.max(getPosition(y.getSrc()),getPosition(y.getDst()));
  String yString=yStart + ""String_Node_Str"" + yEnd;
  String edgeString;
  if (xStart < yStart)   edgeString=xString + ""String_Node_Str"" + yString;
 else   edgeString=yString + ""String_Node_Str"" + xString;
  if (handledEdges.contains(edgeString)) {
    return false;
  }
  handledEdges.add(edgeString);
  if ((xStart < yStart && xEnd > yEnd) || (yStart < xStart && yEnd > xEnd) || (yStart > xEnd || xStart > yEnd)|| (yStart == xEnd || xStart == yEnd || xStart == yStart || xEnd == yEnd)) {
    System.out.println(""String_Node_Str"" + edgeString);
    return false;
  }
  if ((xStart < yStart && xEnd < yEnd) || (xStart > yStart && xEnd > yEnd)) {
    System.out.println(""String_Node_Str"" + edgeString);
    return true;
  }
  System.err.println(""String_Node_Str"" + edgeString);
  return false;
}","private Boolean hasCrossing(Edge x,Edge y){
  if (x.equals(y))   return false;
  double xStart=Math.min(getPosition(x.getSrc()),getPosition(x.getDst()));
  double xEnd=Math.max(getPosition(x.getSrc()),getPosition(x.getDst()));
  String xString=xStart + ""String_Node_Str"" + xEnd;
  double yStart=Math.min(getPosition(y.getSrc()),getPosition(y.getDst()));
  double yEnd=Math.max(getPosition(y.getSrc()),getPosition(y.getDst()));
  String yString=yStart + ""String_Node_Str"" + yEnd;
  String edgeString;
  if (xStart < yStart)   edgeString=xString + ""String_Node_Str"" + yString;
 else   edgeString=yString + ""String_Node_Str"" + xString;
  if (handledEdges.contains(edgeString)) {
    return false;
  }
  handledEdges.add(edgeString);
  if ((xStart < yStart && xEnd > yEnd) || (yStart < xStart && yEnd > xEnd) || (yStart > xEnd || xStart > yEnd)|| (yStart == xEnd || xStart == yEnd || xStart == yStart || xEnd == yEnd)) {
    return false;
  }
  if ((xStart < yStart && xEnd < yEnd) || (xStart > yStart && xEnd > yEnd)) {
    return true;
  }
  System.err.println(""String_Node_Str"" + edgeString);
  return false;
}",0.8472103004291845
38570,"@Override public int compareTo(PlaneIdentifier o){
  return 0;
}","@Override public int compareTo(MDIdentifier o){
  return 0;
}",0.944
38571,"public void plot(Graph g,String filename){
  if (!disabled) {
    gephi.Plot(g,filename + ""String_Node_Str"" + extension);
  }
}","public void plot(Graph g,String filename){
  gephi.Plot(g,filename + ""String_Node_Str"" + extension);
}",0.8908296943231441
38572,"@Override public Double distance(Identifier<Double> id){
  MDIdentifier to=(MDIdentifier)id;
  if (this.idSpace.getDimensions() != to.getIdSpace().getDimensions()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  double squarredResult=0;
  for (int i=0; i < this.idSpace.getDimensions(); i++) {
    if (this.idSpace.isWrapAround()) {
      squarredResult+=Math.abs(this.coordinates[i] - to.getCoordinate(i)) % (this.idSpace.getModulus(i) / 2.0);
    }
 else {
      squarredResult+=Math.abs(this.coordinates[i] - to.getCoordinate(i));
    }
  }
  return Math.sqrt(squarredResult);
}","@Override public Double distance(Identifier<Double> id){
  MDIdentifier to=(MDIdentifier)id;
  if (this.idSpace.getDimensions() != to.getIdSpace().getDimensions()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  double squarredResult=0;
  double temp;
  for (int i=0; i < this.idSpace.getDimensions(); i++) {
    if (this.idSpace.isWrapAround()) {
      temp=Math.abs(this.coordinates[i] - to.getCoordinate(i)) % (this.idSpace.getModulus(i) / 2.0);
    }
 else {
      temp=Math.abs(this.coordinates[i] - to.getCoordinate(i));
    }
    squarredResult+=Math.pow(temp,2);
  }
  return Math.sqrt(squarredResult);
}",0.6139917695473252
38573,"public void Plot(Graph g,String fileName){
  gephiNodes=new org.gephi.graph.api.Node[g.getNodes().length];
  this.plotGraph(g);
  ExportController ec=Lookup.getDefault().lookup(ExportController.class);
  try {
    ec.exportFile(new File(Config.get(""String_Node_Str"") + fileName));
  }
 catch (  IOException ex) {
    ex.printStackTrace();
    return;
  }
}","public void Plot(Graph g,String fileName){
  ProjectController pc=Lookup.getDefault().lookup(ProjectController.class);
  pc.newProject();
  graphModel=Lookup.getDefault().lookup(GraphController.class).getModel();
  gephiGraph=graphModel.getGraph();
  PreviewModel model=Lookup.getDefault().lookup(PreviewController.class).getModel();
  model.getUndirectedEdgeSupervisor().setCurvedFlag(false);
  model.getBiEdgeSupervisor().setCurvedFlag(false);
  gephiNodes=new org.gephi.graph.api.Node[g.getNodes().length];
  this.plotGraph(g);
  ExportController ec=Lookup.getDefault().lookup(ExportController.class);
  try {
    ec.exportFile(new File(Config.get(""String_Node_Str"") + fileName));
  }
 catch (  IOException ex) {
    ex.printStackTrace();
    return;
  }
}",0.6385650224215247
38574,"public Graph getSpanningTree(Node root){
  Graph result=new Graph(this.name + ""String_Node_Str"");
  Node[] resultNodes=new Node[this.nodes.length];
  int[] edges;
  int nodeCounter=0;
  Node tempNodeFromList, tempNewNode;
  LinkedList<Node> todoList=new LinkedList<Node>();
  LinkedList<Integer> handledNodes=new LinkedList<Integer>();
  LinkedList<Integer> linkedNodes=new LinkedList<Integer>();
  LinkedList<Integer> newEdges;
  todoList.add(root);
  linkedNodes.add(root.getIndex());
  while (!todoList.isEmpty()) {
    tempNodeFromList=todoList.pop();
    if (handledNodes.contains(tempNodeFromList.getIndex())) {
      continue;
    }
    edges=tempNodeFromList.getOutgoingEdges();
    newEdges=new LinkedList<Integer>();
    for (    int e : edges) {
      if (!linkedNodes.contains(e)) {
        todoList.add(this.nodes[e]);
        newEdges.add(e);
        linkedNodes.add(e);
      }
    }
    tempNewNode=new Node(tempNodeFromList.getIndex(),result);
    edges=new int[newEdges.size()];
    for (int i=0; i < newEdges.size(); i++) {
      edges[i]=newEdges.get(i);
    }
    tempNewNode.setOutgoingEdges(edges);
    resultNodes[nodeCounter]=tempNewNode;
    handledNodes.add(tempNodeFromList.getIndex());
    nodeCounter++;
  }
  result.setNodes(resultNodes);
  return result;
}","public Graph getSpanningTree(Node root){
  Graph result=new Graph(this.name + ""String_Node_Str"");
  Node[] resultNodes=new Node[this.nodes.length];
  int[] edges;
  Node tempNodeFromList, tempNewNode;
  LinkedList<Node> todoList=new LinkedList<Node>();
  LinkedList<Integer> handledNodes=new LinkedList<Integer>();
  LinkedList<Integer> linkedNodes=new LinkedList<Integer>();
  LinkedList<Integer> newEdges;
  todoList.add(root);
  linkedNodes.add(root.getIndex());
  while (!todoList.isEmpty()) {
    tempNodeFromList=todoList.pop();
    if (handledNodes.contains(tempNodeFromList.getIndex())) {
      continue;
    }
    edges=tempNodeFromList.getOutgoingEdges();
    newEdges=new LinkedList<Integer>();
    for (    int e : edges) {
      if (!linkedNodes.contains(e)) {
        todoList.add(this.nodes[e]);
        newEdges.add(e);
        linkedNodes.add(e);
      }
    }
    tempNewNode=new Node(tempNodeFromList.getIndex(),result);
    edges=new int[newEdges.size()];
    for (int i=0; i < newEdges.size(); i++) {
      edges[i]=newEdges.get(i);
    }
    tempNewNode.setOutgoingEdges(edges);
    resultNodes[tempNodeFromList.getIndex()]=tempNewNode;
    handledNodes.add(tempNodeFromList.getIndex());
  }
  result.setNodes(resultNodes);
  return result;
}",0.1857366771159874
38575,"public Edge[] getAllEdges(){
  ArrayList<Edge> edgeList=new ArrayList<Edge>();
  for (  int dst : getOutgoingEdges()) {
    edgeList.add(new Edge(this.index,dst));
  }
  for (  int src : getIncomingEdges()) {
    edgeList.add(new Edge(src,this.index));
  }
  return (Edge[])edgeList.toArray();
}","public Edge[] getAllEdges(){
  ArrayList<Edge> edgeList=new ArrayList<Edge>();
  for (  int dst : getOutgoingEdges()) {
    edgeList.add(new Edge(this.index,dst));
  }
  for (  int src : getIncomingEdges()) {
    edgeList.add(new Edge(src,this.index));
  }
  Edge[] arrayEdgeList=new Edge[edgeList.size()];
  for (int i=0; i < arrayEdgeList.length; i++) {
    arrayEdgeList[i]=edgeList.get(i);
  }
  return arrayEdgeList;
}",0.7437325905292479
38576,"protected int countAllCrossings(Graph g){
  int numCross=0;
  Edge[] edgeList=g.generateEdges();
  handledEdges=new ArrayList<String>();
  for (  Edge e : edgeList) {
    numCross+=countCrossings(e,edgeList);
  }
  System.out.println(""String_Node_Str"" + numCross + ""String_Node_Str"");
  return numCross;
}","protected int countAllCrossings(Graph g){
  int numCross=0;
  Edge[] edgeList=g.generateEdges();
  handledEdges=new ArrayList<String>();
  for (  Edge e : edgeList) {
    numCross+=countCrossings(e,edgeList);
  }
  return numCross;
}",0.8327137546468402
38577,"private Boolean hasCrossing(Edge x,Edge y){
  if (x.equals(y))   return false;
  double xStart=Math.min(getPosition(x.getSrc()),getPosition(x.getDst()));
  double xEnd=Math.max(getPosition(x.getSrc()),getPosition(x.getDst()));
  String xString=xStart + ""String_Node_Str"" + xEnd;
  double yStart=Math.min(getPosition(y.getSrc()),getPosition(y.getDst()));
  double yEnd=Math.max(getPosition(y.getSrc()),getPosition(y.getDst()));
  String yString=yStart + ""String_Node_Str"" + yEnd;
  String edgeString;
  if (xStart < yStart)   edgeString=xString + ""String_Node_Str"" + yString;
 else   edgeString=yString + ""String_Node_Str"" + xString;
  if (handledEdges.contains(edgeString)) {
    return false;
  }
  handledEdges.add(edgeString);
  if ((xStart < yStart && xEnd > yEnd) || (yStart < xStart && yEnd > xEnd) || (yStart > xEnd || xStart > yEnd)|| (yStart == xEnd || xStart == yEnd || xStart == yStart || xEnd == yEnd)) {
    System.out.println(""String_Node_Str"" + edgeString);
    return false;
  }
  if ((xStart < yStart && xEnd < yEnd) || (xStart > yStart && xEnd > yEnd)) {
    System.out.println(""String_Node_Str"" + edgeString);
    return true;
  }
  System.err.println(""String_Node_Str"" + edgeString);
  return false;
}","private Boolean hasCrossing(Edge x,Edge y){
  if (x.equals(y))   return false;
  double xStart=Math.min(getPosition(x.getSrc()),getPosition(x.getDst()));
  double xEnd=Math.max(getPosition(x.getSrc()),getPosition(x.getDst()));
  String xString=xStart + ""String_Node_Str"" + xEnd;
  double yStart=Math.min(getPosition(y.getSrc()),getPosition(y.getDst()));
  double yEnd=Math.max(getPosition(y.getSrc()),getPosition(y.getDst()));
  String yString=yStart + ""String_Node_Str"" + yEnd;
  String edgeString;
  if (xStart < yStart)   edgeString=xString + ""String_Node_Str"" + yString;
 else   edgeString=yString + ""String_Node_Str"" + xString;
  if (handledEdges.contains(edgeString)) {
    return false;
  }
  handledEdges.add(edgeString);
  if ((xStart < yStart && xEnd > yEnd) || (yStart < xStart && yEnd > xEnd) || (yStart > xEnd || xStart > yEnd)|| (yStart == xEnd || xStart == yEnd || xStart == yStart || xEnd == yEnd)) {
    return false;
  }
  if ((xStart < yStart && xEnd < yEnd) || (xStart > yStart && xEnd > yEnd)) {
    return true;
  }
  System.err.println(""String_Node_Str"" + edgeString);
  return false;
}",0.8472103004291845
38578,"public Edge[] generateEdgesUnidirectional(){
  int index=0;
  Edge[] edges=new Edge[this.parent.length - 1];
  for (int i=0; i < this.parent.length; i++) {
    if (i != -1) {
      edges[index++]=new Edge(this.parent[i],i);
    }
  }
  return edges;
}","public Edge[] generateEdgesUnidirectional(){
  int index=0;
  Edge[] edges=new Edge[this.parent.length - 1];
  for (int i=0; i < this.parent.length; i++) {
    if (this.parent[i] != -1) {
      edges[index++]=new Edge(this.parent[i],i);
    }
  }
  return edges;
}",0.970873786407767
38579,"public Edge[] generateEdgesBidirectional(){
  int index=0;
  Edge[] edges=new Edge[this.parent.length * 2 - 2];
  for (int i=0; i < this.parent.length; i++) {
    if (i != -1) {
      edges[index++]=new Edge(this.parent[i],i);
      edges[index++]=new Edge(i,this.parent[i]);
    }
  }
  return edges;
}","public Edge[] generateEdgesBidirectional(){
  int index=0;
  Edge[] edges=new Edge[this.parent.length * 2 - 2];
  for (int i=0; i < this.parent.length; i++) {
    if (this.parent[i] != -1) {
      edges[index++]=new Edge(this.parent[i],i);
      edges[index++]=new Edge(i,this.parent[i]);
    }
  }
  return edges;
}",0.975767366720517
38580,"@Override public int compareTo(PlaneIdentifier o){
  return 0;
}","@Override public int compareTo(MDIdentifier o){
  return 0;
}",0.944
38581,"/** 
 * @param args
 */
public static void main(String[] args) throws Exception {
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  Config.overwrite(""String_Node_Str"",""String_Node_Str"" + false);
  Network nw1=new ReadableFile(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null,null);
  Network nw2=new ReadableFolder(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null,null);
  Network nw3=new ReadableList(""String_Node_Str"",""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},null,null);
  Series s1=Series.generate(nw1,1);
  Series s2=Series.generate(nw2,10);
  Series s3=Series.generate(nw3,17);
  Plot.multiAvg(s1,""String_Node_Str"");
  Network er=new ErdosRenyi(100,10,false,null,null);
  GraphWriter.write(er.generate(),""String_Node_Str"");
}","/** 
 * @param args
 */
public static void main(String[] args) throws Exception {
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  Config.overwrite(""String_Node_Str"",""String_Node_Str"" + false);
  Network nw1=new ReadableFile(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null,null);
  Network nw2=new ReadableFolder(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null,null);
  Network nw3=new ReadableList(""String_Node_Str"",""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},null,null);
  Series s1=Series.generate(nw1,1);
  Series s2=Series.generate(nw2,10);
  Series s3=Series.generate(nw3,17);
  Plot.multiAvg(s1,""String_Node_Str"");
  Network er=new ErdosRenyi(100,10,false,null,null);
  GraphWriter.write(er.generate(),""String_Node_Str"");
}",0.9906832298136646
38582,"@Override public void computeData(Graph graph,Network nw,HashMap<String,Metric> metrics){
  this.runtime=new Timer();
  this.localCharacteristicPathLength=new double[graph.getNodes().length];
  long[] SPL=this.computeShortestPathLengths(graph.getNodes());
  this.shortestPathLengthDistribution=new Distribution(this.computeShortestPathLengthDistribution(SPL));
  this.shortestPathLengthDistributionAbsolute=new Distribution(this.computeShortestPathLengthDistributionAbsolute(SPL,graph));
  this.connectivity=(double)Util.sum(SPL) / (double)(graph.getNodes().length * (graph.getNodes().length - 1));
  this.runtime.end();
}","@Override public void computeData(Graph graph,Network nw,HashMap<String,Metric> metrics){
  this.runtime=new Timer();
  this.localCharacteristicPathLength=new double[graph.getNodes().length];
  long[] SPL=this.computeShortestPathLengths(graph.getNodes());
  this.shortestPathLengthDistribution=new Distribution(this.computeShortestPathLengthDistribution(SPL));
  this.shortestPathLengthDistributionAbsolute=new Distribution(this.computeShortestPathLengthDistributionAbsolute(SPL,graph));
  this.connectivity=(double)Util.sum(SPL) / (double)((double)graph.getNodes().length * (double)(graph.getNodes().length - 1));
  this.runtime.end();
}",0.9873015873015872
38583,"private double[] computeShortestPathLengthDistributionAbsolute(long[] SPL,Graph graph){
  long sum=graph.getNodes().length * (graph.getNodes().length - 1);
  double[] spld=new double[SPL.length];
  for (int i=0; i < SPL.length; i++) {
    spld[i]=(double)SPL[i] / sum;
  }
  return spld;
}","private double[] computeShortestPathLengthDistributionAbsolute(long[] SPL,Graph graph){
  long sum=(long)graph.getNodes().length * (long)(graph.getNodes().length - 1);
  double[] spld=new double[SPL.length];
  for (int i=0; i < SPL.length; i++) {
    spld[i]=(double)SPL[i] / sum;
  }
  return spld;
}",0.9796610169491524
38584,"public void Plot(Graph g,String fileName){
  gephiNodes=new org.gephi.graph.api.Node[g.getNodes().length];
  this.plotGraph(g);
  ExportController ec=Lookup.getDefault().lookup(ExportController.class);
  try {
    ec.exportFile(new File(Config.get(""String_Node_Str"") + fileName));
  }
 catch (  IOException ex) {
    ex.printStackTrace();
    return;
  }
}","public void Plot(Graph g,String fileName){
  ProjectController pc=Lookup.getDefault().lookup(ProjectController.class);
  pc.newProject();
  graphModel=Lookup.getDefault().lookup(GraphController.class).getModel();
  gephiGraph=graphModel.getGraph();
  PreviewModel model=Lookup.getDefault().lookup(PreviewController.class).getModel();
  model.getUndirectedEdgeSupervisor().setCurvedFlag(false);
  model.getBiEdgeSupervisor().setCurvedFlag(false);
  gephiNodes=new org.gephi.graph.api.Node[g.getNodes().length];
  this.plotGraph(g);
  ExportController ec=Lookup.getDefault().lookup(ExportController.class);
  try {
    ec.exportFile(new File(Config.get(""String_Node_Str"") + fileName));
  }
 catch (  IOException ex) {
    ex.printStackTrace();
    return;
  }
}",0.6385650224215247
38585,"public void plot(Graph g,String filename){
  if (!disabled) {
    gephi.Plot(g,filename + ""String_Node_Str"" + extension);
  }
}","public void plot(Graph g,String filename){
  gephi.Plot(g,filename + ""String_Node_Str"" + extension);
}",0.8908296943231441
38586,"public Graph getSpanningTree(Node root){
  Graph result=new Graph(this.name + ""String_Node_Str"");
  Node[] resultNodes=new Node[this.nodes.length];
  int[] edges;
  int nodeCounter=0;
  Node tempNodeFromList, tempNewNode;
  LinkedList<Node> todoList=new LinkedList<Node>();
  LinkedList<Integer> handledNodes=new LinkedList<Integer>();
  LinkedList<Integer> linkedNodes=new LinkedList<Integer>();
  LinkedList<Integer> newEdges;
  todoList.add(root);
  linkedNodes.add(root.getIndex());
  while (!todoList.isEmpty()) {
    tempNodeFromList=todoList.pop();
    if (handledNodes.contains(tempNodeFromList.getIndex())) {
      continue;
    }
    edges=tempNodeFromList.getOutgoingEdges();
    newEdges=new LinkedList<Integer>();
    for (    int e : edges) {
      if (!linkedNodes.contains(e)) {
        todoList.add(this.nodes[e]);
        newEdges.add(e);
        linkedNodes.add(e);
      }
    }
    tempNewNode=new Node(tempNodeFromList.getIndex(),result);
    edges=new int[newEdges.size()];
    for (int i=0; i < newEdges.size(); i++) {
      edges[i]=newEdges.get(i);
    }
    tempNewNode.setOutgoingEdges(edges);
    resultNodes[nodeCounter]=tempNewNode;
    handledNodes.add(tempNodeFromList.getIndex());
    nodeCounter++;
  }
  result.setNodes(resultNodes);
  return result;
}","public Graph getSpanningTree(Node root){
  Graph result=new Graph(this.name + ""String_Node_Str"");
  Node[] resultNodes=new Node[this.nodes.length];
  int[] edges;
  Node tempNodeFromList, tempNewNode;
  LinkedList<Node> todoList=new LinkedList<Node>();
  LinkedList<Integer> handledNodes=new LinkedList<Integer>();
  LinkedList<Integer> linkedNodes=new LinkedList<Integer>();
  LinkedList<Integer> newEdges;
  todoList.add(root);
  linkedNodes.add(root.getIndex());
  while (!todoList.isEmpty()) {
    tempNodeFromList=todoList.pop();
    if (handledNodes.contains(tempNodeFromList.getIndex())) {
      continue;
    }
    edges=tempNodeFromList.getOutgoingEdges();
    newEdges=new LinkedList<Integer>();
    for (    int e : edges) {
      if (!linkedNodes.contains(e)) {
        todoList.add(this.nodes[e]);
        newEdges.add(e);
        linkedNodes.add(e);
      }
    }
    tempNewNode=new Node(tempNodeFromList.getIndex(),result);
    edges=new int[newEdges.size()];
    for (int i=0; i < newEdges.size(); i++) {
      edges[i]=newEdges.get(i);
    }
    tempNewNode.setOutgoingEdges(edges);
    resultNodes[tempNodeFromList.getIndex()]=tempNewNode;
    handledNodes.add(tempNodeFromList.getIndex());
  }
  result.setNodes(resultNodes);
  return result;
}",0.1857366771159874
38587,"private Route route(ArrayList<Integer> route,int current,Identifier target,Random rand,Node[] nodes,HashSet<Integer> seen){
  route.add(current);
  seen.add(current);
  if (this.idSpace.getPartitions()[current].contains(target)) {
    return new RouteImpl(route,true);
  }
  if (route.size() > this.ttl) {
    return new RouteImpl(route,false);
  }
  LookaheadList list=this.lists.getList(current);
  int via=-1;
  if (list.getList()[0].getPartition() instanceof DPartition) {
    double currentDist=(Double)this.p[current].distance(target);
    double minDist=(Double)this.idSpace.getMaxDistance();
    for (    LookaheadElement l : list.getList()) {
      double dist=((DPartition)l.getPartition()).distance(target);
      if (dist < minDist && dist < currentDist && !seen.contains(l.getVia())) {
        minDist=dist;
        via=l.getVia();
      }
    }
  }
 else   if (list.getList()[0].getPartition() instanceof BIPartition) {
    BigInteger currentDist=(BigInteger)this.p[current].distance(target);
    BigInteger minDist=(BigInteger)this.idSpace.getMaxDistance();
    for (    LookaheadElement l : list.getList()) {
      BigInteger dist=((BIPartition)l.getPartition()).distance(target);
      if (dist.compareTo(minDist) == -1 && dist.compareTo(currentDist) == -1 && !seen.contains(l.getVia())) {
        minDist=dist;
        via=l.getVia();
      }
    }
  }
 else {
    return null;
  }
  if (via == -1) {
    return new RouteImpl(route,false);
  }
  return this.route(route,via,target,rand,nodes,seen);
}","private Route route(ArrayList<Integer> route,int current,Identifier target,Random rand,Node[] nodes,HashSet<Integer> seen){
  route.add(current);
  seen.add(current);
  if (this.idSpace.getPartitions()[current].contains(target)) {
    return new RouteImpl(route,true);
  }
  if (route.size() > this.ttl) {
    return new RouteImpl(route,false);
  }
  LookaheadList list=this.lists.getList(current);
  int via=-1;
  if (list.getList().length == 0) {
    return new RouteImpl(route,false);
  }
  if (list.getList()[0].getPartition() instanceof DPartition) {
    double currentDist=(Double)this.p[current].distance(target);
    double minDist=(Double)this.idSpace.getMaxDistance();
    for (    LookaheadElement l : list.getList()) {
      double dist=((DPartition)l.getPartition()).distance(target);
      if (dist < minDist && dist < currentDist && !seen.contains(l.getVia())) {
        minDist=dist;
        via=l.getVia();
      }
    }
  }
 else   if (list.getList()[0].getPartition() instanceof BIPartition) {
    BigInteger currentDist=(BigInteger)this.p[current].distance(target);
    BigInteger minDist=(BigInteger)this.idSpace.getMaxDistance();
    for (    LookaheadElement l : list.getList()) {
      BigInteger dist=((BIPartition)l.getPartition()).distance(target);
      if (dist.compareTo(minDist) == -1 && dist.compareTo(currentDist) == -1 && !seen.contains(l.getVia())) {
        minDist=dist;
        via=l.getVia();
      }
    }
  }
 else {
    return null;
  }
  if (via == -1) {
    return new RouteImpl(route,false);
  }
  return this.route(route,via,target,rand,nodes,seen);
}",0.9746388443017656
38588,"@Override public Double distance(Identifier<Double> id){
  MDIdentifier to=(MDIdentifier)id;
  if (this.idSpace.getDimensions() != to.getIdSpace().getDimensions()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  double squarredResult=0;
  for (int i=0; i < this.idSpace.getDimensions(); i++) {
    if (this.idSpace.isWrapAround()) {
      squarredResult+=Math.abs(this.coordinates[i] - to.getCoordinate(i)) % (this.idSpace.getModulus(i) / 2.0);
    }
 else {
      squarredResult+=Math.abs(this.coordinates[i] - to.getCoordinate(i));
    }
  }
  return Math.sqrt(squarredResult);
}","@Override public Double distance(Identifier<Double> id){
  MDIdentifier to=(MDIdentifier)id;
  if (this.idSpace.getDimensions() != to.getIdSpace().getDimensions()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  double squarredResult=0;
  double temp;
  for (int i=0; i < this.idSpace.getDimensions(); i++) {
    if (this.idSpace.isWrapAround()) {
      temp=Math.abs(this.coordinates[i] - to.getCoordinate(i)) % (this.idSpace.getModulus(i) / 2.0);
    }
 else {
      temp=Math.abs(this.coordinates[i] - to.getCoordinate(i));
    }
    squarredResult+=Math.pow(temp,2);
  }
  return Math.sqrt(squarredResult);
}",0.6139917695473252
38589,"public BigInteger distance(Identifier<BigInteger> id){
  BigInteger value=((ChordIdentifier)id).getId();
  BigInteger sub1=this.id.subtract(value).abs();
  BigInteger sub2=this.idSpace.getModulus().subtract(sub1);
  return sub1.min(sub2);
}","public BigInteger distance(Identifier<BigInteger> id){
  BigInteger dest=((ChordIdentifier)id).getId();
  if (this.id.compareTo(dest) == -1) {
    return dest.subtract(this.id);
  }
 else {
    return this.idSpace.getModulus().subtract(this.id).add(dest);
  }
}",0.4391217564870259
38590,"@Override public BigInteger distance(Identifier<BigInteger> id){
  if (this.contains(id)) {
    return BigInteger.ZERO;
  }
  BigInteger compare=((ChordIdentifier)id).getId();
  if (this.succ.getId().compareTo(compare) == -1) {
    return compare.subtract(this.succ.getId()).mod(this.succ.getIdSpace().getModulus());
  }
 else {
    return compare.add(this.succ.getIdSpace().getModulus()).subtract(this.succ.getId()).mod(this.succ.getIdSpace().getModulus());
  }
}","@Override public BigInteger distance(Identifier<BigInteger> id){
  if (this.contains(id)) {
    return BigInteger.ZERO;
  }
  BigInteger compare=((ChordIdentifier)id).getId();
  return this.succ.distance(id);
}",0.56973293768546
38591,"/** 
 * @param args
 */
public static void main(String[] args){
  Stats stats=new Stats();
  boolean generate=true;
  int times=1;
  boolean wot=false;
  boolean skipExistingFolders=false;
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  Config.overwrite(""String_Node_Str"",""String_Node_Str"" + skipExistingFolders);
  Network nw1=new ErdosRenyi(1000,20,true,new Greedy(),new Transformation[]{new RandomRingIDSpace()});
  Network nw2=new Chord(1000,20,true,new Greedy(),null);
  Network[] nw=new Network[]{nw1,nw2};
  Series[] s=Series.generate(nw,1);
  Plot.allMulti(s,""String_Node_Str"");
  stats.end();
}","/** 
 * @param args
 */
public static void main(String[] args){
  Stats stats=new Stats();
  boolean generate=true;
  int times=1;
  boolean wot=false;
  boolean skipExistingFolders=false;
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  Config.overwrite(""String_Node_Str"",""String_Node_Str"" + skipExistingFolders);
  Network nw1=new ReadableFile(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null,null);
  Graph g=nw1.generate();
  Transformation t=new RandomRingIDSpaceSimple();
  g=t.transform(g);
  GraphWriter.writeWithProperties(g,""String_Node_Str"");
  Graph g2=GraphReader.readWithProperties(""String_Node_Str"");
  GraphWriter.writeWithProperties(g2,""String_Node_Str"");
  stats.end();
}",0.6654654654654655
38592,"protected NeighborsFirstObfuscatedLookaheadList(String key,boolean randomizeOrder){
  super(key,new String[]{},new String[]{});
  this.randomizeOrder=randomizeOrder;
}","protected NeighborsFirstObfuscatedLookaheadList(String key,boolean randomizeOrder){
  super(key,new String[]{""String_Node_Str""},new String[]{""String_Node_Str"" + randomizeOrder});
  this.randomizeOrder=randomizeOrder;
}",0.8675324675324675
38593,"@Override public Graph transform(Graph g){
  Random rand=new Random();
  GraphProperty[] gps=g.getProperties(""String_Node_Str"");
  for (  GraphProperty p : gps) {
    IdentifierSpace ids=(IdentifierSpace)p;
    ArrayList<LookaheadList> lists=new ArrayList<LookaheadList>();
    for (    Node n : g.getNodes()) {
      ArrayList<LookaheadElement> list=new ArrayList<LookaheadElement>();
      for (      int outIndex : n.getOutgoingEdges()) {
        list.add(new LookaheadElement(ids.getPartitions()[outIndex],outIndex));
        Node out=g.getNode(outIndex);
        for (        int lookaheadIndex : out.getOutgoingEdges()) {
          if (lookaheadIndex == n.getIndex()) {
            continue;
          }
          list.add(new LookaheadElement(this.obfuscatePartition(ids.getPartitions()[lookaheadIndex],rand),outIndex));
        }
      }
      lists.add(new LookaheadList(n.getIndex(),list));
    }
    g.addProperty(g.getNextKey(""String_Node_Str""),new LookaheadLists(lists));
  }
  return g;
}","@Override public Graph transform(Graph g){
  Random rand=new Random();
  GraphProperty[] gps=g.getProperties(""String_Node_Str"");
  for (  GraphProperty p : gps) {
    IdentifierSpace ids=(IdentifierSpace)p;
    ArrayList<LookaheadList> lists=new ArrayList<LookaheadList>();
    for (    Node n : g.getNodes()) {
      ArrayList<LookaheadElement> list=new ArrayList<LookaheadElement>();
      if (this.randomizeOrder) {
        ArrayList<LookaheadElement> neighbors=new ArrayList<LookaheadElement>(n.getOutDegree());
        for (        int outIndex : n.getOutgoingEdges()) {
          neighbors.add(new LookaheadElement(ids.getPartitions()[outIndex],outIndex));
        }
        for (        LookaheadElement neighbor : neighbors) {
          ArrayList<LookaheadElement> lookahead=new ArrayList<LookaheadElement>(g.getNode(neighbor.getVia()).getOutDegree());
          Node out=g.getNode(neighbor.getVia());
          for (          int lookaheadIndex : out.getOutgoingEdges()) {
            if (lookaheadIndex == n.getIndex()) {
              continue;
            }
            lookahead.add(new LookaheadElement(this.obfuscatePartition(ids.getPartitions()[lookaheadIndex],rand),neighbor.getVia()));
          }
          list.add(neighbor);
          list.addAll(lookahead);
        }
      }
 else {
        for (        int outIndex : n.getOutgoingEdges()) {
          list.add(new LookaheadElement(ids.getPartitions()[outIndex],outIndex));
          Node out=g.getNode(outIndex);
          for (          int lookaheadIndex : out.getOutgoingEdges()) {
            if (lookaheadIndex == n.getIndex()) {
              continue;
            }
            list.add(new LookaheadElement(this.obfuscatePartition(ids.getPartitions()[lookaheadIndex],rand),outIndex));
          }
        }
      }
      lists.add(new LookaheadList(n.getIndex(),list));
    }
    g.addProperty(g.getNextKey(""String_Node_Str""),new LookaheadLists(lists));
  }
  return g;
}",0.6393775372124493
38594,"protected NeighborsGroupedObfuscatedLookaheadList(String key,boolean randomizeOrder){
  super(key,new String[]{},new String[]{});
  this.randomizeOrder=randomizeOrder;
}","protected NeighborsGroupedObfuscatedLookaheadList(String key,boolean randomizeOrder){
  super(key,new String[]{""String_Node_Str""},new String[]{""String_Node_Str"" + randomizeOrder});
  this.randomizeOrder=randomizeOrder;
}",0.8688946015424165
38595,"@SuppressWarnings(""String_Node_Str"") protected Partition obfuscatePartition(Partition partition,Random rand){
  if (partition instanceof RingPartitionSimple) {
    RingPartitionSimple p=(RingPartitionSimple)partition;
    double sign=rand.nextBoolean() ? 1.0 : -1.0;
    double epsilon=minEpsilon + rand.nextDouble() * this.size;
    double position=p.getId().getPosition() + sign * epsilon;
    return new RingPartitionSimple(new RingIdentifier(position,p.getId().getIdSpace()));
  }
 else   if (partition instanceof RingPartition) {
    RingPartition p=(RingPartition)partition;
    double sign1=rand.nextBoolean() ? 1.0 : -1.0;
    double epsilon1=minEpsilon + rand.nextDouble() * this.size;
    double position1=p.getStart().getPosition() + sign1 * epsilon1;
    double sign2=rand.nextBoolean() ? 1.0 : -1.0;
    double epsilon2=minEpsilon + rand.nextDouble() * this.size;
    double position2=p.getEnd().getPosition() + sign2 * epsilon2;
    return new RingPartition(new RingIdentifier(position1,p.getStart().getIdSpace()),new RingIdentifier(position2,p.getEnd().getIdSpace()));
  }
 else   if (partition instanceof PlanePartitionSimple) {
    PlanePartitionSimple p=(PlanePartitionSimple)partition;
    double sign1=rand.nextBoolean() ? 1.0 : -1.0;
    double epsilon1=minEpsilon + rand.nextDouble() * this.size;
    double position1=p.getId().getX() + sign1 * epsilon1;
    double sign2=rand.nextBoolean() ? 1.0 : -1.0;
    double epsilon2=minEpsilon + rand.nextDouble() * this.size;
    double position2=p.getId().getY() + sign2 * epsilon2;
    return new PlanePartitionSimple(new PlaneIdentifier(position1,position2,p.getId().getIdSpace()));
  }
 else   if (partition instanceof ChordPartition) {
    ChordPartition p=(ChordPartition)partition;
    BigInteger epsilon1=new BigInteger(this.diff,rand);
    BigInteger position1=rand.nextBoolean() ? p.getPred().getId().add(this.min).add(epsilon1).mod(p.getPred().getIdSpace().getModulus()) : p.getPred().getId().subtract(this.min).subtract(epsilon1).abs().mod(p.getPred().getIdSpace().getModulus());
    BigInteger epsilon2=new BigInteger(this.diff,rand);
    BigInteger position2=rand.nextBoolean() ? p.getPred().getId().add(this.min).add(epsilon2).mod(p.getPred().getIdSpace().getModulus()) : p.getPred().getId().subtract(this.min).subtract(epsilon2).abs().mod(p.getPred().getIdSpace().getModulus());
    return new ChordPartition(new ChordIdentifier(p.getPred().getIdSpace(),position1),new ChordIdentifier(p.getSucc().getIdSpace(),position2));
  }
 else {
    return null;
  }
}","@SuppressWarnings(""String_Node_Str"") protected Partition obfuscatePartition(Partition partition,Random rand){
  if (this.minBits == 0 && this.maxBits == 0) {
    return this.copyPartition(partition);
  }
  if (partition instanceof RingPartitionSimple) {
    RingPartitionSimple p=(RingPartitionSimple)partition;
    double sign=rand.nextBoolean() ? 1.0 : -1.0;
    double epsilon=minEpsilon + rand.nextDouble() * this.size;
    double position=p.getId().getPosition() + sign * epsilon;
    return new RingPartitionSimple(new RingIdentifier(position,p.getId().getIdSpace()));
  }
 else   if (partition instanceof RingPartition) {
    RingPartition p=(RingPartition)partition;
    double sign1=rand.nextBoolean() ? 1.0 : -1.0;
    double epsilon1=minEpsilon + rand.nextDouble() * this.size;
    double position1=p.getStart().getPosition() + sign1 * epsilon1;
    double sign2=rand.nextBoolean() ? 1.0 : -1.0;
    double epsilon2=minEpsilon + rand.nextDouble() * this.size;
    double position2=p.getEnd().getPosition() + sign2 * epsilon2;
    return new RingPartition(new RingIdentifier(position1,p.getStart().getIdSpace()),new RingIdentifier(position2,p.getEnd().getIdSpace()));
  }
 else   if (partition instanceof PlanePartitionSimple) {
    PlanePartitionSimple p=(PlanePartitionSimple)partition;
    double sign1=rand.nextBoolean() ? 1.0 : -1.0;
    double epsilon1=minEpsilon + rand.nextDouble() * this.size;
    double position1=p.getId().getX() + sign1 * epsilon1;
    double sign2=rand.nextBoolean() ? 1.0 : -1.0;
    double epsilon2=minEpsilon + rand.nextDouble() * this.size;
    double position2=p.getId().getY() + sign2 * epsilon2;
    return new PlanePartitionSimple(new PlaneIdentifier(position1,position2,p.getId().getIdSpace()));
  }
 else   if (partition instanceof ChordPartition) {
    ChordPartition p=(ChordPartition)partition;
    BigInteger epsilon1=new BigInteger(this.diff,rand);
    BigInteger position1=rand.nextBoolean() ? p.getPred().getId().add(this.min).add(epsilon1).mod(p.getPred().getIdSpace().getModulus()) : p.getPred().getId().subtract(this.min).subtract(epsilon1).abs().mod(p.getPred().getIdSpace().getModulus());
    BigInteger epsilon2=new BigInteger(this.diff,rand);
    BigInteger position2=rand.nextBoolean() ? p.getSucc().getId().add(this.min).add(epsilon2).mod(p.getSucc().getIdSpace().getModulus()) : p.getSucc().getId().subtract(this.min).subtract(epsilon2).mod(p.getSucc().getIdSpace().getModulus());
    return new ChordPartition(new ChordIdentifier(p.getPred().getIdSpace(),position1),new ChordIdentifier(p.getSucc().getIdSpace(),position2));
  }
 else {
    return null;
  }
}",0.9744384198295896
38596,"protected ObfuscatedLookaheadList(String key,int minBits,int maxBits,String[] configKeys,String[] configValues){
  super(key,ObfuscatedLookaheadList.add(configKeys,""String_Node_Str"",""String_Node_Str""),ObfuscatedLookaheadList.add(configValues,""String_Node_Str"" + BigInteger.ONE.shiftLeft(minBits),""String_Node_Str"" + BigInteger.ONE.shiftLeft(maxBits)));
  this.minBits=minBits;
  this.maxBits=maxBits;
  this.min=BigInteger.ONE.shiftLeft(minBits);
  this.diff=maxBits - minBits;
}","protected ObfuscatedLookaheadList(String key,int minBits,int maxBits,String[] configKeys,String[] configValues){
  super(key,ObfuscatedLookaheadList.add(configKeys,""String_Node_Str"",""String_Node_Str""),ObfuscatedLookaheadList.add(configValues,""String_Node_Str"" + (minBits == 0 ? BigInteger.ZERO : BigInteger.ONE.shiftLeft(minBits)),""String_Node_Str"" + (maxBits == 0 ? BigInteger.ZERO : BigInteger.ONE.shiftLeft(maxBits))));
  this.minBits=minBits;
  this.maxBits=maxBits;
  this.diff=maxBits - minBits;
  if (this.minBits == 0) {
    this.min=BigInteger.ZERO;
  }
 else {
    this.min=BigInteger.ONE.shiftLeft(minBits);
  }
}",0.8159564823209429
38597,"public Edge[] generateEdges(){
  int E=0;
  for (  Node n : this.nodes) {
    E+=n.getDegree();
  }
  Edge[] edges=new Edge[E];
  int index=0;
  for (  Node n : this.nodes) {
    for (    int out : n.getOutgoingEdges()) {
      edges[index++]=new Edge(n.getIndex(),out);
    }
    for (    int in : n.getIncomingEdges()) {
      edges[index++]=new Edge(in,n.getIndex());
    }
  }
  return edges;
}","public Edge[] generateEdges(){
  int E=0;
  for (  Node n : this.nodes) {
    E+=n.getOutDegree();
  }
  Edge[] edges=new Edge[E];
  int index=0;
  for (  Node n : this.nodes) {
    for (    int out : n.getOutgoingEdges()) {
      edges[index++]=new Edge(n.getIndex(),out);
    }
  }
  return edges;
}",0.8125894134477826
38598,"public void computeData(Graph graph,Network nw,HashMap<String,Metric> m){
  this.runtime=new Timer();
  double[] dd=new double[this.maxDegree(graph) + 1];
  double[] ddi=new double[this.maxInDegree(graph) + 1];
  double[] ddo=new double[this.maxOutDegree(graph) + 1];
  for (  Node n : graph.getNodes()) {
    dd[n.getDegree()]++;
    ddi[n.getInDegree()]++;
    ddo[n.getOutDegree()]++;
  }
  for (int i=0; i < dd.length; i++) {
    dd[i]/=(double)graph.getNodes().length;
  }
  for (int i=0; i < ddi.length; i++) {
    ddi[i]/=(double)graph.getNodes().length;
  }
  for (int i=0; i < ddo.length; i++) {
    ddo[i]/=(double)graph.getNodes().length;
  }
  this.degreeDistribution=new Distribution(dd);
  this.inDegreeDistribution=new Distribution(ddi);
  this.outDegreeDistribution=new Distribution(ddo);
  this.nodes=graph.getNodes().length;
  this.edges=graph.generateIncomingEdges().length;
  this.runtime.end();
}","public void computeData(Graph graph,Network nw,HashMap<String,Metric> m){
  this.runtime=new Timer();
  double[] dd=new double[this.maxDegree(graph) + 1];
  double[] ddi=new double[this.maxInDegree(graph) + 1];
  double[] ddo=new double[this.maxOutDegree(graph) + 1];
  for (  Node n : graph.getNodes()) {
    dd[n.getDegree()]++;
    ddi[n.getInDegree()]++;
    ddo[n.getOutDegree()]++;
  }
  for (int i=0; i < dd.length; i++) {
    dd[i]/=(double)graph.getNodes().length;
  }
  for (int i=0; i < ddi.length; i++) {
    ddi[i]/=(double)graph.getNodes().length;
  }
  for (int i=0; i < ddo.length; i++) {
    ddo[i]/=(double)graph.getNodes().length;
  }
  this.degreeDistribution=new Distribution(dd);
  this.inDegreeDistribution=new Distribution(ddi);
  this.outDegreeDistribution=new Distribution(ddo);
  this.nodes=graph.getNodes().length;
  this.edges=graph.generateEdges().length;
  this.runtime.end();
}",0.9649507119386638
38599,"public static void chordTest(){
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  Network nw=new Chord(10000,128,null,null);
  Series s=Series.generate(nw,10);
  Plot.multiConf(s,""String_Node_Str"");
}","public static void chordTest(){
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  RoutingAlgorithm r=new GreedyBI();
  Network nw0=new Chord(16,5,r,null);
  Network[] nw=new Network[]{nw0};
  Series[] s=Series.generate(nw,1);
  Plot.multiConf(s,""String_Node_Str"");
}",0.8978723404255319
38600,"@Override public Graph generate(){
  Graph graph=new Graph(this.description());
  Node[] nodes=Node.init(this.nodes(),graph);
  graph.setNodes(nodes);
  RandomChordIDSpace t=new RandomChordIDSpace(this.bits);
  graph=t.transform(graph);
  ChordIDSpace idSpace=(ChordIDSpace)graph.getProperty(""String_Node_Str"");
  ChordPartition[] partitions=(ChordPartition[])idSpace.getPartitions();
  Edges edges=new Edges(nodes,nodes.length * this.bits);
  for (  Node node : nodes) {
    ChordPartition p=partitions[node.getIndex()];
    BigInteger id=p.getSucc().getId();
    BigInteger predID=p.getPred().getId();
    BigInteger succID=id.add(BigInteger.ONE).mod(idSpace.getModulus());
    int predIndex=this.find(partitions,p.getPred(),node.getIndex());
    int succIndex=this.find(partitions,new ChordID(idSpace,succID),node.getIndex());
    BigInteger add=BigInteger.ONE;
    int[] fingerIndex=new int[this.bits];
    BigInteger[] fingerID=new BigInteger[this.bits];
    for (int i=0; i < this.bits; i++) {
      fingerID[i]=id.add(add).mod(idSpace.getModulus());
      fingerIndex[i]=this.find(partitions,new ChordID(idSpace,fingerID[i]),node.getIndex());
      add=add.shiftLeft(1);
    }
    edges.add(node.getIndex(),predIndex);
    edges.add(node.getIndex(),succIndex);
    for (    int finger : fingerIndex) {
      edges.add(node.getIndex(),finger);
    }
  }
  edges.fill();
  graph.getTimer().end();
  return graph;
}","@Override public Graph generate(){
  Graph graph=new Graph(this.description());
  Node[] nodes=Node.init(this.nodes(),graph);
  graph.setNodes(nodes);
  RandomChordIDSpace t=new RandomChordIDSpace(this.bits);
  graph=t.transform(graph);
  ChordIDSpace idSpace=(ChordIDSpace)graph.getProperty(""String_Node_Str"");
  ChordPartition[] partitions=(ChordPartition[])idSpace.getPartitions();
  Edges edges=new Edges(nodes,nodes.length * this.bits);
  for (  Node node : nodes) {
    ChordPartition p=partitions[node.getIndex()];
    BigInteger id=p.getSucc().getId();
    BigInteger predID=p.getPred().getId();
    BigInteger succID=id.add(BigInteger.ONE).mod(idSpace.getModulus());
    int predIndex=this.find(partitions,p.getPred(),node.getIndex());
    int succIndex=this.find(partitions,new ChordID(idSpace,succID),node.getIndex());
    BigInteger add=BigInteger.ONE;
    int[] fingerIndex=new int[this.bits];
    BigInteger[] fingerID=new BigInteger[this.bits];
    for (int i=0; i < this.bits; i++) {
      fingerID[i]=id.add(add).mod(idSpace.getModulus());
      fingerIndex[i]=this.find(partitions,new ChordID(idSpace,fingerID[i]),node.getIndex());
      add=add.shiftLeft(1);
    }
    edges.add(node.getIndex(),succIndex);
    for (    int finger : fingerIndex) {
      edges.add(node.getIndex(),finger);
    }
  }
  edges.fill();
  graph.getTimer().end();
  return graph;
}",0.9849785407725322
38601,"@Override public BigInteger distance(BIID id){
  return this.succ.distance(id);
}","@Override public BigInteger distance(BIID id){
  if (this.contains(id)) {
    return BigInteger.ZERO;
  }
  BigInteger compare=((ChordID)id).getId();
  if (this.succ.getId().compareTo(compare) == -1) {
    return compare.subtract(this.succ.getId()).mod(this.succ.getIdSpace().getModulus());
  }
 else {
    return compare.add(this.succ.getIdSpace().getModulus()).subtract(this.succ.getId()).mod(this.succ.getIdSpace().getModulus());
  }
}",0.2003853564547206
38602,"@Override public boolean applicable(Graph graph){
  return graph.hasProperty(""String_Node_Str"") && graph.getProperty(""String_Node_Str"") instanceof IDSpace;
}","@Override public boolean applicable(Graph graph){
  return graph.hasProperty(""String_Node_Str"") && graph.getProperty(""String_Node_Str"") instanceof BIIDSpace;
}",0.9936708860759492
38603,"@Override public void computeData(Graph g,Network n,HashMap<String,Metric> m){
  if (!g.hasProperty(""String_Node_Str"")) {
    this.runtime=new Timer();
    this.communitySize=new Distribution(new double[]{0.0});
    this.runtime.end();
  }
  this.runtime=new Timer();
  gtna.communities.Communities communities=(gtna.communities.Communities)g.getProperty(""String_Node_Str"");
  double[] c=new double[communities.getCommunities().length];
  for (int i=0; i < c.length; i++) {
    c[i]=(double)communities.getCommunities()[i].getNodes().length / (double)g.getNodes().length;
  }
  Arrays.sort(c);
  for (int i=0; i < c.length / 2; i++) {
    double temp=c[i];
    c[i]=c[c.length - i - 1];
    c[c.length - i - 1]=temp;
  }
  this.communitySize=new Distribution(c);
  this.runtime.end();
}","@Override public void computeData(Graph g,Network n,HashMap<String,Metric> m){
  if (!g.hasProperty(""String_Node_Str"")) {
    this.runtime=new Timer();
    this.communitySize=new Distribution(new double[]{0.0});
    this.runtime.end();
    return;
  }
  this.runtime=new Timer();
  gtna.communities.Communities communities=(gtna.communities.Communities)g.getProperty(""String_Node_Str"");
  double[] c=new double[communities.getCommunities().length];
  for (int i=0; i < c.length; i++) {
    c[i]=(double)communities.getCommunities()[i].getNodes().length / (double)g.getNodes().length;
  }
  Arrays.sort(c);
  for (int i=0; i < c.length / 2; i++) {
    double temp=c[i];
    c[i]=c[c.length - i - 1];
    c[c.length - i - 1]=temp;
  }
  this.communitySize=new Distribution(c);
  this.runtime.end();
}",0.9924242424242424
38604,"private static void testRouting(){
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  Transformation t1=new RandomRingIDSpaceSimple();
  Transformation[] t=new Transformation[]{t1};
  RoutingAlgorithm r1=new Greedy();
  RoutingAlgorithm r2=new GreedyBacktracking();
  Network nw1=new ReadableFile(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",r1,t);
  Network nw2=new ReadableFile(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",r2,t);
  Network[] nw=new Network[]{nw1,nw2};
  Series[] s=Series.generate(nw,100);
  Plot.multiAvg(s,""String_Node_Str"");
  Plot.singlesAvg(s,""String_Node_Str"");
}","private static void testRouting(){
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  Config.overwrite(""String_Node_Str"",""String_Node_Str"");
  Transformation t1=new RandomRingIDSpaceSimple();
  Transformation[] t=new Transformation[]{t1};
  RoutingAlgorithm r1=new Greedy();
  RoutingAlgorithm r2=new GreedyBacktracking();
  Network nw1=new ErdosRenyi(100,10,true,r1,t);
  Network nw2=new ErdosRenyi(100,10,true,r2,t);
  Network[] nw=new Network[]{nw1,nw2};
  Series[] s=Series.generate(nw,1);
  Plot.multiAvg(s,""String_Node_Str"");
  Plot.singlesAvg(s,""String_Node_Str"");
}",0.8933500627352572
38605,"@Override public Route routeToRandomTarget(Graph graph,int start,Random rand){
  ID target=this.idSpace.randomID(rand);
  while (this.p[start].contains(target)) {
    target=this.idSpace.randomID(rand);
  }
  return this.route(new ArrayList<Integer>(),start,target,rand,graph.getNodes(),new HashMap<Integer,Integer>());
}","@Override public Route routeToRandomTarget(Graph graph,int start,Random rand){
  ID target=this.idSpace.randomID(rand);
  while (this.p[start].contains(target)) {
    target=this.idSpace.randomID(rand);
  }
  System.out.println(""String_Node_Str"");
  return this.route(new ArrayList<Integer>(),start,target,rand,graph.getNodes(),new HashMap<Integer,Integer>());
}",0.9399707174231332
38606,"private Route route(ArrayList<Integer> route,int current,ID target,Random rand,Node[] nodes,HashMap<Integer,Integer> from){
  route.add(current);
  if (this.idSpace.getPartitions()[current].contains(target)) {
    return new RouteImpl(route,true);
  }
  double currentDist=this.idSpace.getPartitions()[current].distance(target);
  double minDist=Double.MAX_VALUE;
  int minNode=-1;
  for (  int out : nodes[current].getOutgoingEdges()) {
    double dist=this.p[out].distance(target);
    if (dist < minDist && dist < currentDist && !from.containsKey(out)) {
      minDist=dist;
      minNode=out;
    }
  }
  if (minNode == -1 && from.containsKey(current)) {
    return this.route(route,from.get(current),target,rand,nodes,from);
  }
 else   if (minNode == -1) {
    return new RouteImpl(route,false);
  }
  from.put(current,minNode);
  return this.route(route,minNode,target,rand,nodes,from);
}","private Route route(ArrayList<Integer> route,int current,ID target,Random rand,Node[] nodes,HashMap<Integer,Integer> from){
  System.out.println(""String_Node_Str"" + current);
  route.add(current);
  if (this.idSpace.getPartitions()[current].contains(target)) {
    return new RouteImpl(route,true);
  }
  double currentDist=this.idSpace.getPartitions()[current].distance(target);
  double minDist=Double.MAX_VALUE;
  int minNode=-1;
  for (  int out : nodes[current].getOutgoingEdges()) {
    double dist=this.p[out].distance(target);
    if (dist < minDist && dist < currentDist && !from.containsKey(out)) {
      minDist=dist;
      minNode=out;
    }
  }
  if (minNode == -1 && from.containsKey(current)) {
    System.out.println(""String_Node_Str"");
    return this.route(route,from.get(current),target,rand,nodes,from);
  }
 else   if (minNode == -1) {
    System.out.println(""String_Node_Str"" + route.size() + ""String_Node_Str""+ from.size());
    System.out.println(""String_Node_Str"" + current);
    for (int i=0; i < route.size(); i++) {
      System.out.print(""String_Node_Str"" + route.get(i) + ""String_Node_Str""+ from.containsKey(current));
    }
    System.out.println(""String_Node_Str"");
    return new RouteImpl(route,false);
  }
  System.out.println(""String_Node_Str"" + current + ""String_Node_Str""+ minNode);
  from.put(minNode,current);
  return this.route(route,minNode,target,rand,nodes,from);
}",0.7574837310195228
38607,"@Override public void read(String filename,Graph graph){
  Filereader fr=new Filereader(filename);
  fr.readLine();
  String key=fr.readLine();
  int partitions=Integer.parseInt(fr.readLine());
  this.partitions=new RingPartitionSimple[partitions];
  String line=null;
  while ((line=fr.readLine()) != null) {
    String[] temp=line.split(""String_Node_Str"");
    int index=Integer.parseInt(temp[0]);
    this.partitions[index++]=new RingPartitionSimple(temp[1]);
  }
  fr.close();
  graph.addProperty(key,this);
}","@Override public void read(String filename,Graph graph){
  Filereader fr=new Filereader(filename);
  fr.readLine();
  String key=fr.readLine();
  int partitions=Integer.parseInt(fr.readLine());
  this.partitions=new RingPartitionSimple[partitions];
  String line=null;
  while ((line=fr.readLine()) != null) {
    String[] temp=line.split(""String_Node_Str"");
    int index=Integer.parseInt(temp[0]);
    this.partitions[index]=new RingPartitionSimple(temp[1]);
  }
  fr.close();
  graph.addProperty(key,this);
}",0.998046875
38608,"@Override public double distance(ID id){
  return this.id.distance((RingID)id);
}","@Override public double distance(ID id){
  return this.id.distance(id);
}",0.948051948051948
38609,"public ReadableFolder(String name,String folder,String src,int type,RoutingAlgorithm ra,Transformation[] t){
  super(key(name,folder),Integer.MIN_VALUE,new String[]{},new String[]{},ra,t);
  this.type=type;
  File d=new File(src);
  if (!d.exists()) {
    this.files=new String[0];
  }
 else {
    File[] f=d.listFiles();
    this.files=new String[f.length];
    for (int i=0; i < f.length; i++) {
      this.files[i]=f[i].getAbsolutePath();
    }
  }
  this.index=-1;
  super.setNodes(GraphReader.nodes(this.files[0],this.type));
}","public ReadableFolder(String name,String folder,String src,int type,RoutingAlgorithm ra,Transformation[] t){
  super(key(name,folder),Integer.MIN_VALUE,new String[]{},new String[]{},ra,t);
  this.type=type;
  File d=new File(src);
  if (!d.exists()) {
    this.files=new String[0];
  }
 else {
    File[] f=d.listFiles();
    this.files=new String[f.length];
    for (int i=0; i < f.length; i++) {
      this.files[i]=f[i].getAbsolutePath();
    }
  }
  this.index=-1;
  if (this.files.length == 0) {
    super.setNodes(0);
  }
 else {
    super.setNodes(GraphReader.nodes(this.files[0],this.type));
  }
}",0.934036939313984
38610,"public static String formatNumber(double d,int decimalPlaces){
  if (decimalPlaces < 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (decimalPlaces == 0) {
    long rounded=Math.round(d);
    return addCommas(rounded + ""String_Node_Str"");
  }
 else {
    long rounded=Math.round(d * Math.pow(10,decimalPlaces));
    d=rounded;
    for (int i=0; i < decimalPlaces; i++) {
      d/=10.0d;
    }
    String s=showAllDigitsFormat.format(d);
    int decimalIndex=s.indexOf('.');
    String leftSide=s.substring(0,decimalIndex);
    String rightSide=s.substring(decimalIndex + 1);
    leftSide=addCommas(leftSide);
    if (decimalPlaces < rightSide.length()) {
      rightSide=rightSide.substring(0,decimalPlaces);
    }
 else     if (decimalPlaces > rightSide.length()) {
      StringBuilder sb=new StringBuilder(rightSide);
      for (int i=0; i < decimalPlaces - rightSide.length(); i++) {
        sb.append('0');
      }
      rightSide=sb.toString();
    }
    return leftSide + ""String_Node_Str"" + rightSide;
  }
}","public static String formatNumber(double d,int decimalPlaces){
  if (decimalPlaces < 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (decimalPlaces == 0) {
    long rounded=Math.round(d);
    return addCommas(rounded + ""String_Node_Str"");
  }
 else {
    long rounded=Math.round(d * Math.pow(10,decimalPlaces));
    d=rounded;
    for (int i=0; i < decimalPlaces; i++) {
      d/=10.0d;
    }
    String s=showAllDigitsFormat.format(d);
    int decimalIndex=0;
    if (s.contains(""String_Node_Str"")) {
      decimalIndex=s.indexOf('.');
    }
 else     if (s.contains(""String_Node_Str"")) {
      decimalIndex=s.indexOf(',');
    }
    String leftSide=s.substring(0,decimalIndex);
    String rightSide=s.substring(decimalIndex + 1);
    leftSide=addCommas(leftSide);
    if (decimalPlaces < rightSide.length()) {
      rightSide=rightSide.substring(0,decimalPlaces);
    }
 else     if (decimalPlaces > rightSide.length()) {
      StringBuilder sb=new StringBuilder(rightSide);
      for (int i=0; i < decimalPlaces - rightSide.length(); i++) {
        sb.append('0');
      }
      rightSide=sb.toString();
    }
    return leftSide + ""String_Node_Str"" + rightSide;
  }
}",0.9297539149888144
38611,"private double[] computeLCC(NodeImpl[] nodes,HashMap<String,Edge> map){
  double[] lcc=new double[nodes.length];
  for (int i=0; i < nodes.length; i++) {
    Node[] neighborhood=this.neighborhood(nodes[i]);
    if (neighborhood.length == 1) {
      lcc[i]=0;
    }
 else {
      int edges=this.edgesInNeighborhood_NEW(neighborhood,nodes[i],nodes.length,map);
      lcc[i]=edges / (double)(neighborhood.length * (neighborhood.length - 1));
    }
  }
  return lcc;
}","private double[] computeLCC(NodeImpl[] nodes,boolean onlyOut){
  double[] lcc=new double[nodes.length];
  for (int i=0; i < nodes.length; i++) {
    Set<NodeImpl> n=this.neighborhood(nodes[i],onlyOut);
    if (n.size() <= 1) {
      lcc[i]=0;
    }
 else {
      int edges=this.edgesInNeighborhood(n);
      lcc[i]=edges / (double)(n.size() * (n.size() - 1));
    }
  }
  return lcc;
}",0.7067137809187279
38612,"public Value[] getValues(Value[] values){
  Value CC=new Value(""String_Node_Str"",this.cc);
  Value CCW=new Value(""String_Node_Str"",this.ccw);
  Value CC_RT=new Value(""String_Node_Str"",this.timer.rt());
  return new Value[]{CC,CCW,CC_RT};
}","public Value[] getValues(Value[] values){
  Value CC=new Value(""String_Node_Str"",this.cc);
  Value CCW=new Value(""String_Node_Str"",this.ccw);
  Value RT=new Value(""String_Node_Str"",this.timer.rt());
  return new Value[]{CC,CCW,RT};
}",0.9872881355932204
38613,"public void computeData(Graph g,Network n,Hashtable<String,Metric> m){
  this.timer=new Timer();
  double[] lcc=this.computeLCC(g.nodes,g.map());
  Arrays.sort(lcc);
  this.lcc=lcc;
  this.lccShort=Util.avgArray(lcc,Config.getInt(""String_Node_Str""));
  this.cc=this.computeCC(this.lcc);
  this.ccw=this.computeCCW(this.lcc,g.nodes);
  this.timer.end();
}","public void computeData(Graph g,Network n,Hashtable<String,Metric> m){
  this.timer=new Timer();
  boolean onlyOut=GraphProperties.bidirectional(g) || Config.getBoolean(""String_Node_Str"");
  this.lcc=this.computeLCC(g.nodes,onlyOut);
  Arrays.sort(this.lcc);
  this.lccShort=this.computeLCCShort(this.lcc);
  this.cc=this.computeCC(this.lcc);
  this.ccw=this.computeCCW(this.lcc,g.nodes);
  this.timer.end();
}",0.6178010471204188
38614,"private Node[] neighborhood(NodeImpl node){
  ArrayList<NodeImpl> neighborhood=new ArrayList<NodeImpl>(node.out().length + node.in().length);
  neighborhood.add(node);
  NodeImpl[] out=node.out();
  for (int i=0; i < out.length; i++) {
    neighborhood.add(out[i]);
  }
  NodeImpl[] in=node.in();
  for (int i=0; i < in.length; i++) {
    if (!neighborhood.contains(in[i])) {
      neighborhood.add(in[i]);
    }
  }
  return Util.toNodeImplArray(neighborhood);
}","private Set<NodeImpl> neighborhood(NodeImpl node,boolean onlyOut){
  Set<NodeImpl> n=new HashSet<NodeImpl>();
  NodeImpl[] OUT=node.out();
  for (  NodeImpl out : OUT) {
    n.add(out);
  }
  if (!onlyOut) {
    NodeImpl[] IN=node.in();
    for (    NodeImpl in : IN) {
      n.add(in);
    }
  }
  return n;
}",0.3984476067270375
38615,"protected SortingNode[] generateNodes(Graph g,Random rand){
  HashSet<NodeImpl> attackers=ATTACK_NONE.equals(this.attack) ? new HashSet<NodeImpl>() : this.selectNodesRandomly(g.nodes,this.attackers,rand);
  SortingNode[] nodes=new SortingNode[g.nodes.length];
  for (int i=0; i < g.nodes.length; i++) {
    double pos=((RingNode)g.nodes[i]).getID().pos;
    if (attackers.contains(g.nodes[i])) {
      System.out.println(""String_Node_Str"" + i);
      if (ATTACK_CONTRACTION.equals(this.attack)) {
        nodes[i]=new SwappingAttackerContraction(i,pos,this);
      }
 else       if (ATTACK_CONVERGENCE.equals(this.attack)) {
        nodes[i]=new SwappingAttackerConvergence(i,pos,this);
      }
 else       if (ATTACK_KLEINBERG.equals(this.attack)) {
        nodes[i]=new SwappingAttackerKleinberg(i,pos,this);
      }
 else       if (ATTACK_CONTRACTION_WC.equals(this.attack)) {
        nodes[i]=new SwappingWCAttackerContraction(i,pos,this);
      }
 else       if (ATTACK_CONVERGENCE_WC.equals(this.attack)) {
        nodes[i]=new SwappingWCAttackerConvergence(i,pos,this);
      }
 else       if (ATTACK_KLEINBERG_WC.equals(this.attack)) {
        nodes[i]=new SwappingWCAttackerKleinberg(i,pos,this);
      }
 else {
        throw new IllegalArgumentException(this.attack + ""String_Node_Str"");
      }
    }
 else {
      if (ATTACK_NONE.equals(this.attack) || ATTACK_CONTRACTION.equals(this.attack) || ATTACK_CONVERGENCE.equals(this.attack)|| ATTACK_KLEINBERG.equals(this.attack)) {
        nodes[i]=new SwappingNode(i,pos,this);
      }
 else       if (ATTACK_CONTRACTION_WC.equals(this.attack) || ATTACK_CONVERGENCE_WC.equals(this.attack) || ATTACK_KLEINBERG_WC.equals(this.attack)) {
        nodes[i]=new SwappingWCNode(i,pos,this);
      }
    }
  }
  this.init(g,null);
  return nodes;
}","protected SortingNode[] generateNodes(Graph g,Random rand){
  HashSet<NodeImpl> attackers=ATTACK_NONE.equals(this.attack) ? new HashSet<NodeImpl>() : this.selectNodesRandomly(g.nodes,this.attackers,rand);
  SortingNode[] nodes=new SortingNode[g.nodes.length];
  for (int i=0; i < g.nodes.length; i++) {
    double pos=((RingNode)g.nodes[i]).getID().pos;
    if (attackers.contains(g.nodes[i])) {
      System.out.println(""String_Node_Str"" + i);
      if (ATTACK_CONTRACTION.equals(this.attack)) {
        nodes[i]=new SwappingAttackerContraction(i,pos,this);
      }
 else       if (ATTACK_CONVERGENCE.equals(this.attack)) {
        nodes[i]=new SwappingAttackerConvergence(i,pos,this);
      }
 else       if (ATTACK_KLEINBERG.equals(this.attack)) {
        nodes[i]=new SwappingAttackerKleinberg(i,pos,this);
      }
 else       if (ATTACK_CONTRACTION_WC.equals(this.attack)) {
        nodes[i]=new SwappingWCAttackerContraction(i,pos,this);
      }
 else       if (ATTACK_CONVERGENCE_WC.equals(this.attack)) {
        nodes[i]=new SwappingWCAttackerConvergence(i,pos,this);
      }
 else       if (ATTACK_KLEINBERG_WC.equals(this.attack)) {
        nodes[i]=new SwappingWCAttackerKleinberg(i,pos,this);
      }
 else {
        throw new IllegalArgumentException(this.attack + ""String_Node_Str"");
      }
    }
 else {
      if (ATTACK_NONE.equals(this.attack) || ATTACK_CONTRACTION.equals(this.attack) || ATTACK_CONVERGENCE.equals(this.attack)|| ATTACK_KLEINBERG.equals(this.attack)) {
        nodes[i]=new SwappingNode(i,pos,this);
      }
 else       if (ATTACK_CONTRACTION_WC.equals(this.attack) || ATTACK_CONVERGENCE_WC.equals(this.attack) || ATTACK_KLEINBERG_WC.equals(this.attack)) {
        nodes[i]=new SwappingWCNode(i,pos,this);
      }
    }
  }
  this.init(g,nodes);
  return nodes;
}",0.9891576313594662
38616,"private synchronized void singleMapping(){
  SingleMappingHandler mcs;
  mcs=new SingleMappingHandler(getQuery(),getTarget(),isMatchBonds(),isMatchRings());
  clearMaps();
  getMCSList().addAll(mcs.getAllAtomMapping());
}","private synchronized void singleMapping(){
  SingleMappingHandler mcs;
  mcs=new SingleMappingHandler(getQuery(),getTarget(),isMatchRings());
  clearMaps();
  getMCSList().addAll(mcs.getAllAtomMapping());
}",0.9648711943793912
38617,"/** 
 * Returns true if query is a subgraph of target molecule
 * @return
 * @throws CDKException
 */
private synchronized boolean findSubgraph() throws CDKException {
  boolean isSubgraph=false;
  if ((getTarget() == null) || (getQuery() == null)) {
    throw new CDKException(""String_Node_Str"");
  }
  if (getQuery().getAtomCount() == 1 || getTarget().getAtomCount() == 1) {
    singleMapping(isMatchBonds());
  }
 else {
    if (getQuery().getAtomCount() > getTarget().getAtomCount()) {
      return false;
    }
    VF2 mapper;
    List<AtomAtomMapping> mappingsVF2=new ArrayList<>();
    if (getQuery() instanceof IQueryAtomContainer) {
      mapper=new VF2((IQueryAtomContainer)getQuery(),getTarget());
    }
 else {
      mapper=new VF2(getQuery(),getTarget(),isMatchBonds(),isMatchRings(),isMatchAtomType());
    }
    isSubgraph=mapper.isSubgraph();
    List<AtomAtomMapping> atomMappings=mapper.getAllAtomMapping();
    if (isSubgraph) {
      mappingsVF2.addAll(atomMappings);
    }
 else {
      return false;
    }
    setVFMappings(mappingsVF2);
  }
  return isSubgraph;
}","/** 
 * Returns true if query is a subgraph of target molecule
 * @return
 * @throws CDKException
 */
private synchronized boolean findSubgraph() throws CDKException {
  boolean isSubgraph;
  if ((getTarget() == null) || (getQuery() == null)) {
    throw new CDKException(""String_Node_Str"");
  }
  if (getQuery().getAtomCount() == 1 || getTarget().getAtomCount() == 1) {
    isSubgraph=singleMapping();
  }
 else {
    if (getQuery().getAtomCount() > getTarget().getAtomCount()) {
      return false;
    }
    VF2 mapper;
    List<AtomAtomMapping> mappingsVF2=new ArrayList<>();
    if (getQuery() instanceof IQueryAtomContainer) {
      mapper=new VF2((IQueryAtomContainer)getQuery(),getTarget());
    }
 else {
      mapper=new VF2(getQuery(),getTarget(),isMatchBonds(),isMatchRings(),isMatchAtomType());
    }
    isSubgraph=mapper.isSubgraph();
    List<AtomAtomMapping> atomMappings=mapper.getAllAtomMapping();
    if (isSubgraph) {
      mappingsVF2.addAll(atomMappings);
    }
 else {
      return false;
    }
    setVFMappings(mappingsVF2);
  }
  return isSubgraph;
}",0.9856680536292188
38618,"private synchronized void singleMapping(boolean shouldMatchBonds){
  SingleMappingHandler mcs;
  if (!(getQuery() instanceof IQueryAtomContainer) && !(getTarget() instanceof IQueryAtomContainer)) {
    mcs=new SingleMappingHandler(getQuery(),getTarget(),shouldMatchBonds,isMatchRings());
  }
 else {
    mcs=new SingleMappingHandler((IQueryAtomContainer)getQuery(),getTarget());
  }
  getMCSList().addAll(mcs.getAllAtomMapping());
}","private synchronized boolean singleMapping(){
  SingleMappingHandler mcs;
  if (!(getQuery() instanceof IQueryAtomContainer) && !(getTarget() instanceof IQueryAtomContainer)) {
    mcs=new SingleMappingHandler(getQuery(),getTarget(),isMatchRings());
  }
 else {
    mcs=new SingleMappingHandler((IQueryAtomContainer)getQuery(),getTarget());
  }
  return mcs.getAllAtomMapping() != null && !mcs.getAllAtomMapping().isEmpty();
}",0.8438228438228438
38619,"/** 
 * Returns true if query is a subgraph of target molecule
 * @return
 * @throws CDKException
 */
private synchronized boolean findSubgraphs() throws CDKException {
  boolean isSubgraph=false;
  if ((getTarget() == null) || (getQuery() == null)) {
    throw new CDKException(""String_Node_Str"");
  }
  if (getQuery().getAtomCount() == 1 || getTarget().getAtomCount() == 1) {
    singleMapping(isMatchBonds());
  }
 else {
    if (getQuery().getAtomCount() > getTarget().getAtomCount()) {
      return false;
    }
 else {
      List<AtomAtomMapping> mappingsVF2=new ArrayList<>();
      VF2Sub mapper;
      if (getQuery() instanceof IQueryAtomContainer) {
        mapper=new VF2Sub((IQueryAtomContainer)getQuery(),getTarget());
      }
 else {
        mapper=new VF2Sub(getQuery(),getTarget(),isMatchBonds(),isMatchRings(),isMatchAtomType());
      }
      isSubgraph=mapper.isSubgraph();
      List<AtomAtomMapping> atomMappings=mapper.getAllAtomMapping();
      if (isSubgraph) {
        mappingsVF2.addAll(atomMappings);
      }
 else {
        return false;
      }
      setVFMappings(mappingsVF2);
    }
  }
  return isSubgraph;
}","/** 
 * Returns true if query is a subgraph of target molecule
 * @return
 * @throws CDKException
 */
private synchronized boolean findSubgraphs() throws CDKException {
  boolean isSubgraph;
  if ((getTarget() == null) || (getQuery() == null)) {
    throw new CDKException(""String_Node_Str"");
  }
  if (getQuery().getAtomCount() == 1 || getTarget().getAtomCount() == 1) {
    isSubgraph=singleMapping();
  }
 else {
    if (getQuery().getAtomCount() > getTarget().getAtomCount()) {
      return false;
    }
 else {
      List<AtomAtomMapping> mappingsVF2=new ArrayList<>();
      VF2Sub mapper;
      if (getQuery() instanceof IQueryAtomContainer) {
        mapper=new VF2Sub((IQueryAtomContainer)getQuery(),getTarget());
      }
 else {
        mapper=new VF2Sub(getQuery(),getTarget(),isMatchBonds(),isMatchRings(),isMatchAtomType());
      }
      isSubgraph=mapper.isSubgraph();
      List<AtomAtomMapping> atomMappings=mapper.getAllAtomMapping();
      if (isSubgraph) {
        mappingsVF2.addAll(atomMappings);
      }
 else {
        return false;
      }
      setVFMappings(mappingsVF2);
    }
  }
  return isSubgraph;
}",0.986349625715544
38620,"/** 
 * Constructor
 * @param queryBond query GraphMolecule
 * @param shouldMatchBonds bond match flag
 * @param matchAtomTypes
 */
public DefaultBondMatcher(IBond queryBond,boolean shouldMatchBonds,boolean matchAtomTypes){
  super();
  this.queryBond=queryBond;
  this.shouldMatchBonds=shouldMatchBonds;
  this.matchAtomTypes=matchAtomTypes;
}","/** 
 * Constructor
 * @param queryBond query GraphMolecule
 * @param shouldMatchBonds bond match flag
 * @param shouldMatchRings
 * @param matchAtomTypes
 */
public DefaultBondMatcher(IBond queryBond,boolean shouldMatchBonds,boolean shouldMatchRings,boolean matchAtomTypes){
  super();
  this.queryBond=queryBond;
  this.shouldMatchBonds=shouldMatchBonds;
  this.shouldMatchRings=shouldMatchRings;
  this.matchAtomTypes=matchAtomTypes;
}",0.8797953964194374
38621,"/** 
 * {@inheritDoc}
 * @param targetBond target bond
 * @return true if bonds match
 */
@Override public boolean matches(IBond targetBond){
  if (this.queryBond != null && queryBond instanceof IQueryBond) {
    return ((IQueryBond)queryBond).matches(targetBond);
  }
 else   if ((queryBond != null && targetBond != null) && (!isBondMatchFlag() || (isBondMatchFlag() && isBondTypeMatch(targetBond)))) {
    return true;
  }
  return false;
}","/** 
 * {@inheritDoc}
 * @param targetBond target bond
 * @return true if bonds match
 */
@Override public boolean matches(IBond targetBond){
  if (this.queryBond != null && queryBond instanceof IQueryBond) {
    return ((IQueryBond)queryBond).matches(targetBond);
  }
 else   if ((queryBond != null && targetBond != null) && isBondMatchFlag() && isBondTypeMatch(targetBond)) {
    return true;
  }
 else   if ((queryBond != null && targetBond != null) && !isBondMatchFlag() && isShouldMatchRings()) {
    if (queryBond.getFlag(CDKConstants.ISAROMATIC) && targetBond.getFlag(CDKConstants.ISAROMATIC)) {
      return true;
    }
    return !queryBond.getFlag(CDKConstants.ISAROMATIC) && !targetBond.getFlag(CDKConstants.ISAROMATIC);
  }
  return false;
}",0.6711297071129707
38622,"/** 
 * @param bondA1
 * @param bondA2
 * @param matchBond
 * @param shouldMatchRings
 * @param matchAtomTypes (atom type also matched and symbol matched)
 * @return
 */
public static boolean matches(IBond bondA1,IBond bondA2,boolean matchBond,boolean shouldMatchRings,boolean matchAtomTypes){
  if (!isAtomMatch(bondA1,bondA2,shouldMatchRings,matchAtomTypes)) {
    return false;
  }
  return !matchBond || isBondMatch(new DefaultBondMatcher(bondA1,matchBond,matchAtomTypes),bondA2);
}","/** 
 * @param bondA1
 * @param bondA2
 * @param matchBond
 * @param shouldMatchRings
 * @param matchAtomTypes (atom type also matched and symbol matched)
 * @return
 */
public static boolean matches(IBond bondA1,IBond bondA2,boolean matchBond,boolean shouldMatchRings,boolean matchAtomTypes){
  if (!isAtomMatch(bondA1,bondA2,shouldMatchRings,matchAtomTypes)) {
    return false;
  }
  return isBondMatch(new DefaultBondMatcher(bondA1,matchBond,shouldMatchRings,matchAtomTypes),bondA2);
}",0.9682051282051282
38623,"/** 
 * @param list
 * @param source
 * @param target
 */
protected synchronized void identifyMatchedParts(List<List<CDKRMap>> list,IAtomContainer source,IAtomContainer target){
  List<IAtom> array1=new ArrayList<IAtom>();
  List<IAtom> array2=new ArrayList<IAtom>();
  for (  List<CDKRMap> rMap : list) {
    Map<Integer,Integer> atomNumbersFromContainer=new TreeMap<>();
    for (    CDKRMap rmap : rMap) {
      IAtom sourceAtom=source.getAtom(rmap.getId1());
      IAtom targetAtom=target.getAtom(rmap.getId2());
      array1.add(sourceAtom);
      array2.add(targetAtom);
      int indexI=source.getAtomNumber(sourceAtom);
      int indexJ=target.getAtomNumber(targetAtom);
      atomNumbersFromContainer.put(indexI,indexJ);
    }
    getMappings().add(atomNumbersFromContainer);
  }
}","/** 
 * @param list
 * @param source
 * @param target
 */
protected synchronized void identifyMatchedParts(List<List<CDKRMap>> list,IAtomContainer source,IAtomContainer target){
  for (  List<CDKRMap> rMap : list) {
    Map<Integer,Integer> atomNumbersFromContainer=new TreeMap<>();
    for (    CDKRMap rmap : rMap) {
      IAtom sourceAtom=source.getAtom(rmap.getId1());
      IAtom targetAtom=target.getAtom(rmap.getId2());
      int indexI=source.getAtomNumber(sourceAtom);
      int indexJ=target.getAtomNumber(targetAtom);
      atomNumbersFromContainer.put(indexI,indexJ);
    }
    getMappings().add(atomNumbersFromContainer);
  }
}",0.8951048951048951
38624,"/** 
 * @param list
 * @param source
 * @param target
 */
protected synchronized void identifySingleAtomsMatchedParts(List<CDKRMap> list,IAtomContainer source,IAtomContainer target){
  List<IAtom> array1=new ArrayList<>();
  List<IAtom> array2=new ArrayList<>();
  TreeMap<Integer,Integer> atomNumbersFromContainer=new TreeMap<>();
  for (  CDKRMap rmap : list) {
    IAtom sAtom=source.getAtom(rmap.getId1());
    IAtom tAtom=target.getAtom(rmap.getId2());
    array1.add(sAtom);
    array2.add(tAtom);
    int indexI=source.getAtomNumber(sAtom);
    int indexJ=target.getAtomNumber(tAtom);
    atomNumbersFromContainer.put(indexI,indexJ);
    getMappings().add(atomNumbersFromContainer);
  }
}","/** 
 * @param list
 * @param source
 * @param target
 */
protected synchronized void identifySingleAtomsMatchedParts(List<CDKRMap> list,IAtomContainer source,IAtomContainer target){
  TreeMap<Integer,Integer> atomNumbersFromContainer=new TreeMap<>();
  for (  CDKRMap rmap : list) {
    IAtom sAtom=source.getAtom(rmap.getId1());
    IAtom tAtom=target.getAtom(rmap.getId2());
    int indexI=source.getAtomNumber(sAtom);
    int indexJ=target.getAtomNumber(tAtom);
    atomNumbersFromContainer.put(indexI,indexJ);
    getMappings().add(atomNumbersFromContainer);
  }
}",0.9003164556962026
38625,"private synchronized void setSourceSingleAtomMap(List<Map<IAtom,IAtom>> mappings) throws CDKException {
  int counter=0;
  BondEnergies be=BondEnergies.getInstance();
  for (  IAtom sourceAtom : source.atoms()) {
    for (    IAtom targetAtom : target.atoms()) {
      Map<IAtom,IAtom> mapAtoms=new HashMap<IAtom,IAtom>();
      if (sourceAtom instanceof IQueryAtom) {
        if (((IQueryAtom)sourceAtom).matches(targetAtom)) {
          mapAtoms.put(sourceAtom,targetAtom);
          List<IBond> Bonds=target.getConnectedBondsList(targetAtom);
          double totalOrder=0;
          for (          IBond bond : Bonds) {
            Order bondOrder=bond.getOrder();
            if (bondOrder == null) {
              continue;
            }
            totalOrder+=bondOrder.numeric() + be.getEnergies(bond);
          }
          if (targetAtom.getFormalCharge() != sourceAtom.getFormalCharge()) {
            totalOrder+=0.5;
          }
          connectedBondOrder.put(counter,totalOrder);
          mappings.add(counter++,mapAtoms);
        }
      }
 else       if (sourceAtom.getSymbol().equalsIgnoreCase(targetAtom.getSymbol())) {
        mapAtoms.put(sourceAtom,targetAtom);
        List<IBond> Bonds=target.getConnectedBondsList(targetAtom);
        double totalOrder=0;
        for (        IBond bond : Bonds) {
          Order bondOrder=bond.getOrder();
          if (bondOrder == null) {
            continue;
          }
          totalOrder+=bondOrder.numeric() + be.getEnergies(bond);
        }
        if (targetAtom.getFormalCharge() != sourceAtom.getFormalCharge()) {
          totalOrder+=0.5;
        }
        connectedBondOrder.put(counter,totalOrder);
        mappings.add(counter,mapAtoms);
        counter++;
      }
    }
  }
}","private synchronized void setSourceSingleAtomMap(List<Map<IAtom,IAtom>> mappings) throws CDKException {
  int counter=0;
  BondEnergies be=BondEnergies.getInstance();
  for (  IAtom sourceAtom : source.atoms()) {
    for (    IAtom targetAtom : target.atoms()) {
      Map<IAtom,IAtom> mapAtoms=new HashMap<>();
      if (sourceAtom instanceof IQueryAtom) {
        if (((IQueryAtom)sourceAtom).matches(targetAtom)) {
          mapAtoms.put(sourceAtom,targetAtom);
          List<IBond> Bonds=target.getConnectedBondsList(targetAtom);
          double totalOrder=0;
          for (          IBond bond : Bonds) {
            Order bondOrder=bond.getOrder();
            if (bondOrder == null) {
              continue;
            }
            totalOrder+=bondOrder.numeric() + be.getEnergies(bond);
          }
          if (!Objects.equals(targetAtom.getFormalCharge(),sourceAtom.getFormalCharge())) {
            totalOrder+=0.5;
          }
          connectedBondOrder.put(counter,totalOrder);
          mappings.add(counter++,mapAtoms);
        }
      }
 else       if (sourceAtom.getSymbol().equalsIgnoreCase(targetAtom.getSymbol())) {
        mapAtoms.put(sourceAtom,targetAtom);
        List<IBond> Bonds=target.getConnectedBondsList(targetAtom);
        double totalOrder=0;
        for (        IBond bond : Bonds) {
          Order bondOrder=bond.getOrder();
          if (bondOrder == null) {
            continue;
          }
          totalOrder+=bondOrder.numeric() + be.getEnergies(bond);
        }
        if (!Objects.equals(targetAtom.getFormalCharge(),sourceAtom.getFormalCharge())) {
          totalOrder+=0.5;
        }
        connectedBondOrder.put(counter,totalOrder);
        mappings.add(counter,mapAtoms);
        counter++;
      }
    }
  }
}",0.9844324936314748
38626,"/** 
 * Default
 */
public SingleMapping(){
  connectedBondOrder=new TreeMap<Integer,Double>();
}","/** 
 * Default
 */
public SingleMapping(){
  connectedBondOrder=new TreeMap<>();
}",0.9222222222222224
38627,"private synchronized void setTargetSingleAtomMap(List<Map<IAtom,IAtom>> mappings) throws CDKException {
  int counter=0;
  BondEnergies be=BondEnergies.getInstance();
  for (  IAtom targetAtom : target.atoms()) {
    for (    IAtom sourceAtoms : source.atoms()) {
      Map<IAtom,IAtom> mapAtoms=new HashMap<IAtom,IAtom>();
      if (targetAtom instanceof IQueryAtom) {
        if (((IQueryAtom)targetAtom).matches(sourceAtoms)) {
          if (targetAtom.getSymbol().equalsIgnoreCase(sourceAtoms.getSymbol())) {
            mapAtoms.put(sourceAtoms,targetAtom);
            List<IBond> Bonds=source.getConnectedBondsList(sourceAtoms);
            double totalOrder=0;
            for (            IBond bond : Bonds) {
              Order bondOrder=bond.getOrder();
              if (bondOrder == null) {
                continue;
              }
              totalOrder+=bondOrder.numeric() + be.getEnergies(bond);
            }
            if (sourceAtoms.getFormalCharge() != targetAtom.getFormalCharge()) {
              totalOrder+=0.5;
            }
            connectedBondOrder.put(counter,totalOrder);
            mappings.add(counter,mapAtoms);
            counter++;
          }
        }
      }
 else       if (targetAtom.getSymbol().equalsIgnoreCase(sourceAtoms.getSymbol())) {
        mapAtoms.put(sourceAtoms,targetAtom);
        List<IBond> Bonds=source.getConnectedBondsList(sourceAtoms);
        double totalOrder=0;
        for (        IBond bond : Bonds) {
          Order bondOrder=bond.getOrder();
          if (bondOrder == null) {
            continue;
          }
          totalOrder+=bondOrder.numeric() + be.getEnergies(bond);
        }
        if (sourceAtoms.getFormalCharge() != targetAtom.getFormalCharge()) {
          totalOrder+=0.5;
        }
        connectedBondOrder.put(counter,totalOrder);
        mappings.add(counter,mapAtoms);
        counter++;
      }
    }
  }
}","private synchronized void setTargetSingleAtomMap(List<Map<IAtom,IAtom>> mappings) throws CDKException {
  int counter=0;
  BondEnergies be=BondEnergies.getInstance();
  for (  IAtom targetAtom : target.atoms()) {
    for (    IAtom sourceAtoms : source.atoms()) {
      Map<IAtom,IAtom> mapAtoms=new HashMap<>();
      if (targetAtom instanceof IQueryAtom) {
        if (((IQueryAtom)targetAtom).matches(sourceAtoms)) {
          if (targetAtom.getSymbol().equalsIgnoreCase(sourceAtoms.getSymbol())) {
            mapAtoms.put(sourceAtoms,targetAtom);
            List<IBond> Bonds=source.getConnectedBondsList(sourceAtoms);
            double totalOrder=0;
            for (            IBond bond : Bonds) {
              Order bondOrder=bond.getOrder();
              if (bondOrder == null) {
                continue;
              }
              totalOrder+=bondOrder.numeric() + be.getEnergies(bond);
            }
            if (!Objects.equals(sourceAtoms.getFormalCharge(),targetAtom.getFormalCharge())) {
              totalOrder+=0.5;
            }
            connectedBondOrder.put(counter,totalOrder);
            mappings.add(counter,mapAtoms);
            counter++;
          }
        }
      }
 else       if (targetAtom.getSymbol().equalsIgnoreCase(sourceAtoms.getSymbol())) {
        mapAtoms.put(sourceAtoms,targetAtom);
        List<IBond> Bonds=source.getConnectedBondsList(sourceAtoms);
        double totalOrder=0;
        for (        IBond bond : Bonds) {
          Order bondOrder=bond.getOrder();
          if (bondOrder == null) {
            continue;
          }
          totalOrder+=bondOrder.numeric() + be.getEnergies(bond);
        }
        if (!Objects.equals(sourceAtoms.getFormalCharge(),targetAtom.getFormalCharge())) {
          totalOrder+=0.5;
        }
        connectedBondOrder.put(counter,totalOrder);
        mappings.add(counter,mapAtoms);
        counter++;
      }
    }
  }
}",0.9856957087126138
38628,"private <K,V>Map<K,V> sortByValue(Map<K,V> map){
  List list=new LinkedList(map.entrySet());
  Collections.sort(list,new Comparator(){
    @Override public int compare(    Object object1,    Object object2){
      return ((Comparable)((Map.Entry<K,V>)(object1)).getValue()).compareTo(((Map.Entry<K,V>)(object2)).getValue());
    }
  }
);
  Map<K,V> result=new LinkedHashMap<K,V>();
  for (Iterator it=list.iterator(); it.hasNext(); ) {
    Map.Entry<K,V> entry=(Map.Entry<K,V>)it.next();
    result.put(entry.getKey(),entry.getValue());
  }
  return result;
}","private <K,V>Map<K,V> sortByValue(Map<K,V> map){
  List list=new LinkedList(map.entrySet());
  Collections.sort(list,new Comparator(){
    @Override public int compare(    Object object1,    Object object2){
      return ((Comparable)((Map.Entry<K,V>)(object1)).getValue()).compareTo(((Map.Entry<K,V>)(object2)).getValue());
    }
  }
);
  Map<K,V> result=new LinkedHashMap<>();
  for (Iterator it=list.iterator(); it.hasNext(); ) {
    Map.Entry<K,V> entry=(Map.Entry<K,V>)it.next();
    result.put(entry.getKey(),entry.getValue());
  }
  return result;
}",0.9973094170403588
38629,"/** 
 * Returns single mapping solutions.
 * @param source
 * @param target
 * @return Mappings
 * @throws CDKException
 */
@TestMethod(""String_Node_Str"") protected synchronized List<Map<IAtom,IAtom>> getOverLaps(IQueryAtomContainer source,IAtomContainer target) throws CDKException {
  List<Map<IAtom,IAtom>> mappings=new ArrayList<Map<IAtom,IAtom>>();
  this.source=source;
  this.target=target;
  if (source.getAtomCount() == 1 || (source.getAtomCount() > 0 && source.getBondCount() == 0)) {
    setSourceSingleAtomMap(mappings);
  }
  if (target.getAtomCount() == 1 || (target.getAtomCount() > 0 && target.getBondCount() == 0)) {
    setTargetSingleAtomMap(mappings);
  }
  return postFilter(mappings);
}","/** 
 * Returns single mapping solutions.
 * @param source
 * @param target
 * @return Mappings
 * @throws CDKException
 */
@TestMethod(""String_Node_Str"") protected synchronized List<Map<IAtom,IAtom>> getOverLaps(IQueryAtomContainer source,IAtomContainer target) throws CDKException {
  List<Map<IAtom,IAtom>> mappings=new ArrayList<>();
  this.source=source;
  this.target=target;
  if (source.getAtomCount() == 1 || (source.getAtomCount() > 0 && source.getBondCount() == 0)) {
    setSourceSingleAtomMap(mappings);
  }
  if (target.getAtomCount() == 1 || (target.getAtomCount() > 0 && target.getBondCount() == 0)) {
    setTargetSingleAtomMap(mappings);
  }
  return postFilter(mappings);
}",0.9885714285714284
38630,"private synchronized List<Map<IAtom,IAtom>> postFilter(List<Map<IAtom,IAtom>> mappings){
  List<Map<IAtom,IAtom>> sortedMap=new ArrayList<Map<IAtom,IAtom>>();
  if (mappings.isEmpty()) {
    return sortedMap;
  }
  Map<Integer,Double> sortedMapByValue=sortByValue(connectedBondOrder);
  for (  Integer key : sortedMapByValue.keySet()) {
    Map<IAtom,IAtom> mapToBeMoved=mappings.get(key);
    sortedMap.add(mapToBeMoved);
  }
  return sortedMap;
}","private synchronized List<Map<IAtom,IAtom>> postFilter(List<Map<IAtom,IAtom>> mappings){
  List<Map<IAtom,IAtom>> sortedMap=new ArrayList<>();
  if (mappings.isEmpty()) {
    return sortedMap;
  }
  Map<Integer,Double> sortedMapByValue=sortByValue(connectedBondOrder);
  for (  Integer key : sortedMapByValue.keySet()) {
    Map<IAtom,IAtom> mapToBeMoved=mappings.get(key);
    sortedMap.add(mapToBeMoved);
  }
  return sortedMap;
}",0.9818181818181818
38631,"private synchronized BondMatcher createBondMatcher(IBond bond){
  return new DefaultBondMatcher(bond,isBondMatchFlag(),isMatchAtomType());
}","private synchronized BondMatcher createBondMatcher(IBond bond){
  return new DefaultBondMatcher(bond,isBondMatchFlag(),isShouldMatchRings(),isMatchAtomType());
}",0.9302325581395348
38632,"boolean matchBonds(IBond queryBond,IBond targetBond){
  BondMatcher defaultVFBondMatcher=new DefaultBondMatcher(queryBond,shouldMatchBonds,shouldMatchAtomType);
  return defaultVFBondMatcher.matches(targetBond);
}","boolean matchBonds(IBond queryBond,IBond targetBond){
  BondMatcher defaultVFBondMatcher=new DefaultBondMatcher(queryBond,shouldMatchBonds,shouldMatchRings,shouldMatchAtomType);
  return defaultVFBondMatcher.matches(targetBond);
}",0.9616252821670428
38633,"private synchronized boolean substructureAlgorithm() throws CDKException {
  Substructure mcs;
  mcs=new Substructure(getQueryContainer(),getTargetContainer(),isMatchBonds(),isMatchRings(),true);
  clearMaps();
  if (isSubgraph()) {
    getMCSList().addAll(mcs.getAllAtomMapping());
  }
  return mcs.isSubgraph();
}","private synchronized boolean substructureAlgorithm() throws CDKException {
  Substructure mcs;
  mcs=new Substructure(getQueryContainer(),getTargetContainer(),isMatchBonds(),isMatchRings(),true);
  clearMaps();
  if (mcs.isSubgraph()) {
    getMCSList().addAll(mcs.getAllAtomMapping());
  }
  return mcs.isSubgraph();
}",0.9936908517350158
38634,"/** 
 * {@inheritDoc}
 * @param targetAtom
 * @return
 */
@Override public boolean matches(IAtom targetAtom){
  if (targetAtom instanceof IQueryAtom) {
    return ((IQueryAtom)targetAtom).matches(getQueryAtom());
  }
 else   if (getQueryAtom() != null && getQueryAtom() instanceof IQueryAtom) {
    return ((IQueryAtom)getQueryAtom()).matches(targetAtom);
  }
 else {
    if (!matchSymbol(targetAtom)) {
      return false;
    }
    if (isShouldMatchRings() && isAtomAttachedToRing(getQueryAtom()) && isAtomAttachedToRing(targetAtom)) {
      return true;
    }
 else     if (isShouldMatchRings() && (isAliphaticAtom(getQueryAtom()) && isRingAtom(targetAtom))) {
      return false;
    }
 else     if (isShouldMatchRings() && (isRingAtom(getQueryAtom()) && isAliphaticAtom(targetAtom))) {
      return false;
    }
 else     if (isShouldMatchRings() && (isRingAtom(getQueryAtom()) && isRingAtom(targetAtom))) {
      if (getQueryAtom().getProperty(SMALLEST_RING_SIZE) != targetAtom.getProperty(SMALLEST_RING_SIZE)) {
        return false;
      }
    }
  }
  return true;
}","/** 
 * {@inheritDoc}
 * @param targetAtom
 * @return
 */
@Override public boolean matches(IAtom targetAtom){
  if (targetAtom instanceof IQueryAtom) {
    return ((IQueryAtom)targetAtom).matches(getQueryAtom());
  }
 else   if (getQueryAtom() != null && getQueryAtom() instanceof IQueryAtom) {
    return ((IQueryAtom)getQueryAtom()).matches(targetAtom);
  }
 else {
    if (!matchSymbol(targetAtom)) {
      return false;
    }
    if (isShouldMatchRings() && isAtomAttachedToRing(getQueryAtom()) && !isRingAtom(getQueryAtom())&& isAtomAttachedToRing(targetAtom)&& !isRingAtom(targetAtom)) {
      return true;
    }
 else     if (isShouldMatchRings() && (isAliphaticAtom(getQueryAtom()) && isRingAtom(targetAtom))) {
      return false;
    }
 else     if (isShouldMatchRings() && (isRingAtom(getQueryAtom()) && isAliphaticAtom(targetAtom))) {
      return false;
    }
 else     if (isShouldMatchRings() && (isRingAtom(getQueryAtom()) && isRingAtom(targetAtom))) {
      if (getQueryAtom().getProperty(SMALLEST_RING_SIZE) != targetAtom.getProperty(SMALLEST_RING_SIZE)) {
        return false;
      }
    }
  }
  return true;
}",0.9746146872166818
38635,"public Map<String,String> getStringDataTypes(){
  return stringDataTypes;
}","public Map<String,String> getStringDataTypes(){
  return Collections.unmodifiableMap(stringDataTypes);
}",0.8379888268156425
38636,"/** 
 * Returns Target molecule
 * @return
 * @throws IOException
 * @throws CDKException
 */
public IAtomContainer getTarget() throws IOException, CDKException {
  String filenameOrData=argumentHandler.getTargetFilepath();
  String type=argumentHandler.getTargetType();
  if (isSingleFileTarget) {
    ISimpleChemObjectReader reader=getReader(type,filenameOrData);
    IChemFile chemFile=reader.read(new ChemFile());
    IAtomContainer molecule=(IAtomContainer)ChemFileManipulator.getAllAtomContainers(chemFile).get(0);
    configure(molecule,type);
    return molecule;
  }
 else {
    return getMolFromString(filenameOrData,type);
  }
}","/** 
 * Returns Target molecule
 * @return
 * @throws IOException
 * @throws CDKException
 */
public IAtomContainer getTarget() throws IOException, CDKException {
  String filenameOrData=argumentHandler.getTargetFilepath();
  String type=argumentHandler.getTargetType();
  if (isSingleFileTarget) {
    ISimpleChemObjectReader reader=getReader(type,filenameOrData);
    IChemFile chemFile=reader.read(new ChemFile());
    IAtomContainer molecule=ChemFileManipulator.getAllAtomContainers(chemFile).get(0);
    configure(molecule,type);
    return molecule;
  }
 else {
    return getMolFromString(filenameOrData,type);
  }
}",0.7337559429477021
38637,"public Map<String,String> getMultipleDataTypes(){
  return multipleDataTypes;
}","public Map<String,String> getMultipleDataTypes(){
  return Collections.unmodifiableMap(multipleDataTypes);
}",0.8449197860962567
38638,"public Map<String,String> getSingularDataTypes(){
  return singularDataTypes;
}","public Map<String,String> getSingularDataTypes(){
  return Collections.unmodifiableMap(singularDataTypes);
}",0.8449197860962567
38639,"/** 
 * Return Query molecule
 * @return
 * @throws IOException
 * @throws CDKException
 */
public IAtomContainer getQuery() throws IOException, CDKException {
  String filenameOrData=argumentHandler.getQueryFilepath();
  String type=argumentHandler.getQueryType();
  if (isSingleFileQuery) {
    ISimpleChemObjectReader reader=getReader(type,filenameOrData);
    IChemFile chemFile=reader.read(new ChemFile());
    IAtomContainer molecule=(IAtomContainer)ChemFileManipulator.getAllAtomContainers(chemFile).get(0);
    configure(molecule,type);
    return molecule;
  }
 else {
    return getMolFromString(filenameOrData,type);
  }
}","/** 
 * Return Query molecule
 * @return
 * @throws IOException
 * @throws CDKException
 */
public IAtomContainer getQuery() throws IOException, CDKException {
  String filenameOrData=argumentHandler.getQueryFilepath();
  String type=argumentHandler.getQueryType();
  if (isSingleFileQuery) {
    ISimpleChemObjectReader reader=getReader(type,filenameOrData);
    IChemFile chemFile=reader.read(new ChemFile());
    IAtomContainer molecule=ChemFileManipulator.getAllAtomContainers(chemFile).get(0);
    configure(molecule,type);
    return molecule;
  }
 else {
    return getMolFromString(filenameOrData,type);
  }
}",0.7312
38640,"public static void runSingleQuerySingleTarget(InputHandler inputHandler,OutputHandler outputHandler,ArgumentHandler argumentHandler) throws IOException, CDKException, CloneNotSupportedException {
  IAtomContainer query=inputHandler.getQuery();
  IAtomContainer target=inputHandler.getTarget();
  boolean removeHydrogens=argumentHandler.isApplyHRemoval();
  boolean flag=ConnectivityChecker.isConnected(query);
  if (!flag) {
    System.out.println(""String_Node_Str"" + inputHandler.getQueryName() + ""String_Node_Str"");
    return;
  }
  flag=ConnectivityChecker.isConnected(target);
  if (!flag) {
    System.out.println(""String_Node_Str"" + inputHandler.getTargetName() + ""String_Node_Str"");
    return;
  }
  if (removeHydrogens) {
    query=new AtomContainer(AtomContainerManipulator.removeHydrogens(query));
    target=new AtomContainer(AtomContainerManipulator.removeHydrogens(target));
  }
  if (target.getProperty(CDKConstants.TITLE) != null) {
    target.setID((String)target.getProperty(CDKConstants.TITLE));
    argumentHandler.setTargetMolOutName(target.getID());
  }
  if (query.getProperty(CDKConstants.TITLE) != null) {
    query.setID((String)target.getProperty(CDKConstants.TITLE));
    argumentHandler.setQueryMolOutName(query.getID());
  }
  String out=""String_Node_Str"";
  if (!argumentHandler.isAppendMode()) {
    outputHandler.startAppending(out);
  }
 else {
    outputHandler.startNew(out);
  }
  CDKHueckelAromaticityDetector.detectAromaticity(query);
  CDKHueckelAromaticityDetector.detectAromaticity(target);
  AtomContainerManipulator.percieveAtomTypesAndConfigureAtoms(query);
  AtomContainerManipulator.percieveAtomTypesAndConfigureAtoms(target);
  if (argumentHandler.isApplyHAdding()) {
    AtomContainerManipulator.convertImplicitToExplicitHydrogens(query);
    AtomContainerManipulator.convertImplicitToExplicitHydrogens(target);
  }
  long startTime=System.currentTimeMillis();
  BaseMapping smsd=null;
  boolean matchBonds=argumentHandler.isMatchBondType();
  boolean matchRings=argumentHandler.isMatchRingType();
  if (argumentHandler.isSubstructureMode()) {
    smsd=runSubstructure(query,target,argumentHandler.getChemFilter(),matchBonds,matchRings);
  }
 else {
    smsd=run(query,target,argumentHandler.getChemFilter(),matchBonds,matchRings);
  }
  query=query.getBuilder().newInstance(IAtomContainer.class,smsd.getFirstAtomMapping().getQuery());
  target=target.getBuilder().newInstance(IAtomContainer.class,smsd.getFirstAtomMapping().getTarget());
  long endTime=System.currentTimeMillis();
  long executionTime=endTime - startTime;
  outputHandler.writeQueryMol(smsd.getFirstAtomMapping().getQuery());
  outputHandler.writeTargetMol(smsd.getFirstAtomMapping().getTarget());
  String queryPath=argumentHandler.getQueryFilepath();
  String targetPath=argumentHandler.getTargetFilepath();
  Map<IAtom,IAtom> mcs=smsd.getFirstAtomMapping().getMappings();
  int nAtomsMatched=(mcs == null) ? 0 : mcs.size();
  double tanimotoSimilarity=smsd.getTanimotoSimilarity();
  if (mcs != null && argumentHandler.isAllMapping()) {
    outputHandler.printHeader(queryPath,targetPath,nAtomsMatched);
    for (    AtomAtomMapping aam : smsd.getAllAtomMapping()) {
      Map<Integer,Integer> mapping=getIndexMapping(aam);
      int counter=0;
      if (argumentHandler.isImage()) {
        double stereoScore=smsd.getStereoScore(counter);
        String label=outputHandler.makeLabel(tanimotoSimilarity,stereoScore);
        outputHandler.addImage(query,target,label,mapping);
      }
      outputHandler.printMapping(counter++,mcs);
    }
  }
 else   if (mcs != null && !argumentHandler.isAllMapping()) {
    Map<Integer,Integer> mcsNumber=getIndexMapping(smsd.getFirstAtomMapping());
    double stereoScore=smsd.getStereoScore(0);
    outputHandler.printHeader(queryPath,targetPath,nAtomsMatched);
    String qrefName=inputHandler.getQRefName();
    String trefName=inputHandler.getTRefName();
    outputHandler.printTopMapping(nAtomsMatched,mcs,mcsNumber,qrefName,trefName);
    if (argumentHandler.isImage()) {
      String label=outputHandler.makeLabel(tanimotoSimilarity,stereoScore);
      outputHandler.makeImage(query,target,label,mcsNumber);
    }
  }
  double tanimotoGraph=smsd.getTanimotoSimilarity();
  double euclidianGraph=smsd.getEuclideanDistance();
  outputHandler.writeResults(query,target,tanimotoGraph,euclidianGraph,nAtomsMatched,executionTime);
  if (mcs != null && argumentHandler.isImage()) {
    String qName=inputHandler.getQueryName();
    String tName=inputHandler.getTargetName();
    outputHandler.writeImage(qName,tName);
  }
  if (argumentHandler.shouldOutputSubgraph()) {
    Map<Integer,Integer> mapping=getIndexMapping(smsd.getFirstAtomMapping());
    IAtomContainer subgraph=getSubgraph(target,mapping);
    String outpath=argumentHandler.getOutputFilepath();
    String outtype=argumentHandler.getOutputFiletype();
    outputHandler.writeMol(outtype,subgraph,outpath);
  }
  outputHandler.closeFiles();
}","public static void runSingleQuerySingleTarget(InputHandler inputHandler,OutputHandler outputHandler,ArgumentHandler argumentHandler) throws IOException, CDKException, CloneNotSupportedException {
  IAtomContainer query=inputHandler.getQuery();
  IAtomContainer target=inputHandler.getTarget();
  boolean removeHydrogens=argumentHandler.isApplyHRemoval();
  boolean flag=ConnectivityChecker.isConnected(query);
  if (!flag) {
    System.out.println(""String_Node_Str"" + inputHandler.getQueryName() + ""String_Node_Str"");
    return;
  }
  flag=ConnectivityChecker.isConnected(target);
  if (!flag) {
    System.out.println(""String_Node_Str"" + inputHandler.getTargetName() + ""String_Node_Str"");
    return;
  }
  if (removeHydrogens) {
    query=new AtomContainer(AtomContainerManipulator.removeHydrogens(query));
    target=new AtomContainer(AtomContainerManipulator.removeHydrogens(target));
  }
  if (target.getProperty(CDKConstants.TITLE) != null) {
    target.setID((String)target.getProperty(CDKConstants.TITLE));
    argumentHandler.setTargetMolOutName(target.getID());
  }
  if (query.getProperty(CDKConstants.TITLE) != null) {
    query.setID((String)query.getProperty(CDKConstants.TITLE));
    argumentHandler.setQueryMolOutName(query.getID());
  }
  String out=""String_Node_Str"";
  if (!argumentHandler.isAppendMode()) {
    outputHandler.startAppending(out);
  }
 else {
    outputHandler.startNew(out);
  }
  CDKHueckelAromaticityDetector.detectAromaticity(query);
  CDKHueckelAromaticityDetector.detectAromaticity(target);
  AtomContainerManipulator.percieveAtomTypesAndConfigureAtoms(query);
  AtomContainerManipulator.percieveAtomTypesAndConfigureAtoms(target);
  if (argumentHandler.isApplyHAdding()) {
    AtomContainerManipulator.convertImplicitToExplicitHydrogens(query);
    AtomContainerManipulator.convertImplicitToExplicitHydrogens(target);
  }
  long startTime=System.currentTimeMillis();
  BaseMapping smsd=null;
  boolean matchBonds=argumentHandler.isMatchBondType();
  boolean matchRings=argumentHandler.isMatchRingType();
  if (argumentHandler.isSubstructureMode()) {
    smsd=runSubstructure(query,target,argumentHandler.getChemFilter(),matchBonds,matchRings);
  }
 else {
    smsd=run(query,target,argumentHandler.getChemFilter(),matchBonds,matchRings);
  }
  query=query.getBuilder().newInstance(IAtomContainer.class,smsd.getFirstAtomMapping().getQuery());
  target=target.getBuilder().newInstance(IAtomContainer.class,smsd.getFirstAtomMapping().getTarget());
  long endTime=System.currentTimeMillis();
  long executionTime=endTime - startTime;
  outputHandler.writeQueryMol(smsd.getFirstAtomMapping().getQuery());
  outputHandler.writeTargetMol(smsd.getFirstAtomMapping().getTarget());
  String queryPath=argumentHandler.getQueryFilepath();
  String targetPath=argumentHandler.getTargetFilepath();
  Map<IAtom,IAtom> mcs=smsd.getFirstAtomMapping().getMappings();
  int nAtomsMatched=(mcs == null) ? 0 : mcs.size();
  double tanimotoSimilarity=smsd.getTanimotoSimilarity();
  if (mcs != null && argumentHandler.isAllMapping()) {
    outputHandler.printHeader(queryPath,targetPath,nAtomsMatched);
    for (    AtomAtomMapping aam : smsd.getAllAtomMapping()) {
      Map<Integer,Integer> mapping=getIndexMapping(aam);
      int counter=0;
      if (argumentHandler.isImage()) {
        double stereoScore=smsd.getStereoScore(counter);
        String label=outputHandler.makeLabel(tanimotoSimilarity,stereoScore);
        outputHandler.addImage(query,target,label,mapping);
      }
      outputHandler.printMapping(counter++,mcs);
    }
  }
 else   if (mcs != null && !argumentHandler.isAllMapping()) {
    Map<Integer,Integer> mcsNumber=getIndexMapping(smsd.getFirstAtomMapping());
    double stereoScore=smsd.getStereoScore(0);
    outputHandler.printHeader(queryPath,targetPath,nAtomsMatched);
    String qrefName=inputHandler.getQRefName();
    String trefName=inputHandler.getTRefName();
    outputHandler.printTopMapping(nAtomsMatched,mcs,mcsNumber,qrefName,trefName);
    if (argumentHandler.isImage()) {
      String label=outputHandler.makeLabel(tanimotoSimilarity,stereoScore);
      outputHandler.makeImage(query,target,label,mcsNumber);
    }
  }
  double tanimotoGraph=smsd.getTanimotoSimilarity();
  double euclidianGraph=smsd.getEuclideanDistance();
  outputHandler.writeResults(query,target,tanimotoGraph,euclidianGraph,nAtomsMatched,executionTime);
  if (mcs != null && argumentHandler.isImage()) {
    String qName=inputHandler.getQueryName();
    String tName=inputHandler.getTargetName();
    outputHandler.writeImage(qName,tName);
  }
  if (argumentHandler.shouldOutputSubgraph()) {
    Map<Integer,Integer> mapping=getIndexMapping(smsd.getFirstAtomMapping());
    IAtomContainer subgraph=getSubgraph(target,mapping);
    String outpath=argumentHandler.getOutputFilepath();
    String outtype=argumentHandler.getOutputFiletype();
    outputHandler.writeMol(outtype,subgraph,outpath);
  }
  outputHandler.closeFiles();
}",0.9988923572651294
38641,"public static void runSingleQueryMultipleTarget(InputHandler inputHandler,OutputHandler outputHandler,ArgumentHandler argumentHandler) throws IOException, CDKException, CloneNotSupportedException {
  IAtomContainer query=inputHandler.getQuery();
  boolean removeHydrogens=argumentHandler.isApplyHRemoval();
  boolean flag=ConnectivityChecker.isConnected(query);
  if (!flag) {
    System.err.println(""String_Node_Str"" + inputHandler.getQueryName() + ""String_Node_Str"");
    return;
  }
  if (removeHydrogens) {
    query=new AtomContainer(AtomContainerManipulator.removeHydrogens(query));
  }
  outputHandler.writeQueryMol(query);
  String out=""String_Node_Str"";
  outputHandler.startAppending(out);
  long startTime=System.currentTimeMillis();
  BaseMapping smsd=null;
  boolean matchBonds=argumentHandler.isMatchBondType();
  boolean matchRings=argumentHandler.isMatchRingType();
  int targetNumber=0;
  IIteratingChemObjectReader reader=inputHandler.getAllTargets();
  String targetType=argumentHandler.getTargetType();
  if (reader == null) {
    throw new IOException(""String_Node_Str"" + targetType);
  }
  while (reader.hasNext()) {
    IAtomContainer target=(IAtomContainer)reader.next();
    flag=ConnectivityChecker.isConnected(target);
    if (!flag) {
      System.err.println(""String_Node_Str"" + target.getProperty(CDKConstants.TITLE) + ""String_Node_Str"");
      continue;
    }
    if (removeHydrogens) {
      target=new AtomContainer(AtomContainerManipulator.removeHydrogens(target));
    }
    if (target.getProperty(CDKConstants.TITLE) != null) {
      target.setID((String)target.getProperty(CDKConstants.TITLE));
      argumentHandler.setTargetMolOutName(target.getID() == null ? ""String_Node_Str"" : target.getID());
    }
    inputHandler.configure(target,targetType);
    if (argumentHandler.isSubstructureMode()) {
      smsd=runSubstructure(query,target,argumentHandler.getChemFilter(),matchBonds,matchRings);
    }
 else {
      smsd=run(query,target,argumentHandler.getChemFilter(),matchBonds,matchRings);
    }
    long endTime=System.currentTimeMillis();
    long executionTime=endTime - startTime;
    outputHandler.writeTargetMol(smsd.getTargetContainer());
    String queryPath=argumentHandler.getQueryFilepath();
    String targetPath=argumentHandler.getTargetFilepath();
    query=query.getBuilder().newInstance(IAtomContainer.class,smsd.getFirstAtomMapping().getQuery());
    target=target.getBuilder().newInstance(IAtomContainer.class,smsd.getFirstAtomMapping().getTarget());
    Map<IAtom,IAtom> mcs=smsd.getFirstAtomMapping().getMappings();
    int nAtomsMatched=(mcs == null) ? 0 : mcs.size();
    double tanimotoSimilarity=smsd.getTanimotoSimilarity();
    if (mcs != null && argumentHandler.isAllMapping()) {
      outputHandler.printHeader(queryPath,targetPath,nAtomsMatched);
      int counter=0;
      for (Iterator<AtomAtomMapping> it=smsd.getAllAtomMapping().iterator(); it.hasNext(); ) {
        AtomAtomMapping aam=it.next();
        Map<Integer,Integer> mapping=aam.getMappingsIndex();
        if (argumentHandler.isImage()) {
          double stereoScore=smsd.getStereoScore(counter);
          String label=outputHandler.makeLabel(tanimotoSimilarity,stereoScore);
          outputHandler.addImage(query,target,label,mapping);
        }
        outputHandler.printMapping((counter + 1),mapping);
        counter+=1;
      }
    }
 else     if (mcs != null && !argumentHandler.isAllMapping()) {
      Map<Integer,Integer> mcsNumber=smsd.getFirstAtomMapping().getMappingsIndex();
      double stereoScore=smsd.getStereoScore(0);
      outputHandler.printHeader(queryPath,targetPath,nAtomsMatched);
      String qrefName=inputHandler.getQRefName();
      String trefName=inputHandler.getTRefName();
      outputHandler.printTopMapping(nAtomsMatched,mcs,mcsNumber,qrefName,trefName);
      if (argumentHandler.isImage()) {
        String label=outputHandler.makeLabel(tanimotoSimilarity,stereoScore);
        outputHandler.makeImage(query,target,label,mcsNumber);
      }
    }
    double tanimotoGraph=smsd.getTanimotoSimilarity();
    double euclidianGraph=smsd.getEuclideanDistance();
    outputHandler.writeResults(query,target,tanimotoGraph,euclidianGraph,nAtomsMatched,executionTime);
    if (mcs != null && argumentHandler.isImage()) {
      String qName=inputHandler.getQueryName();
      String tName=inputHandler.getTargetName() + ""String_Node_Str"" + targetNumber;
      outputHandler.writeImage(qName,tName);
    }
    targetNumber++;
  }
  outputHandler.closeFiles();
}","public static void runSingleQueryMultipleTarget(InputHandler inputHandler,OutputHandler outputHandler,ArgumentHandler argumentHandler) throws IOException, CDKException, CloneNotSupportedException {
  IAtomContainer query=inputHandler.getQuery();
  String name=(String)query.getProperty(CDKConstants.TITLE);
  boolean removeHydrogens=argumentHandler.isApplyHRemoval();
  boolean flag=ConnectivityChecker.isConnected(query);
  if (!flag) {
    System.err.println(""String_Node_Str"" + inputHandler.getQueryName() + ""String_Node_Str"");
    return;
  }
  if (removeHydrogens) {
    query=new AtomContainer(AtomContainerManipulator.removeHydrogens(query));
    query.setProperty(CDKConstants.TITLE,name);
    query.setID(name);
  }
  outputHandler.writeQueryMol(query);
  String out=""String_Node_Str"";
  outputHandler.startAppending(out);
  long startTime=System.currentTimeMillis();
  BaseMapping smsd=null;
  boolean matchBonds=argumentHandler.isMatchBondType();
  boolean matchRings=argumentHandler.isMatchRingType();
  int targetNumber=0;
  IIteratingChemObjectReader reader=inputHandler.getAllTargets();
  String targetType=argumentHandler.getTargetType();
  if (reader == null) {
    throw new IOException(""String_Node_Str"" + targetType);
  }
  while (reader.hasNext()) {
    IAtomContainer target=(IAtomContainer)reader.next();
    flag=ConnectivityChecker.isConnected(target);
    if (!flag) {
      System.err.println(""String_Node_Str"" + target.getProperty(CDKConstants.TITLE) + ""String_Node_Str"");
      continue;
    }
    if (removeHydrogens) {
      target=new AtomContainer(AtomContainerManipulator.removeHydrogens(target));
    }
    if (target.getProperty(CDKConstants.TITLE) != null) {
      target.setID((String)target.getProperty(CDKConstants.TITLE));
      argumentHandler.setTargetMolOutName(target.getID() == null ? ""String_Node_Str"" : target.getID());
    }
    inputHandler.configure(target,targetType);
    if (argumentHandler.isSubstructureMode()) {
      smsd=runSubstructure(query,target,argumentHandler.getChemFilter(),matchBonds,matchRings);
    }
 else {
      smsd=run(query,target,argumentHandler.getChemFilter(),matchBonds,matchRings);
    }
    long endTime=System.currentTimeMillis();
    long executionTime=endTime - startTime;
    outputHandler.writeTargetMol(smsd.getTargetContainer());
    String queryPath=argumentHandler.getQueryFilepath();
    String targetPath=argumentHandler.getTargetFilepath();
    query=query.getBuilder().newInstance(IAtomContainer.class,smsd.getFirstAtomMapping().getQuery());
    target=target.getBuilder().newInstance(IAtomContainer.class,smsd.getFirstAtomMapping().getTarget());
    Map<IAtom,IAtom> mcs=smsd.getFirstAtomMapping().getMappings();
    int nAtomsMatched=(mcs == null) ? 0 : mcs.size();
    double tanimotoSimilarity=smsd.getTanimotoSimilarity();
    if (mcs != null && argumentHandler.isAllMapping()) {
      outputHandler.printHeader(queryPath,targetPath,nAtomsMatched);
      int counter=0;
      for (Iterator<AtomAtomMapping> it=smsd.getAllAtomMapping().iterator(); it.hasNext(); ) {
        AtomAtomMapping aam=it.next();
        Map<Integer,Integer> mapping=aam.getMappingsIndex();
        if (argumentHandler.isImage()) {
          double stereoScore=smsd.getStereoScore(counter);
          String label=outputHandler.makeLabel(tanimotoSimilarity,stereoScore);
          outputHandler.addImage(query,target,label,mapping);
        }
        outputHandler.printMapping((counter + 1),mapping);
        counter+=1;
      }
    }
 else     if (mcs != null && !argumentHandler.isAllMapping()) {
      Map<Integer,Integer> mcsNumber=smsd.getFirstAtomMapping().getMappingsIndex();
      double stereoScore=smsd.getStereoScore(0);
      outputHandler.printHeader(queryPath,targetPath,nAtomsMatched);
      String qrefName=inputHandler.getQRefName();
      String trefName=inputHandler.getTRefName();
      outputHandler.printTopMapping(nAtomsMatched,mcs,mcsNumber,qrefName,trefName);
      if (argumentHandler.isImage()) {
        String label=outputHandler.makeLabel(tanimotoSimilarity,stereoScore);
        outputHandler.makeImage(query,target,label,mcsNumber);
      }
    }
    double tanimotoGraph=smsd.getTanimotoSimilarity();
    double euclidianGraph=smsd.getEuclideanDistance();
    outputHandler.writeResults(query,target,tanimotoGraph,euclidianGraph,nAtomsMatched,executionTime);
    if (mcs != null && argumentHandler.isImage()) {
      String qName=inputHandler.getQueryName();
      String tName=inputHandler.getTargetName() + ""String_Node_Str"" + targetNumber;
      outputHandler.writeImage(qName,tName);
    }
    targetNumber++;
  }
  outputHandler.closeFiles();
}",0.7329557830538009
38642,"public static void runSingleQuerySingleTarget(InputHandler inputHandler,OutputHandler outputHandler,ArgumentHandler argumentHandler) throws IOException, CDKException, CloneNotSupportedException {
  IAtomContainer query=inputHandler.getQuery();
  IAtomContainer target=inputHandler.getTarget();
  boolean removeHydrogens=argumentHandler.isApplyHRemoval();
  boolean flag=ConnectivityChecker.isConnected(query);
  if (!flag) {
    System.err.println(""String_Node_Str"" + inputHandler.getQueryName() + ""String_Node_Str"");
    return;
  }
  flag=ConnectivityChecker.isConnected(target);
  if (!flag) {
    System.err.println(""String_Node_Str"" + inputHandler.getTargetName() + ""String_Node_Str"");
    return;
  }
  if (removeHydrogens) {
    query=new AtomContainer(AtomContainerManipulator.removeHydrogens(query));
    target=new AtomContainer(AtomContainerManipulator.removeHydrogens(target));
  }
  if (target.getProperty(CDKConstants.TITLE) != null) {
    String fileName=target.getProperty(CDKConstants.TITLE) == null ? ""String_Node_Str"" : (String)target.getProperty(CDKConstants.TITLE);
    target.setID(fileName);
    argumentHandler.setTargetMolOutName(target.getID());
  }
  if (query.getProperty(CDKConstants.TITLE) != null) {
    String fileName=query.getProperty(CDKConstants.TITLE) == null ? ""String_Node_Str"" : (String)query.getProperty(CDKConstants.TITLE);
    query.setID(fileName);
    argumentHandler.setQueryMolOutName(query.getID());
  }
  String out=""String_Node_Str"";
  if (!argumentHandler.isAppendMode()) {
    outputHandler.startAppending(out);
  }
 else {
    outputHandler.startNew(out);
  }
  CDKHueckelAromaticityDetector.detectAromaticity(query);
  CDKHueckelAromaticityDetector.detectAromaticity(target);
  AtomContainerManipulator.percieveAtomTypesAndConfigureAtoms(query);
  AtomContainerManipulator.percieveAtomTypesAndConfigureAtoms(target);
  if (argumentHandler.isApplyHAdding()) {
    AtomContainerManipulator.convertImplicitToExplicitHydrogens(query);
    AtomContainerManipulator.convertImplicitToExplicitHydrogens(target);
  }
  long startTime=System.currentTimeMillis();
  BaseMapping smsd;
  boolean matchBonds=argumentHandler.isMatchBondType();
  boolean matchRings=argumentHandler.isMatchRingType();
  if (argumentHandler.isSubstructureMode()) {
    smsd=runSubstructure(query,target,argumentHandler.getChemFilter(),matchBonds,matchRings);
  }
 else {
    smsd=run(query,target,argumentHandler.getChemFilter(),matchBonds,matchRings);
  }
  query=query.getBuilder().newInstance(IAtomContainer.class,smsd.getFirstAtomMapping().getQuery());
  target=target.getBuilder().newInstance(IAtomContainer.class,smsd.getFirstAtomMapping().getTarget());
  long endTime=System.currentTimeMillis();
  long executionTime=endTime - startTime;
  outputHandler.writeQueryMol(smsd.getFirstAtomMapping().getQuery());
  outputHandler.writeTargetMol(smsd.getFirstAtomMapping().getTarget());
  String queryPath=argumentHandler.getQueryFilepath();
  String targetPath=argumentHandler.getTargetFilepath();
  Map<IAtom,IAtom> mcs=smsd.getFirstAtomMapping().getMappings();
  int nAtomsMatched=(mcs == null) ? 0 : mcs.size();
  double tanimotoSimilarity=smsd.getTanimotoSimilarity();
  if (mcs != null && argumentHandler.isAllMapping()) {
    outputHandler.printHeader(queryPath,targetPath,nAtomsMatched);
    int counter=0;
    for (Iterator<AtomAtomMapping> it=smsd.getAllAtomMapping().iterator(); it.hasNext(); ) {
      AtomAtomMapping aam=it.next();
      Map<Integer,Integer> mapping=aam.getMappingsIndex();
      if (argumentHandler.isImage()) {
        double stereoScore=smsd.getStereoScore(counter);
        String label=outputHandler.makeLabel(tanimotoSimilarity,stereoScore);
        outputHandler.addImage(query,target,label,mapping);
      }
      outputHandler.printMapping((counter + 1),mapping);
      counter+=1;
    }
  }
 else   if (mcs != null && !argumentHandler.isAllMapping()) {
    Map<Integer,Integer> mcsNumber=smsd.getFirstAtomMapping().getMappingsIndex();
    double stereoScore=smsd.getStereoScore(0);
    outputHandler.printHeader(queryPath,targetPath,nAtomsMatched);
    String qrefName=inputHandler.getQRefName();
    String trefName=inputHandler.getTRefName();
    outputHandler.printTopMapping(nAtomsMatched,mcs,mcsNumber,qrefName,trefName);
    if (argumentHandler.isImage()) {
      String label=outputHandler.makeLabel(tanimotoSimilarity,stereoScore);
      outputHandler.makeImage(query,target,label,mcsNumber);
    }
  }
  double tanimotoGraph=smsd.getTanimotoSimilarity();
  double euclidianGraph=smsd.getEuclideanDistance();
  outputHandler.writeResults(query,target,tanimotoGraph,euclidianGraph,nAtomsMatched,executionTime);
  if (mcs != null && argumentHandler.isImage()) {
    String qName=inputHandler.getQueryName();
    String tName=inputHandler.getTargetName();
    outputHandler.writeImage(qName,tName);
  }
  if (argumentHandler.shouldOutputSubgraph()) {
    Map<Integer,Integer> mapping=getIndexMapping(smsd.getFirstAtomMapping());
    IAtomContainer subgraph=getSubgraph(target,mapping);
    String outpath=argumentHandler.getOutputFilepath();
    String outtype=argumentHandler.getOutputFiletype();
    outputHandler.writeMol(outtype,subgraph,outpath);
  }
  outputHandler.closeFiles();
}","public static void runSingleQuerySingleTarget(InputHandler inputHandler,OutputHandler outputHandler,ArgumentHandler argumentHandler) throws IOException, CDKException, CloneNotSupportedException {
  IAtomContainer query=inputHandler.getQuery();
  IAtomContainer target=inputHandler.getTarget();
  boolean removeHydrogens=argumentHandler.isApplyHRemoval();
  boolean flag=ConnectivityChecker.isConnected(query);
  if (!flag) {
    System.err.println(""String_Node_Str"" + inputHandler.getQueryName() + ""String_Node_Str"");
    return;
  }
  flag=ConnectivityChecker.isConnected(target);
  if (!flag) {
    System.err.println(""String_Node_Str"" + inputHandler.getTargetName() + ""String_Node_Str"");
    return;
  }
  String fileNameQ=""String_Node_Str"";
  String fileNameT=""String_Node_Str"";
  if (target.getProperty(CDKConstants.TITLE) != null) {
    fileNameQ=target.getProperty(CDKConstants.TITLE) == null ? fileNameT : (String)target.getProperty(CDKConstants.TITLE);
    target.setID(fileNameQ);
    argumentHandler.setTargetMolOutName(target.getID());
  }
  if (query.getProperty(CDKConstants.TITLE) != null) {
    fileNameT=query.getProperty(CDKConstants.TITLE) == null ? fileNameQ : (String)query.getProperty(CDKConstants.TITLE);
    query.setID(fileNameT);
    argumentHandler.setQueryMolOutName(query.getID());
  }
  if (removeHydrogens) {
    query=new AtomContainer(AtomContainerManipulator.removeHydrogens(query));
    query.setID(fileNameQ);
    target=new AtomContainer(AtomContainerManipulator.removeHydrogens(target));
    target.setID(fileNameT);
  }
  String out=""String_Node_Str"";
  if (!argumentHandler.isAppendMode()) {
    outputHandler.startAppending(out);
  }
 else {
    outputHandler.startNew(out);
  }
  CDKHueckelAromaticityDetector.detectAromaticity(query);
  CDKHueckelAromaticityDetector.detectAromaticity(target);
  AtomContainerManipulator.percieveAtomTypesAndConfigureAtoms(query);
  AtomContainerManipulator.percieveAtomTypesAndConfigureAtoms(target);
  if (argumentHandler.isApplyHAdding()) {
    AtomContainerManipulator.convertImplicitToExplicitHydrogens(query);
    AtomContainerManipulator.convertImplicitToExplicitHydrogens(target);
  }
  long startTime=System.currentTimeMillis();
  BaseMapping smsd;
  boolean matchBonds=argumentHandler.isMatchBondType();
  boolean matchRings=argumentHandler.isMatchRingType();
  if (argumentHandler.isSubstructureMode()) {
    smsd=runSubstructure(query,target,argumentHandler.getChemFilter(),matchBonds,matchRings);
  }
 else {
    smsd=run(query,target,argumentHandler.getChemFilter(),matchBonds,matchRings);
  }
  query=query.getBuilder().newInstance(IAtomContainer.class,smsd.getFirstAtomMapping().getQuery());
  target=target.getBuilder().newInstance(IAtomContainer.class,smsd.getFirstAtomMapping().getTarget());
  long endTime=System.currentTimeMillis();
  long executionTime=endTime - startTime;
  outputHandler.writeQueryMol(smsd.getFirstAtomMapping().getQuery());
  outputHandler.writeTargetMol(smsd.getFirstAtomMapping().getTarget());
  String queryPath=argumentHandler.getQueryFilepath();
  String targetPath=argumentHandler.getTargetFilepath();
  Map<IAtom,IAtom> mcs=smsd.getFirstAtomMapping().getMappings();
  int nAtomsMatched=(mcs == null) ? 0 : mcs.size();
  double tanimotoSimilarity=smsd.getTanimotoSimilarity();
  if (mcs != null && argumentHandler.isAllMapping()) {
    outputHandler.printHeader(queryPath,targetPath,nAtomsMatched);
    int counter=0;
    for (Iterator<AtomAtomMapping> it=smsd.getAllAtomMapping().iterator(); it.hasNext(); ) {
      AtomAtomMapping aam=it.next();
      Map<Integer,Integer> mapping=aam.getMappingsIndex();
      if (argumentHandler.isImage()) {
        double stereoScore=smsd.getStereoScore(counter);
        String label=outputHandler.makeLabel(tanimotoSimilarity,stereoScore);
        outputHandler.addImage(query,target,label,mapping);
      }
      outputHandler.printMapping((counter + 1),mapping);
      counter+=1;
    }
  }
 else   if (mcs != null && !argumentHandler.isAllMapping()) {
    Map<Integer,Integer> mcsNumber=smsd.getFirstAtomMapping().getMappingsIndex();
    double stereoScore=smsd.getStereoScore(0);
    outputHandler.printHeader(queryPath,targetPath,nAtomsMatched);
    String qrefName=inputHandler.getQRefName();
    String trefName=inputHandler.getTRefName();
    outputHandler.printTopMapping(nAtomsMatched,mcs,mcsNumber,qrefName,trefName);
    if (argumentHandler.isImage()) {
      String label=outputHandler.makeLabel(tanimotoSimilarity,stereoScore);
      outputHandler.makeImage(query,target,label,mcsNumber);
    }
  }
  double tanimotoGraph=smsd.getTanimotoSimilarity();
  double euclidianGraph=smsd.getEuclideanDistance();
  outputHandler.writeResults(query,target,tanimotoGraph,euclidianGraph,nAtomsMatched,executionTime);
  if (mcs != null && argumentHandler.isImage()) {
    String qName=inputHandler.getQueryName();
    String tName=inputHandler.getTargetName();
    outputHandler.writeImage(qName,tName);
  }
  if (argumentHandler.shouldOutputSubgraph()) {
    Map<Integer,Integer> mapping=getIndexMapping(smsd.getFirstAtomMapping());
    IAtomContainer subgraph=getSubgraph(target,mapping);
    String outpath=argumentHandler.getOutputFilepath();
    String outtype=argumentHandler.getOutputFiletype();
    outputHandler.writeMol(outtype,subgraph,outpath);
  }
  outputHandler.closeFiles();
}",0.9467533691452268
38643,"public static void runNMCS(InputHandler inputHandler,OutputHandler outputHandler,ArgumentHandler argumentHandler) throws IOException, CDKException, CloneNotSupportedException {
  IIteratingChemObjectReader reader=inputHandler.getAllTargets();
  String targetType=argumentHandler.getTargetType();
  if (reader == null) {
    throw new IOException(""String_Node_Str"" + targetType);
  }
  List<IAtomContainer> atomContainerSet=new ArrayList<IAtomContainer>();
  while (reader.hasNext()) {
    IAtomContainer target=(IAtomContainer)reader.next();
    atomContainerSet.add(target);
  }
  Comparator<IAtomContainer> comparator=new AtomContainerComparator();
  Collections.sort(atomContainerSet,comparator);
  IAtomContainer mcsAtomContainer=null;
  boolean matchBonds=argumentHandler.isMatchBondType();
  boolean matchRings=argumentHandler.isMatchRingType();
  boolean removeHydrogens=argumentHandler.isApplyHRemoval();
  int filter=argumentHandler.getChemFilter();
  List<IAtomContainer> targets=new ArrayList<IAtomContainer>();
  for (  IAtomContainer target : atomContainerSet) {
    boolean flag=ConnectivityChecker.isConnected(target);
    if (!flag) {
      System.err.println(""String_Node_Str"" + target.getProperty(CDKConstants.TITLE) + ""String_Node_Str"");
      continue;
    }
 else {
      if (target.getProperty(CDKConstants.TITLE) != null) {
        target.setID((String)target.getProperty(CDKConstants.TITLE));
        argumentHandler.setTargetMolOutName(target.getID() == null ? ""String_Node_Str"" : target.getID());
      }
    }
    if (removeHydrogens) {
      target=new AtomContainer(AtomContainerManipulator.removeHydrogens(target));
    }
    if (mcsAtomContainer != null) {
      flag=ConnectivityChecker.isConnected(mcsAtomContainer);
      if (!flag) {
        System.err.println(""String_Node_Str"" + mcsAtomContainer.getProperty(CDKConstants.TITLE) + ""String_Node_Str"");
        return;
      }
 else       if (mcsAtomContainer.getProperty(CDKConstants.TITLE) != null) {
        String mcsFilenName=mcsAtomContainer.getProperty(CDKConstants.TITLE).equals(""String_Node_Str"") ? ""String_Node_Str"" : (String)mcsAtomContainer.getProperty(CDKConstants.TITLE);
        mcsAtomContainer.setID(mcsFilenName);
        argumentHandler.setQueryMolOutName(mcsAtomContainer.getID());
      }
      if (removeHydrogens) {
        mcsAtomContainer=new AtomContainer(AtomContainerManipulator.removeHydrogens(mcsAtomContainer));
      }
    }
    inputHandler.configure(target,targetType);
    if (mcsAtomContainer == null) {
      mcsAtomContainer=target;
      targets.add(target);
    }
 else {
      BaseMapping smsd=run(mcsAtomContainer,target,filter,matchBonds,matchRings);
      target=target.getBuilder().newInstance(IAtomContainer.class,smsd.getFirstAtomMapping().getTarget());
      targets.add(target);
      Map<Integer,Integer> mapping=getIndexMapping(smsd.getFirstAtomMapping());
      IAtomContainer subgraph=getSubgraph(target,mapping);
      mcsAtomContainer=new AtomContainer(subgraph);
    }
  }
  inputHandler.configure(mcsAtomContainer,targetType);
  if (argumentHandler.shouldOutputSubgraph()) {
    String outpath=argumentHandler.getOutputFilepath();
    String outtype=argumentHandler.getOutputFiletype();
    outputHandler.writeMol(outtype,mcsAtomContainer,outpath);
  }
  if (mcsAtomContainer != null && argumentHandler.isImage()) {
    List<Map<Integer,Integer>> mappings=new ArrayList<Map<Integer,Integer>>();
    List<IAtomContainer> secondRoundTargets=new ArrayList<IAtomContainer>();
    IChemObjectBuilder builder=DefaultChemObjectBuilder.getInstance();
    for (    IAtomContainer target : targets) {
      BaseMapping smsd=run(mcsAtomContainer,target,filter,matchBonds,matchRings);
      mappings.add(getIndexMapping(smsd.getFirstAtomMapping()));
      secondRoundTargets.add(builder.newInstance(IAtomContainer.class,smsd.getFirstAtomMapping().getTarget()));
    }
    String name=inputHandler.getTargetName();
    outputHandler.writeCircleImage(mcsAtomContainer,secondRoundTargets,name,mappings);
  }
}","public static void runNMCS(InputHandler inputHandler,OutputHandler outputHandler,ArgumentHandler argumentHandler) throws IOException, CDKException, CloneNotSupportedException {
  IIteratingChemObjectReader reader=inputHandler.getAllTargets();
  String targetType=argumentHandler.getTargetType();
  if (reader == null) {
    throw new IOException(""String_Node_Str"" + targetType);
  }
  List<IAtomContainer> atomContainerSet=new ArrayList<IAtomContainer>();
  while (reader.hasNext()) {
    IAtomContainer target=(IAtomContainer)reader.next();
    atomContainerSet.add(target);
  }
  Comparator<IAtomContainer> comparator=new AtomContainerComparator();
  Collections.sort(atomContainerSet,comparator);
  IAtomContainer mcsAtomContainer=null;
  boolean matchBonds=argumentHandler.isMatchBondType();
  boolean matchRings=argumentHandler.isMatchRingType();
  boolean removeHydrogens=argumentHandler.isApplyHRemoval();
  int filter=argumentHandler.getChemFilter();
  List<IAtomContainer> targets=new ArrayList<IAtomContainer>();
  for (  IAtomContainer target : atomContainerSet) {
    boolean flag=ConnectivityChecker.isConnected(target);
    String name=(String)target.getProperty(CDKConstants.TITLE);
    if (!flag) {
      System.err.println(""String_Node_Str"" + target.getProperty(CDKConstants.TITLE) + ""String_Node_Str"");
      continue;
    }
 else {
      if (target.getProperty(CDKConstants.TITLE) != null) {
        target.setID((String)target.getProperty(CDKConstants.TITLE));
        argumentHandler.setTargetMolOutName(target.getID() == null ? ""String_Node_Str"" : target.getID());
      }
    }
    if (removeHydrogens) {
      target=new AtomContainer(AtomContainerManipulator.removeHydrogens(target));
      target.setProperty(CDKConstants.TITLE,name);
      target.setID(name);
    }
    if (mcsAtomContainer != null) {
      flag=ConnectivityChecker.isConnected(mcsAtomContainer);
      if (!flag) {
        System.err.println(""String_Node_Str"" + mcsAtomContainer.getProperty(CDKConstants.TITLE) + ""String_Node_Str"");
        return;
      }
 else       if (mcsAtomContainer.getProperty(CDKConstants.TITLE) != null) {
        String mcsFilenName=mcsAtomContainer.getProperty(CDKConstants.TITLE).equals(""String_Node_Str"") ? ""String_Node_Str"" : (String)mcsAtomContainer.getProperty(CDKConstants.TITLE);
        mcsAtomContainer.setID(mcsFilenName);
        argumentHandler.setQueryMolOutName(mcsAtomContainer.getID());
      }
      if (removeHydrogens) {
        mcsAtomContainer=new AtomContainer(AtomContainerManipulator.removeHydrogens(mcsAtomContainer));
      }
    }
    inputHandler.configure(target,targetType);
    if (mcsAtomContainer == null) {
      mcsAtomContainer=target;
      targets.add(target);
    }
 else {
      BaseMapping smsd=run(mcsAtomContainer,target,filter,matchBonds,matchRings);
      target=target.getBuilder().newInstance(IAtomContainer.class,smsd.getFirstAtomMapping().getTarget());
      targets.add(target);
      Map<Integer,Integer> mapping=getIndexMapping(smsd.getFirstAtomMapping());
      IAtomContainer subgraph=getSubgraph(target,mapping);
      mcsAtomContainer=new AtomContainer(subgraph);
    }
  }
  inputHandler.configure(mcsAtomContainer,targetType);
  if (argumentHandler.shouldOutputSubgraph()) {
    String outpath=argumentHandler.getOutputFilepath();
    String outtype=argumentHandler.getOutputFiletype();
    outputHandler.writeMol(outtype,mcsAtomContainer,outpath);
  }
  if (mcsAtomContainer != null && argumentHandler.isImage()) {
    List<Map<Integer,Integer>> mappings=new ArrayList<Map<Integer,Integer>>();
    List<IAtomContainer> secondRoundTargets=new ArrayList<IAtomContainer>();
    IChemObjectBuilder builder=DefaultChemObjectBuilder.getInstance();
    for (    IAtomContainer target : targets) {
      BaseMapping smsd=run(mcsAtomContainer,target,filter,matchBonds,matchRings);
      mappings.add(getIndexMapping(smsd.getFirstAtomMapping()));
      secondRoundTargets.add(builder.newInstance(IAtomContainer.class,smsd.getFirstAtomMapping().getTarget()));
    }
    String name=inputHandler.getTargetName();
    outputHandler.writeCircleImage(mcsAtomContainer,secondRoundTargets,name,mappings);
  }
}",0.8296188040433565
38644,"protected synchronized boolean hasClique(Map<Integer,Integer> cliqueMap,List<Map<Integer,Integer>> mapGlobal){
  for (  Map<Integer,Integer> storedMap : mapGlobal) {
    if (cliqueMap.size() < storedMap.size()) {
      return true;
    }
    if (cliqueMap.keySet().equals(storedMap.keySet()) && cliqueMap.values().equals(storedMap.values())) {
      return true;
    }
  }
  return false;
}","/** 
 * @param cliqueMap
 * @param mapGlobal
 * @return
 */
protected synchronized boolean hasClique(Map<Integer,Integer> cliqueMap,List<Map<Integer,Integer>> mapGlobal){
  for (  Map<Integer,Integer> storedMap : mapGlobal) {
    if (cliqueMap.size() < storedMap.size()) {
      return true;
    }
 else     if (cliqueMap.equals(storedMap)) {
      return true;
    }
  }
  return false;
}",0.7881899871630296
38645,"private boolean hasMap(Map<Integer,Integer> maps,List<Map<Integer,Integer>> mapGlobal){
  for (  Map<Integer,Integer> test : mapGlobal) {
    if (test.equals(maps)) {
      return true;
    }
  }
  return false;
}","private boolean hasMap(Map<Integer,Integer> maps,List<Map<Integer,Integer>> mapGlobal){
  for (  Map<Integer,Integer> test : mapGlobal) {
    if (test.size() > maps.size()) {
      return true;
    }
    if (test.equals(maps)) {
      return true;
    }
  }
  return false;
}",0.8729508196721312
38646,"@Override public void onCreate(SQLiteDatabase db){
  db.execSQL(ActiveRegions.DATABASE_CREATE_ACTIVEREGIONS);
  db.execSQL(ActiveTimes.DATABASE_CREATE_ACTIVETIMES);
  db.execSQL(Contexts.DATABASE_CREATE_CONTEXTS);
  db.execSQL(ContextTimes.DATABASE_CREATE_CONTEXTTIMES);
  db.execSQL(ContextsTasks.DATABASE_CREATE_TASKCONTEXTS);
  db.execSQL(Tasks.DATABASE_CREATE_TASKS);
}","@Override public void onCreate(SQLiteDatabase db){
  db.execSQL(ActiveRegions.DATABASE_CREATE_ACTIVEREGIONS);
  db.execSQL(ActiveTimes.DATABASE_CREATE_ACTIVETIMES);
  db.execSQL(ContextRegions.DATABASE_CREATE_CONTEXTREGIONS);
  db.execSQL(Contexts.DATABASE_CREATE_CONTEXTS);
  db.execSQL(ContextTimes.DATABASE_CREATE_CONTEXTTIMES);
  db.execSQL(Families.DATABASE_CREATE_FAMILIES);
  db.execSQL(ContextsTasks.DATABASE_CREATE_TASKCONTEXTS);
  db.execSQL(Tasks.DATABASE_CREATE_TASKS);
}",0.8714953271028038
38647,"@Test public void testMaxConnectionWaitingTime() throws Exception {
  TransactorImpl<IDatabase1> transactor=transactorBuilder.setMetricsTracking(true).setMaxTotalConnections(1).get();
  transactor.execute(a -> {
  }
);
  double firstMaxConnectionWaitingTime=transactor.getDbMetrics().getMaxConnectionWaitingTime();
  int connectionCount=5;
  final Long[] startingTimes=new Long[connectionCount];
  final Long[] schedulingTimes=new Long[connectionCount];
  Future[] futures=new Future[connectionCount];
  for (int i=0; i < connectionCount; i++) {
    int finalI=i;
    futures[i]=executorService.submit(() -> {
      schedulingTimes[finalI]=stopwatch.elapsedMillis();
      transactor.execute(a -> {
        startingTimes[finalI]=stopwatch.elapsedMillis();
        sleepMillis(100);
      }
);
    }
);
  }
  long measuredMaxWaitingTime=0;
  for (int i=0; i < connectionCount; i++) {
    futures[i].get();
    measuredMaxWaitingTime=Math.max(measuredMaxWaitingTime,startingTimes[i] - schedulingTimes[i]);
  }
  DbMetrics dbMetrics=transactor.getDbMetrics();
  double maxConnectionsWaitingTime=dbMetrics.getMaxConnectionWaitingTime();
  transactor.close();
  double expectedMaxConnectionsWaitingTime=Math.max(measuredMaxWaitingTime,firstMaxConnectionWaitingTime);
  assertRoughEqual(maxConnectionsWaitingTime,expectedMaxConnectionsWaitingTime,20);
}","@Test public void testMaxConnectionWaitingTime() throws Exception {
  TransactorImpl<IDatabase1> transactor=transactorBuilder.setMetricsTracking(true).setMaxTotalConnections(1).get();
  transactor.execute(a -> {
  }
);
  double firstMaxConnectionWaitingTime=transactor.getDbMetrics().getMaxConnectionWaitingTime();
  int connectionCount=5;
  final Long[] startingTimes=new Long[connectionCount];
  final Long[] schedulingTimes=new Long[connectionCount];
  Future[] futures=new Future[connectionCount];
  for (int i=0; i < connectionCount; i++) {
    int finalI=i;
    futures[i]=executorService.submit(() -> {
      schedulingTimes[finalI]=stopwatch.elapsedMillis();
      transactor.execute(a -> {
        startingTimes[finalI]=stopwatch.elapsedMillis();
        sleepMillis(100);
      }
);
    }
);
  }
  long measuredMaxWaitingTime=0;
  for (int i=0; i < connectionCount; i++) {
    futures[i].get();
    measuredMaxWaitingTime=Math.max(measuredMaxWaitingTime,startingTimes[i] - schedulingTimes[i]);
  }
  DbMetrics dbMetrics=transactor.getDbMetrics();
  double maxConnectionsWaitingTime=dbMetrics.getMaxConnectionWaitingTime();
  transactor.close();
  double expectedMaxConnectionsWaitingTime=Math.max(measuredMaxWaitingTime,firstMaxConnectionWaitingTime);
  assertRoughEqual(maxConnectionsWaitingTime,expectedMaxConnectionsWaitingTime,100);
}",0.998886827458256
38648,"private String getWhereSqlCriteria(){
  StringBuilder sb=new StringBuilder();
  Iterator<WhereConstraint> it=whereConstraints.iterator();
  while (it.hasNext()) {
    WhereConstraint constraint=it.next();
    sb.append(constraint.getSqlStatement());
    if (it.hasNext()) {
      sb.append(""String_Node_Str"");
    }
  }
  return sb.toString();
}","private String getWhereSqlCriteria(){
  StringBuilder sb=new StringBuilder();
  Iterator<WhereConstraint> it=whereConstraints.iterator();
  while (it.hasNext()) {
    WhereConstraint constraint=it.next();
    sb.append(""String_Node_Str"").append(constraint.getSqlStatement()).append(""String_Node_Str"");
    if (it.hasNext()) {
      sb.append(""String_Node_Str"");
    }
  }
  return sb.toString();
}",0.9299191374663072
38649,"@Test public void testQueryOperators() throws IOException, SQLException {
  IUserPersistence users=dbs.getDatabase1().users();
  users.deleteAll();
  User brad=users.createDefaultInstance().setHandle(""String_Node_Str"").setBio(""String_Node_Str"").setNumPosts(1).setCreatedAtMillis(1l);
  User brandon=users.createDefaultInstance().setHandle(""String_Node_Str"").setBio(""String_Node_Str"").setNumPosts(2).setCreatedAtMillis(1l).setSomeDatetime(0l);
  User casey=users.createDefaultInstance().setHandle(""String_Node_Str"").setBio(""String_Node_Str"").setNumPosts(2).setCreatedAtMillis(2l);
  User john=users.createDefaultInstance().setHandle(""String_Node_Str"").setBio(""String_Node_Str"").setNumPosts(3).setCreatedAtMillis(2l);
  User james=users.createDefaultInstance().setHandle(""String_Node_Str"").setBio(""String_Node_Str"").setNumPosts(5).setCreatedAtMillis(3l).setSomeDatetime(1000000l);
  brad.save();
  brandon.save();
  casey.save();
  john.save();
  james.save();
  List<User> result;
  result=users.query().whereHandle(equalTo(""String_Node_Str"")).find();
  assertEquals(1,result.size());
  assertTrue(result.contains(brad));
  result=users.query().whereNumPosts(between(4,8)).find();
  assertEquals(1,result.size());
  assertTrue(result.contains(james));
  result=users.query().whereNumPosts(notBetween(4,8)).find();
  assertEquals(4,result.size());
  assertTrue(result.containsAll(Sets.newHashSet(brad,brandon,casey,john)));
  result=users.query().whereCreatedAtMillis(lessThan(2l)).find();
  assertEquals(2,result.size());
  assertTrue(result.contains(brad));
  assertTrue(result.contains(brandon));
  result=users.query().whereCreatedAtMillis(greaterThan(1l)).find();
  assertEquals(3,result.size());
  result=users.query().whereCreatedAtMillis(lessThanOrEqualTo(2l)).find();
  assertEquals(4,result.size());
  result=users.query().whereCreatedAtMillis(greaterThanOrEqualTo(1l)).find();
  assertEquals(5,result.size());
  result=users.query().whereBio(endsWith(""String_Node_Str"")).find();
  assertEquals(5,result.size());
  result=users.query().whereBio(startsWith(""String_Node_Str"")).find();
  assertTrue(result.isEmpty());
  result=users.query().whereSomeDatetime(in(Collections.<Long>emptySet())).find();
  assertTrue(result.isEmpty());
  result=users.query().whereSomeDatetime(notIn(Collections.<Long>emptySet())).find();
  assertEquals(5,result.size());
  result=users.query().whereBio(contains(""String_Node_Str"")).whereNumPosts(in(1,3,5)).find();
  assertEquals(1,result.size());
  assertTrue(result.contains(james));
  result=users.query().whereHandle(notIn(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")).whereNumPosts(notEqualTo(5)).find();
  assertEquals(1,result.size());
  assertTrue(result.contains(casey));
  result=users.query().whereSomeDatetime(JackMatchers.<Long>isNull()).find();
  assertEquals(3,result.size());
  result=users.query().whereSomeDatetime(JackMatchers.<Long>isNotNull()).find();
  assertEquals(2,result.size());
  assertTrue(result.contains(brandon));
  assertTrue(result.contains(james));
  try {
    users.query().whereHandle(in(null,""String_Node_Str"")).find();
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
}","@Test public void testQueryOperators() throws IOException, SQLException {
  IUserPersistence users=dbs.getDatabase1().users();
  users.deleteAll();
  User brad=users.createDefaultInstance().setHandle(""String_Node_Str"").setBio(""String_Node_Str"").setNumPosts(1).setCreatedAtMillis(1l);
  User brandon=users.createDefaultInstance().setHandle(""String_Node_Str"").setBio(""String_Node_Str"").setNumPosts(2).setCreatedAtMillis(1l).setSomeDatetime(0l);
  User casey=users.createDefaultInstance().setHandle(""String_Node_Str"").setBio(""String_Node_Str"").setNumPosts(2).setCreatedAtMillis(2l);
  User john=users.createDefaultInstance().setHandle(""String_Node_Str"").setBio(""String_Node_Str"").setNumPosts(3).setCreatedAtMillis(2l);
  User james=users.createDefaultInstance().setHandle(""String_Node_Str"").setBio(""String_Node_Str"").setNumPosts(5).setCreatedAtMillis(3l).setSomeDatetime(1000000l);
  brad.save();
  brandon.save();
  casey.save();
  john.save();
  james.save();
  List<User> result;
  result=users.query().whereHandle(equalTo(""String_Node_Str"")).find();
  assertEquals(1,result.size());
  assertTrue(result.contains(brad));
  result=users.query().whereNumPosts(between(4,8)).find();
  assertEquals(1,result.size());
  assertTrue(result.contains(james));
  result=users.query().whereNumPosts(notBetween(4,8)).find();
  assertEquals(4,result.size());
  assertTrue(result.containsAll(Sets.newHashSet(brad,brandon,casey,john)));
  result=users.query().whereCreatedAtMillis(lessThan(2l)).find();
  assertEquals(2,result.size());
  assertTrue(result.contains(brad));
  assertTrue(result.contains(brandon));
  result=users.query().whereCreatedAtMillis(greaterThan(1l)).find();
  assertEquals(3,result.size());
  result=users.query().whereCreatedAtMillis(lessThanOrEqualTo(2l)).find();
  assertEquals(4,result.size());
  result=users.query().whereCreatedAtMillis(greaterThanOrEqualTo(1l)).find();
  assertEquals(5,result.size());
  result=users.query().whereBio(endsWith(""String_Node_Str"")).find();
  assertEquals(5,result.size());
  result=users.query().whereBio(startsWith(""String_Node_Str"")).find();
  assertTrue(result.isEmpty());
  result=users.query().whereSomeDatetime(in(Collections.<Long>emptySet())).find();
  assertTrue(result.isEmpty());
  result=users.query().whereSomeDatetime(notIn(Collections.<Long>emptySet())).find();
  assertEquals(5,result.size());
  result=users.query().whereBio(contains(""String_Node_Str"")).whereNumPosts(in(1,3,5)).find();
  assertEquals(1,result.size());
  assertTrue(result.contains(james));
  result=users.query().whereHandle(notIn(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")).whereNumPosts(notEqualTo(5)).find();
  assertEquals(1,result.size());
  assertTrue(result.contains(casey));
  result=users.query().whereSomeDatetime(JackMatchers.<Long>isNull()).find();
  assertEquals(3,result.size());
  result=users.query().whereSomeDatetime(JackMatchers.<Long>isNotNull()).find();
  assertEquals(2,result.size());
  assertTrue(result.contains(brandon));
  assertTrue(result.contains(james));
  result=users.query().whereSomeDatetime(JackMatchers.isNotNull()).whereBio(JackMatchers.noop()).find();
  assertEquals(2,result.size());
  try {
    users.query().whereHandle(in(null,""String_Node_Str"")).find();
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
}",0.9788990825688072
38650,"private static void addArrayPath(JsonElement parentElement,ArrayPath childPath,List<TuplePath> tailPaths,ValueType type,String value){
  Optional<String> childName=childPath.getName();
  Optional<Integer> childIndex=childPath.getListIndex();
  Optional<Integer> childSize=childPath.getListSize();
  Preconditions.checkState(childIndex.isPresent());
  Preconditions.checkState(childSize.isPresent());
  if (childName.isPresent()) {
    String name=childName.get();
    Preconditions.checkState(parentElement.isJsonObject());
    JsonObject parentObject=parentElement.getAsJsonObject();
    final JsonArray childArray;
    if (!parentObject.has(name)) {
      childArray=new JsonArray();
      parentObject.add(name,childArray);
    }
 else {
      childArray=parentObject.get(name).getAsJsonArray();
    }
    if (!tailPaths.isEmpty()) {
      addChildPathToParentArray(childArray,childIndex.get(),tailPaths,type,value);
    }
 else {
      Preconditions.checkState(childArray.size() == childIndex.get());
      if (type != ValueType.JSON_EMPTY) {
        childArray.add(getJsonElement(type,value));
      }
    }
  }
 else {
    Preconditions.checkState(parentElement.isJsonArray());
    JsonArray parentArray=parentElement.getAsJsonArray();
    if (!tailPaths.isEmpty()) {
      addChildPathToParentArray(parentArray,childIndex.get(),tailPaths,type,value);
    }
 else {
      Preconditions.checkState(parentArray.size() == childIndex.get());
      if (type != ValueType.JSON_EMPTY) {
        parentArray.add(getJsonElement(type,value));
      }
    }
  }
}","private static void addArrayPath(JsonElement parentElement,ArrayPath childPath,List<TuplePath> tailPaths,ValueType type,String value){
  Optional<String> childName=childPath.getName();
  Optional<Integer> childIndex=childPath.getListIndex();
  Optional<Integer> childSize=childPath.getListSize();
  Preconditions.checkState(childIndex.isPresent());
  Preconditions.checkState(childSize.isPresent());
  if (childName.isPresent()) {
    String name=childName.get();
    Preconditions.checkState(parentElement.isJsonObject());
    JsonObject parentObject=parentElement.getAsJsonObject();
    final JsonArray childArray;
    if (!parentObject.has(name)) {
      childArray=new JsonArray();
      parentObject.add(name,childArray);
    }
 else {
      childArray=parentObject.get(name).getAsJsonArray();
    }
    if (!tailPaths.isEmpty()) {
      addChildPathToParentArray(childArray,childIndex.get(),tailPaths,type,value);
    }
 else {
      Preconditions.checkState(childArray.size() == childIndex.get());
      if (type != ValueType.JSON_EMPTY) {
        childArray.add(getJsonElement(type,value));
      }
 else       if (childSize.get() > 0) {
        childArray.add(new JsonObject());
      }
    }
  }
 else {
    Preconditions.checkState(parentElement.isJsonArray());
    JsonArray parentArray=parentElement.getAsJsonArray();
    if (!tailPaths.isEmpty()) {
      addChildPathToParentArray(parentArray,childIndex.get(),tailPaths,type,value);
    }
 else {
      Preconditions.checkState(parentArray.size() == childIndex.get());
      if (type != ValueType.JSON_EMPTY) {
        parentArray.add(getJsonElement(type,value));
      }
    }
  }
}",0.9722308892355694
38651,"void deleteExistingEntries(IDb db,Long recordId) throws IOException {
  for (  String key : types.keySet()) {
    db.createDeletion().from(table.table).where(table.scope.equalTo(recordId)).where(table.type.notEqualTo(ValueType.SCOPE.value)).where(table.key.equalTo(key).or(table.key.startsWith(key + JsonDbConstants.PATH_SEPARATOR))).execute();
  }
}","void deleteExistingEntries(IDb db,Long recordId) throws IOException {
  for (  String key : types.keySet()) {
    List<Long> rowIdsToDelete=db.createQuery().from(table.table).where(table.scope.equalTo(recordId)).where(table.type.notEqualTo(ValueType.SCOPE.value)).where(table.key.equalTo(key).or(table.key.startsWith(key + JsonDbConstants.PATH_SEPARATOR))).select(table.id).fetch().gets(table.id);
    db.createDeletion().from(table.table).where(table.id.in(rowIdsToDelete)).execute();
  }
}",0.8038049940546967
38652,"/** 
 * Creation of 100000 records By store: 16730 ms (0.17 ms per record) By model: 16965 ms (0.17 ms per record) Difference: 0.99 <p> Update of 100000 records By store: 44386 ms (0.44 ms per record) By model: 21601 ms (0.22 ms per record) Difference: 2.05 <p> Query (5 times) of 100000 records By store: 1718 ms (0.02 ms per record) By model: 946 ms (0.01 ms per record) Difference: 1.82 <p> Deletion of 100000 records By store: 43240 ms (0.43 ms per record) By model: 6926 ms (0.07 ms per record) Difference: 6.24
 */
@Test public void testPerformance() throws Exception {
  int size=200;
  testRecordCreation(size);
  testRecordUpdate(size);
  testRecordQuery(5,size);
  testRecordDeletion(size);
}","/** 
 * Creation of 100000 records By store: 16730 ms (0.17 ms per record) By model: 16965 ms (0.17 ms per record) Difference: 0.99 <p> Update of 100000 records By store: 67403 ms (0.67 ms per record) By model: 23117 ms (0.23 ms per record) Difference: 2.92 <p> Query (5 times) of 100000 records By store: 1718 ms (0.02 ms per record) By model: 946 ms (0.01 ms per record) Difference: 1.82 <p> Deletion of 100000 records By store: 43240 ms (0.43 ms per record) By model: 6926 ms (0.07 ms per record) Difference: 6.24
 */
@Test public void testPerformance() throws Exception {
  int size=200;
  testRecordCreation(size);
  testRecordUpdate(size);
  testRecordQuery(5,size);
  testRecordDeletion(size);
}",0.9615384615384616
38653,"private Set<Long> querySubRecordsByRecordConstraints(IDb db) throws IOException {
  Set<Long> recordIds=null;
  for (  Map.Entry<String,List<GenericConstraint>> entry : recordConstraints.entrySet()) {
    if (recordIds != null && recordIds.isEmpty()) {
      return Collections.emptySet();
    }
    GenericQuery query=db.createQuery().from(table.table).leftJoin(scope.table).on(table.scopeColumn.equalTo(scope.idColumn)).where(table.typeColumn.notEqualTo(ValueType.SCOPE.value)).select(table.scopeColumn);
    if (recordIds != null) {
      query.where(table.scopeColumn.in(recordIds));
    }
    for (    GenericConstraint constraint : scopeConstraints) {
      query.where(constraint);
    }
    String key=entry.getKey();
    if (key.contains(""String_Node_Str"")) {
      query.where(table.keyColumn.matches(key));
    }
 else {
      query.where(table.keyColumn.equalTo(key));
    }
    List<GenericConstraint> constraints=entry.getValue();
    for (    GenericConstraint constraint : constraints) {
      query.where(constraint);
    }
    recordIds=Sets.newHashSet(query.fetch().gets(table.scopeColumn));
  }
  return recordIds;
}","private Set<Long> querySubRecordsByRecordConstraints(IDb db) throws IOException {
  Set<Long> recordIds=null;
  for (  Map.Entry<String,List<GenericConstraint>> entry : recordConstraints.entrySet()) {
    if (recordIds != null && recordIds.isEmpty()) {
      return Collections.emptySet();
    }
    GenericQuery query=db.createQuery().from(table.table).leftJoin(scope.table).on(table.scopeColumn.equalTo(scope.idColumn)).where(scope.scopeColumn.equalTo(executionRecordId)).where(table.typeColumn.notEqualTo(ValueType.SCOPE.value)).select(table.scopeColumn);
    if (recordIds != null) {
      query.where(table.scopeColumn.in(recordIds));
    }
    for (    GenericConstraint constraint : scopeConstraints) {
      query.where(constraint);
    }
    String key=entry.getKey();
    if (key.contains(""String_Node_Str"")) {
      query.where(table.keyColumn.matches(key));
    }
 else {
      query.where(table.keyColumn.equalTo(key));
    }
    List<GenericConstraint> constraints=entry.getValue();
    for (    GenericConstraint constraint : constraints) {
      query.where(constraint);
    }
    recordIds=Sets.newHashSet(query.fetch().gets(table.scopeColumn));
  }
  return recordIds;
}",0.9776247848537004
38654,"@Test public void testKeyConstraint() throws Exception {
  long s1=createSubScope(Optional.empty(),Optional.of(""String_Node_Str""));
  long s2=createSubScope(Optional.empty(),Optional.of(""String_Node_Str""));
  long s3=createSubScope(Optional.empty(),Optional.of(""String_Node_Str""));
  long s4=createSubScope(Optional.empty(),Optional.of(""String_Node_Str""));
  transactor.executeAsTransaction(db -> {
    jackStore2.record(s1).update().put(""String_Node_Str"",15).put(""String_Node_Str"",50).execute(db);
    jackStore2.record(s2).update().put(""String_Node_Str"",20).put(""String_Node_Str"",60).execute(db);
    jackStore2.record(s3).update().put(""String_Node_Str"",25).put(""String_Node_Str"",70).execute(db);
    jackStore2.record(s4).update().put(""String_Node_Str"",30).put(""String_Node_Str"",80).execute(db);
  }
);
  jsRecords=transactor.query(db -> jackStore2.rootRecord().querySubRecords().whereSubRecord(""String_Node_Str"",JackMatchers.equalTo(""String_Node_Str"")).execute(db));
  assertEquals(Lists.newArrayList(s1),jsRecords.getRecordIds());
  jsRecords=transactor.query(db -> jackStore2.rootRecord().querySubRecords().whereSubRecord(""String_Node_Str"",JackMatchers.notEqualTo(""String_Node_Str"")).execute(db));
  assertEquals(Lists.newArrayList(s2,s3,s4),jsRecords.getRecordIds());
  jsRecords=transactor.query(db -> jackStore2.rootRecord().querySubRecords().whereSubRecord(""String_Node_Str"",JackMatchers.between(""String_Node_Str"",""String_Node_Str"")).execute(db));
  assertEquals(Lists.newArrayList(s1,s2,s3),jsRecords.getRecordIds());
  jsRecords=transactor.query(db -> jackStore2.rootRecord().querySubRecords().whereSubRecord(""String_Node_Str"",JackMatchers.greaterThan(""String_Node_Str"")).whereSubRecord(""String_Node_Str"",JackMatchers.lessThan(""String_Node_Str"")).execute(db));
  assertEquals(Lists.newArrayList(s2),jsRecords.getRecordIds());
  jsRecords=transactor.query(db -> jackStore2.rootRecord().querySubRecords().whereSubRecord(""String_Node_Str"",JackMatchers.equalTo(""String_Node_Str"")).whereSubRecord(""String_Node_Str"",JackMatchers.equalTo(""String_Node_Str"")).execute(db));
  assertEquals(Lists.newArrayList(s1),jsRecords.getRecordIds());
  jsRecords=transactor.query(db -> jackStore2.rootRecord().querySubRecords().whereSubRecord(""String_Node_Str"",JackMatchers.equalTo(""String_Node_Str"")).whereSubRecord(""String_Node_Str"",JackMatchers.notEqualTo(""String_Node_Str"")).execute(db));
  assertEquals(0,jsRecords.size());
  jsRecords=transactor.query(db -> jackStore2.rootRecord().querySubRecords().whereSubRecord(""String_Node_Str"",JackMatchers.greaterThan(""String_Node_Str"")).whereSubRecord(""String_Node_Str"",JackMatchers.lessThan(""String_Node_Str"")).execute(db));
  assertEquals(Lists.newArrayList(s2,s3),jsRecords.getRecordIds());
}","@Test public void testKeyConstraint() throws Exception {
  long s1=createSubScope(Optional.empty(),Optional.of(""String_Node_Str""));
  long s2=createSubScope(Optional.empty(),Optional.of(""String_Node_Str""));
  long s3=createSubScope(Optional.empty(),Optional.of(""String_Node_Str""));
  long s4=createSubScope(Optional.empty(),Optional.of(""String_Node_Str""));
  long s11=createSubScope(Optional.of(s1),Optional.of(""String_Node_Str""));
  long s21=createSubScope(Optional.of(s2),Optional.of(""String_Node_Str""));
  long s31=createSubScope(Optional.of(s3),Optional.of(""String_Node_Str""));
  long s41=createSubScope(Optional.of(s4),Optional.of(""String_Node_Str""));
  transactor.executeAsTransaction(db -> {
    jackStore2.record(s1).update().put(""String_Node_Str"",15).put(""String_Node_Str"",50).exec(db);
    jackStore2.record(s2).update().put(""String_Node_Str"",20).put(""String_Node_Str"",60).exec(db);
    jackStore2.record(s3).update().put(""String_Node_Str"",25).put(""String_Node_Str"",70).exec(db);
    jackStore2.record(s4).update().put(""String_Node_Str"",30).put(""String_Node_Str"",80).exec(db);
    jackStore2.record(s11).update().put(""String_Node_Str"",15).put(""String_Node_Str"",50).exec(db);
    jackStore2.record(s21).update().put(""String_Node_Str"",20).put(""String_Node_Str"",60).exec(db);
    jackStore2.record(s31).update().put(""String_Node_Str"",25).put(""String_Node_Str"",70).exec(db);
    jackStore2.record(s41).update().put(""String_Node_Str"",30).put(""String_Node_Str"",80).exec(db);
  }
);
  jsRecords=transactor.query(db -> jackStore2.rootRecord().querySubRecords().whereSubRecord(""String_Node_Str"",JackMatchers.equalTo(""String_Node_Str"")).execute(db));
  assertEquals(Lists.newArrayList(s1),jsRecords.getRecordIds());
  jsRecords=transactor.query(db -> jackStore2.rootRecord().querySubRecords().whereSubRecord(""String_Node_Str"",JackMatchers.notEqualTo(""String_Node_Str"")).execute(db));
  assertEquals(Lists.newArrayList(s2,s3,s4),jsRecords.getRecordIds());
  jsRecords=transactor.query(db -> jackStore2.rootRecord().querySubRecords().whereSubRecord(""String_Node_Str"",JackMatchers.between(""String_Node_Str"",""String_Node_Str"")).execute(db));
  assertEquals(Lists.newArrayList(s1,s2,s3),jsRecords.getRecordIds());
  jsRecords=transactor.query(db -> jackStore2.rootRecord().querySubRecords().whereSubRecord(""String_Node_Str"",JackMatchers.greaterThan(""String_Node_Str"")).whereSubRecord(""String_Node_Str"",JackMatchers.lessThan(""String_Node_Str"")).execute(db));
  assertEquals(Lists.newArrayList(s2),jsRecords.getRecordIds());
  jsRecords=transactor.query(db -> jackStore2.rootRecord().querySubRecords().whereSubRecord(""String_Node_Str"",JackMatchers.equalTo(""String_Node_Str"")).whereSubRecord(""String_Node_Str"",JackMatchers.equalTo(""String_Node_Str"")).execute(db));
  assertEquals(Lists.newArrayList(s1),jsRecords.getRecordIds());
  jsRecords=transactor.query(db -> jackStore2.rootRecord().querySubRecords().whereSubRecord(""String_Node_Str"",JackMatchers.equalTo(""String_Node_Str"")).whereSubRecord(""String_Node_Str"",JackMatchers.notEqualTo(""String_Node_Str"")).execute(db));
  assertEquals(0,jsRecords.size());
  jsRecords=transactor.query(db -> jackStore2.rootRecord().querySubRecords().whereSubRecord(""String_Node_Str"",JackMatchers.greaterThan(""String_Node_Str"")).whereSubRecord(""String_Node_Str"",JackMatchers.lessThan(""String_Node_Str"")).execute(db));
  assertEquals(Lists.newArrayList(s2,s3),jsRecords.getRecordIds());
}",0.8854539537910836
38655,"public JsRecords execute(IDb db) throws IOException {
  Optional<JsScope> executionScope=getOptionalExecutionScope(db);
  if (!executionScope.isPresent()) {
    throw new MissingScopeException(Joiner.on(""String_Node_Str"").join(predefinedScopeNames));
  }
  Records records=db.createQuery().from(table.table).where(table.typeColumn.notEqualTo(ValueType.SCOPE.value)).where(table.scopeColumn.in(subScopeIds)).select(table.scopeColumn,table.typeColumn,table.keyColumn,table.valueColumn).orderBy(table.scopeColumn).orderBy(table.idColumn).fetch();
  if (records.isEmpty()) {
    return JsRecords.empty(executionScope.get().getScopeId());
  }
  List<JsRecord> jsRecords=Lists.newLinkedList();
  Long previousScopeId=records.get(0).get(table.scopeColumn);
  Map<String,ValueType> types=Maps.newHashMap();
  Map<String,Object> values=Maps.newHashMap();
  List<JsonDbTuple> jsonTuples=Lists.newLinkedList();
  Set<String> jsonKeys=Sets.newHashSet();
  Iterator<Record> iterator=records.iterator();
  while (iterator.hasNext()) {
    Record record=iterator.next();
    Long currentScopeId=record.get(table.scopeColumn);
    if (!Objects.equals(previousScopeId,currentScopeId)) {
      addJsRecord(currentScopeId,types,values,jsonTuples,jsonKeys,jsRecords);
      types=Maps.newHashMap();
      values=Maps.newHashMap();
      jsonTuples=Lists.newLinkedList();
      jsonKeys=Sets.newHashSet();
      previousScopeId=currentScopeId;
    }
    appendRecord(types,values,jsonTuples,jsonKeys,record);
    if (!iterator.hasNext()) {
      addJsRecord(currentScopeId,types,values,jsonTuples,jsonKeys,jsRecords);
    }
  }
  return new JsRecords(executionScope.get().getScopeId(),jsRecords);
}","public JsRecords execute(IDb db) throws IOException {
  Optional<JsScope> executionScope=getOptionalExecutionScope(db);
  if (!executionScope.isPresent()) {
    throw new MissingScopeException(Joiner.on(""String_Node_Str"").join(predefinedScopeNames));
  }
  Records records=db.createQuery().from(table.table).where(table.typeColumn.notEqualTo(ValueType.SCOPE.value)).where(table.scopeColumn.in(subScopeIds)).select(table.scopeColumn,table.typeColumn,table.keyColumn,table.valueColumn).orderBy(table.scopeColumn).orderBy(table.idColumn).fetch();
  if (records.isEmpty()) {
    return JsRecords.empty(executionScope.get().getScopeId());
  }
  List<JsRecord> jsRecords=Lists.newLinkedList();
  Long previousScopeId=records.get(0).get(table.scopeColumn);
  Map<String,ValueType> types=Maps.newHashMap();
  Map<String,Object> values=Maps.newHashMap();
  List<JsonDbTuple> jsonTuples=Lists.newLinkedList();
  Set<String> jsonKeys=Sets.newHashSet();
  Iterator<Record> iterator=records.iterator();
  while (iterator.hasNext()) {
    Record record=iterator.next();
    Long currentScopeId=record.get(table.scopeColumn);
    if (!Objects.equals(previousScopeId,currentScopeId)) {
      addJsRecord(previousScopeId,types,values,jsonTuples,jsonKeys,jsRecords);
      types=Maps.newHashMap();
      values=Maps.newHashMap();
      jsonTuples=Lists.newLinkedList();
      jsonKeys=Sets.newHashSet();
      previousScopeId=currentScopeId;
    }
    appendRecord(types,values,jsonTuples,jsonKeys,record);
    if (!iterator.hasNext()) {
      addJsRecord(currentScopeId,types,values,jsonTuples,jsonKeys,jsRecords);
    }
  }
  return new JsRecords(executionScope.get().getScopeId(),jsRecords);
}",0.9955290611028316
38656,"@Override public JsRecords execute(IDb db) throws IOException {
  Set<Long> validSubScopeIds=InternalScopeGetter.getValidSubScopeIds(db,table,executionScopeId,subScopeIds,ignoreInvalidSubScopes);
  if (validSubScopeIds.isEmpty()) {
    return JsRecords.empty(executionScopeId);
  }
  Records records=db.createQuery().from(table.table).where(table.typeColumn.notEqualTo(ValueType.SCOPE.value)).where(table.scopeColumn.in(validSubScopeIds)).select(table.scopeColumn,table.typeColumn,table.keyColumn,table.valueColumn).orderBy(table.scopeColumn).orderBy(table.idColumn).fetch();
  if (records.isEmpty()) {
    List<JsRecord> emptyRecords=Lists.newLinkedList();
    for (    long subScopeId : validSubScopeIds) {
      emptyRecords.add(JsRecord.empty(subScopeId));
    }
    return new JsRecords(executionScopeId,emptyRecords);
  }
  List<JsRecord> jsRecords=Lists.newLinkedList();
  Long previousScopeId=records.get(0).get(table.scopeColumn);
  InternalRecordCreator recordCreator=new InternalRecordCreator(table,selectedKeys);
  Iterator<Record> iterator=records.iterator();
  while (iterator.hasNext()) {
    Record record=iterator.next();
    Long currentScopeId=record.get(table.scopeColumn);
    if (!Objects.equals(previousScopeId,currentScopeId)) {
      if (recordCreator.hasNewRecord()) {
        jsRecords.add(recordCreator.createNewRecord(currentScopeId));
      }
      previousScopeId=currentScopeId;
    }
    recordCreator.appendRecord(record);
    if (!iterator.hasNext() && recordCreator.hasNewRecord()) {
      jsRecords.add(recordCreator.createNewRecord(currentScopeId));
    }
  }
  return new JsRecords(executionScopeId,jsRecords);
}","@Override public JsRecords execute(IDb db) throws IOException {
  Set<Long> validSubScopeIds=InternalScopeGetter.getValidSubScopeIds(db,table,executionScopeId,subScopeIds,ignoreInvalidSubScopes);
  if (validSubScopeIds.isEmpty()) {
    return JsRecords.empty(executionScopeId);
  }
  Records records=db.createQuery().from(table.table).where(table.typeColumn.notEqualTo(ValueType.SCOPE.value)).where(table.scopeColumn.in(validSubScopeIds)).select(table.scopeColumn,table.typeColumn,table.keyColumn,table.valueColumn).orderBy(table.scopeColumn).orderBy(table.idColumn).fetch();
  if (records.isEmpty()) {
    List<JsRecord> emptyRecords=Lists.newLinkedList();
    for (    long subScopeId : validSubScopeIds) {
      emptyRecords.add(JsRecord.empty(subScopeId));
    }
    return new JsRecords(executionScopeId,emptyRecords);
  }
  List<JsRecord> jsRecords=Lists.newLinkedList();
  Long previousScopeId=records.get(0).get(table.scopeColumn);
  InternalRecordCreator recordCreator=new InternalRecordCreator(table,selectedKeys);
  Iterator<Record> iterator=records.iterator();
  while (iterator.hasNext()) {
    Record record=iterator.next();
    Long currentScopeId=record.get(table.scopeColumn);
    if (!Objects.equals(previousScopeId,currentScopeId)) {
      if (recordCreator.hasNewRecord()) {
        jsRecords.add(recordCreator.createNewRecord(previousScopeId));
      }
      previousScopeId=currentScopeId;
    }
    recordCreator.appendRecord(record);
    if (!iterator.hasNext() && recordCreator.hasNewRecord()) {
      jsRecords.add(recordCreator.createNewRecord(currentScopeId));
    }
  }
  return new JsRecords(executionScopeId,jsRecords);
}",0.9954586739327884
38657,"@Test public void testGetRecords() throws Exception {
  String customScope=""String_Node_Str"";
  String key1=""String_Node_Str"";
  String key2=""String_Node_Str"";
  String key3=""String_Node_Str"";
  int size=20;
  List<JsScope> scopes=Lists.newArrayListWithCapacity(size);
  transactor.executeAsTransaction(db -> {
    for (long i=0L; i < size; ++i) {
      JsScope scope=jackStore.scope(customScope).createSubScope(String.valueOf(i)).execute(db);
      scopes.add(scope);
      jackStore.scope(scope).indexRecords().putLong(LONG_KEY,i).putString(STRING_KEY,String.valueOf(i)).putJson(JSON_KEY,JSON_PARSER.parse(String.format(""String_Node_Str"",key1,key2,i,key3)).getAsJsonObject()).execute(db);
    }
  }
);
  Random random=new Random(System.currentTimeMillis());
  int lo=Math.max(1,random.nextInt(size / 2));
  int hi=Math.min(size,lo + size / 5 + random.nextInt(size));
  LOG.info(""String_Node_Str"",lo,hi);
  List<JsScope> subScopes=scopes.subList(lo,hi);
  JsRecords jsRecords=transactor.queryAsTransaction(db -> jackStore.scope(customScope).readSubScopes(subScopes).execute(db));
  assertEquals(subScopes.size(),jsRecords.size());
  for (int i=0; i < subScopes.size(); ++i) {
    String scopeName=subScopes.get(i).getScopeName();
    int scopeNameInt=Integer.valueOf(scopeName);
    JsRecord jsRecord=jsRecords.get(i);
    assertEquals(scopeNameInt,jsRecord.getLong(LONG_KEY).intValue());
    assertEquals(scopeName,jsRecord.getString(STRING_KEY));
    JsonObject json=jsRecord.getJson(JSON_KEY);
    int jsonKey3Value=json.get(key1).getAsJsonObject().get(key2).getAsJsonPrimitive().getAsNumber().intValue();
    assertEquals(scopeNameInt,jsonKey3Value);
  }
}","@Test public void testGetRecords() throws Exception {
  String customScope=""String_Node_Str"";
  String key1=""String_Node_Str"";
  String key2=""String_Node_Str"";
  String key3=""String_Node_Str"";
  int size=20;
  List<JsScope> scopes=Lists.newArrayListWithCapacity(size);
  transactor.executeAsTransaction(db -> {
    for (long i=0L; i < size; ++i) {
      JsScope scope=jackStore.scope(customScope).createSubScope(String.valueOf(i)).execute(db);
      scopes.add(scope);
      jackStore.scope(scope).indexRecords().putLong(LONG_KEY,i).putString(STRING_KEY,String.valueOf(i)).putJson(JSON_KEY,JSON_PARSER.parse(String.format(""String_Node_Str"",key1,key2,i,key3)).getAsJsonObject()).execute(db);
    }
  }
);
  Random random=new Random(System.currentTimeMillis());
  int lo=Math.max(1,random.nextInt(size / 2));
  int hi=Math.min(size,lo + size / 5 + random.nextInt(size));
  LOG.info(""String_Node_Str"",lo,hi);
  List<JsScope> subScopes=scopes.subList(lo,hi);
  JsRecords jsRecords=transactor.queryAsTransaction(db -> jackStore.scope(customScope).readSubScopes(subScopes).execute(db));
  assertEquals(subScopes.size(),jsRecords.size());
  for (int i=0; i < subScopes.size(); ++i) {
    String scopeName=subScopes.get(i).getScopeName();
    int scopeNameInt=Integer.valueOf(scopeName);
    JsRecord jsRecord=jsRecords.get(i);
    long scopeId=subScopes.get(i).getScopeId();
    assertEquals(scopeId,jsRecord.getScopeId().longValue());
    assertEquals(scopeNameInt,jsRecord.getLong(LONG_KEY).intValue());
    assertEquals(scopeName,jsRecord.getString(STRING_KEY));
    JsonObject json=jsRecord.getJson(JSON_KEY);
    int jsonKey3Value=json.get(key1).getAsJsonObject().get(key2).getAsJsonPrimitive().getAsNumber().intValue();
    assertEquals(scopeNameInt,jsonKey3Value);
  }
}",0.968230836490819
38658,"@Test public void testReadSubScopes() throws Exception {
  String parentScope=""String_Node_Str"";
  String jsonKey1=""String_Node_Str"";
  String jsonKey2=""String_Node_Str"";
  String jsonKey3=""String_Node_Str"";
  long parentScopeId=createSubScope(Optional.empty(),Optional.of(parentScope));
  int size=20;
  List<JsRecord> allJsRecords=Lists.newLinkedList();
  transactor.executeAsTransaction(db -> {
    for (long i=0L; i < size; ++i) {
      JsRecord record=jackStore2.scope(parentScopeId).createSubScope().scopeName(String.valueOf(i)).putLong(LONG_KEY,i).putString(STRING_KEY,String.valueOf(i)).putJson(JSON_KEY,JSON_PARSER.parse(String.format(""String_Node_Str"",jsonKey1,jsonKey2,i,jsonKey3)).getAsJsonObject()).execute(db);
      allJsRecords.add(record);
    }
  }
);
  Random random=new Random(System.currentTimeMillis());
  int lo=Math.max(1,random.nextInt(size / 2));
  int hi=Math.min(size,lo + size / 5 + random.nextInt(size));
  LOG.info(""String_Node_Str"",lo,hi);
  List<JsRecord> subRecords=allJsRecords.subList(lo,hi);
  List<Long> subScopeIds=subRecords.stream().map(JsRecord::getScopeId).collect(Collectors.toList());
  jsRecords=transactor.queryAsTransaction(db -> jackStore2.scope(parentScopeId).readSubScopes().whereSubScopeIds(subScopeIds).execute(db));
  assertEquals(subRecords.size(),jsRecords.size());
  for (int i=0; i < subRecords.size(); ++i) {
    int index=i + lo;
    JsRecord jsRecord=jsRecords.get(i);
    String intString=String.valueOf(index);
    assertEquals(index,jsRecord.getLong(LONG_KEY).intValue());
    assertEquals(intString,jsRecord.getString(STRING_KEY));
    JsonObject json=jsRecord.getJson(JSON_KEY);
    int jsonKey3Value=json.get(jsonKey1).getAsJsonObject().get(jsonKey2).getAsJsonPrimitive().getAsNumber().intValue();
    assertEquals(index,jsonKey3Value);
  }
}","@Test public void testReadSubScopes() throws Exception {
  String parentScope=""String_Node_Str"";
  String jsonKey1=""String_Node_Str"";
  String jsonKey2=""String_Node_Str"";
  String jsonKey3=""String_Node_Str"";
  long parentScopeId=createSubScope(Optional.empty(),Optional.of(parentScope));
  int size=20;
  List<JsRecord> allJsRecords=Lists.newLinkedList();
  transactor.executeAsTransaction(db -> {
    for (long i=0L; i < size; ++i) {
      JsRecord record=jackStore2.scope(parentScopeId).createSubScope().scopeName(String.valueOf(i)).putLong(LONG_KEY,i).putString(STRING_KEY,String.valueOf(i)).putJson(JSON_KEY,JSON_PARSER.parse(String.format(""String_Node_Str"",jsonKey1,jsonKey2,i,jsonKey3)).getAsJsonObject()).execute(db);
      allJsRecords.add(record);
    }
  }
);
  Random random=new Random(System.currentTimeMillis());
  int lo=Math.max(1,random.nextInt(size / 2));
  int hi=Math.min(size,lo + size / 5 + random.nextInt(size));
  LOG.info(""String_Node_Str"",lo,hi);
  List<JsRecord> subRecords=allJsRecords.subList(lo,hi);
  List<Long> subScopeIds=subRecords.stream().map(JsRecord::getScopeId).collect(Collectors.toList());
  jsRecords=transactor.queryAsTransaction(db -> jackStore2.scope(parentScopeId).readSubScopes().whereSubScopeIds(subScopeIds).execute(db));
  assertEquals(subRecords.size(),jsRecords.size());
  for (int i=0; i < subRecords.size(); ++i) {
    int index=i + lo;
    JsRecord jsRecord=jsRecords.get(i);
    long scopeId=subRecords.get(i).getScopeId();
    String intString=String.valueOf(index);
    assertEquals(scopeId,jsRecord.getScopeId().longValue());
    assertEquals(index,jsRecord.getLong(LONG_KEY).intValue());
    assertEquals(intString,jsRecord.getString(STRING_KEY));
    JsonObject json=jsRecord.getJson(JSON_KEY);
    int jsonKey3Value=json.get(jsonKey1).getAsJsonObject().get(jsonKey2).getAsJsonPrimitive().getAsNumber().intValue();
    assertEquals(index,jsonKey3Value);
  }
}",0.9704935622317596
38659,"public boolean isRootScope(){
  return scopeId < 0;
}","public boolean isRootScope(){
  return scopeId == null;
}",0.9272727272727272
38660,"@Test public void testMaxConnectionWaitingTime() throws Exception {
  TransactorImpl<IDatabase1> transactor=transactorBuilder.setMaxTotalConnections(1).get();
  Future<Long> future1=executorService.submit(() -> transactor.query(a -> {
    sleepMillis(100);
    return stopwatch.elapsedMillis();
  }
));
  final Long[] startingTime2=new Long[1];
  Future future2=executorService.submit(() -> {
    startingTime2[0]=stopwatch.elapsedMillis();
    transactor.execute(a -> {
      sleepMillis(100);
    }
);
  }
);
  long finishingTime1=future1.get();
  future2.get();
  DbMetrics dbMetrics=transactor.getDbMetrics();
  double maxConnectionsWaitingTime=dbMetrics.getMaxConnectionWaitingTime();
  transactor.close();
  double expectedMaxConnectionsWaitingTime=finishingTime1 - startingTime2[0];
  expectedMaxConnectionsWaitingTime=(expectedMaxConnectionsWaitingTime > 0) ? expectedMaxConnectionsWaitingTime : 0;
  assertRoughEqual(maxConnectionsWaitingTime,expectedMaxConnectionsWaitingTime,20);
}","@Test public void testMaxConnectionWaitingTime() throws Exception {
  TransactorImpl<IDatabase1> transactor=transactorBuilder.setMaxTotalConnections(1).get();
  sleepMillis(200);
  Future<Long> future1=executorService.submit(() -> transactor.query(a -> {
    sleepMillis(100);
    return stopwatch.elapsedMillis();
  }
));
  final Long[] startingTime2=new Long[1];
  Future future2=executorService.submit(() -> {
    startingTime2[0]=stopwatch.elapsedMillis();
    transactor.execute(a -> {
      sleepMillis(100);
    }
);
  }
);
  long finishingTime1=future1.get();
  future2.get();
  DbMetrics dbMetrics=transactor.getDbMetrics();
  double maxConnectionsWaitingTime=dbMetrics.getMaxConnectionWaitingTime();
  transactor.close();
  double expectedMaxConnectionsWaitingTime=finishingTime1 - startingTime2[0];
  LOG.info(""String_Node_Str"",maxConnectionsWaitingTime);
  LOG.info(""String_Node_Str"",expectedMaxConnectionsWaitingTime);
  expectedMaxConnectionsWaitingTime=(expectedMaxConnectionsWaitingTime > 0) ? expectedMaxConnectionsWaitingTime : 0;
  assertRoughEqual(maxConnectionsWaitingTime,expectedMaxConnectionsWaitingTime,20);
}",0.9332079021636877
38661,"@Test public void testQueryOverhead() throws Exception {
  TransactorImpl<IDatabase1> transactor1=transactorBuilder.setMetricsTracking(false).get();
  long startTime1=stopwatch.elapsedMillis();
  for (int i=0; i < 10; i++) {
    transactor1.execute(db -> {
      Thread.sleep(20);
    }
);
  }
  long finishTime1=stopwatch.elapsedMillis() - startTime1;
  System.out.println(""String_Node_Str"" + finishTime1);
  transactor1.close();
  TransactorImpl<IDatabase1> transactor2=transactorBuilder.setMetricsTracking(false).get();
  long startTime2=stopwatch.elapsedMillis();
  for (int i=0; i < 10; i++) {
    transactor2.execute(db -> {
      Thread.sleep(20);
    }
);
  }
  long finishTime2=stopwatch.elapsedMillis() - startTime2;
  System.out.println(""String_Node_Str"" + finishTime2);
  transactor2.close();
  assertRoughEqual(finishTime1,finishTime2,.2 * finishTime1);
}","@Test public void testQueryOverhead() throws Exception {
  TransactorImpl<IDatabase1> transactor1=transactorBuilder.setMetricsTracking(false).get();
  long startTime1=stopwatch.elapsedMillis();
  for (int i=0; i < 10; i++) {
    transactor1.execute(db -> {
      Thread.sleep(20);
    }
);
  }
  long finishTime1=stopwatch.elapsedMillis() - startTime1;
  System.out.println(""String_Node_Str"" + finishTime1);
  transactor1.close();
  TransactorImpl<IDatabase1> transactor2=transactorBuilder.setMetricsTracking(true).get();
  long startTime2=stopwatch.elapsedMillis();
  for (int i=0; i < 10; i++) {
    transactor2.execute(db -> {
      Thread.sleep(20);
    }
);
  }
  long finishTime2=stopwatch.elapsedMillis() - startTime2;
  System.out.println(""String_Node_Str"" + finishTime2);
  transactor2.close();
  assertRoughEqual(finishTime1,finishTime2,.2 * finishTime1);
}",0.9959654178674352
38662,"@Before public void prepare() throws Exception {
  transactorBuilder.get().query(IDb::deleteAll);
  stopwatch.start();
}","@Before public void prepare() throws Exception {
  transactorBuilder.get().query(IDb::deleteAll);
  stopwatch.start();
  executorService=Executors.newFixedThreadPool(5);
}",0.8247422680412371
38663,"@Test public void testAverageConnectionWaitingTime() throws Exception {
  TransactorImpl<IDatabase1> transactor=transactorBuilder.setMaxTotalConnections(1).get();
  executorService=Executors.newFixedThreadPool(2);
  Future<Long> future1=executorService.submit(() -> transactor.query(a -> {
    sleepMillis(100);
    return stopwatch.elapsedMillis();
  }
));
  final Long[] startingTime2=new Long[1];
  Future future2=executorService.submit(() -> {
    startingTime2[0]=stopwatch.elapsedMillis();
    transactor.execute(a -> {
      sleepMillis(100);
    }
);
  }
);
  long finishingTime1=future1.get();
  future2.get();
  DbMetrics dbMetrics=transactor.getDbMetrics();
  double averageConnectionsWaitingTime=dbMetrics.getAverageConnectionWaitingTime();
  transactor.close();
  double expectedAverageConnectionsWaitingTime=(finishingTime1 - startingTime2[0]) / 2;
  expectedAverageConnectionsWaitingTime=(expectedAverageConnectionsWaitingTime > 0) ? expectedAverageConnectionsWaitingTime : 0;
  assertRoughEqual(averageConnectionsWaitingTime,expectedAverageConnectionsWaitingTime,15);
}","@Test public void testAverageConnectionWaitingTime() throws Exception {
  TransactorImpl<IDatabase1> transactor=transactorBuilder.setMaxTotalConnections(1).get();
  Future<Long> future1=executorService.submit(() -> transactor.query(a -> {
    sleepMillis(100);
    return stopwatch.elapsedMillis();
  }
));
  final Long[] startingTime2=new Long[1];
  Future future2=executorService.submit(() -> {
    startingTime2[0]=stopwatch.elapsedMillis();
    transactor.execute(a -> {
      sleepMillis(100);
    }
);
  }
);
  long finishingTime1=future1.get();
  future2.get();
  DbMetrics dbMetrics=transactor.getDbMetrics();
  double averageConnectionsWaitingTime=dbMetrics.getAverageConnectionWaitingTime();
  transactor.close();
  double expectedAverageConnectionsWaitingTime=(finishingTime1 - startingTime2[0]) / 2;
  expectedAverageConnectionsWaitingTime=(expectedAverageConnectionsWaitingTime > 0) ? expectedAverageConnectionsWaitingTime : 0;
  assertRoughEqual(averageConnectionsWaitingTime,expectedAverageConnectionsWaitingTime,15);
}",0.975932043416706
38664,"@Test public void testAverageConnectionExecutionTime() throws Exception {
  TransactorImpl<IDatabase1> transactor=transactorBuilder.setMaxTotalConnections(2).get();
  executorService=Executors.newFixedThreadPool(5);
  Future<Long> future1=executorService.submit(() -> {
    long start=stopwatch.elapsedMillis();
    transactor.execute(a -> {
      sleepMillis(100);
    }
);
    return stopwatch.elapsedMillis() - start;
  }
);
  Future<Long> future2=executorService.submit(() -> {
    long start=stopwatch.elapsedMillis();
    transactor.execute(a -> {
      sleepMillis(100);
    }
);
    return stopwatch.elapsedMillis() - start;
  }
);
  double expectedAverageConnectionExecutionTime=((double)future1.get() + (double)future2.get()) / 2;
  DbMetrics dbMetrics=transactor.getDbMetrics();
  double averageConnectionExecutionTime=dbMetrics.getAverageConnectionExecutionTime();
  transactor.close();
  assertRoughEqual(averageConnectionExecutionTime,expectedAverageConnectionExecutionTime,20);
}","@Test public void testAverageConnectionExecutionTime() throws Exception {
  TransactorImpl<IDatabase1> transactor=transactorBuilder.setMaxTotalConnections(2).get();
  Future<Long> future1=executorService.submit(() -> {
    long start=stopwatch.elapsedMillis();
    transactor.execute(a -> {
      sleepMillis(100);
    }
);
    return stopwatch.elapsedMillis() - start;
  }
);
  Future<Long> future2=executorService.submit(() -> {
    long start=stopwatch.elapsedMillis();
    transactor.execute(a -> {
      sleepMillis(100);
    }
);
    return stopwatch.elapsedMillis() - start;
  }
);
  double expectedAverageConnectionExecutionTime=((double)future1.get() + (double)future2.get()) / 2;
  DbMetrics dbMetrics=transactor.getDbMetrics();
  double averageConnectionExecutionTime=dbMetrics.getAverageConnectionExecutionTime();
  transactor.close();
  assertRoughEqual(averageConnectionExecutionTime,expectedAverageConnectionExecutionTime,20);
}",0.973670624677336
38665,"@Test public void testOpenedConnectionsNumber() throws Exception {
  executorService=Executors.newFixedThreadPool(5);
  TransactorImpl<IDatabase1> transactor=transactorBuilder.setMaxTotalConnections(2).get();
  Future future1=executorService.submit(() -> transactor.execute(a -> {
    sleepMillis(50);
  }
));
  Future future2=executorService.submit(() -> transactor.execute(a -> {
    sleepMillis(50);
  }
));
  Future future3=executorService.submit(() -> transactor.execute(a -> {
    sleepMillis(50);
  }
));
  future1.get();
  future2.get();
  future3.get();
  DbMetrics dbMetrics=transactor.getDbMetrics();
  double openedConnectionsNumber=dbMetrics.getOpenedConnectionsNumber();
  transactor.close();
  assertTrue(openedConnectionsNumber == 2);
}","@Test public void testOpenedConnectionsNumber() throws Exception {
  TransactorImpl<IDatabase1> transactor=transactorBuilder.setMaxTotalConnections(2).get();
  Future future1=executorService.submit(() -> transactor.execute(a -> {
    sleepMillis(50);
  }
));
  Future future2=executorService.submit(() -> transactor.execute(a -> {
    sleepMillis(50);
  }
));
  Future future3=executorService.submit(() -> transactor.execute(a -> {
    sleepMillis(50);
  }
));
  future1.get();
  future2.get();
  future3.get();
  DbMetrics dbMetrics=transactor.getDbMetrics();
  double openedConnectionsNumber=dbMetrics.getOpenedConnectionsNumber();
  transactor.close();
  assertTrue(openedConnectionsNumber == 2);
}",0.9649002064693736
38666,"@Test public void testMaxConnectionWaitingTime() throws Exception {
  TransactorImpl<IDatabase1> transactor=transactorBuilder.setMaxTotalConnections(1).get();
  executorService=Executors.newFixedThreadPool(2);
  Future<Long> future1=executorService.submit(() -> transactor.query(a -> {
    sleepMillis(100);
    return stopwatch.elapsedMillis();
  }
));
  final Long[] startingTime2=new Long[1];
  Future future2=executorService.submit(() -> {
    startingTime2[0]=stopwatch.elapsedMillis();
    transactor.execute(a -> {
      sleepMillis(100);
    }
);
  }
);
  long finishingTime1=future1.get();
  future2.get();
  DbMetrics dbMetrics=transactor.getDbMetrics();
  double maxConnectionsWaitingTime=dbMetrics.getMaxConnectionWaitingTime();
  transactor.close();
  double expectedMaxConnectionsWaitingTime=finishingTime1 - startingTime2[0];
  expectedMaxConnectionsWaitingTime=(expectedMaxConnectionsWaitingTime > 0) ? expectedMaxConnectionsWaitingTime : 0;
  assertRoughEqual(maxConnectionsWaitingTime,expectedMaxConnectionsWaitingTime,20);
}","@Test public void testMaxConnectionWaitingTime() throws Exception {
  TransactorImpl<IDatabase1> transactor=transactorBuilder.setMaxTotalConnections(1).get();
  Future<Long> future1=executorService.submit(() -> transactor.query(a -> {
    sleepMillis(100);
    return stopwatch.elapsedMillis();
  }
));
  final Long[] startingTime2=new Long[1];
  Future future2=executorService.submit(() -> {
    startingTime2[0]=stopwatch.elapsedMillis();
    transactor.execute(a -> {
      sleepMillis(100);
    }
);
  }
);
  long finishingTime1=future1.get();
  future2.get();
  DbMetrics dbMetrics=transactor.getDbMetrics();
  double maxConnectionsWaitingTime=dbMetrics.getMaxConnectionWaitingTime();
  transactor.close();
  double expectedMaxConnectionsWaitingTime=finishingTime1 - startingTime2[0];
  expectedMaxConnectionsWaitingTime=(expectedMaxConnectionsWaitingTime > 0) ? expectedMaxConnectionsWaitingTime : 0;
  assertRoughEqual(maxConnectionsWaitingTime,expectedMaxConnectionsWaitingTime,20);
}",0.9749385749385748
38667,"@After public void cleanup() throws Exception {
  executorService.shutdown();
  stopwatch.reset();
}","@After public void cleanup() throws Exception {
  stopwatch.reset();
}",0.8235294117647058
38668,"@Override public String getSummary(){
  String summary=""String_Node_Str"";
  summary+=(""String_Node_Str"");
  summary+=String.format(""String_Node_Str"",getAverageIdleConnectionsMinValue(),getAverageIdleConnectionsMaxValue());
  summary+=String.format(""String_Node_Str"",getAverageActiveConnections());
  summary+=(""String_Node_Str"" + getTotalQueries());
  summary+=(""String_Node_Str"" + getOpenedConnectionsNumber());
  summary+=String.format(""String_Node_Str"" + ""String_Node_Str"",getMaxConnectionsProportion());
  summary+=String.format(""String_Node_Str"",getAverageConnectionExecutionTime());
  summary+=String.format(""String_Node_Str"",getAverageConnectionWaitingTime());
  summary+=String.format(""String_Node_Str"",getMaxConnectionWaitingTime());
  summary+=(""String_Node_Str"" + lifeTimeStopwatch.elapsedMillis() + ""String_Node_Str"");
  summary+=(""String_Node_Str"");
  summary+=(""String_Node_Str"" + minIdleConnections);
  summary+=(""String_Node_Str"" + maxTotalConnections);
  summary+=(""String_Node_Str"" + keepAliveMillis + ""String_Node_Str"");
  summary+=(""String_Node_Str"" + maxWaitMillis + ""String_Node_Str"");
  return summary;
}","@Override public String getSummary(){
  String summary=""String_Node_Str"";
  summary+=(""String_Node_Str"");
  summary+=String.format(""String_Node_Str"",getAverageIdleConnectionsMinValue(),getAverageIdleConnectionsMaxValue());
  summary+=String.format(""String_Node_Str"",getAverageActiveConnections());
  summary+=(""String_Node_Str"" + getTotalQueries());
  summary+=(""String_Node_Str"" + getOpenedConnectionsNumber());
  summary+=String.format(""String_Node_Str"",100 * getMaxConnectionsProportion());
  summary+=String.format(""String_Node_Str"",getAverageConnectionExecutionTime());
  summary+=String.format(""String_Node_Str"",getAverageConnectionWaitingTime());
  summary+=String.format(""String_Node_Str"",getMaxConnectionWaitingTime());
  summary+=(""String_Node_Str"" + lifeTimeStopwatch.elapsedMillis() + ""String_Node_Str"");
  summary+=(""String_Node_Str"");
  summary+=(""String_Node_Str"" + minIdleConnections);
  summary+=(""String_Node_Str"" + maxTotalConnections);
  summary+=(""String_Node_Str"" + keepAliveMillis + ""String_Node_Str"");
  summary+=(""String_Node_Str"" + maxWaitMillis + ""String_Node_Str"");
  return summary;
}",0.9883928571428572
38669,"private <T>T query(IQuery<DB,T> query,boolean asTransaction){
  DB connection=dbManager.getConnection();
  connection.setAutoCommit(!asTransaction);
  try {
    long startTime=System.currentTimeMillis();
    T value=query.query(connection);
    if (asTransaction) {
      connection.commit();
    }
    long executionTime=System.currentTimeMillis() - startTime;
    queryMetrics.update(executionTime,Thread.currentThread().getStackTrace()[3]);
    return value;
  }
 catch (  Exception e) {
    LOG.error(""String_Node_Str"",e);
    if (asTransaction) {
      connection.rollback();
    }
    throw new SqlExecutionFailureException(e);
  }
 finally {
    dbManager.returnConnection(connection);
  }
}","private <T>T query(IQuery<DB,T> query,boolean asTransaction){
  DB connection=dbManager.getConnection();
  connection.setAutoCommit(!asTransaction);
  try {
    long startTime=System.currentTimeMillis();
    T value=query.query(connection);
    if (asTransaction) {
      connection.commit();
    }
    long executionTime=System.currentTimeMillis() - startTime;
    if (metricsTrackingEnabled) {
      queryMetrics.update(executionTime,Thread.currentThread().getStackTrace()[3]);
    }
    return value;
  }
 catch (  Exception e) {
    LOG.error(""String_Node_Str"",e);
    if (asTransaction) {
      connection.rollback();
    }
    throw new SqlExecutionFailureException(e);
  }
 finally {
    dbManager.returnConnection(connection);
  }
}",0.9707927677329624
38670,"private void execute(IExecution<DB> execution,boolean asTransaction){
  DB connection=dbManager.getConnection();
  connection.setAutoCommit(!asTransaction);
  try {
    long startTime=System.currentTimeMillis();
    execution.execute(connection);
    if (asTransaction) {
      connection.commit();
    }
    long executionTime=System.currentTimeMillis() - startTime;
    queryMetrics.update(executionTime,Thread.currentThread().getStackTrace()[3]);
  }
 catch (  Exception e) {
    LOG.error(""String_Node_Str"",e);
    if (asTransaction) {
      connection.rollback();
    }
    throw new SqlExecutionFailureException(e);
  }
 finally {
    dbManager.returnConnection(connection);
  }
}","private void execute(IExecution<DB> execution,boolean asTransaction){
  DB connection=dbManager.getConnection();
  connection.setAutoCommit(!asTransaction);
  try {
    long startTime=System.currentTimeMillis();
    execution.execute(connection);
    if (asTransaction) {
      connection.commit();
    }
    long executionTime=System.currentTimeMillis() - startTime;
    if (metricsTrackingEnabled) {
      queryMetrics.update(executionTime,Thread.currentThread().getStackTrace()[3]);
    }
  }
 catch (  Exception e) {
    LOG.error(""String_Node_Str"",e);
    if (asTransaction) {
      connection.rollback();
    }
    throw new SqlExecutionFailureException(e);
  }
 finally {
    dbManager.returnConnection(connection);
  }
}",0.9702970297029704
38671,"@Override public void close(){
  if (metricsTrackingEnabled) {
    LOG.info(dbManager.getMetrics().getSummary());
    LOG.info(""String_Node_Str"" + ""String_Node_Str"" + (queryMetrics.getSummary()));
  }
  dbManager.close();
}","@Override public void close(){
  if (metricsTrackingEnabled) {
    LOG.info(dbManager.getMetrics().getSummary());
    LOG.info(""String_Node_Str"",queryMetrics.getSummary());
  }
  dbManager.close();
}",0.9383886255924172
38672,"@Override public int compare(TransactorMetricElement a,TransactorMetricElement b){
  if (a.getAverageExecutionTime() >= b.getAverageExecutionTime()) {
    return 1;
  }
 else {
    return -1;
  }
}","@Override public int compare(TransactorMetricElement a,TransactorMetricElement b){
  if (a.getAverageExecutionTime() >= b.getAverageExecutionTime()) {
    return -1;
  }
 else {
    return 1;
  }
}",0.9949238578680204
38673,"public synchronized void addExecution(long executionTime){
  count+=1;
  totalExecutionTime+=executionTime;
}","public void addExecution(long executionTime){
  count+=1;
  totalExecutionTime+=executionTime;
}",0.9365853658536586
38674,"synchronized void update(long executionTime,StackTraceElement queryStackTrace){
  if (longestQueriesMap.containsKey(queryStackTrace)) {
    TransactorMetricElement query=longestQueriesMap.get(queryStackTrace);
    longestQueries.remove(query);
    query.addExecution(executionTime);
    longestQueries.add(query);
  }
 else {
    TransactorMetricElement newQuery=new TransactorMetricElement(queryStackTrace,executionTime);
    if (longestQueriesMap.size() < longestQueriesSize) {
      longestQueriesMap.put(queryStackTrace,newQuery);
      longestQueries.add(newQuery);
    }
 else     if (queryComparator.compare(newQuery,longestQueries.peek()) > 0) {
      TransactorMetricElement removedQuery=longestQueries.poll();
      longestQueriesMap.remove(removedQuery.getQueryTrace());
      longestQueriesMap.put(newQuery.getQueryTrace(),newQuery);
      longestQueries.add(newQuery);
    }
  }
}","void update(long executionTime,StackTraceElement queryStackTrace){
  if (longestQueriesMap.containsKey(queryStackTrace)) {
    TransactorMetricElement query=longestQueriesMap.get(queryStackTrace);
    longestQueries.remove(query);
    query.addExecution(executionTime);
    longestQueries.add(query);
  }
 else {
    TransactorMetricElement newQuery=new TransactorMetricElement(queryStackTrace,executionTime);
    if (longestQueriesMap.size() < longestQueriesSize) {
      longestQueriesMap.put(queryStackTrace,newQuery);
      longestQueries.add(newQuery);
    }
 else     if (queryComparator.compare(newQuery,longestQueries.peek()) > 0) {
      TransactorMetricElement removedQuery=longestQueries.poll();
      longestQueriesMap.remove(removedQuery.getQueryTrace());
      longestQueriesMap.put(newQuery.getQueryTrace(),newQuery);
      longestQueries.add(newQuery);
    }
  }
}",0.9926677946982516
38675,"TransactorMetricsImpl(int longestQueriesSize){
  this.longestQueriesSize=longestQueriesSize;
  this.longestQueriesMap=new HashMap<>();
  this.queryComparator=new TransactorMetricElementsComparator().reversed();
  this.longestQueries=new PriorityQueue<>(longestQueriesSize,queryComparator);
}","TransactorMetricsImpl(int longestQueriesSize){
  this.longestQueriesSize=longestQueriesSize;
  this.longestQueriesMap=new HashMap<>();
  this.longestQueries=new PriorityQueue<>(longestQueriesSize,queryComparator);
}",0.849802371541502
38676,"@Test public void testTotalQueries() throws Exception {
  TransactorImpl<IDatabase1> transactor=transactorBuilder.get();
  transactor.execute(db -> {
  }
);
  DbMetrics dbMetrics=transactor.getDbMetrics();
  assert(dbMetrics.getTotalQueries() == 1);
}","@Test public void testTotalQueries() throws Exception {
  TransactorImpl<IDatabase1> transactor=transactorBuilder.get();
  transactor.execute(db -> {
  }
);
  DbMetrics dbMetrics=transactor.getDbMetrics();
  assertTrue(dbMetrics.getTotalQueries() == 1);
}",0.9920948616600792
38677,"@Test public void testAverageIdleConnections() throws Exception {
  TransactorImpl<IDatabase1> transactor=transactorBuilder.setMaxTotalConnections(2).setMinIdleConnections(1).setKeepAliveTime(Duration.millis(50)).get();
  transactor.execute(a -> {
    sleepMillis(100);
  }
);
  long startIdleTime=stopwatch.elapsedMillis();
  sleepMillis(100);
  long idleTime=stopwatch.elapsedMillis() - startIdleTime;
  DbMetrics dbMetrics=transactor.getDbMetrics();
  long lifeTime=dbMetrics.getLifeTime();
  double expectedAverageIdleConnections=(double)idleTime / (double)lifeTime;
  double averageIdleConnectionsMaxValue=dbMetrics.getAverageIdleConnectionsMaxValue();
  double averageIdleConnectionsMinValue=dbMetrics.getAverageIdleConnectionsMinValue();
  transactor.close();
  assert((expectedAverageIdleConnections - .1 <= averageIdleConnectionsMaxValue) && (expectedAverageIdleConnections + .1 >= averageIdleConnectionsMinValue));
}","@Test public void testAverageIdleConnections() throws Exception {
  TransactorImpl<IDatabase1> transactor=transactorBuilder.setMaxTotalConnections(2).setMinIdleConnections(1).setKeepAliveTime(Duration.millis(50)).get();
  transactor.execute(a -> {
    sleepMillis(100);
  }
);
  long startIdleTime=stopwatch.elapsedMillis();
  sleepMillis(100);
  long idleTime=stopwatch.elapsedMillis() - startIdleTime;
  DbMetrics dbMetrics=transactor.getDbMetrics();
  long lifeTime=dbMetrics.getLifeTime();
  double expectedAverageIdleConnections=(double)idleTime / (double)lifeTime;
  double averageIdleConnectionsMaxValue=dbMetrics.getAverageIdleConnectionsMaxValue();
  double averageIdleConnectionsMinValue=dbMetrics.getAverageIdleConnectionsMinValue();
  transactor.close();
  assertTrue((expectedAverageIdleConnections - .1 <= averageIdleConnectionsMaxValue) && (expectedAverageIdleConnections + .1 >= averageIdleConnectionsMinValue));
}",0.9978448275862069
38678,"@After public void cleanup() throws Exception {
  executorService=null;
  stopwatch.reset();
}","@After public void cleanup() throws Exception {
  executorService.shutdown();
  stopwatch.reset();
}",0.9278350515463918
38679,"@Test public void testOpenedConnectionsNumber() throws Exception {
  executorService=Executors.newFixedThreadPool(5);
  TransactorImpl<IDatabase1> transactor=transactorBuilder.setMaxTotalConnections(2).get();
  Future future1=executorService.submit(() -> transactor.execute(a -> {
    sleepMillis(50);
  }
));
  Future future2=executorService.submit(() -> transactor.execute(a -> {
    sleepMillis(50);
  }
));
  Future future3=executorService.submit(() -> transactor.execute(a -> {
    sleepMillis(50);
  }
));
  future1.get();
  future2.get();
  future3.get();
  DbMetrics dbMetrics=transactor.getDbMetrics();
  double openedConnectionsNumber=dbMetrics.getOpenedConnectionsNumber();
  transactor.close();
  assert(openedConnectionsNumber == 2);
}","@Test public void testOpenedConnectionsNumber() throws Exception {
  executorService=Executors.newFixedThreadPool(5);
  TransactorImpl<IDatabase1> transactor=transactorBuilder.setMaxTotalConnections(2).get();
  Future future1=executorService.submit(() -> transactor.execute(a -> {
    sleepMillis(50);
  }
));
  Future future2=executorService.submit(() -> transactor.execute(a -> {
    sleepMillis(50);
  }
));
  Future future3=executorService.submit(() -> transactor.execute(a -> {
    sleepMillis(50);
  }
));
  future1.get();
  future2.get();
  future3.get();
  DbMetrics dbMetrics=transactor.getDbMetrics();
  double openedConnectionsNumber=dbMetrics.getOpenedConnectionsNumber();
  transactor.close();
  assertTrue(openedConnectionsNumber == 2);
}",0.9973333333333332
38680,"@Test public void testMaxConnectionWaitingTime() throws Exception {
  TransactorImpl<IDatabase1> transactor=transactorBuilder.setMaxTotalConnections(1).get();
  executorService=Executors.newFixedThreadPool(2);
  Future<Long> future1=executorService.submit(() -> transactor.query(a -> {
    sleepMillis(100);
    return stopwatch.elapsedMillis();
  }
));
  final Long[] startingTime2=new Long[1];
  Future future2=executorService.submit(() -> {
    startingTime2[0]=stopwatch.elapsedMillis();
    transactor.execute(a -> {
      sleepMillis(100);
    }
);
  }
);
  long finishingTime1=future1.get();
  future2.get();
  DbMetrics dbMetrics=transactor.getDbMetrics();
  double maxConnectionsWaitingTime=dbMetrics.getMaxConnectionWaitingTime();
  transactor.close();
  double expectedMaxConnectionsWaitingTime=(finishingTime1 - startingTime2[0]);
  expectedMaxConnectionsWaitingTime=(expectedMaxConnectionsWaitingTime > 0) ? expectedMaxConnectionsWaitingTime : 0;
  assertRoughEqual(maxConnectionsWaitingTime,expectedMaxConnectionsWaitingTime,20);
}","@Test public void testMaxConnectionWaitingTime() throws Exception {
  TransactorImpl<IDatabase1> transactor=transactorBuilder.setMaxTotalConnections(1).get();
  executorService=Executors.newFixedThreadPool(2);
  Future<Long> future1=executorService.submit(() -> transactor.query(a -> {
    sleepMillis(100);
    return stopwatch.elapsedMillis();
  }
));
  final Long[] startingTime2=new Long[1];
  Future future2=executorService.submit(() -> {
    startingTime2[0]=stopwatch.elapsedMillis();
    transactor.execute(a -> {
      sleepMillis(100);
    }
);
  }
);
  long finishingTime1=future1.get();
  future2.get();
  DbMetrics dbMetrics=transactor.getDbMetrics();
  double maxConnectionsWaitingTime=dbMetrics.getMaxConnectionWaitingTime();
  transactor.close();
  double expectedMaxConnectionsWaitingTime=finishingTime1 - startingTime2[0];
  expectedMaxConnectionsWaitingTime=(expectedMaxConnectionsWaitingTime > 0) ? expectedMaxConnectionsWaitingTime : 0;
  assertRoughEqual(maxConnectionsWaitingTime,expectedMaxConnectionsWaitingTime,20);
}",0.9990421455938696
38681,"@Test public void testQueryOrder() throws Exception {
  TransactorImpl<IDatabase1> transactor=transactorBuilder.get();
  transactor.execute(db -> {
    sleepMillis(200);
  }
);
  transactor.execute(db -> {
    sleepMillis(100);
  }
);
  transactor.execute(db -> {
  }
);
  TransactorMetrics queryMetrics=transactor.getQueryMetrics();
  int lastLine=0;
  transactor.close();
  for (  TransactorMetricElement query : queryMetrics.getLongestQueries()) {
    assert(query.getQueryTrace().getLineNumber() > lastLine);
    lastLine=query.getQueryTrace().getLineNumber();
  }
  transactor.close();
}","@Test public void testQueryOrder() throws Exception {
  TransactorImpl<IDatabase1> transactor=transactorBuilder.get();
  transactor.execute(db -> {
    sleepMillis(200);
  }
);
  transactor.execute(db -> {
    sleepMillis(100);
  }
);
  transactor.execute(db -> {
  }
);
  TransactorMetrics queryMetrics=transactor.getQueryMetrics();
  int lastLine=0;
  transactor.close();
  for (  TransactorMetricElement query : queryMetrics.getLongestQueries()) {
    assertTrue(query.getQueryTrace().getLineNumber() > lastLine);
    lastLine=query.getQueryTrace().getLineNumber();
  }
  transactor.close();
}",0.9966329966329966
38682,"@After public void cleanup() throws Exception {
  executorService=null;
  stopwatch.reset();
}","@After public void cleanup() throws Exception {
  executorService.shutdown();
  stopwatch.reset();
}",0.9278350515463918
38683,"public static String envVar(String property){
  return envVar(property,""String_Node_Str"");
}","public static String envVar(String property){
  return property.replace('.','_').toUpperCase();
}",0.7513227513227513
38684,"public T get(){
  if (persistence == null) {
synchronized (this) {
      this.persistence=build(conn,databases);
    }
  }
  if (disableCaching) {
    persistence.disableCaching();
  }
  return persistence;
}","public T get(){
  if (persistence == null) {
synchronized (this) {
      if (persistence == null) {
        this.persistence=build(conn,databases);
      }
    }
  }
  if (disableCaching) {
    persistence.disableCaching();
  }
  return persistence;
}",0.906318082788671
38685,"public Between(V value1,V value2){
  super(""String_Node_Str"");
  if (!(value1 instanceof Column)) {
    this.parameters.add(value1);
  }
 else {
    this.sqlStatement=StringUtils.replaceOnce(this.sqlStatement,""String_Node_Str"",((Column)value2).getSqlKeyword());
  }
  if (!(value2 instanceof Column)) {
    this.parameters.add(value2);
  }
 else {
    this.sqlStatement=StringUtils.replaceOnce(this.sqlStatement,""String_Node_Str"",""String_Node_Str"" + ((Column)value2).getSqlKeyword());
  }
  ensureNoNullParameter();
}","public Between(V value1,V value2){
  super(""String_Node_Str"");
  if (!(value1 instanceof Column)) {
    this.parameters.add(value1);
  }
 else {
    this.sqlStatement=StringUtils.replaceOnce(this.sqlStatement,""String_Node_Str"",((Column)value1).getSqlKeyword());
  }
  if (!(value2 instanceof Column)) {
    this.parameters.add(value2);
  }
 else {
    this.sqlStatement=StringUtils.replaceOnce(this.sqlStatement,""String_Node_Str"",""String_Node_Str"" + ((Column)value2).getSqlKeyword());
  }
  ensureNoNullParameter();
}",0.9980657640232108
38686,"protected AbstractTable(String table,String alias){
  Preconditions.checkArgument(Strings.isNullOrEmpty(table),""String_Node_Str"");
  Preconditions.checkArgument(Strings.isNullOrEmpty(alias),""String_Node_Str"");
  this.table=table;
  this.alias=alias;
  this.allColumns=Sets.newHashSet();
}","protected AbstractTable(String table,String alias){
  Preconditions.checkArgument(!Strings.isNullOrEmpty(table),""String_Node_Str"");
  Preconditions.checkArgument(!Strings.isNullOrEmpty(alias),""String_Node_Str"");
  this.table=table;
  this.alias=alias;
  this.allColumns=Sets.newHashSet();
}",0.9965397923875432
38687,"public String getSqlKeyword(){
  String fieldKeyword=field != null ? field.toString() : DEFAULT_ID_FIELD;
  if (model != null) {
    return Utility.getTableNameFromModel(model) + ""String_Node_Str"" + fieldKeyword;
  }
 else {
    return fieldKeyword;
  }
}","public String getSqlKeyword(){
  String fieldKeyword=field != null ? field.toString() : DEFAULT_ID_FIELD;
  if (model != null) {
    return Utility.getTableName(model) + ""String_Node_Str"" + fieldKeyword;
  }
 else {
    return fieldKeyword;
  }
}",0.9780439121756488
38688,"private String getSelectClause(){
  StringBuilder clause=new StringBuilder(""String_Node_Str"");
  if (selectedIModelFields.isEmpty()) {
    clause.append(""String_Node_Str"");
  }
 else {
    Iterator<ModelField> it=selectedIModelFields.iterator();
    while (it.hasNext()) {
      clause.append(it.next().getSqlKeyword());
      if (it.hasNext()) {
        clause.append(""String_Node_Str"");
      }
    }
  }
  String tableName=Utility.getTableNameFromModel(mainModel);
  return clause.append(""String_Node_Str"").append(tableName).append(""String_Node_Str"").toString();
}","private String getSelectClause(){
  StringBuilder clause=new StringBuilder(""String_Node_Str"");
  if (selectedIModelFields.isEmpty()) {
    clause.append(""String_Node_Str"");
  }
 else {
    Iterator<ModelField> it=selectedIModelFields.iterator();
    while (it.hasNext()) {
      clause.append(it.next().getSqlKeyword());
      if (it.hasNext()) {
        clause.append(""String_Node_Str"");
      }
    }
  }
  String tableName=Utility.getTableName(mainModel);
  return clause.append(""String_Node_Str"").append(tableName).append(""String_Node_Str"").toString();
}",0.88
38689,"@Override public String getSqlStatement(){
  String tableName=Utility.getTableNameFromModel(model);
  return joinType.getSqlKeyword() + ""String_Node_Str"" + tableName+ ""String_Node_Str""+ modelField1.getSqlKeyword()+ ""String_Node_Str""+ modelField2.getSqlKeyword();
}","@Override public String getSqlStatement(){
  String tableName=Utility.getTableName(model);
  return joinType.getSqlKeyword() + ""String_Node_Str"" + tableName+ ""String_Node_Str""+ modelField1.getSqlKeyword()+ ""String_Node_Str""+ modelField2.getSqlKeyword();
}",0.9826589595375722
38690,"private GenericQuery(BaseDatabaseConnection dbConnection){
  this.dbConnection=dbConnection;
  this.mainModel=null;
  this.joinConditions=Lists.newArrayList();
  this.whereConstraints=Lists.newArrayList();
  this.orderCriteria=Sets.newHashSet();
  this.selectedIModelFields=Sets.newHashSet();
  this.limitCondition=Optional.absent();
}","private GenericQuery(BaseDatabaseConnection dbConnection){
  this.dbConnection=dbConnection;
  this.mainModel=null;
  this.joinConditions=Lists.newArrayList();
  this.whereConstraints=Lists.newArrayList();
  this.orderCriteria=Lists.newArrayList();
  this.selectedIModelFields=Sets.newHashSet();
  this.limitCondition=Optional.absent();
}",0.9539375928677564
38691,"public GenericQueryBuilder or(Column column,IWhereOperator<Object> operator){
  genericQuery.addWhereCondition(new WhereConstraint<Object>(column,operator,WhereConstraint.Logic.OR));
  return this;
}","public GenericQueryBuilder or(Column column,IWhereOperator operator){
  genericQuery.addWhereCondition(new WhereConstraint(column,operator,WhereConstraint.Logic.OR));
  return this;
}",0.9581151832460733
38692,"public GenericQueryBuilder and(Column column,IWhereOperator<Object> operator){
  genericQuery.addWhereCondition(new WhereConstraint<Object>(column,operator,WhereConstraint.Logic.AND));
  return this;
}","public GenericQueryBuilder and(Column column,IWhereOperator operator){
  genericQuery.addWhereCondition(new WhereConstraint(column,operator,WhereConstraint.Logic.AND));
  return this;
}",0.9585492227979274
38693,"public GenericQueryBuilder where(Column column,IWhereOperator<Object> operator){
  genericQuery.addWhereCondition(new WhereConstraint<Object>(column,operator,null));
  return this;
}","public GenericQueryBuilder where(Column column,IWhereOperator operator){
  genericQuery.addWhereCondition(new WhereConstraint(column,operator,null));
  return this;
}",0.9540229885057472
38694,"@Override public String getSqlStatement(){
  return (logic.isPresent() ? logic.toString() + ""String_Node_Str"" : ""String_Node_Str"") + column.getSqlKeyword() + ""String_Node_Str""+ operator.getSqlStatement();
}","@Override public String getSqlStatement(){
  return (logic.isPresent() ? logic.get().toString() + ""String_Node_Str"" : ""String_Node_Str"") + column.getSqlKeyword() + ""String_Node_Str""+ operator.getSqlStatement();
}",0.985645933014354
38695,"public boolean isOnlyIdQuery(){
  return whereConstraints.isEmpty() && selectedFields.isEmpty() && orderCriteria.isEmpty()&& limitCriterion == null;
}","public boolean isOnlyIdQuery(){
  return whereConstraints.isEmpty() && selectedFields.isEmpty() && orderCriteria.isEmpty()&& !limitCriterion.isPresent();
}",0.9377049180327868
38696,"@Override public String getSqlStatement(){
  return ""String_Node_Str"" + Utility.getTableName(model) + ""String_Node_Str""+ modelField1.getSqlKeyword()+ ""String_Node_Str""+ modelField2.getSqlKeyword();
}","@Override public String getSqlStatement(){
  return joinType.getSqlKeyword() + ""String_Node_Str"" + Utility.getTableName(model)+ ""String_Node_Str""+ modelField1.getSqlKeyword()+ ""String_Node_Str""+ modelField2.getSqlKeyword();
}",0.9339622641509434
38697,"public JoinCondition(Class<? extends ModelWithId> model,ModelField modelField1,ModelField modelField2){
  this.model=model;
  this.modelField1=modelField1;
  this.modelField2=modelField2;
}","public JoinCondition(JoinType joinType,Class<? extends ModelWithId> model,ModelField modelField1,ModelField modelField2){
  this.joinType=joinType;
  this.model=model;
  this.modelField1=modelField1;
  this.modelField2=modelField2;
}",0.8957345971563981
38698,"public static String getTableName(Class<? extends ModelWithId> model){
  return model.getSimpleName().toLowerCase() + ""String_Node_Str"";
}","public static String getTableName(Class<? extends ModelWithId> model){
  return CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE,model.getSimpleName()) + ""String_Node_Str"";
}",0.7886435331230284
38699,"public void test() throws IOException, SQLException {
  IDatabases dbs=new DatabasesImpl(DATABASE_CONNECTION1);
  IUserPersistence users=dbs.getDatabase1().users();
  ICommentPersistence comments=dbs.getDatabase1().comments();
  users.deleteAll();
  comments.deleteAll();
  User userA=users.createDefaultInstance().setHandle(""String_Node_Str"").setBio(""String_Node_Str"").setNumPosts(10);
  User userB=users.createDefaultInstance().setHandle(""String_Node_Str"").setBio(""String_Node_Str"").setNumPosts(30);
  User userC=users.createDefaultInstance().setHandle(""String_Node_Str"").setBio(""String_Node_Str"").setNumPosts(20);
  User userD=users.createDefaultInstance().setHandle(""String_Node_Str"").setBio(""String_Node_Str"").setNumPosts(40);
  userA.save();
  userB.save();
  userC.save();
  userD.save();
  Comment commentA=comments.createDefaultInstance().setCommenterId(ModelWithId.safeLongToInt(userA.getId())).setContent(""String_Node_Str"");
  Comment commentB=comments.createDefaultInstance().setCommenterId(ModelWithId.safeLongToInt(userB.getId())).setContent(""String_Node_Str"");
  Comment commentC=comments.createDefaultInstance().setCommenterId(ModelWithId.safeLongToInt(userB.getId())).setContent(""String_Node_Str"");
  Comment commentD=comments.createDefaultInstance().setCommenterId(ModelWithId.safeLongToInt(userC.getId())).setContent(""String_Node_Str"");
  Comment commentE=comments.createDefaultInstance().setCommenterId(ModelWithId.safeLongToInt(userD.getId())).setContent(""String_Node_Str"");
  commentA.save();
  commentB.save();
  commentC.save();
  commentD.save();
  commentE.save();
  List<Map<ModelField,Object>> results=GenericQuery.create(DATABASE_CONNECTION1).from(User.class).join(Comment.class,User.id(),Comment.commenter_id()).where(User.bio(),in(Sets.newHashSet(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""))).where(Comment.content(),isNotNull()).orderBy(User.num_posts(),DESC).orderBy(Comment.id()).select(User.id(),User.bio(),User.handle(),User.num_posts(),Comment.id(),Comment.commenter_id(),Comment.content()).fetch();
  for (  Map<ModelField,Object> record : results) {
    System.out.println(record.toString());
  }
}","public void test() throws IOException, SQLException {
  IDatabases dbs=new DatabasesImpl(DATABASE_CONNECTION1);
  IUserPersistence users=dbs.getDatabase1().users();
  ICommentPersistence comments=dbs.getDatabase1().comments();
  users.deleteAll();
  comments.deleteAll();
  User userA=users.createDefaultInstance().setHandle(""String_Node_Str"").setBio(""String_Node_Str"").setNumPosts(10);
  User userB=users.createDefaultInstance().setHandle(""String_Node_Str"").setBio(""String_Node_Str"").setNumPosts(30);
  User userC=users.createDefaultInstance().setHandle(""String_Node_Str"").setBio(""String_Node_Str"").setNumPosts(20);
  User userD=users.createDefaultInstance().setHandle(""String_Node_Str"").setBio(""String_Node_Str"").setNumPosts(40);
  userA.save();
  userB.save();
  userC.save();
  userD.save();
  Comment commentA=comments.createDefaultInstance().setCommenterId(ModelWithId.safeLongToInt(userA.getId())).setContent(""String_Node_Str"");
  Comment commentB=comments.createDefaultInstance().setCommenterId(ModelWithId.safeLongToInt(userB.getId())).setContent(""String_Node_Str"");
  Comment commentC=comments.createDefaultInstance().setCommenterId(ModelWithId.safeLongToInt(userB.getId())).setContent(""String_Node_Str"");
  Comment commentD=comments.createDefaultInstance().setCommenterId(ModelWithId.safeLongToInt(userC.getId())).setContent(""String_Node_Str"");
  Comment commentE=comments.createDefaultInstance().setCommenterId(ModelWithId.safeLongToInt(userD.getId())).setContent(""String_Node_Str"");
  commentA.save();
  commentB.save();
  commentC.save();
  commentD.save();
  commentE.save();
  List<Map<ModelField,Object>> results=GenericQuery.create(DATABASE_CONNECTION1).from(User.class).leftJoin(Comment.class,User.id(),Comment.commenter_id()).where(User.bio(),in(Sets.newHashSet(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""))).where(Comment.content(),isNotNull()).orderBy(User.num_posts(),DESC).orderBy(Comment.id()).select(User.id(),User.bio(),User.handle(),User.num_posts(),Comment.id(),Comment.commenter_id(),Comment.content()).fetch();
  for (  Map<ModelField,Object> record : results) {
    System.out.println(record.toString());
  }
}",0.9986046511627908
38700,"public String getSelectClause(){
  StringBuilder sqlClause=new StringBuilder(""String_Node_Str"");
  if (selectCriteria.isEmpty()) {
    sqlClause.append(""String_Node_Str"");
    return sqlClause.toString();
  }
  Iterator<SelectCriterion> it=selectCriteria.iterator();
  while (it.hasNext()) {
    sqlClause.append(it.next());
    if (it.hasNext()) {
      sqlClause.append(""String_Node_Str"");
    }
  }
  return sqlClause.toString();
}","public String getSelectClause(){
  StringBuilder sqlClause=new StringBuilder(""String_Node_Str"");
  if (selectCriteria.isEmpty()) {
    sqlClause.append(""String_Node_Str"");
    return sqlClause.toString();
  }
  Iterator<SelectCriterion> it=selectCriteria.iterator();
  while (it.hasNext()) {
    SelectCriterion selectCriterion=it.next();
    sqlClause.append(selectCriterion.getSqlClause());
    if (it.hasNext()) {
      sqlClause.append(""String_Node_Str"");
    }
  }
  return sqlClause.toString();
}",0.8910256410256411
38701,"protected Set<T> realFind(ModelQuery query) throws IOException {
  Set<T> foundSet=new HashSet<T>();
  List<WhereConstraint> constraints=query.getConstraints();
  Set<Long> ids=query.getIdSet();
  if (constraints == null || constraints.isEmpty()) {
    if (ids != null && !ids.isEmpty()) {
      return find(ids);
    }
    return foundSet;
  }
  for (  T record : records.values()) {
    boolean allMatch=true;
    for (    WhereConstraint constraint : constraints) {
      Enum field=constraint.getField();
      IQueryOperator operator=constraint.getOperator();
      allMatch=allMatch && operator.apply(record.getField(field.name()));
    }
    if (ids != null && !ids.isEmpty() && !ids.contains(record.getId())) {
      allMatch=false;
    }
    if (allMatch) {
      if (!query.getSelectCriteria().isEmpty()) {
        for (        Enum field : record.getFieldSet()) {
          if (!query.getSelectCriteria().contains(new SelectCriterion(field))) {
            record.setField(field.name(),null);
          }
        }
      }
      foundSet.add(record);
    }
  }
  return foundSet;
}","protected Set<T> realFind(ModelQuery query) throws IOException {
  Set<T> foundSet=new HashSet<T>();
  List<WhereConstraint> constraints=query.getConstraints();
  Set<Long> ids=query.getIdSet();
  if (constraints == null || constraints.isEmpty()) {
    if (ids != null && !ids.isEmpty()) {
      return find(ids);
    }
    return foundSet;
  }
  for (  T record : records.values()) {
    boolean allMatch=true;
    for (    WhereConstraint constraint : constraints) {
      Enum field=constraint.getField();
      IQueryOperator operator=constraint.getOperator();
      allMatch=allMatch && operator.apply(record.getField(field.name()));
    }
    if (ids != null && !ids.isEmpty() && !ids.contains(record.getId())) {
      allMatch=false;
    }
    if (allMatch) {
      if (!query.getSelectCriteria().isEmpty()) {
        for (        Enum field : record.getFieldSet()) {
          if (!query.getSelectCriteria().contains(new SelectCriterion(field))) {
            if (!isPrimitiveOrWrapped(record.getField(field.name()).getClass())) {
              record.setField(field.name(),null);
            }
          }
        }
      }
      foundSet.add(record);
    }
  }
  return foundSet;
}",0.911957950065703
38702,"protected Set<T> realFind(Set<Long> ids,List<QueryConstraint> constraints) throws IOException {
  Set<T> foundSet=new HashSet<T>();
  if (constraints == null || constraints.isEmpty()) {
    if (ids != null && !ids.isEmpty()) {
      return find(ids);
    }
    return foundSet;
  }
  for (  T record : records.values()) {
    boolean allMatch=true;
    for (    QueryConstraint constraint : constraints) {
      Enum field=constraint.getField();
      IQueryOperator operator=constraint.getOperator();
      allMatch=allMatch && operator.apply(record.getField(field.name()));
    }
    if (ids != null && !ids.isEmpty() && !ids.contains(record.getId())) {
      allMatch=false;
    }
    if (allMatch) {
      foundSet.add(record);
    }
  }
  return foundSet;
}","protected Set<T> realFind(ModelQuery query) throws IOException {
  Set<T> foundSet=new HashSet<T>();
  List<QueryConstraint> constraints=query.getConstraints();
  Set<Long> ids=query.getIdSet();
  if (constraints == null || constraints.isEmpty()) {
    if (ids != null && !ids.isEmpty()) {
      return find(ids);
    }
    return foundSet;
  }
  for (  T record : records.values()) {
    boolean allMatch=true;
    for (    QueryConstraint constraint : constraints) {
      Enum field=constraint.getField();
      IQueryOperator operator=constraint.getOperator();
      allMatch=allMatch && operator.apply(record.getField(field.name()));
    }
    if (ids != null && !ids.isEmpty() && !ids.contains(record.getId())) {
      allMatch=false;
    }
    if (allMatch) {
      foundSet.add(record);
    }
  }
  return foundSet;
}",0.9073724007561436
38703,"public Set<Comment> find(Set<Long> ids,List<QueryConstraint> constraints) throws IOException {
  Set<Comment> foundSet=new HashSet<Comment>();
  if (constraints == null || constraints.isEmpty()) {
    if (ids != null && !ids.isEmpty()) {
      return find(ids);
    }
    return foundSet;
  }
  StringBuilder statementString=new StringBuilder();
  statementString.append(""String_Node_Str"");
  Iterator<QueryConstraint> iter=constraints.iterator();
  while (iter.hasNext()) {
    QueryConstraint constraint=iter.next();
    Enum field=constraint.getField();
    IQueryOperator operator=constraint.getOperator();
    statementString.append(field).append(operator.getSqlStatement());
    if (iter.hasNext()) {
      statementString.append(""String_Node_Str"");
    }
  }
  if (ids != null && !ids.isEmpty())   statementString.append(""String_Node_Str"" + getIdSetCondition(ids));
  statementString.append(""String_Node_Str"");
  PreparedStatement preparedStatement=getPreparedStatement(statementString.toString());
  int index=0;
  for (  QueryConstraint constraint : constraints) {
    Comment._Fields field=(Comment._Fields)constraint.getField();
    for (    Object parameter : constraint.getParameters()) {
      if (parameter == null) {
        continue;
      }
      try {
switch (field) {
case content:
          preparedStatement.setString(++index,(String)parameter);
        break;
case commenter_id:
      preparedStatement.setInt(++index,(Integer)parameter);
    break;
case commented_on_id:
  preparedStatement.setLong(++index,(Long)parameter);
break;
case created_at:
preparedStatement.setTimestamp(++index,new Timestamp((Long)parameter));
break;
}
}
 catch (SQLException e) {
throw new IOException(e);
}
}
}
executeQuery(foundSet,preparedStatement);
return foundSet;
}","public Set<Comment> find(ModelQuery query) throws IOException {
  Set<Comment> foundSet=new HashSet<Comment>();
  if (query.getConstraints() == null || query.getConstraints().isEmpty()) {
    Set<Long> ids=query.getIdSet();
    if (ids != null && !ids.isEmpty()) {
      return find(ids);
    }
    return foundSet;
  }
  StringBuilder statementString=new StringBuilder();
  statementString.append(""String_Node_Str"");
  statementString.append(query.getSqlStatement());
  statementString.append(""String_Node_Str"");
  PreparedStatement preparedStatement=getPreparedStatement(statementString.toString());
  int index=0;
  for (  QueryConstraint constraint : query.getConstraints()) {
    Comment._Fields field=(Comment._Fields)constraint.getField();
    for (    Object parameter : constraint.getParameters()) {
      if (parameter == null) {
        continue;
      }
      try {
switch (field) {
case content:
          preparedStatement.setString(++index,(String)parameter);
        break;
case commenter_id:
      preparedStatement.setInt(++index,(Integer)parameter);
    break;
case commented_on_id:
  preparedStatement.setLong(++index,(Long)parameter);
break;
case created_at:
preparedStatement.setTimestamp(++index,new Timestamp((Long)parameter));
break;
}
}
 catch (SQLException e) {
throw new IOException(e);
}
}
}
executeQuery(foundSet,preparedStatement);
return foundSet;
}",0.7885895404120443
38704,"public Set<Image> find(Set<Long> ids,List<QueryConstraint> constraints) throws IOException {
  Set<Image> foundSet=new HashSet<Image>();
  if (constraints == null || constraints.isEmpty()) {
    if (ids != null && !ids.isEmpty()) {
      return find(ids);
    }
    return foundSet;
  }
  StringBuilder statementString=new StringBuilder();
  statementString.append(""String_Node_Str"");
  Iterator<QueryConstraint> iter=constraints.iterator();
  while (iter.hasNext()) {
    QueryConstraint constraint=iter.next();
    Enum field=constraint.getField();
    IQueryOperator operator=constraint.getOperator();
    statementString.append(field).append(operator.getSqlStatement());
    if (iter.hasNext()) {
      statementString.append(""String_Node_Str"");
    }
  }
  if (ids != null && !ids.isEmpty())   statementString.append(""String_Node_Str"" + getIdSetCondition(ids));
  statementString.append(""String_Node_Str"");
  PreparedStatement preparedStatement=getPreparedStatement(statementString.toString());
  int index=0;
  for (  QueryConstraint constraint : constraints) {
    Image._Fields field=(Image._Fields)constraint.getField();
    for (    Object parameter : constraint.getParameters()) {
      if (parameter == null) {
        continue;
      }
      try {
switch (field) {
case user_id:
          preparedStatement.setInt(++index,(Integer)parameter);
        break;
    }
  }
 catch (  SQLException e) {
    throw new IOException(e);
  }
}
}
executeQuery(foundSet,preparedStatement);
return foundSet;
}","public Set<Image> find(ModelQuery query) throws IOException {
  Set<Image> foundSet=new HashSet<Image>();
  if (query.getConstraints() == null || query.getConstraints().isEmpty()) {
    Set<Long> ids=query.getIdSet();
    if (ids != null && !ids.isEmpty()) {
      return find(ids);
    }
    return foundSet;
  }
  StringBuilder statementString=new StringBuilder();
  statementString.append(""String_Node_Str"");
  statementString.append(query.getSqlStatement());
  statementString.append(""String_Node_Str"");
  PreparedStatement preparedStatement=getPreparedStatement(statementString.toString());
  int index=0;
  for (  QueryConstraint constraint : query.getConstraints()) {
    Image._Fields field=(Image._Fields)constraint.getField();
    for (    Object parameter : constraint.getParameters()) {
      if (parameter == null) {
        continue;
      }
      try {
switch (field) {
case user_id:
          preparedStatement.setInt(++index,(Integer)parameter);
        break;
    }
  }
 catch (  SQLException e) {
    throw new IOException(e);
  }
}
}
executeQuery(foundSet,preparedStatement);
return foundSet;
}",0.7455169782525753
38705,"public Set<Post> find(Set<Long> ids,List<QueryConstraint> constraints) throws IOException {
  Set<Post> foundSet=new HashSet<Post>();
  if (constraints == null || constraints.isEmpty()) {
    if (ids != null && !ids.isEmpty()) {
      return find(ids);
    }
    return foundSet;
  }
  StringBuilder statementString=new StringBuilder();
  statementString.append(""String_Node_Str"");
  Iterator<QueryConstraint> iter=constraints.iterator();
  while (iter.hasNext()) {
    QueryConstraint constraint=iter.next();
    Enum field=constraint.getField();
    IQueryOperator operator=constraint.getOperator();
    statementString.append(field).append(operator.getSqlStatement());
    if (iter.hasNext()) {
      statementString.append(""String_Node_Str"");
    }
  }
  if (ids != null && !ids.isEmpty())   statementString.append(""String_Node_Str"" + getIdSetCondition(ids));
  statementString.append(""String_Node_Str"");
  PreparedStatement preparedStatement=getPreparedStatement(statementString.toString());
  int index=0;
  for (  QueryConstraint constraint : constraints) {
    Post._Fields field=(Post._Fields)constraint.getField();
    for (    Object parameter : constraint.getParameters()) {
      if (parameter == null) {
        continue;
      }
      try {
switch (field) {
case title:
          preparedStatement.setString(++index,(String)parameter);
        break;
case posted_at_millis:
      preparedStatement.setDate(++index,new Date((Long)parameter));
    break;
case user_id:
  preparedStatement.setInt(++index,(Integer)parameter);
break;
case updated_at:
preparedStatement.setTimestamp(++index,new Timestamp((Long)parameter));
break;
}
}
 catch (SQLException e) {
throw new IOException(e);
}
}
}
executeQuery(foundSet,preparedStatement);
return foundSet;
}","public Set<Post> find(ModelQuery query) throws IOException {
  Set<Post> foundSet=new HashSet<Post>();
  if (query.getConstraints() == null || query.getConstraints().isEmpty()) {
    Set<Long> ids=query.getIdSet();
    if (ids != null && !ids.isEmpty()) {
      return find(ids);
    }
    return foundSet;
  }
  StringBuilder statementString=new StringBuilder();
  statementString.append(""String_Node_Str"");
  statementString.append(query.getSqlStatement());
  statementString.append(""String_Node_Str"");
  PreparedStatement preparedStatement=getPreparedStatement(statementString.toString());
  int index=0;
  for (  QueryConstraint constraint : query.getConstraints()) {
    Post._Fields field=(Post._Fields)constraint.getField();
    for (    Object parameter : constraint.getParameters()) {
      if (parameter == null) {
        continue;
      }
      try {
switch (field) {
case title:
          preparedStatement.setString(++index,(String)parameter);
        break;
case posted_at_millis:
      preparedStatement.setDate(++index,new Date((Long)parameter));
    break;
case user_id:
  preparedStatement.setInt(++index,(Integer)parameter);
break;
case updated_at:
preparedStatement.setTimestamp(++index,new Timestamp((Long)parameter));
break;
}
}
 catch (SQLException e) {
throw new IOException(e);
}
}
}
executeQuery(foundSet,preparedStatement);
return foundSet;
}",0.7871050111714012
38706,"public Set<User> find(Set<Long> ids,List<QueryConstraint> constraints) throws IOException {
  Set<User> foundSet=new HashSet<User>();
  if (constraints == null || constraints.isEmpty()) {
    if (ids != null && !ids.isEmpty()) {
      return find(ids);
    }
    return foundSet;
  }
  StringBuilder statementString=new StringBuilder();
  statementString.append(""String_Node_Str"");
  Iterator<QueryConstraint> iter=constraints.iterator();
  while (iter.hasNext()) {
    QueryConstraint constraint=iter.next();
    Enum field=constraint.getField();
    IQueryOperator operator=constraint.getOperator();
    statementString.append(field).append(operator.getSqlStatement());
    if (iter.hasNext()) {
      statementString.append(""String_Node_Str"");
    }
  }
  if (ids != null && !ids.isEmpty())   statementString.append(""String_Node_Str"" + getIdSetCondition(ids));
  statementString.append(""String_Node_Str"");
  PreparedStatement preparedStatement=getPreparedStatement(statementString.toString());
  int index=0;
  for (  QueryConstraint constraint : constraints) {
    User._Fields field=(User._Fields)constraint.getField();
    for (    Object parameter : constraint.getParameters()) {
      if (parameter == null) {
        continue;
      }
      try {
switch (field) {
case handle:
          preparedStatement.setString(++index,(String)parameter);
        break;
case created_at_millis:
      preparedStatement.setLong(++index,(Long)parameter);
    break;
case num_posts:
  preparedStatement.setInt(++index,(Integer)parameter);
break;
case some_date:
preparedStatement.setDate(++index,new Date((Long)parameter));
break;
case some_datetime:
preparedStatement.setTimestamp(++index,new Timestamp((Long)parameter));
break;
case bio:
preparedStatement.setString(++index,(String)parameter);
break;
case some_binary:
preparedStatement.setBytes(++index,(byte[])parameter);
break;
case some_float:
preparedStatement.setDouble(++index,(Double)parameter);
break;
case some_decimal:
preparedStatement.setDouble(++index,(Double)parameter);
break;
case some_boolean:
preparedStatement.setBoolean(++index,(Boolean)parameter);
break;
}
}
 catch (SQLException e) {
throw new IOException(e);
}
}
}
executeQuery(foundSet,preparedStatement);
return foundSet;
}","public Set<User> find(ModelQuery query) throws IOException {
  Set<User> foundSet=new HashSet<User>();
  if (query.getConstraints() == null || query.getConstraints().isEmpty()) {
    Set<Long> ids=query.getIdSet();
    if (ids != null && !ids.isEmpty()) {
      return find(ids);
    }
    return foundSet;
  }
  StringBuilder statementString=new StringBuilder();
  statementString.append(""String_Node_Str"");
  statementString.append(query.getSqlStatement());
  statementString.append(""String_Node_Str"");
  PreparedStatement preparedStatement=getPreparedStatement(statementString.toString());
  int index=0;
  for (  QueryConstraint constraint : query.getConstraints()) {
    User._Fields field=(User._Fields)constraint.getField();
    for (    Object parameter : constraint.getParameters()) {
      if (parameter == null) {
        continue;
      }
      try {
switch (field) {
case handle:
          preparedStatement.setString(++index,(String)parameter);
        break;
case created_at_millis:
      preparedStatement.setLong(++index,(Long)parameter);
    break;
case num_posts:
  preparedStatement.setInt(++index,(Integer)parameter);
break;
case some_date:
preparedStatement.setDate(++index,new Date((Long)parameter));
break;
case some_datetime:
preparedStatement.setTimestamp(++index,new Timestamp((Long)parameter));
break;
case bio:
preparedStatement.setString(++index,(String)parameter);
break;
case some_binary:
preparedStatement.setBytes(++index,(byte[])parameter);
break;
case some_float:
preparedStatement.setDouble(++index,(Double)parameter);
break;
case some_decimal:
preparedStatement.setDouble(++index,(Double)parameter);
break;
case some_boolean:
preparedStatement.setBoolean(++index,(Boolean)parameter);
break;
}
}
 catch (SQLException e) {
throw new IOException(e);
}
}
}
executeQuery(foundSet,preparedStatement);
return foundSet;
}",0.8371184371184371
38707,"public Set<Comment> find(Set<Long> ids,List<QueryConstraint> constraints) throws IOException {
  return super.realFind(ids,constraints);
}","public Set<Comment> find(ModelQuery query) throws IOException {
  return super.realFind(query);
}",0.7148936170212766
38708,"public Set<Image> find(Set<Long> ids,List<QueryConstraint> constraints) throws IOException {
  return super.realFind(ids,constraints);
}","public Set<Image> find(ModelQuery query) throws IOException {
  return super.realFind(query);
}",0.70995670995671
38709,"public Set<Post> find(Set<Long> ids,List<QueryConstraint> constraints) throws IOException {
  return super.realFind(ids,constraints);
}","public Set<Post> find(ModelQuery query) throws IOException {
  return super.realFind(query);
}",0.7074235807860262
38710,"public Set<User> find(Set<Long> ids,List<QueryConstraint> constraints) throws IOException {
  return super.realFind(ids,constraints);
}","public Set<User> find(ModelQuery query) throws IOException {
  return super.realFind(query);
}",0.7074235807860262
38711,"protected Set<T> realFind(Set<Long> ids,List<QueryConstraint> constraints) throws IOException {
  Set<T> foundSet=new HashSet<T>();
  if (constraints == null || constraints.isEmpty()) {
    if (ids != null && !ids.isEmpty()) {
      return find(ids);
    }
    return foundSet;
  }
  for (  T record : records.values()) {
    boolean allMatch=true;
    for (    QueryConstraint constraint : constraints) {
      Enum field=constraint.getField();
      IQueryOperator operator=constraint.getOperator();
      allMatch=allMatch && operator.apply(record.getField(field.name()));
    }
    if (ids != null && !ids.contains(record.getId())) {
      allMatch=false;
    }
    if (allMatch) {
      foundSet.add(record);
    }
  }
  return foundSet;
}","protected Set<T> realFind(Set<Long> ids,List<QueryConstraint> constraints) throws IOException {
  Set<T> foundSet=new HashSet<T>();
  if (constraints == null || constraints.isEmpty()) {
    if (ids != null && !ids.isEmpty()) {
      return find(ids);
    }
    return foundSet;
  }
  for (  T record : records.values()) {
    boolean allMatch=true;
    for (    QueryConstraint constraint : constraints) {
      Enum field=constraint.getField();
      IQueryOperator operator=constraint.getOperator();
      allMatch=allMatch && operator.apply(record.getField(field.name()));
    }
    if (ids != null && !ids.isEmpty() && !ids.contains(record.getId())) {
      allMatch=false;
    }
    if (allMatch) {
      foundSet.add(record);
    }
  }
  return foundSet;
}",0.9880478087649402
38712,"private long handleRailsUpdatedAt(T model){
  if (model.hasField(""String_Node_Str"") && model.getField(""String_Node_Str"").getClass().equals(Long.class)) {
    long oldUpdatedAt=(Long)model.getField(""String_Node_Str"");
    model.setField(""String_Node_Str"",System.currentTimeMillis());
    return oldUpdatedAt;
  }
  return 0;
}","private long handleRailsUpdatedAt(T model){
  if (model.hasField(""String_Node_Str"")) {
    Object field=model.getField(""String_Node_Str"");
    if (field != null && field.getClass().equals(Long.class)) {
      long oldUpdatedAt=(Long)field;
      model.setField(""String_Node_Str"",System.currentTimeMillis());
      return oldUpdatedAt;
    }
  }
  return 0;
}",0.7203513909224012
38713,"@Override public boolean save(T model) throws IOException {
  if (model.isCreated()) {
    PreparedStatement saveStmt=getSaveStmt();
    try {
      setAttrs(model,saveStmt);
      saveStmt.execute();
      boolean success=saveStmt.getUpdateCount() == 1;
      saveStmt.close();
      if (success && useCache) {
        cachedById.put(model.getId(),model);
      }
      clearForeignKeyCache();
      return success;
    }
 catch (    SQLException e) {
      throw new IOException(e);
    }
  }
 else {
    PreparedStatement insertStmt=conn.getPreparedStatement(getInsertWithIdStatement(fieldNames));
    try {
      setAttrs(model,insertStmt);
      insertStmt.setLong(fieldNames.size() + 1,model.getId());
      insertStmt.execute();
      boolean success=insertStmt.getUpdateCount() == 1;
      insertStmt.close();
      if (success && useCache) {
        cachedById.put(model.getId(),model);
      }
      clearForeignKeyCache();
      return success;
    }
 catch (    SQLException e) {
      throw new IOException(e);
    }
  }
}","@Override public boolean save(T model) throws IOException {
  if (model.isCreated()) {
    PreparedStatement saveStmt=getSaveStmt();
    try {
      setAttrs(model,saveStmt);
      saveStmt.execute();
      boolean success=saveStmt.getUpdateCount() == 1;
      saveStmt.close();
      if (success && useCache) {
        cachedById.put(model.getId(),model);
      }
      clearForeignKeyCache();
      return success;
    }
 catch (    SQLException e) {
      throw new IOException(e);
    }
  }
 else {
    PreparedStatement insertStmt=conn.getPreparedStatement(getInsertWithIdStatement(fieldNames));
    try {
      setAttrs(model,insertStmt);
      insertStmt.setLong(fieldNames.size() + 1,model.getId());
      insertStmt.execute();
      boolean success=insertStmt.getUpdateCount() == 1;
      insertStmt.close();
      if (success && useCache) {
        cachedById.put(model.getId(),model);
      }
      clearForeignKeyCache();
      model.setCreated(true);
      return success;
    }
 catch (    SQLException e) {
      throw new IOException(e);
    }
  }
}",0.9857142857142858
38714,"@Override public Set<T> findAllByForeignKey(String foreignKey,Set<Long> ids) throws IOException {
  Map<Long,Set<T>> foreignKeyCache=cachedByForeignKey.get(foreignKey);
  Set<T> foundSet=new HashSet<T>();
  Set<Long> notCachedIds=new HashSet<Long>();
  if (foreignKeyCache != null && useCache) {
    for (    Long id : ids) {
      Set<T> results=foreignKeyCache.get(id);
      if (results != null) {
        foundSet.addAll(results);
      }
 else {
        notCachedIds.add(id);
      }
    }
  }
 else {
    notCachedIds=ids;
    if (useCache) {
      foreignKeyCache=new HashMap<Long,Set<T>>();
      cachedByForeignKey.put(foreignKey,foreignKeyCache);
    }
  }
  if (!notCachedIds.isEmpty()) {
    StringBuilder statementString=new StringBuilder();
    statementString.append(""String_Node_Str"");
    statementString.append(tableName);
    statementString.append(""String_Node_Str"" + foreignKey + ""String_Node_Str"");
    Iterator<Long> iter=notCachedIds.iterator();
    while (iter.hasNext()) {
      Long obj=iter.next();
      statementString.append(obj.toString());
      if (iter.hasNext()) {
        statementString.append(""String_Node_Str"");
      }
    }
    statementString.append(""String_Node_Str"");
    PreparedStatement stmt=conn.getPreparedStatement(statementString.toString());
    ResultSet rs=null;
    try {
      rs=stmt.executeQuery();
      while (rs.next()) {
        T inst=instanceFromResultSet(rs);
        foundSet.add(inst);
        if (useCache) {
          cachedById.put(inst.getId(),inst);
        }
      }
    }
 catch (    SQLException e) {
      throw new IOException(e);
    }
  }
  return foundSet;
}","@Override public Set<T> findAllByForeignKey(String foreignKey,Set<Long> ids) throws IOException {
  Map<Long,Set<T>> foreignKeyCache=cachedByForeignKey.get(foreignKey);
  Set<T> foundSet=new HashSet<T>();
  Set<Long> notCachedIds=new HashSet<Long>();
  if (foreignKeyCache != null && useCache) {
    for (    Long id : ids) {
      Set<T> results=foreignKeyCache.get(id);
      if (results != null) {
        foundSet.addAll(results);
      }
 else {
        notCachedIds.add(id);
      }
    }
  }
 else {
    notCachedIds=ids;
    if (useCache) {
      foreignKeyCache=new HashMap<Long,Set<T>>();
      cachedByForeignKey.put(foreignKey,foreignKeyCache);
    }
  }
  if (!notCachedIds.isEmpty()) {
    StringBuilder statementString=new StringBuilder();
    statementString.append(""String_Node_Str"");
    statementString.append(tableName);
    statementString.append(""String_Node_Str"" + foreignKey + ""String_Node_Str"");
    Iterator<Long> iter=notCachedIds.iterator();
    while (iter.hasNext()) {
      Long obj=iter.next();
      statementString.append(obj.toString());
      if (iter.hasNext()) {
        statementString.append(""String_Node_Str"");
      }
    }
    statementString.append(""String_Node_Str"");
    PreparedStatement stmt=conn.getPreparedStatement(statementString.toString());
    ResultSet rs=null;
    try {
      rs=stmt.executeQuery();
      while (rs.next()) {
        T inst=instanceFromResultSet(rs);
        inst.setCreated(true);
        foundSet.add(inst);
        if (useCache) {
          cachedById.put(inst.getId(),inst);
        }
      }
    }
 catch (    SQLException e) {
      throw new IOException(e);
    }
  }
  return foundSet;
}",0.9906316107585372
38715,public Comment create(final long created_at) throws IOException ;,"public Comment create(final int commenter_id,final long commented_on_id,final long created_at) throws IOException ;",0.7222222222222222
38716,public Set<Comment> findByCommenterId(Integer value) throws IOException ;,public Set<Comment> findByCommenterId(int value) throws IOException ;,0.9577464788732394
38717,public Set<Comment> findByCommentedOnId(Long value) throws IOException ;,public Set<Comment> findByCommentedOnId(long value) throws IOException ;,0.9861111111111112
38718,"public void set(PreparedStatement stmt) throws SQLException {
  stmt.setTimestamp(1,new Timestamp(created_at));
}","public void set(PreparedStatement stmt) throws SQLException {
  stmt.setInt(1,commenter_id);
  stmt.setLong(2,commented_on_id);
  stmt.setTimestamp(3,new Timestamp(created_at));
}",0.7671232876712328
38719,"public Comment create(final long created_at) throws IOException {
  long __id=realCreate(new AttrSetter(){
    public void set(    PreparedStatement stmt) throws SQLException {
      stmt.setTimestamp(1,new Timestamp(created_at));
    }
  }
,getInsertStatement(Arrays.asList(""String_Node_Str"")));
  Comment newInst=new Comment(__id,null,null,null,created_at,databases);
  cachedById.put(__id,newInst);
  clearForeignKeyCache();
  return newInst;
}","public Comment create(final int commenter_id,final long commented_on_id,final long created_at) throws IOException {
  long __id=realCreate(new AttrSetter(){
    public void set(    PreparedStatement stmt) throws SQLException {
      stmt.setInt(1,commenter_id);
      stmt.setLong(2,commented_on_id);
      stmt.setTimestamp(3,new Timestamp(created_at));
    }
  }
,getInsertStatement(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")));
  Comment newInst=new Comment(__id,null,commenter_id,commented_on_id,created_at,databases);
  cachedById.put(__id,newInst);
  clearForeignKeyCache();
  return newInst;
}",0.8145386766076421
38720,"@Override protected void setAttrs(Comment model,PreparedStatement stmt) throws SQLException {
  if (model.getContent() == null) {
    stmt.setNull(1,java.sql.Types.CHAR);
  }
 else {
    stmt.setString(1,model.getContent());
  }
  if (model.getCommenterId() == null) {
    stmt.setNull(2,java.sql.Types.INTEGER);
  }
 else {
    stmt.setInt(2,model.getCommenterId());
  }
  if (model.getCommentedOnId() == null) {
    stmt.setNull(3,java.sql.Types.INTEGER);
  }
 else {
    stmt.setLong(3,model.getCommentedOnId());
  }
{
    stmt.setTimestamp(4,new Timestamp(model.getCreatedAt()));
  }
  stmt.setLong(5,model.getId());
}","@Override protected void setAttrs(Comment model,PreparedStatement stmt) throws SQLException {
  if (model.getContent() == null) {
    stmt.setNull(1,java.sql.Types.CHAR);
  }
 else {
    stmt.setString(1,model.getContent());
  }
{
    stmt.setInt(2,model.getCommenterId());
  }
{
    stmt.setLong(3,model.getCommentedOnId());
  }
{
    stmt.setTimestamp(4,new Timestamp(model.getCreatedAt()));
  }
  stmt.setLong(5,model.getId());
}",0.4459203036053131
38721,"public Set<Comment> findByCommenterId(final Integer value) throws IOException {
  return find(new HashMap<Enum,Object>(){
{
      put(Comment._Fields.commenter_id,value);
    }
  }
);
}","public Set<Comment> findByCommenterId(final int value) throws IOException {
  return find(new HashMap<Enum,Object>(){
{
      put(Comment._Fields.commenter_id,value);
    }
  }
);
}",0.9836065573770492
38722,"public Set<Comment> findByCommentedOnId(final Long value) throws IOException {
  return find(new HashMap<Enum,Object>(){
{
      put(Comment._Fields.commented_on_id,value);
    }
  }
);
}","public Set<Comment> findByCommentedOnId(final long value) throws IOException {
  return find(new HashMap<Enum,Object>(){
{
      put(Comment._Fields.commented_on_id,value);
    }
  }
);
}",0.9946524064171124
38723,"public Comment create(final long created_at) throws IOException {
  long __id=curId.getAndIncrement();
  Comment newInst=new Comment(__id,null,null,null,created_at,databases);
  records.put(__id,newInst);
  clearForeignKeyCache();
  return newInst;
}","public Comment create(final int commenter_id,final long commented_on_id,final long created_at) throws IOException {
  long __id=curId.getAndIncrement();
  Comment newInst=new Comment(__id,null,commenter_id,commented_on_id,created_at,databases);
  records.put(__id,newInst);
  clearForeignKeyCache();
  return newInst;
}",0.8471001757469244
38724,"public Set<Comment> findByCommenterId(final Integer value) throws IOException {
  return find(new HashMap<Enum,Object>(){
{
      put(Comment._Fields.commenter_id,value);
    }
  }
);
}","public Set<Comment> findByCommenterId(final int value) throws IOException {
  return find(new HashMap<Enum,Object>(){
{
      put(Comment._Fields.commenter_id,value);
    }
  }
);
}",0.9836065573770492
38725,"public Set<Comment> findByCommentedOnId(final Long value) throws IOException {
  return find(new HashMap<Enum,Object>(){
{
      put(Comment._Fields.commented_on_id,value);
    }
  }
);
}","public Set<Comment> findByCommentedOnId(final long value) throws IOException {
  return find(new HashMap<Enum,Object>(){
{
      put(Comment._Fields.commented_on_id,value);
    }
  }
);
}",0.9946524064171124
38726,"public void setCommenterId(Integer newval){
  this.__commenter_id=newval;
}","public void setCommenterId(int newval){
  this.__commenter_id=newval;
}",0.958904109589041
38727,"public Long getCommentedOnId(){
  return __commented_on_id;
}","public long getCommentedOnId(){
  return __commented_on_id;
}",0.9836065573770492
38728,"public static Class getFieldType(String fieldName){
  if (fieldName.equals(""String_Node_Str"")) {
    return String.class;
  }
  if (fieldName.equals(""String_Node_Str"")) {
    return Integer.class;
  }
  if (fieldName.equals(""String_Node_Str"")) {
    return Long.class;
  }
  if (fieldName.equals(""String_Node_Str"")) {
    return long.class;
  }
  throw new IllegalStateException(""String_Node_Str"" + fieldName);
}","public static Class getFieldType(String fieldName){
  if (fieldName.equals(""String_Node_Str"")) {
    return String.class;
  }
  if (fieldName.equals(""String_Node_Str"")) {
    return int.class;
  }
  if (fieldName.equals(""String_Node_Str"")) {
    return long.class;
  }
  if (fieldName.equals(""String_Node_Str"")) {
    return long.class;
  }
  throw new IllegalStateException(""String_Node_Str"" + fieldName);
}",0.9853658536585366
38729,"public Integer getCommenterId(){
  return __commenter_id;
}","public int getCommenterId(){
  return __commenter_id;
}",0.9473684210526316
38730,"public void setCommentedOnId(Long newval){
  this.__commented_on_id=newval;
}","public void setCommentedOnId(long newval){
  this.__commented_on_id=newval;
}",0.987012987012987
38731,"protected Set<T> realFind(Map fieldsMap) throws IOException {
  Set<T> foundSet=new HashSet<T>();
  if (fieldsMap == null || fieldsMap.isEmpty()) {
    return foundSet;
  }
  for (  T t : records.values()) {
    for (    Map.Entry<Enum,Object> e : ((Map<Enum,Object>)fieldsMap).entrySet()) {
      if (e.getValue().equals(t.getField(e.getKey().name()))) {
        foundSet.add(t);
      }
    }
  }
  return foundSet;
}","protected Set<T> realFind(Map fieldsMap) throws IOException {
  Set<T> foundSet=new HashSet<T>();
  if (fieldsMap == null || fieldsMap.isEmpty()) {
    return foundSet;
  }
  for (  T record : records.values()) {
    boolean allMatch=true;
    for (    Map.Entry<Enum,Object> e : ((Map<Enum,Object>)fieldsMap).entrySet()) {
      Object searchedForValue=e.getValue();
      Object existingValue=record.getField(e.getKey().name());
      if (existingValue == null) {
        if (searchedForValue != null)         allMatch=false;
      }
 else       if (!existingValue.equals(searchedForValue)) {
        allMatch=false;
      }
      if (allMatch)       foundSet.add(record);
    }
  }
  return foundSet;
}",0.6352313167259787
38732,"public Set<Comment> find(Map<Enum,Object> fieldsMap) throws IOException {
  Set<Comment> foundSet=new HashSet<Comment>();
  EnumSet<Comment._Fields> dateTimeFields=EnumSet.of(Comment._Fields.created_at);
  if (fieldsMap == null || fieldsMap.isEmpty()) {
    return foundSet;
  }
  StringBuilder statementString=new StringBuilder();
  statementString.append(""String_Node_Str"");
  statementString.append(""String_Node_Str"");
  statementString.append(""String_Node_Str"");
  Iterator<Map.Entry<Enum,Object>> iter=fieldsMap.entrySet().iterator();
  while (iter.hasNext()) {
    Map.Entry<Enum,Object> entry=iter.next();
    Enum field=entry.getKey();
    String queryValue=entry.getValue().toString();
    if (dateTimeFields.contains(field)) {
      queryValue=new Timestamp((Long)entry.getValue()).toString();
    }
    statementString.append(field + ""String_Node_Str"" + queryValue+ ""String_Node_Str"");
    if (iter.hasNext()) {
      statementString.append(""String_Node_Str"");
    }
  }
  statementString.append(""String_Node_Str"");
  executeQuery(foundSet,statementString);
  return foundSet;
}","public Set<Comment> find(Map<Enum,Object> fieldsMap) throws IOException {
  Set<Comment> foundSet=new HashSet<Comment>();
  EnumSet<Comment._Fields> dateTimeFields=EnumSet.of(Comment._Fields.created_at);
  EnumSet<Comment._Fields> valueRequiresQuotesFields=EnumSet.of(Comment._Fields.content);
  if (fieldsMap == null || fieldsMap.isEmpty()) {
    return foundSet;
  }
  StringBuilder statementString=new StringBuilder();
  statementString.append(""String_Node_Str"");
  statementString.append(""String_Node_Str"");
  statementString.append(""String_Node_Str"");
  Iterator<Map.Entry<Enum,Object>> iter=fieldsMap.entrySet().iterator();
  while (iter.hasNext()) {
    Map.Entry<Enum,Object> entry=iter.next();
    Enum field=entry.getKey();
    Object value=entry.getValue();
    String queryValue;
    if (value != null) {
      queryValue=entry.getValue().toString();
      if (valueRequiresQuotesFields.contains(field))       queryValue=""String_Node_Str"" + queryValue + ""String_Node_Str"";
      if (dateTimeFields.contains(field)) {
        queryValue=""String_Node_Str"" + new Timestamp((Long)entry.getValue()).toString() + ""String_Node_Str"";
      }
      queryValue=""String_Node_Str"" + queryValue;
    }
 else {
      queryValue=""String_Node_Str"";
    }
    statementString.append(field + queryValue);
    if (iter.hasNext()) {
      statementString.append(""String_Node_Str"");
    }
  }
  statementString.append(""String_Node_Str"");
  System.out.println(statementString);
  executeQuery(foundSet,statementString);
  return foundSet;
}",0.6307751050019091
38733,"public Set<Image> find(Map<Enum,Object> fieldsMap) throws IOException {
  Set<Image> foundSet=new HashSet<Image>();
  if (fieldsMap == null || fieldsMap.isEmpty()) {
    return foundSet;
  }
  StringBuilder statementString=new StringBuilder();
  statementString.append(""String_Node_Str"");
  statementString.append(""String_Node_Str"");
  statementString.append(""String_Node_Str"");
  Iterator<Map.Entry<Enum,Object>> iter=fieldsMap.entrySet().iterator();
  while (iter.hasNext()) {
    Map.Entry<Enum,Object> entry=iter.next();
    Enum field=entry.getKey();
    String queryValue=entry.getValue().toString();
    statementString.append(field + ""String_Node_Str"" + queryValue+ ""String_Node_Str"");
    if (iter.hasNext()) {
      statementString.append(""String_Node_Str"");
    }
  }
  statementString.append(""String_Node_Str"");
  executeQuery(foundSet,statementString);
  return foundSet;
}","public Set<Image> find(Map<Enum,Object> fieldsMap) throws IOException {
  Set<Image> foundSet=new HashSet<Image>();
  if (fieldsMap == null || fieldsMap.isEmpty()) {
    return foundSet;
  }
  StringBuilder statementString=new StringBuilder();
  statementString.append(""String_Node_Str"");
  statementString.append(""String_Node_Str"");
  statementString.append(""String_Node_Str"");
  Iterator<Map.Entry<Enum,Object>> iter=fieldsMap.entrySet().iterator();
  while (iter.hasNext()) {
    Map.Entry<Enum,Object> entry=iter.next();
    Enum field=entry.getKey();
    Object value=entry.getValue();
    String queryValue;
    if (value != null) {
      queryValue=entry.getValue().toString();
    }
 else {
      queryValue=""String_Node_Str"";
    }
    statementString.append(field + queryValue);
    if (iter.hasNext()) {
      statementString.append(""String_Node_Str"");
    }
  }
  statementString.append(""String_Node_Str"");
  System.out.println(statementString);
  executeQuery(foundSet,statementString);
  return foundSet;
}",0.6799580272822665
38734,"public Set<Post> find(Map<Enum,Object> fieldsMap) throws IOException {
  Set<Post> foundSet=new HashSet<Post>();
  EnumSet<Post._Fields> dateFields=EnumSet.of(Post._Fields.posted_at_millis);
  if (fieldsMap == null || fieldsMap.isEmpty()) {
    return foundSet;
  }
  StringBuilder statementString=new StringBuilder();
  statementString.append(""String_Node_Str"");
  statementString.append(""String_Node_Str"");
  statementString.append(""String_Node_Str"");
  Iterator<Map.Entry<Enum,Object>> iter=fieldsMap.entrySet().iterator();
  while (iter.hasNext()) {
    Map.Entry<Enum,Object> entry=iter.next();
    Enum field=entry.getKey();
    String queryValue=entry.getValue().toString();
    if (dateFields.contains(field)) {
      queryValue=new Date((Long)entry.getValue()).toString();
    }
    statementString.append(field + ""String_Node_Str"" + queryValue+ ""String_Node_Str"");
    if (iter.hasNext()) {
      statementString.append(""String_Node_Str"");
    }
  }
  statementString.append(""String_Node_Str"");
  executeQuery(foundSet,statementString);
  return foundSet;
}","public Set<Post> find(Map<Enum,Object> fieldsMap) throws IOException {
  Set<Post> foundSet=new HashSet<Post>();
  EnumSet<Post._Fields> dateFields=EnumSet.of(Post._Fields.posted_at_millis);
  EnumSet<Post._Fields> valueRequiresQuotesFields=EnumSet.of(Post._Fields.title);
  if (fieldsMap == null || fieldsMap.isEmpty()) {
    return foundSet;
  }
  StringBuilder statementString=new StringBuilder();
  statementString.append(""String_Node_Str"");
  statementString.append(""String_Node_Str"");
  statementString.append(""String_Node_Str"");
  Iterator<Map.Entry<Enum,Object>> iter=fieldsMap.entrySet().iterator();
  while (iter.hasNext()) {
    Map.Entry<Enum,Object> entry=iter.next();
    Enum field=entry.getKey();
    Object value=entry.getValue();
    String queryValue;
    if (value != null) {
      queryValue=entry.getValue().toString();
      if (valueRequiresQuotesFields.contains(field))       queryValue=""String_Node_Str"" + queryValue + ""String_Node_Str"";
      if (dateFields.contains(field)) {
        queryValue=""String_Node_Str"" + new Date((Long)entry.getValue()).toString() + ""String_Node_Str"";
      }
    }
 else {
      queryValue=""String_Node_Str"";
    }
    statementString.append(field + queryValue);
    if (iter.hasNext()) {
      statementString.append(""String_Node_Str"");
    }
  }
  statementString.append(""String_Node_Str"");
  System.out.println(statementString);
  executeQuery(foundSet,statementString);
  return foundSet;
}",0.6465448768864178
38735,"public Set<User> find(Map<Enum,Object> fieldsMap) throws IOException {
  Set<User> foundSet=new HashSet<User>();
  EnumSet<User._Fields> dateFields=EnumSet.of(User._Fields.some_date);
  EnumSet<User._Fields> dateTimeFields=EnumSet.of(User._Fields.some_datetime);
  if (fieldsMap == null || fieldsMap.isEmpty()) {
    return foundSet;
  }
  StringBuilder statementString=new StringBuilder();
  statementString.append(""String_Node_Str"");
  statementString.append(""String_Node_Str"");
  statementString.append(""String_Node_Str"");
  Iterator<Map.Entry<Enum,Object>> iter=fieldsMap.entrySet().iterator();
  while (iter.hasNext()) {
    Map.Entry<Enum,Object> entry=iter.next();
    Enum field=entry.getKey();
    String queryValue=entry.getValue().toString();
    if (dateFields.contains(field)) {
      queryValue=new Date((Long)entry.getValue()).toString();
    }
    if (dateTimeFields.contains(field)) {
      queryValue=new Timestamp((Long)entry.getValue()).toString();
    }
    statementString.append(field + ""String_Node_Str"" + queryValue+ ""String_Node_Str"");
    if (iter.hasNext()) {
      statementString.append(""String_Node_Str"");
    }
  }
  statementString.append(""String_Node_Str"");
  executeQuery(foundSet,statementString);
  return foundSet;
}","public Set<User> find(Map<Enum,Object> fieldsMap) throws IOException {
  Set<User> foundSet=new HashSet<User>();
  EnumSet<User._Fields> dateFields=EnumSet.of(User._Fields.some_date);
  EnumSet<User._Fields> dateTimeFields=EnumSet.of(User._Fields.some_datetime);
  EnumSet<User._Fields> valueRequiresQuotesFields=EnumSet.of(User._Fields.handle,User._Fields.bio);
  if (fieldsMap == null || fieldsMap.isEmpty()) {
    return foundSet;
  }
  StringBuilder statementString=new StringBuilder();
  statementString.append(""String_Node_Str"");
  statementString.append(""String_Node_Str"");
  statementString.append(""String_Node_Str"");
  Iterator<Map.Entry<Enum,Object>> iter=fieldsMap.entrySet().iterator();
  while (iter.hasNext()) {
    Map.Entry<Enum,Object> entry=iter.next();
    Enum field=entry.getKey();
    Object value=entry.getValue();
    String queryValue;
    if (value != null) {
      queryValue=entry.getValue().toString();
      if (valueRequiresQuotesFields.contains(field))       queryValue=""String_Node_Str"" + queryValue + ""String_Node_Str"";
      if (dateFields.contains(field)) {
        queryValue=""String_Node_Str"" + new Date((Long)entry.getValue()).toString() + ""String_Node_Str"";
      }
      if (dateTimeFields.contains(field)) {
        queryValue=""String_Node_Str"" + new Timestamp((Long)entry.getValue()).toString() + ""String_Node_Str"";
      }
      queryValue=""String_Node_Str"" + queryValue;
    }
 else {
      queryValue=""String_Node_Str"";
    }
    statementString.append(field + queryValue);
    if (iter.hasNext()) {
      statementString.append(""String_Node_Str"");
    }
  }
  statementString.append(""String_Node_Str"");
  System.out.println(statementString);
  executeQuery(foundSet,statementString);
  return foundSet;
}",0.6502495840266223
38736,"public Comment create(final String content,final Integer commenter_id,final Integer commented_on_id) throws IOException ;",public Comment create(final long created_at) throws IOException ;,0.6451612903225806
38737,"public void set(PreparedStatement stmt) throws SQLException {
  if (content == null) {
    stmt.setNull(1,java.sql.Types.CHAR);
  }
 else {
    stmt.setString(1,content);
  }
  if (commenter_id == null) {
    stmt.setNull(2,java.sql.Types.INTEGER);
  }
 else {
    stmt.setInt(2,commenter_id);
  }
  if (commented_on_id == null) {
    stmt.setNull(3,java.sql.Types.INTEGER);
  }
 else {
    stmt.setInt(3,commented_on_id);
  }
}","public void set(PreparedStatement stmt) throws SQLException {
  stmt.setTimestamp(1,new Timestamp(created_at));
}",0.3438077634011091
38738,"public Comment create(final String content,final Integer commenter_id,final Integer commented_on_id) throws IOException {
  int __id=realCreate(new AttrSetter(){
    public void set(    PreparedStatement stmt) throws SQLException {
      if (content == null) {
        stmt.setNull(1,java.sql.Types.CHAR);
      }
 else {
        stmt.setString(1,content);
      }
      if (commenter_id == null) {
        stmt.setNull(2,java.sql.Types.INTEGER);
      }
 else {
        stmt.setInt(2,commenter_id);
      }
      if (commented_on_id == null) {
        stmt.setNull(3,java.sql.Types.INTEGER);
      }
 else {
        stmt.setInt(3,commented_on_id);
      }
    }
  }
,getInsertStatement(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")));
  Comment newInst=new Comment(__id,content,commenter_id,commented_on_id,databases);
  cachedById.put(__id,newInst);
  clearForeignKeyCache();
  return newInst;
}","public Comment create(final long created_at) throws IOException {
  int __id=realCreate(new AttrSetter(){
    public void set(    PreparedStatement stmt) throws SQLException {
      stmt.setTimestamp(1,new Timestamp(created_at));
    }
  }
,getInsertStatement(Arrays.asList(""String_Node_Str"")));
  Comment newInst=new Comment(__id,null,null,null,created_at,databases);
  cachedById.put(__id,newInst);
  clearForeignKeyCache();
  return newInst;
}",0.3850658857979502
38739,"@Override protected void setAttrs(Comment model,PreparedStatement stmt) throws SQLException {
  if (model.getContent() == null) {
    stmt.setNull(1,java.sql.Types.CHAR);
  }
 else {
    stmt.setString(1,model.getContent());
  }
  if (model.getCommenterId() == null) {
    stmt.setNull(2,java.sql.Types.INTEGER);
  }
 else {
    stmt.setInt(2,model.getCommenterId());
  }
  if (model.getCommentedOnId() == null) {
    stmt.setNull(3,java.sql.Types.INTEGER);
  }
 else {
    stmt.setInt(3,model.getCommentedOnId());
  }
  stmt.setLong(4,model.getId());
}","@Override protected void setAttrs(Comment model,PreparedStatement stmt) throws SQLException {
  if (model.getContent() == null) {
    stmt.setNull(1,java.sql.Types.CHAR);
  }
 else {
    stmt.setString(1,model.getContent());
  }
  if (model.getCommenterId() == null) {
    stmt.setNull(2,java.sql.Types.INTEGER);
  }
 else {
    stmt.setInt(2,model.getCommenterId());
  }
  if (model.getCommentedOnId() == null) {
    stmt.setNull(3,java.sql.Types.INTEGER);
  }
 else {
    stmt.setInt(3,model.getCommentedOnId());
  }
{
    stmt.setTimestamp(4,new Timestamp(model.getCreatedAt()));
  }
  stmt.setLong(5,model.getId());
}",0.909710391822828
38740,"@Override protected Comment instanceFromResultSet(ResultSet rs) throws SQLException {
  return new Comment(rs.getInt(""String_Node_Str""),rs.getString(""String_Node_Str""),getIntOrNull(rs,""String_Node_Str""),getIntOrNull(rs,""String_Node_Str""),databases);
}","@Override protected Comment instanceFromResultSet(ResultSet rs) throws SQLException {
  return new Comment(rs.getInt(""String_Node_Str""),rs.getString(""String_Node_Str""),getIntOrNull(rs,""String_Node_Str""),getIntOrNull(rs,""String_Node_Str""),getDateAsLong(rs,""String_Node_Str""),databases);
}",0.933085501858736
38741,"public BaseCommentPersistenceImpl(BaseDatabaseConnection conn,IDatabases databases){
  super(conn,""String_Node_Str"",Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  this.databases=databases;
}","public BaseCommentPersistenceImpl(BaseDatabaseConnection conn,IDatabases databases){
  super(conn,""String_Node_Str"",Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  this.databases=databases;
}",0.96
38742,"public Comment create(final String content,final Integer commenter_id,final Integer commented_on_id) throws IOException {
  int __id=curId.getAndIncrement();
  Comment newInst=new Comment(__id,content,commenter_id,commented_on_id,databases);
  records.put(__id,newInst);
  clearForeignKeyCache();
  return newInst;
}","public Comment create(final long created_at) throws IOException {
  int __id=curId.getAndIncrement();
  Comment newInst=new Comment(__id,null,null,null,created_at,databases);
  records.put(__id,newInst);
  clearForeignKeyCache();
  return newInst;
}",0.7539823008849558
38743,"public Comment(Comment other){
  super(other.getId());
  this.__content=other.getContent();
  this.__commenter_id=other.getCommenterId();
  this.__commented_on_id=other.getCommentedOnId();
}","public Comment(Comment other){
  super(other.getId());
  this.__content=other.getContent();
  this.__commenter_id=other.getCommenterId();
  this.__commented_on_id=other.getCommentedOnId();
  this.__created_at=other.getCreatedAt();
}",0.9004739336492891
38744,"public void setField(_Fields field,Object value){
switch (field) {
case content:
    setContent((String)value);
  break;
case commenter_id:
setCommenterId((Integer)value);
break;
case commented_on_id:
setCommentedOnId((Integer)value);
break;
}
throw new IllegalStateException(""String_Node_Str"" + field);
}","public void setField(_Fields field,Object value){
switch (field) {
case content:
    setContent((String)value);
  break;
case commenter_id:
setCommenterId((Integer)value);
break;
case commented_on_id:
setCommentedOnId((Integer)value);
break;
case created_at:
setCreatedAt((Long)value);
break;
}
throw new IllegalStateException(""String_Node_Str"" + field);
}",0.9228441754916792
38745,"public Object getField(_Fields field){
switch (field) {
case content:
    return getContent();
case commenter_id:
  return getCommenterId();
case commented_on_id:
return getCommentedOnId();
}
throw new IllegalStateException(""String_Node_Str"" + field);
}","public Object getField(_Fields field){
switch (field) {
case content:
    return getContent();
case commenter_id:
  return getCommenterId();
case commented_on_id:
return getCommentedOnId();
case created_at:
return getCreatedAt();
}
throw new IllegalStateException(""String_Node_Str"" + field);
}",0.9267399267399268
38746,"public Object getDefaultValue(_Fields field){
switch (field) {
case content:
    return null;
case commenter_id:
  return null;
case commented_on_id:
return null;
}
throw new IllegalStateException(""String_Node_Str"" + field);
}","public Object getDefaultValue(_Fields field){
switch (field) {
case content:
    return null;
case commenter_id:
  return null;
case commented_on_id:
return null;
case created_at:
return 28800000;
}
throw new IllegalStateException(""String_Node_Str"" + field);
}",0.9300411522633744
38747,"public String toString(){
  return ""String_Node_Str"" + ""String_Node_Str"" + __content + ""String_Node_Str""+ __commenter_id+ ""String_Node_Str""+ __commented_on_id+ ""String_Node_Str"";
}","public String toString(){
  return ""String_Node_Str"" + ""String_Node_Str"" + __content + ""String_Node_Str""+ __commenter_id+ ""String_Node_Str""+ __commented_on_id+ ""String_Node_Str""+ __created_at+ ""String_Node_Str"";
}",0.916030534351145
38748,"public void setField(_Fields field,Object value){
switch (field) {
case content:
    setContent((String)value);
  break;
case commenter_id:
setCommenterId((Integer)value);
break;
case commented_on_id:
setCommentedOnId((Integer)value);
break;
case created_at:
setCreatedAt((Long)value);
break;
}
throw new IllegalStateException(""String_Node_Str"" + field);
}","public void setField(_Fields field,Object value){
switch (field) {
case content:
    setContent((String)value);
  break;
case commenter_id:
setCommenterId((Integer)value);
break;
case commented_on_id:
setCommentedOnId((Integer)value);
break;
case created_at:
setCreatedAt((Long)value);
break;
default :
throw new IllegalStateException(""String_Node_Str"" + field);
}
}",0.9833795013850416
38749,"public void setField(_Fields field,Object value){
switch (field) {
case user_id:
    setUserId((Integer)value);
  break;
}
throw new IllegalStateException(""String_Node_Str"" + field);
}","public void setField(_Fields field,Object value){
switch (field) {
case user_id:
    setUserId((Integer)value);
  break;
default :
throw new IllegalStateException(""String_Node_Str"" + field);
}
}",0.9682539682539684
38750,"public void setField(_Fields field,Object value){
switch (field) {
case title:
    setTitle((String)value);
  break;
case posted_at_millis:
setPostedAtMillis((Long)value);
break;
case user_id:
setUserId((Integer)value);
break;
}
throw new IllegalStateException(""String_Node_Str"" + field);
}","public void setField(_Fields field,Object value){
switch (field) {
case title:
    setTitle((String)value);
  break;
case posted_at_millis:
setPostedAtMillis((Long)value);
break;
case user_id:
setUserId((Integer)value);
break;
default :
throw new IllegalStateException(""String_Node_Str"" + field);
}
}",0.9796610169491524
38751,"public void setField(_Fields field,Object value){
switch (field) {
case handle:
    setHandle((String)value);
  break;
case created_at_millis:
setCreatedAtMillis((Long)value);
break;
case num_posts:
setNumPosts((Integer)value);
break;
case some_date:
setSomeDate((Long)value);
break;
case some_datetime:
setSomeDatetime((Long)value);
break;
case bio:
setBio((String)value);
break;
case some_binary:
setSomeBinary((byte[])value);
break;
case some_float:
setSomeFloat((Double)value);
break;
case some_boolean:
setSomeBoolean((Boolean)value);
break;
}
throw new IllegalStateException(""String_Node_Str"" + field);
}","public void setField(_Fields field,Object value){
switch (field) {
case handle:
    setHandle((String)value);
  break;
case created_at_millis:
setCreatedAtMillis((Long)value);
break;
case num_posts:
setNumPosts((Integer)value);
break;
case some_date:
setSomeDate((Long)value);
break;
case some_datetime:
setSomeDatetime((Long)value);
break;
case bio:
setBio((String)value);
break;
case some_binary:
setSomeBinary((byte[])value);
break;
case some_float:
setSomeFloat((Double)value);
break;
case some_boolean:
setSomeBoolean((Boolean)value);
break;
default :
throw new IllegalStateException(""String_Node_Str"" + field);
}
}",0.9902439024390244
38752,"private void executeQuery(Set<T> foundSet,StringBuilder statementString) throws IOException {
  PreparedStatement stmt=conn.getPreparedStatement(statementString.toString());
  ResultSet rs=null;
  try {
    rs=stmt.executeQuery();
    while (rs.next()) {
      T inst=instanceFromResultSet(rs);
      foundSet.add(inst);
      if (useCache) {
        cachedById.put(inst.getId(),inst);
      }
    }
  }
 catch (  SQLException e) {
    throw new IOException(e);
  }
 finally {
    try {
      if (rs != null) {
        rs.close();
      }
      stmt.close();
    }
 catch (    SQLException e) {
      throw new IOException(e);
    }
  }
}","protected void executeQuery(Set<T> foundSet,StringBuilder statementString) throws IOException {
  PreparedStatement stmt=conn.getPreparedStatement(statementString.toString());
  ResultSet rs=null;
  try {
    rs=stmt.executeQuery();
    while (rs.next()) {
      T inst=instanceFromResultSet(rs);
      foundSet.add(inst);
      if (useCache) {
        cachedById.put(inst.getId(),inst);
      }
    }
  }
 catch (  SQLException e) {
    throw new IOException(e);
  }
 finally {
    try {
      if (rs != null) {
        rs.close();
      }
      stmt.close();
    }
 catch (    SQLException e) {
      throw new IOException(e);
    }
  }
}",0.9906103286384976
38753,"protected Set<T> realFind(Map fieldsMap) throws IOException {
  Set<T> foundSet=new HashSet<T>();
  if (fieldsMap == null || fieldsMap.isEmpty()) {
    return foundSet;
  }
  for (  T t : records.values()) {
    for (    Map.Entry<Enum,Object> e : ((Map<Enum,Object>)fieldsMap).entrySet()) {
      if (t.getField(e.getKey().name()).equals(e.getValue())) {
        foundSet.add(t);
      }
    }
  }
  return foundSet;
}","protected Set<T> realFind(Map fieldsMap) throws IOException {
  Set<T> foundSet=new HashSet<T>();
  if (fieldsMap == null || fieldsMap.isEmpty()) {
    return foundSet;
  }
  for (  T t : records.values()) {
    for (    Map.Entry<Enum,Object> e : ((Map<Enum,Object>)fieldsMap).entrySet()) {
      if (e.getValue().equals(t.getField(e.getKey().name()))) {
        foundSet.add(t);
      }
    }
  }
  return foundSet;
}",0.9498806682577564
38754,"public Set<Comment> find(Map<Enum,Object> fieldsMap) throws IOException {
  return super.realFind(fieldsMap);
}","public Set<Comment> find(Map<Enum,Object> fieldsMap) throws IOException {
  Set<Comment> foundSet=new HashSet<Comment>();
  EnumSet<Comment._Fields> dateTimeFields=EnumSet.of(Comment._Fields.created_at);
  if (fieldsMap == null || fieldsMap.isEmpty()) {
    return foundSet;
  }
  StringBuilder statementString=new StringBuilder();
  statementString.append(""String_Node_Str"");
  statementString.append(""String_Node_Str"");
  statementString.append(""String_Node_Str"");
  Iterator<Map.Entry<Enum,Object>> iter=fieldsMap.entrySet().iterator();
  while (iter.hasNext()) {
    Map.Entry<Enum,Object> entry=iter.next();
    Enum field=entry.getKey();
    String queryValue=entry.getValue().toString();
    if (dateTimeFields.contains(field)) {
      queryValue=new Timestamp((Long)entry.getValue()).toString();
    }
    statementString.append(field + ""String_Node_Str"" + queryValue+ ""String_Node_Str"");
    if (iter.hasNext()) {
      statementString.append(""String_Node_Str"");
    }
  }
  statementString.append(""String_Node_Str"");
  executeQuery(foundSet,statementString);
  return foundSet;
}",0.1483333333333333
38755,"public Set<Image> find(Map<Enum,Object> fieldsMap) throws IOException {
  return super.realFind(fieldsMap);
}","public Set<Image> find(Map<Enum,Object> fieldsMap) throws IOException {
  Set<Image> foundSet=new HashSet<Image>();
  if (fieldsMap == null || fieldsMap.isEmpty()) {
    return foundSet;
  }
  StringBuilder statementString=new StringBuilder();
  statementString.append(""String_Node_Str"");
  statementString.append(""String_Node_Str"");
  statementString.append(""String_Node_Str"");
  Iterator<Map.Entry<Enum,Object>> iter=fieldsMap.entrySet().iterator();
  while (iter.hasNext()) {
    Map.Entry<Enum,Object> entry=iter.next();
    Enum field=entry.getKey();
    String queryValue=entry.getValue().toString();
    statementString.append(field + ""String_Node_Str"" + queryValue+ ""String_Node_Str"");
    if (iter.hasNext()) {
      statementString.append(""String_Node_Str"");
    }
  }
  statementString.append(""String_Node_Str"");
  executeQuery(foundSet,statementString);
  return foundSet;
}",0.1708542713567839
38756,"public Set<Post> find(Map<Enum,Object> fieldsMap) throws IOException {
  return super.realFind(fieldsMap);
}","public Set<Post> find(Map<Enum,Object> fieldsMap) throws IOException {
  Set<Post> foundSet=new HashSet<Post>();
  EnumSet<Post._Fields> dateFields=EnumSet.of(Post._Fields.posted_at_millis);
  if (fieldsMap == null || fieldsMap.isEmpty()) {
    return foundSet;
  }
  StringBuilder statementString=new StringBuilder();
  statementString.append(""String_Node_Str"");
  statementString.append(""String_Node_Str"");
  statementString.append(""String_Node_Str"");
  Iterator<Map.Entry<Enum,Object>> iter=fieldsMap.entrySet().iterator();
  while (iter.hasNext()) {
    Map.Entry<Enum,Object> entry=iter.next();
    Enum field=entry.getKey();
    String queryValue=entry.getValue().toString();
    if (dateFields.contains(field)) {
      queryValue=new Date((Long)entry.getValue()).toString();
    }
    statementString.append(field + ""String_Node_Str"" + queryValue+ ""String_Node_Str"");
    if (iter.hasNext()) {
      statementString.append(""String_Node_Str"");
    }
  }
  statementString.append(""String_Node_Str"");
  executeQuery(foundSet,statementString);
  return foundSet;
}",0.1463829787234042
38757,"public Set<User> find(Map<Enum,Object> fieldsMap) throws IOException {
  return super.realFind(fieldsMap);
}","public Set<User> find(Map<Enum,Object> fieldsMap) throws IOException {
  Set<User> foundSet=new HashSet<User>();
  EnumSet<User._Fields> dateFields=EnumSet.of(User._Fields.some_date);
  EnumSet<User._Fields> dateTimeFields=EnumSet.of(User._Fields.some_datetime);
  if (fieldsMap == null || fieldsMap.isEmpty()) {
    return foundSet;
  }
  StringBuilder statementString=new StringBuilder();
  statementString.append(""String_Node_Str"");
  statementString.append(""String_Node_Str"");
  statementString.append(""String_Node_Str"");
  Iterator<Map.Entry<Enum,Object>> iter=fieldsMap.entrySet().iterator();
  while (iter.hasNext()) {
    Map.Entry<Enum,Object> entry=iter.next();
    Enum field=entry.getKey();
    String queryValue=entry.getValue().toString();
    if (dateFields.contains(field)) {
      queryValue=new Date((Long)entry.getValue()).toString();
    }
    if (dateTimeFields.contains(field)) {
      queryValue=new Timestamp((Long)entry.getValue()).toString();
    }
    statementString.append(field + ""String_Node_Str"" + queryValue+ ""String_Node_Str"");
    if (iter.hasNext()) {
      statementString.append(""String_Node_Str"");
    }
  }
  statementString.append(""String_Node_Str"");
  executeQuery(foundSet,statementString);
  return foundSet;
}",0.1262848751835536
38758,"public Set<Comment> find(Map<Enum,Object> fieldsMap) throws IOException {
  Set<Comment> foundSet=new HashSet<Comment>();
  EnumSet<Comment._Fields> dateTimeFields=EnumSet.of(Comment._Fields.created_at);
  EnumSet<Comment._Fields> valueRequiresQuotesFields=EnumSet.of(Comment._Fields.content);
  if (fieldsMap == null || fieldsMap.isEmpty()) {
    return foundSet;
  }
  StringBuilder statementString=new StringBuilder();
  statementString.append(""String_Node_Str"");
  statementString.append(""String_Node_Str"");
  statementString.append(""String_Node_Str"");
  Iterator<Map.Entry<Enum,Object>> iter=fieldsMap.entrySet().iterator();
  while (iter.hasNext()) {
    Map.Entry<Enum,Object> entry=iter.next();
    Enum field=entry.getKey();
    Object value=entry.getValue();
    String queryValue;
    if (value != null) {
      queryValue=entry.getValue().toString();
      if (valueRequiresQuotesFields.contains(field))       queryValue=""String_Node_Str"" + queryValue + ""String_Node_Str"";
      if (dateTimeFields.contains(field)) {
        queryValue=""String_Node_Str"" + new Timestamp((Long)entry.getValue()).toString() + ""String_Node_Str"";
      }
      queryValue=""String_Node_Str"" + queryValue;
    }
 else {
      queryValue=""String_Node_Str"";
    }
    statementString.append(field + queryValue);
    if (iter.hasNext()) {
      statementString.append(""String_Node_Str"");
    }
  }
  statementString.append(""String_Node_Str"");
  System.out.println(statementString);
  executeQuery(foundSet,statementString);
  return foundSet;
}","public Set<Comment> find(Map<Enum,Object> fieldsMap) throws IOException {
  Set<Comment> foundSet=new HashSet<Comment>();
  EnumSet<Comment._Fields> dateTimeFields=EnumSet.of(Comment._Fields.created_at);
  EnumSet<Comment._Fields> valueRequiresQuotesFields=EnumSet.of(Comment._Fields.content);
  if (fieldsMap == null || fieldsMap.isEmpty()) {
    return foundSet;
  }
  StringBuilder statementString=new StringBuilder();
  statementString.append(""String_Node_Str"");
  statementString.append(""String_Node_Str"");
  statementString.append(""String_Node_Str"");
  Iterator<Map.Entry<Enum,Object>> iter=fieldsMap.entrySet().iterator();
  while (iter.hasNext()) {
    Map.Entry<Enum,Object> entry=iter.next();
    Enum field=entry.getKey();
    Object value=entry.getValue();
    String queryValue;
    if (value != null) {
      queryValue=entry.getValue().toString();
      if (valueRequiresQuotesFields.contains(field))       queryValue=""String_Node_Str"" + queryValue + ""String_Node_Str"";
      if (dateTimeFields.contains(field)) {
        queryValue=""String_Node_Str"" + new Timestamp((Long)entry.getValue()).toString() + ""String_Node_Str"";
      }
      queryValue=""String_Node_Str"" + queryValue;
    }
 else {
      queryValue=""String_Node_Str"";
    }
    statementString.append(field + queryValue);
    if (iter.hasNext()) {
      statementString.append(""String_Node_Str"");
    }
  }
  statementString.append(""String_Node_Str"");
  executeQuery(foundSet,statementString);
  return foundSet;
}",0.987090367428004
38759,"public Set<Image> find(Map<Enum,Object> fieldsMap) throws IOException {
  Set<Image> foundSet=new HashSet<Image>();
  if (fieldsMap == null || fieldsMap.isEmpty()) {
    return foundSet;
  }
  StringBuilder statementString=new StringBuilder();
  statementString.append(""String_Node_Str"");
  statementString.append(""String_Node_Str"");
  statementString.append(""String_Node_Str"");
  Iterator<Map.Entry<Enum,Object>> iter=fieldsMap.entrySet().iterator();
  while (iter.hasNext()) {
    Map.Entry<Enum,Object> entry=iter.next();
    Enum field=entry.getKey();
    Object value=entry.getValue();
    String queryValue;
    if (value != null) {
      queryValue=entry.getValue().toString();
    }
 else {
      queryValue=""String_Node_Str"";
    }
    statementString.append(field + queryValue);
    if (iter.hasNext()) {
      statementString.append(""String_Node_Str"");
    }
  }
  statementString.append(""String_Node_Str"");
  System.out.println(statementString);
  executeQuery(foundSet,statementString);
  return foundSet;
}","public Set<Image> find(Map<Enum,Object> fieldsMap) throws IOException {
  Set<Image> foundSet=new HashSet<Image>();
  if (fieldsMap == null || fieldsMap.isEmpty()) {
    return foundSet;
  }
  StringBuilder statementString=new StringBuilder();
  statementString.append(""String_Node_Str"");
  statementString.append(""String_Node_Str"");
  statementString.append(""String_Node_Str"");
  Iterator<Map.Entry<Enum,Object>> iter=fieldsMap.entrySet().iterator();
  while (iter.hasNext()) {
    Map.Entry<Enum,Object> entry=iter.next();
    Enum field=entry.getKey();
    Object value=entry.getValue();
    String queryValue;
    if (value != null) {
      queryValue=entry.getValue().toString();
      queryValue=""String_Node_Str"" + queryValue;
    }
 else {
      queryValue=""String_Node_Str"";
    }
    statementString.append(field + queryValue);
    if (iter.hasNext()) {
      statementString.append(""String_Node_Str"");
    }
  }
  statementString.append(""String_Node_Str"");
  executeQuery(foundSet,statementString);
  return foundSet;
}",0.9570731707317072
38760,"public Set<Post> find(Map<Enum,Object> fieldsMap) throws IOException {
  Set<Post> foundSet=new HashSet<Post>();
  EnumSet<Post._Fields> dateFields=EnumSet.of(Post._Fields.posted_at_millis);
  EnumSet<Post._Fields> valueRequiresQuotesFields=EnumSet.of(Post._Fields.title);
  if (fieldsMap == null || fieldsMap.isEmpty()) {
    return foundSet;
  }
  StringBuilder statementString=new StringBuilder();
  statementString.append(""String_Node_Str"");
  statementString.append(""String_Node_Str"");
  statementString.append(""String_Node_Str"");
  Iterator<Map.Entry<Enum,Object>> iter=fieldsMap.entrySet().iterator();
  while (iter.hasNext()) {
    Map.Entry<Enum,Object> entry=iter.next();
    Enum field=entry.getKey();
    Object value=entry.getValue();
    String queryValue;
    if (value != null) {
      queryValue=entry.getValue().toString();
      if (valueRequiresQuotesFields.contains(field))       queryValue=""String_Node_Str"" + queryValue + ""String_Node_Str"";
      if (dateFields.contains(field)) {
        queryValue=""String_Node_Str"" + new Date((Long)entry.getValue()).toString() + ""String_Node_Str"";
      }
    }
 else {
      queryValue=""String_Node_Str"";
    }
    statementString.append(field + queryValue);
    if (iter.hasNext()) {
      statementString.append(""String_Node_Str"");
    }
  }
  statementString.append(""String_Node_Str"");
  System.out.println(statementString);
  executeQuery(foundSet,statementString);
  return foundSet;
}","public Set<Post> find(Map<Enum,Object> fieldsMap) throws IOException {
  Set<Post> foundSet=new HashSet<Post>();
  EnumSet<Post._Fields> dateFields=EnumSet.of(Post._Fields.posted_at_millis);
  EnumSet<Post._Fields> valueRequiresQuotesFields=EnumSet.of(Post._Fields.title);
  if (fieldsMap == null || fieldsMap.isEmpty()) {
    return foundSet;
  }
  StringBuilder statementString=new StringBuilder();
  statementString.append(""String_Node_Str"");
  statementString.append(""String_Node_Str"");
  statementString.append(""String_Node_Str"");
  Iterator<Map.Entry<Enum,Object>> iter=fieldsMap.entrySet().iterator();
  while (iter.hasNext()) {
    Map.Entry<Enum,Object> entry=iter.next();
    Enum field=entry.getKey();
    Object value=entry.getValue();
    String queryValue;
    if (value != null) {
      queryValue=entry.getValue().toString();
      if (valueRequiresQuotesFields.contains(field))       queryValue=""String_Node_Str"" + queryValue + ""String_Node_Str"";
      if (dateFields.contains(field)) {
        queryValue=""String_Node_Str"" + new Date((Long)entry.getValue()).toString() + ""String_Node_Str"";
      }
      queryValue=""String_Node_Str"" + queryValue;
    }
 else {
      queryValue=""String_Node_Str"";
    }
    statementString.append(field + queryValue);
    if (iter.hasNext()) {
      statementString.append(""String_Node_Str"");
    }
  }
  statementString.append(""String_Node_Str"");
  executeQuery(foundSet,statementString);
  return foundSet;
}",0.9697802197802198
38761,"protected Set<T> realFind(Set<Integer> ids,Map fieldsMap) throws IOException {
  Set<T> foundSet=new HashSet<T>();
  if (fieldsMap == null || fieldsMap.isEmpty()) {
    return foundSet;
  }
  for (  T record : records.values()) {
    boolean allMatch=true;
    for (    Map.Entry<Enum,Object> e : ((Map<Enum,Object>)fieldsMap).entrySet()) {
      Object searchedForValue=e.getValue();
      Object existingValue=record.getField(e.getKey().name());
      if (ids != null && !ids.contains(record.getId())) {
        allMatch=false;
      }
      if (existingValue == null) {
        if (searchedForValue != null)         allMatch=false;
      }
 else       if (!existingValue.equals(searchedForValue)) {
        allMatch=false;
      }
      if (allMatch)       foundSet.add(record);
    }
  }
  return foundSet;
}","protected Set<T> realFind(Set<Integer> ids,Map fieldsMap) throws IOException {
  Set<T> foundSet=new HashSet<T>();
  if (fieldsMap == null || fieldsMap.isEmpty()) {
    return foundSet;
  }
  for (  T record : records.values()) {
    boolean allMatch=true;
    for (    Map.Entry<Enum,Object> e : ((Map<Enum,Object>)fieldsMap).entrySet()) {
      Object searchedForValue=e.getValue();
      Object existingValue=record.getField(e.getKey().name());
      if (ids != null && !ids.contains(record.getId())) {
        allMatch=false;
      }
      if (existingValue == null) {
        if (searchedForValue != null)         allMatch=false;
      }
 else       if (!existingValue.equals(searchedForValue)) {
        allMatch=false;
      }
    }
    if (allMatch)     foundSet.add(record);
  }
  return foundSet;
}",0.9530864197530864
38762,"public User(User other){
  super(other.getId());
  this.__handle=other.getHandle();
  this.__created_at_millis=other.getCreatedAtMillis();
  this.__num_posts=other.getNumPosts();
  this.__some_date=other.getSomeDate();
  this.__some_datetime=other.getSomeDatetime();
  this.__bio=other.getBio();
  this.__some_binary=other.getSomeBinary();
  this.__some_float=other.getSomeFloat();
  this.__some_boolean=other.isSomeBoolean();
}","public User(User other){
  super(other.getId());
  this.__handle=other.getHandle();
  this.__created_at_millis=other.getCreatedAtMillis();
  this.__num_posts=other.getNumPosts();
  this.__some_date=other.getSomeDate();
  this.__some_datetime=other.getSomeDatetime();
  this.__bio=other.getBio();
  this.__some_binary=copyBinary(other.getSomeBinary());
  this.__some_float=other.getSomeFloat();
  this.__some_boolean=other.isSomeBoolean();
}",0.9861751152073732
38763,"public DatabasesImpl(){
  Map env_info;
  try {
    env_info=(Map)YAML.load(new FileReader(""String_Node_Str""));
  }
 catch (  FileNotFoundException e) {
    throw new RuntimeException(e);
  }
  Boolean use_mock=(Boolean)env_info.get(""String_Node_Str"");
  if (use_mock != null && use_mock) {
    this.database1=new MockDatabase1Impl(this);
  }
 else {
    this.database1=new Database1Impl(new DatabaseConnection(""String_Node_Str""),this);
  }
}","public DatabasesImpl(){
  Map env_info;
  try {
    env_info=(Map)YAML.load(new FileReader(""String_Node_Str""));
  }
 catch (  FileNotFoundException e) {
    throw new RuntimeException(e);
  }
  Boolean use_mock=(Boolean)env_info.get(""String_Node_Str"");
  if (use_mock != null && use_mock) {
    this.database1=mockDatabases.getDatabase1();
  }
 else {
    this.database1=new Database1Impl(new DatabaseConnection(""String_Node_Str""),this);
  }
}",0.7661016949152543
38764,"public Set<T> find(Set<Integer> ids) throws IOException {
  Set<T> foundSet=new HashSet<T>();
  Set<Integer> notCachedIds=new HashSet<Integer>();
  for (  Integer id : ids) {
    T model=cachedById.get(id);
    if (model != null) {
      foundSet.add(model);
    }
 else {
      notCachedIds.add(id);
    }
  }
  if (!notCachedIds.isEmpty()) {
    StringBuilder statementString=new StringBuilder();
    statementString.append(""String_Node_Str"");
    statementString.append(tableName);
    statementString.append(""String_Node_Str"");
    Iterator<Integer> iter=notCachedIds.iterator();
    while (iter.hasNext()) {
      Integer obj=iter.next();
      statementString.append(obj.toString());
      if (iter.hasNext()) {
        statementString.append(""String_Node_Str"");
      }
    }
    statementString.append(""String_Node_Str"");
    PreparedStatement stmt=conn.getPreparedStatement(""String_Node_Str"" + tableName + ""String_Node_Str""+ ""String_Node_Str"");
    ResultSet rs=null;
    try {
      rs=stmt.executeQuery();
      while (rs.next()) {
        T inst=instanceFromResultSet(rs);
        cachedById.put(inst.getId(),inst);
        foundSet.add(inst);
      }
    }
 catch (    SQLException e) {
      throw new IOException(e);
    }
 finally {
      try {
        if (rs != null) {
          rs.close();
        }
        stmt.close();
      }
 catch (      SQLException e) {
        throw new IOException(e);
      }
    }
  }
  return foundSet;
}","public Set<T> find(Set<Integer> ids) throws IOException {
  Set<T> foundSet=new HashSet<T>();
  Set<Integer> notCachedIds=new HashSet<Integer>();
  for (  Integer id : ids) {
    T model=cachedById.get(id);
    if (model != null) {
      foundSet.add(model);
    }
 else {
      notCachedIds.add(id);
    }
  }
  if (!notCachedIds.isEmpty()) {
    StringBuilder statementString=new StringBuilder();
    statementString.append(""String_Node_Str"");
    statementString.append(tableName);
    statementString.append(""String_Node_Str"");
    Iterator<Integer> iter=notCachedIds.iterator();
    while (iter.hasNext()) {
      Integer obj=iter.next();
      statementString.append(obj.toString());
      if (iter.hasNext()) {
        statementString.append(""String_Node_Str"");
      }
    }
    statementString.append(""String_Node_Str"");
    PreparedStatement stmt=conn.getPreparedStatement(statementString.toString());
    ResultSet rs=null;
    try {
      rs=stmt.executeQuery();
      while (rs.next()) {
        T inst=instanceFromResultSet(rs);
        cachedById.put(inst.getId(),inst);
        foundSet.add(inst);
      }
    }
 catch (    SQLException e) {
      throw new IOException(e);
    }
 finally {
      try {
        if (rs != null) {
          rs.close();
        }
        stmt.close();
      }
 catch (      SQLException e) {
        throw new IOException(e);
      }
    }
  }
  return foundSet;
}",0.9671787709497208
38765,"public void testFindSet() throws Exception {
  IUserPersistence users=dbs.getDatabase1().users();
  long t0=System.currentTimeMillis();
  long t1=t0 + 10;
  long t2=t0 + 20;
  byte[] someBinary=new byte[]{5,4,3,2,1};
  User bryand=users.create(""String_Node_Str"",t0,5,t1,t2,""String_Node_Str"",someBinary,1.2d,true);
  User notBryand=users.create(""String_Node_Str"",t0,3,t1,t2,""String_Node_Str"",someBinary,1.2d,true);
  users.create(""String_Node_Str"",t0,0,t1,t2,""String_Node_Str"",someBinary,1.2d,true);
  Set<Integer> keysToSearch=new HashSet<Integer>();
  keysToSearch.add(bryand.getId());
  keysToSearch.add(notBryand.getId());
  Set<User> foundValues=users.find(keysToSearch);
  assertEquals(2,foundValues.size());
  Iterator<User> iter=foundValues.iterator();
  User bryand_again=null;
  User notBryand_again=null;
  while (iter.hasNext()) {
    User curUser=iter.next();
    if (curUser.getId() == bryand.getId()) {
      bryand_again=curUser;
    }
 else     if (curUser.getId() == notBryand.getId()) {
      notBryand_again=curUser;
    }
 else {
      fail(""String_Node_Str"" + curUser.getId());
    }
  }
  assertNotNull(bryand_again);
  assertNotNull(notBryand_again);
  assertEquals(bryand.getId(),bryand_again.getId());
  assertEquals(""String_Node_Str"",bryand_again.getHandle());
  assertEquals(Long.valueOf(t0),bryand_again.getCreatedAtMillis());
  assertEquals(5,bryand_again.getNumPosts());
  assertEquals(""String_Node_Str"",bryand_again.getBio());
  assertEquals(ByteBuffer.wrap(someBinary),ByteBuffer.wrap(bryand_again.getSomeBinary()));
  assertEquals(1.2,bryand_again.getSomeFloat());
  assertTrue(bryand_again.isSomeBoolean());
  assertEquals(notBryand.getId(),notBryand_again.getId());
  assertEquals(""String_Node_Str"",notBryand_again.getHandle());
  assertEquals(Long.valueOf(t0),notBryand_again.getCreatedAtMillis());
  assertEquals(3,notBryand_again.getNumPosts());
  assertEquals(""String_Node_Str"",notBryand_again.getBio());
  assertEquals(ByteBuffer.wrap(someBinary),ByteBuffer.wrap(notBryand_again.getSomeBinary()));
  assertEquals(1.2,notBryand_again.getSomeFloat());
  assertTrue(notBryand_again.isSomeBoolean());
}","public void testFindSet() throws Exception {
  IUserPersistence users=dbs.getDatabase1().users();
  long t0=System.currentTimeMillis();
  long t1=t0 + 10;
  long t2=t0 + 20;
  byte[] someBinary=new byte[]{5,4,3,2,1};
  User bryand=users.create(""String_Node_Str"",t0,5,t1,t2,""String_Node_Str"",someBinary,1.2d,true);
  User notBryand=users.create(""String_Node_Str"",t0,3,t1,t2,""String_Node_Str"",someBinary,1.2d,true);
  users.create(""String_Node_Str"",t0,0,t1,t2,""String_Node_Str"",someBinary,1.2d,true);
  users.clearCacheById(bryand.getId());
  users.clearCacheById(notBryand.getId());
  Set<Integer> keysToSearch=new HashSet<Integer>();
  keysToSearch.add(bryand.getId());
  keysToSearch.add(notBryand.getId());
  Set<User> foundValues=users.find(keysToSearch);
  assertEquals(2,foundValues.size());
  Iterator<User> iter=foundValues.iterator();
  User bryand_again=null;
  User notBryand_again=null;
  while (iter.hasNext()) {
    User curUser=iter.next();
    if (curUser.getId() == bryand.getId()) {
      bryand_again=curUser;
    }
 else     if (curUser.getId() == notBryand.getId()) {
      notBryand_again=curUser;
    }
 else {
      fail(""String_Node_Str"" + curUser.getId());
    }
  }
  assertNotNull(bryand_again);
  assertNotNull(notBryand_again);
  assertEquals(bryand.getId(),bryand_again.getId());
  assertEquals(""String_Node_Str"",bryand_again.getHandle());
  assertEquals(Long.valueOf(t0),bryand_again.getCreatedAtMillis());
  assertEquals(5,bryand_again.getNumPosts());
  assertEquals(""String_Node_Str"",bryand_again.getBio());
  assertEquals(ByteBuffer.wrap(someBinary),ByteBuffer.wrap(bryand_again.getSomeBinary()));
  assertEquals(1.2,bryand_again.getSomeFloat());
  assertTrue(bryand_again.isSomeBoolean());
  assertEquals(notBryand.getId(),notBryand_again.getId());
  assertEquals(""String_Node_Str"",notBryand_again.getHandle());
  assertEquals(Long.valueOf(t0),notBryand_again.getCreatedAtMillis());
  assertEquals(3,notBryand_again.getNumPosts());
  assertEquals(""String_Node_Str"",notBryand_again.getBio());
  assertEquals(ByteBuffer.wrap(someBinary),ByteBuffer.wrap(notBryand_again.getSomeBinary()));
  assertEquals(1.2,notBryand_again.getSomeFloat());
  assertTrue(notBryand_again.isSomeBoolean());
}",0.9809589355356734
38766,"/** 
 * Returns the type of portal that was used. <p/> This will be Legacy for MV1 style portals and Normal for Portals that use the swirly purple goo.
 * @return A {@link PortalType}
 */
public PortalType getPortalType(){
  if (this.travelAgent == null) {
    return PortalType.Legacy;
  }
  return PortalType.Legacy;
}","/** 
 * Returns the type of portal that was used. This will be Legacy for MV1 style portals and Normal for Portals that use the swirly purple goo.
 * @return A {@link PortalType}
 */
public PortalType getPortalType(){
  if (this.travelAgent == null) {
    return PortalType.Legacy;
  }
  return PortalType.Legacy;
}",0.9921259842519684
38767,"private void removeFromWorldChunkPortals(MultiverseWorld world,MVPortal portal){
  Map<Integer,Collection<MVPortal>> chunksToPortals=this.worldChunkPortals.get(world);
  PortalLocation location=portal.getLocation();
  Vector min=location.getMinimum();
  Vector max=location.getMaximum();
  int c1x=blockToChunk(min.getBlockX()), c1z=blockToChunk(min.getBlockZ());
  int c2x=blockToChunk(max.getBlockX()), c2z=blockToChunk(max.getBlockZ());
  for (int cx=c1x; cx <= c2x; cx++) {
    for (int cz=c1z; cz <= c2z; cz++) {
      Integer hashCode=hashChunk(cx,cz);
      chunksToPortals.get(hashCode).remove(portal);
    }
  }
}","private void removeFromWorldChunkPortals(MultiverseWorld world,MVPortal portal){
  Map<Integer,Collection<MVPortal>> chunksToPortals=this.worldChunkPortals.get(world);
  if (chunksToPortals == null) {
    return;
  }
  PortalLocation location=portal.getLocation();
  Vector min=location.getMinimum();
  Vector max=location.getMaximum();
  int c1x=blockToChunk(min.getBlockX()), c1z=blockToChunk(min.getBlockZ());
  int c2x=blockToChunk(max.getBlockX()), c2z=blockToChunk(max.getBlockZ());
  for (int cx=c1x; cx <= c2x; cx++) {
    for (int cz=c1z; cz <= c2z; cz++) {
      Integer hashCode=hashChunk(cx,cz);
      chunksToPortals.get(hashCode).remove(portal);
    }
  }
}",0.9621036349574632
38768,"@Override public void runCommand(CommandSender sender,List<String> args){
  if (args.size() == 1) {
    if (args.get(0).equalsIgnoreCase(""String_Node_Str"")) {
      String[] allProps=PortalConfigProperty.getAllValues().split(""String_Node_Str"");
      String currentvals=""String_Node_Str"";
      for (      String prop : allProps) {
        currentvals+=ChatColor.GREEN;
        currentvals+=prop;
        currentvals+=ChatColor.WHITE;
        currentvals+=""String_Node_Str"";
        currentvals+=ChatColor.GOLD;
        currentvals+=this.plugin.getMainConfig().get(prop,""String_Node_Str"");
        currentvals+=ChatColor.WHITE;
        currentvals+=""String_Node_Str"";
      }
      sender.sendMessage(currentvals.substring(0,currentvals.length() - 2));
      return;
    }
  }
  if (args.get(0).equalsIgnoreCase(""String_Node_Str"") || args.get(0).equalsIgnoreCase(""String_Node_Str"")) {
    if (args.size() == 1) {
      sender.sendMessage(ChatColor.AQUA + args.get(0) + ChatColor.WHITE+ ""String_Node_Str""+ ChatColor.GREEN+ this.plugin.getMainConfig().get(args.get(0).toLowerCase()));
      return;
    }
 else {
      try {
        this.plugin.getMainConfig().set(args.get(0).toLowerCase(),Integer.parseInt(args.get(1)));
      }
 catch (      NumberFormatException e) {
        sender.sendMessage(ChatColor.RED + ""String_Node_Str"" + ChatColor.AQUA+ args.get(0)+ ChatColor.WHITE+ ""String_Node_Str"");
        return;
      }
    }
  }
 else {
    PortalConfigProperty property=null;
    try {
      property=PortalConfigProperty.valueOf(args.get(0).toLowerCase());
    }
 catch (    IllegalArgumentException e) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"" + ChatColor.AQUA+ args.get(0)+ ChatColor.WHITE+ ""String_Node_Str""+ ChatColor.AQUA+ args.get(0));
      sender.sendMessage(ChatColor.GREEN + ""String_Node_Str"");
      sender.sendMessage(ConfigProperty.getAllValues());
      return;
    }
    if (property != null) {
      try {
        this.plugin.getMainConfig().set(args.get(0).toLowerCase(),Boolean.parseBoolean(args.get(1)));
      }
 catch (      Exception e) {
        sender.sendMessage(ChatColor.RED + ""String_Node_Str"" + ChatColor.AQUA+ args.get(0)+ ChatColor.WHITE+ ""String_Node_Str"");
        return;
      }
    }
  }
  if (this.plugin.saveMainConfig()) {
    sender.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + ChatColor.WHITE+ ""String_Node_Str"");
    this.plugin.loadConfig();
  }
 else {
    sender.sendMessage(ChatColor.RED + ""String_Node_Str"" + ChatColor.WHITE+ ""String_Node_Str"");
  }
}","@Override public void runCommand(CommandSender sender,List<String> args){
  if (args.size() == 1) {
    if (args.get(0).equalsIgnoreCase(""String_Node_Str"")) {
      String[] allProps=PortalConfigProperty.getAllValues().split(""String_Node_Str"");
      String currentvals=""String_Node_Str"";
      for (      String prop : allProps) {
        currentvals+=ChatColor.GREEN;
        currentvals+=prop;
        currentvals+=ChatColor.WHITE;
        currentvals+=""String_Node_Str"";
        currentvals+=ChatColor.GOLD;
        currentvals+=this.plugin.getMainConfig().get(prop,""String_Node_Str"");
        currentvals+=ChatColor.WHITE;
        currentvals+=""String_Node_Str"";
      }
      sender.sendMessage(currentvals.substring(0,currentvals.length() - 2));
      return;
    }
  }
  if (args.get(0).equalsIgnoreCase(""String_Node_Str"") || args.get(0).equalsIgnoreCase(""String_Node_Str"")) {
    if (args.size() == 1) {
      sender.sendMessage(ChatColor.AQUA + args.get(0) + ChatColor.WHITE+ ""String_Node_Str""+ ChatColor.GREEN+ this.plugin.getMainConfig().get(args.get(0).toLowerCase()));
      return;
    }
 else {
      try {
        this.plugin.getMainConfig().set(args.get(0).toLowerCase(),Integer.parseInt(args.get(1)));
      }
 catch (      NumberFormatException e) {
        sender.sendMessage(ChatColor.RED + ""String_Node_Str"" + ChatColor.AQUA+ args.get(0)+ ChatColor.WHITE+ ""String_Node_Str"");
        return;
      }
    }
  }
 else {
    PortalConfigProperty property=null;
    try {
      property=PortalConfigProperty.valueOf(args.get(0).toLowerCase());
    }
 catch (    IllegalArgumentException e) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"" + ChatColor.AQUA+ args.get(0)+ ChatColor.WHITE+ ""String_Node_Str""+ ChatColor.AQUA+ args.get(0));
      sender.sendMessage(ChatColor.GREEN + ""String_Node_Str"");
      sender.sendMessage(PortalConfigProperty.getAllValues());
      return;
    }
    if (property != null) {
      try {
        this.plugin.getMainConfig().set(args.get(0).toLowerCase(),Boolean.parseBoolean(args.get(1)));
      }
 catch (      Exception e) {
        sender.sendMessage(ChatColor.RED + ""String_Node_Str"" + ChatColor.AQUA+ args.get(0)+ ChatColor.WHITE+ ""String_Node_Str"");
        return;
      }
    }
  }
  if (this.plugin.saveMainConfig()) {
    sender.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + ChatColor.WHITE+ ""String_Node_Str"");
    this.plugin.loadConfig();
  }
 else {
    sender.sendMessage(ChatColor.RED + ""String_Node_Str"" + ChatColor.WHITE+ ""String_Node_Str"");
  }
}",0.9988146977479258
38769,"@EventHandler(priority=EventPriority.LOW) public void playerInteract(PlayerInteractEvent event){
  if (event.getAction() == Action.RIGHT_CLICK_BLOCK && event.getMaterial() == Material.FLINT_AND_STEEL) {
    this.plugin.log(Level.FINER,""String_Node_Str"" + LocationManipulation.strCoordsRaw(event.getClickedBlock().getLocation()));
    PortalPlayerSession ps=this.plugin.getPortalSession(event.getPlayer());
    Location translatedLocation=this.getTranslatedLocation(event.getClickedBlock(),event.getBlockFace());
    if (!portalManager.isPortal(translatedLocation)) {
      return;
    }
    MVPortal portal=portalManager.isPortal(event.getPlayer(),translatedLocation);
    if (event.getItem() == null) {
      return;
    }
    if (!this.plugin.getCore().getMVPerms().hasPermission(event.getPlayer(),""String_Node_Str"",true)) {
      return;
    }
    Material inHand=event.getItem().getType();
    if (portal != null) {
      this.plugin.log(Level.FINER,""String_Node_Str"");
      this.plugin.log(Level.FINER,""String_Node_Str"" + event.getClickedBlock() + ""String_Node_Str""+ event.getClickedBlock().getType());
      this.plugin.log(Level.FINER,""String_Node_Str"" + event.getPlayer().getWorld().getBlockAt(translatedLocation) + ""String_Node_Str""+ event.getPlayer().getWorld().getBlockAt(translatedLocation).getType());
      this.plugin.log(Level.FINER,""String_Node_Str"" + inHand);
      if (ps.isDebugModeOn()) {
        ps.showDebugInfo(portal);
        event.setCancelled(true);
      }
 else {
        Material fillMaterial=Material.PORTAL;
        if (translatedLocation.getWorld().getBlockAt(translatedLocation).getType() == Material.PORTAL) {
          fillMaterial=Material.AIR;
        }
        this.plugin.log(Level.FINER,""String_Node_Str"" + fillMaterial);
        event.setCancelled(this.filler.fillRegion(portal.getLocation().getRegion(),translatedLocation,fillMaterial,event.getPlayer()));
      }
    }
    return;
  }
  int itemType=this.plugin.getMainConfig().getInt(""String_Node_Str"",MultiversePortals.DEFAULT_WAND);
  if (this.plugin.getWEAPI() != null || event.getPlayer().getItemInHand().getTypeId() != itemType || !this.plugin.getCore().getMVPerms().hasPermission(event.getPlayer(),""String_Node_Str"",true)) {
    return;
  }
  if (event.getAction() == Action.LEFT_CLICK_BLOCK) {
    MultiverseWorld world=this.plugin.getCore().getMVWorldManager().getMVWorld(event.getPlayer().getWorld().getName());
    event.setCancelled(this.plugin.getPortalSession(event.getPlayer()).setLeftClickSelection(event.getClickedBlock().getLocation().toVector(),world));
  }
 else   if (event.getAction() == Action.RIGHT_CLICK_BLOCK) {
    MultiverseWorld world=this.plugin.getCore().getMVWorldManager().getMVWorld(event.getPlayer().getWorld().getName());
    event.setCancelled(this.plugin.getPortalSession(event.getPlayer()).setRightClickSelection(event.getClickedBlock().getLocation().toVector(),world));
  }
}","@EventHandler(priority=EventPriority.LOW) public void playerInteract(PlayerInteractEvent event){
  if (event.getAction() == Action.RIGHT_CLICK_BLOCK && event.getMaterial() == Material.FLINT_AND_STEEL) {
    this.plugin.log(Level.FINER,""String_Node_Str"" + this.plugin.getCore().getLocationManipulation().strCoordsRaw(event.getClickedBlock().getLocation()));
    PortalPlayerSession ps=this.plugin.getPortalSession(event.getPlayer());
    Location translatedLocation=this.getTranslatedLocation(event.getClickedBlock(),event.getBlockFace());
    if (!portalManager.isPortal(translatedLocation)) {
      return;
    }
    MVPortal portal=portalManager.isPortal(event.getPlayer(),translatedLocation);
    if (event.getItem() == null) {
      return;
    }
    if (!this.plugin.getCore().getMVPerms().hasPermission(event.getPlayer(),""String_Node_Str"",true)) {
      return;
    }
    Material inHand=event.getItem().getType();
    if (portal != null) {
      this.plugin.log(Level.FINER,""String_Node_Str"");
      this.plugin.log(Level.FINER,""String_Node_Str"" + event.getClickedBlock() + ""String_Node_Str""+ event.getClickedBlock().getType());
      this.plugin.log(Level.FINER,""String_Node_Str"" + event.getPlayer().getWorld().getBlockAt(translatedLocation) + ""String_Node_Str""+ event.getPlayer().getWorld().getBlockAt(translatedLocation).getType());
      this.plugin.log(Level.FINER,""String_Node_Str"" + inHand);
      if (ps.isDebugModeOn()) {
        ps.showDebugInfo(portal);
        event.setCancelled(true);
      }
 else {
        Material fillMaterial=Material.PORTAL;
        if (translatedLocation.getWorld().getBlockAt(translatedLocation).getType() == Material.PORTAL) {
          fillMaterial=Material.AIR;
        }
        this.plugin.log(Level.FINER,""String_Node_Str"" + fillMaterial);
        event.setCancelled(this.filler.fillRegion(portal.getLocation().getRegion(),translatedLocation,fillMaterial,event.getPlayer()));
      }
    }
    return;
  }
  int itemType=this.plugin.getMainConfig().getInt(""String_Node_Str"",MultiversePortals.DEFAULT_WAND);
  if (this.plugin.getWEAPI() != null || event.getPlayer().getItemInHand().getTypeId() != itemType || !this.plugin.getCore().getMVPerms().hasPermission(event.getPlayer(),""String_Node_Str"",true)) {
    return;
  }
  if (event.getAction() == Action.LEFT_CLICK_BLOCK) {
    MultiverseWorld world=this.plugin.getCore().getMVWorldManager().getMVWorld(event.getPlayer().getWorld().getName());
    event.setCancelled(this.plugin.getPortalSession(event.getPlayer()).setLeftClickSelection(event.getClickedBlock().getLocation().toVector(),world));
  }
 else   if (event.getAction() == Action.RIGHT_CLICK_BLOCK) {
    MultiverseWorld world=this.plugin.getCore().getMVWorldManager().getMVWorld(event.getPlayer().getWorld().getName());
    event.setCancelled(this.plugin.getPortalSession(event.getPlayer()).setRightClickSelection(event.getClickedBlock().getLocation().toVector(),world));
  }
}",0.9953838262950933
38770,"private void performTeleport(PlayerMoveEvent event,PortalPlayerSession ps,MVDestination d){
  SafeTTeleporter playerTeleporter=new SafeTTeleporter(this.plugin.getCore());
  TeleportResult result=playerTeleporter.safelyTeleport(event.getPlayer(),event.getPlayer(),d);
  if (result == TeleportResult.SUCCESS) {
    ps.playerDidTeleport(event.getTo());
    ps.setTeleportTime(new Date());
  }
}","private void performTeleport(PlayerMoveEvent event,PortalPlayerSession ps,MVDestination d){
  SafeTTeleporter playerTeleporter=this.plugin.getCore().getSafeTTeleporter();
  TeleportResult result=playerTeleporter.safelyTeleport(event.getPlayer(),event.getPlayer(),d);
  if (result == TeleportResult.SUCCESS) {
    ps.playerDidTeleport(event.getTo());
    ps.setTeleportTime(new Date());
  }
}",0.948849104859335
38771,"@EventHandler public void playerPortal(PlayerPortalEvent event){
  this.plugin.log(Level.FINER,""String_Node_Str"");
  PortalManager pm=this.plugin.getPortalManager();
  MVPortal portal=pm.isPortal(event.getPlayer(),event.getPlayer().getLocation());
  if (portal == null) {
    Location newLoc=SafeTTeleporter.findPortalBlockNextTo(event.getFrom());
    if (newLoc != null) {
      this.plugin.log(Level.FINER,""String_Node_Str"");
      portal=pm.isPortal(event.getPlayer(),newLoc);
    }
  }
  if (portal != null) {
    this.plugin.log(Level.FINER,""String_Node_Str"");
    MVDestination portalDest=portal.getDestination();
    if (portalDest != null && !(portalDest instanceof InvalidDestination)) {
      PortalPlayerSession ps=this.plugin.getPortalSession(event.getPlayer());
      if (!ps.allowTeleportViaCooldown(new Date())) {
        event.getPlayer().sendMessage(ps.getFriendlyRemainingTimeMessage());
        event.setCancelled(true);
        return;
      }
      TravelAgent agent=new MVTravelAgent(this.plugin.getCore(),portalDest,event.getPlayer());
      event.setTo(portalDest.getLocation(event.getPlayer()));
      if (portalDest.useSafeTeleporter()) {
        SafeTTeleporter teleporter=this.plugin.getCore().getTeleporter();
        event.setTo(teleporter.getSafeLocation(event.getPlayer(),portalDest));
      }
      event.setPortalTravelAgent(agent);
      event.useTravelAgent(true);
      MVPortalEvent portalEvent=new MVPortalEvent(portalDest,event.getPlayer(),agent);
      this.plugin.getServer().getPluginManager().callEvent(portalEvent);
      if (portalEvent.isCancelled()) {
        event.setCancelled(true);
        this.plugin.log(Level.FINE,""String_Node_Str"");
        return;
      }
      this.plugin.log(Level.FINE,""String_Node_Str"");
    }
 else     if (!this.plugin.getMainConfig().getBoolean(""String_Node_Str"",false)) {
      event.getPlayer().sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str""+ ChatColor.RED+ ""String_Node_Str"");
      event.setCancelled(true);
    }
  }
}","@EventHandler public void playerPortal(PlayerPortalEvent event){
  this.plugin.log(Level.FINER,""String_Node_Str"");
  PortalManager pm=this.plugin.getPortalManager();
  MVPortal portal=pm.isPortal(event.getPlayer(),event.getPlayer().getLocation());
  if (portal == null) {
    Location newLoc=this.plugin.getCore().getSafeTTeleporter().findPortalBlockNextTo(event.getFrom());
    if (newLoc != null) {
      this.plugin.log(Level.FINER,""String_Node_Str"");
      portal=pm.isPortal(event.getPlayer(),newLoc);
    }
  }
  if (portal != null) {
    this.plugin.log(Level.FINER,""String_Node_Str"");
    MVDestination portalDest=portal.getDestination();
    if (portalDest != null && !(portalDest instanceof InvalidDestination)) {
      PortalPlayerSession ps=this.plugin.getPortalSession(event.getPlayer());
      if (!ps.allowTeleportViaCooldown(new Date())) {
        event.getPlayer().sendMessage(ps.getFriendlyRemainingTimeMessage());
        event.setCancelled(true);
        return;
      }
      TravelAgent agent=new MVTravelAgent(this.plugin.getCore(),portalDest,event.getPlayer());
      event.setTo(portalDest.getLocation(event.getPlayer()));
      if (portalDest.useSafeTeleporter()) {
        SafeTTeleporter teleporter=this.plugin.getCore().getSafeTTeleporter();
        event.setTo(teleporter.getSafeLocation(event.getPlayer(),portalDest));
      }
      event.setPortalTravelAgent(agent);
      event.useTravelAgent(true);
      MVPortalEvent portalEvent=new MVPortalEvent(portalDest,event.getPlayer(),agent);
      this.plugin.getServer().getPluginManager().callEvent(portalEvent);
      if (portalEvent.isCancelled()) {
        event.setCancelled(true);
        this.plugin.log(Level.FINE,""String_Node_Str"");
        return;
      }
      this.plugin.log(Level.FINE,""String_Node_Str"");
    }
 else     if (!this.plugin.getMainConfig().getBoolean(""String_Node_Str"",false)) {
      event.getPlayer().sendMessage(""String_Node_Str"" + ChatColor.RED + ""String_Node_Str""+ ChatColor.RED+ ""String_Node_Str"");
      event.setCancelled(true);
    }
  }
}",0.992153016184404
38772,"@Override public void onPlayerTeleport(PlayerTeleportEvent event){
  this.plugin.getPortalSession(event.getPlayer()).playerDidTeleport();
  super.onPlayerTeleport(event);
}","@Override public void onPlayerTeleport(PlayerTeleportEvent event){
  PortalPlayerSession ps=this.plugin.getPortalSession(event.getPlayer());
  ps.playerDidTeleport(event.getTo());
  super.onPlayerTeleport(event);
}",0.8911917098445595
38773,"@Override public void onPlayerMove(PlayerMoveEvent event){
  Player p=event.getPlayer();
  Location loc=p.getLocation();
  PortalPlayerSession ps=this.plugin.getPortalSession(event.getPlayer());
  ps.setStaleLocation(loc);
  if (ps.isStaleLocation()) {
    return;
  }
  MVPortal portal=ps.getStandingInPortal();
  if (portal != null && ps.doTeleportPlayer() && !this.showDebugInfo(event.getPlayer(),portal)) {
    Destination d=portal.getDestination();
    Location l=d.getLocation();
    Vector v=event.getPlayer().getVelocity();
    System.out.print(""String_Node_Str"" + v.toString());
    System.out.print(""String_Node_Str"" + event.getPlayer().getFallDistance());
    event.getPlayer().setFallDistance(0);
    if (d instanceof InvalidDestination) {
      System.out.print(""String_Node_Str"");
      return;
    }
    ps.playerDidTeleport();
    event.getPlayer().teleport(l);
  }
}","@Override public void onPlayerMove(PlayerMoveEvent event){
  Player p=event.getPlayer();
  Location loc=p.getLocation();
  PortalPlayerSession ps=this.plugin.getPortalSession(event.getPlayer());
  ps.setStaleLocation(loc,Type.PLAYER_MOVE);
  if (ps.isStaleLocation()) {
    return;
  }
  MVPortal portal=ps.getStandingInPortal();
  if (portal != null && ps.doTeleportPlayer(Type.PLAYER_MOVE) && !ps.showDebugInfo()) {
    Destination d=portal.getDestination();
    if (d == null) {
      return;
    }
    Location l=d.getLocation();
    event.getPlayer().setFallDistance(0);
    if (d instanceof InvalidDestination) {
      return;
    }
    ps.playerDidTeleport(event.getTo());
    event.getPlayer().teleport(l);
  }
}",0.5876481597005615
38774,"private boolean teleportVehicle(Vehicle v,Player p){
  MVPortal portal=this.plugin.getPortalManager().isPortal(p,v.getLocation());
  if (portal != null) {
    System.out.print(""String_Node_Str"");
    Destination d=portal.getDestination();
    Location l=d.getLocation();
    Vector vec=p.getVelocity();
    System.out.print(""String_Node_Str"" + vec.toString());
    System.out.print(""String_Node_Str"" + p.getFallDistance());
    p.setFallDistance(0);
    if (d instanceof InvalidDestination) {
      System.out.print(""String_Node_Str"");
      return false;
    }
    v.teleport(l);
    return true;
  }
  return false;
}","private boolean teleportVehicle(Player p,Vehicle v,Location to){
  PortalPlayerSession ps=this.plugin.getPortalSession(p);
  MVPortal portal=ps.getStandingInPortal();
  if (portal != null && ps.doTeleportPlayer(Type.VEHICLE_MOVE) && !ps.showDebugInfo()) {
    Destination d=portal.getDestination();
    if (d == null) {
      return false;
    }
    Location l=d.getLocation();
    p.setFallDistance(0);
    if (d instanceof InvalidDestination) {
      return false;
    }
    ps.playerDidTeleport(l);
    v.teleport(l);
    return true;
  }
  return false;
}",0.1494057724957555
38775,"@Override public void onVehicleMove(VehicleMoveEvent event){
  if (event.getVehicle().getPassenger() instanceof Player) {
    System.out.print(""String_Node_Str"");
    Vehicle v=event.getVehicle();
    Player p=(Player)v.getPassenger();
    teleportVehicle(v,p);
  }
}","@Override public void onVehicleMove(VehicleMoveEvent event){
  if (event.getVehicle().getPassenger() instanceof Player) {
    Vehicle v=event.getVehicle();
    Player p=(Player)v.getPassenger();
    PortalPlayerSession ps=this.plugin.getPortalSession(p);
    ps.setStaleLocation(v.getLocation(),Type.VEHICLE_MOVE);
    if (ps.isStaleLocation()) {
      return;
    }
    teleportVehicle(p,v,event.getTo());
  }
}",0.406480117820324
38776,"public boolean setDestination(String destinationString){
  this.destination=this.plugin.getCore().getDestinationFactory().getDestination(destinationString);
  if (this.destination instanceof InvalidDestination) {
    this.plugin.getCore().log(Level.WARNING,""String_Node_Str"" + this.name + ""String_Node_Str"");
    return false;
  }
  this.config.setProperty(this.portalConfigString + ""String_Node_Str"",this.destination.toString());
  this.config.save();
  return true;
}","public boolean setDestination(String destinationString){
  this.plugin.getCore().log(Level.WARNING,destinationString);
  this.destination=this.plugin.getCore().getDestinationFactory().getDestination(destinationString);
  if (this.destination instanceof InvalidDestination) {
    this.plugin.getCore().log(Level.WARNING,""String_Node_Str"" + this.name + ""String_Node_Str"");
    return false;
  }
  this.config.setProperty(this.portalConfigString + ""String_Node_Str"",this.destination.toString());
  this.config.save();
  return true;
}",0.622
38777,"public MVPortal(MultiversePortals instance,String name,String owner,PortalLocation location){
  this(instance,name);
  this.setOwner(owner);
  this.setPortalLocation(location);
  System.out.print(this.plugin.getServer().getPluginManager().getPermission(""String_Node_Str"" + this.getName()));
}","public MVPortal(MultiversePortals instance,String name,String owner,PortalLocation location){
  this(instance,name);
  this.setOwner(owner);
  this.setPortalLocation(location);
}",0.7574468085106383
38778,"public static MVPortal loadMVPortalFromConfig(MultiversePortals instance,String name){
  MVPortal portal=new MVPortal(instance,name);
  portal.setDestination(portal.config.getString(portal.portalConfigString + ""String_Node_Str"",""String_Node_Str""));
  String portalLocString=portal.config.getString(portal.portalConfigString + ""String_Node_Str"",""String_Node_Str"");
  String worldString=portal.config.getString(portal.portalConfigString + ""String_Node_Str"",""String_Node_Str"");
  portal.setPortalLocation(portalLocString,worldString);
  portal.setOwner(portal.config.getString(portal.portalConfigString + ""String_Node_Str"",""String_Node_Str""));
  return portal;
}","public static MVPortal loadMVPortalFromConfig(MultiversePortals instance,String name){
  MVPortal portal=new MVPortal(instance,name);
  String portalLocString=portal.config.getString(portal.portalConfigString + ""String_Node_Str"",""String_Node_Str"");
  String worldString=portal.config.getString(portal.portalConfigString + ""String_Node_Str"",""String_Node_Str"");
  portal.setPortalLocation(portalLocString,worldString);
  portal.setOwner(portal.config.getString(portal.portalConfigString + ""String_Node_Str"",""String_Node_Str""));
  return portal;
}",0.9044056525353285
38779,"private void loadPortals(){
  this.MVPconfig=new Configuration(new File(getDataFolder(),""String_Node_Str""));
  this.MVPconfig.load();
  List<String> keys=this.MVPconfig.getKeys(""String_Node_Str"");
  if (keys != null) {
    for (    String pname : keys) {
      this.portalManager.addPortal(MVPortal.loadMVPortalFromConfig(this,pname));
    }
  }
}","private void loadPortals(){
  this.MVPconfig=new Configuration(new File(getDataFolder(),""String_Node_Str""));
  this.MVPconfig.load();
  List<String> keys=this.MVPconfig.getKeys(""String_Node_Str"");
  if (keys != null) {
    for (    String pname : keys) {
      this.portalManager.addPortal(MVPortal.loadMVPortalFromConfig(this,pname));
    }
  }
  for (  MVPortal portal : this.portalManager.getAllPortals()) {
    String dest=this.MVPconfig.getString(""String_Node_Str"" + portal.getName() + ""String_Node_Str"",""String_Node_Str"");
    if (dest != ""String_Node_Str"") {
      portal.setDestination(dest);
    }
  }
}",0.7236704900938478
38780,"/** 
 * This method should be called every time a player telports to a portal.
 */
public void playerDidTeleport(){
  this.hasMovedOutOfPortal=false;
}","/** 
 * This method should be called every time a player telports to a portal.
 * @param location
 */
public void playerDidTeleport(Location location){
  PortalManager pm=this.plugin.getPortalManager();
  if (pm.isPortal(this.player,location) != null) {
    this.hasMovedOutOfPortal=false;
    return;
  }
  this.hasMovedOutOfPortal=true;
}",0.615071283095723
38781,"public void setStaleLocation(Location loc){
  if (this.getLocation().getBlockX() == loc.getBlockX() && this.getLocation().getBlockY() == loc.getBlockY() && this.getLocation().getBlockZ() == loc.getBlockZ()) {
    this.setStaleLocation(true);
  }
 else {
    this.setLocation(loc);
    this.setStaleLocation(false);
  }
}","public void setStaleLocation(Location loc,Type moveType){
  if (this.player.isInsideVehicle() && moveType != Type.VEHICLE_MOVE) {
    return;
  }
  if (this.getLocation().getBlockX() == loc.getBlockX() && this.getLocation().getBlockY() == loc.getBlockY() && this.getLocation().getBlockZ() == loc.getBlockZ()) {
    this.setStaleLocation(true);
  }
 else {
    this.setLocation(loc);
    this.setStaleLocation(false);
  }
}",0.862533692722372
38782,"public boolean doTeleportPlayer(){
  return this.hasMovedOutOfPortal == true && this.standingIn != null;
}","public boolean doTeleportPlayer(Type eventType){
  if (eventType == Type.PLAYER_MOVE && this.player.isInsideVehicle()) {
    return false;
  }
  return this.hasMovedOutOfPortal == true && this.standingIn != null;
}",0.6625
38783,"@Override public void onPlayerMove(PlayerMoveEvent event){
  MVPlayerSession ps=this.plugin.core.getPlayerSession(event.getPlayer());
  if (ps != null && ps.isStaleLocation()) {
    return;
  }
  MVPortal portal=this.plugin.getPortalUtils().isPortal(event.getPlayer(),event.getTo());
  if (portal != null) {
    System.out.print(""String_Node_Str"" + portal);
    Destination d=portal.getDestination();
    Location l=null;
    if (d.getType() == DestinationType.World) {
      if (this.plugin.core.isMVWorld(d.getName())) {
        MVWorld w=this.plugin.core.getMVWorld(d.getName());
        l=w.getCBWorld().getSpawnLocation();
      }
 else       if (this.plugin.getServer().getWorld(d.getName()) != null) {
        l=this.plugin.getServer().getWorld(d.getName()).getSpawnLocation();
      }
    }
 else     if (d.getType() == DestinationType.Portal) {
    }
    if (l == null) {
      return;
    }
    event.getPlayer().teleport(l);
  }
}","@Override public void onPlayerMove(PlayerMoveEvent event){
  MVPlayerSession ps=this.plugin.core.getPlayerSession(event.getPlayer());
  if (ps != null && ps.isStaleLocation()) {
    return;
  }
  MVPortal portal=this.plugin.getPortalUtils().isPortal(event.getPlayer(),event.getTo());
  if (portal != null && !this.showDebugInfo(event.getPlayer(),portal)) {
    Destination d=portal.getDestination();
    Location l=null;
    if (d.getType() == DestinationType.World) {
      if (this.plugin.core.isMVWorld(d.getName())) {
        MVWorld w=this.plugin.core.getMVWorld(d.getName());
        l=w.getCBWorld().getSpawnLocation();
      }
 else       if (this.plugin.getServer().getWorld(d.getName()) != null) {
        l=this.plugin.getServer().getWorld(d.getName()).getSpawnLocation();
      }
    }
 else     if (d.getType() == DestinationType.Portal) {
    }
 else     if (d.getType() == DestinationType.Exact) {
    }
    if (l == null) {
      return;
    }
    event.getPlayer().teleport(l);
  }
}",0.9088098918083464
38784,"private boolean setDestination(String destinationString){
  this.destination=Destination.parseDestination(destinationString,this.plugin.core);
  if (this.destination.getType() == DestinationType.Invalid) {
    this.plugin.core.log(Level.WARNING,""String_Node_Str"" + ChatColor.RED + this.name+ ChatColor.WHITE+ ""String_Node_Str"");
    return false;
  }
  this.config.setProperty(this.portalConfigString + ""String_Node_Str"",this.destination.toString());
  this.config.save();
  return true;
}","public boolean setDestination(String destinationString){
  this.destination=Destination.parseDestination(destinationString,this.plugin.core);
  if (this.destination.getType() == DestinationType.Invalid) {
    this.plugin.core.log(Level.WARNING,""String_Node_Str"" + ChatColor.RED + this.name+ ChatColor.WHITE+ ""String_Node_Str"");
    return false;
  }
  this.config.setProperty(this.portalConfigString + ""String_Node_Str"",this.destination.toString());
  this.config.save();
  return true;
}",0.9887410440122824
38785,"public void onEnable(){
  this.core=(MultiverseCore)getServer().getPluginManager().getPlugin(""String_Node_Str"");
  if (this.core == null) {
    log.info(logPrefix + ""String_Node_Str"");
    getServer().getPluginManager().disablePlugin(this);
    return;
  }
  this.portalUtils=new PortalUtils(this);
  debugLog=new DebugLog(""String_Node_Str"",getDataFolder() + File.separator + ""String_Node_Str"");
  this.pluginListener=new MVPPluginListener(this);
  this.playerListener=new MVPPlayerListener(this);
  this.getServer().getPluginManager().registerEvent(Type.PLUGIN_ENABLE,this.pluginListener,Priority.Normal,this);
  this.getServer().getPluginManager().registerEvent(Type.PLAYER_PORTAL,this.playerListener,Priority.Normal,this);
  this.getServer().getPluginManager().registerEvent(Type.PLAYER_MOVE,this.playerListener,Priority.Low,this);
  log.info(logPrefix + ""String_Node_Str"" + this.getDescription().getVersion()+ ""String_Node_Str""+ getAuthors());
  this.portals=new HashMap<String,MVPortal>();
  this.loadPortals();
  registerCommands();
}","public void onEnable(){
  this.core=(MultiverseCore)getServer().getPluginManager().getPlugin(""String_Node_Str"");
  if (this.core == null) {
    log.info(logPrefix + ""String_Node_Str"");
    getServer().getPluginManager().disablePlugin(this);
    return;
  }
  this.portalUtils=new PortalUtils(this);
  debugLog=new DebugLog(""String_Node_Str"",getDataFolder() + File.separator + ""String_Node_Str"");
  this.pluginListener=new MVPPluginListener(this);
  this.playerListener=new MVPPlayerListener(this);
  this.getServer().getPluginManager().registerEvent(Type.PLUGIN_ENABLE,this.pluginListener,Priority.Normal,this);
  this.getServer().getPluginManager().registerEvent(Type.PLAYER_PORTAL,this.playerListener,Priority.Normal,this);
  this.getServer().getPluginManager().registerEvent(Type.PLAYER_MOVE,this.playerListener,Priority.Low,this);
  log.info(logPrefix + ""String_Node_Str"" + this.getDescription().getVersion()+ ""String_Node_Str""+ getAuthors());
  this.portals=new HashMap<String,MVPortal>();
  this.loadPortals();
  registerCommands();
  this.portalSessions=new HashMap<Player,PortalPlayerSession>();
}",0.9696969696969696
38786,"/** 
 * Register commands to Multiverse's CommandHandler so we get a super sexy single menu 
 */
private void registerCommands(){
  this.commandHandler=this.core.getCommandHandler();
  this.commandHandler.registerCommand(new ListCommand(this));
  this.commandHandler.registerCommand(new CreateCommand(this));
}","/** 
 * Register commands to Multiverse's CommandHandler so we get a super sexy single menu
 */
private void registerCommands(){
  this.commandHandler=this.core.getCommandHandler();
  this.commandHandler.registerCommand(new ListCommand(this));
  this.commandHandler.registerCommand(new CreateCommand(this));
  this.commandHandler.registerCommand(new DebugCommand(this));
}",0.906158357771261
38787,"public CreateCommand(MultiversePortals plugin){
  super(plugin);
  this.commandName=""String_Node_Str"";
  this.commandDesc=""String_Node_Str"";
  this.commandUsage=""String_Node_Str"" + ChatColor.GOLD + ""String_Node_Str"";
  this.minimumArgLength=1;
  this.maximumArgLength=1;
  this.commandKeys.add(""String_Node_Str"");
  this.commandKeys.add(""String_Node_Str"");
  this.commandKeys.add(""String_Node_Str"");
  this.permission=""String_Node_Str"";
  this.opRequired=true;
}","public CreateCommand(MultiversePortals plugin){
  super(plugin);
  this.commandName=""String_Node_Str"";
  this.commandDesc=""String_Node_Str"";
  this.commandUsage=""String_Node_Str"" + ChatColor.GOLD + ""String_Node_Str"";
  this.minimumArgLength=1;
  this.maximumArgLength=2;
  this.commandKeys.add(""String_Node_Str"");
  this.commandKeys.add(""String_Node_Str"");
  this.commandKeys.add(""String_Node_Str"");
  this.permission=""String_Node_Str"";
  this.opRequired=true;
}",0.997835497835498
38788,"@Override public void runCommand(CommandSender sender,List<String> args){
  Player p=null;
  if (!(sender instanceof Player)) {
    sender.sendMessage(""String_Node_Str"");
    return;
  }
  p=(Player)sender;
  if (!((MultiversePortals)this.plugin).getCore().isMVWorld(p.getWorld().getName())) {
    ((MultiversePortals)this.plugin).getCore().showNotMVWorldMessage(sender,p.getWorld().getName());
    return;
  }
  MVWorld world=((MultiversePortals)this.plugin).getCore().getMVWorld(p.getWorld().getName());
  WorldEditAPI api=((MultiversePortals)this.plugin).getWEAPI();
  if (api == null) {
    sender.sendMessage(""String_Node_Str"");
    sender.sendMessage(""String_Node_Str"");
    return;
  }
  LocalSession s=api.getSession(p);
  Region r=null;
  try {
    r=s.getSelection(s.getSelectionWorld());
  }
 catch (  IncompleteRegionException e) {
    sender.sendMessage(""String_Node_Str"");
    return;
  }
  PortalLocation location=new PortalLocation(r.getMinimumPoint(),r.getMaximumPoint(),world);
  ((MultiversePortals)this.plugin).addPortal(world,args.get(0),p.getName(),location);
  sender.sendMessage(""String_Node_Str"");
}","@Override public void runCommand(CommandSender sender,List<String> args){
  Player p=null;
  if (!(sender instanceof Player)) {
    sender.sendMessage(""String_Node_Str"");
    return;
  }
  p=(Player)sender;
  if (!((MultiversePortals)this.plugin).getCore().isMVWorld(p.getWorld().getName())) {
    ((MultiversePortals)this.plugin).getCore().showNotMVWorldMessage(sender,p.getWorld().getName());
    return;
  }
  MVWorld world=((MultiversePortals)this.plugin).getCore().getMVWorld(p.getWorld().getName());
  WorldEditAPI api=((MultiversePortals)this.plugin).getWEAPI();
  if (api == null) {
    sender.sendMessage(""String_Node_Str"");
    sender.sendMessage(""String_Node_Str"");
    return;
  }
  LocalSession s=api.getSession(p);
  Region r=null;
  try {
    r=s.getSelection(s.getSelectionWorld());
  }
 catch (  IncompleteRegionException e) {
    sender.sendMessage(""String_Node_Str"");
    return;
  }
  MVPortal portal=((MultiversePortals)this.plugin).getPortal(args.get(0));
  PortalLocation location=new PortalLocation(r.getMinimumPoint(),r.getMaximumPoint(),world);
  if (((MultiversePortals)this.plugin).addPortal(world,args.get(0),p.getName(),location)) {
    sender.sendMessage(""String_Node_Str"" + ChatColor.DARK_AQUA + args.get(0)+ ChatColor.WHITE+ ""String_Node_Str"");
    portal=((MultiversePortals)this.plugin).getPortal(args.get(0));
  }
 else {
    sender.sendMessage(""String_Node_Str"" + ChatColor.DARK_AQUA + args.get(0)+ ChatColor.WHITE+ ""String_Node_Str"");
    sender.sendMessage(""String_Node_Str"");
  }
  ((MultiversePortals)this.plugin).getPortalSession(p).selectPortal(portal);
  if (args.size() > 1 && portal != null) {
    portal.setDestination(args.get(1));
  }
}",0.7967248131007476
38789,"@EventHandler(priority=EventPriority.MONITOR) public void onPlayerJoin(final PlayerJoinEvent event){
  Player p=event.getPlayer();
  if (p == null || !p.isOnline())   return;
  xAuthPlayer xp=plyrMngr.getPlayer(p,plugin.getConfig().getBoolean(""String_Node_Str""));
  String node=""String_Node_Str"";
  if (xp.isFixSS()) {
    plyrMngr.unprotect(xp);
    xp.setFixSS(false);
  }
  if (xp.isRegistered() || plugin.isAuthURL()) {
    if (plyrMngr.checkSession(xp)) {
      xp.setStatus(Status.Authenticated);
      plugin.getAuthClass(xp).online(p.getName());
      node=""String_Node_Str"";
    }
 else {
      xp.setStatus(Status.Registered);
      node=""String_Node_Str"";
      plyrMngr.protect(xp);
    }
  }
 else   if (plyrMngr.mustRegister(p)) {
    xp.setStatus(Status.Guest);
    node=""String_Node_Str"";
    plyrMngr.protect(xp);
  }
  if (!node.isEmpty())   sendDelayedMessage(p,node,1);
}","@EventHandler(priority=EventPriority.MONITOR) public void onPlayerJoin(final PlayerJoinEvent event){
  Player p=event.getPlayer();
  if (p == null || !p.isOnline())   return;
  xAuthPlayer xp=plyrMngr.getPlayer(p,plugin.getConfig().getBoolean(""String_Node_Str""));
  String node=""String_Node_Str"";
  boolean protect=false;
  if (xp.isFixSS()) {
    plyrMngr.unprotect(xp);
    xp.setFixSS(false);
  }
  if (xp.isRegistered() || plugin.isAuthURL()) {
    if (plyrMngr.checkSession(xp)) {
      xp.setStatus(Status.Authenticated);
      plugin.getAuthClass(xp).online(p.getName());
      node=""String_Node_Str"";
    }
 else {
      xp.setStatus(Status.Registered);
      node=""String_Node_Str"";
      protect=true;
    }
  }
 else   if (plyrMngr.mustRegister(p)) {
    xp.setStatus(Status.Guest);
    node=""String_Node_Str"";
    protect=true;
  }
  if (protect)   scheduleDelayedProtect(xp);
  if (!node.isEmpty())   sendDelayedMessage(p,node,1);
}",0.9291938997821352
38790,"private boolean checkAuthURL(String action,String... params){
  if (params.length < 2 || ((params.length % 2) != 0))   return false;
  try {
    HttpURLConnection.setFollowRedirects(false);
    HttpURLConnection uc=(HttpURLConnection)new URL(plugin.getConfig().getString(""String_Node_Str"")).openConnection();
    uc.setRequestMethod(""String_Node_Str"");
    uc.setDoInput(true);
    uc.setDoOutput(true);
    uc.setUseCaches(false);
    uc.setAllowUserInteraction(false);
    uc.setInstanceFollowRedirects(false);
    uc.setRequestProperty(""String_Node_Str"",""String_Node_Str"" + version);
    uc.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
    DataOutputStream out=new DataOutputStream(uc.getOutputStream());
    out.writeBytes(""String_Node_Str"" + version);
    writeParam(out,""String_Node_Str"",this.ipAddress);
    writeParam(out,""String_Node_Str"",action);
    for (int x=0; x < params.length; ++x)     writeParam(out,params[x],params[++x]);
    out.flush();
    out.close();
    BufferedReader in=new BufferedReader(new InputStreamReader(uc.getInputStream()));
    String line=in.readLine();
    boolean success=line != null && line.equals(""String_Node_Str"");
    response=in.readLine();
    if (plugin.getConfig().getBoolean(""String_Node_Str""))     group=in.readLine();
    in.close();
    return success;
  }
 catch (  Exception e) {
    xAuthLog.severe(""String_Node_Str"" + action,e);
    return false;
  }
}","private boolean checkAuthURL(String action,String... params){
  if (params.length < 2 || ((params.length % 2) != 0))   return false;
  try {
    HttpURLConnection uc=(HttpURLConnection)new URL(plugin.getConfig().getString(""String_Node_Str"")).openConnection();
    uc.setRequestMethod(""String_Node_Str"");
    uc.setDoInput(true);
    uc.setDoOutput(true);
    uc.setUseCaches(false);
    uc.setAllowUserInteraction(false);
    uc.setInstanceFollowRedirects(false);
    uc.setRequestProperty(""String_Node_Str"",""String_Node_Str"" + version);
    uc.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
    DataOutputStream out=new DataOutputStream(uc.getOutputStream());
    out.writeBytes(""String_Node_Str"" + version);
    writeParam(out,""String_Node_Str"",this.ipAddress);
    writeParam(out,""String_Node_Str"",action);
    for (int x=0; x < params.length; ++x)     writeParam(out,params[x],params[++x]);
    out.flush();
    out.close();
    BufferedReader in=new BufferedReader(new InputStreamReader(uc.getInputStream()));
    String line=in.readLine();
    boolean success=line != null && line.equals(""String_Node_Str"");
    response=in.readLine();
    if (plugin.getConfig().getBoolean(""String_Node_Str""))     group=in.readLine();
    in.close();
    return success;
  }
 catch (  Exception e) {
    xAuthLog.severe(""String_Node_Str"" + action,e);
    return false;
  }
}",0.982481229889167
38791,"public boolean deleteSession(int accountId){
  Connection conn=plugin.getDbCtrl().getConnection();
  PreparedStatement ps=null;
  try {
    String sql=String.format(""String_Node_Str"",plugin.getDbCtrl().getTable(Table.SESSION));
    ps=conn.prepareStatement(sql);
    ps.setInt(1,accountId);
    ps.executeUpdate();
    return true;
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + accountId,e);
    return false;
  }
 finally {
    plugin.getDbCtrl().close(conn,ps);
  }
}","public boolean deleteSession(int accountId){
  if (!plugin.getDbCtrl().isTableActive(Table.SESSION))   return true;
  Connection conn=plugin.getDbCtrl().getConnection();
  PreparedStatement ps=null;
  try {
    String sql=String.format(""String_Node_Str"",plugin.getDbCtrl().getTable(Table.SESSION));
    ps=conn.prepareStatement(sql);
    ps.setInt(1,accountId);
    ps.executeUpdate();
    return true;
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + accountId,e);
    return false;
  }
 finally {
    plugin.getDbCtrl().close(conn,ps);
  }
}",0.9330819981149858
38792,"public void reload(){
  loadConfiguration();
  plyrMngr.reload();
}","public void reload(){
  loadConfiguration();
}",0.8141592920353983
38793,"public String getIPAddress(){
  Player player=getPlayer();
  return player == null ? null : player.getAddress().getAddress().getHostAddress();
}","public String getIPAddress(){
  Player player=getPlayer();
  if (player == null)   return null;
  try {
    return player.getAddress().getAddress().getHostAddress();
  }
 catch (  NullPointerException e) {
    return null;
  }
}",0.6881720430107527
38794,"public Connection getConnection(){
  try {
    return connPool.leaseConn();
  }
 catch (  Exception e) {
    xAuthLog.severe(""String_Node_Str"",e);
    return null;
  }
}","public Connection getConnection(){
  try {
    return connPool.leaseConn();
  }
 catch (  Exception e) {
    xAuthLog.severe(""String_Node_Str"" + getDBMS() + ""String_Node_Str"",e);
    return null;
  }
}",0.9135135135135136
38795,"public void close(){
  try {
    connPool.close();
  }
 catch (  Exception e) {
    xAuthLog.severe(""String_Node_Str"",e);
  }
}","public void close(){
  try {
    connPool.close();
  }
 catch (  Exception e) {
    xAuthLog.severe(""String_Node_Str"" + getDBMS() + ""String_Node_Str"",e);
  }
}",0.8881118881118881
38796,"public Connection leaseConn() throws SQLException {
  lock.lock();
  try {
    if (!idleConnections.isEmpty()) {
      Connection conn=idleConnections.firstElement();
      idleConnections.removeElementAt(0);
      if (!conn.isClosed()) {
        busyConnections.add(conn);
        return conn;
      }
 else {
        conn.close();
        return leaseConn();
      }
    }
    if (idleConnections.size() + busyConnections.size() >= maxConnections)     throw new SQLException(""String_Node_Str"");
    Connection conn=DriverManager.getConnection(url,user,password);
    if (!conn.isClosed()) {
      busyConnections.add(conn);
      return conn;
    }
 else {
      conn.close();
      throw new SQLException(""String_Node_Str"");
    }
  }
  finally {
    lock.unlock();
  }
}","public Connection leaseConn() throws SQLException {
  lock.lock();
  try {
    if (!idleConnections.isEmpty()) {
      Connection conn=idleConnections.firstElement();
      idleConnections.removeElementAt(0);
      if (conn.isValid(1)) {
        xAuthLog.info(""String_Node_Str"");
        busyConnections.add(conn);
        return conn;
      }
 else {
        conn.close();
        return leaseConn();
      }
    }
    if (idleConnections.size() + busyConnections.size() >= maxConnections)     throw new SQLException(""String_Node_Str"");
    Connection conn=DriverManager.getConnection(url,user,password);
    if (conn.isValid(1)) {
      busyConnections.add(conn);
      return conn;
    }
 else {
      conn.close();
      throw new SQLException(""String_Node_Str"");
    }
  }
  finally {
    lock.unlock();
  }
}",0.9370277078085644
38797,"public boolean createSession(int accountId,String ipAddress){
  Connection conn=plugin.getDbCtrl().getConnection();
  PreparedStatement ps=null;
  try {
    String sql=String.format(""String_Node_Str"",plugin.getConfig().getString(""String_Node_Str""));
    ps=conn.prepareStatement(sql);
    ps.setInt(1,accountId);
    ps.setString(2,ipAddress);
    ps.setTimestamp(3,new Timestamp(System.currentTimeMillis()));
    ps.executeUpdate();
    return true;
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + accountId,e);
    return false;
  }
 finally {
    plugin.getDbCtrl().close(conn,ps);
  }
}","public boolean createSession(int accountId,String ipAddress) throws SQLException {
  Connection conn=plugin.getDbCtrl().getConnection();
  PreparedStatement ps=null;
  try {
    String sql=String.format(""String_Node_Str"",plugin.getConfig().getString(""String_Node_Str""));
    ps=conn.prepareStatement(sql);
    ps.setInt(1,accountId);
    ps.setString(2,ipAddress);
    ps.setTimestamp(3,new Timestamp(System.currentTimeMillis()));
    ps.executeUpdate();
    return true;
  }
  finally {
    plugin.getDbCtrl().close(conn,ps);
  }
}",0.1867364746945898
38798,"public boolean mustRegister(Player player){
  return plugin.getConfig().getBoolean(""String_Node_Str"") || xPermissions.has(player,""String_Node_Str"");
}","public boolean mustRegister(Player player){
  if (plugin.getConfig().getBoolean(""String_Node_Str""))   return plugin.getConfig().getBoolean(""String_Node_Str"");
  return plugin.getConfig().getBoolean(""String_Node_Str"") || xPermissions.has(player,""String_Node_Str"");
}",0.7228915662650602
38799,"public boolean login(String user,String pass){
  if (!player.isRegistered()) {
    response=""String_Node_Str"";
    return false;
  }
 else   if (player.isAuthenticated()) {
    response=""String_Node_Str"";
    return false;
  }
 else   if (!plugin.getPwdHndlr().checkPassword(player.getAccountId(),pass)) {
    int strikes=plugin.getStrkMngr().getRecord(player.getIPAddress()).addStrike(player.getPlayerName());
    if (strikes >= plugin.getConfig().getInt(""String_Node_Str""))     plugin.getStrkMngr().strikeout(player.getPlayer());
    response=""String_Node_Str"";
    return false;
  }
 else   if (!isActive(player.getAccountId())) {
    response=""String_Node_Str"";
    return false;
  }
  Connection conn=plugin.getDbCtrl().getConnection();
  PreparedStatement ps=null;
  Timestamp currentTime=new Timestamp(System.currentTimeMillis());
  String ipAddress=player.getIPAddress();
  try {
    String sql=String.format(""String_Node_Str"",plugin.getConfig().getString(""String_Node_Str""));
    ps=conn.prepareStatement(sql);
    ps.setTimestamp(1,currentTime);
    ps.setString(2,ipAddress);
    ps.setInt(3,player.getAccountId());
    ps.executeUpdate();
    plugin.getStrkMngr().getRecord(ipAddress).clearStrikes(player.getPlayerName());
    player.setLoginTime(currentTime);
    response=""String_Node_Str"";
    return true;
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + user,e);
    try {
      conn.rollback();
    }
 catch (    SQLException ex) {
    }
    response=""String_Node_Str"";
    return false;
  }
 finally {
    plugin.getDbCtrl().close(conn,ps);
  }
}","public boolean login(String user,String pass){
  if (!player.isRegistered()) {
    response=""String_Node_Str"";
    return false;
  }
 else   if (player.isAuthenticated()) {
    response=""String_Node_Str"";
    return false;
  }
 else   if (!plugin.getPwdHndlr().checkPassword(player.getAccountId(),pass)) {
    int strikes=plugin.getStrkMngr().getRecord(player.getIPAddress()).addStrike(player.getPlayerName());
    if (strikes >= plugin.getConfig().getInt(""String_Node_Str""))     plugin.getStrkMngr().strikeout(player.getPlayer());
    response=""String_Node_Str"";
    return false;
  }
 else   if (!isActive(player.getAccountId())) {
    response=""String_Node_Str"";
    return false;
  }
  return true;
}",0.6029668411867365
38800,"private boolean execRegQuery(String user,String pass,String email,boolean admin){
  Connection conn=plugin.getDbCtrl().getConnection();
  PreparedStatement ps=null;
  ResultSet rs=null;
  try {
    String sql=String.format(""String_Node_Str"",plugin.getConfig().getString(""String_Node_Str""));
    ps=conn.prepareStatement(sql,Statement.RETURN_GENERATED_KEYS);
    ps.setString(1,user);
    ps.setString(2,plugin.getPwdHndlr().hash(pass));
    ps.setString(3,email);
    ps.setTimestamp(4,new Timestamp(System.currentTimeMillis()));
    ps.setString(5,player.getIPAddress());
    ps.executeUpdate();
    rs=ps.getGeneratedKeys();
    if (rs.next()) {
      player.setAccountId(rs.getInt(1));
      response=admin ? ""String_Node_Str"" : ""String_Node_Str"";
      player.setStatus(Status.Registered);
      return true;
    }
 else     throw new SQLException();
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + user,e);
    response=admin ? ""String_Node_Str"" : ""String_Node_Str"";
    return false;
  }
 finally {
    plugin.getDbCtrl().close(conn,ps,rs);
  }
}","private boolean execRegQuery(String user,String pass,String email,boolean admin){
  try {
    int accId=plugin.getPlyrMngr().createAccount(user,pass,email,player.getIPAddress());
    if (accId > 0) {
      player.setAccountId(accId);
      player.setStatus(Status.Registered);
      response=admin ? ""String_Node_Str"" : ""String_Node_Str"";
      return true;
    }
 else     throw new SQLException();
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + user,e);
    response=admin ? ""String_Node_Str"" : ""String_Node_Str"";
    return false;
  }
}",0.4878048780487805
38801,"public boolean onCommand(CommandSender sender,Command command,String label,String[] args){
  args=CommandLineTokenizer.tokenize(args);
  if (sender instanceof Player) {
    xAuthPlayer p=plugin.getPlyrMngr().getPlayer((Player)sender);
    if (args.length < 1) {
      plugin.getMsgHndlr().sendMessage(""String_Node_Str"",p.getPlayer());
      return true;
    }
    String playerName=p.getPlayerName();
    String password=args[0];
    Auth a=plugin.getAuthClass(p);
    boolean success=a.login(playerName,password);
    String response=a.getResponse();
    if (response != null)     plugin.getMsgHndlr().sendMessage(response,p.getPlayer());
    if (success) {
      plugin.getPlyrMngr().unprotect(p);
      if (plugin.getDbCtrl().isTableActive(Table.SESSION))       plugin.getPlyrMngr().createSession(p.getAccountId(),p.getIPAddress());
      p.setStatus(Status.Authenticated);
      plugin.getAuthClass(p).online(p.getPlayerName());
      xAuthLog.info(playerName + ""String_Node_Str"");
    }
    return true;
  }
  return false;
}","public boolean onCommand(CommandSender sender,Command command,String label,String[] args){
  args=CommandLineTokenizer.tokenize(args);
  if (sender instanceof Player) {
    xAuthPlayer p=plugin.getPlyrMngr().getPlayer((Player)sender);
    if (args.length < 1) {
      plugin.getMsgHndlr().sendMessage(""String_Node_Str"",p.getPlayer());
      return true;
    }
    String playerName=p.getPlayerName();
    String password=args[0];
    Auth a=plugin.getAuthClass(p);
    boolean passChecks=a.login(playerName,password);
    String response=a.getResponse();
    if (passChecks) {
      boolean success=plugin.getPlyrMngr().doLogin(p);
      if (success) {
        response=""String_Node_Str"";
        a.online(p.getPlayerName());
        xAuthLog.info(playerName + ""String_Node_Str"");
      }
 else       response=""String_Node_Str"";
    }
    if (response != null)     plugin.getMsgHndlr().sendMessage(response,p.getPlayer());
    return true;
  }
  return false;
}",0.5886489201406329
38802,"@EventHandler(priority=EventPriority.MONITOR) public void onPlayerJoin(final PlayerJoinEvent event){
  Player p=event.getPlayer();
  if (p == null || !p.isOnline())   return;
  xAuthPlayer xp=plyrMngr.getPlayer(p,true);
  String node=""String_Node_Str"";
  if (xp.isRegistered()) {
    if (plyrMngr.checkSession(xp)) {
      xp.setStatus(Status.Authenticated);
      plugin.getAuthClass(xp).online(p.getName());
      node=""String_Node_Str"";
    }
 else {
      node=""String_Node_Str"";
      plyrMngr.protect(xp);
    }
  }
 else   if (plyrMngr.mustRegister(p)) {
    node=""String_Node_Str"";
    plyrMngr.protect(xp);
  }
  if (!node.isEmpty())   plugin.getSchdlr().sendDelayedMessage(p,node,1);
}","@EventHandler(priority=EventPriority.MONITOR) public void onPlayerJoin(final PlayerJoinEvent event){
  Player p=event.getPlayer();
  if (p == null || !p.isOnline())   return;
  xAuthPlayer xp=plyrMngr.getPlayer(p,true);
  String node=""String_Node_Str"";
  if (xp.isRegistered() || plugin.getConfig().getBoolean(""String_Node_Str"")) {
    if (plyrMngr.checkSession(xp)) {
      xp.setStatus(Status.Authenticated);
      plugin.getAuthClass(xp).online(p.getName());
      node=""String_Node_Str"";
    }
 else {
      node=""String_Node_Str"";
      plyrMngr.protect(xp);
    }
  }
 else   if (plyrMngr.mustRegister(p)) {
    node=""String_Node_Str"";
    plyrMngr.protect(xp);
  }
  if (!node.isEmpty())   plugin.getSchdlr().sendDelayedMessage(p,node,1);
}",0.9639389736477116
38803,"@EventHandler(priority=EventPriority.MONITOR) public void onPlayerJoin(final PlayerJoinEvent event){
  Player p=event.getPlayer();
  if (p == null || !p.isOnline())   return;
  xAuthPlayer xp=plyrMngr.getPlayer(p,true);
  String node=""String_Node_Str"";
  if (xp.isRegistered()) {
    if (plyrMngr.checkSession(xp)) {
      xp.setStatus(Status.Authenticated);
      plugin.getAuthClass(xp).online(p.getName());
      node=""String_Node_Str"";
    }
 else {
      node=""String_Node_Str"";
      plyrMngr.protect(xp);
    }
  }
 else   if (plyrMngr.mustRegister(p)) {
    node=""String_Node_Str"";
    plyrMngr.protect(xp);
  }
  if (!node.isEmpty())   plugin.getSchdlr().sendDelayedMessage(p,node,1);
}","@EventHandler(priority=EventPriority.MONITOR) public void onPlayerJoin(final PlayerJoinEvent event){
  Player p=event.getPlayer();
  if (p == null || !p.isOnline())   return;
  xAuthPlayer xp=plyrMngr.getPlayer(p,true);
  String node=""String_Node_Str"";
  if (xp.isRegistered()) {
    if (plyrMngr.checkSession(xp)) {
      xp.setStatus(Status.Authenticated);
      plugin.getAuthClass(xp).online(p.getName());
      node=""String_Node_Str"";
    }
 else {
      node=""String_Node_Str"";
      plyrMngr.deleteSession(xp.getAccountId());
      plyrMngr.protect(xp);
    }
  }
 else   if (plyrMngr.mustRegister(p)) {
    node=""String_Node_Str"";
    plyrMngr.protect(xp);
  }
  if (!node.isEmpty())   plugin.getSchdlr().sendDelayedMessage(p,node,1);
}",0.965948575399583
38804,"private boolean unregisterCommand(CommandSender sender,String[] args){
  if (sender instanceof Player) {
    Player player=(Player)sender;
    if (!xAuthPermissions.has(player,""String_Node_Str"")) {
      xAuthMessages.send(""String_Node_Str"",player);
      return true;
    }
 else     if (args.length < 2) {
      xAuthMessages.send(""String_Node_Str"",player);
      return true;
    }
    String targetName=args[1];
    xAuthPlayer xPlayer=dataManager.getPlayer(targetName);
    if (!xPlayer.isRegistered()) {
      xAuthMessages.send(""String_Node_Str"",player,xPlayer.getPlayer());
      return true;
    }
    dataManager.deleteAccount(xPlayer);
    Player target=xPlayer.getPlayer();
    if (target != null) {
      plugin.createGuest(xPlayer);
      xAuthMessages.send(""String_Node_Str"",target);
    }
    xAuthMessages.send(""String_Node_Str"",player,target);
    xAuthLog.info(targetName + ""String_Node_Str"" + player.getName());
  }
 else   if (sender instanceof ConsoleCommandSender) {
    if (args.length < 2) {
      xAuthLog.info(""String_Node_Str"");
      return true;
    }
    String targetName=args[1];
    xAuthPlayer xPlayer=dataManager.getPlayer(targetName);
    if (!xPlayer.isRegistered()) {
      xAuthLog.info(targetName + ""String_Node_Str"");
      return true;
    }
    dataManager.deleteAccount(xPlayer);
    Player target=xPlayer.getPlayer();
    if (target != null) {
      plugin.createGuest(xPlayer);
      target.sendMessage(""String_Node_Str"");
    }
    xAuthLog.info(targetName + ""String_Node_Str"");
  }
  return true;
}","private boolean unregisterCommand(CommandSender sender,String[] args){
  if (sender instanceof Player) {
    Player player=(Player)sender;
    if (!xAuthPermissions.has(player,""String_Node_Str"")) {
      xAuthMessages.send(""String_Node_Str"",player);
      return true;
    }
 else     if (args.length < 2) {
      xAuthMessages.send(""String_Node_Str"",player);
      return true;
    }
    String targetName=args[1];
    xAuthPlayer xPlayer=dataManager.getPlayer(targetName);
    if (!xPlayer.isRegistered()) {
      xAuthMessages.send(""String_Node_Str"",player,xPlayer.getPlayer());
      return true;
    }
    dataManager.deleteAccount(xPlayer);
    Player target=xPlayer.getPlayer();
    if (target != null) {
      if (xPlayer.mustRegister())       plugin.createGuest(xPlayer);
      xAuthMessages.send(""String_Node_Str"",target);
    }
    xAuthMessages.send(""String_Node_Str"",player,target);
    xAuthLog.info(targetName + ""String_Node_Str"" + player.getName());
  }
 else   if (sender instanceof ConsoleCommandSender) {
    if (args.length < 2) {
      xAuthLog.info(""String_Node_Str"");
      return true;
    }
    String targetName=args[1];
    xAuthPlayer xPlayer=dataManager.getPlayer(targetName);
    if (!xPlayer.isRegistered()) {
      xAuthLog.info(targetName + ""String_Node_Str"");
      return true;
    }
    dataManager.deleteAccount(xPlayer);
    Player target=xPlayer.getPlayer();
    if (target != null) {
      if (xPlayer.mustRegister())       plugin.createGuest(xPlayer);
      target.sendMessage(""String_Node_Str"");
    }
    xAuthLog.info(targetName + ""String_Node_Str"");
  }
  return true;
}",0.978494623655914
38805,"public void loadTeleLocations(){
  try {
    rs=stmt.executeQuery(""String_Node_Str"" + ""String_Node_Str"" + xAuthSettings.tblLocation + ""String_Node_Str"");
    while (rs.next()) {
      TeleLocation teleLocation=new TeleLocation();
      teleLocation.setWorldName(rs.getString(""String_Node_Str""));
      teleLocation.setX(rs.getDouble(""String_Node_Str""));
      teleLocation.setY(rs.getDouble(""String_Node_Str""));
      teleLocation.setZ(rs.getDouble(""String_Node_Str""));
      teleLocation.setYaw(rs.getFloat(""String_Node_Str""));
      teleLocation.setPitch(rs.getFloat(""String_Node_Str""));
      teleLocations.put(teleLocation.getWorldName(),teleLocation);
    }
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"",e);
  }
}","public void loadTeleLocations(){
  if (!isConnected())   connect();
  try {
    rs=stmt.executeQuery(""String_Node_Str"" + ""String_Node_Str"" + xAuthSettings.tblLocation + ""String_Node_Str"");
    while (rs.next()) {
      TeleLocation teleLocation=new TeleLocation();
      teleLocation.setWorldName(rs.getString(""String_Node_Str""));
      teleLocation.setX(rs.getDouble(""String_Node_Str""));
      teleLocation.setY(rs.getDouble(""String_Node_Str""));
      teleLocation.setZ(rs.getDouble(""String_Node_Str""));
      teleLocation.setYaw(rs.getFloat(""String_Node_Str""));
      teleLocation.setPitch(rs.getFloat(""String_Node_Str""));
      teleLocations.put(teleLocation.getWorldName(),teleLocation);
    }
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"",e);
  }
}",0.976958525345622
38806,"public boolean isHostUsed(String host){
  try {
    prepStmt=connection.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + xAuthSettings.tblAccount + ""String_Node_Str""+ ""String_Node_Str"");
    prepStmt.setString(1,host);
    rs=prepStmt.executeQuery();
    if (rs.next())     return true;
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"",e);
  }
  return false;
}","public boolean isHostUsed(String host){
  if (!isConnected())   connect();
  try {
    prepStmt=connection.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + xAuthSettings.tblAccount + ""String_Node_Str""+ ""String_Node_Str"");
    prepStmt.setString(1,host);
    rs=prepStmt.executeQuery();
    if (rs.next())     return true;
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"",e);
  }
  return false;
}",0.9570552147239264
38807,"public void insertAccounts(List<Account> accounts){
  StringBuilder sb=new StringBuilder();
  Account account;
  sb.append(""String_Node_Str"" + xAuthSettings.tblAccount + ""String_Node_Str"");
  sb.append(""String_Node_Str"");
  for (int i=1; i < accounts.size(); i++)   sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  try {
    prepStmt=connection.prepareStatement(sb.toString());
    for (int i=0, j=1; j < accounts.size() * 2; i++, j+=2) {
      account=accounts.get(i);
      prepStmt.setString(j,account.getPlayerName());
      prepStmt.setString(j + 1,account.getPassword().toLowerCase());
    }
    prepStmt.executeUpdate();
  }
 catch (  SQLException e) {
    e.printStackTrace();
  }
}","public void insertAccounts(List<Account> accounts){
  if (!isConnected())   connect();
  StringBuilder sb=new StringBuilder();
  Account account;
  sb.append(""String_Node_Str"" + xAuthSettings.tblAccount + ""String_Node_Str"");
  sb.append(""String_Node_Str"");
  for (int i=1; i < accounts.size(); i++)   sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  try {
    prepStmt=connection.prepareStatement(sb.toString());
    for (int i=0, j=1; j < accounts.size() * 2; i++, j+=2) {
      account=accounts.get(i);
      prepStmt.setString(j,account.getPlayerName());
      prepStmt.setString(j + 1,account.getPassword().toLowerCase());
    }
    prepStmt.executeUpdate();
  }
 catch (  SQLException e) {
    e.printStackTrace();
  }
}",0.9757785467128028
38808,"protected void updateAccount(Account account){
  try {
    prepStmt=connection.prepareStatement(""String_Node_Str"" + xAuthSettings.tblAccount + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    prepStmt.setString(1,account.getPlayerName());
    prepStmt.setString(2,account.getPassword());
    prepStmt.setString(3,account.getEmail());
    prepStmt.setTimestamp(4,account.getRegisterDate());
    prepStmt.setString(5,account.getRegisterHost());
    prepStmt.setTimestamp(6,account.getLastLoginDate());
    prepStmt.setString(7,account.getLastLoginHost());
    prepStmt.setInt(8,account.getActive());
    prepStmt.setInt(9,account.getId());
    prepStmt.executeUpdate();
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + account.getPlayerName(),e);
  }
}","protected void updateAccount(Account account){
  if (!isConnected())   connect();
  try {
    prepStmt=connection.prepareStatement(""String_Node_Str"" + xAuthSettings.tblAccount + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    prepStmt.setString(1,account.getPlayerName());
    prepStmt.setString(2,account.getPassword());
    prepStmt.setString(3,account.getEmail());
    prepStmt.setTimestamp(4,account.getRegisterDate());
    prepStmt.setString(5,account.getRegisterHost());
    prepStmt.setTimestamp(6,account.getLastLoginDate());
    prepStmt.setString(7,account.getLastLoginHost());
    prepStmt.setInt(8,account.getActive());
    prepStmt.setInt(9,account.getId());
    prepStmt.executeUpdate();
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + account.getPlayerName(),e);
  }
}",0.9816849816849816
38809,"public void insertSession(Session session){
  try {
    prepStmt=connection.prepareStatement(""String_Node_Str"" + xAuthSettings.tblSession + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",Statement.RETURN_GENERATED_KEYS);
    prepStmt.setInt(1,session.getAccountId());
    prepStmt.setString(2,session.getHost());
    prepStmt.setTimestamp(3,session.getLoginTime());
    prepStmt.executeUpdate();
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + session.getAccountId(),e);
  }
}","public void insertSession(Session session){
  if (!isConnected())   connect();
  try {
    prepStmt=connection.prepareStatement(""String_Node_Str"" + xAuthSettings.tblSession + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",Statement.RETURN_GENERATED_KEYS);
    prepStmt.setInt(1,session.getAccountId());
    prepStmt.setString(2,session.getHost());
    prepStmt.setTimestamp(3,session.getLoginTime());
    prepStmt.executeUpdate();
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + session.getAccountId(),e);
  }
}",0.9667616334283
38810,"public StrikeBan loadStrikeBan(String host){
  StrikeBan ban=null;
  try {
    prepStmt=connection.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + xAuthSettings.tblStrike + ""String_Node_Str""+ ""String_Node_Str"");
    prepStmt.setString(1,host);
    rs=prepStmt.executeQuery();
    if (rs.next()) {
      ban=new StrikeBan();
      ban.setHost(rs.getString(""String_Node_Str""));
      ban.setBanTime(rs.getTimestamp(""String_Node_Str""));
    }
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + host,e);
  }
  return ban;
}","public StrikeBan loadStrikeBan(String host){
  if (!isConnected())   connect();
  StrikeBan ban=null;
  try {
    prepStmt=connection.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + xAuthSettings.tblStrike + ""String_Node_Str""+ ""String_Node_Str"");
    prepStmt.setString(1,host);
    rs=prepStmt.executeQuery();
    if (rs.next()) {
      ban=new StrikeBan();
      ban.setHost(rs.getString(""String_Node_Str""));
      ban.setBanTime(rs.getTimestamp(""String_Node_Str""));
    }
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + host,e);
  }
  return ban;
}",0.9691085613415712
38811,"public ItemStack[] getInventory(xAuthPlayer xPlayer){
  try {
    prepStmt=connection.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + xAuthSettings.tblInventory + ""String_Node_Str""+ ""String_Node_Str"");
    prepStmt.setString(1,xPlayer.getPlayerName());
    rs=prepStmt.executeQuery();
    if (rs.next()) {
      int[] itemid=Util.stringToInt(rs.getString(""String_Node_Str"").split(""String_Node_Str""));
      int[] amount=Util.stringToInt(rs.getString(""String_Node_Str"").split(""String_Node_Str""));
      int[] durability=Util.stringToInt(rs.getString(""String_Node_Str"").split(""String_Node_Str""));
      ItemStack[] inv=new ItemStack[itemid.length];
      for (int i=0; i < inv.length; i++)       inv[i]=new ItemStack(itemid[i],amount[i],(short)durability[i]);
      return inv;
    }
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + xPlayer.getPlayerName(),e);
  }
  return null;
}","public ItemStack[] getInventory(xAuthPlayer xPlayer){
  if (!isConnected())   connect();
  try {
    prepStmt=connection.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + xAuthSettings.tblInventory + ""String_Node_Str""+ ""String_Node_Str"");
    prepStmt.setString(1,xPlayer.getPlayerName());
    rs=prepStmt.executeQuery();
    if (rs.next()) {
      int[] itemid=Util.stringToInt(rs.getString(""String_Node_Str"").split(""String_Node_Str""));
      int[] amount=Util.stringToInt(rs.getString(""String_Node_Str"").split(""String_Node_Str""));
      int[] durability=Util.stringToInt(rs.getString(""String_Node_Str"").split(""String_Node_Str""));
      ItemStack[] inv=new ItemStack[itemid.length];
      for (int i=0; i < inv.length; i++)       inv[i]=new ItemStack(itemid[i],amount[i],(short)durability[i]);
      return inv;
    }
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + xPlayer.getPlayerName(),e);
  }
  return null;
}",0.98115239633818
38812,"public void deleteAccount(xAuthPlayer xPlayer){
  Account account=xPlayer.getAccount();
  try {
    prepStmt=connection.prepareStatement(""String_Node_Str"" + xAuthSettings.tblAccount + ""String_Node_Str""+ ""String_Node_Str"");
    prepStmt.setInt(1,account.getId());
    prepStmt.executeUpdate();
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + xPlayer.getPlayerName(),e);
  }
  xPlayer.setAccount(null);
  xPlayer.setSession(null);
}","public void deleteAccount(xAuthPlayer xPlayer){
  if (!isConnected())   connect();
  Account account=xPlayer.getAccount();
  try {
    prepStmt=connection.prepareStatement(""String_Node_Str"" + xAuthSettings.tblAccount + ""String_Node_Str""+ ""String_Node_Str"");
    prepStmt.setInt(1,account.getId());
    prepStmt.executeUpdate();
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + xPlayer.getPlayerName(),e);
  }
  xPlayer.setAccount(null);
  xPlayer.setSession(null);
}",0.9628844114528102
38813,"public void deleteInventory(xAuthPlayer xPlayer){
  try {
    prepStmt=connection.prepareStatement(""String_Node_Str"" + xAuthSettings.tblInventory + ""String_Node_Str""+ ""String_Node_Str"");
    prepStmt.setString(1,xPlayer.getPlayerName());
    prepStmt.executeUpdate();
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + xPlayer.getPlayerName(),e);
  }
}","public void deleteInventory(xAuthPlayer xPlayer){
  if (!isConnected())   connect();
  try {
    prepStmt=connection.prepareStatement(""String_Node_Str"" + xAuthSettings.tblInventory + ""String_Node_Str""+ ""String_Node_Str"");
    prepStmt.setString(1,xPlayer.getPlayerName());
    prepStmt.executeUpdate();
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + xPlayer.getPlayerName(),e);
  }
}",0.9551856594110116
38814,"public void updateTeleLocation(TeleLocation teleLocation){
  try {
    prepStmt=connection.prepareStatement(""String_Node_Str"" + xAuthSettings.tblLocation + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    prepStmt.setDouble(1,teleLocation.getX());
    prepStmt.setDouble(2,teleLocation.getY());
    prepStmt.setDouble(3,teleLocation.getZ());
    prepStmt.setFloat(4,teleLocation.getYaw());
    prepStmt.setFloat(5,teleLocation.getPitch());
    prepStmt.setString(6,teleLocation.getWorldName());
    prepStmt.executeUpdate();
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + teleLocation.getWorldName(),e);
  }
}","public void updateTeleLocation(TeleLocation teleLocation){
  if (!isConnected())   connect();
  try {
    prepStmt=connection.prepareStatement(""String_Node_Str"" + xAuthSettings.tblLocation + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    prepStmt.setDouble(1,teleLocation.getX());
    prepStmt.setDouble(2,teleLocation.getY());
    prepStmt.setDouble(3,teleLocation.getZ());
    prepStmt.setFloat(4,teleLocation.getYaw());
    prepStmt.setFloat(5,teleLocation.getPitch());
    prepStmt.setString(6,teleLocation.getWorldName());
    prepStmt.executeUpdate();
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + teleLocation.getWorldName(),e);
  }
}",0.976958525345622
38815,"public void insertStrikeBan(StrikeBan ban){
  try {
    prepStmt=connection.prepareStatement(""String_Node_Str"" + xAuthSettings.tblStrike + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    prepStmt.setString(1,ban.getHost());
    prepStmt.setTimestamp(2,ban.getBanTime());
    prepStmt.executeUpdate();
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + ban.getHost(),e);
  }
}","public void insertStrikeBan(StrikeBan ban){
  if (!isConnected())   connect();
  try {
    prepStmt=connection.prepareStatement(""String_Node_Str"" + xAuthSettings.tblStrike + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    prepStmt.setString(1,ban.getHost());
    prepStmt.setTimestamp(2,ban.getBanTime());
    prepStmt.executeUpdate();
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + ban.getHost(),e);
  }
}",0.9608062709966404
38816,"public xAuthPlayer getPlayerFromDb(String playerName){
  xAuthPlayer xPlayer=null;
  try {
    prepStmt=connection.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + xAuthSettings.tblAccount + ""String_Node_Str""+ ""String_Node_Str""+ xAuthSettings.tblSession+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    prepStmt.setString(1,playerName);
    rs=prepStmt.executeQuery();
    if (rs.next())     xPlayer=new xAuthPlayer(playerName,buildAccount(rs),buildSession(rs));
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + playerName,e);
  }
  return xPlayer;
}","public xAuthPlayer getPlayerFromDb(String playerName){
  if (!isConnected())   connect();
  xAuthPlayer xPlayer=null;
  try {
    prepStmt=connection.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + xAuthSettings.tblAccount + ""String_Node_Str""+ ""String_Node_Str""+ xAuthSettings.tblSession+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    prepStmt.setString(1,playerName);
    rs=prepStmt.executeQuery();
    if (rs.next())     xPlayer=new xAuthPlayer(playerName,buildAccount(rs),buildSession(rs));
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + playerName,e);
  }
  return xPlayer;
}",0.9714285714285714
38817,"protected void insertAccount(Account account){
  try {
    prepStmt=connection.prepareStatement(""String_Node_Str"" + xAuthSettings.tblAccount + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",Statement.RETURN_GENERATED_KEYS);
    prepStmt.setString(1,account.getPlayerName());
    prepStmt.setString(2,account.getPassword());
    prepStmt.setString(3,account.getEmail());
    prepStmt.setTimestamp(4,account.getRegisterDate());
    prepStmt.setString(5,account.getRegisterHost());
    prepStmt.setTimestamp(6,account.getLastLoginDate());
    prepStmt.setString(7,account.getLastLoginHost());
    prepStmt.setInt(8,account.getActive());
    prepStmt.executeUpdate();
    rs=prepStmt.getGeneratedKeys();
    if (rs.next())     account.setId(rs.getInt(1));
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + account.getPlayerName(),e);
  }
}","protected void insertAccount(Account account){
  if (!isConnected())   connect();
  try {
    prepStmt=connection.prepareStatement(""String_Node_Str"" + xAuthSettings.tblAccount + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",Statement.RETURN_GENERATED_KEYS);
    prepStmt.setString(1,account.getPlayerName());
    prepStmt.setString(2,account.getPassword());
    prepStmt.setString(3,account.getEmail());
    prepStmt.setTimestamp(4,account.getRegisterDate());
    prepStmt.setString(5,account.getRegisterHost());
    prepStmt.setTimestamp(6,account.getLastLoginDate());
    prepStmt.setString(7,account.getLastLoginHost());
    prepStmt.setInt(8,account.getActive());
    prepStmt.executeUpdate();
    rs=prepStmt.getGeneratedKeys();
    if (rs.next())     account.setId(rs.getInt(1));
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + account.getPlayerName(),e);
  }
}",0.9806094182825484
38818,"public DataManager(){
  if (xAuthSettings.datasource.equals(""String_Node_Str""))   connectMySQL();
 else   connectH2();
}","public DataManager(){
  connect();
}",0.4615384615384615
38819,"public void createTables(){
  try {
    stmt.execute(""String_Node_Str"" + xAuthSettings.tblAccount + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    stmt.execute(""String_Node_Str"" + xAuthSettings.tblSession + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ xAuthSettings.tblAccount+ ""String_Node_Str""+ ""String_Node_Str"");
    stmt.execute(""String_Node_Str"" + xAuthSettings.tblLocation + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    stmt.execute(""String_Node_Str"" + xAuthSettings.tblStrike + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    stmt.execute(""String_Node_Str"" + xAuthSettings.tblInventory + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"",e);
  }
}","public void createTables(){
  if (!isConnected())   connect();
  try {
    stmt.execute(""String_Node_Str"" + xAuthSettings.tblAccount + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    stmt.execute(""String_Node_Str"" + xAuthSettings.tblSession + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ xAuthSettings.tblAccount+ ""String_Node_Str""+ ""String_Node_Str"");
    stmt.execute(""String_Node_Str"" + xAuthSettings.tblLocation + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    stmt.execute(""String_Node_Str"" + xAuthSettings.tblStrike + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    stmt.execute(""String_Node_Str"" + xAuthSettings.tblInventory + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"",e);
  }
}",0.9861605377619612
38820,"public void runStartupTasks(){
  createTables();
  loadTeleLocations();
  String sql;
  if (xAuthSettings.datasource.equals(""String_Node_Str"")) {
    sql=""String_Node_Str"" + xAuthSettings.tblSession + ""String_Node_Str""+ ""String_Node_Str""+ xAuthSettings.sessionLength+ ""String_Node_Str"";
  }
 else {
    sql=""String_Node_Str"" + xAuthSettings.tblSession + ""String_Node_Str""+ ""String_Node_Str""+ xAuthSettings.sessionLength+ ""String_Node_Str"";
  }
  try {
    stmt.executeUpdate(sql);
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"",e);
  }
}","public void runStartupTasks(){
  createTables();
  loadTeleLocations();
  String sql;
  if (xAuthSettings.datasource.equals(""String_Node_Str"")) {
    sql=""String_Node_Str"" + xAuthSettings.tblSession + ""String_Node_Str""+ ""String_Node_Str""+ xAuthSettings.sessionLength+ ""String_Node_Str"";
  }
 else {
    sql=""String_Node_Str"" + xAuthSettings.tblSession + ""String_Node_Str""+ ""String_Node_Str""+ xAuthSettings.sessionLength+ ""String_Node_Str"";
  }
  if (!isConnected())   connect();
  try {
    stmt.executeUpdate(sql);
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"",e);
  }
}",0.9696969696969696
38821,"public void printStats(){
  try {
    rs=stmt.executeQuery(""String_Node_Str"" + ""String_Node_Str"" + xAuthSettings.tblAccount + ""String_Node_Str""+ ""String_Node_Str""+ xAuthSettings.tblSession+ ""String_Node_Str"");
    if (rs.next())     xAuthLog.info(""String_Node_Str"" + rs.getInt(""String_Node_Str"") + ""String_Node_Str""+ rs.getInt(""String_Node_Str""));
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"",e);
  }
}","public void printStats(){
  if (!isConnected())   connect();
  try {
    rs=stmt.executeQuery(""String_Node_Str"" + ""String_Node_Str"" + xAuthSettings.tblAccount + ""String_Node_Str""+ ""String_Node_Str""+ xAuthSettings.tblSession+ ""String_Node_Str"");
    if (rs.next())     xAuthLog.info(""String_Node_Str"" + rs.getInt(""String_Node_Str"") + ""String_Node_Str""+ rs.getInt(""String_Node_Str""));
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"",e);
  }
}",0.9606299212598424
38822,"public void insertTeleLocation(TeleLocation teleLocation){
  try {
    prepStmt=connection.prepareStatement(""String_Node_Str"" + xAuthSettings.tblLocation + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    prepStmt.setString(1,teleLocation.getWorldName());
    prepStmt.setDouble(2,teleLocation.getX());
    prepStmt.setDouble(3,teleLocation.getY());
    prepStmt.setDouble(4,teleLocation.getZ());
    prepStmt.setFloat(5,teleLocation.getYaw());
    prepStmt.setFloat(6,teleLocation.getPitch());
    prepStmt.executeUpdate();
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + teleLocation.getWorldName(),e);
  }
}","public void insertTeleLocation(TeleLocation teleLocation){
  if (!isConnected())   connect();
  try {
    prepStmt=connection.prepareStatement(""String_Node_Str"" + xAuthSettings.tblLocation + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    prepStmt.setString(1,teleLocation.getWorldName());
    prepStmt.setDouble(2,teleLocation.getX());
    prepStmt.setDouble(3,teleLocation.getY());
    prepStmt.setDouble(4,teleLocation.getZ());
    prepStmt.setFloat(5,teleLocation.getYaw());
    prepStmt.setFloat(6,teleLocation.getPitch());
    prepStmt.executeUpdate();
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + teleLocation.getWorldName(),e);
  }
}",0.9736644093303236
38823,"public void deleteSession(xAuthPlayer xPlayer){
  Session session=xPlayer.getSession();
  try {
    prepStmt=connection.prepareStatement(""String_Node_Str"" + xAuthSettings.tblSession + ""String_Node_Str""+ ""String_Node_Str"");
    prepStmt.setInt(1,session.getAccountId());
    prepStmt.executeUpdate();
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + xPlayer.getPlayerName(),e);
  }
  xPlayer.setSession(null);
}","public void deleteSession(xAuthPlayer xPlayer){
  if (!isConnected())   connect();
  Session session=xPlayer.getSession();
  try {
    prepStmt=connection.prepareStatement(""String_Node_Str"" + xAuthSettings.tblSession + ""String_Node_Str""+ ""String_Node_Str"");
    prepStmt.setInt(1,session.getAccountId());
    prepStmt.executeUpdate();
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + xPlayer.getPlayerName(),e);
  }
  xPlayer.setSession(null);
}",0.9611542730299668
38824,"public xAuthPlayer reloadPlayer(xAuthPlayer xPlayer){
  try {
    prepStmt=connection.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + xAuthSettings.tblAccount + ""String_Node_Str""+ ""String_Node_Str""+ xAuthSettings.tblSession+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    prepStmt.setString(1,xPlayer.getPlayerName());
    rs=prepStmt.executeQuery();
    if (rs.next()) {
      xPlayer.setAccount(buildAccount(rs));
      xPlayer.setSession(buildSession(rs));
    }
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + xPlayer.getPlayerName(),e);
  }
  return xPlayer;
}","public xAuthPlayer reloadPlayer(xAuthPlayer xPlayer){
  if (!isConnected())   connect();
  try {
    prepStmt=connection.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + xAuthSettings.tblAccount + ""String_Node_Str""+ ""String_Node_Str""+ xAuthSettings.tblSession+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    prepStmt.setString(1,xPlayer.getPlayerName());
    rs=prepStmt.executeQuery();
    if (rs.next()) {
      xPlayer.setAccount(buildAccount(rs));
      xPlayer.setSession(buildSession(rs));
    }
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + xPlayer.getPlayerName(),e);
  }
  return xPlayer;
}",0.972244250594766
38825,"public void deleteStrikeBan(StrikeBan ban){
  try {
    stmt=connection.prepareStatement(""String_Node_Str"" + xAuthSettings.tblStrike + ""String_Node_Str""+ ""String_Node_Str"");
    prepStmt.setString(1,ban.getHost());
    prepStmt.executeUpdate();
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + ban.getHost(),e);
  }
}","public void deleteStrikeBan(StrikeBan ban){
  if (!isConnected())   connect();
  try {
    stmt=connection.prepareStatement(""String_Node_Str"" + xAuthSettings.tblStrike + ""String_Node_Str""+ ""String_Node_Str"");
    prepStmt.setString(1,ban.getHost());
    prepStmt.executeUpdate();
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + ban.getHost(),e);
  }
}",0.951048951048951
38826,"public int getActive(String playerName){
  try {
    prepStmt=connection.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + xAuthSettings.tblAccount + ""String_Node_Str""+ ""String_Node_Str"");
    prepStmt.setString(1,playerName);
    rs=prepStmt.executeQuery();
    if (rs.next())     return rs.getInt(""String_Node_Str"");
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + playerName,e);
  }
  return 0;
}","public int getActive(String playerName){
  if (!isConnected())   connect();
  try {
    prepStmt=connection.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + xAuthSettings.tblAccount + ""String_Node_Str""+ ""String_Node_Str"");
    prepStmt.setString(1,playerName);
    rs=prepStmt.executeQuery();
    if (rs.next())     return rs.getInt(""String_Node_Str"");
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + playerName,e);
  }
  return 0;
}",0.9608938547486032
38827,"public void deleteTeleLocation(TeleLocation teleLocation){
  try {
    prepStmt=connection.prepareStatement(""String_Node_Str"" + xAuthSettings.tblLocation + ""String_Node_Str""+ ""String_Node_Str"");
    prepStmt.setString(1,teleLocation.getWorldName());
    prepStmt.executeUpdate();
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + teleLocation.getWorldName(),e);
  }
}","public void deleteTeleLocation(TeleLocation teleLocation){
  if (!isConnected())   connect();
  try {
    prepStmt=connection.prepareStatement(""String_Node_Str"" + xAuthSettings.tblLocation + ""String_Node_Str""+ ""String_Node_Str"");
    prepStmt.setString(1,teleLocation.getWorldName());
    prepStmt.executeUpdate();
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + teleLocation.getWorldName(),e);
  }
}",0.956949569495695
38828,"public void insertInventory(xAuthPlayer xPlayer){
  try {
    prepStmt=connection.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + xAuthSettings.tblInventory + ""String_Node_Str""+ ""String_Node_Str"");
    prepStmt.setString(1,xPlayer.getPlayerName());
    rs=prepStmt.executeQuery();
    if (rs.next())     return;
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + xPlayer.getPlayerName(),e);
  }
  PlayerInventory inv=xPlayer.getPlayer().getInventory();
  StringBuilder sbItems=new StringBuilder();
  StringBuilder sbAmount=new StringBuilder();
  StringBuilder sbDurability=new StringBuilder();
  for (  ItemStack item : inv.getContents()) {
    int itemid=0;
    int amount=0;
    short durability=0;
    if (item != null) {
      itemid=item.getTypeId();
      amount=item.getAmount();
      durability=item.getDurability();
    }
    sbItems.append(itemid + ""String_Node_Str"");
    sbAmount.append(amount + ""String_Node_Str"");
    sbDurability.append(durability + ""String_Node_Str"");
  }
  for (  ItemStack item : inv.getArmorContents()) {
    int itemid=0;
    int amount=0;
    short durability=0;
    if (item != null) {
      itemid=item.getTypeId();
      amount=item.getAmount();
      durability=item.getDurability();
    }
    sbItems.append(itemid + ""String_Node_Str"");
    sbAmount.append(amount + ""String_Node_Str"");
    sbDurability.append(durability + ""String_Node_Str"");
  }
  sbItems.deleteCharAt(sbItems.lastIndexOf(""String_Node_Str""));
  sbAmount.deleteCharAt(sbAmount.lastIndexOf(""String_Node_Str""));
  sbDurability.deleteCharAt(sbDurability.lastIndexOf(""String_Node_Str""));
  try {
    prepStmt=connection.prepareStatement(""String_Node_Str"" + xAuthSettings.tblInventory + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    prepStmt.setString(1,xPlayer.getPlayerName());
    prepStmt.setString(2,sbItems.toString());
    prepStmt.setString(3,sbAmount.toString());
    prepStmt.setString(4,sbDurability.toString());
    prepStmt.executeUpdate();
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + xPlayer.getPlayerName(),e);
  }
}","public void insertInventory(xAuthPlayer xPlayer){
  if (!isConnected())   connect();
  try {
    prepStmt=connection.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + xAuthSettings.tblInventory + ""String_Node_Str""+ ""String_Node_Str"");
    prepStmt.setString(1,xPlayer.getPlayerName());
    rs=prepStmt.executeQuery();
    if (rs.next())     return;
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + xPlayer.getPlayerName(),e);
  }
  PlayerInventory inv=xPlayer.getPlayer().getInventory();
  StringBuilder sbItems=new StringBuilder();
  StringBuilder sbAmount=new StringBuilder();
  StringBuilder sbDurability=new StringBuilder();
  for (  ItemStack item : inv.getContents()) {
    int itemid=0;
    int amount=0;
    short durability=0;
    if (item != null) {
      itemid=item.getTypeId();
      amount=item.getAmount();
      durability=item.getDurability();
    }
    sbItems.append(itemid + ""String_Node_Str"");
    sbAmount.append(amount + ""String_Node_Str"");
    sbDurability.append(durability + ""String_Node_Str"");
  }
  for (  ItemStack item : inv.getArmorContents()) {
    int itemid=0;
    int amount=0;
    short durability=0;
    if (item != null) {
      itemid=item.getTypeId();
      amount=item.getAmount();
      durability=item.getDurability();
    }
    sbItems.append(itemid + ""String_Node_Str"");
    sbAmount.append(amount + ""String_Node_Str"");
    sbDurability.append(durability + ""String_Node_Str"");
  }
  sbItems.deleteCharAt(sbItems.lastIndexOf(""String_Node_Str""));
  sbAmount.deleteCharAt(sbAmount.lastIndexOf(""String_Node_Str""));
  sbDurability.deleteCharAt(sbDurability.lastIndexOf(""String_Node_Str""));
  try {
    prepStmt=connection.prepareStatement(""String_Node_Str"" + xAuthSettings.tblInventory + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    prepStmt.setString(1,xPlayer.getPlayerName());
    prepStmt.setString(2,sbItems.toString());
    prepStmt.setString(3,sbAmount.toString());
    prepStmt.setString(4,sbDurability.toString());
    prepStmt.executeUpdate();
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + xPlayer.getPlayerName(),e);
  }
}",0.9917782475922012
38829,"public void onPlayerMove(PlayerMoveEvent event){
  if (event.isCancelled())   return;
  Player player=event.getPlayer();
  xAuthPlayer xPlayer=plugin.getDataManager().getPlayer(player.getName());
  if (xPlayer.isGuest()) {
    event.setTo(plugin.getLocationToTeleport(player.getWorld()));
    if (xPlayer.canNotify())     xPlayer.sendIllegalActionNotice();
  }
}","public void onPlayerMove(PlayerMoveEvent event){
  if (event.isCancelled())   return;
  Player player=event.getPlayer();
  xAuthPlayer xPlayer=plugin.getDataManager().getPlayer(player.getName());
  if (xPlayer.isGuest()) {
    if (xAuthSettings.protectLoc)     event.setTo(plugin.getLocationToTeleport(player.getWorld()));
 else     event.setTo(xPlayer.getLocation());
    if (xPlayer.canNotify())     xPlayer.sendIllegalActionNotice();
  }
}",0.900497512437811
38830,"public void run(){
  player.kickPlayer(xAuthMessages.get(""String_Node_Str"",player,null));
}","public void run(){
  if (player.getHealth() > 0)   xPlayer.setLocation(player.getLocation());
  if (xAuthSettings.protectLoc)   player.teleport(getLocationToTeleport(player.getWorld()));
}",0.4516129032258064
38831,"public void onEnable(){
  desc=getDescription();
  dataFolder=getDataFolder();
  if (!dataFolder.exists())   dataFolder.mkdirs();
  xAuthSettings.setup();
  xAuthMessages.setup();
  if (xAuthSettings.autoDisable && getServer().getOnlineMode()) {
    xAuthLog.warning(""String_Node_Str"");
    getServer().getPluginManager().disablePlugin(this);
    return;
  }
  initializePlugins();
  if (xAuthSettings.downloadLib && Database.getDBMS() == DBMS.H2 && !Util.checkLibrary()) {
    xAuthLog.info(""String_Node_Str"");
    Util.downloadLibrary();
    xAuthLog.info(""String_Node_Str"");
    getServer().getPluginManager().disablePlugin(this);
    return;
  }
  Database.connect();
  if (!Database.isConnected()) {
    xAuthLog.severe(""String_Node_Str"");
    getServer().getPluginManager().disablePlugin(this);
    return;
  }
  DbUpdate dbUpdate=new DbUpdate();
  if (!dbUpdate.checkVersion()) {
    xAuthLog.info(""String_Node_Str"");
    dbUpdate.update();
  }
  DbUtil.deleteExpiredSessions();
  loadTeleLocations();
  File oldAuthFile=new File(dataFolder,""String_Node_Str"");
  if (oldAuthFile.exists())   importAccounts(oldAuthFile);
  Database.printStats();
  Player[] players=getServer().getOnlinePlayers();
  if (players.length > 0)   handleReload(players);
  (new xAuthPlayerListener(this)).registerEvents();
  (new xAuthBlockListener(this)).registerEvents();
  (new xAuthEntityListener(this)).registerEvents();
  getCommand(""String_Node_Str"").setExecutor(new RegisterCommand(this));
  getCommand(""String_Node_Str"").setExecutor(new LoginCommand(this));
  getCommand(""String_Node_Str"").setExecutor(new ChangePasswordCommand(this));
  getCommand(""String_Node_Str"").setExecutor(new LogoutCommand(this));
  getCommand(""String_Node_Str"").setExecutor(new xAuthCommand(this));
  xAuthLog.info(""String_Node_Str"" + desc.getVersion() + ""String_Node_Str"");
}","public void onEnable(){
  desc=getDescription();
  dataFolder=getDataFolder();
  if (!dataFolder.exists())   dataFolder.mkdirs();
  xAuthSettings.setup();
  xAuthMessages.setup();
  if (xAuthSettings.autoDisable && getServer().getOnlineMode()) {
    xAuthLog.warning(""String_Node_Str"");
    getServer().getPluginManager().disablePlugin(this);
    return;
  }
  initializePlugins();
  if (xAuthSettings.downloadLib && Database.getDBMS() == DBMS.H2 && !checkLibrary()) {
    xAuthLog.info(""String_Node_Str"");
    downloadLibrary();
    xAuthLog.info(""String_Node_Str"");
    getServer().getPluginManager().disablePlugin(this);
    return;
  }
  Database.connect();
  if (!Database.isConnected()) {
    xAuthLog.severe(""String_Node_Str"");
    getServer().getPluginManager().disablePlugin(this);
    return;
  }
  DbUpdate dbUpdate=new DbUpdate();
  if (!dbUpdate.checkVersion()) {
    xAuthLog.info(""String_Node_Str"");
    dbUpdate.update();
  }
  DbUtil.deleteExpiredSessions();
  loadTeleLocations();
  File oldAuthFile=new File(dataFolder,""String_Node_Str"");
  if (oldAuthFile.exists())   importAccounts(oldAuthFile);
  DbUtil.printStats();
  Player[] players=getServer().getOnlinePlayers();
  if (players.length > 0)   handleReload(players);
  (new xAuthPlayerListener(this)).registerEvents();
  (new xAuthBlockListener(this)).registerEvents();
  (new xAuthEntityListener(this)).registerEvents();
  getCommand(""String_Node_Str"").setExecutor(new RegisterCommand(this));
  getCommand(""String_Node_Str"").setExecutor(new LoginCommand(this));
  getCommand(""String_Node_Str"").setExecutor(new ChangePasswordCommand(this));
  getCommand(""String_Node_Str"").setExecutor(new LogoutCommand(this));
  getCommand(""String_Node_Str"").setExecutor(new xAuthCommand(this));
  xAuthLog.info(""String_Node_Str"" + desc.getVersion() + ""String_Node_Str"");
}",0.9945593035908596
38832,"public void protect(xAuthPlayer xPlayer){
  Player player=xPlayer.getPlayer();
  PlayerInventory playerInv=player.getInventory();
  DbUtil.insertInventory(xPlayer);
  playerInv.clear();
  playerInv.setHelmet(null);
  playerInv.setChestplate(null);
  playerInv.setLeggings(null);
  playerInv.setBoots(null);
  player.saveData();
  if (player.getHealth() > 0)   xPlayer.setLocation(player.getLocation());
  if (xAuthSettings.protectLoc)   player.teleport(getLocationToTeleport(player.getWorld()));
}","public void protect(final xAuthPlayer xPlayer){
  final Player player=xPlayer.getPlayer();
  PlayerInventory playerInv=player.getInventory();
  DbUtil.insertInventory(xPlayer);
  playerInv.clear();
  playerInv.setHelmet(null);
  playerInv.setChestplate(null);
  playerInv.setLeggings(null);
  playerInv.setBoots(null);
  player.saveData();
  getServer().getScheduler().scheduleAsyncDelayedTask(this,new Runnable(){
    public void run(){
      if (player.getHealth() > 0)       xPlayer.setLocation(player.getLocation());
      if (xAuthSettings.protectLoc)       player.teleport(getLocationToTeleport(player.getWorld()));
    }
  }
,1);
}",0.8757709251101321
38833,"public void deleteStrikeBan(StrikeBan ban){
  if (!isConnected())   connect();
  try {
    stmt=connection.prepareStatement(""String_Node_Str"" + xAuthSettings.tblStrike + ""String_Node_Str""+ ""String_Node_Str"");
    prepStmt.setString(1,ban.getHost());
    prepStmt.executeUpdate();
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + ban.getHost(),e);
  }
}","public void deleteStrikeBan(StrikeBan ban){
  if (!isConnected())   connect();
  try {
    prepStmt=connection.prepareStatement(""String_Node_Str"" + xAuthSettings.tblStrike + ""String_Node_Str""+ ""String_Node_Str"");
    prepStmt.setString(1,ban.getHost());
    prepStmt.executeUpdate();
  }
 catch (  SQLException e) {
    xAuthLog.severe(""String_Node_Str"" + ban.getHost(),e);
  }
}",0.9920424403183024
38834,"private void apply(PsiElement element){
  remove();
  _editor=FileEditorManager.getInstance(_project).getSelectedTextEditor();
  if (_editor == null) {
    debug(""String_Node_Str"");
    return;
  }
  if (element instanceof PsiWhiteSpace && isWhiteSpaceFiltered())   return;
  if (isHighlightOn() && isElementInEditor(_editor,element)) {
    TextRange textRange=element.getTextRange();
    debug(""String_Node_Str"" + textRange);
    _highlighter=_editor.getMarkupModel().addRangeHighlighter(textRange.getStartOffset(),textRange.getEndOffset(),PsiViewerConstants.PSIVIEWER_HIGHLIGHT_LAYER,_textAttributes,HighlighterTargetArea.EXACT_RANGE);
  }
}","private void apply(PsiElement element){
  remove();
  _editor=FileEditorManager.getInstance(_project).getSelectedTextEditor();
  if (_editor == null) {
    debug(""String_Node_Str"");
    return;
  }
  if (element instanceof PsiWhiteSpace && isWhiteSpaceFiltered())   return;
  if (isHighlightOn() && isElementInEditor(_editor,element)) {
    TextRange textRange=element.getTextRange();
    debug(""String_Node_Str"" + textRange);
    final int docTextLength=_editor.getDocument().getTextLength();
    _highlighter=_editor.getMarkupModel().addRangeHighlighter(textRange.getStartOffset(),Math.min(textRange.getEndOffset(),docTextLength),PsiViewerConstants.PSIVIEWER_HIGHLIGHT_LAYER,_textAttributes,HighlighterTargetArea.EXACT_RANGE);
  }
}",0.933914306463326
38835,"public void selectionChanged(@NotNull FileEditorManagerEvent event){
  debug(""String_Node_Str"" + event.toString());
  if (event.getNewFile() == null)   return;
  Editor newEditor=event.getManager().getSelectedTextEditor();
  if (_currentEditor != newEditor)   _currentEditor.getCaretModel().removeCaretListener(this);
  _viewer.selectElementAtCaret();
  _currentEditor.getCaretModel().addCaretListener(this);
}","public void selectionChanged(@NotNull FileEditorManagerEvent event){
  debug(""String_Node_Str"" + event.toString());
  if (event.getNewFile() == null)   return;
  Editor newEditor=event.getManager().getSelectedTextEditor();
  if (_currentEditor != newEditor)   _currentEditor.getCaretModel().removeCaretListener(this);
  _viewer.selectElementAtCaret();
  if (newEditor != null)   _currentEditor=newEditor;
  _currentEditor.getCaretModel().addCaretListener(this);
}",0.9392898052691868
38836,"public PsiViewerTreeCellRenderer(){
  setOpaque(false);
  _elementVisitor=new ElementVisitor();
}","public PsiViewerTreeCellRenderer(){
  setOpaque(false);
}",0.7402597402597403
38837,"private String truncate(String text){
  if (text.length() > MAX_TEXT_LENGTH)   return text.substring(0,MAX_TEXT_LENGTH).trim() + ""String_Node_Str"";
 else   return text;
}","private String truncate(String text){
  if (text.length() > 80)   return text.substring(0,80).trim() + ""String_Node_Str"";
 else   return text;
}",0.89171974522293
38838,"public Component getTreeCellRendererComponent(JTree tree,Object value,boolean isSelected,boolean isExpanded,boolean isLeaf,int row,boolean hasFocus){
  super.getTreeCellRendererComponent(tree,value,isSelected,isExpanded,isLeaf,row,hasFocus);
  setIcon(IconCache.DEFAULT_ICON);
  PsiElement psiElement=(PsiElement)value;
  psiElement.accept(_elementVisitor);
  return this;
}","public Component getTreeCellRendererComponent(JTree tree,Object value,boolean isSelected,boolean isExpanded,boolean isLeaf,int row,boolean hasFocus){
  super.getTreeCellRendererComponent(tree,value,isSelected,isExpanded,isLeaf,row,hasFocus);
  setIcon(IconCache.DEFAULT_ICON);
  PsiElement psiElement=(PsiElement)value;
  psiElement.accept(_elementVisitor);
  psiElement.accept(_elementVisitorXml);
  psiElement.accept(_elementVisitorJava);
  return this;
}",0.9001203369434416
38839,"public void visitReferenceExpression(PsiReferenceExpression psiReferenceExpression){
}","public void visitReferenceExpression(PsiReferenceExpression psireferenceexpression){
}",0.9767441860465116
38840,"/** 
 * cat out the time_in_state as root as an alternative to reading the file. THis is necesary for ROMs who have blocked user/group read access to the file due to some bug 
 */
private List<CpuState> getStatesAsRoot(){
  Process process=null;
  DataOutputStream out=null;
  InputStreamReader inReader=null;
  try {
    process=Runtime.getRuntime().exec(""String_Node_Str"");
    out=new DataOutputStream(process.getOutputStream());
    out.writeChars(""String_Node_Str"" + TIME_IN_STATE_PATH + ""String_Node_Str"");
    out.flush();
    inReader=new InputStreamReader(process.getInputStream());
    BufferedReader br=new BufferedReader(inReader);
    readInStates(br);
  }
 catch (  Exception e) {
    Log.d(""String_Node_Str"",""String_Node_Str"");
    Log.e(""String_Node_Str"",e.getMessage());
  }
 finally {
    try {
      out.close();
      inReader.close();
      process.destroy();
    }
 catch (    Exception e) {
      Log.e(""String_Node_Str"",e.getMessage());
    }
  }
  return mStates;
}","/** 
 * cat out the time_in_state as root as an alternative to reading the file. THis is necesary for ROMs who have blocked user/group read access to the file due to some bug 
 */
private List<CpuState> getStatesAsRoot(){
  Process process=null;
  DataOutputStream out=null;
  InputStreamReader inReader=null;
  try {
    process=Runtime.getRuntime().exec(""String_Node_Str"");
    out=new DataOutputStream(process.getOutputStream());
    out.writeChars(""String_Node_Str"" + TIME_IN_STATE_PATH + ""String_Node_Str"");
    out.flush();
    inReader=new InputStreamReader(process.getInputStream());
    BufferedReader br=new BufferedReader(inReader);
    readInStates(br);
  }
 catch (  Exception e) {
    Log.d(""String_Node_Str"",""String_Node_Str"");
    Log.e(""String_Node_Str"",e.getMessage());
  }
 finally {
    try {
      out.close();
      inReader.close();
      process.destroy();
    }
 catch (    Exception e) {
      Log.e(""String_Node_Str"",e.getMessage());
    }
  }
  if (mStates.size() == 0)   return null;
  return mStates;
}",0.9792284866468842
38841,"/** 
 * update the view 
 */
public void updateView(){
  mUiStatesView.removeAllViews();
  List<String> extraStates=new ArrayList<String>();
  for (  CpuState state : mApp.getStates()) {
    if (state.duration > 0) {
      generateStateRow(state,mUiStatesView);
    }
 else {
      extraStates.add(state.freq / 1000 + ""String_Node_Str"");
    }
  }
  if (mApp.getStates().size() == 0) {
    mUiStatesWarning.setVisibility(View.VISIBLE);
  }
  if (extraStates.size() > 0) {
    int n=0;
    String str=""String_Node_Str"";
    for (    String s : extraStates) {
      if (n++ > 0)       str+=""String_Node_Str"";
      str+=s;
    }
    mUiAdditionalStates.setVisibility(View.VISIBLE);
    mUiHeaderAdditionalStates.setVisibility(View.VISIBLE);
    mUiAdditionalStates.setText(str);
  }
  mUiKernelString.setText(mApp.getKernelString());
}","/** 
 * update the view 
 */
public void updateView(){
  mUiStatesView.removeAllViews();
  List<String> extraStates=new ArrayList<String>();
  for (  CpuState state : mApp.getStates()) {
    if (state.duration > 0) {
      generateStateRow(state,mUiStatesView);
    }
 else {
      extraStates.add(state.freq / 1000 + ""String_Node_Str"");
    }
  }
  if (mApp.getStates().size() == 0) {
    mUiStatesWarning.setVisibility(View.VISIBLE);
  }
  if (extraStates.size() > 0) {
    int n=0;
    String str=""String_Node_Str"";
    for (    String s : extraStates) {
      if (n++ > 0)       str+=""String_Node_Str"";
      str+=s;
    }
    mUiAdditionalStates.setVisibility(View.VISIBLE);
    mUiHeaderAdditionalStates.setVisibility(View.VISIBLE);
    mUiAdditionalStates.setText(str);
  }
 else {
    mUiAdditionalStates.setVisibility(View.GONE);
    mUiHeaderAdditionalStates.setVisibility(View.GONE);
  }
  mUiKernelString.setText(mApp.getKernelString());
}",0.9338565022421524
38842,"/** 
 * access state list 
 */
public List<CpuState> getStates(){
  List<CpuState> ret=new ArrayList<CpuState>();
  for (  CpuState state : mStates) {
    int dur=state.duration;
    if (mOffsets.containsKey(state.freq)) {
      dur=state.duration - mOffsets.get(state.freq);
    }
    ret.add(new CpuState(state.freq,dur));
  }
  return ret;
}","/** 
 * access state list 
 */
public List<CpuState> getStates(){
  List<CpuState> ret=new ArrayList<CpuState>();
  for (  CpuState state : mStates) {
    int dur=state.duration;
    if (mOffsets.containsKey(state.freq)) {
      dur=state.duration - mOffsets.get(state.freq);
      if (dur < 0)       dur=state.duration;
    }
    ret.add(new CpuState(state.freq,dur));
  }
  return ret;
}",0.9386084583901774
38843,"/** 
 * spit out a view representing a cpustate so we can cram it into a ScrollView 
 */
private View generateStateRow(CpuState state,ViewGroup parent){
  LayoutInflater inf=LayoutInflater.from((Context)mApp);
  LinearLayout theRow=(LinearLayout)inf.inflate(R.layout.state_row,parent,false);
  float per=(float)state.duration * 100 / mApp.getTotalStateTime();
  String sFreq=state.freq / 1000 + ""String_Node_Str"";
  String sPer=(int)per + ""String_Node_Str"";
  int h=(int)Math.floor(state.duration / 6000);
  int m=(state.duration / 100) % 60;
  String sDur;
  if (m < 10)   sDur=h + ""String_Node_Str"" + m;
 else   sDur=h + ""String_Node_Str"" + m;
  TextView freqText=(TextView)theRow.findViewById(R.id.ui_freq_text);
  TextView durText=(TextView)theRow.findViewById(R.id.ui_duration_text);
  TextView perText=(TextView)theRow.findViewById(R.id.ui_percentage_text);
  ProgressBar bar=(ProgressBar)theRow.findViewById(R.id.ui_bar);
  freqText.setText(sFreq);
  perText.setText(sPer);
  durText.setText(sDur);
  bar.setProgress((int)per);
  parent.addView(theRow);
  return theRow;
}","/** 
 * spit out a view representing a cpustate so we can cram it into a ScrollView 
 */
private View generateStateRow(CpuState state,ViewGroup parent){
  LayoutInflater inf=LayoutInflater.from((Context)mApp);
  LinearLayout theRow=(LinearLayout)inf.inflate(R.layout.state_row,parent,false);
  float per=(float)state.duration * 100 / mApp.getTotalStateTime();
  String sFreq=state.freq / 1000 + ""String_Node_Str"";
  String sPer=(int)per + ""String_Node_Str"";
  int tSec=state.duration / 100;
  int h=(int)Math.floor(tSec / (60 * 60));
  int m=(int)Math.floor((tSec - h * 60 * 60) / 60);
  int s=(state.duration / 100) % 60;
  String sDur;
  sDur=h + ""String_Node_Str"";
  if (m < 10)   sDur+=""String_Node_Str"";
  sDur+=m + ""String_Node_Str"";
  if (s < 10)   sDur+=""String_Node_Str"";
  sDur+=s;
  TextView freqText=(TextView)theRow.findViewById(R.id.ui_freq_text);
  TextView durText=(TextView)theRow.findViewById(R.id.ui_duration_text);
  TextView perText=(TextView)theRow.findViewById(R.id.ui_percentage_text);
  ProgressBar bar=(ProgressBar)theRow.findViewById(R.id.ui_bar);
  freqText.setText(sFreq);
  perText.setText(sPer);
  durText.setText(sDur);
  bar.setProgress((int)per);
  parent.addView(theRow);
  return theRow;
}",0.8932291666666666
38844,"@Test public void canDecode2(){
  AISMessage aisMessage=AISMessage.create(NMEAMessage.fromString(""String_Node_Str""));
  System.out.println(aisMessage.toString());
  assertEquals(AISMessageType.AidToNavigationReport,aisMessage.getMessageType());
  assertEquals((Integer)0,aisMessage.getRepeatIndicator());
  AidToNavigationReport message=(AidToNavigationReport)aisMessage;
  assertEquals(MMSI.valueOf(995036021),message.getSourceMmsi());
  assertEquals(AidType.BeaconSpecialMark,message.getAidType());
  assertEquals(false,message.getAssignedMode());
  assertEquals(""String_Node_Str"",message.getName());
  assertEquals(null,message.getNameExtension());
  assertEquals(false,message.getOffPosition());
  assertEquals(Integer.valueOf(60),message.getSecond());
  assertEquals(Integer.valueOf(0),message.getToBow());
  assertEquals(Integer.valueOf(0),message.getToPort());
  assertEquals(Integer.valueOf(0),message.getToStern());
  assertEquals(Integer.valueOf(0),message.getToStarboard());
  assertEquals(true,message.getVirtualAid());
  assertEquals(false,message.getPositionAccurate());
  assertEquals(Float.valueOf(-23.917383f),message.getLatitude());
  assertEquals(Float.valueOf(151.49791f),message.getLongitude());
  assertEquals(PositionFixingDevice.Surveyed,message.getPositionFixingDevice());
  assertFalse(message.getRaimFlag());
}","@Test public void canDecode2(){
  AISMessage aisMessage=AISMessage.create(NMEAMessage.fromString(""String_Node_Str""));
  System.out.println(aisMessage.toString());
  assertEquals(AISMessageType.AidToNavigationReport,aisMessage.getMessageType());
  assertEquals((Integer)0,aisMessage.getRepeatIndicator());
  AidToNavigationReport message=(AidToNavigationReport)aisMessage;
  assertEquals(MMSI.valueOf(995036021),message.getSourceMmsi());
  assertEquals(AidType.BeaconSpecialMark,message.getAidType());
  assertEquals(false,message.getAssignedMode());
  assertEquals(""String_Node_Str"",message.getName());
  assertEquals(null,message.getNameExtension());
  assertEquals(false,message.getOffPosition());
  assertEquals(Integer.valueOf(60),message.getSecond());
  assertEquals(Integer.valueOf(0),message.getToBow());
  assertEquals(Integer.valueOf(0),message.getToPort());
  assertEquals(Integer.valueOf(0),message.getToStern());
  assertEquals(Integer.valueOf(0),message.getToStarboard());
  assertEquals(true,message.getVirtualAid());
  assertEquals(false,message.getPositionAccurate());
  assertEquals(Float.valueOf(-23.917385f),message.getLatitude());
  assertEquals(Float.valueOf(151.49791f),message.getLongitude());
  assertEquals(PositionFixingDevice.Surveyed,message.getPositionFixingDevice());
  assertFalse(message.getRaimFlag());
}",0.99925205684368
38845,"@Test public void testDataFields(){
  AISMessage aisMessage=AISMessage.create(NMEAMessage.fromString(""String_Node_Str""));
  Map<String,Object> dataFields=aisMessage.dataFields();
  assertNotNull(dataFields);
  assertEquals(23,dataFields.size());
  assertEquals(""String_Node_Str"",dataFields.get(""String_Node_Str""));
  assertEquals(0,dataFields.get(""String_Node_Str""));
  assertEquals(995036021,dataFields.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",dataFields.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",dataFields.get(""String_Node_Str""));
  assertEquals(false,dataFields.get(""String_Node_Str""));
  assertEquals(151.49791f,dataFields.get(""String_Node_Str""));
  assertEquals(-23.917383f,dataFields.get(""String_Node_Str""));
  assertEquals(0,dataFields.get(""String_Node_Str""));
  assertEquals(0,dataFields.get(""String_Node_Str""));
  assertEquals(0,dataFields.get(""String_Node_Str""));
  assertEquals(0,dataFields.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",dataFields.get(""String_Node_Str""));
  assertEquals(60,dataFields.get(""String_Node_Str""));
  assertEquals(false,dataFields.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",dataFields.get(""String_Node_Str""));
  assertEquals(false,dataFields.get(""String_Node_Str""));
  assertEquals(true,dataFields.get(""String_Node_Str""));
  assertEquals(false,dataFields.get(""String_Node_Str""));
  assertEquals(0,dataFields.get(""String_Node_Str""));
  assertEquals(0,dataFields.get(""String_Node_Str""));
  assertEquals(true,dataFields.get(""String_Node_Str""));
  assertFalse(dataFields.containsKey(""String_Node_Str""));
  assertFalse(dataFields.containsKey(""String_Node_Str""));
}","@Test public void testDataFields(){
  AISMessage aisMessage=AISMessage.create(NMEAMessage.fromString(""String_Node_Str""));
  Map<String,Object> dataFields=aisMessage.dataFields();
  assertNotNull(dataFields);
  assertEquals(23,dataFields.size());
  assertEquals(""String_Node_Str"",dataFields.get(""String_Node_Str""));
  assertEquals(0,dataFields.get(""String_Node_Str""));
  assertEquals(995036021,dataFields.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",dataFields.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",dataFields.get(""String_Node_Str""));
  assertEquals(false,dataFields.get(""String_Node_Str""));
  assertEquals(151.49791f,dataFields.get(""String_Node_Str""));
  assertEquals(-23.917385f,dataFields.get(""String_Node_Str""));
  assertEquals(0,dataFields.get(""String_Node_Str""));
  assertEquals(0,dataFields.get(""String_Node_Str""));
  assertEquals(0,dataFields.get(""String_Node_Str""));
  assertEquals(0,dataFields.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",dataFields.get(""String_Node_Str""));
  assertEquals(60,dataFields.get(""String_Node_Str""));
  assertEquals(false,dataFields.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",dataFields.get(""String_Node_Str""));
  assertEquals(false,dataFields.get(""String_Node_Str""));
  assertEquals(true,dataFields.get(""String_Node_Str""));
  assertEquals(false,dataFields.get(""String_Node_Str""));
  assertEquals(0,dataFields.get(""String_Node_Str""));
  assertEquals(0,dataFields.get(""String_Node_Str""));
  assertEquals(true,dataFields.get(""String_Node_Str""));
  assertFalse(dataFields.containsKey(""String_Node_Str""));
  assertFalse(dataFields.containsKey(""String_Node_Str""));
}",0.9993972272453284
38846,"@Test public void canDecode1(){
  AISMessage aisMessage=AISMessage.create(NMEAMessage.fromString(""String_Node_Str""));
  System.out.println(aisMessage.toString());
  assertEquals(AISMessageType.AidToNavigationReport,aisMessage.getMessageType());
  assertEquals((Integer)0,aisMessage.getRepeatIndicator());
  AidToNavigationReport message=(AidToNavigationReport)aisMessage;
  assertEquals(MMSI.valueOf(995036019),message.getSourceMmsi());
  assertEquals(AidType.BeaconSpecialMark,message.getAidType());
  assertEquals(false,message.getAssignedMode());
  assertEquals(""String_Node_Str"",message.getName());
  assertEquals(null,message.getNameExtension());
  assertEquals(false,message.getOffPosition());
  assertEquals(Integer.valueOf(60),message.getSecond());
  assertEquals(Integer.valueOf(0),message.getToBow());
  assertEquals(Integer.valueOf(0),message.getToPort());
  assertEquals(Integer.valueOf(0),message.getToStern());
  assertEquals(Integer.valueOf(0),message.getToStarboard());
  assertEquals(true,message.getVirtualAid());
  assertEquals(false,message.getPositionAccurate());
  assertEquals(Float.valueOf(-23.936691f),message.getLatitude());
  assertEquals(Float.valueOf(151.44344f),message.getLongitude());
  assertEquals(PositionFixingDevice.Surveyed,message.getPositionFixingDevice());
  assertFalse(message.getRaimFlag());
}","@Test public void canDecode1(){
  AISMessage aisMessage=AISMessage.create(NMEAMessage.fromString(""String_Node_Str""));
  System.out.println(aisMessage.toString());
  assertEquals(AISMessageType.AidToNavigationReport,aisMessage.getMessageType());
  assertEquals((Integer)0,aisMessage.getRepeatIndicator());
  AidToNavigationReport message=(AidToNavigationReport)aisMessage;
  assertEquals(MMSI.valueOf(995036019),message.getSourceMmsi());
  assertEquals(AidType.BeaconSpecialMark,message.getAidType());
  assertEquals(false,message.getAssignedMode());
  assertEquals(""String_Node_Str"",message.getName());
  assertEquals(null,message.getNameExtension());
  assertEquals(false,message.getOffPosition());
  assertEquals(Integer.valueOf(60),message.getSecond());
  assertEquals(Integer.valueOf(0),message.getToBow());
  assertEquals(Integer.valueOf(0),message.getToPort());
  assertEquals(Integer.valueOf(0),message.getToStern());
  assertEquals(Integer.valueOf(0),message.getToStarboard());
  assertEquals(true,message.getVirtualAid());
  assertEquals(false,message.getPositionAccurate());
  assertEquals(Float.valueOf(-23.936693f),message.getLatitude());
  assertEquals(Float.valueOf(151.44344f),message.getLongitude());
  assertEquals(PositionFixingDevice.Surveyed,message.getPositionFixingDevice());
  assertFalse(message.getRaimFlag());
}",0.99925205684368
38847,"@Test public void canDecode2(){
  AISMessage aisMessage=AISMessage.create(NMEAMessage.fromString(""String_Node_Str""));
  System.out.println(aisMessage.toString());
  assertEquals(AISMessageType.LongRangeBroadcastMessage,aisMessage.getMessageType());
  assertEquals((Integer)0,aisMessage.getRepeatIndicator());
  assertEquals(MMSI.valueOf(357277000),aisMessage.getSourceMmsi());
  LongRangeBroadcastMessage message=(LongRangeBroadcastMessage)aisMessage;
  assertTrue(message.getPositionAccuracy());
  assertFalse(message.getRaim());
  assertEquals(NavigationStatus.Moored,message.getNavigationalStatus());
  assertEquals(Float.valueOf(176.18167f),message.getLongitude());
  assertEquals(Float.valueOf(-37.65167f),message.getLatitude());
  assertEquals(Float.valueOf(0f),message.getSpeedOverGround(),1e-5);
  assertEquals(Float.valueOf(11f),message.getCourseOverGround(),1e-5);
}","@Test public void canDecode2(){
  AISMessage aisMessage=AISMessage.create(NMEAMessage.fromString(""String_Node_Str""));
  System.out.println(aisMessage.toString());
  assertEquals(AISMessageType.LongRangeBroadcastMessage,aisMessage.getMessageType());
  assertEquals((Integer)0,aisMessage.getRepeatIndicator());
  assertEquals(MMSI.valueOf(357277000),aisMessage.getSourceMmsi());
  LongRangeBroadcastMessage message=(LongRangeBroadcastMessage)aisMessage;
  assertTrue(message.getPositionAccuracy());
  assertFalse(message.getRaim());
  assertEquals(NavigationStatus.Moored,message.getNavigationalStatus());
  assertEquals(Float.valueOf(176.18167f),message.getLongitude());
  assertEquals(Float.valueOf(-37.65333f),message.getLatitude());
  assertEquals(Float.valueOf(0f),message.getSpeedOverGround(),1e-5);
  assertEquals(Float.valueOf(11f),message.getCourseOverGround(),1e-5);
}",0.9965753424657534
38848,"@Test public void canDecodeCommunicationState(){
  AISMessage aisMessage=AISMessage.create(NMEAMessage.fromString(""String_Node_Str""));
  System.out.println(aisMessage.toString());
  assertEquals(AISMessageType.PositionReportClassAScheduled,aisMessage.getMessageType());
  assertEquals((Integer)0,aisMessage.getRepeatIndicator());
  PositionReportClassAScheduled message=(PositionReportClassAScheduled)aisMessage;
  assertEquals(MMSI.valueOf(503175400),message.getSourceMmsi());
  assertEquals(NavigationStatus.Undefined,message.getNavigationStatus());
  assertEquals(Integer.valueOf(-127),message.getRateOfTurn());
  assertEquals(Float.valueOf(0.0f),message.getSpeedOverGround());
  assertFalse(message.getPositionAccuracy());
  assertEquals(Float.valueOf(-34.773254f),message.getLatitude());
  assertEquals(Float.valueOf(138.48856f),message.getLongitude());
  assertEquals(Float.valueOf(4.8f),message.getCourseOverGround());
  assertEquals(Integer.valueOf(47),message.getSecond());
  assertEquals(Integer.valueOf(511),message.getTrueHeading());
  assertEquals(ManeuverIndicator.NotAvailable,message.getSpecialManeuverIndicator());
  assertFalse(message.getRaimFlag());
  CommunicationState communicationState=message.getCommunicationState();
  assertEquals(SyncState.UTCDirect,communicationState.getSyncState());
  assertTrue(communicationState instanceof SOTDMACommunicationState);
  SOTDMACommunicationState sotdmaCommunicationState=(SOTDMACommunicationState)communicationState;
  assertNull(sotdmaCommunicationState.getNumberOfReceivedStations());
  assertNull(sotdmaCommunicationState.getSlotNumber());
  assertNull(sotdmaCommunicationState.getSlotOffset());
  assertEquals(Integer.valueOf(1),sotdmaCommunicationState.getSlotTimeout());
  assertEquals(Integer.valueOf(0),sotdmaCommunicationState.getUtcHour());
  assertEquals(Integer.valueOf(24),sotdmaCommunicationState.getUtcMinute());
}","@Test public void canDecodeCommunicationState(){
  AISMessage aisMessage=AISMessage.create(NMEAMessage.fromString(""String_Node_Str""));
  System.out.println(aisMessage.toString());
  assertEquals(AISMessageType.PositionReportClassAScheduled,aisMessage.getMessageType());
  assertEquals((Integer)0,aisMessage.getRepeatIndicator());
  PositionReportClassAScheduled message=(PositionReportClassAScheduled)aisMessage;
  assertEquals(MMSI.valueOf(503175400),message.getSourceMmsi());
  assertEquals(NavigationStatus.Undefined,message.getNavigationStatus());
  assertEquals(Integer.valueOf(-128),message.getRateOfTurn());
  assertEquals(Float.valueOf(0.0f),message.getSpeedOverGround());
  assertFalse(message.getPositionAccuracy());
  assertEquals(Float.valueOf(-34.773254f),message.getLatitude());
  assertEquals(Float.valueOf(138.48856f),message.getLongitude());
  assertEquals(Float.valueOf(4.8f),message.getCourseOverGround());
  assertEquals(Integer.valueOf(47),message.getSecond());
  assertEquals(Integer.valueOf(511),message.getTrueHeading());
  assertEquals(ManeuverIndicator.NotAvailable,message.getSpecialManeuverIndicator());
  assertFalse(message.getRaimFlag());
  CommunicationState communicationState=message.getCommunicationState();
  assertEquals(SyncState.UTCDirect,communicationState.getSyncState());
  assertTrue(communicationState instanceof SOTDMACommunicationState);
  SOTDMACommunicationState sotdmaCommunicationState=(SOTDMACommunicationState)communicationState;
  assertNull(sotdmaCommunicationState.getNumberOfReceivedStations());
  assertNull(sotdmaCommunicationState.getSlotNumber());
  assertNull(sotdmaCommunicationState.getSlotOffset());
  assertEquals(Integer.valueOf(1),sotdmaCommunicationState.getSlotTimeout());
  assertEquals(Integer.valueOf(0),sotdmaCommunicationState.getUtcHour());
  assertEquals(Integer.valueOf(24),sotdmaCommunicationState.getUtcMinute());
}",0.9994720168954594
38849,"@Test public void canDecodeITDMACommunicationState(){
  AISMessage aisMessage=AISMessage.create(NMEAMessage.fromString(""String_Node_Str""));
  System.out.println(aisMessage.toString());
  assertEquals(AISMessageType.StandardClassBCSPositionReport,aisMessage.getMessageType());
  StandardClassBCSPositionReport message=(StandardClassBCSPositionReport)aisMessage;
  assertEquals(Integer.valueOf(0),message.getRepeatIndicator());
  assertEquals(MMSI.valueOf(423302100),message.getSourceMmsi());
  assertEquals(""String_Node_Str"",message.getRegionalReserved1());
  assertEquals((Float)1.4f,message.getSpeedOverGround());
  assertTrue(message.getPositionAccurate());
  assertEquals(Float.valueOf(40.005283f),message.getLatitude());
  assertEquals(Float.valueOf(53.010998f),message.getLongitude());
  assertEquals(Float.valueOf(177f),message.getCourseOverGround());
  assertEquals((Integer)177,message.getTrueHeading());
  assertEquals((Integer)34,message.getSecond());
  assertEquals(""String_Node_Str"",message.getRegionalReserved2());
  assertTrue(message.getCsUnit());
  assertTrue(message.getDisplay());
  assertTrue(message.getDsc());
  assertTrue(message.getBand());
  assertTrue(message.getMessage22());
  assertFalse(message.getAssigned());
  assertFalse(message.getRaimFlag());
  assertTrue(message.getCommunicationStateSelectorFlag());
  CommunicationState communicationState=message.getCommunicationState();
  assertEquals(SyncState.UTCDirect,communicationState.getSyncState());
  assertTrue(communicationState instanceof ITDMACommunicationState);
  ITDMACommunicationState itdmaCommunicationState=(ITDMACommunicationState)communicationState;
  assertEquals(Integer.valueOf(0),itdmaCommunicationState.getSlotIncrement());
  assertEquals(Integer.valueOf(3),itdmaCommunicationState.getNumberOfSlots());
  assertFalse(itdmaCommunicationState.getKeepFlag());
}","@Test public void canDecodeITDMACommunicationState(){
  AISMessage aisMessage=AISMessage.create(NMEAMessage.fromString(""String_Node_Str""));
  System.out.println(aisMessage.toString());
  assertEquals(AISMessageType.StandardClassBCSPositionReport,aisMessage.getMessageType());
  StandardClassBCSPositionReport message=(StandardClassBCSPositionReport)aisMessage;
  assertEquals(Integer.valueOf(0),message.getRepeatIndicator());
  assertEquals(MMSI.valueOf(423302100),message.getSourceMmsi());
  assertEquals(""String_Node_Str"",message.getRegionalReserved1());
  assertEquals((Float)1.4f,message.getSpeedOverGround());
  assertTrue(message.getPositionAccurate());
  assertEquals(Float.valueOf(40.005283f),message.getLatitude());
  assertEquals(Float.valueOf(53.010998f),message.getLongitude());
  assertEquals(Float.valueOf(177f),message.getCourseOverGround());
  assertEquals((Integer)177,message.getTrueHeading());
  assertEquals((Integer)34,message.getSecond());
  assertEquals(""String_Node_Str"",message.getRegionalReserved2());
  assertTrue(message.getCsUnit());
  assertTrue(message.getDisplay());
  assertTrue(message.getDsc());
  assertTrue(message.getBand());
  assertTrue(message.getMessage22());
  assertFalse(message.getAssigned());
  assertFalse(message.getRaimFlag());
  assertTrue(message.getCommunicationStateSelectorFlag());
  CommunicationState communicationState=message.getCommunicationState();
  assertEquals(SyncState.BaseIndirect,communicationState.getSyncState());
  assertTrue(communicationState instanceof ITDMACommunicationState);
  ITDMACommunicationState itdmaCommunicationState=(ITDMACommunicationState)communicationState;
  assertEquals(Integer.valueOf(0),itdmaCommunicationState.getSlotIncrement());
  assertEquals(Integer.valueOf(3),itdmaCommunicationState.getNumberOfSlots());
  assertFalse(itdmaCommunicationState.getKeepFlag());
}",0.997042215649368
38850,"public boolean isValid(){
  final String bitString=getBitString();
  if (bitString.length() < 6) {
    LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
    return Boolean.FALSE;
  }
  int messageType=Integer.parseInt(bitString.substring(0,6),2);
  if (messageType < 1 || messageType > 26) {
    LOG.warning(""String_Node_Str"" + messageType);
    return Boolean.FALSE;
  }
  int actualMessageLength=bitString.length();
switch (messageType) {
case 1:
    if (actualMessageLength != 168) {
      LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
      return Boolean.FALSE;
    }
  break;
case 2:
if (actualMessageLength != 168) {
  LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
  return Boolean.FALSE;
}
break;
case 3:
if (actualMessageLength != 168) {
LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
return Boolean.FALSE;
}
break;
case 4:
if (actualMessageLength != 168) return Boolean.FALSE;
break;
case 5:
if (actualMessageLength != 424) {
LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
return Boolean.FALSE;
}
break;
case 6:
if (actualMessageLength > 1008) {
LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
return Boolean.FALSE;
}
break;
case 7:
if (actualMessageLength != 72 && actualMessageLength != 104 && actualMessageLength != 136 && actualMessageLength != 168) {
LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
return Boolean.FALSE;
}
break;
case 8:
if (actualMessageLength > 1008) {
LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
return Boolean.FALSE;
}
break;
case 9:
if (actualMessageLength != 168) {
LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
return Boolean.FALSE;
}
break;
case 10:
if (actualMessageLength != 72) {
LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
return Boolean.FALSE;
}
break;
case 11:
if (actualMessageLength != 168) return Boolean.FALSE;
break;
case 12:
if (actualMessageLength > 1008) {
LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
return Boolean.FALSE;
}
break;
case 13:
if (actualMessageLength != 72 && actualMessageLength != 104 && actualMessageLength != 136 && actualMessageLength != 168) {
LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
return Boolean.FALSE;
}
break;
case 14:
if (actualMessageLength > 1008) {
LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
return Boolean.FALSE;
}
break;
case 15:
if (actualMessageLength != 88 && actualMessageLength != 110 && actualMessageLength != 112 && actualMessageLength != 160) return Boolean.FALSE;
break;
case 16:
if (actualMessageLength != 96 && actualMessageLength != 144) {
LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
return Boolean.FALSE;
}
break;
case 17:
if (actualMessageLength < 80 || actualMessageLength > 816) {
LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
return Boolean.FALSE;
}
break;
case 18:
if (actualMessageLength != 168) {
LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
return Boolean.FALSE;
}
break;
case 19:
if (actualMessageLength != 312) {
LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
return Boolean.FALSE;
}
break;
case 20:
if (actualMessageLength < 72 || actualMessageLength > 160) {
LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
return Boolean.FALSE;
}
break;
case 21:
if (actualMessageLength < 272 || actualMessageLength > 360) {
LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
return Boolean.FALSE;
}
break;
case 22:
if (actualMessageLength != 168) {
LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
return Boolean.FALSE;
}
break;
case 23:
if (actualMessageLength != 160) {
LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
return Boolean.FALSE;
}
break;
case 24:
if (actualMessageLength != 160 && actualMessageLength != 168) {
LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
return Boolean.FALSE;
}
break;
case 25:
if (actualMessageLength > 168) {
LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
return Boolean.FALSE;
}
break;
case 26:
break;
case 27:
if (actualMessageLength != 96 && actualMessageLength != 168) {
LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
return Boolean.FALSE;
}
break;
default :
return Boolean.FALSE;
}
return Boolean.TRUE;
}","public boolean isValid(){
  final String bitString=getBitString();
  if (bitString.length() < 6) {
    LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
    return Boolean.FALSE;
  }
  int messageType=Integer.parseInt(bitString.substring(0,6),2);
  if (messageType < AISMessageType.MINIMUM_CODE || messageType > AISMessageType.MAXIMUM_CODE) {
    LOG.warning(""String_Node_Str"" + messageType);
    return Boolean.FALSE;
  }
  int actualMessageLength=bitString.length();
switch (messageType) {
case 1:
    if (actualMessageLength != 168) {
      LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
      return Boolean.FALSE;
    }
  break;
case 2:
if (actualMessageLength != 168) {
  LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
  return Boolean.FALSE;
}
break;
case 3:
if (actualMessageLength != 168) {
LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
return Boolean.FALSE;
}
break;
case 4:
if (actualMessageLength != 168) return Boolean.FALSE;
break;
case 5:
if (actualMessageLength != 424) {
LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
return Boolean.FALSE;
}
break;
case 6:
if (actualMessageLength > 1008) {
LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
return Boolean.FALSE;
}
break;
case 7:
if (actualMessageLength != 72 && actualMessageLength != 104 && actualMessageLength != 136 && actualMessageLength != 168) {
LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
return Boolean.FALSE;
}
break;
case 8:
if (actualMessageLength > 1008) {
LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
return Boolean.FALSE;
}
break;
case 9:
if (actualMessageLength != 168) {
LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
return Boolean.FALSE;
}
break;
case 10:
if (actualMessageLength != 72) {
LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
return Boolean.FALSE;
}
break;
case 11:
if (actualMessageLength != 168) return Boolean.FALSE;
break;
case 12:
if (actualMessageLength > 1008) {
LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
return Boolean.FALSE;
}
break;
case 13:
if (actualMessageLength != 72 && actualMessageLength != 104 && actualMessageLength != 136 && actualMessageLength != 168) {
LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
return Boolean.FALSE;
}
break;
case 14:
if (actualMessageLength > 1008) {
LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
return Boolean.FALSE;
}
break;
case 15:
if (actualMessageLength != 88 && actualMessageLength != 110 && actualMessageLength != 112 && actualMessageLength != 160) return Boolean.FALSE;
break;
case 16:
if (actualMessageLength != 96 && actualMessageLength != 144) {
LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
return Boolean.FALSE;
}
break;
case 17:
if (actualMessageLength < 80 || actualMessageLength > 816) {
LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
return Boolean.FALSE;
}
break;
case 18:
if (actualMessageLength != 168) {
LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
return Boolean.FALSE;
}
break;
case 19:
if (actualMessageLength != 312) {
LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
return Boolean.FALSE;
}
break;
case 20:
if (actualMessageLength < 72 || actualMessageLength > 160) {
LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
return Boolean.FALSE;
}
break;
case 21:
if (actualMessageLength < 272 || actualMessageLength > 360) {
LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
return Boolean.FALSE;
}
break;
case 22:
if (actualMessageLength != 168) {
LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
return Boolean.FALSE;
}
break;
case 23:
if (actualMessageLength != 160) {
LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
return Boolean.FALSE;
}
break;
case 24:
if (actualMessageLength != 160 && actualMessageLength != 168) {
LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
return Boolean.FALSE;
}
break;
case 25:
if (actualMessageLength > 168) {
LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
return Boolean.FALSE;
}
break;
case 26:
break;
case 27:
if (actualMessageLength != 96 && actualMessageLength != 168) {
LOG.warning(""String_Node_Str"" + bitString.length() + ""String_Node_Str"");
return Boolean.FALSE;
}
break;
default :
return Boolean.FALSE;
}
return Boolean.TRUE;
}",0.9927245086328592
38851,"@Override public String toString(){
  return ""String_Node_Str"" + ""String_Node_Str"" + getMessageType() + ""String_Node_Str""+ getAccuracy()+ ""String_Node_Str""+ getRaim()+ ""String_Node_Str""+ getStatus()+ ""String_Node_Str""+ getLongitude()+ ""String_Node_Str""+ getLatitude()+ ""String_Node_Str""+ getSpeed()+ ""String_Node_Str""+ getCourse()+ ""String_Node_Str""+ getGnss()+ ""String_Node_Str""+ getSpare()+ ""String_Node_Str""+ super.toString();
}","@Override public String toString(){
  return ""String_Node_Str"" + ""String_Node_Str"" + getMessageType() + ""String_Node_Str""+ getPositionAccuracy()+ ""String_Node_Str""+ getRaim()+ ""String_Node_Str""+ getNavigationalStatus()+ ""String_Node_Str""+ getLongitude()+ ""String_Node_Str""+ getLatitude()+ ""String_Node_Str""+ getSpeedOverGround()+ ""String_Node_Str""+ getCourseOverGround()+ ""String_Node_Str""+ getPositionLatency()+ ""String_Node_Str""+ getSpare()+ ""String_Node_Str""+ super.toString();
}",0.8806133625410734
38852,"public AddressedBinaryMessage(Integer repeatIndicator,MMSI sourceMmsi,Integer sequenceNumber,MMSI destinationMmsi,Boolean retransmit,Integer designatedAreaCode,Integer functionalId,String binaryData){
  super(AISMessageType.AddressedBinaryMessage,repeatIndicator,sourceMmsi);
  this.sequenceNumber=sequenceNumber;
  this.destinationMmsi=destinationMmsi;
  this.retransmit=retransmit;
  this.designatedAreaCode=designatedAreaCode;
  this.functionalId=functionalId;
  this.binaryData=binaryData;
}","public AddressedBinaryMessage(Integer repeatIndicator,MMSI sourceMmsi,Integer sequenceNumber,MMSI destinationMmsi,Boolean retransmit,int spare,Integer designatedAreaCode,Integer functionalId,String binaryData){
  super(AISMessageType.AddressedBinaryMessage,repeatIndicator,sourceMmsi);
  this.sequenceNumber=sequenceNumber;
  this.destinationMmsi=destinationMmsi;
  this.retransmit=retransmit;
  this.spare=spare;
  this.designatedAreaCode=designatedAreaCode;
  this.functionalId=functionalId;
  this.binaryData=binaryData;
}",0.9705882352941176
38853,"public static AddressedBinaryMessage fromEncodedMessage(EncodedAISMessage encodedMessage){
  if (!encodedMessage.isValid())   throw new InvalidEncodedMessage(encodedMessage);
  if (!encodedMessage.getMessageType().equals(AISMessageType.AddressedBinaryMessage))   throw new UnsupportedMessageType(encodedMessage.getMessageType().getCode());
  Integer repeatIndicator=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(6,8));
  MMSI sourceMmsi=MMSI.valueOf(DecoderImpl.convertToUnsignedLong(encodedMessage.getBits(8,38)));
  Integer sequenceNumber=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(38,40));
  MMSI destinationMmsi=MMSI.valueOf(DecoderImpl.convertToUnsignedLong(encodedMessage.getBits(40,70)));
  Boolean retransmit=DecoderImpl.convertToBoolean(encodedMessage.getBits(70,71));
  Integer designatedAreaCode=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(72,82));
  Integer functionalId=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(82,88));
  String binaryData=DecoderImpl.convertToBitString(encodedMessage.getBits(88,1009));
  return new AddressedBinaryMessage(repeatIndicator,sourceMmsi,sequenceNumber,destinationMmsi,retransmit,designatedAreaCode,functionalId,binaryData);
}","public static AddressedBinaryMessage fromEncodedMessage(EncodedAISMessage encodedMessage){
  if (!encodedMessage.isValid())   throw new InvalidEncodedMessage(encodedMessage);
  if (!encodedMessage.getMessageType().equals(AISMessageType.AddressedBinaryMessage))   throw new UnsupportedMessageType(encodedMessage.getMessageType().getCode());
  Integer repeatIndicator=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(6,8));
  MMSI sourceMmsi=MMSI.valueOf(DecoderImpl.convertToUnsignedLong(encodedMessage.getBits(8,38)));
  Integer sequenceNumber=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(38,40));
  MMSI destinationMmsi=MMSI.valueOf(DecoderImpl.convertToUnsignedLong(encodedMessage.getBits(40,70)));
  Boolean retransmit=DecoderImpl.convertToBoolean(encodedMessage.getBits(70,71));
  int spare=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(71,72));
  Integer designatedAreaCode=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(72,82));
  Integer functionalId=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(82,88));
  String binaryData=DecoderImpl.convertToBitString(encodedMessage.getBits(88,encodedMessage.getNumberOfBits()));
  return new AddressedBinaryMessage(repeatIndicator,sourceMmsi,sequenceNumber,destinationMmsi,retransmit,spare,designatedAreaCode,functionalId,binaryData);
}",0.9330754352030948
38854,"public static AddressedSafetyRelatedMessage fromEncodedMessage(EncodedAISMessage encodedMessage){
  if (!encodedMessage.isValid())   throw new InvalidEncodedMessage(encodedMessage);
  if (!encodedMessage.getMessageType().equals(AISMessageType.AddressedSafetyRelatedMessage))   throw new UnsupportedMessageType(encodedMessage.getMessageType().getCode());
  Integer repeatIndicator=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(6,8));
  MMSI sourceMmsi=MMSI.valueOf(DecoderImpl.convertToUnsignedLong(encodedMessage.getBits(8,38)));
  Integer sequenceNumber=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(38,40));
  MMSI destinationMmsi=MMSI.valueOf(DecoderImpl.convertToUnsignedLong(encodedMessage.getBits(40,70)));
  Boolean retransmit=DecoderImpl.convertToBoolean(encodedMessage.getBits(70,71));
  String text=DecoderImpl.convertToString(encodedMessage.getBits(70,1009));
  return new AddressedSafetyRelatedMessage(repeatIndicator,sourceMmsi,sequenceNumber,destinationMmsi,retransmit,text);
}","public static AddressedSafetyRelatedMessage fromEncodedMessage(EncodedAISMessage encodedMessage){
  if (!encodedMessage.isValid())   throw new InvalidEncodedMessage(encodedMessage);
  if (!encodedMessage.getMessageType().equals(AISMessageType.AddressedSafetyRelatedMessage))   throw new UnsupportedMessageType(encodedMessage.getMessageType().getCode());
  Integer repeatIndicator=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(6,8));
  MMSI sourceMmsi=MMSI.valueOf(DecoderImpl.convertToUnsignedLong(encodedMessage.getBits(8,38)));
  Integer sequenceNumber=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(38,40));
  MMSI destinationMmsi=MMSI.valueOf(DecoderImpl.convertToUnsignedLong(encodedMessage.getBits(40,70)));
  Boolean retransmit=DecoderImpl.convertToBoolean(encodedMessage.getBits(70,71));
  int spare=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(71,72));
  int extraBitsOfChars=((encodedMessage.getNumberOfBits() - 72) / 6) * 6;
  String text=DecoderImpl.convertToString(encodedMessage.getBits(72,72 + extraBitsOfChars));
  return new AddressedSafetyRelatedMessage(repeatIndicator,sourceMmsi,sequenceNumber,destinationMmsi,retransmit,spare,text);
}",0.8998194945848376
38855,"public AddressedSafetyRelatedMessage(Integer repeatIndicator,MMSI sourceMmsi,Integer sequenceNumber,MMSI destinationMmsi,Boolean retransmit,String text){
  super(AISMessageType.AddressedSafetyRelatedMessage,repeatIndicator,sourceMmsi);
  this.sequenceNumber=sequenceNumber;
  this.destinationMmsi=destinationMmsi;
  this.retransmit=retransmit;
  this.text=text;
}","public AddressedSafetyRelatedMessage(Integer repeatIndicator,MMSI sourceMmsi,Integer sequenceNumber,MMSI destinationMmsi,Boolean retransmit,int spare,String text){
  super(AISMessageType.AddressedSafetyRelatedMessage,repeatIndicator,sourceMmsi);
  this.sequenceNumber=sequenceNumber;
  this.destinationMmsi=destinationMmsi;
  this.retransmit=retransmit;
  this.spare=spare;
  this.text=text;
}",0.9603174603174603
38856,"public static AidToNavigationReport fromEncodedMessage(EncodedAISMessage encodedMessage){
  if (!encodedMessage.isValid())   throw new InvalidEncodedMessage(encodedMessage);
  if (!encodedMessage.getMessageType().equals(AISMessageType.AidToNavigationReport))   throw new UnsupportedMessageType(encodedMessage.getMessageType().getCode());
  Integer repeatIndicator=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(6,8));
  MMSI sourceMmsi=MMSI.valueOf(DecoderImpl.convertToUnsignedLong(encodedMessage.getBits(8,38)));
  AidType aidType=AidType.fromInteger(DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(38,43)));
  String name=DecoderImpl.convertToString(encodedMessage.getBits(43,163));
  Boolean positionAccurate=DecoderImpl.convertToBoolean(encodedMessage.getBits(163,164));
  Float longitude=DecoderImpl.convertToFloat(encodedMessage.getBits(164,192)) / 600000f;
  Float latitude=DecoderImpl.convertToFloat(encodedMessage.getBits(192,219)) / 600000f;
  Integer toBow=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(219,228));
  Integer toStern=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(228,237));
  Integer toPort=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(237,243));
  Integer toStarboard=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(243,249));
  PositionFixingDevice positionFixingDevice=PositionFixingDevice.fromInteger(DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(249,253)));
  Integer second=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(253,259));
  Boolean offPosition=DecoderImpl.convertToBoolean(encodedMessage.getBits(259,260));
  String regionalUse=DecoderImpl.convertToBitString(encodedMessage.getBits(260,268));
  Boolean raimFlag=DecoderImpl.convertToBoolean(encodedMessage.getBits(268,269));
  Boolean virtualAid=DecoderImpl.convertToBoolean(encodedMessage.getBits(269,270));
  Boolean assignedMode=DecoderImpl.convertToBoolean(encodedMessage.getBits(270,271));
  String nameExtension=DecoderImpl.convertToString(encodedMessage.getBits(272,361));
  return new AidToNavigationReport(repeatIndicator,sourceMmsi,aidType,name,positionAccurate,latitude,longitude,toBow,toStern,toStarboard,toPort,positionFixingDevice,second,offPosition,regionalUse,raimFlag,virtualAid,assignedMode,nameExtension);
}","public static AidToNavigationReport fromEncodedMessage(EncodedAISMessage encodedMessage){
  if (!encodedMessage.isValid())   throw new InvalidEncodedMessage(encodedMessage);
  if (!encodedMessage.getMessageType().equals(AISMessageType.AidToNavigationReport))   throw new UnsupportedMessageType(encodedMessage.getMessageType().getCode());
  Integer repeatIndicator=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(6,8));
  MMSI sourceMmsi=MMSI.valueOf(DecoderImpl.convertToUnsignedLong(encodedMessage.getBits(8,38)));
  AidType aidType=AidType.fromInteger(DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(38,43)));
  String name=DecoderImpl.convertToString(encodedMessage.getBits(43,163));
  Boolean positionAccurate=DecoderImpl.convertToBoolean(encodedMessage.getBits(163,164));
  Float longitude=DecoderImpl.convertToFloat(encodedMessage.getBits(164,192)) / 600000f;
  Float latitude=DecoderImpl.convertToFloat(encodedMessage.getBits(192,219)) / 600000f;
  Integer toBow=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(219,228));
  Integer toStern=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(228,237));
  Integer toPort=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(237,243));
  Integer toStarboard=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(243,249));
  PositionFixingDevice positionFixingDevice=PositionFixingDevice.fromInteger(DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(249,253)));
  Integer second=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(253,259));
  Boolean offPosition=DecoderImpl.convertToBoolean(encodedMessage.getBits(259,260));
  String regionalUse=DecoderImpl.convertToBitString(encodedMessage.getBits(260,268));
  Boolean raimFlag=DecoderImpl.convertToBoolean(encodedMessage.getBits(268,269));
  Boolean virtualAid=DecoderImpl.convertToBoolean(encodedMessage.getBits(269,270));
  Boolean assignedMode=DecoderImpl.convertToBoolean(encodedMessage.getBits(270,271));
  int spare1=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(271,272));
  String nameExtension=null;
  int spare2=0;
  if (encodedMessage.getNumberOfBits() > 272) {
    int extraBits=encodedMessage.getNumberOfBits() - 272;
    int extraChars=extraBits / 6;
    int extraBitsOfChars=extraChars * 6;
    nameExtension=DecoderImpl.convertToString(encodedMessage.getBits(272,272 + extraBitsOfChars));
    spare2=(extraBits == extraBitsOfChars) ? 0 : DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(272 + extraBitsOfChars,encodedMessage.getNumberOfBits()));
  }
  return new AidToNavigationReport(repeatIndicator,sourceMmsi,aidType,name,positionAccurate,latitude,longitude,toBow,toStern,toStarboard,toPort,positionFixingDevice,second,offPosition,regionalUse,raimFlag,virtualAid,assignedMode,spare1,nameExtension,spare2);
}",0.9000387446726075
38857,"public AidToNavigationReport(Integer repeatIndicator,MMSI sourceMmsi,AidType aidType,String name,Boolean positionAccurate,Float latitude,Float longitude,Integer toBow,Integer toStern,Integer toStarboard,Integer toPort,PositionFixingDevice positionFixingDevice,Integer second,Boolean offPosition,String regionalUse,Boolean raimFlag,Boolean virtualAid,Boolean assignedMode,String nameExtension){
  super(AISMessageType.AidToNavigationReport,repeatIndicator,sourceMmsi);
  this.aidType=aidType;
  this.name=name;
  this.positionAccurate=positionAccurate;
  this.latitude=latitude;
  this.longitude=longitude;
  this.toBow=toBow;
  this.toStern=toStern;
  this.toStarboard=toStarboard;
  this.toPort=toPort;
  this.positionFixingDevice=positionFixingDevice;
  this.second=second;
  this.offPosition=offPosition;
  this.regionalUse=regionalUse;
  this.raimFlag=raimFlag;
  this.virtualAid=virtualAid;
  this.assignedMode=assignedMode;
  this.nameExtension=nameExtension;
}","public AidToNavigationReport(Integer repeatIndicator,MMSI sourceMmsi,AidType aidType,String name,Boolean positionAccurate,Float latitude,Float longitude,Integer toBow,Integer toStern,Integer toStarboard,Integer toPort,PositionFixingDevice positionFixingDevice,Integer second,Boolean offPosition,String regionalUse,Boolean raimFlag,Boolean virtualAid,Boolean assignedMode,int spare1,String nameExtension,int spare2){
  super(AISMessageType.AidToNavigationReport,repeatIndicator,sourceMmsi);
  this.aidType=aidType;
  this.name=name;
  this.positionAccurate=positionAccurate;
  this.latitude=latitude;
  this.longitude=longitude;
  this.toBow=toBow;
  this.toStern=toStern;
  this.toStarboard=toStarboard;
  this.toPort=toPort;
  this.positionFixingDevice=positionFixingDevice;
  this.second=second;
  this.offPosition=offPosition;
  this.regionalUse=regionalUse;
  this.raimFlag=raimFlag;
  this.virtualAid=virtualAid;
  this.assignedMode=assignedMode;
  this.spare1=spare1;
  this.nameExtension=nameExtension;
  this.spare2=spare2;
}",0.967
38858,"public BinaryAcknowledge(Integer repeatIndicator,MMSI sourceMmsi,MMSI mmsi1,MMSI mmsi2,MMSI mmsi3,MMSI mmsi4){
  super(AISMessageType.BinaryAcknowledge,repeatIndicator,sourceMmsi);
  this.mmsi1=mmsi1;
  this.mmsi2=mmsi2;
  this.mmsi3=mmsi3;
  this.mmsi4=mmsi4;
}","public BinaryAcknowledge(Integer repeatIndicator,MMSI sourceMmsi,int spare,MMSI mmsi1,int sequence1,MMSI mmsi2,int sequence2,MMSI mmsi3,int sequence3,MMSI mmsi4,int sequence4,int numOfAcks){
  super(AISMessageType.BinaryAcknowledge,repeatIndicator,sourceMmsi);
  this.spare=spare;
  this.mmsi1=mmsi1;
  this.sequence1=sequence1;
  this.mmsi2=mmsi2;
  this.sequence2=sequence2;
  this.mmsi3=mmsi3;
  this.sequence3=sequence3;
  this.mmsi4=mmsi4;
  this.sequence4=sequence4;
  this.numOfAcks=numOfAcks;
}",0.6858638743455497
38859,"public static BinaryAcknowledge fromEncodedMessage(EncodedAISMessage encodedMessage){
  if (!encodedMessage.isValid())   throw new InvalidEncodedMessage(encodedMessage);
  if (!encodedMessage.getMessageType().equals(AISMessageType.BinaryAcknowledge))   throw new UnsupportedMessageType(encodedMessage.getMessageType().getCode());
  Integer repeatIndicator=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(6,8));
  MMSI sourceMmsi=MMSI.valueOf(DecoderImpl.convertToUnsignedLong(encodedMessage.getBits(8,38)));
  MMSI mmsi1=MMSI.valueOf(DecoderImpl.convertToUnsignedLong(encodedMessage.getBits(40,70)));
  MMSI mmsi2=MMSI.valueOf(DecoderImpl.convertToUnsignedLong(encodedMessage.getBits(72,102)));
  MMSI mmsi3=MMSI.valueOf(DecoderImpl.convertToUnsignedLong(encodedMessage.getBits(104,134)));
  MMSI mmsi4=MMSI.valueOf(DecoderImpl.convertToUnsignedLong(encodedMessage.getBits(136,166)));
  return new BinaryAcknowledge(repeatIndicator,sourceMmsi,mmsi1,mmsi2,mmsi3,mmsi4);
}","public static BinaryAcknowledge fromEncodedMessage(EncodedAISMessage encodedMessage){
  if (!encodedMessage.isValid())   throw new InvalidEncodedMessage(encodedMessage);
  if (!encodedMessage.getMessageType().equals(AISMessageType.BinaryAcknowledge))   throw new UnsupportedMessageType(encodedMessage.getMessageType().getCode());
  Integer repeatIndicator=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(6,8));
  MMSI sourceMmsi=MMSI.valueOf(DecoderImpl.convertToUnsignedLong(encodedMessage.getBits(8,38)));
  int spare=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(38,40));
  MMSI mmsi1=MMSI.valueOf(DecoderImpl.convertToUnsignedLong(encodedMessage.getBits(40,70)));
  int sequence1=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(70,72));
  int numOfAcks=1;
  MMSI mmsi2=null;
  int sequence2=0;
  if (encodedMessage.getNumberOfBits() > 72) {
    mmsi2=MMSI.valueOf(DecoderImpl.convertToUnsignedLong(encodedMessage.getBits(72,102)));
    sequence2=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(102,104));
    numOfAcks++;
  }
  MMSI mmsi3=null;
  int sequence3=0;
  if (encodedMessage.getNumberOfBits() > 104) {
    mmsi3=MMSI.valueOf(DecoderImpl.convertToUnsignedLong(encodedMessage.getBits(104,134)));
    sequence3=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(134,136));
    numOfAcks++;
  }
  MMSI mmsi4=null;
  int sequence4=0;
  if (encodedMessage.getNumberOfBits() > 136) {
    mmsi4=MMSI.valueOf(DecoderImpl.convertToUnsignedLong(encodedMessage.getBits(136,166)));
    sequence4=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(166,168));
    numOfAcks++;
  }
  return new BinaryAcknowledge(repeatIndicator,sourceMmsi,spare,mmsi1,sequence1,mmsi2,sequence2,mmsi3,sequence3,mmsi4,sequence4,numOfAcks);
}",0.6207145434861061
38860,"public GNSSBinaryBroadcastMessage(Integer repeatIndicator,MMSI sourceMmsi,Float latitude,Float longitude,String binaryData){
  super(AISMessageType.GNSSBinaryBroadcastMessage,repeatIndicator,sourceMmsi);
  this.latitude=latitude;
  this.longitude=longitude;
  this.binaryData=binaryData;
}","public GNSSBinaryBroadcastMessage(Integer repeatIndicator,MMSI sourceMmsi,int spare1,Float latitude,Float longitude,int spare2,int mType,int stationId,int zCount,int sequenceNumber,int numOfWords,int health,String binaryData){
  super(AISMessageType.GNSSBinaryBroadcastMessage,repeatIndicator,sourceMmsi);
  this.spare1=spare1;
  this.latitude=latitude;
  this.longitude=longitude;
  this.spare2=spare2;
  this.mType=mType;
  this.stationId=stationId;
  this.zCount=zCount;
  this.sequenceNumber=sequenceNumber;
  this.numOfWords=numOfWords;
  this.health=health;
  this.binaryData=binaryData;
}",0.5520361990950227
38861,"public static GNSSBinaryBroadcastMessage fromEncodedMessage(EncodedAISMessage encodedMessage){
  if (!encodedMessage.isValid())   throw new InvalidEncodedMessage(encodedMessage);
  if (!encodedMessage.getMessageType().equals(AISMessageType.GNSSBinaryBroadcastMessage))   throw new UnsupportedMessageType(encodedMessage.getMessageType().getCode());
  Integer repeatIndicator=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(6,8));
  MMSI sourceMmsi=MMSI.valueOf(DecoderImpl.convertToUnsignedLong(encodedMessage.getBits(8,38)));
  Float longitude=DecoderImpl.convertToFloat(encodedMessage.getBits(40,58)) / 10f;
  Float latitude=DecoderImpl.convertToFloat(encodedMessage.getBits(58,75)) / 10f;
  String binaryData=DecoderImpl.convertToBitString(encodedMessage.getBits(80,816));
  return new GNSSBinaryBroadcastMessage(repeatIndicator,sourceMmsi,latitude,longitude,binaryData);
}","public static GNSSBinaryBroadcastMessage fromEncodedMessage(EncodedAISMessage encodedMessage){
  if (!encodedMessage.isValid())   throw new InvalidEncodedMessage(encodedMessage);
  if (!encodedMessage.getMessageType().equals(AISMessageType.GNSSBinaryBroadcastMessage))   throw new UnsupportedMessageType(encodedMessage.getMessageType().getCode());
  Integer repeatIndicator=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(6,8));
  MMSI sourceMmsi=MMSI.valueOf(DecoderImpl.convertToUnsignedLong(encodedMessage.getBits(8,38)));
  int spare1=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(38,40));
  Float longitude=DecoderImpl.convertToFloat(encodedMessage.getBits(40,58)) / 10f;
  Float latitude=DecoderImpl.convertToFloat(encodedMessage.getBits(58,75)) / 10f;
  int spare2=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(75,80));
  int mType=0;
  int stationId=0;
  int zCount=0;
  int sequenceNumber=0;
  int numOfWords=0;
  int health=0;
  if (encodedMessage.getNumberOfBits() > 80) {
    mType=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(80,86));
    stationId=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(86,96));
    zCount=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(96,109));
    sequenceNumber=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(109,112));
    numOfWords=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(112,117));
    health=DecoderImpl.convertToUnsignedInteger(encodedMessage.getBits(117,120));
  }
  String binaryData=DecoderImpl.convertToBitString(encodedMessage.getBits(80,encodedMessage.getNumberOfBits()));
  return new GNSSBinaryBroadcastMessage(repeatIndicator,sourceMmsi,spare1,latitude,longitude,spare2,mType,stationId,zCount,sequenceNumber,numOfWords,health,binaryData);
}",0.6417191552426825
38862,"private void removeTag(final Dtos.TaskTag tag){
  filterObject.remove(tag);
  tagsFilter.remove(new PanelWithCheckboxes.Predicate(){
    @Override public boolean toRemove(    FilterCheckBox w){
      Dtos.TaskTag candidate=(Dtos.TaskTag)w.getEntity();
      return objEq(candidate.getName(),tag.getName());
    }
  }
);
}","private void removeTag(final Dtos.TaskTag tag){
  filterObject.deleteFromStorage(tag);
  tagsFilter.remove(new PanelWithCheckboxes.Predicate(){
    @Override public boolean toRemove(    FilterCheckBox w){
      Dtos.TaskTag candidate=(Dtos.TaskTag)w.getEntity();
      return objEq(candidate.getName(),tag.getName());
    }
  }
);
  filterObject.storeFilterData();
}",0.9199417758369725
38863,"private TaskTagsManager(){
  AddedEditedListener addedEditedListener=new AddedEditedListener();
  MessageBus.registerListener(TaskAddedMessage.class,addedEditedListener);
  MessageBus.registerListener(TaskEditedMessage.class,addedEditedListener);
  MessageBus.registerListener(TaskDeletedMessage.class,new RemovedListener());
}","private TaskTagsManager(){
  AddedOrEditedListener addedOrEditedListener=new AddedOrEditedListener();
  MessageBus.registerListener(TaskAddedMessage.class,addedOrEditedListener);
  MessageBus.registerListener(TaskEditedMessage.class,addedOrEditedListener);
  MessageBus.registerListener(TaskDeletedMessage.class,new RemovedListener());
}",0.9246987951807228
38864,List<Filtered<BoardWithProjectsDto>> getBoardWithProjectsDto();,List<BoardWithProjectsWithSelectedDto> getBoardWithProjectsDto();,0.828125
38865,void setUsers(List<Dtos.Filtered<Dtos.UserDto>> users);,void setUsers(List<UserWithSelectedDto> users);,0.6862745098039216
38866,List<Dtos.Filtered<Dtos.UserDto>> getUsers();,List<UserWithSelectedDto> getUsers();,0.6097560975609756
38867,void setBoardWithProjectsDto(List<Filtered<BoardWithProjectsDto>> boardWithProjectsDto);,void setBoardWithProjectsDto(List<BoardWithProjectsWithSelectedDto> boardWithProjectsDto);,0.8764044943820225
38868,void setBoards(List<Filtered<BoardDto>> boards);,void setBoards(List<BoardWithSelectedDto> boards);,0.7755102040816326
38869,void setClassesOfServices(List<Filtered<Dtos.ClassOfServiceDto>> classesOfServices);,void setClassesOfServices(List<ClassOfServiceWithSelectedDto> classesOfServices);,0.8363636363636363
38870,List<Filtered<Dtos.ClassOfServiceDto>> getClassesOfServices();,List<ClassOfServiceWithSelectedDto> getClassesOfServices();,0.7768595041322314
38871,List<Filtered<BoardDto>> getBoards();,List<BoardWithSelectedDto> getBoards();,0.7105263157894737
38872,"@Override public void messageArrived(Message<BoardsFilter> message){
  List<Dtos.Filtered<Dtos.BoardDto>> visibleBoards=message.getPayload().getFilterDataDto().getBoards();
  setVisible(false);
  if (visibleBoards == null || visibleBoards.size() == 0) {
    return;
  }
  for (  Dtos.Filtered<Dtos.BoardDto> visibleBoard : visibleBoards) {
    if (visibleBoard.getData().getId().equals(boardDto.getId())) {
      setVisible(true);
      break;
    }
  }
}","@Override public void messageArrived(Message<BoardsFilter> message){
  List<Dtos.BoardWithSelectedDto> visibleBoards=message.getPayload().getFilterDataDto().getBoards();
  setVisible(false);
  if (visibleBoards == null || visibleBoards.size() == 0) {
    return;
  }
  for (  Dtos.BoardWithSelectedDto visibleBoard : visibleBoards) {
    if (!visibleBoard.isSelected()) {
      continue;
    }
    if (visibleBoard.getBoard().getId().equals(boardDto.getId())) {
      setVisible(true);
      break;
    }
  }
}",0.8062176165803109
38873,"public void add(Dtos.BoardWithProjectsDto entity){
  int id=findById(entity);
  if (id == -1) {
    filterDataDto.getBoardWithProjectsDto().add(DtoFactory.filtered(entity,true));
  }
}","public void add(Dtos.BoardWithProjectsDto entity){
  int id=findById(entity);
  if (id == -1) {
    filterDataDto.getBoardWithProjectsDto().add(DtoFactory.withSelected(entity,true));
  }
 else {
    filterDataDto.getBoardWithProjectsDto().get(id).setSelected(true);
  }
}",0.7824175824175824
38874,"public boolean taskMatches(Dtos.TaskDto task){
  List<Dtos.FilteredEntity> filteredEntities=filterDataDto.getFullTextFilter().getFilteredEntities();
  if (filteredEntities != null && filteredEntities.size() != 0) {
    boolean matches=false;
    if (filteredEntities.contains(Dtos.FilteredEntity.SHORT_DESCRIPTION)) {
      if (stringMatches(filterDataDto.getFullTextFilter(),task.getName())) {
        matches=true;
      }
    }
    if (!matches && filteredEntities.contains(Dtos.FilteredEntity.LONG_DESCRIPTION)) {
      if (stringMatches(filterDataDto.getFullTextFilter(),new HTML(task.getDescription()).getText())) {
        matches=true;
      }
    }
    if (!matches && filteredEntities.contains(Dtos.FilteredEntity.TICKET_ID)) {
      if (stringMatches(filterDataDto.getFullTextFilter(),task.getTicketId())) {
        matches=true;
      }
    }
    if (!matches) {
      return false;
    }
  }
  if (!checkDueDates(task)) {
    return false;
  }
  boolean classOfServiceMatches=(task.getClassOfService() != null && findById(task.getClassOfService()) != -1);
  if (!classOfServiceMatches) {
    return false;
  }
  boolean userMatches=findById(task.getAssignee()) != -1;
  return userMatches;
}","public boolean taskMatches(Dtos.TaskDto task){
  List<Dtos.FilteredEntity> filteredEntities=filterDataDto.getFullTextFilter().getFilteredEntities();
  if (filteredEntities != null && filteredEntities.size() != 0) {
    boolean matches=false;
    if (filteredEntities.contains(Dtos.FilteredEntity.SHORT_DESCRIPTION)) {
      if (stringMatches(filterDataDto.getFullTextFilter(),task.getName())) {
        matches=true;
      }
    }
    if (!matches && filteredEntities.contains(Dtos.FilteredEntity.LONG_DESCRIPTION)) {
      if (stringMatches(filterDataDto.getFullTextFilter(),new HTML(task.getDescription()).getText())) {
        matches=true;
      }
    }
    if (!matches && filteredEntities.contains(Dtos.FilteredEntity.TICKET_ID)) {
      if (stringMatches(filterDataDto.getFullTextFilter(),task.getTicketId())) {
        matches=true;
      }
    }
    if (!matches) {
      return false;
    }
  }
  if (!checkDueDates(task)) {
    return false;
  }
  int classOfServicePosition=task.getClassOfService() == null ? -1 : findById(task.getClassOfService());
  boolean classOfServiceMatches=task.getClassOfService() != null && classOfServicePosition != -1 && filterDataDto.getClassesOfServices().get(classOfServicePosition).isSelected();
  if (!classOfServiceMatches) {
    return false;
  }
  int assigneePosition=findById(task.getAssignee());
  boolean userMatches=assigneePosition != -1 && filterDataDto.getUsers().get(assigneePosition).isSelected();
  return userMatches;
}",0.8636363636363636
38875,"public boolean projectOnBoardMatches(Dtos.ProjectDto projectDto,Dtos.BoardDto boardDto){
  Dtos.BoardWithProjectsDto boardWithProjectsDto=DtoFactory.boardWithProjectsDto();
  boardWithProjectsDto.setBoard(boardDto);
  List<Dtos.ProjectDto> projects=new ArrayList<Dtos.ProjectDto>();
  projects.add(projectDto);
  boardWithProjectsDto.setProjectsOnBoard(DtoFactory.projectsDto(projects));
  return findById(boardWithProjectsDto) != -1;
}","public boolean projectOnBoardMatches(Dtos.ProjectDto projectDto,Dtos.BoardDto boardDto){
  Dtos.BoardWithProjectsDto boardWithProjectsDto=DtoFactory.boardWithProjectsDto();
  boardWithProjectsDto.setBoard(boardDto);
  List<Dtos.ProjectDto> projects=new ArrayList<Dtos.ProjectDto>();
  projects.add(projectDto);
  boardWithProjectsDto.setProjectsOnBoard(DtoFactory.projectsDto(projects));
  int projectOnBoardPosition=findById(boardWithProjectsDto);
  return projectOnBoardPosition != -1 && filterDataDto.getBoardWithProjectsDto().get(projectOnBoardPosition).isSelected();
}",0.8503468780971258
38876,"public void remove(Dtos.BoardWithProjectsDto entity){
  int id=findById(entity);
  if (id != -1) {
    filterDataDto.getBoardWithProjectsDto().get(id).setSelected(false);
  }
}","public void remove(Dtos.BoardWithProjectsDto entity){
  int id=findById(entity);
  if (id != -1) {
    filterDataDto.getBoardWithProjectsDto().get(id).setSelected(false);
  }
 else {
    filterDataDto.getBoardWithProjectsDto().add(DtoFactory.withSelected(entity,false));
  }
}",0.7787610619469026
38877,"public int findById(Dtos.BoardWithProjectsDto boardWithProjectsDto){
  int id=0;
  String boardId=boardWithProjectsDto.getBoard().getId();
  String projectId=boardWithProjectsDto.getProjectsOnBoard().getValues().get(0).getId();
  for (  Dtos.Filtered<Dtos.BoardWithProjectsDto> candidate : filterDataDto.getBoardWithProjectsDto()) {
    if (candidate.getData().getBoard().getId().equals(boardId) && candidate.getData().getProjectsOnBoard().getValues().get(0).getId().equals(projectId)) {
      return id;
    }
    id++;
  }
  return -1;
}","public int findById(Dtos.BoardWithProjectsDto boardWithProjectsDto){
  int id=0;
  String boardId=boardWithProjectsDto.getBoard().getId();
  String projectId=boardWithProjectsDto.getProjectsOnBoard().getValues().get(0).getId();
  for (  Dtos.BoardWithProjectsWithSelectedDto candidate : filterDataDto.getBoardWithProjectsDto()) {
    if (candidate.getBoardWithProjects().getBoard().getId().equals(boardId) && candidate.getBoardWithProjects().getProjectsOnBoard().getValues().get(0).getId().equals(projectId)) {
      return id;
    }
    id++;
  }
  return -1;
}",0.9009990917347864
38878,"public UserFilterCheckBox(Dtos.UserDto entity,BoardsFilter filter){
  super(entity,filter);
  setValue(filter.findById(entity) != -1);
}","public UserFilterCheckBox(Dtos.UserDto entity,BoardsFilter filter){
  super(entity,filter);
  setValue(filter.isSelected(entity));
}",0.9253731343283582
38879,"private boolean createFilterObject(){
  boolean loaded=true;
  filterObject=new BoardsFilter();
  Dtos.FilterDataDto filterDataDto=filterObject.loadFilterData();
  if (filterDataDto == null) {
    filterDataDto=DtoFactory.filterDataDto();
    filterDataDto.setFullTextFilter(DtoFactory.fullTextMatcherDataDto());
    List<Dtos.FilteredEntity> entities=new ArrayList<Dtos.FilteredEntity>();
    entities.add(Dtos.FilteredEntity.LONG_DESCRIPTION);
    entities.add(Dtos.FilteredEntity.SHORT_DESCRIPTION);
    filterDataDto.getFullTextFilter().setCaseSensitive(false);
    filterDataDto.getFullTextFilter().setInverse(false);
    filterDataDto.getFullTextFilter().setRegex(false);
    filterDataDto.getFullTextFilter().setString(""String_Node_Str"");
    filterDataDto.getFullTextFilter().setFilteredEntities(entities);
    filterDataDto.setClassesOfServices(new ArrayList<Dtos.Filtered<Dtos.ClassOfServiceDto>>());
    filterDataDto.setUsers(new ArrayList<Dtos.Filtered<Dtos.UserDto>>());
    filterDataDto.setBoards(new ArrayList<Dtos.Filtered<Dtos.BoardDto>>());
    filterDataDto.setBoardWithProjectsDto(new ArrayList<Dtos.Filtered<Dtos.BoardWithProjectsDto>>());
    Dtos.DateMatcherDataDto dueDateFilter=DtoFactory.dateMatcherDataDto();
    dueDateFilter.setCondition(0);
    dueDateFilter.setDateFrom(""String_Node_Str"");
    dueDateFilter.setDateTo(""String_Node_Str"");
    filterDataDto.setDueDate(dueDateFilter);
    loaded=false;
  }
  filterObject.setFilterDataDto(filterDataDto);
  return loaded;
}","private boolean createFilterObject(){
  boolean loaded=true;
  filterObject=new BoardsFilter();
  Dtos.FilterDataDto filterDataDto=filterObject.loadFilterData();
  if (filterDataDto == null) {
    filterDataDto=DtoFactory.filterDataDto();
    filterDataDto.setFullTextFilter(DtoFactory.fullTextMatcherDataDto());
    List<Dtos.FilteredEntity> entities=new ArrayList<Dtos.FilteredEntity>();
    entities.add(Dtos.FilteredEntity.LONG_DESCRIPTION);
    entities.add(Dtos.FilteredEntity.SHORT_DESCRIPTION);
    filterDataDto.getFullTextFilter().setCaseSensitive(false);
    filterDataDto.getFullTextFilter().setInverse(false);
    filterDataDto.getFullTextFilter().setRegex(false);
    filterDataDto.getFullTextFilter().setString(""String_Node_Str"");
    filterDataDto.getFullTextFilter().setFilteredEntities(entities);
    filterDataDto.setClassesOfServices(new ArrayList<Dtos.ClassOfServiceWithSelectedDto>());
    filterDataDto.setUsers(new ArrayList<Dtos.UserWithSelectedDto>());
    filterDataDto.setBoards(new ArrayList<Dtos.BoardWithSelectedDto>());
    filterDataDto.setBoardWithProjectsDto(new ArrayList<Dtos.BoardWithProjectsWithSelectedDto>());
    Dtos.DateMatcherDataDto dueDateFilter=DtoFactory.dateMatcherDataDto();
    dueDateFilter.setCondition(0);
    dueDateFilter.setDateFrom(""String_Node_Str"");
    dueDateFilter.setDateTo(""String_Node_Str"");
    filterDataDto.setDueDate(dueDateFilter);
    loaded=false;
  }
  filterObject.setFilterDataDto(filterDataDto);
  return loaded;
}",0.9559412550066756
38880,"public static <T>String asJson(T dto){
  AutoBean<T> bean=AutoBeanUtils.getAutoBean(dto);
  return ""String_Node_Str"" + URL.encodePathSegment(AutoBeanCodex.encode(bean).getPayload());
}","public static <T>String asJson(T dto){
  return ""String_Node_Str"" + URL.encodePathSegment(asRawJson(dto));
}",0.6643835616438356
38881,"private int findById(Dtos.BoardWithProjectsDto boardWithProjectsDto){
  int id=0;
  String boardId=boardWithProjectsDto.getBoard().getId();
  String projectId=boardWithProjectsDto.getProjectsOnBoard().getValues().get(0).getId();
  for (  Dtos.BoardWithProjectsDto candidate : filterDataDto.getBoardWithProjectsDto()) {
    if (candidate.getBoard().getId().equals(boardId) && candidate.getProjectsOnBoard().getValues().get(0).getId().equals(projectId)) {
      return id;
    }
    id++;
  }
  return -1;
}","public int findById(Dtos.BoardWithProjectsDto boardWithProjectsDto){
  int id=0;
  String boardId=boardWithProjectsDto.getBoard().getId();
  String projectId=boardWithProjectsDto.getProjectsOnBoard().getValues().get(0).getId();
  for (  Dtos.BoardWithProjectsDto candidate : filterDataDto.getBoardWithProjectsDto()) {
    if (candidate.getBoard().getId().equals(boardId) && candidate.getProjectsOnBoard().getValues().get(0).getId().equals(projectId)) {
      return id;
    }
    id++;
  }
  return -1;
}",0.9890981169474728
38882,"public boolean taskMatches(Dtos.TaskDto task){
  List<Dtos.FilteredEntity> filteredEntities=filterDataDto.getFullTextFilter().getFilteredEntities();
  if (filteredEntities != null && filteredEntities.size() != 0) {
    boolean matches=false;
    if (filteredEntities.contains(Dtos.FilteredEntity.SHORT_DESCRIPTION)) {
      if (stringMatches(filterDataDto.getFullTextFilter(),task.getName())) {
        matches=true;
      }
      if (!matches && filteredEntities.contains(Dtos.FilteredEntity.LONG_DESCRIPTION)) {
        if (stringMatches(filterDataDto.getFullTextFilter(),new HTML(task.getDescription()).getText())) {
          matches=true;
        }
      }
      if (!matches && filteredEntities.contains(Dtos.FilteredEntity.TICKET_ID)) {
        if (stringMatches(filterDataDto.getFullTextFilter(),task.getTicketId())) {
          matches=true;
        }
      }
      if (!matches) {
        return false;
      }
    }
  }
  if (!checkDueDates(task)) {
    return false;
  }
  boolean classOfServiceMatches=(task.getClassOfService() != null && findById(task.getClassOfService()) != -1);
  if (!classOfServiceMatches) {
    return false;
  }
  boolean userMatches=filterDataDto.getUsers().isEmpty() || (task.getAssignee() != null && findById(task.getAssignee()) != -1);
  return userMatches;
}","public boolean taskMatches(Dtos.TaskDto task){
  List<Dtos.FilteredEntity> filteredEntities=filterDataDto.getFullTextFilter().getFilteredEntities();
  if (filteredEntities != null && filteredEntities.size() != 0) {
    boolean matches=false;
    if (filteredEntities.contains(Dtos.FilteredEntity.SHORT_DESCRIPTION)) {
      if (stringMatches(filterDataDto.getFullTextFilter(),task.getName())) {
        matches=true;
      }
      if (!matches && filteredEntities.contains(Dtos.FilteredEntity.LONG_DESCRIPTION)) {
        if (stringMatches(filterDataDto.getFullTextFilter(),new HTML(task.getDescription()).getText())) {
          matches=true;
        }
      }
      if (!matches && filteredEntities.contains(Dtos.FilteredEntity.TICKET_ID)) {
        if (stringMatches(filterDataDto.getFullTextFilter(),task.getTicketId())) {
          matches=true;
        }
      }
      if (!matches) {
        return false;
      }
    }
  }
  if (!checkDueDates(task)) {
    return false;
  }
  boolean classOfServiceMatches=(task.getClassOfService() != null && findById(task.getClassOfService()) != -1);
  if (!classOfServiceMatches) {
    return false;
  }
  boolean userMatches=(task.getAssignee() != null && findById(task.getAssignee()) != -1) || (task.getAssignee() == null && noUserSelected());
  return userMatches;
}",0.9655700076511096
38883,"public void removeTask(TaskDto task){
  for (int i=0; i < contentPanel.getWidgetCount(); i++) {
    Widget widget=contentPanel.getWidget(i);
    if (widget instanceof TaskGui) {
      if (((TaskGui)widget).getDto().equals(task)) {
        contentPanel.remove(i);
      }
    }
  }
}","public void removeTask(TaskDto task){
  int widgetIndex=getTaskIndex(task);
  if (widgetIndex != -1) {
    contentPanel.remove(widgetIndex);
  }
}",0.5186915887850467
38884,"public void messageArrived(Message<TaskDto> message){
  if (!(contentPanel instanceof TaskContainer)) {
    return;
  }
  if (!isThisPlace(message.getPayload())) {
    return;
  }
  if (message instanceof TaskDeleteRequestedMessage) {
    ((TaskContainer)contentPanel).removeTask(message.getPayload());
  }
 else   if (message instanceof TaskAddedMessage) {
    TaskGui task=new TaskGui(message.getPayload());
    dragController.makeDraggable(task,task.getHeader());
    ((TaskContainer)contentPanel).add(task);
  }
}","public void messageArrived(Message<TaskDto> message){
  if (!(contentPanel instanceof TaskContainer)) {
    return;
  }
  TaskDto taskDto=message.getPayload();
  if (!isThisPlace(taskDto)) {
    return;
  }
  if (((TaskContainer)contentPanel).containsTask(taskDto)) {
    return;
  }
  if (message instanceof TaskDeleteRequestedMessage) {
    ((TaskContainer)contentPanel).removeTask(taskDto);
  }
 else   if (message instanceof TaskAddedMessage) {
    TaskGui task=new TaskGui(taskDto);
    dragController.makeDraggable(task,task.getHeader());
    ((TaskContainer)contentPanel).add(task);
  }
}",0.2841726618705036
38885,"/** 
 * Method to create a Push button for the toolbar 
 */
private PushButton createPushButton(String url,Integer top,Integer left,Integer width,Integer height,String tip){
  Image extract=new Image(url,left,top,width,height);
  PushButton tb=new PushButton(extract);
  tb.setHeight(height + ""String_Node_Str"");
  tb.setWidth(width + ""String_Node_Str"");
  tb.addClickHandler(evHandler);
  if (tip != null) {
    tb.setTitle(tip);
  }
  return tb;
}","/** 
 * Method to create a Push button for the toolbar 
 */
private PushButton createPushButton(ImageResource imageResource,Integer width,Integer height,String tip){
  Image extract=new Image(imageResource);
  PushButton tb=new PushButton(extract);
  tb.setHeight(height + ""String_Node_Str"");
  tb.setWidth(width + ""String_Node_Str"");
  tb.addClickHandler(evHandler);
  if (tip != null) {
    tb.setTitle(tip);
  }
  return tb;
}",0.8747152619589977
38886,"/** 
 * Initialize the options on the toolbar 
 */
private void buildTools(){
  topPanel.add(bold=createToggleButton(HTTP_STATIC_ICONS_GIF,0,0,20,20,GUI_HOVERTEXT_BOLD));
  topPanel.add(italic=createToggleButton(HTTP_STATIC_ICONS_GIF,0,60,20,20,GUI_HOVERTEXT_ITALIC));
  topPanel.add(underline=createToggleButton(HTTP_STATIC_ICONS_GIF,0,140,20,20,GUI_HOVERTEXT_UNDERLINE));
  topPanel.add(stroke=createToggleButton(HTTP_STATIC_ICONS_GIF,0,120,20,20,GUI_HOVERTEXT_STROKE));
  topPanel.add(new HTML(""String_Node_Str""));
  topPanel.add(subscript=createToggleButton(HTTP_STATIC_ICONS_GIF,0,600,20,20,GUI_HOVERTEXT_SUBSCRIPT));
  topPanel.add(superscript=createToggleButton(HTTP_STATIC_ICONS_GIF,0,620,20,20,GUI_HOVERTEXT_SUPERSCRIPT));
  topPanel.add(new HTML(""String_Node_Str""));
  topPanel.add(alignleft=createPushButton(HTTP_STATIC_ICONS_GIF,0,460,20,20,GUI_HOVERTEXT_ALIGNLEFT));
  topPanel.add(alignmiddle=createPushButton(HTTP_STATIC_ICONS_GIF,0,420,20,20,GUI_HOVERTEXT_ALIGNCENTER));
  topPanel.add(alignright=createPushButton(HTTP_STATIC_ICONS_GIF,0,480,20,20,GUI_HOVERTEXT_ALIGNRIGHT));
  topPanel.add(new HTML(""String_Node_Str""));
  topPanel.add(orderlist=createPushButton(HTTP_STATIC_ICONS_GIF,0,80,20,20,GUI_HOVERTEXT_ORDERLIST));
  topPanel.add(unorderlist=createPushButton(HTTP_STATIC_ICONS_GIF,0,20,20,20,GUI_HOVERTEXT_UNORDERLIST));
  topPanel.add(indentright=createPushButton(HTTP_STATIC_ICONS_GIF,0,400,20,20,GUI_HOVERTEXT_IDENTRIGHT));
  topPanel.add(indentleft=createPushButton(HTTP_STATIC_ICONS_GIF,0,540,20,20,GUI_HOVERTEXT_IDENTLEFT));
  topPanel.add(new HTML(""String_Node_Str""));
  topPanel.add(generatelink=createPushButton(HTTP_STATIC_ICONS_GIF,0,500,20,20,GUI_HOVERTEXT_LINK));
  topPanel.add(breaklink=createPushButton(HTTP_STATIC_ICONS_GIF,0,640,20,20,GUI_HOVERTEXT_BREAKLINK));
  topPanel.add(new HTML(""String_Node_Str""));
  topPanel.add(insertline=createPushButton(HTTP_STATIC_ICONS_GIF,0,360,20,20,GUI_HOVERTEXT_HLINE));
  topPanel.add(insertimage=createPushButton(HTTP_STATIC_ICONS_GIF,0,380,20,20,GUI_HOVERTEXT_IMAGE));
  topPanel.add(new HTML(""String_Node_Str""));
  topPanel.add(removeformatting=createPushButton(HTTP_STATIC_ICONS_GIF,20,460,20,20,GUI_HOVERTEXT_REMOVEFORMAT));
  topPanel.add(new HTML(""String_Node_Str""));
  topPanel.add(texthtml=createToggleButton(HTTP_STATIC_ICONS_GIF,0,260,20,20,GUI_HOVERTEXT_SWITCHVIEW));
  bottomPanel.add(fontlist=createFontList());
  bottomPanel.add(new HTML(""String_Node_Str""));
  bottomPanel.add(colorlist=createColorList());
}","/** 
 * Initialize the options on the toolbar 
 */
private void buildTools(){
  topPanel.add(bold=createToggleButton(resources.bold(),20,20,GUI_HOVERTEXT_BOLD));
  topPanel.add(italic=createToggleButton(resources.italic(),20,20,GUI_HOVERTEXT_ITALIC));
  topPanel.add(underline=createToggleButton(resources.underline(),20,20,GUI_HOVERTEXT_UNDERLINE));
  topPanel.add(stroke=createToggleButton(resources.stroke(),20,20,GUI_HOVERTEXT_STROKE));
  topPanel.add(new HTML(""String_Node_Str""));
  topPanel.add(subscript=createToggleButton(resources.subscript(),20,20,GUI_HOVERTEXT_SUBSCRIPT));
  topPanel.add(superscript=createToggleButton(resources.superscript(),20,20,GUI_HOVERTEXT_SUPERSCRIPT));
  topPanel.add(new HTML(""String_Node_Str""));
  topPanel.add(alignleft=createPushButton(resources.alignleft(),20,20,GUI_HOVERTEXT_ALIGNLEFT));
  topPanel.add(alignmiddle=createPushButton(resources.alignmiddle(),20,20,GUI_HOVERTEXT_ALIGNCENTER));
  topPanel.add(alignright=createPushButton(resources.alignright(),20,20,GUI_HOVERTEXT_ALIGNRIGHT));
  topPanel.add(new HTML(""String_Node_Str""));
  topPanel.add(orderlist=createPushButton(resources.orderlist(),20,20,GUI_HOVERTEXT_ORDERLIST));
  topPanel.add(unorderlist=createPushButton(resources.unorderlist(),20,20,GUI_HOVERTEXT_UNORDERLIST));
  topPanel.add(indentright=createPushButton(resources.indentright(),20,20,GUI_HOVERTEXT_IDENTRIGHT));
  topPanel.add(indentleft=createPushButton(resources.indentleft(),20,20,GUI_HOVERTEXT_IDENTLEFT));
  topPanel.add(new HTML(""String_Node_Str""));
  topPanel.add(generatelink=createPushButton(resources.generatelink(),20,20,GUI_HOVERTEXT_LINK));
  topPanel.add(breaklink=createPushButton(resources.breaklink(),20,20,GUI_HOVERTEXT_BREAKLINK));
  topPanel.add(new HTML(""String_Node_Str""));
  topPanel.add(insertline=createPushButton(resources.insertline(),20,20,GUI_HOVERTEXT_HLINE));
  topPanel.add(insertimage=createPushButton(resources.insertimage(),20,20,GUI_HOVERTEXT_IMAGE));
  topPanel.add(new HTML(""String_Node_Str""));
  topPanel.add(removeformatting=createPushButton(resources.removeformatting(),20,20,GUI_HOVERTEXT_REMOVEFORMAT));
  topPanel.add(new HTML(""String_Node_Str""));
  topPanel.add(texthtml=createToggleButton(resources.texthtml(),20,20,GUI_HOVERTEXT_SWITCHVIEW));
  bottomPanel.add(fontlist=createFontList());
  bottomPanel.add(new HTML(""String_Node_Str""));
  bottomPanel.add(colorlist=createColorList());
}",0.8126401630988787
38887,"/** 
 * Method to create a Toggle button for the toolbar 
 */
private ToggleButton createToggleButton(String url,Integer top,Integer left,Integer width,Integer height,String tip){
  Image extract=new Image(url,left,top,width,height);
  ToggleButton tb=new ToggleButton(extract);
  tb.setHeight(height + ""String_Node_Str"");
  tb.setWidth(width + ""String_Node_Str"");
  tb.addClickHandler(evHandler);
  if (tip != null) {
    tb.setTitle(tip);
  }
  return tb;
}","/** 
 * Method to create a Toggle button for the toolbar 
 */
private ToggleButton createToggleButton(ImageResource imageResource,Integer width,Integer height,String tip){
  Image extract=new Image(imageResource);
  ToggleButton tb=new ToggleButton(extract);
  tb.setHeight(height + ""String_Node_Str"");
  tb.setWidth(width + ""String_Node_Str"");
  tb.addClickHandler(evHandler);
  if (tip != null) {
    tb.setTitle(tip);
  }
  return tb;
}",0.8775055679287305
38888,"@Override public boolean canEnhance(Class<?> type,Class<? extends Annotation> qualifier){
  return RemoteWebDriver.class == type || ReusableRemoteWebDriver.class == type;
}","@Override public boolean canEnhance(Class<?> type,Class<? extends Annotation> qualifier){
  if (RemoteWebDriver.class == type || ReusableRemoteWebDriver.class == type) {
    return true;
  }
  if (RemoteWebDriver.class.isAssignableFrom(type) && DroneAugmented.class.isAssignableFrom(type)) {
    return true;
  }
  return false;
}",0.6573705179282868
38889,"/** 
 * Unwraps the instance
 */
@Override public RemoteWebDriver deenhance(RemoteWebDriver enhancedInstance,Class<? extends Annotation> qualifier){
  if (enhancedInstance instanceof DroneAugmented) {
    return (RemoteWebDriver)((DroneAugmented)enhancedInstance).getWrapped();
  }
  return enhancedInstance;
}","/** 
 * Unwraps the instance
 */
@Override public RemoteWebDriver deenhance(RemoteWebDriver enhancedInstance,Class<? extends Annotation> qualifier){
  if (enhancedInstance instanceof DroneAugmented) {
    RemoteWebDriver original=(RemoteWebDriver)((DroneAugmented)enhancedInstance).getWrapped();
    Capabilities capabilities=enhancedInstance.getCapabilities();
    if (capabilities != null) {
      ((DesiredCapabilities)enhancedInstance.getCapabilities()).setCapability(DRONE_AUGMENTED,Boolean.FALSE);
    }
    return original;
  }
  return enhancedInstance;
}",0.6918671248568156
38890,"/** 
 * Augments the instance
 */
@Override public RemoteWebDriver enhance(RemoteWebDriver instance,Class<? extends Annotation> qualifier){
  return (RemoteWebDriver)augmenter.augment(instance);
}","/** 
 * Augments the instance
 */
@Override public RemoteWebDriver enhance(RemoteWebDriver instance,Class<? extends Annotation> qualifier){
  RemoteWebDriver enhanced=(RemoteWebDriver)augmenter.augment(instance);
  return enhanced;
}",0.8811188811188811
38891,"@Test public void testCanEnhance(){
  assertTrue(enhancer.canEnhance(RemoteWebDriver.class,Default.class));
  assertTrue(enhancer.canEnhance(mock(RemoteWebDriver.class).getClass(),Default.class));
  assertFalse(enhancer.canEnhance(WebDriver.class,Default.class));
}","@Test public void testCanEnhance(){
  assertTrue(enhancer.canEnhance(RemoteWebDriver.class,Default.class));
  assertTrue(enhancer.canEnhance(ReusableRemoteWebDriver.class,Default.class));
  assertFalse(enhancer.canEnhance(WebDriver.class,Default.class));
  assertFalse(enhancer.canEnhance(mock(RemoteWebDriver.class).getClass(),Default.class));
}",0.6481178396072013
38892,"@Test public void whenBrowserIsCreatedAndQuitAndTriedToReuseThenItShouldThrowException(@Drone @Reusable RemoteWebDriver driver){
  driver.navigate().to(SERVER_URL.toString());
  Capabilities reusedCapabilities=serializeDeserialize(driver.getCapabilities());
  SessionId reusedSessionId=new SessionId(serializeDeserialize(driver.getSessionId().toString()));
  driver.quit();
  try {
    ReusableRemoteWebDriver.fromReusedSession(HUB_URL,reusedCapabilities,reusedSessionId);
    fail(""String_Node_Str"");
  }
 catch (  UnableReuseSessionException e) {
  }
}","@Test public void whenBrowserIsCreatedAndQuitAndTriedToReuseThenItShouldThrowException(@Drone @Reusable RemoteWebDriver driver){
  driver.navigate().to(SERVER_URL.toString());
  new AugmentingEnhancer().deenhance(driver,Reusable.class);
  Capabilities reusedCapabilities=serializeDeserialize(driver.getCapabilities());
  SessionId reusedSessionId=new SessionId(serializeDeserialize(driver.getSessionId().toString()));
  driver.quit();
  try {
    ReusableRemoteWebDriver.fromReusedSession(HUB_URL,reusedCapabilities,reusedSessionId);
    fail(""String_Node_Str"");
  }
 catch (  UnableReuseSessionException e) {
  }
}",0.9478186484174508
38893,"@Test public void whenBrowserIsCreatedThenCouldBeReused(@Drone @Reusable RemoteWebDriver driver) throws UnableReuseSessionException {
  driver.navigate().to(SERVER_URL.toString());
  Capabilities reusedCapabilities=serializeDeserialize(driver.getCapabilities());
  SessionId reusedSessionId=new SessionId(serializeDeserialize(driver.getSessionId().toString()));
  RemoteWebDriver reusedDriver=ReusableRemoteWebDriver.fromReusedSession(HUB_URL,reusedCapabilities,reusedSessionId);
  reusedDriver.navigate().to(HUB_URL.toString());
}","@Test public void whenBrowserIsCreatedThenCouldBeReused(@Drone @Reusable RemoteWebDriver driver) throws UnableReuseSessionException {
  driver.navigate().to(SERVER_URL.toString());
  new AugmentingEnhancer().deenhance(driver,Reusable.class);
  Capabilities reusedCapabilities=serializeDeserialize(driver.getCapabilities());
  SessionId reusedSessionId=new SessionId(serializeDeserialize(driver.getSessionId().toString()));
  RemoteWebDriver reusedDriver=ReusableRemoteWebDriver.fromReusedSession(HUB_URL,reusedCapabilities,reusedSessionId);
  reusedDriver.navigate().to(HUB_URL.toString());
}",0.9456812110418522
38894,"@Test public void systemPropertyTest(){
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  MockDroneConfiguration configuration=ConfigurationMapper.fromSystemConfiguration(new MockDroneConfiguration(),Default.class);
  validateConfiguration(configuration,54321,false,""String_Node_Str"");
}","@Test public void systemPropertyTest(){
  try {
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
    MockDroneConfiguration configuration=ConfigurationMapper.fromSystemConfiguration(new MockDroneConfiguration(),Default.class);
    validateConfiguration(configuration,54321,false,""String_Node_Str"");
  }
  finally {
    System.clearProperty(""String_Node_Str"");
    System.clearProperty(""String_Node_Str"");
    System.clearProperty(""String_Node_Str"");
  }
}",0.4796019900497512
38895,"@Test public void mapFromArquillianDescriptorAndSystemPropertiesTest(){
  ArquillianDescriptor descriptor=Descriptors.create(ArquillianDescriptor.class).extension(""String_Node_Str"").property(""String_Node_Str"",""String_Node_Str"").property(""String_Node_Str"",""String_Node_Str"").property(""String_Node_Str"",""String_Node_Str"").property(""String_Node_Str"",""String_Node_Str"").property(""String_Node_Str"",""String_Node_Str"");
  System.clearProperty(""String_Node_Str"");
  System.clearProperty(""String_Node_Str"");
  System.clearProperty(""String_Node_Str"");
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  MockDroneConfiguration configuration=ConfigurationMapper.fromArquillianDescriptor(descriptor,new MockDroneConfiguration(),Default.class);
  ConfigurationMapper.fromSystemConfiguration(configuration,Default.class);
  Assert.assertNotNull(""String_Node_Str"",configuration.getMapMap());
  Assert.assertEquals(""String_Node_Str"",3,configuration.getMapMap().size());
  Assert.assertEquals(""String_Node_Str"",""String_Node_Str"",configuration.getMapMap().get(""String_Node_Str""));
  Assert.assertEquals(""String_Node_Str"",""String_Node_Str"",configuration.getMapMap().get(""String_Node_Str""));
  Assert.assertEquals(""String_Node_Str"",""String_Node_Str"",configuration.getMapMap().get(""String_Node_Str""));
}","@Test public void mapFromArquillianDescriptorAndSystemPropertiesTest(){
  try {
    ArquillianDescriptor descriptor=Descriptors.create(ArquillianDescriptor.class).extension(""String_Node_Str"").property(""String_Node_Str"",""String_Node_Str"").property(""String_Node_Str"",""String_Node_Str"").property(""String_Node_Str"",""String_Node_Str"").property(""String_Node_Str"",""String_Node_Str"").property(""String_Node_Str"",""String_Node_Str"");
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
    MockDroneConfiguration configuration=ConfigurationMapper.fromArquillianDescriptor(descriptor,new MockDroneConfiguration(),Default.class);
    ConfigurationMapper.fromSystemConfiguration(configuration,Default.class);
    Assert.assertNotNull(""String_Node_Str"",configuration.getMapMap());
    Assert.assertEquals(""String_Node_Str"",3,configuration.getMapMap().size());
    Assert.assertEquals(""String_Node_Str"",""String_Node_Str"",configuration.getMapMap().get(""String_Node_Str""));
    Assert.assertEquals(""String_Node_Str"",""String_Node_Str"",configuration.getMapMap().get(""String_Node_Str""));
    Assert.assertEquals(""String_Node_Str"",""String_Node_Str"",configuration.getMapMap().get(""String_Node_Str""));
  }
  finally {
    System.clearProperty(""String_Node_Str"");
  }
}",0.8985849056603774
38896,"@Test public void qualifierSystemPropertyTest(){
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  MockDroneConfiguration configuration=ConfigurationMapper.fromSystemConfiguration(new MockDroneConfiguration(),DifferentMock.class);
  validateConfiguration(configuration,0,false,""String_Node_Str"");
}","@Test public void qualifierSystemPropertyTest(){
  try {
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
    MockDroneConfiguration configuration=ConfigurationMapper.fromSystemConfiguration(new MockDroneConfiguration(),DifferentMock.class);
    validateConfiguration(configuration,0,false,""String_Node_Str"");
  }
  finally {
    System.clearProperty(""String_Node_Str"");
    System.clearProperty(""String_Node_Str"");
    System.clearProperty(""String_Node_Str"");
  }
}",0.4394071490845684
38897,"@Test public void mapFromSystemPropertiesTest(){
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  MockDroneConfiguration configuration=ConfigurationMapper.fromSystemConfiguration(new MockDroneConfiguration(),Default.class);
  Assert.assertNotNull(""String_Node_Str"",configuration.getMapMap());
  Assert.assertEquals(""String_Node_Str"",3,configuration.getMapMap().size());
  Assert.assertEquals(""String_Node_Str"",""String_Node_Str"",configuration.getMapMap().get(""String_Node_Str""));
  Assert.assertEquals(""String_Node_Str"",""String_Node_Str"",configuration.getMapMap().get(""String_Node_Str""));
}","@Test public void mapFromSystemPropertiesTest(){
  try {
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
    MockDroneConfiguration configuration=ConfigurationMapper.fromSystemConfiguration(new MockDroneConfiguration(),Default.class);
    Assert.assertNotNull(""String_Node_Str"",configuration.getMapMap());
    Assert.assertEquals(""String_Node_Str"",4,configuration.getMapMap().size());
    Assert.assertEquals(""String_Node_Str"",""String_Node_Str"",configuration.getMapMap().get(""String_Node_Str""));
    Assert.assertEquals(""String_Node_Str"",""String_Node_Str"",configuration.getMapMap().get(""String_Node_Str""));
    Assert.assertEquals(""String_Node_Str"",""String_Node_Str"",configuration.getMapMap().get(""String_Node_Str""));
  }
  finally {
    System.clearProperty(""String_Node_Str"");
    System.clearProperty(""String_Node_Str"");
    System.clearProperty(""String_Node_Str"");
    System.clearProperty(""String_Node_Str"");
  }
}",0.7829880043620502
38898,"@Override public int hashCode(){
  return concept.hashCode() + literal.hashCode() + labelType.hashCode();
}","@Override public int hashCode(){
  return concept.hashCode() + literal.hashCode();
}",0.8795811518324608
38899,"private void writeDQVReport(Issue issue,RepositoryConnection repCon,ValueFactory f,String sdate) throws IOException, OpenRDFException {
  String ndqv=""String_Node_Str"";
  String nex=""String_Node_Str"";
  URI ptype=f.createURI(""String_Node_Str"");
  URI pcomputedOn=f.createURI(ndqv + ""String_Node_Str"");
  URI pdate=f.createURI(""String_Node_Str"");
  URI pvalue=f.createURI(ndqv + ""String_Node_Str"");
  URI pisMeasurementOf=f.createURI(ndqv + ""String_Node_Str"");
  String datasetName=this.computedOn.substring(this.computedOn.lastIndexOf(""String_Node_Str"") + 1,this.computedOn.length());
  URI measure=f.createURI(nex + datasetName + issue.getName().replace(""String_Node_Str"",""String_Node_Str"")+ sdate);
  repCon.add(measure,ptype,f.createURI(ndqv + ""String_Node_Str""));
  if (this.computedOn.startsWith(""String_Node_Str""))   repCon.add(measure,pcomputedOn,f.createURI(this.computedOn));
 else {
    Value datasetPath=new LiteralImpl(this.computedOn,XMLSchema.STRING);
    repCon.add(measure,pcomputedOn,datasetPath);
  }
  Value ldate=new LiteralImpl(sdate,XMLSchema.DATE);
  repCon.add(measure,pdate,ldate);
  int i=new Integer(0);
  String res;
  if (issue.getResult().isProblematic())   res=Long.toString(issue.getResult().occurrenceCount());
 else   res=""String_Node_Str"";
  Value lval=new LiteralImpl(res,XMLSchema.INTEGER);
  repCon.add(measure,pvalue,lval);
  URI uriDimension=f.createURI(nex + ""String_Node_Str"" + issue.getName().replace(""String_Node_Str"",""String_Node_Str""));
  repCon.add(measure,pisMeasurementOf,uriDimension);
}","private void writeDQVReport(Issue issue,RepositoryConnection repCon,ValueFactory f,String sdate) throws IOException, OpenRDFException {
  String ndqv=""String_Node_Str"";
  String nex=""String_Node_Str"";
  URI ptype=f.createURI(""String_Node_Str"");
  URI pcomputedOn=f.createURI(ndqv + ""String_Node_Str"");
  URI pdate=f.createURI(""String_Node_Str"");
  URI pvalue=f.createURI(ndqv + ""String_Node_Str"");
  URI pisMeasurementOf=f.createURI(ndqv + ""String_Node_Str"");
  String datasetName=this.computedOn.substring(this.computedOn.lastIndexOf(""String_Node_Str"") + 1,this.computedOn.length());
  URI measure=f.createURI(nex + datasetName + issue.getName().replace(""String_Node_Str"",""String_Node_Str"")+ sdate);
  repCon.add(measure,ptype,f.createURI(ndqv + ""String_Node_Str""));
  if (this.computedOn.startsWith(""String_Node_Str""))   repCon.add(measure,pcomputedOn,f.createURI(this.computedOn));
 else {
    Value datasetPath=new LiteralImpl(this.computedOn,XMLSchema.STRING);
    repCon.add(measure,pcomputedOn,datasetPath);
  }
  Value ldate=new LiteralImpl(sdate,XMLSchema.DATE);
  repCon.add(measure,pdate,ldate);
  int i=new Integer(0);
  String res;
  Value lval;
  try {
    long r=issue.getResult().occurrenceCount();
    if (issue.getResult().isProblematic())     res=Long.toString(issue.getResult().occurrenceCount());
 else     res=""String_Node_Str"";
    lval=new LiteralImpl(res,XMLSchema.INTEGER);
  }
 catch (  java.lang.UnsupportedOperationException e) {
    if (issue.getResult().isProblematic())     lval=new LiteralImpl(""String_Node_Str"",XMLSchema.BOOLEAN);
 else     lval=new LiteralImpl(""String_Node_Str"",XMLSchema.BOOLEAN);
  }
  repCon.add(measure,pvalue,lval);
  URI uriDimension=f.createURI(nex + ""String_Node_Str"" + issue.getName().replace(""String_Node_Str"",""String_Node_Str""));
  repCon.add(measure,pisMeasurementOf,uriDimension);
}",0.9054373522458627
38900,"void outputIssuesReport(boolean shouldWriteGraphs) throws IOException, OpenRDFException {
  File reportFile=createReportFile();
  BufferedWriter reportWriter=new BufferedWriter(new FileWriter(reportFile));
  processIssues();
  String reportSummary=""String_Node_Str"";
  if (includeSummary) {
    reportSummary=createReportSummary();
    logger.info(""String_Node_Str"" + reportSummary);
  }
  writeReportHeader(reportWriter,reportFile,reportSummary);
  writeReportBody(reportWriter,reportFile,shouldWriteGraphs);
  if (this.inDQV) {
    File DQVFile=createDQVFile();
    FileOutputStream out=new FileOutputStream(DQVFile,true);
    RDFWriter writer=Rio.createWriter(RDFFormat.TURTLE,out);
    logger.info(""String_Node_Str"" + ""String_Node_Str"");
    writeDQVReportBody(writer,DQVFile,shouldWriteGraphs);
    out.close();
  }
  reportWriter.close();
}","void outputIssuesReport(boolean shouldWriteGraphs) throws IOException, OpenRDFException {
  File reportFile=createReportFile();
  BufferedWriter reportWriter=new BufferedWriter(new FileWriter(reportFile));
  processIssues();
  String reportSummary=""String_Node_Str"";
  if (includeSummary) {
    reportSummary=createReportSummary();
    logger.info(""String_Node_Str"" + reportSummary);
  }
  writeReportHeader(reportWriter,reportFile,reportSummary);
  writeReportBody(reportWriter,reportFile,shouldWriteGraphs);
  if (this.inDQV) {
    File DQVFile=createDQVFile();
    FileOutputStream out=new FileOutputStream(DQVFile,true);
    RDFWriter writer=Rio.createWriter(RDFFormat.TURTLE,out);
    logger.info(""String_Node_Str"" + ""String_Node_Str"");
    writeDQVReportBody(writer,DQVFile,shouldWriteGraphs);
    logger.info(""String_Node_Str"" + ""String_Node_Str"" + DQVFile.getPath());
    out.close();
  }
  reportWriter.close();
}",0.9570135746606336
38901,"private void writeReportHeader(BufferedWriter reportWriter,File reportFile,String reportSummary) throws IOException {
  String issuedDate=new SimpleDateFormat(""String_Node_Str"").format(new Date());
  String fileName=reportFile.getAbsolutePath();
  reportWriter.write(""String_Node_Str"" + fileName + ""String_Node_Str""+ issuedDate);
  reportWriter.newLine();
  reportWriter.newLine();
  reportWriter.write(reportSummary);
}","private void writeReportHeader(BufferedWriter reportWriter,File vocabFile,String reportSummary) throws IOException {
  String issuedDate=new SimpleDateFormat(""String_Node_Str"").format(new Date());
  reportWriter.write(""String_Node_Str"");
  Iterator<String> vocabIt=vocabFileNames.iterator();
  while (vocabIt.hasNext()) {
    String vocabFileName=vocabIt.next();
    reportWriter.write(vocabFileName);
    if (vocabIt.hasNext())     reportWriter.write(""String_Node_Str"");
  }
  reportWriter.write(""String_Node_Str"" + issuedDate);
  reportWriter.newLine();
  reportWriter.newLine();
  reportWriter.write(reportSummary);
}",0.3961538461538461
38902,"public ReportCollector(Collection<Issue> issues,String reportFileName,boolean includeSummary){
  this.issues=issues;
  this.reportFileName=reportFileName;
  this.includeSummary=includeSummary;
}","public ReportCollector(Collection<Issue> issues,String reportFileName,Collection<String> vocabFileNames,boolean includeSummary){
  this.issues=issues;
  this.reportFileName=reportFileName;
  this.includeSummary=includeSummary;
  this.vocabFileNames=vocabFileNames;
}",0.8434782608695652
38903,"private void evaluate() throws OpenRDFException, IOException {
  setup();
  String command=jc.getParsedCommand();
  reportCollector=new ReportCollector(extractMeasures(),parsedCommand.reportFileName,command.equals(CMD_NAME_ANALYZE));
  reportCollector.outputIssuesReport(shouldWriteGraphs());
}","private void evaluate() throws OpenRDFException, IOException {
  setup();
  String command=jc.getParsedCommand();
  reportCollector=new ReportCollector(extractMeasures(),parsedCommand.reportFileName,parsedCommand.vocabFilenames,command.equals(CMD_NAME_ANALYZE));
  reportCollector.outputIssuesReport(shouldWriteGraphs());
}",0.9529983792544572
38904,"private Collection<Issue> getAllIssuesForCommand(){
  List<Issue> issuesForCommand=new ArrayList<Issue>();
  for (  Issue issue : qskos.getAllIssues()) {
    String command=jc.getParsedCommand();
    if ((issue.getType() == Issue.IssueType.ANALYTICAL && command.equals(CMD_NAME_ANALYZE)) || (issue.getType() == Issue.IssueType.STATISTICAL && command.equals(CMD_NAME_SUMMARIZE))) {
      issuesForCommand.add(issue);
    }
  }
  return issuesForCommand;
}","private Collection<Issue> getAllIssuesForCommand(){
  List<Issue> issuesForCommand=new ArrayList<>();
  for (  Issue issue : qskos.getAllIssues()) {
    String command=jc.getParsedCommand();
    if ((issue.getType() == Issue.IssueType.ANALYTICAL && command.equals(CMD_NAME_ANALYZE)) || (issue.getType() == Issue.IssueType.STATISTICAL && command.equals(CMD_NAME_SUMMARIZE))) {
      issuesForCommand.add(issue);
    }
  }
  return issuesForCommand;
}",0.9944629014396456
38905,"private void createGraph() throws OpenRDFException {
  graph=new DirectedMultigraph<Resource,NamedEdge>(NamedEdge.class);
  Iterator<Resource> conceptIt=new MonitoredIterator<Resource>(involvedConcepts.getResult().getData(),progressMonitor);
  while (conceptIt.hasNext()) {
    Resource concept=conceptIt.next();
    Collection<Relation> relations=findRelations(concept);
    for (    Relation relation : relations) {
      addNodesToGraph(relation.sourceConcept,relation.targetConcept,relation.property);
    }
  }
}","private void createGraph() throws OpenRDFException {
  graph=new DirectedMultigraph<>(NamedEdge.class);
  Iterator<Resource> conceptIt=new MonitoredIterator<>(involvedConcepts.getResult().getData(),progressMonitor);
  while (conceptIt.hasNext()) {
    Resource concept=conceptIt.next();
    Collection<Relation> relations=findRelations(concept);
    for (    Relation relation : relations) {
      addNodesToGraph(relation.sourceConcept,relation.targetConcept,relation.property);
    }
  }
}",0.8650793650793651
38906,"@Override protected ClustersResult invoke() throws OpenRDFException {
  createGraph();
  Collection<Collection<Resource>> connectedSets=new ArrayList<Collection<Resource>>();
  connectedSets.addAll(new ConnectivityInspector<Resource,NamedEdge>(graph).connectedSets());
  return new ClustersResult(connectedSets,graph);
}","@Override protected ClustersResult invoke() throws OpenRDFException {
  createGraph();
  Collection<Collection<Resource>> connectedSets=new ArrayList<>();
  connectedSets.addAll(new ConnectivityInspector<>(graph).connectedSets());
  return new ClustersResult(connectedSets,graph);
}",0.9368770764119602
38907,"private Collection<Relation> findRelations(Resource concept){
  Collection<Relation> allRelations=new ArrayList<Relation>();
  try {
    TupleQuery query=repCon.prepareTupleQuery(QueryLanguage.SPARQL,createConnectionsQuery(concept));
    TupleQueryResult result=query.evaluate();
    while (result.hasNext()) {
      BindingSet bindingSet=result.next();
      Resource otherConcept=(Resource)bindingSet.getValue(""String_Node_Str"");
      URI semanticRelation=(URI)bindingSet.getValue(""String_Node_Str"");
      if (otherConcept != null && semanticRelation != null) {
        allRelations.add(new Relation(concept,otherConcept,semanticRelation));
      }
    }
  }
 catch (  OpenRDFException e) {
    logger.error(""String_Node_Str"" + concept + ""String_Node_Str"");
  }
  return allRelations;
}","private Collection<Relation> findRelations(Resource concept){
  Collection<Relation> allRelations=new ArrayList<>();
  try {
    TupleQuery query=repCon.prepareTupleQuery(QueryLanguage.SPARQL,createConnectionsQuery(concept));
    TupleQueryResult result=query.evaluate();
    while (result.hasNext()) {
      BindingSet bindingSet=result.next();
      Resource otherConcept=(Resource)bindingSet.getValue(""String_Node_Str"");
      URI semanticRelation=(URI)bindingSet.getValue(""String_Node_Str"");
      if (otherConcept != null && semanticRelation != null) {
        allRelations.add(new Relation(concept,otherConcept,semanticRelation));
      }
    }
  }
 catch (  OpenRDFException e) {
    logger.error(""String_Node_Str"" + concept + ""String_Node_Str"");
  }
  return allRelations;
}",0.9949109414758268
38908,"@Override protected CollectionResult<Resource> invoke() throws OpenRDFException {
  TupleQuery query=repCon.prepareTupleQuery(QueryLanguage.SPARQL,createOrphanConceptsQuery());
  Set<Value> connectedConcepts=TupleQueryResultUtil.getValuesForBindingName(query.evaluate(),""String_Node_Str"");
  Set<Resource> orphanConcepts=new HashSet<Resource>(involvedConcepts.getResult().getData());
  orphanConcepts.removeAll(connectedConcepts);
  return new CollectionResult<Resource>(orphanConcepts);
}","@Override protected CollectionResult<Resource> invoke() throws OpenRDFException {
  TupleQuery query=repCon.prepareTupleQuery(QueryLanguage.SPARQL,createOrphanConceptsQuery());
  Set<Value> connectedConcepts=TupleQueryResultUtil.getValuesForBindingName(query.evaluate(),""String_Node_Str"");
  Set<Resource> orphanConcepts=new HashSet<>(involvedConcepts.getResult().getData());
  orphanConcepts.removeAll(connectedConcepts);
  return new CollectionResult<>(orphanConcepts);
}",0.9833679833679834
38909,"@Override protected CollectionResult<Statement> invoke() throws OpenRDFException {
  Collection<Statement> problematicRelations=new ArrayList<Statement>();
  RepositoryResult<Statement> result=repCon.getStatements(null,SkosOntology.getInstance().getUri(""String_Node_Str""),null,true);
  while (result.hasNext()) {
    Statement st=result.next();
    Resource concept=st.getSubject();
    Resource otherConcept=(Resource)st.getObject();
    if (areAuthoritativeConcepts(concept,otherConcept) && (ConceptSchemeUtil.inSameConceptScheme(concept,otherConcept,repCon) || ConceptSchemeUtil.inNoConceptScheme(concept,otherConcept,repCon))) {
      problematicRelations.add(st);
    }
  }
  return new CollectionResult<Statement>(problematicRelations);
}","@Override protected CollectionResult<Statement> invoke() throws OpenRDFException {
  Collection<Statement> problematicRelations=new ArrayList<>();
  RepositoryResult<Statement> result=repCon.getStatements(null,SkosOntology.getInstance().getUri(""String_Node_Str""),null,true);
  while (result.hasNext()) {
    Statement st=result.next();
    Resource concept=st.getSubject();
    Resource otherConcept=(Resource)st.getObject();
    if (areAuthoritativeConcepts(concept,otherConcept) && (ConceptSchemeUtil.inSameConceptScheme(concept,otherConcept,repCon) || ConceptSchemeUtil.inNoConceptScheme(concept,otherConcept,repCon))) {
      problematicRelations.add(st);
    }
  }
  return new CollectionResult<>(problematicRelations);
}",0.9877551020408164
38910,"@Override protected CollectionResult<Resource> invoke() throws OpenRDFException {
  Collection<Resource> csWithOmittedTopConcepts=new HashSet<Resource>();
  for (  Resource conceptScheme : conceptSchemes.getResult().getData()) {
    BooleanQuery hasTopConceptQuery=repCon.prepareBooleanQuery(QueryLanguage.SPARQL,createConceptSchemeWithoutTopConceptQuery(conceptScheme));
    if (!hasTopConceptQuery.evaluate()) {
      csWithOmittedTopConcepts.add(conceptScheme);
    }
  }
  return new CollectionResult<Resource>(csWithOmittedTopConcepts);
}","@Override protected CollectionResult<Resource> invoke() throws OpenRDFException {
  Collection<Resource> csWithOmittedTopConcepts=new HashSet<>();
  for (  Resource conceptScheme : conceptSchemes.getResult().getData()) {
    BooleanQuery hasTopConceptQuery=repCon.prepareBooleanQuery(QueryLanguage.SPARQL,createConceptSchemeWithoutTopConceptQuery(conceptScheme));
    if (!hasTopConceptQuery.evaluate()) {
      csWithOmittedTopConcepts.add(conceptScheme);
    }
  }
  return new CollectionResult<>(csWithOmittedTopConcepts);
}",0.9850467289719628
38911,"private Collection<Value> createUriResultList(TupleQueryResult result) throws OpenRDFException {
  List<Value> resultList=new ArrayList<Value>();
  while (result.hasNext()) {
    BindingSet queryResult=result.next();
    URI resource=(URI)queryResult.getValue(""String_Node_Str"");
    resultList.add(resource);
  }
  return resultList;
}","private Collection<Value> createUriResultList(TupleQueryResult result) throws OpenRDFException {
  List<Value> resultList=new ArrayList<>();
  while (result.hasNext()) {
    BindingSet queryResult=result.next();
    URI resource=(URI)queryResult.getValue(""String_Node_Str"");
    resultList.add(resource);
  }
  return resultList;
}",0.992503748125937
38912,"@Override protected CollectionResult<Value> invoke() throws OpenRDFException {
  TupleQuery query=repCon.prepareTupleQuery(QueryLanguage.SPARQL,createTopConceptsHavingBroaderConceptQuery());
  return new CollectionResult<Value>(createUriResultList(query.evaluate()));
}","@Override protected CollectionResult<Value> invoke() throws OpenRDFException {
  TupleQuery query=repCon.prepareTupleQuery(QueryLanguage.SPARQL,createTopConceptsHavingBroaderConceptQuery());
  return new CollectionResult<>(createUriResultList(query.evaluate()));
}",0.9906191369606004
38913,"private List<Collection<Resource>> trackNodesInCycles(Set<Resource> nodesInCycles){
  List<Collection<Resource>> ret=new ArrayList<Collection<Resource>>();
  List<Set<Resource>> stronglyConnectedSets=new StrongConnectivityInspector<Resource,NamedEdge>(hierarchyGraph).stronglyConnectedSets();
  for (  Resource node : nodesInCycles) {
    for (    Set<Resource> stronglyConnectedSet : stronglyConnectedSets) {
      if (stronglyConnectedSet.contains(node)) {
        if (!ret.contains(stronglyConnectedSet)) {
          ret.add(stronglyConnectedSet);
        }
      }
    }
  }
  return ret;
}","private List<Collection<Resource>> trackNodesInCycles(Set<Resource> nodesInCycles){
  List<Collection<Resource>> ret=new ArrayList<>();
  List<Set<Resource>> stronglyConnectedSets=new StrongConnectivityInspector<>(hierarchyGraph).stronglyConnectedSets();
  for (  Resource node : nodesInCycles) {
    for (    Set<Resource> stronglyConnectedSet : stronglyConnectedSets) {
      if (stronglyConnectedSet.contains(node)) {
        if (!ret.contains(stronglyConnectedSet)) {
          ret.add(stronglyConnectedSet);
        }
      }
    }
  }
  return ret;
}",0.9408695652173912
38914,"private List<Collection<Resource>> findCycleContainingComponents(){
  logger.debug(""String_Node_Str"");
  Set<Resource> nodesInCycles=new CycleDetector<Resource,NamedEdge>(hierarchyGraph).findCycles();
  return trackNodesInCycles(nodesInCycles);
}","private List<Collection<Resource>> findCycleContainingComponents(){
  logger.debug(""String_Node_Str"");
  Set<Resource> nodesInCycles=new CycleDetector<>(hierarchyGraph).findCycles();
  return trackNodesInCycles(nodesInCycles);
}",0.9620253164556962
38915,"@Override protected ExtrapolatedCollectionResult<Resource> invoke() throws OpenRDFException {
  Collection<Resource> conceptsToCheck=getConceptsToCheck(randomSubsetSize_percent);
  if (randomSubsetSize_percent != null) {
    logger.info(""String_Node_Str"" + conceptsToCheck.size() + ""String_Node_Str"");
  }
  Iterator<Resource> conceptIt=new MonitoredIterator<Resource>(conceptsToCheck,progressMonitor,""String_Node_Str"");
  while (conceptIt.hasNext()) {
    rankConcept(conceptIt.next());
  }
  return new ExtrapolatedCollectionResult<Resource>(extractUnreferencedConcepts(),randomSubsetSize_percent);
}","@Override protected ExtrapolatedCollectionResult<Resource> invoke() throws OpenRDFException {
  Collection<Resource> conceptsToCheck=getConceptsToCheck(randomSubsetSize_percent);
  if (randomSubsetSize_percent != null) {
    logger.info(""String_Node_Str"" + conceptsToCheck.size() + ""String_Node_Str"");
  }
  Iterator<Resource> conceptIt=new MonitoredIterator<>(conceptsToCheck,progressMonitor,""String_Node_Str"");
  while (conceptIt.hasNext()) {
    rankConcept(conceptIt.next());
  }
  return new ExtrapolatedCollectionResult<>(extractUnreferencedConcepts(),randomSubsetSize_percent);
}",0.9865319865319864
38916,"private Collection<Resource> getConceptsToCheck(Float randomSubsetSize_percent) throws OpenRDFException {
  if (randomSubsetSize_percent == null) {
    return authoritativeConcepts.getResult().getData();
  }
 else {
    return new RandomSubSet<Resource>(authoritativeConcepts.getResult().getData(),randomSubsetSize_percent);
  }
}","private Collection<Resource> getConceptsToCheck(Float randomSubsetSize_percent) throws OpenRDFException {
  if (randomSubsetSize_percent == null) {
    return authoritativeConcepts.getResult().getData();
  }
 else {
    return new RandomSubSet<>(authoritativeConcepts.getResult().getData(),randomSubsetSize_percent);
  }
}",0.9877300613496932
38917,"private void addToConceptsRankMap(Resource concept,TupleQueryResult result) throws QueryEvaluationException {
  Set<URI> referencingResourcesOnOtherHost=getReferencingResourcesOnOtherHost(concept,result);
  Set<URI> allReferencingResources=conceptReferencingResources.get(concept);
  if (allReferencingResources == null) {
    allReferencingResources=new HashSet<URI>();
    conceptReferencingResources.put(concept,allReferencingResources);
  }
  allReferencingResources.addAll(referencingResourcesOnOtherHost);
}","private void addToConceptsRankMap(Resource concept,TupleQueryResult result) throws QueryEvaluationException {
  Set<URI> referencingResourcesOnOtherHost=getReferencingResourcesOnOtherHost(concept,result);
  Set<URI> allReferencingResources=conceptReferencingResources.get(concept);
  if (allReferencingResources == null) {
    allReferencingResources=new HashSet<>();
    conceptReferencingResources.put(concept,allReferencingResources);
  }
  allReferencingResources.addAll(referencingResourcesOnOtherHost);
}",0.997067448680352
38918,"private Collection<Resource> extractUnreferencedConcepts(){
  Collection<Resource> unrefConcepts=new HashSet<Resource>();
  for (  Resource concept : conceptReferencingResources.keySet()) {
    if (conceptReferencingResources.get(concept).isEmpty()) {
      unrefConcepts.add(concept);
    }
  }
  return unrefConcepts;
}","private Collection<Resource> extractUnreferencedConcepts(){
  Collection<Resource> unrefConcepts=new HashSet<>();
  for (  Resource concept : conceptReferencingResources.keySet()) {
    if (conceptReferencingResources.get(concept).isEmpty()) {
      unrefConcepts.add(concept);
    }
  }
  return unrefConcepts;
}",0.9873817034700316
38919,"private Set<URI> getReferencingResourcesOnOtherHost(Value concept,TupleQueryResult result) throws QueryEvaluationException {
  Set<URI> referencingResourcesOnOtherHost=new HashSet<URI>();
  while (result.hasNext()) {
    Value referencingResource=result.next().getValue(""String_Node_Str"");
    try {
      if (referencingResource instanceof URI && concept instanceof URI && isDistinctHost((URI)concept,(URI)referencingResource)) {
        referencingResourcesOnOtherHost.add((URI)referencingResource);
      }
    }
 catch (    URISyntaxException e) {
    }
  }
  return referencingResourcesOnOtherHost;
}","private Set<URI> getReferencingResourcesOnOtherHost(Value concept,TupleQueryResult result) throws QueryEvaluationException {
  Set<URI> referencingResourcesOnOtherHost=new HashSet<>();
  while (result.hasNext()) {
    Value referencingResource=result.next().getValue(""String_Node_Str"");
    try {
      if (referencingResource instanceof URI && concept instanceof URI && isDistinctHost((URI)concept,(URI)referencingResource)) {
        referencingResourcesOnOtherHost.add((URI)referencingResource);
      }
    }
 catch (    URISyntaxException e) {
    }
  }
  return referencingResourcesOnOtherHost;
}",0.9975144987572494
38920,"private Collection<URI> collectUrisToBeDereferenced() throws OpenRDFException {
  if (randomSubsetSize_percent == null) {
    return httpURIs.getResult().getData();
  }
  RandomSubSet<URI> urisToBeDereferenced=new RandomSubSet<URI>(httpURIs.getResult().getData(),randomSubsetSize_percent);
  logger.info(""String_Node_Str"" + urisToBeDereferenced.size() + ""String_Node_Str"");
  return urisToBeDereferenced;
}","private Collection<URI> collectUrisToBeDereferenced() throws OpenRDFException {
  if (randomSubsetSize_percent == null) {
    return httpURIs.getResult().getData();
  }
  RandomSubSet<URI> urisToBeDereferenced=new RandomSubSet<>(httpURIs.getResult().getData(),randomSubsetSize_percent);
  logger.info(""String_Node_Str"" + urisToBeDereferenced.size() + ""String_Node_Str"");
  return urisToBeDereferenced;
}",0.9814585908529048
38921,"private void dereferenceURIs() throws OpenRDFException {
  Collection<URI> urisToBeDereferenced=collectUrisToBeDereferenced();
  Iterator<URI> it=new MonitoredIterator<URI>(urisToBeDereferenced,progressMonitor);
  int i=1;
  while (it.hasNext()) {
    URI uri=it.next();
    logger.debug(""String_Node_Str"" + i + ""String_Node_Str""+ urisToBeDereferenced.size());
    i++;
    try {
      Thread.sleep(extAccessDelayMillis);
    }
 catch (    InterruptedException e) {
    }
    addToResults(uri);
  }
}","private void dereferenceURIs() throws OpenRDFException {
  Collection<URI> urisToBeDereferenced=collectUrisToBeDereferenced();
  Iterator<URI> it=new MonitoredIterator<>(urisToBeDereferenced,progressMonitor);
  int i=1;
  while (it.hasNext()) {
    URI uri=it.next();
    logger.debug(""String_Node_Str"" + i + ""String_Node_Str""+ urisToBeDereferenced.size());
    i++;
    try {
      Thread.sleep(extAccessDelayMillis);
    }
 catch (    InterruptedException e) {
    }
    addToResults(uri);
  }
}",0.9969909729187564
38922,"@Override protected ExtrapolatedCollectionResult<URL> invoke() throws OpenRDFException {
  dereferenceURIs();
  return new ExtrapolatedCollectionResult<URL>(collectUnavailableURLs(),randomSubsetSize_percent);
}","@Override protected ExtrapolatedCollectionResult<URL> invoke() throws OpenRDFException {
  dereferenceURIs();
  return new ExtrapolatedCollectionResult<>(collectUnavailableURLs(),randomSubsetSize_percent);
}",0.9928057553956836
38923,"private Collection<URL> collectUnavailableURLs(){
  Collection<URL> unavailableURLs=new ArrayList<URL>();
  for (  URL url : urlAvailability.keySet()) {
    if (urlAvailability.get(url) == null) {
      unavailableURLs.add(url);
    }
  }
  return unavailableURLs;
}","private Collection<URL> collectUnavailableURLs(){
  Collection<URL> unavailableURLs=new ArrayList<>();
  for (  URL url : urlAvailability.keySet()) {
    if (urlAvailability.get(url) == null) {
      unavailableURLs.add(url);
    }
  }
  return unavailableURLs;
}",0.994328922495274
38924,"@Override protected CollectionResult<URI> invoke() throws OpenRDFException {
  RepositoryResult<Statement> result=repCon.getStatements(null,null,null,false,(Resource)null);
  while (result.hasNext()) {
    Statement st=result.next();
    Collection<Value> tripleValues=new ArrayList<Value>();
    tripleValues.addAll(Arrays.asList(st.getSubject(),st.getObject(),st.getPredicate()));
    for (    Value value : tripleValues) {
      if (value instanceof org.openrdf.model.URI)       addToUrlList(value);
    }
  }
  return new CollectionResult<URI>(httpURIs);
}","@Override protected CollectionResult<URI> invoke() throws OpenRDFException {
  RepositoryResult<Statement> result=repCon.getStatements(null,null,null,false,(Resource)null);
  while (result.hasNext()) {
    Statement st=result.next();
    Collection<Value> tripleValues=new ArrayList<>();
    tripleValues.addAll(Arrays.asList(st.getSubject(),st.getObject(),st.getPredicate()));
    for (    Value value : tripleValues) {
      if (value instanceof org.openrdf.model.URI)       addToUrlList(value);
    }
  }
  return new CollectionResult<>(httpURIs);
}",0.9820143884892086
38925,"private Collection<URI> extractExternalResources(Collection<URI> allResources) throws OpenRDFException {
  Collection<URI> validExternalResources=new HashSet<URI>();
  for (  URI uri : allResources) {
    if (isExternalResource(uri) && isNonSkosURL(uri)) {
      validExternalResources.add(uri);
    }
  }
  return validExternalResources;
}","private Collection<URI> extractExternalResources(Collection<URI> allResources) throws OpenRDFException {
  Collection<URI> validExternalResources=new HashSet<>();
  for (  URI uri : allResources) {
    if (isExternalResource(uri) && isNonSkosURL(uri)) {
      validExternalResources.add(uri);
    }
  }
  return validExternalResources;
}",0.9955686853766618
38926,"@Override protected CollectionResult<Resource> invoke() throws OpenRDFException {
  extResourcesForConcept=new HashMap<Resource,Collection<URI>>();
  findResourcesForConcepts(authoritativeConcepts.getResult().getData());
  return new CollectionResult<Resource>(extractUnlinkedConcepts());
}","@Override protected CollectionResult<Resource> invoke() throws OpenRDFException {
  extResourcesForConcept=new HashMap<>();
  findResourcesForConcepts(authoritativeConcepts.getResult().getData());
  return new CollectionResult<>(extractUnlinkedConcepts());
}",0.9416058394160584
38927,"private void findResourcesForConcepts(Collection<Resource> concepts) throws OpenRDFException {
  Iterator<Resource> conceptIt=new MonitoredIterator<Resource>(concepts,progressMonitor,""String_Node_Str"");
  while (conceptIt.hasNext()) {
    Resource concept=conceptIt.next();
    extResourcesForConcept.put(concept,extractExternalResources(getURIsOfConcept(concept)));
  }
}","private void findResourcesForConcepts(Collection<Resource> concepts) throws OpenRDFException {
  Iterator<Resource> conceptIt=new MonitoredIterator<>(concepts,progressMonitor,""String_Node_Str"");
  while (conceptIt.hasNext()) {
    Resource concept=conceptIt.next();
    extResourcesForConcept.put(concept,extractExternalResources(getURIsOfConcept(concept)));
  }
}",0.9891304347826086
38928,"private Collection<Resource> extractUnlinkedConcepts(){
  Collection<Resource> unlinkedConcepts=new HashSet<Resource>();
  for (  Resource concept : extResourcesForConcept.keySet()) {
    if (extResourcesForConcept.get(concept).isEmpty()) {
      unlinkedConcepts.add(concept);
    }
  }
  return unlinkedConcepts;
}","private Collection<Resource> extractUnlinkedConcepts(){
  Collection<Resource> unlinkedConcepts=new HashSet<>();
  for (  Resource concept : extResourcesForConcept.keySet()) {
    if (extResourcesForConcept.get(concept).isEmpty()) {
      unlinkedConcepts.add(concept);
    }
  }
  return unlinkedConcepts;
}",0.9871794871794872
38929,"private Collection<URI> getURIsOfConcept(Resource concept) throws RepositoryException {
  Collection<URI> urisForConcept=new ArrayList<URI>();
  RepositoryResult<Statement> conceptAsSubject=repCon.getStatements((Resource)concept,null,null,false);
  while (conceptAsSubject.hasNext()) {
    Value object=conceptAsSubject.next().getObject();
    addToUriCollection(object,urisForConcept);
  }
  RepositoryResult<Statement> conceptAsObject=repCon.getStatements(null,null,concept,false);
  while (conceptAsObject.hasNext()) {
    Value object=conceptAsObject.next().getSubject();
    addToUriCollection(object,urisForConcept);
  }
  return urisForConcept;
}","private Collection<URI> getURIsOfConcept(Resource concept) throws RepositoryException {
  Collection<URI> urisForConcept=new ArrayList<>();
  RepositoryResult<Statement> conceptAsSubject=repCon.getStatements(concept,null,null,false);
  while (conceptAsSubject.hasNext()) {
    Value object=conceptAsSubject.next().getObject();
    addToUriCollection(object,urisForConcept);
  }
  RepositoryResult<Statement> conceptAsObject=repCon.getStatements(null,null,concept,false);
  while (conceptAsObject.hasNext()) {
    Value object=conceptAsObject.next().getSubject();
    addToUriCollection(object,urisForConcept);
  }
  return urisForConcept;
}",0.9899458623356536
38930,"private CollectionResult<Tuple<Resource>> createReport(){
  Collection<Tuple<Resource>> relatedConcepts=new HashSet<Tuple<Resource>>();
  for (  Statement statement : solitaryTransitiveRelations) {
    relatedConcepts.add(new Tuple<Resource>(statement.getSubject(),(Resource)statement.getObject()));
  }
  return new CollectionResult(relatedConcepts);
}","private CollectionResult<Tuple<Resource>> createReport(){
  Collection<Tuple<Resource>> relatedConcepts=new HashSet<>();
  for (  Statement statement : solitaryTransitiveRelations) {
    relatedConcepts.add(new Tuple<>(statement.getSubject(),(Resource)statement.getObject()));
  }
  return new CollectionResult(relatedConcepts);
}",0.9663250366032212
38931,"@Override protected CollectionResult<Tuple<Resource>> invoke() throws OpenRDFException {
  solitaryTransitiveRelations=new ArrayList<Statement>();
  for (  String[] transitivePropertyPair : transitiveNontransiviteInverseProperties) {
    String query=createSolitaryTransitiveRelationsQuery(transitivePropertyPair);
    TupleQuery tupleQuery=repCon.prepareTupleQuery(QueryLanguage.SPARQL,query);
    addToResults(tupleQuery.evaluate(),transitivePropertyPair[0]);
  }
  return createReport();
}","@Override protected CollectionResult<Tuple<Resource>> invoke() throws OpenRDFException {
  solitaryTransitiveRelations=new ArrayList<>();
  for (  String[] transitivePropertyPair : transitiveNontransiviteInverseProperties) {
    String query=createSolitaryTransitiveRelationsQuery(transitivePropertyPair);
    TupleQuery tupleQuery=repCon.prepareTupleQuery(QueryLanguage.SPARQL,query);
    addToResults(tupleQuery.evaluate(),transitivePropertyPair[0]);
  }
  return createReport();
}",0.9907692307692308
38932,"private void addStatisticalIssues(){
  involvedConcepts=new InvolvedConcepts();
  authoritativeConcepts=new AuthoritativeConcepts(involvedConcepts);
  authoritativeConcepts.setBaseURI(baseURI);
  authoritativeConcepts.setAuthResourceIdentifier(authResourceIdentifier);
  conceptSchemes=new ConceptSchemes();
  httpURIs=new HttpURIs();
  registeredIssues.add(involvedConcepts);
  registeredIssues.add(authoritativeConcepts);
  registeredIssues.add(new LexicalRelations(involvedConcepts));
  registeredIssues.add(new SemanticRelations());
  registeredIssues.add(new AggregationRelations());
  registeredIssues.add(conceptSchemes);
  registeredIssues.add(new at.ac.univie.mminf.qskos4j.issues.count.Collections());
  registeredIssues.add(httpURIs);
}","private void addStatisticalIssues(){
  involvedConcepts=new InvolvedConcepts();
  authoritativeConcepts=new AuthoritativeConcepts(involvedConcepts);
  authoritativeConcepts.setBaseURI(baseURI);
  conceptSchemes=new ConceptSchemes();
  httpURIs=new HttpURIs();
  registeredIssues.add(involvedConcepts);
  registeredIssues.add(authoritativeConcepts);
  registeredIssues.add(new LexicalRelations(involvedConcepts));
  registeredIssues.add(new SemanticRelations());
  registeredIssues.add(new AggregationRelations());
  registeredIssues.add(conceptSchemes);
  registeredIssues.add(new at.ac.univie.mminf.qskos4j.issues.count.Collections());
  registeredIssues.add(httpURIs);
}",0.9471458773784356
38933,"/** 
 * Some methods in this class support investigating only a subset of the vocabulary and extrapolate the results to shorten evaluation time. Works for, e.g., finding broken links. 
 * @param subsetSizePercent percentage of the total resources to investigate.
 */
public void setSubsetSize(Float subsetSizePercent){
  randomSubsetSize_percent=subsetSizePercent;
}","/** 
 * Some methods in this class support investigating only a subset of the vocabulary and extrapolate the results to shorten evaluation time. Works for, e.g., finding broken links. 
 * @param subsetSizePercent percentage of the total resources to investigate.
 */
public void setSubsetSize(Float subsetSizePercent){
  missingInLinks.setSubsetSize(subsetSizePercent);
  brokenLinks.setSubsetSize(subsetSizePercent);
}",0.8713375796178344
38934,"private void addAnalyticalIssues(){
  HierarchyGraphBuilder hierarchyGraphBuilder=new HierarchyGraphBuilder();
  registeredIssues.add(new OmittedOrInvalidLanguageTags());
  registeredIssues.add(new IncompleteLanguageCoverage(involvedConcepts));
  registeredIssues.add(new UndocumentedConcepts(authoritativeConcepts));
  registeredIssues.add(new OverlappingLabels(involvedConcepts));
  registeredIssues.add(new OrphanConcepts(involvedConcepts));
  registeredIssues.add(new DisconnectedConceptClusters(involvedConcepts));
  registeredIssues.add(new HierarchicalCycles(hierarchyGraphBuilder));
  registeredIssues.add(new ValuelessAssociativeRelations());
  registeredIssues.add(new SolelyTransitivelyRelatedConcepts());
  registeredIssues.add(new OmittedTopConcepts(conceptSchemes));
  registeredIssues.add(new TopConceptsHavingBroaderConcepts());
  missingInLinks=new MissingInLinks(authoritativeConcepts);
  missingInLinks.setQueryDelayMillis(extAccessDelayMillis);
  missingInLinks.setSubsetSize(randomSubsetSize_percent);
  registeredIssues.add(missingInLinks);
  registeredIssues.add(new MissingOutLinks(authoritativeConcepts));
  BrokenLinks brokenLinks=new BrokenLinks(httpURIs);
  brokenLinks.setSubsetSize(randomSubsetSize_percent);
  brokenLinks.setExtAccessDelayMillis(extAccessDelayMillis);
  registeredIssues.add(brokenLinks);
  registeredIssues.add(new UndefinedSkosResources());
  registeredIssues.add(new UnidirectionallyRelatedConcepts());
  registeredIssues.add(new HttpUriSchemeViolations());
  registeredIssues.add(new RelationClashes(hierarchyGraphBuilder));
  registeredIssues.add(new MappingClashes());
}","private void addAnalyticalIssues(){
  HierarchyGraphBuilder hierarchyGraphBuilder=new HierarchyGraphBuilder();
  registeredIssues.add(new OmittedOrInvalidLanguageTags());
  registeredIssues.add(new IncompleteLanguageCoverage(involvedConcepts));
  registeredIssues.add(new UndocumentedConcepts(authoritativeConcepts));
  registeredIssues.add(new OverlappingLabels(involvedConcepts));
  registeredIssues.add(new OrphanConcepts(involvedConcepts));
  registeredIssues.add(new DisconnectedConceptClusters(involvedConcepts));
  registeredIssues.add(new HierarchicalCycles(hierarchyGraphBuilder));
  registeredIssues.add(new ValuelessAssociativeRelations());
  registeredIssues.add(new SolelyTransitivelyRelatedConcepts());
  registeredIssues.add(new OmittedTopConcepts(conceptSchemes));
  registeredIssues.add(new TopConceptsHavingBroaderConcepts());
  missingInLinks=new MissingInLinks(authoritativeConcepts);
  missingInLinks.setQueryDelayMillis(EXT_ACCESS_MILLIS);
  registeredIssues.add(missingInLinks);
  registeredIssues.add(new MissingOutLinks(authoritativeConcepts));
  brokenLinks=new BrokenLinks(httpURIs);
  brokenLinks.setExtAccessDelayMillis(EXT_ACCESS_MILLIS);
  registeredIssues.add(brokenLinks);
  registeredIssues.add(new UndefinedSkosResources());
  registeredIssues.add(new UnidirectionallyRelatedConcepts());
  registeredIssues.add(new HttpUriSchemeViolations());
  registeredIssues.add(new RelationClashes(hierarchyGraphBuilder));
  registeredIssues.add(new MappingClashes());
}",0.8283606031440488
38935,"/** 
 * Sets a string that is used to identify if an URI is authoritative. This is required to, e.g., find all out-links to distinguish between URIs in the vocabulary namespace and other resources on the Web.
 * @param authResourceIdentifier a string, usually a substring of an URI in the vocabulary's namespace,that uniquely identifies an authoritative URI.
 */
public void setAuthResourceIdentifier(String authResourceIdentifier){
  this.authResourceIdentifier=authResourceIdentifier;
}","/** 
 * Sets a string that is used to identify if an URI is authoritative. This is required to, e.g., find all out-links to distinguish between URIs in the vocabulary namespace and other resources on the Web.
 * @param authResourceIdentifier a string, usually a substring of an URI in the vocabulary's namespace,that uniquely identifies an authoritative URI.
 */
public void setAuthResourceIdentifier(String authResourceIdentifier){
  authoritativeConcepts.setAuthResourceIdentifier(authResourceIdentifier);
}",0.8826479438314945
38936,"/** 
 * Sets a delay time in milliseconds that must pass between accessing an external resource. This is intended to avoid flooding of, e.g., vocabulary hosts or SPARQL endpoints with HTTP requests.
 * @param delayMillis delay time in milliseconds
 */
@SuppressWarnings(""String_Node_Str"") public void setExtAccessDelayMillis(int delayMillis){
  extAccessDelayMillis=delayMillis;
}","/** 
 * Sets a delay time in milliseconds that must pass between accessing an external resource. This is intended to avoid flooding of, e.g., vocabulary hosts or SPARQL endpoints with HTTP requests.
 * @param delayMillis delay time in milliseconds
 */
@SuppressWarnings(""String_Node_Str"") public void setExtAccessDelayMillis(int delayMillis){
  missingInLinks.setQueryDelayMillis(delayMillis);
  brokenLinks.setExtAccessDelayMillis(delayMillis);
}",0.8875453446191052
38937,"public DisjointLabelsViolations(ResourceLabelsCollector resourceLabelsCollector){
  super(resourceLabelsCollector,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",IssueType.ANALYTICAL);
  this.resourceLabelsCollector=resourceLabelsCollector;
}","public DisjointLabelsViolations(ResourceLabelsCollector resourceLabelsCollector){
  super(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",IssueType.ANALYTICAL);
  this.resourceLabelsCollector=resourceLabelsCollector;
}",0.9491525423728814
38938,"private Map<Literal,Collection<LabeledConcept>> orderResourcesByLabel() throws OpenRDFException {
  Map<Literal,Collection<LabeledConcept>> resourcesByLabel=new HashMap<Literal,Collection<LabeledConcept>>();
  for (  LabeledConcept labeledResource : resourceLabelsCollector.getPreparedData()) {
    Literal literal=new LiteralImpl(labeledResource.getLiteral().getLabel().toUpperCase(),labeledResource.getLiteral().getLanguage());
    Collection<LabeledConcept> resourcesForLiteral=resourcesByLabel.get(literal);
    if (resourcesForLiteral == null) {
      resourcesForLiteral=new HashSet<LabeledConcept>();
      resourcesByLabel.put(literal,resourcesForLiteral);
    }
    resourcesForLiteral.add(labeledResource);
  }
  return resourcesByLabel;
}","private Map<Literal,Collection<LabeledConcept>> orderResourcesByLabel() throws OpenRDFException {
  Map<Literal,Collection<LabeledConcept>> resourcesByLabel=new HashMap<Literal,Collection<LabeledConcept>>();
  for (  LabeledConcept labeledResource : resourceLabelsCollector.getLabeledConcepts()) {
    Literal literal=new LiteralImpl(labeledResource.getLiteral().getLabel().toUpperCase(),labeledResource.getLiteral().getLanguage());
    Collection<LabeledConcept> resourcesForLiteral=resourcesByLabel.get(literal);
    if (resourcesForLiteral == null) {
      resourcesForLiteral=new HashSet<LabeledConcept>();
      resourcesByLabel.put(literal,resourcesForLiteral);
    }
    resourcesForLiteral.add(labeledResource);
  }
  return resourcesByLabel;
}",0.9820119920053296
38939,"private Map<Value,Collection<LabeledConcept>> orderPrefLabelsByResource() throws OpenRDFException {
  Map<Value,Collection<LabeledConcept>> prefLabelsByResource=new HashMap<Value,Collection<LabeledConcept>>();
  for (  LabeledConcept labeledConcept : resourceLabelsCollector.getPreparedData()) {
    if (labeledConcept.getLabelType() != LabelType.PREF_LABEL)     continue;
    Collection<LabeledConcept> labeledResourcesOfUri=prefLabelsByResource.get(labeledConcept.getConcept());
    if (labeledResourcesOfUri == null) {
      labeledResourcesOfUri=new ArrayList<LabeledConcept>();
      prefLabelsByResource.put(labeledConcept.getConcept(),labeledResourcesOfUri);
    }
    labeledResourcesOfUri.add(labeledConcept);
  }
  return prefLabelsByResource;
}","private Map<Value,Collection<LabeledConcept>> orderPrefLabelsByResource() throws OpenRDFException {
  Map<Value,Collection<LabeledConcept>> prefLabelsByResource=new HashMap<Value,Collection<LabeledConcept>>();
  for (  LabeledConcept labeledConcept : resourceLabelsCollector.getLabeledConcepts()) {
    if (labeledConcept.getLabelType() != LabelType.PREF_LABEL)     continue;
    Collection<LabeledConcept> labeledResourcesOfUri=prefLabelsByResource.get(labeledConcept.getConcept());
    if (labeledResourcesOfUri == null) {
      labeledResourcesOfUri=new ArrayList<LabeledConcept>();
      prefLabelsByResource.put(labeledConcept.getConcept(),labeledResourcesOfUri);
    }
    labeledResourcesOfUri.add(labeledConcept);
  }
  return prefLabelsByResource;
}",0.9821546596166556
38940,"public InconsistentPrefLabels(ResourceLabelsCollector resourceLabelsCollector){
  super(resourceLabelsCollector,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",IssueType.ANALYTICAL);
  this.resourceLabelsCollector=resourceLabelsCollector;
}","public InconsistentPrefLabels(ResourceLabelsCollector resourceLabelsCollector){
  super(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",IssueType.ANALYTICAL);
  this.resourceLabelsCollector=resourceLabelsCollector;
}",0.9487179487179488
38941,"public VocEvaluate(String[] args) throws OpenRDFException, IOException {
  parseCmdParams(args);
  if (outputVersion) {
    System.out.println(""String_Node_Str"" + getClass().getPackage().getImplementationVersion());
  }
  if (parsedCommand == null) {
    jc.usage();
  }
 else {
    listIssuesOrEvaluate();
  }
}","public VocEvaluate(String[] args) throws OpenRDFException, IOException {
  qskos=new QSkos();
  parseCmdParams(args);
  if (outputVersion) {
    System.out.println(""String_Node_Str"" + getClass().getPackage().getImplementationVersion());
  }
  if (parsedCommand == null) {
    jc.usage();
  }
 else {
    listIssuesOrEvaluate();
  }
}",0.9674418604651164
38942,"private void setup() throws OpenRDFException, IOException {
  setupLogging();
  RepositoryBuilder repositoryBuilder=new RepositoryBuilder();
  Repository repo=repositoryBuilder.setUpFromFile(new File(parsedCommand.vocabFilenames.get(0)),null,null);
  qskos=new QSkos();
  qskos.setRepositoryConnection(repo.getConnection());
  qskos.setAuthResourceIdentifier(parsedCommand.authoritativeResourceIdentifier);
  qskos.addSparqlEndPoint(""String_Node_Str"");
  qskos.addSparqlEndPoint(""String_Node_Str"");
  if (parsedCommand instanceof CommandAnalyze) {
    qskos.setSubsetSize(((CommandAnalyze)parsedCommand).randomSubsetSize_percent);
  }
  if (parsedCommand.enableSkosXl) {
    repositoryBuilder.enableSkosXlSupport();
  }
  if (!uriTrackingEnabled() && !parsedCommand.noProgressBar) {
    qskos.setProgressMonitor(new ConsoleProgressMonitor());
  }
}","private void setup() throws OpenRDFException, IOException {
  setupLogging();
  RepositoryBuilder repositoryBuilder=new RepositoryBuilder();
  Repository repo=repositoryBuilder.setUpFromFile(new File(parsedCommand.vocabFilenames.get(0)),null,null);
  qskos.setRepositoryConnection(repo.getConnection());
  qskos.setAuthResourceIdentifier(parsedCommand.authoritativeResourceIdentifier);
  qskos.addSparqlEndPoint(""String_Node_Str"");
  qskos.addSparqlEndPoint(""String_Node_Str"");
  if (parsedCommand instanceof CommandAnalyze) {
    qskos.setSubsetSize(((CommandAnalyze)parsedCommand).randomSubsetSize_percent);
  }
  if (parsedCommand.enableSkosXl) {
    repositoryBuilder.enableSkosXlSupport();
  }
  if (!uriTrackingEnabled() && !parsedCommand.noProgressBar) {
    qskos.setProgressMonitor(new ConsoleProgressMonitor());
  }
}",0.9874626865671642
38943,"/** 
 * Set an IProgressMonitor that is notified on changes in the evaluation progress for every managed issues.
 * @param progressMonitor monitor instance to be notified
 */
public void setProgressMonitor(IProgressMonitor progressMonitor){
  for (  Issue issue : registeredIssues) {
    issue.setProgressMonitor(progressMonitor);
  }
}","/** 
 * Set an IProgressMonitor that is notified on changes in the evaluation progress for every managed issues.
 * @param progressMonitor monitor instance to be notified
 */
public void setProgressMonitor(IProgressMonitor progressMonitor){
  this.progressMonitor=progressMonitor;
}",0.7993527508090615
38944,"public List<Issue> getAllIssues(){
  return registeredIssues;
}","public List<Issue> getAllIssues(){
  initialize();
  return registeredIssues;
}",0.8873239436619719
38945,"public void initialize(){
  registeredIssues.clear();
  addStatisticalIssues();
  try {
    addAnalyticalIssues();
    addSkosIntegrityIssues();
  }
 catch (  OpenRDFException e) {
    logger.error(""String_Node_Str"",e);
  }
}","private void initialize(){
  registeredIssues.clear();
  addStatisticalIssues();
  try {
    addAnalyticalIssues();
    addSkosIntegrityIssues();
  }
 catch (  OpenRDFException e) {
    logger.error(""String_Node_Str"",e);
  }
  for (  Issue issue : registeredIssues) {
    issue.setProgressMonitor(progressMonitor);
  }
}",0.8073394495412844
38946,"public Collection<Issue> getIssues(String commaSeparatedIssueIDs){
  if (commaSeparatedIssueIDs == null || commaSeparatedIssueIDs.isEmpty()) {
    return Collections.emptySet();
  }
  Collection<Issue> issues=new ArrayList<Issue>();
  StringTokenizer tokenizer=new StringTokenizer(commaSeparatedIssueIDs,""String_Node_Str"");
  while (tokenizer.hasMoreElements()) {
    issues.add(findIssue(tokenizer.nextToken().trim()));
  }
  return issues;
}","public Collection<Issue> getIssues(String commaSeparatedIssueIDs){
  initialize();
  if (commaSeparatedIssueIDs == null || commaSeparatedIssueIDs.isEmpty()) {
    return Collections.emptySet();
  }
  Collection<Issue> issues=new ArrayList<Issue>();
  StringTokenizer tokenizer=new StringTokenizer(commaSeparatedIssueIDs,""String_Node_Str"");
  while (tokenizer.hasMoreElements()) {
    issues.add(findIssue(tokenizer.nextToken().trim()));
  }
  return issues;
}",0.9822616407982262
38947,"private void setup() throws OpenRDFException, IOException {
  setupLogging();
  RepositoryBuilder repositoryBuilder=new RepositoryBuilder();
  Repository repo=repositoryBuilder.setUpFromFile(new File(parsedCommand.vocabFilenames.get(0)),null,null);
  qskos=new QSkos(repo.getConnection());
  qskos.setAuthResourceIdentifier(parsedCommand.authoritativeResourceIdentifier);
  qskos.addSparqlEndPoint(""String_Node_Str"");
  qskos.addSparqlEndPoint(""String_Node_Str"");
  if (parsedCommand instanceof CommandAnalyze) {
    qskos.setSubsetSize(((CommandAnalyze)parsedCommand).randomSubsetSize_percent);
  }
  if (parsedCommand.enableSkosXl) {
    repositoryBuilder.enableSkosXlSupport();
  }
  if (!uriTrackingEnabled() && !parsedCommand.noProgressBar) {
    qskos.setProgressMonitor(new ConsoleProgressMonitor());
  }
  qskos.initialize();
}","private void setup() throws OpenRDFException, IOException {
  setupLogging();
  RepositoryBuilder repositoryBuilder=new RepositoryBuilder();
  Repository repo=repositoryBuilder.setUpFromFile(new File(parsedCommand.vocabFilenames.get(0)),null,null);
  qskos=new QSkos(repo.getConnection());
  qskos.setAuthResourceIdentifier(parsedCommand.authoritativeResourceIdentifier);
  qskos.addSparqlEndPoint(""String_Node_Str"");
  qskos.addSparqlEndPoint(""String_Node_Str"");
  if (parsedCommand instanceof CommandAnalyze) {
    qskos.setSubsetSize(((CommandAnalyze)parsedCommand).randomSubsetSize_percent);
  }
  if (parsedCommand.enableSkosXl) {
    repositoryBuilder.enableSkosXlSupport();
  }
  if (!uriTrackingEnabled() && !parsedCommand.noProgressBar) {
    qskos.setProgressMonitor(new ConsoleProgressMonitor());
  }
}",0.9866504854368932
38948,"private Collection<URL> extractExternalResources(Collection<URL> allResources){
  Collection<URL> validExternalResources=new HashSet<URL>();
  for (  URL url : allResources) {
    if (isExternalResource(url) && isNonSkosURL(url)) {
      validExternalResources.add(url);
    }
  }
  return validExternalResources;
}","private Collection<URI> extractExternalResources(Collection<URI> allResources){
  Collection<URI> validExternalResources=new HashSet<URI>();
  for (  URI uri : allResources) {
    if (isExternalResource(uri) && isNonSkosURL(uri)) {
      validExternalResources.add(uri);
    }
  }
  return validExternalResources;
}",0.961904761904762
38949,"private boolean isNonSkosURL(URL url){
  return !url.toString().contains(SparqlPrefix.SKOS.getNameSpace());
}","private boolean isNonSkosURL(URI url){
  return !url.toString().contains(SparqlPrefix.SKOS.getNameSpace());
}",0.9908256880733946
38950,"private boolean isExternalResource(URL url){
  String authResourceIdentifier=authoritativeConcepts.getAuthResourceIdentifier();
  if (authResourceIdentifier != null && !authResourceIdentifier.isEmpty()) {
    return !url.toString().toLowerCase().contains(authResourceIdentifier.toLowerCase());
  }
  throw new IllegalArgumentException(""String_Node_Str"");
}","private boolean isExternalResource(URI url){
  String authResourceIdentifier=authoritativeConcepts.getAuthResourceIdentifier();
  if (authResourceIdentifier != null && !authResourceIdentifier.isEmpty()) {
    return !url.toString().toLowerCase().contains(authResourceIdentifier.toLowerCase());
  }
  throw new IllegalArgumentException(""String_Node_Str"");
}",0.9971910112359552
38951,"@Override public Collection<Value> prepareData() throws OpenRDFException {
  extResourcesForConcept=new HashMap<Value,Collection<URL>>();
  findResourcesForConcepts(authoritativeConcepts.getPreparedData());
  return extractUnlinkedConcepts();
}","@Override public Collection<Value> prepareData() throws OpenRDFException {
  extResourcesForConcept=new HashMap<Value,Collection<URI>>();
  findResourcesForConcepts(authoritativeConcepts.getPreparedData());
  return extractUnlinkedConcepts();
}",0.9959016393442623
38952,"private void findResourcesForConcepts(Collection<Value> concepts){
  Iterator<Value> conceptIt=new MonitoredIterator<Value>(concepts,progressMonitor,""String_Node_Str"");
  while (conceptIt.hasNext()) {
    Value concept=conceptIt.next();
    extResourcesForConcept.put(concept,findExternalResourcesForConcept(concept));
  }
}","private void findResourcesForConcepts(Collection<Value> concepts) throws RepositoryException {
  Iterator<Value> conceptIt=new MonitoredIterator<Value>(concepts,progressMonitor,""String_Node_Str"");
  while (conceptIt.hasNext()) {
    Value concept=conceptIt.next();
    extResourcesForConcept.put(concept,extractExternalResources(getURIsOfConcept(concept)));
  }
}",0.87627365356623
38953,"@Before public void setUp() throws IOException, OpenRDFException {
  qskos=new QSkos(new RepositoryBuilder().setUpFromTestResource(""String_Node_Str"").getConnection());
  qskos.initialize();
}","@Before public void setUp() throws IOException, OpenRDFException {
  qskos=new QSkos(new RepositoryBuilder().setUpFromTestResource(""String_Node_Str"").getConnection());
}",0.9388888888888888
38954,"private void addAllIssues() throws OpenRDFException {
  issuesToTest.clear();
  HierarchyGraphBuilder hierarchyGraphBuilder=new HierarchyGraphBuilder(vocabRepository);
  ResourceLabelsCollector resourceLabelsCollector=new ResourceLabelsCollector(vocabRepository);
  InvolvedConcepts involvedConcepts=new InvolvedConcepts(vocabRepository);
  AuthoritativeConcepts authoritativeConcepts=new AuthoritativeConcepts(involvedConcepts);
  authoritativeConcepts.setBaseURI(baseURI);
  authoritativeConcepts.setAuthResourceIdentifier(authResourceIdentifier);
  HttpURIs httpURIs=new HttpURIs(vocabRepository);
  issuesToTest.add(involvedConcepts);
  issuesToTest.add(authoritativeConcepts);
  issuesToTest.add(new OrphanConcepts(involvedConcepts));
  issuesToTest.add(new MissingOutLinks(authoritativeConcepts));
  issuesToTest.add(new LexicalRelations(involvedConcepts));
  issuesToTest.add(new SemanticRelations(vocabRepository));
  issuesToTest.add(new AggregationRelations(vocabRepository));
  ConceptSchemes conceptSchemes=new ConceptSchemes(vocabRepository);
  issuesToTest.add(conceptSchemes);
  issuesToTest.add(new at.ac.univie.mminf.qskos4j.issues.count.Collections(vocabRepository));
  issuesToTest.add(httpURIs);
  issuesToTest.add(new DisconnectedConceptClusters(involvedConcepts));
  issuesToTest.add(new MissingOutLinks(authoritativeConcepts));
  issuesToTest.add(new HierarchicalCycles(hierarchyGraphBuilder));
  issuesToTest.add(new NonHttpResources(vocabRepository));
  issuesToTest.add(new OmittedOrInvalidLanguageTags(vocabRepository));
  issuesToTest.add(new IncompleteLanguageCoverage(involvedConcepts));
  issuesToTest.add(new InconsistentPrefLabels(resourceLabelsCollector));
  issuesToTest.add(new DisjointLabelsViolations(resourceLabelsCollector));
  issuesToTest.add(new OverlappingLabels(involvedConcepts));
  issuesToTest.add(new ValuelessAssociativeRelations(vocabRepository));
  issuesToTest.add(new UndefinedSkosResources(vocabRepository));
  issuesToTest.add(new UndocumentedConcepts(authoritativeConcepts));
  issuesToTest.add(new SolelyTransitivelyRelatedConcepts(vocabRepository));
  issuesToTest.add(new OmittedTopConcepts(conceptSchemes));
  issuesToTest.add(new TopConceptsHavingBroaderConcepts(vocabRepository));
  issuesToTest.add(new MappingClashes(vocabRepository));
  issuesToTest.add(new RelationClashes(hierarchyGraphBuilder));
  BrokenLinks brokenLinks=new BrokenLinks(httpURIs);
  brokenLinks.setSubsetSize(randomSubsetSize_percent);
  brokenLinks.setExtAccessDelayMillis(extAccessDelayMillis);
  issuesToTest.add(brokenLinks);
  MissingInLinks missingInLinks=new MissingInLinks(authoritativeConcepts);
  missingInLinks.setQueryDelayMillis(extAccessDelayMillis);
  missingInLinks.setSubsetSize(randomSubsetSize_percent);
  for (  String sparqlEndpointUrl : sparqlEndpointUrls) {
    missingInLinks.addSparqlEndPoint(sparqlEndpointUrl);
  }
  issuesToTest.add(missingInLinks);
}","private void addAllIssues() throws OpenRDFException {
  issuesToTest.clear();
  addStatisticalIssues();
  addAnalyticalIssues();
  addSkosIntegrityIssues();
}",0.0819778789850357
38955,"@Test public void testResourcesNonHttpUriCount() throws OpenRDFException {
  Assert.assertEquals(4,nonHttpResourcesForResources.getResult().getData().size());
}","@Test public void testResourcesNonHttpUriCount() throws OpenRDFException {
  Assert.assertEquals(4,httpResourcesForUriSchemeViolations.getResult().getData().size());
}",0.9174311926605504
38956,"@Test public void testConceptsNonHttpUriCount() throws OpenRDFException {
  Assert.assertEquals(1,nonHttpResourcesForConcepts.getResult().getData().size());
}","@Test public void testConceptsNonHttpUriCount() throws OpenRDFException {
  Assert.assertEquals(1,httpUriSchemeViolationsForConcepts.getResult().getData().size());
}",0.9164086687306502
38957,"@Before public void setUp() throws OpenRDFException, IOException {
  nonHttpResourcesForConcepts=new NonHttpResources(setUpRepository(""String_Node_Str""));
  nonHttpResourcesForResources=new NonHttpResources(setUpRepository(""String_Node_Str""));
}","@Before public void setUp() throws OpenRDFException, IOException {
  httpUriSchemeViolationsForConcepts=new HttpUriSchemeViolations(setUpRepository(""String_Node_Str""));
  httpResourcesForUriSchemeViolations=new HttpUriSchemeViolations(setUpRepository(""String_Node_Str""));
}",0.61003861003861
38958,"public void addAllIssues() throws OpenRDFException {
  issuesToTest.clear();
  HierarchyGraphBuilder hierarchyGraphBuilder=new HierarchyGraphBuilder(vocabRepository);
  ResourceLabelsCollector resourceLabelsCollector=new ResourceLabelsCollector(vocabRepository);
  InvolvedConcepts involvedConcepts=new InvolvedConcepts(vocabRepository);
  AuthoritativeConcepts authoritativeConcepts=new AuthoritativeConcepts(involvedConcepts);
  authoritativeConcepts.setBaseURI(baseURI);
  authoritativeConcepts.setAuthResourceIdentifier(authResourceIdentifier);
  HttpURIs httpURIs=new HttpURIs(vocabRepository);
  addIssue(involvedConcepts);
  addIssue(authoritativeConcepts);
  addIssue(new OrphanConcepts(involvedConcepts));
  addIssue(new MissingOutLinks(authoritativeConcepts));
  addIssue(new LexicalRelations(involvedConcepts));
  addIssue(new SemanticRelations(vocabRepository));
  addIssue(new AggregationRelations(vocabRepository));
  ConceptSchemes conceptSchemes=new ConceptSchemes(vocabRepository);
  addIssue(conceptSchemes);
  addIssue(new at.ac.univie.mminf.qskos4j.issues.count.Collections(vocabRepository));
  addIssue(httpURIs);
  addIssue(new DisconnectedConceptClusters(involvedConcepts));
  addIssue(new MissingOutLinks(authoritativeConcepts));
  addIssue(new HierarchicalCycles(hierarchyGraphBuilder));
  addIssue(new NonHttpResources(vocabRepository));
  addIssue(new OmittedOrInvalidLanguageTags(vocabRepository));
  addIssue(new IncompleteLanguageCoverage(involvedConcepts));
  addIssue(new InconsistentPrefLabels(resourceLabelsCollector));
  addIssue(new DisjointLabelsViolations(resourceLabelsCollector));
  addIssue(new OverlappingLabels(involvedConcepts));
  addIssue(new ValuelessAssociativeRelations(vocabRepository));
  addIssue(new UndefinedSkosResources(vocabRepository));
  addIssue(new UndocumentedConcepts(authoritativeConcepts));
  addIssue(new SolelyTransitivelyRelatedConcepts(vocabRepository));
  addIssue(new OmittedTopConcepts(conceptSchemes));
  addIssue(new TopConceptsHavingBroaderConcepts(vocabRepository));
  addIssue(new MappingClashes(vocabRepository));
  addIssue(new RelationClashes(hierarchyGraphBuilder));
  BrokenLinks brokenLinks=new BrokenLinks(httpURIs);
  brokenLinks.setSubsetSize(randomSubsetSize_percent);
  brokenLinks.setExtAccessDelayMillis(extAccessDelayMillis);
  addIssue(brokenLinks);
  MissingInLinks missingInLinks=new MissingInLinks(authoritativeConcepts);
  missingInLinks.setQueryDelayMillis(extAccessDelayMillis);
  missingInLinks.setSubsetSize(randomSubsetSize_percent);
  for (  String sparqlEndpointUrl : sparqlEndpointUrls) {
    missingInLinks.addSparqlEndPoint(sparqlEndpointUrl);
  }
  addIssue(missingInLinks);
}","private void addAllIssues() throws OpenRDFException {
  issuesToTest.clear();
  HierarchyGraphBuilder hierarchyGraphBuilder=new HierarchyGraphBuilder(vocabRepository);
  ResourceLabelsCollector resourceLabelsCollector=new ResourceLabelsCollector(vocabRepository);
  InvolvedConcepts involvedConcepts=new InvolvedConcepts(vocabRepository);
  AuthoritativeConcepts authoritativeConcepts=new AuthoritativeConcepts(involvedConcepts);
  authoritativeConcepts.setBaseURI(baseURI);
  authoritativeConcepts.setAuthResourceIdentifier(authResourceIdentifier);
  HttpURIs httpURIs=new HttpURIs(vocabRepository);
  issuesToTest.add(involvedConcepts);
  issuesToTest.add(authoritativeConcepts);
  issuesToTest.add(new OrphanConcepts(involvedConcepts));
  issuesToTest.add(new MissingOutLinks(authoritativeConcepts));
  issuesToTest.add(new LexicalRelations(involvedConcepts));
  issuesToTest.add(new SemanticRelations(vocabRepository));
  issuesToTest.add(new AggregationRelations(vocabRepository));
  ConceptSchemes conceptSchemes=new ConceptSchemes(vocabRepository);
  issuesToTest.add(conceptSchemes);
  issuesToTest.add(new at.ac.univie.mminf.qskos4j.issues.count.Collections(vocabRepository));
  issuesToTest.add(httpURIs);
  issuesToTest.add(new DisconnectedConceptClusters(involvedConcepts));
  issuesToTest.add(new MissingOutLinks(authoritativeConcepts));
  issuesToTest.add(new HierarchicalCycles(hierarchyGraphBuilder));
  issuesToTest.add(new NonHttpResources(vocabRepository));
  issuesToTest.add(new OmittedOrInvalidLanguageTags(vocabRepository));
  issuesToTest.add(new IncompleteLanguageCoverage(involvedConcepts));
  issuesToTest.add(new InconsistentPrefLabels(resourceLabelsCollector));
  issuesToTest.add(new DisjointLabelsViolations(resourceLabelsCollector));
  issuesToTest.add(new OverlappingLabels(involvedConcepts));
  issuesToTest.add(new ValuelessAssociativeRelations(vocabRepository));
  issuesToTest.add(new UndefinedSkosResources(vocabRepository));
  issuesToTest.add(new UndocumentedConcepts(authoritativeConcepts));
  issuesToTest.add(new SolelyTransitivelyRelatedConcepts(vocabRepository));
  issuesToTest.add(new OmittedTopConcepts(conceptSchemes));
  issuesToTest.add(new TopConceptsHavingBroaderConcepts(vocabRepository));
  issuesToTest.add(new MappingClashes(vocabRepository));
  issuesToTest.add(new RelationClashes(hierarchyGraphBuilder));
  BrokenLinks brokenLinks=new BrokenLinks(httpURIs);
  brokenLinks.setSubsetSize(randomSubsetSize_percent);
  brokenLinks.setExtAccessDelayMillis(extAccessDelayMillis);
  issuesToTest.add(brokenLinks);
  MissingInLinks missingInLinks=new MissingInLinks(authoritativeConcepts);
  missingInLinks.setQueryDelayMillis(extAccessDelayMillis);
  missingInLinks.setSubsetSize(randomSubsetSize_percent);
  for (  String sparqlEndpointUrl : sparqlEndpointUrls) {
    missingInLinks.addSparqlEndPoint(sparqlEndpointUrl);
  }
  issuesToTest.add(missingInLinks);
}",0.8501518128237185
38959,"/** 
 * Set an IProgressMonitor that is notified on changes in the evaluation progress for every managed issues.
 * @param progressMonitor monitor instance to be notified
 */
public void setProgressMonitor(IProgressMonitor progressMonitor){
  this.progressMonitor=progressMonitor;
}","/** 
 * Set an IProgressMonitor that is notified on changes in the evaluation progress for every managed issues.
 * @param progressMonitor monitor instance to be notified
 */
public void setProgressMonitor(IProgressMonitor progressMonitor){
  for (  Issue issue : issuesToTest) {
    issue.setProgressMonitor(progressMonitor);
  }
}",0.8045602605863192
38960,"public VocEvaluate(String[] args) throws OpenRDFException, IOException, UnsupportedIssueIdException {
  parseCmdParams(args);
  if (outputVersion) {
    System.out.println(""String_Node_Str"" + getClass().getPackage().getImplementationVersion());
  }
  if (parsedCommand == null) {
    jc.usage();
  }
 else {
    qskos=new QSkos();
    listIssuesOrEvaluate();
  }
}","private VocEvaluate(String[] args) throws OpenRDFException, IOException {
  parseCmdParams(args);
  if (outputVersion) {
    System.out.println(""String_Node_Str"" + getClass().getPackage().getImplementationVersion());
  }
  if (parsedCommand == null) {
    jc.usage();
  }
 else {
    listIssuesOrEvaluate();
  }
}",0.9069423929098966
38961,"private Collection<Issue> extractMeasures() throws UnsupportedIssueIdException {
  Collection<Issue> resultingIssues;
  Collection<Issue> selectedIssues=getIssues(parsedCommand.selectedIds);
  Collection<Issue> excludedIssues=getIssues(parsedCommand.excludedIds);
  if (!selectedIssues.isEmpty()) {
    resultingIssues=selectedIssues;
  }
 else   if (!excludedIssues.isEmpty()) {
    resultingIssues=getAllIssuesForCommand();
    resultingIssues.removeAll(excludedIssues);
  }
 else {
    resultingIssues=getAllIssuesForCommand();
  }
  return resultingIssues;
}","private Collection<Issue> extractMeasures(){
  Collection<Issue> resultingIssues;
  Collection<Issue> selectedIssues=getIssues(parsedCommand.selectedIds);
  Collection<Issue> excludedIssues=getIssues(parsedCommand.excludedIds);
  if (!selectedIssues.isEmpty()) {
    resultingIssues=selectedIssues;
  }
 else   if (!excludedIssues.isEmpty()) {
    resultingIssues=getAllIssuesForCommand();
    resultingIssues.removeAll(excludedIssues);
  }
 else {
    resultingIssues=getAllIssuesForCommand();
  }
  return resultingIssues;
}",0.1691176470588235
38962,"public static void main(String[] args){
  try {
    new VocEvaluate(args);
  }
 catch (  ParameterException paramExc) {
    jc.usage();
  }
catch (  IOException ioException) {
    System.out.println(""String_Node_Str"" + ioException.getMessage());
  }
catch (  OpenRDFException rdfException) {
    System.out.println(""String_Node_Str"" + rdfException.getMessage());
  }
catch (  UnsupportedIssueIdException measureIdExc) {
    System.out.println(""String_Node_Str"" + measureIdExc.getUnsupportedId());
  }
}","public static void main(String[] args){
  try {
    new VocEvaluate(args);
  }
 catch (  ParameterException paramExc) {
    jc.usage();
  }
catch (  IOException ioException) {
    System.out.println(""String_Node_Str"" + ioException.getMessage());
  }
catch (  OpenRDFException rdfException) {
    System.out.println(""String_Node_Str"" + rdfException.getMessage());
  }
}",0.8436781609195402
38963,"private void setup() throws OpenRDFException, IOException {
  setupLogging();
  VocabRepository vocabRepo=new VocabRepository(new File(parsedCommand.vocabFilenames.get(0)),null,null);
  qskos.setVocabRepository(vocabRepo);
  qskos.setAuthResourceIdentifier(parsedCommand.authoritativeResourceIdentifier);
  qskos.addSparqlEndPoint(""String_Node_Str"");
  qskos.addSparqlEndPoint(""String_Node_Str"");
  if (parsedCommand instanceof CommandAnalyze) {
    qskos.setSubsetSize(((CommandAnalyze)parsedCommand).randomSubsetSize_percent);
  }
  if (parsedCommand.enableSkosXl) {
    vocabRepo.enableSkosXlSupport();
  }
  if (!uriTrackingEnabled() && !parsedCommand.noProgressBar) {
    qskos.setProgressMonitor(new ConsoleProgressMonitor());
  }
}","private void setup() throws OpenRDFException, IOException {
  setupLogging();
  VocabRepository vocabRepo=new VocabRepository(new File(parsedCommand.vocabFilenames.get(0)),null,null);
  qskos=new QSkos(vocabRepo);
  qskos.setAuthResourceIdentifier(parsedCommand.authoritativeResourceIdentifier);
  qskos.addSparqlEndPoint(""String_Node_Str"");
  qskos.addSparqlEndPoint(""String_Node_Str"");
  if (parsedCommand instanceof CommandAnalyze) {
    qskos.setSubsetSize(((CommandAnalyze)parsedCommand).randomSubsetSize_percent);
  }
  if (parsedCommand.enableSkosXl) {
    vocabRepo.enableSkosXlSupport();
  }
  if (!uriTrackingEnabled() && !parsedCommand.noProgressBar) {
    qskos.setProgressMonitor(new ConsoleProgressMonitor());
  }
}",0.9802317655078392
38964,"private void evaluate() throws OpenRDFException, IOException, UnsupportedIssueIdException {
  setup();
  reportGenerator=new ReportGenerator(extractMeasures());
  if (uriTrackingEnabled()) {
    reportGenerator.outputURITrackingReport(new File(((CommandAnalyze)parsedCommand).uriTrackFilename));
  }
 else {
    reportGenerator.outputIssuesReport(shouldOutputExtReport(),shouldWriteGraphs());
  }
}","private void evaluate() throws OpenRDFException, IOException {
  setup();
  reportGenerator=new ReportGenerator(extractMeasures());
  if (uriTrackingEnabled()) {
    reportGenerator.outputURITrackingReport(new File(((CommandAnalyze)parsedCommand).uriTrackFilename));
  }
 else {
    reportGenerator.outputIssuesReport(shouldOutputExtReport(),shouldWriteGraphs());
  }
}",0.1903520208604954
38965,"private Collection<Issue> getIssues(String ids) throws UnsupportedIssueIdException {
  if (ids == null || ids.isEmpty()) {
    return Collections.emptySet();
  }
  Collection<Issue> issues=new ArrayList<Issue>();
  StringTokenizer tokenizer=new StringTokenizer(ids,""String_Node_Str"");
  while (tokenizer.hasMoreElements()) {
    for (    Issue issue : qskos.getAllIssues()) {
      if (issue.getId().equalsIgnoreCase(tokenizer.nextToken())) {
        issues.add(issue);
      }
    }
  }
  return issues;
}","private Collection<Issue> getIssues(String ids){
  if (ids == null || ids.isEmpty()) {
    return Collections.emptySet();
  }
  Collection<Issue> issues=new ArrayList<Issue>();
  StringTokenizer tokenizer=new StringTokenizer(ids,""String_Node_Str"");
  while (tokenizer.hasMoreElements()) {
    String token=tokenizer.nextToken();
    for (    Issue issue : qskos.getAllIssues()) {
      if (issue.getId().equalsIgnoreCase(token)) {
        issues.add(issue);
      }
    }
  }
  return issues;
}",0.908
38966,"private void listIssuesOrEvaluate() throws OpenRDFException, IOException, UnsupportedIssueIdException {
  if (parsedCommand.vocabFilenames == null) {
    if (parsedCommand instanceof CommandAnalyze) {
      outputIssueDetails(Issue.IssueType.ANALYTICAL);
    }
 else {
      outputIssueDetails(Issue.IssueType.STATISTICAL);
    }
  }
 else {
    checkVocabFilenameGiven();
    evaluate();
  }
}","private void listIssuesOrEvaluate() throws OpenRDFException, IOException {
  if (parsedCommand.vocabFilenames == null) {
    if (parsedCommand instanceof CommandAnalyze) {
      outputIssueDetails(Issue.IssueType.ANALYTICAL);
    }
 else {
      outputIssueDetails(Issue.IssueType.STATISTICAL);
    }
  }
 else {
    checkVocabFilenameGiven();
    evaluate();
  }
}",0.9617918313570488
38967,"public final void reset(){
  result=null;
  if (progressMonitor != null) {
    progressMonitor.reset();
  }
}","protected final void reset(){
  result=null;
  if (progressMonitor != null) {
    progressMonitor.reset();
  }
}",0.9502262443438914
38968,"private Collection<Value> createUriResultList(TupleQueryResult result,String bindingName) throws OpenRDFException {
  List<Value> resultList=new ArrayList<Value>();
  while (result.hasNext()) {
    BindingSet queryResult=result.next();
    URI resource=(URI)queryResult.getValue(bindingName);
    resultList.add(resource);
  }
  return resultList;
}","private Collection<Value> createUriResultList(TupleQueryResult result) throws OpenRDFException {
  List<Value> resultList=new ArrayList<Value>();
  while (result.hasNext()) {
    BindingSet queryResult=result.next();
    URI resource=(URI)queryResult.getValue(""String_Node_Str"");
    resultList.add(resource);
  }
  return resultList;
}",0.9343065693430656
38969,"@Override protected CollectionResult<Value> invoke() throws OpenRDFException {
  TupleQueryResult result=vocabRepository.query(createTopConceptsHavingBroaderConceptQuery());
  return new CollectionResult<Value>(createUriResultList(result,""String_Node_Str""));
}","@Override protected CollectionResult<Value> invoke() throws OpenRDFException {
  TupleQueryResult result=vocabRepository.query(createTopConceptsHavingBroaderConceptQuery());
  return new CollectionResult<Value>(createUriResultList(result));
}",0.9641434262948207
38970,"public Result(T data){
  this.data=data;
}","protected Result(T data){
  this.data=data;
}",0.8735632183908046
38971,"public static Set<Value> getValuesForBindingName(TupleQueryResult result,String bindingName) throws QueryEvaluationException {
  Set<Value> ret=new HashSet<Value>();
  while (result.hasNext()) {
    Value concept=result.next().getValue(bindingName);
    if (concept instanceof URI) {
      ret.add((URI)concept);
    }
  }
  return ret;
}","public static Set<Value> getValuesForBindingName(TupleQueryResult result,String bindingName) throws QueryEvaluationException {
  Set<Value> ret=new HashSet<Value>();
  while (result.hasNext()) {
    Value concept=result.next().getValue(bindingName);
    if (concept instanceof URI) {
      ret.add(concept);
    }
  }
  return ret;
}",0.992548435171386
38972,"public BrokenLinksResult findBrokenLinks() throws OpenRDFException {
  resourceAvailabilityChecker.setProgressMonitor(progressMonitor);
  return resourceAvailabilityChecker.findBrokenLinks(randomSubsetSize_percent,urlDereferencingDelay);
}","public ExtrapolatedCollectionResult<URL> findBrokenLinks() throws OpenRDFException {
  resourceAvailabilityChecker.setProgressMonitor(progressMonitor);
  return resourceAvailabilityChecker.findBrokenLinks(randomSubsetSize_percent,urlDereferencingDelay);
}",0.902834008097166
38973,"private void dereferenceURIs(Float randomSubsetSize_percent){
  Set<URI> urisToBeDereferenced=collectUrisToBeDereferenced(randomSubsetSize_percent);
  Iterator<URI> it=new MonitoredIterator<URI>(urisToBeDereferenced,progressMonitor);
  int i=1;
  while (it.hasNext()) {
    URI uri=it.next();
    logger.debug(""String_Node_Str"" + i + ""String_Node_Str""+ urisToBeDereferenced.size());
    i++;
    try {
      Thread.sleep(urlDereferencingDelayMillis);
    }
 catch (    InterruptedException e) {
    }
    addToResults(uri);
  }
}","private void dereferenceURIs(Float randomSubsetSize_percent,Integer urlDereferencingDelayMillis){
  Set<URI> urisToBeDereferenced=collectUrisToBeDereferenced(randomSubsetSize_percent);
  Iterator<URI> it=new MonitoredIterator<URI>(urisToBeDereferenced,progressMonitor);
  int i=1;
  while (it.hasNext()) {
    URI uri=it.next();
    logger.debug(""String_Node_Str"" + i + ""String_Node_Str""+ urisToBeDereferenced.size());
    i++;
    try {
      if (urlDereferencingDelayMillis == null) {
        urlDereferencingDelayMillis=DEREF_DELAY_MILLIS;
      }
      Thread.sleep(urlDereferencingDelayMillis);
    }
 catch (    InterruptedException e) {
    }
    addToResults(uri);
  }
}",0.8765534382767192
38974,"public BrokenLinksResult findBrokenLinks(Float randomSubsetSize_percent,Integer urlDereferencingDelayMillis) throws OpenRDFException {
  if (urlDereferencingDelayMillis != null) {
    this.urlDereferencingDelayMillis=urlDereferencingDelayMillis;
  }
  findAllHttpURLs();
  dereferenceURIs(randomSubsetSize_percent);
  return new BrokenLinksResult(urlAvailability,randomSubsetSize_percent);
}","public ExtrapolatedCollectionResult<URL> findBrokenLinks(Float randomSubsetSize_percent,Integer urlDereferencingDelayMillis) throws OpenRDFException {
  createAvailabilityMap(randomSubsetSize_percent,urlDereferencingDelayMillis);
  return new ExtrapolatedCollectionResult<URL>(collectUnavailableURLs(),randomSubsetSize_percent);
}",0.521497919556172
38975,"public CollectionResult<Set<URI>> findHierarchicalCycles() throws OpenRDFException {
  return hierarchyAnalyer.findCycleContainingComponents();
}","public CollectionResult<Set<Resource>> findHierarchicalCycles() throws OpenRDFException {
  return hierarchyAnalyer.findCycleContainingComponents();
}",0.9694915254237289
38976,"private Relation(URI sourceConcept,URI targetConcept,URI property){
  this.sourceConcept=sourceConcept;
  this.targetConcept=targetConcept;
  this.property=property;
}","private Relation(Resource sourceConcept,Resource targetConcept,Resource property){
  this.sourceConcept=sourceConcept;
  this.targetConcept=targetConcept;
  this.property=property;
}",0.9226361031518624
38977,"private void createGraph(Collection<URI> allConcepts) throws OpenRDFException {
  graph=new DirectedMultigraph<URI,NamedEdge>(NamedEdge.class);
  Iterator<URI> conceptIt=new MonitoredIterator<URI>(allConcepts,progressMonitor);
  while (conceptIt.hasNext()) {
    Collection<Relation> relations=findRelations(conceptIt.next());
    for (    Relation relation : relations) {
      addNodesToGraph(relation.sourceConcept,relation.targetConcept,relation.property);
    }
  }
}","private void createGraph(Collection<URI> allConcepts) throws OpenRDFException {
  graph=new DirectedMultigraph<Resource,NamedEdge>(NamedEdge.class);
  Iterator<URI> conceptIt=new MonitoredIterator<URI>(allConcepts,progressMonitor);
  while (conceptIt.hasNext()) {
    Collection<Relation> relations=findRelations(conceptIt.next());
    for (    Relation relation : relations) {
      addNodesToGraph(relation.sourceConcept,relation.targetConcept,relation.property);
    }
  }
}",0.98840885142255
38978,"private void addNodesToGraph(URI skosResource,URI otherResource,URI skosRelation){
  graph.addVertex(skosResource);
  if (otherResource != null) {
    graph.addVertex(otherResource);
    graph.addEdge(skosResource,otherResource,new NamedEdge(skosRelation.getLocalName()));
  }
}","private void addNodesToGraph(Resource skosResource,Resource otherResource,Resource skosRelation){
  graph.addVertex(skosResource);
  if (otherResource != null) {
    graph.addVertex(otherResource);
    graph.addEdge(skosResource,otherResource,new NamedEdge(skosRelation.stringValue()));
  }
}",0.8035087719298246
38979,"private Collection<Relation> findRelations(URI concept) throws OpenRDFException {
  Collection<Relation> allRelations=new ArrayList<Relation>();
  TupleQueryResult result=vocabRepository.query(createConnectionsQuery(concept));
  while (result.hasNext()) {
    BindingSet bindingSet=result.next();
    Value otherConcept=bindingSet.getValue(""String_Node_Str"");
    Value semanticRelation=bindingSet.getValue(""String_Node_Str"");
    if (otherConcept != null && semanticRelation != null) {
      allRelations.add(new Relation(concept,(URI)otherConcept,(URI)semanticRelation));
    }
  }
  return allRelations;
}","private Collection<Relation> findRelations(URI concept) throws OpenRDFException {
  Collection<Relation> allRelations=new ArrayList<Relation>();
  TupleQueryResult result=vocabRepository.query(createConnectionsQuery(concept));
  while (result.hasNext()) {
    BindingSet bindingSet=result.next();
    Value otherConcept=bindingSet.getValue(""String_Node_Str"");
    Value semanticRelation=bindingSet.getValue(""String_Node_Str"");
    if (otherConcept != null && semanticRelation != null) {
      allRelations.add(new Relation(concept,(Resource)otherConcept,(Resource)semanticRelation));
    }
  }
  return allRelations;
}",0.9820554649265906
38980,"private void createGraph(TupleQueryResult broaderResult,TupleQueryResult narrowerResult) throws QueryEvaluationException {
  hierarchyGraph=new DirectedMultigraph<URI,NamedEdge>(NamedEdge.class);
  addResultsToGraph(broaderResult,false);
  addResultsToGraph(narrowerResult,true);
}","private void createGraph(TupleQueryResult broaderResult,TupleQueryResult narrowerResult) throws QueryEvaluationException {
  hierarchyGraph=new DirectedMultigraph<Resource,NamedEdge>(NamedEdge.class);
  addResultsToGraph(broaderResult,false);
  addResultsToGraph(narrowerResult,true);
}",0.980599647266314
38981,"private void addToGraph(Value resource,Value otherResource,boolean invertEdges){
  URI resourceNode=new URIImpl(resource.stringValue());
  hierarchyGraph.addVertex(resourceNode);
  URI otherNode=new URIImpl(otherResource.stringValue());
  hierarchyGraph.addVertex(otherNode);
  if (invertEdges) {
    hierarchyGraph.addEdge(otherNode,resourceNode,new NamedEdge());
  }
 else {
    hierarchyGraph.addEdge(resourceNode,otherNode,new NamedEdge());
  }
}","private void addToGraph(Value resource,Value otherResource,boolean invertEdges){
  Resource resourceNode=(Resource)resource;
  hierarchyGraph.addVertex(resourceNode);
  Resource otherNode=(Resource)otherResource;
  hierarchyGraph.addVertex(otherNode);
  if (invertEdges) {
    hierarchyGraph.addEdge(otherNode,resourceNode,new NamedEdge());
  }
 else {
    hierarchyGraph.addEdge(resourceNode,otherNode,new NamedEdge());
  }
}",0.8424657534246576
38982,"private List<Set<URI>> trackNodesInCycles(Set<URI> nodesInCycles){
  List<Set<URI>> ret=new ArrayList<Set<URI>>();
  List<Set<URI>> stronglyConnectedSets=new StrongConnectivityInspector<URI,NamedEdge>(hierarchyGraph).stronglyConnectedSets();
  for (  URI node : nodesInCycles) {
    for (    Set<URI> stronglyConnectedSet : stronglyConnectedSets) {
      if (stronglyConnectedSet.contains(node)) {
        if (!ret.contains(stronglyConnectedSet)) {
          ret.add(stronglyConnectedSet);
        }
      }
    }
  }
  return ret;
}","private List<Set<Resource>> trackNodesInCycles(Set<Resource> nodesInCycles){
  List<Set<Resource>> ret=new ArrayList<Set<Resource>>();
  List<Set<Resource>> stronglyConnectedSets=new StrongConnectivityInspector<Resource,NamedEdge>(hierarchyGraph).stronglyConnectedSets();
  for (  Resource node : nodesInCycles) {
    for (    Set<Resource> stronglyConnectedSet : stronglyConnectedSets) {
      if (stronglyConnectedSet.contains(node)) {
        if (!ret.contains(stronglyConnectedSet)) {
          ret.add(stronglyConnectedSet);
        }
      }
    }
  }
  return ret;
}",0.4394213381555154
38983,"public CollectionResult<Set<URI>> findCycleContainingComponents() throws OpenRDFException {
  if (hierarchyGraph == null) {
    TupleQueryResult broaderResult=findTriples(HierarchyStyle.BROADER);
    TupleQueryResult narrowerResult=findTriples(HierarchyStyle.NARROWER);
    createGraph(broaderResult,narrowerResult);
  }
  Set<URI> nodesInCycles=new CycleDetector<URI,NamedEdge>(hierarchyGraph).findCycles();
  cycleContainingComponents=trackNodesInCycles(nodesInCycles);
  return new CollectionResult<Set<URI>>(cycleContainingComponents);
}","public CollectionResult<Set<Resource>> findCycleContainingComponents() throws OpenRDFException {
  if (hierarchyGraph == null) {
    TupleQueryResult broaderResult=findTriples(HierarchyStyle.BROADER);
    TupleQueryResult narrowerResult=findTriples(HierarchyStyle.NARROWER);
    createGraph(broaderResult,narrowerResult);
  }
  Set<Resource> nodesInCycles=new CycleDetector<Resource,NamedEdge>(hierarchyGraph).findCycles();
  cycleContainingComponents=trackNodesInCycles(nodesInCycles);
  return new CollectionResult<Set<Resource>>(cycleContainingComponents);
}",0.9473684210526316
38984,"public CollectionResult<URI> findMissingOutLinks(Collection<URI> autoritativeConcepts,String authResourceIdentifier) throws OpenRDFException {
  extResourcesForConcept=new HashMap<URI,List<URL>>();
  this.authResourceIdentifier=authResourceIdentifier;
  findResourcesForConcepts(autoritativeConcepts);
  retainExternalResources();
  return new CollectionResult<URI>(extractUnlinkedConcepts());
}","public CollectionResult<URI> findMissingOutLinks(Collection<URI> autoritativeConcepts,String authResourceIdentifier) throws OpenRDFException {
  extResourcesForConcept=new HashMap<URI,Collection<URL>>();
  this.authResourceIdentifier=authResourceIdentifier;
  findResourcesForConcepts(autoritativeConcepts);
  return new CollectionResult<URI>(extractUnlinkedConcepts());
}",0.7979139504563233
38985,"private void findResourcesForConcepts(Collection<URI> concepts) throws OpenRDFException {
  Iterator<URI> conceptIt=new MonitoredIterator<URI>(concepts,progressMonitor,""String_Node_Str"");
  while (conceptIt.hasNext()) {
    URI concept=conceptIt.next();
    extResourcesForConcept.put(concept,findResourcesForConcept(concept));
  }
}","private void findResourcesForConcepts(Collection<URI> concepts) throws OpenRDFException {
  Iterator<URI> conceptIt=new MonitoredIterator<URI>(concepts,progressMonitor,""String_Node_Str"");
  while (conceptIt.hasNext()) {
    URI concept=conceptIt.next();
    extResourcesForConcept.put(concept,findExternalResourcesForConcept(concept));
  }
}",0.9881305637982196
38986,"public WeaklyConnectedComponentsResult(DirectedGraph<URI,NamedEdge> data){
  super(data);
  connectedSets=new ConnectivityInspector<URI,NamedEdge>(getData()).connectedSets();
}","public WeaklyConnectedComponentsResult(DirectedGraph<Resource,NamedEdge> data){
  super(data);
  connectedSets=new ConnectivityInspector<Resource,NamedEdge>(getData()).connectedSets();
}",0.9502762430939228
38987,"public List<Set<URI>> getConnectedSets(){
  return connectedSets;
}","public List<Set<Resource>> getConnectedSets(){
  return connectedSets;
}",0.935251798561151
38988,"@Override public String getExtensiveReport(){
  String detailedReport=""String_Node_Str"";
  long compCount=1;
  for (  Set<URI> component : connectedSets) {
    detailedReport+=""String_Node_Str"" + compCount + ""String_Node_Str""+ component.size()+ ""String_Node_Str""+ component.toString()+ ""String_Node_Str"";
    compCount++;
  }
  return detailedReport;
}","@Override public String getExtensiveReport(){
  String detailedReport=""String_Node_Str"";
  long compCount=1;
  for (  Set<Resource> component : connectedSets) {
    detailedReport+=""String_Node_Str"" + compCount + ""String_Node_Str""+ component.size()+ ""String_Node_Str""+ component.toString()+ ""String_Node_Str"";
    compCount++;
  }
  return detailedReport;
}",0.9844851904090268
38989,"public void exportSubGraph(List<Set<URI>> vertexSubSets,Writer[] outputWriters){
  int i=0;
  Iterator<Set<URI>> it=vertexSubSets.iterator();
  while (it.hasNext()) {
    Graph<URI,NamedEdge> componentGraph=getGraphForComponent(it.next());
    new DOTExporter<URI,NamedEdge>(new IntegerNameProvider<URI>(),new URIVertexNameProvider(),new StringEdgeNameProvider<NamedEdge>()).export(outputWriters[i],(DirectedGraph<URI,NamedEdge>)componentGraph);
    i++;
  }
}","public void exportSubGraph(List<Set<Resource>> vertexSubSets,Writer[] outputWriters){
  int i=0;
  Iterator<Set<Resource>> it=vertexSubSets.iterator();
  while (it.hasNext()) {
    Graph<Resource,NamedEdge> componentGraph=getGraphForComponent(it.next());
    new DOTExporter<Resource,NamedEdge>(new IntegerNameProvider<Resource>(),new URIVertexNameProvider(),new StringEdgeNameProvider<NamedEdge>()).export(outputWriters[i],(DirectedGraph<Resource,NamedEdge>)componentGraph);
    i++;
  }
}",0.8968421052631579
38990,"private Graph<URI,NamedEdge> getGraphForComponent(Collection<URI> component){
  return new DirectedSubgraph<URI,NamedEdge>(graph,new HashSet<URI>(component),null);
}","private Graph<Resource,NamedEdge> getGraphForComponent(Collection<Resource> component){
  return new DirectedSubgraph<Resource,NamedEdge>(graph,new HashSet<Resource>(component),null);
}",0.8971428571428571
38991,"public GraphExporter(DirectedGraph<URI,NamedEdge> graph){
  this.graph=graph;
}","public GraphExporter(DirectedGraph<Resource,NamedEdge> graph){
  this.graph=graph;
}",0.9447852760736196
38992,"@Override public String getVertexName(URI vertex){
  return vertex.getLocalName();
}","@Override public String getVertexName(Resource vertex){
  return vertex.stringValue();
}",0.8604651162790697
38993,"@Test public void testComponentCount() throws OpenRDFException {
  long conceptCount=qSkosComponents.findInvolvedConcepts().getData().size();
  List<Set<URI>> components=qSkosComponents.findComponents().getConnectedSets();
  Assert.assertEquals(7,components.size());
  Assert.assertTrue(getVertexCount(components) <= conceptCount);
}","@Test public void testComponentCount() throws OpenRDFException {
  long conceptCount=qSkosComponents.findInvolvedConcepts().getData().size();
  List<Set<Resource>> components=qSkosComponents.findComponents().getConnectedSets();
  Assert.assertEquals(7,components.size());
  Assert.assertTrue(getVertexCount(components) <= conceptCount);
}",0.9865871833084948
38994,"private long getVertexCount(List<Set<URI>> components){
  long ret=0;
  for (  Set<URI> component : components) {
    ret+=component.size();
  }
  return ret;
}","private long getVertexCount(List<Set<Resource>> components){
  long ret=0;
  for (  Set<Resource> component : components) {
    ret+=component.size();
  }
  return ret;
}",0.9454545454545454
38995,"public CollectionResult<URI> findOmittedTopConcepts() throws OpenRDFException {
  return new ConceptSchemeChecker(vocabRepository).findOmittedTopConcepts();
}","public CollectionResult<URI> findOmittedTopConcepts() throws OpenRDFException {
  return new ConceptSchemeChecker(vocabRepository).findOmittedTopConcepts(findConceptSchemes().getData());
}",0.9132947976878611
38996,"public CollectionResult<URI> findOmittedTopConcepts() throws OpenRDFException {
  TupleQueryResult result=vocabRepository.query(createConceptSchemesWithoutTopConceptQuery());
  Collection<URI> foundConceptSchemes=createUriResultList(result,""String_Node_Str"");
  return new CollectionResult<URI>(foundConceptSchemes);
}","public CollectionResult<URI> findOmittedTopConcepts(Collection<URI> allConceptSchemes) throws OpenRDFException {
  RepositoryConnection connection=vocabRepository.getRepository().getConnection();
  Collection<URI> csWithOmittedTopConcepts=new HashSet<URI>();
  for (  URI conceptScheme : allConceptSchemes) {
    BooleanQuery hasTopConceptQuery=connection.prepareBooleanQuery(QueryLanguage.SPARQL,createConceptSchemeWithoutTopConceptQuery(conceptScheme));
    if (!hasTopConceptQuery.evaluate()) {
      csWithOmittedTopConcepts.add(conceptScheme);
    }
  }
  return new CollectionResult<URI>(csWithOmittedTopConcepts);
}",0.3
38997,"@Test public void testConceptSchemesWithoutTopConceptsCount() throws OpenRDFException {
  Collection<URI> conceptSchemes=qSkosMissingTopConcepts.findOmittedTopConcepts().getData();
  Assert.assertEquals(1,conceptSchemes.size());
}","@Test public void testConceptSchemesWithoutTopConceptsCount() throws OpenRDFException {
  Collection<URI> conceptSchemes=qSkosMissingTopConcepts.findOmittedTopConcepts().getData();
  Assert.assertEquals(2,conceptSchemes.size());
}",0.9956521739130436
38998,"private String createRedundantAssociativeRelationsQuery(){
  return SparqlPrefix.SKOS + ""String_Node_Str"" + ""String_Node_Str""+ vocabRepository.getVocabContext()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
}","private String createRedundantAssociativeRelationsQuery(){
  return SparqlPrefix.SKOS + ""String_Node_Str"" + ""String_Node_Str""+ vocabRepository.getVocabContext()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
}",0.736517719568567
38999,"@Test public void testRedundantAssociativeRelationsCount() throws OpenRDFException {
  Collection<Pair<URI>> redAssRels=qSkosRedundantAssociativeRelations.findValuelessAssociativeRelations().getData();
  Assert.assertEquals(5,redAssRels.size());
}","@Test public void testRedundantAssociativeRelationsCount() throws OpenRDFException {
  Collection<Pair<URI>> redAssRels=qSkosRedundantAssociativeRelations.findValuelessAssociativeRelations().getData();
  Assert.assertEquals(6,redAssRels.size());
}",0.9959514170040484
39000,"public QSkos(File rdfFile,String baseURI,RDFFormat dataFormat) throws RepositoryException, RDFParseException, IOException {
  vocabRepository=new VocabRepository(rdfFile,baseURI,dataFormat);
  extractPublishingHost(baseURI);
  init();
}","public QSkos(File rdfFile,String baseURI,RDFFormat dataFormat) throws RepositoryException, RDFParseException, IOException {
  logger.info(""String_Node_Str"" + rdfFile.getName() + ""String_Node_Str"");
  vocabRepository=new VocabRepository(rdfFile,baseURI,dataFormat);
  extractPublishingHost(baseURI);
  init();
}",0.8644688644688645
