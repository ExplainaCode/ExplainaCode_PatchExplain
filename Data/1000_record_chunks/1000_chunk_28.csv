record_number,buggy_code,fixed_code,code_similarity
27001,"@Override public View getView(int position,View convertView,Context c){
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(c).inflate(R.layout.list_item_linechart,null);
    holder.chart=(LineChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setDrawYValues(false);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setDrawVerticalGrid(false);
  holder.chart.setDrawGridBackground(false);
  XLabels xl=holder.chart.getXLabels();
  xl.setCenterXLabelText(true);
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setTypeface(mTf);
  YLabels yl=holder.chart.getYLabels();
  yl.setTypeface(mTf);
  yl.setLabelCount(5);
  holder.chart.setData(mChartData);
  holder.chart.animateX(1000);
  return convertView;
}","@Override public View getView(int position,View convertView,Context c){
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(c).inflate(R.layout.list_item_linechart,null);
    holder.chart=(LineChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setDrawYValues(false);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setDrawVerticalGrid(false);
  holder.chart.setDrawGridBackground(false);
  XLabels xl=holder.chart.getXLabels();
  xl.setCenterXLabelText(true);
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setTypeface(mTf);
  YLabels yl=holder.chart.getYLabels();
  yl.setTypeface(mTf);
  yl.setLabelCount(5);
  holder.chart.setData((LineData)mChartData);
  holder.chart.animateX(1000);
  return convertView;
}",0.9943883277216612
27002,"@Override public View getView(int position,View convertView,Context c){
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(c).inflate(R.layout.list_item_piechart,null);
    holder.chart=(PieChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setValueTypeface(mTf);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setHoleRadius(60f);
  holder.chart.setTransparentCircleRadius(65f);
  holder.chart.setCenterText(""String_Node_Str"");
  holder.chart.setCenterTextTypeface(mTf);
  holder.chart.setCenterTextSize(18f);
  holder.chart.setDrawXValues(false);
  holder.chart.setUsePercentValues(true);
  holder.chart.setData(mChartData);
  Legend l=holder.chart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  holder.chart.animateXY(900,900);
  return convertView;
}","@Override public View getView(int position,View convertView,Context c){
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(c).inflate(R.layout.list_item_piechart,null);
    holder.chart=(PieChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setValueTypeface(mTf);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setHoleRadius(60f);
  holder.chart.setTransparentCircleRadius(65f);
  holder.chart.setCenterText(""String_Node_Str"");
  holder.chart.setCenterTextTypeface(mTf);
  holder.chart.setCenterTextSize(18f);
  holder.chart.setDrawXValues(false);
  holder.chart.setUsePercentValues(true);
  holder.chart.setData((PieData)mChartData);
  Legend l=holder.chart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  holder.chart.animateXY(900,900);
  return convertView;
}",0.9953198127925116
27003,"@Override protected void drawValues(){
  long starttime=System.currentTimeMillis();
  if (mDrawYValues && mCurrentData.getYValCount() < mMaxVisibleCount * mScaleX) {
    ArrayList<BarDataSet> dataSets=(ArrayList<BarDataSet>)mCurrentData.getDataSets();
    float offset=0f;
    if (mDrawValueAboveBar)     offset=-Utils.convertDpToPixel(5);
 else     offset=Utils.calcTextHeight(mValuePaint,""String_Node_Str"") * 1.5f;
    for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
      BarDataSet dataSet=dataSets.get(i);
      ArrayList<Entry> entries=dataSet.getYVals();
      float[] valuePoints=generateTransformedValues(entries,0.5f);
      if (!mDrawValuesForWholeStack) {
        for (int j=0; j < valuePoints.length * mPhaseX; j+=2) {
          if (isOffContentRight(valuePoints[j]))           break;
          if (isOffContentLeft(valuePoints[j]))           continue;
          float val=entries.get(j / 2).getSum();
          drawValue(mFormatValue.format(val),valuePoints[j],valuePoints[j + 1] + offset);
        }
      }
 else {
        for (int j=0; j < (valuePoints.length - 1) * mPhaseX; j+=2) {
          if (isOffContentRight(valuePoints[j]))           break;
          if (isOffContentLeft(valuePoints[j]))           continue;
          Entry e=entries.get(j / 2);
          float[] vals=e.getVals();
          if (vals == null) {
            drawValue(mFormatValue.format(e.getVal()),valuePoints[j],valuePoints[j + 1] + offset);
          }
 else {
            float[] transformed=new float[vals.length * 2];
            int cnt=0;
            float add=e.getSum();
            for (int k=0; k < transformed.length; k+=2) {
              add-=vals[cnt];
              transformed[k + 1]=(vals[cnt] + add) * mPhaseY;
              cnt++;
            }
            transformPointArray(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              drawValue(mFormatValue.format(vals[k / 2]),valuePoints[j],transformed[k + 1] + offset);
            }
          }
        }
      }
    }
  }
  Log.i(LOG_TAG,""String_Node_Str"" + (System.currentTimeMillis() - starttime) + ""String_Node_Str"");
}","@Override protected void drawValues(){
  long starttime=System.currentTimeMillis();
  if (mDrawYValues && mCurrentData.getYValCount() < mMaxVisibleCount * mScaleX) {
    ArrayList<BarDataSet> dataSets=(ArrayList<BarDataSet>)mCurrentData.getDataSets();
    float offset=0f;
    if (mDrawValueAboveBar)     offset=-Utils.convertDpToPixel(5);
 else     offset=Utils.calcTextHeight(mValuePaint,""String_Node_Str"") * 1.5f;
    for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
      BarDataSet dataSet=dataSets.get(i);
      ArrayList<Entry> entries=dataSet.getYVals();
      float[] valuePoints=generateTransformedValues(entries,0.5f);
      if (!mDrawValuesForWholeStack) {
        for (int j=0; j < valuePoints.length * mPhaseX; j+=2) {
          if (isOffContentRight(valuePoints[j]))           break;
          if (isOffContentLeft(valuePoints[j]) || isOffContentTop(valuePoints[j + 1]) || isOffContentBottom(valuePoints[j + 1]))           continue;
          float val=entries.get(j / 2).getSum();
          drawValue(mFormatValue.format(val),valuePoints[j],valuePoints[j + 1] + offset);
        }
      }
 else {
        for (int j=0; j < (valuePoints.length - 1) * mPhaseX; j+=2) {
          if (isOffContentRight(valuePoints[j]))           break;
          if (isOffContentLeft(valuePoints[j]) || isOffContentTop(valuePoints[j + 1]) || isOffContentBottom(valuePoints[j + 1]))           continue;
          Entry e=entries.get(j / 2);
          float[] vals=e.getVals();
          if (vals == null) {
            drawValue(mFormatValue.format(e.getVal()),valuePoints[j],valuePoints[j + 1] + offset);
          }
 else {
            float[] transformed=new float[vals.length * 2];
            int cnt=0;
            float add=e.getSum();
            for (int k=0; k < transformed.length; k+=2) {
              add-=vals[cnt];
              transformed[k + 1]=(vals[cnt] + add) * mPhaseY;
              cnt++;
            }
            transformPointArray(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              drawValue(mFormatValue.format(vals[k / 2]),valuePoints[j],transformed[k + 1] + offset);
            }
          }
        }
      }
    }
  }
  Log.i(LOG_TAG,""String_Node_Str"" + (System.currentTimeMillis() - starttime) + ""String_Node_Str"");
}",0.9633484162895928
27004,"@Override protected void calculateOffsets(){
  if (mLegend == null)   return;
  Log.i(LOG_TAG,""String_Node_Str"");
  if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART) {
    float spacing=Utils.convertDpToPixel(7f);
    mLegend.setOffsetRight(mLegend.getMaximumEntryLength(mLegendLabelPaint) + mLegend.getFormSize() + mLegend.getFormToTextSpace()+ spacing);
    mLegendLabelPaint.setTextAlign(Align.LEFT);
  }
 else   if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
    if (mXLabels.getPosition() == XLabelPosition.TOP)     mLegend.setOffsetBottom(mLegendLabelPaint.getTextSize() * 3.5f);
 else {
      mLegend.setOffsetBottom(mLegendLabelPaint.getTextSize() * 2.5f);
    }
  }
  float yleft=0f, yright=0f;
  float xtop=0f, xbottom=0f;
  if (mYLabels.getPosition() == YLabelPosition.LEFT) {
    if (mYChartMin >= 0)     yleft=Utils.calcTextWidth(mYLabelPaint,(int)mDeltaY + ""String_Node_Str"" + mUnit);
 else     yleft=Utils.calcTextWidth(mYLabelPaint,(int)(mDeltaY * -1) + ""String_Node_Str"" + mUnit);
    mYLabelPaint.setTextAlign(Align.RIGHT);
  }
 else   if (mYLabels.getPosition() == YLabelPosition.RIGHT) {
    if (mYChartMin >= 0)     yright=Utils.calcTextWidth(mYLabelPaint,(int)mDeltaY + ""String_Node_Str"" + mUnit);
 else     yright=Utils.calcTextWidth(mYLabelPaint,(int)(mDeltaY * -1) + ""String_Node_Str"" + mUnit);
    mYLabelPaint.setTextAlign(Align.LEFT);
  }
 else   if (mYLabels.getPosition() == YLabelPosition.BOTH_SIDED) {
    float width=0f;
    if (mYChartMin >= 0)     width=Utils.calcTextWidth(mYLabelPaint,(int)mDeltaY + ""String_Node_Str"" + mUnit);
 else     width=Utils.calcTextWidth(mYLabelPaint,(int)(mDeltaY * -1) + ""String_Node_Str"" + mUnit);
    yright=width;
    yleft=width;
  }
  if (mXLabels.getPosition() == XLabelPosition.BOTTOM) {
    xbottom=Utils.calcTextHeight(mXLabelPaint,""String_Node_Str"") * 2f;
  }
 else   if (mXLabels.getPosition() == XLabelPosition.TOP) {
    xtop=Utils.calcTextHeight(mXLabelPaint,""String_Node_Str"") * 2f;
  }
 else   if (mXLabels.getPosition() == XLabelPosition.BOTH_SIDED) {
    float height=Utils.calcTextHeight(mXLabelPaint,""String_Node_Str"") * 2f;
    xbottom=height;
    xtop=height;
  }
  if (mDrawLegend) {
    if (mDrawXLabels) {
      mOffsetBottom=Math.max(mOffsetBottom,xbottom + mLegend.getOffsetBottom());
      mOffsetTop=Math.max(mOffsetTop,xtop + mLegend.getOffsetTop());
    }
 else {
      mOffsetBottom=Math.max(mOffsetBottom,mLegend.getOffsetBottom());
      mOffsetTop=Math.max(mOffsetTop,mLegend.getOffsetTop());
    }
    if (mDrawYLabels) {
      mOffsetLeft=Math.max(mOffsetLeft,yleft + mLegend.getOffsetLeft());
      mOffsetRight=Math.max(mOffsetRight,yright + mLegend.getOffsetRight());
    }
 else {
      mOffsetLeft=Math.max(mOffsetLeft,mLegend.getOffsetLeft());
      mOffsetRight=Math.max(mOffsetRight,mLegend.getOffsetRight());
    }
  }
 else {
    if (mDrawXLabels) {
      mOffsetBottom=Math.max(mOffsetBottom,xbottom);
      mOffsetTop=Math.max(mOffsetTop,xtop);
    }
    if (mDrawYLabels) {
      mOffsetLeft=Math.max(mOffsetLeft,yleft);
      mOffsetRight=Math.max(mOffsetRight,yright);
    }
  }
  mLegend.setOffsetTop(mOffsetTop);
  mLegend.setOffsetLeft(mOffsetLeft);
  prepareContentRect();
  float scaleX=(float)((getWidth() - mOffsetLeft - mOffsetRight) / mDeltaX);
  float scaleY=(float)((getHeight() - mOffsetBottom - mOffsetTop) / mDeltaY);
  Matrix val=new Matrix();
  val.postTranslate(0,-mYChartMin);
  val.postScale(scaleX,-scaleY);
  mMatrixValueToPx.set(val);
  Matrix offset=new Matrix();
  if (!mInvertYAxis)   offset.postTranslate(mOffsetLeft,getHeight() - mOffsetBottom);
 else {
    offset.setTranslate(mOffsetLeft,-getOffsetTop());
    offset.postScale(1.0f,-1.0f);
  }
  mMatrixOffset.set(offset);
}","@Override protected void calculateOffsets(){
  if (mLegend == null)   return;
  if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART) {
    float spacing=Utils.convertDpToPixel(7f);
    mLegend.setOffsetRight(mLegend.getMaximumEntryLength(mLegendLabelPaint) + mLegend.getFormSize() + mLegend.getFormToTextSpace()+ spacing);
    mLegendLabelPaint.setTextAlign(Align.LEFT);
  }
 else   if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
    if (mXLabels.getPosition() == XLabelPosition.TOP)     mLegend.setOffsetBottom(mLegendLabelPaint.getTextSize() * 3.5f);
 else {
      mLegend.setOffsetBottom(mLegendLabelPaint.getTextSize() * 2.5f);
    }
  }
  float yleft=0f, yright=0f;
  float xtop=0f, xbottom=0f;
  if (mYLabels.getPosition() == YLabelPosition.LEFT) {
    if (mYChartMin >= 0)     yleft=Utils.calcTextWidth(mYLabelPaint,(int)mDeltaY + ""String_Node_Str"" + mUnit);
 else     yleft=Utils.calcTextWidth(mYLabelPaint,(int)(mDeltaY * -1) + ""String_Node_Str"" + mUnit);
    mYLabelPaint.setTextAlign(Align.RIGHT);
  }
 else   if (mYLabels.getPosition() == YLabelPosition.RIGHT) {
    if (mYChartMin >= 0)     yright=Utils.calcTextWidth(mYLabelPaint,(int)mDeltaY + ""String_Node_Str"" + mUnit);
 else     yright=Utils.calcTextWidth(mYLabelPaint,(int)(mDeltaY * -1) + ""String_Node_Str"" + mUnit);
    mYLabelPaint.setTextAlign(Align.LEFT);
  }
 else   if (mYLabels.getPosition() == YLabelPosition.BOTH_SIDED) {
    float width=0f;
    if (mYChartMin >= 0)     width=Utils.calcTextWidth(mYLabelPaint,(int)mDeltaY + ""String_Node_Str"" + mUnit);
 else     width=Utils.calcTextWidth(mYLabelPaint,(int)(mDeltaY * -1) + ""String_Node_Str"" + mUnit);
    yright=width;
    yleft=width;
  }
  if (mXLabels.getPosition() == XLabelPosition.BOTTOM) {
    xbottom=Utils.calcTextHeight(mXLabelPaint,""String_Node_Str"") * 2f;
  }
 else   if (mXLabels.getPosition() == XLabelPosition.TOP) {
    xtop=Utils.calcTextHeight(mXLabelPaint,""String_Node_Str"") * 2f;
  }
 else   if (mXLabels.getPosition() == XLabelPosition.BOTH_SIDED) {
    float height=Utils.calcTextHeight(mXLabelPaint,""String_Node_Str"") * 2f;
    xbottom=height;
    xtop=height;
  }
  if (mDrawLegend) {
    if (mDrawXLabels) {
      mOffsetBottom=Math.max(mOffsetBottom,xbottom + mLegend.getOffsetBottom());
      mOffsetTop=Math.max(mOffsetTop,xtop + mLegend.getOffsetTop());
    }
 else {
      mOffsetBottom=Math.max(mOffsetBottom,mLegend.getOffsetBottom());
      mOffsetTop=Math.max(mOffsetTop,mLegend.getOffsetTop());
    }
    if (mDrawYLabels) {
      mOffsetLeft=Math.max(mOffsetLeft,yleft + mLegend.getOffsetLeft());
      mOffsetRight=Math.max(mOffsetRight,yright + mLegend.getOffsetRight());
    }
 else {
      mOffsetLeft=Math.max(mOffsetLeft,mLegend.getOffsetLeft());
      mOffsetRight=Math.max(mOffsetRight,mLegend.getOffsetRight());
    }
  }
 else {
    if (mDrawXLabels) {
      mOffsetBottom=Math.max(mOffsetBottom,xbottom);
      mOffsetTop=Math.max(mOffsetTop,xtop);
    }
    if (mDrawYLabels) {
      mOffsetLeft=Math.max(mOffsetLeft,yleft);
      mOffsetRight=Math.max(mOffsetRight,yright);
    }
  }
  mLegend.setOffsetTop(mOffsetTop);
  mLegend.setOffsetLeft(mOffsetLeft);
  prepareContentRect();
  float scaleX=(float)((getWidth() - mOffsetLeft - mOffsetRight) / mDeltaX);
  float scaleY=(float)((getHeight() - mOffsetBottom - mOffsetTop) / mDeltaY);
  Matrix val=new Matrix();
  val.postTranslate(0,-mYChartMin);
  val.postScale(scaleX,-scaleY);
  mMatrixValueToPx.set(val);
  Matrix offset=new Matrix();
  if (!mInvertYAxis)   offset.postTranslate(mOffsetLeft,getHeight() - mOffsetBottom);
 else {
    offset.setTranslate(mOffsetLeft,-getOffsetTop());
    offset.postScale(1.0f,-1.0f);
  }
  mMatrixOffset.set(offset);
}",0.9953271028037384
27005,"/** 
 * Sets a new ChartData object for the chart.
 * @param data
 */
public void setData(ChartData data){
  if (data == null || !data.isValid()) {
    Log.e(LOG_TAG,""String_Node_Str"");
    mDataNotSet=true;
    return;
  }
  mDataNotSet=false;
  mOffsetsCalculated=false;
  mCurrentData=data;
  mOriginalData=data;
  prepare();
  Log.i(LOG_TAG,""String_Node_Str"");
}","/** 
 * Sets a new ChartData object for the chart.
 * @param data
 */
protected void setData(ChartData data){
  if (data == null || !data.isValid()) {
    Log.e(LOG_TAG,""String_Node_Str"");
    mDataNotSet=true;
    return;
  }
  mDataNotSet=false;
  mOffsetsCalculated=false;
  mCurrentData=data;
  mOriginalData=data;
  prepare();
  Log.i(LOG_TAG,""String_Node_Str"");
}",0.9850340136054422
27006,"@Override public Fragment getItem(int pos){
  Fragment f=null;
switch (pos) {
case 0:
    f=LineChartFrag.newInstance();
  break;
case 1:
f=BarChartFrag.newInstance();
break;
case 2:
f=ScatterChartFrag.newInstance();
break;
case 3:
f=PieChartFrag.newInstance();
break;
}
return f;
}","@Override public Fragment getItem(int pos){
  Fragment f=null;
switch (pos) {
case 0:
    f=SineCosineFragment.newInstance();
  break;
case 1:
f=ComplexityFragment.newInstance();
break;
case 2:
f=BarChartFrag.newInstance();
break;
case 3:
f=ScatterChartFrag.newInstance();
break;
case 4:
f=PieChartFrag.newInstance();
break;
}
return f;
}",0.6451612903225806
27007,"@Override public int getCount(){
  return 4;
}","@Override public int getCount(){
  return 5;
}",0.9782608695652174
27008,"/** 
 * draws the given y values to the screen
 */
@Override protected void drawData(){
  ArrayList<LineDataSet> dataSets=(ArrayList<LineDataSet>)mCurrentData.getDataSets();
  mRenderPaint.setStyle(Paint.Style.STROKE);
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    ArrayList<Entry> entries=dataSet.getYVals();
    float[] valuePoints=generateTransformedValues(entries,0f);
    mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
    mRenderPaint.setPathEffect(dataSet.getDashPathEffect());
    if (mDrawCubic) {
      mRenderPaint.setColor(dataSet.getColor(i));
      Path spline=new Path();
      spline.moveTo(entries.get(0).getXIndex(),entries.get(0).getVal());
      for (int x=1; x < entries.size() - 3; x+=2) {
        spline.cubicTo(entries.get(x).getXIndex(),entries.get(x).getVal(),entries.get(x + 1).getXIndex(),entries.get(x + 1).getVal(),entries.get(x + 2).getXIndex(),entries.get(x + 2).getVal());
      }
      transformPath(spline);
      mDrawCanvas.drawPath(spline,mRenderPaint);
    }
 else {
      for (int j=0; j < (valuePoints.length - 2) * mPhaseX; j+=2) {
        mRenderPaint.setColor(dataSet.getColor(j));
        if (isOffContentRight(valuePoints[j]))         break;
        if (j != 0 && isOffContentLeft(valuePoints[j - 1]) && isOffContentTop(valuePoints[j + 1]) && isOffContentBottom(valuePoints[j + 1]))         continue;
        mDrawCanvas.drawLine(valuePoints[j],valuePoints[j + 1],valuePoints[j + 2],valuePoints[j + 3],mRenderPaint);
      }
    }
    mRenderPaint.setPathEffect(null);
    if (dataSet.isDrawFilledEnabled() && entries.size() > 0) {
      mRenderPaint.setStyle(Paint.Style.FILL);
      mRenderPaint.setAlpha(85);
      Path filled=generateFilledPath(entries);
      transformPath(filled);
      mDrawCanvas.drawPath(filled,mRenderPaint);
      mRenderPaint.setAlpha(255);
    }
  }
}","/** 
 * draws the given y values to the screen
 */
@Override protected void drawData(){
  ArrayList<LineDataSet> dataSets=(ArrayList<LineDataSet>)mCurrentData.getDataSets();
  mRenderPaint.setStyle(Paint.Style.STROKE);
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    ArrayList<Entry> entries=dataSet.getYVals();
    float[] valuePoints=generateTransformedValues(entries,0f);
    mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
    mRenderPaint.setPathEffect(dataSet.getDashPathEffect());
    if (mDrawCubic) {
      mRenderPaint.setColor(dataSet.getColor(i));
      Path spline=new Path();
      spline.moveTo(entries.get(0).getXIndex(),entries.get(0).getVal());
      for (int x=1; x < entries.size() - 3; x+=2) {
        spline.cubicTo(entries.get(x).getXIndex(),entries.get(x).getVal(),entries.get(x + 1).getXIndex(),entries.get(x + 1).getVal(),entries.get(x + 2).getXIndex(),entries.get(x + 2).getVal());
      }
      transformPath(spline);
      mDrawCanvas.drawPath(spline,mRenderPaint);
    }
 else {
      for (int j=0; j < (valuePoints.length - 2) * mPhaseX; j+=2) {
        mRenderPaint.setColor(dataSet.getColor(j / 2));
        if (isOffContentRight(valuePoints[j]))         break;
        if (j != 0 && isOffContentLeft(valuePoints[j - 1]) && isOffContentTop(valuePoints[j + 1]) && isOffContentBottom(valuePoints[j + 1]))         continue;
        mDrawCanvas.drawLine(valuePoints[j],valuePoints[j + 1],valuePoints[j + 2],valuePoints[j + 3],mRenderPaint);
      }
    }
    mRenderPaint.setPathEffect(null);
    if (dataSet.isDrawFilledEnabled() && entries.size() > 0) {
      mRenderPaint.setStyle(Paint.Style.FILL);
      mRenderPaint.setAlpha(85);
      Path filled=generateFilledPath(entries);
      transformPath(filled);
      mDrawCanvas.drawPath(filled,mRenderPaint);
      mRenderPaint.setAlpha(255);
    }
  }
}",0.9989440337909188
27009,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setDrawYValues(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setValueDigits(2);
  mChart.set3DEnabled(false);
  mChart.setPinchZoom(false);
  mChart.setDrawBarShadow(true);
  mChart.setUnit(""String_Node_Str"");
  YLabels yLabels=mChart.getYLabels();
  yLabels.setPosition(YLabelPosition.BOTH_SIDED);
  XLabels xLabels=mChart.getXLabels();
  xLabels.setPosition(XLabelPosition.TOP);
  mChart.setDrawGridBackground(false);
  mChart.setDrawHorizontalGrid(true);
  mChart.setDrawVerticalGrid(false);
  mChart.setValueTextSize(10f);
  mChart.setDrawBorder(false);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XLabels xl=mChart.getXLabels();
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setCenterXLabelText(true);
  xl.setTypeface(tf);
  YLabels yl=mChart.getYLabels();
  yl.setTypeface(tf);
  yl.setLabelCount(8);
  mChart.setValueTypeface(tf);
  mSeekBarX.setProgress(12);
  mSeekBarY.setProgress(50);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setFormSize(8f);
  l.setXEntrySpace(4f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setDrawYValues(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setValueDigits(2);
  mChart.set3DEnabled(false);
  mChart.setPinchZoom(false);
  mChart.setUnit(""String_Node_Str"");
  YLabels yLabels=mChart.getYLabels();
  yLabels.setPosition(YLabelPosition.BOTH_SIDED);
  XLabels xLabels=mChart.getXLabels();
  xLabels.setPosition(XLabelPosition.TOP);
  mChart.setDrawGridBackground(false);
  mChart.setDrawHorizontalGrid(true);
  mChart.setDrawVerticalGrid(false);
  mChart.setValueTextSize(10f);
  mChart.setDrawBorder(false);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XLabels xl=mChart.getXLabels();
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setCenterXLabelText(true);
  xl.setTypeface(tf);
  YLabels yl=mChart.getYLabels();
  yl.setTypeface(tf);
  yl.setLabelCount(8);
  mChart.setValueTypeface(tf);
  mSeekBarX.setProgress(12);
  mSeekBarY.setProgress(50);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setFormSize(8f);
  l.setXEntrySpace(4f);
}",0.9901697944593388
27010,"@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
  tvX.setText(""String_Node_Str"" + (mSeekBarX.getProgress() + 1));
  tvY.setText(""String_Node_Str"" + (mSeekBarY.getProgress()));
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < mSeekBarX.getProgress() + 1; i++) {
    xVals.add(mMonths[i % 12]);
  }
  ArrayList<Entry> yVals1=new ArrayList<Entry>();
  for (int i=0; i < mSeekBarX.getProgress() + 1; i++) {
    float mult=(mSeekBarY.getProgress() + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals1.add(new Entry(val,i));
  }
  BarDataSet set1=new BarDataSet(yVals1,""String_Node_Str"");
  set1.setBarSpacePercent(35f);
  ArrayList<BarDataSet> dataSets=new ArrayList<BarDataSet>();
  dataSets.add(set1);
  BarData data=new BarData(xVals,dataSets);
  mChart.setData(data);
  mChart.invalidate();
}","@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
  tvX.setText(""String_Node_Str"" + (mSeekBarX.getProgress() + 1));
  tvY.setText(""String_Node_Str"" + (mSeekBarY.getProgress()));
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < mSeekBarX.getProgress() + 1; i++) {
    xVals.add(mMonths[i % 12]);
  }
  ArrayList<Entry> yVals1=new ArrayList<Entry>();
  for (int i=0; i < mSeekBarX.getProgress() + 1; i++) {
    float mult=(mSeekBarY.getProgress() + 1);
    float val=(float)(Math.random() * mult) - 50;
    yVals1.add(new Entry(val,i));
  }
  BarDataSet set1=new BarDataSet(yVals1,""String_Node_Str"");
  set1.setBarSpacePercent(35f);
  ArrayList<BarDataSet> dataSets=new ArrayList<BarDataSet>();
  dataSets.add(set1);
  BarData data=new BarData(xVals,dataSets);
  mChart.setData(data);
  mChart.invalidate();
}",0.9959607616849394
27011,"@Override protected void calcMinMax(boolean fixedValues){
  super.calcMinMax(fixedValues);
  if (!mStartAtZero && getYMin() >= 0f) {
    mYChartMin=getYMin();
    mDeltaY=Math.abs(mYChartMax - mYChartMin);
  }
  mDeltaX++;
}","@Override protected void calcMinMax(boolean fixedValues){
  super.calcMinMax(fixedValues);
  mDeltaX++;
}",0.6382978723404256
27012,"@Override protected void drawHighlights(){
  if (mHighlightEnabled && mHighLightIndicatorEnabled && valuesToHighlight()) {
    float offsetY=mDeltaY * 0.04f;
    for (int i=0; i < mIndicesToHightlight.length; i++) {
      Highlight h=mIndicesToHightlight[i];
      int index=h.getXIndex();
      int dataSetIndex=h.getDataSetIndex();
      BarDataSet ds=(BarDataSet)mCurrentData.getDataSetByIndex(dataSetIndex);
      if (index < mCurrentData.getYValCount() && index >= 0 && index < mDeltaX * mPhaseX) {
        mHighlightPaint.setAlpha(120);
        Entry e=getEntryByDataSetIndex(index,dataSetIndex);
        float y=e.getSum() * mPhaseY;
        float top=y >= 0 ? y : 0;
        float bottom=y <= 0 ? y : 0;
        float left=index + ds.getBarSpace() / 2f;
        float right=index + 1f - ds.getBarSpace() / 2f;
        RectF highlight=new RectF(left,top,right,bottom);
        transformRect(highlight);
        mDrawCanvas.drawRect(highlight,mHighlightPaint);
        if (mDrawHighlightArrow) {
          mHighlightPaint.setAlpha(200);
          Path arrow=new Path();
          arrow.moveTo(index + 0.5f,y + offsetY * 0.3f);
          arrow.lineTo(index + 0.2f,y + offsetY);
          arrow.lineTo(index + 0.8f,y + offsetY);
          transformPath(arrow);
          mDrawCanvas.drawPath(arrow,mHighlightPaint);
        }
      }
    }
  }
}","@Override protected void drawHighlights(){
  if (mHighlightEnabled && mHighLightIndicatorEnabled && valuesToHighlight()) {
    for (int i=0; i < mIndicesToHightlight.length; i++) {
      Highlight h=mIndicesToHightlight[i];
      int index=h.getXIndex();
      int dataSetIndex=h.getDataSetIndex();
      BarDataSet ds=(BarDataSet)mCurrentData.getDataSetByIndex(dataSetIndex);
      if (index < mCurrentData.getYValCount() && index >= 0 && index < mDeltaX * mPhaseX) {
        mHighlightPaint.setAlpha(120);
        Entry e=getEntryByDataSetIndex(index,dataSetIndex);
        prepareBar(e.getXIndex(),e.getSum(),ds.getBarSpace());
        mDrawCanvas.drawRect(mBarRect,mHighlightPaint);
      }
    }
  }
}",0.6452554744525547
27013,"/** 
 * Prepares a bar for drawing on the specified x-index and y-position. Also prepares the shadow-bar if enabled.
 * @param x the x-position
 * @param y the y-position
 * @param space the space between bars
 */
private void prepareBar(float x,float y,float space){
  float left=x + space / 2f;
  float right=x + 1f - space / 2f;
  float top=(y >= 0 ? y : 0) * mPhaseY;
  float bottom=(y <= 0 ? y : 0) * mPhaseY;
  mBarRect.set(left,top,right,bottom);
  transformRect(mBarRect);
  if (mDrawBarShadow) {
    mBarShadow.set(mBarRect.left,mOffsetTop,mBarRect.right,getHeight() - mOffsetBottom);
  }
}","/** 
 * Prepares a bar for drawing on the specified x-index and y-position. Also prepares the shadow-bar if enabled.
 * @param x the x-position
 * @param y the y-position
 * @param space the space between bars
 */
private void prepareBar(float x,float y,float space){
  float spaceHalf=space / 2f;
  float left=x + spaceHalf;
  float right=x + 1f - spaceHalf;
  float top=y >= 0 ? y : 0;
  float bottom=y <= 0 ? y : 0;
  mBarRect.set(left,top,right,bottom);
  transformRectWithPhase(mBarRect);
  if (mDrawBarShadow) {
    mBarShadow.set(mBarRect.left,mOffsetTop,mBarRect.right,getHeight() - mOffsetBottom);
  }
}",0.8538398018166804
27014,"/** 
 * draws the y-labels on the specified x-position
 * @param xPos
 * @param positions
 */
private void drawYLabels(float xPos,float[] positions){
  for (int i=0; i < mYLabels.mEntryCount; i++) {
    String text=Utils.formatNumber(mYLabels.mEntries[i],mYLabels.mDecimals,mSeparateTousands);
    if (!mYLabels.isDrawTopYLabelEntryEnabled() && i >= mYLabels.mEntryCount - 1)     return;
    if (mYLabels.isDrawUnitsInYLabelEnabled()) {
      mDrawCanvas.drawText(text + mUnit,xPos,positions[i * 2 + 1],mYLabelPaint);
    }
 else {
      mDrawCanvas.drawText(text,xPos,positions[i * 2 + 1],mYLabelPaint);
    }
  }
}","/** 
 * draws the y-labels on the specified x-position
 * @param xPos
 * @param positions
 */
private void drawYLabels(float xPos,float[] positions,float yOffset){
  for (int i=0; i < mYLabels.mEntryCount; i++) {
    String text=Utils.formatNumber(mYLabels.mEntries[i],mYLabels.mDecimals,mSeparateTousands);
    if (!mYLabels.isDrawTopYLabelEntryEnabled() && i >= mYLabels.mEntryCount - 1)     return;
    if (mYLabels.isDrawUnitsInYLabelEnabled()) {
      mDrawCanvas.drawText(text + mUnit,xPos,positions[i * 2 + 1] + yOffset,mYLabelPaint);
    }
 else {
      mDrawCanvas.drawText(text,xPos,positions[i * 2 + 1] + yOffset,mYLabelPaint);
    }
  }
}",0.9731437598736176
27015,"@Override protected void calcMinMax(boolean fixedValues){
  super.calcMinMax(fixedValues);
  float space=mDeltaY / 100f * 15f;
  if (mStartAtZero) {
    mYChartMin=0;
  }
 else {
    mYChartMin=mYChartMin - space;
  }
  mYChartMax=mYChartMax + space;
  mDeltaY=Math.abs(mYChartMax - mYChartMin);
}","@Override protected void calcMinMax(boolean fixedValues){
  super.calcMinMax(fixedValues);
  float space=Math.abs(mDeltaY / 100f * 15f);
  if (mStartAtZero) {
    if (mYChartMax < 0) {
      mYChartMax=0;
      mYChartMin=mYChartMin - space;
    }
 else {
      mYChartMin=0;
      mYChartMax=mYChartMax + space;
    }
  }
 else {
    mYChartMin=mYChartMin - space / 2f;
    mYChartMax=mYChartMax + space / 2f;
  }
  mDeltaY=Math.abs(mYChartMax - mYChartMin);
}",0.662269129287599
27016,"private Path generateFilledPath(ArrayList<Entry> entries){
  Path filled=new Path();
  filled.moveTo(entries.get(0).getXIndex(),entries.get(0).getVal() * mPhaseY);
  for (int x=1; x < entries.size() * mPhaseX; x++) {
    Entry e=entries.get(x);
    filled.lineTo(e.getXIndex(),e.getVal() * mPhaseY);
  }
  filled.lineTo(entries.get((int)((entries.size() - 1) * mPhaseX)).getXIndex(),mYChartMin);
  filled.lineTo(entries.get(0).getXIndex(),mYChartMin);
  filled.close();
  return filled;
}","/** 
 * Generates the path that is used for filled drawing.
 * @param entries
 * @return
 */
private Path generateFilledPath(ArrayList<Entry> entries){
  Path filled=new Path();
  filled.moveTo(entries.get(0).getXIndex(),entries.get(0).getVal() * mPhaseY);
  for (int x=1; x < entries.size() * mPhaseX; x++) {
    Entry e=entries.get(x);
    filled.lineTo(e.getXIndex(),e.getVal() * mPhaseY);
  }
  filled.lineTo(entries.get((int)((entries.size() - 1) * mPhaseX)).getXIndex(),mYChartMin);
  filled.lineTo(entries.get(0).getXIndex(),mYChartMin);
  filled.close();
  return filled;
}",0.9130028063610852
27017,"@Override protected void drawValues(){
  if (mDrawYValues && mCurrentData.getYValCount() < mMaxVisibleCount * mScaleX) {
    ArrayList<ScatterDataSet> dataSets=(ArrayList<ScatterDataSet>)mCurrentData.getDataSets();
    for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
      ScatterDataSet dataSet=dataSets.get(i);
      ArrayList<Entry> entries=dataSet.getYVals();
      float[] positions=generateTransformedValues(entries,0f);
      float shapeSize=dataSet.getScatterShapeSize();
      for (int j=0; j < positions.length; j+=2) {
        if (isOffContentRight(positions[j]))         break;
        if (isOffContentLeft(positions[j]) || isOffContentTop(positions[j + 1]) || isOffContentBottom(positions[j + 1]))         continue;
        float val=entries.get(j / 2).getVal();
        if (mDrawUnitInChart) {
          mDrawCanvas.drawText(mFormatValue.format(val) + mUnit,positions[j],positions[j + 1] - shapeSize,mValuePaint);
        }
 else {
          mDrawCanvas.drawText(mFormatValue.format(val),positions[j],positions[j + 1] - shapeSize,mValuePaint);
        }
      }
    }
  }
}","@Override protected void drawValues(){
  if (mDrawYValues && mCurrentData.getYValCount() < mMaxVisibleCount * mScaleX) {
    ArrayList<ScatterDataSet> dataSets=(ArrayList<ScatterDataSet>)mCurrentData.getDataSets();
    for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
      ScatterDataSet dataSet=dataSets.get(i);
      ArrayList<Entry> entries=dataSet.getYVals();
      float[] positions=generateTransformedValues(entries,0f);
      float shapeSize=dataSet.getScatterShapeSize();
      for (int j=0; j < positions.length * mPhaseX; j+=2) {
        if (isOffContentRight(positions[j]))         break;
        if (isOffContentLeft(positions[j]) || isOffContentTop(positions[j + 1]) || isOffContentBottom(positions[j + 1]))         continue;
        float val=entries.get(j / 2).getVal();
        if (mDrawUnitInChart) {
          mDrawCanvas.drawText(mFormatValue.format(val) + mUnit,positions[j],positions[j + 1] - shapeSize,mValuePaint);
        }
 else {
          mDrawCanvas.drawText(mFormatValue.format(val),positions[j],positions[j + 1] - shapeSize,mValuePaint);
        }
      }
    }
  }
}",0.9954586739327884
27018,"/** 
 * returns the Highlight object (contains x-index and DataSet index) of the selected value at the given touch point.
 * @param x
 * @param y
 * @return
 */
public Highlight getHighlightByTouchPoint(float x,float y){
  float[] pts=new float[2];
  pts[0]=x;
  pts[1]=y;
  Matrix tmp=new Matrix();
  mMatrixOffset.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixTouch.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixValueToPx.invert(tmp);
  tmp.mapPoints(pts);
  double xTouchVal=pts[0];
  double yTouchVal=pts[1];
  double base=Math.floor(xTouchVal);
  Log.i(LOG_TAG,""String_Node_Str"" + xTouchVal + ""String_Node_Str""+ yTouchVal);
  if ((this instanceof LineChart || this instanceof ScatterChart) && (xTouchVal < 0 || xTouchVal > mDeltaX))   return null;
  if (this instanceof BarChart && (xTouchVal < 0 || xTouchVal > mDeltaX + 1))   return null;
  int xIndex=(int)base;
  int dataSetIndex=0;
  if (this instanceof LineChart || this instanceof ScatterChart) {
    if (xTouchVal - base > 0.5) {
      xIndex=(int)base + 1;
    }
  }
  ArrayList<SelInfo> valsAtIndex=getYValsAtIndex(xIndex);
  dataSetIndex=getClosestDataSetIndex(valsAtIndex,(float)yTouchVal);
  if (dataSetIndex == -1)   return null;
  return new Highlight(xIndex,(float)yTouchVal,dataSetIndex);
}","/** 
 * returns the Highlight object (contains x-index and DataSet index) of the selected value at the given touch point.
 * @param x
 * @param y
 * @return
 */
public Highlight getHighlightByTouchPoint(float x,float y){
  float[] pts=new float[2];
  pts[0]=x;
  pts[1]=y;
  Matrix tmp=new Matrix();
  mMatrixOffset.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixTouch.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixValueToPx.invert(tmp);
  tmp.mapPoints(pts);
  double xTouchVal=pts[0];
  double yTouchVal=pts[1];
  double base=Math.floor(xTouchVal);
  double touchOffset=mDeltaX * 0.025;
  Log.i(LOG_TAG,""String_Node_Str"" + xTouchVal + ""String_Node_Str""+ yTouchVal+ ""String_Node_Str""+ touchOffset);
  if ((this instanceof LineChart || this instanceof ScatterChart) && (xTouchVal < -touchOffset || xTouchVal > mDeltaX + touchOffset))   return null;
  if (this instanceof BarChart && (xTouchVal < 0 || xTouchVal > mDeltaX))   return null;
  if (base < 0)   base=0;
  if (base >= mDeltaX)   base=mDeltaX - 1;
  int xIndex=(int)base;
  int dataSetIndex=0;
  if (this instanceof LineChart || this instanceof ScatterChart) {
    if (xTouchVal - base > 0.5) {
      xIndex=(int)base + 1;
    }
  }
  ArrayList<SelInfo> valsAtIndex=getYValsAtIndex(xIndex);
  dataSetIndex=getClosestDataSetIndex(valsAtIndex,(float)yTouchVal);
  if (dataSetIndex == -1)   return null;
  return new Highlight(xIndex,(float)yTouchVal,dataSetIndex);
}",0.9260089686098656
27019,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_piechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(PieChart)findViewById(R.id.chart1);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  mChart.setValueTypeface(tf);
  mChart.setCenterTextTypeface(Typeface.createFromAsset(getAssets(),""String_Node_Str""));
  mChart.setHoleRadius(60f);
  mChart.setDrawYValues(true);
  mChart.setDrawCenterText(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawHoleEnabled(true);
  mChart.setDrawXValues(true);
  mChart.setTouchEnabled(true);
  mChart.setUsePercentValues(true);
  mChart.setOnChartValueSelectedListener(this);
  mSeekBarX.setProgress(4);
  mSeekBarY.setProgress(100);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setYEntrySpace(3f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_piechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(PieChart)findViewById(R.id.chart1);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  mChart.setValueTypeface(tf);
  mChart.setCenterTextTypeface(Typeface.createFromAsset(getAssets(),""String_Node_Str""));
  mChart.setHoleRadius(60f);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawYValues(true);
  mChart.setDrawCenterText(true);
  mChart.setDrawHoleEnabled(true);
  mChart.setDrawXValues(true);
  mChart.setTouchEnabled(true);
  mChart.setUsePercentValues(true);
  mChart.setOnChartValueSelectedListener(this);
  mSeekBarX.setProgress(4);
  mSeekBarY.setProgress(100);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  l.setXEntrySpace(7f);
  l.setYEntrySpace(5f);
}",0.9494869771112864
27020,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_scatterchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(ScatterChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setTouchEnabled(true);
  mChart.setHighlightEnabled(true);
  mChart.setDrawYValues(false);
  mChart.setDragEnabled(true);
  mChart.setMaxVisibleValueCount(200);
  mChart.setPinchZoom(true);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_scatterchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(ScatterChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setTouchEnabled(true);
  mChart.setHighlightEnabled(true);
  mChart.setDrawYValues(false);
  mChart.setDragEnabled(true);
  mChart.setMaxVisibleValueCount(200);
  mChart.setPinchZoom(true);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
}",0.957776590058792
27021,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawYValues(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setValueDigits(2);
  mChart.set3DEnabled(false);
  mChart.setPinchZoom(false);
  mChart.setDrawBarShadow(false);
  YLabels yLabels=mChart.getYLabels();
  yLabels.setPosition(YLabelPosition.BOTH_SIDED);
  yLabels.setLabelCount(5);
  XLabels xLabels=mChart.getXLabels();
  xLabels.setPosition(XLabelPosition.TOP);
  xLabels.setCenterXLabelText(true);
  mSeekBarX.setProgress(12);
  mSeekBarY.setProgress(100);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setFormSize(8f);
  l.setXEntrySpace(4f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawYValues(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setValueDigits(2);
  mChart.set3DEnabled(false);
  mChart.setPinchZoom(false);
  mChart.setDrawBarShadow(false);
  YLabels yLabels=mChart.getYLabels();
  yLabels.setPosition(YLabelPosition.BOTH_SIDED);
  yLabels.setLabelCount(5);
  XLabels xLabels=mChart.getXLabels();
  xLabels.setPosition(XLabelPosition.TOP);
  xLabels.setCenterXLabelText(true);
  mSeekBarX.setProgress(12);
  mSeekBarY.setProgress(100);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_RIGHT);
  l.setFormSize(8f);
  l.setFormToTextSpace(4f);
  l.setXEntrySpace(6f);
}",0.9857747020376778
27022,"@Override protected void calculateOffsets(){
  if (mLegend == null)   return;
  Log.i(LOG_TAG,""String_Node_Str"");
  if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART) {
    mLegend.setOffsetRight(mLegend.getMaximumEntryLength(mLegendLabelPaint));
    mLegendLabelPaint.setTextAlign(Align.LEFT);
  }
 else   if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT) {
    if (mXLabels.getPosition() == XLabelPosition.TOP)     mLegend.setOffsetBottom(mLegendLabelPaint.getTextSize() * 3.5f);
 else {
      mLegend.setOffsetBottom(mLegendLabelPaint.getTextSize() * 2.5f);
    }
  }
  float yleft=0f, yright=0f;
  float xtop=0f, xbottom=0f;
  if (mYLabels.getPosition() == YLabelPosition.LEFT) {
    if (mYChartMin >= 0)     yleft=Utils.calcTextWidth(mYLabelPaint,(int)mDeltaY + ""String_Node_Str"" + mUnit);
 else     yleft=Utils.calcTextWidth(mYLabelPaint,(int)(mDeltaY * -1) + ""String_Node_Str"" + mUnit);
    mYLabelPaint.setTextAlign(Align.RIGHT);
  }
 else   if (mYLabels.getPosition() == YLabelPosition.RIGHT) {
    if (mYChartMin >= 0)     yright=Utils.calcTextWidth(mYLabelPaint,(int)mDeltaY + ""String_Node_Str"" + mUnit);
 else     yright=Utils.calcTextWidth(mYLabelPaint,(int)(mDeltaY * -1) + ""String_Node_Str"" + mUnit);
    mYLabelPaint.setTextAlign(Align.LEFT);
  }
 else   if (mYLabels.getPosition() == YLabelPosition.BOTH_SIDED) {
    float width=0f;
    if (mYChartMin >= 0)     width=Utils.calcTextWidth(mYLabelPaint,(int)mDeltaY + ""String_Node_Str"" + mUnit);
 else     width=Utils.calcTextWidth(mYLabelPaint,(int)(mDeltaY * -1) + ""String_Node_Str"" + mUnit);
    yright=width;
    yleft=width;
  }
  if (mXLabels.getPosition() == XLabelPosition.BOTTOM) {
    xbottom=Utils.calcTextHeight(mXLabelPaint,""String_Node_Str"") * 2f;
  }
 else   if (mXLabels.getPosition() == XLabelPosition.TOP) {
    xtop=Utils.calcTextHeight(mXLabelPaint,""String_Node_Str"") * 2f;
  }
 else   if (mXLabels.getPosition() == XLabelPosition.BOTH_SIDED) {
    float height=Utils.calcTextHeight(mXLabelPaint,""String_Node_Str"") * 2f;
    xbottom=height;
    xtop=height;
  }
  if (mDrawLegend) {
    if (mDrawXLabels) {
      mOffsetBottom=Math.max(mOffsetBottom,xbottom + mLegend.getOffsetBottom());
      mOffsetTop=Math.max(mOffsetTop,xtop + mLegend.getOffsetTop());
    }
 else {
      mOffsetBottom=Math.max(mOffsetBottom,mLegend.getOffsetBottom());
      mOffsetTop=Math.max(mOffsetTop,mLegend.getOffsetTop());
    }
    if (mDrawYLabels) {
      mOffsetLeft=Math.max(mOffsetLeft,yleft + mLegend.getOffsetLeft());
      mOffsetRight=Math.max(mOffsetRight,yright + mLegend.getOffsetRight());
    }
 else {
      mOffsetLeft=Math.max(mOffsetLeft,mLegend.getOffsetLeft());
      mOffsetRight=Math.max(mOffsetRight,mLegend.getOffsetRight());
    }
  }
 else {
    if (mDrawXLabels) {
      mOffsetBottom=Math.max(mOffsetBottom,xbottom);
      mOffsetTop=Math.max(mOffsetTop,xtop);
    }
    if (mDrawYLabels) {
      mOffsetLeft=Math.max(mOffsetLeft,yleft);
      mOffsetRight=Math.max(mOffsetRight,yright);
    }
  }
  mLegend.setOffsetTop(mOffsetTop);
  mLegend.setOffsetLeft(mOffsetLeft);
  prepareContentRect();
  float scaleX=(float)((getWidth() - mOffsetLeft - mOffsetRight) / mDeltaX);
  float scaleY=(float)((getHeight() - mOffsetBottom - mOffsetTop) / mDeltaY);
  Matrix val=new Matrix();
  val.postTranslate(0,-mYChartMin);
  val.postScale(scaleX,-scaleY);
  mMatrixValueToPx.set(val);
  Matrix offset=new Matrix();
  offset.postTranslate(mOffsetLeft,getHeight() - mOffsetBottom);
  mMatrixOffset.set(offset);
}","@Override protected void calculateOffsets(){
  if (mLegend == null)   return;
  Log.i(LOG_TAG,""String_Node_Str"");
  if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART) {
    float spacing=Utils.convertDpToPixel(7f);
    mLegend.setOffsetRight(mLegend.getMaximumEntryLength(mLegendLabelPaint) + mLegend.getFormSize() + mLegend.getFormToTextSpace()+ spacing);
    mLegendLabelPaint.setTextAlign(Align.LEFT);
  }
 else   if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT) {
    if (mXLabels.getPosition() == XLabelPosition.TOP)     mLegend.setOffsetBottom(mLegendLabelPaint.getTextSize() * 3.5f);
 else {
      mLegend.setOffsetBottom(mLegendLabelPaint.getTextSize() * 2.5f);
    }
  }
  float yleft=0f, yright=0f;
  float xtop=0f, xbottom=0f;
  if (mYLabels.getPosition() == YLabelPosition.LEFT) {
    if (mYChartMin >= 0)     yleft=Utils.calcTextWidth(mYLabelPaint,(int)mDeltaY + ""String_Node_Str"" + mUnit);
 else     yleft=Utils.calcTextWidth(mYLabelPaint,(int)(mDeltaY * -1) + ""String_Node_Str"" + mUnit);
    mYLabelPaint.setTextAlign(Align.RIGHT);
  }
 else   if (mYLabels.getPosition() == YLabelPosition.RIGHT) {
    if (mYChartMin >= 0)     yright=Utils.calcTextWidth(mYLabelPaint,(int)mDeltaY + ""String_Node_Str"" + mUnit);
 else     yright=Utils.calcTextWidth(mYLabelPaint,(int)(mDeltaY * -1) + ""String_Node_Str"" + mUnit);
    mYLabelPaint.setTextAlign(Align.LEFT);
  }
 else   if (mYLabels.getPosition() == YLabelPosition.BOTH_SIDED) {
    float width=0f;
    if (mYChartMin >= 0)     width=Utils.calcTextWidth(mYLabelPaint,(int)mDeltaY + ""String_Node_Str"" + mUnit);
 else     width=Utils.calcTextWidth(mYLabelPaint,(int)(mDeltaY * -1) + ""String_Node_Str"" + mUnit);
    yright=width;
    yleft=width;
  }
  if (mXLabels.getPosition() == XLabelPosition.BOTTOM) {
    xbottom=Utils.calcTextHeight(mXLabelPaint,""String_Node_Str"") * 2f;
  }
 else   if (mXLabels.getPosition() == XLabelPosition.TOP) {
    xtop=Utils.calcTextHeight(mXLabelPaint,""String_Node_Str"") * 2f;
  }
 else   if (mXLabels.getPosition() == XLabelPosition.BOTH_SIDED) {
    float height=Utils.calcTextHeight(mXLabelPaint,""String_Node_Str"") * 2f;
    xbottom=height;
    xtop=height;
  }
  if (mDrawLegend) {
    if (mDrawXLabels) {
      mOffsetBottom=Math.max(mOffsetBottom,xbottom + mLegend.getOffsetBottom());
      mOffsetTop=Math.max(mOffsetTop,xtop + mLegend.getOffsetTop());
    }
 else {
      mOffsetBottom=Math.max(mOffsetBottom,mLegend.getOffsetBottom());
      mOffsetTop=Math.max(mOffsetTop,mLegend.getOffsetTop());
    }
    if (mDrawYLabels) {
      mOffsetLeft=Math.max(mOffsetLeft,yleft + mLegend.getOffsetLeft());
      mOffsetRight=Math.max(mOffsetRight,yright + mLegend.getOffsetRight());
    }
 else {
      mOffsetLeft=Math.max(mOffsetLeft,mLegend.getOffsetLeft());
      mOffsetRight=Math.max(mOffsetRight,mLegend.getOffsetRight());
    }
  }
 else {
    if (mDrawXLabels) {
      mOffsetBottom=Math.max(mOffsetBottom,xbottom);
      mOffsetTop=Math.max(mOffsetTop,xtop);
    }
    if (mDrawYLabels) {
      mOffsetLeft=Math.max(mOffsetLeft,yleft);
      mOffsetRight=Math.max(mOffsetRight,yright);
    }
  }
  mLegend.setOffsetTop(mOffsetTop);
  mLegend.setOffsetLeft(mOffsetLeft);
  prepareContentRect();
  float scaleX=(float)((getWidth() - mOffsetLeft - mOffsetRight) / mDeltaX);
  float scaleY=(float)((getHeight() - mOffsetBottom - mOffsetTop) / mDeltaY);
  Matrix val=new Matrix();
  val.postTranslate(0,-mYChartMin);
  val.postScale(scaleX,-scaleY);
  mMatrixValueToPx.set(val);
  Matrix offset=new Matrix();
  offset.postTranslate(mOffsetLeft,getHeight() - mOffsetBottom);
  mMatrixOffset.set(offset);
}",0.9848568281938326
27023,"/** 
 * draws the legend
 */
protected void drawLegend(){
  if (!mDrawLegend || mLegend == null)   return;
  String[] labels=mLegend.getLegendLabels();
  Typeface tf=mLegend.getTypeface();
  if (tf != null)   mLegendLabelPaint.setTypeface(tf);
  mLegendLabelPaint.setTextSize(mLegend.getTextSize());
  float formSize=mLegend.getFormSize();
  float formToTextSpace=mLegend.getFormToTextSpace() + formSize;
  float xEntrySpace=mLegend.getXEntrySpace() + formSize;
  float yEntrySpace=mLegend.getYEntrySpace() + formSize;
  float textSize=mLegend.getTextSize();
  float textDrop=(Utils.calcTextHeight(mLegendLabelPaint,""String_Node_Str"") + formSize) / 2f;
  float posX, posY;
switch (mLegend.getPosition()) {
case BELOW_CHART_LEFT:
    posX=mLegend.getOffsetLeft();
  posY=getHeight() - mLegend.getOffsetBottom() / 2f - formSize / 2f;
for (int i=0; i < labels.length; i++) {
  mLegend.drawForm(mDrawCanvas,posX,posY,mLegendFormPaint,i);
  if (labels[i] != null) {
    if (mLegend.getColors()[i] != -1)     posX+=formToTextSpace;
    mLegend.drawLabel(mDrawCanvas,posX,posY + textDrop,mLegendLabelPaint,i);
    posX+=Utils.calcTextWidth(mLegendLabelPaint,labels[i]) + xEntrySpace;
  }
 else {
    posX+=xEntrySpace;
  }
}
break;
case BELOW_CHART_RIGHT:
posX=getWidth() - mLegend.getOffsetRight() - getOffsetRight();
posY=getHeight() - mLegend.getOffsetBottom() / 2f - formSize / 2f;
for (int i=labels.length - 1; i >= 0; i--) {
if (labels[i] != null) {
posX-=Utils.calcTextWidth(mLegendLabelPaint,labels[i]);
mLegend.drawLabel(mDrawCanvas,posX,posY + textDrop,mLegendLabelPaint,i);
if (mLegend.getColors()[i] != -1) posX-=formToTextSpace;
}
mLegend.drawForm(mDrawCanvas,posX,posY,mLegendFormPaint,i);
posX-=xEntrySpace;
}
break;
case RIGHT_OF_CHART:
if (this instanceof BarLineChartBase) {
posX=getWidth() - mLegend.getOffsetRight() + Utils.convertDpToPixel(9f);
posY=mLegend.getOffsetTop();
}
 else {
posX=getWidth() - mLegend.getMaximumEntryLength(mLegendLabelPaint);
posY=Utils.calcTextHeight(mLegendLabelPaint,""String_Node_Str"") * 1.5f;
}
float stack=0f;
boolean wasStacked=false;
for (int i=0; i < labels.length; i++) {
mLegend.drawForm(mDrawCanvas,posX + stack,posY,mLegendFormPaint,i);
if (labels[i] != null) {
if (!wasStacked) {
float x=posX;
if (mLegend.getColors()[i] != -1) x+=formToTextSpace;
mLegend.drawLabel(mDrawCanvas,x,posY + textDrop,mLegendLabelPaint,i);
}
 else {
mLegend.drawLabel(mDrawCanvas,posX,posY + textSize + formSize+ mLegend.getYEntrySpace(),mLegendLabelPaint,i);
posY+=yEntrySpace;
}
posY+=mLegend.getYEntrySpace() + textSize;
stack=0f;
}
 else {
stack+=formSize + 4f;
wasStacked=true;
}
}
break;
}
}","/** 
 * draws the legend
 */
protected void drawLegend(){
  if (!mDrawLegend || mLegend == null)   return;
  String[] labels=mLegend.getLegendLabels();
  Typeface tf=mLegend.getTypeface();
  if (tf != null)   mLegendLabelPaint.setTypeface(tf);
  mLegendLabelPaint.setTextSize(mLegend.getTextSize());
  float formSize=mLegend.getFormSize();
  float formTextSpaceAndForm=mLegend.getFormToTextSpace() + formSize;
  float stackSpace=Utils.convertDpToPixel(3f);
  float textSize=mLegend.getTextSize();
  float textDrop=(Utils.calcTextHeight(mLegendLabelPaint,""String_Node_Str"") + formSize) / 2f;
  float posX, posY;
switch (mLegend.getPosition()) {
case BELOW_CHART_LEFT:
    posX=mLegend.getOffsetLeft();
  posY=getHeight() - mLegend.getOffsetBottom() / 2f - formSize / 2f;
for (int i=0; i < labels.length; i++) {
  mLegend.drawForm(mDrawCanvas,posX,posY,mLegendFormPaint,i);
  if (labels[i] != null) {
    if (mLegend.getColors()[i] != -1)     posX+=formTextSpaceAndForm;
    mLegend.drawLabel(mDrawCanvas,posX,posY + textDrop,mLegendLabelPaint,i);
    posX+=Utils.calcTextWidth(mLegendLabelPaint,labels[i]) + mLegend.getXEntrySpace();
  }
 else {
    posX+=formSize + stackSpace;
  }
}
break;
case BELOW_CHART_RIGHT:
posX=getWidth() - getOffsetRight();
posY=getHeight() - mLegend.getOffsetBottom() / 2f - formSize / 2f;
for (int i=labels.length - 1; i >= 0; i--) {
if (labels[i] != null) {
posX-=Utils.calcTextWidth(mLegendLabelPaint,labels[i]) + mLegend.getXEntrySpace();
mLegend.drawLabel(mDrawCanvas,posX,posY + textDrop,mLegendLabelPaint,i);
if (mLegend.getColors()[i] != -1) posX-=formTextSpaceAndForm;
}
 else {
posX-=stackSpace + formSize;
}
mLegend.drawForm(mDrawCanvas,posX,posY,mLegendFormPaint,i);
}
break;
case RIGHT_OF_CHART:
posX=getWidth() - mLegend.getMaximumEntryLength(mLegendLabelPaint) - formTextSpaceAndForm;
posY=mLegend.getOffsetTop();
float stack=0f;
boolean wasStacked=false;
for (int i=0; i < labels.length; i++) {
mLegend.drawForm(mDrawCanvas,posX + stack,posY,mLegendFormPaint,i);
if (labels[i] != null) {
if (!wasStacked) {
float x=posX;
if (mLegend.getColors()[i] != -1) x+=formTextSpaceAndForm;
posY+=textDrop;
mLegend.drawLabel(mDrawCanvas,x,posY,mLegendLabelPaint,i);
}
 else {
posY+=textSize * 1.2f + formSize;
mLegend.drawLabel(mDrawCanvas,posX,posY,mLegendLabelPaint,i);
}
posY+=mLegend.getYEntrySpace();
stack=0f;
}
 else {
stack+=formSize + stackSpace;
wasStacked=true;
}
}
break;
}
}",0.7935816164817749
27024,"/** 
 * returns the maximum length in pixels over all legend labels + their forms
 * @param p the paint object used for rendering the text
 * @return
 */
public int getMaximumEntryLength(Paint p){
  int max=0;
  for (int i=0; i < mLegendLabels.length; i++) {
    if (mLegendLabels[i] != null) {
      int length=Utils.calcTextWidth(p,mLegendLabels[i]);
      if (length > max)       max=length;
    }
  }
  return max + (int)mFormSize * 4;
}","/** 
 * returns the maximum length in pixels over all legend labels + their forms
 * @param p the paint object used for rendering the text
 * @return
 */
public int getMaximumEntryLength(Paint p){
  int max=0;
  for (int i=0; i < mLegendLabels.length; i++) {
    if (mLegendLabels[i] != null) {
      int length=Utils.calcTextWidth(p,mLegendLabels[i]);
      if (length > max)       max=length;
    }
  }
  return max + (int)mFormSize;
}",0.9954441913439636
27025,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_pie,container,false);
  mChart=(PieChart)v.findViewById(R.id.pieChart1);
  mChart.setDescription(""String_Node_Str"");
  Typeface tf=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  mChart.setValueTypeface(tf);
  mChart.setCenterTextTypeface(Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str""));
  mChart.setUsePercentValues(true);
  mChart.setCenterText(""String_Node_Str"");
  mChart.setCenterTextSize(23f);
  mChart.setHoleRadius(45f);
  mChart.setTransparentCircleRadius(50f);
  mChart.setData(generateLessData());
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  return v;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_pie,container,false);
  mChart=(PieChart)v.findViewById(R.id.pieChart1);
  mChart.setDescription(""String_Node_Str"");
  Typeface tf=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  mChart.setValueTypeface(tf);
  mChart.setCenterTextTypeface(Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str""));
  mChart.setUsePercentValues(true);
  mChart.setCenterText(""String_Node_Str"");
  mChart.setCenterTextSize(22f);
  mChart.setHoleRadius(45f);
  mChart.setTransparentCircleRadius(50f);
  mChart.setData(generateLessData());
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  return v;
}",0.9987546699875468
27026,"/** 
 * draws the legend
 */
protected void drawLegend(){
  if (!mDrawLegend || mLegend == null)   return;
  String[] labels=mLegend.getLegendLabels();
  Typeface tf=mLegend.getTypeface();
  if (tf != null)   mLegendLabelPaint.setTypeface(tf);
  float formSize=mLegend.getFormSize();
  float formToTextSpace=mLegend.getFormToTextSpace();
  float entrySpace=mLegend.getEntrySpace();
  float textSize=Utils.convertPixelsToDp(mLegendLabelPaint.getTextSize());
  float textDrop=(textSize + formSize) / 2f;
  float posX, posY;
switch (mLegend.getPosition()) {
case BELOW_CHART_LEFT:
    posX=mOffsetLeft;
  posY=getHeight() - mOffsetBottom + textSize * 2;
for (int i=0; i < labels.length; i++) {
  mLegend.drawForm(mDrawCanvas,posX,posY,mLegendFormPaint,i);
  posX+=formToTextSpace;
  if (labels[i] != null) {
    mLegend.drawLabel(mDrawCanvas,posX,posY + textDrop,mLegendLabelPaint,i);
    posX+=Utils.calcTextWidth(mLegendLabelPaint,labels[i]) + entrySpace;
  }
}
break;
case BELOW_CHART_RIGHT:
posX=getWidth() - mOffsetRight;
posY=getHeight() - mOffsetBottom + textSize * 2;
for (int i=labels.length - 1; i >= 0; i--) {
if (labels[i] != null) {
posX-=Utils.calcTextWidth(mLegendLabelPaint,labels[i]);
mLegend.drawLabel(mDrawCanvas,posX,posY + textDrop,mLegendLabelPaint,i);
posX-=formToTextSpace;
}
mLegend.drawForm(mDrawCanvas,posX,posY,mLegendFormPaint,i);
posX-=entrySpace;
}
break;
case RIGHT_OF_CHART:
if (this instanceof BarLineChartBase) {
posX=getWidth() - mOffsetRight + formSize;
}
 else {
posX=getWidth() - mLegend.getMaximumEntryLength(mLegendLabelPaint);
}
posY=mOffsetTop;
float stack=0f;
boolean wasStacked=false;
for (int i=0; i < labels.length; i++) {
mLegend.drawForm(mDrawCanvas,posX + stack,posY,mLegendFormPaint,i);
if (labels[i] != null) {
if (!wasStacked) {
mLegend.drawLabel(mDrawCanvas,posX + formToTextSpace,posY + textDrop,mLegendLabelPaint,i);
}
 else {
mLegend.drawLabel(mDrawCanvas,posX,posY + textDrop + entrySpace,mLegendLabelPaint,i);
posY+=entrySpace;
}
posY+=entrySpace;
stack=0f;
}
 else {
stack+=formSize + 4f;
wasStacked=true;
}
}
break;
}
}","/** 
 * draws the legend
 */
protected void drawLegend(){
  if (!mDrawLegend || mLegend == null)   return;
  String[] labels=mLegend.getLegendLabels();
  Typeface tf=mLegend.getTypeface();
  if (tf != null)   mLegendLabelPaint.setTypeface(tf);
  float formSize=mLegend.getFormSize();
  float formToTextSpace=mLegend.getFormToTextSpace();
  float entrySpace=mLegend.getEntrySpace();
  float textSize=Utils.convertPixelsToDp(mLegendLabelPaint.getTextSize());
  float textDrop=(textSize + formSize) / 2f + textSize / 2f;
  float posX, posY;
switch (mLegend.getPosition()) {
case BELOW_CHART_LEFT:
    posX=mOffsetLeft;
  posY=getHeight() - mOffsetBottom + textSize * 2;
for (int i=0; i < labels.length; i++) {
  mLegend.drawForm(mDrawCanvas,posX,posY,mLegendFormPaint,i);
  posX+=formToTextSpace;
  if (labels[i] != null) {
    mLegend.drawLabel(mDrawCanvas,posX,posY + textDrop,mLegendLabelPaint,i);
    posX+=Utils.calcTextWidth(mLegendLabelPaint,labels[i]) + entrySpace;
  }
}
break;
case BELOW_CHART_RIGHT:
posX=getWidth() - mOffsetRight;
posY=getHeight() - mOffsetBottom + textSize * 2;
for (int i=labels.length - 1; i >= 0; i--) {
if (labels[i] != null) {
posX-=Utils.calcTextWidth(mLegendLabelPaint,labels[i]);
mLegend.drawLabel(mDrawCanvas,posX,posY + textDrop,mLegendLabelPaint,i);
posX-=formToTextSpace;
}
mLegend.drawForm(mDrawCanvas,posX,posY,mLegendFormPaint,i);
posX-=entrySpace;
}
break;
case RIGHT_OF_CHART:
if (this instanceof BarLineChartBase) {
posX=getWidth() - mOffsetRight + formSize;
posY=mOffsetTop;
}
 else {
posX=getWidth() - mLegend.getMaximumEntryLength(mLegendLabelPaint);
posY=Utils.calcTextHeight(mLegendLabelPaint,""String_Node_Str"") * 1.5f;
}
float stack=0f;
boolean wasStacked=false;
for (int i=0; i < labels.length; i++) {
mLegend.drawForm(mDrawCanvas,posX + stack,posY,mLegendFormPaint,i);
if (labels[i] != null) {
if (!wasStacked) {
mLegend.drawLabel(mDrawCanvas,posX + formToTextSpace,posY + textDrop,mLegendLabelPaint,i);
}
 else {
mLegend.drawLabel(mDrawCanvas,posX,posY + textDrop + entrySpace,mLegendLabelPaint,i);
posY+=entrySpace;
}
posY+=entrySpace;
stack=0f;
}
 else {
stack+=formSize + 4f;
wasStacked=true;
}
}
break;
}
}",0.97146899316199
27027,"/** 
 * draws the given y values to the screen
 */
@Override protected void drawData(){
  ArrayList<DataSet> dataSets;
  dataSets=mCurrentData.getDataSets();
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    DataSet dataSet=dataSets.get(i);
    ArrayList<Entry> entries=dataSet.getYVals();
    float[] valuePoints=generateTransformedValues(entries,0f);
    ArrayList<Integer> colors=mCt.getDataSetColors(i % mCt.getColors().size());
    Paint paint=mRenderPaint;
    if (mDrawSpline) {
      Path spline=new Path();
      spline.moveTo(entries.get(0).getXIndex(),entries.get(0).getVal());
      paint.setColor(colors.get(i % colors.size()));
      for (int x=1; x < entries.size() - 3; x+=2) {
        spline.cubicTo(entries.get(x).getXIndex(),entries.get(x).getVal(),entries.get(x + 1).getXIndex(),entries.get(x + 1).getVal(),entries.get(x + 2).getXIndex(),entries.get(x + 2).getVal());
      }
      transformPath(spline);
      mDrawCanvas.drawPath(spline,paint);
    }
 else {
      for (int j=0; j < valuePoints.length - 2; j+=2) {
        paint.setColor(colors.get(j % colors.size()));
        if (isOffContentRight(valuePoints[j]))         break;
        if (j != 0 && isOffContentLeft(valuePoints[j - 1]) && isOffContentTop(valuePoints[j + 1]) && isOffContentBottom(valuePoints[j + 1]))         continue;
        mDrawCanvas.drawLine(valuePoints[j],valuePoints[j + 1],valuePoints[j + 2],valuePoints[j + 3],paint);
      }
    }
    if (mDrawFilled && entries.size() > 0) {
      paint.setAlpha(85);
      Path filled=new Path();
      filled.moveTo(entries.get(0).getXIndex(),entries.get(0).getVal());
      for (int x=1; x < entries.size(); x++) {
        filled.lineTo(entries.get(x).getXIndex(),entries.get(x).getVal());
      }
      filled.lineTo(entries.get(entries.size() - 1).getXIndex(),mYChartMin);
      filled.lineTo(entries.get(0).getXIndex(),mYChartMin);
      filled.close();
      transformPath(filled);
      mDrawCanvas.drawPath(filled,paint);
      paint.setAlpha(255);
    }
  }
}","/** 
 * draws the given y values to the screen
 */
@Override protected void drawData(){
  ArrayList<DataSet> dataSets;
  dataSets=mCurrentData.getDataSets();
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    DataSet dataSet=dataSets.get(i);
    ArrayList<Entry> entries=dataSet.getYVals();
    float[] valuePoints=generateTransformedValues(entries,0f);
    ArrayList<Integer> colors=mCt.getDataSetColors(i % mCt.getColors().size());
    Paint paint=mRenderPaint;
    if (mDrawCubic) {
      paint.setColor(colors.get(i % colors.size()));
      Path spline=new Path();
      spline.moveTo(entries.get(0).getXIndex(),entries.get(0).getVal());
      for (int x=1; x < entries.size() - 3; x+=2) {
        spline.cubicTo(entries.get(x).getXIndex(),entries.get(x).getVal(),entries.get(x + 1).getXIndex(),entries.get(x + 1).getVal(),entries.get(x + 2).getXIndex(),entries.get(x + 2).getVal());
      }
      transformPath(spline);
      mDrawCanvas.drawPath(spline,paint);
    }
 else {
      for (int j=0; j < valuePoints.length - 2; j+=2) {
        paint.setColor(colors.get(j % colors.size()));
        if (isOffContentRight(valuePoints[j]))         break;
        if (j != 0 && isOffContentLeft(valuePoints[j - 1]) && isOffContentTop(valuePoints[j + 1]) && isOffContentBottom(valuePoints[j + 1]))         continue;
        mDrawCanvas.drawLine(valuePoints[j],valuePoints[j + 1],valuePoints[j + 2],valuePoints[j + 3],paint);
      }
    }
    if (mDrawFilled && entries.size() > 0) {
      paint.setAlpha(85);
      Path filled=new Path();
      filled.moveTo(entries.get(0).getXIndex(),entries.get(0).getVal());
      for (int x=1; x < entries.size(); x++) {
        filled.lineTo(entries.get(x).getXIndex(),entries.get(x).getVal());
      }
      filled.lineTo(entries.get(entries.size() - 1).getXIndex(),mYChartMin);
      filled.lineTo(entries.get(0).getXIndex(),mYChartMin);
      filled.close();
      transformPath(filled);
      mDrawCanvas.drawPath(filled,paint);
      paint.setAlpha(255);
    }
  }
}",0.9700569166048008
27028,"/** 
 * draws the description text in the center of the pie chart makes most sense when center-hole is enabled
 */
private void drawCenterText(){
  if (mDrawCenterText) {
    PointF c=getCenterCircleBox();
    String[] lines=mCenterText.split(""String_Node_Str"");
    float lineHeight=Utils.calcTextHeight(mCenterTextPaint,lines[0]) * 1.2f;
    float totalheight=lineHeight * lines.length;
    int cnt=lines.length;
    for (int i=0; i < lines.length; i++) {
      String line=lines[lines.length - i - 1];
      mDrawCanvas.drawText(line,c.x,c.y + lineHeight * cnt - lineHeight / 2 - totalheight * 0.45f,mCenterTextPaint);
      cnt--;
    }
  }
}","/** 
 * draws the description text in the center of the pie chart makes most sense when center-hole is enabled
 */
private void drawCenterText(){
  if (mDrawCenterText) {
    PointF c=getCenterCircleBox();
    String[] lines=mCenterText.split(""String_Node_Str"");
    float lineHeight=Utils.calcTextHeight(mCenterTextPaint,lines[0]);
    float linespacing=lineHeight * 0.2f;
    float totalheight=lineHeight * lines.length - linespacing * (lines.length - 1);
    int cnt=lines.length;
    float y=c.y;
    for (int i=0; i < lines.length; i++) {
      String line=lines[lines.length - i - 1];
      mDrawCanvas.drawText(line,c.x,y + lineHeight * cnt - totalheight / 2f,mCenterTextPaint);
      cnt--;
      y-=linespacing;
    }
  }
}",0.783744557329463
27029,"@Override public void calculateOffsets(){
  if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART) {
    mLegendLabelPaint.setTextAlign(Align.LEFT);
  }
 else   if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT) {
    mOffsetBottom=(int)(mLegendLabelPaint.getTextSize() * 3.5f);
  }
  prepareContentRect();
  float scaleX=(float)((getWidth() - mOffsetLeft - mOffsetRight) / mDeltaX);
  float scaleY=(float)((getHeight() - mOffsetBottom - mOffsetTop) / mDeltaY);
  Matrix val=new Matrix();
  val.postTranslate(0,-mYChartMin);
  val.postScale(scaleX,-scaleY);
  mMatrixValueToPx.set(val);
  Matrix offset=new Matrix();
  offset.postTranslate(mOffsetLeft,getHeight() - mOffsetBottom);
  mMatrixOffset.set(offset);
}","@Override public void calculateOffsets(){
  if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART) {
    mLegendLabelPaint.setTextAlign(Align.LEFT);
    mOffsetTop=(int)(mLegendLabelPaint.getTextSize() * 3.5f);
  }
 else   if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT) {
    mOffsetBottom=(int)(mLegendLabelPaint.getTextSize() * 3.5f);
  }
  prepareContentRect();
  float scaleX=(float)((getWidth() - mOffsetLeft - mOffsetRight) / mDeltaX);
  float scaleY=(float)((getHeight() - mOffsetBottom - mOffsetTop) / mDeltaY);
  Matrix val=new Matrix();
  val.postTranslate(0,-mYChartMin);
  val.postScale(scaleX,-scaleY);
  mMatrixValueToPx.set(val);
  Matrix offset=new Matrix();
  offset.postTranslate(mOffsetLeft,getHeight() - mOffsetBottom);
  mMatrixOffset.set(offset);
}",0.9621951219512196
27030,"@Override protected void drawData(){
  ArrayList<DataSet> dataSets=mCurrentData.getDataSets();
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    DataSet dataSet=dataSets.get(i);
    ArrayList<Entry> entries=dataSet.getYVals();
    float[] pos=generateTransformedValues(entries,0f);
    ArrayList<Integer> colors=mCt.getDataSetColors(i % mCt.getColors().size());
    ScatterShape shape=mScatterShapes[i % mScatterShapes.length];
    for (int j=0; j < pos.length; j+=2) {
      mRenderPaint.setColor(colors.get(j % colors.size()));
      if (isOffContentRight(pos[j]))       break;
      float shapeHalf=mShapeSize / 2f;
      if (j != 0 && isOffContentLeft(pos[j - 1]) && isOffContentTop(pos[j + 1]) && isOffContentBottom(pos[j + 1]))       continue;
      if (shape == ScatterShape.SQUARE) {
        mDrawCanvas.drawRect(pos[j] - shapeHalf,pos[j + 1] - shapeHalf,pos[j] + shapeHalf,pos[j + 1] + shapeHalf,mRenderPaint);
      }
 else       if (shape == ScatterShape.CIRCLE) {
        mDrawCanvas.drawCircle(pos[j],pos[j + 1],mShapeSize / 2f,mRenderPaint);
      }
 else       if (shape == ScatterShape.CROSS) {
        mDrawCanvas.drawLine(pos[j] - shapeHalf,pos[j + 1],pos[j] + shapeHalf,pos[j + 1],mRenderPaint);
        mDrawCanvas.drawLine(pos[j],pos[j + 1] - shapeHalf,pos[j],pos[j + 1] + shapeHalf,mRenderPaint);
      }
 else       if (shape == ScatterShape.TRIANGLE) {
        Path tri=new Path();
        tri.moveTo(pos[j],pos[j + 1] - shapeHalf);
        tri.lineTo(pos[j] + shapeHalf,pos[j + 1] + shapeHalf);
        tri.lineTo(pos[j] - shapeHalf,pos[j + 1] + shapeHalf);
        tri.close();
        mDrawCanvas.drawPath(tri,mRenderPaint);
      }
 else       if (shape == ScatterShape.CUSTOM) {
        if (mCustomScatterPath == null)         return;
        transformPath(mCustomScatterPath);
        mDrawCanvas.drawPath(mCustomScatterPath,mRenderPaint);
      }
    }
  }
}","@Override protected void drawData(){
  ArrayList<DataSet> dataSets=mCurrentData.getDataSets();
  float shapeHalf=mShapeSize / 2f;
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    DataSet dataSet=dataSets.get(i);
    ArrayList<Entry> entries=dataSet.getYVals();
    float[] pos=generateTransformedValues(entries,0f);
    ArrayList<Integer> colors=mCt.getDataSetColors(i % mCt.getColors().size());
    ScatterShape shape=mScatterShapes[i % mScatterShapes.length];
    for (int j=0; j < pos.length; j+=2) {
      mRenderPaint.setColor(colors.get(j % colors.size()));
      if (isOffContentRight(pos[j]))       break;
      if (j != 0 && isOffContentLeft(pos[j - 1]) && isOffContentTop(pos[j + 1]) && isOffContentBottom(pos[j + 1]))       continue;
      if (shape == ScatterShape.SQUARE) {
        mDrawCanvas.drawRect(pos[j] - shapeHalf,pos[j + 1] - shapeHalf,pos[j] + shapeHalf,pos[j + 1] + shapeHalf,mRenderPaint);
      }
 else       if (shape == ScatterShape.CIRCLE) {
        mDrawCanvas.drawCircle(pos[j],pos[j + 1],mShapeSize / 2f,mRenderPaint);
      }
 else       if (shape == ScatterShape.CROSS) {
        mDrawCanvas.drawLine(pos[j] - shapeHalf,pos[j + 1],pos[j] + shapeHalf,pos[j + 1],mRenderPaint);
        mDrawCanvas.drawLine(pos[j],pos[j + 1] - shapeHalf,pos[j],pos[j + 1] + shapeHalf,mRenderPaint);
      }
 else       if (shape == ScatterShape.TRIANGLE) {
        Path tri=new Path();
        tri.moveTo(pos[j],pos[j + 1] - shapeHalf);
        tri.lineTo(pos[j] + shapeHalf,pos[j + 1] + shapeHalf);
        tri.lineTo(pos[j] - shapeHalf,pos[j + 1] + shapeHalf);
        tri.close();
        mDrawCanvas.drawPath(tri,mRenderPaint);
      }
 else       if (shape == ScatterShape.CUSTOM) {
        if (mCustomScatterPath == null)         return;
        transformPath(mCustomScatterPath);
        mDrawCanvas.drawPath(mCustomScatterPath,mRenderPaint);
      }
    }
  }
}",0.9805263157894736
27031,"/** 
 * Loads a DataSet from a textfile from the sd-card. Textfile syntax is: labelstring<linebreak>500.99#0<linebreak>350.80#1<linebreak>and so on...
 * @param path the name of the file on the sd card (path if needed)
 * @return
 */
public static DataSet dataSetFromFile(String path){
  File sdcard=Environment.getExternalStorageDirectory();
  File file=new File(sdcard,path);
  ArrayList<Entry> entries=new ArrayList<Entry>();
  String label=""String_Node_Str"";
  try {
    @SuppressWarnings(""String_Node_Str"") BufferedReader br=new BufferedReader(new FileReader(file));
    String line=br.readLine();
    label=line;
    while ((line=br.readLine()) != null) {
      String[] split=line.split(""String_Node_Str"");
      entries.add(new Entry(Float.valueOf(split[0]),Integer.valueOf(split[1])));
    }
  }
 catch (  IOException e) {
    Log.e(LOG,e.toString());
  }
  DataSet ds=new DataSet(entries,label);
  return ds;
}","/** 
 * Loads a DataSet from a textfile from the sd-card. Textfile syntax is: labelstring<linebreak>500.99#0<linebreak>350.80#1<linebreak>and so on...
 * @param path the name of the file on the sd card (path if needed)
 * @return
 */
public static DataSet dataSetFromFile(String path){
  File sdcard=Environment.getExternalStorageDirectory();
  File file=new File(sdcard,path);
  ArrayList<Entry> entries=new ArrayList<Entry>();
  String label=""String_Node_Str"";
  try {
    @SuppressWarnings(""String_Node_Str"") BufferedReader br=new BufferedReader(new FileReader(file));
    String line=br.readLine();
    label=line;
    while ((line=br.readLine()) != null) {
      String[] split=line.split(""String_Node_Str"");
      entries.add(new Entry(Float.parseFloat(split[0]),Integer.parseInt(split[1])));
    }
  }
 catch (  IOException e) {
    Log.e(LOG,e.toString());
  }
  DataSet ds=new DataSet(entries,label);
  return ds;
}",0.982646420824295
27032,"@Override public void run(){
  float indicesInView=mDeltaX / mScaleX;
  float valsInView=mDeltaY / mScaleY;
  float[] pts=new float[]{xIndex - indicesInView / 2f,yVal + valsInView / 2f};
  Matrix save=new Matrix();
  save.set(mMatrixTouch);
  transformPointArray(pts);
  final float x=-pts[0] + getOffsetLeft();
  final float y=-pts[1] - getOffsetTop();
  save.postTranslate(x,y);
  refreshTouchNoInvalidate(save);
}","@Override public void run(){
  float indicesInView=mDeltaX / mScaleX;
  float valsInView=mDeltaY / mScaleY;
  float[] pts=new float[]{xIndex - indicesInView / 2f,yVal + valsInView / 2f};
  Matrix save=new Matrix();
  save.set(mMatrixTouch);
  transformPointArray(pts);
  final float x=-pts[0] + getOffsetLeft();
  final float y=-pts[1] - getOffsetTop();
  save.postTranslate(x,y);
  refreshTouch(save);
}",0.9853658536585366
27033,"/** 
 * Centers the viewport around the specified x-index and the specified y-value in the chart. Centering the viewport outside the bounds of the chart is not possible. Makes most sense in combination with the setScaleMinima(...) method. SHOULD BE CALLED AFTER setting data for the chart.
 * @param xIndex the index on the x-axis to center to
 * @param yVal the value ont he y-axis to center to
 */
public synchronized void centerViewPort(final int xIndex,final float yVal){
  post(new Runnable(){
    @Override public void run(){
      float indicesInView=mDeltaX / mScaleX;
      float valsInView=mDeltaY / mScaleY;
      float[] pts=new float[]{xIndex - indicesInView / 2f,yVal + valsInView / 2f};
      Matrix save=new Matrix();
      save.set(mMatrixTouch);
      transformPointArray(pts);
      final float x=-pts[0] + getOffsetLeft();
      final float y=-pts[1] - getOffsetTop();
      save.postTranslate(x,y);
      refreshTouchNoInvalidate(save);
    }
  }
);
}","/** 
 * Centers the viewport around the specified x-index and the specified y-value in the chart. Centering the viewport outside the bounds of the chart is not possible. Makes most sense in combination with the setScaleMinima(...) method. First set the scale minima, then center the viewport. SHOULD BE CALLED AFTER setting data for the chart.
 * @param xIndex the index on the x-axis to center to
 * @param yVal the value ont he y-axis to center to
 */
public synchronized void centerViewPort(final int xIndex,final float yVal){
  post(new Runnable(){
    @Override public void run(){
      float indicesInView=mDeltaX / mScaleX;
      float valsInView=mDeltaY / mScaleY;
      float[] pts=new float[]{xIndex - indicesInView / 2f,yVal + valsInView / 2f};
      Matrix save=new Matrix();
      save.set(mMatrixTouch);
      transformPointArray(pts);
      final float x=-pts[0] + getOffsetLeft();
      final float y=-pts[1] - getOffsetTop();
      save.postTranslate(x,y);
      refreshTouch(save);
    }
  }
);
}",0.9667673716012084
27034,"private boolean alreadyCounted(ArrayList<String> countedLabels,String label){
  for (int i=0; i < countedLabels.size(); i++) {
    if (countedLabels.get(i).equals(label))     return true;
  }
  return false;
}","private boolean alreadyCounted(ArrayList<String> countedLabels,String label){
  if (label == null)   return true;
  for (int i=0; i < countedLabels.size(); i++) {
    if (countedLabels.get(i).equals(label))     return true;
  }
  return false;
}",0.920704845814978
27035,"/** 
 * Does all necessary calculations, if the underlying data has changed
 */
private void doCalculations(){
  calcTypes();
  calcMinMax();
  calcYValueSum();
}","/** 
 * Does all necessary calculations, if the underlying data has changed
 */
private void doCalculations(){
  calcMinMax();
  calcYValueSum();
}",0.9514563106796116
27036,"private void init(ArrayList<String> xVals,ArrayList<DataSet> dataSets){
  this.mXVals=xVals;
  this.mDataSets=dataSets;
  calcTypes();
  calcMinMax();
  calcYValueSum();
  for (int i=0; i < mDataSets.size(); i++) {
    if (mDataSets.get(i).getYVals().size() > xVals.size()) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
}","private void init(ArrayList<String> xVals,ArrayList<DataSet> dataSets){
  this.mXVals=xVals;
  this.mDataSets=dataSets;
  calcMinMax();
  calcYValueSum();
  for (int i=0; i < mDataSets.size(); i++) {
    if (mDataSets.get(i).getYVals().size() > xVals.size()) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
}",0.9779735682819384
27037,"/** 
 * Call this method to create a new drawing DataSet
 * @param type the type of the new DataSet
 */
public void createNewDrawingDataSet(ChartData chartData){
  if (mCurrentDrawingDataSet != null && mCurrentDrawingEntries != null) {
    finishNewDrawingEntry(chartData);
  }
  if (!chartData.getLabels().contains(mLastDrawnDataSetIndex)) {
    chartData.getLabels().add(""String_Node_Str"" + mLastDrawnDataSetIndex);
  }
  mCurrentDrawingEntries=new ArrayList<Entry>();
  this.mCurrentDrawingDataSet=new DataSet(mCurrentDrawingEntries,""String_Node_Str"" + mLastDrawnDataSetIndex);
  chartData.getDataSets().add(mCurrentDrawingDataSet);
}","/** 
 * Call this method to create a new drawing DataSet
 * @param type the type of the new DataSet
 */
public void createNewDrawingDataSet(ChartData chartData){
  if (mCurrentDrawingDataSet != null && mCurrentDrawingEntries != null) {
    finishNewDrawingEntry(chartData);
  }
  mCurrentDrawingEntries=new ArrayList<Entry>();
  this.mCurrentDrawingDataSet=new DataSet(mCurrentDrawingEntries,""String_Node_Str"" + mLastDrawnDataSetIndex);
  chartData.getDataSets().add(mCurrentDrawingDataSet);
}",0.5823008849557522
27038,"/** 
 * calculates the approximate width of a text, depending on a demo text avoid repeated calls (e.g. inside drawing methods)
 * @param paint
 * @param demoText
 * @return
 */
public static int calcTextWidth(Paint paint,String demoText){
  Rect r=new Rect();
  paint.getTextBounds(demoText,0,demoText.length(),r);
  return r.width();
}","/** 
 * calculates the approximate width of a text, depending on a demo text avoid repeated calls (e.g. inside drawing methods)
 * @param paint
 * @param demoText
 * @return
 */
public static int calcTextWidth(Paint paint,String demoText){
  return (int)paint.measureText(demoText);
}",0.7922705314009661
27039,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  ColorTemplate ct=new ColorTemplate();
  ct.addDataSetColors(new int[]{R.color.colorful_1},this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setColorTemplate(ct);
  mChart.setStartAtZero(false);
  mChart.setDrawYValues(false);
  mChart.setLineWidth(1f);
  mChart.setCircleSize(4f);
  mChart.setDrawBorder(true);
  mChart.setBorderStyles(new BorderStyle[]{BorderStyle.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setYLabelCount(6);
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setPinchZoom(true);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mv.setOffsets(-mv.getMeasuredWidth() / 2,-mv.getMeasuredHeight());
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  mChart.enableDashedLine(10f,5f,0f);
  setData(45,100);
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  mChart.invalidate();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  ColorTemplate ct=new ColorTemplate();
  ct.addDataSetColors(new int[]{R.color.colorful_1},this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setColorTemplate(ct);
  mChart.setStartAtZero(false);
  mChart.setDrawYValues(false);
  mChart.setLineWidth(1f);
  mChart.setCircleSize(4f);
  mChart.setDrawBorder(true);
  mChart.setBorderStyles(new BorderStyle[]{BorderStyle.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setYLabelCount(6);
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setPinchZoom(true);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mv.setOffsets(-mv.getMeasuredWidth() / 2,-mv.getMeasuredHeight());
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  mChart.enableDashedLine(10f,5f,0f);
  setData(45,100);
  mChart.setScaleMinima(3f,3f);
  mChart.centerViewPort(10,50);
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  mChart.invalidate();
}",0.9802590993214064
27040,"@Override public void run(){
  float indicesInView=mDeltaX / mScaleX;
  float valsInView=mDeltaY / mScaleY;
  float[] pts=new float[]{xIndex - indicesInView / 2f,yVal + valsInView / 2f};
  Matrix save=new Matrix();
  save.set(mMatrixTouch);
  transformPointArray(pts);
  final float x=-pts[0] + getOffsetLeft();
  final float y=-pts[1] + getOffsetBottom();
  save.postTranslate(x,y);
  refreshTouchNoInvalidate(save);
}","@Override public void run(){
  float indicesInView=mDeltaX / mScaleX;
  float valsInView=mDeltaY / mScaleY;
  float[] pts=new float[]{xIndex - indicesInView / 2f,yVal + valsInView / 2f};
  Matrix save=new Matrix();
  save.set(mMatrixTouch);
  transformPointArray(pts);
  final float x=-pts[0] + getOffsetLeft();
  final float y=-pts[1] - getOffsetTop();
  save.postTranslate(x,y);
  refreshTouchNoInvalidate(save);
}",0.9868263473053892
27041,"/** 
 * Centers the viewport around the specified x-index and the specified y-value in the chart. Centering the viewport outside the bounds of the chart is not possible. Makes most sense in combination with the setScaleMinima(...) method. SHOULD BE CALLED AFTER setting data for the chart.
 * @param xIndex the index on the x-axis to center to
 * @param yVal the value ont he y-axis to center to
 */
public synchronized void centerViewPort(final int xIndex,final float yVal){
  post(new Runnable(){
    @Override public void run(){
      float indicesInView=mDeltaX / mScaleX;
      float valsInView=mDeltaY / mScaleY;
      float[] pts=new float[]{xIndex - indicesInView / 2f,yVal + valsInView / 2f};
      Matrix save=new Matrix();
      save.set(mMatrixTouch);
      transformPointArray(pts);
      final float x=-pts[0] + getOffsetLeft();
      final float y=-pts[1] + getOffsetBottom();
      save.postTranslate(x,y);
      refreshTouchNoInvalidate(save);
    }
  }
);
}","/** 
 * Centers the viewport around the specified x-index and the specified y-value in the chart. Centering the viewport outside the bounds of the chart is not possible. Makes most sense in combination with the setScaleMinima(...) method. SHOULD BE CALLED AFTER setting data for the chart.
 * @param xIndex the index on the x-axis to center to
 * @param yVal the value ont he y-axis to center to
 */
public synchronized void centerViewPort(final int xIndex,final float yVal){
  post(new Runnable(){
    @Override public void run(){
      float indicesInView=mDeltaX / mScaleX;
      float valsInView=mDeltaY / mScaleY;
      float[] pts=new float[]{xIndex - indicesInView / 2f,yVal + valsInView / 2f};
      Matrix save=new Matrix();
      save.set(mMatrixTouch);
      transformPointArray(pts);
      final float x=-pts[0] + getOffsetLeft();
      final float y=-pts[1] - getOffsetTop();
      save.postTranslate(x,y);
      refreshTouchNoInvalidate(save);
    }
  }
);
}",0.9943502824858758
27042,"@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  super.onLayout(changed,left,top,right,bottom);
  prepareContentRect();
  Log.i(LOG_TAG,""String_Node_Str"" + mContentRect.width() + ""String_Node_Str""+ mContentRect.height());
  if (this instanceof BarLineChartBase) {
    if (!((BarLineChartBase)this).hasFixedYValues())     prepareMatrix();
  }
 else {
    prepareMatrix();
  }
}","@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  super.onLayout(changed,left,top,right,bottom);
  prepareContentRect();
  Log.i(LOG_TAG,""String_Node_Str"" + mContentRect.width() + ""String_Node_Str""+ mContentRect.height());
  if (this instanceof BarLineChartBase) {
    BarLineChartBase b=(BarLineChartBase)this;
    if (!b.hasFixedYValues() && !mMatrixOnLayoutPrepared) {
      prepareMatrix();
      mMatrixOnLayoutPrepared=true;
    }
  }
 else {
    prepareMatrix();
  }
}",0.8076923076923077
27043,"/** 
 * setup all the matrices that will be used for scaling the coordinates to the display
 */
protected void prepareMatrix(){
  float scaleX=(float)((getWidth() - mOffsetLeft - mOffsetRight) / mDeltaX);
  float scaleY=(float)((getHeight() - mOffsetBottom - mOffsetTop) / mDeltaY);
  mMatrixValueToPx.reset();
  mMatrixValueToPx.postTranslate(0,-mYChartMin);
  mMatrixValueToPx.postScale(scaleX,-scaleY);
  mMatrixOffset.reset();
  mMatrixOffset.postTranslate(mOffsetLeft,getHeight() - mOffsetBottom);
}","/** 
 * setup all the matrices that will be used for scaling the coordinates to the display
 */
protected void prepareMatrix(){
  float scaleX=(float)((getWidth() - mOffsetLeft - mOffsetRight) / mDeltaX);
  float scaleY=(float)((getHeight() - mOffsetBottom - mOffsetTop) / mDeltaY);
  mMatrixValueToPx.reset();
  mMatrixValueToPx.postTranslate(0,-mYChartMin);
  mMatrixValueToPx.postScale(scaleX,-scaleY);
  mMatrixOffset.reset();
  mMatrixOffset.postTranslate(mOffsetLeft,getHeight() - mOffsetBottom);
  Log.i(LOG_TAG,""String_Node_Str"");
}",0.9655172413793104
27044,"/** 
 * does all necessary preparations, needed when data is changed or flags that effect the data are changed
 */
@Override protected void prepare(){
  if (mDataNotSet)   return;
  calcMinMax();
  prepareXLegend();
  prepareYLegend();
  calcFormats();
  prepareMatrix();
}","/** 
 * does all necessary preparations, needed when data is changed or flags that effect the data are changed
 */
@Override public void prepare(){
  if (mDataNotSet)   return;
  calcMinMax();
  prepareXLegend();
  prepareYLegend();
  calcFormats();
  prepareMatrix();
}",0.9760589318600368
27045,"private void initWithDummyData(){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < 25; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  DataSet set1=new DataSet(yVals,0);
  ArrayList<DataSet> dataSets=new ArrayList<DataSet>();
  dataSets.add(set1);
  ChartData data=new ChartData(xVals,dataSets);
  mChart.setData(data);
  mChart.invalidate();
}","private void initWithDummyData(){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < 25; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  DataSet set1=new DataSet(yVals,0);
  ArrayList<DataSet> dataSets=new ArrayList<DataSet>();
  dataSets.add(set1);
  ChartData data=new ChartData(xVals,dataSets);
  mChart.setData(data);
  mChart.setYRange(10,40,0);
  mChart.invalidate();
}",0.9666283084004604
27046,"@Override protected void calcMinMax(boolean fixedValues){
  super.calcMinMax(fixedValues);
  mDeltaX++;
}","@Override protected void calcMinMax(boolean fixedValues){
  super.calcMinMax(fixedValues);
  if (!mStartAtZero && getYMin() >= 0f) {
    mYChartMin=getYMin();
    mDeltaY=Math.abs(mYChartMax - mYChartMin);
  }
  mDeltaX++;
}",0.6382978723404256
27047,"@Override protected void calcMinMax(boolean fixedValues){
  super.calcMinMax(fixedValues);
  float spaceTop=(mData.getYMax() - mYChartMin) / 100f * 10f;
  if (mStartAtZero) {
    mYChartMin=0;
  }
 else {
    float spaceBottom=(mData.getYMax() - mYChartMin) / 100f * 10f;
    mYChartMin=mYChartMin - spaceBottom;
  }
  mDeltaY=(mData.getYMax() + spaceTop) - mYChartMin;
  mYChartMax=mYChartMin + mDeltaY;
  Log.i(LOG_TAG,""String_Node_Str"" + mDeltaX + ""String_Node_Str""+ mDeltaY);
}","@Override protected void calcMinMax(boolean fixedValues){
  super.calcMinMax(fixedValues);
  float space=mDeltaY / 100f * 10f;
  if (mStartAtZero) {
    mYChartMin=0;
  }
 else {
    mYChartMin=mYChartMin - space;
  }
  mYChartMax=mYChartMax + space;
  mDeltaY=Math.abs(mYChartMax - mYChartMin);
}",0.313624678663239
27048,"/** 
 * setup the Y legend
 */
protected void prepareYLegend(){
  ArrayList<Float> yLegend=new ArrayList<Float>();
  if (mRoundedYLegend) {
    float interval=(mDeltaY) / (mYLegendCount - 1);
    double log10=Math.log10(interval);
    int exp=(int)Math.floor(log10);
    double tenPowExp=POW_10[exp + 5];
    double multi=Math.round(interval / tenPowExp);
    if (multi >= 1) {
      if (multi > 2 && multi < 5) {
        multi=5;
      }
 else       if (multi > 5 && multi < 10) {
        multi=10;
      }
    }
    float step=(float)(multi * tenPowExp);
    float val=0;
    if (step >= 1f)     val=(int)(mYChartMin / step) * step;
 else {
      val=mYChartMin;
    }
    while (val <= mDeltaY + step + mYChartMin) {
      yLegend.add(val);
      val=val + step;
    }
    if (step >= 1f)     mYChartMin=(int)(mYChartMin / step) * step;
    mDeltaY=val - step - mYChartMin;
    mYChartMax=yLegend.get(yLegend.size() - 1);
  }
 else {
    float interval=(mDeltaY) / (mYLegendCount - 1);
    yLegend.add(mYChartMin);
    for (int i=1; i < mYLegendCount - 1; i++) {
      yLegend.add(mYChartMin + ((float)i * interval));
    }
    yLegend.add(mDeltaY + mYChartMin);
  }
  mYLegend=yLegend.toArray(new Float[0]);
}","/** 
 * setup the Y legend
 */
protected void prepareYLegend(){
  ArrayList<Float> yLegend=new ArrayList<Float>();
  if (mRoundedYLegend) {
    float interval=(mDeltaY) / (mYLegendCount - 1);
    double log10=Math.log10(interval);
    int exp=(int)Math.floor(log10);
    double tenPowExp=POW_10[exp + 5];
    double multi=Math.round(interval / tenPowExp);
    if (multi >= 1) {
      if (multi > 2 && multi < 5) {
        multi=5;
      }
 else       if (multi > 5 && multi < 10) {
        multi=10;
      }
    }
    float step=(float)(multi * tenPowExp);
    float min=mYChartMin;
    float val=0;
    if (step >= 1f) {
      val=(int)(mYChartMin / step) - step;
      mYChartMin=val;
    }
 else {
      val=mYChartMin;
    }
    if (mStartAtZero) {
      val=0;
      mYChartMin=0;
    }
 else {
      if (getYMin() >= 0 && this instanceof BarChart) {
        val=0;
        mYChartMin=0;
      }
    }
    while (val <= mDeltaY + step + min) {
      yLegend.add(val);
      val=val + step;
    }
    mDeltaY=val - step - mYChartMin;
  }
 else {
    float interval=(mDeltaY) / (mYLegendCount - 1);
    yLegend.add(mYChartMin);
    for (int i=1; i < mYLegendCount - 1; i++) {
      yLegend.add(mYChartMin + ((float)i * interval));
    }
    yLegend.add(mDeltaY + mYChartMin);
  }
  mYChartMax=yLegend.get(yLegend.size() - 1);
  mYLegend=yLegend.toArray(new Float[0]);
  Log.i(LOG_TAG,""String_Node_Str"" + mDeltaX + ""String_Node_Str""+ mDeltaY);
  Log.i(LOG_TAG,""String_Node_Str"" + mYChartMax + ""String_Node_Str""+ mYChartMin);
  Log.i(LOG_TAG,""String_Node_Str"" + getYMax() + ""String_Node_Str""+ getYMin());
}",0.5212765957446809
27049,"/** 
 * calcualtes the y-min and y-max value and the y-delta and x-delta value
 */
protected void calcMinMax(boolean fixedValues){
  if (!fixedValues) {
    mYChartMin=mData.getYMin();
    mYChartMax=mYChartMin + mData.getYMax();
  }
  mDeltaY=mData.getYMax() - mYChartMin;
  mDeltaX=mData.getXVals().size() - 1;
}","/** 
 * calcualtes the y-min and y-max value and the y-delta and x-delta value
 */
protected void calcMinMax(boolean fixedValues){
  if (!fixedValues) {
    mYChartMin=mData.getYMin();
    mYChartMax=mData.getYMax();
  }
  mDeltaY=Math.abs(mData.getYMax() - mData.getYMin());
  mDeltaX=mData.getXVals().size() - 1;
}",0.8666666666666667
27050,"/** 
 * calcualtes the y-min and y-max value and the y-delta and x-delta value
 */
protected void calcMinMax(boolean fixedValues){
  if (fixedValues) {
    mYChartMin=mData.getYMin();
    mYChartMax=mYChartMin + mData.getYMax();
  }
  mDeltaY=mData.getYMax() - mYChartMin;
  mDeltaX=mData.getXVals().size() - 1;
}","/** 
 * calcualtes the y-min and y-max value and the y-delta and x-delta value
 */
protected void calcMinMax(boolean fixedValues){
  if (!fixedValues) {
    mYChartMin=mData.getYMin();
    mYChartMax=mYChartMin + mData.getYMax();
  }
  mDeltaY=mData.getYMax() - mYChartMin;
  mDeltaX=mData.getXVals().size() - 1;
}",0.9984051036682616
27051,"private void initWithDummyData(){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < 148; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  DataSet set1=new DataSet(yVals,0);
  ArrayList<DataSet> dataSets=new ArrayList<DataSet>();
  dataSets.add(set1);
  ChartData data=new ChartData(xVals,dataSets);
  mChart.setData(data);
  mChart.setYRange(10f,40f);
  mChart.invalidate();
}","private void initWithDummyData(){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < 148; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  DataSet set1=new DataSet(yVals,0);
  ArrayList<DataSet> dataSets=new ArrayList<DataSet>();
  dataSets.add(set1);
  ChartData data=new ChartData(xVals,dataSets);
  mChart.setData(data);
  mChart.setYRangeFixed(false);
  mChart.setYRange(-40f,40f);
  mChart.invalidate();
}",0.960342979635584
27052,"@Override public void notifyDataSetChanged(){
  calcMinMax(mFixedYValues);
}","@Override public void notifyDataSetChanged(){
  if (!mFixedYValues) {
    prepare();
  }
 else {
    calcMinMax(mFixedYValues);
  }
}",0.7272727272727273
27053,"/** 
 * sets the effective range of y-values the chart can display
 * @param minY
 * @param maxY
 */
public void setYRange(float minY,float maxY){
  mFixedYValues=true;
  mYChartMin=minY;
  mYChartMax=maxY;
  mDeltaY=mYChartMax - mYChartMin;
  calcFormats();
  prepareMatrix();
  invalidate();
}","/** 
 * sets the effective range of y-values the chart can display
 * @param minY
 * @param maxY
 */
public void setYRange(float minY,float maxY){
  mYChartMin=minY;
  mYChartMax=maxY;
  if (minY < 0) {
    mStartAtZero=false;
  }
  mDeltaY=mYChartMax - mYChartMin;
  calcFormats();
  prepareMatrix();
  invalidate();
}",0.5211726384364821
27054,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setDrawYValues(false);
  mChart.setLineWidth(5f);
  mChart.setCircleSize(5f);
  mChart.setYLegendCount(6);
  mChart.setTouchEnabled(true);
  mChart.setHighlightEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setTouchEnabled(true);
  TextView textView=new TextView(this);
  textView.setVisibility(View.VISIBLE);
  textView.setBackgroundColor(Color.WHITE);
  textView.setPadding(15,15,15,15);
  textView.setText(""String_Node_Str"");
  mChart.setDrawMarkerView(true);
  mChart.setMarkerView(textView);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawYValues(false);
  mChart.setLineWidth(5f);
  mChart.setCircleSize(5f);
  mChart.setYLegendCount(6);
  mChart.setTouchEnabled(true);
  mChart.setHighlightEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setTouchEnabled(true);
  TextView textView=new TextView(this);
  textView.setVisibility(View.VISIBLE);
  textView.setBackgroundColor(Color.WHITE);
  textView.setPadding(15,15,15,15);
  textView.setText(""String_Node_Str"");
  mChart.setDrawMarkerView(true);
  mChart.setMarkerView(textView);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
}",0.9796782387806944
27055,"@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Series> yVals=new ArrayList<Series>();
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    float mult=(mSeekBarY.getProgress() + 1);
    float val=(float)(Math.random() * mult * 0.1) + 3;
    yVals.add(new Series(val,i));
  }
  tvX.setText(""String_Node_Str"" + (mSeekBarX.getProgress() + 1));
  tvY.setText(""String_Node_Str"" + (mSeekBarY.getProgress() / 10));
  DataSet set=new DataSet(yVals,0);
  ArrayList<DataSet> dataSets=new ArrayList<DataSet>();
  dataSets.add(set);
  ChartData data=new ChartData(xVals,dataSets);
  mChart.setData(data);
  mChart.invalidate();
}","@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Series> yVals=new ArrayList<Series>();
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    float mult=(mSeekBarY.getProgress() + 1);
    float val=(float)(Math.random() * mult * 0.1) + 3;
    yVals.add(new Series(val,i));
  }
  tvX.setText(""String_Node_Str"" + (mSeekBarX.getProgress() + 1));
  tvY.setText(""String_Node_Str"" + (mSeekBarY.getProgress() / 10));
  DataSet set1=new DataSet(yVals,0);
  ArrayList<DataSet> dataSets=new ArrayList<DataSet>();
  dataSets.add(set1);
  ChartData data=new ChartData(xVals,dataSets);
  mChart.setData(data);
  mChart.invalidate();
}",0.998780487804878
27056,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setDrawYValues(false);
  mChart.setLineWidth(4f);
  mChart.setCircleSize(4f);
  mChart.setYLegendCount(6);
  mChart.setTouchEnabled(true);
  mChart.setHighlightEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setTouchEnabled(true);
  TextView textView=new TextView(this);
  textView.setVisibility(View.VISIBLE);
  textView.setBackgroundColor(Color.WHITE);
  textView.setPadding(15,15,15,15);
  textView.setText(""String_Node_Str"");
  mChart.setDrawMarkerView(true);
  mChart.setMarkerView(textView);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setColorTemplate(new ColorTemplate(ColorTemplate.getColors(this,ColorTemplate.JOYFUL_COLORS)));
  mChart.setDrawTopYLegendEntry(false);
  mChart.setDrawYValues(false);
  mChart.setLineWidth(5f);
  mChart.setCircleSize(5f);
  mChart.setYLegendCount(6);
  mChart.setTouchEnabled(true);
  mChart.setHighlightEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setTouchEnabled(true);
  TextView textView=new TextView(this);
  textView.setVisibility(View.VISIBLE);
  textView.setBackgroundColor(Color.WHITE);
  textView.setPadding(15,15,15,15);
  textView.setText(""String_Node_Str"");
  mChart.setDrawMarkerView(true);
  mChart.setMarkerView(textView);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
}",0.9345262301748678
27057,"/** 
 * draws the circle value indicators
 */
@Override protected void drawAdditional(){
  if (mDrawCircles) {
    ArrayList<DataSet> dataSets=mData.getDataSets();
    for (int i=0; i < mData.getDataSetCount(); i++) {
      DataSet dataSet=dataSets.get(i);
      ArrayList<Series> series=dataSet.getYVals();
      float[] positions=new float[dataSet.getYValCount() * 2];
      for (int j=0; j < positions.length; j+=2) {
        positions[j]=series.get(j / 2).getXIndex();
        positions[j + 1]=series.get(j / 2).getVal();
      }
      transformPointArray(positions);
      for (int j=0; j < positions.length; j+=2) {
        if (positions[j] < mContentRect.left || positions[j] > mContentRect.right)         continue;
        mDrawCanvas.drawCircle(positions[j],positions[j + 1],mCircleSize,mCirclePaintOuter);
        mDrawCanvas.drawCircle(positions[j],positions[j + 1],mCircleSize / 2,mCirclePaintInner);
      }
    }
  }
}","/** 
 * draws the circle value indicators
 */
@Override protected void drawAdditional(){
  if (mDrawCircles) {
    ArrayList<DataSet> dataSets=mData.getDataSets();
    for (int i=0; i < mData.getDataSetCount(); i++) {
      DataSet dataSet=dataSets.get(i);
      ArrayList<Series> series=dataSet.getYVals();
      float[] positions=new float[dataSet.getYValCount() * 2];
      for (int j=0; j < positions.length; j+=2) {
        positions[j]=series.get(j / 2).getXIndex();
        positions[j + 1]=series.get(j / 2).getVal();
      }
      transformPointArray(positions);
      for (int j=0; j < positions.length; j+=2) {
        if (positions[j] < mContentRect.left || positions[j] > mContentRect.right)         continue;
        mDrawCanvas.drawCircle(positions[j],positions[j + 1],mCircleSize,mDrawPaints[i % mDrawPaints.length]);
        mDrawCanvas.drawCircle(positions[j],positions[j + 1],mCircleSize / 2,mCirclePaintInner);
      }
    }
  }
}",0.9787460148777896
27058,"@Override protected void prepareDataPaints(ColorTemplate ct){
  if (ct == null)   return;
  mDrawPaints=new Paint[ct.getColors().size()];
  for (int i=0; i < ct.getColors().size(); i++) {
    mDrawPaints[i]=new Paint(Paint.ANTI_ALIAS_FLAG);
    mDrawPaints[i].setStrokeWidth(mLineWidth);
    mDrawPaints[i].setStyle(Style.STROKE);
    mDrawPaints[i].setColor(ct.getColors().get(i));
  }
}","@Override protected void prepareDataPaints(ColorTemplate ct){
  if (ct == null)   return;
  mDrawPaints=new Paint[ct.getColors().size()];
  for (int i=0; i < ct.getColors().size(); i++) {
    mDrawPaints[i]=new Paint(Paint.ANTI_ALIAS_FLAG);
    mDrawPaints[i].setStrokeWidth(mLineWidth);
    mDrawPaints[i].setStyle(Style.FILL);
    mDrawPaints[i].setColor(ct.getColors().get(i));
  }
}",0.9870801033591732
27059,"/** 
 * returns the color value at the given index from the DataSet at the given index
 * @param dataSetIndex
 * @param colorIndex
 * @return
 */
public int getDataSetColor(int dataSetIndex,int colorIndex){
  return mDataSetColors.get(dataSetIndex).get(colorIndex);
}","/** 
 * Returns the color value at the given index from the DataSet at the given index. If index is outofbounds, it restart at lower indices.
 * @param dataSetIndex
 * @param colorIndex
 * @return
 */
public int getDataSetColor(int dataSetIndex,int colorIndex){
  return mDataSetColors.get(dataSetIndex).get(colorIndex % mDataSetColors.get(dataSetIndex).size());
}",0.8431061806656102
27060,"@Override protected void drawHighlights(){
  if (mHighlightEnabled && valuesToHighlight()) {
    float angle=0f;
    for (int i=0; i < mIndicesToHightlight.length; i++) {
      int index=mIndicesToHightlight[i].getXIndex();
      if (index >= mDrawAngles.length || index > mDeltaX)       continue;
      if (index == 0)       angle=mChartAngle;
 else       angle=mChartAngle + mAbsoluteAngles[index - 1];
      float sliceDegrees=mDrawAngles[index];
      float shiftangle=(float)Math.toRadians(angle + sliceDegrees / 2f);
      float xShift=mShift * (float)Math.cos(shiftangle);
      float yShift=mShift * (float)Math.sin(shiftangle);
      RectF highlighted=new RectF(mCircleBox.left + xShift,mCircleBox.top + yShift,mCircleBox.right + xShift,mCircleBox.bottom + yShift);
      ArrayList<Integer> colors=mCt.getDataSetColors(mIndicesToHightlight[i].getDataSetIndex());
      mRenderPaint.setColor(colors.get(index % colors.size()));
      mDrawCanvas.drawArc(highlighted,angle,sliceDegrees,true,mRenderPaint);
    }
  }
}","@Override protected void drawHighlights(){
  if (mHighlightEnabled && valuesToHighlight()) {
    float angle=0f;
    for (int i=0; i < mIndicesToHightlight.length; i++) {
      int xIndex=mIndicesToHightlight[i].getXIndex();
      if (xIndex >= mDrawAngles.length || xIndex > mDeltaX)       continue;
      if (xIndex == 0)       angle=mChartAngle;
 else       angle=mChartAngle + mAbsoluteAngles[xIndex - 1];
      float sliceDegrees=mDrawAngles[xIndex];
      float shiftangle=(float)Math.toRadians(angle + sliceDegrees / 2f);
      float xShift=mShift * (float)Math.cos(shiftangle);
      float yShift=mShift * (float)Math.sin(shiftangle);
      RectF highlighted=new RectF(mCircleBox.left + xShift,mCircleBox.top + yShift,mCircleBox.right + xShift,mCircleBox.bottom + yShift);
      DataSet set=mData.getDataSetByIndex(mIndicesToHightlight[i].getDataSetIndex());
      int color=mCt.getDataSetColor(mIndicesToHightlight[i].getDataSetIndex(),set.getIndexInSeries(xIndex));
      mRenderPaint.setColor(color);
      mDrawCanvas.drawArc(highlighted,angle,sliceDegrees,true,mRenderPaint);
    }
  }
}",0.908662900188324
27061,"@Override protected void drawData(){
  float angle=mChartAngle;
  ArrayList<DataSet> dataSets=mData.getDataSets();
  int cnt=0;
  for (int i=0; i < mData.getDataSetCount(); i++) {
    DataSet dataSet=dataSets.get(i);
    ArrayList<Series> series=dataSet.getYVals();
    ArrayList<Integer> colors=mCt.getDataSetColors(i % mCt.getColors().size());
    for (int j=0; j < series.size(); j++) {
      mRenderPaint.setColor(colors.get(j % colors.size()));
      float newangle=mDrawAngles[cnt];
      if (!needsHighlight(series.get(j).getXIndex(),i)) {
        mDrawCanvas.drawArc(mCircleBox,angle,newangle,true,mRenderPaint);
      }
      angle+=newangle;
      cnt++;
    }
  }
}","@Override protected void drawData(){
  float angle=mChartAngle;
  ArrayList<DataSet> dataSets=mData.getDataSets();
  int cnt=0;
  for (int i=0; i < mData.getDataSetCount(); i++) {
    DataSet dataSet=dataSets.get(i);
    ArrayList<Series> series=dataSet.getYVals();
    ArrayList<Integer> colors=mCt.getDataSetColors(i % mCt.getColors().size());
    for (int j=0; j < series.size(); j++) {
      float newangle=mDrawAngles[cnt];
      if (!needsHighlight(series.get(j).getXIndex(),i)) {
        mRenderPaint.setColor(colors.get(j % colors.size()));
        mDrawCanvas.drawArc(mCircleBox,angle,newangle,true,mRenderPaint);
      }
      angle+=newangle;
      cnt++;
    }
  }
}",0.9098966026587888
27062,"@Override protected void drawHighlights(){
  if (mHighlightEnabled && valuesToHighlight()) {
    float offsetY=mDeltaY * 0.04f;
    for (int i=0; i < mIndicesToHightlight.length; i++) {
      int index=mIndicesToHightlight[i];
      if (index < mYVals.size()) {
        mHighlightPaint.setAlpha(120);
        float y=mYVals.get(index).getVal();
        float left=index + mBarSpace / 2f;
        float right=index + 1f - mBarSpace / 2f;
        float top=y >= 0 ? y : 0;
        float bottom=y <= 0 ? y : 0;
        RectF highlight=new RectF(left,top,right,bottom);
        transformRect(highlight);
        mDrawCanvas.drawRect(highlight,mHighlightPaint);
        if (mDrawHighlightArrow) {
          mHighlightPaint.setAlpha(200);
          Path arrow=new Path();
          arrow.moveTo(index + 0.5f,y + offsetY * 0.3f);
          arrow.lineTo(index + 0.2f,y + offsetY);
          arrow.lineTo(index + 0.8f,y + offsetY);
          transformPath(arrow);
          mDrawCanvas.drawPath(arrow,mHighlightPaint);
        }
      }
    }
  }
}","@Override protected void drawHighlights(){
  if (mHighlightEnabled && valuesToHighlight()) {
    float offsetY=mDeltaY * 0.04f;
    for (int i=0; i < mIndicesToHightlight.length; i++) {
      int index=mIndicesToHightlight[i];
      if (index < mYVals.size() && index >= 0) {
        mHighlightPaint.setAlpha(120);
        float y=mYVals.get(index).getVal();
        float left=index + mBarSpace / 2f;
        float right=index + 1f - mBarSpace / 2f;
        float top=y >= 0 ? y : 0;
        float bottom=y <= 0 ? y : 0;
        RectF highlight=new RectF(left,top,right,bottom);
        transformRect(highlight);
        mDrawCanvas.drawRect(highlight,mHighlightPaint);
        if (mDrawHighlightArrow) {
          mHighlightPaint.setAlpha(200);
          Path arrow=new Path();
          arrow.moveTo(index + 0.5f,y + offsetY * 0.3f);
          arrow.lineTo(index + 0.2f,y + offsetY);
          arrow.lineTo(index + 0.8f,y + offsetY);
          transformPath(arrow);
          mDrawCanvas.drawPath(arrow,mHighlightPaint);
        }
      }
    }
  }
}",0.9933078393881452
27063,"/** 
 * returns the index of the value (on the x-axis) for the given touch point
 * @param x
 * @param y
 * @return
 */
public int getIndexByTouchPoint(float x,float y){
  float[] pts=new float[2];
  pts[0]=x;
  pts[1]=y;
  Matrix tmp=new Matrix();
  mMatrixOffset.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixTouch.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixValueToPx.invert(tmp);
  tmp.mapPoints(pts);
  double touchPointIndex=pts[0];
  double base=Math.floor(touchPointIndex);
  int index=(int)base;
  if (this instanceof LineChart) {
    if (touchPointIndex - base > 0.5) {
      index=(int)base + 1;
    }
  }
  return index;
}","/** 
 * returns the index of the value (on the x-axis) for the given touch point
 * @param x
 * @param y
 * @return
 */
public int getIndexByTouchPoint(float x,float y){
  float[] pts=new float[2];
  pts[0]=x;
  pts[1]=y;
  Matrix tmp=new Matrix();
  mMatrixOffset.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixTouch.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixValueToPx.invert(tmp);
  tmp.mapPoints(pts);
  double touchPointIndex=pts[0];
  double base=Math.floor(touchPointIndex);
  if (touchPointIndex < 0 || touchPointIndex > getValueCount() - 1)   return -1;
  int index=(int)base;
  if (this instanceof LineChart) {
    if (touchPointIndex - base > 0.5) {
      index=(int)base + 1;
    }
  }
  return index;
}",0.9397769516728623
27064,"/** 
 * returns the x-value at the given index
 * @param index
 * @return
 */
public String getXValue(int index){
  if (mXVals == null || mXVals.size() >= index)   return null;
 else   return mXVals.get(index);
}","/** 
 * returns the x-value at the given index
 * @param index
 * @return
 */
public String getXValue(int index){
  if (mXVals == null || mXVals.size() <= index)   return null;
 else   return mXVals.get(index);
}",0.9952830188679244
27065,"/** 
 * returns true if there are values to highlight, false if there are not checks if the highlight array is null, has a length of zero or contains -1
 * @return
 */
public boolean valuesToHighlight(){
  return mIndicesToHightlight == null || mIndicesToHightlight.length == 0 || mIndicesToHightlight[0] == -1 ? false : true;
}","/** 
 * returns true if there are values to highlight, false if there are not checks if the highlight array is null, has a length of zero or contains -1
 * @return
 */
public boolean valuesToHighlight(){
  return mIndicesToHightlight == null || mIndicesToHightlight.length == 0 || mIndicesToHightlight[0] < 0 ? false : true;
}",0.9877675840978594
27066,"@Override protected void drawHighlights(){
  if (mHighlightEnabled && valuesToHighlight()) {
    for (int i=0; i < mIndicesToHightlight.length; i++) {
      int index=mIndicesToHightlight[i];
      if (index < mYVals.size()) {
        float[] pts=new float[]{index,mYChartMax,index,mYChartMin,0,mYVals.get(index).getVal(),mDeltaX,mYVals.get(index).getVal()};
        transformPointArray(pts);
        mDrawCanvas.drawLines(pts,mHighlightPaint);
      }
    }
  }
}","@Override protected void drawHighlights(){
  if (mHighlightEnabled && valuesToHighlight()) {
    for (int i=0; i < mIndicesToHightlight.length; i++) {
      int index=mIndicesToHightlight[i];
      if (index < mYVals.size() && index >= 0) {
        float[] pts=new float[]{index,mYChartMax,index,mYChartMin,0,mYVals.get(index).getVal(),mDeltaX,mYVals.get(index).getVal()};
        transformPointArray(pts);
        mDrawCanvas.drawLines(pts,mHighlightPaint);
      }
    }
  }
}",0.9851380042462844
27067,"@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Series> yVals=new ArrayList<Series>();
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    float mult=(mSeekBarY.getProgress() + 1);
    float val=(float)(Math.random() * mult * 0.1) + 3;
    yVals.add(new Series(val,i));
  }
  tvX.setText(""String_Node_Str"" + (mSeekBarX.getProgress() + 1));
  tvY.setText(""String_Node_Str"" + (mSeekBarY.getProgress() / 10));
  DataSet set=new DataSet(yVals,0);
  ArrayList<DataSet> dataSets=new ArrayList<DataSet>();
  dataSets.add(set);
  ChartData data=new ChartData(xVals,dataSets);
  mChart.setData(data);
  mChart.invalidate();
}","@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Series> yVals1=new ArrayList<Series>();
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    float mult=(mSeekBarY.getProgress() + 1);
    float val=(float)(Math.random() * mult * 0.1) + 3;
    yVals1.add(new Series(val,i));
  }
  tvX.setText(""String_Node_Str"" + (mSeekBarX.getProgress() + 1));
  tvY.setText(""String_Node_Str"" + (mSeekBarY.getProgress() / 10));
  DataSet set1=new DataSet(yVals1,0);
  ArrayList<DataSet> dataSets=new ArrayList<DataSet>();
  dataSets.add(set1);
  ChartData data=new ChartData(xVals,dataSets);
  mChart.setData(data);
  mChart.invalidate();
}",0.996956786366403
27068,"@Override protected void drawData(){
  ArrayList<Path> topPaths=new ArrayList<Path>();
  ArrayList<Path> sidePaths=new ArrayList<Path>();
  if (m3DEnabled) {
    float[] pts=new float[]{0f,0f,1f,0f};
    transformPointArray(pts);
    pts[3]=pts[2] - pts[0];
    pts[2]=0f;
    pts[1]=0f;
    pts[0]=0f;
    Matrix invert=new Matrix();
    mMatrixOffset.invert(invert);
    invert.mapPoints(pts);
    mMatrixTouch.invert(invert);
    invert.mapPoints(pts);
    mMatrixValueToPx.invert(invert);
    invert.mapPoints(pts);
    float depth=Math.abs(pts[3] - pts[1]) * mDepth;
    for (int i=0; i < mData.getYValCount(); i++) {
      float y=getYValue(i);
      float left=i + mBarSpace / 2f;
      float right=i + 1f - mBarSpace / 2f;
      float top=y >= 0 ? y : 0;
      Path topPath=new Path();
      topPath.moveTo(left,top);
      topPath.lineTo(left + mSkew,top + depth);
      topPath.lineTo(right + mSkew,top + depth);
      topPath.lineTo(right,top);
      topPaths.add(topPath);
      Path sidePath=new Path();
      sidePath.moveTo(right,top);
      sidePath.lineTo(right + mSkew,top + depth);
      sidePath.lineTo(right + mSkew,depth);
      sidePath.lineTo(right,0);
      sidePaths.add(sidePath);
    }
    transformPaths(topPaths);
    transformPaths(sidePaths);
  }
  ArrayList<DataSet> dataSets=mData.getDataSets();
  for (int i=0; i < mData.getDataSetCount(); i++) {
    DataSet dataSet=dataSets.get(i);
    ArrayList<Series> series=dataSet.getYVals();
    for (int j=0; j < dataSet.getSeriesCount(); j++) {
      Paint paint=mDrawPaints[j % mDrawPaints.length];
      int x=series.get(j).getXIndex();
      float y=series.get(j).getVal();
      float left=x + mBarSpace / 2f;
      float right=x + 1f - mBarSpace / 2f;
      float top=y >= 0 ? y : 0;
      float bottom=y <= 0 ? y : 0;
      mBarRect.set(left,top,right,bottom);
      transformRect(mBarRect);
      mDrawCanvas.drawRect(mBarRect,paint);
      if (m3DEnabled) {
        int c=paint.getColor();
        paint.setColor(mTopColors[j % mTopColors.length]);
        mDrawCanvas.drawPath(topPaths.get(j),paint);
        paint.setColor(mSideColors[j % mSideColors.length]);
        mDrawCanvas.drawPath(sidePaths.get(j),paint);
        paint.setColor(c);
      }
    }
  }
}","@Override protected void drawData(){
  ArrayList<Path> topPaths=new ArrayList<Path>();
  ArrayList<Path> sidePaths=new ArrayList<Path>();
  if (m3DEnabled) {
    float[] pts=new float[]{0f,0f,1f,0f};
    transformPointArray(pts);
    pts[3]=pts[2] - pts[0];
    pts[2]=0f;
    pts[1]=0f;
    pts[0]=0f;
    Matrix invert=new Matrix();
    mMatrixOffset.invert(invert);
    invert.mapPoints(pts);
    mMatrixTouch.invert(invert);
    invert.mapPoints(pts);
    mMatrixValueToPx.invert(invert);
    invert.mapPoints(pts);
    float depth=Math.abs(pts[3] - pts[1]) * mDepth;
    for (int i=0; i < mData.getYValCount(); i++) {
      float y=getYValue(i);
      float left=i + mBarSpace / 2f;
      float right=i + 1f - mBarSpace / 2f;
      float top=y >= 0 ? y : 0;
      Path topPath=new Path();
      topPath.moveTo(left,top);
      topPath.lineTo(left + mSkew,top + depth);
      topPath.lineTo(right + mSkew,top + depth);
      topPath.lineTo(right,top);
      topPaths.add(topPath);
      Path sidePath=new Path();
      sidePath.moveTo(right,top);
      sidePath.lineTo(right + mSkew,top + depth);
      sidePath.lineTo(right + mSkew,depth);
      sidePath.lineTo(right,0);
      sidePaths.add(sidePath);
    }
    transformPaths(topPaths);
    transformPaths(sidePaths);
  }
  ArrayList<DataSet> dataSets=mData.getDataSets();
  for (int i=0; i < mData.getDataSetCount(); i++) {
    DataSet dataSet=dataSets.get(i);
    ArrayList<Series> series=dataSet.getYVals();
    Paint paint=mDrawPaints[i % mDrawPaints.length];
    for (int j=0; j < dataSet.getSeriesCount(); j++) {
      if (mData.getDataSetCount() == 1)       paint=mDrawPaints[j % mDrawPaints.length];
      int x=series.get(j).getXIndex();
      float y=series.get(j).getVal();
      float left=x + mBarSpace / 2f;
      float right=x + 1f - mBarSpace / 2f;
      float top=y >= 0 ? y : 0;
      float bottom=y <= 0 ? y : 0;
      mBarRect.set(left,top,right,bottom);
      transformRect(mBarRect);
      mDrawCanvas.drawRect(mBarRect,paint);
      if (m3DEnabled) {
        int c=paint.getColor();
        paint.setColor(mTopColors[j % mTopColors.length]);
        mDrawCanvas.drawPath(topPaths.get(j),paint);
        paint.setColor(mSideColors[j % mSideColors.length]);
        mDrawCanvas.drawPath(sidePaths.get(j),paint);
        paint.setColor(c);
      }
    }
  }
}",0.978844056706652
27069,"@Override protected void drawHighlights(){
  if (mHighlightEnabled && valuesToHighlight()) {
    float offsetY=mDeltaY * 0.04f;
    for (int i=0; i < mIndicesToHightlight.length; i++) {
      int index=mIndicesToHightlight[i].getXIndex();
      if (index < mData.getYValCount() && index >= 0) {
        mHighlightPaint.setAlpha(120);
        float y=getYValue(index);
        float left=index + mBarSpace / 2f;
        float right=index + 1f - mBarSpace / 2f;
        float top=y >= 0 ? y : 0;
        float bottom=y <= 0 ? y : 0;
        RectF highlight=new RectF(left,top,right,bottom);
        transformRect(highlight);
        mDrawCanvas.drawRect(highlight,mHighlightPaint);
        if (mDrawHighlightArrow) {
          mHighlightPaint.setAlpha(200);
          Path arrow=new Path();
          arrow.moveTo(index + 0.5f,y + offsetY * 0.3f);
          arrow.lineTo(index + 0.2f,y + offsetY);
          arrow.lineTo(index + 0.8f,y + offsetY);
          transformPath(arrow);
          mDrawCanvas.drawPath(arrow,mHighlightPaint);
        }
      }
    }
  }
}","@Override protected void drawHighlights(){
  if (mHighlightEnabled && valuesToHighlight()) {
    float offsetY=mDeltaY * 0.04f;
    for (int i=0; i < mIndicesToHightlight.length; i++) {
      int index=mIndicesToHightlight[i].getXIndex();
      if (index < mData.getYValCount() && index >= 0) {
        mHighlightPaint.setAlpha(120);
        float y=getYValueByDataSetIndex(index,mIndicesToHightlight[i].getDataSetIndex());
        float left=index + mBarSpace / 2f;
        float right=index + 1f - mBarSpace / 2f;
        float top=y >= 0 ? y : 0;
        float bottom=y <= 0 ? y : 0;
        RectF highlight=new RectF(left,top,right,bottom);
        transformRect(highlight);
        mDrawCanvas.drawRect(highlight,mHighlightPaint);
        if (mDrawHighlightArrow) {
          mHighlightPaint.setAlpha(200);
          Path arrow=new Path();
          arrow.moveTo(index + 0.5f,y + offsetY * 0.3f);
          arrow.lineTo(index + 0.2f,y + offsetY);
          arrow.lineTo(index + 0.8f,y + offsetY);
          transformPath(arrow);
          mDrawCanvas.drawPath(arrow,mHighlightPaint);
        }
      }
    }
  }
}",0.9724770642201837
27070,"/** 
 * returns the Highlight object (x index and DataSet index) of the selected value at the given touch point
 * @param x
 * @param y
 * @return
 */
public Highlight getIndexByTouchPoint(float x,float y){
  float[] pts=new float[2];
  pts[0]=x;
  pts[1]=y;
  Matrix tmp=new Matrix();
  mMatrixOffset.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixTouch.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixValueToPx.invert(tmp);
  tmp.mapPoints(pts);
  double xTouchVal=pts[0];
  double yTouchVal=pts[1];
  double base=Math.floor(xTouchVal);
  Log.i(LOG_TAG,""String_Node_Str"" + xTouchVal + ""String_Node_Str""+ yTouchVal);
  if (this instanceof LineChart && (xTouchVal < 0 || xTouchVal > mDeltaX))   return null;
  if (this instanceof BarChart && (xTouchVal < 0 || xTouchVal > mDeltaX + 1))   return null;
  int xIndex=(int)base;
  int yIndex=0;
  if (this instanceof LineChart) {
    if (xTouchVal - base > 0.5) {
      xIndex=(int)base + 1;
    }
  }
  ArrayList<Float> valsAtIndex=getYValsAtIndex(xIndex);
  yIndex=getClosestDataSetIndex(valsAtIndex,(float)yTouchVal);
  if (yIndex == -1)   return null;
  return new Highlight(xIndex,yIndex);
}","/** 
 * returns the Highlight object (x index and DataSet index) of the selected value at the given touch point
 * @param x
 * @param y
 * @return
 */
public Highlight getIndexByTouchPoint(float x,float y){
  float[] pts=new float[2];
  pts[0]=x;
  pts[1]=y;
  Matrix tmp=new Matrix();
  mMatrixOffset.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixTouch.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixValueToPx.invert(tmp);
  tmp.mapPoints(pts);
  double xTouchVal=pts[0];
  double yTouchVal=pts[1];
  double base=Math.floor(xTouchVal);
  Log.i(LOG_TAG,""String_Node_Str"" + xTouchVal + ""String_Node_Str""+ yTouchVal);
  if (this instanceof LineChart && (xTouchVal < 0 || xTouchVal > mDeltaX))   return null;
  if (this instanceof BarChart && (xTouchVal < 0 || xTouchVal > mDeltaX + 1))   return null;
  int xIndex=(int)base;
  int yIndex=0;
  if (this instanceof LineChart) {
    if (xTouchVal - base > 0.5) {
      xIndex=(int)base + 1;
    }
  }
  ArrayList<SelInfo> valsAtIndex=getYValsAtIndex(xIndex);
  yIndex=getClosestDataSetIndex(valsAtIndex,(float)yTouchVal);
  if (yIndex == -1)   return null;
  return new Highlight(xIndex,yIndex);
}",0.9947183098591548
27071,"/** 
 * returns the index DataSet that contains the closest value    
 * @param valsAtIndex
 * @return
 */
private int getClosestDataSetIndex(ArrayList<Float> valsAtIndex,float val){
  int index=-1;
  float distance=Float.MAX_VALUE;
  for (int c=0; c < valsAtIndex.size(); c++) {
    float cdistance=Math.abs((float)valsAtIndex.get(c) - val);
    if (cdistance < distance) {
      index=c;
      distance=cdistance;
    }
  }
  Log.i(LOG_TAG,""String_Node_Str"" + index);
  return index;
}","/** 
 * returns the index DataSet that contains the closest value    
 * @param valsAtIndex
 * @return
 */
private int getClosestDataSetIndex(ArrayList<SelInfo> valsAtIndex,float val){
  int index=-1;
  float distance=Float.MAX_VALUE;
  for (int i=0; i < valsAtIndex.size(); i++) {
    float cdistance=Math.abs((float)valsAtIndex.get(i).val - val);
    if (cdistance < distance) {
      index=valsAtIndex.get(i).dataSetIndex;
      distance=cdistance;
    }
  }
  Log.i(LOG_TAG,""String_Node_Str"" + index);
  return index;
}",0.9425742574257424
27072,"/** 
 * returns the y-value for the given x-index and DataSet index
 * @param index
 * @param dataSet
 * @return
 */
public float getYValueByDataSetIndex(int index,int dataSet){
  DataSet set=mData.getDataSetByIndex(dataSet);
  return set.getYVals().get(index).getVal();
}","/** 
 * returns the y-value for the given x-index and DataSet index
 * @param index
 * @param dataSet
 * @return
 */
public float getYValueByDataSetIndex(int xIndex,int dataSet){
  DataSet set=mData.getDataSetByIndex(dataSet);
  return set.getYValForXIndex(xIndex);
}",0.927643784786642
27073,"/** 
 * Get the y-values from the Series object at the given index across all DataSets. INFORMATION: This method does calculations at runtime. Do not over-use in performance critical situations.
 * @param xIndex
 * @return
 */
public ArrayList<Float> getYValsAtIndex(int xIndex){
  ArrayList<Float> vals=new ArrayList<Float>();
  for (int i=0; i < mData.getDataSetCount(); i++) {
    float yVal=mData.getDataSetByIndex(i).getYValForXIndex(xIndex);
    if (!Float.isNaN(yVal))     vals.add(yVal);
  }
  return vals;
}","/** 
 * Returns an array of SelInfo objects for the given x-index. The SelInfo objects give information about the value at the selected index and the DataSet it belongs to. INFORMATION: This method does calculations at runtime. Do not over-use in performance critical situations.
 * @param xIndex
 * @return
 */
protected ArrayList<SelInfo> getYValsAtIndex(int xIndex){
  ArrayList<SelInfo> vals=new ArrayList<SelInfo>();
  for (int i=0; i < mData.getDataSetCount(); i++) {
    float yVal=mData.getDataSetByIndex(i).getYValForXIndex(xIndex);
    if (!Float.isNaN(yVal)) {
      vals.add(new SelInfo(yVal,i));
    }
  }
  return vals;
}",0.7715030408340573
27074,"/** 
 * Returns the Series object at the given xIndex. INFORMATION: This method does calculations at runtime. Do not over-use in performance critical situations.
 * @param xIndex
 * @return
 */
public Series getSeriesForXIndex(int xIndex){
  for (int i=0; i < mYVals.size(); i++) {
    if (xIndex == mYVals.get(i).getXIndex())     return mYVals.get(i);
  }
  return null;
}","/** 
 * Returns the Series object at the given xIndex. Returns null if no Series object at that index. INFORMATION: This method does calculations at runtime. Do not over-use in performance critical situations.
 * @param xIndex
 * @return
 */
public Series getSeriesForXIndex(int xIndex){
  for (int i=0; i < mYVals.size(); i++) {
    if (xIndex == mYVals.get(i).getXIndex())     return mYVals.get(i);
  }
  return null;
}",0.9395465994962215
27075,"public int getType(){
  return mType;
}","/** 
 * returns the type of the DataSet, specified via constructor
 * @return
 */
public int getType(){
  return mType;
}",0.4875
27076,"public float getYMax(){
  return mYMax;
}","/** 
 * returns the maximum y-value this DataSet holds
 * @return
 */
public float getYMax(){
  return mYMax;
}",0.5394736842105263
27077,"public float getYMin(){
  return mYMin;
}","/** 
 * returns the minimum y-value this DataSet holds
 * @return
 */
public float getYMin(){
  return mYMin;
}",0.5394736842105263
27078,"public ArrayList<Series> getYVals(){
  return mYVals;
}","/** 
 * returns the DataSets Series array
 * @return
 */
public ArrayList<Series> getYVals(){
  return mYVals;
}",0.6586826347305389
27079,"public float getYValueSum(){
  return mYValueSum;
}","/** 
 * gets the sum of all y-values
 * @return
 */
public float getYValueSum(){
  return mYValueSum;
}",0.6623376623376623
27080,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  ColorTemplate ct=new ColorTemplate();
  ct.addDataSetColors(ColorTemplate.FRESH_COLORS,this);
  ct.addDataSetColors(new int[]{R.color.liberty_2},this);
  ct.addDataSetColors(ColorTemplate.COLORFUL_COLORS,this);
  mChart.setColorTemplate(ct);
  mChart.setDrawYValues(false);
  mChart.set3DEnabled(false);
  mChart.setYLegendCount(5);
  mChart.setTouchEnabled(true);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  ColorTemplate ct=new ColorTemplate();
  ct.addDataSetColors(ColorTemplate.FRESH_COLORS,this);
  ct.addDataSetColors(new int[]{R.color.liberty_2},this);
  ct.addDataSetColors(ColorTemplate.COLORFUL_COLORS,this);
  mChart.setColorTemplate(ct);
  mChart.setDrawYValues(false);
  mChart.set3DEnabled(false);
  mChart.setYLegendCount(5);
  mChart.setTouchEnabled(true);
  mChart.setDescription(""String_Node_Str"");
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
}",0.9786407766990292
27081,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_piechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(PieChart)findViewById(R.id.chart1);
  ColorTemplate ct=new ColorTemplate();
  ct.addDataSetColors(ColorTemplate.COLORFUL_COLORS,this);
  ct.addDataSetColors(ColorTemplate.LIBERTY_COLORS,this);
  mChart.setColorTemplate(ct);
  mChart.setDrawYValues(true);
  mChart.setDrawCenterText(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawHoleEnabled(true);
  mChart.setDrawXValues(true);
  mChart.setTouchEnabled(true);
  mChart.setUsePercentValues(false);
  mChart.setOnChartValueSelectedListener(this);
  mSeekBarX.setProgress(10);
  mSeekBarY.setProgress(100);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_piechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(PieChart)findViewById(R.id.chart1);
  ColorTemplate ct=new ColorTemplate();
  ct.addDataSetColors(ColorTemplate.COLORFUL_COLORS,this);
  ct.addDataSetColors(ColorTemplate.FRESH_COLORS,this);
  mChart.setColorTemplate(ct);
  mChart.setDrawYValues(true);
  mChart.setDrawCenterText(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawHoleEnabled(true);
  mChart.setDrawXValues(true);
  mChart.setTouchEnabled(true);
  mChart.setUsePercentValues(false);
  mChart.setOnChartValueSelectedListener(this);
  mSeekBarX.setProgress(10);
  mSeekBarY.setProgress(100);
}",0.9955357142857144
27082,"@Override protected void drawData(){
  ArrayList<Path> topPaths=new ArrayList<Path>();
  ArrayList<Path> sidePaths=new ArrayList<Path>();
  if (m3DEnabled) {
    float[] pts=new float[]{0f,0f,1f,0f};
    transformPointArray(pts);
    pts[3]=pts[2] - pts[0];
    pts[2]=0f;
    pts[1]=0f;
    pts[0]=0f;
    Matrix invert=new Matrix();
    mMatrixOffset.invert(invert);
    invert.mapPoints(pts);
    mMatrixTouch.invert(invert);
    invert.mapPoints(pts);
    mMatrixValueToPx.invert(invert);
    invert.mapPoints(pts);
    float depth=Math.abs(pts[3] - pts[1]) * mDepth;
    for (int i=0; i < mData.getYValCount(); i++) {
      float y=getYValue(i);
      float left=i + mBarSpace / 2f;
      float right=i + 1f - mBarSpace / 2f;
      float top=y >= 0 ? y : 0;
      Path topPath=new Path();
      topPath.moveTo(left,top);
      topPath.lineTo(left + mSkew,top + depth);
      topPath.lineTo(right + mSkew,top + depth);
      topPath.lineTo(right,top);
      topPaths.add(topPath);
      Path sidePath=new Path();
      sidePath.moveTo(right,top);
      sidePath.lineTo(right + mSkew,top + depth);
      sidePath.lineTo(right + mSkew,depth);
      sidePath.lineTo(right,0);
      sidePaths.add(sidePath);
    }
    transformPaths(topPaths);
    transformPaths(sidePaths);
  }
  ArrayList<DataSet> dataSets=mData.getDataSets();
  for (int i=0; i < mData.getDataSetCount(); i++) {
    DataSet dataSet=dataSets.get(i);
    ArrayList<Series> series=dataSet.getYVals();
    ArrayList<Integer> colors=mCt.getDataSetColors(i % mCt.getColors().size());
    for (int j=0; j < dataSet.getSeriesCount(); j++) {
      mRenderPaint.setColor(colors.get(j % colors.size()));
      int x=series.get(j).getXIndex();
      float y=series.get(j).getVal();
      float left=x + mBarSpace / 2f;
      float right=x + 1f - mBarSpace / 2f;
      float top=y >= 0 ? y : 0;
      float bottom=y <= 0 ? y : 0;
      mBarRect.set(left,top,right,bottom);
      transformRect(mBarRect);
      mDrawCanvas.drawRect(mBarRect,mRenderPaint);
      if (m3DEnabled) {
        int c=mRenderPaint.getColor();
        mRenderPaint.setColor(mTopColors[j % mTopColors.length]);
        mDrawCanvas.drawPath(topPaths.get(j),mRenderPaint);
        mRenderPaint.setColor(mSideColors[j % mSideColors.length]);
        mDrawCanvas.drawPath(sidePaths.get(j),mRenderPaint);
        mRenderPaint.setColor(c);
      }
    }
  }
}","@Override protected void drawData(){
  ArrayList<Path> topPaths=new ArrayList<Path>();
  ArrayList<Path> sidePaths=new ArrayList<Path>();
  ArrayList<DataSet> dataSets=mData.getDataSets();
  if (m3DEnabled) {
    float[] pts=new float[]{0f,0f,1f,0f};
    transformPointArray(pts);
    pts[3]=pts[2] - pts[0];
    pts[2]=0f;
    pts[1]=0f;
    pts[0]=0f;
    Matrix invert=new Matrix();
    mMatrixOffset.invert(invert);
    invert.mapPoints(pts);
    mMatrixTouch.invert(invert);
    invert.mapPoints(pts);
    mMatrixValueToPx.invert(invert);
    invert.mapPoints(pts);
    float depth=Math.abs(pts[3] - pts[1]) * mDepth;
    for (int i=0; i < mData.getDataSetCount(); i++) {
      DataSet dataSet=dataSets.get(i);
      ArrayList<Series> series=dataSet.getYVals();
      for (int j=0; j < series.size(); j++) {
        float x=series.get(j).getXIndex();
        float y=series.get(j).getVal();
        float left=x + mBarSpace / 2f;
        float right=x + 1f - mBarSpace / 2f;
        float top=y >= 0 ? y : 0;
        Path topPath=new Path();
        topPath.moveTo(left,top);
        topPath.lineTo(left + mSkew,top + depth);
        topPath.lineTo(right + mSkew,top + depth);
        topPath.lineTo(right,top);
        topPaths.add(topPath);
        Path sidePath=new Path();
        sidePath.moveTo(right,top);
        sidePath.lineTo(right + mSkew,top + depth);
        sidePath.lineTo(right + mSkew,depth);
        sidePath.lineTo(right,0);
        sidePaths.add(sidePath);
      }
    }
    transformPaths(topPaths);
    transformPaths(sidePaths);
  }
  int cnt=0;
  for (int i=0; i < mData.getDataSetCount(); i++) {
    DataSet dataSet=dataSets.get(i);
    ArrayList<Series> series=dataSet.getYVals();
    ArrayList<Integer> colors=mCt.getDataSetColors(i % mCt.getColors().size());
    ArrayList<Integer> colors3DTop=mTopColors.get(i % mCt.getColors().size());
    ArrayList<Integer> colors3DSide=mSideColors.get(i % mCt.getColors().size());
    for (int j=0; j < dataSet.getSeriesCount(); j++) {
      mRenderPaint.setColor(colors.get(j % colors.size()));
      int x=series.get(j).getXIndex();
      float y=series.get(j).getVal();
      float left=x + mBarSpace / 2f;
      float right=x + 1f - mBarSpace / 2f;
      float top=y >= 0 ? y : 0;
      float bottom=y <= 0 ? y : 0;
      mBarRect.set(left,top,right,bottom);
      transformRect(mBarRect);
      if (isOffContentRight(mBarRect.left))       break;
      if (isOffContentLeft(mBarRect.right)) {
        cnt++;
        continue;
      }
      mDrawCanvas.drawRect(mBarRect,mRenderPaint);
      if (m3DEnabled) {
        mRenderPaint.setColor(colors3DTop.get(j % colors3DTop.size()));
        mDrawCanvas.drawPath(topPaths.get(cnt),mRenderPaint);
        mRenderPaint.setColor(colors3DSide.get(j % colors3DSide.size()));
        mDrawCanvas.drawPath(sidePaths.get(cnt),mRenderPaint);
      }
      cnt++;
    }
  }
}",0.4344526655283627
27083,"/** 
 * Sets a colortemplate for the chart that defindes the colors used for drawing. If more values need to be drawn than provided colors available in the colortemplate, colors are repeated.
 * @param ct
 */
public void setColorTemplate(ColorTemplate ct){
  this.mCt=ct;
  prepareDataPaints(ct);
}","/** 
 * Sets a colortemplate for the chart that defindes the colors used for drawing. If more values need to be drawn than provided colors available in the colortemplate, colors are repeated.
 * @param ct
 */
public void setColorTemplate(ColorTemplate ct){
  this.mCt=ct;
}",0.956217162872154
27084,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setColorTemplate(new ColorTemplate(ColorTemplate.getColors(this,ColorTemplate.FRESH_COLORS)));
  mChart.setDrawValues(false);
  mChart.set3DEnabled(false);
  mChart.setDrawAdditional(true);
  mChart.setYLegendCount(5);
  mChart.setTouchEnabled(true);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setColorTemplate(new ColorTemplate(ColorTemplate.getColors(this,ColorTemplate.FRESH_COLORS)));
  mChart.setDrawValues(false);
  mChart.set3DEnabled(false);
  mChart.setYLegendCount(5);
  mChart.setTouchEnabled(true);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
}",0.9807692307692308
27085,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setDrawValues(false);
  mChart.setLineWidth(5f);
  mChart.setCircleSize(5f);
  mChart.setDrawAdditional(true);
  mChart.setYLegendCount(6);
  mChart.setTouchEnabled(true);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setDrawValues(false);
  mChart.setLineWidth(5f);
  mChart.setCircleSize(5f);
  mChart.setYLegendCount(6);
  mChart.setTouchEnabled(true);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
}",0.9789343246592316
27086,"@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.actionToggleRound:
{
      if (mChart.isYLegendRounded())       mChart.setRoundedYLegend(false);
 else       mChart.setRoundedYLegend(true);
      mChart.invalidate();
      break;
    }
case R.id.actionToggleValues:
{
    if (mChart.isDrawValuesEnabled())     mChart.setDrawValues(false);
 else     mChart.setDrawValues(true);
    mChart.invalidate();
    break;
  }
case R.id.actionToggleFilled:
{
  if (mChart.isDrawFilledEnabled())   mChart.setDrawFilled(false);
 else   mChart.setDrawFilled(true);
  mChart.invalidate();
  break;
}
case R.id.actionToggleCircles:
{
if (mChart.isDrawAdditionalEnabled()) mChart.setDrawAdditional(false);
 else mChart.setDrawAdditional(true);
mChart.invalidate();
break;
}
case R.id.actionToggleStartzero:
{
if (mChart.isStartAtZeroEnabled()) mChart.setStartAtZero(false);
 else mChart.setStartAtZero(true);
mChart.invalidate();
break;
}
case R.id.actionToggleAdjustXLegend:
{
if (mChart.isAdjustXLegendEnabled()) mChart.setAdjustXLegend(false);
 else mChart.setAdjustXLegend(true);
mChart.invalidate();
break;
}
case R.id.actionSave:
{
mChart.saveToPath(""String_Node_Str"" + System.currentTimeMillis(),""String_Node_Str"");
break;
}
}
return true;
}","@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.actionToggleRound:
{
      if (mChart.isYLegendRounded())       mChart.setRoundedYLegend(false);
 else       mChart.setRoundedYLegend(true);
      mChart.invalidate();
      break;
    }
case R.id.actionToggleValues:
{
    if (mChart.isDrawValuesEnabled())     mChart.setDrawValues(false);
 else     mChart.setDrawValues(true);
    mChart.invalidate();
    break;
  }
case R.id.actionToggleFilled:
{
  if (mChart.isDrawFilledEnabled())   mChart.setDrawFilled(false);
 else   mChart.setDrawFilled(true);
  mChart.invalidate();
  break;
}
case R.id.actionToggleCircles:
{
if (mChart.isDrawCirclesEnabled()) mChart.setDrawCircles(false);
 else mChart.setDrawCircles(true);
mChart.invalidate();
break;
}
case R.id.actionToggleStartzero:
{
if (mChart.isStartAtZeroEnabled()) mChart.setStartAtZero(false);
 else mChart.setStartAtZero(true);
mChart.invalidate();
break;
}
case R.id.actionToggleAdjustXLegend:
{
if (mChart.isAdjustXLegendEnabled()) mChart.setAdjustXLegend(false);
 else mChart.setAdjustXLegend(true);
mChart.invalidate();
break;
}
case R.id.actionSave:
{
mChart.saveToPath(""String_Node_Str"" + System.currentTimeMillis(),""String_Node_Str"");
break;
}
}
return true;
}",0.9800703399765534
27087,"/** 
 * draws the circle value indicators
 */
@Override protected void drawAdditional(){
  if (!mDrawAdditional)   return;
  if (mDrawCircles) {
    float[] positions=new float[mYVals.size() * 2];
    for (int i=0; i < positions.length; i+=2) {
      positions[i]=i / 2;
      positions[i + 1]=mYVals.get(i / 2);
    }
    transformPointArray(positions);
    for (int i=0; i < positions.length; i+=2) {
      mDrawCanvas.drawCircle(positions[i],positions[i + 1],mCircleSize,mCirclePaintOuter);
      mDrawCanvas.drawCircle(positions[i],positions[i + 1],mCircleSize / 2,mCirclePaintInner);
    }
  }
}","/** 
 * draws the circle value indicators
 */
@Override protected void drawAdditional(){
  if (mDrawCircles) {
    float[] positions=new float[mYVals.size() * 2];
    for (int i=0; i < positions.length; i+=2) {
      positions[i]=i / 2;
      positions[i + 1]=mYVals.get(i / 2);
    }
    transformPointArray(positions);
    for (int i=0; i < positions.length; i+=2) {
      mDrawCanvas.drawCircle(positions[i],positions[i + 1],mCircleSize,mCirclePaintOuter);
      mDrawCanvas.drawCircle(positions[i],positions[i + 1],mCircleSize / 2,mCirclePaintInner);
    }
  }
}",0.9708404802744426
27088,"public void isEqualTo(Node node){
  check(""String_Node_Str"",node).that(actual().checkTreeEquals(node)).isNull();
}","@Override public void isEqualTo(Object o){
  check().that(actual()).isInstanceOf(Node.class);
  Node node=(Node)o;
  check(""String_Node_Str"",node).that(actual().checkTreeEquals(node)).isNull();
}",0.7313915857605178
27089,"private void validateExpressionType(Node n){
switch (n.getToken()) {
case NAME:
    validateNameType(n);
  break;
case CALL:
if (!n.getFirstChild().isSuper()) {
  validateCallType(n);
}
break;
default :
expectSomeTypeInformation(n);
}
}","private void validateExpressionType(Node n){
switch (n.getToken()) {
case NAME:
    validateNameType(n);
  break;
case CALL:
if (!n.getFirstChild().isSuper()) {
  validateCallType(n);
}
break;
case SPREAD:
break;
default :
expectSomeTypeInformation(n);
}
}",0.959349593495935
27090,"/** 
 * Infers all of a function's parameters if their types aren't declared. 
 */
@SuppressWarnings(""String_Node_Str"") private void inferParameters(TypedScope functionScope){
  Node functionNode=functionScope.getRootNode();
  Node astParameters=functionNode.getSecondChild();
  Node iifeArgumentNode=null;
  if (NodeUtil.isInvocationTarget(functionNode)) {
    iifeArgumentNode=functionNode.getNext();
  }
  FunctionType functionType=JSType.toMaybeFunctionType(functionNode.getJSType());
  if (functionType != null) {
    Node parameterTypes=functionType.getParametersNode();
    if (parameterTypes != null) {
      Node parameterTypeNode=parameterTypes.getFirstChild();
      for (      Node astParameter : astParameters.children()) {
        if (astParameter.isDefaultValue()) {
          astParameter=astParameter.getFirstChild();
        }
        if (astParameter.isRest()) {
          astParameter=astParameter.getOnlyChild();
        }
        if (!astParameter.isName()) {
          continue;
        }
        TypedVar var=functionScope.getVar(astParameter.getString());
        checkNotNull(var);
        if (var.isTypeInferred() && var.getType() == unknownType) {
          JSType newType=null;
          if (iifeArgumentNode != null) {
            newType=iifeArgumentNode.getJSType();
          }
 else           if (parameterTypeNode != null) {
            newType=parameterTypeNode.getJSType();
          }
          if (newType != null) {
            var.setType(newType);
            astParameter.setJSType(newType);
          }
        }
        if (parameterTypeNode != null) {
          parameterTypeNode=parameterTypeNode.getNext();
        }
        if (iifeArgumentNode != null) {
          iifeArgumentNode=iifeArgumentNode.getNext();
        }
      }
    }
  }
}","/** 
 * Infers all of a function's parameters if their types aren't declared. 
 */
@SuppressWarnings(""String_Node_Str"") private void inferParameters(TypedScope functionScope){
  Node functionNode=functionScope.getRootNode();
  Node astParameters=functionNode.getSecondChild();
  Node iifeArgumentNode=null;
  if (NodeUtil.isInvocationTarget(functionNode)) {
    iifeArgumentNode=functionNode.getNext();
  }
  FunctionType functionType=JSType.toMaybeFunctionType(functionNode.getJSType());
  if (functionType != null) {
    Node parameterTypes=functionType.getParametersNode();
    if (parameterTypes != null) {
      Node parameterTypeNode=parameterTypes.getFirstChild();
      for (      Node astParameter : astParameters.children()) {
        boolean isRest=false;
        if (astParameter.isDefaultValue()) {
          astParameter=astParameter.getFirstChild();
        }
        if (astParameter.isRest()) {
          astParameter=astParameter.getOnlyChild();
          isRest=true;
        }
        if (!astParameter.isName()) {
          continue;
        }
        if (iifeArgumentNode != null && iifeArgumentNode.isSpread()) {
          iifeArgumentNode=null;
        }
        TypedVar var=functionScope.getVar(astParameter.getString());
        checkNotNull(var);
        if (var.isTypeInferred() && (var.getType() == unknownType || isRest)) {
          JSType newType=null;
          if (iifeArgumentNode != null) {
            newType=iifeArgumentNode.getJSType();
          }
 else           if (parameterTypeNode != null) {
            newType=parameterTypeNode.getJSType();
          }
          if (newType != null) {
            if (isRest) {
              newType=registry.createTemplatizedType(registry.getNativeObjectType(ARRAY_TYPE),newType);
            }
            var.setType(newType);
            astParameter.setJSType(newType);
          }
        }
        if (parameterTypeNode != null) {
          parameterTypeNode=parameterTypeNode.getNext();
        }
        if (iifeArgumentNode != null) {
          iifeArgumentNode=iifeArgumentNode.getNext();
        }
      }
    }
  }
}",0.8474750064086132
27091,"/** 
 * Declares all of a function's parameters inside the function's scope. 
 */
void declareParameters(){
  Node functionNode=currentScope.getRootNode();
  Node astParameters=functionNode.getSecondChild();
  Node iifeArgumentNode=null;
  if (NodeUtil.isInvocationTarget(functionNode)) {
    iifeArgumentNode=functionNode.getNext();
  }
  FunctionType functionType=JSType.toMaybeFunctionType(functionNode.getJSType());
  if (functionType != null) {
    Node jsDocParameters=functionType.getParametersNode();
    if (jsDocParameters != null) {
      Node jsDocParameter=jsDocParameters.getFirstChild();
      for (      Node astParameter : astParameters.children()) {
        JSType declaredType=jsDocParameter == null ? unknownType : jsDocParameter.getJSType();
        declareNamesInPositionalParameter(astParameter,declaredType,iifeArgumentNode);
        if (jsDocParameter != null) {
          jsDocParameter=jsDocParameter.getNext();
        }
        if (iifeArgumentNode != null) {
          iifeArgumentNode=iifeArgumentNode.getNext();
        }
      }
    }
    JSDocInfo info=NodeUtil.getBestJSDocInfo(functionNode);
    if (info != null) {
      Iterable<String> templateNames=Iterables.concat(info.getTemplateTypeNames(),info.getTypeTransformations().keySet());
      if (!Iterables.isEmpty(templateNames)) {
        CompilerInput input=getCompilerInput();
        JSType voidType=typeRegistry.getNativeType(VOID_TYPE);
        for (        String name : templateNames) {
          if (!currentScope.canDeclare(name)) {
            validator.expectUndeclaredVariable(NodeUtil.getSourceName(functionNode),input,functionNode,functionNode.getParent(),currentScope.getVar(name),name,voidType);
          }
          currentScope.declare(name,functionNode,voidType,input,false);
        }
      }
    }
  }
}","/** 
 * Declares all of a function's parameters inside the function's scope. 
 */
void declareParameters(){
  Node functionNode=currentScope.getRootNode();
  Node astParameters=functionNode.getSecondChild();
  Node iifeArgumentNode=null;
  if (NodeUtil.isInvocationTarget(functionNode)) {
    iifeArgumentNode=functionNode.getNext();
  }
  FunctionType functionType=JSType.toMaybeFunctionType(functionNode.getJSType());
  if (functionType != null) {
    Node jsDocParameters=functionType.getParametersNode();
    if (jsDocParameters != null) {
      Node jsDocParameter=jsDocParameters.getFirstChild();
      for (      Node astParameter : astParameters.children()) {
        if (iifeArgumentNode != null && iifeArgumentNode.isSpread()) {
          iifeArgumentNode=null;
        }
        JSType declaredType=jsDocParameter == null ? unknownType : jsDocParameter.getJSType();
        declareNamesInPositionalParameter(astParameter,declaredType,iifeArgumentNode);
        if (jsDocParameter != null) {
          jsDocParameter=jsDocParameter.getNext();
        }
        if (iifeArgumentNode != null) {
          iifeArgumentNode=iifeArgumentNode.getNext();
        }
      }
    }
    JSDocInfo info=NodeUtil.getBestJSDocInfo(functionNode);
    if (info != null) {
      Iterable<String> templateNames=Iterables.concat(info.getTemplateTypeNames(),info.getTypeTransformations().keySet());
      if (!Iterables.isEmpty(templateNames)) {
        CompilerInput input=getCompilerInput();
        JSType voidType=typeRegistry.getNativeType(VOID_TYPE);
        for (        String name : templateNames) {
          if (!currentScope.canDeclare(name)) {
            validator.expectUndeclaredVariable(NodeUtil.getSourceName(functionNode),input,functionNode,functionNode.getParent(),currentScope.getVar(name),name,voidType);
          }
          currentScope.declare(name,functionNode,voidType,input,false);
        }
      }
    }
  }
}",0.9695675387079552
27092,"/** 
 * Given a constructor type and a property name, check that the property has the JSDoc annotation @override iff the property is declared on a superclass. Several checks regarding inheritance correctness are also performed.
 */
private void checkDeclaredPropertyInheritance(NodeTraversal t,Node n,FunctionType ctorType,String propertyName,JSDocInfo info,JSType propertyType){
  if (hasUnknownOrEmptySupertype(ctorType)) {
    return;
  }
  FunctionType superClass=ctorType.getSuperClassConstructor();
  boolean superClassHasProperty=superClass != null && superClass.getInstanceType().hasProperty(propertyName);
  boolean superClassHasDeclaredProperty=superClass != null && superClass.getInstanceType().isPropertyTypeDeclared(propertyName);
  boolean superInterfaceHasProperty=false;
  boolean superInterfaceHasDeclaredProperty=false;
  if (ctorType.isInterface()) {
    for (    ObjectType interfaceType : ctorType.getExtendedInterfaces()) {
      superInterfaceHasProperty=superInterfaceHasProperty || interfaceType.hasProperty(propertyName);
      superInterfaceHasDeclaredProperty=superInterfaceHasDeclaredProperty || interfaceType.isPropertyTypeDeclared(propertyName);
    }
  }
  boolean declaredOverride=info != null && info.isOverride();
  boolean foundInterfaceProperty=false;
  if (ctorType.isConstructor()) {
    for (    JSType implementedInterface : ctorType.getAllImplementedInterfaces()) {
      if (implementedInterface.isUnknownType() || implementedInterface.isEmptyType()) {
        continue;
      }
      FunctionType interfaceType=implementedInterface.toObjectType().getConstructor();
      checkNotNull(interfaceType);
      boolean interfaceHasProperty=interfaceType.getPrototype().hasProperty(propertyName);
      foundInterfaceProperty=foundInterfaceProperty || interfaceHasProperty;
      if (!declaredOverride && interfaceHasProperty && !""String_Node_Str"".equals(propertyName)) {
        compiler.report(t.makeError(n,HIDDEN_INTERFACE_PROPERTY,propertyName,interfaceType.getTopMostDefiningType(propertyName).toString()));
      }
    }
  }
  if (!declaredOverride && !superClassHasProperty && !superInterfaceHasProperty) {
    return;
  }
  ObjectType topInstanceType=superClassHasDeclaredProperty ? superClass.getTopMostDefiningType(propertyName) : null;
  boolean declaredLocally=ctorType.isConstructor() && (ctorType.getPrototype().hasOwnProperty(propertyName) || ctorType.getInstanceType().hasOwnProperty(propertyName));
  if (!declaredOverride && superClassHasDeclaredProperty && declaredLocally&& !""String_Node_Str"".equals(propertyName)) {
    compiler.report(t.makeError(n,HIDDEN_SUPERCLASS_PROPERTY,propertyName,topInstanceType.toString()));
  }
  if (superClassHasDeclaredProperty) {
    JSType superClassPropType=superClass.getInstanceType().getPropertyType(propertyName);
    TemplateTypeMap ctorTypeMap=ctorType.getTypeOfThis().getTemplateTypeMap();
    if (!ctorTypeMap.isEmpty()) {
      superClassPropType=superClassPropType.visit(new TemplateTypeMapReplacer(typeRegistry,ctorTypeMap));
    }
    if (!propertyType.isSubtype(superClassPropType,this.subtypingMode)) {
      compiler.report(t.makeError(n,HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,propertyName,topInstanceType.toString(),superClassPropType.toString(),propertyType.toString()));
    }
  }
 else   if (superInterfaceHasDeclaredProperty) {
    for (    ObjectType interfaceType : ctorType.getExtendedInterfaces()) {
      if (interfaceType.hasProperty(propertyName)) {
        JSType superPropertyType=interfaceType.getPropertyType(propertyName);
        if (!propertyType.isSubtype(superPropertyType,this.subtypingMode)) {
          topInstanceType=interfaceType.getConstructor().getTopMostDefiningType(propertyName);
          compiler.report(t.makeError(n,HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,propertyName,topInstanceType.toString(),superPropertyType.toString(),propertyType.toString()));
        }
      }
    }
  }
 else   if (!foundInterfaceProperty && !superClassHasProperty && !superInterfaceHasProperty) {
    compiler.report(t.makeError(n,UNKNOWN_OVERRIDE,propertyName,ctorType.getInstanceType().toString()));
  }
}","/** 
 * Given a constructor type and a property name, check that the property has the JSDoc annotation @override iff the property is declared on a superclass. Several checks regarding inheritance correctness are also performed.
 */
private void checkDeclaredPropertyInheritance(NodeTraversal t,Node n,FunctionType ctorType,String propertyName,JSDocInfo info,JSType propertyType){
  if (hasUnknownOrEmptySupertype(ctorType)) {
    return;
  }
  FunctionType superClass=ctorType.getSuperClassConstructor();
  boolean superClassHasProperty=superClass != null && superClass.getInstanceType().hasProperty(propertyName);
  boolean superClassHasDeclaredProperty=superClass != null && superClass.getInstanceType().isPropertyTypeDeclared(propertyName);
  boolean superInterfaceHasProperty=false;
  boolean superInterfaceHasDeclaredProperty=false;
  if (ctorType.isInterface()) {
    for (    ObjectType interfaceType : ctorType.getExtendedInterfaces()) {
      superInterfaceHasProperty=superInterfaceHasProperty || interfaceType.hasProperty(propertyName);
      superInterfaceHasDeclaredProperty=superInterfaceHasDeclaredProperty || interfaceType.isPropertyTypeDeclared(propertyName);
    }
  }
  boolean declaredOverride=info != null && info.isOverride();
  boolean foundInterfaceProperty=false;
  if (ctorType.isConstructor()) {
    for (    JSType implementedInterface : ctorType.getAllImplementedInterfaces()) {
      if (implementedInterface.isUnknownType() || implementedInterface.isEmptyType()) {
        continue;
      }
      FunctionType interfaceType=implementedInterface.toObjectType().getConstructor();
      checkNotNull(interfaceType);
      boolean interfaceHasProperty=interfaceType.getPrototype().hasProperty(propertyName);
      foundInterfaceProperty=foundInterfaceProperty || interfaceHasProperty;
      if (!declaredOverride && interfaceHasProperty && !""String_Node_Str"".equals(propertyName)&& !""String_Node_Str"".equals(propertyName)) {
        compiler.report(t.makeError(n,HIDDEN_INTERFACE_PROPERTY,propertyName,interfaceType.getTopMostDefiningType(propertyName).toString()));
      }
    }
  }
  if (!declaredOverride && !superClassHasProperty && !superInterfaceHasProperty) {
    return;
  }
  ObjectType topInstanceType=superClassHasDeclaredProperty ? superClass.getTopMostDefiningType(propertyName) : null;
  boolean declaredLocally=ctorType.isConstructor() && (ctorType.getPrototype().hasOwnProperty(propertyName) || ctorType.getInstanceType().hasOwnProperty(propertyName));
  if (!declaredOverride && superClassHasDeclaredProperty && declaredLocally&& !""String_Node_Str"".equals(propertyName)) {
    compiler.report(t.makeError(n,HIDDEN_SUPERCLASS_PROPERTY,propertyName,topInstanceType.toString()));
  }
  if (superClassHasDeclaredProperty) {
    JSType superClassPropType=superClass.getInstanceType().getPropertyType(propertyName);
    TemplateTypeMap ctorTypeMap=ctorType.getTypeOfThis().getTemplateTypeMap();
    if (!ctorTypeMap.isEmpty()) {
      superClassPropType=superClassPropType.visit(new TemplateTypeMapReplacer(typeRegistry,ctorTypeMap));
    }
    if (!propertyType.isSubtype(superClassPropType,this.subtypingMode)) {
      compiler.report(t.makeError(n,HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,propertyName,topInstanceType.toString(),superClassPropType.toString(),propertyType.toString()));
    }
  }
 else   if (superInterfaceHasDeclaredProperty) {
    for (    ObjectType interfaceType : ctorType.getExtendedInterfaces()) {
      if (interfaceType.hasProperty(propertyName)) {
        JSType superPropertyType=interfaceType.getPropertyType(propertyName);
        if (!propertyType.isSubtype(superPropertyType,this.subtypingMode)) {
          topInstanceType=interfaceType.getConstructor().getTopMostDefiningType(propertyName);
          compiler.report(t.makeError(n,HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,propertyName,topInstanceType.toString(),superPropertyType.toString(),propertyType.toString()));
        }
      }
    }
  }
 else   if (!foundInterfaceProperty && !superClassHasProperty && !superInterfaceHasProperty) {
    compiler.report(t.makeError(n,UNKNOWN_OVERRIDE,propertyName,ctorType.getInstanceType().toString()));
  }
}",0.9949336550060314
27093,"public void testClassSuperConstructorParameterMismatch(){
  testTypes(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"" + ""String_Node_Str"");
}","public void testClassSuperConstructorParameterMismatch(){
  testTypes(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.7318982387475538
27094,"/** 
 * Look at the   {@code extends} clause to find the instance type being extended.Returns  {@code null} if there is no such clause, and unknown if the type cannotbe determined.
 */
@Nullable private ObjectType findSuperClassFromNodes(Node extendsNode,@Nullable JSDocInfo info){
  if (extendsNode.isEmpty()) {
    return null;
  }
  JSType ctorType=extendsNode.getJSType();
  if (ctorType == null) {
    if (extendsNode.isQualifiedName()) {
      TypedVar var=currentScope.getVar(extendsNode.getQualifiedName());
      if (var != null) {
        ctorType=var.getType();
      }
    }
 else {
      if (info == null || !info.hasBaseType()) {
        report(JSError.make(extendsNode,DYNAMIC_EXTENDS_WITHOUT_JSDOC));
      }
    }
  }
  if (ctorType != null && (ctorType.isConstructor() || ctorType.isInterface())) {
    return ctorType.toMaybeFunctionType().getInstanceType();
  }
  return null;
}","/** 
 * Look at the   {@code extends} clause to find the instance type being extended.Returns  {@code null} if there is no such clause, and unknown if the type cannotbe determined.
 */
@Nullable private ObjectType findSuperClassFromNodes(Node extendsNode,@Nullable JSDocInfo info){
  if (extendsNode.isEmpty()) {
    return null;
  }
  JSType ctorType=extendsNode.getJSType();
  if (ctorType == null) {
    if (extendsNode.isQualifiedName()) {
      TypedVar var=currentScope.getVar(extendsNode.getQualifiedName());
      if (var != null) {
        ctorType=var.getType();
      }
      if (ctorType == null) {
        return ObjectType.cast(typeRegistry.getType(currentScope,extendsNode.getQualifiedName(),extendsNode.getSourceFileName(),extendsNode.getLineno(),extendsNode.getCharno()));
      }
    }
 else {
      if (info == null || !info.hasBaseType()) {
        report(JSError.make(extendsNode,DYNAMIC_EXTENDS_WITHOUT_JSDOC));
      }
    }
  }
  if (ctorType != null && (ctorType.isConstructor() || ctorType.isInterface())) {
    return ctorType.toMaybeFunctionType().getInstanceType();
  }
  return null;
}",0.892200695479384
27095,"/** 
 * Returns true if this is a global this type. 
 */
public final boolean isGlobalThisType(){
  return this == registry.getNativeType(JSTypeNative.GLOBAL_THIS);
}","/** 
 * Returns true if this is a global this type. 
 */
public final boolean isGlobalThisType(){
  return areIdentical(this,registry.getNativeType(JSTypeNative.GLOBAL_THIS));
}",0.9446064139941692
27096,"/** 
 * A generic implementation meant to be used as a helper for common getLeastSupertype implementations.
 */
static JSType getLeastSupertype(JSType thisType,JSType thatType){
  boolean areEquivalent=thisType.isEquivalentTo(thatType);
  return areEquivalent ? thisType : filterNoResolvedType(thisType.registry.createUnionType(thisType,thatType));
}","/** 
 * A generic implementation meant to be used as a helper for common getLeastSupertype implementations.
 */
@SuppressWarnings(""String_Node_Str"") static JSType getLeastSupertype(JSType thisType,JSType thatType){
  boolean areEquivalent=thisType.isEquivalentTo(thatType);
  return areEquivalent ? thisType : filterNoResolvedType(thisType.registry.createUnionType(thisType,thatType));
}",0.949796472184532
27097,"/** 
 * Null-safe version of toMaybeFunctionType().
 */
public static FunctionType toMaybeFunctionType(JSType type){
  return type == null ? null : type.toMaybeFunctionType();
}","/** 
 * Null-safe version of toMaybeFunctionType(). 
 */
@SuppressWarnings(""String_Node_Str"") public static FunctionType toMaybeFunctionType(JSType type){
  return type == null ? null : type.toMaybeFunctionType();
}",0.903061224489796
27098,"/** 
 * Tests whether   {@code this} and {@code that} are meaningfullycomparable using shallow comparison. By meaningfully, we mean compatible types that are not rejected by step 1 of the definition of the Strict Equality Comparison Algorithm (11.9.6, page 56&ndash;57) of the ECMA-262 specification.<p>
 */
public final boolean canTestForShallowEqualityWith(JSType that){
  if (isEmptyType() || that.isEmptyType()) {
    return isSubtypeOf(that) || that.isSubtypeOf(this);
  }
  JSType inf=getGreatestSubtype(that);
  return !inf.isEmptyType() || inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);
}","/** 
 * Tests whether   {@code this} and {@code that} are meaningfullycomparable using shallow comparison. By meaningfully, we mean compatible types that are not rejected by step 1 of the definition of the Strict Equality Comparison Algorithm (11.9.6, page 56&ndash;57) of the ECMA-262 specification.<p>
 */
public final boolean canTestForShallowEqualityWith(JSType that){
  if (isEmptyType() || that.isEmptyType()) {
    return isSubtypeOf(that) || that.isSubtypeOf(this);
  }
  JSType inf=getGreatestSubtype(that);
  return !inf.isEmptyType() || areIdentical(inf,registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE));
}",0.979822437449556
27099,"public final boolean isEmptyType(){
  return isNoType() || isNoObjectType() || isNoResolvedType()|| (registry.getNativeFunctionType(JSTypeNative.LEAST_FUNCTION_TYPE) == this);
}","public final boolean isEmptyType(){
  return isNoType() || isNoObjectType() || isNoResolvedType()|| areIdentical(this,registry.getNativeFunctionType(JSTypeNative.LEAST_FUNCTION_TYPE));
}",0.931129476584022
27100,"/** 
 * A generic implementation meant to be used as a helper for common getGreatestSubtype implementations.
 */
static JSType getGreatestSubtype(JSType thisType,JSType thatType){
  if (thisType.isFunctionType() && thatType.isFunctionType()) {
    return thisType.toMaybeFunctionType().supAndInfHelper(thatType.toMaybeFunctionType(),false);
  }
 else   if (thisType.isEquivalentTo(thatType)) {
    return thisType;
  }
 else   if (thisType.isUnknownType() || thatType.isUnknownType()) {
    return thisType.isEquivalentTo(thatType) ? thisType : thisType.getNativeType(JSTypeNative.UNKNOWN_TYPE);
  }
 else   if (thisType.isUnionType()) {
    return thisType.toMaybeUnionType().meet(thatType);
  }
 else   if (thatType.isUnionType()) {
    return thatType.toMaybeUnionType().meet(thisType);
  }
 else   if (thisType.isTemplatizedType()) {
    return thisType.toMaybeTemplatizedType().getGreatestSubtypeHelper(thatType);
  }
 else   if (thatType.isTemplatizedType()) {
    return thatType.toMaybeTemplatizedType().getGreatestSubtypeHelper(thisType);
  }
 else   if (thisType.isSubtypeOf(thatType)) {
    return filterNoResolvedType(thisType);
  }
 else   if (thatType.isSubtypeOf(thisType)) {
    return filterNoResolvedType(thatType);
  }
 else   if (thisType.isRecordType()) {
    return thisType.toMaybeRecordType().getGreatestSubtypeHelper(thatType);
  }
 else   if (thatType.isRecordType()) {
    return thatType.toMaybeRecordType().getGreatestSubtypeHelper(thisType);
  }
  if (thisType.isEnumElementType()) {
    JSType inf=thisType.toMaybeEnumElementType().meet(thatType);
    if (inf != null) {
      return inf;
    }
  }
 else   if (thatType.isEnumElementType()) {
    JSType inf=thatType.toMaybeEnumElementType().meet(thisType);
    if (inf != null) {
      return inf;
    }
  }
  if (thisType.isObject() && thatType.isObject()) {
    return thisType.getNativeType(JSTypeNative.NO_OBJECT_TYPE);
  }
  return thisType.getNativeType(JSTypeNative.NO_TYPE);
}","/** 
 * A generic implementation meant to be used as a helper for common getGreatestSubtype implementations.
 */
@SuppressWarnings(""String_Node_Str"") static JSType getGreatestSubtype(JSType thisType,JSType thatType){
  if (thisType.isFunctionType() && thatType.isFunctionType()) {
    return thisType.toMaybeFunctionType().supAndInfHelper(thatType.toMaybeFunctionType(),false);
  }
 else   if (thisType.isEquivalentTo(thatType)) {
    return thisType;
  }
 else   if (thisType.isUnknownType() || thatType.isUnknownType()) {
    return thisType.isEquivalentTo(thatType) ? thisType : thisType.getNativeType(JSTypeNative.UNKNOWN_TYPE);
  }
 else   if (thisType.isUnionType()) {
    return thisType.toMaybeUnionType().meet(thatType);
  }
 else   if (thatType.isUnionType()) {
    return thatType.toMaybeUnionType().meet(thisType);
  }
 else   if (thisType.isTemplatizedType()) {
    return thisType.toMaybeTemplatizedType().getGreatestSubtypeHelper(thatType);
  }
 else   if (thatType.isTemplatizedType()) {
    return thatType.toMaybeTemplatizedType().getGreatestSubtypeHelper(thisType);
  }
 else   if (thisType.isSubtypeOf(thatType)) {
    return filterNoResolvedType(thisType);
  }
 else   if (thatType.isSubtypeOf(thisType)) {
    return filterNoResolvedType(thatType);
  }
 else   if (thisType.isRecordType()) {
    return thisType.toMaybeRecordType().getGreatestSubtypeHelper(thatType);
  }
 else   if (thatType.isRecordType()) {
    return thatType.toMaybeRecordType().getGreatestSubtypeHelper(thisType);
  }
  if (thisType.isEnumElementType()) {
    JSType inf=thisType.toMaybeEnumElementType().meet(thatType);
    if (inf != null) {
      return inf;
    }
  }
 else   if (thatType.isEnumElementType()) {
    JSType inf=thatType.toMaybeEnumElementType().meet(thisType);
    if (inf != null) {
      return inf;
    }
  }
  if (thisType.isObject() && thatType.isObject()) {
    return thisType.getNativeType(JSTypeNative.NO_OBJECT_TYPE);
  }
  return thisType.getNativeType(JSTypeNative.NO_TYPE);
}",0.9906777525825144
27101,"/** 
 * Computes the restricted type of this type knowing that the  {@code ToBoolean} predicate has a specific value. For more informationabout the  {@code ToBoolean} predicate, see{@link #getPossibleToBooleanOutcomes}.
 * @param outcome the value of the {@code ToBoolean} predicate
 * @return the restricted type, or the Any Type if the underlying type couldnot have yielded this ToBoolean value TODO(user): Move this method to the SemanticRAI and use the visit method of types to get the restricted type.
 */
public JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome){
  if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
    return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
  }
  BooleanLiteralSet literals=getPossibleToBooleanOutcomes();
  if (literals.contains(outcome)) {
    return this;
  }
 else {
    return getNativeType(JSTypeNative.NO_TYPE);
  }
}","/** 
 * Computes the restricted type of this type knowing that the  {@code ToBoolean} predicate has a specific value. For more informationabout the  {@code ToBoolean} predicate, see{@link #getPossibleToBooleanOutcomes}.
 * @param outcome the value of the {@code ToBoolean} predicate
 * @return the restricted type, or the Any Type if the underlying type couldnot have yielded this ToBoolean value TODO(user): Move this method to the SemanticRAI and use the visit method of types to get the restricted type.
 */
public JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome){
  if (outcome && areIdentical(this,getNativeType(JSTypeNative.UNKNOWN_TYPE))) {
    return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
  }
  BooleanLiteralSet literals=getPossibleToBooleanOutcomes();
  if (literals.contains(outcome)) {
    return this;
  }
 else {
    return getNativeType(JSTypeNative.NO_TYPE);
  }
}",0.9850083287062744
27102,"/** 
 * Computes the subset of   {@code this} and {@code that} types undershallow inequality.
 * @return A pair containing the restricted type of {@code this} as the firstcomponent and the restricted type of  {@code that} as the secondelement. The returned pair is never  {@code null} even though itscomponents may be  {@code null}
 */
public TypePair getTypesUnderShallowInequality(JSType that){
  if (that.isUnionType()) {
    TypePair p=that.toMaybeUnionType().getTypesUnderShallowInequality(this);
    return new TypePair(p.typeB,p.typeA);
  }
  if (isNullType() && that.isNullType() || isVoidType() && that.isVoidType()) {
    return new TypePair(null,null);
  }
 else {
    return new TypePair(this,that);
  }
}","/** 
 * Computes the subset of   {@code this} and {@code that} types undershallow inequality.
 * @return A pair containing the restricted type of {@code this} as the firstcomponent and the restricted type of  {@code that} as the secondelement. The returned pair is never  {@code null} even though itscomponents may be  {@code null}
 */
public TypePair getTypesUnderShallowInequality(JSType that){
  if (that.isUnionType()) {
    TypePair p=that.toMaybeUnionType().getTypesUnderShallowInequality(this);
    return new TypePair(p.typeB,p.typeA);
  }
  if ((isNullType() && that.isNullType()) || (isVoidType() && that.isVoidType())) {
    return new TypePair(null,null);
  }
 else {
    return new TypePair(this,that);
  }
}",0.9972183588317108
27103,"boolean checkEquivalenceHelper(final JSType that,EquivalenceMethod eqMethod,EqCache eqCache){
  if (this == that) {
    return true;
  }
  if (this.isNoResolvedType() && that.isNoResolvedType()) {
    if (this.isNamedType() && that.isNamedType()) {
      return Objects.equals(((NamedType)this).getReferenceName(),((NamedType)that).getReferenceName());
    }
 else {
      return true;
    }
  }
  boolean thisUnknown=isUnknownType();
  boolean thatUnknown=that.isUnknownType();
  if (thisUnknown || thatUnknown) {
    if (eqMethod == EquivalenceMethod.INVARIANT) {
      return true;
    }
 else     if (eqMethod == EquivalenceMethod.DATA_FLOW) {
      return thisUnknown && thatUnknown;
    }
 else     if (thisUnknown && thatUnknown && (isNominalType() ^ that.isNominalType())) {
      return false;
    }
  }
  if (isUnionType() && that.isUnionType()) {
    return toMaybeUnionType().checkUnionEquivalenceHelper(that.toMaybeUnionType(),eqMethod,eqCache);
  }
  if (isFunctionType() && that.isFunctionType()) {
    return toMaybeFunctionType().checkFunctionEquivalenceHelper(that.toMaybeFunctionType(),eqMethod,eqCache);
  }
  if (!getTemplateTypeMap().checkEquivalenceHelper(that.getTemplateTypeMap(),eqMethod,eqCache,SubtypingMode.NORMAL)) {
    return false;
  }
  if (eqCache.isStructuralTyping() && this.isStructuralType() && that.isStructuralType()) {
    return toMaybeObjectType().checkStructuralEquivalenceHelper(that.toMaybeObjectType(),eqMethod,eqCache);
  }
  if (isNominalType() && that.isNominalType()) {
    return getConcreteNominalTypeName(this.toObjectType()).equals(getConcreteNominalTypeName(that.toObjectType()));
  }
  if (isTemplateType() && that.isTemplateType()) {
    return false;
  }
  if (this instanceof ProxyObjectType) {
    return ((ProxyObjectType)this).getReferencedTypeInternal().checkEquivalenceHelper(that,eqMethod,eqCache);
  }
  if (that instanceof ProxyObjectType) {
    return checkEquivalenceHelper(((ProxyObjectType)that).getReferencedTypeInternal(),eqMethod,eqCache);
  }
  return false;
}","boolean checkEquivalenceHelper(final JSType that,EquivalenceMethod eqMethod,EqCache eqCache){
  if (areIdentical(this,that)) {
    return true;
  }
  if (this.isNoResolvedType() && that.isNoResolvedType()) {
    if (this.isNamedType() && that.isNamedType()) {
      return Objects.equals(((NamedType)this).getReferenceName(),((NamedType)that).getReferenceName());
    }
 else {
      return true;
    }
  }
  boolean thisUnknown=isUnknownType();
  boolean thatUnknown=that.isUnknownType();
  if (thisUnknown || thatUnknown) {
    if (eqMethod == EquivalenceMethod.INVARIANT) {
      return true;
    }
 else     if (eqMethod == EquivalenceMethod.DATA_FLOW) {
      return thisUnknown && thatUnknown;
    }
 else     if (thisUnknown && thatUnknown && (isNominalType() ^ that.isNominalType())) {
      return false;
    }
  }
  if (isUnionType() && that.isUnionType()) {
    return toMaybeUnionType().checkUnionEquivalenceHelper(that.toMaybeUnionType(),eqMethod,eqCache);
  }
  if (isFunctionType() && that.isFunctionType()) {
    return toMaybeFunctionType().checkFunctionEquivalenceHelper(that.toMaybeFunctionType(),eqMethod,eqCache);
  }
  if (!getTemplateTypeMap().checkEquivalenceHelper(that.getTemplateTypeMap(),eqMethod,eqCache,SubtypingMode.NORMAL)) {
    return false;
  }
  if (eqCache.isStructuralTyping() && this.isStructuralType() && that.isStructuralType()) {
    return toMaybeObjectType().checkStructuralEquivalenceHelper(that.toMaybeObjectType(),eqMethod,eqCache);
  }
  if (isNominalType() && that.isNominalType()) {
    return getConcreteNominalTypeName(this.toObjectType()).equals(getConcreteNominalTypeName(that.toObjectType()));
  }
  if (isTemplateType() && that.isTemplateType()) {
    return false;
  }
  if (this instanceof ProxyObjectType) {
    return ((ProxyObjectType)this).getReferencedTypeInternal().checkEquivalenceHelper(that,eqMethod,eqCache);
  }
  if (that instanceof ProxyObjectType) {
    return checkEquivalenceHelper(((ProxyObjectType)that).getReferencedTypeInternal(),eqMethod,eqCache);
  }
  return false;
}",0.9914320685434516
27104,"public static boolean isEquivalent(JSType typeA,JSType typeB){
  return (typeA == null || typeB == null) ? typeA == typeB : typeA.isEquivalentTo(typeB);
}","public static boolean isEquivalent(JSType typeA,JSType typeB){
  return (typeA == null || typeB == null) ? areIdentical(typeA,typeB) : typeA.isEquivalentTo(typeB);
}",0.9404388714733544
27105,"public final boolean isUnresolvedOrResolvedUnknown(){
  return isNoResolvedType() || isNamedType() && isUnknownType();
}","public final boolean isUnresolvedOrResolvedUnknown(){
  return isNoResolvedType() || (isNamedType() && isUnknownType());
}",0.9917355371900828
27106,"private void checkProtoCycle(ErrorReporter reporter){
  JSType referencedType=getReferencedType();
  if (referencedType == this) {
    handleTypeCycle(reporter);
  }
}","private void checkProtoCycle(ErrorReporter reporter){
  JSType referencedType=getReferencedType();
  if (areIdentical(referencedType,this)) {
    handleTypeCycle(reporter);
  }
}",0.944927536231884
27107,"private void checkEnumElementCycle(ErrorReporter reporter){
  JSType referencedType=getReferencedType();
  if (referencedType instanceof EnumElementType && ((EnumElementType)referencedType).getPrimitiveType() == this) {
    handleTypeCycle(reporter);
  }
}","private void checkEnumElementCycle(ErrorReporter reporter){
  JSType referencedType=getReferencedType();
  if (referencedType instanceof EnumElementType && areIdentical(this,((EnumElementType)referencedType).getPrimitiveType())) {
    handleTypeCycle(reporter);
  }
}",0.9177820267686424
27108,"/** 
 * Tests object types.
 */
public void testObjectType() throws Exception {
  PrototypeObjectType objectType=new PrototypeObjectType(registry,null,null);
  assertFalse(objectType.isAllType());
  assertFalse(objectType.isArrayType());
  assertFalse(objectType.isDateType());
  assertFalse(objectType.isFunctionPrototypeType());
  assertTrue(objectType.getImplicitPrototype() == OBJECT_TYPE);
  assertTrue(objectType.isSubtypeOf(ALL_TYPE));
  assertFalse(objectType.isSubtypeOf(STRING_OBJECT_TYPE));
  assertFalse(objectType.isSubtypeOf(NUMBER_TYPE));
  assertFalse(objectType.isSubtypeOf(functionType));
  assertFalse(objectType.isSubtypeOf(NULL_TYPE));
  assertFalse(objectType.isSubtypeOf(DATE_TYPE));
  assertTrue(objectType.isSubtypeOf(OBJECT_TYPE));
  assertTrue(objectType.isSubtypeOf(unresolvedNamedType));
  assertFalse(objectType.isSubtypeOf(namedGoogBar));
  assertFalse(objectType.isSubtypeOf(REGEXP_TYPE));
  assertNull(objectType.autoboxesTo());
  assertCanTestForEqualityWith(objectType,NUMBER_TYPE);
  assertFalse(objectType.matchesNumberContext());
  assertFalse(objectType.matchesNumberContext());
  assertTrue(objectType.matchesObjectContext());
  assertFalse(objectType.matchesStringContext());
  assertFalse(objectType.matchesNumberContext());
  assertFalse(objectType.isNullable());
  assertFalse(objectType.isVoidable());
  assertTrue(createNullableType(objectType).isNullable());
  assertTrue(createUnionType(objectType,VOID_TYPE).isVoidable());
  assertEquals(""String_Node_Str"",objectType.toString());
  assertEquals(null,objectType.getDisplayName());
  assertFalse(objectType.hasReferenceName());
  assertEquals(""String_Node_Str"",new PrototypeObjectType(registry,""String_Node_Str"",null).getDisplayName());
  Asserts.assertResolvesToSame(objectType);
}","/** 
 * Tests object types.
 */
public void testObjectType() throws Exception {
  PrototypeObjectType objectType=new PrototypeObjectType(registry,null,null);
  assertFalse(objectType.isAllType());
  assertFalse(objectType.isArrayType());
  assertFalse(objectType.isDateType());
  assertFalse(objectType.isFunctionPrototypeType());
  assertSame(objectType.getImplicitPrototype(),OBJECT_TYPE);
  assertTrue(objectType.isSubtypeOf(ALL_TYPE));
  assertFalse(objectType.isSubtypeOf(STRING_OBJECT_TYPE));
  assertFalse(objectType.isSubtypeOf(NUMBER_TYPE));
  assertFalse(objectType.isSubtypeOf(functionType));
  assertFalse(objectType.isSubtypeOf(NULL_TYPE));
  assertFalse(objectType.isSubtypeOf(DATE_TYPE));
  assertTrue(objectType.isSubtypeOf(OBJECT_TYPE));
  assertTrue(objectType.isSubtypeOf(unresolvedNamedType));
  assertFalse(objectType.isSubtypeOf(namedGoogBar));
  assertFalse(objectType.isSubtypeOf(REGEXP_TYPE));
  assertNull(objectType.autoboxesTo());
  assertCanTestForEqualityWith(objectType,NUMBER_TYPE);
  assertFalse(objectType.matchesNumberContext());
  assertFalse(objectType.matchesNumberContext());
  assertTrue(objectType.matchesObjectContext());
  assertFalse(objectType.matchesStringContext());
  assertFalse(objectType.matchesNumberContext());
  assertFalse(objectType.isNullable());
  assertFalse(objectType.isVoidable());
  assertTrue(createNullableType(objectType).isNullable());
  assertTrue(createUnionType(objectType,VOID_TYPE).isVoidable());
  assertEquals(""String_Node_Str"",objectType.toString());
  assertEquals(null,objectType.getDisplayName());
  assertFalse(objectType.hasReferenceName());
  assertEquals(""String_Node_Str"",new PrototypeObjectType(registry,""String_Node_Str"",null).getDisplayName());
  Asserts.assertResolvesToSame(objectType);
}",0.9969057665260196
27109,"/** 
 * @return Whether the given property access is on 'this' or a static property on a class. 
 */
private boolean isCandidatePropertyDefinition(Node n){
  Node target=n.getFirstChild();
  return target.isThis() || isConstructor(target);
}","/** 
 * @return Whether the given node is a @private property declaration that is not marked constant.
 */
private boolean isCandidatePropertyDefinition(Node n){
  if (!NodeUtil.isLhsOfAssign(n)) {
    return false;
  }
  Node target=n.getFirstChild();
  if (!(target.isThis() || isConstructor(target))) {
    return false;
  }
  JSDocInfo info=NodeUtil.getBestJSDocInfo(n);
  return info != null && info.getVisibility() == Visibility.PRIVATE && !info.isConstant() && !info.hasTypedefType() && !info.hasEnumParameterType() && !info.isInterface() && !isFunctionProperty(n);
}",0.4220858895705521
27110,"@Override public void visit(NodeTraversal t,Node n,Node parent){
switch (n.getToken()) {
case SCRIPT:
    reportMissingConst(t);
  break;
case GETELEM:
case GETPROP:
Node lastChild=n.getLastChild();
if (!lastChild.isString()) {
return;
}
String propName=lastChild.getString();
if (isCandidatePropertyDefinition(n) && isNonConstCheckablePrivatePropDecl(n)) {
candidates.add(n);
}
 else if (isModificationOp(n)) {
modified.add(propName);
}
break;
default :
break;
}
}","@Override public void visit(NodeTraversal t,Node n,Node parent){
switch (n.getToken()) {
case SCRIPT:
    reportMissingConst(t);
  break;
case GETELEM:
case GETPROP:
Node lastChild=n.getLastChild();
if (!lastChild.isString()) {
return;
}
String propName=lastChild.getString();
if (isCandidatePropertyDefinition(n)) {
candidates.add(n);
}
 else if (isModificationOp(n)) {
modified.add(propName);
}
break;
default :
break;
}
}",0.7199100112485939
27111,"private void processAllFiles(Deque<ScriptDescription> scriptDescriptions,Iterable<Node> scriptNodes){
  for (  Node c : scriptNodes) {
    checkState(c.isScript(),c);
    NodeTraversal.traverse(compiler,c,new UnwrapGoogLoadModule());
    pushScript(new ScriptDescription());
    currentScript.rootNode=c;
    scriptDescriptions.addLast(currentScript);
    NodeTraversal.traverse(compiler,c,new ScriptPreprocessor());
    NodeTraversal.traverse(compiler,c,new ScriptRecorder());
    popScript();
  }
  reportUnrecognizedRequires();
  if (compiler.hasHaltingErrors()) {
    return;
  }
  for (  Node c : scriptNodes) {
    pushScript(scriptDescriptions.removeFirst());
    NodeTraversal.traverse(compiler,c,new ScriptUpdater());
    popScript();
  }
}","private void processAllFiles(Deque<ScriptDescription> scriptDescriptions,Iterable<Node> scriptNodes){
  for (  Node c : scriptNodes) {
    checkState(c.isScript(),c);
    if (c.isFromExterns() && !NodeUtil.isFromTypeSummary(c)) {
      continue;
    }
    NodeTraversal.traverse(compiler,c,new UnwrapGoogLoadModule());
    pushScript(new ScriptDescription());
    currentScript.rootNode=c;
    scriptDescriptions.addLast(currentScript);
    NodeTraversal.traverse(compiler,c,new ScriptPreprocessor());
    NodeTraversal.traverse(compiler,c,new ScriptRecorder());
    popScript();
  }
  reportUnrecognizedRequires();
  if (compiler.hasHaltingErrors()) {
    return;
  }
  for (  Node c : scriptNodes) {
    if (c.isFromExterns() && !NodeUtil.isFromTypeSummary(c)) {
      continue;
    }
    pushScript(scriptDescriptions.removeFirst());
    NodeTraversal.traverse(compiler,c,new ScriptUpdater());
    popScript();
  }
}",0.8980815347721822
27112,"public void testIjsModule(){
  allowExternsChanges();
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(lines(""String_Node_Str"",""String_Node_Str"")));
}","public void testIjsModule(){
  allowExternsChanges();
  test(new String[]{lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")},new String[]{lines(""String_Node_Str"",""String_Node_Str"")});
}",0.2934537246049661
27113,"public void testExternsReferencesToGoogModuleTypesAreRewritten(){
  CompilerOptions options=createCompilerOptions();
  options.setClosurePass(true);
  options.setCheckTypes(true);
  test(options,new String[]{LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")},(String[])null);
}","public void testExternsReferencesToGoogModuleTypesAreRewritten(){
  CompilerOptions options=createCompilerOptions();
  options.setClosurePass(true);
  options.setCheckTypes(true);
  test(options,new String[]{LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")},(String[])null);
}",0.9783653846153846
27114,"Node processAstRoot(ProgramTree rootNode){
  Node scriptNode=newNode(Token.SCRIPT);
  for (  ParseTree child : rootNode.sourceElements) {
    scriptNode.addChildToBack(transform(child));
  }
  parseDirectives(scriptNode);
  boolean isGoogModule=isGoogModuleFile(scriptNode);
  if (isGoogModule || features.has(Feature.MODULES)) {
    Node moduleNode=newNode(Token.MODULE_BODY);
    setSourceInfo(moduleNode,rootNode);
    moduleNode.addChildrenToBack(scriptNode.removeChildren());
    scriptNode.addChildToBack(moduleNode);
    if (isGoogModule) {
      scriptNode.putBooleanProp(Node.GOOG_MODULE,true);
    }
  }
  return scriptNode;
}","Node processAstRoot(ProgramTree rootNode){
  Node scriptNode=newNode(Token.SCRIPT);
  for (  ParseTree child : rootNode.sourceElements) {
    scriptNode.addChildToBack(transform(child));
  }
  parseDirectives(scriptNode);
  boolean isGoogModule=isGoogModuleFile(scriptNode);
  if (isGoogModule || features.has(Feature.MODULES)) {
    Node moduleNode=newNode(Token.MODULE_BODY);
    setSourceInfo(moduleNode,rootNode);
    moduleNode.addChildrenToBack(scriptNode.removeChildren());
    scriptNode.addChildToBack(moduleNode);
    if (isGoogModule) {
      scriptNode.putBooleanProp(Node.GOOG_MODULE,true);
    }
 else {
      scriptNode.putBooleanProp(Node.ES6_MODULE,true);
    }
  }
  return scriptNode;
}",0.9202087994034304
27115,"private static final String propToString(byte propType){
switch (propType) {
case VAR_ARGS_NAME:
    return ""String_Node_Str"";
case JSDOC_INFO_PROP:
  return ""String_Node_Str"";
case INCRDECR_PROP:
return ""String_Node_Str"";
case QUOTED_PROP:
return ""String_Node_Str"";
case OPT_ARG_NAME:
return ""String_Node_Str"";
case SYNTHETIC_BLOCK_PROP:
return ""String_Node_Str"";
case ADDED_BLOCK:
return ""String_Node_Str"";
case ORIGINALNAME_PROP:
return ""String_Node_Str"";
case SIDE_EFFECT_FLAGS:
return ""String_Node_Str"";
case IS_CONSTANT_NAME:
return ""String_Node_Str"";
case IS_NAMESPACE:
return ""String_Node_Str"";
case DIRECTIVES:
return ""String_Node_Str"";
case DIRECT_EVAL:
return ""String_Node_Str"";
case FREE_CALL:
return ""String_Node_Str"";
case STATIC_SOURCE_FILE:
return ""String_Node_Str"";
case INPUT_ID:
return ""String_Node_Str"";
case SLASH_V:
return ""String_Node_Str"";
case INFERRED_FUNCTION:
return ""String_Node_Str"";
case CHANGE_TIME:
return ""String_Node_Str"";
case REFLECTED_OBJECT:
return ""String_Node_Str"";
case STATIC_MEMBER:
return ""String_Node_Str"";
case GENERATOR_FN:
return ""String_Node_Str"";
case ARROW_FN:
return ""String_Node_Str"";
case ASYNC_FN:
return ""String_Node_Str"";
case YIELD_ALL:
return ""String_Node_Str"";
case EXPORT_DEFAULT:
return ""String_Node_Str"";
case EXPORT_ALL_FROM:
return ""String_Node_Str"";
case IS_CONSTANT_VAR:
return ""String_Node_Str"";
case GENERATOR_MARKER:
return ""String_Node_Str"";
case GENERATOR_SAFE:
return ""String_Node_Str"";
case RAW_STRING_VALUE:
return ""String_Node_Str"";
case COMPUTED_PROP_METHOD:
return ""String_Node_Str"";
case COMPUTED_PROP_GETTER:
return ""String_Node_Str"";
case COMPUTED_PROP_SETTER:
return ""String_Node_Str"";
case COMPUTED_PROP_VARIABLE:
return ""String_Node_Str"";
case ANALYZED_DURING_GTI:
return ""String_Node_Str"";
case CONSTANT_PROPERTY_DEF:
return ""String_Node_Str"";
case DECLARED_TYPE_EXPR:
return ""String_Node_Str"";
case TYPE_BEFORE_CAST:
return ""String_Node_Str"";
case OPT_ES6_TYPED:
return ""String_Node_Str"";
case GENERIC_TYPE_LIST:
return ""String_Node_Str"";
case IMPLEMENTS:
return ""String_Node_Str"";
case CONSTRUCT_SIGNATURE:
return ""String_Node_Str"";
case ACCESS_MODIFIER:
return ""String_Node_Str"";
case NON_INDEXABLE:
return ""String_Node_Str"";
case PARSE_RESULTS:
return ""String_Node_Str"";
case GOOG_MODULE:
return ""String_Node_Str"";
case GOOG_MODULE_REQUIRE:
return ""String_Node_Str"";
case FEATURE_SET:
return ""String_Node_Str"";
case IS_MODULE_NAME:
return ""String_Node_Str"";
case WAS_PREVIOUSLY_PROVIDED:
return ""String_Node_Str"";
case IS_ES6_CLASS:
return ""String_Node_Str"";
case TRANSPILED:
return ""String_Node_Str"";
case DELETED:
return ""String_Node_Str"";
case MODULE_ALIAS:
return ""String_Node_Str"";
case IS_UNUSED_PARAMETER:
return ""String_Node_Str"";
case MODULE_EXPORT:
return ""String_Node_Str"";
case IS_SHORTHAND_PROPERTY:
return ""String_Node_Str"";
default :
throw new IllegalStateException(""String_Node_Str"" + propType);
}
}","private static final String propToString(byte propType){
switch (propType) {
case VAR_ARGS_NAME:
    return ""String_Node_Str"";
case JSDOC_INFO_PROP:
  return ""String_Node_Str"";
case INCRDECR_PROP:
return ""String_Node_Str"";
case QUOTED_PROP:
return ""String_Node_Str"";
case OPT_ARG_NAME:
return ""String_Node_Str"";
case SYNTHETIC_BLOCK_PROP:
return ""String_Node_Str"";
case ADDED_BLOCK:
return ""String_Node_Str"";
case ORIGINALNAME_PROP:
return ""String_Node_Str"";
case SIDE_EFFECT_FLAGS:
return ""String_Node_Str"";
case IS_CONSTANT_NAME:
return ""String_Node_Str"";
case IS_NAMESPACE:
return ""String_Node_Str"";
case DIRECTIVES:
return ""String_Node_Str"";
case DIRECT_EVAL:
return ""String_Node_Str"";
case FREE_CALL:
return ""String_Node_Str"";
case STATIC_SOURCE_FILE:
return ""String_Node_Str"";
case INPUT_ID:
return ""String_Node_Str"";
case SLASH_V:
return ""String_Node_Str"";
case INFERRED_FUNCTION:
return ""String_Node_Str"";
case CHANGE_TIME:
return ""String_Node_Str"";
case REFLECTED_OBJECT:
return ""String_Node_Str"";
case STATIC_MEMBER:
return ""String_Node_Str"";
case GENERATOR_FN:
return ""String_Node_Str"";
case ARROW_FN:
return ""String_Node_Str"";
case ASYNC_FN:
return ""String_Node_Str"";
case YIELD_ALL:
return ""String_Node_Str"";
case EXPORT_DEFAULT:
return ""String_Node_Str"";
case EXPORT_ALL_FROM:
return ""String_Node_Str"";
case IS_CONSTANT_VAR:
return ""String_Node_Str"";
case GENERATOR_MARKER:
return ""String_Node_Str"";
case GENERATOR_SAFE:
return ""String_Node_Str"";
case RAW_STRING_VALUE:
return ""String_Node_Str"";
case COMPUTED_PROP_METHOD:
return ""String_Node_Str"";
case COMPUTED_PROP_GETTER:
return ""String_Node_Str"";
case COMPUTED_PROP_SETTER:
return ""String_Node_Str"";
case COMPUTED_PROP_VARIABLE:
return ""String_Node_Str"";
case ANALYZED_DURING_GTI:
return ""String_Node_Str"";
case CONSTANT_PROPERTY_DEF:
return ""String_Node_Str"";
case DECLARED_TYPE_EXPR:
return ""String_Node_Str"";
case TYPE_BEFORE_CAST:
return ""String_Node_Str"";
case OPT_ES6_TYPED:
return ""String_Node_Str"";
case GENERIC_TYPE_LIST:
return ""String_Node_Str"";
case IMPLEMENTS:
return ""String_Node_Str"";
case CONSTRUCT_SIGNATURE:
return ""String_Node_Str"";
case ACCESS_MODIFIER:
return ""String_Node_Str"";
case NON_INDEXABLE:
return ""String_Node_Str"";
case PARSE_RESULTS:
return ""String_Node_Str"";
case GOOG_MODULE:
return ""String_Node_Str"";
case GOOG_MODULE_REQUIRE:
return ""String_Node_Str"";
case FEATURE_SET:
return ""String_Node_Str"";
case IS_MODULE_NAME:
return ""String_Node_Str"";
case WAS_PREVIOUSLY_PROVIDED:
return ""String_Node_Str"";
case IS_ES6_CLASS:
return ""String_Node_Str"";
case TRANSPILED:
return ""String_Node_Str"";
case DELETED:
return ""String_Node_Str"";
case MODULE_ALIAS:
return ""String_Node_Str"";
case IS_UNUSED_PARAMETER:
return ""String_Node_Str"";
case MODULE_EXPORT:
return ""String_Node_Str"";
case IS_SHORTHAND_PROPERTY:
return ""String_Node_Str"";
case ES6_MODULE:
return ""String_Node_Str"";
default :
throw new IllegalStateException(""String_Node_Str"" + propType);
}
}",0.9926533401674354
27116,"@Override protected void setUp() throws Exception {
  super.setUp();
  enableTypeCheck();
  enableClosurePass();
  enableClosurePassForExpected();
  enableRewriteClosureCode();
  setLanguage(LanguageMode.ECMASCRIPT_2015,LanguageMode.ECMASCRIPT5_STRICT);
  enableClosurePass();
  configuration=DEFAULT_CONFORMANCE;
  ignoreWarnings(DiagnosticGroups.MISSING_PROPERTIES);
}","@Override protected void setUp() throws Exception {
  super.setUp();
  enableTypeCheck();
  enableClosurePass();
  enableClosurePassForExpected();
  enableRewriteClosureCode();
  setLanguage(LanguageMode.ECMASCRIPT_2015,LanguageMode.ECMASCRIPT5_STRICT);
  configuration=DEFAULT_CONFORMANCE;
  ignoreWarnings(DiagnosticGroups.MISSING_PROPERTIES);
}",0.9679218967921897
27117,"/** 
 * This is the meat of the type checking.  It is basically one big switch, with each case representing one type of parse tree node.  The individual cases are usually pretty straightforward.
 * @param t The node traversal object that supplies context, such as thescope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */
@Override public void visit(NodeTraversal t,Node n,Node parent){
  JSType childType;
  JSType leftType;
  JSType rightType;
  Node left;
  Node right;
  boolean typeable=true;
switch (n.getToken()) {
case CAST:
    Node expr=n.getFirstChild();
  JSType exprType=getJSType(expr);
JSType castType=getJSType(n);
if (!expr.isObjectLit()) {
validator.expectCanCast(t,n,castType,exprType);
}
ensureTyped(t,n,castType);
expr.putProp(Node.TYPE_BEFORE_CAST,exprType);
if (castType.restrictByNotNullOrUndefined().isSubtypeOf(exprType) || expr.isObjectLit()) {
expr.setJSType(castType);
}
break;
case NAME:
typeable=visitName(t,n,parent);
break;
case COMMA:
ensureTyped(t,n,getJSType(n.getLastChild()));
break;
case THIS:
ensureTyped(t,n,t.getTypedScope().getTypeOfThis());
break;
case SUPER:
ensureTyped(t,n);
break;
case NULL:
ensureTyped(t,n,NULL_TYPE);
break;
case NUMBER:
ensureTyped(t,n,NUMBER_TYPE);
break;
case GETTER_DEF:
case SETTER_DEF:
break;
case ARRAYLIT:
ensureTyped(t,n,ARRAY_TYPE);
break;
case REGEXP:
ensureTyped(t,n,REGEXP_TYPE);
break;
case GETPROP:
visitGetProp(t,n);
typeable=!(parent.isAssign() && parent.getFirstChild() == n);
break;
case GETELEM:
visitGetElem(t,n);
typeable=false;
break;
case VAR:
case LET:
case CONST:
visitVar(t,n);
typeable=false;
break;
case NEW:
visitNew(t,n);
break;
case CALL:
visitCall(t,n);
typeable=!parent.isExprResult();
break;
case RETURN:
visitReturn(t,n);
typeable=false;
break;
case YIELD:
visitYield(t,n);
typeable=false;
break;
case DEC:
case INC:
left=n.getFirstChild();
checkPropCreation(t,left);
validator.expectNumber(t,left,getJSType(left),""String_Node_Str"");
ensureTyped(t,n,NUMBER_TYPE);
break;
case VOID:
ensureTyped(t,n,VOID_TYPE);
break;
case STRING:
case TYPEOF:
ensureTyped(t,n,STRING_TYPE);
break;
case BITNOT:
childType=getJSType(n.getFirstChild());
if (!childType.matchesNumberContext()) {
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getToken()),childType.toString());
}
 else if (this.strictOperatorChecks) {
this.validator.expectNumberStrict(n,childType,""String_Node_Str"");
}
ensureTyped(t,n,NUMBER_TYPE);
break;
case POS:
case NEG:
left=n.getFirstChild();
if (n.getToken() == Token.NEG) {
validator.expectNumber(t,left,getJSType(left),""String_Node_Str"");
}
ensureTyped(t,n,NUMBER_TYPE);
break;
case EQ:
case NE:
case SHEQ:
case SHNE:
{
left=n.getFirstChild();
right=n.getLastChild();
if (left.isTypeOf()) {
if (right.isString()) {
checkTypeofString(t,right,right.getString());
}
}
 else if (right.isTypeOf() && left.isString()) {
checkTypeofString(t,left,left.getString());
}
leftType=getJSType(left);
rightType=getJSType(right);
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=TernaryValue.UNKNOWN;
if (n.getToken() == Token.EQ || n.isNE()) {
result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if (n.isNE()) {
result=result.not();
}
}
 else {
if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
result=n.getToken() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
}
}
if (result != TernaryValue.UNKNOWN) {
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case LT:
case LE:
case GT:
case GE:
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
if (rightType.isUnknownType()) {
validator.expectStringOrNumber(t,n,leftType,""String_Node_Str"");
}
 else if (leftType.isUnknownType()) {
validator.expectStringOrNumber(t,n,leftType,""String_Node_Str"");
}
 else if (rightType.isNumber()) {
validator.expectNumber(t,n,leftType,""String_Node_Str"");
}
 else if (leftType.isNumber()) {
validator.expectNumber(t,n,rightType,""String_Node_Str"");
}
 else if (this.strictOperatorChecks) {
String errorMsg=""String_Node_Str"";
this.validator.expectMatchingTypes(n,leftType,rightType,errorMsg);
}
 else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
}
 else {
String message=""String_Node_Str"";
validator.expectString(t,n,leftType,message);
validator.expectNotNullOrUndefined(t,n,leftType,message,getNativeType(STRING_TYPE));
message=""String_Node_Str"";
validator.expectString(t,n,rightType,message);
validator.expectNotNullOrUndefined(t,n,rightType,message,getNativeType(STRING_TYPE));
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case IN:
left=n.getFirstChild();
right=n.getLastChild();
rightType=getJSType(right);
validator.expectString(t,left,getJSType(left),""String_Node_Str"");
validator.expectObject(t,n,rightType,""String_Node_Str"");
if (rightType.isStruct()) {
report(t,right,IN_USED_WITH_STRUCT);
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case INSTANCEOF:
left=n.getFirstChild();
right=n.getLastChild();
rightType=getJSType(right).restrictByNotNullOrUndefined();
validator.expectAnyObject(t,left,getJSType(left),""String_Node_Str"");
validator.expectActualObject(t,right,rightType,""String_Node_Str"");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case ASSIGN:
visitAssign(t,n);
typeable=false;
break;
case ASSIGN_LSH:
case ASSIGN_RSH:
case ASSIGN_URSH:
case ASSIGN_DIV:
case ASSIGN_MOD:
case ASSIGN_BITOR:
case ASSIGN_BITXOR:
case ASSIGN_BITAND:
case ASSIGN_SUB:
case ASSIGN_ADD:
case ASSIGN_MUL:
checkPropCreation(t,n.getFirstChild());
case LSH:
case RSH:
case URSH:
case DIV:
case MOD:
case BITOR:
case BITXOR:
case BITAND:
case SUB:
case ADD:
case MUL:
visitBinaryOperator(n.getToken(),t,n);
break;
case TRUE:
case FALSE:
case NOT:
case DELPROP:
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case CASE:
JSType switchType=getJSType(parent.getFirstChild());
JSType caseType=getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t,n,switchType,caseType);
typeable=false;
break;
case WITH:
{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,""String_Node_Str"");
typeable=false;
break;
}
case MEMBER_FUNCTION_DEF:
ensureTyped(t,n,getJSType(n.getFirstChild()));
break;
case FUNCTION:
visitFunction(t,n);
break;
case PARAM_LIST:
case STRING_KEY:
case LABEL:
case LABEL_NAME:
case SWITCH:
case BREAK:
case CATCH:
case TRY:
case SCRIPT:
case EXPR_RESULT:
case BLOCK:
case ROOT:
case EMPTY:
case DEFAULT_CASE:
case CONTINUE:
case DEBUGGER:
case THROW:
case DO:
case IF:
case WHILE:
case FOR:
typeable=false;
break;
case FOR_IN:
Node obj=n.getSecondChild();
if (getJSType(obj).isStruct()) {
report(t,obj,IN_USED_WITH_STRUCT);
}
typeable=false;
break;
case FOR_OF:
ensureTyped(t,n.getSecondChild());
JSType iterable=getJSType(n.getSecondChild());
JSType autoboxedIterable=iterable.autoboxesTo();
iterable=autoboxedIterable != null ? autoboxedIterable : iterable;
validator.expectIterable(t,n.getSecondChild(),iterable,""String_Node_Str"");
typeable=false;
Node loopVarNode=NodeUtil.isNameDeclaration(n.getFirstChild()) ? n.getFirstFirstChild() : n.getFirstChild();
JSType declaredType=loopVarNode.getJSType();
if (declaredType != null) {
JSType actualType=iterable.getTemplateTypeMap().getResolvedTemplateType(typeRegistry.getIterableTemplate());
validator.expectCanAssignTo(t,loopVarNode,declaredType,actualType,""String_Node_Str"");
}
break;
case AND:
case HOOK:
case OBJECTLIT:
case OR:
if (n.getJSType() != null) {
ensureTyped(t,n);
}
 else {
if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
ensureTyped(t,n,parent.getJSType());
}
 else {
ensureTyped(t,n);
}
}
if (n.isObjectLit()) {
JSType typ=getJSType(n);
for (Node key : n.children()) {
visitObjLitKey(t,key,n,typ);
}
}
break;
default :
report(t,n,UNEXPECTED_TOKEN,n.getToken().toString());
ensureTyped(t,n);
break;
}
typeable=typeable && !inExterns;
if (typeable) {
doPercentTypedAccounting(t,n);
}
checkJsdocInfoContainsObjectWithBadKey(t,n);
}","/** 
 * This is the meat of the type checking.  It is basically one big switch, with each case representing one type of parse tree node.  The individual cases are usually pretty straightforward.
 * @param t The node traversal object that supplies context, such as thescope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */
@Override public void visit(NodeTraversal t,Node n,Node parent){
  JSType childType;
  JSType leftType;
  JSType rightType;
  Node left;
  Node right;
  boolean typeable=true;
switch (n.getToken()) {
case CAST:
    Node expr=n.getFirstChild();
  JSType exprType=getJSType(expr);
JSType castType=getJSType(n);
if (!expr.isObjectLit()) {
validator.expectCanCast(t,n,castType,exprType);
}
ensureTyped(t,n,castType);
expr.putProp(Node.TYPE_BEFORE_CAST,exprType);
if (castType.restrictByNotNullOrUndefined().isSubtypeOf(exprType) || expr.isObjectLit()) {
expr.setJSType(castType);
}
break;
case NAME:
typeable=visitName(t,n,parent);
break;
case COMMA:
ensureTyped(t,n,getJSType(n.getLastChild()));
break;
case THIS:
ensureTyped(t,n,t.getTypedScope().getTypeOfThis());
break;
case SUPER:
ensureTyped(t,n);
break;
case NULL:
ensureTyped(t,n,NULL_TYPE);
break;
case NUMBER:
ensureTyped(t,n,NUMBER_TYPE);
break;
case GETTER_DEF:
case SETTER_DEF:
break;
case ARRAYLIT:
ensureTyped(t,n,ARRAY_TYPE);
break;
case REGEXP:
ensureTyped(t,n,REGEXP_TYPE);
break;
case GETPROP:
visitGetProp(t,n);
typeable=!(parent.isAssign() && parent.getFirstChild() == n);
break;
case GETELEM:
visitGetElem(t,n);
typeable=false;
break;
case VAR:
case LET:
case CONST:
visitVar(t,n);
typeable=false;
break;
case NEW:
visitNew(t,n);
break;
case CALL:
visitCall(t,n);
typeable=!parent.isExprResult();
break;
case RETURN:
visitReturn(t,n);
typeable=false;
break;
case YIELD:
visitYield(t,n);
typeable=false;
break;
case DEC:
case INC:
left=n.getFirstChild();
checkPropCreation(t,left);
validator.expectNumber(t,left,getJSType(left),""String_Node_Str"");
ensureTyped(t,n,NUMBER_TYPE);
break;
case VOID:
ensureTyped(t,n,VOID_TYPE);
break;
case STRING:
case TYPEOF:
ensureTyped(t,n,STRING_TYPE);
break;
case BITNOT:
childType=getJSType(n.getFirstChild());
if (!childType.matchesNumberContext()) {
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getToken()),childType.toString());
}
 else if (this.strictOperatorChecks) {
this.validator.expectNumberStrict(n,childType,""String_Node_Str"");
}
ensureTyped(t,n,NUMBER_TYPE);
break;
case POS:
case NEG:
left=n.getFirstChild();
if (n.getToken() == Token.NEG) {
validator.expectNumber(t,left,getJSType(left),""String_Node_Str"");
}
ensureTyped(t,n,NUMBER_TYPE);
break;
case EQ:
case NE:
case SHEQ:
case SHNE:
{
left=n.getFirstChild();
right=n.getLastChild();
if (left.isTypeOf()) {
if (right.isString()) {
checkTypeofString(t,right,right.getString());
}
}
 else if (right.isTypeOf() && left.isString()) {
checkTypeofString(t,left,left.getString());
}
leftType=getJSType(left);
rightType=getJSType(right);
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=TernaryValue.UNKNOWN;
if (n.getToken() == Token.EQ || n.isNE()) {
result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if (n.isNE()) {
result=result.not();
}
}
 else {
if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
result=n.getToken() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
}
}
if (result != TernaryValue.UNKNOWN) {
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case LT:
case LE:
case GT:
case GE:
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
if (rightType.isUnknownType()) {
validator.expectStringOrNumber(t,n,leftType,""String_Node_Str"");
}
 else if (leftType.isUnknownType()) {
validator.expectStringOrNumber(t,n,leftType,""String_Node_Str"");
}
 else if (rightType.isNumber()) {
validator.expectNumber(t,n,leftType,""String_Node_Str"");
}
 else if (leftType.isNumber()) {
validator.expectNumber(t,n,rightType,""String_Node_Str"");
}
 else if (this.strictOperatorChecks) {
String errorMsg=""String_Node_Str"";
this.validator.expectMatchingTypes(n,leftType,rightType,errorMsg);
}
 else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
}
 else {
String message=""String_Node_Str"";
validator.expectString(t,n,leftType,message);
validator.expectNotNullOrUndefined(t,n,leftType,message,getNativeType(STRING_TYPE));
message=""String_Node_Str"";
validator.expectString(t,n,rightType,message);
validator.expectNotNullOrUndefined(t,n,rightType,message,getNativeType(STRING_TYPE));
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case IN:
left=n.getFirstChild();
right=n.getLastChild();
rightType=getJSType(right);
validator.expectString(t,left,getJSType(left),""String_Node_Str"");
validator.expectObject(t,n,rightType,""String_Node_Str"");
if (rightType.isStruct()) {
report(t,right,IN_USED_WITH_STRUCT);
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case INSTANCEOF:
left=n.getFirstChild();
right=n.getLastChild();
rightType=getJSType(right).restrictByNotNullOrUndefined();
validator.expectAnyObject(t,left,getJSType(left),""String_Node_Str"");
validator.expectActualObject(t,right,rightType,""String_Node_Str"");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case ASSIGN:
visitAssign(t,n);
typeable=false;
break;
case ASSIGN_LSH:
case ASSIGN_RSH:
case ASSIGN_URSH:
case ASSIGN_DIV:
case ASSIGN_MOD:
case ASSIGN_BITOR:
case ASSIGN_BITXOR:
case ASSIGN_BITAND:
case ASSIGN_SUB:
case ASSIGN_ADD:
case ASSIGN_MUL:
checkPropCreation(t,n.getFirstChild());
case LSH:
case RSH:
case URSH:
case DIV:
case MOD:
case BITOR:
case BITXOR:
case BITAND:
case SUB:
case ADD:
case MUL:
visitBinaryOperator(n.getToken(),t,n);
break;
case TRUE:
case FALSE:
case NOT:
case DELPROP:
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case CASE:
JSType switchType=getJSType(parent.getFirstChild());
JSType caseType=getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t,n,switchType,caseType);
typeable=false;
break;
case WITH:
{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,""String_Node_Str"");
typeable=false;
break;
}
case MEMBER_FUNCTION_DEF:
ensureTyped(t,n,getJSType(n.getFirstChild()));
break;
case FUNCTION:
visitFunction(t,n);
break;
case PARAM_LIST:
case STRING_KEY:
case LABEL:
case LABEL_NAME:
case SWITCH:
case BREAK:
case CATCH:
case TRY:
case SCRIPT:
case EXPR_RESULT:
case BLOCK:
case ROOT:
case EMPTY:
case DEFAULT_CASE:
case CONTINUE:
case DEBUGGER:
case THROW:
case DO:
case IF:
case WHILE:
case FOR:
typeable=false;
break;
case FOR_IN:
Node obj=n.getSecondChild();
if (getJSType(obj).isStruct()) {
report(t,obj,IN_USED_WITH_STRUCT);
}
typeable=false;
break;
case FOR_OF:
ensureTyped(t,n.getSecondChild());
JSType iterable=getJSType(n.getSecondChild());
JSType autoboxedIterable=iterable.autoboxesTo();
iterable=autoboxedIterable != null ? autoboxedIterable : iterable;
validator.expectIterable(t,n.getSecondChild(),iterable,""String_Node_Str"");
typeable=false;
Node loopVarNode=NodeUtil.isNameDeclaration(n.getFirstChild()) ? n.getFirstFirstChild() : n.getFirstChild();
JSType declaredType=loopVarNode.getJSType();
if (declaredType != null) {
JSType actualType=iterable.getTemplateTypeMap().getResolvedTemplateType(typeRegistry.getIterableTemplate());
validator.expectCanAssignTo(t,loopVarNode,actualType,declaredType,""String_Node_Str"");
}
break;
case AND:
case HOOK:
case OBJECTLIT:
case OR:
if (n.getJSType() != null) {
ensureTyped(t,n);
}
 else {
if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
ensureTyped(t,n,parent.getJSType());
}
 else {
ensureTyped(t,n);
}
}
if (n.isObjectLit()) {
JSType typ=getJSType(n);
for (Node key : n.children()) {
visitObjLitKey(t,key,n,typ);
}
}
break;
default :
report(t,n,UNEXPECTED_TOKEN,n.getToken().toString());
ensureTyped(t,n);
break;
}
typeable=typeable && !inExterns;
if (typeable) {
doPercentTypedAccounting(t,n);
}
checkJsdocInfoContainsObjectWithBadKey(t,n);
}",0.9976546105419084
27118,"protected void initTypes(){
  ALL_TYPE=registry.getNativeType(JSTypeNative.ALL_TYPE);
  NO_OBJECT_TYPE=registry.getNativeObjectType(JSTypeNative.NO_OBJECT_TYPE);
  NO_TYPE=registry.getNativeObjectType(JSTypeNative.NO_TYPE);
  NO_RESOLVED_TYPE=registry.getNativeObjectType(JSTypeNative.NO_RESOLVED_TYPE);
  ARRAY_FUNCTION_TYPE=registry.getNativeFunctionType(JSTypeNative.ARRAY_FUNCTION_TYPE);
  ARRAY_TYPE=registry.getNativeObjectType(JSTypeNative.ARRAY_TYPE);
  BOOLEAN_OBJECT_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE);
  BOOLEAN_OBJECT_TYPE=registry.getNativeObjectType(JSTypeNative.BOOLEAN_OBJECT_TYPE);
  BOOLEAN_TYPE=registry.getNativeType(JSTypeNative.BOOLEAN_TYPE);
  CHECKED_UNKNOWN_TYPE=registry.getNativeObjectType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
  DATE_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.DATE_FUNCTION_TYPE);
  DATE_TYPE=registry.getNativeObjectType(JSTypeNative.DATE_TYPE);
  ERROR_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.ERROR_FUNCTION_TYPE);
  ERROR_TYPE=registry.getNativeObjectType(JSTypeNative.ERROR_TYPE);
  EVAL_ERROR_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.EVAL_ERROR_FUNCTION_TYPE);
  EVAL_ERROR_TYPE=registry.getNativeObjectType(JSTypeNative.EVAL_ERROR_TYPE);
  FUNCTION_FUNCTION_TYPE=registry.getNativeFunctionType(JSTypeNative.FUNCTION_FUNCTION_TYPE);
  FUNCTION_INSTANCE_TYPE=registry.getNativeFunctionType(JSTypeNative.FUNCTION_INSTANCE_TYPE);
  FUNCTION_PROTOTYPE=registry.getNativeObjectType(JSTypeNative.FUNCTION_PROTOTYPE);
  GREATEST_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.GREATEST_FUNCTION_TYPE);
  LEAST_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);
  NULL_TYPE=registry.getNativeType(JSTypeNative.NULL_TYPE);
  NUMBER_OBJECT_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE);
  NUMBER_OBJECT_TYPE=registry.getNativeObjectType(JSTypeNative.NUMBER_OBJECT_TYPE);
  NUMBER_STRING_BOOLEAN=registry.getNativeType(JSTypeNative.NUMBER_STRING_BOOLEAN);
  NUMBER_STRING_BOOLEAN_SYMBOL=registry.getNativeType(JSTypeNative.NUMBER_STRING_BOOLEAN_SYMBOL);
  NUMBER_TYPE=registry.getNativeType(JSTypeNative.NUMBER_TYPE);
  OBJECT_FUNCTION_TYPE=registry.getNativeFunctionType(JSTypeNative.OBJECT_FUNCTION_TYPE);
  NULL_VOID=registry.getNativeType(JSTypeNative.NULL_VOID);
  OBJECT_NUMBER_STRING=registry.getNativeType(JSTypeNative.OBJECT_NUMBER_STRING);
  OBJECT_NUMBER_STRING_BOOLEAN=registry.getNativeType(JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN);
  OBJECT_NUMBER_STRING_BOOLEAN_SYMBOL=registry.getNativeType(JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN_SYMBOL);
  OBJECT_PROTOTYPE=registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE);
  OBJECT_TYPE=registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);
  RANGE_ERROR_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.RANGE_ERROR_FUNCTION_TYPE);
  RANGE_ERROR_TYPE=registry.getNativeObjectType(JSTypeNative.RANGE_ERROR_TYPE);
  REFERENCE_ERROR_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE);
  REFERENCE_ERROR_TYPE=registry.getNativeObjectType(JSTypeNative.REFERENCE_ERROR_TYPE);
  REGEXP_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.REGEXP_FUNCTION_TYPE);
  REGEXP_TYPE=registry.getNativeObjectType(JSTypeNative.REGEXP_TYPE);
  STRING_OBJECT_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.STRING_OBJECT_FUNCTION_TYPE);
  STRING_OBJECT_TYPE=registry.getNativeObjectType(JSTypeNative.STRING_OBJECT_TYPE);
  STRING_TYPE=registry.getNativeType(JSTypeNative.STRING_TYPE);
  SYMBOL_OBJECT_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.SYMBOL_OBJECT_FUNCTION_TYPE);
  SYMBOL_OBJECT_TYPE=registry.getNativeObjectType(JSTypeNative.SYMBOL_OBJECT_TYPE);
  SYMBOL_TYPE=registry.getNativeType(JSTypeNative.SYMBOL_TYPE);
  SYNTAX_ERROR_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE);
  SYNTAX_ERROR_TYPE=registry.getNativeObjectType(JSTypeNative.SYNTAX_ERROR_TYPE);
  TYPE_ERROR_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.TYPE_ERROR_FUNCTION_TYPE);
  TYPE_ERROR_TYPE=registry.getNativeObjectType(JSTypeNative.TYPE_ERROR_TYPE);
  U2U_CONSTRUCTOR_TYPE=registry.getNativeFunctionType(JSTypeNative.U2U_CONSTRUCTOR_TYPE);
  U2U_FUNCTION_TYPE=registry.getNativeFunctionType(JSTypeNative.U2U_FUNCTION_TYPE);
  UNKNOWN_TYPE=registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE);
  URI_ERROR_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.URI_ERROR_FUNCTION_TYPE);
  URI_ERROR_TYPE=registry.getNativeObjectType(JSTypeNative.URI_ERROR_TYPE);
  VOID_TYPE=registry.getNativeType(JSTypeNative.VOID_TYPE);
  addNativeProperties(registry);
  NATIVE_PROPERTIES_COUNT=OBJECT_TYPE.getPropertiesCount();
}","protected void initTypes(){
  ALL_TYPE=registry.getNativeType(JSTypeNative.ALL_TYPE);
  NO_OBJECT_TYPE=registry.getNativeObjectType(JSTypeNative.NO_OBJECT_TYPE);
  NO_TYPE=registry.getNativeObjectType(JSTypeNative.NO_TYPE);
  NO_RESOLVED_TYPE=registry.getNativeObjectType(JSTypeNative.NO_RESOLVED_TYPE);
  ARRAY_FUNCTION_TYPE=registry.getNativeFunctionType(JSTypeNative.ARRAY_FUNCTION_TYPE);
  ARRAY_TYPE=registry.getNativeObjectType(JSTypeNative.ARRAY_TYPE);
  BOOLEAN_OBJECT_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE);
  BOOLEAN_OBJECT_TYPE=registry.getNativeObjectType(JSTypeNative.BOOLEAN_OBJECT_TYPE);
  BOOLEAN_TYPE=registry.getNativeType(JSTypeNative.BOOLEAN_TYPE);
  CHECKED_UNKNOWN_TYPE=registry.getNativeObjectType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
  DATE_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.DATE_FUNCTION_TYPE);
  DATE_TYPE=registry.getNativeObjectType(JSTypeNative.DATE_TYPE);
  ERROR_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.ERROR_FUNCTION_TYPE);
  ERROR_TYPE=registry.getNativeObjectType(JSTypeNative.ERROR_TYPE);
  EVAL_ERROR_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.EVAL_ERROR_FUNCTION_TYPE);
  EVAL_ERROR_TYPE=registry.getNativeObjectType(JSTypeNative.EVAL_ERROR_TYPE);
  FUNCTION_FUNCTION_TYPE=registry.getNativeFunctionType(JSTypeNative.FUNCTION_FUNCTION_TYPE);
  FUNCTION_INSTANCE_TYPE=registry.getNativeFunctionType(JSTypeNative.FUNCTION_INSTANCE_TYPE);
  FUNCTION_PROTOTYPE=registry.getNativeObjectType(JSTypeNative.FUNCTION_PROTOTYPE);
  GREATEST_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.GREATEST_FUNCTION_TYPE);
  LEAST_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);
  NULL_TYPE=registry.getNativeType(JSTypeNative.NULL_TYPE);
  NUMBER_OBJECT_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE);
  NUMBER_OBJECT_TYPE=registry.getNativeObjectType(JSTypeNative.NUMBER_OBJECT_TYPE);
  NUMBER_STRING_BOOLEAN=registry.getNativeType(JSTypeNative.NUMBER_STRING_BOOLEAN);
  NUMBER_TYPE=registry.getNativeType(JSTypeNative.NUMBER_TYPE);
  OBJECT_FUNCTION_TYPE=registry.getNativeFunctionType(JSTypeNative.OBJECT_FUNCTION_TYPE);
  NULL_VOID=registry.getNativeType(JSTypeNative.NULL_VOID);
  OBJECT_NUMBER_STRING=registry.getNativeType(JSTypeNative.OBJECT_NUMBER_STRING);
  OBJECT_NUMBER_STRING_BOOLEAN=registry.getNativeType(JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN);
  OBJECT_PROTOTYPE=registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE);
  OBJECT_TYPE=registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);
  RANGE_ERROR_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.RANGE_ERROR_FUNCTION_TYPE);
  RANGE_ERROR_TYPE=registry.getNativeObjectType(JSTypeNative.RANGE_ERROR_TYPE);
  REFERENCE_ERROR_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE);
  REFERENCE_ERROR_TYPE=registry.getNativeObjectType(JSTypeNative.REFERENCE_ERROR_TYPE);
  REGEXP_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.REGEXP_FUNCTION_TYPE);
  REGEXP_TYPE=registry.getNativeObjectType(JSTypeNative.REGEXP_TYPE);
  STRING_OBJECT_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.STRING_OBJECT_FUNCTION_TYPE);
  STRING_OBJECT_TYPE=registry.getNativeObjectType(JSTypeNative.STRING_OBJECT_TYPE);
  STRING_TYPE=registry.getNativeType(JSTypeNative.STRING_TYPE);
  SYMBOL_OBJECT_TYPE=registry.getNativeObjectType(JSTypeNative.SYMBOL_OBJECT_TYPE);
  SYMBOL_TYPE=registry.getNativeType(JSTypeNative.SYMBOL_TYPE);
  SYNTAX_ERROR_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE);
  SYNTAX_ERROR_TYPE=registry.getNativeObjectType(JSTypeNative.SYNTAX_ERROR_TYPE);
  TYPE_ERROR_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.TYPE_ERROR_FUNCTION_TYPE);
  TYPE_ERROR_TYPE=registry.getNativeObjectType(JSTypeNative.TYPE_ERROR_TYPE);
  U2U_CONSTRUCTOR_TYPE=registry.getNativeFunctionType(JSTypeNative.U2U_CONSTRUCTOR_TYPE);
  U2U_FUNCTION_TYPE=registry.getNativeFunctionType(JSTypeNative.U2U_FUNCTION_TYPE);
  UNKNOWN_TYPE=registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE);
  URI_ERROR_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.URI_ERROR_FUNCTION_TYPE);
  URI_ERROR_TYPE=registry.getNativeObjectType(JSTypeNative.URI_ERROR_TYPE);
  VOID_TYPE=registry.getNativeType(JSTypeNative.VOID_TYPE);
  addNativeProperties(registry);
  NATIVE_PROPERTIES_COUNT=OBJECT_TYPE.getPropertiesCount();
}",0.9661728940968384
27119,"protected final void assertTypeNotEquals(String msg,JSType a,JSType b){
  Asserts.assertTypeNotEquals(msg,a,b);
}","protected final void assertTypeNotEquals(JSType a,JSType b){
  Asserts.assertTypeNotEquals(a,b);
}",0.9289099526066352
27120,"/** 
 * Gets a   {@link Property} given the node that references it; the {@link Property} is createdif it does not already exist.
 * @return A {@link Property}, or null if the provided node is not a qualified name.
 */
private Property getOrCreateProperty(Node propNode){
  if (!propNode.isQualifiedName()) {
    return null;
  }
  String propName=propNode.isGetProp() ? propNode.getLastChild().getString() : propNode.getQualifiedName();
  if (propertyMap.containsKey(propName)) {
    return propertyMap.get(propName);
  }
  Property property=new Property(propName);
  propertyMap.put(propName,property);
  if (propNode.isGetProp()) {
    Property parentProperty=getOrCreateProperty(propNode.getFirstChild());
    if (parentProperty != null) {
      parentProperty.children.add(property);
    }
  }
  return property;
}","/** 
 * Gets a   {@link Property} given the node that references it; the {@link Property} is createdif it does not already exist.
 * @return A {@link Property}, or null if the provided node is not a qualified name.
 */
private Property getOrCreateProperty(Node propNode){
  if (!propNode.isQualifiedName()) {
    return null;
  }
  String propName=propNode.isGetProp() ? propNode.getLastChild().getString() : propNode.getQualifiedName();
  Property property=propertyMap.computeIfAbsent(propName,name -> new Property(name));
  if (propNode.isGetProp()) {
    Property parentProperty=getOrCreateProperty(propNode.getFirstChild());
    if (parentProperty != null) {
      parentProperty.children.add(property);
    }
  }
  return property;
}",0.8978805394990366
27121,"/** 
 * Walk the AST from the call site to the expression root and verify that the portions of the expression that are evaluated before the call: 1) are unaffected by the side-effects, if any, of the call. 2) have no side-effects, that may influence the call. For example, if x has side-effects: a = 1 + x(); the call to x can be moved because the final value of ""a"" can not be influenced by x(), but in: a = b + x(); the call to x cannot be moved because the value of ""b"" may be modified by the call to x. If x is without side-effects in: a = b + x(); the call to x can be moved, but in: a = (b.foo = c) + x(); the call to x can not be moved because the value of b.foo may be referenced by x().  Note: this is true even if b is a local variable; the object that b refers to may have a global alias.
 * @return UNDECOMPOSABLE if the expression cannot be moved, DECOMPOSABLE ifdecomposition is required before the expression can be moved, otherwise MOVABLE.
 */
private DecompositionType isSubexpressionMovable(Node expressionRoot,Node subExpression){
  boolean requiresDecomposition=false;
  boolean seenSideEffects=NodeUtil.mayHaveSideEffects(subExpression,compiler);
  Node child=subExpression;
  for (  Node parent : child.getAncestors()) {
    if (parent == expressionRoot) {
      return requiresDecomposition ? DecompositionType.DECOMPOSABLE : DecompositionType.MOVABLE;
    }
    if (isConditionalOp(parent)) {
      if (child != parent.getFirstChild()) {
        requiresDecomposition=true;
      }
    }
 else {
      if (isSafeAssign(parent,seenSideEffects)) {
      }
 else {
        for (        Node n : parent.children()) {
          if (n == child) {
            break;
          }
          if (isExpressionTreeUnsafe(n,seenSideEffects)) {
            seenSideEffects=true;
            requiresDecomposition=true;
          }
        }
        Node first=parent.getFirstChild();
        if (requiresDecomposition && parent.isCall() && NodeUtil.isGet(first)) {
          if (allowMethodCallDecomposing) {
            return DecompositionType.DECOMPOSABLE;
          }
 else {
            return DecompositionType.UNDECOMPOSABLE;
          }
        }
      }
    }
    child=parent;
  }
  throw new IllegalStateException(""String_Node_Str"");
}","/** 
 * Walk the AST from the call site to the expression root and verify that the portions of the expression that are evaluated before the call: 1) are unaffected by the side-effects, if any, of the call. 2) have no side-effects, that may influence the call. For example, if x has side-effects: a = 1 + x(); the call to x can be moved because the final value of ""a"" can not be influenced by x(), but in: a = b + x(); the call to x cannot be moved because the value of ""b"" may be modified by the call to x. If x is without side-effects in: a = b + x(); the call to x can be moved, but in: a = (b.foo = c) + x(); the call to x can not be moved because the value of b.foo may be referenced by x().  Note: this is true even if b is a local variable; the object that b refers to may have a global alias.
 * @return UNDECOMPOSABLE if the expression cannot be moved, DECOMPOSABLE ifdecomposition is required before the expression can be moved, otherwise MOVABLE.
 */
private DecompositionType isSubexpressionMovable(Node expressionRoot,Node subExpression){
  boolean requiresDecomposition=false;
  boolean seenSideEffects=NodeUtil.mayHaveSideEffects(subExpression,compiler);
  Node child=subExpression;
  for (  Node parent : child.getAncestors()) {
    if (parent == expressionRoot) {
      return requiresDecomposition ? DecompositionType.DECOMPOSABLE : DecompositionType.MOVABLE;
    }
    if (isConditionalOp(parent)) {
      if (child != parent.getFirstChild()) {
        requiresDecomposition=true;
      }
    }
 else {
      if (isSafeAssign(parent,seenSideEffects)) {
      }
 else {
        EvaluationDirection direction=getEvaluationDirection(parent);
        for (Node n=getFirstEvaluatedChild(parent,direction); n != null; n=getNextEvaluatedSibling(n,direction)) {
          if (n == child) {
            break;
          }
          if (isExpressionTreeUnsafe(n,seenSideEffects)) {
            seenSideEffects=true;
            requiresDecomposition=true;
          }
        }
        Node first=parent.getFirstChild();
        if (requiresDecomposition && parent.isCall() && NodeUtil.isGet(first)) {
          if (allowMethodCallDecomposing) {
            return DecompositionType.DECOMPOSABLE;
          }
 else {
            return DecompositionType.UNDECOMPOSABLE;
          }
        }
      }
    }
    child=parent;
  }
  throw new IllegalStateException(""String_Node_Str"");
}",0.9574010327022376
27122,"private void replaceSymbol(NodeTraversal t,Node node,String name,CompilerInput input){
  Node parent=node.getParent();
  boolean isCrossModule=isCrossModuleName(name);
  if (!isCrossModule) {
    if (!NodeUtil.isNameDeclaration(parent)) {
      return;
    }
    boolean hasInterestingChildren=false;
    for (    Node c : parent.children()) {
      if (!c.isName() || isCrossModuleName(c.getString()) || isExternVar(c.getString(),t)) {
        hasInterestingChildren=true;
        break;
      }
    }
    if (!hasInterestingChildren) {
      return;
    }
  }
  Node replacement=isCrossModule ? IR.getprop(IR.name(globalSymbolNamespace).srcref(node),IR.string(name).srcref(node)) : IR.name(name).srcref(node);
  replacement.srcref(node);
  if (node.hasChildren()) {
    Node assign=IR.assign(replacement,node.removeFirstChild());
    parent.replaceChild(node,assign);
    compiler.reportChangeToEnclosingScope(assign);
  }
 else   if (isCrossModule) {
    parent.replaceChild(node,replacement);
    compiler.reportChangeToEnclosingScope(replacement);
    if (parent.isCall() && !maybeReferencesThis.contains(name)) {
      parent.putBooleanProp(Node.FREE_CALL,false);
    }
  }
  if (!isCrossModule && NodeUtil.isNameDeclaration(parent)) {
    preDeclarations.add(new ModuleGlobal(input.getAstRoot(compiler),IR.name(name).srcref(node)));
  }
  compiler.reportChangeToEnclosingScope(parent);
}","/** 
 * Replaces a global cross-module name with an access on the global namespace symbol 
 */
private void replaceSymbol(Node node,String name){
  Node parent=node.getParent();
  Node replacement=IR.getprop(IR.name(globalSymbolNamespace),IR.string(name));
  replacement.useSourceInfoFromForTree(node);
  parent.replaceChild(node,replacement);
  compiler.reportChangeToEnclosingScope(replacement);
  if (parent.isCall() && !maybeReferencesThis.contains(name)) {
    parent.putBooleanProp(Node.FREE_CALL,false);
  }
  compiler.reportChangeToEnclosingScope(parent);
}",0.3481368044920878
27123,"/** 
 * Rewrites extern names to be explicit children of window instead of only implicitly referencing it. This enables injecting window into a scope and make all global symbols depend on the injected object.
 */
private void visitExtern(Node nameNode,Node parent){
  String name=nameNode.getString();
  if (globalSymbolNamespace.equals(name) || SPECIAL_EXTERNS.contains(name)) {
    return;
  }
  Node windowPropAccess=IR.getprop(IR.name(WINDOW),IR.string(name));
  if (NodeUtil.isNameDeclaration(parent) && nameNode.hasOneChild()) {
    Node assign=IR.assign(windowPropAccess,nameNode.removeFirstChild());
    assign.setJSDocInfo(parent.getJSDocInfo());
    parent.replaceChild(nameNode,assign.srcrefTree(parent));
  }
 else {
    parent.replaceChild(nameNode,windowPropAccess.srcrefTree(nameNode));
  }
  compiler.reportChangeToEnclosingScope(parent);
}","/** 
 * Rewrites extern names to be explicit children of window instead of only implicitly referencing it. This enables injecting window into a scope and make all global symbols depend on the injected object.
 */
private void visitExtern(Node nameNode,Node parent){
  String name=nameNode.getString();
  if (globalSymbolNamespace.equals(name) || SPECIAL_EXTERNS.contains(name)) {
    return;
  }
  Node windowPropAccess=IR.getprop(IR.name(WINDOW),IR.string(name));
  parent.replaceChild(nameNode,windowPropAccess.srcrefTree(nameNode));
  compiler.reportChangeToEnclosingScope(parent);
}",0.6893203883495146
27124,"private void visitName(NodeTraversal t,Node n,Node parent){
  String name=n.getString();
  if (parent.isFunction() && name.isEmpty()) {
    return;
  }
  if (isExternVar(name,t)) {
    visitExtern(n,parent);
    return;
  }
  Var var=t.getScope().getVar(name);
  if (!var.isGlobal() && (name.equals(globalSymbolNamespace) || name.startsWith(globalSymbolNamespace + DISAMBIGUATION_SUFFIX))) {
    n.setString(name + DISAMBIGUATION_SUFFIX);
    compiler.reportChangeToEnclosingScope(n);
  }
  if (!var.isGlobal()) {
    return;
  }
  replaceSymbol(t,n,name,t.getInput());
}","private void visitName(NodeTraversal t,Node n,Node parent){
  String name=n.getString();
  if (parent.isFunction() && name.isEmpty()) {
    return;
  }
  if (isExternVar(name,t)) {
    visitExtern(n,parent);
    return;
  }
  Var var=t.getScope().getVar(name);
  if (!var.isGlobal() && (name.equals(globalSymbolNamespace) || name.startsWith(globalSymbolNamespace + DISAMBIGUATION_SUFFIX))) {
    n.setString(name + DISAMBIGUATION_SUFFIX);
    compiler.reportChangeToEnclosingScope(n);
  }
  if (!(var.isGlobal() && isCrossModuleName(name))) {
    return;
  }
  replaceSymbol(n,name);
}",0.9550173010380624
27125,"public void testObjectDestructuringDeclarations(){
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
}","public void testObjectDestructuringDeclarations(){
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
}",0.948216340621404
27126,"public void testSameVarDeclaredInExternsAndSource(){
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
}","public void testSameVarDeclaredInExternsAndSource(){
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
}",0.9587242026266416
27127,"public void testObjectDestructuringDeclarations_acrossModules(){
  assumeCrossModuleNames=false;
  test(createModules(""String_Node_Str"",""String_Node_Str""),new String[]{""String_Node_Str"",""String_Node_Str""});
  test(createModules(""String_Node_Str"",""String_Node_Str""),new String[]{""String_Node_Str"",""String_Node_Str""});
  test(createModules(""String_Node_Str"",""String_Node_Str""),new String[]{""String_Node_Str"",""String_Node_Str""});
  test(createModules(""String_Node_Str"",""String_Node_Str""),new String[]{""String_Node_Str"",""String_Node_Str""});
}","public void testObjectDestructuringDeclarations_acrossModules(){
  assumeCrossModuleNames=false;
  test(createModules(""String_Node_Str"",""String_Node_Str""),new String[]{""String_Node_Str"",""String_Node_Str""});
  test(createModules(""String_Node_Str"",""String_Node_Str""),new String[]{""String_Node_Str"",""String_Node_Str""});
  test(createModules(""String_Node_Str"",""String_Node_Str""),new String[]{""String_Node_Str"",""String_Node_Str""});
  test(createModules(""String_Node_Str"",""String_Node_Str""),new String[]{""String_Node_Str"",""String_Node_Str""});
  test(createModules(""String_Node_Str"",""String_Node_Str""),new String[]{""String_Node_Str"",""String_Node_Str""});
  test(createModules(""String_Node_Str"",""String_Node_Str""),new String[]{""String_Node_Str"",""String_Node_Str""});
}",0.8302469135802469
27128,"public void testObjectDestructuringDeclarations_allSameModule(){
  assumeCrossModuleNames=false;
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
}","public void testObjectDestructuringDeclarations_allSameModule(){
  assumeCrossModuleNames=false;
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
}",0.8815286624203822
27129,"/** 
 * Expect that the given variable has not been declared with a type.
 * @param sourceName The name of the source file we're in.
 * @param n The node where warnings should point to.
 * @param parent The parent of {@code n}.
 * @param var The variable that we're checking.
 * @param variableName The name of the variable.
 * @param newType The type being applied to the variable. Mostly just herefor the benefit of the warning.
 * @return The variable we end up with. Most of the time, this will justbe  {@code var}, but in some rare cases we will need to declare a new var with new source info.
 */
TypedVar expectUndeclaredVariable(String sourceName,CompilerInput input,Node n,Node parent,TypedVar var,String variableName,JSType newType){
  TypedVar newVar=var;
  JSType varType=var.getType();
  if (varType != null && varType != typeRegistry.getNativeType(UNKNOWN_TYPE) && newType != null && newType != typeRegistry.getNativeType(UNKNOWN_TYPE)) {
    if (var.input == null) {
      TypedScope s=var.getScope();
      s.undeclare(var);
      newVar=s.declare(variableName,n,varType,input,false);
      n.setJSType(varType);
      if (parent.isVar()) {
        if (n.hasChildren()) {
          n.getFirstChild().setJSType(varType);
        }
      }
 else {
        checkState(parent.isFunction());
        parent.setJSType(varType);
      }
    }
 else {
      boolean allowDupe=hasDuplicateDeclarationSuppression(compiler,var.getNameNode());
      if (!allowDupe) {
        if (!newType.isEquivalentTo(varType)) {
          report(JSError.make(n,DUP_VAR_DECLARATION_TYPE_MISMATCH,variableName,newType.toString(),var.getInputName(),String.valueOf(var.nameNode.getLineno()),varType.toString()));
        }
 else         if (!var.getParentNode().isExprResult()) {
          report(JSError.make(n,DUP_VAR_DECLARATION,variableName,var.getInputName(),String.valueOf(var.nameNode.getLineno())));
        }
      }
    }
  }
  return newVar;
}","/** 
 * Expect that the given variable has not been declared with a type.
 * @param sourceName The name of the source file we're in.
 * @param n The node where warnings should point to.
 * @param parent The parent of {@code n}.
 * @param var The variable that we're checking.
 * @param variableName The name of the variable.
 * @param newType The type being applied to the variable. Mostly just herefor the benefit of the warning.
 * @return The variable we end up with. Most of the time, this will justbe  {@code var}, but in some rare cases we will need to declare a new var with new source info.
 */
TypedVar expectUndeclaredVariable(String sourceName,CompilerInput input,Node n,Node parent,TypedVar var,String variableName,JSType newType){
  TypedVar newVar=var;
  JSType varType=var.getType();
  if (varType != null && varType != typeRegistry.getNativeType(UNKNOWN_TYPE) && newType != null && newType != typeRegistry.getNativeType(UNKNOWN_TYPE)) {
    if (var.input == null) {
      TypedScope s=var.getScope();
      s.undeclare(var);
      newVar=s.declare(variableName,n,varType,input,false);
      n.setJSType(varType);
      if (parent.isVar()) {
        if (n.hasChildren()) {
          n.getFirstChild().setJSType(varType);
        }
      }
 else {
        checkState(parent.isFunction());
        parent.setJSType(varType);
      }
    }
 else {
      boolean allowDupe=hasDuplicateDeclarationSuppression(compiler,var.getNameNode());
      if (!allowDupe) {
        if (!newType.isEquivalentTo(varType,true)) {
          report(JSError.make(n,DUP_VAR_DECLARATION_TYPE_MISMATCH,variableName,newType.toString(),var.getInputName(),String.valueOf(var.nameNode.getLineno()),varType.toString()));
        }
 else         if (!var.getParentNode().isExprResult()) {
          report(JSError.make(n,DUP_VAR_DECLARATION,variableName,var.getInputName(),String.valueOf(var.nameNode.getLineno())));
        }
      }
    }
  }
  return newVar;
}",0.9987136609210188
27130,"/** 
 * Whether this type is meaningfully different from   {@code that} type forthe purposes of data flow analysis. This is a trickier check than pure equality, because it has to properly handle unknown types. See  {@code EquivalenceMethod} for more info.
 * @see <a href=""http://www.youtube.com/watch?v=_RpSv3HjpEw"">Unknown unknowns</a>
 */
public final boolean differsFrom(JSType that){
  return !checkEquivalenceHelper(that,EquivalenceMethod.DATA_FLOW);
}","/** 
 * Whether this type is meaningfully different from   {@code that} type forthe purposes of data flow analysis. This is a trickier check than pure equality, because it has to properly handle unknown types. See  {@code EquivalenceMethod} for more info.
 * @see <a href=""http://www.youtube.com/watch?v=_RpSv3HjpEw"">Unknown unknowns</a>
 */
public final boolean differsFrom(JSType that){
  return !checkEquivalenceHelper(that,EquivalenceMethod.DATA_FLOW,EqCache.create());
}",0.9817792068595927
27131,"/** 
 * Detects cycles in either the implicit prototype chain, or the implemented/extended interfaces.<p>
 * @return True iff a cycle was detected.
 */
final boolean detectInheritanceCycle(){
  return detectImplicitPrototypeCycle() || Iterables.contains(this.getCtorImplementedInterfaces(),this) || Iterables.contains(this.getCtorExtendedInterfaces(),this);
}","/** 
 * Detects cycles in either the implicit prototype chain, or the implemented/extended interfaces.<p>
 * @return True iff a cycle was detected.
 */
final boolean detectInheritanceCycle(){
  if (detectImplicitPrototypeCycle() || Iterables.contains(this.getCtorImplementedInterfaces(),this)) {
    return true;
  }
  FunctionType fnType=this.getConstructor();
  return fnType != null && fnType.checkExtendsLoop() != null;
}",0.7806122448979592
27132,"public static void assertTypeEquals(String message,JSType a,JSType b){
  checkNotNull(a);
  checkNotNull(b);
  Assert.assertTrue(message + (message.isEmpty() ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ a+ ""String_Node_Str""+ ""String_Node_Str""+ b,a.isEquivalentTo(b));
  Assert.assertTrue(message + ""String_Node_Str"" + ""String_Node_Str""+ b+ ""String_Node_Str""+ ""String_Node_Str""+ a,b.isEquivalentTo(a));
}","public static void assertTypeEquals(String message,JSType a,JSType b){
  checkNotNull(a);
  checkNotNull(b);
  Assert.assertTrue(message + (message.isEmpty() ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ a+ ""String_Node_Str""+ ""String_Node_Str""+ b,a.isEquivalentTo(b,true));
  Assert.assertTrue(message + ""String_Node_Str"" + ""String_Node_Str""+ b+ ""String_Node_Str""+ ""String_Node_Str""+ a,b.isEquivalentTo(a,true));
}",0.9882352941176472
27133,"public void verifySubtypeChain(List<JSType> typeChain,boolean checkSubtyping) throws Exception {
  for (int i=0; i < typeChain.size(); i++) {
    for (int j=0; j < typeChain.size(); j++) {
      JSType typeI=typeChain.get(i);
      JSType typeJ=typeChain.get(j);
      JSType namedTypeI=getNamedWrapper(""String_Node_Str"",typeI);
      JSType namedTypeJ=getNamedWrapper(""String_Node_Str"",typeJ);
      JSType proxyTypeI=new ProxyObjectType(registry,typeI);
      JSType proxyTypeJ=new ProxyObjectType(registry,typeJ);
      if (i == j) {
        assertTrue(typeI + ""String_Node_Str"",typeI.isEquivalentTo(typeI));
        assertTrue(""String_Node_Str"" + typeI + ""String_Node_Str"",namedTypeI.isEquivalentTo(namedTypeI));
        assertTrue(""String_Node_Str"" + typeI + ""String_Node_Str"",proxyTypeI.isEquivalentTo(proxyTypeI));
      }
 else {
        boolean shouldCheck=true;
        ObjectType objectI=typeI.toObjectType();
        ObjectType objectJ=typeJ.toObjectType();
        if (objectI != null && objectJ != null) {
          FunctionType constructorI=objectI.getConstructor();
          FunctionType constructorJ=objectJ.getConstructor();
          if (constructorI != null && constructorJ != null && constructorI.isStructuralInterface() && constructorJ.isStructuralInterface()) {
            if (constructorI.checkEquivalenceHelper(constructorJ,EquivalenceMethod.IDENTITY)) {
              shouldCheck=false;
            }
          }
        }
        if (shouldCheck) {
          assertFalse(typeI + ""String_Node_Str"" + typeJ,typeI.isEquivalentTo(typeJ));
          assertFalse(""String_Node_Str"" + typeI + ""String_Node_Str""+ typeJ,namedTypeI.isEquivalentTo(namedTypeJ));
          assertFalse(""String_Node_Str"" + typeI + ""String_Node_Str""+ typeJ,proxyTypeI.isEquivalentTo(proxyTypeJ));
        }
      }
      assertTrue(typeJ + ""String_Node_Str"" + typeI,typeJ.canCastTo(typeI));
      assertTrue(typeJ + ""String_Node_Str"" + namedTypeI,typeJ.canCastTo(namedTypeI));
      assertTrue(typeJ + ""String_Node_Str"" + proxyTypeI,typeJ.canCastTo(proxyTypeI));
      assertTrue(""String_Node_Str"" + typeJ + ""String_Node_Str""+ typeI,namedTypeJ.canCastTo(typeI));
      assertTrue(""String_Node_Str"" + typeJ + ""String_Node_Str""+ typeI,namedTypeJ.canCastTo(namedTypeI));
      assertTrue(""String_Node_Str"" + typeJ + ""String_Node_Str""+ typeI,namedTypeJ.canCastTo(proxyTypeI));
      assertTrue(""String_Node_Str"" + typeJ + ""String_Node_Str""+ typeI,proxyTypeJ.canCastTo(typeI));
      assertTrue(""String_Node_Str"" + typeJ + ""String_Node_Str""+ typeI,proxyTypeJ.canCastTo(namedTypeI));
      assertTrue(""String_Node_Str"" + typeJ + ""String_Node_Str""+ typeI,proxyTypeJ.canCastTo(proxyTypeI));
      if (typeI.isSubtypeOf(typeJ) && typeJ.isSubtypeOf(typeI)) {
        continue;
      }
      if (checkSubtyping) {
        if (i <= j) {
          assertTrue(typeJ + ""String_Node_Str"" + typeI,typeJ.isSubtypeOf(typeI));
          assertTrue(""String_Node_Str"" + typeJ + ""String_Node_Str""+ typeI,namedTypeJ.isSubtypeOf(namedTypeI));
          assertTrue(""String_Node_Str"" + typeJ + ""String_Node_Str""+ typeI,proxyTypeJ.isSubtypeOf(proxyTypeI));
        }
 else {
          assertFalse(typeJ + ""String_Node_Str"" + typeI,typeJ.isSubtypeOf(typeI));
          assertFalse(""String_Node_Str"" + typeJ + ""String_Node_Str""+ typeI,namedTypeJ.isSubtypeOf(namedTypeI));
          assertFalse(""String_Node_Str"" + typeJ + ""String_Node_Str""+ typeI,proxyTypeJ.isSubtypeOf(proxyTypeI));
        }
        JSType expectedSupremum=i < j ? typeI : typeJ;
        JSType expectedInfimum=i > j ? typeI : typeJ;
        assertTypeEquals(expectedSupremum + ""String_Node_Str"" + typeI+ ""String_Node_Str""+ typeJ,expectedSupremum,typeI.getLeastSupertype(typeJ));
        assertTypeEquals(expectedInfimum + ""String_Node_Str"" + typeI+ ""String_Node_Str""+ typeJ,expectedInfimum,typeI.getGreatestSubtype(typeJ));
      }
    }
  }
}","public void verifySubtypeChain(List<JSType> typeChain,boolean checkSubtyping) throws Exception {
  for (int i=0; i < typeChain.size(); i++) {
    for (int j=0; j < typeChain.size(); j++) {
      JSType typeI=typeChain.get(i);
      JSType typeJ=typeChain.get(j);
      JSType namedTypeI=getNamedWrapper(""String_Node_Str"",typeI);
      JSType namedTypeJ=getNamedWrapper(""String_Node_Str"",typeJ);
      JSType proxyTypeI=new ProxyObjectType(registry,typeI);
      JSType proxyTypeJ=new ProxyObjectType(registry,typeJ);
      if (i == j) {
        assertTrue(typeI + ""String_Node_Str"",typeI.isEquivalentTo(typeI));
        assertTrue(""String_Node_Str"" + typeI + ""String_Node_Str"",namedTypeI.isEquivalentTo(namedTypeI));
        assertTrue(""String_Node_Str"" + typeI + ""String_Node_Str"",proxyTypeI.isEquivalentTo(proxyTypeI));
      }
 else {
        boolean shouldCheck=true;
        ObjectType objectI=typeI.toObjectType();
        ObjectType objectJ=typeJ.toObjectType();
        if (objectI != null && objectJ != null) {
          FunctionType constructorI=objectI.getConstructor();
          FunctionType constructorJ=objectJ.getConstructor();
          if (constructorI != null && constructorJ != null && constructorI.isStructuralInterface() && constructorJ.isStructuralInterface()) {
            if (constructorI.isEquivalentTo(constructorJ)) {
              shouldCheck=false;
            }
          }
        }
        if (shouldCheck) {
          assertFalse(typeI + ""String_Node_Str"" + typeJ,typeI.isEquivalentTo(typeJ));
          assertFalse(""String_Node_Str"" + typeI + ""String_Node_Str""+ typeJ,namedTypeI.isEquivalentTo(namedTypeJ));
          assertFalse(""String_Node_Str"" + typeI + ""String_Node_Str""+ typeJ,proxyTypeI.isEquivalentTo(proxyTypeJ));
        }
      }
      assertTrue(typeJ + ""String_Node_Str"" + typeI,typeJ.canCastTo(typeI));
      assertTrue(typeJ + ""String_Node_Str"" + namedTypeI,typeJ.canCastTo(namedTypeI));
      assertTrue(typeJ + ""String_Node_Str"" + proxyTypeI,typeJ.canCastTo(proxyTypeI));
      assertTrue(""String_Node_Str"" + typeJ + ""String_Node_Str""+ typeI,namedTypeJ.canCastTo(typeI));
      assertTrue(""String_Node_Str"" + typeJ + ""String_Node_Str""+ typeI,namedTypeJ.canCastTo(namedTypeI));
      assertTrue(""String_Node_Str"" + typeJ + ""String_Node_Str""+ typeI,namedTypeJ.canCastTo(proxyTypeI));
      assertTrue(""String_Node_Str"" + typeJ + ""String_Node_Str""+ typeI,proxyTypeJ.canCastTo(typeI));
      assertTrue(""String_Node_Str"" + typeJ + ""String_Node_Str""+ typeI,proxyTypeJ.canCastTo(namedTypeI));
      assertTrue(""String_Node_Str"" + typeJ + ""String_Node_Str""+ typeI,proxyTypeJ.canCastTo(proxyTypeI));
      if (typeI.isSubtypeOf(typeJ) && typeJ.isSubtypeOf(typeI)) {
        continue;
      }
      if (checkSubtyping) {
        if (i <= j) {
          assertTrue(typeJ + ""String_Node_Str"" + typeI,typeJ.isSubtypeOf(typeI));
          assertTrue(""String_Node_Str"" + typeJ + ""String_Node_Str""+ typeI,namedTypeJ.isSubtypeOf(namedTypeI));
          assertTrue(""String_Node_Str"" + typeJ + ""String_Node_Str""+ typeI,proxyTypeJ.isSubtypeOf(proxyTypeI));
        }
 else {
          assertFalse(typeJ + ""String_Node_Str"" + typeI,typeJ.isSubtypeOf(typeI));
          assertFalse(""String_Node_Str"" + typeJ + ""String_Node_Str""+ typeI,namedTypeJ.isSubtypeOf(namedTypeI));
          assertFalse(""String_Node_Str"" + typeJ + ""String_Node_Str""+ typeI,proxyTypeJ.isSubtypeOf(proxyTypeI));
        }
        JSType expectedSupremum=i < j ? typeI : typeJ;
        JSType expectedInfimum=i > j ? typeI : typeJ;
        assertTypeEquals(expectedSupremum + ""String_Node_Str"" + typeI+ ""String_Node_Str""+ typeJ,expectedSupremum,typeI.getLeastSupertype(typeJ));
        assertTypeEquals(expectedInfimum + ""String_Node_Str"" + typeI+ ""String_Node_Str""+ typeJ,expectedInfimum,typeI.getGreatestSubtype(typeJ));
      }
    }
  }
}",0.9908090614886732
27134,"public AbstractScope<?,?> getClosestHoistScope(){
  for (int i=scopeRoots.size(); i > 0; i--) {
    if (isHoistScopeRootNode(scopeRoots.get(i - 1))) {
      return instantiateScopes(i);
    }
  }
  return (AbstractScope<?,?>)scopes.peek().getClosestHoistScope();
}","public AbstractScope<?,?> getClosestHoistScope(){
  for (int i=scopeRoots.size(); i > 0; i--) {
    if (isHoistScopeRootNode(scopeRoots.get(i - 1))) {
      return instantiateScopes(i);
    }
  }
  return scopes.peek().getClosestHoistScope();
}",0.9606299212598424
27135,"/** 
 * Keep applying fixes to the given file until no more fixes can be found, or until fixes have been applied   {@code MAX_FIXES} times.
 */
static void fixRepeatedly(String filename) throws IOException {
  for (int i=0; i < MAX_FIXES; i++) {
    if (!fix(filename)) {
      break;
    }
  }
}","/** 
 * Keep applying fixes to the given file until no more fixes can be found, or until fixes have been applied   {@code MAX_FIXES} times.
 */
static void fixRepeatedly(String filename,ImmutableSet<DiagnosticType> unfixableErrors) throws IOException {
  for (int i=0; i < MAX_FIXES; i++) {
    if (!fix(filename,unfixableErrors)) {
      break;
    }
  }
}",0.906584992343032
27136,"/** 
 * @return Whether any fixes were applied. 
 */
private static boolean fix(String filename) throws IOException {
  Compiler compiler=new Compiler(System.out);
  FixingErrorManager errorManager=new FixingErrorManager();
  compiler.setErrorManager(errorManager);
  errorManager.setCompiler(compiler);
  lint(Paths.get(filename),compiler);
  Collection<SuggestedFix> fixes=errorManager.getAllFixes();
  if (!fixes.isEmpty()) {
    ApplySuggestedFixes.applySuggestedFixesToFiles(fixes);
    return true;
  }
  return false;
}","/** 
 * @return Whether any fixes were applied. 
 */
private static boolean fix(String filename,ImmutableSet<DiagnosticType> unfixableErrors) throws IOException {
  Compiler compiler=new Compiler(System.out);
  FixingErrorManager errorManager=new FixingErrorManager(unfixableErrors);
  compiler.setErrorManager(errorManager);
  errorManager.setCompiler(compiler);
  lint(Paths.get(filename),compiler);
  Collection<SuggestedFix> fixes=errorManager.getAllFixes();
  if (!fixes.isEmpty()) {
    ApplySuggestedFixes.applySuggestedFixesToFiles(fixes);
    return true;
  }
  return false;
}",0.946043165467626
27137,"public FixingErrorManager(){
}","public FixingErrorManager(ImmutableSet<DiagnosticType> unfixableErrors){
  this.unfixableErrors=unfixableErrors;
}",0.4166666666666667
27138,"@Override public void report(CheckLevel level,JSError error){
  super.report(level,error);
  fixes.putAll(error,ErrorToFixMapper.getFixesForJsError(error,compiler));
}","@Override public void report(CheckLevel level,JSError error){
  super.report(level,error);
  if (!unfixableErrors.contains(error.getType())) {
    fixes.putAll(error,ErrorToFixMapper.getFixesForJsError(error,compiler));
  }
}",0.8520408163265306
27139,"@Override @SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) List<FlowScope> branchedFlowThrough(Node source,FlowScope input){
  FlowScope output=flowThrough(source,input);
  Node condition=null;
  FlowScope conditionFlowScope=null;
  BooleanOutcomePair conditionOutcomes=null;
  List<DiGraphEdge<Node,Branch>> branchEdges=getCfg().getOutEdges(source);
  List<FlowScope> result=new ArrayList<>(branchEdges.size());
  for (  DiGraphEdge<Node,Branch> branchEdge : branchEdges) {
    Branch branch=branchEdge.getValue();
    FlowScope newScope=output;
switch (branch) {
case ON_TRUE:
      if (source.isForIn() || source.isForOf()) {
        Node item=source.getFirstChild();
        Node obj=item.getNext();
        FlowScope informed=traverse(obj,output.createChildFlowScope());
        if (item.isVar()) {
          item=item.getFirstChild();
        }
        if (source.isForIn()) {
          if (item.isName()) {
            JSType iterKeyType=getNativeType(STRING_TYPE);
            ObjectType objType=getJSType(obj).dereference();
            JSType objIndexType=objType == null ? null : objType.getTemplateTypeMap().getResolvedTemplateType(registry.getObjectIndexKey());
            if (objIndexType != null && !objIndexType.isUnknownType()) {
              JSType narrowedKeyType=iterKeyType.getGreatestSubtype(objIndexType);
              if (!narrowedKeyType.isEmptyType()) {
                iterKeyType=narrowedKeyType;
              }
            }
            redeclareSimpleVar(informed,item,iterKeyType);
          }
        }
 else {
          ObjectType objType=getJSType(obj).dereference();
          if (objType.isSubtypeOf(getNativeType(JSTypeNative.ITERABLE_TYPE))) {
            if (objType.isTemplatizedType()) {
              JSType newType=objType.getTemplateTypes().get(0);
              redeclareSimpleVar(informed,item,newType);
            }
          }
        }
        newScope=informed;
        break;
      }
case ON_FALSE:
    if (condition == null) {
      condition=NodeUtil.getConditionExpression(source);
      if (condition == null && source.isCase()) {
        condition=source;
        if (conditionFlowScope == null) {
          conditionFlowScope=traverse(condition.getFirstChild(),output.createChildFlowScope());
        }
      }
    }
  if (condition != null) {
    if (condition.isAnd() || condition.isOr()) {
      if (conditionOutcomes == null) {
        conditionOutcomes=condition.isAnd() ? traverseAnd(condition,output.createChildFlowScope()) : traverseOr(condition,output.createChildFlowScope());
      }
      newScope=reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition,conditionOutcomes.getOutcomeFlowScope(condition.getToken(),branch == Branch.ON_TRUE),branch == Branch.ON_TRUE);
    }
 else {
      if (conditionFlowScope == null) {
        conditionFlowScope=traverse(condition,output.createChildFlowScope());
      }
      newScope=reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition,conditionFlowScope,branch == Branch.ON_TRUE);
    }
  }
break;
default :
break;
}
result.add(newScope.optimize());
}
return result;
}","@Override @SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) List<FlowScope> branchedFlowThrough(Node source,FlowScope input){
  FlowScope output=flowThrough(source,input);
  Node condition=null;
  FlowScope conditionFlowScope=null;
  BooleanOutcomePair conditionOutcomes=null;
  List<DiGraphEdge<Node,Branch>> branchEdges=getCfg().getOutEdges(source);
  List<FlowScope> result=new ArrayList<>(branchEdges.size());
  for (  DiGraphEdge<Node,Branch> branchEdge : branchEdges) {
    Branch branch=branchEdge.getValue();
    FlowScope newScope=output;
switch (branch) {
case ON_TRUE:
      if (source.isForIn() || source.isForOf()) {
        Node item=source.getFirstChild();
        Node obj=item.getNext();
        FlowScope informed=traverse(obj,output.createChildFlowScope());
        if (item.isVar()) {
          item=item.getFirstChild();
        }
        if (source.isForIn()) {
          if (item.isName()) {
            JSType iterKeyType=getNativeType(STRING_TYPE);
            ObjectType objType=getJSType(obj).dereference();
            JSType objIndexType=objType == null ? null : objType.getTemplateTypeMap().getResolvedTemplateType(registry.getObjectIndexKey());
            if (objIndexType != null && !objIndexType.isUnknownType()) {
              JSType narrowedKeyType=iterKeyType.getGreatestSubtype(objIndexType);
              if (!narrowedKeyType.isEmptyType()) {
                iterKeyType=narrowedKeyType;
              }
            }
            redeclareSimpleVar(informed,item,iterKeyType);
          }
        }
 else {
          ObjectType objType=getJSType(obj).dereference();
          if (objType.isSubtypeOf(getNativeType(JSTypeNative.ITERABLE_TYPE))) {
            if (objType.isTemplatizedType()) {
              JSType newType=objType.getTemplateTypeMap().getResolvedTemplateType(registry.getIterableTemplate());
              redeclareSimpleVar(informed,item,newType);
            }
          }
        }
        newScope=informed;
        break;
      }
case ON_FALSE:
    if (condition == null) {
      condition=NodeUtil.getConditionExpression(source);
      if (condition == null && source.isCase()) {
        condition=source;
        if (conditionFlowScope == null) {
          conditionFlowScope=traverse(condition.getFirstChild(),output.createChildFlowScope());
        }
      }
    }
  if (condition != null) {
    if (condition.isAnd() || condition.isOr()) {
      if (conditionOutcomes == null) {
        conditionOutcomes=condition.isAnd() ? traverseAnd(condition,output.createChildFlowScope()) : traverseOr(condition,output.createChildFlowScope());
      }
      newScope=reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition,conditionOutcomes.getOutcomeFlowScope(condition.getToken(),branch == Branch.ON_TRUE),branch == Branch.ON_TRUE);
    }
 else {
      if (conditionFlowScope == null) {
        conditionFlowScope=traverse(condition,output.createChildFlowScope());
      }
      newScope=reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition,conditionFlowScope,branch == Branch.ON_TRUE);
    }
  }
break;
default :
break;
}
result.add(newScope.optimize());
}
return result;
}",0.9890214797136038
27140,"static boolean isPrototypeAssignment(Node getProp){
  if (!getProp.isGetProp()) {
    return false;
  }
  Node parent=getProp.getParent();
  return parent.isAssign() && parent.getFirstChild() == getProp && parent.getFirstChild().getLastChild().getString().equals(""String_Node_Str"");
}","static boolean isPrototypeAssignment(Node getProp){
  if (!getProp.isGetProp()) {
    return false;
  }
  Node parent=getProp.getParent();
  return parent.isAssign() && parent.getFirstChild() == getProp && getProp.getLastChild().getString().equals(""String_Node_Str"");
}",0.9258589511754068
27141,"/** 
 * Updates the scope according to the result of a type change, like an assignment or a type cast.
 */
private void updateScopeForTypeChange(FlowScope scope,Node left,JSType leftType,JSType resultType){
  checkNotNull(resultType);
  Node right=NodeUtil.getRValueOfLValue(left);
  if (isPossibleMixinApplication(left,right)) {
    addMissingInterfaceProperties(leftType);
  }
switch (left.getToken()) {
case NAME:
    String varName=left.getString();
  TypedVar var=syntacticScope.getVar(varName);
JSType varType=var == null ? null : var.getType();
boolean isVarDeclaration=left.hasChildren() && varType != null && !var.isTypeInferred();
boolean isTypelessConstDecl=isVarDeclaration && NodeUtil.isConstantDeclaration(compiler.getCodingConvention(),var.getJSDocInfo(),var.getNameNode()) && !(var.getJSDocInfo() != null && var.getJSDocInfo().hasType());
boolean isVarTypeBetter=isVarDeclaration && !resultType.isNullType() && !resultType.isVoidType()&& !isTypelessConstDecl;
if (isVarTypeBetter) {
redeclareSimpleVar(scope,left,varType);
}
 else {
redeclareSimpleVar(scope,left,resultType);
}
left.setJSType(resultType);
if (var != null && var.isTypeInferred()) {
JSType oldType=var.getType();
var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType));
}
 else if (isTypelessConstDecl) {
var.setType(resultType);
}
break;
case GETPROP:
if (left.isQualifiedName()) {
String qualifiedName=left.getQualifiedName();
boolean declaredSlotType=false;
JSType rawObjType=left.getFirstChild().getJSType();
if (rawObjType != null) {
ObjectType objType=ObjectType.cast(rawObjType.restrictByNotNullOrUndefined());
if (objType != null) {
String propName=left.getLastChild().getString();
declaredSlotType=objType.isPropertyTypeDeclared(propName);
}
}
JSType safeLeftType=leftType == null ? unknownType : leftType;
scope.inferQualifiedSlot(left,qualifiedName,safeLeftType,resultType,declaredSlotType);
}
left.setJSType(resultType);
ensurePropertyDefined(left,resultType);
break;
default :
break;
}
}","/** 
 * Updates the scope according to the result of a type change, like an assignment or a type cast.
 */
private void updateScopeForTypeChange(FlowScope scope,Node left,JSType leftType,JSType resultType){
  checkNotNull(resultType);
  Node right=NodeUtil.getRValueOfLValue(left);
  if (isPossibleMixinApplication(left,right)) {
    addMissingInterfaceProperties(leftType);
  }
  if (isLooseAssignmentToPrototype(left,leftType,resultType)) {
    return;
  }
switch (left.getToken()) {
case NAME:
    String varName=left.getString();
  TypedVar var=syntacticScope.getVar(varName);
JSType varType=var == null ? null : var.getType();
boolean isVarDeclaration=left.hasChildren() && varType != null && !var.isTypeInferred();
boolean isTypelessConstDecl=isVarDeclaration && NodeUtil.isConstantDeclaration(compiler.getCodingConvention(),var.getJSDocInfo(),var.getNameNode()) && !(var.getJSDocInfo() != null && var.getJSDocInfo().hasType());
boolean isVarTypeBetter=isVarDeclaration && !resultType.isNullType() && !resultType.isVoidType()&& !isTypelessConstDecl;
if (isVarTypeBetter) {
redeclareSimpleVar(scope,left,varType);
}
 else {
redeclareSimpleVar(scope,left,resultType);
}
left.setJSType(resultType);
if (var != null && var.isTypeInferred()) {
JSType oldType=var.getType();
var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType));
}
 else if (isTypelessConstDecl) {
var.setType(resultType);
}
break;
case GETPROP:
if (left.isQualifiedName()) {
String qualifiedName=left.getQualifiedName();
boolean declaredSlotType=false;
JSType rawObjType=left.getFirstChild().getJSType();
if (rawObjType != null) {
ObjectType objType=ObjectType.cast(rawObjType.restrictByNotNullOrUndefined());
if (objType != null) {
String propName=left.getLastChild().getString();
declaredSlotType=objType.isPropertyTypeDeclared(propName);
}
}
JSType safeLeftType=leftType == null ? unknownType : leftType;
scope.inferQualifiedSlot(left,qualifiedName,safeLeftType,resultType,declaredSlotType);
}
left.setJSType(resultType);
ensurePropertyDefined(left,resultType);
break;
default :
break;
}
}",0.98046875
27142,"public void testConstructorType9(){
  testTypes(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testConstructorType9(){
  testTypes(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"");
}",0.9688581314878892
27143,"public void testDirectPrototypeAssign(){
  testTypes(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
}","public void testDirectPrototypeAssign(){
  testTypes(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"" + ""String_Node_Str"");
}",0.8252788104089219
27144,"/** 
 * @return The statement containing the expression or null if the subExpressionis not contain in a Node where inlining is known to be possible. For example, a WHILE node condition expression.
 */
@Nullable static Node findExpressionRoot(Node subExpression){
  Node child=subExpression;
  for (  Node parent : child.getAncestors()) {
    Token parentType=parent.getToken();
switch (parentType) {
case EXPR_RESULT:
case IF:
case SWITCH:
case RETURN:
case THROW:
      Preconditions.checkState(child == parent.getFirstChild());
    return parent;
case VAR:
case CONST:
case LET:
  Preconditions.checkState(child == parent.getFirstChild());
if (parent.getParent().isVanillaFor() && parent == parent.getParent().getFirstChild()) {
  return null;
}
 else {
  return parent;
}
case FOR:
if (child == parent.getFirstChild()) {
return parent;
}
case FOR_IN:
case FOR_OF:
case SCRIPT:
case BLOCK:
case LABEL:
case CASE:
case DEFAULT_CASE:
return null;
default :
break;
}
child=parent;
}
throw new IllegalStateException(""String_Node_Str"");
}","/** 
 * @return The statement containing the expression or null if the subExpressionis not contain in a Node where inlining is known to be possible. For example, a WHILE node condition expression.
 */
@Nullable static Node findExpressionRoot(Node subExpression){
  Node child=subExpression;
  for (  Node parent : child.getAncestors()) {
    Token parentType=parent.getToken();
switch (parentType) {
case EXPR_RESULT:
case IF:
case SWITCH:
case RETURN:
case THROW:
      Preconditions.checkState(child == parent.getFirstChild());
    return parent;
case VAR:
case CONST:
case LET:
  Preconditions.checkState(child == parent.getFirstChild());
if (parent.getParent().isVanillaFor() && parent == parent.getParent().getFirstChild()) {
  return parent.getParent();
}
 else {
  return parent;
}
case FOR:
if (child == parent.getFirstChild()) {
return parent;
}
case FOR_IN:
case FOR_OF:
case SCRIPT:
case BLOCK:
case LABEL:
case CASE:
case DEFAULT_CASE:
return null;
default :
break;
}
child=parent;
}
throw new IllegalStateException(""String_Node_Str"");
}",0.989443378119002
27145,"/** 
 * Determine which, if any, of the supported types the call site is. Constant vars are treated differently so that we don't break their const-ness when we decompose the expression. Once the CONSTANT_VAR annotation is used everywhere instead of coding conventions, we should just teach this pass how to remove the annotation.
 */
private CallSiteType classifyCallSite(Reference ref){
  Node callNode=ref.callNode;
  Node parent=callNode.getParent();
  Node grandParent=parent.getParent();
  if (NodeUtil.isExprCall(parent)) {
    return CallSiteType.SIMPLE_CALL;
  }
 else   if (NodeUtil.isExprAssign(grandParent) && !NodeUtil.isNameDeclOrSimpleAssignLhs(callNode,parent) && parent.getFirstChild().isName()&& !NodeUtil.isConstantName(parent.getFirstChild())) {
    return CallSiteType.SIMPLE_ASSIGNMENT;
  }
 else   if (parent.isName() && !NodeUtil.isConstantName(parent) && (grandParent.isVar() || grandParent.isLet())&& grandParent.hasOneChild()) {
    return CallSiteType.VAR_DECL_SIMPLE_ASSIGNMENT;
  }
 else {
    Node expressionRoot=ExpressionDecomposer.findExpressionRoot(callNode);
    if (expressionRoot != null) {
      ExpressionDecomposer decomposer=getDecomposer(ref.scope);
      DecompositionType type=decomposer.canExposeExpression(callNode);
      if (type == DecompositionType.MOVABLE) {
        return CallSiteType.EXPRESSION;
      }
 else       if (type == DecompositionType.DECOMPOSABLE) {
        return CallSiteType.DECOMPOSABLE_EXPRESSION;
      }
 else {
        checkState(type == DecompositionType.UNDECOMPOSABLE);
      }
    }
  }
  return CallSiteType.UNSUPPORTED;
}","/** 
 * Determine which, if any, of the supported types the call site is. Constant vars are treated differently so that we don't break their const-ness when we decompose the expression. Once the CONSTANT_VAR annotation is used everywhere instead of coding conventions, we should just teach this pass how to remove the annotation.
 */
private CallSiteType classifyCallSite(Reference ref){
  Node callNode=ref.callNode;
  Node parent=callNode.getParent();
  Node grandParent=parent.getParent();
  if (NodeUtil.isExprCall(parent)) {
    return CallSiteType.SIMPLE_CALL;
  }
 else   if (NodeUtil.isExprAssign(grandParent) && !NodeUtil.isNameDeclOrSimpleAssignLhs(callNode,parent) && parent.getFirstChild().isName()&& !NodeUtil.isConstantName(parent.getFirstChild())) {
    return CallSiteType.SIMPLE_ASSIGNMENT;
  }
 else   if (parent.isName() && !NodeUtil.isConstantName(parent) && grandParent.isVar()&& grandParent.hasOneChild()) {
    return CallSiteType.VAR_DECL_SIMPLE_ASSIGNMENT;
  }
 else {
    Node expressionRoot=ExpressionDecomposer.findExpressionRoot(callNode);
    if (expressionRoot != null) {
      ExpressionDecomposer decomposer=getDecomposer(ref.scope);
      DecompositionType type=decomposer.canExposeExpression(callNode);
      if (type == DecompositionType.MOVABLE) {
        return CallSiteType.EXPRESSION;
      }
 else       if (type == DecompositionType.DECOMPOSABLE) {
        return CallSiteType.DECOMPOSABLE_EXPRESSION;
      }
 else {
        checkState(type == DecompositionType.UNDECOMPOSABLE);
      }
    }
  }
  return CallSiteType.UNSUPPORTED;
}",0.9921309411394396
27146,"public void testFindExpressionRoot5(){
  assertThat(findExpressionRoot(""String_Node_Str"",""String_Node_Str"")).isNull();
}","public void testFindExpressionRoot5(){
  assertNode(findExpressionRoot(""String_Node_Str"",""String_Node_Str"")).hasType(Token.FOR);
}",0.888
27147,"/** 
 * @return The result of calling {@link ExpressionDecomposer#findExpressionRoot} on the CALLnode in  {@code js} whose callee is a NAME matching {@code name}.
 */
@Nullable private Node findExpressionRoot(String js,String name){
  Compiler compiler=getCompiler();
  Node tree=parse(compiler,js);
  Node call=findCall(tree,name);
  checkNotNull(call);
  return ExpressionDecomposer.findExpressionRoot(call);
}","/** 
 * @return The result of calling {@link ExpressionDecomposer#findExpressionRoot} on the CALLnode in  {@code js} whose callee is a NAME matching {@code name}.
 */
@Nullable private Node findExpressionRoot(String js,String name){
  Compiler compiler=getCompiler();
  Node tree=parse(compiler,js);
  Node call=findCall(tree,name);
  checkNotNull(call);
  Node root=ExpressionDecomposer.findExpressionRoot(call);
  if (root != null) {
    checkState(NodeUtil.isStatement(root),root);
  }
  return root;
}",0.8833151581243184
27148,"public void testShadowVariables19(){
  test(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testShadowVariables19(){
  test(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.9703947368421052
27149,"private void computeMayUse(Node n,Node cfgNode,ReachingUses output,boolean conditional){
switch (n.getToken()) {
case BLOCK:
case ROOT:
case FUNCTION:
    return;
case NAME:
  if (NodeUtil.isLhsByDestructuring(n)) {
    if (!conditional) {
      removeFromUseIfLocal(n.getString(),output);
    }
  }
 else {
    addToUseIfLocal(n.getString(),cfgNode,output);
  }
return;
case WHILE:
case DO:
case IF:
computeMayUse(NodeUtil.getConditionExpression(n),cfgNode,output,conditional);
return;
case FOR:
computeMayUse(NodeUtil.getConditionExpression(n),cfgNode,output,conditional);
return;
case FOR_IN:
case FOR_OF:
Node lhs=n.getFirstChild();
Node rhs=lhs.getNext();
if (NodeUtil.isNameDeclaration(lhs)) {
lhs=lhs.getLastChild();
if (lhs.isDestructuringLhs()) {
lhs=lhs.getFirstChild();
}
}
if (lhs.isName() && !conditional) {
removeFromUseIfLocal(lhs.getString(),output);
}
 else if (lhs.isDestructuringPattern()) {
computeMayUse(lhs,cfgNode,output,true);
}
computeMayUse(rhs,cfgNode,output,conditional);
return;
case AND:
case OR:
computeMayUse(n.getLastChild(),cfgNode,output,true);
computeMayUse(n.getFirstChild(),cfgNode,output,conditional);
return;
case HOOK:
computeMayUse(n.getLastChild(),cfgNode,output,true);
computeMayUse(n.getSecondChild(),cfgNode,output,true);
computeMayUse(n.getFirstChild(),cfgNode,output,conditional);
return;
case VAR:
case LET:
case CONST:
Node varName=n.getFirstChild();
checkState(n.hasChildren(),""String_Node_Str"",n);
if (varName.isDestructuringLhs()) {
computeMayUse(varName.getFirstChild(),cfgNode,output,conditional);
computeMayUse(varName.getSecondChild(),cfgNode,output,conditional);
}
 else if (varName.hasChildren()) {
computeMayUse(varName.getFirstChild(),cfgNode,output,conditional);
if (!conditional) {
removeFromUseIfLocal(varName.getString(),output);
}
}
return;
default :
if (NodeUtil.isAssignmentOp(n) && n.getFirstChild().isName()) {
Node name=n.getFirstChild();
if (!conditional) {
removeFromUseIfLocal(name.getString(),output);
}
if (!n.isAssign()) {
addToUseIfLocal(name.getString(),cfgNode,output);
}
computeMayUse(name.getNext(),cfgNode,output,conditional);
}
 else {
for (Node c=n.getLastChild(); c != null; c=c.getPrevious()) {
computeMayUse(c,cfgNode,output,conditional);
}
}
}
}","/** 
 * @param conditional Whether {@code n} is only conditionally evaluated given that {@code cfgNode}is evaluated. Do not remove conditionally redefined variables from the reaching uses set.
 */
private void computeMayUse(Node n,Node cfgNode,ReachingUses output,boolean conditional){
switch (n.getToken()) {
case BLOCK:
case ROOT:
case FUNCTION:
    return;
case NAME:
  if (NodeUtil.isLhsByDestructuring(n)) {
    if (!conditional) {
      removeFromUseIfLocal(n.getString(),output);
    }
  }
 else {
    addToUseIfLocal(n.getString(),cfgNode,output);
  }
return;
case WHILE:
case DO:
case IF:
computeMayUse(NodeUtil.getConditionExpression(n),cfgNode,output,conditional);
return;
case FOR:
computeMayUse(NodeUtil.getConditionExpression(n),cfgNode,output,conditional);
return;
case FOR_IN:
case FOR_OF:
Node lhs=n.getFirstChild();
Node rhs=lhs.getNext();
if (NodeUtil.isNameDeclaration(lhs)) {
lhs=lhs.getLastChild();
if (lhs.isDestructuringLhs()) {
lhs=lhs.getFirstChild();
}
}
if (lhs.isName() && !conditional) {
removeFromUseIfLocal(lhs.getString(),output);
}
 else if (lhs.isDestructuringPattern()) {
computeMayUse(lhs,cfgNode,output,true);
}
computeMayUse(rhs,cfgNode,output,conditional);
return;
case AND:
case OR:
computeMayUse(n.getLastChild(),cfgNode,output,true);
computeMayUse(n.getFirstChild(),cfgNode,output,conditional);
return;
case HOOK:
computeMayUse(n.getLastChild(),cfgNode,output,true);
computeMayUse(n.getSecondChild(),cfgNode,output,true);
computeMayUse(n.getFirstChild(),cfgNode,output,conditional);
return;
case VAR:
case LET:
case CONST:
Node varName=n.getFirstChild();
checkState(n.hasChildren(),""String_Node_Str"",n);
if (varName.isDestructuringLhs()) {
computeMayUse(varName.getFirstChild(),cfgNode,output,conditional);
computeMayUse(varName.getSecondChild(),cfgNode,output,conditional);
}
 else if (varName.hasChildren()) {
computeMayUse(varName.getFirstChild(),cfgNode,output,conditional);
if (!conditional) {
removeFromUseIfLocal(varName.getString(),output);
}
}
return;
case DEFAULT_VALUE:
if (n.getFirstChild().isDestructuringPattern()) {
computeMayUse(n.getFirstChild(),cfgNode,output,conditional);
computeMayUse(n.getSecondChild(),cfgNode,output,true);
}
 else if (n.getFirstChild().isName()) {
if (!conditional) {
removeFromUseIfLocal(n.getFirstChild().getString(),output);
}
computeMayUse(n.getSecondChild(),cfgNode,output,true);
}
 else {
computeMayUse(n.getSecondChild(),cfgNode,output,true);
computeMayUse(n.getFirstChild(),cfgNode,output,conditional);
}
break;
default :
if (NodeUtil.isAssignmentOp(n) && n.getFirstChild().isName()) {
Node name=n.getFirstChild();
if (!conditional) {
removeFromUseIfLocal(name.getString(),output);
}
if (!n.isAssign()) {
addToUseIfLocal(name.getString(),cfgNode,output);
}
computeMayUse(name.getNext(),cfgNode,output,conditional);
}
 else if (n.isAssign() && n.getFirstChild().isDestructuringPattern()) {
computeMayUse(n.getFirstChild(),cfgNode,output,conditional);
computeMayUse(n.getSecondChild(),cfgNode,output,conditional);
}
 else {
for (Node c=n.getLastChild(); c != null; c=c.getPrevious()) {
computeMayUse(c,cfgNode,output,conditional);
}
}
}
}",0.8332711674748229
27150,"public void testDestructuringEvaluationOrder(){
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
  inline(""String_Node_Str"",""String_Node_Str"");
}","public void testDestructuringEvaluationOrder(){
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
  inline(""String_Node_Str"",""String_Node_Str"");
}",0.9009584664536742
27151,"public void testDestructuringDefaultValue(){
  inline(""String_Node_Str"",""String_Node_Str"");
  inline(""String_Node_Str"",""String_Node_Str"");
  inline(""String_Node_Str"",""String_Node_Str"");
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
  inline(""String_Node_Str"",""String_Node_Str"");
  inline(""String_Node_Str"",""String_Node_Str"");
  inline(""String_Node_Str"",""String_Node_Str"");
}","public void testDestructuringDefaultValue(){
  inline(""String_Node_Str"",""String_Node_Str"");
  inline(""String_Node_Str"",""String_Node_Str"");
  inline(""String_Node_Str"",""String_Node_Str"");
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
  inline(""String_Node_Str"",""String_Node_Str"");
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
}",0.8004587155963303
27152,"public void testGithubIssue2818(){
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
  inline(""String_Node_Str"",""String_Node_Str"");
}","public void testGithubIssue2818(){
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
}",0.9197080291970804
27153,"public void testDestructuringComputedProperty(){
  inline(""String_Node_Str"",""String_Node_Str"");
  noInline(""String_Node_Str"");
}","public void testDestructuringComputedProperty(){
  inline(""String_Node_Str"",""String_Node_Str"");
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
  inline(""String_Node_Str"",""String_Node_Str"");
}",0.7664670658682635
27154,"private boolean canInline(final Scope scope){
  if (getDefCfgNode().isFunction()) {
    return false;
  }
  getDefinition(getDefCfgNode());
  getNumUseInUseCfgNode(useCfgNode);
  if (def == null) {
    return false;
  }
  if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {
    return false;
  }
  if (checkRightOf(def,getDefCfgNode(),SIDE_EFFECT_PREDICATE)) {
    return false;
  }
  if (checkLeftOf(use,useCfgNode,SIDE_EFFECT_PREDICATE)) {
    return false;
  }
  if (NodeUtil.mayHaveSideEffects(def.getLastChild(),compiler)) {
    return false;
  }
  if (numUsesWithinCfgNode != 1) {
    return false;
  }
  if (NodeUtil.isWithinLoop(use)) {
    return false;
  }
  Collection<Node> uses=reachingUses.getUses(varName,getDefCfgNode());
  if (uses.size() != 1) {
    return false;
  }
  if (NodeUtil.has(def.getLastChild(),new Predicate<Node>(){
    @Override public boolean apply(    Node input){
switch (input.getToken()) {
case GETELEM:
case GETPROP:
case ARRAYLIT:
case OBJECTLIT:
case REGEXP:
case NEW:
        return true;
case NAME:
      Var var=scope.getOwnSlot(input.getString());
    if (var != null && var.getParentNode().isCatch()) {
      return true;
    }
default :
  break;
}
return false;
}
}
,new Predicate<Node>(){
@Override public boolean apply(Node input){
return !input.isFunction();
}
}
)) {
return false;
}
if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {
CheckPathsBetweenNodes<Node,ControlFlowGraph.Branch> pathCheck=new CheckPathsBetweenNodes<>(cfg,cfg.getDirectedGraphNode(getDefCfgNode()),cfg.getDirectedGraphNode(useCfgNode),SIDE_EFFECT_PREDICATE,Predicates.<DiGraphEdge<Node,ControlFlowGraph.Branch>>alwaysTrue(),false);
if (pathCheck.somePathsSatisfyPredicate()) {
return false;
}
}
return true;
}","private boolean canInline(final Scope scope){
  if (getDefCfgNode().isFunction()) {
    return false;
  }
  getDefinition(getDefCfgNode());
  getNumUseInUseCfgNode(useCfgNode);
  if (def == null) {
    return false;
  }
  if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {
    return false;
  }
  if (checkPostExpressions(def,getDefCfgNode(),SIDE_EFFECT_PREDICATE)) {
    return false;
  }
  if (checkPreExpressions(use,useCfgNode,SIDE_EFFECT_PREDICATE)) {
    return false;
  }
  if (NodeUtil.mayHaveSideEffects(def.getLastChild(),compiler)) {
    return false;
  }
  if (numUsesWithinCfgNode != 1) {
    return false;
  }
  if (NodeUtil.isWithinLoop(use)) {
    return false;
  }
  Collection<Node> uses=reachingUses.getUses(varName,getDefCfgNode());
  if (uses.size() != 1) {
    return false;
  }
  if (NodeUtil.has(def.getLastChild(),new Predicate<Node>(){
    @Override public boolean apply(    Node input){
switch (input.getToken()) {
case GETELEM:
case GETPROP:
case ARRAYLIT:
case OBJECTLIT:
case REGEXP:
case NEW:
        return true;
case NAME:
      Var var=scope.getOwnSlot(input.getString());
    if (var != null && var.getParentNode().isCatch()) {
      return true;
    }
default :
  break;
}
return false;
}
}
,new Predicate<Node>(){
@Override public boolean apply(Node input){
return !input.isFunction();
}
}
)) {
return false;
}
if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {
CheckPathsBetweenNodes<Node,ControlFlowGraph.Branch> pathCheck=new CheckPathsBetweenNodes<>(cfg,cfg.getDirectedGraphNode(getDefCfgNode()),cfg.getDirectedGraphNode(useCfgNode),SIDE_EFFECT_PREDICATE,Predicates.<DiGraphEdge<Node,ControlFlowGraph.Branch>>alwaysTrue(),false);
if (pathCheck.somePathsSatisfyPredicate()) {
return false;
}
}
return true;
}",0.9883849557522124
27155,"private void computeMayUse(Node n,Node cfgNode,ReachingUses output,boolean conditional){
switch (n.getToken()) {
case BLOCK:
case ROOT:
case FUNCTION:
    return;
case NAME:
  addToUseIfLocal(n.getString(),cfgNode,output);
return;
case WHILE:
case DO:
case IF:
computeMayUse(NodeUtil.getConditionExpression(n),cfgNode,output,conditional);
return;
case FOR:
computeMayUse(NodeUtil.getConditionExpression(n),cfgNode,output,conditional);
return;
case FOR_IN:
Node lhs=n.getFirstChild();
Node rhs=lhs.getNext();
if (lhs.isVar()) {
lhs=lhs.getLastChild();
}
if (lhs.isName() && !conditional) {
removeFromUseIfLocal(lhs.getString(),output);
}
computeMayUse(rhs,cfgNode,output,conditional);
return;
case AND:
case OR:
computeMayUse(n.getLastChild(),cfgNode,output,true);
computeMayUse(n.getFirstChild(),cfgNode,output,conditional);
return;
case HOOK:
computeMayUse(n.getLastChild(),cfgNode,output,true);
computeMayUse(n.getSecondChild(),cfgNode,output,true);
computeMayUse(n.getFirstChild(),cfgNode,output,conditional);
return;
case VAR:
Node varName=n.getFirstChild();
Preconditions.checkState(n.hasChildren(),""String_Node_Str"",n);
if (varName.hasChildren()) {
computeMayUse(varName.getFirstChild(),cfgNode,output,conditional);
if (!conditional) {
removeFromUseIfLocal(varName.getString(),output);
}
}
return;
default :
if (NodeUtil.isAssignmentOp(n) && n.getFirstChild().isName()) {
Node name=n.getFirstChild();
if (!conditional) {
removeFromUseIfLocal(name.getString(),output);
}
if (!n.isAssign()) {
addToUseIfLocal(name.getString(),cfgNode,output);
}
computeMayUse(name.getNext(),cfgNode,output,conditional);
}
 else {
for (Node c=n.getLastChild(); c != null; c=c.getPrevious()) {
computeMayUse(c,cfgNode,output,conditional);
}
}
}
}","private void computeMayUse(Node n,Node cfgNode,ReachingUses output,boolean conditional){
switch (n.getToken()) {
case BLOCK:
case ROOT:
case FUNCTION:
    return;
case NAME:
  if (NodeUtil.isLhsByDestructuring(n)) {
    if (!conditional) {
      removeFromUseIfLocal(n.getString(),output);
    }
  }
 else {
    addToUseIfLocal(n.getString(),cfgNode,output);
  }
return;
case WHILE:
case DO:
case IF:
computeMayUse(NodeUtil.getConditionExpression(n),cfgNode,output,conditional);
return;
case FOR:
computeMayUse(NodeUtil.getConditionExpression(n),cfgNode,output,conditional);
return;
case FOR_IN:
Node lhs=n.getFirstChild();
Node rhs=lhs.getNext();
if (lhs.isVar()) {
lhs=lhs.getLastChild();
}
if (lhs.isName() && !conditional) {
removeFromUseIfLocal(lhs.getString(),output);
}
computeMayUse(rhs,cfgNode,output,conditional);
return;
case AND:
case OR:
computeMayUse(n.getLastChild(),cfgNode,output,true);
computeMayUse(n.getFirstChild(),cfgNode,output,conditional);
return;
case HOOK:
computeMayUse(n.getLastChild(),cfgNode,output,true);
computeMayUse(n.getSecondChild(),cfgNode,output,true);
computeMayUse(n.getFirstChild(),cfgNode,output,conditional);
return;
case VAR:
Node varName=n.getFirstChild();
checkState(n.hasChildren(),""String_Node_Str"",n);
if (varName.isDestructuringLhs()) {
computeMayUse(varName.getFirstChild(),cfgNode,output,conditional);
computeMayUse(varName.getSecondChild(),cfgNode,output,conditional);
}
 else if (varName.hasChildren()) {
computeMayUse(varName.getFirstChild(),cfgNode,output,conditional);
if (!conditional) {
removeFromUseIfLocal(varName.getString(),output);
}
}
return;
default :
if (NodeUtil.isAssignmentOp(n) && n.getFirstChild().isName()) {
Node name=n.getFirstChild();
if (!conditional) {
removeFromUseIfLocal(name.getString(),output);
}
if (!n.isAssign()) {
addToUseIfLocal(name.getString(),cfgNode,output);
}
computeMayUse(name.getNext(),cfgNode,output,conditional);
}
 else {
for (Node c=n.getLastChild(); c != null; c=c.getPrevious()) {
computeMayUse(c,cfgNode,output,conditional);
}
}
}
}",0.9116007432970532
27156,"private ParseTree parseMultiplicativeExpression(){
  SourcePosition start=getTreeStartLocation();
  ParseTree left=parseExponentiationExpression();
  while (peekMultiplicativeOperator()) {
    Token operator=nextToken();
    ParseTree right=parseUnaryExpression();
    left=new BinaryOperatorTree(getTreeLocation(start),left,operator,right);
  }
  return left;
}","private ParseTree parseMultiplicativeExpression(){
  SourcePosition start=getTreeStartLocation();
  ParseTree left=parseExponentiationExpression();
  while (peekMultiplicativeOperator()) {
    Token operator=nextToken();
    ParseTree right=parseExponentiationExpression();
    left=new BinaryOperatorTree(getTreeLocation(start),left,operator,right);
  }
  return left;
}",0.9740791268758526
27157,"public void testExponentiationOperator(){
  languageMode=LanguageMode.ECMASCRIPT_2016;
  assertPrintSame(""String_Node_Str"");
  assertPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrintSame(""String_Node_Str"");
  assertPrintSame(""String_Node_Str"");
  assertPrintSame(""String_Node_Str"");
  assertPrint(""String_Node_Str"",""String_Node_Str"");
}","public void testExponentiationOperator(){
  languageMode=LanguageMode.ECMASCRIPT_2016;
  assertPrintSame(""String_Node_Str"");
  assertPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrintSame(""String_Node_Str"");
  assertPrintSame(""String_Node_Str"");
  assertPrintSame(""String_Node_Str"");
  assertPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrintSame(""String_Node_Str"");
}",0.884318766066838
27158,"public void testExponentOperator(){
  mode=LanguageMode.ECMASCRIPT7;
  strictMode=STRICT;
  parseError(""String_Node_Str"",""String_Node_Str"");
  expectFeatures(Feature.EXPONENT_OP);
  parse(""String_Node_Str"");
  parse(""String_Node_Str"");
  parse(""String_Node_Str"");
  parse(""String_Node_Str"");
  mode=LanguageMode.ECMASCRIPT6;
  strictMode=SLOPPY;
  parseWarning(""String_Node_Str"",requiresLanguageModeMessage(LanguageMode.ECMASCRIPT7,Feature.EXPONENT_OP));
}","public void testExponentOperator(){
  mode=LanguageMode.ECMASCRIPT7;
  strictMode=STRICT;
  parseError(""String_Node_Str"",""String_Node_Str"");
  expectFeatures(Feature.EXPONENT_OP);
  parse(""String_Node_Str"");
  parse(""String_Node_Str"");
  parse(""String_Node_Str"");
  parse(""String_Node_Str"");
  parse(""String_Node_Str"");
  mode=LanguageMode.ECMASCRIPT6;
  strictMode=SLOPPY;
  parseWarning(""String_Node_Str"",requiresLanguageModeMessage(LanguageMode.ECMASCRIPT7,Feature.EXPONENT_OP));
}",0.9702127659574468
27159,"/** 
 * Resolve any stub declarations to unknown types if we could not find types for them during traversal.
 */
void resolveStubDeclarations(){
  for (  StubDeclaration stub : stubDeclarations) {
    Node n=stub.node;
    Node parent=n.getParent();
    String qName=n.getQualifiedName();
    String propName=n.getLastChild().getString();
    String ownerName=stub.ownerName;
    boolean isExtern=stub.isExtern;
    if (scope.isDeclared(qName,false)) {
      continue;
    }
    ObjectType ownerType=getObjectSlot(ownerName);
    defineSlot(n,parent,unknownType,true);
    if (ownerType != null && (isExtern || ownerType.isFunctionPrototypeType())) {
      ownerType.defineInferredProperty(propName,unknownType,n);
    }
 else {
      typeRegistry.registerPropertyOnType(propName,ownerType == null ? unknownType : ownerType);
    }
  }
}","/** 
 * Resolve any stub declarations to unknown types if we could not find types for them during traversal.
 */
void resolveStubDeclarations(){
  for (  StubDeclaration stub : stubDeclarations) {
    Node n=stub.node;
    Node parent=n.getParent();
    String qName=n.getQualifiedName();
    String propName=n.getLastChild().getString();
    String ownerName=stub.ownerName;
    boolean isExtern=stub.isExtern;
    if (scope.isDeclared(qName,false)) {
      continue;
    }
    ObjectType ownerType=getObjectSlot(ownerName);
    JSType inheritedType=getInheritedInterfacePropertyType(ownerType,propName);
    JSType stubType=inheritedType == null ? unknownType : inheritedType;
    defineSlot(n,parent,stubType,true);
    if (ownerType != null && (isExtern || ownerType.isFunctionPrototypeType())) {
      ownerType.defineInferredProperty(propName,stubType,n);
    }
 else {
      typeRegistry.registerPropertyOnType(propName,ownerType == null ? stubType : ownerType);
    }
  }
}",0.8800880088008801
27160,"private ObjectType getThisTypeForCollectingProperties(){
  Node rootNode=scope.getRootNode();
  if (rootNode.isFromExterns())   return null;
  JSType type=rootNode.getJSType();
  if (type == null || !type.isFunctionType())   return null;
  FunctionType fnType=type.toMaybeFunctionType();
  JSType fnThisType=fnType.getTypeOfThis();
  return fnThisType.isUnknownType() ? null : fnThisType.toObjectType();
}","private ObjectType getThisTypeForCollectingProperties(){
  Node rootNode=scope.getRootNode();
  if (rootNode.isFromExterns()) {
    return null;
  }
  JSType type=rootNode.getJSType();
  if (type == null || !type.isFunctionType()) {
    return null;
  }
  FunctionType fnType=type.toMaybeFunctionType();
  JSType fnThisType=fnType.getTypeOfThis();
  return fnThisType.isUnknownType() ? null : fnThisType.toObjectType();
}",0.9128329297820824
27161,"/** 
 * Called for the usual style of prototype-property definitions, but also for @lends and for direct assignments of object literals to prototypes.
 */
private void mayAddPropToPrototype(RawNominalType rawType,String pname,Node defSite,Node initializer){
  NTIScope methodScope=null;
  DeclaredFunctionType methodType=null;
  JSType propDeclType=null;
  JSDocInfo jsdoc=NodeUtil.getBestJSDocInfo(defSite);
  if (initializer != null && initializer.isFunction()) {
    methodScope=visitFunctionLate(initializer,rawType);
    methodType=methodScope.getDeclaredFunctionType();
    if (defSite.isGetterDef()) {
      pname=getCommonTypes().createGetterPropName(pname);
    }
 else     if (defSite.isSetterDef()) {
      pname=getCommonTypes().createSetterPropName(pname);
    }
  }
 else   if (jsdoc != null && jsdoc.containsFunctionDeclaration() && !defSite.isStringKey()) {
    methodType=computeFnDeclaredType(jsdoc,pname,defSite,rawType,currentScope);
  }
  if (jsdoc != null && jsdoc.hasType()) {
    propDeclType=getTypeParser().getDeclaredTypeOfNode(jsdoc,rawType,currentScope);
  }
 else   if (methodType != null) {
    propDeclType=getCommonTypes().fromFunctionType(methodType.toFunctionType());
  }
  if (defSite.isGetterDef()) {
    FunctionType ft=propDeclType.getFunTypeIfSingletonObj();
    if (ft != null) {
      propDeclType=ft.getReturnType();
    }
  }
  PropertyDef def=new PropertyDef(defSite,methodType,methodScope);
  propertyDefs.put(rawType,pname,def);
  if (methodType != null && methodType.isAbstract() && !rawType.isAbstractClass()) {
    if (rawType.isClass()) {
      warnings.add(JSError.make(defSite,ABSTRACT_METHOD_IN_CONCRETE_CLASS,rawType.getName()));
    }
 else     if (rawType.isInterface()) {
      warnings.add(JSError.make(defSite,ABSTRACT_METHOD_IN_INTERFACE));
    }
  }
  boolean isConst=isConst(defSite);
  if (propDeclType != null || isConst) {
    if (mayWarnAboutExistingProp(rawType,pname,defSite,propDeclType)) {
      return;
    }
    if (propDeclType == null) {
      propDeclType=mayInferFromRhsIfConst(defSite);
    }
    rawType.addProtoProperty(pname,defSite,propDeclType,isConst);
    if (defSite.isGetProp()) {
      defSite.putBooleanProp(Node.ANALYZED_DURING_GTI,true);
      if (isConst) {
        defSite.putBooleanProp(Node.CONSTANT_PROPERTY_DEF,true);
      }
    }
  }
 else {
    JSType inferredType=null;
    if (initializer != null) {
      inferredType=simpleInferExpr(initializer,this.currentScope);
    }
    if (inferredType == null) {
      inferredType=getCommonTypes().UNKNOWN;
    }
    rawType.addUndeclaredProtoProperty(pname,defSite,inferredType);
  }
}","/** 
 * Called for the usual style of prototype-property definitions, but also for @lends and for direct assignments of object literals to prototypes.
 */
private void mayAddPropToPrototype(RawNominalType rawType,String pname,Node defSite,Node initializer){
  NTIScope methodScope=null;
  DeclaredFunctionType methodType=null;
  JSType propDeclType=null;
  JSDocInfo jsdoc=NodeUtil.getBestJSDocInfo(defSite);
  if (initializer != null && initializer.isFunction()) {
    methodScope=visitFunctionLate(initializer,rawType);
    methodType=methodScope.getDeclaredFunctionType();
    if (defSite.isGetterDef()) {
      pname=getCommonTypes().createGetterPropName(pname);
    }
 else     if (defSite.isSetterDef()) {
      pname=getCommonTypes().createSetterPropName(pname);
    }
  }
 else   if (jsdoc != null && jsdoc.containsFunctionDeclaration() && !defSite.isStringKey()) {
    methodType=computeFnDeclaredType(jsdoc,pname,defSite,rawType,currentScope);
  }
  if (jsdoc != null && jsdoc.hasType()) {
    propDeclType=getTypeParser().getDeclaredTypeOfNode(jsdoc,rawType,currentScope);
    if ((defSite.isGetterDef() || defSite.isSetterDef()) && propDeclType != null && !propDeclType.isFunctionType()) {
      propDeclType=null;
    }
  }
 else   if (methodType != null) {
    propDeclType=getCommonTypes().fromFunctionType(methodType.toFunctionType());
  }
  if (defSite.isGetterDef() && propDeclType != null) {
    FunctionType ft=propDeclType.getFunTypeIfSingletonObj();
    if (ft != null) {
      propDeclType=ft.getReturnType();
    }
  }
  PropertyDef def=new PropertyDef(defSite,methodType,methodScope);
  propertyDefs.put(rawType,pname,def);
  if (methodType != null && methodType.isAbstract() && !rawType.isAbstractClass()) {
    if (rawType.isClass()) {
      warnings.add(JSError.make(defSite,ABSTRACT_METHOD_IN_CONCRETE_CLASS,rawType.getName()));
    }
 else     if (rawType.isInterface()) {
      warnings.add(JSError.make(defSite,ABSTRACT_METHOD_IN_INTERFACE));
    }
  }
  boolean isConst=isConst(defSite);
  if (propDeclType != null || isConst) {
    if (mayWarnAboutExistingProp(rawType,pname,defSite,propDeclType)) {
      return;
    }
    if (propDeclType == null) {
      propDeclType=mayInferFromRhsIfConst(defSite);
    }
    rawType.addProtoProperty(pname,defSite,propDeclType,isConst);
    if (defSite.isGetProp()) {
      defSite.putBooleanProp(Node.ANALYZED_DURING_GTI,true);
      if (isConst) {
        defSite.putBooleanProp(Node.CONSTANT_PROPERTY_DEF,true);
      }
    }
  }
 else {
    JSType inferredType=null;
    if (initializer != null) {
      inferredType=simpleInferExpr(initializer,this.currentScope);
    }
    if (inferredType == null) {
      inferredType=getCommonTypes().UNKNOWN;
    }
    rawType.addUndeclaredProtoProperty(pname,defSite,inferredType);
  }
}",0.9681692732290708
27162,"public void testSetters(){
  typeCheck(""String_Node_Str"",GlobalTypeInfoCollector.SETTER_WITH_RETURN);
  typeCheck(""String_Node_Str"",GlobalTypeInfoCollector.SETTER_WITH_RETURN);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),JSTypeCreatorFromJSDoc.TEMPLATED_GETTER_SETTER);
  typeCheck(""String_Node_Str"",NewTypeInference.RETURN_NONDECLARED_TYPE);
  typeCheck(""String_Node_Str"",JSTypeCreatorFromJSDoc.FUNCTION_WITH_NONFUNC_JSDOC);
  typeCheck(""String_Node_Str"",NewTypeInference.ILLEGAL_OBJLIT_KEY);
  typeCheck(""String_Node_Str"",NewTypeInference.ILLEGAL_OBJLIT_KEY);
  typeCheck(""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"",NewTypeInference.INEXISTENT_PROPERTY);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
}","public void testSetters(){
  typeCheck(""String_Node_Str"",GlobalTypeInfoCollector.SETTER_WITH_RETURN);
  typeCheck(""String_Node_Str"",GlobalTypeInfoCollector.SETTER_WITH_RETURN);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),JSTypeCreatorFromJSDoc.TEMPLATED_GETTER_SETTER);
  typeCheck(""String_Node_Str"",NewTypeInference.RETURN_NONDECLARED_TYPE);
  typeCheck(""String_Node_Str"",JSTypeCreatorFromJSDoc.FUNCTION_WITH_NONFUNC_JSDOC);
  typeCheck(""String_Node_Str"",NewTypeInference.ILLEGAL_OBJLIT_KEY);
  typeCheck(""String_Node_Str"",NewTypeInference.ILLEGAL_OBJLIT_KEY);
  typeCheck(""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"",NewTypeInference.INEXISTENT_PROPERTY);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),JSTypeCreatorFromJSDoc.FUNCTION_WITH_NONFUNC_JSDOC);
}",0.895676318921063
27163,"/** 
 * Computes the GEN and KILL set.
 * @param n Root node.
 * @param gen Local variables that are live because of the instruction at {@code n} will be addedto this set.
 * @param kill Local variables that are killed because of the instruction at {@code n} will beadded to this set.
 * @param conditional {@code true} if any assignments encountered are conditionally executed.These assignments might not kill a variable.
 */
private void computeGenKill(Node n,BitSet gen,BitSet kill,boolean conditional){
switch (n.getToken()) {
case SCRIPT:
case ROOT:
case FUNCTION:
case BLOCK:
    return;
case WHILE:
case DO:
case IF:
case FOR:
  computeGenKill(NodeUtil.getConditionExpression(n),gen,kill,conditional);
return;
case FOR_OF:
case FOR_IN:
{
Node lhs=n.getFirstChild();
if (NodeUtil.isNameDeclaration(lhs)) {
  lhs=lhs.getLastChild();
}
if (lhs.isName()) {
  addToSetIfLocal(lhs,kill);
  addToSetIfLocal(lhs,gen);
}
 else {
  computeGenKill(lhs,gen,kill,conditional);
}
return;
}
case LET:
case CONST:
case VAR:
for (Node c=n.getFirstChild(); c != null; c=c.getNext()) {
if (c.isName()) {
if (c.hasChildren()) {
  computeGenKill(c.getFirstChild(),gen,kill,conditional);
  if (!conditional) {
    addToSetIfLocal(c,kill);
  }
}
}
 else {
computeGenKill(c,gen,kill,conditional);
}
}
return;
case DESTRUCTURING_LHS:
if (n.hasTwoChildren()) {
computeGenKill(n.getSecondChild(),gen,kill,conditional);
if (!conditional) {
Iterable<Node> allVars=NodeUtil.findLhsNodesInNode(n);
for (Node child : allVars) {
addToSetIfLocal(child,kill);
}
}
}
return;
case AND:
case OR:
computeGenKill(n.getFirstChild(),gen,kill,conditional);
computeGenKill(n.getLastChild(),gen,kill,true);
return;
case HOOK:
computeGenKill(n.getFirstChild(),gen,kill,conditional);
computeGenKill(n.getSecondChild(),gen,kill,true);
computeGenKill(n.getLastChild(),gen,kill,true);
return;
case NAME:
if (isArgumentsName(n)) {
markAllParametersEscaped();
}
 else {
addToSetIfLocal(n,gen);
}
return;
default :
if (NodeUtil.isAssignmentOp(n) && n.getFirstChild().isName()) {
Node lhs=n.getFirstChild();
if (!conditional) {
addToSetIfLocal(lhs,kill);
}
if (!n.isAssign()) {
addToSetIfLocal(lhs,gen);
}
computeGenKill(lhs.getNext(),gen,kill,conditional);
}
 else {
for (Node c=n.getFirstChild(); c != null; c=c.getNext()) {
computeGenKill(c,gen,kill,conditional);
}
}
return;
}
}","/** 
 * Computes the GEN and KILL set.
 * @param n Root node.
 * @param gen Local variables that are live because of the instruction at {@code n} will be addedto this set.
 * @param kill Local variables that are killed because of the instruction at {@code n} will beadded to this set.
 * @param conditional {@code true} if any assignments encountered are conditionally executed.These assignments might not kill a variable.
 */
private void computeGenKill(Node n,BitSet gen,BitSet kill,boolean conditional){
switch (n.getToken()) {
case SCRIPT:
case ROOT:
case FUNCTION:
case BLOCK:
    return;
case WHILE:
case DO:
case IF:
case FOR:
  computeGenKill(NodeUtil.getConditionExpression(n),gen,kill,conditional);
return;
case FOR_OF:
case FOR_IN:
{
Node lhs=n.getFirstChild();
if (NodeUtil.isNameDeclaration(lhs)) {
  lhs=lhs.getLastChild();
}
computeGenKill(lhs,gen,kill,conditional);
return;
}
case LET:
case CONST:
case VAR:
for (Node c=n.getFirstChild(); c != null; c=c.getNext()) {
if (c.isName()) {
if (c.hasChildren()) {
  computeGenKill(c.getFirstChild(),gen,kill,conditional);
  if (!conditional) {
    addToSetIfLocal(c,kill);
  }
}
}
 else {
checkState(c.isDestructuringLhs(),c);
if (!conditional) {
  Iterable<Node> allVars=NodeUtil.findLhsNodesInNode(c);
  for (  Node lhsNode : allVars) {
    addToSetIfLocal(lhsNode,kill);
  }
}
computeGenKill(c.getFirstChild(),gen,kill,conditional);
computeGenKill(c.getSecondChild(),gen,kill,conditional);
}
}
return;
case AND:
case OR:
computeGenKill(n.getFirstChild(),gen,kill,conditional);
computeGenKill(n.getLastChild(),gen,kill,true);
return;
case HOOK:
computeGenKill(n.getFirstChild(),gen,kill,conditional);
computeGenKill(n.getSecondChild(),gen,kill,true);
computeGenKill(n.getLastChild(),gen,kill,true);
return;
case NAME:
if (isArgumentsName(n)) {
markAllParametersEscaped();
}
 else if (!NodeUtil.isLhsByDestructuring(n)) {
addToSetIfLocal(n,gen);
}
return;
default :
if (NodeUtil.isAssignmentOp(n) && n.getFirstChild().isName()) {
Node lhs=n.getFirstChild();
if (!conditional) {
addToSetIfLocal(lhs,kill);
}
if (!n.isAssign()) {
addToSetIfLocal(lhs,gen);
}
computeGenKill(lhs.getNext(),gen,kill,conditional);
}
 else if (n.isAssign() && n.getFirstChild().isDestructuringPattern()) {
if (!conditional) {
Iterable<Node> allVars=NodeUtil.findLhsNodesInNode(n);
for (Node child : allVars) {
if (child.isName()) {
addToSetIfLocal(child,kill);
}
}
}
computeGenKill(n.getFirstChild(),gen,kill,conditional);
computeGenKill(n.getSecondChild(),gen,kill,conditional);
}
 else {
for (Node c=n.getFirstChild(); c != null; c=c.getNext()) {
computeGenKill(c,gen,kill,conditional);
}
}
return;
}
}",0.7982315112540193
27164,"public void testReferenceInDestructuringPatternComputedProperty(){
  inFunction(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testReferenceInDestructuringPatternComputedProperty(){
  inFunction(""String_Node_Str"");
  inFunction(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.7929515418502202
27165,"public void testDestructuring(){
  inFunction(""String_Node_Str"");
  inFunction(""String_Node_Str"");
}","public void testDestructuring(){
  inFunction(""String_Node_Str"");
  inFunction(""String_Node_Str"");
  inFunction(""String_Node_Str"",""String_Node_Str"");
  inFunction(""String_Node_Str"");
}",0.704225352112676
27166,"public void testReferenceInDestructuringPatternDefaultValue(){
  inFunction(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  inFunction(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  inFunction(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testReferenceInDestructuringPatternDefaultValue(){
  inFunction(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  inFunction(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  inFunction(""String_Node_Str"");
  inFunction(""String_Node_Str"");
}",0.6361323155216285
27167,"public void testForOfWithDestructuring(){
  inFunction(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  inFunction(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testForOfWithDestructuring(){
  inFunction(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  inFunction(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  inFunction(""String_Node_Str"");
  inFunction(""String_Node_Str"");
  inFunction(""String_Node_Str"",""String_Node_Str"");
}",0.721875
27168,"/** 
 * Computes the GEN and KILL set.
 * @param n Root node.
 * @param gen Local variables that are live because of the instruction at {@code n} will be addedto this set.
 * @param kill Local variables that are killed because of the instruction at {@code n} will beadded to this set.
 * @param conditional {@code true} if any assignments encountered are conditionally executed.These assignments might not kill a variable.
 */
private void computeGenKill(Node n,BitSet gen,BitSet kill,boolean conditional){
switch (n.getToken()) {
case SCRIPT:
case ROOT:
case FUNCTION:
case BLOCK:
    return;
case WHILE:
case DO:
case IF:
case FOR:
  computeGenKill(NodeUtil.getConditionExpression(n),gen,kill,conditional);
return;
case FOR_OF:
case FOR_IN:
{
Node lhs=n.getFirstChild();
if (NodeUtil.isNameDeclaration(lhs)) {
  lhs=lhs.getLastChild();
}
if (lhs.isName()) {
  addToSetIfLocal(lhs,kill);
  addToSetIfLocal(lhs,gen);
}
 else {
  computeGenKill(lhs,gen,kill,conditional);
}
return;
}
case LET:
case CONST:
case VAR:
for (Node c=n.getFirstChild(); c != null; c=c.getNext()) {
if (c.isName()) {
if (c.hasChildren()) {
  computeGenKill(c.getFirstChild(),gen,kill,conditional);
  if (!conditional) {
    addToSetIfLocal(c,kill);
  }
}
}
 else {
Iterable<Node> allVars=NodeUtil.findLhsNodesInNode(n);
for (Node child : allVars) {
  addToSetIfLocal(child,kill);
}
}
}
return;
case AND:
case OR:
computeGenKill(n.getFirstChild(),gen,kill,conditional);
computeGenKill(n.getLastChild(),gen,kill,true);
return;
case HOOK:
computeGenKill(n.getFirstChild(),gen,kill,conditional);
computeGenKill(n.getSecondChild(),gen,kill,true);
computeGenKill(n.getLastChild(),gen,kill,true);
return;
case NAME:
if (isArgumentsName(n)) {
markAllParametersEscaped();
}
 else {
addToSetIfLocal(n,gen);
}
return;
default :
if (NodeUtil.isAssignmentOp(n) && n.getFirstChild().isName()) {
Node lhs=n.getFirstChild();
if (!conditional) {
addToSetIfLocal(lhs,kill);
}
if (!n.isAssign()) {
addToSetIfLocal(lhs,gen);
}
computeGenKill(lhs.getNext(),gen,kill,conditional);
}
 else {
for (Node c=n.getFirstChild(); c != null; c=c.getNext()) {
computeGenKill(c,gen,kill,conditional);
}
}
return;
}
}","/** 
 * Computes the GEN and KILL set.
 * @param n Root node.
 * @param gen Local variables that are live because of the instruction at {@code n} will be addedto this set.
 * @param kill Local variables that are killed because of the instruction at {@code n} will beadded to this set.
 * @param conditional {@code true} if any assignments encountered are conditionally executed.These assignments might not kill a variable.
 */
private void computeGenKill(Node n,BitSet gen,BitSet kill,boolean conditional){
switch (n.getToken()) {
case SCRIPT:
case ROOT:
case FUNCTION:
case BLOCK:
    return;
case WHILE:
case DO:
case IF:
case FOR:
  computeGenKill(NodeUtil.getConditionExpression(n),gen,kill,conditional);
return;
case FOR_OF:
case FOR_IN:
{
Node lhs=n.getFirstChild();
if (NodeUtil.isNameDeclaration(lhs)) {
  lhs=lhs.getLastChild();
}
if (lhs.isName()) {
  addToSetIfLocal(lhs,kill);
  addToSetIfLocal(lhs,gen);
}
 else {
  computeGenKill(lhs,gen,kill,conditional);
}
return;
}
case LET:
case CONST:
case VAR:
for (Node c=n.getFirstChild(); c != null; c=c.getNext()) {
if (c.isName()) {
if (c.hasChildren()) {
  computeGenKill(c.getFirstChild(),gen,kill,conditional);
  if (!conditional) {
    addToSetIfLocal(c,kill);
  }
}
}
 else {
computeGenKill(c,gen,kill,conditional);
}
}
return;
case DESTRUCTURING_LHS:
if (n.hasTwoChildren()) {
computeGenKill(n.getSecondChild(),gen,kill,conditional);
if (!conditional) {
Iterable<Node> allVars=NodeUtil.findLhsNodesInNode(n);
for (Node child : allVars) {
addToSetIfLocal(child,kill);
}
}
}
return;
case AND:
case OR:
computeGenKill(n.getFirstChild(),gen,kill,conditional);
computeGenKill(n.getLastChild(),gen,kill,true);
return;
case HOOK:
computeGenKill(n.getFirstChild(),gen,kill,conditional);
computeGenKill(n.getSecondChild(),gen,kill,true);
computeGenKill(n.getLastChild(),gen,kill,true);
return;
case NAME:
if (isArgumentsName(n)) {
markAllParametersEscaped();
}
 else {
addToSetIfLocal(n,gen);
}
return;
default :
if (NodeUtil.isAssignmentOp(n) && n.getFirstChild().isName()) {
Node lhs=n.getFirstChild();
if (!conditional) {
addToSetIfLocal(lhs,kill);
}
if (!n.isAssign()) {
addToSetIfLocal(lhs,gen);
}
computeGenKill(lhs.getNext(),gen,kill,conditional);
}
 else {
for (Node c=n.getFirstChild(); c != null; c=c.getNext()) {
computeGenKill(c,gen,kill,conditional);
}
}
return;
}
}",0.959715112397062
27169,"/** 
 * For each node, update the block stack and reference collection as appropriate.
 */
@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (n.isName() || n.isImportStar() || (n.isStringKey() && !n.hasChildren())) {
    Var v=t.getScope().getVar(n.getString());
    if (v != null) {
      if (varFilter.apply(v)) {
        addReference(v,new Reference(n,t,peek(blockStack)));
      }
      if (v.getParentNode() != null && NodeUtil.isHoistedFunctionDeclaration(v.getParentNode()) && (narrowScope == null || narrowScope.getDepth() <= v.getScope().getDepth())) {
        outOfBandTraversal(v);
      }
    }
  }
  if (isBlockBoundary(n,parent)) {
    pop(blockStack);
  }
}","/** 
 * For each node, update the block stack and reference collection as appropriate.
 */
@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (n.isName() || n.isImportStar() || (n.isStringKey() && !n.hasChildren())) {
    if ((parent.isImportSpec() && n != parent.getLastChild()) || (parent.isExportSpec() && n != parent.getFirstChild())) {
      return;
    }
    Var v=t.getScope().getVar(n.getString());
    if (v != null) {
      if (varFilter.apply(v)) {
        addReference(v,new Reference(n,t,peek(blockStack)));
      }
      if (v.getParentNode() != null && NodeUtil.isHoistedFunctionDeclaration(v.getParentNode()) && (narrowScope == null || narrowScope.getDepth() <= v.getScope().getDepth())) {
        outOfBandTraversal(v);
      }
    }
  }
  if (isBlockBoundary(n,parent)) {
    pop(blockStack);
  }
}",0.6614276358873609
27170,"public void testFailModule(){
  testError(""String_Node_Str"",EXTRA_REQUIRE_WARNING);
  testError(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),EXTRA_REQUIRE_WARNING);
}","public void testFailModule(){
  testError(""String_Node_Str"",EXTRA_REQUIRE_WARNING);
  testError(""String_Node_Str"",EXTRA_REQUIRE_WARNING);
  testError(""String_Node_Str"",EXTRA_REQUIRE_WARNING);
  testError(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),EXTRA_REQUIRE_WARNING);
}",0.7711864406779662
27171,"public void testES6ModuleWithDestructuringRequire(){
  testError(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),EXTRA_REQUIRE_WARNING);
}","public void testES6ModuleWithDestructuringRequire(){
  testError(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),EXTRA_REQUIRE_WARNING);
  testError(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),EXTRA_REQUIRE_WARNING);
  testError(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),EXTRA_REQUIRE_WARNING);
}",0.5688775510204082
27172,"public void testRedeclareVariableFromImport(){
  assertRedeclareError(""String_Node_Str"");
  assertRedeclareError(""String_Node_Str"");
  assertRedeclareError(""String_Node_Str"");
  assertRedeclareError(""String_Node_Str"");
  assertRedeclareError(""String_Node_Str"");
  assertRedeclareError(""String_Node_Str"");
  assertRedeclareError(""String_Node_Str"");
  assertRedeclareError(""String_Node_Str"");
  assertRedeclareError(""String_Node_Str"");
  assertRedeclareError(""String_Node_Str"");
  testSame(""String_Node_Str"");
}","public void testRedeclareVariableFromImport(){
  assertRedeclareError(""String_Node_Str"");
  assertRedeclareError(""String_Node_Str"");
  assertRedeclareError(""String_Node_Str"");
  assertRedeclareError(""String_Node_Str"");
  assertRedeclareError(""String_Node_Str"");
  assertRedeclareError(""String_Node_Str"");
  assertRedeclareError(""String_Node_Str"");
  assertRedeclareError(""String_Node_Str"");
  assertRedeclareError(""String_Node_Str"");
  assertRedeclareError(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
}",0.9425925925925924
27173,"public void testES6Module_destructuring(){
  enableUnusedLocalAssignmentCheck=true;
  assertNoWarning(""String_Node_Str"");
}","public void testES6Module_destructuring(){
  enableUnusedLocalAssignmentCheck=true;
  assertNoWarning(""String_Node_Str"");
  assertNoWarning(""String_Node_Str"");
  assertNoWarning(""String_Node_Str"");
}",0.7639751552795031
27174,"public NameDeclarationStatement(RemovableBuilder builder,Node declarationStatement){
  super(builder);
  this.declarationStatement=declarationStatement;
}","public NameDeclarationStatement(RemovableBuilder builder,Node declarationStatement){
  super(builder);
  checkArgument(NodeUtil.isNameDeclaration(declarationStatement),declarationStatement);
  this.declarationStatement=declarationStatement;
}",0.7777777777777778
27175,"Assign(RemovableBuilder builder,Node assignNode,Kind kind,@Nullable Node propertyNode){
  super(builder);
  checkState(NodeUtil.isAssignmentOp(assignNode));
  if (kind == Kind.VARIABLE) {
    checkArgument(propertyNode == null,""String_Node_Str"",propertyNode);
  }
 else {
    checkArgument(propertyNode != null,""String_Node_Str"");
    if (kind == Kind.NAMED_PROPERTY) {
      checkArgument(propertyNode.isString(),""String_Node_Str"",propertyNode);
    }
  }
  this.assignNode=assignNode;
  this.kind=kind;
  this.propertyNode=propertyNode;
  this.maybeAliased=NodeUtil.isExpressionResultUsed(assignNode);
}","Assign(RemovableBuilder builder,Node assignNode,Kind kind,@Nullable Node propertyNode){
  super(builder);
  checkArgument(NodeUtil.isAssignmentOp(assignNode),assignNode);
  if (kind == Kind.VARIABLE) {
    checkArgument(propertyNode == null,""String_Node_Str"",propertyNode);
  }
 else {
    checkArgument(propertyNode != null,""String_Node_Str"");
    if (kind == Kind.NAMED_PROPERTY) {
      checkArgument(propertyNode.isString(),""String_Node_Str"",propertyNode);
    }
  }
  this.assignNode=assignNode;
  this.kind=kind;
  this.propertyNode=propertyNode;
  this.maybeAliased=NodeUtil.isExpressionResultUsed(assignNode);
}",0.9803921568627452
27176,"private void addSyntheticConstructor(Node classNode){
  Node superClass=classNode.getSecondChild();
  Node classMembers=classNode.getLastChild();
  Node memberDef;
  if (superClass.isEmpty()) {
    Node function=NodeUtil.emptyFunction();
    compiler.reportChangeToChangeScope(function);
    memberDef=IR.memberFunctionDef(""String_Node_Str"",function);
  }
 else {
    if (!superClass.isQualifiedName()) {
      return;
    }
    Node body=IR.block();
    if (!classNode.isFromExterns() && !isInterface(classNode)) {
      Node exprResult=IR.exprResult(IR.call(IR.getprop(IR.superNode(),IR.string(""String_Node_Str"")),IR.thisNode(),IR.name(""String_Node_Str"")));
      body.addChildToFront(exprResult);
    }
    Node constructor=IR.function(IR.name(""String_Node_Str""),IR.paramList(IR.name(""String_Node_Str"")),body);
    compiler.reportChangeToChangeScope(constructor);
    memberDef=IR.memberFunctionDef(""String_Node_Str"",constructor);
    JSDocInfoBuilder info=new JSDocInfoBuilder(false);
    info.recordParameter(""String_Node_Str"",new JSTypeExpression(new Node(Token.ELLIPSIS,new Node(Token.QMARK)),""String_Node_Str""));
    memberDef.setJSDocInfo(info.build());
  }
  memberDef.useSourceInfoIfMissingFromForTree(classNode);
  classMembers.addChildToFront(memberDef);
  compiler.reportChangeToEnclosingScope(memberDef);
}","private void addSyntheticConstructor(Node classNode){
  Node superClass=classNode.getSecondChild();
  Node classMembers=classNode.getLastChild();
  Node memberDef;
  if (superClass.isEmpty()) {
    Node function=NodeUtil.emptyFunction();
    compiler.reportChangeToChangeScope(function);
    memberDef=IR.memberFunctionDef(""String_Node_Str"",function);
  }
 else {
    if (!superClass.isQualifiedName()) {
      return;
    }
    Node body=IR.block();
    if (!classNode.isFromExterns() && !isInterface(classNode)) {
      Node exprResult=IR.exprResult(IR.call(IR.getprop(IR.superNode(),IR.string(""String_Node_Str"")),IR.thisNode(),IR.name(""String_Node_Str"")));
      body.addChildToFront(exprResult);
    }
    Node constructor=IR.function(IR.name(""String_Node_Str""),IR.paramList(IR.name(""String_Node_Str"")),body);
    compiler.reportChangeToChangeScope(constructor);
    memberDef=IR.memberFunctionDef(""String_Node_Str"",constructor);
    JSDocInfoBuilder info=new JSDocInfoBuilder(false);
    info.recordParameter(""String_Node_Str"",new JSTypeExpression(new Node(Token.ELLIPSIS,new Node(Token.QMARK)),""String_Node_Str""));
    memberDef.setJSDocInfo(info.build());
  }
  memberDef.useSourceInfoIfMissingFromForTree(classNode);
  memberDef.makeNonIndexableRecursive();
  classMembers.addChildToFront(memberDef);
  compiler.reportChangeToEnclosingScope(memberDef);
}",0.9847185985836748
27177,"/** 
 * Classes are processed in 3 phases: <ol> <li>The class name is extracted. <li>Class members are processed and rewritten. <li>The constructor is built. </ol>
 */
private void visitClass(final NodeTraversal t,final Node classNode,final Node parent){
  checkClassReassignment(classNode);
  ClassDeclarationMetadata metadata=ClassDeclarationMetadata.create(classNode,parent);
  if (metadata == null || metadata.fullClassName == null) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + classNode);
  }
  if (metadata.hasSuperClass() && !metadata.superClassNameNode.isQualifiedName()) {
    compiler.report(JSError.make(metadata.superClassNameNode,DYNAMIC_EXTENDS_TYPE));
    return;
  }
  Preconditions.checkState(NodeUtil.isStatement(metadata.insertionPoint),""String_Node_Str"",metadata.insertionPoint);
  Node constructor=null;
  JSDocInfo ctorJSDocInfo=null;
  Node classMembers=classNode.getLastChild();
  for (  Node member : classMembers.children()) {
    if ((member.isComputedProp() && (member.getBooleanProp(Node.COMPUTED_PROP_GETTER) || member.getBooleanProp(Node.COMPUTED_PROP_SETTER))) || (member.isGetterDef() || member.isSetterDef())) {
      visitNonMethodMember(member,metadata);
    }
 else     if (member.isMemberFunctionDef() && member.getString().equals(""String_Node_Str"")) {
      ctorJSDocInfo=member.getJSDocInfo();
      constructor=member.getFirstChild().detach();
      if (!metadata.anonymous) {
        constructor.replaceChild(constructor.getFirstChild(),metadata.classNameNode.cloneNode());
      }
    }
 else     if (member.isEmpty()) {
    }
 else {
      Preconditions.checkState(member.isMemberFunctionDef() || member.isComputedProp(),""String_Node_Str"",member);
      Preconditions.checkState(!member.getBooleanProp(Node.COMPUTED_PROP_VARIABLE),""String_Node_Str"",member);
      visitMethod(member,metadata);
    }
  }
  if (metadata.definePropertiesObjForPrototype.hasChildren()) {
    compiler.ensureLibraryInjected(""String_Node_Str"",false);
    Node definePropsCall=IR.exprResult(IR.call(NodeUtil.newQName(compiler,""String_Node_Str""),NodeUtil.newQName(compiler,metadata.fullClassName + ""String_Node_Str""),metadata.definePropertiesObjForPrototype));
    definePropsCall.useSourceInfoIfMissingFromForTree(classNode);
    metadata.insertNodeAndAdvance(definePropsCall);
  }
  if (metadata.definePropertiesObjForClass.hasChildren()) {
    compiler.ensureLibraryInjected(""String_Node_Str"",false);
    Node definePropsCall=IR.exprResult(IR.call(NodeUtil.newQName(compiler,""String_Node_Str""),NodeUtil.newQName(compiler,metadata.fullClassName),metadata.definePropertiesObjForClass));
    definePropsCall.useSourceInfoIfMissingFromForTree(classNode);
    metadata.insertNodeAndAdvance(definePropsCall);
  }
  checkNotNull(constructor);
  JSDocInfo classJSDoc=NodeUtil.getBestJSDocInfo(classNode);
  JSDocInfoBuilder newInfo=JSDocInfoBuilder.maybeCopyFrom(classJSDoc);
  newInfo.recordConstructor();
  Node enclosingStatement=NodeUtil.getEnclosingStatement(classNode);
  if (metadata.hasSuperClass()) {
    String superClassString=metadata.superClassNameNode.getQualifiedName();
    if (newInfo.isInterfaceRecorded()) {
      newInfo.recordExtendedInterface(new JSTypeExpression(new Node(Token.BANG,IR.string(superClassString)),metadata.superClassNameNode.getSourceFileName()));
    }
 else {
      if (shouldAddInheritsPolyfill && !classNode.isFromExterns()) {
        Node classNameNode=NodeUtil.newQName(compiler,metadata.fullClassName).useSourceInfoIfMissingFrom(metadata.classNameNode);
        Node superClassNameNode=NodeUtil.newQName(compiler,superClassString).useSourceInfoIfMissingFrom(metadata.superClassNameNode);
        Node inherits=IR.call(NodeUtil.newQName(compiler,INHERITS),classNameNode,superClassNameNode);
        Node inheritsCall=IR.exprResult(inherits);
        compiler.ensureLibraryInjected(""String_Node_Str"",false);
        inheritsCall.useSourceInfoIfMissingFromForTree(metadata.superClassNameNode);
        enclosingStatement.getParent().addChildAfter(inheritsCall,enclosingStatement);
      }
      newInfo.recordBaseType(new JSTypeExpression(new Node(Token.BANG,IR.string(superClassString)),metadata.superClassNameNode.getSourceFileName()));
    }
  }
  addTypeDeclarations(metadata,enclosingStatement);
  updateClassJsDoc(ctorJSDocInfo,newInfo);
  if (NodeUtil.isStatement(classNode)) {
    constructor.getFirstChild().setString(""String_Node_Str"");
    Node ctorVar=IR.let(metadata.classNameNode.cloneNode(),constructor);
    ctorVar.useSourceInfoIfMissingFromForTree(classNode);
    parent.replaceChild(classNode,ctorVar);
  }
 else {
    parent.replaceChild(classNode,constructor);
  }
  NodeUtil.markFunctionsDeleted(classNode,compiler);
  if (NodeUtil.isStatement(constructor)) {
    constructor.setJSDocInfo(newInfo.build());
  }
 else   if (parent.isName()) {
    Node var=parent.getParent();
    var.setJSDocInfo(newInfo.build());
  }
 else   if (constructor.getParent().isName()) {
    Node var=constructor.getGrandparent();
    var.setJSDocInfo(newInfo.build());
  }
 else   if (parent.isAssign()) {
    parent.setJSDocInfo(newInfo.build());
  }
 else {
    throw new IllegalStateException(""String_Node_Str"" + parent);
  }
  constructor.putBooleanProp(Node.IS_ES6_CLASS,true);
  t.reportCodeChange();
}","/** 
 * Classes are processed in 3 phases: <ol> <li>The class name is extracted. <li>Class members are processed and rewritten. <li>The constructor is built. </ol>
 */
private void visitClass(final NodeTraversal t,final Node classNode,final Node parent){
  checkClassReassignment(classNode);
  ClassDeclarationMetadata metadata=ClassDeclarationMetadata.create(classNode,parent);
  if (metadata == null || metadata.fullClassName == null) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + classNode);
  }
  if (metadata.hasSuperClass() && !metadata.superClassNameNode.isQualifiedName()) {
    compiler.report(JSError.make(metadata.superClassNameNode,DYNAMIC_EXTENDS_TYPE));
    return;
  }
  Preconditions.checkState(NodeUtil.isStatement(metadata.insertionPoint),""String_Node_Str"",metadata.insertionPoint);
  Node constructor=null;
  JSDocInfo ctorJSDocInfo=null;
  Node classMembers=classNode.getLastChild();
  for (  Node member : classMembers.children()) {
    if ((member.isComputedProp() && (member.getBooleanProp(Node.COMPUTED_PROP_GETTER) || member.getBooleanProp(Node.COMPUTED_PROP_SETTER))) || (member.isGetterDef() || member.isSetterDef())) {
      visitNonMethodMember(member,metadata);
    }
 else     if (member.isMemberFunctionDef() && member.getString().equals(""String_Node_Str"")) {
      ctorJSDocInfo=member.getJSDocInfo();
      constructor=member.getFirstChild().detach();
      if (!metadata.anonymous) {
        constructor.replaceChild(constructor.getFirstChild(),metadata.classNameNode.cloneNode());
      }
    }
 else     if (member.isEmpty()) {
    }
 else {
      Preconditions.checkState(member.isMemberFunctionDef() || member.isComputedProp(),""String_Node_Str"",member);
      Preconditions.checkState(!member.getBooleanProp(Node.COMPUTED_PROP_VARIABLE),""String_Node_Str"",member);
      visitMethod(member,metadata);
    }
  }
  if (metadata.definePropertiesObjForPrototype.hasChildren()) {
    compiler.ensureLibraryInjected(""String_Node_Str"",false);
    Node definePropsCall=IR.exprResult(IR.call(NodeUtil.newQName(compiler,""String_Node_Str""),NodeUtil.newQName(compiler,metadata.fullClassName + ""String_Node_Str""),metadata.definePropertiesObjForPrototype));
    definePropsCall.useSourceInfoIfMissingFromForTree(classNode);
    metadata.insertNodeAndAdvance(definePropsCall);
  }
  if (metadata.definePropertiesObjForClass.hasChildren()) {
    compiler.ensureLibraryInjected(""String_Node_Str"",false);
    Node definePropsCall=IR.exprResult(IR.call(NodeUtil.newQName(compiler,""String_Node_Str""),NodeUtil.newQName(compiler,metadata.fullClassName),metadata.definePropertiesObjForClass));
    definePropsCall.useSourceInfoIfMissingFromForTree(classNode);
    metadata.insertNodeAndAdvance(definePropsCall);
  }
  checkNotNull(constructor);
  JSDocInfo classJSDoc=NodeUtil.getBestJSDocInfo(classNode);
  JSDocInfoBuilder newInfo=JSDocInfoBuilder.maybeCopyFrom(classJSDoc);
  newInfo.recordConstructor();
  Node enclosingStatement=NodeUtil.getEnclosingStatement(classNode);
  if (metadata.hasSuperClass()) {
    String superClassString=metadata.superClassNameNode.getQualifiedName();
    if (newInfo.isInterfaceRecorded()) {
      newInfo.recordExtendedInterface(new JSTypeExpression(new Node(Token.BANG,IR.string(superClassString)),metadata.superClassNameNode.getSourceFileName()));
    }
 else {
      if (shouldAddInheritsPolyfill && !classNode.isFromExterns()) {
        Node classNameNode=NodeUtil.newQName(compiler,metadata.fullClassName).useSourceInfoIfMissingFrom(metadata.classNameNode);
        Node superClassNameNode=metadata.superClassNameNode.cloneTree();
        Node inherits=IR.call(NodeUtil.newQName(compiler,INHERITS),classNameNode,superClassNameNode);
        Node inheritsCall=IR.exprResult(inherits);
        compiler.ensureLibraryInjected(""String_Node_Str"",false);
        inheritsCall.useSourceInfoIfMissingFromForTree(metadata.superClassNameNode);
        enclosingStatement.getParent().addChildAfter(inheritsCall,enclosingStatement);
      }
      newInfo.recordBaseType(new JSTypeExpression(new Node(Token.BANG,IR.string(superClassString)),metadata.superClassNameNode.getSourceFileName()));
    }
  }
  addTypeDeclarations(metadata,enclosingStatement);
  updateClassJsDoc(ctorJSDocInfo,newInfo);
  if (NodeUtil.isStatement(classNode)) {
    constructor.getFirstChild().setString(""String_Node_Str"");
    Node ctorVar=IR.let(metadata.classNameNode.cloneNode(),constructor);
    ctorVar.useSourceInfoIfMissingFromForTree(classNode);
    parent.replaceChild(classNode,ctorVar);
  }
 else {
    parent.replaceChild(classNode,constructor);
  }
  NodeUtil.markFunctionsDeleted(classNode,compiler);
  if (NodeUtil.isStatement(constructor)) {
    constructor.setJSDocInfo(newInfo.build());
  }
 else   if (parent.isName()) {
    Node var=parent.getParent();
    var.setJSDocInfo(newInfo.build());
  }
 else   if (constructor.getParent().isName()) {
    Node var=constructor.getGrandparent();
    var.setJSDocInfo(newInfo.build());
  }
 else   if (parent.isAssign()) {
    parent.setJSDocInfo(newInfo.build());
  }
 else {
    throw new IllegalStateException(""String_Node_Str"" + parent);
  }
  constructor.putBooleanProp(Node.IS_ES6_CLASS,true);
  t.reportCodeChange();
}",0.9869981968302172
27178,"public void assertHasEncounteredAllErrors(){
  assertThat(errors).hasLength(errorsIndex);
}","public void assertHasEncounteredAllErrors(){
  if (errors.length != errorsIndex) {
    Assert.fail(""String_Node_Str"" + Arrays.asList(errors).subList(errorsIndex,errors.length));
  }
}",0.5985401459854015
27179,"public void assertHasEncounteredAllWarnings(){
  assertThat(warnings).hasLength(warningsIndex);
}","public void assertHasEncounteredAllWarnings(){
  if (warnings.length != warningsIndex) {
    Assert.fail(""String_Node_Str"" + Arrays.asList(warnings).subList(warningsIndex,warnings.length));
  }
}",0.6095890410958904
27180,"protected Compiler compile(CompilerOptions options,String[] original){
  Compiler compiler=useNoninjectingCompiler ? new NoninjectingCompiler() : new Compiler();
  lastCompiler=compiler;
  options.setErrorHandler(new BlackHoleErrorManager());
  compiler.compileModules(externs,ImmutableList.copyOf(CompilerTestCase.createModuleChain(ImmutableList.copyOf(original),inputFileNamePrefix,inputFileNameSuffix)),options);
  return compiler;
}","protected Compiler compile(CompilerOptions options,String[] original){
  Compiler compiler=useNoninjectingCompiler ? new NoninjectingCompiler(new BlackHoleErrorManager()) : new Compiler(new BlackHoleErrorManager());
  lastCompiler=compiler;
  compiler.compileModules(externs,ImmutableList.copyOf(CompilerTestCase.createModuleChain(ImmutableList.copyOf(original),inputFileNamePrefix,inputFileNameSuffix)),options);
  return compiler;
}",0.8735632183908046
27181,"@Override protected void setUp() throws Exception {
  super.setUp();
  options=new CompilerOptions();
  options.setErrorHandler(new BlackHoleErrorManager());
  options.setLanguageIn(LanguageMode.ECMASCRIPT_2017);
  options.setLanguageOut(LanguageMode.ECMASCRIPT5);
  options.setCodingConvention(new ClosureCodingConvention());
  CompilationLevel.SIMPLE_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
  WarningLevel.VERBOSE.setOptionsForWarningLevel(options);
  options.setChecksOnly(true);
  options.setPreserveDetailedSourceInfo(true);
  options.setContinueAfterErrors(true);
  options.setAllowHotswapReplaceScript(true);
  options.setParseJsDocDocumentation(INCLUDE_DESCRIPTIONS_NO_WHITESPACE);
}","@Override protected void setUp() throws Exception {
  super.setUp();
  options=new CompilerOptions();
  options.setLanguageIn(LanguageMode.ECMASCRIPT_2017);
  options.setLanguageOut(LanguageMode.ECMASCRIPT5);
  options.setCodingConvention(new ClosureCodingConvention());
  CompilationLevel.SIMPLE_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
  WarningLevel.VERBOSE.setOptionsForWarningLevel(options);
  options.setChecksOnly(true);
  options.setPreserveDetailedSourceInfo(true);
  options.setContinueAfterErrors(true);
  options.setAllowHotswapReplaceScript(true);
  options.setParseJsDocDocumentation(INCLUDE_DESCRIPTIONS_NO_WHITESPACE);
}",0.9586410635155096
27182,"private SymbolTable createSymbolTable(String input){
  List<SourceFile> inputs=ImmutableList.of(SourceFile.fromCode(""String_Node_Str"",input));
  List<SourceFile> externs=ImmutableList.of(SourceFile.fromCode(""String_Node_Str"",EXTERNS));
  Compiler compiler=new Compiler();
  compiler.compile(externs,inputs,options);
  return assertSymbolTableValid(compiler.buildKnownSymbolTable());
}","private SymbolTable createSymbolTable(String input){
  List<SourceFile> inputs=ImmutableList.of(SourceFile.fromCode(""String_Node_Str"",input));
  List<SourceFile> externs=ImmutableList.of(SourceFile.fromCode(""String_Node_Str"",EXTERNS));
  Compiler compiler=new Compiler(new BlackHoleErrorManager());
  compiler.compile(externs,inputs,options);
  return assertSymbolTableValid(compiler.buildKnownSymbolTable());
}",0.9660377358490566
27183,"private static Compiler getCompiler(String externs,String jsInput){
  Compiler compiler=new Compiler();
  compiler.disableThreads();
  CompilerOptions options=RefactoringDriver.getCompilerOptions();
  options.setErrorHandler(new BlackHoleErrorManager());
  compiler.compile(ImmutableList.of(SourceFile.fromCode(""String_Node_Str"",externs)),ImmutableList.of(SourceFile.fromCode(""String_Node_Str"",jsInput)),options);
  return compiler;
}","private static Compiler getCompiler(String externs,String jsInput){
  Compiler compiler=new Compiler(new BlackHoleErrorManager());
  compiler.disableThreads();
  CompilerOptions options=RefactoringDriver.getCompilerOptions();
  compiler.compile(ImmutableList.of(SourceFile.fromCode(""String_Node_Str"",externs)),ImmutableList.of(SourceFile.fromCode(""String_Node_Str"",jsInput)),options);
  return compiler;
}",0.901072705601907
27184,"private boolean inlineAliasIfPossible(Name name,Ref alias,GlobalNamespace namespace){
  Node aliasParent=alias.node.getParent();
  if (aliasParent.isName() || aliasParent.isAssign()) {
    Node aliasLhsNode=aliasParent.isName() ? aliasParent : aliasParent.getFirstChild();
    String aliasVarName=aliasLhsNode.getString();
    Var aliasVar=alias.scope.getVar(aliasVarName);
    checkState(aliasVar != null,""String_Node_Str"",aliasVarName);
    Node aliasDeclarationParent=aliasVar.getParentNode();
    Scope scope=aliasDeclarationParent.isVar() ? alias.scope.getClosestHoistScope() : alias.scope;
    ReferenceCollectingCallback collector=new ReferenceCollectingCallback(compiler,ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,new Es6SyntacticScopeCreator(compiler),Predicates.equalTo(aliasVar));
    collector.processScope(scope);
    ReferenceCollection aliasRefs=collector.getReferences(aliasVar);
    Set<AstChange> newNodes=new LinkedHashSet<>();
    if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration()) {
      if (!aliasRefs.isAssignedOnceInLifetime()) {
        if (name.isConstructor() && referencesCollapsibleProperty(aliasRefs,name,namespace)) {
          compiler.report(JSError.make(aliasParent,UNSAFE_CTOR_ALIASING,aliasVarName));
        }
        return false;
      }
      int size=aliasRefs.references.size();
      for (int i=1; i < size; i++) {
        Reference aliasRef=aliasRefs.references.get(i);
        newNodes.add(replaceAliasReference(alias,aliasRef));
      }
      aliasParent.replaceChild(alias.node,IR.nullNode());
      codeChanged=true;
      compiler.reportChangeToEnclosingScope(aliasParent);
      namespace.scanNewNodes(newNodes);
      return true;
    }
    if (name.isConstructor()) {
      return partiallyInlineAlias(alias,namespace,aliasRefs,aliasLhsNode);
    }
  }
  return false;
}","private boolean inlineAliasIfPossible(Name name,Ref alias,GlobalNamespace namespace){
  Node aliasParent=alias.node.getParent();
  if (aliasParent.isName() || aliasParent.isAssign()) {
    Node aliasLhsNode=aliasParent.isName() ? aliasParent : aliasParent.getFirstChild();
    String aliasVarName=aliasLhsNode.getString();
    Var aliasVar=alias.scope.getVar(aliasVarName);
    checkState(aliasVar != null,""String_Node_Str"",aliasVarName);
    ReferenceCollectingCallback collector=new ReferenceCollectingCallback(compiler,ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,new Es6SyntacticScopeCreator(compiler),Predicates.equalTo(aliasVar));
    Scope aliasScope=aliasVar.getScope();
    collector.processScope(aliasScope);
    ReferenceCollection aliasRefs=collector.getReferences(aliasVar);
    Set<AstChange> newNodes=new LinkedHashSet<>();
    if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration()) {
      if (!aliasRefs.isAssignedOnceInLifetime()) {
        if (name.isConstructor() && referencesCollapsibleProperty(aliasRefs,name,namespace)) {
          compiler.report(JSError.make(aliasParent,UNSAFE_CTOR_ALIASING,aliasVarName));
        }
        return false;
      }
      int size=aliasRefs.references.size();
      for (int i=1; i < size; i++) {
        Reference aliasRef=aliasRefs.references.get(i);
        newNodes.add(replaceAliasReference(alias,aliasRef));
      }
      aliasParent.replaceChild(alias.node,IR.nullNode());
      codeChanged=true;
      compiler.reportChangeToEnclosingScope(aliasParent);
      namespace.scanNewNodes(newNodes);
      return true;
    }
    if (name.isConstructor()) {
      return partiallyInlineAlias(alias,namespace,aliasRefs,aliasLhsNode);
    }
  }
  return false;
}",0.9329639889196676
27185,"/** 
 * For each qualified name N in the global scope, we check if: (a) No ancestor of N is ever aliased or assigned an unknown value type. (If N = ""a.b.c"", ""a"" and ""a.b"" are never aliased). (b) N has exactly one write, and it lives in the global scope. (c) N is aliased in a local scope. (d) N is aliased in global scope <p>If (a) is true, then GlobalNamespace must know all the writes to N. If (a) and (b) are true, then N cannot change during the execution of a local scope. If (a) and (b) and (c) are true, then the alias can be inlined if the alias obeys the usual rules for how we decide whether a variable is inlineable. If (a) and (b) and (d) are true, then inline the alias if possible (if it is assigned exactly once unconditionally). <p>For (a), (b), and (c) are true and the alias is of a constructor, we may also partially inline the alias - i.e. replace some references with the constructor but not all - since constructor properties are always collapsed, so we want to be more aggressive about removing aliases.
 * @see InlineVariables
 */
private void inlineAliases(GlobalNamespace namespace){
  Deque<Name> workList=new ArrayDeque<>(namespace.getNameForest());
  while (!workList.isEmpty()) {
    Name name=workList.pop();
    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {
      continue;
    }
    if (!name.inExterns && name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) {
      List<Ref> refs=new ArrayList<>(name.getRefs());
      for (      Ref ref : refs) {
        Scope hoistScope=ref.scope.getClosestHoistScope();
        if (ref.type == Type.ALIASING_GET && !mayBeGlobalAlias(ref)) {
          if (inlineAliasIfPossible(name,ref,namespace)) {
            name.removeRef(ref);
          }
        }
 else         if (ref.type == Type.ALIASING_GET && hoistScope.isGlobal() && ref.getTwin() == null) {
          if (inlineGlobalAliasIfPossible(name,ref,namespace)) {
            name.removeRef(ref);
          }
        }
      }
    }
    if (!name.inExterns && name.type == Name.Type.CLASS) {
      List<Name> subclasses=name.subclasses;
      if (subclasses != null && name.props != null) {
        for (        Name subclass : subclasses) {
          for (          Name prop : name.props) {
            rewriteAllSubclassInheritedAccesses(name,subclass,prop,namespace);
          }
        }
      }
    }
    if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION || name.type == Name.Type.CLASS) && name.aliasingGets == 0 && name.props != null) {
      workList.addAll(name.props);
    }
  }
}","/** 
 * For each qualified name N in the global scope, we check if: (a) No ancestor of N is ever aliased or assigned an unknown value type. (If N = ""a.b.c"", ""a"" and ""a.b"" are never aliased). (b) N has exactly one write, and it lives in the global scope. (c) N is aliased in a local scope. (d) N is aliased in global scope <p>If (a) is true, then GlobalNamespace must know all the writes to N. If (a) and (b) are true, then N cannot change during the execution of a local scope. If (a) and (b) and (c) are true, then the alias can be inlined if the alias obeys the usual rules for how we decide whether a variable is inlineable. If (a) and (b) and (d) are true, then inline the alias if possible (if it is assigned exactly once unconditionally). <p>For (a), (b), and (c) are true and the alias is of a constructor, we may also partially inline the alias - i.e. replace some references with the constructor but not all - since constructor properties are always collapsed, so we want to be more aggressive about removing aliases.
 * @see InlineVariables
 */
private void inlineAliases(GlobalNamespace namespace){
  Deque<Name> workList=new ArrayDeque<>(namespace.getNameForest());
  while (!workList.isEmpty()) {
    Name name=workList.pop();
    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {
      continue;
    }
    if (!name.inExterns && name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) {
      List<Ref> refs=new ArrayList<>(name.getRefs());
      for (      Ref ref : refs) {
        Scope hoistScope=ref.scope.getClosestHoistScope();
        if (ref.type == Type.ALIASING_GET && !mayBeGlobalAlias(ref)) {
          if (inlineAliasIfPossible(name,ref,namespace)) {
            name.removeRef(ref);
          }
        }
 else         if (ref.type == Type.ALIASING_GET && hoistScope.isGlobal() && ref.getTwin() == null) {
          if (inlineGlobalAliasIfPossible(name,ref,namespace)) {
            name.removeRef(ref);
          }
        }
      }
    }
    if (!name.inExterns && name.type == Name.Type.CLASS) {
      List<Name> subclasses=name.subclasses;
      if (subclasses != null && name.props != null) {
        for (        Name subclass : subclasses) {
          for (          Name prop : name.props) {
            rewriteAllSubclassInheritedAccesses(name,subclass,prop,namespace);
          }
        }
      }
    }
    if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) && name.aliasingGets == 0 && name.props != null) {
      workList.addAll(name.props);
    }
  }
}",0.9937573156457276
27186,"private boolean inlineAliasIfPossible(Name name,Ref alias,GlobalNamespace namespace){
  Node aliasParent=alias.node.getParent();
  if (aliasParent.isName() || aliasParent.isAssign()) {
    Node aliasLhsNode=aliasParent.isName() ? aliasParent : aliasParent.getFirstChild();
    String aliasVarName=aliasLhsNode.getString();
    Var aliasVar=alias.scope.getVar(aliasVarName);
    checkState(aliasVar != null,""String_Node_Str"",aliasVarName);
    ReferenceCollectingCallback collector=new ReferenceCollectingCallback(compiler,ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,new Es6SyntacticScopeCreator(compiler),Predicates.equalTo(aliasVar));
    collector.processScope(aliasVar.getScope());
    ReferenceCollection aliasRefs=collector.getReferences(aliasVar);
    Set<AstChange> newNodes=new LinkedHashSet<>();
    if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration()) {
      if (!aliasRefs.isAssignedOnceInLifetime()) {
        if (name.isConstructor()) {
          boolean accessPropsAfterAliasing=false;
          for (          Reference ref : aliasRefs.references) {
            if (ref.getNode().getParent().isGetProp()) {
              accessPropsAfterAliasing=true;
              break;
            }
          }
          if (accessPropsAfterAliasing) {
            compiler.report(JSError.make(aliasParent,UNSAFE_CTOR_ALIASING,aliasVarName));
          }
        }
        return false;
      }
      int size=aliasRefs.references.size();
      for (int i=1; i < size; i++) {
        Reference aliasRef=aliasRefs.references.get(i);
        newNodes.add(replaceAliasReference(alias,aliasRef));
      }
      aliasParent.replaceChild(alias.node,IR.nullNode());
      codeChanged=true;
      compiler.reportChangeToEnclosingScope(aliasParent);
      namespace.scanNewNodes(newNodes);
      return true;
    }
    if (name.isConstructor()) {
      return partiallyInlineAlias(alias,namespace,aliasRefs,aliasLhsNode);
    }
  }
  return false;
}","private boolean inlineAliasIfPossible(Name name,Ref alias,GlobalNamespace namespace){
  Node aliasParent=alias.node.getParent();
  if (aliasParent.isName() || aliasParent.isAssign()) {
    Node aliasLhsNode=aliasParent.isName() ? aliasParent : aliasParent.getFirstChild();
    String aliasVarName=aliasLhsNode.getString();
    Var aliasVar=alias.scope.getVar(aliasVarName);
    checkState(aliasVar != null,""String_Node_Str"",aliasVarName);
    Node aliasDeclarationParent=aliasVar.getParentNode();
    Scope scope=aliasDeclarationParent.isVar() ? alias.scope.getClosestHoistScope() : alias.scope;
    ReferenceCollectingCallback collector=new ReferenceCollectingCallback(compiler,ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,new Es6SyntacticScopeCreator(compiler),Predicates.equalTo(aliasVar));
    collector.processScope(scope);
    ReferenceCollection aliasRefs=collector.getReferences(aliasVar);
    Set<AstChange> newNodes=new LinkedHashSet<>();
    if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration()) {
      if (!aliasRefs.isAssignedOnceInLifetime()) {
        if (name.isConstructor()) {
          boolean accessPropsAfterAliasing=false;
          for (          Reference ref : aliasRefs.references) {
            if (ref.getNode().getParent().isGetProp()) {
              accessPropsAfterAliasing=true;
              break;
            }
          }
          if (accessPropsAfterAliasing) {
            compiler.report(JSError.make(aliasParent,UNSAFE_CTOR_ALIASING,aliasVarName));
          }
        }
        return false;
      }
      int size=aliasRefs.references.size();
      for (int i=1; i < size; i++) {
        Reference aliasRef=aliasRefs.references.get(i);
        newNodes.add(replaceAliasReference(alias,aliasRef));
      }
      aliasParent.replaceChild(alias.node,IR.nullNode());
      codeChanged=true;
      compiler.reportChangeToEnclosingScope(aliasParent);
      namespace.scanNewNodes(newNodes);
      return true;
    }
    if (name.isConstructor()) {
      return partiallyInlineAlias(alias,namespace,aliasRefs,aliasLhsNode);
    }
  }
  return false;
}",0.9558428885093926
27187,"/** 
 * @param value The value to use when rewriting.
 * @param depth The chain depth.
 * @param newNodes Expression nodes that have been updated.
 * @param prop The property to rewrite with value.
 */
private void rewriteAliasProp(Node value,int depth,Set<AstChange> newNodes,Name prop){
  rewriteAliasProps(prop,value,depth + 1,newNodes);
  List<Ref> refs=new ArrayList<>(prop.getRefs());
  for (  Ref ref : refs) {
    Node target=ref.node;
    for (int i=0; i <= depth; i++) {
      if (target.isGetProp()) {
        target=target.getFirstChild();
      }
 else       if (NodeUtil.isObjectLitKey(target)) {
        Node gparent=target.getGrandparent();
        if (gparent.isAssign()) {
          target=gparent.getFirstChild();
        }
 else {
          checkState(NodeUtil.isObjectLitKey(gparent));
          target=gparent;
        }
      }
 else {
        throw new IllegalStateException(""String_Node_Str"" + target);
      }
    }
    checkState(target.isGetProp() || target.isName());
    Node newValue=value.cloneTree();
    target.replaceWith(newValue);
    compiler.reportChangeToEnclosingScope(newValue);
    prop.removeRef(ref);
    newNodes.add(new AstChange(ref.module,ref.scope,ref.node));
    codeChanged=true;
  }
}","/** 
 * @param value The value to use when rewriting.
 * @param depth The chain depth.
 * @param newNodes Expression nodes that have been updated.
 * @param prop The property to rewrite with value.
 */
private void rewriteAliasProp(Node value,int depth,Set<AstChange> newNodes,Name prop){
  rewriteAliasProps(prop,value,depth + 1,newNodes);
  List<Ref> refs=new ArrayList<>(prop.getRefs());
  for (  Ref ref : refs) {
    Node target=ref.node;
    for (int i=0; i <= depth; i++) {
      if (target.isGetProp()) {
        target=target.getFirstChild();
      }
 else       if (NodeUtil.isObjectLitKey(target)) {
        Node gparent=target.getGrandparent();
        if (gparent.isAssign()) {
          target=gparent.getFirstChild();
        }
 else {
          checkState(NodeUtil.isObjectLitKey(gparent));
          target=gparent;
        }
      }
 else {
        throw new IllegalStateException(""String_Node_Str"" + target);
      }
    }
    checkState(target.isGetProp() || target.isName());
    Node newValue=value.cloneTree();
    target.replaceWith(newValue);
    compiler.reportChangeToEnclosingScope(newValue);
    prop.removeRef(ref);
    newNodes.add(new AstChange(ref.module,ref.scope,ref.node));
  }
}",0.9910277324632952
27188,"/** 
 * For each qualified name N in the global scope, we check if: (a) No ancestor of N is ever aliased or assigned an unknown value type. (If N = ""a.b.c"", ""a"" and ""a.b"" are never aliased). (b) N has exactly one write, and it lives in the global scope. (c) N is aliased in a local scope. (d) N is aliased in global scope <p>If (a) is true, then GlobalNamespace must know all the writes to N. If (a) and (b) are true, then N cannot change during the execution of a local scope. If (a) and (b) and (c) are true, then the alias can be inlined if the alias obeys the usual rules for how we decide whether a variable is inlineable. If (a) and (b) and (d) are true, then inline the alias if possible (if it is assigned exactly once unconditionally). <p>For (a), (b), and (c) are true and the alias is of a constructor, we may also partially inline the alias - i.e. replace some references with the constructor but not all - since constructor properties are always collapsed, so we want to be more aggressive about removing aliases.
 * @see InlineVariables
 */
private void inlineAliases(GlobalNamespace namespace){
  Deque<Name> workList=new ArrayDeque<>(namespace.getNameForest());
  while (!workList.isEmpty()) {
    Name name=workList.pop();
    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {
      continue;
    }
    if (!name.inExterns && name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) {
      List<Ref> refs=new ArrayList<>(name.getRefs());
      for (      Ref ref : refs) {
        Scope hoistScope=ref.scope.getClosestHoistScope();
        if (ref.type == Type.ALIASING_GET && !mayBeGlobalAlias(ref)) {
          if (inlineAliasIfPossible(name,ref,namespace)) {
            name.removeRef(ref);
          }
        }
 else         if (ref.type == Type.ALIASING_GET && hoistScope.isGlobal() && ref.getTwin() == null) {
          if (inlineGlobalAliasIfPossible(name,ref,namespace)) {
            name.removeRef(ref);
          }
        }
      }
    }
    if (!name.inExterns && name.type == Name.Type.CLASS) {
      List<Name> subclasses=name.subclasses;
      if (subclasses != null && name.props != null) {
        for (        Name subclass : subclasses) {
          for (          Name prop : name.props) {
            rewriteAllSubclassInheritedAccesses(name,subclass,prop,namespace);
          }
        }
      }
    }
    if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) && name.aliasingGets == 0 && name.props != null) {
      workList.addAll(name.props);
    }
  }
}","/** 
 * For each qualified name N in the global scope, we check if: (a) No ancestor of N is ever aliased or assigned an unknown value type. (If N = ""a.b.c"", ""a"" and ""a.b"" are never aliased). (b) N has exactly one write, and it lives in the global scope. (c) N is aliased in a local scope. (d) N is aliased in global scope <p>If (a) is true, then GlobalNamespace must know all the writes to N. If (a) and (b) are true, then N cannot change during the execution of a local scope. If (a) and (b) and (c) are true, then the alias can be inlined if the alias obeys the usual rules for how we decide whether a variable is inlineable. If (a) and (b) and (d) are true, then inline the alias if possible (if it is assigned exactly once unconditionally). <p>For (a), (b), and (c) are true and the alias is of a constructor, we may also partially inline the alias - i.e. replace some references with the constructor but not all - since constructor properties are always collapsed, so we want to be more aggressive about removing aliases.
 * @see InlineVariables
 */
private void inlineAliases(GlobalNamespace namespace){
  Deque<Name> workList=new ArrayDeque<>(namespace.getNameForest());
  while (!workList.isEmpty()) {
    Name name=workList.pop();
    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {
      continue;
    }
    if (!name.inExterns && name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) {
      List<Ref> refs=new ArrayList<>(name.getRefs());
      for (      Ref ref : refs) {
        Scope hoistScope=ref.scope.getClosestHoistScope();
        if (ref.type == Type.ALIASING_GET && !mayBeGlobalAlias(ref)) {
          if (inlineAliasIfPossible(name,ref,namespace)) {
            name.removeRef(ref);
          }
        }
 else         if (ref.type == Type.ALIASING_GET && hoistScope.isGlobal() && ref.getTwin() == null) {
          if (inlineGlobalAliasIfPossible(name,ref,namespace)) {
            name.removeRef(ref);
          }
        }
      }
    }
    if (!name.inExterns && name.type == Name.Type.CLASS) {
      List<Name> subclasses=name.subclasses;
      if (subclasses != null && name.props != null) {
        for (        Name subclass : subclasses) {
          for (          Name prop : name.props) {
            rewriteAllSubclassInheritedAccesses(name,subclass,prop,namespace);
          }
        }
      }
    }
    if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION || name.type == Name.Type.CLASS) && name.aliasingGets == 0 && name.props != null) {
      workList.addAll(name.props);
    }
  }
}",0.9937573156457276
27189,"private boolean inlineAliasIfPossible(Name name,Ref alias,GlobalNamespace namespace){
  Node aliasParent=alias.node.getParent();
  if (aliasParent.isName() || aliasParent.isAssign()) {
    Node aliasLhsNode=aliasParent.isName() ? aliasParent : aliasParent.getFirstChild();
    String aliasVarName=aliasLhsNode.getString();
    Var aliasVar=alias.scope.getVar(aliasVarName);
    checkState(aliasVar != null,""String_Node_Str"",aliasVarName);
    Node aliasDeclarationParent=aliasVar.getParentNode();
    Scope scope=aliasDeclarationParent.isVar() ? alias.scope.getClosestHoistScope() : alias.scope;
    ReferenceCollectingCallback collector=new ReferenceCollectingCallback(compiler,ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,new Es6SyntacticScopeCreator(compiler),Predicates.equalTo(aliasVar));
    collector.processScope(scope);
    ReferenceCollection aliasRefs=collector.getReferences(aliasVar);
    Set<AstChange> newNodes=new LinkedHashSet<>();
    if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration()) {
      if (!aliasRefs.isAssignedOnceInLifetime()) {
        if (name.isConstructor()) {
          boolean accessPropsAfterAliasing=false;
          for (          Reference ref : aliasRefs.references) {
            if (ref.getNode().getParent().isGetProp()) {
              accessPropsAfterAliasing=true;
              break;
            }
          }
          if (accessPropsAfterAliasing) {
            compiler.report(JSError.make(aliasParent,UNSAFE_CTOR_ALIASING,aliasVarName));
          }
        }
        return false;
      }
      int size=aliasRefs.references.size();
      for (int i=1; i < size; i++) {
        Reference aliasRef=aliasRefs.references.get(i);
        newNodes.add(replaceAliasReference(alias,aliasRef));
      }
      aliasParent.replaceChild(alias.node,IR.nullNode());
      codeChanged=true;
      compiler.reportChangeToEnclosingScope(aliasParent);
      namespace.scanNewNodes(newNodes);
      return true;
    }
    if (name.isConstructor()) {
      return partiallyInlineAlias(alias,namespace,aliasRefs,aliasLhsNode);
    }
  }
  return false;
}","private boolean inlineAliasIfPossible(Name name,Ref alias,GlobalNamespace namespace){
  Node aliasParent=alias.node.getParent();
  if (aliasParent.isName() || aliasParent.isAssign()) {
    Node aliasLhsNode=aliasParent.isName() ? aliasParent : aliasParent.getFirstChild();
    String aliasVarName=aliasLhsNode.getString();
    Var aliasVar=alias.scope.getVar(aliasVarName);
    checkState(aliasVar != null,""String_Node_Str"",aliasVarName);
    ReferenceCollectingCallback collector=new ReferenceCollectingCallback(compiler,ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,new Es6SyntacticScopeCreator(compiler),Predicates.equalTo(aliasVar));
    collector.processScope(aliasVar.getScope());
    ReferenceCollection aliasRefs=collector.getReferences(aliasVar);
    Set<AstChange> newNodes=new LinkedHashSet<>();
    if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration()) {
      if (!aliasRefs.isAssignedOnceInLifetime()) {
        if (name.isConstructor()) {
          boolean accessPropsAfterAliasing=false;
          for (          Reference ref : aliasRefs.references) {
            if (ref.getNode().getParent().isGetProp()) {
              accessPropsAfterAliasing=true;
              break;
            }
          }
          if (accessPropsAfterAliasing) {
            compiler.report(JSError.make(aliasParent,UNSAFE_CTOR_ALIASING,aliasVarName));
          }
        }
        return false;
      }
      int size=aliasRefs.references.size();
      for (int i=1; i < size; i++) {
        Reference aliasRef=aliasRefs.references.get(i);
        newNodes.add(replaceAliasReference(alias,aliasRef));
      }
      aliasParent.replaceChild(alias.node,IR.nullNode());
      codeChanged=true;
      compiler.reportChangeToEnclosingScope(aliasParent);
      namespace.scanNewNodes(newNodes);
      return true;
    }
    if (name.isConstructor()) {
      return partiallyInlineAlias(alias,namespace,aliasRefs,aliasLhsNode);
    }
  }
  return false;
}",0.9558428885093926
27190,"/** 
 * @param value The value to use when rewriting.
 * @param depth The chain depth.
 * @param newNodes Expression nodes that have been updated.
 * @param prop The property to rewrite with value.
 */
private void rewriteAliasProp(Node value,int depth,Set<AstChange> newNodes,Name prop){
  rewriteAliasProps(prop,value,depth + 1,newNodes);
  List<Ref> refs=new ArrayList<>(prop.getRefs());
  for (  Ref ref : refs) {
    Node target=ref.node;
    for (int i=0; i <= depth; i++) {
      if (target.isGetProp()) {
        target=target.getFirstChild();
      }
 else       if (NodeUtil.isObjectLitKey(target)) {
        Node gparent=target.getGrandparent();
        if (gparent.isAssign()) {
          target=gparent.getFirstChild();
        }
 else {
          checkState(NodeUtil.isObjectLitKey(gparent));
          target=gparent;
        }
      }
 else {
        throw new IllegalStateException(""String_Node_Str"" + target);
      }
    }
    checkState(target.isGetProp() || target.isName());
    Node newValue=value.cloneTree();
    target.replaceWith(newValue);
    compiler.reportChangeToEnclosingScope(newValue);
    prop.removeRef(ref);
    newNodes.add(new AstChange(ref.module,ref.scope,ref.node));
  }
}","/** 
 * @param value The value to use when rewriting.
 * @param depth The chain depth.
 * @param newNodes Expression nodes that have been updated.
 * @param prop The property to rewrite with value.
 */
private void rewriteAliasProp(Node value,int depth,Set<AstChange> newNodes,Name prop){
  rewriteAliasProps(prop,value,depth + 1,newNodes);
  List<Ref> refs=new ArrayList<>(prop.getRefs());
  for (  Ref ref : refs) {
    Node target=ref.node;
    for (int i=0; i <= depth; i++) {
      if (target.isGetProp()) {
        target=target.getFirstChild();
      }
 else       if (NodeUtil.isObjectLitKey(target)) {
        Node gparent=target.getGrandparent();
        if (gparent.isAssign()) {
          target=gparent.getFirstChild();
        }
 else {
          checkState(NodeUtil.isObjectLitKey(gparent));
          target=gparent;
        }
      }
 else {
        throw new IllegalStateException(""String_Node_Str"" + target);
      }
    }
    checkState(target.isGetProp() || target.isName());
    Node newValue=value.cloneTree();
    target.replaceWith(newValue);
    compiler.reportChangeToEnclosingScope(newValue);
    prop.removeRef(ref);
    newNodes.add(new AstChange(ref.module,ref.scope,ref.node));
    codeChanged=true;
  }
}",0.9910277324632952
27191,"private void safeSetMaybeQualifiedString(Node nameNode,String newString){
  if (!newString.contains(""String_Node_Str"")) {
    safeSetString(nameNode,newString);
    return;
  }
  Node nameParent=nameNode.getParent();
  JSDocInfo jsdoc=nameParent.getJSDocInfo();
switch (nameParent.getToken()) {
case FUNCTION:
case CLASS:
    if (NodeUtil.isStatement(nameParent) && nameParent.getFirstChild() == nameNode) {
      Node statementParent=nameParent.getParent();
      Node placeholder=IR.empty();
      statementParent.replaceChild(nameParent,placeholder);
      Node newStatement=NodeUtil.newQNameDeclaration(compiler,newString,nameParent,jsdoc);
      nameParent.setJSDocInfo(null);
      newStatement.useSourceInfoIfMissingFromForTree(nameParent);
      replaceStringNodeLocationForExportedTopLevelVariable(newStatement,nameNode.getSourcePosition(),nameNode.getLength());
      statementParent.replaceChild(placeholder,newStatement);
      NodeUtil.removeName(nameParent);
      return;
    }
  break;
case VAR:
case LET:
case CONST:
{
  Node rhs=nameNode.hasChildren() ? nameNode.getLastChild().detach() : null;
  Node newStatement=NodeUtil.newQNameDeclaration(compiler,newString,rhs,jsdoc);
  newStatement.useSourceInfoIfMissingFromForTree(nameParent);
  int nameLength=nameNode.getOriginalName() != null ? nameNode.getOriginalName().length() : nameNode.getString().length();
  replaceStringNodeLocationForExportedTopLevelVariable(newStatement,nameNode.getSourcePosition(),nameLength);
  NodeUtil.replaceDeclarationChild(nameNode,newStatement);
  return;
}
case OBJECT_PATTERN:
case ARRAY_PATTERN:
case PARAM_LIST:
throw new RuntimeException(""String_Node_Str"");
default :
break;
}
Node newQualifiedNameNode=NodeUtil.newQName(compiler,newString);
newQualifiedNameNode.srcrefTree(nameNode);
nameParent.replaceChild(nameNode,newQualifiedNameNode);
compiler.reportChangeToEnclosingScope(newQualifiedNameNode);
}","private void safeSetMaybeQualifiedString(Node nameNode,String newString){
  if (!newString.contains(""String_Node_Str"")) {
    safeSetString(nameNode,newString);
    return;
  }
  Node nameParent=nameNode.getParent();
  JSDocInfo jsdoc=nameParent.getJSDocInfo();
switch (nameParent.getToken()) {
case FUNCTION:
case CLASS:
    if (NodeUtil.isStatement(nameParent) && nameParent.getFirstChild() == nameNode) {
      Node statementParent=nameParent.getParent();
      Node placeholder=IR.empty();
      statementParent.replaceChild(nameParent,placeholder);
      Node newStatement=NodeUtil.newQNameDeclaration(compiler,newString,nameParent,jsdoc);
      nameParent.setJSDocInfo(null);
      newStatement.useSourceInfoIfMissingFromForTree(nameParent);
      replaceStringNodeLocationForExportedTopLevelVariable(newStatement,nameNode.getSourcePosition(),nameNode.getLength());
      statementParent.replaceChild(placeholder,newStatement);
      NodeUtil.removeName(nameParent);
      return;
    }
  break;
case VAR:
case LET:
case CONST:
{
  Node rhs=nameNode.hasChildren() ? nameNode.getLastChild().detach() : null;
  Node newStatement=NodeUtil.newQNameDeclaration(compiler,newString,rhs,jsdoc);
  newStatement.useSourceInfoIfMissingFromForTree(nameParent);
  int nameLength=nameNode.getOriginalName() != null ? nameNode.getOriginalName().length() : nameNode.getString().length();
  replaceStringNodeLocationForExportedTopLevelVariable(newStatement,nameNode.getSourcePosition(),nameLength);
  NodeUtil.replaceDeclarationChild(nameNode,newStatement);
  return;
}
case OBJECT_PATTERN:
case ARRAY_PATTERN:
case PARAM_LIST:
throw new RuntimeException(""String_Node_Str"");
default :
break;
}
Node newQualifiedNameNode=NodeUtil.newQName(compiler,newString);
newQualifiedNameNode.srcrefTree(nameNode);
nameParent.replaceChild(nameNode,newQualifiedNameNode);
if (newQualifiedNameNode.getFirstChild() != null) {
newQualifiedNameNode.getFirstChild().makeNonIndexableRecursive();
}
compiler.reportChangeToEnclosingScope(newQualifiedNameNode);
}",0.9624174707973592
27192,"private void addNonUnionType(TypeI newType){
  if (skipAmbiguating || invalidatingTypes.isInvalidating(newType)) {
    skipAmbiguating=true;
    return;
  }
  if (!relatedTypes.get(getIntForType(newType))) {
    computeRelatedTypes(newType);
    relatedTypes.or(getRelatedTypesOnNonUnion(newType));
  }
}","private void addNonUnionType(TypeI newType){
  if (skipAmbiguating || invalidatingTypes.isInvalidating(newType)) {
    skipAmbiguating=true;
    return;
  }
  ObjectTypeI maybeObj=newType.toMaybeObjectType();
  if (maybeObj != null) {
    newType=maybeObj.withoutStrayProperties();
  }
  if (!relatedTypes.get(getIntForType(newType))) {
    computeRelatedTypes(newType);
    relatedTypes.or(getRelatedTypesOnNonUnion(newType));
  }
}",0.7924016282225237
27193,"@Override public ObjectTypeI withoutStrayProperties(){
  ObjectType obj=getObjTypeIfSingletonObj();
  NominalType nt=getNominalTypeIfSingletonObj();
  return nt.isLiteralObject() || obj.isPrototypeObject() || obj.isNamespace() ? this : nt.getInstanceAsJSType();
}","@Override public ObjectTypeI withoutStrayProperties(){
  ObjectType obj=getObjTypeIfSingletonObj();
  NominalType nt=getNominalTypeIfSingletonObj();
  if (nt.isLiteralObject()) {
    return this;
  }
  if (obj.isPrototypeObject()) {
    return obj.getOwnerFunction().getInstanceTypeOfCtor().getPrototypeObject();
  }
  if (obj.isNamespace()) {
    return obj.getNamespaceType();
  }
  return nt.getInstanceAsJSType();
}",0.7008797653958945
27194,"private static boolean canMergeObjectsInJoin(ObjectType obj1,ObjectType obj2){
  if (obj1.isTopObject() || obj2.isTopObject()) {
    return true;
  }
  NominalType nt1=obj1.nominalType;
  NominalType nt2=obj2.nominalType;
  if ((nt1.isBuiltinObject() || nt1.isLiteralObject()) && (nt2.isBuiltinObject() || nt2.isLiteralObject())) {
    return true;
  }
  if (nt1.isBuiltinObject()) {
    return obj1.isLoose && obj2.isSubtypeOf(obj1,SubtypeCache.create());
  }
  if (nt2.isBuiltinObject()) {
    return obj2.isLoose && obj1.isSubtypeOf(obj2,SubtypeCache.create());
  }
  return areRelatedNominalTypes(nt1,nt2) || NominalType.equalRawTypes(nt1,nt2);
}","private static boolean canMergeObjectsInJoin(ObjectType obj1,ObjectType obj2){
  if (obj1.isTopObject() || obj2.isTopObject() || obj1.equals(obj2)) {
    return true;
  }
  NominalType nt1=obj1.nominalType;
  NominalType nt2=obj2.nominalType;
  if (!obj1.isPrototypeObject() && (nt1.isBuiltinObject() || nt1.isLiteralObject()) && !obj2.isPrototypeObject()&& (nt2.isBuiltinObject() || nt2.isLiteralObject())) {
    return true;
  }
  if (nt1.isBuiltinObject()) {
    return obj1.isLoose && obj2.isSubtypeOf(obj1,SubtypeCache.create());
  }
  if (nt2.isBuiltinObject()) {
    return obj2.isLoose && obj1.isSubtypeOf(obj2,SubtypeCache.create());
  }
  return !obj1.isPrototypeObject() && !obj2.isPrototypeObject() && (areRelatedNominalTypes(nt1,nt2) || NominalType.equalRawTypes(nt1,nt2));
}",0.9040333796940194
27195,"Set<JSType> getSubtypesWithProperty(String pname){
  if (mayHaveProp(pname)) {
    if (this.protoProps.containsKey(pname)) {
      return ImmutableSet.of(this.protoObject);
    }
 else {
      return ImmutableSet.of(getInstanceAsJSType());
    }
  }
  HashSet<JSType> typesWithProp=new HashSet<>();
  for (  RawNominalType subtype : this.subtypes) {
    typesWithProp.addAll(subtype.getSubtypesWithProperty(pname));
  }
  return typesWithProp;
}","Set<JSType> getSubtypesWithProperty(String pname){
  if (mayHaveProp(pname)) {
    if (this.protoProps.containsKey(pname)) {
      return ImmutableSet.of(this.protoObject);
    }
    return ImmutableSet.of(getInstanceAsJSType());
  }
  HashSet<JSType> typesWithProp=new HashSet<>();
  for (  RawNominalType subtype : this.subtypes) {
    typesWithProp.addAll(subtype.getSubtypesWithProperty(pname));
  }
  return typesWithProp;
}",0.9176201372997712
27196,"public void testGetAllVars2(){
  String fnString=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  Compiler compiler=new Compiler();
  compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);
  ScopeCreator scopeCreator=new Es6SyntacticScopeCreator(compiler);
  Node ast=parse(fnString);
  Node functionNode=getFunctionNode(fnString);
  Scope globalScope=Scope.createGlobalScope(ast);
  Scope functionScope=scopeCreator.createScope(functionNode,globalScope);
  Map<String,Var> allVariables=new HashMap<>();
  List<Var> orderedVars=new LinkedList<>();
  NodeUtil.getAllVarsDeclaredInFunction(allVariables,orderedVars,compiler,scopeCreator,functionScope);
  Set<String> keySet=new HashSet<>(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  assertEquals(keySet,allVariables.keySet());
}","public void testGetAllVars2(){
  String fnString=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  Compiler compiler=new Compiler();
  compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);
  ScopeCreator scopeCreator=new Es6SyntacticScopeCreator(compiler);
  Node ast=parse(fnString);
  Node functionNode=getFunctionNode(fnString);
  Scope globalScope=Scope.createGlobalScope(ast);
  Scope functionScope=scopeCreator.createScope(functionNode,globalScope);
  Map<String,Var> allVariables=new HashMap<>();
  List<Var> orderedVars=new ArrayList<>();
  NodeUtil.getAllVarsDeclaredInFunction(allVariables,orderedVars,compiler,scopeCreator,functionScope);
  Set<String> keySet=new HashSet<>(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  assertEquals(keySet,allVariables.keySet());
}",0.9940636805180788
27197,"public void testGetAllVars1(){
  String fnString=""String_Node_Str"";
  Compiler compiler=new Compiler();
  compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);
  ScopeCreator scopeCreator=new Es6SyntacticScopeCreator(compiler);
  Node ast=parse(fnString);
  Node functionNode=getFunctionNode(fnString);
  Scope globalScope=Scope.createGlobalScope(ast);
  Scope functionScope=scopeCreator.createScope(functionNode,globalScope);
  Map<String,Var> allVariables=new HashMap<>();
  List<Var> orderedVars=new LinkedList<>();
  NodeUtil.getAllVarsDeclaredInFunction(allVariables,orderedVars,compiler,scopeCreator,functionScope);
  Set<String> keySet=new HashSet<>(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  assertEquals(keySet,allVariables.keySet());
}","public void testGetAllVars1(){
  String fnString=""String_Node_Str"";
  Compiler compiler=new Compiler();
  compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);
  ScopeCreator scopeCreator=new Es6SyntacticScopeCreator(compiler);
  Node ast=parse(fnString);
  Node functionNode=getFunctionNode(fnString);
  Scope globalScope=Scope.createGlobalScope(ast);
  Scope functionScope=scopeCreator.createScope(functionNode,globalScope);
  Map<String,Var> allVariables=new HashMap<>();
  List<Var> orderedVars=new ArrayList<>();
  NodeUtil.getAllVarsDeclaredInFunction(allVariables,orderedVars,compiler,scopeCreator,functionScope);
  Set<String> keySet=new HashSet<>(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  assertEquals(keySet,allVariables.keySet());
}",0.9933694996986135
27198,"private void maybeProcessClassBaseCall(NodeTraversal t,Node n){
  Node callTarget=n.getFirstChild();
  Node baseContainerNode=callTarget.getFirstChild();
  if (!baseContainerNode.isUnscopedQualifiedName()) {
    return;
  }
  String baseContainer=callTarget.getFirstChild().getQualifiedName();
  Node enclosingFnNameNode=getEnclosingDeclNameNode(n);
  if (enclosingFnNameNode == null || !enclosingFnNameNode.isUnscopedQualifiedName()) {
    if (knownClosureSubclasses.contains(baseContainer)) {
      reportBadBaseMethodUse(t,n,baseContainer,""String_Node_Str"");
    }
 else     if (baseUsedInClass(n)) {
      Node clazz=NodeUtil.getEnclosingClass(n);
      if ((clazz.getFirstChild().isName() && clazz.getFirstChild().getString().equals(baseContainer)) || (clazz.getSecondChild().isName() && clazz.getSecondChild().getString().equals(baseContainer))) {
        reportBadGoogBaseUse(t,n,""String_Node_Str"");
      }
    }
    return;
  }
  if (baseUsedInClass(n)) {
    reportBadGoogBaseUse(t,n,""String_Node_Str"");
    return;
  }
  String enclosingQname=enclosingFnNameNode.getQualifiedName();
  if (!enclosingQname.contains(""String_Node_Str"")) {
    if (!enclosingQname.equals(baseContainer)) {
      if (knownClosureSubclasses.contains(baseContainer)) {
        reportBadBaseMethodUse(t,n,baseContainer,""String_Node_Str"" + baseContainer + ""String_Node_Str"");
      }
      return;
    }
    Node enclosingParent=enclosingFnNameNode.getParent();
    Node maybeInheritsExpr=(enclosingParent.isAssign() ? enclosingParent.getParent() : enclosingParent).getNext();
    while (maybeInheritsExpr != null && maybeInheritsExpr.isEmpty()) {
      maybeInheritsExpr=maybeInheritsExpr.getNext();
    }
    Node baseClassNode=null;
    if (maybeInheritsExpr != null && maybeInheritsExpr.isExprResult() && maybeInheritsExpr.getFirstChild().isCall()) {
      Node callNode=maybeInheritsExpr.getFirstChild();
      if (callNode.getFirstChild().matchesQualifiedName(""String_Node_Str"") && callNode.getLastChild().isQualifiedName()) {
        baseClassNode=callNode.getLastChild();
      }
    }
    if (baseClassNode == null) {
      return;
    }
    Node callee=n.getFirstChild();
    Node thisArg=callee.getNext();
    if (thisArg == null || !thisArg.isThis()) {
      reportBadBaseMethodUse(t,n,baseContainer,""String_Node_Str"");
      return;
    }
    Node methodNameNode=thisArg.getNext();
    if (methodNameNode == null || !methodNameNode.isString() || !methodNameNode.getString().equals(""String_Node_Str"")) {
      reportBadBaseMethodUse(t,n,baseContainer,""String_Node_Str"");
      return;
    }
    n.replaceChild(callee,NodeUtil.newQName(compiler,baseClassNode.getQualifiedName() + ""String_Node_Str"",callee,enclosingQname + ""String_Node_Str""));
    n.removeChild(methodNameNode);
    compiler.reportChangeToEnclosingScope(n);
  }
 else {
    if (!knownClosureSubclasses.contains(baseContainer)) {
      return;
    }
    boolean misuseOfBase=!enclosingFnNameNode.getFirstFirstChild().matchesQualifiedName(baseContainer);
    if (misuseOfBase) {
      reportBadBaseMethodUse(t,n,baseContainer,""String_Node_Str"" + baseContainer + ""String_Node_Str"");
      return;
    }
    Node callee=n.getFirstChild();
    Node thisArg=callee.getNext();
    if (thisArg == null || !thisArg.isThis()) {
      reportBadBaseMethodUse(t,n,baseContainer,""String_Node_Str"");
      return;
    }
    Node methodNameNode=thisArg.getNext();
    if (methodNameNode == null || !methodNameNode.isString()) {
      reportBadBaseMethodUse(t,n,baseContainer,""String_Node_Str"");
      return;
    }
    String methodName=methodNameNode.getString();
    String ending=""String_Node_Str"" + methodName;
    if (enclosingQname == null || !enclosingQname.endsWith(ending)) {
      reportBadBaseMethodUse(t,n,baseContainer,""String_Node_Str"" + methodName);
      return;
    }
    Node className=enclosingFnNameNode.getFirstFirstChild();
    n.replaceChild(callee,NodeUtil.newQName(compiler,className.getQualifiedName() + ""String_Node_Str"" + methodName+ ""String_Node_Str"",callee,enclosingQname + ""String_Node_Str""));
    n.removeChild(methodNameNode);
    compiler.reportChangeToEnclosingScope(n);
  }
}","private void maybeProcessClassBaseCall(NodeTraversal t,Node n){
  Node callTarget=n.getFirstChild();
  Node baseContainerNode=callTarget.getFirstChild();
  if (!baseContainerNode.isUnscopedQualifiedName()) {
    return;
  }
  String baseContainer=callTarget.getFirstChild().getQualifiedName();
  Node enclosingFnNameNode=getEnclosingDeclNameNode(n);
  if (enclosingFnNameNode == null || !enclosingFnNameNode.isUnscopedQualifiedName()) {
    if (knownClosureSubclasses.contains(baseContainer)) {
      reportBadBaseMethodUse(t,n,baseContainer,""String_Node_Str"");
    }
 else     if (baseUsedInClass(n)) {
      Node clazz=NodeUtil.getEnclosingClass(n);
      if ((clazz.getFirstChild().isName() && clazz.getFirstChild().getString().equals(baseContainer)) || (clazz.getSecondChild().isName() && clazz.getSecondChild().getString().equals(baseContainer))) {
        reportBadBaseMethodUse(t,n,clazz.getFirstChild().getString(),""String_Node_Str"");
      }
    }
    return;
  }
  if (baseUsedInClass(n)) {
    reportBadGoogBaseUse(t,n,""String_Node_Str"");
    return;
  }
  String enclosingQname=enclosingFnNameNode.getQualifiedName();
  if (!enclosingQname.contains(""String_Node_Str"")) {
    if (!enclosingQname.equals(baseContainer)) {
      if (knownClosureSubclasses.contains(baseContainer)) {
        reportBadBaseMethodUse(t,n,baseContainer,""String_Node_Str"" + baseContainer + ""String_Node_Str"");
      }
      return;
    }
    Node enclosingParent=enclosingFnNameNode.getParent();
    Node maybeInheritsExpr=(enclosingParent.isAssign() ? enclosingParent.getParent() : enclosingParent).getNext();
    while (maybeInheritsExpr != null && maybeInheritsExpr.isEmpty()) {
      maybeInheritsExpr=maybeInheritsExpr.getNext();
    }
    Node baseClassNode=null;
    if (maybeInheritsExpr != null && maybeInheritsExpr.isExprResult() && maybeInheritsExpr.getFirstChild().isCall()) {
      Node callNode=maybeInheritsExpr.getFirstChild();
      if (callNode.getFirstChild().matchesQualifiedName(""String_Node_Str"") && callNode.getLastChild().isQualifiedName()) {
        baseClassNode=callNode.getLastChild();
      }
    }
    if (baseClassNode == null) {
      return;
    }
    Node callee=n.getFirstChild();
    Node thisArg=callee.getNext();
    if (thisArg == null || !thisArg.isThis()) {
      reportBadBaseMethodUse(t,n,baseContainer,""String_Node_Str"");
      return;
    }
    Node methodNameNode=thisArg.getNext();
    if (methodNameNode == null || !methodNameNode.isString() || !methodNameNode.getString().equals(""String_Node_Str"")) {
      reportBadBaseMethodUse(t,n,baseContainer,""String_Node_Str"");
      return;
    }
    n.replaceChild(callee,NodeUtil.newQName(compiler,baseClassNode.getQualifiedName() + ""String_Node_Str"",callee,enclosingQname + ""String_Node_Str""));
    n.removeChild(methodNameNode);
    compiler.reportChangeToEnclosingScope(n);
  }
 else {
    if (!knownClosureSubclasses.contains(baseContainer)) {
      return;
    }
    boolean misuseOfBase=!enclosingFnNameNode.getFirstFirstChild().matchesQualifiedName(baseContainer);
    if (misuseOfBase) {
      reportBadBaseMethodUse(t,n,baseContainer,""String_Node_Str"" + baseContainer + ""String_Node_Str"");
      return;
    }
    Node callee=n.getFirstChild();
    Node thisArg=callee.getNext();
    if (thisArg == null || !thisArg.isThis()) {
      reportBadBaseMethodUse(t,n,baseContainer,""String_Node_Str"");
      return;
    }
    Node methodNameNode=thisArg.getNext();
    if (methodNameNode == null || !methodNameNode.isString()) {
      reportBadBaseMethodUse(t,n,baseContainer,""String_Node_Str"");
      return;
    }
    String methodName=methodNameNode.getString();
    String ending=""String_Node_Str"" + methodName;
    if (enclosingQname == null || !enclosingQname.endsWith(ending)) {
      reportBadBaseMethodUse(t,n,baseContainer,""String_Node_Str"" + methodName);
      return;
    }
    Node className=enclosingFnNameNode.getFirstFirstChild();
    n.replaceChild(callee,NodeUtil.newQName(compiler,className.getQualifiedName() + ""String_Node_Str"" + methodName+ ""String_Node_Str"",callee,enclosingQname + ""String_Node_Str""));
    n.removeChild(methodNameNode);
    compiler.reportChangeToEnclosingScope(n);
  }
}",0.9947305389221556
27199,"public void testInvalidGoogBase14(){
  testError(""String_Node_Str"",GOOG_BASE_CLASS_ERROR);
}","public void testInvalidGoogBase14(){
  testError(""String_Node_Str"",BASE_CLASS_ERROR);
}",0.9720670391061452
27200,"public void testInvalidGoogBase14b(){
  testError(""String_Node_Str"",GOOG_BASE_CLASS_ERROR);
}","public void testInvalidGoogBase14b(){
  testError(""String_Node_Str"",BASE_CLASS_ERROR);
}",0.9723756906077348
27201,"private void visitNamespacePropertyDeclaration(Node declNode,Node recv,String pname){
  checkArgument(declNode.isGetProp() || NodeUtil.isObjLitProperty(declNode),declNode);
  checkArgument(currentScope.isNamespace(recv));
  if (declNode.isGetterDef()) {
    pname=getCommonTypes().createGetterPropName(pname);
  }
 else   if (declNode.isSetterDef()) {
    pname=getCommonTypes().createSetterPropName(pname);
  }
  if (declNode.isStringKey() && currentScope.isNamespace(declNode.getFirstChild())) {
    return;
  }
  EnumType et=currentScope.getEnum(QualifiedName.fromNode(recv));
  if (et != null && et.enumLiteralHasKey(pname)) {
    return;
  }
  Namespace ns=currentScope.getNamespace(QualifiedName.fromNode(recv));
  JSDocInfo jsdoc=NodeUtil.getBestJSDocInfo(declNode);
  PropertyType pt=getPropTypeHelper(jsdoc,declNode,null);
  JSType propDeclType=pt.declType;
  JSType propInferredFunType=pt.inferredFunType;
  boolean isConst=isConst(declNode);
  if (propDeclType != null || isConst) {
    JSType previousPropType=ns.getPropDeclaredType(pname);
    if (ns.hasSubnamespace(new QualifiedName(pname)) || (ns.hasStaticProp(pname) && previousPropType != null && !suppressDupPropWarning(jsdoc,propDeclType,previousPropType))) {
      warnings.add(JSError.make(declNode,REDECLARED_PROPERTY,pname,""String_Node_Str"" + ns));
      declNode.getParent().putBooleanProp(Node.ANALYZED_DURING_GTI,true);
      return;
    }
    if (propDeclType == null) {
      propDeclType=mayInferFromRhsIfConst(declNode);
    }
    ns.addProperty(pname,declNode,propDeclType,isConst);
    declNode.putBooleanProp(Node.ANALYZED_DURING_GTI,true);
    if (declNode.isGetProp() && isConst) {
      declNode.putBooleanProp(Node.CONSTANT_PROPERTY_DEF,true);
    }
  }
 else   if (propInferredFunType != null) {
    ns.addUndeclaredProperty(pname,declNode,propInferredFunType,false);
  }
 else {
    Node initializer=NodeUtil.getRValueOfLValue(declNode);
    JSType t=initializer == null ? null : simpleInferExprType(initializer);
    if (t == null) {
      t=getCommonTypes().UNKNOWN;
    }
    ns.addUndeclaredProperty(pname,declNode,t,false);
  }
}","private void visitNamespacePropertyDeclaration(Node declNode,Node recv,String pname){
  checkArgument(declNode.isGetProp() || NodeUtil.isObjLitProperty(declNode),declNode);
  checkArgument(currentScope.isNamespace(recv));
  if (declNode.isGetterDef()) {
    pname=getCommonTypes().createGetterPropName(pname);
  }
 else   if (declNode.isSetterDef()) {
    pname=getCommonTypes().createSetterPropName(pname);
  }
  if (declNode.isStringKey() && currentScope.isNamespace(declNode.getFirstChild())) {
    return;
  }
  EnumType et=currentScope.getEnum(QualifiedName.fromNode(recv));
  if (et != null && et.enumLiteralHasKey(pname)) {
    return;
  }
  Namespace ns=currentScope.getNamespace(QualifiedName.fromNode(recv));
  JSDocInfo jsdoc=NodeUtil.getBestJSDocInfo(declNode);
  PropertyType pt=getPropTypeHelper(jsdoc,declNode,null);
  JSType propDeclType=pt.declType;
  JSType propInferredFunType=pt.inferredFunType;
  boolean isConst=isConst(declNode);
  if (propDeclType != null || isConst) {
    JSType previousPropType=ns.getPropDeclaredType(pname);
    declNode.putBooleanProp(Node.ANALYZED_DURING_GTI,true);
    if (ns.hasSubnamespace(new QualifiedName(pname)) || (ns.hasStaticProp(pname) && previousPropType != null && !suppressDupPropWarning(jsdoc,propDeclType,previousPropType))) {
      warnings.add(JSError.make(declNode,REDECLARED_PROPERTY,pname,""String_Node_Str"" + ns));
      declNode.getParent().putBooleanProp(Node.ANALYZED_DURING_GTI,true);
      return;
    }
    if (propDeclType == null) {
      propDeclType=mayInferFromRhsIfConst(declNode);
    }
    ns.addProperty(pname,declNode,propDeclType,isConst);
    if (declNode.isGetProp() && isConst) {
      declNode.putBooleanProp(Node.CONSTANT_PROPERTY_DEF,true);
    }
  }
 else   if (propInferredFunType != null) {
    ns.addUndeclaredProperty(pname,declNode,propInferredFunType,false);
  }
 else {
    Node initializer=NodeUtil.getRValueOfLValue(declNode);
    JSType t=initializer == null ? null : simpleInferExprType(initializer);
    if (t == null) {
      t=getCommonTypes().UNKNOWN;
    }
    ns.addUndeclaredProperty(pname,declNode,t,false);
  }
}",0.9717514124293786
27202,"private void analyzeFunctionFwd(NTIWorkset workset){
  for (  DiGraphNode<Node,ControlFlowGraph.Branch> dn : workset.forward()) {
    Node n=dn.getValue();
    Node parent=n.getParent();
    checkState(n != null,""String_Node_Str"");
    TypeEnv inEnv=getInEnv(dn);
    TypeEnv outEnv=null;
    if (parent.isScript() || (parent.isNormalBlock() && parent.getParent().isFunction())) {
      inEnv=inEnv.clearChangeLog();
    }
    println(""String_Node_Str"",n);
    println(""String_Node_Str"",inEnv);
    boolean conditional=false;
switch (n.getToken()) {
case BLOCK:
case ROOT:
case BREAK:
case CONTINUE:
case DEFAULT_CASE:
case DEBUGGER:
case EMPTY:
case FUNCTION:
case SCRIPT:
case TRY:
case WITH:
      outEnv=inEnv;
    break;
case CATCH:
  String catchVarname=n.getFirstChild().getString();
outEnv=envPutType(inEnv,catchVarname,UNKNOWN);
break;
case EXPR_RESULT:
println(""String_Node_Str"",n.getFirstChild().getToken());
if (n.getBooleanProp(Node.ANALYZED_DURING_GTI)) {
n.removeProp(Node.ANALYZED_DURING_GTI);
outEnv=inEnv;
}
 else {
outEnv=analyzeExprFwd(n.getFirstChild(),inEnv,UNKNOWN).env;
}
break;
case RETURN:
outEnv=analyzeReturnFwd(n,inEnv);
break;
case DO:
case IF:
case FOR:
case WHILE:
conditional=true;
analyzeConditionalStmFwd(dn,NodeUtil.getConditionExpression(n),inEnv);
break;
case FOR_IN:
outEnv=analyzeForInFwd(n,inEnv);
break;
case FOR_OF:
outEnv=analyzeForOfFwd(n,inEnv);
break;
case CASE:
{
conditional=true;
analyzeConditionalStmFwd(dn,n,inEnv);
break;
}
case VAR:
outEnv=inEnv;
if (NodeUtil.isTypedefDecl(n)) {
break;
}
for (Node nameNode : n.children()) {
outEnv=analyzeVarDeclFwd(nameNode,outEnv);
}
break;
case SWITCH:
outEnv=analyzeExprFwd(n.getFirstChild(),inEnv).env;
break;
case THROW:
{
outEnv=analyzeExprFwd(n.getFirstChild(),inEnv).env;
exitEnvs.add(outEnv);
break;
}
default :
if (NodeUtil.isStatement(n)) {
throw new RuntimeException(""String_Node_Str"" + n.getToken());
}
 else {
outEnv=analyzeExprFwd(n,inEnv,UNKNOWN).env;
break;
}
}
if (!conditional) {
println(""String_Node_Str"",outEnv);
setOutEnv(dn,outEnv);
}
}
}","private void analyzeFunctionFwd(NTIWorkset workset){
  for (  DiGraphNode<Node,ControlFlowGraph.Branch> dn : workset.forward()) {
    Node n=dn.getValue();
    Node parent=n.getParent();
    checkState(n != null,""String_Node_Str"");
    TypeEnv inEnv=getInEnv(dn);
    TypeEnv outEnv=null;
    if (parent.isScript() || (parent.isNormalBlock() && parent.getParent().isFunction())) {
      inEnv=inEnv.clearChangeLog();
    }
    println(""String_Node_Str"",n);
    println(""String_Node_Str"",inEnv);
    boolean conditional=false;
switch (n.getToken()) {
case BLOCK:
case ROOT:
case BREAK:
case CONTINUE:
case DEFAULT_CASE:
case DEBUGGER:
case EMPTY:
case FUNCTION:
case SCRIPT:
case TRY:
case WITH:
      outEnv=inEnv;
    break;
case CATCH:
  Node catchVar=n.getFirstChild();
String catchVarname=catchVar.getString();
outEnv=envPutType(inEnv,catchVarname,UNKNOWN);
maybeSetTypeI(catchVar,UNKNOWN);
break;
case EXPR_RESULT:
println(""String_Node_Str"",n.getFirstChild().getToken());
if (n.getBooleanProp(Node.ANALYZED_DURING_GTI)) {
n.removeProp(Node.ANALYZED_DURING_GTI);
outEnv=inEnv;
}
 else {
outEnv=analyzeExprFwd(n.getFirstChild(),inEnv,UNKNOWN).env;
}
break;
case RETURN:
outEnv=analyzeReturnFwd(n,inEnv);
break;
case DO:
case IF:
case FOR:
case WHILE:
conditional=true;
analyzeConditionalStmFwd(dn,NodeUtil.getConditionExpression(n),inEnv);
break;
case FOR_IN:
outEnv=analyzeForInFwd(n,inEnv);
break;
case FOR_OF:
outEnv=analyzeForOfFwd(n,inEnv);
break;
case CASE:
{
conditional=true;
analyzeConditionalStmFwd(dn,n,inEnv);
break;
}
case VAR:
outEnv=inEnv;
if (NodeUtil.isTypedefDecl(n)) {
maybeSetTypeI(n.getFirstChild(),UNDEFINED);
break;
}
for (Node nameNode : n.children()) {
outEnv=analyzeVarDeclFwd(nameNode,outEnv);
}
break;
case SWITCH:
outEnv=analyzeExprFwd(n.getFirstChild(),inEnv).env;
break;
case THROW:
{
outEnv=analyzeExprFwd(n.getFirstChild(),inEnv).env;
exitEnvs.add(outEnv);
break;
}
default :
if (NodeUtil.isStatement(n)) {
throw new RuntimeException(""String_Node_Str"" + n.getToken());
}
 else {
outEnv=analyzeExprFwd(n,inEnv,UNKNOWN).env;
break;
}
}
if (!conditional) {
println(""String_Node_Str"",outEnv);
setOutEnv(dn,outEnv);
}
}
}",0.953128717582679
27203,"private EnvTypePair analyzePropertyTestCallFwd(Node call,TypeEnv inEnv,JSType specializedType){
  return analyzeTypePredicate(call,call.getFirstChild().getLastChild().getString(),inEnv,specializedType);
}","private EnvTypePair analyzePropertyTestCallFwd(Node call,TypeEnv inEnv,JSType specializedType){
  analyzeExprFwdIgnoreResult(call.getFirstChild(),inEnv);
  return analyzeTypePredicate(call,call.getFirstChild().getLastChild().getString(),inEnv,specializedType);
}",0.8755364806866953
27204,"private EnvTypePair analyzeTypePredicate(Node call,String typeHint,TypeEnv inEnv,JSType specializedType){
  int numArgs=call.getChildCount() - 1;
  if (numArgs != 1) {
    warnings.add(JSError.make(call,WRONG_ARGUMENT_COUNT,call.getFirstChild().getQualifiedName(),Integer.toString(numArgs),""String_Node_Str"",""String_Node_Str""));
    return analyzeInvocationArgsFwdWhenError(call,inEnv);
  }
  EnvTypePair pair=analyzeExprFwd(call.getLastChild(),inEnv);
  if (specializedType.isTrueOrTruthy() || specializedType.isFalseOrFalsy()) {
    pair=analyzeExprFwd(call.getLastChild(),inEnv,UNKNOWN,predicateTransformType(typeHint,specializedType,pair.type));
  }
  pair.type=BOOLEAN;
  return pair;
}","private EnvTypePair analyzeTypePredicate(Node call,String typeHint,TypeEnv inEnv,JSType specializedType){
  analyzeExprFwdIgnoreResult(call.getFirstChild(),inEnv);
  int numArgs=call.getChildCount() - 1;
  if (numArgs != 1) {
    warnings.add(JSError.make(call,WRONG_ARGUMENT_COUNT,call.getFirstChild().getQualifiedName(),Integer.toString(numArgs),""String_Node_Str"",""String_Node_Str""));
    return analyzeInvocationArgsFwdWhenError(call,inEnv);
  }
  EnvTypePair pair=analyzeExprFwd(call.getLastChild(),inEnv);
  if (specializedType.isTrueOrTruthy() || specializedType.isFalseOrFalsy()) {
    pair=analyzeExprFwd(call.getLastChild(),inEnv,UNKNOWN,predicateTransformType(typeHint,specializedType,pair.type));
  }
  pair.type=BOOLEAN;
  return pair;
}",0.9597222222222224
27205,"private EnvTypePair analyzeIncDecFwd(Node expr,TypeEnv inEnv,JSType requiredType){
  mayWarnAboutConst(expr);
  Node ch=expr.getFirstChild();
  if (ch.isGetProp() || (ch.isGetElem() && ch.getLastChild().isString())) {
    Node recv=ch.getFirstChild();
    String pname=ch.getLastChild().getString();
    EnvTypePair pair=analyzeExprFwd(recv,inEnv);
    JSType recvType=pair.type;
    if (mayWarnAboutConstProp(ch,recvType,new QualifiedName(pname))) {
      pair.type=requiredType;
      return pair;
    }
  }
  return analyzeUnaryNumFwd(expr,inEnv);
}","private EnvTypePair analyzeIncDecFwd(Node expr,TypeEnv inEnv,JSType requiredType){
  mayWarnAboutConst(expr);
  Node ch=expr.getFirstChild();
  if (ch.isGetProp() || (ch.isGetElem() && ch.getLastChild().isString())) {
    Node recv=ch.getFirstChild();
    String pname=ch.getLastChild().getString();
    EnvTypePair pair=analyzeExprFwd(recv,inEnv);
    JSType recvType=pair.type;
    if (mayWarnAboutConstProp(ch,recvType,new QualifiedName(pname))) {
      maybeSetTypeI(ch,recvType.getProp(new QualifiedName(pname)));
      pair.type=requiredType;
      return pair;
    }
  }
  return analyzeUnaryNumFwd(expr,inEnv);
}",0.9419795221843004
27206,"private EnvTypePair analyzeAssertionCall(Node callNode,TypeEnv env,AssertionFunctionSpec assertionFunctionSpec){
  Node firstParam=callNode.getSecondChild();
  if (firstParam == null) {
    return new EnvTypePair(env,UNKNOWN);
  }
  Node assertedNode=assertionFunctionSpec.getAssertedParam(firstParam);
  if (assertedNode == null) {
    return new EnvTypePair(env,UNKNOWN);
  }
  JSType assertedType=assertionFunctionSpec.getAssertedNewType(callNode,currentScope);
  if (assertedType.isUnknown()) {
    warnings.add(JSError.make(callNode,UNKNOWN_ASSERTION_TYPE));
  }
  EnvTypePair pair=analyzeExprFwd(assertedNode,env,UNKNOWN,assertedType);
  boolean haveCommonSubtype=JSType.haveCommonSubtype(assertedType,pair.type);
  if (!pair.type.isSubtypeOf(assertedType) && haveCommonSubtype) {
    pair.type=assertedType;
  }
  if (!haveCommonSubtype) {
    JSType t=analyzeExprFwd(assertedNode,env).type.substituteGenericsWithUnknown();
    if (t.isSubtypeOf(assertedType)) {
      pair.type=t;
    }
 else {
      if (!firstParam.isFalse()) {
        warnings.add(JSError.make(assertedNode,ASSERT_FALSE));
      }
      pair.type=UNKNOWN;
      pair.env=env;
    }
  }
  return pair;
}","private EnvTypePair analyzeAssertionCall(Node callNode,TypeEnv env,AssertionFunctionSpec assertionFunctionSpec){
  analyzeExprFwdIgnoreResult(callNode.getFirstChild(),env);
  Node firstParam=callNode.getSecondChild();
  if (firstParam == null) {
    return new EnvTypePair(env,UNKNOWN);
  }
  for (  Node assertionArgument : firstParam.siblings()) {
    analyzeExprFwdIgnoreResult(assertionArgument,env);
  }
  Node assertedNode=assertionFunctionSpec.getAssertedParam(firstParam);
  if (assertedNode == null) {
    return new EnvTypePair(env,UNKNOWN);
  }
  JSType assertedType=assertionFunctionSpec.getAssertedNewType(callNode,currentScope);
  if (assertedType.isUnknown()) {
    warnings.add(JSError.make(callNode,UNKNOWN_ASSERTION_TYPE));
  }
  EnvTypePair pair=analyzeExprFwd(assertedNode,env,UNKNOWN,assertedType);
  boolean haveCommonSubtype=JSType.haveCommonSubtype(assertedType,pair.type);
  if (!pair.type.isSubtypeOf(assertedType) && haveCommonSubtype) {
    pair.type=assertedType;
  }
  if (!haveCommonSubtype) {
    JSType t=analyzeExprFwd(assertedNode,env).type.substituteGenericsWithUnknown();
    if (t.isSubtypeOf(assertedType)) {
      pair.type=t;
    }
 else {
      if (!firstParam.isFalse()) {
        warnings.add(JSError.make(assertedNode,ASSERT_FALSE));
      }
      pair.type=UNKNOWN;
      pair.env=env;
    }
  }
  return pair;
}",0.9038613081166272
27207,"/** 
 * This method processes a single variable declaration in a VAR statement, in the forward phase of the analysis.
 */
private TypeEnv analyzeVarDeclFwd(Node nameNode,TypeEnv inEnv){
  String varName=nameNode.getString();
  JSType declType=this.currentScope.getDeclaredTypeOf(varName);
  if (this.currentScope.isLocalFunDef(varName)) {
    return inEnv;
  }
  Node rhs=nameNode.getFirstChild();
  if (NodeUtil.isNamespaceDecl(nameNode) || (GlobalTypeInfoCollector.isCtorDefinedByCall(nameNode) && !isFunctionBind(rhs.getFirstChild(),inEnv,true)) || nameNode.getParent().getBooleanProp(Node.ANALYZED_DURING_GTI)) {
    Preconditions.checkNotNull(declType,""String_Node_Str"",nameNode);
    maybeSetTypeI(nameNode,declType);
    return envPutType(inEnv,varName,declType);
  }
  TypeEnv outEnv=inEnv;
  JSType rhsType=null;
  if (rhs != null) {
    EnvTypePair pair=analyzeExprFwd(rhs,inEnv,firstNonNull(declType,UNKNOWN));
    outEnv=pair.env;
    rhsType=pair.type;
    if (declType != null) {
      if (rhsType.isSubtypeOf(declType)) {
        registerImplicitUses(rhs,rhsType,declType);
      }
 else {
        registerMismatchAndWarn(JSError.make(rhs,MISTYPED_ASSIGN_RHS,errorMsgWithTypeDiff(declType,rhsType)),rhsType,declType);
      }
    }
  }
  JSType varType=rhsType;
  if (rhs == null) {
    varType=UNDEFINED;
  }
 else   if (declType != null) {
    JSDocInfo jsdoc=NodeUtil.getBestJSDocInfo(nameNode);
    if (jsdoc != null && (!jsdoc.hasConstAnnotation() || jsdoc.hasType())) {
      varType=declType;
    }
  }
  maybeSetTypeI(nameNode,varType);
  return envPutType(outEnv,varName,varType);
}","/** 
 * This method processes a single variable declaration in a VAR statement, in the forward phase of the analysis.
 */
private TypeEnv analyzeVarDeclFwd(Node nameNode,TypeEnv inEnv){
  String varName=nameNode.getString();
  JSType declType=this.currentScope.getDeclaredTypeOf(varName);
  if (this.currentScope.isLocalFunDef(varName)) {
    return inEnv;
  }
  Node rhs=nameNode.getFirstChild();
  if (NodeUtil.isNamespaceDecl(nameNode) || (GlobalTypeInfoCollector.isCtorDefinedByCall(nameNode) && !isFunctionBind(rhs.getFirstChild(),inEnv,true)) || nameNode.getParent().getBooleanProp(Node.ANALYZED_DURING_GTI)) {
    Preconditions.checkNotNull(declType,""String_Node_Str"",nameNode);
    maybeSetTypeI(nameNode,declType);
    maybeSetTypeI(rhs,declType);
    return envPutType(inEnv,varName,declType);
  }
  TypeEnv outEnv=inEnv;
  JSType rhsType=null;
  if (rhs != null) {
    EnvTypePair pair=analyzeExprFwd(rhs,inEnv,firstNonNull(declType,UNKNOWN));
    outEnv=pair.env;
    rhsType=pair.type;
    if (declType != null) {
      if (rhsType.isSubtypeOf(declType)) {
        registerImplicitUses(rhs,rhsType,declType);
      }
 else {
        registerMismatchAndWarn(JSError.make(rhs,MISTYPED_ASSIGN_RHS,errorMsgWithTypeDiff(declType,rhsType)),rhsType,declType);
      }
    }
  }
  JSType varType=rhsType;
  if (rhs == null) {
    varType=UNDEFINED;
  }
 else   if (declType != null) {
    JSDocInfo jsdoc=NodeUtil.getBestJSDocInfo(nameNode);
    if (jsdoc != null && (!jsdoc.hasConstAnnotation() || jsdoc.hasType())) {
      varType=declType;
    }
  }
  maybeSetTypeI(nameNode,varType);
  return envPutType(outEnv,varName,varType);
}",0.9898305084745764
27208,"private boolean isFunctionBind(Node expr,TypeEnv env,boolean isFwd){
  if (NodeUtil.isFunctionBind(expr)) {
    return true;
  }
  if (!expr.isGetProp() || !expr.isQualifiedName() || !expr.getLastChild().getString().equals(""String_Node_Str"")) {
    return false;
  }
  Node recv=expr.getFirstChild();
  JSType recvType=isFwd ? analyzeExprFwd(recv,env).type : analyzeExprBwd(recv,env).type;
  return !recvType.isUnknown() && recvType.isSubtypeOf(commonTypes.topFunction());
}","private boolean isFunctionBind(Node callee,TypeEnv env,boolean isFwd){
  if (NodeUtil.isFunctionBind(callee)) {
    if (isFwd) {
      analyzeExprFwdIgnoreResult(callee,env);
    }
    return true;
  }
  if (!callee.isGetProp() || !callee.isQualifiedName() || !callee.getLastChild().getString().equals(""String_Node_Str"")) {
    return false;
  }
  Node recv=callee.getFirstChild();
  JSType recvType;
  if (isFwd) {
    recvType=analyzeExprFwd(recv,env).type;
    maybeSetTypeI(callee,recvType.getProp(new QualifiedName(""String_Node_Str"")));
  }
 else {
    recvType=analyzeExprBwd(recv,env).type;
  }
  return !recvType.isUnknown() && recvType.isSubtypeOf(commonTypes.topFunction());
}",0.7241379310344828
27209,"private LValueResultFwd analyzeLValueFwd(Node expr,TypeEnv inEnv,JSType requiredType,boolean insideQualifiedName){
  LValueResultFwd lvalResult=null;
switch (expr.getToken()) {
case THIS:
{
      mayWarnAboutGlobalThis(expr);
      if (this.currentScope.hasThis()) {
        lvalResult=new LValueResultFwd(inEnv,envGetType(inEnv,THIS_ID),this.currentScope.getDeclaredTypeOf(THIS_ID),new QualifiedName(THIS_ID));
      }
 else {
        lvalResult=new LValueResultFwd(inEnv,UNKNOWN,null,null);
      }
      break;
    }
case NAME:
{
    String varName=expr.getString();
    JSType varType=analyzeExprFwd(expr,inEnv).type;
    lvalResult=new LValueResultFwd(inEnv,varType,this.currentScope.getDeclaredTypeOf(varName),varType.hasNonScalar() ? new QualifiedName(varName) : null);
    break;
  }
case GETPROP:
case GETELEM:
{
  Node obj=expr.getFirstChild();
  Node prop=expr.getLastChild();
  QualifiedName pname=expr.isGetProp() || prop.isString() ? new QualifiedName(prop.getString()) : null;
  LValueResultFwd recvLvalue=analyzeReceiverLvalFwd(obj,pname,inEnv,requiredType);
  if (!recvLvalue.type.isSubtypeOf(TOP_OBJECT)) {
    EnvTypePair pair=analyzeExprFwd(prop,recvLvalue.env,requiredType);
    lvalResult=new LValueResultFwd(pair.env,requiredType,null,null);
    break;
  }
  JSType indexType=recvLvalue.type.getIndexType();
  if (expr.isGetElem() && indexType != null) {
    lvalResult=analyzeIObjectElmLvalFwd(prop,recvLvalue,indexType);
    break;
  }
  if (expr.isGetProp() || prop.isString()) {
    lvalResult=analyzePropLValFwd(obj,pname,recvLvalue,requiredType,insideQualifiedName);
    break;
  }
  EnvTypePair pair=analyzeExprFwd(expr,recvLvalue.env,requiredType);
  lvalResult=new LValueResultFwd(pair.env,pair.type,null,null);
  break;
}
case VAR:
{
checkState(expr.getParent().isForIn() || expr.getParent().isForOf());
Node vdecl=expr.getFirstChild();
String name=vdecl.getString();
checkState(!vdecl.hasChildren());
if (expr.getParent().isForIn()) {
  return new LValueResultFwd(inEnv,STRING,null,new QualifiedName(name));
}
 else {
  JSType declType=this.currentScope.getDeclaredTypeOf(name);
  return new LValueResultFwd(inEnv,requiredType,declType,new QualifiedName(name));
}
}
default :
{
checkState(insideQualifiedName);
EnvTypePair pair=analyzeExprFwd(expr,inEnv,requiredType);
return new LValueResultFwd(pair.env,pair.type,null,null);
}
}
maybeSetTypeI(expr,lvalResult.type);
mayWarnAboutUnknownType(expr,lvalResult.type);
return lvalResult;
}","private LValueResultFwd analyzeLValueFwd(Node expr,TypeEnv inEnv,JSType requiredType,boolean insideQualifiedName){
  LValueResultFwd lvalResult=null;
switch (expr.getToken()) {
case THIS:
{
      mayWarnAboutGlobalThis(expr);
      if (this.currentScope.hasThis()) {
        lvalResult=new LValueResultFwd(inEnv,envGetType(inEnv,THIS_ID),this.currentScope.getDeclaredTypeOf(THIS_ID),new QualifiedName(THIS_ID));
      }
 else {
        lvalResult=new LValueResultFwd(inEnv,UNKNOWN,null,null);
      }
      break;
    }
case NAME:
{
    String varName=expr.getString();
    JSType varType=analyzeExprFwd(expr,inEnv).type;
    lvalResult=new LValueResultFwd(inEnv,varType,this.currentScope.getDeclaredTypeOf(varName),varType.hasNonScalar() ? new QualifiedName(varName) : null);
    break;
  }
case GETPROP:
case GETELEM:
{
  Node obj=expr.getFirstChild();
  Node prop=expr.getLastChild();
  QualifiedName pname=expr.isGetProp() || prop.isString() ? new QualifiedName(prop.getString()) : null;
  LValueResultFwd recvLvalue=analyzeReceiverLvalFwd(obj,pname,inEnv,requiredType);
  if (!recvLvalue.type.isSubtypeOf(TOP_OBJECT)) {
    EnvTypePair pair=analyzeExprFwd(prop,recvLvalue.env,requiredType);
    lvalResult=new LValueResultFwd(pair.env,requiredType,null,null);
    break;
  }
  JSType indexType=recvLvalue.type.getIndexType();
  if (expr.isGetElem() && indexType != null) {
    lvalResult=analyzeIObjectElmLvalFwd(prop,recvLvalue,indexType);
    break;
  }
  if (expr.isGetProp() || prop.isString()) {
    lvalResult=analyzePropLValFwd(obj,pname,recvLvalue,requiredType,insideQualifiedName);
    break;
  }
  EnvTypePair pair=analyzeExprFwd(expr,recvLvalue.env,requiredType);
  lvalResult=new LValueResultFwd(pair.env,pair.type,null,null);
  break;
}
case VAR:
{
checkState(expr.getParent().isForIn() || expr.getParent().isForOf());
Node nameNode=expr.getFirstChild();
String name=nameNode.getString();
checkState(!nameNode.hasChildren());
maybeSetTypeI(nameNode,requiredType);
if (expr.getParent().isForIn()) {
  return new LValueResultFwd(inEnv,STRING,null,new QualifiedName(name));
}
 else {
  JSType declType=this.currentScope.getDeclaredTypeOf(name);
  return new LValueResultFwd(inEnv,requiredType,declType,new QualifiedName(name));
}
}
default :
{
checkState(insideQualifiedName);
EnvTypePair pair=analyzeExprFwd(expr,inEnv,requiredType);
return new LValueResultFwd(pair.env,pair.type,null,null);
}
}
maybeSetTypeI(expr,lvalResult.type);
mayWarnAboutUnknownType(expr,lvalResult.type);
return lvalResult;
}",0.9845536609829488
27210,"private EnvTypePair analyzeGoogTypeof(Node typeof,Node typeString,TypeEnv inEnv,JSType specializedType){
  return analyzeTypePredicate(typeof,typeString.isString() ? typeString.getString() : ""String_Node_Str"",inEnv,specializedType);
}","private EnvTypePair analyzeGoogTypeof(Node typeof,Node typeString,TypeEnv inEnv,JSType specializedType){
  analyzeExprFwdIgnoreResult(typeString,inEnv);
  return analyzeTypePredicate(typeof,typeString.isString() ? typeString.getString() : ""String_Node_Str"",inEnv,specializedType);
}",0.9069767441860463
27211,"static boolean isFunctionBind(Node expr){
  if (!expr.isGetProp()) {
    return false;
  }
  if (isGoogBind(expr) || isGoogPartial(expr)) {
    return true;
  }
  return expr.getFirstChild().isFunction() && expr.getLastChild().getString().equals(""String_Node_Str"");
}","/** 
 * Does not use type info. For example, it returns false for f.bind(...) because it cannot know whether f is a function.
 */
static boolean isFunctionBind(Node expr){
  if (!expr.isGetProp()) {
    return false;
  }
  if (isGoogBind(expr) || isGoogPartial(expr)) {
    return true;
  }
  return expr.getFirstChild().isFunction() && expr.getLastChild().getString().equals(""String_Node_Str"");
}",0.8042168674698795
27212,"public void testClosureStyleFunctionBind(){
  typeCheck(""String_Node_Str"",NewTypeInference.GOOG_BIND_EXPECTS_FUNCTION);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.WRONG_ARGUMENT_COUNT);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.WRONG_ARGUMENT_COUNT);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_THIS_TYPE_IN_BIND);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"");
  typeCheck(""String_Node_Str"");
}","public void testClosureStyleFunctionBind(){
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str""),NewTypeInference.GOOG_BIND_EXPECTS_FUNCTION);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str""),NewTypeInference.WRONG_ARGUMENT_COUNT);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str""),NewTypeInference.WRONG_ARGUMENT_COUNT);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_THIS_TYPE_IN_BIND);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str""));
}",0.8862370723945903
27213,"public void testSuperClassCtorProperty() throws Exception {
  String CLOSURE_DEFS=LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"");
  typeCheck(CLOSURE_DEFS + LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(CLOSURE_DEFS + LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INEXISTENT_PROPERTY);
  typeCheck(CLOSURE_DEFS + LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(CLOSURE_DEFS + LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(CLOSURE_DEFS + ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(CLOSURE_DEFS + ""String_Node_Str"",NewTypeInference.INEXISTENT_PROPERTY);
  typeCheck(CLOSURE_DEFS + ""String_Node_Str"");
}","public void testSuperClassCtorProperty() throws Exception {
  String CLOSURE_DEFS=LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"");
  typeCheck(CLOSURE_DEFS + LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(CLOSURE_DEFS + LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INEXISTENT_PROPERTY);
  typeCheck(CLOSURE_DEFS + LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(CLOSURE_DEFS + LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(CLOSURE_DEFS + ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(CLOSURE_DEFS + ""String_Node_Str"",NewTypeInference.INEXISTENT_PROPERTY);
  typeCheck(LINE_JOINER.join(CLOSURE_DEFS,""String_Node_Str""));
}",0.9739049394221808
27214,"public void testGoogIsPredicatesNoSpecializedContext(){
  typeCheck(CLOSURE_BASE + ""String_Node_Str"",NewTypeInference.WRONG_ARGUMENT_COUNT);
  typeCheck(CLOSURE_BASE + ""String_Node_Str"",NewTypeInference.WRONG_ARGUMENT_COUNT,NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(CLOSURE_BASE + ""String_Node_Str"");
}","public void testGoogIsPredicatesNoSpecializedContext(){
  typeCheck(CLOSURE_BASE + ""String_Node_Str"",NewTypeInference.WRONG_ARGUMENT_COUNT);
  typeCheck(CLOSURE_BASE + ""String_Node_Str"",NewTypeInference.WRONG_ARGUMENT_COUNT,NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str""));
}",0.965625
27215,"public void testSpecializeTypesAfterNullableDereference(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NULLABLE_DEREFERENCE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NULLABLE_DEREFERENCE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NULLABLE_DEREFERENCE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NULLABLE_DEREFERENCE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NULLABLE_DEREFERENCE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NULLABLE_DEREFERENCE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NULLABLE_DEREFERENCE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NULLABLE_DEREFERENCE);
}","public void testSpecializeTypesAfterNullableDereference(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NULLABLE_DEREFERENCE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NULLABLE_DEREFERENCE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NULLABLE_DEREFERENCE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NULLABLE_DEREFERENCE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NULLABLE_DEREFERENCE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NULLABLE_DEREFERENCE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NULLABLE_DEREFERENCE);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NULLABLE_DEREFERENCE);
}",0.9951726698848868
27216,"public void testAsserts(){
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.ASSERT_FALSE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.UNKNOWN_ASSERTION_TYPE);
  typeCheck(""String_Node_Str"");
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
}","public void testAsserts(){
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.ASSERT_FALSE);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.UNKNOWN_ASSERTION_TYPE,NewTypeInference.INEXISTENT_PROPERTY);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
}",0.8210125980508676
27217,"public void testInferThisInSimpleInferExprType(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
}","public void testInferThisInSimpleInferExprType(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
}",0.9826897470039948
27218,"public void testGoogIsPredicatesTrue(){
  typeCheck(CLOSURE_BASE + ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testGoogIsPredicatesTrue(){
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.9849640444541294
27219,"public static QualifiedName fromNode(Node qnameNode){
  if (qnameNode == null || !qnameNode.isQualifiedName()) {
    return null;
  }
  return qnameNode.isName() ? new QualifiedName(qnameNode.getString()) : new QualifiedName(ImmutableList.copyOf(Splitter.on('.').split(qnameNode.getQualifiedName())));
}","public static QualifiedName fromNode(Node qnameNode){
  if (qnameNode == null || !qnameNode.isQualifiedName()) {
    return null;
  }
  if (qnameNode.isGetProp()) {
    String pname=qnameNode.getLastChild().getString();
    return join(fromNode(qnameNode.getFirstChild()),new QualifiedName(pname));
  }
  return new QualifiedName(qnameNode.getQualifiedName());
}",0.5353383458646617
27220,"public final Node cloneTree(boolean cloneTypeExprs){
  Node result=cloneNode(cloneTypeExprs);
  Node firstChild=null;
  Node lastChild=null;
  if (this.hasChildren()) {
    for (Node n2=getFirstChild(); n2 != null; n2=n2.next) {
      Node n2clone=n2.cloneTree(cloneTypeExprs);
      n2clone.parent=result;
      if (firstChild == null) {
        firstChild=n2clone;
        lastChild=firstChild;
      }
 else {
        lastChild.next=n2clone;
        n2clone.previous=lastChild;
        lastChild=n2clone;
      }
    }
    firstChild.previous=lastChild;
    lastChild.next=null;
    result.first=firstChild;
  }
  return result;
}","@CheckReturnValue public final Node cloneTree(boolean cloneTypeExprs){
  Node result=cloneNode(cloneTypeExprs);
  Node firstChild=null;
  Node lastChild=null;
  if (this.hasChildren()) {
    for (Node n2=getFirstChild(); n2 != null; n2=n2.next) {
      Node n2clone=n2.cloneTree(cloneTypeExprs);
      n2clone.parent=result;
      if (firstChild == null) {
        firstChild=n2clone;
        lastChild=firstChild;
      }
 else {
        lastChild.next=n2clone;
        n2clone.previous=lastChild;
        lastChild=n2clone;
      }
    }
    firstChild.previous=lastChild;
    lastChild.next=null;
    result.first=firstChild;
  }
  return result;
}",0.985981308411215
27221,"/** 
 * @return A detached clone of the Node, specifically excluding its children.
 */
protected Node cloneNode(boolean cloneTypeExprs){
  return copyNodeFields(new Node(token),cloneTypeExprs);
}","/** 
 * @return A detached clone of the Node, specifically excluding its children.
 */
@CheckReturnValue protected Node cloneNode(boolean cloneTypeExprs){
  return copyNodeFields(new Node(token),cloneTypeExprs);
}",0.9558823529411764
27222,"public final void addChildToBack(Node child){
  checkArgument(child.parent == null,""String_Node_Str"",child,parent,this);
  checkArgument(child.next == null);
  checkArgument(child.previous == null);
  if (first == null) {
    child.previous=child;
    first=child;
  }
 else {
    Node last=first.previous;
    last.next=child;
    child.previous=last;
    first.previous=child;
  }
  child.parent=this;
}","public final void addChildToBack(Node child){
  checkArgument(child.parent == null,""String_Node_Str"",child,child.parent,this);
  checkArgument(child.next == null);
  checkArgument(child.previous == null);
  if (first == null) {
    child.previous=child;
    first=child;
  }
 else {
    Node last=first.previous;
    last.next=child;
    child.previous=last;
    first.previous=child;
  }
  child.parent=this;
}",0.9926470588235294
27223,"/** 
 * @param fnNode The function to inspect.
 * @return Whether the function has parameters, var, or function declarations.
 */
private static boolean hasLocalNames(Node fnNode){
  Node block=NodeUtil.getFunctionBody(fnNode);
  return NodeUtil.getFunctionParameters(fnNode).hasChildren() || NodeUtil.has(block,new NodeUtil.MatchDeclaration(),new NodeUtil.MatchShallowStatement());
}","/** 
 * @param fnNode The function to inspect.
 * @return Whether the function has parameters, var/const/let, class, or function declarations.
 */
private static boolean hasLocalNames(Node fnNode){
  Node block=NodeUtil.getFunctionBody(fnNode);
  return NodeUtil.getFunctionParameters(fnNode).hasChildren() || NodeUtil.has(block,new NodeUtil.MatchDeclaration(),new NodeUtil.MatchShallowStatement());
}",0.978343949044586
27224,"/** 
 * see   {@link #isClassDeclaration}
 */
public static boolean isClassDeclaration(Node n){
  return n.isClass() && isDeclarationParent(n.getParent());
}","/** 
 * see   {@link #isClassDeclaration}
 */
public static boolean isClassDeclaration(Node n){
  return n.isClass() && isDeclarationParent(n.getParent()) && isNamedClass(n);
}",0.9429429429429428
27225,"private static boolean isDeclarationParent(Node parent){
switch (parent.getToken()) {
case DECLARE:
    return true;
case EXPORT:
  return !parent.getBooleanProp(Node.EXPORT_DEFAULT);
default :
return isStatementParent(parent);
}
}","private static boolean isDeclarationParent(Node parent){
switch (parent.getToken()) {
case DECLARE:
case EXPORT:
    return true;
default :
  return isStatementParent(parent);
}
}",0.8
27226,"/** 
 * Is this node a function declaration? A function declaration is a function that has a name that is added to the current scope (i.e. a function that is not part of a expression; see   {@link #isFunctionExpression}).
 */
public static boolean isFunctionDeclaration(Node n){
  return n.isFunction() && isDeclarationParent(n.getParent());
}","/** 
 * Is this node a function declaration? A function declaration is a function that has a name that is added to the current scope (i.e. a function that is not part of a expression; see   {@link #isFunctionExpression}).
 */
public static boolean isFunctionDeclaration(Node n){
  return n.isFunction() && isDeclarationParent(n.getParent()) && isNamedFunction(n);
}",0.9689265536723164
27227,"/** 
 * Splits ES6 export combined with a variable or function declaration.
 */
private void splitExportDeclaration(Node n){
  Node c=n.getFirstChild();
  if (NodeUtil.isNameDeclaration(c) || c.isClass()) {
    n.removeChild(c);
    Node exportSpecs=new Node(Token.EXPORT_SPECS).srcref(n);
    n.addChildToFront(exportSpecs);
    Iterable<Node> names;
    if (c.isClass()) {
      names=Collections.singleton(c.getFirstChild());
      n.getParent().addChildBefore(c,n);
      n.getParent().addChildBefore(new Node(Token.EMPTY).srcref(n),n);
    }
 else {
      names=NodeUtil.getLhsNodesOfDeclaration(c);
      for (      Node child : c.children()) {
        c.removeChild(child);
        Node newDeclaration=new Node(c.getToken(),child).srcref(n);
        n.getParent().addChildBefore(newDeclaration,n);
      }
    }
    for (    Node name : names) {
      Node exportSpec=new Node(Token.EXPORT_SPEC).srcref(name);
      exportSpec.addChildToFront(name.cloneNode());
      exportSpec.addChildToFront(name.cloneNode());
      exportSpecs.addChildToBack(exportSpec);
    }
    compiler.reportChangeToEnclosingScope(n.getParent());
  }
}","/** 
 * Splits ES6 export combined with a variable or function declaration.
 */
private void splitExportDeclaration(Node n){
  if (n.getBooleanProp(Node.EXPORT_DEFAULT)) {
    return;
  }
  Node c=n.getFirstChild();
  if (NodeUtil.isDeclaration(c)) {
    n.removeChild(c);
    Node exportSpecs=new Node(Token.EXPORT_SPECS).srcref(n);
    n.addChildToFront(exportSpecs);
    Iterable<Node> names;
    if (c.isClass() || c.isFunction()) {
      names=Collections.singleton(c.getFirstChild());
      n.getParent().addChildBefore(c,n);
      if (c.isClass()) {
        n.getParent().addChildBefore(new Node(Token.EMPTY).srcref(n),n);
      }
    }
 else {
      names=NodeUtil.getLhsNodesOfDeclaration(c);
      for (      Node child : c.children()) {
        c.removeChild(child);
        Node newDeclaration=new Node(c.getToken(),child).srcref(n);
        n.getParent().addChildBefore(newDeclaration,n);
      }
    }
    for (    Node name : names) {
      Node exportSpec=new Node(Token.EXPORT_SPEC).srcref(name);
      exportSpec.addChildToFront(name.cloneNode());
      exportSpec.addChildToFront(name.cloneNode());
      exportSpecs.addChildToBack(exportSpec);
    }
    compiler.reportChangeToEnclosingScope(n.getParent());
  }
}",0.340227944280287
27228,"/** 
 * Rewrite named unhoisted functions declarations to a known consistent behavior so we don't to different logic paths for the same code. From: function f() {} to: var f = function () {}; and move it to the top of the block. This actually breaks semantics, but the semantics are also not well-defined cross-browser.
 * @see https://github.com/google/closure-compiler/pull/429
 */
static boolean visitFunction(Node n,AbstractCompiler compiler){
  checkState(n.isFunction(),n);
  if (NodeUtil.isFunctionDeclaration(n) && !NodeUtil.isHoistedFunctionDeclaration(n)) {
    rewriteFunctionDeclaration(n,compiler);
    return true;
  }
 else   if (n.isFunction() && !NodeUtil.getFunctionBody(n).isNormalBlock()) {
    Node returnValue=NodeUtil.getFunctionBody(n);
    Node body=IR.block(IR.returnNode(returnValue.detach()));
    body.useSourceInfoIfMissingFromForTree(returnValue);
    n.addChildToBack(body);
    compiler.reportChangeToEnclosingScope(body);
  }
  return false;
}","/** 
 * Rewrite named unhoisted functions declarations to a known consistent behavior so we don't to different logic paths for the same code. From: function f() {} to: var f = function () {}; and move it to the top of the block. This actually breaks semantics, but the semantics are also not well-defined cross-browser.
 * @see https://github.com/google/closure-compiler/pull/429
 */
static boolean visitFunction(Node n,AbstractCompiler compiler){
  checkState(n.isFunction(),n);
  if (NodeUtil.isFunctionDeclaration(n) && !NodeUtil.isHoistedFunctionDeclaration(n) && !n.getParent().isExport()) {
    rewriteFunctionDeclaration(n,compiler);
    return true;
  }
 else   if (n.isFunction() && !NodeUtil.getFunctionBody(n).isNormalBlock()) {
    Node returnValue=NodeUtil.getFunctionBody(n);
    Node body=IR.block(IR.returnNode(returnValue.detach()));
    body.useSourceInfoIfMissingFromForTree(returnValue);
    n.addChildToBack(body);
    compiler.reportChangeToEnclosingScope(body);
  }
  return false;
}",0.9853756933938476
27229,"public void testIsFunctionDeclaration(){
  assertTrue(NodeUtil.isFunctionDeclaration(getFunctionNode(""String_Node_Str"")));
  assertFalse(NodeUtil.isFunctionDeclaration(getFunctionNode(""String_Node_Str"")));
  assertFalse(NodeUtil.isFunctionDeclaration(getFunctionNode(""String_Node_Str"")));
  assertTrue(NodeUtil.isFunctionDeclaration(getFunctionNode(""String_Node_Str"")));
  assertFalse(NodeUtil.isFunctionDeclaration(getFunctionNode(""String_Node_Str"")));
  assertFalse(NodeUtil.isFunctionDeclaration(getFunctionNode(""String_Node_Str"")));
  assertFalse(NodeUtil.isFunctionDeclaration(getFunctionNode(""String_Node_Str"")));
}","public void testIsFunctionDeclaration(){
  assertTrue(NodeUtil.isFunctionDeclaration(getFunctionNode(""String_Node_Str"")));
  assertFalse(NodeUtil.isFunctionDeclaration(getFunctionNode(""String_Node_Str"")));
  assertFalse(NodeUtil.isFunctionDeclaration(getFunctionNode(""String_Node_Str"")));
  assertTrue(NodeUtil.isFunctionDeclaration(getFunctionNode(""String_Node_Str"")));
  assertFalse(NodeUtil.isFunctionDeclaration(getFunctionNode(""String_Node_Str"")));
  assertTrue(NodeUtil.isFunctionDeclaration(getFunctionNode(""String_Node_Str"")));
  assertFalse(NodeUtil.isFunctionDeclaration(getFunctionNode(""String_Node_Str"")));
}",0.9943593875906528
27230,"public void testIsClassDeclaration(){
  assertTrue(NodeUtil.isClassDeclaration(getClassNode(""String_Node_Str"")));
  assertFalse(NodeUtil.isClassDeclaration(getClassNode(""String_Node_Str"")));
  assertFalse(NodeUtil.isClassDeclaration(getClassNode(""String_Node_Str"")));
  assertFalse(NodeUtil.isClassDeclaration(getClassNode(""String_Node_Str"")));
  assertTrue(NodeUtil.isClassDeclaration(getClassNode(""String_Node_Str"")));
}","public void testIsClassDeclaration(){
  assertTrue(NodeUtil.isClassDeclaration(getClassNode(""String_Node_Str"")));
  assertFalse(NodeUtil.isClassDeclaration(getClassNode(""String_Node_Str"")));
  assertFalse(NodeUtil.isClassDeclaration(getClassNode(""String_Node_Str"")));
  assertTrue(NodeUtil.isClassDeclaration(getClassNode(""String_Node_Str"")));
  assertTrue(NodeUtil.isClassDeclaration(getClassNode(""String_Node_Str"")));
  assertFalse(NodeUtil.isClassDeclaration(getClassNode(""String_Node_Str"")));
}",0.7521739130434782
27231,"public void testSplitExportDeclarationOfClass(){
  test(""String_Node_Str"",""String_Node_Str"");
}","public void testSplitExportDeclarationOfClass(){
  test(""String_Node_Str"",""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
}",0.753968253968254
27232,"public void testSplitExportDeclarationOfFunction(){
  test(""String_Node_Str"",LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""));
}","public void testSplitExportDeclarationOfFunction(){
  test(""String_Node_Str"",LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""));
  testSame(""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
}",0.7790697674418605
27233,"/** 
 * Given an object literal to export, create an object lit with all its string properties. We don't care what the values of those properties are because they are not checked.
 */
private Node createExternObjectLit(Node exportedObjectLit){
  Node lit=IR.objectlit();
  lit.setJSType(exportedObjectLit.getJSType());
  lit.setJSDocInfo(buildEmptyJSDoc());
  int index=1;
  for (Node child=exportedObjectLit.getFirstChild(); child != null; child=child.getNext()) {
    if (child.isStringKey()) {
      lit.addChildToBack(IR.propdef(IR.stringKey(child.getString()),IR.number(index++)));
    }
  }
  return lit;
}","/** 
 * Given an object literal to export, create an object lit with all its string properties. We don't care what the values of those properties are because they are not checked.
 */
private Node createExternObjectLit(Node exportedObjectLit){
  Node lit=IR.objectlit();
  lit.setTypeI(exportedObjectLit.getTypeI());
  lit.setJSDocInfo(buildEmptyJSDoc());
  int index=1;
  for (Node child=exportedObjectLit.getFirstChild(); child != null; child=child.getNext()) {
    if (child.isStringKey()) {
      lit.addChildToBack(IR.propdef(IR.stringKey(child.getString()),IR.number(index++)));
    }
  }
  return lit;
}",0.995090016366612
27234,"/** 
 * Given a function to export, create the empty function that will be put in the externs file. This extern function should have the same type as the original function and the same parameter name but no function body. We create a warning here if the the function to export is missing parameter or return types.
 */
private Node createExternFunction(Node exportedFunction){
  Node paramList=NodeUtil.getFunctionParameters(exportedFunction).cloneTree();
  Node param=paramList.getFirstChild();
  while (param != null && param.isName()) {
    String originalName=param.getOriginalName();
    if (originalName != null) {
      param.setString(originalName);
    }
    param=param.getNext();
  }
  Node externFunction=IR.function(IR.name(""String_Node_Str""),paramList,IR.block());
  if (exportedFunction.getJSType() != null) {
    externFunction.setJSType(exportedFunction.getJSType());
    deleteInlineJsdocs(externFunction);
  }
  return externFunction;
}","/** 
 * Given a function to export, create the empty function that will be put in the externs file. This extern function should have the same type as the original function and the same parameter name but no function body. We create a warning here if the the function to export is missing parameter or return types.
 */
private Node createExternFunction(Node exportedFunction){
  Node paramList=NodeUtil.getFunctionParameters(exportedFunction).cloneTree();
  Node param=paramList.getFirstChild();
  while (param != null && param.isName()) {
    String originalName=param.getOriginalName();
    if (originalName != null) {
      param.setString(originalName);
    }
    param=param.getNext();
  }
  Node externFunction=IR.function(IR.name(""String_Node_Str""),paramList,IR.block());
  if (exportedFunction.getTypeI() != null) {
    externFunction.setTypeI(exportedFunction.getTypeI());
    deleteInlineJsdocs(externFunction);
  }
  return externFunction;
}",0.97325642370215
27235,"StringBuilder appendTo(StringBuilder builder,ToStringContext ctx){
  if (isPrototypeObject()) {
    return builder.append(getOwnerFunction().getThisType()).append(""String_Node_Str"");
  }
  if (!hasNonPrototypeProperties()) {
    if (fn != null) {
      return fn.appendTo(builder,ctx);
    }
    return this.nominalType.appendTo(builder,ctx);
  }
  if (!nominalType.isFunction() && !nominalType.isBuiltinObject() && !nominalType.isLiteralObject()) {
    nominalType.appendTo(builder,ctx);
  }
 else   if (isStruct()) {
    builder.append(""String_Node_Str"");
  }
 else   if (isDict()) {
    builder.append(""String_Node_Str"");
  }
 else   if (this.ns != null) {
    builder.append(this.ns);
  }
  if (this.fn != null) {
    builder.append(""String_Node_Str"");
    fn.appendTo(builder,ctx);
    builder.append(""String_Node_Str"");
  }
  if (ns == null || !props.isEmpty()) {
    builder.append('{');
    boolean firstIteration=true;
    for (    String pname : new TreeSet<>(props.keySet())) {
      if (firstIteration) {
        firstIteration=false;
      }
 else {
        builder.append(""String_Node_Str"");
      }
      builder.append(pname);
      builder.append(""String_Node_Str"");
      props.get(pname).appendTo(builder,ctx);
    }
    builder.append('}');
  }
  if (isLoose) {
    builder.append(""String_Node_Str"");
  }
  return builder;
}","StringBuilder appendTo(StringBuilder builder,ToStringContext ctx){
  if (isPrototypeObject()) {
    return builder.append(getOwnerFunction().getThisType()).append(""String_Node_Str"");
  }
  if (ctx.forAnnotation()) {
    if (fn != null) {
      fn.appendTo(builder,ctx);
    }
 else     if (!props.isEmpty()) {
      appendPropsTo(builder,ctx);
    }
 else     if (nominalType.isLiteralObject()) {
      builder.append(""String_Node_Str"");
    }
 else {
      nominalType.appendTo(builder,ctx);
    }
    return builder;
  }
  if (!hasNonPrototypeProperties()) {
    if (fn != null) {
      return fn.appendTo(builder,ctx);
    }
    return this.nominalType.appendTo(builder,ctx);
  }
  if (!nominalType.isFunction() && !nominalType.isBuiltinObject() && !nominalType.isLiteralObject()) {
    nominalType.appendTo(builder,ctx);
  }
 else   if (isStruct()) {
    builder.append(""String_Node_Str"");
  }
 else   if (isDict()) {
    builder.append(""String_Node_Str"");
  }
 else   if (this.ns != null) {
    builder.append(this.ns);
  }
  if (this.fn != null) {
    builder.append(""String_Node_Str"");
    fn.appendTo(builder,ctx);
    builder.append(""String_Node_Str"");
  }
  if (ns == null || !props.isEmpty()) {
    appendPropsTo(builder,ctx);
  }
  if (isLoose) {
    builder.append(""String_Node_Str"");
  }
  return builder;
}",0.4330206378986866
27236,"private void createSummary(NTIScope fn){
  Node fnRoot=fn.getRoot();
  checkArgument(!fnRoot.isFromExterns());
  FunctionTypeBuilder builder=new FunctionTypeBuilder(this.commonTypes);
  TypeEnv entryEnv=getEntryTypeEnv();
  TypeEnv exitEnv=getExitTypeEnv();
  if (exitEnv == null) {
    exitEnv=envPutType(new TypeEnv(),RETVAL_ID,BOTTOM);
  }
  DeclaredFunctionType declType=fn.getDeclaredFunctionType();
  int reqArity=declType.getRequiredArity();
  int optArity=declType.getOptionalArity();
  if (declType.isGeneric()) {
    builder.addTypeParameters(declType.getTypeParameters());
  }
  List<String> formals=fn.getFormals();
  for (int i=reqArity - 1; i >= 0; i--) {
    JSType formalType=declType.getFormalType(i);
    if (formalType != null) {
      break;
    }
    String formalName=formals.get(i);
    formalType=getTypeAfterFwd(formalName,entryEnv,exitEnv);
    if (formalType.isUnknown() || UNDEFINED.isSubtypeOf(formalType)) {
      reqArity--;
    }
 else {
      break;
    }
  }
  int i=0;
  for (  String formalName : formals) {
    JSType formalType=declType.getFormalType(i);
    if (formalType == null) {
      formalType=getTypeAfterFwd(formalName,entryEnv,exitEnv);
    }
    if (i < reqArity) {
      builder.addReqFormal(formalType);
    }
 else     if (i < optArity) {
      builder.addOptFormal(formalType);
    }
    i++;
  }
  if (declType.hasRestFormals()) {
    builder.addRestFormals(declType.getFormalType(i));
  }
  for (  String outer : fn.getOuterVars()) {
    println(""String_Node_Str"",outer,""String_Node_Str"");
    builder.addOuterVarPrecondition(outer,envGetType(entryEnv,outer));
  }
  builder.addNominalType(declType.getNominalType());
  builder.addReceiverType(declType.getReceiverType());
  builder.addAbstract(declType.isAbstract());
  addRetTypeAndWarn(fn,exitEnv,declType,builder);
  JSType summary=commonTypes.fromFunctionType(builder.buildFunction());
  println(""String_Node_Str"",fn.getReadableName());
  println(""String_Node_Str"",summary);
  summary=changeTypeIfFunctionNamespace(fn,summary);
  summaries.put(fn,summary);
  maybeSetTypeI(fnRoot,summary);
  Node fnNameNode=NodeUtil.getNameNode(fnRoot);
  if (fnNameNode != null) {
    maybeSetTypeI(fnNameNode,summary);
  }
}","private void createSummary(NTIScope fn){
  Node fnRoot=fn.getRoot();
  checkArgument(!fnRoot.isFromExterns());
  FunctionTypeBuilder builder=new FunctionTypeBuilder(this.commonTypes);
  TypeEnv entryEnv=getEntryTypeEnv();
  TypeEnv exitEnv=getExitTypeEnv();
  DeclaredFunctionType declType=fn.getDeclaredFunctionType();
  int reqArity=declType.getRequiredArity();
  int optArity=declType.getOptionalArity();
  if (declType.isGeneric()) {
    builder.addTypeParameters(declType.getTypeParameters());
  }
  List<String> formals=fn.getFormals();
  for (int i=reqArity - 1; i >= 0; i--) {
    JSType formalType=declType.getFormalType(i);
    if (formalType != null) {
      break;
    }
    String formalName=formals.get(i);
    formalType=getTypeAfterFwd(formalName,entryEnv,exitEnv);
    if (formalType.isUnknown() || UNDEFINED.isSubtypeOf(formalType)) {
      reqArity--;
    }
 else {
      break;
    }
  }
  int i=0;
  for (  String formalName : formals) {
    JSType formalType=declType.getFormalType(i);
    if (formalType == null) {
      formalType=getTypeAfterFwd(formalName,entryEnv,exitEnv);
    }
    if (i < reqArity) {
      builder.addReqFormal(formalType);
    }
 else     if (i < optArity) {
      builder.addOptFormal(formalType);
    }
    i++;
  }
  if (declType.hasRestFormals()) {
    builder.addRestFormals(declType.getFormalType(i));
  }
  for (  String outer : fn.getOuterVars()) {
    println(""String_Node_Str"",outer,""String_Node_Str"");
    builder.addOuterVarPrecondition(outer,envGetType(entryEnv,outer));
  }
  builder.addNominalType(declType.getNominalType());
  builder.addReceiverType(declType.getReceiverType());
  builder.addAbstract(declType.isAbstract());
  addRetTypeAndWarn(fn,exitEnv,declType,builder);
  JSType summary=commonTypes.fromFunctionType(builder.buildFunction());
  println(""String_Node_Str"",fn.getReadableName());
  println(""String_Node_Str"",summary);
  summary=changeTypeIfFunctionNamespace(fn,summary);
  summaries.put(fn,summary);
  maybeSetTypeI(fnRoot,summary);
  Node fnNameNode=NodeUtil.getNameNode(fnRoot);
  if (fnNameNode != null) {
    maybeSetTypeI(fnNameNode,summary);
  }
}",0.9804911636447096
27237,"private void addRetTypeAndWarn(NTIScope fn,TypeEnv exitEnv,DeclaredFunctionType declType,FunctionTypeBuilder builder){
  Node fnRoot=fn.getRoot();
  JSType declRetType=declType.getReturnType();
  JSType actualRetType=checkNotNull(envGetType(exitEnv,RETVAL_ID));
  if (declRetType != null) {
    if (fnRoot.isGeneratorFunction()) {
      JSType generator=this.commonTypes.getGeneratorInstance(UNKNOWN);
      if (!generator.isSubtypeOf(declRetType)) {
        registerMismatchAndWarn(JSError.make(fnRoot,INVALID_DECLARED_RETURN_TYPE_OF_GENERATOR_FUNCTION,errorMsgWithTypeDiff(generator,declRetType)),declRetType,generator);
        builder.addRetType(UNKNOWN);
      }
 else {
        builder.addRetType(declRetType);
      }
    }
 else {
      builder.addRetType(declRetType);
      if (!isAllowedToNotReturn(fn) && !UNDEFINED.isSubtypeOf(declRetType) && hasPathWithNoReturn(this.cfg)) {
        warnings.add(JSError.make(fnRoot,MISSING_RETURN_STATEMENT,declRetType.toString()));
      }
    }
  }
 else   if (fnRoot.isGeneratorFunction()) {
    JSType yieldType=envGetType(exitEnv,YIELDVAL_ID);
    builder.addRetType(this.commonTypes.getGeneratorInstance(firstNonNull(yieldType,UNKNOWN)));
  }
 else   if (declType.getNominalType() == null) {
    builder.addRetType(firstNonBottom(actualRetType,TOP));
  }
 else {
    builder.addRetType(UNDEFINED);
  }
}","private void addRetTypeAndWarn(NTIScope fn,TypeEnv exitEnv,DeclaredFunctionType declType,FunctionTypeBuilder builder){
  Node fnRoot=fn.getRoot();
  JSType declRetType=declType.getReturnType();
  JSType actualRetType=checkNotNull(envGetType(exitEnv,RETVAL_ID));
  if (declRetType != null) {
    if (fnRoot.isGeneratorFunction()) {
      JSType generator=this.commonTypes.getGeneratorInstance(UNKNOWN);
      if (!generator.isSubtypeOf(declRetType)) {
        registerMismatchAndWarn(JSError.make(fnRoot,INVALID_DECLARED_RETURN_TYPE_OF_GENERATOR_FUNCTION,errorMsgWithTypeDiff(generator,declRetType)),declRetType,generator);
        builder.addRetType(UNKNOWN);
      }
 else {
        builder.addRetType(declRetType);
      }
    }
 else {
      builder.addRetType(declRetType);
      if (!isAllowedToNotReturn(fn) && !UNDEFINED.isSubtypeOf(declRetType) && hasPathWithNoReturn(this.cfg)) {
        warnings.add(JSError.make(fnRoot,MISSING_RETURN_STATEMENT,declRetType.toString()));
      }
    }
  }
 else   if (fnRoot.isGeneratorFunction()) {
    JSType yieldType=envGetType(exitEnv,YIELDVAL_ID);
    builder.addRetType(this.commonTypes.getGeneratorInstance(firstNonNull(yieldType,UNKNOWN)));
  }
 else   if (declType.getNominalType() == null) {
    builder.addRetType(firstNonBottom(actualRetType,UNKNOWN));
  }
 else {
    builder.addRetType(UNDEFINED);
  }
}",0.9970566593083148
27238,"private TypeEnv getExitTypeEnv(){
  if (!this.cfg.getImplicitReturn().getInEdges().isEmpty()) {
    exitEnvs.add(getInEnv(this.cfg.getImplicitReturn()));
  }
  checkState(!exitEnvs.isEmpty(),""String_Node_Str"");
  return TypeEnv.join(exitEnvs);
}","private TypeEnv getExitTypeEnv(){
  for (int i=0; i < exitEnvs.size(); i++) {
    TypeEnv env=exitEnvs.get(i);
    exitEnvs.set(i,envPutType(env,RETVAL_ID,BOTTOM));
  }
  if (!this.cfg.getImplicitReturn().getInEdges().isEmpty()) {
    exitEnvs.add(getInEnv(this.cfg.getImplicitReturn()));
  }
  checkState(!exitEnvs.isEmpty(),""String_Node_Str"");
  return TypeEnv.join(exitEnvs);
}",0.784
27239,"public void testFunctionsWithAbnormalExit(){
  typeCheck(""String_Node_Str"");
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
}","public void testFunctionsWithAbnormalExit(){
  typeCheck(""String_Node_Str"");
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""));
}",0.8413284132841329
27240,"private boolean evalTypePredicate(Node ttlAst,NameResolver nameResolver){
  TypeI[] params=evalTypeParams(ttlAst,nameResolver);
  String name=getCallName(ttlAst);
  Keywords keyword=nameToKeyword(name);
  TypeI type=params[0];
switch (keyword) {
case EQ:
    return type.isEquivalentTo(params[1]);
case SUB:
  return type.isSubtypeOf(params[1]);
case ISCTOR:
return type.isConstructor();
case ISTEMPLATIZED:
return type.isObjectType() && type.toMaybeObjectType().isGenericObjectType() && !type.hasUninstantiatedTypeVariables();
case ISRECORD:
return type.isRecordType();
case ISUNKNOWN:
return type.isSomeUnknownType();
default :
throw new IllegalStateException(""String_Node_Str"");
}
}","private boolean evalTypePredicate(Node ttlAst,NameResolver nameResolver){
  TypeI[] params=evalTypeParams(ttlAst,nameResolver);
  String name=getCallName(ttlAst);
  Keywords keyword=nameToKeyword(name);
  TypeI type=params[0];
switch (keyword) {
case EQ:
    return type.isEquivalentTo(params[1]);
case SUB:
  return type.isSubtypeOf(params[1]);
case ISCTOR:
return type.isConstructor();
case ISTEMPLATIZED:
return type.isObjectType() && type.toMaybeObjectType().isGenericObjectType();
case ISRECORD:
return type.isRecordType();
case ISUNKNOWN:
return type.isSomeUnknownType();
default :
throw new IllegalStateException(""String_Node_Str"");
}
}",0.9683734939759036
27241,"private TypeI evalTemplatizedType(Node ttlAst,NameResolver nameResolver){
  ImmutableList<Node> params=getCallParams(ttlAst);
  TypeI firstParam=evalInternal(params.get(0),nameResolver);
  if (!firstParam.hasUninstantiatedTypeVariables()) {
    reportWarning(ttlAst,BASETYPE_INVALID,firstParam.toString());
    return getUnknownType();
  }
  TypeI[] templatizedTypes=new TypeI[params.size() - 1];
  for (int i=0; i < templatizedTypes.length; i++) {
    templatizedTypes[i]=evalInternal(params.get(i + 1),nameResolver);
  }
  ObjectTypeI baseType=firstParam.toMaybeObjectType();
  return createTemplatizedType(baseType,templatizedTypes);
}","private TypeI evalTemplatizedType(Node ttlAst,NameResolver nameResolver){
  ImmutableList<Node> params=getCallParams(ttlAst);
  TypeI firstParam=evalInternal(params.get(0),nameResolver);
  if (firstParam.isFullyInstantiated()) {
    reportWarning(ttlAst,BASETYPE_INVALID,firstParam.toString());
    return getUnknownType();
  }
  TypeI[] templatizedTypes=new TypeI[params.size() - 1];
  for (int i=0; i < templatizedTypes.length; i++) {
    templatizedTypes[i]=evalInternal(params.get(i + 1),nameResolver);
  }
  ObjectTypeI baseType=firstParam.toMaybeObjectType();
  return createTemplatizedType(baseType,templatizedTypes);
}",0.9604430379746836
27242,"private boolean evalTypePredicate(Node ttlAst,NameResolver nameResolver){
  TypeI[] params=evalTypeParams(ttlAst,nameResolver);
  String name=getCallName(ttlAst);
  Keywords keyword=nameToKeyword(name);
  TypeI type=params[0];
switch (keyword) {
case EQ:
    return type.isEquivalentTo(params[1]);
case SUB:
  return type.isSubtypeOf(params[1]);
case ISCTOR:
return type.isConstructor();
case ISTEMPLATIZED:
return type.isObjectType() && type.toMaybeObjectType().isGenericObjectType();
case ISRECORD:
return type.isRecordType();
case ISUNKNOWN:
return type.isSomeUnknownType();
default :
throw new IllegalStateException(""String_Node_Str"");
}
}","private boolean evalTypePredicate(Node ttlAst,NameResolver nameResolver){
  TypeI[] params=evalTypeParams(ttlAst,nameResolver);
  String name=getCallName(ttlAst);
  Keywords keyword=nameToKeyword(name);
  TypeI type=params[0];
switch (keyword) {
case EQ:
    return type.isEquivalentTo(params[1]);
case SUB:
  return type.isSubtypeOf(params[1]);
case ISCTOR:
return type.isConstructor();
case ISTEMPLATIZED:
return type.isObjectType() && type.toMaybeObjectType().isGenericObjectType() && type.isPartiallyInstantiated();
case ISRECORD:
return type.isRecordType();
case ISUNKNOWN:
return type.isSomeUnknownType();
default :
throw new IllegalStateException(""String_Node_Str"");
}
}",0.9742424242424242
27243,"private void exportClass(Node scriptNode,Node classNode){
  Node classMembers=classNode.getLastChild();
  for (  Node maybeMemberFunctionDef : classMembers.children()) {
    if (maybeMemberFunctionDef.isMemberFunctionDef()) {
      String methodName=maybeMemberFunctionDef.getString();
      if (TEST_FUNCTIONS_NAME_PATTERN.matcher(methodName).matches()) {
        String functionRef=NodeUtil.getName(classNode) + ""String_Node_Str"" + methodName;
        String classRef=NodeUtil.getName(classNode) + ""String_Node_Str"";
        Node exportCallTarget=NodeUtil.newQName(compiler,exportPropertyFunction,maybeMemberFunctionDef,methodName);
        Node call=IR.call(exportCallTarget);
        if (exportCallTarget.isName()) {
          call.putBooleanProp(Node.FREE_CALL,true);
        }
        call.addChildToBack(NodeUtil.newQName(compiler,classRef,maybeMemberFunctionDef,classRef));
        call.addChildToBack(IR.string(methodName));
        call.addChildToBack(NodeUtil.newQName(compiler,functionRef,maybeMemberFunctionDef,functionRef));
        Node expression=IR.exprResult(call);
        scriptNode.addChildAfter(expression,classNode);
        compiler.reportChangeToEnclosingScope(expression);
      }
    }
  }
}","private void exportClass(Node scriptNode,Node classNode,String className,Node baseNode){
  Node classMembers=classNode.getLastChild();
  for (  Node maybeMemberFunctionDef : classMembers.children()) {
    if (maybeMemberFunctionDef.isMemberFunctionDef()) {
      String methodName=maybeMemberFunctionDef.getString();
      if (isTestFunction(methodName)) {
        String functionRef=className + ""String_Node_Str"" + methodName;
        String classRef=className + ""String_Node_Str"";
        Node exportCallTarget=NodeUtil.newQName(compiler,exportPropertyFunction,maybeMemberFunctionDef,methodName);
        Node call=IR.call(exportCallTarget);
        if (exportCallTarget.isName()) {
          call.putBooleanProp(Node.FREE_CALL,true);
        }
        call.addChildToBack(NodeUtil.newQName(compiler,classRef,maybeMemberFunctionDef,classRef));
        call.addChildToBack(IR.string(methodName));
        call.addChildToBack(NodeUtil.newQName(compiler,functionRef,maybeMemberFunctionDef,functionRef));
        Node expression=IR.exprResult(call);
        scriptNode.addChildAfter(expression,baseNode);
        compiler.reportChangeToEnclosingScope(expression);
      }
    }
  }
}",0.8978741142142559
27244,"/** 
 * Whether node corresponds to a function expression declared with var, let or const which is of the form: <pre> var/let/const functionName = function() { // Implementation }; </pre> This has the AST structure VAR/LET/CONST -> NAME -> FUNCTION
 * @param node
 */
private boolean isNameDeclaredFunction(Node node){
  if (!NodeUtil.isNameDeclaration(node)) {
    return false;
  }
  Node grandchild=node.getFirstFirstChild();
  return grandchild != null && grandchild.isFunction();
}","/** 
 * Whether node corresponds to a function expression declared with var, let or const which is of the form: <pre> var/let/const functionName = function() { // Implementation }; </pre> This has the AST structure VAR/LET/CONST -> NAME -> FUNCTION
 * @param node
 */
private boolean isNameDeclaredFunction(Node node){
  Node grandchild=getNameDeclaredGrandchild(node);
  return grandchild != null && grandchild.isFunction();
}",0.7272727272727273
27245,"@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (parent == null) {
    return;
  }
  if (parent.isScript()) {
    if (NodeUtil.isFunctionDeclaration(n)) {
      String functionName=NodeUtil.getName(n);
      if (isTestFunction(functionName)) {
        exportTestFunctionAsSymbol(functionName,n,parent);
      }
    }
 else     if (isNameDeclaredFunction(n)) {
      Node functionNode=n.getFirstFirstChild();
      String functionName=NodeUtil.getName(functionNode);
      if (isTestFunction(functionName)) {
        exportTestFunctionAsSymbol(functionName,n,parent);
      }
    }
 else     if (n.isClass()) {
      exportClass(parent,n);
    }
  }
 else   if (NodeUtil.isExprAssign(parent) && !n.getLastChild().isAssign()) {
    Node grandparent=parent.getParent();
    if (grandparent != null && grandparent.isScript()) {
      String functionName=n.getFirstChild().getQualifiedName();
      if (isTestFunction(functionName)) {
        if (n.getFirstChild().isName()) {
          exportTestFunctionAsSymbol(functionName,parent,grandparent);
        }
 else {
          exportTestFunctionAsProperty(functionName,parent,n,grandparent);
        }
      }
    }
  }
 else   if (n.isObjectLit() && isCallTargetQName(n.getParent(),""String_Node_Str"")) {
    for (    Node c : n.children()) {
      if (c.isStringKey() && !c.isQuotedString()) {
        c.setQuotedString();
        compiler.reportChangeToEnclosingScope(c);
      }
 else       if (c.isMemberFunctionDef()) {
        rewriteMemberDefInObjLit(c,n);
      }
    }
  }
}","@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (parent == null) {
    return;
  }
  if (parent.isScript()) {
    if (NodeUtil.isFunctionDeclaration(n)) {
      String functionName=NodeUtil.getName(n);
      if (isTestFunction(functionName)) {
        exportTestFunctionAsSymbol(functionName,n,parent);
      }
    }
 else     if (isNameDeclaredFunction(n)) {
      Node functionNode=n.getFirstFirstChild();
      String functionName=NodeUtil.getName(functionNode);
      if (isTestFunction(functionName)) {
        exportTestFunctionAsSymbol(functionName,n,parent);
      }
    }
 else     if (isNameDeclaredClass(n)) {
      Node classNode=n.getFirstFirstChild();
      String className=NodeUtil.getName(classNode);
      exportClass(parent,classNode,className,n);
    }
 else     if (n.isClass()) {
      exportClass(parent,n);
    }
  }
 else   if (NodeUtil.isExprAssign(parent) && !n.getLastChild().isAssign()) {
    Node grandparent=parent.getParent();
    if (grandparent != null && grandparent.isScript()) {
      Node firstChild=n.getFirstChild();
      Node lastChild=n.getLastChild();
      String nodeName=firstChild.getQualifiedName();
      if (lastChild.isFunction()) {
        if (isTestFunction(nodeName)) {
          if (n.getFirstChild().isName()) {
            exportTestFunctionAsSymbol(nodeName,parent,grandparent);
          }
 else {
            exportTestFunctionAsProperty(nodeName,parent,n,grandparent);
          }
        }
      }
 else       if (lastChild.isClass()) {
        exportClass(grandparent,lastChild,nodeName,parent);
      }
    }
  }
 else   if (n.isObjectLit() && isCallTargetQName(n.getParent(),""String_Node_Str"")) {
    for (    Node c : n.children()) {
      if (c.isStringKey() && !c.isQuotedString()) {
        c.setQuotedString();
        compiler.reportChangeToEnclosingScope(c);
      }
 else       if (c.isMemberFunctionDef()) {
        rewriteMemberDefInObjLit(c,n);
      }
    }
  }
}",0.8103644646924829
27246,"@Override public void process(Node externs,Node root){
  NodeTraversal.traverseRootsEs6(compiler,new AbstractPostOrderCallback(){
    @Override public void visit(    NodeTraversal t,    Node n,    Node parent){
      if (n.isName() && !parent.isFunction() && !parent.isLabel()) {
        assertTrue(""String_Node_Str"" + n.getString() + ""String_Node_Str"",t.getScope().isDeclared(n.getString(),true));
      }
    }
  }
,externs,root);
}","@Override public void process(Node externs,Node root){
  NodeTraversal.traverseRootsEs6(compiler,new AbstractPostOrderCallback(){
    @Override public void visit(    NodeTraversal t,    Node n,    Node parent){
      if (n.isName() && !parent.isFunction() && !parent.isLabel()) {
        assertWithMessage(""String_Node_Str"",n).that(t.getScope().isDeclared(n.getString(),true)).isTrue();
      }
    }
  }
,externs,root);
}",0.866822429906542
27247,"@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (n.isName() && !parent.isFunction() && !parent.isLabel()) {
    assertTrue(""String_Node_Str"" + n.getString() + ""String_Node_Str"",t.getScope().isDeclared(n.getString(),true));
  }
}","@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (n.isName() && !parent.isFunction() && !parent.isLabel()) {
    assertWithMessage(""String_Node_Str"",n).that(t.getScope().isDeclared(n.getString(),true)).isTrue();
  }
}",0.6270491803278688
27248,"void fillPropertyScopes(){
  List<Symbol> types=new ArrayList<>();
  List<Symbol> googModuleExportTypes=new ArrayList<>();
  for (  Symbol sym : getAllSymbols()) {
    if (needsPropertyScope(sym)) {
      if (sym.getName().startsWith(""String_Node_Str"")) {
        googModuleExportTypes.add(sym);
      }
 else {
        types.add(sym);
      }
    }
  }
  Collections.sort(types,getNaturalSymbolOrdering().reverse());
  Collections.sort(googModuleExportTypes,getNaturalSymbolOrdering().reverse());
  for (  Symbol s : Iterables.concat(googModuleExportTypes,types)) {
    createPropertyScopeFor(s);
  }
  pruneOrphanedNames();
}","@SuppressWarnings(""String_Node_Str"") void fillPropertyScopes(){
  List<Symbol> types=new ArrayList<>();
  List<Symbol> googModuleExportTypes=new ArrayList<>();
  for (  Symbol sym : getAllSymbols()) {
    if (needsPropertyScope(sym)) {
      if (sym.getName().startsWith(""String_Node_Str"")) {
        googModuleExportTypes.add(sym);
      }
 else {
        types.add(sym);
      }
    }
  }
  Collections.sort(types,getNaturalSymbolOrdering().reverse());
  Collections.sort(googModuleExportTypes,getNaturalSymbolOrdering().reverse());
  Iterable<Symbol> allTypes=Iterables.concat(googModuleExportTypes,types);
  Map<JSType,Symbol> symbolThatDeclaresType=new IdentityHashMap<>();
  for (  Symbol s : allTypes) {
    symbolThatDeclaresType.put(s.getType(),s);
  }
  for (  Symbol s : allTypes) {
    if (s.getType() == null || symbolThatDeclaresType.get(s.getType()).equals(s)) {
      createPropertyScopeFor(s);
    }
  }
  for (  Symbol s : allTypes) {
    if (s.getType() != null) {
      s.propertyScope=symbolThatDeclaresType.get(s.getType()).getPropertyScope();
    }
  }
  pruneOrphanedNames();
}",0.7025462962962963
27249,"private void removeSymbol(Symbol s){
  SymbolScope scope=getScope(s);
  if (scope.ownSymbols.remove(s.getName()) != s) {
    throw new IllegalStateException(""String_Node_Str"" + s);
  }
  if (symbols.remove(s.getDeclaration().getNode(),s.getName()) != s) {
    throw new IllegalStateException(""String_Node_Str"" + s);
  }
}","private void removeSymbol(Symbol s){
  SymbolScope scope=getScope(s);
  if (!scope.ownSymbols.remove(s.getName()).equals(s)) {
    throw new IllegalStateException(""String_Node_Str"" + s);
  }
  if (!symbols.remove(s.getDeclaration().getNode(),s.getName()).equals(s)) {
    throw new IllegalStateException(""String_Node_Str"" + s);
  }
}",0.8440366972477065
27250,"/** 
 * Build a property scope for the given symbol. Any properties of the symbol will be added to the property scope. It is important that property scopes are created in order from the leaves up to the root, so this should only be called from #fillPropertyScopes. If you try to create a property scope for a parent before its leaf, then the leaf will get cut and re-added to the parent property scope, and weird things will happen.
 */
private void createPropertyScopeFor(Symbol s){
  if (s.propertyScope != null) {
    return;
  }
  SymbolScope parentPropertyScope=null;
  ObjectType type=getType(s) == null ? null : getType(s).toObjectType();
  if (type == null) {
    return;
  }
  ObjectType proto=type.getParentScope();
  if (proto != null && proto != type && proto.getConstructor() != null) {
    Symbol parentSymbol=getSymbolForInstancesOf(proto.getConstructor());
    if (parentSymbol != null) {
      createPropertyScopeFor(parentSymbol);
      parentPropertyScope=parentSymbol.getPropertyScope();
    }
  }
  ObjectType instanceType=type;
  Iterable<String> propNames=type.getOwnPropertyNames();
  if (instanceType.isFunctionPrototypeType()) {
    if (instanceType.getOwnerFunction().hasInstanceType()) {
      instanceType=instanceType.getOwnerFunction().getInstanceType();
      propNames=Iterables.concat(propNames,instanceType.getOwnPropertyNames());
    }
  }
  s.setPropertyScope(new SymbolScope(null,parentPropertyScope,type,s));
  for (  String propName : propNames) {
    StaticSlot newProp=instanceType.getSlot(propName);
    if (newProp.getDeclaration() == null) {
      continue;
    }
    Symbol oldProp=symbols.get(newProp.getDeclaration().getNode(),s.getName() + ""String_Node_Str"" + propName);
    if (oldProp != null) {
      removeSymbol(oldProp);
    }
    if (symbols.get(newProp.getDeclaration().getNode(),newProp.getName()) != null) {
      if (logger.isLoggable(Level.FINE)) {
        logger.fine(""String_Node_Str"" + newProp);
      }
      continue;
    }
    Symbol newSym=copySymbolTo(newProp,s.propertyScope);
    if (oldProp != null) {
      if (newSym.getJSDocInfo() == null) {
        newSym.setJSDocInfo(oldProp.getJSDocInfo());
      }
      newSym.setPropertyScope(oldProp.propertyScope);
      for (      Reference ref : oldProp.references.values()) {
        newSym.defineReferenceAt(ref.getNode());
      }
    }
  }
}","/** 
 * Build a property scope for the given symbol. Any properties of the symbol will be added to the property scope. <p>It is important that property scopes are created in order from the leaves up to the root, so this should only be called from #fillPropertyScopes. If you try to create a property scope for a parent before its leaf, then the leaf will get cut and re-added to the parent property scope, and weird things will happen.
 */
@SuppressWarnings(""String_Node_Str"") private void createPropertyScopeFor(Symbol s){
  if (s.propertyScope != null) {
    return;
  }
  SymbolScope parentPropertyScope=null;
  ObjectType type=getType(s) == null ? null : getType(s).toObjectType();
  if (type == null) {
    return;
  }
  ObjectType proto=type.getParentScope();
  if (proto != null && proto != type && proto.getConstructor() != null) {
    Symbol parentSymbol=getSymbolForInstancesOf(proto.getConstructor());
    if (parentSymbol != null) {
      createPropertyScopeFor(parentSymbol);
      parentPropertyScope=parentSymbol.getPropertyScope();
    }
  }
  ObjectType instanceType=type;
  Iterable<String> propNames=type.getOwnPropertyNames();
  if (instanceType.isFunctionPrototypeType()) {
    if (instanceType.getOwnerFunction().hasInstanceType()) {
      instanceType=instanceType.getOwnerFunction().getInstanceType();
      propNames=Iterables.concat(propNames,instanceType.getOwnPropertyNames());
    }
  }
  s.setPropertyScope(new SymbolScope(null,parentPropertyScope,type,s));
  for (  String propName : propNames) {
    StaticSlot newProp=instanceType.getSlot(propName);
    if (newProp.getDeclaration() == null) {
      continue;
    }
    Symbol oldProp=symbols.get(newProp.getDeclaration().getNode(),s.getName() + ""String_Node_Str"" + propName);
    if (oldProp != null) {
      removeSymbol(oldProp);
    }
    if (symbols.get(newProp.getDeclaration().getNode(),newProp.getName()) != null) {
      if (logger.isLoggable(Level.FINE)) {
        logger.fine(""String_Node_Str"" + newProp);
      }
      continue;
    }
    Symbol newSym=copySymbolTo(newProp,s.propertyScope);
    if (oldProp != null) {
      if (newSym.getJSDocInfo() == null) {
        newSym.setJSDocInfo(oldProp.getJSDocInfo());
      }
      newSym.setPropertyScope(oldProp.propertyScope);
      for (      Reference ref : oldProp.references.values()) {
        newSym.defineReferenceAt(ref.getNode());
      }
    }
  }
}",0.9916107382550337
27251,"private boolean isSubtypeOfHelper(boolean keepLoosenessOfThis,JSType other,SubtypeCache subSuperMap,MismatchInfo[] boxedInfo){
  if (isUnknown() || other.isUnknown() || other.isTop()) {
    return true;
  }
  if (isTheTruthyType()) {
    return !other.makeTruthy().isBottom();
  }
  if (isTheFalsyType()) {
    return !other.makeFalsy().isBottom();
  }
  if (!EnumType.areSubtypes(this,other,subSuperMap)) {
    return false;
  }
  int mask=getMask() & ~ENUM_MASK;
  if ((mask | other.getMask()) != other.getMask()) {
    if (boxedInfo != null && isUnion()) {
      whyNotUnionSubtypes(this,other,boxedInfo);
    }
    return false;
  }
  if (getTypeVar() != null && !getTypeVar().equals(other.getTypeVar())) {
    return false;
  }
  if (getObjs().isEmpty()) {
    return true;
  }
  boolean result=ObjectType.isUnionSubtype(keepLoosenessOfThis,getObjs(),other.getObjs(),subSuperMap);
  if (boxedInfo != null) {
    ObjectType.whyNotUnionSubtypes(keepLoosenessOfThis,getObjs(),other.getObjs(),subSuperMap,boxedInfo);
  }
  return result;
}","private boolean isSubtypeOfHelper(boolean keepLoosenessOfThis,JSType other,SubtypeCache subSuperMap,MismatchInfo[] boxedInfo){
  if (isUnknown() || other.isUnknown() || other.isTop()) {
    return true;
  }
  if (isTheTruthyType()) {
    return !other.makeTruthy().isBottom();
  }
  if (isTheFalsyType()) {
    return !other.makeFalsy().isBottom();
  }
  if (other.isTheTruthyType()) {
    return isAnyTruthyType();
  }
  if (!EnumType.areSubtypes(this,other,subSuperMap)) {
    return false;
  }
  int mask=getMask() & ~ENUM_MASK;
  if ((mask | other.getMask()) != other.getMask()) {
    if (boxedInfo != null && isUnion()) {
      whyNotUnionSubtypes(this,other,boxedInfo);
    }
    return false;
  }
  if (getTypeVar() != null && !getTypeVar().equals(other.getTypeVar())) {
    return false;
  }
  if (getObjs().isEmpty()) {
    return true;
  }
  boolean result=ObjectType.isUnionSubtype(keepLoosenessOfThis,getObjs(),other.getObjs(),subSuperMap);
  if (boxedInfo != null) {
    ObjectType.whyNotUnionSubtypes(keepLoosenessOfThis,getObjs(),other.getObjs(),subSuperMap,boxedInfo);
  }
  return result;
}",0.9687936655798788
27252,"public void testAsserts(){
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.ASSERT_FALSE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.UNKNOWN_ASSERTION_TYPE);
  typeCheck(""String_Node_Str"");
}","public void testAsserts(){
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.ASSERT_FALSE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.UNKNOWN_ASSERTION_TYPE);
  typeCheck(""String_Node_Str"");
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
}",0.9146131805157592
27253,"public void testExports(){
  CompilerOptions options=createCompilerOptions();
  CompilationLevel level=CompilationLevel.ADVANCED_OPTIMIZATIONS;
  level.setOptionsForCompilationLevel(options);
  WarningLevel warnings=WarningLevel.DEFAULT;
  warnings.setOptionsForWarningLevel(options);
  options.setRemoveUnusedPrototypePropertiesInExterns(true);
  String code=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  test(options,code,""String_Node_Str"" + ""String_Node_Str"");
  options.setGenerateExports(true);
  test(options,""String_Node_Str"" + ""String_Node_Str"",FindExportableNodes.NON_GLOBAL_ERROR);
  options.exportLocalPropertyDefinitions=true;
  options.setRemoveUnusedPrototypePropertiesInExterns(false);
  test(options,code,""String_Node_Str"" + ""String_Node_Str"");
  test(options,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
  options.setCheckTypes(true);
  options.setDisambiguateProperties(true);
  options.setAmbiguateProperties(true);
  options.propertyInvalidationErrors=ImmutableMap.of(""String_Node_Str"",CheckLevel.ERROR);
  test(options,code,""String_Node_Str"" + ""String_Node_Str"");
  test(options,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"");
}","public void testExports(){
  CompilerOptions options=createCompilerOptions();
  CompilationLevel level=CompilationLevel.ADVANCED_OPTIMIZATIONS;
  level.setOptionsForCompilationLevel(options);
  WarningLevel warnings=WarningLevel.DEFAULT;
  warnings.setOptionsForWarningLevel(options);
  options.setRemoveUnusedPrototypePropertiesInExterns(true);
  String code=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  test(options,code,""String_Node_Str"" + ""String_Node_Str"");
  options.setGenerateExports(true);
  test(options,""String_Node_Str"" + ""String_Node_Str"",FindExportableNodes.NON_GLOBAL_ERROR);
  options.exportLocalPropertyDefinitions=true;
  options.setRemoveUnusedPrototypePropertiesInExterns(false);
  test(options,code,""String_Node_Str"");
  test(options,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  options.setCheckTypes(true);
  options.setDisambiguateProperties(true);
  options.setAmbiguateProperties(true);
  options.propertyInvalidationErrors=ImmutableMap.of(""String_Node_Str"",CheckLevel.ERROR);
  test(options,code,""String_Node_Str"");
  test(options,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"");
}",0.8377331925378388
27254,"public void testIssue724(){
  CompilerOptions options=createCompilerOptions();
  CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
  options.setCheckSymbols(false);
  options.setCheckTypes(false);
  String code=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String result=""String_Node_Str"" + ""String_Node_Str"";
  test(options,code,result);
}","public void testIssue724(){
  CompilerOptions options=createCompilerOptions();
  CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
  options.setCheckSymbols(false);
  options.setCheckTypes(false);
  String code=LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  String result=""String_Node_Str"";
  test(options,code,result);
}",0.7187864644107351
27255,"private EnvTypePair analyzeLooseCallNodeBwd(Node callNode,TypeEnv outEnv,JSType retType){
  Preconditions.checkArgument(callNode.isCall() || callNode.isNew());
  Preconditions.checkNotNull(retType);
  Node callee=callNode.getFirstChild();
  TypeEnv tmpEnv=outEnv;
  FunctionTypeBuilder builder=new FunctionTypeBuilder(this.commonTypes);
  for (Node arg=callee.getNext(); arg != null; arg=arg.getNext()) {
    EnvTypePair pair=analyzeExprBwd(arg,tmpEnv);
    JSType argType=pair.type;
    tmpEnv=pair.env;
    builder.addReqFormal(isImpreciseType(argType) ? BOTTOM : argType);
  }
  JSType looseRetType=retType.isUnknown() ? BOTTOM : retType;
  JSType looseFunctionType=commonTypes.fromFunctionType(builder.addRetType(looseRetType).addLoose().buildFunction());
  println(""String_Node_Str"",looseFunctionType);
  EnvTypePair calleePair=analyzeExprBwd(callee,tmpEnv,looseFunctionType);
  return new EnvTypePair(calleePair.env,retType);
}","private EnvTypePair analyzeLooseCallNodeBwd(Node callNode,TypeEnv outEnv,JSType retType){
  Preconditions.checkArgument(callNode.isCall() || callNode.isNew());
  Preconditions.checkNotNull(retType);
  Node callee=callNode.getFirstChild();
  TypeEnv tmpEnv=outEnv;
  FunctionTypeBuilder builder=new FunctionTypeBuilder(this.commonTypes);
  Node target=callNode.getFirstChild();
  for (Node arg=callNode.getLastChild(); arg != target; arg=arg.getPrevious()) {
    EnvTypePair pair=analyzeExprBwd(arg,tmpEnv);
    JSType argType=pair.type;
    tmpEnv=pair.env;
    builder.addReqFormalToFront(isImpreciseType(argType) ? BOTTOM : argType);
  }
  JSType looseRetType=retType.isUnknown() ? BOTTOM : retType;
  JSType looseFunctionType=commonTypes.fromFunctionType(builder.addRetType(looseRetType).addLoose().buildFunction());
  println(""String_Node_Str"",looseFunctionType);
  EnvTypePair calleePair=analyzeExprBwd(callee,tmpEnv,looseFunctionType);
  return new EnvTypePair(calleePair.env,retType);
}",0.936656282450675
27256,"public void testBackwardAnalyzedLooseFunctionParametersInRightOrder(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testBackwardAnalyzedLooseFunctionParametersInRightOrder(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.901818181818182
27257,"private EnvTypePair analyzeThisFwd(Node expr,TypeEnv inEnv,JSType requiredType,JSType specializedType){
  mayWarnAboutGlobalThis(expr,currentScope);
  if (!this.currentScope.hasThis()) {
    return new EnvTypePair(inEnv,UNKNOWN);
  }
  JSType inferredType=envGetType(inEnv,THIS_ID);
  if (!inferredType.isSubtypeOf(requiredType)) {
    return new EnvTypePair(inEnv,inferredType);
  }
  JSType preciseType=inferredType.specialize(specializedType);
  if (preciseType.isBottom()) {
    preciseType=pickFallbackTypeAfterBottom(THIS_ID,inferredType,specializedType);
  }
  return EnvTypePair.addBinding(inEnv,THIS_ID,preciseType);
}","private EnvTypePair analyzeThisFwd(Node expr,TypeEnv inEnv,JSType requiredType,JSType specializedType){
  mayWarnAboutGlobalThis(expr);
  if (!this.currentScope.hasThis()) {
    return new EnvTypePair(inEnv,UNKNOWN);
  }
  JSType inferredType=envGetType(inEnv,THIS_ID);
  if (!inferredType.isSubtypeOf(requiredType)) {
    return new EnvTypePair(inEnv,inferredType);
  }
  JSType preciseType=inferredType.specialize(specializedType);
  if (preciseType.isBottom()) {
    preciseType=pickFallbackTypeAfterBottom(THIS_ID,inferredType,specializedType);
  }
  return EnvTypePair.addBinding(inEnv,THIS_ID,preciseType);
}",0.9895245769540691
27258,"private EnvTypePair analyzeFunctionBindFwd(Node call,TypeEnv inEnv){
  Preconditions.checkArgument(call.isCall());
  Bind bindComponents=this.convention.describeFunctionBind(call,true,false);
  Node boundFunNode=bindComponents.target;
  EnvTypePair pair=analyzeExprFwd(boundFunNode,inEnv);
  TypeEnv env=pair.env;
  FunctionType boundFunType=pair.type.getFunTypeIfSingletonObj();
  if (!pair.type.isSubtypeOf(commonTypes.topFunction())) {
    warnings.add(JSError.make(boundFunNode,GOOG_BIND_EXPECTS_FUNCTION,pair.type.toString()));
  }
  if (boundFunType == null || boundFunType.isTopFunction() || boundFunType.isQmarkFunction() || boundFunType.isLoose()) {
    return analyzeCallNodeArgsFwdWhenError(call,env);
  }
  if (boundFunType.isSomeConstructorOrInterface()) {
    warnings.add(JSError.make(call,CANNOT_BIND_CTOR));
    return new EnvTypePair(env,UNKNOWN);
  }
  int callChildCount=call.getChildCount();
  if (NodeUtil.isGoogBind(call.getFirstChild()) && callChildCount <= 2 || !NodeUtil.isGoogPartial(call.getFirstChild()) && callChildCount == 1) {
    warnings.add(JSError.make(call,WRONG_ARGUMENT_COUNT,getReadableCalleeName(call.getFirstChild()),""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  int maxArity=boundFunType.hasRestFormals() ? Integer.MAX_VALUE : boundFunType.getMaxArity();
  int numArgs=bindComponents.getBoundParameterCount();
  if (numArgs > maxArity) {
    warnings.add(JSError.make(call,WRONG_ARGUMENT_COUNT,getReadableCalleeName(call.getFirstChild()),Integer.toString(numArgs),""String_Node_Str"",""String_Node_Str"" + maxArity));
    return analyzeCallNodeArgsFwdWhenError(call,inEnv);
  }
  Node receiver=bindComponents.thisValue;
  if (boundFunType.isGeneric()) {
    Map<String,JSType> typeMap=calcTypeInstantiationFwd(call,receiver,bindComponents.parameters,boundFunType,env);
    boundFunType=boundFunType.instantiateGenerics(typeMap);
  }
  FunctionTypeBuilder builder=new FunctionTypeBuilder(this.commonTypes);
  if (receiver != null) {
    JSType reqThisType=boundFunType.getThisType();
    if (reqThisType == null || boundFunType.isSomeConstructorOrInterface()) {
      reqThisType=JSType.join(NULL,TOP_OBJECT);
    }
    pair=analyzeExprFwd(receiver,env,reqThisType);
    env=pair.env;
    if (!pair.type.isSubtypeOf(reqThisType)) {
      warnings.add(JSError.make(call,INVALID_THIS_TYPE_IN_BIND,errorMsgWithTypeDiff(reqThisType,pair.type)));
    }
  }
  env=analyzeCallNodeArgumentsFwd(call,bindComponents.parameters,boundFunType,new ArrayList<JSType>(),env);
  for (int j=numArgs; j < boundFunType.getMaxArityWithoutRestFormals(); j++) {
    JSType formalType=boundFunType.getFormalType(j);
    if (boundFunType.isRequiredArg(j)) {
      builder.addReqFormal(formalType);
    }
 else {
      builder.addOptFormal(formalType);
    }
  }
  if (boundFunType.hasRestFormals()) {
    builder.addRestFormals(boundFunType.getRestFormalsType());
  }
  return new EnvTypePair(env,commonTypes.fromFunctionType(builder.addRetType(boundFunType.getReturnType()).buildFunction()));
}","private EnvTypePair analyzeFunctionBindFwd(Node call,TypeEnv inEnv){
  Preconditions.checkArgument(call.isCall());
  Bind bindComponents=this.convention.describeFunctionBind(call,true,false);
  Node boundFunNode=bindComponents.target;
  EnvTypePair pair=analyzeExprFwd(boundFunNode,inEnv);
  TypeEnv env=pair.env;
  FunctionType boundFunType=pair.type.getFunTypeIfSingletonObj();
  if (!pair.type.isSubtypeOf(commonTypes.topFunction())) {
    warnings.add(JSError.make(boundFunNode,GOOG_BIND_EXPECTS_FUNCTION,pair.type.toString()));
  }
  if (boundFunType == null || boundFunType.isTopFunction() || boundFunType.isQmarkFunction() || boundFunType.isLoose()) {
    return analyzeCallNodeArgsFwdWhenError(call,env);
  }
  if (boundFunType.isSomeConstructorOrInterface()) {
    warnings.add(JSError.make(call,CANNOT_BIND_CTOR));
    return new EnvTypePair(env,UNKNOWN);
  }
  int callChildCount=call.getChildCount();
  if ((NodeUtil.isGoogBind(call.getFirstChild()) && callChildCount <= 2) || (!NodeUtil.isGoogPartial(call.getFirstChild()) && callChildCount == 1)) {
    warnings.add(JSError.make(call,WRONG_ARGUMENT_COUNT,getReadableCalleeName(call.getFirstChild()),""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  int maxArity=boundFunType.hasRestFormals() ? Integer.MAX_VALUE : boundFunType.getMaxArity();
  int numArgs=bindComponents.getBoundParameterCount();
  if (numArgs > maxArity) {
    warnings.add(JSError.make(call,WRONG_ARGUMENT_COUNT,getReadableCalleeName(call.getFirstChild()),Integer.toString(numArgs),""String_Node_Str"",""String_Node_Str"" + maxArity));
    return analyzeCallNodeArgsFwdWhenError(call,inEnv);
  }
  Node receiver=bindComponents.thisValue;
  if (boundFunType.isGeneric()) {
    Map<String,JSType> typeMap=calcTypeInstantiationFwd(call,receiver,bindComponents.parameters,boundFunType,env);
    boundFunType=boundFunType.instantiateGenerics(typeMap);
  }
  FunctionTypeBuilder builder=new FunctionTypeBuilder(this.commonTypes);
  if (receiver != null) {
    JSType reqThisType=boundFunType.getThisType();
    if (reqThisType == null || boundFunType.isSomeConstructorOrInterface()) {
      reqThisType=JSType.join(NULL,TOP_OBJECT);
    }
    pair=analyzeExprFwd(receiver,env,reqThisType);
    env=pair.env;
    if (!pair.type.isSubtypeOf(reqThisType)) {
      warnings.add(JSError.make(call,INVALID_THIS_TYPE_IN_BIND,errorMsgWithTypeDiff(reqThisType,pair.type)));
    }
  }
  env=analyzeCallNodeArgumentsFwd(call,bindComponents.parameters,boundFunType,new ArrayList<JSType>(),env);
  for (int j=numArgs; j < boundFunType.getMaxArityWithoutRestFormals(); j++) {
    JSType formalType=boundFunType.getFormalType(j);
    if (boundFunType.isRequiredArg(j)) {
      builder.addReqFormal(formalType);
    }
 else {
      builder.addOptFormal(formalType);
    }
  }
  if (boundFunType.hasRestFormals()) {
    builder.addRestFormals(boundFunType.getRestFormalsType());
  }
  return new EnvTypePair(env,commonTypes.fromFunctionType(builder.addRetType(boundFunType.getReturnType()).buildFunction()));
}",0.9993392798149984
27259,"private EnvTypePair analyzeIncDecFwd(Node expr,TypeEnv inEnv,JSType requiredType){
  mayWarnAboutConst(expr);
  Node ch=expr.getFirstChild();
  if (ch.isGetProp() || ch.isGetElem() && ch.getLastChild().isString()) {
    Node recv=ch.getFirstChild();
    String pname=ch.getLastChild().getString();
    EnvTypePair pair=analyzeExprFwd(recv,inEnv);
    JSType recvType=pair.type;
    if (mayWarnAboutConstProp(ch,recvType,new QualifiedName(pname))) {
      pair.type=requiredType;
      return pair;
    }
  }
  return analyzeUnaryNumFwd(expr,inEnv);
}","private EnvTypePair analyzeIncDecFwd(Node expr,TypeEnv inEnv,JSType requiredType){
  mayWarnAboutConst(expr);
  Node ch=expr.getFirstChild();
  if (ch.isGetProp() || (ch.isGetElem() && ch.getLastChild().isString())) {
    Node recv=ch.getFirstChild();
    String pname=ch.getLastChild().getString();
    EnvTypePair pair=analyzeExprFwd(recv,inEnv);
    JSType recvType=pair.type;
    if (mayWarnAboutConstProp(ch,recvType,new QualifiedName(pname))) {
      pair.type=requiredType;
      return pair;
    }
  }
  return analyzeUnaryNumFwd(expr,inEnv);
}",0.998185117967332
27260,"private EnvTypePair analyzeNonStrictComparisonFwd(Node expr,TypeEnv inEnv,JSType specializedType){
  Token tokenType=expr.getToken();
  Node lhs=expr.getFirstChild();
  Node rhs=expr.getLastChild();
  if (specializedType.isTrueOrTruthy() || specializedType.isFalseOrFalsy()) {
    if (lhs.isTypeOf()) {
      return analyzeSpecializedTypeof(lhs,rhs,tokenType,inEnv,specializedType);
    }
 else     if (rhs.isTypeOf()) {
      return analyzeSpecializedTypeof(rhs,lhs,tokenType,inEnv,specializedType);
    }
 else     if (isGoogTypeof(lhs)) {
      return analyzeGoogTypeof(lhs,rhs,inEnv,specializedType);
    }
 else     if (isGoogTypeof(rhs)) {
      return analyzeGoogTypeof(rhs,lhs,inEnv,specializedType);
    }
  }
  EnvTypePair lhsPair=analyzeExprFwd(lhs,inEnv);
  EnvTypePair rhsPair=analyzeExprFwd(rhs,lhsPair.env);
  TypeEnv preciseEnv=rhsPair.env;
  JSType lhsType=lhsPair.type;
  JSType rhsType=rhsPair.type;
  if (tokenType == Token.EQ && specializedType.isTrueOrTruthy() || tokenType == Token.NE && specializedType.isFalseOrFalsy()) {
    if (lhsType.isNullOrUndef()) {
      rhsPair=analyzeExprFwd(rhs,preciseEnv,UNKNOWN,NULL_OR_UNDEFINED);
    }
 else     if (rhsType.isNullOrUndef()) {
      lhsPair=analyzeExprFwd(lhs,preciseEnv,UNKNOWN,NULL_OR_UNDEFINED);
      rhsPair=analyzeExprFwd(rhs,lhsPair.env);
    }
 else     if (!NULL.isSubtypeOf(lhsType) && !UNDEFINED.isSubtypeOf(lhsType)) {
      rhsType=rhsType.removeType(NULL_OR_UNDEFINED);
      rhsPair=analyzeExprFwd(rhs,preciseEnv,UNKNOWN,rhsType);
    }
 else     if (!NULL.isSubtypeOf(rhsType) && !UNDEFINED.isSubtypeOf(rhsType)) {
      lhsType=lhsType.removeType(NULL_OR_UNDEFINED);
      lhsPair=analyzeExprFwd(lhs,preciseEnv,UNKNOWN,lhsType);
      rhsPair=analyzeExprFwd(rhs,lhsPair.env);
    }
  }
 else   if (tokenType == Token.EQ && specializedType.isFalseOrFalsy() || tokenType == Token.NE && specializedType.isTrueOrTruthy()) {
    if (lhsType.isNullOrUndef()) {
      rhsType=rhsType.removeType(NULL_OR_UNDEFINED);
      rhsPair=analyzeExprFwd(rhs,preciseEnv,UNKNOWN,rhsType);
    }
 else     if (rhsType.isNullOrUndef()) {
      lhsType=lhsType.removeType(NULL_OR_UNDEFINED);
      lhsPair=analyzeExprFwd(lhs,preciseEnv,UNKNOWN,lhsType);
      rhsPair=analyzeExprFwd(rhs,lhsPair.env);
    }
  }
  rhsPair.type=BOOLEAN;
  return rhsPair;
}","private EnvTypePair analyzeNonStrictComparisonFwd(Node expr,TypeEnv inEnv,JSType specializedType){
  Token tokenType=expr.getToken();
  Node lhs=expr.getFirstChild();
  Node rhs=expr.getLastChild();
  if (specializedType.isTrueOrTruthy() || specializedType.isFalseOrFalsy()) {
    if (lhs.isTypeOf()) {
      return analyzeSpecializedTypeof(lhs,rhs,tokenType,inEnv,specializedType);
    }
 else     if (rhs.isTypeOf()) {
      return analyzeSpecializedTypeof(rhs,lhs,tokenType,inEnv,specializedType);
    }
 else     if (isGoogTypeof(lhs)) {
      return analyzeGoogTypeof(lhs,rhs,inEnv,specializedType);
    }
 else     if (isGoogTypeof(rhs)) {
      return analyzeGoogTypeof(rhs,lhs,inEnv,specializedType);
    }
  }
  EnvTypePair lhsPair=analyzeExprFwd(lhs,inEnv);
  EnvTypePair rhsPair=analyzeExprFwd(rhs,lhsPair.env);
  TypeEnv preciseEnv=rhsPair.env;
  JSType lhsType=lhsPair.type;
  JSType rhsType=rhsPair.type;
  if ((tokenType == Token.EQ && specializedType.isTrueOrTruthy()) || (tokenType == Token.NE && specializedType.isFalseOrFalsy())) {
    if (lhsType.isNullOrUndef()) {
      rhsPair=analyzeExprFwd(rhs,preciseEnv,UNKNOWN,NULL_OR_UNDEFINED);
    }
 else     if (rhsType.isNullOrUndef()) {
      lhsPair=analyzeExprFwd(lhs,preciseEnv,UNKNOWN,NULL_OR_UNDEFINED);
      rhsPair=analyzeExprFwd(rhs,lhsPair.env);
    }
 else     if (!NULL.isSubtypeOf(lhsType) && !UNDEFINED.isSubtypeOf(lhsType)) {
      rhsType=rhsType.removeType(NULL_OR_UNDEFINED);
      rhsPair=analyzeExprFwd(rhs,preciseEnv,UNKNOWN,rhsType);
    }
 else     if (!NULL.isSubtypeOf(rhsType) && !UNDEFINED.isSubtypeOf(rhsType)) {
      lhsType=lhsType.removeType(NULL_OR_UNDEFINED);
      lhsPair=analyzeExprFwd(lhs,preciseEnv,UNKNOWN,lhsType);
      rhsPair=analyzeExprFwd(rhs,lhsPair.env);
    }
  }
 else   if ((tokenType == Token.EQ && specializedType.isFalseOrFalsy()) || (tokenType == Token.NE && specializedType.isTrueOrTruthy())) {
    if (lhsType.isNullOrUndef()) {
      rhsType=rhsType.removeType(NULL_OR_UNDEFINED);
      rhsPair=analyzeExprFwd(rhs,preciseEnv,UNKNOWN,rhsType);
    }
 else     if (rhsType.isNullOrUndef()) {
      lhsType=lhsType.removeType(NULL_OR_UNDEFINED);
      lhsPair=analyzeExprFwd(lhs,preciseEnv,UNKNOWN,lhsType);
      rhsPair=analyzeExprFwd(rhs,lhsPair.env);
    }
  }
  rhsPair.type=BOOLEAN;
  return rhsPair;
}",0.998281048560378
27261,"private EnvTypePair analyzeInstanceofFwd(Node expr,TypeEnv inEnv,JSType specializedType){
  Node obj=expr.getFirstChild();
  Node ctor=expr.getLastChild();
  EnvTypePair objPair, ctorPair;
  objPair=analyzeExprFwd(obj,inEnv);
  JSType objType=objPair.type;
  if (!objType.isTop() && !objType.isUnknown() && !objType.isTrueOrTruthy()&& !objType.hasNonScalar()&& !objType.hasTypeVariable()) {
    warnInvalidOperand(obj,Token.INSTANCEOF,""String_Node_Str"",objPair.type);
  }
  ctorPair=analyzeExprFwd(ctor,objPair.env,commonTypes.topFunction());
  JSType ctorType=ctorPair.type;
  FunctionType ctorFunType=ctorType.getFunType();
  boolean mayBeConstructorFunction=ctorFunType != null && (ctorFunType.isLoose() || ctorFunType.isQmarkFunction() || ctorFunType.isSomeConstructorOrInterface());
  if (!(ctorType.isUnknown() || mayBeConstructorFunction)) {
    warnInvalidOperand(ctor,Token.INSTANCEOF,""String_Node_Str"",ctorType);
  }
  if (ctorFunType == null || !ctorFunType.isUniqueConstructor() || (!specializedType.isTrueOrTruthy() && !specializedType.isFalseOrFalsy())) {
    ctorPair.type=BOOLEAN;
    return ctorPair;
  }
  JSType instanceType=ctorFunType.getInstanceTypeOfCtor();
  JSType instanceSpecType;
  if (specializedType.isTrueOrTruthy()) {
    instanceSpecType=objType.specialize(instanceType);
  }
 else   if (objType.isTop()) {
    instanceSpecType=objType;
  }
 else {
    instanceSpecType=objType.removeType(instanceType);
  }
  if (!instanceSpecType.isBottom()) {
    objPair=analyzeExprFwd(obj,inEnv,UNKNOWN,instanceSpecType);
    ctorPair=analyzeExprFwd(ctor,objPair.env,commonTypes.topFunction());
  }
  ctorPair.type=BOOLEAN;
  return ctorPair;
}","private EnvTypePair analyzeInstanceofFwd(Node expr,TypeEnv inEnv,JSType specializedType){
  Node obj=expr.getFirstChild();
  Node ctor=expr.getLastChild();
  EnvTypePair objPair;
  EnvTypePair ctorPair;
  objPair=analyzeExprFwd(obj,inEnv);
  JSType objType=objPair.type;
  if (!objType.isTop() && !objType.isUnknown() && !objType.isTrueOrTruthy()&& !objType.hasNonScalar()&& !objType.hasTypeVariable()) {
    warnInvalidOperand(obj,Token.INSTANCEOF,""String_Node_Str"",objPair.type);
  }
  ctorPair=analyzeExprFwd(ctor,objPair.env,commonTypes.topFunction());
  JSType ctorType=ctorPair.type;
  FunctionType ctorFunType=ctorType.getFunType();
  boolean mayBeConstructorFunction=ctorFunType != null && (ctorFunType.isLoose() || ctorFunType.isQmarkFunction() || ctorFunType.isSomeConstructorOrInterface());
  if (!(ctorType.isUnknown() || mayBeConstructorFunction)) {
    warnInvalidOperand(ctor,Token.INSTANCEOF,""String_Node_Str"",ctorType);
  }
  if (ctorFunType == null || !ctorFunType.isUniqueConstructor() || (!specializedType.isTrueOrTruthy() && !specializedType.isFalseOrFalsy())) {
    ctorPair.type=BOOLEAN;
    return ctorPair;
  }
  JSType instanceType=ctorFunType.getInstanceTypeOfCtor();
  JSType instanceSpecType;
  if (specializedType.isTrueOrTruthy()) {
    instanceSpecType=objType.specialize(instanceType);
  }
 else   if (objType.isTop()) {
    instanceSpecType=objType;
  }
 else {
    instanceSpecType=objType.removeType(instanceType);
  }
  if (!instanceSpecType.isBottom()) {
    objPair=analyzeExprFwd(obj,inEnv,UNKNOWN,instanceSpecType);
    ctorPair=analyzeExprFwd(ctor,objPair.env,commonTypes.topFunction());
  }
  ctorPair.type=BOOLEAN;
  return ctorPair;
}",0.9952153110047848
27262,"private boolean mayWarnAboutInexistentProp(Node propAccessNode,JSType recvType,QualifiedName propQname){
  Preconditions.checkState(propAccessNode.isGetProp() || propAccessNode.isGetElem());
  String pname=propQname.toString();
  if (propAccessNode.isGetElem() || !recvType.isLoose() && recvType.hasProp(propQname)) {
    return false;
  }
  if (recvType.isUnknown() || recvType.isTrueOrTruthy() || recvType.isLoose()|| (allowPropertyOnSubtypes && (recvType.mayContainUnknownObject() || recvType.isIObject()))) {
    if (symbolTable.isPropertyDefined(pname)) {
      return false;
    }
    warnings.add(JSError.make(propAccessNode,INEXISTENT_PROPERTY,pname,""String_Node_Str""));
    return true;
  }
  if (allowPropertyOnSubtypes && !recvType.isStruct() && recvType.isPropDefinedOnSubtype(propQname)) {
    return false;
  }
  String recvTypeAsString=recvType.toString();
  Node recv=propAccessNode.getFirstChild();
  String errorMsg;
  if (!recv.isQualifiedName()) {
    errorMsg=recvTypeAsString;
  }
 else   if (recvTypeAsString.length() > 100) {
    errorMsg=recv.getQualifiedName();
  }
 else {
    errorMsg=recv.getQualifiedName() + ""String_Node_Str"" + recvTypeAsString;
  }
  DiagnosticType warningType=recvType.mayHaveProp(propQname) ? POSSIBLY_INEXISTENT_PROPERTY : INEXISTENT_PROPERTY;
  warnings.add(JSError.make(propAccessNode,warningType,pname,errorMsg));
  return true;
}","private boolean mayWarnAboutInexistentProp(Node propAccessNode,JSType recvType,QualifiedName propQname){
  Preconditions.checkState(propAccessNode.isGetProp() || propAccessNode.isGetElem());
  String pname=propQname.toString();
  if (propAccessNode.isGetElem() || (!recvType.isLoose() && recvType.hasProp(propQname))) {
    return false;
  }
  if (recvType.isUnknown() || recvType.isTrueOrTruthy() || recvType.isLoose()|| (allowPropertyOnSubtypes && (recvType.mayContainUnknownObject() || recvType.isIObject()))) {
    if (symbolTable.isPropertyDefined(pname)) {
      return false;
    }
    warnings.add(JSError.make(propAccessNode,INEXISTENT_PROPERTY,pname,""String_Node_Str""));
    return true;
  }
  if (allowPropertyOnSubtypes && !recvType.isStruct() && recvType.isPropDefinedOnSubtype(propQname)) {
    return false;
  }
  String recvTypeAsString=recvType.toString();
  Node recv=propAccessNode.getFirstChild();
  String errorMsg;
  if (!recv.isQualifiedName()) {
    errorMsg=recvTypeAsString;
  }
 else   if (recvTypeAsString.length() > 100) {
    errorMsg=recv.getQualifiedName();
  }
 else {
    errorMsg=recv.getQualifiedName() + ""String_Node_Str"" + recvTypeAsString;
  }
  DiagnosticType warningType=recvType.mayHaveProp(propQname) ? POSSIBLY_INEXISTENT_PROPERTY : INEXISTENT_PROPERTY;
  warnings.add(JSError.make(propAccessNode,warningType,pname,errorMsg));
  return true;
}",0.9992784992784992
27263,"private void mayWarnAboutGlobalThis(Node thisExpr,NTIScope currentScope){
  Preconditions.checkArgument(thisExpr.isThis());
  if (this.currentScope.isTopLevel() || !this.currentScope.hasThis()) {
    Node parent=thisExpr.getParent();
    if ((parent.isGetProp() || parent.isGetElem()) && !NodeUtil.isCallOrNewArgument(this.currentScope.getRoot())) {
      warnings.add(JSError.make(thisExpr,GLOBAL_THIS));
    }
  }
}","private void mayWarnAboutGlobalThis(Node thisExpr){
  Preconditions.checkArgument(thisExpr.isThis());
  if (this.currentScope.isTopLevel() || !this.currentScope.hasThis()) {
    Node parent=thisExpr.getParent();
    if ((parent.isGetProp() || parent.isGetElem()) && !NodeUtil.isCallOrNewArgument(this.currentScope.getRoot())) {
      warnings.add(JSError.make(thisExpr,GLOBAL_THIS));
    }
  }
}",0.9729064039408868
27264,"private void warnInvalidOperand(Node expr,Token operatorType,Object expected,Object actual){
  Preconditions.checkArgument((expected instanceof String) || (expected instanceof JSType));
  Preconditions.checkArgument((actual instanceof String) || (actual instanceof JSType));
  if (expected instanceof JSType && actual instanceof JSType) {
    warnings.add(JSError.make(expr,INVALID_OPERAND_TYPE,operatorType.toString(),errorMsgWithTypeDiff((JSType)expected,(JSType)actual)));
  }
 else {
    warnings.add(JSError.make(expr,INVALID_OPERAND_TYPE,operatorType.toString(),""String_Node_Str"" + expected.toString() + ""String_Node_Str""+ ""String_Node_Str""+ actual.toString()+ ""String_Node_Str""));
  }
}","private void warnInvalidOperand(Node expr,Token operatorType,Object expected,Object actual){
  Preconditions.checkArgument((expected instanceof String) || (expected instanceof JSType));
  Preconditions.checkArgument((actual instanceof String) || (actual instanceof JSType));
  if (expected instanceof JSType && actual instanceof JSType) {
    warnings.add(JSError.make(expr,INVALID_OPERAND_TYPE,operatorType.toString(),errorMsgWithTypeDiff((JSType)expected,(JSType)actual)));
  }
 else {
    warnings.add(JSError.make(expr,INVALID_OPERAND_TYPE,operatorType.toString(),""String_Node_Str"" + expected + ""String_Node_Str""+ ""String_Node_Str""+ actual+ ""String_Node_Str""));
  }
}",0.9838709677419356
27265,"private EnvTypePair analyzePropAccessFwd(Node receiver,String pname,TypeEnv inEnv,JSType requiredType,JSType specializedType){
  QualifiedName propQname=new QualifiedName(pname);
  Node propAccessNode=receiver.getParent();
  EnvTypePair pair;
  JSType reqObjType=pickReqObjType(propAccessNode);
  JSType recvReqType, recvSpecType;
  if ((NodeUtil.isPropertyTest(compiler,propAccessNode) && !specializedType.isFalseOrFalsy()) || (NodeUtil.isPropertyAbsenceTest(propAccessNode) && !specializedType.isTrueOrTruthy()) || specializedType.isTrueOrTruthy()) {
    recvReqType=reqObjType;
    pair=analyzeExprFwd(receiver,inEnv,recvReqType);
    JSType subtypeWithProp=pair.type.findSubtypeWithProp(propQname);
    if (subtypeWithProp.isBottom()) {
      recvSpecType=reqObjType;
    }
 else {
      recvSpecType=subtypeWithProp;
    }
    if (specializedType.isTrueOrTruthy()) {
      recvSpecType=recvSpecType.withLoose().withProperty(propQname,specializedType);
    }
 else {
      recvSpecType=recvSpecType.withProperty(propQname,specializedType);
    }
  }
 else   if (specializedType.isFalseOrFalsy()) {
    recvReqType=recvSpecType=reqObjType;
  }
 else {
    recvReqType=reqObjType.withProperty(propQname,requiredType);
    recvSpecType=reqObjType.withProperty(propQname,specializedType);
  }
  pair=analyzeExprFwd(receiver,inEnv,recvReqType,recvSpecType);
  pair=mayWarnAboutNullableReferenceAndTighten(receiver,pair.type,recvSpecType,pair.env);
  JSType recvType=pair.type.autobox();
  if (recvType.isUnknown() || recvType.isTrueOrTruthy()) {
    mayWarnAboutInexistentProp(propAccessNode,recvType,propQname);
    return new EnvTypePair(pair.env,requiredType);
  }
  if (mayWarnAboutNonObject(receiver,recvType,specializedType)) {
    return new EnvTypePair(pair.env,requiredType);
  }
  FunctionType ft=recvType.getFunTypeIfSingletonObj();
  if (ft != null && (pname.equals(""String_Node_Str"") || pname.equals(""String_Node_Str""))) {
    if (ft.isAbstract()) {
      String funName=receiver.isQualifiedName() ? receiver.getQualifiedName() : ""String_Node_Str"";
      warnings.add(JSError.make(propAccessNode,ABSTRACT_SUPER_METHOD_NOT_CALLABLE,funName));
    }
    return new EnvTypePair(pair.env,pname.equals(""String_Node_Str"") ? commonTypes.fromFunctionType(ft.transformByCallProperty()) : commonTypes.fromFunctionType(ft.transformByApplyProperty()));
  }
  if (this.convention.isSuperClassReference(pname)) {
    if (ft != null && ft.isUniqueConstructor()) {
      JSType result=ft.getSuperPrototype();
      pair.type=result != null ? result : UNDEFINED;
      return pair;
    }
  }
  if (propAccessNode.isGetProp() && mayWarnAboutDictPropAccess(receiver,recvType)) {
    return new EnvTypePair(pair.env,requiredType);
  }
  if (recvType.isTop()) {
    recvType=TOP_OBJECT;
  }
  if (propAccessNode.getParent().isDelProp() && recvType.hasConstantProp(propQname)) {
    warnings.add(JSError.make(propAccessNode.getParent(),CONST_PROPERTY_DELETED,pname));
  }
  QualifiedName getterPname=new QualifiedName(JSType.createGetterPropName(pname));
  if (recvType.hasProp(getterPname)) {
    return new EnvTypePair(pair.env,recvType.getProp(getterPname));
  }
  JSType resultType=recvType.getProp(propQname);
  if (resultType != null && resultType.isBottom()) {
    warnings.add(JSError.make(propAccessNode,BOTTOM_PROP,pname,recvType.toString()));
    return new EnvTypePair(pair.env,UNKNOWN);
  }
  if (!propAccessNode.getParent().isExprResult() && !specializedType.isTrueOrTruthy() && !specializedType.isFalseOrFalsy()&& !recvType.mayBeDict()&& !mayWarnAboutInexistentProp(propAccessNode,recvType,propQname)&& recvType.hasProp(propQname)&& !resultType.isSubtypeOf(requiredType)&& tightenPropertyTypeAndDontWarn(receiver.isName() ? receiver.getString() : null,propAccessNode,recvType,recvType.getDeclaredProp(propQname),resultType,requiredType)) {
    resultType=resultType.specialize(requiredType);
    LValueResultFwd lvr=analyzeLValueFwd(propAccessNode,inEnv,resultType);
    TypeEnv updatedEnv=updateLvalueTypeInEnv(lvr.env,propAccessNode,lvr.ptr,resultType);
    return new EnvTypePair(updatedEnv,resultType);
  }
  if (resultType == null) {
    resultType=UNKNOWN;
  }
  return new EnvTypePair(pair.env,resultType);
}","private EnvTypePair analyzePropAccessFwd(Node receiver,String pname,TypeEnv inEnv,JSType requiredType,JSType specializedType){
  QualifiedName propQname=new QualifiedName(pname);
  Node propAccessNode=receiver.getParent();
  EnvTypePair pair;
  JSType reqObjType=pickReqObjType(propAccessNode);
  JSType recvReqType;
  JSType recvSpecType;
  if ((NodeUtil.isPropertyTest(compiler,propAccessNode) && !specializedType.isFalseOrFalsy()) || (NodeUtil.isPropertyAbsenceTest(propAccessNode) && !specializedType.isTrueOrTruthy()) || specializedType.isTrueOrTruthy()) {
    recvReqType=reqObjType;
    pair=analyzeExprFwd(receiver,inEnv,recvReqType);
    JSType subtypeWithProp=pair.type.findSubtypeWithProp(propQname);
    if (subtypeWithProp.isBottom()) {
      recvSpecType=reqObjType;
    }
 else {
      recvSpecType=subtypeWithProp;
    }
    if (specializedType.isTrueOrTruthy()) {
      recvSpecType=recvSpecType.withLoose().withProperty(propQname,specializedType);
    }
 else {
      recvSpecType=recvSpecType.withProperty(propQname,specializedType);
    }
  }
 else   if (specializedType.isFalseOrFalsy()) {
    recvReqType=recvSpecType=reqObjType;
  }
 else {
    recvReqType=reqObjType.withProperty(propQname,requiredType);
    recvSpecType=reqObjType.withProperty(propQname,specializedType);
  }
  pair=analyzeExprFwd(receiver,inEnv,recvReqType,recvSpecType);
  pair=mayWarnAboutNullableReferenceAndTighten(receiver,pair.type,recvSpecType,pair.env);
  JSType recvType=pair.type.autobox();
  if (recvType.isUnknown() || recvType.isTrueOrTruthy()) {
    mayWarnAboutInexistentProp(propAccessNode,recvType,propQname);
    return new EnvTypePair(pair.env,requiredType);
  }
  if (mayWarnAboutNonObject(receiver,recvType,specializedType)) {
    return new EnvTypePair(pair.env,requiredType);
  }
  FunctionType ft=recvType.getFunTypeIfSingletonObj();
  if (ft != null && (pname.equals(""String_Node_Str"") || pname.equals(""String_Node_Str""))) {
    if (ft.isAbstract()) {
      String funName=receiver.isQualifiedName() ? receiver.getQualifiedName() : ""String_Node_Str"";
      warnings.add(JSError.make(propAccessNode,ABSTRACT_SUPER_METHOD_NOT_CALLABLE,funName));
    }
    return new EnvTypePair(pair.env,pname.equals(""String_Node_Str"") ? commonTypes.fromFunctionType(ft.transformByCallProperty()) : commonTypes.fromFunctionType(ft.transformByApplyProperty()));
  }
  if (this.convention.isSuperClassReference(pname)) {
    if (ft != null && ft.isUniqueConstructor()) {
      JSType result=ft.getSuperPrototype();
      pair.type=result != null ? result : UNDEFINED;
      return pair;
    }
  }
  if (propAccessNode.isGetProp() && mayWarnAboutDictPropAccess(receiver,recvType)) {
    return new EnvTypePair(pair.env,requiredType);
  }
  if (recvType.isTop()) {
    recvType=TOP_OBJECT;
  }
  if (propAccessNode.getParent().isDelProp() && recvType.hasConstantProp(propQname)) {
    warnings.add(JSError.make(propAccessNode.getParent(),CONST_PROPERTY_DELETED,pname));
  }
  QualifiedName getterPname=new QualifiedName(JSType.createGetterPropName(pname));
  if (recvType.hasProp(getterPname)) {
    return new EnvTypePair(pair.env,recvType.getProp(getterPname));
  }
  JSType resultType=recvType.getProp(propQname);
  if (resultType != null && resultType.isBottom()) {
    warnings.add(JSError.make(propAccessNode,BOTTOM_PROP,pname,recvType.toString()));
    return new EnvTypePair(pair.env,UNKNOWN);
  }
  if (!propAccessNode.getParent().isExprResult() && !specializedType.isTrueOrTruthy() && !specializedType.isFalseOrFalsy()&& !recvType.mayBeDict()&& !mayWarnAboutInexistentProp(propAccessNode,recvType,propQname)&& recvType.hasProp(propQname)&& !resultType.isSubtypeOf(requiredType)&& tightenPropertyTypeAndDontWarn(receiver.isName() ? receiver.getString() : null,propAccessNode,recvType,recvType.getDeclaredProp(propQname),resultType,requiredType)) {
    resultType=resultType.specialize(requiredType);
    LValueResultFwd lvr=analyzeLValueFwd(propAccessNode,inEnv,resultType);
    TypeEnv updatedEnv=updateLvalueTypeInEnv(lvr.env,propAccessNode,lvr.ptr,resultType);
    return new EnvTypePair(updatedEnv,resultType);
  }
  if (resultType == null) {
    resultType=UNKNOWN;
  }
  return new EnvTypePair(pair.env,resultType);
}",0.9986980707776068
27266,"private EnvTypePair analyzeObjLitFwd(Node objLit,TypeEnv inEnv,JSType requiredType,JSType specializedType){
  if (NodeUtil.isEnumDecl(objLit.getParent())) {
    return analyzeEnumObjLitFwd(objLit,inEnv,requiredType);
  }
  JSDocInfo jsdoc=objLit.getJSDocInfo();
  boolean isStruct=jsdoc != null && jsdoc.makesStructs();
  boolean isDict=jsdoc != null && jsdoc.makesDicts();
  TypeEnv env=inEnv;
  JSType result=pickReqObjType(objLit);
  for (  Node prop : objLit.children()) {
    if (isStruct && prop.isQuotedString()) {
      warnings.add(JSError.make(prop,ILLEGAL_OBJLIT_KEY,""String_Node_Str""));
    }
 else     if (isDict && !prop.isQuotedString()) {
      warnings.add(JSError.make(prop,ILLEGAL_OBJLIT_KEY,""String_Node_Str""));
    }
    String pname=NodeUtil.getObjectLitKeyName(prop);
    if (prop.isGetterDef() || prop.isSetterDef()) {
      EnvTypePair pair=analyzeExprFwd(prop.getFirstChild(),env);
      FunctionType funType=pair.type.getFunType();
      Preconditions.checkNotNull(funType);
      String specialPropName;
      JSType propType;
      if (prop.isGetterDef()) {
        specialPropName=JSType.createGetterPropName(pname);
        propType=funType.getReturnType();
      }
 else {
        specialPropName=JSType.createSetterPropName(pname);
        propType=pair.type;
      }
      result=result.withProperty(new QualifiedName(specialPropName),propType);
      env=pair.env;
    }
 else {
      QualifiedName qname=new QualifiedName(pname);
      JSType jsdocType=symbolTable.getPropDeclaredType(prop);
      JSType reqPtype, specPtype;
      if (jsdocType != null) {
        reqPtype=specPtype=jsdocType;
      }
 else       if (requiredType.mayHaveProp(qname)) {
        reqPtype=specPtype=requiredType.getProp(qname);
        if (specializedType.mayHaveProp(qname)) {
          specPtype=specializedType.getProp(qname);
        }
      }
 else {
        reqPtype=specPtype=UNKNOWN;
      }
      EnvTypePair pair=analyzeExprFwd(prop.getFirstChild(),env,reqPtype,specPtype);
      if (jsdocType != null) {
        result=result.withDeclaredProperty(qname,jsdocType,false);
        if (!pair.type.isSubtypeOf(jsdocType)) {
          warnings.add(JSError.make(prop,INVALID_OBJLIT_PROPERTY_TYPE,errorMsgWithTypeDiff(jsdocType,pair.type)));
          pair.type=jsdocType;
        }
      }
      result=result.withProperty(qname,pair.type);
      env=pair.env;
    }
  }
  result=mayAdjustObjLitType(objLit,jsdoc,inEnv,result);
  return new EnvTypePair(env,result);
}","private EnvTypePair analyzeObjLitFwd(Node objLit,TypeEnv inEnv,JSType requiredType,JSType specializedType){
  if (NodeUtil.isEnumDecl(objLit.getParent())) {
    return analyzeEnumObjLitFwd(objLit,inEnv,requiredType);
  }
  JSDocInfo jsdoc=objLit.getJSDocInfo();
  boolean isStruct=jsdoc != null && jsdoc.makesStructs();
  boolean isDict=jsdoc != null && jsdoc.makesDicts();
  TypeEnv env=inEnv;
  JSType result=pickReqObjType(objLit);
  for (  Node prop : objLit.children()) {
    if (isStruct && prop.isQuotedString()) {
      warnings.add(JSError.make(prop,ILLEGAL_OBJLIT_KEY,""String_Node_Str""));
    }
 else     if (isDict && !prop.isQuotedString()) {
      warnings.add(JSError.make(prop,ILLEGAL_OBJLIT_KEY,""String_Node_Str""));
    }
    String pname=NodeUtil.getObjectLitKeyName(prop);
    if (prop.isGetterDef() || prop.isSetterDef()) {
      EnvTypePair pair=analyzeExprFwd(prop.getFirstChild(),env);
      FunctionType funType=pair.type.getFunType();
      Preconditions.checkNotNull(funType);
      String specialPropName;
      JSType propType;
      if (prop.isGetterDef()) {
        specialPropName=JSType.createGetterPropName(pname);
        propType=funType.getReturnType();
      }
 else {
        specialPropName=JSType.createSetterPropName(pname);
        propType=pair.type;
      }
      result=result.withProperty(new QualifiedName(specialPropName),propType);
      env=pair.env;
    }
 else {
      QualifiedName qname=new QualifiedName(pname);
      JSType jsdocType=symbolTable.getPropDeclaredType(prop);
      JSType reqPtype;
      JSType specPtype;
      if (jsdocType != null) {
        reqPtype=specPtype=jsdocType;
      }
 else       if (requiredType.mayHaveProp(qname)) {
        reqPtype=specPtype=requiredType.getProp(qname);
        if (specializedType.mayHaveProp(qname)) {
          specPtype=specializedType.getProp(qname);
        }
      }
 else {
        reqPtype=specPtype=UNKNOWN;
      }
      EnvTypePair pair=analyzeExprFwd(prop.getFirstChild(),env,reqPtype,specPtype);
      if (jsdocType != null) {
        result=result.withDeclaredProperty(qname,jsdocType,false);
        if (!pair.type.isSubtypeOf(jsdocType)) {
          warnings.add(JSError.make(prop,INVALID_OBJLIT_PROPERTY_TYPE,errorMsgWithTypeDiff(jsdocType,pair.type)));
          pair.type=jsdocType;
        }
      }
      result=result.withProperty(qname,pair.type);
      env=pair.env;
    }
  }
  result=mayAdjustObjLitType(objLit,jsdoc,inEnv,result);
  return new EnvTypePair(env,result);
}",0.9969957941117564
27267,"void add(JSError warning){
  String filename=warning.node.getSourceFileName();
  if (filename != null && filename.startsWith(""String_Node_Str"") || JSType.mockToString) {
    return;
  }
  compiler.report(warning);
}","void add(JSError warning){
  String filename=warning.node.getSourceFileName();
  if ((filename != null && filename.startsWith(""String_Node_Str"")) || JSType.mockToString) {
    return;
  }
  compiler.report(warning);
}",0.9953703703703703
27268,"private TypeEnv collectTypesForFreeVarsFwd(Node n,TypeEnv env){
  Preconditions.checkArgument(n.isFunction() || n.isName() && NodeUtil.isCallOrNewTarget(n));
  String fnName=n.isFunction() ? symbolTable.getFunInternalName(n) : n.getString();
  NTIScope innerScope=this.currentScope.getScope(fnName);
  for (  String freeVar : innerScope.getOuterVars()) {
    if (innerScope.getDeclaredTypeOf(freeVar) == null) {
      FunctionType summary=summaries.get(innerScope).getFunType();
      JSType outerType=envGetType(env,freeVar);
      if (outerType == null) {
        outerType=UNKNOWN;
      }
      JSType innerType=summary.getOuterVarPrecondition(freeVar);
      if (!innerType.isLoose() && (n.isName() || n.isFunction() && !outerType.isUndefined()) && !JSType.haveCommonSubtype(outerType,innerType)) {
        warnings.add(JSError.make(n,CROSS_SCOPE_GOTCHA,freeVar,outerType.toString(),innerType.toString()));
      }
      env=envPutType(env,freeVar,n.isFunction() ? JSType.join(innerType,outerType) : innerType);
    }
  }
  return env;
}","private TypeEnv collectTypesForFreeVarsFwd(Node n,TypeEnv env){
  Preconditions.checkArgument(n.isFunction() || (n.isName() && NodeUtil.isCallOrNewTarget(n)));
  String fnName=n.isFunction() ? symbolTable.getFunInternalName(n) : n.getString();
  NTIScope innerScope=this.currentScope.getScope(fnName);
  for (  String freeVar : innerScope.getOuterVars()) {
    if (innerScope.getDeclaredTypeOf(freeVar) == null) {
      FunctionType summary=summaries.get(innerScope).getFunType();
      JSType outerType=envGetType(env,freeVar);
      if (outerType == null) {
        outerType=UNKNOWN;
      }
      JSType innerType=summary.getOuterVarPrecondition(freeVar);
      if (!innerType.isLoose() && (n.isName() || (n.isFunction() && !outerType.isUndefined())) && !JSType.haveCommonSubtype(outerType,innerType)) {
        warnings.add(JSError.make(n,CROSS_SCOPE_GOTCHA,freeVar,outerType.toString(),innerType.toString()));
      }
      env=envPutType(env,freeVar,n.isFunction() ? JSType.join(innerType,outerType) : innerType);
    }
  }
  return env;
}",0.9980842911877394
27269,"private LValueResultFwd analyzeLValueFwd(Node expr,TypeEnv inEnv,JSType type,boolean insideQualifiedName){
  LValueResultFwd lvalResult=null;
switch (expr.getToken()) {
case THIS:
{
      mayWarnAboutGlobalThis(expr,currentScope);
      if (this.currentScope.hasThis()) {
        lvalResult=new LValueResultFwd(inEnv,envGetType(inEnv,THIS_ID),this.currentScope.getDeclaredTypeOf(THIS_ID),new QualifiedName(THIS_ID));
      }
 else {
        lvalResult=new LValueResultFwd(inEnv,UNKNOWN,null,null);
      }
      break;
    }
case NAME:
{
    String varName=expr.getString();
    JSType varType=analyzeExprFwd(expr,inEnv).type;
    lvalResult=new LValueResultFwd(inEnv,varType,this.currentScope.getDeclaredTypeOf(varName),varType.hasNonScalar() ? new QualifiedName(varName) : null);
    break;
  }
case GETPROP:
case GETELEM:
{
  Node obj=expr.getFirstChild();
  Node prop=expr.getLastChild();
  QualifiedName pname=expr.isGetProp() || prop.isString() ? new QualifiedName(prop.getString()) : null;
  LValueResultFwd recvLvalue=analyzeReceiverLvalFwd(obj,pname,inEnv,type);
  if (!recvLvalue.type.isSubtypeOf(TOP_OBJECT)) {
    EnvTypePair pair=analyzeExprFwd(prop,recvLvalue.env,type);
    lvalResult=new LValueResultFwd(pair.env,type,null,null);
    break;
  }
  JSType indexType=recvLvalue.type.getIndexType();
  if (expr.isGetElem() && indexType != null) {
    lvalResult=analyzeIObjectElmLvalFwd(prop,recvLvalue,indexType);
    break;
  }
  if (expr.isGetProp() || prop.isString()) {
    lvalResult=analyzePropLValFwd(obj,pname,recvLvalue,type,insideQualifiedName);
    break;
  }
  EnvTypePair pair=analyzeExprFwd(expr,recvLvalue.env,type);
  lvalResult=new LValueResultFwd(pair.env,pair.type,null,null);
  break;
}
case VAR:
{
Preconditions.checkState(expr.getParent().isForIn());
Node vdecl=expr.getFirstChild();
String name=vdecl.getString();
Preconditions.checkState(!vdecl.hasChildren());
return new LValueResultFwd(inEnv,STRING,null,new QualifiedName(name));
}
default :
{
Preconditions.checkState(insideQualifiedName);
EnvTypePair pair=analyzeExprFwd(expr,inEnv,type);
return new LValueResultFwd(pair.env,pair.type,null,null);
}
}
maybeSetTypeI(expr,lvalResult.type);
mayWarnAboutUnknownType(expr,lvalResult.type);
return lvalResult;
}","private LValueResultFwd analyzeLValueFwd(Node expr,TypeEnv inEnv,JSType type,boolean insideQualifiedName){
  LValueResultFwd lvalResult=null;
switch (expr.getToken()) {
case THIS:
{
      mayWarnAboutGlobalThis(expr);
      if (this.currentScope.hasThis()) {
        lvalResult=new LValueResultFwd(inEnv,envGetType(inEnv,THIS_ID),this.currentScope.getDeclaredTypeOf(THIS_ID),new QualifiedName(THIS_ID));
      }
 else {
        lvalResult=new LValueResultFwd(inEnv,UNKNOWN,null,null);
      }
      break;
    }
case NAME:
{
    String varName=expr.getString();
    JSType varType=analyzeExprFwd(expr,inEnv).type;
    lvalResult=new LValueResultFwd(inEnv,varType,this.currentScope.getDeclaredTypeOf(varName),varType.hasNonScalar() ? new QualifiedName(varName) : null);
    break;
  }
case GETPROP:
case GETELEM:
{
  Node obj=expr.getFirstChild();
  Node prop=expr.getLastChild();
  QualifiedName pname=expr.isGetProp() || prop.isString() ? new QualifiedName(prop.getString()) : null;
  LValueResultFwd recvLvalue=analyzeReceiverLvalFwd(obj,pname,inEnv,type);
  if (!recvLvalue.type.isSubtypeOf(TOP_OBJECT)) {
    EnvTypePair pair=analyzeExprFwd(prop,recvLvalue.env,type);
    lvalResult=new LValueResultFwd(pair.env,type,null,null);
    break;
  }
  JSType indexType=recvLvalue.type.getIndexType();
  if (expr.isGetElem() && indexType != null) {
    lvalResult=analyzeIObjectElmLvalFwd(prop,recvLvalue,indexType);
    break;
  }
  if (expr.isGetProp() || prop.isString()) {
    lvalResult=analyzePropLValFwd(obj,pname,recvLvalue,type,insideQualifiedName);
    break;
  }
  EnvTypePair pair=analyzeExprFwd(expr,recvLvalue.env,type);
  lvalResult=new LValueResultFwd(pair.env,pair.type,null,null);
  break;
}
case VAR:
{
Preconditions.checkState(expr.getParent().isForIn());
Node vdecl=expr.getFirstChild();
String name=vdecl.getString();
Preconditions.checkState(!vdecl.hasChildren());
return new LValueResultFwd(inEnv,STRING,null,new QualifiedName(name));
}
default :
{
Preconditions.checkState(insideQualifiedName);
EnvTypePair pair=analyzeExprFwd(expr,inEnv,type);
return new LValueResultFwd(pair.env,pair.type,null,null);
}
}
maybeSetTypeI(expr,lvalResult.type);
mayWarnAboutUnknownType(expr,lvalResult.type);
return lvalResult;
}",0.9970975664210762
27270,"private EnvTypePair analyzeCallNewBwd(Node expr,TypeEnv outEnv,JSType requiredType){
  Preconditions.checkArgument(expr.isNew() || expr.isCall());
  Node callee=expr.getFirstChild();
  EnvTypePair pair=analyzeExprBwd(callee,outEnv,commonTypes.topFunction());
  TypeEnv envAfterCallee=pair.env;
  FunctionType funType=pair.type.getFunType();
  if (funType == null) {
    return analyzeCallNodeArgumentsBwd(expr,envAfterCallee);
  }
 else   if (funType.isLoose()) {
    return analyzeLooseCallNodeBwd(expr,envAfterCallee,requiredType);
  }
 else   if (expr.isCall() && funType.isSomeConstructorOrInterface() || expr.isNew() && !funType.isSomeConstructorOrInterface()) {
    return analyzeCallNodeArgumentsBwd(expr,envAfterCallee);
  }
 else   if (funType.isTopFunction()) {
    return analyzeCallNodeArgumentsBwd(expr,envAfterCallee);
  }
  if (callee.isName() && !funType.isGeneric() && expr.isCall()) {
    createDeferredCheckBwd(expr,requiredType);
  }
  int numArgs=expr.getChildCount() - 1;
  if (numArgs < funType.getMinArity() || numArgs > funType.getMaxArity()) {
    return analyzeCallNodeArgumentsBwd(expr,envAfterCallee);
  }
  if (funType.isGeneric()) {
    Map<String,JSType> typeMap=calcTypeInstantiationBwd(expr,funType,envAfterCallee);
    funType=funType.instantiateGenerics(typeMap);
  }
  TypeEnv tmpEnv=envAfterCallee;
  Node target=expr.getFirstChild();
  int i=expr.getChildCount() - 1;
  for (Node arg=expr.getLastChild(); arg != target; arg=arg.getPrevious()) {
    i--;
    JSType formalType=funType.getFormalType(i);
    if (formalType.isBottom()) {
      formalType=UNKNOWN;
    }
    tmpEnv=analyzeExprBwd(arg,tmpEnv,formalType).env;
  }
  JSType retType=expr.isNew() ? funType.getThisType() : funType.getReturnType();
  return new EnvTypePair(tmpEnv,retType);
}","private EnvTypePair analyzeCallNewBwd(Node expr,TypeEnv outEnv,JSType requiredType){
  Preconditions.checkArgument(expr.isNew() || expr.isCall());
  Node callee=expr.getFirstChild();
  EnvTypePair pair=analyzeExprBwd(callee,outEnv,commonTypes.topFunction());
  TypeEnv envAfterCallee=pair.env;
  FunctionType funType=pair.type.getFunType();
  if (funType == null) {
    return analyzeCallNodeArgumentsBwd(expr,envAfterCallee);
  }
 else   if (funType.isLoose()) {
    return analyzeLooseCallNodeBwd(expr,envAfterCallee,requiredType);
  }
 else   if ((expr.isCall() && funType.isSomeConstructorOrInterface()) || (expr.isNew() && !funType.isSomeConstructorOrInterface())) {
    return analyzeCallNodeArgumentsBwd(expr,envAfterCallee);
  }
 else   if (funType.isTopFunction()) {
    return analyzeCallNodeArgumentsBwd(expr,envAfterCallee);
  }
  if (callee.isName() && !funType.isGeneric() && expr.isCall()) {
    createDeferredCheckBwd(expr,requiredType);
  }
  int numArgs=expr.getChildCount() - 1;
  if (numArgs < funType.getMinArity() || numArgs > funType.getMaxArity()) {
    return analyzeCallNodeArgumentsBwd(expr,envAfterCallee);
  }
  if (funType.isGeneric()) {
    Map<String,JSType> typeMap=calcTypeInstantiationBwd(expr,funType,envAfterCallee);
    funType=funType.instantiateGenerics(typeMap);
  }
  TypeEnv tmpEnv=envAfterCallee;
  Node target=expr.getFirstChild();
  int i=expr.getChildCount() - 1;
  for (Node arg=expr.getLastChild(); arg != target; arg=arg.getPrevious()) {
    i--;
    JSType formalType=funType.getFormalType(i);
    if (formalType.isBottom()) {
      formalType=UNKNOWN;
    }
    tmpEnv=analyzeExprBwd(arg,tmpEnv,formalType).env;
  }
  JSType retType=expr.isNew() ? funType.getThisType() : funType.getReturnType();
  return new EnvTypePair(tmpEnv,retType);
}",0.9988826815642458
27271,"private void validateCatch(Node n){
  validateNodeType(Token.CATCH,n);
  validateChildCount(n);
  Node caught=n.getFirstChild();
  if (caught.isName()) {
    validateName(caught);
  }
 else   if (n.isArrayPattern()) {
    validateArrayPattern(Token.CATCH,caught);
  }
 else {
    validateObjectPattern(Token.CATCH,caught);
  }
  validateBlock(n.getLastChild());
}","private void validateCatch(Node n){
  validateNodeType(Token.CATCH,n);
  validateChildCount(n);
  Node caught=n.getFirstChild();
  if (caught.isName()) {
    validateName(caught);
  }
 else   if (caught.isArrayPattern()) {
    validateArrayPattern(Token.CATCH,caught);
  }
 else {
    validateObjectPattern(Token.CATCH,caught);
  }
  validateBlock(n.getLastChild());
}",0.9904240766073872
27272,"/** 
 * Gets the outcome scope if we do know the outcome of the entire expression.
 */
FlowScope getOutcomeFlowScope(Token nodeType,boolean outcome){
  if (nodeType == Token.AND && outcome || nodeType == Token.OR && !outcome) {
    return rightScope;
  }
 else {
    return getJoinedFlowScope();
  }
}","/** 
 * Gets the outcome scope if we do know the outcome of the entire expression.
 */
FlowScope getOutcomeFlowScope(Token nodeType,boolean outcome){
  if ((nodeType == Token.AND && outcome) || (nodeType == Token.OR && !outcome)) {
    return rightScope;
  }
 else {
    return getJoinedFlowScope();
  }
}",0.9933993399339934
27273,"/** 
 * @return Whether the alias was recorded.
 */
private boolean maybeRecordAlias(String name,Node parent,@Nullable NameInformation referring,String referringName){
  boolean isPrototypePropAssignment=parent.isAssign() && NodeUtil.isPrototypeProperty(parent.getFirstChild());
  if ((parent.isName() || parent.isAssign()) && !isPrototypePropAssignment && referring != null && scopes.containsEntry(parent,referring)) {
    recordAlias(referringName,name);
    return true;
  }
  return false;
}","/** 
 * @return Whether the alias was recorded.
 */
private boolean maybeRecordAlias(String name,Node n,@Nullable NameInformation referring,String referringName){
  Node consumer=getConsumingExpression(n);
  boolean isPrototypePropAssignment=consumer.isAssign() && NodeUtil.isPrototypeProperty(consumer.getFirstChild());
  if ((consumer.isName() || consumer.isAssign()) && !isPrototypePropAssignment && referring != null && scopes.containsEntry(consumer,referring)) {
    recordAlias(referringName,name);
    return true;
  }
  return false;
}",0.884393063583815
27274,"private void maybeRecordReferenceOrAlias(NodeTraversal t,Node n,Node parent,NameInformation nameInfo,@Nullable NameInformation referring){
  String referringName=""String_Node_Str"";
  if (referring != null) {
    referringName=referring.isPrototype ? referring.prototypeClass : referring.name;
  }
  String name=nameInfo.name;
  if (maybeHiddenAlias(n)) {
    recordAlias(name,WINDOW);
  }
  if (nameInfo.isExternallyReferenceable) {
    recordReference(WINDOW,name,RefType.REGULAR);
    maybeRecordAlias(name,parent,referring,referringName);
    return;
  }
  if (NodeUtil.isVarOrSimpleAssignLhs(n,parent)) {
    if (referring != null) {
      recordReference(referringName,name,RefType.REGULAR);
    }
    return;
  }
  if (nodesToKeep.contains(n)) {
    List<NameInformation> functionScopes=getEnclosingFunctionDependencyScope(t);
    if (!functionScopes.isEmpty()) {
      for (      NameInformation functionScope : functionScopes) {
        recordReference(functionScope.name,name,RefType.REGULAR);
      }
    }
 else {
      recordReference(WINDOW,name,RefType.REGULAR);
      if (referring != null) {
        maybeRecordAlias(name,parent,referring,referringName);
      }
    }
  }
 else   if (referring != null) {
    if (!maybeRecordAlias(name,parent,referring,referringName)) {
      RefType depType=referring.onlyAffectsClassDef ? RefType.INHERITANCE : RefType.REGULAR;
      recordReference(referringName,name,depType);
    }
  }
 else {
    for (    Node ancestor : n.getAncestors()) {
      if (NodeUtil.isAssignmentOp(ancestor) || ancestor.isFunction()) {
        recordReference(WINDOW,name,RefType.REGULAR);
        break;
      }
    }
  }
}","private void maybeRecordReferenceOrAlias(NodeTraversal t,Node n,Node parent,NameInformation nameInfo,@Nullable NameInformation referring){
  String referringName=""String_Node_Str"";
  if (referring != null) {
    referringName=referring.isPrototype ? referring.prototypeClass : referring.name;
  }
  String name=nameInfo.name;
  if (maybeHiddenAlias(n)) {
    recordAlias(name,WINDOW);
  }
  if (nameInfo.isExternallyReferenceable) {
    recordReference(WINDOW,name,RefType.REGULAR);
    maybeRecordAlias(name,n,referring,referringName);
    return;
  }
  if (NodeUtil.isVarOrSimpleAssignLhs(n,parent)) {
    if (referring != null) {
      recordReference(referringName,name,RefType.REGULAR);
    }
    return;
  }
  if (nodesToKeep.contains(n)) {
    List<NameInformation> functionScopes=getEnclosingFunctionDependencyScope(t);
    if (!functionScopes.isEmpty()) {
      for (      NameInformation functionScope : functionScopes) {
        recordReference(functionScope.name,name,RefType.REGULAR);
      }
    }
 else {
      recordReference(WINDOW,name,RefType.REGULAR);
      if (referring != null) {
        maybeRecordAlias(name,n,referring,referringName);
      }
    }
  }
 else   if (referring != null) {
    if (!maybeRecordAlias(name,n,referring,referringName)) {
      RefType depType=referring.onlyAffectsClassDef ? RefType.INHERITANCE : RefType.REGULAR;
      recordReference(referringName,name,depType);
    }
  }
 else {
    for (    Node ancestor : n.getAncestors()) {
      if (NodeUtil.isAssignmentOp(ancestor) || ancestor.isFunction()) {
        recordReference(WINDOW,name,RefType.REGULAR);
        break;
      }
    }
  }
}",0.9936421435059036
27275,"public void testNoRemoveWindowPropertyAlias4(){
  test(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"");
}","public void testNoRemoveWindowPropertyAlias4(){
  testSame(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""));
}",0.8347826086956521
27276,"public void testNoRemoveWindowPropertyAlias5(){
  test(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"");
}","public void testNoRemoveWindowPropertyAlias5(){
  testSame(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""));
}",0.8347826086956521
27277,"public void testNoRemoveWindowPropertyAlias4a(){
  test(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"");
}","public void testNoRemoveWindowPropertyAlias4a(){
  testSame(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""));
}",0.8362068965517241
27278,"public void testNoRemoveWindowPropertyAlias5a(){
  test(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"");
}","public void testNoRemoveWindowPropertyAlias5a(){
  testSame(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""));
}",0.8362068965517241
27279,"public void testAliasInstanceof5(){
  test(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
}","public void testAliasInstanceof5(){
  testSame(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.659217877094972
27280,"boolean isGlobalVar(String varName){
  NTIScope s=this;
  while (s.parent != null) {
    if (isDefinedLocally(varName,false)) {
      return false;
    }
    s=s.parent;
  }
  return true;
}","boolean isGlobalVar(String varName){
  NTIScope s=this;
  while (s.parent != null) {
    if (s.isDefinedLocally(varName,false)) {
      return false;
    }
    s=s.parent;
  }
  return true;
}",0.9947643979057592
27281,"void addNamespace(Node qnameNode,Namespace ns){
  if (ns instanceof EnumType) {
    this.localEnums.add((EnumType)ns);
  }
  if (qnameNode.isName()) {
    String varName=qnameNode.getString();
    Preconditions.checkState(!this.localNamespaces.containsKey(varName));
    this.localNamespaces.put(varName,ns);
    if (qnameNode.isFromExterns() && !this.externs.containsKey(varName)) {
      this.externs.put(qnameNode.getString(),null);
    }
  }
 else {
    Preconditions.checkState(!isDefined(qnameNode));
    QualifiedName qname=QualifiedName.fromNode(qnameNode);
    Namespace rootns=getNamespace(qname.getLeftmostName());
    rootns.addNamespace(qname.getAllButLeftmost(),ns);
  }
}","void addNamespace(Node qnameNode,Namespace ns){
  if (ns instanceof EnumType) {
    this.localEnums.add((EnumType)ns);
  }
  if (qnameNode.isName()) {
    String varName=qnameNode.getString();
    Preconditions.checkState(!this.localNamespaces.containsKey(varName),""String_Node_Str"",varName);
    this.localNamespaces.put(varName,ns);
    if (qnameNode.isFromExterns() && !this.externs.containsKey(varName)) {
      this.externs.put(qnameNode.getString(),null);
    }
  }
 else {
    Preconditions.checkState(!isDefined(qnameNode));
    QualifiedName qname=QualifiedName.fromNode(qnameNode);
    Namespace rootns=getNamespace(qname.getLeftmostName());
    rootns.addNamespace(qname.getAllButLeftmost(),ns);
  }
}",0.9814020028612304
27282,"static NominalType join(NominalType c1,NominalType c2){
  if (c1 == null || c2 == null) {
    return null;
  }
  if (c1.isNominalSubtypeOf(c2)) {
    return c2;
  }
  if (c1.isRawSubtypeOf(c2)) {
    return new NominalType(joinTypeMaps(c2.typeMap.keySet(),c1.typeMap,c2.typeMap),c2.rawType);
  }
  if (c2.isNominalSubtypeOf(c1)) {
    return c1;
  }
  if (c2.isRawSubtypeOf(c1)) {
    return new NominalType(joinTypeMaps(c1.typeMap.keySet(),c1.typeMap,c2.typeMap),c1.rawType);
  }
  return null;
}","static NominalType join(NominalType c1,NominalType c2){
  if (c1 == null || c2 == null) {
    return null;
  }
  if (c1.isNominalSubtypeOf(c2)) {
    return c2;
  }
  if (c2.isNominalSubtypeOf(c1)) {
    return c1;
  }
  if (c1.rawType.equals(c2.rawType)) {
    return c1.isGeneric() ? new NominalType(joinTypeMaps(c1,c2),c1.rawType) : c1;
  }
  Preconditions.checkState(!c1.isRawSubtypeOf(c2) && !c2.isRawSubtypeOf(c1));
  return null;
}",0.4149732620320855
27283,"private static ImmutableMap<String,JSType> joinTypeMaps(Set<String> domain,ImmutableMap<String,JSType> m1,ImmutableMap<String,JSType> m2){
  ImmutableMap.Builder<String,JSType> builder=ImmutableMap.builder();
  for (  String typevar : domain) {
    JSType t1=m1.get(typevar);
    JSType t2=m2.get(typevar);
    if (t1 == null) {
      builder.put(typevar,Preconditions.checkNotNull(t2));
    }
 else     if (t2 == null) {
      builder.put(typevar,t1);
    }
 else {
      builder.put(typevar,JSType.join(t1,t2));
    }
  }
  return builder.build();
}","private static ImmutableMap<String,JSType> joinTypeMaps(NominalType nt1,NominalType nt2){
  Preconditions.checkState(nt1.rawType.equals(nt2.rawType));
  ImmutableMap.Builder<String,JSType> builder=ImmutableMap.builder();
  if (nt1.isIObject()) {
    String indexTypevar=nt1.rawType.getTypeParameters().get(0);
    builder.put(indexTypevar,JSType.meet(nt1.getIndexType(),nt2.getIndexType()));
    String indexedTypevar=nt1.rawType.getTypeParameters().get(1);
    builder.put(indexedTypevar,JSType.join(nt1.getIndexedType(),nt2.getIndexedType()));
    return builder.build();
  }
  for (  String typevar : nt1.typeMap.keySet()) {
    builder.put(typevar,JSType.join(nt1.typeMap.get(typevar),nt2.typeMap.get(typevar)));
  }
  return builder.build();
}",0.3187066974595843
27284,"static ObjectType join(ObjectType obj1,ObjectType obj2){
  if (obj1.isTopObject() || obj2.isTopObject()) {
    return obj1.commonTypes.getTopObjectType();
  }
  if (obj1.equals(obj2)) {
    return obj1;
  }
 else   if (obj1.isPrototypeObject() && obj2.isPrototypeObject()) {
    return join(obj1.getNominalType().getInstanceAsObjectType(),obj2.getNominalType().getInstanceAsObjectType());
  }
  NominalType nt1=obj1.nominalType;
  NominalType nt2=obj2.nominalType;
  Preconditions.checkState(nt1.isRawSubtypeOf(nt2) || nt2.isRawSubtypeOf(nt1));
  JSTypes commonTypes=obj1.commonTypes;
  boolean isLoose=obj1.isLoose || obj2.isLoose;
  FunctionType fn=FunctionType.join(obj1.fn,obj2.fn);
  PersistentMap<String,Property> props;
  if (isLoose) {
    fn=fn == null ? null : fn.withLoose();
    props=joinPropsLoosely(commonTypes,obj1.props,obj2.props);
  }
 else {
    props=joinProps(obj1.props,obj2.props,nt1,nt2);
  }
  NominalType nominal=NominalType.join(nt1,nt2);
  if (nominal.isBuiltinObject() && fn != null) {
    if (isLoose) {
      nominal=obj1.commonTypes.getFunctionType();
    }
 else {
      fn=null;
    }
  }
  Namespace ns=Objects.equals(obj1.ns,obj2.ns) ? obj1.ns : null;
  return makeObjectType(commonTypes,nominal,props,fn,ns,isLoose,ObjectKind.join(obj1.objectKind,obj2.objectKind));
}","static ObjectType join(ObjectType obj1,ObjectType obj2){
  if (obj1.isTopObject() || obj2.isTopObject()) {
    return obj1.commonTypes.getTopObjectType();
  }
  if (obj1.equals(obj2)) {
    return obj1;
  }
  if (obj1.isPrototypeObject() && obj2.isPrototypeObject()) {
    return join(obj1.getNominalType().getInstanceAsObjectType(),obj2.getNominalType().getInstanceAsObjectType());
  }
  NominalType nt1=obj1.nominalType;
  NominalType nt2=obj2.nominalType;
  Preconditions.checkState(nt1.isRawSubtypeOf(nt2) || nt2.isRawSubtypeOf(nt1));
  JSTypes commonTypes=obj1.commonTypes;
  boolean isLoose=obj1.isLoose || obj2.isLoose;
  FunctionType fn=FunctionType.join(obj1.fn,obj2.fn);
  PersistentMap<String,Property> props;
  if (isLoose) {
    fn=fn == null ? null : fn.withLoose();
    props=joinPropsLoosely(commonTypes,obj1.props,obj2.props);
  }
 else {
    props=joinProps(obj1.props,obj2.props,nt1,nt2);
  }
  NominalType nominal=NominalType.join(nt1,nt2);
  if (nominal.isBuiltinObject() && fn != null) {
    if (isLoose) {
      nominal=obj1.commonTypes.getFunctionType();
    }
 else {
      fn=null;
    }
  }
  Namespace ns=Objects.equals(obj1.ns,obj2.ns) ? obj1.ns : null;
  return makeObjectType(commonTypes,nominal,props,fn,ns,isLoose,ObjectKind.join(obj1.objectKind,obj2.objectKind));
}",0.9976958525345622
27285,"static ImmutableSet<ObjectType> meetSetsHelper(boolean specializeObjs1,Set<ObjectType> objs1,Set<ObjectType> objs2){
  ObjectsBuilder newObjs=new ObjectsBuilder(ResolveConflictsBy.MEET);
  for (  ObjectType obj2 : objs2) {
    for (    ObjectType obj1 : objs1) {
      if (areRelatedNominalTypes(obj1.nominalType,obj2.nominalType)) {
        ObjectType newObj;
        if (specializeObjs1) {
          newObj=obj1.specialize(obj2);
          if (newObj == null) {
            continue;
          }
        }
 else {
          newObj=meet(obj1,obj2);
        }
        newObjs.add(newObj);
      }
 else       if (obj1.nominalType.isStructuralInterface() && obj2.isSubtypeOf(obj1,SubtypeCache.create())) {
        newObjs.add(obj2);
      }
 else       if (obj2.nominalType.isStructuralInterface() && obj1.isSubtypeOf(obj2,SubtypeCache.create())) {
        newObjs.add(obj1);
      }
    }
  }
  return newObjs.build();
}","static ImmutableSet<ObjectType> meetSetsHelper(boolean specializeObjs1,Set<ObjectType> objs1,Set<ObjectType> objs2){
  ObjectsBuilder newObjs=new ObjectsBuilder();
  for (  ObjectType obj2 : objs2) {
    for (    ObjectType obj1 : objs1) {
      if (areRelatedNominalTypes(obj1.nominalType,obj2.nominalType)) {
        ObjectType newObj;
        if (specializeObjs1) {
          newObj=obj1.specialize(obj2);
          if (newObj == null) {
            continue;
          }
        }
 else {
          newObj=meet(obj1,obj2);
        }
        newObjs.add(newObj);
      }
 else       if (obj1.nominalType.isStructuralInterface() && obj2.isSubtypeOf(obj1,SubtypeCache.create())) {
        newObjs.add(obj2);
      }
 else       if (obj2.nominalType.isStructuralInterface() && obj1.isSubtypeOf(obj2,SubtypeCache.create())) {
        newObjs.add(obj1);
      }
    }
  }
  return newObjs.build();
}",0.9873417721518988
27286,"static ImmutableSet<ObjectType> joinSets(ImmutableSet<ObjectType> objs1,ImmutableSet<ObjectType> objs2){
  if (objs1.isEmpty()) {
    return objs2;
  }
 else   if (objs2.isEmpty()) {
    return objs1;
  }
  ObjectType[] objs1Arr=objs1.toArray(new ObjectType[0]);
  ObjectType[] keptFrom1=Arrays.copyOf(objs1Arr,objs1Arr.length);
  ObjectsBuilder newObjs=new ObjectsBuilder(ResolveConflictsBy.JOIN);
  for (  ObjectType obj2 : objs2) {
    boolean addedObj2=false;
    for (int i=0; i < objs1Arr.length; i++) {
      ObjectType obj1=objs1Arr[i];
      NominalType nt1=obj1.nominalType;
      NominalType nt2=obj2.nominalType;
      if (areRelatedNominalTypes(nt1,nt2)) {
        if ((nt2.isBuiltinObject() && nt1 != null && !obj1.isSubtypeOf(obj2,SubtypeCache.create())) || (nt1.isBuiltinObject() && nt2 != null && !obj2.isSubtypeOf(obj1,SubtypeCache.create()))) {
          break;
        }
        keptFrom1[i]=null;
        addedObj2=true;
        newObjs.add(join(obj1,obj2));
        break;
      }
    }
    if (!addedObj2) {
      newObjs.add(obj2);
    }
  }
  for (  ObjectType o : keptFrom1) {
    if (o != null) {
      newObjs.add(o);
    }
  }
  return newObjs.build();
}","static ImmutableSet<ObjectType> joinSets(ImmutableSet<ObjectType> objs1,ImmutableSet<ObjectType> objs2){
  if (objs1.isEmpty()) {
    return objs2;
  }
 else   if (objs2.isEmpty()) {
    return objs1;
  }
  List<ObjectType> objs=new ArrayList<>(objs1);
  objs.addAll(objs2);
  for (int i=0; i < objs.size() - 1; i++) {
    ObjectType obj1=objs.get(i);
    NominalType nt1=obj1.nominalType;
    for (int j=i + 1; j < objs.size(); j++) {
      ObjectType obj2=objs.get(j);
      NominalType nt2=obj2.nominalType;
      if (nt1.isBuiltinObject() && nt2.isBuiltinObject()) {
        objs.set(i,null);
        objs.set(j,join(obj1,obj2));
      }
 else       if ((areRelatedNominalTypes(nt1,nt2) || NominalType.equalRawTypes(nt1,nt2)) && (!nt1.isBuiltinObject() || obj2.isSubtypeOf(obj1,SubtypeCache.create())) && (!nt2.isBuiltinObject() || obj1.isSubtypeOf(obj2,SubtypeCache.create()))) {
        objs.set(i,null);
        objs.set(j,join(obj1,obj2));
      }
    }
  }
  ImmutableSet.Builder<ObjectType> builder=ImmutableSet.builder();
  for (  ObjectType obj : objs) {
    if (obj != null) {
      builder.add(obj);
    }
  }
  return builder.build();
}",0.3581833761782348
27287,"static ObjectType meet(ObjectType obj1,ObjectType obj2){
  Preconditions.checkState(areRelatedNominalTypes(obj1.nominalType,obj2.nominalType));
  if (obj1.isTopObject() || obj2.isBottomObject()) {
    return obj2;
  }
 else   if (obj2.isTopObject() || obj1.isBottomObject()) {
    return obj1;
  }
  JSTypes commonTypes=obj1.commonTypes;
  NominalType resultNomType=NominalType.pickSubclass(obj1.nominalType,obj2.nominalType);
  FunctionType fn=FunctionType.meet(obj1.fn,obj2.fn);
  if (!FunctionType.isInhabitable(fn)) {
    return commonTypes.getBottomObject();
  }
  boolean isLoose=(obj1.isLoose && obj2.isLoose) || fn != null && fn.isLoose();
  if (resultNomType.isFunction() && fn == null) {
    fn=obj1.fn == null ? obj2.fn : obj1.fn;
    isLoose=fn.isLoose();
  }
  PersistentMap<String,Property> props;
  if (isLoose) {
    props=joinPropsLoosely(commonTypes,obj1.props,obj2.props);
  }
 else {
    props=meetPropsHelper(commonTypes,false,resultNomType,obj1.props,obj2.props);
  }
  if (props == commonTypes.BOTTOM_PROPERTY_MAP) {
    return commonTypes.getBottomObject();
  }
  ObjectKind ok=ObjectKind.meet(obj1.objectKind,obj2.objectKind);
  Namespace resultNs=Objects.equals(obj1.ns,obj2.ns) ? obj1.ns : null;
  return new ObjectType(commonTypes,resultNomType,props,fn,resultNs,isLoose,ok);
}","static ObjectType meet(ObjectType obj1,ObjectType obj2){
  NominalType nt1=obj1.nominalType;
  NominalType nt2=obj2.nominalType;
  Preconditions.checkState(areRelatedNominalTypes(nt1,nt2),""String_Node_Str"",nt1,nt2);
  if (obj1.isTopObject() || obj2.isBottomObject()) {
    return obj2;
  }
 else   if (obj2.isTopObject() || obj1.isBottomObject()) {
    return obj1;
  }
  JSTypes commonTypes=obj1.commonTypes;
  NominalType resultNomType=NominalType.pickSubclass(nt1,nt2);
  FunctionType fn=FunctionType.meet(obj1.fn,obj2.fn);
  if (!FunctionType.isInhabitable(fn)) {
    return commonTypes.getBottomObject();
  }
  boolean isLoose=(obj1.isLoose && obj2.isLoose) || fn != null && fn.isLoose();
  if (resultNomType.isFunction() && fn == null) {
    fn=obj1.fn == null ? obj2.fn : obj1.fn;
    isLoose=fn.isLoose();
  }
  PersistentMap<String,Property> props;
  if (isLoose) {
    props=joinPropsLoosely(commonTypes,obj1.props,obj2.props);
  }
 else {
    props=meetPropsHelper(commonTypes,false,resultNomType,obj1.props,obj2.props);
  }
  if (props == commonTypes.BOTTOM_PROPERTY_MAP) {
    return commonTypes.getBottomObject();
  }
  ObjectKind ok=ObjectKind.meet(obj1.objectKind,obj2.objectKind);
  Namespace resultNs=Objects.equals(obj1.ns,obj2.ns) ? obj1.ns : null;
  return new ObjectType(commonTypes,resultNomType,props,fn,resultNs,isLoose,ok);
}",0.9322289156626506
27288,"void add(ObjectType newObj){
  boolean addedObj=false;
  for (int i=0; i < this.objs.size(); i++) {
    ObjectType oldObj=this.objs.get(i);
    if (NominalType.equalRawTypes(oldObj.getNominalType(),newObj.getNominalType())) {
      addedObj=true;
      if (this.resolution == ResolveConflictsBy.JOIN) {
        this.objs.set(i,ObjectType.join(oldObj,newObj));
      }
 else {
        this.objs.set(i,ObjectType.meet(oldObj,newObj));
      }
    }
  }
  if (!addedObj) {
    this.objs.add(newObj);
  }
}","void add(ObjectType newObj){
  boolean addedObj=false;
  for (int i=0; i < this.objs.size(); i++) {
    ObjectType oldObj=this.objs.get(i);
    if (NominalType.equalRawTypes(oldObj.getNominalType(),newObj.getNominalType())) {
      addedObj=true;
      this.objs.set(i,ObjectType.meet(oldObj,newObj));
    }
  }
  if (!addedObj) {
    this.objs.add(newObj);
  }
}",0.6173410404624278
27289,"ObjectsBuilder(ResolveConflictsBy resolution){
  this.resolution=resolution;
  this.objs=new ArrayList<>();
}","ObjectsBuilder(){
  this.objs=new ArrayList<>();
}",0.6289308176100629
27290,"public void testIObjectBracketAccesses(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_INDEX_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_INDEX_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.BOTTOM_INDEX_TYPE,NewTypeInference.BOTTOM_INDEX_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS,NewTypeInference.MISTYPED_ASSIGN_RHS,NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.BOTTOM_INDEX_TYPE,NewTypeInference.BOTTOM_INDEX_TYPE);
}","public void testIObjectBracketAccesses(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_INDEX_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_INDEX_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.BOTTOM_INDEX_TYPE,NewTypeInference.BOTTOM_INDEX_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS,NewTypeInference.MISTYPED_ASSIGN_RHS,NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.BOTTOM_INDEX_TYPE,NewTypeInference.BOTTOM_INDEX_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.BOTTOM_INDEX_TYPE,NewTypeInference.BOTTOM_INDEX_TYPE);
}",0.9630331753554502
27291,"/** 
 * Updates the FunctionState object for the given function. Checks if the given function matches the criteria for an inlinable function.
 */
private void maybeAddFunction(Function fn,JSModule module){
  String name=fn.getName();
  FunctionState fs=getOrCreateFunctionState(name);
  if (fs.hasExistingFunctionDefinition()) {
    fs.setInline(false);
    return;
  }
  Node fnNode=fn.getFunctionNode();
  if (enforceMaxSizeAfterInlining && !isAlwaysInlinable(fnNode) && maxSizeAfterInlining <= NodeUtil.countAstSizeUpToLimit(fnNode,maxSizeAfterInlining)) {
    fs.setInline(false);
    return;
  }
  if (fs.canInline()) {
    fs.setFn(fn);
    if (FunctionInjector.isDirectCallNodeReplacementPossible(fn.getFunctionNode())) {
      fs.inlineDirectly(true);
    }
    if (!isCandidateFunction(fn)) {
      fs.setInline(false);
    }
    if (fs.canInline()) {
      fs.setModule(module);
      Set<String> namesToAlias=FunctionArgumentInjector.findModifiedParameters(fnNode);
      if (!namesToAlias.isEmpty()) {
        fs.inlineDirectly(false);
        fs.setNamesToAlias(namesToAlias);
      }
      Node block=NodeUtil.getFunctionBody(fnNode);
      if (NodeUtil.referencesThis(block)) {
        fs.setReferencesThis(true);
      }
      if (NodeUtil.containsFunction(block)) {
        fs.setHasInnerFunctions(true);
        if (!assumeMinimumCapture && hasLocalNames(fnNode) && !NodeUtil.isIIFE(fnNode)) {
          fs.setInline(false);
        }
      }
    }
    if (fs.canInline() && !fs.canInlineDirectly() && !blockFunctionInliningEnabled) {
      fs.setInline(false);
    }
  }
}","/** 
 * Updates the FunctionState object for the given function. Checks if the given function matches the criteria for an inlinable function.
 */
private void maybeAddFunction(Function fn,JSModule module){
  String name=fn.getName();
  FunctionState fs=getOrCreateFunctionState(name);
  if (fs.hasExistingFunctionDefinition()) {
    fs.setInline(false);
    return;
  }
  Node fnNode=fn.getFunctionNode();
  if (enforceMaxSizeAfterInlining && !isAlwaysInlinable(fnNode) && maxSizeAfterInlining <= NodeUtil.countAstSizeUpToLimit(fnNode,maxSizeAfterInlining)) {
    fs.setInline(false);
    return;
  }
  if (fs.canInline()) {
    fs.setFn(fn);
    if (FunctionInjector.isDirectCallNodeReplacementPossible(fn.getFunctionNode())) {
      fs.inlineDirectly(true);
    }
    if (!isCandidateFunction(fn)) {
      fs.setInline(false);
    }
    if (fs.canInline()) {
      fs.setModule(module);
      Set<String> namesToAlias=FunctionArgumentInjector.findModifiedParameters(fnNode);
      if (!namesToAlias.isEmpty()) {
        fs.inlineDirectly(false);
        fs.setNamesToAlias(namesToAlias);
      }
      Node block=NodeUtil.getFunctionBody(fnNode);
      if (NodeUtil.referencesThis(block)) {
        fs.setReferencesThis(true);
      }
      if (NodeUtil.containsFunction(block)) {
        fs.setHasInnerFunctions(true);
        if (!assumeMinimumCapture && hasLocalNames(fnNode)) {
          fs.setInline(false);
        }
      }
    }
    if (fs.canInline() && !fs.canInlineDirectly() && !blockFunctionInliningEnabled) {
      fs.setInline(false);
    }
  }
}",0.9270767279644896
27292,"public void testComplexFunctionWithFunctionDefinition2a(){
  assumeMinimumCapture=false;
  test(""String_Node_Str"",LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  assumeMinimumCapture=true;
  test(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"");
}","public void testComplexFunctionWithFunctionDefinition2a(){
  assumeMinimumCapture=false;
  testSame(""String_Node_Str"" + ""String_Node_Str"");
  assumeMinimumCapture=true;
  test(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"");
}",0.472027972027972
27293,"public void testShadowVariables16(){
  assumeMinimumCapture=false;
  test(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assumeMinimumCapture=true;
  test(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
}","public void testShadowVariables16(){
  assumeMinimumCapture=false;
  test(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
  assumeMinimumCapture=true;
  test(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
}",0.7342192691029901
27294,"public void testAnonymous3(){
  assumeMinimumCapture=false;
  test(""String_Node_Str"",""String_Node_Str"");
  assumeMinimumCapture=true;
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
}","public void testAnonymous3(){
  assumeMinimumCapture=false;
  testSame(""String_Node_Str"");
  assumeMinimumCapture=true;
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
}",0.6926605504587156
27295,"public void testAnonymous1(){
  assumeMinimumCapture=false;
  test(""String_Node_Str"",LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  assumeMinimumCapture=true;
  test(""String_Node_Str"",LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testAnonymous1(){
  assumeMinimumCapture=false;
  test(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  assumeMinimumCapture=true;
  test(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
}",0.3901098901098901
27296,"public void testShadowVariables7(){
  assumeMinimumCapture=false;
  test(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assumeMinimumCapture=true;
  test(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
}","public void testShadowVariables7(){
  assumeMinimumCapture=false;
  test(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
  assumeMinimumCapture=true;
  test(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
}",0.7333333333333333
27297,"public void testAddFunctionProperties3() throws Exception {
  String source=LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  String expected=""String_Node_Str"";
  CompilerOptions options=createCompilerOptions();
  CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
  options.setRenamingPolicy(VariableRenamingPolicy.OFF,PropertyRenamingPolicy.OFF);
  options.setCheckTypes(false);
  test(options,source,expected);
}","public void testAddFunctionProperties3() throws Exception {
  String source=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String expected=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
  CompilerOptions options=createCompilerOptions();
  CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
  options.setRenamingPolicy(VariableRenamingPolicy.OFF,PropertyRenamingPolicy.OFF);
  options.setCheckTypes(false);
  test(options,source,expected);
}",0.7276051188299817
27298,"public static MismatchInfo whyNotSubtypeOf(JSType t1,JSType t2){
  if (t1.isSingletonObj() && t2.isSingletonObj()) {
    MismatchInfo[] boxedInfo=new MismatchInfo[1];
    ObjectType.whyNotSubtypeOf(t1.getObjTypeIfSingletonObj(),t2.getObjTypeIfSingletonObj(),boxedInfo);
    return boxedInfo[0];
  }
  if (t1.isUnion()) {
    MismatchInfo[] boxedInfo=new MismatchInfo[1];
    boolean areSubtypes=t1.isSubtypeOfHelper(true,t2,SubtypeCache.create(),boxedInfo);
    Preconditions.checkState(!areSubtypes);
    return boxedInfo[0];
  }
  return null;
}","public static MismatchInfo whyNotSubtypeOf(JSType found,JSType expected){
  if (found.isSingletonObj() && expected.isSingletonObj()) {
    MismatchInfo[] boxedInfo=new MismatchInfo[1];
    ObjectType.whyNotSubtypeOf(found.getObjTypeIfSingletonObj(),expected.getObjTypeIfSingletonObj(),boxedInfo);
    return boxedInfo[0];
  }
  if (found.isUnion()) {
    MismatchInfo[] boxedInfo=new MismatchInfo[1];
    boolean areSubtypes=found.isSubtypeOfHelper(true,expected,SubtypeCache.create(),boxedInfo);
    Preconditions.checkState(!areSubtypes);
    return boxedInfo[0];
  }
  return null;
}",0.9338040600176524
27299,"private ObjectType withLoose(){
  if (isTopObject()) {
    return this.commonTypes.getLooseTopObjectType();
  }
  if (isLoose() || this.nominalType != null && this.nominalType.isClassy() || this.ns != null) {
    return this;
  }
  FunctionType fn=this.fn == null ? null : this.fn.withLoose();
  PersistentMap<String,Property> newProps=PersistentMap.create();
  for (  Map.Entry<String,Property> propsEntry : this.props.entrySet()) {
    String pname=propsEntry.getKey();
    Property prop=propsEntry.getValue();
    newProps=newProps.with(pname,prop.withRequired());
  }
  return new ObjectType(this.commonTypes,this.nominalType,newProps,fn,null,true,this.objectKind);
}","private ObjectType withLoose(){
  if (isTopObject()) {
    return this.commonTypes.getLooseTopObjectType();
  }
  if (isLoose() || (!this.nominalType.isBuiltinObject() && !this.nominalType.isFunction()) || this.ns != null) {
    return this;
  }
  FunctionType fn=this.fn == null ? null : this.fn.withLoose();
  PersistentMap<String,Property> newProps=PersistentMap.create();
  for (  Map.Entry<String,Property> propsEntry : this.props.entrySet()) {
    String pname=propsEntry.getKey();
    Property prop=propsEntry.getValue();
    newProps=newProps.with(pname,prop.withRequired());
  }
  return new ObjectType(this.commonTypes,this.nominalType,newProps,fn,null,true,this.objectKind);
}",0.2253313696612665
27300,"private ObjectType(JSTypes commonTypes,NominalType nominalType,PersistentMap<String,Property> props,FunctionType fn,Namespace ns,boolean isLoose,ObjectKind objectKind){
  Preconditions.checkNotNull(commonTypes);
  Preconditions.checkNotNull(nominalType);
  Preconditions.checkArgument(fn == null || fn.isQmarkFunction() || fn.isLoose() == isLoose,""String_Node_Str"",isLoose,fn);
  Preconditions.checkArgument(FunctionType.isInhabitable(fn));
  if (ns != null) {
    String name=nominalType.getName();
    Preconditions.checkArgument(name.equals(JSTypes.OBJLIT_CLASS_NAME) || name.equals(""String_Node_Str"") || name.equals(""String_Node_Str""),""String_Node_Str"",name);
  }
  Preconditions.checkArgument(!nominalType.isClassy() || !isLoose,""String_Node_Str"",nominalType);
  Preconditions.checkArgument(fn == null || nominalType.isFunction(),""String_Node_Str"",nominalType,fn);
  this.commonTypes=commonTypes;
  this.nominalType=nominalType;
  this.props=isLoose ? loosenProps(props) : props;
  this.fn=fn;
  this.ns=ns;
  this.isLoose=isLoose;
  this.objectKind=isLoose ? ObjectKind.UNRESTRICTED : objectKind;
}","private ObjectType(JSTypes commonTypes,NominalType nominalType,PersistentMap<String,Property> props,FunctionType fn,Namespace ns,boolean isLoose,ObjectKind objectKind){
  Preconditions.checkNotNull(commonTypes);
  Preconditions.checkNotNull(nominalType);
  Preconditions.checkArgument(fn == null || fn.isQmarkFunction() || fn.isLoose() == isLoose,""String_Node_Str"",isLoose,fn);
  Preconditions.checkArgument(FunctionType.isInhabitable(fn));
  if (ns != null) {
    String name=nominalType.getName();
    Preconditions.checkArgument(name.equals(JSTypes.OBJLIT_CLASS_NAME) || name.equals(""String_Node_Str"") || name.equals(""String_Node_Str""),""String_Node_Str"",name);
  }
  if (isLoose) {
    Preconditions.checkArgument(nominalType.isBuiltinObject() || nominalType.isFunction(),""String_Node_Str"",nominalType);
  }
  Preconditions.checkArgument(fn == null || nominalType.isFunction(),""String_Node_Str"",nominalType,fn);
  this.commonTypes=commonTypes;
  this.nominalType=nominalType;
  this.props=isLoose ? loosenProps(props) : props;
  this.fn=fn;
  this.ns=ns;
  this.isLoose=isLoose;
  this.objectKind=isLoose ? ObjectKind.UNRESTRICTED : objectKind;
}",0.6542387927208166
27301,"StringBuilder appendTo(StringBuilder builder){
  if (isPrototypeObject()) {
    return builder.append(getOwnerFunction().getThisType()).append(""String_Node_Str"");
  }
  if (!hasNonPrototypeProperties()) {
    if (fn != null) {
      return fn.appendTo(builder);
    }
 else     if (this.nominalType != null) {
      return this.nominalType.appendTo(builder);
    }
  }
  if (!nominalType.getName().equals(""String_Node_Str"") && !nominalType.getName().equals(""String_Node_Str"") && !nominalType.getName().equals(JSTypes.OBJLIT_CLASS_NAME)) {
    nominalType.appendTo(builder);
  }
 else   if (isStruct()) {
    builder.append(""String_Node_Str"");
  }
 else   if (isDict()) {
    builder.append(""String_Node_Str"");
  }
 else   if (this.ns != null) {
    builder.append(this.ns);
  }
  if (this.fn != null) {
    builder.append(""String_Node_Str"");
    fn.appendTo(builder);
    builder.append(""String_Node_Str"");
  }
  if (ns == null || !props.isEmpty()) {
    builder.append('{');
    boolean firstIteration=true;
    for (    String pname : new TreeSet<>(props.keySet())) {
      if (firstIteration) {
        firstIteration=false;
      }
 else {
        builder.append(""String_Node_Str"");
      }
      builder.append(pname);
      builder.append(':');
      props.get(pname).appendTo(builder);
    }
    builder.append('}');
  }
  if (isLoose) {
    builder.append(""String_Node_Str"");
  }
  return builder;
}","StringBuilder appendTo(StringBuilder builder){
  if (isPrototypeObject()) {
    return builder.append(getOwnerFunction().getThisType()).append(""String_Node_Str"");
  }
  if (!hasNonPrototypeProperties()) {
    if (fn != null) {
      return fn.appendTo(builder);
    }
    return this.nominalType.appendTo(builder);
  }
  if (!nominalType.getName().equals(""String_Node_Str"") && !nominalType.getName().equals(""String_Node_Str"") && !nominalType.getName().equals(JSTypes.OBJLIT_CLASS_NAME)) {
    nominalType.appendTo(builder);
  }
 else   if (isStruct()) {
    builder.append(""String_Node_Str"");
  }
 else   if (isDict()) {
    builder.append(""String_Node_Str"");
  }
 else   if (this.ns != null) {
    builder.append(this.ns);
  }
  if (this.fn != null) {
    builder.append(""String_Node_Str"");
    fn.appendTo(builder);
    builder.append(""String_Node_Str"");
  }
  if (ns == null || !props.isEmpty()) {
    builder.append('{');
    boolean firstIteration=true;
    for (    String pname : new TreeSet<>(props.keySet())) {
      if (firstIteration) {
        firstIteration=false;
      }
 else {
        builder.append(""String_Node_Str"");
      }
      builder.append(pname);
      builder.append(':');
      props.get(pname).appendTo(builder);
    }
    builder.append('}');
  }
  if (isLoose) {
    builder.append(""String_Node_Str"");
  }
  return builder;
}",0.9609261939218524
27302,"private Property getLeftmostProp(QualifiedName qname){
  String pname=qname.getLeftmostName();
  Property p=props.get(pname);
  if (p != null) {
    return p;
  }
  if (this.ns != null) {
    p=this.ns.getNsProp(pname);
    if (p != null) {
      return p;
    }
  }
  if (this.nominalType != null) {
    return this.nominalType.getProp(pname);
  }
  if (this.commonTypes.getObjectType() != null) {
    return this.commonTypes.getObjectType().getProp(pname);
  }
  return null;
}","private Property getLeftmostProp(QualifiedName qname){
  String pname=qname.getLeftmostName();
  Property p=props.get(pname);
  if (p != null) {
    return p;
  }
  if (this.ns != null) {
    p=this.ns.getNsProp(pname);
    if (p != null) {
      return p;
    }
  }
  return this.nominalType.getProp(pname);
}",0.7249683143219265
27303,"static void whyNotSubtypeOf(ObjectType obj1,ObjectType obj2,MismatchInfo[] boxedInfo){
  Preconditions.checkArgument(boxedInfo.length == 1);
  boolean areSubtypes=obj1.isSubtypeOfHelper(true,obj2,SubtypeCache.create(),boxedInfo);
  Preconditions.checkState(!areSubtypes);
}","static void whyNotSubtypeOf(ObjectType obj1,ObjectType obj2,MismatchInfo[] boxedInfo){
  Preconditions.checkArgument(boxedInfo.length == 1);
  boolean areSubtypes=obj1.isSubtypeOfHelper(true,obj2,SubtypeCache.create(),boxedInfo);
  Preconditions.checkState(!areSubtypes,""String_Node_Str"",obj1,obj2);
}",0.951219512195122
27304,"boolean isInterfaceInstance(){
  return this.nominalType != null && this.nominalType.isInterface();
}","boolean isInterfaceInstance(){
  return this.nominalType.isInterface();
}",0.8390804597701149
27305,"static ObjectType meet(ObjectType obj1,ObjectType obj2){
  Preconditions.checkState(areRelatedNominalTypes(obj1.nominalType,obj2.nominalType));
  if (obj1.isTopObject() || obj2.isBottomObject()) {
    return obj2;
  }
 else   if (obj2.isTopObject() || obj1.isBottomObject()) {
    return obj1;
  }
  JSTypes commonTypes=obj1.commonTypes;
  NominalType resultNomType=NominalType.pickSubclass(obj1.nominalType,obj2.nominalType);
  FunctionType fn=FunctionType.meet(obj1.fn,obj2.fn);
  if (!FunctionType.isInhabitable(fn)) {
    return commonTypes.getBottomObject();
  }
  boolean isLoose=obj1.isLoose && obj2.isLoose || fn != null && fn.isLoose();
  if (resultNomType.isFunction() && fn == null) {
    fn=obj1.fn == null ? obj2.fn : obj1.fn;
    isLoose=fn.isLoose();
  }
  PersistentMap<String,Property> props;
  if (isLoose) {
    props=joinPropsLoosely(commonTypes,obj1.props,obj2.props);
  }
 else {
    props=meetPropsHelper(commonTypes,false,resultNomType,obj1.props,obj2.props);
  }
  if (props == commonTypes.BOTTOM_PROPERTY_MAP) {
    return commonTypes.getBottomObject();
  }
  ObjectKind ok=ObjectKind.meet(obj1.objectKind,obj2.objectKind);
  Namespace resultNs=Objects.equals(obj1.ns,obj2.ns) ? obj1.ns : null;
  return new ObjectType(commonTypes,resultNomType,props,fn,resultNs,isLoose,ok);
}","static ObjectType meet(ObjectType obj1,ObjectType obj2){
  Preconditions.checkState(areRelatedNominalTypes(obj1.nominalType,obj2.nominalType));
  if (obj1.isTopObject() || obj2.isBottomObject()) {
    return obj2;
  }
 else   if (obj2.isTopObject() || obj1.isBottomObject()) {
    return obj1;
  }
  JSTypes commonTypes=obj1.commonTypes;
  NominalType resultNomType=NominalType.pickSubclass(obj1.nominalType,obj2.nominalType);
  FunctionType fn=FunctionType.meet(obj1.fn,obj2.fn);
  if (!FunctionType.isInhabitable(fn)) {
    return commonTypes.getBottomObject();
  }
  boolean isLoose=(obj1.isLoose && obj2.isLoose) || fn != null && fn.isLoose();
  if (resultNomType.isFunction() && fn == null) {
    fn=obj1.fn == null ? obj2.fn : obj1.fn;
    isLoose=fn.isLoose();
  }
  PersistentMap<String,Property> props;
  if (isLoose) {
    props=joinPropsLoosely(commonTypes,obj1.props,obj2.props);
  }
 else {
    props=meetPropsHelper(commonTypes,false,resultNomType,obj1.props,obj2.props);
  }
  if (props == commonTypes.BOTTOM_PROPERTY_MAP) {
    return commonTypes.getBottomObject();
  }
  ObjectKind ok=ObjectKind.meet(obj1.objectKind,obj2.objectKind);
  Namespace resultNs=Objects.equals(obj1.ns,obj2.ns) ? obj1.ns : null;
  return new ObjectType(commonTypes,resultNomType,props,fn,resultNs,isLoose,ok);
}",0.9992331288343558
27306,"ObjectType specialize(ObjectType other){
  Preconditions.checkState(areRelatedNominalTypes(this.nominalType,other.nominalType));
  if (isTopObject() && other.objectKind.isUnrestricted()) {
    return other;
  }
  if (this.ns != null) {
    return specializeNamespace(other);
  }
  NominalType resultNomType;
  if (this.nominalType.isBuiltinObject() && other.nominalType.isStructuralInterface()) {
    resultNomType=this.nominalType;
  }
 else {
    resultNomType=NominalType.pickSubclass(this.nominalType,other.nominalType);
  }
  if (resultNomType.isClassy()) {
    Preconditions.checkState(this.fn == null && other.fn == null);
    PersistentMap<String,Property> newProps=meetPropsHelper(this.commonTypes,true,resultNomType,this.props,other.props);
    if (newProps == this.commonTypes.BOTTOM_PROPERTY_MAP) {
      return this.commonTypes.getBottomObject();
    }
    return new ObjectType(this.commonTypes,resultNomType,newProps,null,this.ns,false,this.objectKind);
  }
  FunctionType thisFn=this.fn;
  boolean isLoose=this.isLoose;
  if (resultNomType.isFunction() && this.fn == null) {
    thisFn=other.fn;
    isLoose=other.fn.isLoose();
  }
  PersistentMap<String,Property> newProps=meetPropsHelper(this.commonTypes,true,resultNomType,this.props,other.props);
  if (newProps == this.commonTypes.BOTTOM_PROPERTY_MAP) {
    return this.commonTypes.getBottomObject();
  }
  FunctionType newFn=thisFn == null ? null : thisFn.specialize(other.fn);
  if (!FunctionType.isInhabitable(newFn)) {
    return this.commonTypes.getBottomObject();
  }
  return new ObjectType(this.commonTypes,resultNomType,newProps,newFn,this.ns,isLoose,this.objectKind);
}","ObjectType specialize(ObjectType other){
  Preconditions.checkState(areRelatedNominalTypes(this.nominalType,other.nominalType));
  if (isTopObject() && other.objectKind.isUnrestricted()) {
    return other;
  }
  if (this.ns != null) {
    return specializeNamespace(other);
  }
  NominalType resultNomType;
  if (this.nominalType.isBuiltinObject() && other.nominalType.isStructuralInterface()) {
    resultNomType=this.nominalType;
  }
 else {
    resultNomType=NominalType.pickSubclass(this.nominalType,other.nominalType);
  }
  if (resultNomType.isClassy()) {
    Preconditions.checkState(this.fn == null && other.fn == null);
    PersistentMap<String,Property> newProps=meetPropsHelper(this.commonTypes,true,resultNomType,this.props,other.props);
    if (newProps == this.commonTypes.BOTTOM_PROPERTY_MAP) {
      return this.commonTypes.getBottomObject();
    }
    return new ObjectType(this.commonTypes,resultNomType,newProps,null,this.ns,false,this.objectKind);
  }
  FunctionType thisFn=this.fn;
  boolean isLoose=this.isLoose;
  if (resultNomType.isFunction() && this.fn == null) {
    thisFn=other.fn;
    isLoose=other.fn.isLoose();
  }
  if (isLoose && resultNomType.isLiteralObject()) {
    resultNomType=this.commonTypes.getObjectType();
  }
  PersistentMap<String,Property> newProps=meetPropsHelper(this.commonTypes,true,resultNomType,this.props,other.props);
  if (newProps == this.commonTypes.BOTTOM_PROPERTY_MAP) {
    return this.commonTypes.getBottomObject();
  }
  FunctionType newFn=thisFn == null ? null : thisFn.specialize(other.fn);
  if (!FunctionType.isInhabitable(newFn)) {
    return this.commonTypes.getBottomObject();
  }
  return new ObjectType(this.commonTypes,resultNomType,newProps,newFn,this.ns,isLoose,this.objectKind);
}",0.9683098591549296
27307,"/** 
 * We don't use the requiredType of the context to unify with the return type. There are several difficulties: 1) A polymorphic function is allowed to return ANY subtype of the requiredType, so we would need to use a heuristic to determine the type to unify with. 2) It's hard to give good error messages in cases like: id('str') - 5 We want an invalid-operand-type, not a not-unique-instantiation. We don't take the arg evaluation order into account during instantiation. When calculating the instantiation, when do we use the receiver type? See the following snippet: / * @constructor * @template T * @param {T} x * / function Foo(x) {} / * @template T * @param {T} x * / Foo.prototype.f = function(x) {}; Foo.prototype.f.bind(new Foo(123), 'asdf'); Here, the receiver type of f is Foo<T>, but the T is the class's T, not the T of f's template declaration. OTOH, if f had a @this annotation that contained T, T would refer to f's T. There is no way of knowing what's the scope of the type variables in the receiver of the function type. But when THIS comes from the class, it is always a singleton object. So, we use a heuristic: if THIS is not a singleton obj, we know it comes from and we use it for the instantiation.
 */
private ImmutableMap<String,JSType> calcTypeInstantiation(Node callNode,Node receiver,Node firstArg,FunctionType funType,TypeEnv typeEnv,boolean isFwd){
  Preconditions.checkState(receiver == null || isFwd);
  List<String> typeParameters=funType.getTypeParameters();
  Multimap<String,JSType> typeMultimap=LinkedHashMultimap.create();
  JSType funRecvType=funType.getThisType();
  if (receiver != null && funRecvType != null && !funRecvType.isSingletonObj()) {
    EnvTypePair pair=analyzeExprFwd(receiver,typeEnv);
    unifyWithSubtypeWarnIfFail(funRecvType,pair.type,typeParameters,typeMultimap,receiver,isFwd);
    typeEnv=pair.env;
  }
  Node arg=firstArg;
  int i=0;
  while (arg != null) {
    EnvTypePair pair=isFwd ? analyzeExprFwd(arg,typeEnv) : analyzeExprBwd(arg,typeEnv);
    unifyWithSubtypeWarnIfFail(funType.getFormalType(i),pair.type,typeParameters,typeMultimap,arg,isFwd);
    arg=arg.getNext();
    typeEnv=pair.env;
    i++;
  }
  ImmutableMap.Builder<String,JSType> builder=ImmutableMap.builder();
  for (  String typeParam : typeParameters) {
    Collection<JSType> types=typeMultimap.get(typeParam);
    if (types.size() > 1) {
      if (isFwd) {
        warnings.add(JSError.make(callNode,NOT_UNIQUE_INSTANTIATION,Integer.toString(types.size()),UniqueNameGenerator.getOriginalName(typeParam),types.toString(),funType.toString()));
      }
      if (joinTypesWhenInstantiatingGenerics) {
        JSType joinedType=BOTTOM;
        for (        JSType t : types) {
          joinedType=JSType.join(joinedType,t);
        }
        builder.put(typeParam,joinedType);
      }
 else {
        builder.put(typeParam,UNKNOWN);
      }
    }
 else     if (types.size() == 1) {
      JSType t=Iterables.getOnlyElement(types);
      builder.put(typeParam,t.isBottom() ? UNKNOWN : t);
    }
 else {
      builder.put(typeParam,UNKNOWN);
    }
  }
  return builder.build();
}","/** 
 * We don't use the requiredType of the context to unify with the return type. There are several difficulties: 1) A polymorphic function is allowed to return ANY subtype of the requiredType, so we would need to use a heuristic to determine the type to unify with. 2) It's hard to give good error messages in cases like: id('str') - 5 We want an invalid-operand-type, not a not-unique-instantiation. We don't take the arg evaluation order into account during instantiation. When calculating the instantiation, when do we use the receiver type? See the following snippet: / * @constructor * @template T * @param {T} x * / function Foo(x) {} / * @template T * @param {T} x * / Foo.prototype.f = function(x) {}; Foo.prototype.f.bind(new Foo(123), 'asdf'); Here, the receiver type of f is Foo<T>, but the T is the class's T, not the T of f's template declaration. OTOH, if f had a @this annotation that contained T, T would refer to f's T. There is no way of knowing what's the scope of the type variables in the receiver of the function type. But when THIS comes from the class, it is always a singleton object. So, we use a heuristic: if THIS is not a singleton obj, we know it comes from and we use it for the instantiation.
 */
private ImmutableMap<String,JSType> calcTypeInstantiation(Node callNode,Node receiver,Node firstArg,FunctionType funType,TypeEnv typeEnv,boolean isFwd){
  Preconditions.checkState(receiver == null || isFwd);
  List<String> typeParameters=funType.getTypeParameters();
  Multimap<String,JSType> typeMultimap=LinkedHashMultimap.create();
  JSType funRecvType=funType.getThisType();
  if (receiver != null && funRecvType != null && !funRecvType.isSingletonObj()) {
    JSType recvType=(JSType)receiver.getTypeI();
    if (recvType == null) {
      EnvTypePair pair=analyzeExprFwd(receiver,typeEnv);
      recvType=pair.type;
      typeEnv=pair.env;
    }
    unifyWithSubtypeWarnIfFail(funRecvType,recvType,typeParameters,typeMultimap,receiver,isFwd);
  }
  Node arg=firstArg;
  int i=0;
  while (arg != null) {
    EnvTypePair pair=isFwd ? analyzeExprFwd(arg,typeEnv) : analyzeExprBwd(arg,typeEnv);
    unifyWithSubtypeWarnIfFail(funType.getFormalType(i),pair.type,typeParameters,typeMultimap,arg,isFwd);
    arg=arg.getNext();
    typeEnv=pair.env;
    i++;
  }
  ImmutableMap.Builder<String,JSType> builder=ImmutableMap.builder();
  for (  String typeParam : typeParameters) {
    Collection<JSType> types=typeMultimap.get(typeParam);
    if (types.size() > 1) {
      if (isFwd) {
        warnings.add(JSError.make(callNode,NOT_UNIQUE_INSTANTIATION,Integer.toString(types.size()),UniqueNameGenerator.getOriginalName(typeParam),types.toString(),funType.toString()));
      }
      if (joinTypesWhenInstantiatingGenerics) {
        JSType joinedType=BOTTOM;
        for (        JSType t : types) {
          joinedType=JSType.join(joinedType,t);
        }
        builder.put(typeParam,joinedType);
      }
 else {
        builder.put(typeParam,UNKNOWN);
      }
    }
 else     if (types.size() == 1) {
      JSType t=Iterables.getOnlyElement(types);
      builder.put(typeParam,t.isBottom() ? UNKNOWN : t);
    }
 else {
      builder.put(typeParam,UNKNOWN);
    }
  }
  return builder.build();
}",0.973526630948629
27308,"private EnvTypePair analyzeCallNewFwd(Node expr,TypeEnv inEnv,JSType requiredType,JSType specializedType){
  if (isPropertyTestCall(expr)) {
    return analyzePropertyTestCallFwd(expr,inEnv,specializedType);
  }
  Node callee=expr.getFirstChild();
  if (isFunctionBind(callee,inEnv,true)) {
    return analyzeFunctionBindFwd(expr,inEnv);
  }
  AssertionFunctionSpec assertionFunctionSpec=assertionFunctionsMap.get(callee.getQualifiedName());
  if (assertionFunctionSpec != null) {
    return analyzeAssertionCall(expr,inEnv,assertionFunctionSpec);
  }
  EnvTypePair calleePair=analyzeExprFwd(callee,inEnv,commonTypes.topFunction());
  TypeEnv envAfterCallee=calleePair.env;
  calleePair=mayWarnAboutNullableReferenceAndTighten(callee,calleePair.type,null,envAfterCallee);
  JSType calleeType=calleePair.type;
  if (calleeType.isBottom() || !calleeType.isSubtypeOf(commonTypes.topFunction())) {
    warnings.add(JSError.make(expr,NOT_CALLABLE,calleeType.toString()));
  }
  FunctionType funType=calleeType.getFunTypeIfSingletonObj();
  if (funType == null || funType.isTopFunction() || funType.isQmarkFunction()) {
    return analyzeCallNodeArgsFwdWhenError(expr,envAfterCallee);
  }
 else   if (funType.isLoose()) {
    return analyzeLooseCallNodeFwd(expr,envAfterCallee,requiredType);
  }
 else   if (!isConstructorCall(expr) && funType.isSomeConstructorOrInterface() && (funType.getReturnType().isUnknown() || funType.getReturnType().isUndefined())) {
    warnings.add(JSError.make(expr,CONSTRUCTOR_NOT_CALLABLE,funType.toString()));
    return analyzeCallNodeArgsFwdWhenError(expr,envAfterCallee);
  }
 else   if (expr.isNew()) {
    if (!funType.isSomeConstructorOrInterface() || funType.isInterfaceDefinition()) {
      warnings.add(JSError.make(expr,NOT_A_CONSTRUCTOR,funType.toString()));
      return analyzeCallNodeArgsFwdWhenError(expr,envAfterCallee);
    }
 else     if (funType.isConstructorOfAbstractClass()) {
      warnings.add(JSError.make(expr,CANNOT_INSTANTIATE_ABSTRACT_CLASS,funType.toString()));
      return analyzeCallNodeArgsFwdWhenError(expr,envAfterCallee);
    }
  }
  int maxArity=funType.getMaxArity();
  int minArity=funType.getMinArity();
  int numArgs=expr.getChildCount() - 1;
  if (numArgs < minArity || numArgs > maxArity) {
    warnings.add(JSError.make(expr,WRONG_ARGUMENT_COUNT,getReadableCalleeName(callee),Integer.toString(numArgs),Integer.toString(minArity),""String_Node_Str"" + maxArity));
    return analyzeCallNodeArgsFwdWhenError(expr,envAfterCallee);
  }
  FunctionType origFunType=funType;
  if (funType.isGeneric()) {
    Map<String,JSType> typeMap=calcTypeInstantiationFwd(expr,callee.isGetProp() ? callee.getFirstChild() : null,expr.getSecondChild(),funType,envAfterCallee);
    funType=funType.instantiateGenerics(typeMap);
    println(""String_Node_Str"" + funType);
  }
  List<JSType> argTypes=new ArrayList<>();
  TypeEnv tmpEnv=analyzeCallNodeArgumentsFwd(expr,expr.getSecondChild(),funType,argTypes,envAfterCallee);
  if (callee.isName()) {
    String calleeName=callee.getString();
    if (currentScope.isKnownFunction(calleeName) && !currentScope.isExternalFunction(calleeName)) {
      if (currentScope.isLocalFunDef(calleeName)) {
        tmpEnv=collectTypesForFreeVarsFwd(callee,tmpEnv);
      }
 else       if (!origFunType.isGeneric()) {
        JSType expectedRetType=requiredType;
        println(""String_Node_Str"",expectedRetType,""String_Node_Str"",argTypes);
        DeferredCheck dc;
        if (isConstructorCall(expr)) {
          dc=new DeferredCheck(expr,null,currentScope,currentScope.getScope(calleeName));
          deferredChecks.put(expr,dc);
        }
 else {
          dc=deferredChecks.get(expr);
          if (dc != null) {
            dc.updateReturn(expectedRetType);
          }
 else {
            Preconditions.checkState(!currentScope.hasUndeclaredFormalsOrOuters(),""String_Node_Str"",expr);
          }
        }
        if (dc != null) {
          dc.updateArgTypes(argTypes);
        }
      }
    }
  }
  JSType retType=expr.isNew() ? funType.getThisType() : funType.getReturnType();
  if (retType.isSubtypeOf(requiredType)) {
    retType=retType.specialize(specializedType);
  }
  return new EnvTypePair(tmpEnv,retType);
}","private EnvTypePair analyzeCallNewFwd(Node expr,TypeEnv inEnv,JSType requiredType,JSType specializedType){
  if (isPropertyTestCall(expr)) {
    return analyzePropertyTestCallFwd(expr,inEnv,specializedType);
  }
  Node callee=expr.getFirstChild();
  if (isFunctionBind(callee,inEnv,true)) {
    return analyzeFunctionBindFwd(expr,inEnv);
  }
  AssertionFunctionSpec assertionFunctionSpec=assertionFunctionsMap.get(callee.getQualifiedName());
  if (assertionFunctionSpec != null) {
    return analyzeAssertionCall(expr,inEnv,assertionFunctionSpec);
  }
  EnvTypePair calleePair=analyzeExprFwd(callee,inEnv,commonTypes.topFunction());
  TypeEnv envAfterCallee=calleePair.env;
  calleePair=mayWarnAboutNullableReferenceAndTighten(callee,calleePair.type,null,envAfterCallee);
  JSType calleeType=calleePair.type;
  if (calleeType.isBottom() || !calleeType.isSubtypeOf(commonTypes.topFunction())) {
    warnings.add(JSError.make(expr,NOT_CALLABLE,calleeType.toString()));
  }
  FunctionType funType=calleeType.getFunTypeIfSingletonObj();
  if (funType == null || funType.isTopFunction() || funType.isQmarkFunction()) {
    return analyzeCallNodeArgsFwdWhenError(expr,envAfterCallee);
  }
 else   if (funType.isLoose()) {
    return analyzeLooseCallNodeFwd(expr,envAfterCallee,requiredType);
  }
 else   if (!isConstructorCall(expr) && funType.isSomeConstructorOrInterface() && (funType.getReturnType().isUnknown() || funType.getReturnType().isUndefined())) {
    warnings.add(JSError.make(expr,CONSTRUCTOR_NOT_CALLABLE,funType.toString()));
    return analyzeCallNodeArgsFwdWhenError(expr,envAfterCallee);
  }
 else   if (expr.isNew()) {
    if (!funType.isSomeConstructorOrInterface() || funType.isInterfaceDefinition()) {
      warnings.add(JSError.make(expr,NOT_A_CONSTRUCTOR,funType.toString()));
      return analyzeCallNodeArgsFwdWhenError(expr,envAfterCallee);
    }
 else     if (funType.isConstructorOfAbstractClass()) {
      warnings.add(JSError.make(expr,CANNOT_INSTANTIATE_ABSTRACT_CLASS,funType.toString()));
      return analyzeCallNodeArgsFwdWhenError(expr,envAfterCallee);
    }
  }
  int maxArity=funType.getMaxArity();
  int minArity=funType.getMinArity();
  int numArgs=expr.getChildCount() - 1;
  if (numArgs < minArity || numArgs > maxArity) {
    warnings.add(JSError.make(expr,WRONG_ARGUMENT_COUNT,getReadableCalleeName(callee),Integer.toString(numArgs),Integer.toString(minArity),""String_Node_Str"" + maxArity));
    return analyzeCallNodeArgsFwdWhenError(expr,envAfterCallee);
  }
  FunctionType origFunType=funType;
  if (funType.isGeneric()) {
    Map<String,JSType> typeMap=calcTypeInstantiationFwd(expr,callee.isGetProp() ? callee.getFirstChild() : null,expr.getSecondChild(),funType,envAfterCallee);
    funType=funType.instantiateGenerics(typeMap);
    println(""String_Node_Str"",funType);
  }
  List<JSType> argTypes=new ArrayList<>();
  TypeEnv tmpEnv=analyzeCallNodeArgumentsFwd(expr,expr.getSecondChild(),funType,argTypes,envAfterCallee);
  if (callee.isName()) {
    String calleeName=callee.getString();
    if (currentScope.isKnownFunction(calleeName) && !currentScope.isExternalFunction(calleeName)) {
      if (currentScope.isLocalFunDef(calleeName)) {
        tmpEnv=collectTypesForFreeVarsFwd(callee,tmpEnv);
      }
 else       if (!origFunType.isGeneric()) {
        JSType expectedRetType=requiredType;
        println(""String_Node_Str"",expectedRetType,""String_Node_Str"",argTypes);
        DeferredCheck dc;
        if (isConstructorCall(expr)) {
          dc=new DeferredCheck(expr,null,currentScope,currentScope.getScope(calleeName));
          deferredChecks.put(expr,dc);
        }
 else {
          dc=deferredChecks.get(expr);
          if (dc != null) {
            dc.updateReturn(expectedRetType);
          }
 else {
            Preconditions.checkState(!currentScope.hasUndeclaredFormalsOrOuters(),""String_Node_Str"",expr);
          }
        }
        if (dc != null) {
          dc.updateArgTypes(argTypes);
        }
      }
    }
  }
  JSType retType=expr.isNew() ? funType.getThisType() : funType.getReturnType();
  if (retType.isSubtypeOf(requiredType)) {
    retType=retType.specialize(specializedType);
  }
  return new EnvTypePair(tmpEnv,retType);
}",0.9995248277500594
27309,"private static JSType joinNominalTypes(JSType nt1,JSType nt2){
  if (nt1 == null || nt2 == null) {
    return null;
  }
  NominalType n1=getNominalTypeIfSingletonObj(nt1);
  NominalType n2=getNominalTypeIfSingletonObj(nt2);
  if (n1 != null && n2 != null) {
    NominalType tmp=NominalType.pickSuperclass(n1,n2);
    if (tmp != null) {
      return tmp.getInstanceAsJSType();
    }
  }
  return JSType.join(nt1,nt2);
}","private static JSType joinNominalTypes(JSType nt1,JSType nt2){
  if (nt1 == null || nt2 == null) {
    return null;
  }
  NominalType n1=getNominalTypeIfSingletonObj(nt1);
  NominalType n2=getNominalTypeIfSingletonObj(nt2);
  if (n1 != null && n2 != null) {
    NominalType tmp=NominalType.join(n1,n2);
    if (tmp != null) {
      return tmp.getInstanceAsJSType();
    }
  }
  return JSType.join(nt1,nt2);
}",0.9782082324455206
27310,"static ObjectType join(ObjectType obj1,ObjectType obj2){
  if (obj1.isTopObject() || obj2.isTopObject()) {
    return obj1.commonTypes.getTopObjectType();
  }
  if (obj1.equals(obj2)) {
    return obj1;
  }
  NominalType nt1=obj1.nominalType;
  NominalType nt2=obj2.nominalType;
  Preconditions.checkState(nt1.isRawSubtypeOf(nt2) || nt2.isRawSubtypeOf(nt1));
  JSTypes commonTypes=obj1.commonTypes;
  boolean isLoose=obj1.isLoose || obj2.isLoose;
  FunctionType fn=FunctionType.join(obj1.fn,obj2.fn);
  PersistentMap<String,Property> props;
  if (isLoose) {
    fn=fn == null ? null : fn.withLoose();
    props=joinPropsLoosely(commonTypes,obj1.props,obj2.props);
  }
 else {
    props=joinProps(obj1.props,obj2.props,nt1,nt2);
  }
  NominalType nominal=NominalType.pickSuperclass(nt1,nt2);
  if (nominal.isBuiltinObject() && fn != null) {
    if (isLoose) {
      nominal=obj1.commonTypes.getFunctionType();
    }
 else {
      fn=null;
    }
  }
  Namespace ns=Objects.equals(obj1.ns,obj2.ns) ? obj1.ns : null;
  return makeObjectType(commonTypes,nominal,props,fn,ns,isLoose,ObjectKind.join(obj1.objectKind,obj2.objectKind));
}","static ObjectType join(ObjectType obj1,ObjectType obj2){
  if (obj1.isTopObject() || obj2.isTopObject()) {
    return obj1.commonTypes.getTopObjectType();
  }
  if (obj1.equals(obj2)) {
    return obj1;
  }
  NominalType nt1=obj1.nominalType;
  NominalType nt2=obj2.nominalType;
  Preconditions.checkState(nt1.isRawSubtypeOf(nt2) || nt2.isRawSubtypeOf(nt1));
  JSTypes commonTypes=obj1.commonTypes;
  boolean isLoose=obj1.isLoose || obj2.isLoose;
  FunctionType fn=FunctionType.join(obj1.fn,obj2.fn);
  PersistentMap<String,Property> props;
  if (isLoose) {
    fn=fn == null ? null : fn.withLoose();
    props=joinPropsLoosely(commonTypes,obj1.props,obj2.props);
  }
 else {
    props=joinProps(obj1.props,obj2.props,nt1,nt2);
  }
  NominalType nominal=NominalType.join(nt1,nt2);
  if (nominal.isBuiltinObject() && fn != null) {
    if (isLoose) {
      nominal=obj1.commonTypes.getFunctionType();
    }
 else {
      fn=null;
    }
  }
  Namespace ns=Objects.equals(obj1.ns,obj2.ns) ? obj1.ns : null;
  return makeObjectType(commonTypes,nominal,props,fn,ns,isLoose,ObjectKind.join(obj1.objectKind,obj2.objectKind));
}",0.9919928825622776
27311,"public void testOnlyOneInstanceOfEachClassInUnion(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testOnlyOneInstanceOfEachClassInUnion(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.8380545163014431
27312,"private JSType evalTemplateTypeOf(Node ttlAst,NameResolver nameResolver){
  ImmutableList<Node> params=getCallParams(ttlAst);
  JSType type=evalInternal(params.get(0),nameResolver);
  if (!type.isTemplatizedType()) {
    reportWarning(ttlAst,TEMPTYPE_INVALID,""String_Node_Str"",type.toString());
    return getUnknownType();
  }
  int index=(int)params.get(1).getDouble();
  ImmutableList<JSType> templateTypes=((TemplatizedType)type).getTemplateTypes();
  if (index > templateTypes.size()) {
    reportWarning(ttlAst,INDEX_OUTOFBOUNDS,Integer.toString(index),Integer.toString(templateTypes.size()));
    return getUnknownType();
  }
  return templateTypes.get(index);
}","private JSType evalTemplateTypeOf(Node ttlAst,NameResolver nameResolver){
  ImmutableList<Node> params=getCallParams(ttlAst);
  JSType type=evalInternal(params.get(0),nameResolver);
  if (!type.isTemplatizedType()) {
    reportWarning(ttlAst,TEMPTYPE_INVALID,""String_Node_Str"",type.toString());
    return getUnknownType();
  }
  int index=(int)params.get(1).getDouble();
  ImmutableList<JSType> templateTypes=((TemplatizedType)type).getTemplateTypes();
  if (index >= templateTypes.size()) {
    reportWarning(ttlAst,INDEX_OUTOFBOUNDS,Integer.toString(index),Integer.toString(templateTypes.size()));
    return getUnknownType();
  }
  return templateTypes.get(index);
}",0.9992531740104555
27313,"/** 
 * This may start a new line if the current line is longer than the line length threshold.
 */
@Override void maybeCutLine(){
  if (lineLength > lineLengthThreshold) {
    if (preferredBreakPosition > lineStartPosition && preferredBreakPosition < lineStartPosition + lineLength) {
      int position=preferredBreakPosition;
      code.insert(position,'\n');
      prevCutPosition=position;
      reportLineCut(lineIndex,position - lineStartPosition,true);
      lineIndex++;
      lineLength-=(position - lineStartPosition);
      lineStartPosition=position + 1;
    }
 else {
      startNewLine();
    }
  }
}","/** 
 * This may start a new line if the current line is longer than the line length threshold.
 */
@Override void maybeCutLine(){
  if (lineLength > lineLengthThreshold) {
    if (preferredBreakPosition > lineStartPosition && preferredBreakPosition < lineStartPosition + lineLength) {
      int position=preferredBreakPosition;
      code.insert(position,'\n');
      prevCutPosition=position;
      reportLineCut(lineIndex,position - lineStartPosition,true);
      lineIndex++;
      lineLength-=(position - lineStartPosition);
      prevLineStartPosition=lineStartPosition;
      lineStartPosition=position + 1;
    }
 else {
      startNewLine();
    }
  }
}",0.9631949882537196
27314,"@Override void endFile(){
  super.endFile();
  if (!preferLineBreakAtEndOfFile) {
    return;
  }
  if (lineLength > lineLengthThreshold / 2) {
    append(""String_Node_Str"");
    startNewLine();
  }
 else   if (prevCutPosition > 0) {
    code.setCharAt(prevCutPosition,' ');
    lineStartPosition=prevLineStartPosition;
    lineLength=code.length() - lineStartPosition;
    reportLineCut(lineIndex,prevCutPosition + 1,false);
    lineIndex--;
    prevCutPosition=0;
    prevLineStartPosition=0;
    append(""String_Node_Str"");
    startNewLine();
  }
 else {
  }
}","@Override void endFile(){
  super.endFile();
  if (!preferLineBreakAtEndOfFile) {
    return;
  }
  if (lineLength > lineLengthThreshold / 2) {
    append(""String_Node_Str"");
    startNewLine();
  }
 else   if (prevCutPosition > 0) {
    code.setCharAt(prevCutPosition,' ');
    lineStartPosition=prevLineStartPosition;
    lineLength=code.length() - lineStartPosition;
    int prevLineEndPosition=prevCutPosition - prevLineStartPosition + 1;
    reportLineCut(lineIndex,prevLineEndPosition,false);
    lineIndex--;
    prevCutPosition=0;
    prevLineStartPosition=0;
    append(""String_Node_Str"");
    startNewLine();
  }
 else {
  }
}",0.8974145120934112
27315,"/** 
 * Converts a tree to JS code
 */
private static String toSource(Node root,Format outputFormat,CompilerOptions options,SourceMap sourceMap,boolean tagAsExterns,boolean tagAsStrict,boolean lineBreak,CodeGeneratorFactory codeGeneratorFactory){
  Preconditions.checkState(options.sourceMapDetailLevel != null);
  boolean createSourceMap=(sourceMap != null);
  MappedCodePrinter mcp=outputFormat == Format.COMPACT ? new CompactCodePrinter(lineBreak,options.preferLineBreakAtEndOfFile,options.lineLengthThreshold,createSourceMap,options.sourceMapDetailLevel) : new PrettyCodePrinter(options.lineLengthThreshold,createSourceMap,options.sourceMapDetailLevel);
  CodeGenerator cg=codeGeneratorFactory.getCodeGenerator(outputFormat,mcp);
  if (tagAsExterns) {
    cg.tagAsExterns();
  }
  if (tagAsStrict) {
    cg.tagAsStrict();
  }
  cg.add(root);
  mcp.endFile();
  String code=mcp.getCode();
  if (createSourceMap) {
    mcp.generateSourceMap(sourceMap);
  }
  return code;
}","/** 
 * Converts a tree to JS code
 */
private static String toSource(Node root,Format outputFormat,CompilerOptions options,SourceMap sourceMap,boolean tagAsExterns,boolean tagAsStrict,boolean lineBreak,CodeGeneratorFactory codeGeneratorFactory){
  Preconditions.checkState(options.sourceMapDetailLevel != null);
  boolean createSourceMap=(sourceMap != null);
  MappedCodePrinter mcp=outputFormat == Format.COMPACT ? new CompactCodePrinter(lineBreak,options.preferLineBreakAtEndOfFile,options.lineLengthThreshold,createSourceMap,options.sourceMapDetailLevel) : new PrettyCodePrinter(options.lineLengthThreshold,createSourceMap,options.sourceMapDetailLevel);
  CodeGenerator cg=codeGeneratorFactory.getCodeGenerator(outputFormat,mcp);
  if (tagAsExterns) {
    cg.tagAsExterns();
  }
  if (tagAsStrict) {
    cg.tagAsStrict();
  }
  cg.add(root);
  mcp.endFile();
  String code=mcp.getCode();
  if (createSourceMap) {
    mcp.generateSourceMap(code,sourceMap);
  }
  return code;
}",0.9974424552429668
27316,"/** 
 * Generates the source map from the given code consumer, appending the information it saved to the SourceMap object given.
 */
void generateSourceMap(SourceMap map){
  if (createSrcMap) {
    for (    Mapping mapping : allMappings) {
      map.addMapping(mapping.node,mapping.start,mapping.end);
    }
  }
}","/** 
 * Generates the source map from the given code consumer, appending the information it saved to the SourceMap object given.
 */
void generateSourceMap(String code,SourceMap map){
  if (createSrcMap) {
    List<Integer> lineLengths=computeLineLengths(code);
    for (    Mapping mapping : allMappings) {
      map.addMapping(mapping.node,mapping.start,adjustEndPosition(lineLengths,mapping.end));
    }
  }
}",0.863448275862069
27317,"/** 
 * Invalidates the given type, so that no properties on it will be renamed.
 */
private void recordInvalidatingType(JSType type,JSError error){
  type=type.restrictByNotNullOrUndefined();
  if (type.isUnionType()) {
    for (    JSType alt : type.toMaybeUnionType().getAlternatesWithoutStructuralTyping()) {
      recordInvalidatingType(alt,error);
    }
  }
 else   if (type.isEnumElementType()) {
    recordInvalidatingType(type.toMaybeEnumElementType().getPrimitiveType(),error);
  }
 else {
    addInvalidatingType(type);
    recordInvalidationError(type,error);
    ObjectType objType=ObjectType.cast(type);
    if (objType != null && objType.getImplicitPrototype() != null) {
      addInvalidatingType(objType.getImplicitPrototype());
      recordInvalidationError(objType.getImplicitPrototype(),error);
    }
    if (objType != null && objType.isConstructor() && objType.isFunctionType()) {
      addInvalidatingType(objType.toMaybeFunctionType().getInstanceType());
    }
  }
}","/** 
 * Invalidates the given type, so that no properties on it will be renamed.
 */
private void recordInvalidatingType(JSType type,TypeMismatch mis){
  type=type.restrictByNotNullOrUndefined();
  if (type.isUnionType()) {
    for (    JSType alt : type.toMaybeUnionType().getAlternatesWithoutStructuralTyping()) {
      recordInvalidatingType(alt,mis);
    }
  }
 else   if (type.isEnumElementType()) {
    recordInvalidatingType(type.toMaybeEnumElementType().getPrimitiveType(),mis);
  }
 else {
    addInvalidatingType(type);
    recordInvalidationError(type,mis);
    ObjectType objType=ObjectType.cast(type);
    if (objType != null && objType.getImplicitPrototype() != null) {
      addInvalidatingType(objType.getImplicitPrototype());
      recordInvalidationError(objType.getImplicitPrototype(),mis);
    }
    if (objType != null && objType.isConstructor() && objType.isFunctionType()) {
      addInvalidatingType(objType.toMaybeFunctionType().getInstanceType());
    }
  }
}",0.5762025316455697
27318,"@Override public void process(Node externs,Node root){
  Preconditions.checkState(compiler.getLifeCycleStage() == LifeCycleStage.NORMALIZED);
  this.ancestorInterfaces=new HashMap<>();
  this.gtwpCache=new HashMap<>();
  for (  TypeMismatch mis : compiler.getTypeMismatches()) {
    recordInvalidatingType(mis.typeA,mis.src);
    recordInvalidatingType(mis.typeB,mis.src);
  }
  for (  TypeMismatch mis : compiler.getImplicitInterfaceUses()) {
    recordInvalidatingType(mis.typeA,mis.src);
    recordInvalidatingType(mis.typeB,mis.src);
  }
  NodeTraversal.traverseEs6(compiler,externs,new FindExternProperties());
  NodeTraversal.traverseEs6(compiler,root,new FindRenameableProperties());
  renameProperties();
}","@Override public void process(Node externs,Node root){
  Preconditions.checkState(compiler.getLifeCycleStage() == LifeCycleStage.NORMALIZED);
  this.ancestorInterfaces=new HashMap<>();
  this.gtwpCache=new HashMap<>();
  for (  TypeMismatch mis : compiler.getTypeMismatches()) {
    recordInvalidatingType(mis.typeA,mis);
    recordInvalidatingType(mis.typeB,mis);
  }
  for (  TypeMismatch mis : compiler.getImplicitInterfaceUses()) {
    recordInvalidatingType(mis.typeA,mis);
    recordInvalidatingType(mis.typeB,mis);
  }
  NodeTraversal.traverseEs6(compiler,externs,new FindExternProperties());
  NodeTraversal.traverseEs6(compiler,root,new FindRenameableProperties());
  renameProperties();
}",0.9886685552407932
27319,"private void recordInvalidationError(JSType t,JSError error){
  if (!t.isObject()) {
    return;
  }
  if (invalidationMap != null) {
    Collection<JSError> errors=this.invalidationMap.get(t);
    if (errors.size() < MAX_INVALIDATION_WARNINGS_PER_PROPERTY) {
      errors.add(error);
    }
  }
}","private void recordInvalidationError(JSType t,TypeMismatch mis){
  if (!t.isObject()) {
    return;
  }
  if (invalidationMap != null) {
    Collection<JSError> errors=this.invalidationMap.get(t);
    if (errors.size() < MAX_INVALIDATION_WARNINGS_PER_PROPERTY) {
      JSError error=mis.src;
      if (error.getType().equals(TypeValidator.TYPE_MISMATCH_WARNING) && error.description.isEmpty()) {
        String msg=""String_Node_Str"" + mis.typeA + ""String_Node_Str""+ mis.typeB;
        error=JSError.make(error.node,TypeValidator.TYPE_MISMATCH_WARNING,msg);
      }
      errors.add(error);
    }
  }
}",0.5930880713489409
27320,"private void recordImplicitInterfaceUses(Node src,JSType sourceType,JSType targetType){
  sourceType=removeNullUndefinedAndTemplates(sourceType);
  targetType=removeNullUndefinedAndTemplates(targetType);
  boolean strictMismatch=!sourceType.isSubtypeWithoutStructuralTyping(targetType) && !targetType.isSubtypeWithoutStructuralTyping(sourceType);
  boolean mismatch=!sourceType.isSubtype(targetType) && !targetType.isSubtype(sourceType);
  if (strictMismatch || mismatch) {
    String msg;
    if (numImplicitUses < 10) {
      msg=""String_Node_Str"" + sourceType + ""String_Node_Str""+ targetType;
    }
 else {
      msg=""String_Node_Str"";
    }
    numImplicitUses++;
    JSError err=JSError.make(src,TYPE_MISMATCH_WARNING,msg);
    implicitInterfaceUses.add(new TypeMismatch(sourceType,targetType,err));
  }
}","private void recordImplicitInterfaceUses(Node src,JSType sourceType,JSType targetType){
  sourceType=removeNullUndefinedAndTemplates(sourceType);
  targetType=removeNullUndefinedAndTemplates(targetType);
  boolean strictMismatch=!sourceType.isSubtypeWithoutStructuralTyping(targetType) && !targetType.isSubtypeWithoutStructuralTyping(sourceType);
  boolean mismatch=!sourceType.isSubtype(targetType) && !targetType.isSubtype(sourceType);
  if (strictMismatch || mismatch) {
    JSError err=JSError.make(src,TYPE_MISMATCH_WARNING,""String_Node_Str"");
    implicitInterfaceUses.add(new TypeMismatch(sourceType,targetType,err));
  }
}",0.8513888888888889
27321,"@Override SourceFile getSourceFileByName(String sourceName){
  if (sourceName != null) {
    CompilerInput input=inputsById.get(new InputId(sourceName));
    if (input != null) {
      return input.getSourceFile();
    }
    return sourceMapOriginalSources.get(sourceName);
  }
  return null;
}","@Override public SourceFile getSourceFileByName(String sourceName){
  if (sourceName != null) {
    CompilerInput input=inputsById.get(new InputId(sourceName));
    if (input != null) {
      return input.getSourceFile();
    }
    return sourceMapOriginalSources.get(sourceName);
  }
  return null;
}",0.9882352941176472
27322,"/** 
 * Applies the provided set of code replacements to the code and returns the transformed code. The code replacements may not have any overlap.
 */
public static String applyCodeReplacements(Iterable<CodeReplacement> replacements,String code){
  List<CodeReplacement> sortedReplacements=ORDER_CODE_REPLACEMENTS.sortedCopy(replacements);
  validateNoOverlaps(sortedReplacements);
  StringBuilder sb=new StringBuilder();
  int lastIndex=0;
  for (  CodeReplacement replacement : sortedReplacements) {
    sb.append(code,lastIndex,replacement.getStartPosition());
    sb.append(replacement.getNewContent());
    lastIndex=replacement.getStartPosition() + replacement.getLength();
  }
  if (lastIndex <= code.length()) {
    sb.append(code,lastIndex,code.length());
  }
  return sb.toString();
}","/** 
 * Applies the provided set of code replacements to the code and returns the transformed code. The code replacements may not have any overlap.
 */
public static String applyCodeReplacements(Iterable<CodeReplacement> replacements,String code){
  List<CodeReplacement> sortedReplacements=ORDER_CODE_REPLACEMENTS.sortedCopy(replacements);
  validateNoOverlaps(sortedReplacements);
  StringBuilder sb=new StringBuilder();
  int lastIndex=0;
  for (  CodeReplacement replacement : sortedReplacements) {
    sb.append(code,lastIndex,replacement.getStartPosition());
    sb.append(replacement.getNewContent());
    lastIndex=replacement.getEndPosition();
  }
  if (lastIndex <= code.length()) {
    sb.append(code,lastIndex,code.length());
  }
  return sb.toString();
}",0.9782330345710628
27323,"/** 
 * Checks whether the CodeReplacements have any overlap. The replacements must be provided in order sorted by start position, as sorted by ORDER_CODE_REPLACEMENTS.
 */
private static boolean containsOverlaps(List<CodeReplacement> replacements){
  Preconditions.checkState(ORDER_CODE_REPLACEMENTS.isOrdered(replacements));
  int start=-1;
  for (  CodeReplacement replacement : replacements) {
    if (replacement.getStartPosition() < start) {
      return true;
    }
    start=Math.max(start,replacement.getStartPosition() + replacement.getLength());
  }
  return false;
}","/** 
 * Checks whether the CodeReplacements have any overlap. The replacements must be provided in order sorted by start position, as sorted by ORDER_CODE_REPLACEMENTS.
 */
private static boolean containsOverlaps(List<CodeReplacement> replacements){
  Preconditions.checkState(ORDER_CODE_REPLACEMENTS.isOrdered(replacements));
  int start=-1;
  for (  CodeReplacement replacement : replacements) {
    if (replacement.getStartPosition() < start) {
      return true;
    }
    start=Math.max(start,replacement.getEndPosition());
  }
  return false;
}",0.9698581560283688
27324,"/** 
 * Returns how many bytes the new content should replace in the original content.
 */
public int getLength(){
  return length;
}","/** 
 * Returns how many characters the new content should replace in the original content.
 */
public int getLength(){
  return length;
}",0.966789667896679
27325,"public DeclaredFunctionType withTypeInfoFromSuper(DeclaredFunctionType superType,boolean getsTypeInfoFromParentMethod){
  if (getsTypeInfoFromParentMethod && getSyntacticArity() == superType.getSyntacticArity()) {
    NominalType nt=superType.nominalType == null ? null : superType.nominalType.getNominalTypeIfSingletonObj();
    NominalType rt=this.receiverType == null ? null : this.receiverType.getNominalTypeIfSingletonObj();
    return new DeclaredFunctionType(this.commonTypes,superType.requiredFormals,superType.optionalFormals,superType.restFormals,superType.returnType,nt == null ? null : nt.getInstanceAsJSType(),rt == null ? null : rt.getInstanceAsJSType(),superType.typeParameters,false);
  }
  FunctionTypeBuilder builder=new FunctionTypeBuilder(this.commonTypes);
  int i=0;
  for (  JSType formal : this.requiredFormals) {
    builder.addReqFormal(formal != null ? formal : superType.getFormalType(i));
    i++;
  }
  for (  JSType formal : this.optionalFormals) {
    builder.addOptFormal(formal != null ? formal : superType.getFormalType(i));
    i++;
  }
  if (this.restFormals != null) {
    builder.addRestFormals(this.restFormals);
  }
 else   if (superType.hasRestFormals()) {
    builder.addRestFormals(superType.restFormals);
  }
  builder.addRetType(this.returnType != null ? this.returnType : superType.returnType);
  builder.addNominalType(this.nominalType);
  builder.addReceiverType(this.receiverType);
  if (!this.typeParameters.isEmpty()) {
    builder.addTypeParameters(this.typeParameters);
  }
 else   if (!superType.typeParameters.isEmpty()) {
    builder.addTypeParameters(superType.typeParameters);
  }
  return builder.buildDeclaration();
}","public DeclaredFunctionType withTypeInfoFromSuper(DeclaredFunctionType superType,boolean getsTypeInfoFromParentMethod){
  if (getsTypeInfoFromParentMethod && getSyntacticArity() == superType.getSyntacticArity()) {
    NominalType nt=superType.nominalType == null ? null : superType.nominalType.getNominalTypeIfSingletonObj();
    NominalType rt=this.receiverType == null ? null : this.receiverType.getNominalTypeIfSingletonObj();
    return new DeclaredFunctionType(this.commonTypes,superType.requiredFormals,superType.optionalFormals,superType.restFormals,superType.returnType,nt == null ? null : nt.getInstanceAsJSType(),rt == null ? null : rt.getInstanceAsJSType(),superType.typeParameters,false);
  }
  FunctionTypeBuilder builder=new FunctionTypeBuilder(this.commonTypes);
  int i=0;
  for (  JSType formal : this.requiredFormals) {
    builder.addReqFormal(formal != null ? formal : superType.getFormalType(i));
    i++;
  }
  for (  JSType formal : this.optionalFormals) {
    builder.addOptFormal(formal != null ? formal : superType.getFormalType(i));
    i++;
  }
  if (this.restFormals != null) {
    builder.addRestFormals(this.restFormals);
  }
 else   if (superType.hasRestFormals()) {
    builder.addRestFormals(superType.restFormals);
  }
  builder.addRetType(this.returnType != null ? this.returnType : superType.returnType);
  builder.addNominalType(this.nominalType);
  builder.addReceiverType(this.receiverType);
  if (!this.typeParameters.isEmpty()) {
    builder.addTypeParameters(this.typeParameters);
  }
 else   if (!superType.typeParameters.isEmpty()) {
    builder.addTypeParameters(superType.typeParameters);
  }
  builder.addAbstract(this.isAbstract);
  return builder.buildDeclaration();
}",0.988221436984688
27326,"public void testAbstractDeclarations(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.CANNOT_INSTANTIATE_ABSTRACT_CLASS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.ABSTRACT_METHOD_IN_CONCRETE_CLASS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.ABSTRACT_METHOD_IN_INTERFACE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.ABSTRACT_METHOD_NOT_IMPLEMENTED_IN_CONCRETE_CLASS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.ABSTRACT_METHOD_NOT_IMPLEMENTED_IN_CONCRETE_CLASS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.INTERFACE_METHOD_NOT_IMPLEMENTED);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testAbstractDeclarations(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.CANNOT_INSTANTIATE_ABSTRACT_CLASS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.ABSTRACT_METHOD_IN_CONCRETE_CLASS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.ABSTRACT_METHOD_IN_INTERFACE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.ABSTRACT_METHOD_NOT_IMPLEMENTED_IN_CONCRETE_CLASS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.ABSTRACT_METHOD_NOT_IMPLEMENTED_IN_CONCRETE_CLASS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.INTERFACE_METHOD_NOT_IMPLEMENTED);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.9345646437994723
27327,"/** 
 * Returns the type in the chain from the given type that contains the given field or null if it is not found anywhere. Can return a subtype of the input type.
 */
@VisibleForTesting ObjectType getTypeWithProperty(String field,JSType type){
  if (type == null) {
    return null;
  }
  ObjectType foundType=gtwpCacheGet(field,type);
  if (foundType != null) {
    return foundType.equals(BOTTOM_OBJECT) ? null : foundType;
  }
  if (type.isEnumElementType()) {
    foundType=getTypeWithProperty(field,type.toMaybeEnumElementType().getPrimitiveType());
    gtwpCachePut(field,type,foundType == null ? BOTTOM_OBJECT : foundType);
    return foundType;
  }
  if (!(type instanceof ObjectType)) {
    if (type.autoboxesTo() != null) {
      foundType=getTypeWithProperty(field,type.autoboxesTo());
      gtwpCachePut(field,type,foundType == null ? BOTTOM_OBJECT : foundType);
      return foundType;
    }
 else {
      gtwpCachePut(field,type,BOTTOM_OBJECT);
      return null;
    }
  }
  if (""String_Node_Str"".equals(field)) {
    gtwpCachePut(field,type,BOTTOM_OBJECT);
    return null;
  }
  ObjectType objType=ObjectType.cast(type);
  if (objType != null && objType.getConstructor() != null && objType.getConstructor().isInterface()) {
    ObjectType topInterface=FunctionType.getTopDefiningInterface(objType,field);
    if (topInterface != null && topInterface.getConstructor() != null) {
      foundType=topInterface.getConstructor().getPrototype();
    }
  }
 else {
    while (objType != null && !Objects.equals(objType.getImplicitPrototype(),objType)) {
      if (objType.hasOwnProperty(field)) {
        foundType=objType;
      }
      objType=objType.getImplicitPrototype();
    }
  }
  if (foundType == null) {
    ObjectType maybeType=ObjectType.cast(registry.getGreatestSubtypeWithProperty(type,field));
    if (maybeType != null && maybeType.hasOwnProperty(field)) {
      foundType=maybeType;
    }
  }
  if (foundType != null && foundType.isTemplatizedType()) {
    foundType=foundType.toMaybeTemplatizedType().getReferencedType();
  }
  if (foundType != null && foundType.isNamedType()) {
    foundType=foundType.toMaybeNamedType().getReferencedType().toMaybeObjectType();
  }
  gtwpCachePut(field,type,foundType == null ? BOTTOM_OBJECT : foundType);
  return foundType;
}","/** 
 * Returns the type in the chain from the given type that contains the given field or null if it is not found anywhere. Can return a subtype of the input type.
 */
private ObjectType getTypeWithProperty(String field,JSType type){
  if (type == null) {
    return null;
  }
  ObjectType foundType=gtwpCacheGet(field,type);
  if (foundType != null) {
    return foundType.equals(BOTTOM_OBJECT) ? null : foundType;
  }
  if (type.isEnumElementType()) {
    foundType=getTypeWithProperty(field,type.toMaybeEnumElementType().getPrimitiveType());
    gtwpCachePut(field,type,foundType == null ? BOTTOM_OBJECT : foundType);
    return foundType;
  }
  if (!(type instanceof ObjectType)) {
    if (type.autoboxesTo() != null) {
      foundType=getTypeWithProperty(field,type.autoboxesTo());
      gtwpCachePut(field,type,foundType == null ? BOTTOM_OBJECT : foundType);
      return foundType;
    }
 else {
      gtwpCachePut(field,type,BOTTOM_OBJECT);
      return null;
    }
  }
  if (""String_Node_Str"".equals(field)) {
    gtwpCachePut(field,type,BOTTOM_OBJECT);
    return null;
  }
  ObjectType objType=ObjectType.cast(type);
  if (objType != null && objType.getConstructor() != null && objType.getConstructor().isInterface()) {
    ObjectType topInterface=FunctionType.getTopDefiningInterface(objType,field);
    if (topInterface != null && topInterface.getConstructor() != null) {
      foundType=topInterface.getConstructor().getPrototype();
    }
  }
 else {
    while (objType != null && !Objects.equals(objType.getImplicitPrototype(),objType)) {
      if (objType.hasOwnProperty(field)) {
        foundType=objType;
      }
      objType=objType.getImplicitPrototype();
    }
  }
  if (foundType == null) {
    ObjectType maybeType=ObjectType.cast(registry.getGreatestSubtypeWithProperty(type,field));
    if (maybeType != null && maybeType.hasOwnProperty(field)) {
      foundType=maybeType;
    }
  }
  if (foundType != null && foundType.isTemplatizedType()) {
    foundType=foundType.toMaybeTemplatizedType().getReferencedType();
  }
  if (foundType != null && foundType.isNamedType()) {
    foundType=foundType.toMaybeNamedType().getReferencedType().toMaybeObjectType();
  }
  gtwpCachePut(field,type,foundType == null ? BOTTOM_OBJECT : foundType);
  return foundType;
}",0.994537906925934
27328,"/** 
 * Records that this property could be referenced from any interface that this type, or any type in its superclass chain, implements. If the property p is defined only on a subtype of constructor, then this method has no effect. But we tried modifying getTypeWithProperty to tell us when the returned type is a subtype, and then skip those calls to recordInterface, and there was no speed-up. And it made the code harder to understand, so we don't do it.
 */
private void recordInterfaces(FunctionType constructor,JSType relatedType,DisambiguateProperties.Property p){
  Preconditions.checkArgument(constructor.isConstructor());
  Iterable<ObjectType> interfaces=implementedInterfaces.get(constructor);
  if (interfaces == null) {
    interfaces=constructor.getImplementedInterfaces();
    implementedInterfaces.put(constructor,interfaces);
  }
  for (  ObjectType itype : interfaces) {
    JSType top=getTypeWithProperty(p.name,itype);
    if (top != null) {
      p.addType(itype,relatedType);
    }
    if (p.skipRenaming) {
      return;
    }
  }
}","/** 
 * Records that this property could be referenced from any interface that this type inherits from. If the property p is defined only on a subtype of constructor, then this method has no effect. But we tried modifying getTypeWithProperty to tell us when the returned type is a subtype, and then skip those calls to recordInterface, and there was no speed-up. And it made the code harder to understand, so we don't do it.
 */
private void recordInterfaces(FunctionType constructor,JSType relatedType,Property p){
  Iterable<ObjectType> interfaces=ancestorInterfaces.get(constructor);
  if (interfaces == null) {
    interfaces=constructor.isConstructor() ? constructor.getImplementedInterfaces() : constructor.getExtendedInterfaces();
    ancestorInterfaces.put(constructor,interfaces);
  }
  for (  ObjectType itype : interfaces) {
    JSType top=getTypeWithProperty(p.name,itype);
    if (top != null) {
      p.addType(itype,relatedType);
    }
    if (p.skipRenaming) {
      return;
    }
  }
}",0.8786407766990292
27329,"@Override public void process(Node externs,Node root){
  Preconditions.checkState(compiler.getLifeCycleStage() == LifeCycleStage.NORMALIZED);
  this.implementedInterfaces=new HashMap<>();
  this.gtwpCache=new HashMap<>();
  for (  TypeMismatch mis : compiler.getTypeMismatches()) {
    recordInvalidatingType(mis.typeA,mis.src);
    recordInvalidatingType(mis.typeB,mis.src);
  }
  for (  TypeMismatch mis : compiler.getImplicitInterfaceUses()) {
    recordInvalidatingType(mis.typeA,mis.src);
    recordInvalidatingType(mis.typeB,mis.src);
  }
  NodeTraversal.traverseEs6(compiler,externs,new FindExternProperties());
  NodeTraversal.traverseEs6(compiler,root,new FindRenameableProperties());
  renameProperties();
}","@Override public void process(Node externs,Node root){
  Preconditions.checkState(compiler.getLifeCycleStage() == LifeCycleStage.NORMALIZED);
  this.ancestorInterfaces=new HashMap<>();
  this.gtwpCache=new HashMap<>();
  for (  TypeMismatch mis : compiler.getTypeMismatches()) {
    recordInvalidatingType(mis.typeA,mis.src);
    recordInvalidatingType(mis.typeB,mis.src);
  }
  for (  TypeMismatch mis : compiler.getImplicitInterfaceUses()) {
    recordInvalidatingType(mis.typeA,mis.src);
    recordInvalidatingType(mis.typeB,mis.src);
  }
  NodeTraversal.traverseEs6(compiler,externs,new FindExternProperties());
  NodeTraversal.traverseEs6(compiler,root,new FindRenameableProperties());
  renameProperties();
}",0.986722571628232
27330,"private FunctionType getConstructor(JSType type){
  ObjectType objType=ObjectType.cast(type);
  if (objType == null) {
    return null;
  }
  FunctionType constructor=null;
  if (objType.isFunctionType()) {
    constructor=objType.toMaybeFunctionType();
  }
 else   if (objType.isFunctionPrototypeType()) {
    constructor=objType.getOwnerFunction();
  }
 else {
    constructor=objType.getConstructor();
  }
  return constructor != null && constructor.isConstructor() ? constructor : null;
}","private FunctionType getConstructor(JSType type){
  ObjectType objType=ObjectType.cast(type);
  if (objType == null) {
    return null;
  }
  FunctionType constructor=null;
  if (objType.isFunctionType()) {
    constructor=objType.toMaybeFunctionType();
  }
 else   if (objType.isFunctionPrototypeType()) {
    constructor=objType.getOwnerFunction();
  }
 else {
    constructor=objType.getConstructor();
  }
  return constructor;
}",0.935064935064935
27331,"/** 
 * Returns the alternatives if this is a type that represents multiple types, and null if not. Union and interface types can correspond to multiple other types.
 */
private Iterable<JSType> getTypeAlternatives(JSType type){
  if (type.isUnionType()) {
    return type.toMaybeUnionType().getAlternatesWithoutStructuralTyping();
  }
 else {
    ObjectType objType=type.toObjectType();
    if (objType != null && objType.getConstructor() != null && objType.getConstructor().isInterface()) {
      List<JSType> list=new ArrayList<>();
      for (      FunctionType impl : registry.getDirectImplementors(objType)) {
        list.add(impl.getInstanceType());
      }
      return list;
    }
 else {
      return null;
    }
  }
}","/** 
 * Returns the alternatives if this is a type that represents multiple types, and null if not. Union and interface types can correspond to multiple other types.
 */
private Iterable<JSType> getTypeAlternatives(JSType type){
  if (type.isUnionType()) {
    return type.toMaybeUnionType().getAlternatesWithoutStructuralTyping();
  }
 else {
    ObjectType objType=type.toObjectType();
    if (objType != null && objType.getConstructor() != null && objType.getConstructor().isInterface()) {
      List<JSType> list=new ArrayList<>();
      for (      FunctionType impl : registry.getDirectImplementors(objType)) {
        list.add(impl.getInstanceType());
      }
      return list.isEmpty() ? null : list;
    }
 else {
      return null;
    }
  }
}",0.9838056680161944
27332,"/** 
 * Traverse a node and its children and remove any references to from the structures.
 */
void removeReferences(Node node){
  if (DefinitionsRemover.isDefinitionNode(node)) {
    DefinitionSite defSite=definitionNodeByDefinitionSite.get(node);
    if (defSite != null) {
      Definition def=defSite.definition;
      String name=getSimplifiedName(def.getLValue());
      if (name != null) {
        this.definitionNodeByDefinitionSite.remove(node);
        this.nameDefinitionMultimap.remove(name,node);
      }
    }
  }
 else {
    Node useSite=node;
    if (useSite.isGetProp()) {
      String propName=useSite.getLastChild().getString();
      if (propName.equals(""String_Node_Str"") || propName.equals(""String_Node_Str"")) {
        useSite=useSite.getFirstChild();
      }
    }
    String name=getSimplifiedName(useSite);
    if (name != null) {
      this.nameUseSiteMultimap.remove(name,new UseSite(useSite,null,null));
    }
  }
  for (  Node child : node.children()) {
    removeReferences(child);
  }
}","/** 
 * Traverse a node and its children and remove any references to from the structures.
 */
void removeReferences(Node node){
  if (DefinitionsRemover.isDefinitionNode(node)) {
    DefinitionSite defSite=definitionNodeByDefinitionSite.get(node);
    if (defSite != null) {
      Definition def=defSite.definition;
      String name=getSimplifiedName(def.getLValue());
      if (name != null) {
        this.definitionNodeByDefinitionSite.remove(node);
        this.nameDefinitionMultimap.remove(name,def);
      }
    }
  }
 else {
    Node useSite=node;
    if (useSite.isGetProp()) {
      String propName=useSite.getLastChild().getString();
      if (propName.equals(""String_Node_Str"") || propName.equals(""String_Node_Str"")) {
        useSite=useSite.getFirstChild();
      }
    }
    String name=getSimplifiedName(useSite);
    if (name != null) {
      this.nameUseSiteMultimap.remove(name,new UseSite(useSite,null,null));
    }
  }
  for (  Node child : node.children()) {
    removeReferences(child);
  }
}",0.9965601965601966
27333,"private void maybeRecordNominalType(Node defSite,Node nameNode,JSDocInfo fnDoc,boolean isRedeclaration){
  Preconditions.checkState(nameNode == null || nameNode.isQualifiedName());
  if (fnDoc == null) {
    return;
  }
  if (fnDoc.isConstructorOrInterface()) {
    if (nameNode == null) {
      warnings.add(JSError.make(defSite,ANONYMOUS_NOMINAL_TYPE));
      nameNode=IR.name(ANON_FUN_PREFIX + funNameGen.generateNextName());
      nameNode.useSourceInfoFrom(defSite);
    }
    String qname=nameNode.getQualifiedName();
    ImmutableList.Builder<String> builder=ImmutableList.builder();
    for (    String typeParam : fnDoc.getTemplateTypeNames()) {
      builder.add(varNameGen.getNextName(typeParam));
    }
    ImmutableList<String> typeParameters=builder.build();
    RawNominalType rawType;
    if (fnDoc.usesImplicitMatch()) {
      rawType=RawNominalType.makeStructuralInterface(commonTypes,defSite,qname,typeParameters);
    }
 else     if (fnDoc.isInterface()) {
      rawType=RawNominalType.makeNominalInterface(commonTypes,defSite,qname,typeParameters);
    }
 else     if (fnDoc.makesStructs()) {
      rawType=RawNominalType.makeStructClass(commonTypes,defSite,qname,typeParameters);
    }
 else     if (fnDoc.makesDicts()) {
      rawType=RawNominalType.makeDictClass(commonTypes,defSite,qname,typeParameters);
    }
 else {
      rawType=RawNominalType.makeUnrestrictedClass(commonTypes,defSite,qname,typeParameters);
    }
    nominaltypesByNode.put(defSite,rawType);
    if (isRedeclaration) {
      return;
    }
    Node firstChild=nameNode.getFirstChild();
    if (nameNode.isName() || currentScope.isNamespace(firstChild) || mayCreateFunctionNamespace(firstChild)|| mayCreateWindowNamespace(firstChild)) {
      if (nameNode.isGetProp()) {
        defSite.getParent().getFirstChild().putBooleanProp(Node.ANALYZED_DURING_GTI,true);
      }
 else       if (currentScope.isTopLevel()) {
        maybeRecordBuiltinType(qname,rawType);
      }
      currentScope.addNamespace(nameNode,rawType);
    }
  }
 else   if (fnDoc.makesStructs()) {
    warnings.add(JSError.make(defSite,STRUCTDICT_WITHOUT_CTOR,""String_Node_Str""));
  }
 else   if (fnDoc.makesDicts()) {
    warnings.add(JSError.make(defSite,STRUCTDICT_WITHOUT_CTOR,""String_Node_Str""));
  }
}","private void maybeRecordNominalType(Node defSite,Node nameNode,JSDocInfo fnDoc,boolean isRedeclaration){
  Preconditions.checkState(nameNode == null || nameNode.isQualifiedName());
  if (fnDoc == null) {
    return;
  }
  if (fnDoc.isConstructorOrInterface()) {
    if (nameNode == null) {
      warnings.add(JSError.make(defSite,ANONYMOUS_NOMINAL_TYPE));
      nameNode=IR.name(ANON_FUN_PREFIX + funNameGen.generateNextName());
      nameNode.useSourceInfoFrom(defSite);
    }
    String qname=nameNode.getQualifiedName();
    ImmutableList.Builder<String> builder=ImmutableList.builder();
    for (    String typeParam : fnDoc.getTemplateTypeNames()) {
      builder.add(varNameGen.getNextName(typeParam));
    }
    ImmutableList<String> typeParameters=builder.build();
    RawNominalType rawType;
    ObjectKind objKind=fnDoc.makesStructs() ? ObjectKind.STRUCT : (fnDoc.makesDicts() ? ObjectKind.DICT : ObjectKind.UNRESTRICTED);
    if (fnDoc.isConstructor()) {
      rawType=RawNominalType.makeClass(commonTypes,defSite,qname,typeParameters,objKind);
    }
 else     if (fnDoc.usesImplicitMatch()) {
      rawType=RawNominalType.makeStructuralInterface(commonTypes,defSite,qname,typeParameters,objKind);
    }
 else {
      Preconditions.checkState(fnDoc.isInterface());
      rawType=RawNominalType.makeNominalInterface(commonTypes,defSite,qname,typeParameters,objKind);
    }
    nominaltypesByNode.put(defSite,rawType);
    if (isRedeclaration) {
      return;
    }
    Node firstChild=nameNode.getFirstChild();
    if (nameNode.isName() || currentScope.isNamespace(firstChild) || mayCreateFunctionNamespace(firstChild)|| mayCreateWindowNamespace(firstChild)) {
      if (nameNode.isGetProp()) {
        defSite.getParent().getFirstChild().putBooleanProp(Node.ANALYZED_DURING_GTI,true);
      }
 else       if (currentScope.isTopLevel()) {
        maybeRecordBuiltinType(qname,rawType);
      }
      currentScope.addNamespace(nameNode,rawType);
    }
  }
 else   if (fnDoc.makesStructs()) {
    warnings.add(JSError.make(defSite,STRUCT_WITHOUT_CTOR_OR_INTERF));
  }
  if (fnDoc.makesDicts() && !fnDoc.isConstructor()) {
    warnings.add(JSError.make(defSite,DICT_WITHOUT_CTOR));
  }
}",0.8103023516237402
27334,"public static RawNominalType makeStructuralInterface(JSTypes commonTypes,Node defSite,String name,ImmutableList<String> typeParameters){
  return new RawNominalType(commonTypes,defSite,name,typeParameters,Kind.RECORD,ObjectKind.UNRESTRICTED);
}","public static RawNominalType makeStructuralInterface(JSTypes commonTypes,Node defSite,String name,ImmutableList<String> typeParameters,ObjectKind objKind){
  if (objKind == ObjectKind.DICT) {
    objKind=ObjectKind.UNRESTRICTED;
  }
  return new RawNominalType(commonTypes,defSite,name,typeParameters,Kind.RECORD,objKind);
}",0.778169014084507
27335,"public static RawNominalType makeNominalInterface(JSTypes commonTypes,Node defSite,String name,ImmutableList<String> typeParameters){
  return new RawNominalType(commonTypes,defSite,name,typeParameters,Kind.INTERFACE,ObjectKind.UNRESTRICTED);
}","public static RawNominalType makeNominalInterface(JSTypes commonTypes,Node defSite,String name,ImmutableList<String> typeParameters,ObjectKind objKind){
  if (objKind == ObjectKind.DICT) {
    objKind=ObjectKind.UNRESTRICTED;
  }
  return new RawNominalType(commonTypes,defSite,name,typeParameters,Kind.INTERFACE,objKind);
}",0.778169014084507
27336,"public void testMisplacedStructDictAnnotation(){
  typeCheck(""String_Node_Str"",GlobalTypeInfo.STRUCTDICT_WITHOUT_CTOR);
  typeCheck(""String_Node_Str"",GlobalTypeInfo.STRUCTDICT_WITHOUT_CTOR);
}","public void testMisplacedStructDictAnnotation(){
  typeCheck(""String_Node_Str"",GlobalTypeInfo.STRUCT_WITHOUT_CTOR_OR_INTERF);
  typeCheck(""String_Node_Str"",GlobalTypeInfo.DICT_WITHOUT_CTOR);
  typeCheck(""String_Node_Str"",GlobalTypeInfo.DICT_WITHOUT_CTOR);
}",0.8106904231625836
27337,"public void testStructPropAccess(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(""String_Node_Str"",NewTypeInference.ILLEGAL_OBJLIT_KEY);
  typeCheck(""String_Node_Str"",NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
}","public void testStructPropAccess(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(""String_Node_Str"",NewTypeInference.ILLEGAL_OBJLIT_KEY);
  typeCheck(""String_Node_Str"",NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
}",0.9523809523809524
27338,"static ObjectType join(ObjectType obj1,ObjectType obj2){
  if (obj1.isTopObject() || obj2.isTopObject()) {
    return obj1.commonTypes.TOP_OBJECTTYPE;
  }
  NominalType nom1=obj1.nominalType;
  NominalType nom2=obj2.nominalType;
  Preconditions.checkState(nom1 == null || nom2 == null || nom1.isRawSubtypeOf(nom2) || nom2.isRawSubtypeOf(nom1));
  if (obj1.equals(obj2)) {
    return obj1;
  }
  JSTypes commonTypes=obj1.commonTypes;
  boolean isLoose=obj1.isLoose || obj2.isLoose;
  FunctionType fn=FunctionType.join(obj1.fn,obj2.fn);
  PersistentMap<String,Property> props;
  if (isLoose) {
    fn=fn == null ? null : fn.withLoose();
    props=joinPropsLoosely(commonTypes,obj1.props,obj2.props);
  }
 else {
    props=joinProps(obj1.props,obj2.props,nom1,nom2);
  }
  NominalType nominal=NominalType.pickSuperclass(nom1,nom2);
  if (nominal == null || !nominal.isFunction()) {
    fn=null;
  }
  Namespace ns=Objects.equals(obj1.ns,obj2.ns) ? obj1.ns : null;
  return makeObjectType(commonTypes,nominal,props,fn,ns,isLoose,ObjectKind.join(obj1.objectKind,obj2.objectKind));
}","static ObjectType join(ObjectType obj1,ObjectType obj2){
  if ((obj1.isTopObject() && obj2.props.isEmpty()) || (obj2.isTopObject() && obj1.props.isEmpty())) {
    return obj1.commonTypes.TOP_OBJECTTYPE;
  }
  NominalType nom1=obj1.nominalType;
  NominalType nom2=obj2.nominalType;
  Preconditions.checkState(nom1 == null || nom2 == null || nom1.isRawSubtypeOf(nom2) || nom2.isRawSubtypeOf(nom1));
  if (obj1.equals(obj2)) {
    return obj1;
  }
  JSTypes commonTypes=obj1.commonTypes;
  boolean isLoose=obj1.isLoose || obj2.isLoose;
  FunctionType fn=FunctionType.join(obj1.fn,obj2.fn);
  PersistentMap<String,Property> props;
  if (isLoose) {
    fn=fn == null ? null : fn.withLoose();
    props=joinPropsLoosely(commonTypes,obj1.props,obj2.props);
  }
 else {
    props=joinProps(obj1.props,obj2.props,nom1,nom2);
  }
  NominalType nominal=NominalType.pickSuperclass(nom1,nom2);
  if (nominal == null || !nominal.isFunction()) {
    fn=null;
  }
  Namespace ns=Objects.equals(obj1.ns,obj2.ns) ? obj1.ns : null;
  return makeObjectType(commonTypes,nominal,props,fn,ns,isLoose,ObjectKind.join(obj1.objectKind,obj2.objectKind));
}",0.9764279238440616
27339,"public void testJoinWithTopObject(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testJoinWithTopObject(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.5610859728506787
27340,"public void testDoWhileLoopBranch() throws Exception {
  compareDoWhileLoopBranch(LanguageMode.ECMASCRIPT6);
}","public void testDoWhileLoopBranch() throws Exception {
  compareDoWhileLoopBranch(LanguageMode.ECMASCRIPT5);
  compareDoWhileLoopBranch(LanguageMode.ECMASCRIPT6);
}",0.8029197080291971
27341,"public void testDoWhileLoopMultiLineBranch() throws Exception {
  compareDoWhileLoopBranch(LanguageMode.ECMASCRIPT6);
}","public void testDoWhileLoopMultiLineBranch() throws Exception {
  compareDoWhileLoopMultiLineBranch(LanguageMode.ECMASCRIPT5);
  compareDoWhileLoopMultiLineBranch(LanguageMode.ECMASCRIPT6);
}",0.7677419354838709
27342,"@Override public final void visit(NodeTraversal nodeTraversal,Node n,Node parent){
  if (n.isCall() && parent.isExprResult() && n.getFirstChild().matchesQualifiedName(closureFunction)) {
    calls.add(parent);
  }
 else   if (NodeUtil.isNameDeclaration(parent) && n.getLastChild().getFirstChild().matchesQualifiedName(closureFunction)) {
    Preconditions.checkState(n.isName() || n.isDestructuringLhs());
    calls.add(parent);
  }
}","@Override public final void visit(NodeTraversal nodeTraversal,Node n,Node parent){
  if (n.isCall() && parent.isExprResult() && n.getFirstChild().matchesQualifiedName(closureFunction)) {
    calls.add(parent);
  }
 else   if (NodeUtil.isNameDeclaration(parent) && n.hasChildren() && n.getLastChild().isCall()&& n.getLastChild().getFirstChild().matchesQualifiedName(closureFunction)) {
    Preconditions.checkState(n.isName() || n.isDestructuringLhs());
    calls.add(parent);
  }
}",0.9486338797814208
27343,"/** 
 * Normalize the type of a constructor, its instance, and its prototype all down to the same type (the instance type).
 */
private static TypeI normalizeClassType(TypeI type){
  if (type == null || type.isUnknownType()) {
    return type;
  }
 else   if (type.isConstructor() || type.isInterface()) {
    return type.toMaybeFunctionType().getInstanceType();
  }
 else   if (type.isPrototypeObject()) {
    Preconditions.checkState(type instanceof ObjectType);
    FunctionType owner=((ObjectType)type).getOwnerFunction();
    if (owner.isConstructor()) {
      return owner.getInstanceType();
    }
  }
  return type;
}","/** 
 * Normalize the type of a constructor, its instance, and its prototype all down to the same type (the instance type).
 */
private static TypeI normalizeClassType(TypeI type){
  if (type == null || type.isUnknownType()) {
    return type;
  }
 else   if (type.isConstructor() || type.isInterface()) {
    return type.toMaybeFunctionType().getInstanceType();
  }
 else {
    ObjectTypeI obj=type.toMaybeObjectType();
    if (obj != null) {
      return obj.normalizeObjectForCheckAccessControls();
    }
  }
  return type;
}",0.6944444444444444
27344,"private void fixLineNumbers(Node expr){
  expr.setLineno(expr.getLineno() + templateLineno - 1);
  for (  Node child : expr.children()) {
    fixLineNumbers(child);
  }
}","private void fixLineNumbers(Node expr){
  expr.setLineno(expr.getLineno() + templateLineno);
  for (  Node child : expr.children()) {
    fixLineNumbers(child);
  }
}",0.988095238095238
27345,"protected void add(Node n,Context context){
  if (!cc.continueProcessing()) {
    return;
  }
  if (preserveTypeAnnotations && n.getJSDocInfo() != null) {
    String jsdocAsString=JSDocInfoPrinter.print(n.getJSDocInfo());
    if (!jsdocAsString.equals(""String_Node_Str"")) {
      add(jsdocAsString);
    }
  }
  Token type=n.getToken();
  String opstr=NodeUtil.opToStr(type);
  int childCount=n.getChildCount();
  Node first=n.getFirstChild();
  Node last=n.getLastChild();
  if (opstr != null && first != last) {
    Preconditions.checkState(childCount == 2,""String_Node_Str"",opstr,childCount);
    int p=NodeUtil.precedence(type);
    Context rhsContext=getContextForNoInOperator(context);
    boolean needsParens=(context == Context.START_OF_EXPR) && first.isObjectPattern();
    if (n.isAssign() && needsParens) {
      add(""String_Node_Str"");
    }
    if (NodeUtil.isAssignmentOp(n) || type == Token.EXPONENT) {
      addExpr(first,p + 1,context);
      cc.addOp(opstr,true);
      addExpr(last,p,rhsContext);
    }
 else {
      unrollBinaryOperator(n,type,opstr,context,rhsContext,p,p + 1);
    }
    if (n.isAssign() && needsParens) {
      add(""String_Node_Str"");
    }
    return;
  }
  cc.startSourceMapping(n);
switch (type) {
case TRY:
{
      Preconditions.checkState(first.getNext().isBlock() && !first.getNext().hasMoreThanOneChild());
      Preconditions.checkState(childCount >= 2 && childCount <= 3);
      add(""String_Node_Str"");
      add(first,Context.PRESERVE_BLOCK);
      Node catchblock=first.getNext().getFirstChild();
      if (catchblock != null) {
        add(catchblock);
      }
      if (childCount == 3) {
        cc.maybeInsertSpace();
        add(""String_Node_Str"");
        add(last,Context.PRESERVE_BLOCK);
      }
      break;
    }
case CATCH:
  Preconditions.checkState(childCount == 2);
cc.maybeInsertSpace();
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(last,Context.PRESERVE_BLOCK);
break;
case THROW:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(first);
cc.endStatement(true);
break;
case RETURN:
add(""String_Node_Str"");
if (childCount == 1) {
cc.maybeInsertSpace();
add(first);
}
 else {
Preconditions.checkState(childCount == 0);
}
cc.endStatement();
break;
case VAR:
if (first != null) {
add(""String_Node_Str"");
addList(first,false,getContextForNoInOperator(context),""String_Node_Str"");
}
break;
case CONST:
add(""String_Node_Str"");
addList(first,false,getContextForNoInOperator(context),""String_Node_Str"");
break;
case LET:
add(""String_Node_Str"");
addList(first,false,getContextForNoInOperator(context),""String_Node_Str"");
break;
case LABEL_NAME:
Preconditions.checkState(!n.getString().isEmpty());
addIdentifier(n.getString());
break;
case DESTRUCTURING_LHS:
add(first);
if (first != last) {
Preconditions.checkState(childCount == 2);
cc.addOp(""String_Node_Str"",true);
add(last);
}
break;
case NAME:
if (useOriginalName && n.getOriginalName() != null) {
addIdentifier(n.getOriginalName());
}
 else {
addIdentifier(n.getString());
}
maybeAddOptional(n);
maybeAddTypeDecl(n);
if (first != null && !first.isEmpty()) {
Preconditions.checkState(childCount == 1);
cc.addOp(""String_Node_Str"",true);
if (first.isComma()) {
addExpr(first,NodeUtil.precedence(Token.ASSIGN),Context.OTHER);
}
 else {
addExpr(first,0,getContextForNoInOperator(context));
}
}
break;
case ARRAYLIT:
add(""String_Node_Str"");
addArrayList(first);
add(""String_Node_Str"");
break;
case ARRAY_PATTERN:
add(""String_Node_Str"");
addArrayList(first);
add(""String_Node_Str"");
maybeAddTypeDecl(n);
break;
case PARAM_LIST:
add(""String_Node_Str"");
addList(first);
add(""String_Node_Str"");
break;
case DEFAULT_VALUE:
add(first);
maybeAddTypeDecl(n);
cc.addOp(""String_Node_Str"",true);
add(first.getNext());
break;
case COMMA:
Preconditions.checkState(childCount == 2);
unrollBinaryOperator(n,Token.COMMA,""String_Node_Str"",context,getContextForNoInOperator(context),0,0);
break;
case NUMBER:
Preconditions.checkState(childCount == 0);
cc.addNumber(n.getDouble());
break;
case TYPEOF:
case VOID:
case NOT:
case BITNOT:
case POS:
{
Preconditions.checkState(childCount == 1);
cc.addOp(NodeUtil.opToStrNoFail(type),false);
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
break;
}
case NEG:
{
Preconditions.checkState(childCount == 1);
if (n.getFirstChild().isNumber()) {
cc.addNumber(-n.getFirstChild().getDouble());
}
 else {
cc.addOp(NodeUtil.opToStrNoFail(type),false);
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
}
break;
}
case HOOK:
{
Preconditions.checkState(childCount == 3);
int p=NodeUtil.precedence(type);
Context rhsContext=getContextForNoInOperator(context);
addExpr(first,p + 1,context);
cc.addOp(""String_Node_Str"",true);
addExpr(first.getNext(),1,rhsContext);
cc.addOp(""String_Node_Str"",true);
addExpr(last,1,rhsContext);
break;
}
case REGEXP:
if (!first.isString() || !last.isString()) {
throw new Error(""String_Node_Str"");
}
String regexp=regexpEscape(first.getString());
if (childCount == 2) {
add(regexp + last.getString());
}
 else {
Preconditions.checkState(childCount == 1);
add(regexp);
}
break;
case FUNCTION:
{
if (n.getClass() != Node.class) {
throw new Error(""String_Node_Str"");
}
Preconditions.checkState(childCount == 3);
if (n.isArrowFunction()) {
addArrowFunction(n,first,last,context);
}
 else {
addFunction(n,first,last,context);
}
break;
}
case REST:
add(""String_Node_Str"");
add(first);
maybeAddTypeDecl(n);
break;
case SPREAD:
add(""String_Node_Str"");
add(n.getFirstChild());
break;
case EXPORT:
add(""String_Node_Str"");
if (n.getBooleanProp(Node.EXPORT_DEFAULT)) {
add(""String_Node_Str"");
}
if (n.getBooleanProp(Node.EXPORT_ALL_FROM)) {
add(""String_Node_Str"");
Preconditions.checkState(first != null && first.isEmpty());
}
 else {
add(first);
}
if (childCount == 2) {
add(""String_Node_Str"");
add(last);
}
processEnd(first,context);
break;
case IMPORT:
add(""String_Node_Str"");
Node second=first.getNext();
if (!first.isEmpty()) {
add(first);
if (!second.isEmpty()) {
cc.listSeparator();
}
}
if (!second.isEmpty()) {
add(second);
}
if (!first.isEmpty() || !second.isEmpty()) {
add(""String_Node_Str"");
}
add(last);
cc.endStatement();
break;
case EXPORT_SPECS:
case IMPORT_SPECS:
add(""String_Node_Str"");
for (Node c=first; c != null; c=c.getNext()) {
if (c != first) {
cc.listSeparator();
}
add(c);
}
add(""String_Node_Str"");
break;
case EXPORT_SPEC:
case IMPORT_SPEC:
add(first);
if (first != last) {
add(""String_Node_Str"");
add(last);
}
break;
case IMPORT_STAR:
add(""String_Node_Str"");
add(""String_Node_Str"");
add(n.getString());
break;
case CLASS:
{
Preconditions.checkState(childCount == 3);
boolean classNeedsParens=(context == Context.START_OF_EXPR);
if (classNeedsParens) {
add(""String_Node_Str"");
}
Node name=first;
Node superClass=first.getNext();
Node members=last;
add(""String_Node_Str"");
if (!name.isEmpty()) {
add(name);
}
maybeAddGenericTypes(first);
if (!superClass.isEmpty()) {
add(""String_Node_Str"");
add(superClass);
}
Node interfaces=(Node)n.getProp(Node.IMPLEMENTS);
if (interfaces != null) {
add(""String_Node_Str"");
Node child=interfaces.getFirstChild();
add(child);
while ((child=child.getNext()) != null) {
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(child);
}
}
add(members);
cc.endClass(context == Context.STATEMENT);
if (classNeedsParens) {
add(""String_Node_Str"");
}
}
break;
case CLASS_MEMBERS:
case INTERFACE_MEMBERS:
case NAMESPACE_ELEMENTS:
cc.beginBlock();
for (Node c=first; c != null; c=c.getNext()) {
add(c);
processEnd(c,context);
cc.endLine();
}
cc.endBlock(false);
break;
case ENUM_MEMBERS:
cc.beginBlock();
for (Node c=first; c != null; c=c.getNext()) {
add(c);
if (c.getNext() != null) {
add(""String_Node_Str"");
}
cc.endLine();
}
cc.endBlock(false);
break;
case GETTER_DEF:
case SETTER_DEF:
case MEMBER_FUNCTION_DEF:
case MEMBER_VARIABLE_DEF:
{
n.getParent().toStringTree();
Preconditions.checkState(n.getParent().isObjectLit() || n.getParent().isClassMembers() || n.getParent().isInterfaceMembers()|| n.getParent().isRecordType()|| n.getParent().isIndexSignature());
maybeAddAccessibilityModifier(n);
if (n.isStaticMember()) {
add(""String_Node_Str"");
}
if (!n.isMemberVariableDef() && n.getFirstChild().isGeneratorFunction()) {
Preconditions.checkState(type == Token.MEMBER_FUNCTION_DEF);
add(""String_Node_Str"");
}
if (n.isMemberFunctionDef() && n.getFirstChild().isAsyncFunction()) {
add(""String_Node_Str"");
}
switch (type) {
case GETTER_DEF:
Preconditions.checkState(!first.getSecondChild().hasChildren());
add(""String_Node_Str"");
break;
case SETTER_DEF:
Preconditions.checkState(first.getSecondChild().hasOneChild());
add(""String_Node_Str"");
break;
case MEMBER_FUNCTION_DEF:
case MEMBER_VARIABLE_DEF:
break;
default :
break;
}
String name=n.getString();
if (n.isMemberVariableDef()) {
add(n.getString());
maybeAddOptional(n);
maybeAddTypeDecl(n);
}
 else {
Preconditions.checkState(childCount == 1);
Preconditions.checkState(first.isFunction());
Preconditions.checkState(first.getFirstChild().getString().isEmpty());
Node fn=first;
Node parameters=fn.getSecondChild();
Node body=fn.getLastChild();
if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) && NodeUtil.isLatin(name)) {
add(name);
maybeAddGenericTypes(fn.getFirstChild());
}
 else {
double d=getSimpleNumber(name);
if (!Double.isNaN(d)) {
cc.addNumber(d);
}
 else {
addJsString(n);
}
}
maybeAddOptional(fn);
add(parameters);
maybeAddTypeDecl(fn);
add(body,Context.PRESERVE_BLOCK);
}
break;
}
case SCRIPT:
case MODULE_BODY:
case BLOCK:
{
if (n.getClass() != Node.class) {
throw new Error(""String_Node_Str"");
}
boolean preserveBlock=context == Context.PRESERVE_BLOCK;
if (preserveBlock) {
cc.beginBlock();
}
boolean preferLineBreaks=type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().isScript());
for (Node c=first; c != null; c=c.getNext()) {
add(c,Context.STATEMENT);
if (NodeUtil.isNameDeclaration(c)) {
cc.endStatement();
}
if (c.isFunction() || c.isClass()) {
cc.maybeLineBreak();
}
if (preferLineBreaks) {
cc.notePreferredLineBreak();
}
}
if (preserveBlock) {
cc.endBlock(cc.breakAfterBlockFor(n,context == Context.STATEMENT));
}
break;
}
case FOR:
if (childCount == 4) {
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
if (NodeUtil.isNameDeclaration(first)) {
add(first,Context.IN_FOR_INIT_CLAUSE);
}
 else {
addExpr(first,0,Context.IN_FOR_INIT_CLAUSE);
}
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
add(first.getNext().getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
 else {
Preconditions.checkState(childCount == 3);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
break;
case FOR_OF:
Preconditions.checkState(childCount == 3);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case DO:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
addNonEmptyStatement(first,Context.OTHER,false);
cc.maybeInsertSpace();
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(last);
add(""String_Node_Str"");
cc.endStatement();
break;
case WHILE:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case EMPTY:
Preconditions.checkState(childCount == 0);
break;
case GETPROP:
{
Preconditions.checkState(childCount == 2,""String_Node_Str"",childCount);
Preconditions.checkState(last.isString(),""String_Node_Str"");
boolean needsParens=(first.isNumber());
if (needsParens) {
add(""String_Node_Str"");
}
addExpr(first,NodeUtil.precedence(type),context);
if (needsParens) {
add(""String_Node_Str"");
}
if (quoteKeywordProperties && TokenStream.isKeyword(last.getString())) {
add(""String_Node_Str"");
add(last);
add(""String_Node_Str"");
}
 else {
add(""String_Node_Str"");
addIdentifier(last.getString());
}
break;
}
case GETELEM:
Preconditions.checkState(childCount == 2,""String_Node_Str"",childCount,n);
addExpr(first,NodeUtil.precedence(type),context);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
break;
case WITH:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case INC:
case DEC:
{
Preconditions.checkState(childCount == 1);
String o=type == Token.INC ? ""String_Node_Str"" : ""String_Node_Str"";
boolean postProp=n.getBooleanProp(Node.INCRDECR_PROP);
if (postProp) {
addExpr(first,NodeUtil.precedence(type),context);
cc.addOp(o,false);
}
 else {
cc.addOp(o,false);
add(first);
}
break;
}
case CALL:
if (isIndirectEval(first) || (n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first))) {
add(""String_Node_Str"");
addExpr(first,NodeUtil.precedence(Token.COMMA),Context.OTHER);
add(""String_Node_Str"");
}
 else {
addExpr(first,NodeUtil.precedence(type),context);
}
Node args=first.getNext();
add(""String_Node_Str"");
addList(args);
add(""String_Node_Str"");
break;
case IF:
boolean hasElse=childCount == 3;
boolean ambiguousElseClause=context == Context.BEFORE_DANGLING_ELSE && !hasElse;
if (ambiguousElseClause) {
cc.beginBlock();
}
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
if (childCount == 1) {
break;
}
if (hasElse) {
addNonEmptyStatement(first.getNext(),Context.BEFORE_DANGLING_ELSE,false);
cc.maybeInsertSpace();
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
 else {
addNonEmptyStatement(first.getNext(),Context.OTHER,false);
Preconditions.checkState(childCount == 2);
}
if (ambiguousElseClause) {
cc.endBlock();
}
break;
case NULL:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case THIS:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
break;
case SUPER:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
break;
case NEW_TARGET:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
break;
case YIELD:
add(""String_Node_Str"");
if (n.isYieldFor()) {
Preconditions.checkNotNull(first);
add(""String_Node_Str"");
}
if (first != null) {
cc.maybeInsertSpace();
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
}
break;
case AWAIT:
add(""String_Node_Str"");
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
break;
case FALSE:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case TRUE:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case CONTINUE:
Preconditions.checkState(childCount <= 1);
add(""String_Node_Str"");
if (childCount == 1) {
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
}
cc.endStatement();
break;
case DEBUGGER:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
cc.endStatement();
break;
case BREAK:
Preconditions.checkState(childCount <= 1);
add(""String_Node_Str"");
if (childCount == 1) {
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
}
cc.endStatement();
break;
case EXPR_RESULT:
Preconditions.checkState(childCount == 1);
add(first,Context.START_OF_EXPR);
cc.endStatement();
break;
case NEW:
add(""String_Node_Str"");
int precedence=NodeUtil.precedence(type);
if (NodeUtil.containsType(first,Token.CALL,NodeUtil.MATCH_NOT_FUNCTION)) {
precedence=NodeUtil.precedence(first.getToken()) + 1;
}
addExpr(first,precedence,Context.OTHER);
Node next=first.getNext();
if (next != null) {
add(""String_Node_Str"");
addList(next);
add(""String_Node_Str"");
}
break;
case STRING_KEY:
addStringKey(n);
break;
case STRING:
Preconditions.checkState(childCount == 0,""String_Node_Str"");
addJsString(n);
break;
case DELPROP:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
add(first);
break;
case OBJECTLIT:
{
boolean needsParens=(context == Context.START_OF_EXPR);
if (needsParens) {
add(""String_Node_Str"");
}
add(""String_Node_Str"");
for (Node c=first; c != null; c=c.getNext()) {
if (c != first) {
cc.listSeparator();
}
Preconditions.checkState(c.isComputedProp() || c.isGetterDef() || c.isSetterDef()|| c.isStringKey()|| c.isMemberFunctionDef());
add(c);
}
add(""String_Node_Str"");
if (needsParens) {
add(""String_Node_Str"");
}
break;
}
case COMPUTED_PROP:
maybeAddAccessibilityModifier(n);
if (n.getBooleanProp(Node.STATIC_MEMBER)) {
add(""String_Node_Str"");
}
if (n.getBooleanProp(Node.COMPUTED_PROP_GETTER)) {
add(""String_Node_Str"");
}
 else if (n.getBooleanProp(Node.COMPUTED_PROP_SETTER)) {
add(""String_Node_Str"");
}
 else if (last.getBooleanProp(Node.GENERATOR_FN)) {
add(""String_Node_Str"");
}
 else if (last.isAsyncFunction()) {
add(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
maybeAddTypeDecl(n);
if (n.getBooleanProp(Node.COMPUTED_PROP_METHOD) || n.getBooleanProp(Node.COMPUTED_PROP_GETTER) || n.getBooleanProp(Node.COMPUTED_PROP_SETTER)) {
Node function=first.getNext();
Node params=function.getSecondChild();
Node body=function.getLastChild();
add(params);
add(body,Context.PRESERVE_BLOCK);
}
 else {
boolean isInClass=n.getParent().getToken() == Token.CLASS_MEMBERS;
Node initializer=first.getNext();
if (initializer != null) {
Preconditions.checkState(!isInClass,""String_Node_Str"");
cc.addOp(""String_Node_Str"",false);
add(initializer);
}
 else {
Preconditions.checkState(n.getBooleanProp(Node.COMPUTED_PROP_VARIABLE),n);
}
}
break;
case OBJECT_PATTERN:
addObjectPattern(n);
maybeAddTypeDecl(n);
break;
case SWITCH:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
cc.beginBlock();
addAllSiblings(first.getNext());
cc.endBlock(context == Context.STATEMENT);
break;
case CASE:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
add(first);
addCaseBody(last);
break;
case DEFAULT_CASE:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
addCaseBody(first);
break;
case LABEL:
Preconditions.checkState(childCount == 2);
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(first);
add(""String_Node_Str"");
if (!last.isBlock()) {
cc.maybeInsertSpace();
}
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),true);
break;
case CAST:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
break;
case TAGGED_TEMPLATELIT:
add(first,Context.START_OF_EXPR);
add(first.getNext());
break;
case TEMPLATELIT:
add(""String_Node_Str"");
for (Node c=first; c != null; c=c.getNext()) {
if (c.isString()) {
add(strEscape(c.getString(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false,false));
}
 else {
cc.append(""String_Node_Str"");
add(c.getFirstChild(),Context.START_OF_EXPR);
add(""String_Node_Str"");
}
}
add(""String_Node_Str"");
break;
case STRING_TYPE:
add(""String_Node_Str"");
break;
case BOOLEAN_TYPE:
add(""String_Node_Str"");
break;
case NUMBER_TYPE:
add(""String_Node_Str"");
break;
case ANY_TYPE:
add(""String_Node_Str"");
break;
case VOID_TYPE:
add(""String_Node_Str"");
break;
case NAMED_TYPE:
add(first);
break;
case ARRAY_TYPE:
addExpr(first,NodeUtil.precedence(Token.ARRAY_TYPE),context);
add(""String_Node_Str"");
break;
case FUNCTION_TYPE:
Node returnType=first;
add(""String_Node_Str"");
addList(first.getNext());
add(""String_Node_Str"");
cc.addOp(""String_Node_Str"",true);
add(returnType);
break;
case UNION_TYPE:
addList(first,""String_Node_Str"");
break;
case RECORD_TYPE:
add(""String_Node_Str"");
addList(first,false,Context.OTHER,""String_Node_Str"");
add(""String_Node_Str"");
break;
case PARAMETERIZED_TYPE:
add(first);
add(""String_Node_Str"");
addList(first.getNext());
add(""String_Node_Str"");
break;
case GENERIC_TYPE_LIST:
add(""String_Node_Str"");
addList(first,false,Context.STATEMENT,""String_Node_Str"");
add(""String_Node_Str"");
break;
case GENERIC_TYPE:
addIdentifier(n.getString());
if (n.hasChildren()) {
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(n.getFirstChild());
}
break;
case INTERFACE:
{
Preconditions.checkState(childCount == 3);
Node name=first;
Node superTypes=first.getNext();
Node members=last;
add(""String_Node_Str"");
add(name);
maybeAddGenericTypes(name);
if (!superTypes.isEmpty()) {
add(""String_Node_Str"");
Node superType=superTypes.getFirstChild();
add(superType);
while ((superType=superType.getNext()) != null) {
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(superType);
}
}
add(members);
}
break;
case ENUM:
{
Preconditions.checkState(childCount == 2);
Node name=first;
Node members=last;
add(""String_Node_Str"");
add(name);
add(members);
break;
}
case NAMESPACE:
{
Preconditions.checkState(childCount == 2);
Node name=first;
Node elements=last;
add(""String_Node_Str"");
add(name);
add(elements);
break;
}
case TYPE_ALIAS:
add(""String_Node_Str"");
add(n.getString());
cc.addOp(""String_Node_Str"",true);
add(last);
cc.endStatement(true);
break;
case DECLARE:
add(""String_Node_Str"");
add(first);
processEnd(n,context);
break;
case INDEX_SIGNATURE:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
maybeAddTypeDecl(n);
cc.endStatement(true);
break;
case CALL_SIGNATURE:
if (n.getBooleanProp(Node.CONSTRUCT_SIGNATURE)) {
add(""String_Node_Str"");
}
maybeAddGenericTypes(n);
add(first);
maybeAddTypeDecl(n);
cc.endStatement(true);
break;
default :
throw new RuntimeException(""String_Node_Str"" + type + ""String_Node_Str""+ n.toStringTree());
}
cc.endSourceMapping(n);
}","protected void add(Node n,Context context){
  if (!cc.continueProcessing()) {
    return;
  }
  if (preserveTypeAnnotations && n.getJSDocInfo() != null) {
    String jsdocAsString=jsDocInfoPrinter.print(n.getJSDocInfo());
    if (!jsdocAsString.equals(""String_Node_Str"")) {
      add(jsdocAsString);
    }
  }
  Token type=n.getToken();
  String opstr=NodeUtil.opToStr(type);
  int childCount=n.getChildCount();
  Node first=n.getFirstChild();
  Node last=n.getLastChild();
  if (opstr != null && first != last) {
    Preconditions.checkState(childCount == 2,""String_Node_Str"",opstr,childCount);
    int p=NodeUtil.precedence(type);
    Context rhsContext=getContextForNoInOperator(context);
    boolean needsParens=(context == Context.START_OF_EXPR) && first.isObjectPattern();
    if (n.isAssign() && needsParens) {
      add(""String_Node_Str"");
    }
    if (NodeUtil.isAssignmentOp(n) || type == Token.EXPONENT) {
      addExpr(first,p + 1,context);
      cc.addOp(opstr,true);
      addExpr(last,p,rhsContext);
    }
 else {
      unrollBinaryOperator(n,type,opstr,context,rhsContext,p,p + 1);
    }
    if (n.isAssign() && needsParens) {
      add(""String_Node_Str"");
    }
    return;
  }
  cc.startSourceMapping(n);
switch (type) {
case TRY:
{
      Preconditions.checkState(first.getNext().isBlock() && !first.getNext().hasMoreThanOneChild());
      Preconditions.checkState(childCount >= 2 && childCount <= 3);
      add(""String_Node_Str"");
      add(first,Context.PRESERVE_BLOCK);
      Node catchblock=first.getNext().getFirstChild();
      if (catchblock != null) {
        add(catchblock);
      }
      if (childCount == 3) {
        cc.maybeInsertSpace();
        add(""String_Node_Str"");
        add(last,Context.PRESERVE_BLOCK);
      }
      break;
    }
case CATCH:
  Preconditions.checkState(childCount == 2);
cc.maybeInsertSpace();
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(last,Context.PRESERVE_BLOCK);
break;
case THROW:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(first);
cc.endStatement(true);
break;
case RETURN:
add(""String_Node_Str"");
if (childCount == 1) {
cc.maybeInsertSpace();
add(first);
}
 else {
Preconditions.checkState(childCount == 0);
}
cc.endStatement();
break;
case VAR:
if (first != null) {
add(""String_Node_Str"");
addList(first,false,getContextForNoInOperator(context),""String_Node_Str"");
}
break;
case CONST:
add(""String_Node_Str"");
addList(first,false,getContextForNoInOperator(context),""String_Node_Str"");
break;
case LET:
add(""String_Node_Str"");
addList(first,false,getContextForNoInOperator(context),""String_Node_Str"");
break;
case LABEL_NAME:
Preconditions.checkState(!n.getString().isEmpty());
addIdentifier(n.getString());
break;
case DESTRUCTURING_LHS:
add(first);
if (first != last) {
Preconditions.checkState(childCount == 2);
cc.addOp(""String_Node_Str"",true);
add(last);
}
break;
case NAME:
if (useOriginalName && n.getOriginalName() != null) {
addIdentifier(n.getOriginalName());
}
 else {
addIdentifier(n.getString());
}
maybeAddOptional(n);
maybeAddTypeDecl(n);
if (first != null && !first.isEmpty()) {
Preconditions.checkState(childCount == 1);
cc.addOp(""String_Node_Str"",true);
if (first.isComma()) {
addExpr(first,NodeUtil.precedence(Token.ASSIGN),Context.OTHER);
}
 else {
addExpr(first,0,getContextForNoInOperator(context));
}
}
break;
case ARRAYLIT:
add(""String_Node_Str"");
addArrayList(first);
add(""String_Node_Str"");
break;
case ARRAY_PATTERN:
add(""String_Node_Str"");
addArrayList(first);
add(""String_Node_Str"");
maybeAddTypeDecl(n);
break;
case PARAM_LIST:
add(""String_Node_Str"");
addList(first);
add(""String_Node_Str"");
break;
case DEFAULT_VALUE:
add(first);
maybeAddTypeDecl(n);
cc.addOp(""String_Node_Str"",true);
add(first.getNext());
break;
case COMMA:
Preconditions.checkState(childCount == 2);
unrollBinaryOperator(n,Token.COMMA,""String_Node_Str"",context,getContextForNoInOperator(context),0,0);
break;
case NUMBER:
Preconditions.checkState(childCount == 0);
cc.addNumber(n.getDouble());
break;
case TYPEOF:
case VOID:
case NOT:
case BITNOT:
case POS:
{
Preconditions.checkState(childCount == 1);
cc.addOp(NodeUtil.opToStrNoFail(type),false);
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
break;
}
case NEG:
{
Preconditions.checkState(childCount == 1);
if (n.getFirstChild().isNumber()) {
cc.addNumber(-n.getFirstChild().getDouble());
}
 else {
cc.addOp(NodeUtil.opToStrNoFail(type),false);
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
}
break;
}
case HOOK:
{
Preconditions.checkState(childCount == 3);
int p=NodeUtil.precedence(type);
Context rhsContext=getContextForNoInOperator(context);
addExpr(first,p + 1,context);
cc.addOp(""String_Node_Str"",true);
addExpr(first.getNext(),1,rhsContext);
cc.addOp(""String_Node_Str"",true);
addExpr(last,1,rhsContext);
break;
}
case REGEXP:
if (!first.isString() || !last.isString()) {
throw new Error(""String_Node_Str"");
}
String regexp=regexpEscape(first.getString());
if (childCount == 2) {
add(regexp + last.getString());
}
 else {
Preconditions.checkState(childCount == 1);
add(regexp);
}
break;
case FUNCTION:
{
if (n.getClass() != Node.class) {
throw new Error(""String_Node_Str"");
}
Preconditions.checkState(childCount == 3);
if (n.isArrowFunction()) {
addArrowFunction(n,first,last,context);
}
 else {
addFunction(n,first,last,context);
}
break;
}
case REST:
add(""String_Node_Str"");
add(first);
maybeAddTypeDecl(n);
break;
case SPREAD:
add(""String_Node_Str"");
add(n.getFirstChild());
break;
case EXPORT:
add(""String_Node_Str"");
if (n.getBooleanProp(Node.EXPORT_DEFAULT)) {
add(""String_Node_Str"");
}
if (n.getBooleanProp(Node.EXPORT_ALL_FROM)) {
add(""String_Node_Str"");
Preconditions.checkState(first != null && first.isEmpty());
}
 else {
add(first);
}
if (childCount == 2) {
add(""String_Node_Str"");
add(last);
}
processEnd(first,context);
break;
case IMPORT:
add(""String_Node_Str"");
Node second=first.getNext();
if (!first.isEmpty()) {
add(first);
if (!second.isEmpty()) {
cc.listSeparator();
}
}
if (!second.isEmpty()) {
add(second);
}
if (!first.isEmpty() || !second.isEmpty()) {
add(""String_Node_Str"");
}
add(last);
cc.endStatement();
break;
case EXPORT_SPECS:
case IMPORT_SPECS:
add(""String_Node_Str"");
for (Node c=first; c != null; c=c.getNext()) {
if (c != first) {
cc.listSeparator();
}
add(c);
}
add(""String_Node_Str"");
break;
case EXPORT_SPEC:
case IMPORT_SPEC:
add(first);
if (first != last) {
add(""String_Node_Str"");
add(last);
}
break;
case IMPORT_STAR:
add(""String_Node_Str"");
add(""String_Node_Str"");
add(n.getString());
break;
case CLASS:
{
Preconditions.checkState(childCount == 3);
boolean classNeedsParens=(context == Context.START_OF_EXPR);
if (classNeedsParens) {
add(""String_Node_Str"");
}
Node name=first;
Node superClass=first.getNext();
Node members=last;
add(""String_Node_Str"");
if (!name.isEmpty()) {
add(name);
}
maybeAddGenericTypes(first);
if (!superClass.isEmpty()) {
add(""String_Node_Str"");
add(superClass);
}
Node interfaces=(Node)n.getProp(Node.IMPLEMENTS);
if (interfaces != null) {
add(""String_Node_Str"");
Node child=interfaces.getFirstChild();
add(child);
while ((child=child.getNext()) != null) {
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(child);
}
}
add(members);
cc.endClass(context == Context.STATEMENT);
if (classNeedsParens) {
add(""String_Node_Str"");
}
}
break;
case CLASS_MEMBERS:
case INTERFACE_MEMBERS:
case NAMESPACE_ELEMENTS:
cc.beginBlock();
for (Node c=first; c != null; c=c.getNext()) {
add(c);
processEnd(c,context);
cc.endLine();
}
cc.endBlock(false);
break;
case ENUM_MEMBERS:
cc.beginBlock();
for (Node c=first; c != null; c=c.getNext()) {
add(c);
if (c.getNext() != null) {
add(""String_Node_Str"");
}
cc.endLine();
}
cc.endBlock(false);
break;
case GETTER_DEF:
case SETTER_DEF:
case MEMBER_FUNCTION_DEF:
case MEMBER_VARIABLE_DEF:
{
n.getParent().toStringTree();
Preconditions.checkState(n.getParent().isObjectLit() || n.getParent().isClassMembers() || n.getParent().isInterfaceMembers()|| n.getParent().isRecordType()|| n.getParent().isIndexSignature());
maybeAddAccessibilityModifier(n);
if (n.isStaticMember()) {
add(""String_Node_Str"");
}
if (!n.isMemberVariableDef() && n.getFirstChild().isGeneratorFunction()) {
Preconditions.checkState(type == Token.MEMBER_FUNCTION_DEF);
add(""String_Node_Str"");
}
if (n.isMemberFunctionDef() && n.getFirstChild().isAsyncFunction()) {
add(""String_Node_Str"");
}
switch (type) {
case GETTER_DEF:
Preconditions.checkState(!first.getSecondChild().hasChildren());
add(""String_Node_Str"");
break;
case SETTER_DEF:
Preconditions.checkState(first.getSecondChild().hasOneChild());
add(""String_Node_Str"");
break;
case MEMBER_FUNCTION_DEF:
case MEMBER_VARIABLE_DEF:
break;
default :
break;
}
String name=n.getString();
if (n.isMemberVariableDef()) {
add(n.getString());
maybeAddOptional(n);
maybeAddTypeDecl(n);
}
 else {
Preconditions.checkState(childCount == 1);
Preconditions.checkState(first.isFunction());
Preconditions.checkState(first.getFirstChild().getString().isEmpty());
Node fn=first;
Node parameters=fn.getSecondChild();
Node body=fn.getLastChild();
if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) && NodeUtil.isLatin(name)) {
add(name);
maybeAddGenericTypes(fn.getFirstChild());
}
 else {
double d=getSimpleNumber(name);
if (!Double.isNaN(d)) {
cc.addNumber(d);
}
 else {
addJsString(n);
}
}
maybeAddOptional(fn);
add(parameters);
maybeAddTypeDecl(fn);
add(body,Context.PRESERVE_BLOCK);
}
break;
}
case SCRIPT:
case MODULE_BODY:
case BLOCK:
{
if (n.getClass() != Node.class) {
throw new Error(""String_Node_Str"");
}
boolean preserveBlock=context == Context.PRESERVE_BLOCK;
if (preserveBlock) {
cc.beginBlock();
}
boolean preferLineBreaks=type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().isScript());
for (Node c=first; c != null; c=c.getNext()) {
add(c,Context.STATEMENT);
if (NodeUtil.isNameDeclaration(c)) {
cc.endStatement();
}
if (c.isFunction() || c.isClass()) {
cc.maybeLineBreak();
}
if (preferLineBreaks) {
cc.notePreferredLineBreak();
}
}
if (preserveBlock) {
cc.endBlock(cc.breakAfterBlockFor(n,context == Context.STATEMENT));
}
break;
}
case FOR:
if (childCount == 4) {
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
if (NodeUtil.isNameDeclaration(first)) {
add(first,Context.IN_FOR_INIT_CLAUSE);
}
 else {
addExpr(first,0,Context.IN_FOR_INIT_CLAUSE);
}
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
add(first.getNext().getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
 else {
Preconditions.checkState(childCount == 3);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
break;
case FOR_OF:
Preconditions.checkState(childCount == 3);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case DO:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
addNonEmptyStatement(first,Context.OTHER,false);
cc.maybeInsertSpace();
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(last);
add(""String_Node_Str"");
cc.endStatement();
break;
case WHILE:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case EMPTY:
Preconditions.checkState(childCount == 0);
break;
case GETPROP:
{
if (useOriginalName && n.getOriginalName() != null) {
if (n.getFirstChild().matchesQualifiedName(""String_Node_Str"") && n.getParent().isAssign()) {
add(""String_Node_Str"");
}
addIdentifier(n.getOriginalName());
break;
}
Preconditions.checkState(childCount == 2,""String_Node_Str"",childCount);
Preconditions.checkState(last.isString(),""String_Node_Str"");
boolean needsParens=(first.isNumber());
if (needsParens) {
add(""String_Node_Str"");
}
addExpr(first,NodeUtil.precedence(type),context);
if (needsParens) {
add(""String_Node_Str"");
}
if (quoteKeywordProperties && TokenStream.isKeyword(last.getString())) {
add(""String_Node_Str"");
add(last);
add(""String_Node_Str"");
}
 else {
add(""String_Node_Str"");
addIdentifier(last.getString());
}
break;
}
case GETELEM:
Preconditions.checkState(childCount == 2,""String_Node_Str"",childCount,n);
addExpr(first,NodeUtil.precedence(type),context);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
break;
case WITH:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case INC:
case DEC:
{
Preconditions.checkState(childCount == 1);
String o=type == Token.INC ? ""String_Node_Str"" : ""String_Node_Str"";
boolean postProp=n.getBooleanProp(Node.INCRDECR_PROP);
if (postProp) {
addExpr(first,NodeUtil.precedence(type),context);
cc.addOp(o,false);
}
 else {
cc.addOp(o,false);
add(first);
}
break;
}
case CALL:
if (isIndirectEval(first) || (n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first))) {
add(""String_Node_Str"");
addExpr(first,NodeUtil.precedence(Token.COMMA),Context.OTHER);
add(""String_Node_Str"");
}
 else {
addExpr(first,NodeUtil.precedence(type),context);
}
Node args=first.getNext();
add(""String_Node_Str"");
addList(args);
add(""String_Node_Str"");
break;
case IF:
boolean hasElse=childCount == 3;
boolean ambiguousElseClause=context == Context.BEFORE_DANGLING_ELSE && !hasElse;
if (ambiguousElseClause) {
cc.beginBlock();
}
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
if (childCount == 1) {
break;
}
if (hasElse) {
addNonEmptyStatement(first.getNext(),Context.BEFORE_DANGLING_ELSE,false);
cc.maybeInsertSpace();
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
 else {
addNonEmptyStatement(first.getNext(),Context.OTHER,false);
Preconditions.checkState(childCount == 2);
}
if (ambiguousElseClause) {
cc.endBlock();
}
break;
case NULL:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case THIS:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
break;
case SUPER:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
break;
case NEW_TARGET:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
break;
case YIELD:
add(""String_Node_Str"");
if (n.isYieldFor()) {
Preconditions.checkNotNull(first);
add(""String_Node_Str"");
}
if (first != null) {
cc.maybeInsertSpace();
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
}
break;
case AWAIT:
add(""String_Node_Str"");
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
break;
case FALSE:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case TRUE:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case CONTINUE:
Preconditions.checkState(childCount <= 1);
add(""String_Node_Str"");
if (childCount == 1) {
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
}
cc.endStatement();
break;
case DEBUGGER:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
cc.endStatement();
break;
case BREAK:
Preconditions.checkState(childCount <= 1);
add(""String_Node_Str"");
if (childCount == 1) {
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
}
cc.endStatement();
break;
case EXPR_RESULT:
Preconditions.checkState(childCount == 1);
add(first,Context.START_OF_EXPR);
cc.endStatement();
break;
case NEW:
add(""String_Node_Str"");
int precedence=NodeUtil.precedence(type);
if (NodeUtil.containsType(first,Token.CALL,NodeUtil.MATCH_NOT_FUNCTION)) {
precedence=NodeUtil.precedence(first.getToken()) + 1;
}
addExpr(first,precedence,Context.OTHER);
Node next=first.getNext();
if (next != null) {
add(""String_Node_Str"");
addList(next);
add(""String_Node_Str"");
}
break;
case STRING_KEY:
addStringKey(n);
break;
case STRING:
Preconditions.checkState(childCount == 0,""String_Node_Str"");
addJsString(n);
break;
case DELPROP:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
add(first);
break;
case OBJECTLIT:
{
boolean needsParens=(context == Context.START_OF_EXPR);
if (needsParens) {
add(""String_Node_Str"");
}
add(""String_Node_Str"");
for (Node c=first; c != null; c=c.getNext()) {
if (c != first) {
cc.listSeparator();
}
Preconditions.checkState(c.isComputedProp() || c.isGetterDef() || c.isSetterDef()|| c.isStringKey()|| c.isMemberFunctionDef());
add(c);
}
add(""String_Node_Str"");
if (needsParens) {
add(""String_Node_Str"");
}
break;
}
case COMPUTED_PROP:
maybeAddAccessibilityModifier(n);
if (n.getBooleanProp(Node.STATIC_MEMBER)) {
add(""String_Node_Str"");
}
if (n.getBooleanProp(Node.COMPUTED_PROP_GETTER)) {
add(""String_Node_Str"");
}
 else if (n.getBooleanProp(Node.COMPUTED_PROP_SETTER)) {
add(""String_Node_Str"");
}
 else if (last.getBooleanProp(Node.GENERATOR_FN)) {
add(""String_Node_Str"");
}
 else if (last.isAsyncFunction()) {
add(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
maybeAddTypeDecl(n);
if (n.getBooleanProp(Node.COMPUTED_PROP_METHOD) || n.getBooleanProp(Node.COMPUTED_PROP_GETTER) || n.getBooleanProp(Node.COMPUTED_PROP_SETTER)) {
Node function=first.getNext();
Node params=function.getSecondChild();
Node body=function.getLastChild();
add(params);
add(body,Context.PRESERVE_BLOCK);
}
 else {
boolean isInClass=n.getParent().getToken() == Token.CLASS_MEMBERS;
Node initializer=first.getNext();
if (initializer != null) {
Preconditions.checkState(!isInClass,""String_Node_Str"");
cc.addOp(""String_Node_Str"",false);
add(initializer);
}
 else {
Preconditions.checkState(n.getBooleanProp(Node.COMPUTED_PROP_VARIABLE),n);
}
}
break;
case OBJECT_PATTERN:
addObjectPattern(n);
maybeAddTypeDecl(n);
break;
case SWITCH:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
cc.beginBlock();
addAllSiblings(first.getNext());
cc.endBlock(context == Context.STATEMENT);
break;
case CASE:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
add(first);
addCaseBody(last);
break;
case DEFAULT_CASE:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
addCaseBody(first);
break;
case LABEL:
Preconditions.checkState(childCount == 2);
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(first);
add(""String_Node_Str"");
if (!last.isBlock()) {
cc.maybeInsertSpace();
}
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),true);
break;
case CAST:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
break;
case TAGGED_TEMPLATELIT:
add(first,Context.START_OF_EXPR);
add(first.getNext());
break;
case TEMPLATELIT:
add(""String_Node_Str"");
for (Node c=first; c != null; c=c.getNext()) {
if (c.isString()) {
add(strEscape(c.getString(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false,false));
}
 else {
cc.append(""String_Node_Str"");
add(c.getFirstChild(),Context.START_OF_EXPR);
add(""String_Node_Str"");
}
}
add(""String_Node_Str"");
break;
case STRING_TYPE:
add(""String_Node_Str"");
break;
case BOOLEAN_TYPE:
add(""String_Node_Str"");
break;
case NUMBER_TYPE:
add(""String_Node_Str"");
break;
case ANY_TYPE:
add(""String_Node_Str"");
break;
case VOID_TYPE:
add(""String_Node_Str"");
break;
case NAMED_TYPE:
add(first);
break;
case ARRAY_TYPE:
addExpr(first,NodeUtil.precedence(Token.ARRAY_TYPE),context);
add(""String_Node_Str"");
break;
case FUNCTION_TYPE:
Node returnType=first;
add(""String_Node_Str"");
addList(first.getNext());
add(""String_Node_Str"");
cc.addOp(""String_Node_Str"",true);
add(returnType);
break;
case UNION_TYPE:
addList(first,""String_Node_Str"");
break;
case RECORD_TYPE:
add(""String_Node_Str"");
addList(first,false,Context.OTHER,""String_Node_Str"");
add(""String_Node_Str"");
break;
case PARAMETERIZED_TYPE:
add(first);
add(""String_Node_Str"");
addList(first.getNext());
add(""String_Node_Str"");
break;
case GENERIC_TYPE_LIST:
add(""String_Node_Str"");
addList(first,false,Context.STATEMENT,""String_Node_Str"");
add(""String_Node_Str"");
break;
case GENERIC_TYPE:
addIdentifier(n.getString());
if (n.hasChildren()) {
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(n.getFirstChild());
}
break;
case INTERFACE:
{
Preconditions.checkState(childCount == 3);
Node name=first;
Node superTypes=first.getNext();
Node members=last;
add(""String_Node_Str"");
add(name);
maybeAddGenericTypes(name);
if (!superTypes.isEmpty()) {
add(""String_Node_Str"");
Node superType=superTypes.getFirstChild();
add(superType);
while ((superType=superType.getNext()) != null) {
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(superType);
}
}
add(members);
}
break;
case ENUM:
{
Preconditions.checkState(childCount == 2);
Node name=first;
Node members=last;
add(""String_Node_Str"");
add(name);
add(members);
break;
}
case NAMESPACE:
{
Preconditions.checkState(childCount == 2);
Node name=first;
Node elements=last;
add(""String_Node_Str"");
add(name);
add(elements);
break;
}
case TYPE_ALIAS:
add(""String_Node_Str"");
add(n.getString());
cc.addOp(""String_Node_Str"",true);
add(last);
cc.endStatement(true);
break;
case DECLARE:
add(""String_Node_Str"");
add(first);
processEnd(n,context);
break;
case INDEX_SIGNATURE:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
maybeAddTypeDecl(n);
cc.endStatement(true);
break;
case CALL_SIGNATURE:
if (n.getBooleanProp(Node.CONSTRUCT_SIGNATURE)) {
add(""String_Node_Str"");
}
maybeAddGenericTypes(n);
add(first);
maybeAddTypeDecl(n);
cc.endStatement(true);
break;
default :
throw new RuntimeException(""String_Node_Str"" + type + ""String_Node_Str""+ n.toStringTree());
}
cc.endSourceMapping(n);
}",0.9949213030746704
27346,"protected CodeGenerator(CodeConsumer consumer,CompilerOptions options){
  cc=consumer;
  this.outputCharsetEncoder=new OutputCharsetEncoder(options.getOutputCharset());
  this.preferSingleQuotes=options.preferSingleQuotes;
  this.trustedStrings=options.trustedStrings;
  this.preserveTypeAnnotations=options.preserveTypeAnnotations;
  this.quoteKeywordProperties=options.quoteKeywordProperties;
  this.outputAsExterns=options.shouldGenerateTypedExterns();
  this.useOriginalName=options.getUseOriginalNamesInOutput();
}","protected CodeGenerator(CodeConsumer consumer,CompilerOptions options){
  cc=consumer;
  this.outputCharsetEncoder=new OutputCharsetEncoder(options.getOutputCharset());
  this.preferSingleQuotes=options.preferSingleQuotes;
  this.trustedStrings=options.trustedStrings;
  this.preserveTypeAnnotations=options.preserveTypeAnnotations;
  this.quoteKeywordProperties=options.quoteKeywordProperties;
  this.outputAsExterns=options.shouldGenerateTypedExterns();
  this.useOriginalName=options.getUseOriginalNamesInOutput();
  this.jsDocInfoPrinter=new JSDocInfoPrinter(useOriginalName);
}",0.9427792915531336
27347,"private static String buildAnnotationWithType(String annotation,Node type){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  sb.append(annotation);
  sb.append(""String_Node_Str"");
  appendTypeNode(sb,type);
  sb.append(""String_Node_Str"");
  return sb.toString();
}","private String buildAnnotationWithType(String annotation,Node type){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  sb.append(annotation);
  sb.append(""String_Node_Str"");
  appendTypeNode(sb,type);
  sb.append(""String_Node_Str"");
  return sb.toString();
}",0.9877408056042032
27348,"private static String typeNode(Node typeNode){
  StringBuilder sb=new StringBuilder();
  appendTypeNode(sb,typeNode);
  return sb.toString();
}","private String typeNode(Node typeNode){
  StringBuilder sb=new StringBuilder();
  appendTypeNode(sb,typeNode);
  return sb.toString();
}",0.974910394265233
27349,"public static String print(JSDocInfo info){
  boolean multiline=false;
  List<String> parts=new ArrayList<>();
  parts.add(""String_Node_Str"");
  if (info.isExport()) {
    parts.add(""String_Node_Str"");
  }
 else   if (info.getVisibility() != null && info.getVisibility() != Visibility.INHERITED) {
    parts.add(""String_Node_Str"" + info.getVisibility().toString().toLowerCase());
  }
  if (info.isConstant() && !info.isDefine() && !info.isFinal()) {
    parts.add(""String_Node_Str"");
  }
  if (info.isFinal()) {
    parts.add(""String_Node_Str"");
  }
  if (info.makesDicts()) {
    parts.add(""String_Node_Str"");
  }
  if (info.makesStructs()) {
    parts.add(""String_Node_Str"");
  }
  if (info.makesUnrestricted()) {
    parts.add(""String_Node_Str"");
  }
  if (info.isConstructor()) {
    parts.add(""String_Node_Str"");
  }
  if (info.isInterface() && !info.usesImplicitMatch()) {
    parts.add(""String_Node_Str"");
  }
  if (info.isInterface() && info.usesImplicitMatch()) {
    parts.add(""String_Node_Str"");
  }
  if (info.hasBaseType()) {
    multiline=true;
    Node typeNode=stripBang(info.getBaseType().getRoot());
    parts.add(buildAnnotationWithType(""String_Node_Str"",typeNode));
  }
  for (  JSTypeExpression type : info.getExtendedInterfaces()) {
    multiline=true;
    Node typeNode=stripBang(type.getRoot());
    parts.add(buildAnnotationWithType(""String_Node_Str"",typeNode));
  }
  for (  JSTypeExpression type : info.getImplementedInterfaces()) {
    multiline=true;
    Node typeNode=stripBang(type.getRoot());
    parts.add(buildAnnotationWithType(""String_Node_Str"",typeNode));
  }
  if (info.hasThisType()) {
    multiline=true;
    Node typeNode=stripBang(info.getThisType().getRoot());
    parts.add(buildAnnotationWithType(""String_Node_Str"",typeNode));
  }
  if (info.getParameterCount() > 0) {
    multiline=true;
    for (    String name : info.getParameterNames()) {
      parts.add(""String_Node_Str"" + buildParamType(name,info.getParameterType(name)));
    }
  }
  if (info.hasReturnType()) {
    multiline=true;
    parts.add(buildAnnotationWithType(""String_Node_Str"",info.getReturnType()));
  }
  if (!info.getThrownTypes().isEmpty()) {
    parts.add(buildAnnotationWithType(""String_Node_Str"",info.getThrownTypes().get(0)));
  }
  ImmutableList<String> names=info.getTemplateTypeNames();
  if (!names.isEmpty()) {
    parts.add(""String_Node_Str"" + Joiner.on(',').join(names));
    multiline=true;
  }
  if (info.isOverride()) {
    parts.add(""String_Node_Str"");
  }
  if (info.hasType() && !info.isDefine()) {
    if (info.isInlineType()) {
      parts.add(typeNode(info.getType().getRoot()));
    }
 else {
      parts.add(buildAnnotationWithType(""String_Node_Str"",info.getType()));
    }
  }
  if (info.isDefine()) {
    parts.add(buildAnnotationWithType(""String_Node_Str"",info.getType()));
  }
  if (info.hasTypedefType()) {
    parts.add(buildAnnotationWithType(""String_Node_Str"",info.getTypedefType()));
  }
  if (info.hasEnumParameterType()) {
    parts.add(buildAnnotationWithType(""String_Node_Str"",info.getEnumParameterType()));
  }
  Set<String> suppressions=info.getSuppressions();
  if (!suppressions.isEmpty()) {
    String[] arr=suppressions.toArray(new String[0]);
    Arrays.sort(arr,Ordering.<String>natural());
    parts.add(""String_Node_Str"" + Joiner.on(',').join(arr) + ""String_Node_Str"");
    multiline=true;
  }
  if (info.isDeprecated()) {
    parts.add(""String_Node_Str"" + info.getDeprecationReason());
    multiline=true;
  }
  parts.add(""String_Node_Str"");
  StringBuilder sb=new StringBuilder();
  if (multiline) {
    Joiner.on(""String_Node_Str"").appendTo(sb,parts);
  }
 else {
    Joiner.on(""String_Node_Str"").appendTo(sb,parts);
  }
  sb.append((multiline) ? ""String_Node_Str"" : ""String_Node_Str"");
  return sb.toString();
}","public String print(JSDocInfo info){
  boolean multiline=false;
  List<String> parts=new ArrayList<>();
  parts.add(""String_Node_Str"");
  if (info.isExport()) {
    parts.add(""String_Node_Str"");
  }
 else   if (info.getVisibility() != null && info.getVisibility() != Visibility.INHERITED) {
    parts.add(""String_Node_Str"" + info.getVisibility().toString().toLowerCase());
  }
  if (info.isConstant() && !info.isDefine() && !info.isFinal()) {
    parts.add(""String_Node_Str"");
  }
  if (info.isFinal()) {
    parts.add(""String_Node_Str"");
  }
  if (info.makesDicts()) {
    parts.add(""String_Node_Str"");
  }
  if (info.makesStructs()) {
    parts.add(""String_Node_Str"");
  }
  if (info.makesUnrestricted()) {
    parts.add(""String_Node_Str"");
  }
  if (info.isConstructor()) {
    parts.add(""String_Node_Str"");
  }
  if (info.isInterface() && !info.usesImplicitMatch()) {
    parts.add(""String_Node_Str"");
  }
  if (info.isInterface() && info.usesImplicitMatch()) {
    parts.add(""String_Node_Str"");
  }
  if (info.hasBaseType()) {
    multiline=true;
    Node typeNode=stripBang(info.getBaseType().getRoot());
    parts.add(buildAnnotationWithType(""String_Node_Str"",typeNode));
  }
  for (  JSTypeExpression type : info.getExtendedInterfaces()) {
    multiline=true;
    Node typeNode=stripBang(type.getRoot());
    parts.add(buildAnnotationWithType(""String_Node_Str"",typeNode));
  }
  for (  JSTypeExpression type : info.getImplementedInterfaces()) {
    multiline=true;
    Node typeNode=stripBang(type.getRoot());
    parts.add(buildAnnotationWithType(""String_Node_Str"",typeNode));
  }
  if (info.hasThisType()) {
    multiline=true;
    Node typeNode=stripBang(info.getThisType().getRoot());
    parts.add(buildAnnotationWithType(""String_Node_Str"",typeNode));
  }
  if (info.getParameterCount() > 0) {
    multiline=true;
    for (    String name : info.getParameterNames()) {
      parts.add(""String_Node_Str"" + buildParamType(name,info.getParameterType(name)));
    }
  }
  if (info.hasReturnType()) {
    multiline=true;
    parts.add(buildAnnotationWithType(""String_Node_Str"",info.getReturnType()));
  }
  if (!info.getThrownTypes().isEmpty()) {
    parts.add(buildAnnotationWithType(""String_Node_Str"",info.getThrownTypes().get(0)));
  }
  ImmutableList<String> names=info.getTemplateTypeNames();
  if (!names.isEmpty()) {
    parts.add(""String_Node_Str"" + Joiner.on(',').join(names));
    multiline=true;
  }
  if (info.isOverride()) {
    parts.add(""String_Node_Str"");
  }
  if (info.hasType() && !info.isDefine()) {
    if (info.isInlineType()) {
      parts.add(typeNode(info.getType().getRoot()));
    }
 else {
      parts.add(buildAnnotationWithType(""String_Node_Str"",info.getType()));
    }
  }
  if (info.isDefine()) {
    parts.add(buildAnnotationWithType(""String_Node_Str"",info.getType()));
  }
  if (info.hasTypedefType()) {
    parts.add(buildAnnotationWithType(""String_Node_Str"",info.getTypedefType()));
  }
  if (info.hasEnumParameterType()) {
    parts.add(buildAnnotationWithType(""String_Node_Str"",info.getEnumParameterType()));
  }
  Set<String> suppressions=info.getSuppressions();
  if (!suppressions.isEmpty()) {
    String[] arr=suppressions.toArray(new String[0]);
    Arrays.sort(arr,Ordering.<String>natural());
    parts.add(""String_Node_Str"" + Joiner.on(',').join(arr) + ""String_Node_Str"");
    multiline=true;
  }
  if (info.isDeprecated()) {
    parts.add(""String_Node_Str"" + info.getDeprecationReason());
    multiline=true;
  }
  parts.add(""String_Node_Str"");
  StringBuilder sb=new StringBuilder();
  if (multiline) {
    Joiner.on(""String_Node_Str"").appendTo(sb,parts);
  }
 else {
    Joiner.on(""String_Node_Str"").appendTo(sb,parts);
  }
  sb.append((multiline) ? ""String_Node_Str"" : ""String_Node_Str"");
  return sb.toString();
}",0.9990729704674878
27350,"private static Node stripBang(Node typeNode){
  if (typeNode.getToken() == Token.BANG) {
    typeNode=typeNode.getFirstChild();
  }
  return typeNode;
}","private Node stripBang(Node typeNode){
  if (typeNode.getToken() == Token.BANG) {
    typeNode=typeNode.getFirstChild();
  }
  return typeNode;
}",0.9764309764309764
27351,"private static String buildParamType(String name,JSTypeExpression type){
  if (type != null) {
    return ""String_Node_Str"" + typeNode(type.getRoot()) + ""String_Node_Str""+ name;
  }
 else {
    return name;
  }
}","private String buildParamType(String name,JSTypeExpression type){
  if (type != null) {
    return ""String_Node_Str"" + typeNode(type.getRoot()) + ""String_Node_Str""+ name;
  }
 else {
    return name;
  }
}",0.9832134292565948
27352,"private static void appendFunctionNode(StringBuilder sb,Node function){
  boolean hasNewOrThis=false;
  sb.append(""String_Node_Str"");
  Node first=function.getFirstChild();
  if (first.isNew()) {
    sb.append(""String_Node_Str"");
    appendTypeNode(sb,first.getFirstChild());
    hasNewOrThis=true;
  }
 else   if (first.isThis()) {
    sb.append(""String_Node_Str"");
    appendTypeNode(sb,first.getFirstChild());
    hasNewOrThis=true;
  }
 else   if (first.isEmpty()) {
    sb.append(""String_Node_Str"");
    return;
  }
 else   if (!first.isParamList()) {
    sb.append(""String_Node_Str"");
    appendTypeNode(sb,first);
    return;
  }
  Node paramList=null;
  if (first.isParamList()) {
    paramList=first;
  }
 else   if (first.getNext().isParamList()) {
    paramList=first.getNext();
  }
  if (paramList != null) {
    boolean firstParam=true;
    for (    Node param : paramList.children()) {
      if (!firstParam || hasNewOrThis) {
        sb.append(""String_Node_Str"");
      }
      appendTypeNode(sb,param);
      firstParam=false;
    }
  }
  sb.append(""String_Node_Str"");
  Node returnType=function.getLastChild();
  if (!returnType.isEmpty()) {
    sb.append(""String_Node_Str"");
    appendTypeNode(sb,returnType);
  }
}","private void appendFunctionNode(StringBuilder sb,Node function){
  boolean hasNewOrThis=false;
  sb.append(""String_Node_Str"");
  Node first=function.getFirstChild();
  if (first.isNew()) {
    sb.append(""String_Node_Str"");
    appendTypeNode(sb,first.getFirstChild());
    hasNewOrThis=true;
  }
 else   if (first.isThis()) {
    sb.append(""String_Node_Str"");
    appendTypeNode(sb,first.getFirstChild());
    hasNewOrThis=true;
  }
 else   if (first.isEmpty()) {
    sb.append(""String_Node_Str"");
    return;
  }
 else   if (!first.isParamList()) {
    sb.append(""String_Node_Str"");
    appendTypeNode(sb,first);
    return;
  }
  Node paramList=null;
  if (first.isParamList()) {
    paramList=first;
  }
 else   if (first.getNext().isParamList()) {
    paramList=first.getNext();
  }
  if (paramList != null) {
    boolean firstParam=true;
    for (    Node param : paramList.children()) {
      if (!firstParam || hasNewOrThis) {
        sb.append(""String_Node_Str"");
      }
      appendTypeNode(sb,param);
      firstParam=false;
    }
  }
  sb.append(""String_Node_Str"");
  Node returnType=function.getLastChild();
  if (!returnType.isEmpty()) {
    sb.append(""String_Node_Str"");
    appendTypeNode(sb,returnType);
  }
}",0.9971533143554292
27353,"private static void appendTypeNode(StringBuilder sb,Node typeNode){
  if (typeNode.getToken() == Token.BANG) {
    sb.append(""String_Node_Str"");
    appendTypeNode(sb,typeNode.getFirstChild());
  }
 else   if (typeNode.getToken() == Token.EQUALS) {
    appendTypeNode(sb,typeNode.getFirstChild());
    sb.append(""String_Node_Str"");
  }
 else   if (typeNode.getToken() == Token.PIPE) {
    sb.append(""String_Node_Str"");
    for (int i=0; i < typeNode.getChildCount() - 1; i++) {
      appendTypeNode(sb,typeNode.getChildAtIndex(i));
      sb.append(""String_Node_Str"");
    }
    appendTypeNode(sb,typeNode.getLastChild());
    sb.append(""String_Node_Str"");
  }
 else   if (typeNode.getToken() == Token.ELLIPSIS) {
    sb.append(""String_Node_Str"");
    if (typeNode.hasChildren() && !typeNode.getFirstChild().isEmpty()) {
      appendTypeNode(sb,typeNode.getFirstChild());
    }
  }
 else   if (typeNode.getToken() == Token.STAR) {
    sb.append(""String_Node_Str"");
  }
 else   if (typeNode.getToken() == Token.QMARK) {
    sb.append(""String_Node_Str"");
    if (typeNode.hasChildren()) {
      appendTypeNode(sb,typeNode.getFirstChild());
    }
  }
 else   if (typeNode.isFunction()) {
    appendFunctionNode(sb,typeNode);
  }
 else   if (typeNode.getToken() == Token.LC) {
    sb.append(""String_Node_Str"");
    Node lb=typeNode.getFirstChild();
    for (int i=0; i < lb.getChildCount() - 1; i++) {
      Node colon=lb.getChildAtIndex(i);
      if (colon.hasChildren()) {
        sb.append(colon.getFirstChild().getString()).append(""String_Node_Str"");
        appendTypeNode(sb,colon.getLastChild());
      }
 else {
        sb.append(colon.getString());
      }
      sb.append(""String_Node_Str"");
    }
    Node lastColon=lb.getLastChild();
    if (lastColon.hasChildren()) {
      sb.append(lastColon.getFirstChild().getString()).append(""String_Node_Str"");
      appendTypeNode(sb,lastColon.getLastChild());
    }
 else {
      sb.append(lastColon.getString());
    }
    sb.append(""String_Node_Str"");
  }
 else   if (typeNode.getToken() == Token.VOID) {
    sb.append(""String_Node_Str"");
  }
 else {
    if (typeNode.hasChildren()) {
      sb.append(typeNode.getString()).append(""String_Node_Str"");
      Node child=typeNode.getFirstChild();
      appendTypeNode(sb,child.getFirstChild());
      for (int i=1; i < child.getChildCount(); i++) {
        sb.append(""String_Node_Str"");
        appendTypeNode(sb,child.getChildAtIndex(i));
      }
      sb.append(""String_Node_Str"");
    }
 else {
      sb.append(typeNode.getString());
    }
  }
}","private void appendTypeNode(StringBuilder sb,Node typeNode){
  if (useOriginalName && typeNode.getOriginalName() != null) {
    sb.append(typeNode.getOriginalName());
    return;
  }
  if (typeNode.getToken() == Token.BANG) {
    sb.append(""String_Node_Str"");
    appendTypeNode(sb,typeNode.getFirstChild());
  }
 else   if (typeNode.getToken() == Token.EQUALS) {
    appendTypeNode(sb,typeNode.getFirstChild());
    sb.append(""String_Node_Str"");
  }
 else   if (typeNode.getToken() == Token.PIPE) {
    sb.append(""String_Node_Str"");
    for (int i=0; i < typeNode.getChildCount() - 1; i++) {
      appendTypeNode(sb,typeNode.getChildAtIndex(i));
      sb.append(""String_Node_Str"");
    }
    appendTypeNode(sb,typeNode.getLastChild());
    sb.append(""String_Node_Str"");
  }
 else   if (typeNode.getToken() == Token.ELLIPSIS) {
    sb.append(""String_Node_Str"");
    if (typeNode.hasChildren() && !typeNode.getFirstChild().isEmpty()) {
      appendTypeNode(sb,typeNode.getFirstChild());
    }
  }
 else   if (typeNode.getToken() == Token.STAR) {
    sb.append(""String_Node_Str"");
  }
 else   if (typeNode.getToken() == Token.QMARK) {
    sb.append(""String_Node_Str"");
    if (typeNode.hasChildren()) {
      appendTypeNode(sb,typeNode.getFirstChild());
    }
  }
 else   if (typeNode.isFunction()) {
    appendFunctionNode(sb,typeNode);
  }
 else   if (typeNode.getToken() == Token.LC) {
    sb.append(""String_Node_Str"");
    Node lb=typeNode.getFirstChild();
    for (int i=0; i < lb.getChildCount() - 1; i++) {
      Node colon=lb.getChildAtIndex(i);
      if (colon.hasChildren()) {
        sb.append(colon.getFirstChild().getString()).append(""String_Node_Str"");
        appendTypeNode(sb,colon.getLastChild());
      }
 else {
        sb.append(colon.getString());
      }
      sb.append(""String_Node_Str"");
    }
    Node lastColon=lb.getLastChild();
    if (lastColon.hasChildren()) {
      sb.append(lastColon.getFirstChild().getString()).append(""String_Node_Str"");
      appendTypeNode(sb,lastColon.getLastChild());
    }
 else {
      sb.append(lastColon.getString());
    }
    sb.append(""String_Node_Str"");
  }
 else   if (typeNode.getToken() == Token.VOID) {
    sb.append(""String_Node_Str"");
  }
 else {
    if (typeNode.hasChildren()) {
      sb.append(typeNode.getString()).append(""String_Node_Str"");
      Node child=typeNode.getFirstChild();
      appendTypeNode(sb,child.getFirstChild());
      for (int i=1; i < child.getChildCount(); i++) {
        sb.append(""String_Node_Str"");
        appendTypeNode(sb,child.getChildAtIndex(i));
      }
      sb.append(""String_Node_Str"");
    }
 else {
      sb.append(typeNode.getString());
    }
  }
}",0.9752161383285304
27354,"private void fixTypeNode(Node typeNode){
  if (typeNode.isString()) {
    String name=typeNode.getString();
    int endIndex=name.indexOf('.');
    if (endIndex == -1) {
      endIndex=name.length();
    }
    String baseName=name.substring(0,endIndex);
    Var aliasVar=aliases.get(baseName);
    if (aliasVar != null) {
      aliasUsages.add(new AliasedTypeNode(aliasVar,typeNode));
    }
  }
  for (Node child=typeNode.getFirstChild(); child != null; child=child.getNext()) {
    fixTypeNode(child);
  }
}","private void fixTypeNode(Node typeNode){
  if (typeNode.isString()) {
    String name=typeNode.getString();
    int endIndex=name.indexOf('.');
    if (endIndex == -1) {
      endIndex=name.length();
    }
    String baseName=name.substring(0,endIndex);
    Var aliasVar=aliases.get(baseName);
    if (aliasVar != null) {
      aliasUsages.add(new AliasedTypeNode(aliasVar,typeNode));
    }
    if (compiler.getOptions().preservesDetailedSourceInfo()) {
      typeNode.setOriginalName(name);
    }
  }
  for (Node child=typeNode.getFirstChild(); child != null; child=child.getNext()) {
    fixTypeNode(child);
  }
}",0.904719501335708
27355,"@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (isCallToScopeMethod(n)) {
    validateScopeCall(t,n,n.getParent());
  }
  if (!inGoogScopeBody()) {
    return;
  }
  Token type=n.getToken();
  boolean isObjLitShorthand=type == Token.STRING_KEY && !n.hasChildren();
  Var aliasVar=null;
  if (type == Token.NAME || isObjLitShorthand) {
    String name=n.getString();
    Var lexicalVar=t.getScope().getVar(name);
    if (lexicalVar != null && lexicalVar == aliases.get(name)) {
      aliasVar=lexicalVar;
    }
  }
  if (isGoogScopeFunctionBody(t.getEnclosingFunction().getLastChild())) {
    if (aliasVar != null && !isObjLitShorthand && NodeUtil.isLValue(n)) {
      if (aliasVar.getNode() == n) {
        aliasDefinitionsInOrder.add(n);
        return;
      }
 else {
        report(t,n,GOOG_SCOPE_ALIAS_REDEFINED,n.getString());
      }
    }
    if (type == Token.RETURN) {
      report(t,n,GOOG_SCOPE_USES_RETURN);
    }
 else     if (type == Token.THIS) {
      report(t,n,GOOG_SCOPE_REFERENCES_THIS);
    }
 else     if (type == Token.THROW) {
      report(t,n,GOOG_SCOPE_USES_THROW);
    }
  }
  if (inGoogScopeBody()) {
    if (aliasVar != null) {
      aliasUsages.add(new AliasedNode(aliasVar,n));
    }
    JSDocInfo info=n.getJSDocInfo();
    if (info != null && !injectedDecls.contains(n)) {
      for (      Node node : info.getTypeNodes()) {
        fixTypeNode(node);
      }
    }
  }
}","@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (isCallToScopeMethod(n)) {
    validateScopeCall(t,n,n.getParent());
  }
  if (!inGoogScopeBody()) {
    return;
  }
  Token type=n.getToken();
  boolean isObjLitShorthand=type == Token.STRING_KEY && !n.hasChildren();
  Var aliasVar=null;
  if (type == Token.NAME || isObjLitShorthand) {
    String name=n.getString();
    Var lexicalVar=t.getScope().getVar(name);
    if (lexicalVar != null && lexicalVar == aliases.get(name)) {
      aliasVar=lexicalVar;
      if (compiler.getOptions().preservesDetailedSourceInfo() && n.isName()) {
        n.setOriginalName(name);
      }
    }
  }
  if (isGoogScopeFunctionBody(t.getEnclosingFunction().getLastChild())) {
    if (aliasVar != null && !isObjLitShorthand && NodeUtil.isLValue(n)) {
      if (aliasVar.getNode() == n) {
        aliasDefinitionsInOrder.add(n);
        return;
      }
 else {
        report(t,n,GOOG_SCOPE_ALIAS_REDEFINED,n.getString());
      }
    }
    if (type == Token.RETURN) {
      report(t,n,GOOG_SCOPE_USES_RETURN);
    }
 else     if (type == Token.THIS) {
      report(t,n,GOOG_SCOPE_REFERENCES_THIS);
    }
 else     if (type == Token.THROW) {
      report(t,n,GOOG_SCOPE_USES_THROW);
    }
  }
  if (inGoogScopeBody()) {
    if (aliasVar != null) {
      aliasUsages.add(new AliasedNode(aliasVar,n));
    }
    JSDocInfo info=n.getJSDocInfo();
    if (info != null && !injectedDecls.contains(n)) {
      for (      Node node : info.getTypeNodes()) {
        fixTypeNode(node);
      }
    }
  }
}",0.9596774193548387
27356,"@Override protected void add(Node n,Context context){
  Node parent=n.getParent();
  if (parent != null && (parent.isBlock() || parent.isScript())) {
    if (n.isFunction()) {
      add(getFunctionAnnotation(n));
    }
 else     if (n.isExprResult() && n.getFirstChild().isAssign()) {
      Node assign=n.getFirstChild();
      if (NodeUtil.isNamespaceDecl(assign.getFirstChild())) {
        add(JSDocInfoPrinter.print(assign.getJSDocInfo()));
      }
 else {
        Node rhs=assign.getLastChild();
        add(getTypeAnnotation(rhs));
      }
    }
 else     if (n.isVar() && n.getFirstFirstChild() != null) {
      if (NodeUtil.isNamespaceDecl(n.getFirstChild())) {
        add(JSDocInfoPrinter.print(n.getJSDocInfo()));
      }
 else {
        add(getTypeAnnotation(n.getFirstFirstChild()));
      }
    }
  }
  super.add(n,context);
}","@Override protected void add(Node n,Context context){
  Node parent=n.getParent();
  if (parent != null && (parent.isBlock() || parent.isScript())) {
    if (n.isFunction()) {
      add(getFunctionAnnotation(n));
    }
 else     if (n.isExprResult() && n.getFirstChild().isAssign()) {
      Node assign=n.getFirstChild();
      if (NodeUtil.isNamespaceDecl(assign.getFirstChild())) {
        add(jsDocInfoPrinter.print(assign.getJSDocInfo()));
      }
 else {
        Node rhs=assign.getLastChild();
        add(getTypeAnnotation(rhs));
      }
    }
 else     if (n.isVar() && n.getFirstFirstChild() != null) {
      if (NodeUtil.isNamespaceDecl(n.getFirstChild())) {
        add(jsDocInfoPrinter.print(n.getJSDocInfo()));
      }
 else {
        add(getTypeAnnotation(n.getFirstFirstChild()));
      }
    }
  }
  super.add(n,context);
}",0.5768772348033373
27357,"TypedCodeGenerator(CodeConsumer consumer,CompilerOptions options,TypeIRegistry registry){
  super(consumer,options);
  Preconditions.checkNotNull(registry);
  this.registry=registry;
}","TypedCodeGenerator(CodeConsumer consumer,CompilerOptions options,TypeIRegistry registry){
  super(consumer,options);
  Preconditions.checkNotNull(registry);
  this.registry=registry;
  this.jsDocInfoPrinter=new JSDocInfoPrinter(options.getUseOriginalNamesInOutput());
}",0.8123620309050773
27358,"private ParseTree parseCoverParenthesizedExpressionAndArrowParameterList(){
  if (peekType(1) == TokenType.FOR) {
    return parseGeneratorComprehension();
  }
  SourcePosition start=getTreeStartLocation();
  eat(TokenType.OPEN_PAREN);
  if (peek(TokenType.CLOSE_PAREN)) {
    eat(TokenType.CLOSE_PAREN);
    return new FormalParameterListTree(getTreeLocation(start),ImmutableList.<ParseTree>of());
  }
  if (peek(TokenType.SPREAD)) {
    ParseTree result=new FormalParameterListTree(getTreeLocation(start),ImmutableList.of(parseParameter(ParamContext.IMPLEMENTATION)));
    eat(TokenType.CLOSE_PAREN);
    return result;
  }
  ParseTree result=parseExpression();
  if (peek(TokenType.COMMA)) {
    eat(TokenType.COMMA);
    result=new CommaExpressionTree(getTreeLocation(start),ImmutableList.of(result,parseParameter(ParamContext.IMPLEMENTATION)));
  }
  eat(TokenType.CLOSE_PAREN);
  return new ParenExpressionTree(getTreeLocation(start),result);
}","private ParseTree parseCoverParenthesizedExpressionAndArrowParameterList(){
  if (peekType(1) == TokenType.FOR) {
    return parseGeneratorComprehension();
  }
  SourcePosition start=getTreeStartLocation();
  eat(TokenType.OPEN_PAREN);
  if (peek(TokenType.CLOSE_PAREN)) {
    eat(TokenType.CLOSE_PAREN);
    if (peek(TokenType.ARROW)) {
      return new FormalParameterListTree(getTreeLocation(start),ImmutableList.<ParseTree>of());
    }
 else {
      reportError(""String_Node_Str"");
      return new MissingPrimaryExpressionTree(getTreeLocation(start));
    }
  }
  if (peek(TokenType.SPREAD)) {
    ImmutableList<ParseTree> params=ImmutableList.of(parseParameter(ParamContext.IMPLEMENTATION));
    eat(TokenType.CLOSE_PAREN);
    if (peek(TokenType.ARROW)) {
      return new FormalParameterListTree(getTreeLocation(start),params);
    }
 else {
      reportError(""String_Node_Str"");
      return new MissingPrimaryExpressionTree(getTreeLocation(start));
    }
  }
  ParseTree result=parseExpression();
  if (peek(TokenType.COMMA)) {
    eat(TokenType.COMMA);
    result=new CommaExpressionTree(getTreeLocation(start),ImmutableList.of(result,parseParameter(ParamContext.IMPLEMENTATION)));
  }
  eat(TokenType.CLOSE_PAREN);
  return new ParenExpressionTree(getTreeLocation(start),result);
}",0.7757467677218012
27359,"private ParseTree parseAssignment(Expression expressionIn){
  if (peek(TokenType.YIELD) && inGeneratorContext()) {
    return parseYield(expressionIn);
  }
  SourcePosition start=getTreeStartLocation();
  ParseTree left=parseConditional(expressionIn);
  if (peek(TokenType.ARROW)) {
    return completeAssignmentExpressionParseAtArrow(left,expressionIn);
  }
  if (left.type == ParseTreeType.FORMAL_PARAMETER_LIST) {
    reportError(""String_Node_Str"");
  }
  if (peekAssignmentOperator()) {
    left=transformLeftHandSideExpression(left);
    if (!left.isValidAssignmentTarget()) {
      reportError(""String_Node_Str"");
    }
    Token operator=nextToken();
    if (TokenType.STAR_STAR_EQUAL.equals(operator.type)) {
      features=features.require(Feature.EXPONENT_OP);
    }
    ParseTree right=parseAssignment(expressionIn);
    return new BinaryOperatorTree(getTreeLocation(start),left,operator,right);
  }
  return left;
}","private ParseTree parseAssignment(Expression expressionIn){
  if (peek(TokenType.YIELD) && inGeneratorContext()) {
    return parseYield(expressionIn);
  }
  SourcePosition start=getTreeStartLocation();
  ParseTree left=parseConditional(expressionIn);
  if (peek(TokenType.ARROW)) {
    return completeAssignmentExpressionParseAtArrow(left,expressionIn);
  }
  if (peekAssignmentOperator()) {
    left=transformLeftHandSideExpression(left);
    if (!left.isValidAssignmentTarget()) {
      reportError(""String_Node_Str"");
    }
    Token operator=nextToken();
    if (TokenType.STAR_STAR_EQUAL.equals(operator.type)) {
      features=features.require(Feature.EXPONENT_OP);
    }
    ParseTree right=parseAssignment(expressionIn);
    return new BinaryOperatorTree(getTreeLocation(start),left,operator,right);
  }
  return left;
}",0.9441913439635536
27360,"@Override public boolean isUnresolved(){
  return isUnknown();
}","@Override public boolean isUnresolved(){
  return false;
}",0.8852459016393442
27361,"public void testCustomBanUnresolvedType(){
  configuration=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  this.mode=TypeInferenceMode.OTI_ONLY;
  testSame(EXTERNS,""String_Node_Str"" + ""String_Node_Str"",CheckConformance.CONFORMANCE_VIOLATION,""String_Node_Str"");
}","public void testCustomBanUnresolvedType(){
  configuration=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  this.mode=TypeInferenceMode.OTI_ONLY;
  testSame(EXTERNS,""String_Node_Str"" + ""String_Node_Str"",CheckConformance.CONFORMANCE_VIOLATION,""String_Node_Str"");
  this.mode=TypeInferenceMode.BOTH;
  testSame(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.7815230961298377
27362,"@Override public void visit(NodeTraversal t,Node n,Node parent){
switch (n.getType()) {
case FUNCTION:
    Node grandparent=parent.getParent();
  if (grandparent == null || (!isPrototypePropertyDeclaration(grandparent) && !isClassPropertyDeclaration(parent.getFirstChild(),currentScope))) {
    RawNominalType ownerType=maybeGetOwnerType(n,parent);
    visitFunctionLate(n,ownerType);
  }
break;
case NAME:
{
String name=n.getString();
if (name == null || parent.isFunction()) {
  return;
}
if (parent.isVar() || parent.isCatch()) {
  visitVar(n,parent);
}
 else if (currentScope.isOuterVarEarly(name)) {
  currentScope.addOuterVar(name);
}
 else if (currentScope.getTypedef(name) != null || !name.equals(currentScope.getName()) && !currentScope.isDefinedLocally(name,false)) {
}
break;
}
case GETPROP:
if (NodeUtil.isPropertyTest(compiler,n) || isPropertyAbsentTest(n)) {
allPropertyNames.add(n.getLastChild().getString());
}
if (parent.isExprResult() && n.isQualifiedName()) {
visitPropertyDeclaration(n);
}
break;
case ASSIGN:
{
Node lvalue=n.getFirstChild();
if (lvalue.isGetProp() && lvalue.isQualifiedName() && parent.isExprResult()) {
visitPropertyDeclaration(lvalue);
}
break;
}
case CAST:
castTypes.put(n,getDeclaredTypeOfNode(n.getJSDocInfo(),currentScope));
break;
case OBJECTLIT:
visitObjectLit(n,parent);
break;
case CALL:
visitCall(n);
break;
default :
break;
}
}","@Override public void visit(NodeTraversal t,Node n,Node parent){
switch (n.getType()) {
case FUNCTION:
    Node grandparent=parent.getParent();
  if (grandparent == null || (!isPrototypePropertyDeclaration(grandparent) && !isClassPropertyDeclaration(parent.getFirstChild(),currentScope))) {
    RawNominalType ownerType=maybeGetOwnerType(n,parent);
    visitFunctionLate(n,ownerType);
  }
break;
case NAME:
{
String name=n.getString();
if (name == null || parent.isFunction()) {
  return;
}
if (parent.isVar() || parent.isCatch()) {
  visitVar(n,parent);
}
 else if (currentScope.isOuterVarEarly(name)) {
  currentScope.addOuterVar(name);
}
 else if (currentScope.getTypedef(name) != null || !name.equals(currentScope.getName()) && !currentScope.isDefinedLocally(name,false)) {
}
break;
}
case GETPROP:
if (NodeUtil.isPropertyTest(compiler,n) || isPropertyAbsentTest(n)) {
allPropertyNames.add(n.getLastChild().getString());
}
if (parent.isExprResult() && n.isQualifiedName()) {
visitPropertyDeclaration(n);
}
break;
case ASSIGN:
{
Node lvalue=n.getFirstChild();
if (lvalue.isGetProp() && lvalue.isQualifiedName()) {
visitPropertyDeclaration(lvalue);
}
break;
}
case CAST:
castTypes.put(n,getDeclaredTypeOfNode(n.getJSDocInfo(),currentScope));
break;
case OBJECTLIT:
visitObjectLit(n,parent);
break;
case CALL:
visitCall(n);
break;
default :
break;
}
}",0.9908391352143644
27363,"boolean isPropDefinedOnSubtype(QualifiedName pname){
  Preconditions.checkArgument(pname.isIdentifier());
  return this.rawType.isPropDefinedOnSubtype(this,pname);
}","boolean isPropDefinedOnSubtype(QualifiedName pname){
  Preconditions.checkArgument(pname.isIdentifier());
  return this.rawType.isPropDefinedOnSubtype(pname.getLeftmostName());
}",0.932944606413994
27364,"boolean isPropDefinedOnSubtype(QualifiedName pname){
  Preconditions.checkArgument(pname.isIdentifier());
  NominalType nt=getNominalType();
  Preconditions.checkState(!nt.isBuiltinObject());
  return nt.isPropDefinedOnSubtype(pname);
}","boolean isPropDefinedOnSubtype(QualifiedName pname){
  Preconditions.checkArgument(pname.isIdentifier());
  NominalType nt=getNominalType();
  return nt.isBuiltinObject() ? false : nt.isPropDefinedOnSubtype(pname);
}",0.6637168141592921
27365,"/** 
 * @return Whether the superclass can be added without creating a cycle. 
 */
public boolean addSuperClass(NominalType superclass){
  Preconditions.checkState(!this.isFinalized);
  Preconditions.checkState(this.superclass == null);
  if (superclass.hasAncestorClass(this)) {
    return false;
  }
  this.superclass=superclass;
  addSubtypeTo(superclass,this);
  return true;
}","/** 
 * @return Whether the superclass can be added without creating a cycle. 
 */
public boolean addSuperClass(NominalType superclass){
  Preconditions.checkState(!this.isFinalized);
  Preconditions.checkState(this.superclass == null);
  if (superclass.hasAncestorClass(this)) {
    return false;
  }
  this.superclass=superclass;
  superclass.getRawNominalType().addSubtype(this);
  return true;
}",0.941025641025641
27366,"/** 
 * @return Whether the interface can be added without creating a cycle. 
 */
public boolean addInterfaces(ImmutableSet<NominalType> interfaces){
  Preconditions.checkState(!this.isFinalized);
  Preconditions.checkState(this.interfaces == null);
  Preconditions.checkNotNull(interfaces);
  if (this.isInterface()) {
    for (    NominalType interf : interfaces) {
      if (interf.hasAncestorInterface(this)) {
        this.interfaces=ImmutableSet.of();
        return false;
      }
    }
  }
  for (  NominalType interf : interfaces) {
    if (interf.getRawNominalType().inheritsFromIObjectReflexive()) {
      this.objectKind=ObjectKind.UNRESTRICTED;
    }
    addSubtypeTo(interf,this);
  }
  this.interfaces=interfaces;
  return true;
}","/** 
 * @return Whether the interface can be added without creating a cycle. 
 */
public boolean addInterfaces(ImmutableSet<NominalType> interfaces){
  Preconditions.checkState(!this.isFinalized);
  Preconditions.checkState(this.interfaces == null);
  Preconditions.checkNotNull(interfaces);
  if (this.isInterface()) {
    for (    NominalType interf : interfaces) {
      if (interf.hasAncestorInterface(this)) {
        this.interfaces=ImmutableSet.of();
        return false;
      }
    }
  }
  for (  NominalType interf : interfaces) {
    if (interf.getRawNominalType().inheritsFromIObjectReflexive()) {
      this.objectKind=ObjectKind.UNRESTRICTED;
    }
    interf.getRawNominalType().addSubtype(this);
  }
  this.interfaces=interfaces;
  return true;
}",0.9655172413793104
27367,"boolean isPropDefinedOnSubtype(NominalType thisAsNominal,QualifiedName qname){
  Preconditions.checkArgument(qname.isIdentifier());
  String pname=qname.getLeftmostName();
  for (  RawNominalType subtype : this.subtypes.get(thisAsNominal)) {
    if (subtype.mayHaveProp(pname)) {
      return true;
    }
  }
  return false;
}","boolean isPropDefinedOnSubtype(String pname){
  if (mayHaveProp(pname)) {
    return true;
  }
  for (  RawNominalType subtype : this.subtypes) {
    if (subtype.isPropDefinedOnSubtype(pname)) {
      return true;
    }
  }
  return false;
}",0.1798941798941798
27368,"public void testPropertyCheckingCompatibility(){
  compilerOptions.setWarningLevel(DiagnosticGroups.NEW_CHECK_TYPES_EXTRA_CHECKS,CheckLevel.OFF);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INEXISTENT_PROPERTY);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testPropertyCheckingCompatibility(){
  compilerOptions.setWarningLevel(DiagnosticGroups.NEW_CHECK_TYPES_EXTRA_CHECKS,CheckLevel.OFF);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INEXISTENT_PROPERTY);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INEXISTENT_PROPERTY);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.7586007516623302
27369,"/** 
 * Creates a SuggestedFix for the given error. Note that some errors have multiple fixes so getFixesForJsError should often be used instead of this.
 */
public static SuggestedFix getFixForJsError(JSError error,AbstractCompiler compiler){
switch (error.getType().key) {
case ""String_Node_Str"":
    return getFixForMissingSemicolon(error,compiler);
case ""String_Node_Str"":
  return getFixForUnsortedRequiresOrProvides(""String_Node_Str"",error,compiler);
case ""String_Node_Str"":
return getFixForUnsortedRequiresOrProvides(""String_Node_Str"",error,compiler);
case ""String_Node_Str"":
case ""String_Node_Str"":
return removeNode(error,compiler);
case ""String_Node_Str"":
return getFixForInexistentProperty(error,compiler);
case ""String_Node_Str"":
return getFixForMissingSuper(error,compiler);
case ""String_Node_Str"":
return getFixForInvalidSuper(error,compiler);
case ""String_Node_Str"":
case ""String_Node_Str"":
return getFixForMissingRequire(error,compiler);
case ""String_Node_Str"":
return getFixForExtraRequire(error,compiler,DUPLICATE_REQUIRE);
case ""String_Node_Str"":
return getFixForExtraRequire(error,compiler,EXTRA_REQUIRE);
default :
return null;
}
}","/** 
 * Creates a SuggestedFix for the given error. Note that some errors have multiple fixes so getFixesForJsError should often be used instead of this.
 */
public static SuggestedFix getFixForJsError(JSError error,AbstractCompiler compiler){
switch (error.getType().key) {
case ""String_Node_Str"":
    return getFixForMissingSemicolon(error,compiler);
case ""String_Node_Str"":
  return getFixForUnsortedRequiresOrProvides(""String_Node_Str"",error,compiler);
case ""String_Node_Str"":
return getFixForUnsortedRequiresOrProvides(""String_Node_Str"",error,compiler);
case ""String_Node_Str"":
case ""String_Node_Str"":
return removeNode(error,compiler);
case ""String_Node_Str"":
return getFixForInexistentProperty(error,compiler);
case ""String_Node_Str"":
return getFixForMissingSuper(error,compiler);
case ""String_Node_Str"":
return getFixForInvalidSuper(error,compiler);
case ""String_Node_Str"":
case ""String_Node_Str"":
return getFixForMissingRequire(error,compiler);
case ""String_Node_Str"":
return getFixForExtraRequire(error,compiler,DUPLICATE_REQUIRE);
case ""String_Node_Str"":
return getFixForExtraRequire(error,compiler,EXTRA_REQUIRE);
case ""String_Node_Str"":
return getFixForReferenceToShortImportByLongName(error,compiler);
default :
return null;
}
}",0.946532999164578
27370,"/** 
 * Returns whether two nodes are equivalent, taking into account the template parameters that were provided to this matcher. If the template comparison node is a parameter node, then only the types of the node must match. Otherwise, the node must be equal and the child nodes must be equivalent according to the same function. This differs from the built in Node equivalence function with the special comparison.
 */
private boolean matchesNode(Node template,Node ast){
  if (isTemplateParameterNode(template)) {
    int paramIndex=(int)(template.getDouble());
    Node previousMatch=paramNodeMatches.get(paramIndex);
    if (previousMatch != null) {
      return ast.isEquivalentTo(previousMatch);
    }
    JSType templateType=template.getJSType();
    Preconditions.checkNotNull(templateType,""String_Node_Str"");
    if (templateType.isNoResolvedType()) {
      return false;
    }
    MatchResult matchResult=typeMatchingStrategy.match(templateType,ast.getJSType());
    isLooseMatch=matchResult.isLooseMatch();
    boolean isMatch=matchResult.isMatch();
    if (isMatch && previousMatch == null) {
      paramNodeMatches.set(paramIndex,ast);
    }
    return isMatch;
  }
 else   if (isTemplateLocalNameNode(template)) {
    int paramIndex=(int)(template.getDouble());
    boolean previouslyMatched=this.localVarMatches.get(paramIndex) != null;
    if (previouslyMatched) {
      return ast.getString().equals(this.localVarMatches.get(paramIndex));
    }
 else {
      this.localVarMatches.set(paramIndex,ast.getString());
    }
  }
  Node templateChild=template.getFirstChild();
  Node astChild=ast.getFirstChild();
  while (templateChild != null) {
    if (!matchesNode(templateChild,astChild)) {
      return false;
    }
    templateChild=templateChild.getNext();
    astChild=astChild.getNext();
  }
  return true;
}","/** 
 * Returns whether two nodes are equivalent, taking into account the template parameters that were provided to this matcher. If the template comparison node is a parameter node, then only the types of the node must match. Otherwise, the node must be equal and the child nodes must be equivalent according to the same function. This differs from the built in Node equivalence function with the special comparison.
 */
private boolean matchesNode(Node template,Node ast){
  if (isTemplateParameterNode(template)) {
    int paramIndex=(int)(template.getDouble());
    Node previousMatch=paramNodeMatches.get(paramIndex);
    if (previousMatch != null) {
      return ast.isEquivalentTo(previousMatch);
    }
    JSType templateType=template.getJSType();
    Preconditions.checkNotNull(templateType,""String_Node_Str"");
    if (isUnresolvedType(templateType)) {
      return false;
    }
    MatchResult matchResult=typeMatchingStrategy.match(templateType,ast.getJSType());
    isLooseMatch=matchResult.isLooseMatch();
    boolean isMatch=matchResult.isMatch();
    if (isMatch && previousMatch == null) {
      paramNodeMatches.set(paramIndex,ast);
    }
    return isMatch;
  }
 else   if (isTemplateLocalNameNode(template)) {
    int paramIndex=(int)(template.getDouble());
    boolean previouslyMatched=this.localVarMatches.get(paramIndex) != null;
    if (previouslyMatched) {
      return ast.getString().equals(this.localVarMatches.get(paramIndex));
    }
 else {
      this.localVarMatches.set(paramIndex,ast.getString());
    }
  }
  Node templateChild=template.getFirstChild();
  Node astChild=ast.getFirstChild();
  while (templateChild != null) {
    if (!matchesNode(templateChild,astChild)) {
      return false;
    }
    templateChild=templateChild.getNext();
    astChild=astChild.getNext();
  }
  return true;
}",0.9882481552336704
27371,"@Override protected List<PassFactory> getOptimizations(){
  List<PassFactory> passes=new ArrayList<>();
  if (options.skipNonTranspilationPasses) {
    return passes;
  }
  passes.add(gatherExternProperties);
  passes.add(garbageCollectChecks);
  if (options.instrumentForCoverage) {
    passes.add(instrumentForCodeCoverage);
  }
  if (options.runtimeTypeCheck) {
    passes.add(runtimeTypeCheck);
  }
  if (options.j2clPassMode.shouldAddJ2clPasses()) {
    passes.add(j2clPass);
    passes.add(j2clPropertyInlinerPass);
  }
  passes.add(createEmptyPass(""String_Node_Str""));
  if (options.replaceIdGenerators) {
    passes.add(replaceIdGenerators);
  }
  if (options.optimizeArgumentsArray) {
    passes.add(optimizeArgumentsArray);
  }
  if (options.closurePass && (options.removeAbstractMethods || options.removeClosureAsserts)) {
    passes.add(closureCodeRemoval);
  }
  if (options.disambiguatePrivateProperties) {
    passes.add(disambiguatePrivateProperties);
  }
  if (options.collapseProperties) {
    passes.add(collapseProperties);
  }
  if (options.inferConsts) {
    passes.add(inferConsts);
  }
  if (options.reportPath != null && options.smartNameRemoval) {
    passes.add(initNameAnalyzeReport);
  }
  if (options.extraSmartNameRemoval && options.smartNameRemoval) {
    if (options.foldConstants && (options.inlineVariables || options.inlineLocalVariables)) {
      passes.add(earlyInlineVariables);
      passes.add(earlyPeepholeOptimizations);
    }
    passes.add(extraSmartNamePass);
  }
  if (options.rewritePolyfills) {
    passes.add(removeUnusedPolyfills);
  }
  if (options.shouldDisambiguateProperties()) {
    passes.add(disambiguateProperties);
  }
  if (options.computeFunctionSideEffects) {
    passes.add(markPureFunctions);
  }
 else   if (options.markNoSideEffectCalls) {
    passes.add(markNoSideEffectCalls);
  }
  if (options.chainCalls) {
    passes.add(chainCalls);
  }
  passes.add(checkConstParams);
  assertAllOneTimePasses(passes);
  if (options.smartNameRemoval || options.reportPath != null) {
    passes.addAll(getCodeRemovingPasses());
    passes.add(smartNamePass);
  }
  if (options.closurePass) {
    passes.add(closureOptimizePrimitives);
  }
  if (!options.replaceStringsFunctionDescriptions.isEmpty()) {
    passes.add(replaceStrings);
  }
  if (options.crossModuleCodeMotion) {
    passes.add(crossModuleCodeMotion);
  }
  if (options.devirtualizePrototypeMethods) {
    passes.add(devirtualizePrototypeMethods);
  }
  if (options.customPasses != null) {
    passes.add(getCustomPasses(CustomPassExecutionTime.BEFORE_OPTIMIZATION_LOOP));
  }
  passes.add(createEmptyPass(""String_Node_Str""));
  if (options.inlineVariables || options.inlineLocalVariables) {
    passes.add(flowSensitiveInlineVariables);
  }
  passes.addAll(getMainOptimizationLoop());
  passes.add(createEmptyPass(""String_Node_Str""));
  passes.add(createEmptyPass(""String_Node_Str""));
  if (options.crossModuleCodeMotion) {
    passes.add(crossModuleCodeMotion);
  }
  if (options.crossModuleMethodMotion) {
    passes.add(crossModuleMethodMotion);
  }
  passes.add(createEmptyPass(""String_Node_Str""));
  if (options.customPasses != null) {
    passes.add(getCustomPasses(CustomPassExecutionTime.AFTER_OPTIMIZATION_LOOP));
  }
  if (options.inlineVariables || options.inlineLocalVariables) {
    passes.add(flowSensitiveInlineVariables);
    if (options.removeUnusedVars || options.removeUnusedLocalVars) {
      passes.add(getRemoveUnusedVars(""String_Node_Str"",false));
    }
  }
  if (options.smartNameRemoval) {
    passes.add(smartNamePass2);
  }
  if (options.collapseAnonymousFunctions) {
    passes.add(collapseAnonymousFunctions);
  }
  if (options.moveFunctionDeclarations || options.renamePrefixNamespace != null) {
    passes.add(moveFunctionDeclarations);
  }
  if (options.anonymousFunctionNaming == AnonymousFunctionNamingPolicy.MAPPED) {
    passes.add(nameMappedAnonymousFunctions);
  }
  if (options.extractPrototypeMemberDeclarations != ExtractPrototypeMemberDeclarationsMode.OFF) {
    passes.add(extractPrototypeMemberDeclarations);
  }
  if (options.shouldAmbiguateProperties() && (options.propertyRenaming == PropertyRenamingPolicy.ALL_UNQUOTED)) {
    passes.add(ambiguateProperties);
  }
  if (options.propertyRenaming == PropertyRenamingPolicy.ALL_UNQUOTED) {
    passes.add(renameProperties);
  }
  if (options.reserveRawExports) {
    passes.add(gatherRawExports);
  }
  if (options.convertToDottedProperties) {
    passes.add(convertToDottedProperties);
  }
  if (options.rewriteFunctionExpressions) {
    passes.add(rewriteFunctionExpressions);
  }
  if (!options.aliasableStrings.isEmpty() || options.aliasAllStrings) {
    passes.add(aliasStrings);
  }
  passes.add(markUnnormalized);
  if (options.coalesceVariableNames) {
    passes.add(coalesceVariableNames);
    if (options.foldConstants) {
      passes.add(peepholeOptimizations);
    }
  }
  if (options.collapseVariableDeclarations) {
    passes.add(exploitAssign);
    passes.add(collapseVariableDeclarations);
  }
  passes.add(denormalize);
  if (options.instrumentationTemplate != null) {
    passes.add(instrumentFunctions);
  }
  if (options.variableRenaming != VariableRenamingPolicy.ALL) {
    passes.add(invertContextualRenaming);
  }
  if (options.variableRenaming != VariableRenamingPolicy.OFF) {
    passes.add(renameVars);
  }
  if (options.processObjectPropertyString) {
    passes.add(objectPropertyStringPostprocess);
  }
  if (options.labelRenaming) {
    passes.add(renameLabels);
  }
  if (options.foldConstants) {
    passes.add(latePeepholeOptimizations);
  }
  if (options.anonymousFunctionNaming == AnonymousFunctionNamingPolicy.UNMAPPED) {
    passes.add(nameUnmappedAnonymousFunctions);
  }
  if (protectHiddenSideEffects) {
    passes.add(stripSideEffectProtection);
  }
  if (options.renamePrefixNamespace != null) {
    if (!GLOBAL_SYMBOL_NAMESPACE_PATTERN.matcher(options.renamePrefixNamespace).matches()) {
      throw new IllegalArgumentException(""String_Node_Str"" + options.renamePrefixNamespace);
    }
    passes.add(rescopeGlobalSymbols);
  }
  passes.add(sanityCheckAst);
  passes.add(sanityCheckVars);
  if (options.getLanguageOut().isEs6OrHigher()) {
    passes.add(optimizeToEs6);
    passes.add(rewriteBindThis);
  }
  return passes;
}","@Override protected List<PassFactory> getOptimizations(){
  List<PassFactory> passes=new ArrayList<>();
  if (options.skipNonTranspilationPasses) {
    return passes;
  }
  passes.add(gatherExternProperties);
  passes.add(garbageCollectChecks);
  if (options.instrumentForCoverage) {
    passes.add(instrumentForCodeCoverage);
  }
  if (options.runtimeTypeCheck) {
    passes.add(runtimeTypeCheck);
  }
  if (options.j2clPassMode.shouldAddJ2clPasses()) {
    passes.add(j2clPass);
    passes.add(j2clPropertyInlinerPass);
  }
  passes.add(createEmptyPass(""String_Node_Str""));
  if (options.replaceIdGenerators) {
    passes.add(replaceIdGenerators);
  }
  if (options.optimizeArgumentsArray) {
    passes.add(optimizeArgumentsArray);
  }
  if (options.closurePass && (options.removeAbstractMethods || options.removeClosureAsserts)) {
    passes.add(closureCodeRemoval);
  }
  if (options.disambiguatePrivateProperties) {
    passes.add(disambiguatePrivateProperties);
  }
  if (options.collapseProperties) {
    passes.add(collapseProperties);
  }
  if (options.inferConsts) {
    passes.add(inferConsts);
  }
  if (options.reportPath != null && options.smartNameRemoval) {
    passes.add(initNameAnalyzeReport);
  }
  if (options.extraSmartNameRemoval && options.smartNameRemoval) {
    if (options.foldConstants && (options.inlineVariables || options.inlineLocalVariables)) {
      passes.add(earlyInlineVariables);
      passes.add(earlyPeepholeOptimizations);
    }
    passes.add(extraSmartNamePass);
  }
  if (options.shouldDisambiguateProperties()) {
    passes.add(disambiguateProperties);
  }
  if (options.computeFunctionSideEffects) {
    passes.add(markPureFunctions);
  }
 else   if (options.markNoSideEffectCalls) {
    passes.add(markNoSideEffectCalls);
  }
  if (options.chainCalls) {
    passes.add(chainCalls);
  }
  passes.add(checkConstParams);
  assertAllOneTimePasses(passes);
  if (options.smartNameRemoval || options.reportPath != null) {
    passes.addAll(getCodeRemovingPasses());
    passes.add(smartNamePass);
  }
  if (options.closurePass) {
    passes.add(closureOptimizePrimitives);
  }
  if (!options.replaceStringsFunctionDescriptions.isEmpty()) {
    passes.add(replaceStrings);
  }
  if (options.crossModuleCodeMotion) {
    passes.add(crossModuleCodeMotion);
  }
  if (options.devirtualizePrototypeMethods) {
    passes.add(devirtualizePrototypeMethods);
  }
  if (options.customPasses != null) {
    passes.add(getCustomPasses(CustomPassExecutionTime.BEFORE_OPTIMIZATION_LOOP));
  }
  passes.add(createEmptyPass(""String_Node_Str""));
  if (options.inlineVariables || options.inlineLocalVariables) {
    passes.add(flowSensitiveInlineVariables);
  }
  passes.addAll(getMainOptimizationLoop());
  passes.add(createEmptyPass(""String_Node_Str""));
  passes.add(createEmptyPass(""String_Node_Str""));
  if (options.crossModuleCodeMotion) {
    passes.add(crossModuleCodeMotion);
  }
  if (options.crossModuleMethodMotion) {
    passes.add(crossModuleMethodMotion);
  }
  passes.add(createEmptyPass(""String_Node_Str""));
  if (options.customPasses != null) {
    passes.add(getCustomPasses(CustomPassExecutionTime.AFTER_OPTIMIZATION_LOOP));
  }
  if (options.inlineVariables || options.inlineLocalVariables) {
    passes.add(flowSensitiveInlineVariables);
    if (options.removeUnusedVars || options.removeUnusedLocalVars) {
      passes.add(getRemoveUnusedVars(""String_Node_Str"",false));
    }
  }
  if (options.smartNameRemoval) {
    passes.add(smartNamePass2);
  }
  if (options.collapseAnonymousFunctions) {
    passes.add(collapseAnonymousFunctions);
  }
  if (options.moveFunctionDeclarations || options.renamePrefixNamespace != null) {
    passes.add(moveFunctionDeclarations);
  }
  if (options.anonymousFunctionNaming == AnonymousFunctionNamingPolicy.MAPPED) {
    passes.add(nameMappedAnonymousFunctions);
  }
  if (options.extractPrototypeMemberDeclarations != ExtractPrototypeMemberDeclarationsMode.OFF) {
    passes.add(extractPrototypeMemberDeclarations);
  }
  if (options.shouldAmbiguateProperties() && (options.propertyRenaming == PropertyRenamingPolicy.ALL_UNQUOTED)) {
    passes.add(ambiguateProperties);
  }
  if (options.propertyRenaming == PropertyRenamingPolicy.ALL_UNQUOTED) {
    passes.add(renameProperties);
  }
  if (options.reserveRawExports) {
    passes.add(gatherRawExports);
  }
  if (options.convertToDottedProperties) {
    passes.add(convertToDottedProperties);
  }
  if (options.rewriteFunctionExpressions) {
    passes.add(rewriteFunctionExpressions);
  }
  if (!options.aliasableStrings.isEmpty() || options.aliasAllStrings) {
    passes.add(aliasStrings);
  }
  passes.add(markUnnormalized);
  if (options.coalesceVariableNames) {
    passes.add(coalesceVariableNames);
    if (options.foldConstants) {
      passes.add(peepholeOptimizations);
    }
  }
  if (options.collapseVariableDeclarations) {
    passes.add(exploitAssign);
    passes.add(collapseVariableDeclarations);
  }
  passes.add(denormalize);
  if (options.instrumentationTemplate != null) {
    passes.add(instrumentFunctions);
  }
  if (options.variableRenaming != VariableRenamingPolicy.ALL) {
    passes.add(invertContextualRenaming);
  }
  if (options.variableRenaming != VariableRenamingPolicy.OFF) {
    passes.add(renameVars);
  }
  if (options.processObjectPropertyString) {
    passes.add(objectPropertyStringPostprocess);
  }
  if (options.labelRenaming) {
    passes.add(renameLabels);
  }
  if (options.foldConstants) {
    passes.add(latePeepholeOptimizations);
  }
  if (options.anonymousFunctionNaming == AnonymousFunctionNamingPolicy.UNMAPPED) {
    passes.add(nameUnmappedAnonymousFunctions);
  }
  if (protectHiddenSideEffects) {
    passes.add(stripSideEffectProtection);
  }
  if (options.renamePrefixNamespace != null) {
    if (!GLOBAL_SYMBOL_NAMESPACE_PATTERN.matcher(options.renamePrefixNamespace).matches()) {
      throw new IllegalArgumentException(""String_Node_Str"" + options.renamePrefixNamespace);
    }
    passes.add(rescopeGlobalSymbols);
  }
  passes.add(sanityCheckAst);
  passes.add(sanityCheckVars);
  if (options.getLanguageOut().isEs6OrHigher()) {
    passes.add(optimizeToEs6);
    passes.add(rewriteBindThis);
  }
  return passes;
}",0.9938355616043552
27372,"void collectPropertyNames(Set<String> props){
  Set<PropertyMap> identitySet=Sets.newIdentityHashSet();
  collectPropertyNamesHelper(props,identitySet);
}","void collectPropertyNames(Set<String> props){
  props.addAll(properties.keySet());
  PropertyMap primaryParent=getPrimaryParent();
  if (primaryParent != null) {
    primaryParent.collectPropertyNames(props);
  }
  for (  PropertyMap p : getSecondaryParents()) {
    if (p != null) {
      p.collectPropertyNames(props);
    }
  }
}",0.2921810699588477
27373,"public void testInterfaceExtendsLoop2(){
  testClosureTypes(suppressMissingProperty(""String_Node_Str"") + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"");
}","public void testInterfaceExtendsLoop2(){
  testClosureTypesMultipleWarnings(suppressMissingProperty(""String_Node_Str"") + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",ImmutableList.of(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""));
}",0.7096774193548387
27374,"void collectPropertyNames(Set<String> props){
  props.addAll(properties.keySet());
  PropertyMap primaryParent=getPrimaryParent();
  if (primaryParent != null) {
    primaryParent.collectPropertyNames(props);
  }
  for (  PropertyMap p : getSecondaryParents()) {
    if (p != null) {
      p.collectPropertyNames(props);
    }
  }
}","void collectPropertyNames(Set<String> props){
  Set<PropertyMap> identitySet=Sets.newIdentityHashSet();
  collectPropertyNamesHelper(props,identitySet);
}",0.4444444444444444
27375,"public void testInterfaceExtendsLoop2(){
  testClosureTypesMultipleWarnings(suppressMissingProperty(""String_Node_Str"") + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",ImmutableList.of(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""));
}","public void testInterfaceExtendsLoop2(){
  testClosureTypes(suppressMissingProperty(""String_Node_Str"") + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"");
}",0.7459677419354839
27376,"@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (n.isExprResult()) {
    Node expr=n.getFirstChild();
    Node name=expr.isAssign() ? expr.getFirstChild() : expr;
    if (!name.isGetProp() || !name.getFirstChild().isThis()) {
      return;
    }
    JSType type=name.getJSType();
    String pname=name.getLastChild().getString();
    JSDocInfo jsdoc=NodeUtil.getBestJSDocInfo(name);
    Node initializer=null;
    if (type == null) {
      initializer=NodeUtil.getRValueOfLValue(name).detachFromParent();
    }
 else     if (isInferrableConst(jsdoc,name)) {
      jsdoc=maybeUpdateJSDocInfoWithType(jsdoc,name);
    }
    Node newProtoAssignStmt=NodeUtil.newQNameDeclaration(compiler,className + ""String_Node_Str"" + pname,initializer,jsdoc);
    newProtoAssignStmt.useSourceInfoIfMissingFromForTree(expr);
    insertionPoint.getParent().addChildAfter(newProtoAssignStmt,insertionPoint);
    compiler.reportCodeChange();
  }
}","@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (n.isExprResult()) {
    Node expr=n.getFirstChild();
    Node name=expr.isAssign() ? expr.getFirstChild() : expr;
    if (!name.isGetProp() || !name.getFirstChild().isThis()) {
      return;
    }
    String pname=name.getLastChild().getString();
    String fullyQualifiedName=className + ""String_Node_Str"" + pname;
    if (seenNames.contains(fullyQualifiedName)) {
      return;
    }
    JSType type=name.getJSType();
    JSDocInfo jsdoc=NodeUtil.getBestJSDocInfo(name);
    if (jsdoc == null) {
      jsdoc=getAllTypeJSDoc();
    }
 else     if (isInferrableConst(jsdoc,name)) {
      jsdoc=maybeUpdateJSDocInfoWithType(jsdoc,name);
      if (type == null) {
        compiler.report(JSError.make(name,CONSTANT_WITHOUT_EXPLICIT_TYPE));
        return;
      }
    }
    Node newProtoAssignStmt=NodeUtil.newQNameDeclaration(compiler,fullyQualifiedName,null,jsdoc);
    newProtoAssignStmt.useSourceInfoIfMissingFromForTree(expr);
    insertionPoint.getParent().addChildAfter(newProtoAssignStmt,insertionPoint);
    compiler.reportCodeChange();
    seenNames.add(fullyQualifiedName);
  }
}",0.7188983855650523
27377,"private void processConstructor(final Node function){
  final String className=getClassName(function);
  if (className == null) {
    return;
  }
  final Node insertionPoint=NodeUtil.getEnclosingStatement(function);
  NodeTraversal.traverseEs6(compiler,function.getLastChild(),new AbstractShallowStatementCallback(){
    @Override public void visit(    NodeTraversal t,    Node n,    Node parent){
      if (n.isExprResult()) {
        Node expr=n.getFirstChild();
        Node name=expr.isAssign() ? expr.getFirstChild() : expr;
        if (!name.isGetProp() || !name.getFirstChild().isThis()) {
          return;
        }
        JSType type=name.getJSType();
        String pname=name.getLastChild().getString();
        JSDocInfo jsdoc=NodeUtil.getBestJSDocInfo(name);
        Node initializer=null;
        if (type == null) {
          initializer=NodeUtil.getRValueOfLValue(name).detachFromParent();
        }
 else         if (isInferrableConst(jsdoc,name)) {
          jsdoc=maybeUpdateJSDocInfoWithType(jsdoc,name);
        }
        Node newProtoAssignStmt=NodeUtil.newQNameDeclaration(compiler,className + ""String_Node_Str"" + pname,initializer,jsdoc);
        newProtoAssignStmt.useSourceInfoIfMissingFromForTree(expr);
        insertionPoint.getParent().addChildAfter(newProtoAssignStmt,insertionPoint);
        compiler.reportCodeChange();
      }
    }
  }
);
}","private void processConstructor(final Node function){
  final String className=getClassName(function);
  if (className == null) {
    return;
  }
  final Node insertionPoint=NodeUtil.getEnclosingStatement(function);
  NodeTraversal.traverseEs6(compiler,function.getLastChild(),new AbstractShallowStatementCallback(){
    @Override public void visit(    NodeTraversal t,    Node n,    Node parent){
      if (n.isExprResult()) {
        Node expr=n.getFirstChild();
        Node name=expr.isAssign() ? expr.getFirstChild() : expr;
        if (!name.isGetProp() || !name.getFirstChild().isThis()) {
          return;
        }
        String pname=name.getLastChild().getString();
        String fullyQualifiedName=className + ""String_Node_Str"" + pname;
        if (seenNames.contains(fullyQualifiedName)) {
          return;
        }
        JSType type=name.getJSType();
        JSDocInfo jsdoc=NodeUtil.getBestJSDocInfo(name);
        if (jsdoc == null) {
          jsdoc=getAllTypeJSDoc();
        }
 else         if (isInferrableConst(jsdoc,name)) {
          jsdoc=maybeUpdateJSDocInfoWithType(jsdoc,name);
          if (type == null) {
            compiler.report(JSError.make(name,CONSTANT_WITHOUT_EXPLICIT_TYPE));
            return;
          }
        }
        Node newProtoAssignStmt=NodeUtil.newQNameDeclaration(compiler,fullyQualifiedName,null,jsdoc);
        newProtoAssignStmt.useSourceInfoIfMissingFromForTree(expr);
        insertionPoint.getParent().addChildAfter(newProtoAssignStmt,insertionPoint);
        compiler.reportCodeChange();
        seenNames.add(fullyQualifiedName);
      }
    }
  }
);
}",0.7585056704469646
27378,"private static boolean isUnknownType(JSType jsType){
  return jsType == null || jsType.isUnknownType() || jsType.isNoType();
}","private static boolean isUnknownType(JSType jsType){
  return jsType == null || jsType.isUnknownType() || jsType.isNoType() || jsType.isAllType();
}",0.9197080291970804
27379,"private static boolean isObjectType(Node n){
  JSType jsType=n.getJSType();
  if (jsType == null) {
    return false;
  }
  jsType=jsType.restrictByNotNullOrUndefined();
  return !jsType.isUnknownType() && !jsType.isNoType() && jsType.isObject();
}","private static boolean isObjectType(Node n){
  JSType jsType=n.getJSType();
  if (jsType == null) {
    return false;
  }
  jsType=jsType.restrictByNotNullOrUndefined();
  return !jsType.isUnknownType() && !jsType.isNoType() && !jsType.isAllType()&& jsType.isObject();
}",0.9575289575289576
27380,"private static boolean isNumberType(Node n){
  JSType jsType=n.getJSType();
  if (jsType == null) {
    return false;
  }
  return !jsType.isUnknownType() && !jsType.isNoType() && jsType.isNumberValueType();
}","private static boolean isNumberType(Node n){
  JSType jsType=n.getJSType();
  if (jsType == null) {
    return false;
  }
  return !jsType.isUnknownType() && !jsType.isNoType() && !jsType.isAllType()&& jsType.isNumberValueType();
}",0.95
27381,"private EnvTypePair analyzePropAccessFwd(Node receiver,String pname,TypeEnv inEnv,JSType requiredType,JSType specializedType){
  QualifiedName propQname=new QualifiedName(pname);
  Node propAccessNode=receiver.getParent();
  EnvTypePair pair;
  JSType reqObjType=pickReqObjType(propAccessNode);
  JSType recvReqType, recvSpecType;
  if (NodeUtil.isPropertyTest(compiler,propAccessNode) && !specializedType.isFalseOrFalsy() || specializedType.isTrueOrTruthy()) {
    recvReqType=reqObjType;
    pair=analyzeExprFwd(receiver,inEnv,recvReqType);
    JSType subtypeWithProp=pair.type.findSubtypeWithProp(propQname);
    if (subtypeWithProp.isBottom()) {
      recvSpecType=reqObjType;
    }
 else {
      recvSpecType=subtypeWithProp;
    }
    if (specializedType.isTrueOrTruthy()) {
      recvSpecType=recvSpecType.withLoose().withProperty(propQname,specializedType);
    }
 else {
      recvSpecType=recvSpecType.withProperty(propQname,specializedType);
    }
  }
 else   if (specializedType.isFalseOrFalsy()) {
    recvReqType=recvSpecType=reqObjType;
  }
 else {
    recvReqType=reqObjType.withProperty(propQname,requiredType);
    recvSpecType=reqObjType.withProperty(propQname,specializedType);
  }
  pair=analyzeExprFwd(receiver,inEnv,recvReqType,recvSpecType);
  pair=mayWarnAboutNullableReferenceAndTighten(receiver,pair.type,recvSpecType,pair.env);
  JSType recvType=pair.type.autobox();
  if (recvType.isUnknown() || mayWarnAboutNonObject(receiver,recvType,specializedType)) {
    return new EnvTypePair(pair.env,requiredType);
  }
  FunctionType ft=recvType.getFunTypeIfSingletonObj();
  if (ft != null && pname.equals(""String_Node_Str"")) {
    return new EnvTypePair(pair.env,commonTypes.fromFunctionType(ft.transformByCallProperty()));
  }
  if (ft != null && pname.equals(""String_Node_Str"")) {
    return new EnvTypePair(pair.env,commonTypes.fromFunctionType(ft.transformByApplyProperty(commonTypes)));
  }
  if (this.convention.isSuperClassReference(pname)) {
    if (ft != null && ft.isUniqueConstructor()) {
      JSType result=ft.getSuperPrototype();
      pair.type=result != null ? result : JSType.UNDEFINED;
      return pair;
    }
  }
  if (propAccessNode.isGetProp() && mayWarnAboutDictPropAccess(receiver,recvType)) {
    return new EnvTypePair(pair.env,requiredType);
  }
  if (recvType.isTop()) {
    recvType=JSType.TOP_OBJECT;
  }
  QualifiedName getterPname=new QualifiedName(createGetterPropName(pname));
  if (recvType.hasProp(getterPname)) {
    return new EnvTypePair(pair.env,recvType.getProp(getterPname));
  }
  JSType resultType=recvType.getProp(propQname);
  if (resultType != null && resultType.isBottom()) {
    warnings.add(JSError.make(propAccessNode,BOTTOM_PROP,pname,recvType.toString()));
    return new EnvTypePair(pair.env,JSType.UNKNOWN);
  }
  if (!propAccessNode.getParent().isExprResult() && !specializedType.isTrueOrTruthy() && !specializedType.isFalseOrFalsy()&& !recvType.mayBeDict()&& !mayWarnAboutInexistentProp(propAccessNode,recvType,propQname,pair.env)&& recvType.hasProp(propQname)&& !resultType.isSubtypeOf(requiredType)&& tightenTypeAndDontWarn(receiver.isName() ? receiver.getString() : null,receiver,recvType.getDeclaredProp(propQname),resultType,requiredType)) {
    resultType=resultType.specialize(requiredType);
    LValueResultFwd lvr=analyzeLValueFwd(propAccessNode,inEnv,resultType);
    TypeEnv updatedEnv=updateLvalueTypeInEnv(lvr.env,propAccessNode,lvr.ptr,resultType);
    return new EnvTypePair(updatedEnv,resultType);
  }
  if (resultType == null) {
    resultType=JSType.UNKNOWN;
  }
  return new EnvTypePair(pair.env,resultType);
}","private EnvTypePair analyzePropAccessFwd(Node receiver,String pname,TypeEnv inEnv,JSType requiredType,JSType specializedType){
  QualifiedName propQname=new QualifiedName(pname);
  Node propAccessNode=receiver.getParent();
  EnvTypePair pair;
  JSType reqObjType=pickReqObjType(propAccessNode);
  JSType recvReqType, recvSpecType;
  if (NodeUtil.isPropertyTest(compiler,propAccessNode) && !specializedType.isFalseOrFalsy() || specializedType.isTrueOrTruthy()) {
    recvReqType=reqObjType;
    pair=analyzeExprFwd(receiver,inEnv,recvReqType);
    JSType subtypeWithProp=pair.type.findSubtypeWithProp(propQname);
    if (subtypeWithProp.isBottom()) {
      recvSpecType=reqObjType;
    }
 else {
      recvSpecType=subtypeWithProp;
    }
    if (specializedType.isTrueOrTruthy()) {
      recvSpecType=recvSpecType.withLoose().withProperty(propQname,specializedType);
    }
 else {
      recvSpecType=recvSpecType.withProperty(propQname,specializedType);
    }
  }
 else   if (specializedType.isFalseOrFalsy()) {
    recvReqType=recvSpecType=reqObjType;
  }
 else {
    recvReqType=reqObjType.withProperty(propQname,requiredType);
    recvSpecType=reqObjType.withProperty(propQname,specializedType);
  }
  pair=analyzeExprFwd(receiver,inEnv,recvReqType,recvSpecType);
  pair=mayWarnAboutNullableReferenceAndTighten(receiver,pair.type,recvSpecType,pair.env);
  JSType recvType=pair.type.autobox();
  if (recvType.isUnknown() || recvType.isTrueOrTruthy() || mayWarnAboutNonObject(receiver,recvType,specializedType)) {
    return new EnvTypePair(pair.env,requiredType);
  }
  FunctionType ft=recvType.getFunTypeIfSingletonObj();
  if (ft != null && pname.equals(""String_Node_Str"")) {
    return new EnvTypePair(pair.env,commonTypes.fromFunctionType(ft.transformByCallProperty()));
  }
  if (ft != null && pname.equals(""String_Node_Str"")) {
    return new EnvTypePair(pair.env,commonTypes.fromFunctionType(ft.transformByApplyProperty(commonTypes)));
  }
  if (this.convention.isSuperClassReference(pname)) {
    if (ft != null && ft.isUniqueConstructor()) {
      JSType result=ft.getSuperPrototype();
      pair.type=result != null ? result : JSType.UNDEFINED;
      return pair;
    }
  }
  if (propAccessNode.isGetProp() && mayWarnAboutDictPropAccess(receiver,recvType)) {
    return new EnvTypePair(pair.env,requiredType);
  }
  if (recvType.isTop()) {
    recvType=JSType.TOP_OBJECT;
  }
  QualifiedName getterPname=new QualifiedName(createGetterPropName(pname));
  if (recvType.hasProp(getterPname)) {
    return new EnvTypePair(pair.env,recvType.getProp(getterPname));
  }
  JSType resultType=recvType.getProp(propQname);
  if (resultType != null && resultType.isBottom()) {
    warnings.add(JSError.make(propAccessNode,BOTTOM_PROP,pname,recvType.toString()));
    return new EnvTypePair(pair.env,JSType.UNKNOWN);
  }
  if (!propAccessNode.getParent().isExprResult() && !specializedType.isTrueOrTruthy() && !specializedType.isFalseOrFalsy()&& !recvType.mayBeDict()&& !mayWarnAboutInexistentProp(propAccessNode,recvType,propQname,pair.env)&& recvType.hasProp(propQname)&& !resultType.isSubtypeOf(requiredType)&& tightenTypeAndDontWarn(receiver.isName() ? receiver.getString() : null,receiver,recvType.getDeclaredProp(propQname),resultType,requiredType)) {
    resultType=resultType.specialize(requiredType);
    LValueResultFwd lvr=analyzeLValueFwd(propAccessNode,inEnv,resultType);
    TypeEnv updatedEnv=updateLvalueTypeInEnv(lvr.env,propAccessNode,lvr.ptr,resultType);
    return new EnvTypePair(updatedEnv,resultType);
  }
  if (resultType == null) {
    resultType=JSType.UNKNOWN;
  }
  return new EnvTypePair(pair.env,resultType);
}",0.9959983441424036
27382,"public JSType getProp(QualifiedName qname){
  if (isBottom() || isUnknown()) {
    return UNKNOWN;
  }
  Preconditions.checkState(!getObjs().isEmpty() || !getEnums().isEmpty(),""String_Node_Str"",this);
  return nullAcceptingJoin(TypeWithPropertiesStatics.getProp(getObjs(),qname),TypeWithPropertiesStatics.getProp(getEnums(),qname));
}","public JSType getProp(QualifiedName qname){
  if (isBottom() || isUnknown() || hasTruthyMask()) {
    return UNKNOWN;
  }
  Preconditions.checkState(!getObjs().isEmpty() || !getEnums().isEmpty(),""String_Node_Str"",qname,this);
  return nullAcceptingJoin(TypeWithPropertiesStatics.getProp(getObjs(),qname),TypeWithPropertiesStatics.getProp(getEnums(),qname));
}",0.963924963924964
27383,"private static JSType meetHelper(JSType lhs,JSType rhs){
  if (lhs.isTop()) {
    return rhs;
  }
 else   if (rhs.isTop()) {
    return lhs;
  }
 else   if (lhs.isUnknown()) {
    return rhs;
  }
 else   if (rhs.isUnknown()) {
    return lhs;
  }
 else   if (lhs.isBottom() || rhs.isBottom()) {
    return BOTTOM;
  }
  int newMask=lhs.getMask() & rhs.getMask();
  String newTypevar;
  if (Objects.equals(lhs.getTypeVar(),rhs.getTypeVar())) {
    newTypevar=lhs.getTypeVar();
  }
 else {
    newTypevar=null;
    newMask=newMask & ~TYPEVAR_MASK;
  }
  return meetEnums(newMask,lhs.getMask() | rhs.getMask(),ObjectType.meetSets(lhs.getObjs(),rhs.getObjs()),newTypevar,lhs.getObjs(),rhs.getObjs(),lhs.getEnums(),rhs.getEnums());
}","private static JSType meetHelper(JSType lhs,JSType rhs){
  if (lhs.isTop()) {
    return rhs;
  }
  if (rhs.isTop()) {
    return lhs;
  }
  if (lhs.isUnknown()) {
    return rhs;
  }
  if (rhs.isUnknown()) {
    return lhs;
  }
  if (lhs.isBottom() || rhs.isBottom()) {
    return BOTTOM;
  }
  if (lhs.hasTruthyMask()) {
    return rhs.makeTruthy();
  }
  if (lhs.hasFalsyMask()) {
    return rhs.makeFalsy();
  }
  if (rhs.hasTruthyMask()) {
    return lhs.makeTruthy();
  }
  if (rhs.hasFalsyMask()) {
    return lhs.makeFalsy();
  }
  int newMask=lhs.getMask() & rhs.getMask();
  String newTypevar;
  if (Objects.equals(lhs.getTypeVar(),rhs.getTypeVar())) {
    newTypevar=lhs.getTypeVar();
  }
 else {
    newTypevar=null;
    newMask=newMask & ~TYPEVAR_MASK;
  }
  return meetEnums(newMask,lhs.getMask() | rhs.getMask(),ObjectType.meetSets(lhs.getObjs(),rhs.getObjs()),newTypevar,lhs.getObjs(),rhs.getObjs(),lhs.getEnums(),rhs.getEnums());
}",0.8400954653937948
27384,"/** 
 * Tries to apply our various peephole minimizations on the passed in node.
 */
@Override @SuppressWarnings(""String_Node_Str"") public Node optimizeSubtree(Node node){
switch (node.getType()) {
case THROW:
case RETURN:
{
      Node result=tryRemoveRedundantExit(node);
      if (result != node) {
        return result;
      }
      return tryReplaceExitWithBreak(node);
    }
case NOT:
  tryMinimizeCondition(node.getFirstChild());
return tryMinimizeNot(node);
case IF:
performCoercionSubstitutions(node.getFirstChild());
performConditionSubstitutions(node.getFirstChild());
return tryMinimizeIf(node);
case EXPR_RESULT:
performConditionSubstitutions(node.getFirstChild());
return tryMinimizeExprResult(node);
case HOOK:
performCoercionSubstitutions(node.getFirstChild());
performConditionSubstitutions(node.getFirstChild());
return tryMinimizeHook(node);
case WHILE:
case DO:
tryMinimizeCondition(NodeUtil.getConditionExpression(node));
return node;
case FOR:
if (!NodeUtil.isForIn(node)) {
tryJoinForCondition(node);
tryMinimizeCondition(NodeUtil.getConditionExpression(node));
}
return node;
case BLOCK:
return tryReplaceIf(node);
default :
return node;
}
}","/** 
 * Tries to apply our various peephole minimizations on the passed in node.
 */
@Override @SuppressWarnings(""String_Node_Str"") public Node optimizeSubtree(Node node){
switch (node.getType()) {
case THROW:
case RETURN:
{
      Node result=tryRemoveRedundantExit(node);
      if (result != node) {
        return result;
      }
      return tryReplaceExitWithBreak(node);
    }
case NOT:
  tryMinimizeCondition(node.getFirstChild());
return tryMinimizeNot(node);
case IF:
performCoercionSubstitutions(node.getFirstChild());
performConditionSubstitutions(node.getFirstChild());
return tryMinimizeIf(node);
case EXPR_RESULT:
performCoercionSubstitutions(node.getFirstChild());
performConditionSubstitutions(node.getFirstChild());
return tryMinimizeExprResult(node);
case HOOK:
performCoercionSubstitutions(node.getFirstChild());
performConditionSubstitutions(node.getFirstChild());
return tryMinimizeHook(node);
case WHILE:
case DO:
tryMinimizeCondition(NodeUtil.getConditionExpression(node));
return node;
case FOR:
if (!NodeUtil.isForIn(node)) {
tryJoinForCondition(node);
tryMinimizeCondition(NodeUtil.getConditionExpression(node));
}
return node;
case BLOCK:
return tryReplaceIf(node);
default :
return node;
}
}",0.9781879194630873
27385,"private static boolean isObjectType(Node n){
  JSType jsType=n.getJSType();
  if (jsType == null) {
    return false;
  }
  return !jsType.isUnknownType() && jsType.isObject();
}","private static boolean isObjectType(Node n){
  JSType jsType=n.getJSType();
  if (jsType == null) {
    return false;
  }
  jsType=jsType.restrictByNotNullOrUndefined();
  return !jsType.isUnknownType() && !jsType.isNoType() && jsType.isObject();
}",0.8356807511737089
27386,"/** 
 * Given a source file, line, and column, return the reverse mapping (source --> target). A collection is returned as in some cases (like a function being inlined), one source line may map to more then one target location. An empty collection is returned if there were no matches.
 * @param originalFile the source file
 * @param line the source line
 * @param column the source column
 * @return the reverse mapping (source --> target)
 */
public Collection<OriginalMapping> getReverseMapping(String originalFile,int line,int column);","/** 
 * Given a source file, line, and column, return the reverse mapping (source  target). A collection is returned as in some cases (like a function being inlined), one source line may map to more then one target location. An empty collection is returned if there were no matches.
 * @param originalFile the source file
 * @param line the source line
 * @param column the source column
 * @return the reverse mapping (source  target)
 */
public Collection<OriginalMapping> getReverseMapping(String originalFile,int line,int column);",0.9925650557620818
27387,"/** 
 * Prefix for filenames of compiled JS modules. <module-name>.js will be appended to this prefix. Directories will be created as needed. Use with --module
 */
public CommandLineConfig setModuleOutputPathPrefix(String moduleOutputPathPrefix){
  this.moduleOutputPathPrefix=moduleOutputPathPrefix;
  return this;
}","/** 
 * Prefix for filenames of compiled JS modules.  {@code <module-name>.js} will be appended to this prefix. Directorieswill be created as needed. Use with --module
 */
public CommandLineConfig setModuleOutputPathPrefix(String moduleOutputPathPrefix){
  this.moduleOutputPathPrefix=moduleOutputPathPrefix;
  return this;
}",0.9844236760124612
27388,"/** 
 * Decodes an encoded string from the JS Compiler ReplaceStrings pass. <p>An original string with args might look like this: <pre>  Error('Some ' + arg1 + ' error ' + arg2 + ' message.');</pre> Which gets replaced with: <pre>  Error('key' + '`' + arg1 + '`' + arg2);</pre> Where ` is the argument place holder. The replacement mapping would be: <pre>  key -> 'Some ` error ` message.'</pre> Where key is some arbitrary replacement string. An encoded string, with args, from the client will look like: <pre>  'key`arg1`arg2'</pre>
 * @param encodedStr An encoded string.
 * @return The decoded string, or the encoded string if it fails to decode.
 * @see com.google.javascript.jscomp.ReplaceStrings
 */
public String decode(String encodedStr){
  String[] suppliedBits=encodedStr.split(ARGUMENT_PLACE_HOLDER,-1);
  String originalStr=originalToNewNameMap.get(suppliedBits[0]);
  if (originalStr == null) {
    return encodedStr;
  }
  String[] originalBits=originalStr.split(ARGUMENT_PLACE_HOLDER,-1);
  StringBuilder sb=new StringBuilder(originalBits[0]);
  for (int i=1; i < Math.max(originalBits.length,suppliedBits.length); i++) {
    sb.append(i < suppliedBits.length ? suppliedBits[i] : ""String_Node_Str"");
    sb.append(i < originalBits.length ? originalBits[i] : ""String_Node_Str"");
  }
  return sb.toString();
}","/** 
 * Decodes an encoded string from the JS Compiler ReplaceStrings pass. <p>An original string with args might look like this: <pre>  Error('Some ' + arg1 + ' error ' + arg2 + ' message.');</pre> Which gets replaced with: <pre>  Error('key' + '`' + arg1 + '`' + arg2);</pre> Where ` is the argument place holder. The replacement mapping would be: <pre>  key  'Some ` error ` message.'</pre> Where key is some arbitrary replacement string. An encoded string, with args, from the client will look like: <pre>  'key`arg1`arg2'</pre>
 * @param encodedStr An encoded string.
 * @return The decoded string, or the encoded string if it fails to decode.
 * @see com.google.javascript.jscomp.ReplaceStrings
 */
public String decode(String encodedStr){
  String[] suppliedBits=encodedStr.split(ARGUMENT_PLACE_HOLDER,-1);
  String originalStr=originalToNewNameMap.get(suppliedBits[0]);
  if (originalStr == null) {
    return encodedStr;
  }
  String[] originalBits=originalStr.split(ARGUMENT_PLACE_HOLDER,-1);
  StringBuilder sb=new StringBuilder(originalBits[0]);
  for (int i=1; i < Math.max(originalBits.length,suppliedBits.length); i++) {
    sb.append(i < suppliedBits.length ? suppliedBits[i] : ""String_Node_Str"");
    sb.append(i < originalBits.length ? originalBits[i] : ""String_Node_Str"");
  }
  return sb.toString();
}",0.9988657844990548
27389,"/** 
 * Adds a <path/> entry.
 */
public void addPath(Path list){
  this.sourcePaths.add(list);
}","/** 
 * Adds a   {@code <path/>} entry.
 */
public void addPath(Path list){
  this.sourcePaths.add(list);
}",0.9509803921568628
27390,"@Override public void process(Node externs,Node root){
  NodeTraversal.traverseEs6(compiler,root,this);
}","@Override public void process(Node externs,Node root){
  GetterSetterCollector getterSetterCollector=new GetterSetterCollector();
  NodeTraversal.traverseEs6(compiler,root,getterSetterCollector);
  NodeTraversal.traverseEs6(compiler,root,new FunctionVisitor(compiler,getterSetterCollector.propNames));
}",0.4950980392156863
27391,"private boolean visitNode(Node n,Node parent){
switch (n.getType()) {
case Token.GETPROP:
    if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) {
      return false;
    }
  Property property=getOrCreateProperty(n);
if (property != null) {
  property.markLastWriteRead();
  property.markChildrenRead();
}
return true;
case Token.CALL:
if (ASSUME_CONSTRUCTORS_HAVENT_ESCAPED && isConstructor && !NodeUtil.referencesThis(n)&& NodeUtil.getEnclosingType(n,Token.TRY) == null) {
markAllPropsReadExceptThisProps();
}
 else {
markAllPropsRead();
}
return false;
case Token.THIS:
case Token.NAME:
Property nameProp=Preconditions.checkNotNull(getOrCreateProperty(n));
nameProp.markLastWriteRead();
nameProp.markChildrenRead();
return true;
case Token.THROW:
case Token.FOR:
case Token.SWITCH:
markAllPropsRead();
return false;
case Token.BLOCK:
visitBlock(n);
return true;
default :
if (isConditionalExpression(n)) {
markAllPropsRead();
return false;
}
return true;
}
}","private boolean visitNode(Node n,Node parent){
switch (n.getType()) {
case Token.GETPROP:
    if (n.isGetProp() && n.getLastChild().isString() && getterSetterNames.contains(n.getLastChild().getString())) {
      markAllPropsRead();
      return true;
    }
  if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) {
    return false;
  }
Property property=getOrCreateProperty(n);
if (property != null) {
property.markLastWriteRead();
if (!parent.isGetProp()) {
  property.markChildrenRead();
}
}
return true;
case Token.CALL:
if (ASSUME_CONSTRUCTORS_HAVENT_ESCAPED && isConstructor && !NodeUtil.referencesThis(n)&& NodeUtil.getEnclosingType(n,Token.TRY) == null) {
markAllPropsReadExceptThisProps();
}
 else {
markAllPropsRead();
}
return false;
case Token.THIS:
case Token.NAME:
Property nameProp=Preconditions.checkNotNull(getOrCreateProperty(n));
nameProp.markLastWriteRead();
if (!parent.isGetProp()) {
nameProp.markChildrenRead();
}
return true;
case Token.THROW:
case Token.FOR:
case Token.SWITCH:
markAllPropsRead();
return false;
case Token.BLOCK:
visitBlock(n);
return true;
default :
if (isConditionalExpression(n)) {
markAllPropsRead();
return false;
}
return true;
}
}",0.8530631045601106
27392,"@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (NodeUtil.isAssignmentOp(n)) {
    visitAssignmentLhs(n.getFirstChild());
  }
  if (n.isBlock()) {
    visitBlock(n);
  }
}","@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (NodeUtil.isGetterOrSetter(n)) {
    Node grandparent=parent.getParent();
    if (NodeUtil.isGetOrSetKey(n) && n.getString() != null) {
      propNames.add(n.getString());
    }
 else     if (NodeUtil.isObjectDefinePropertyDefinition(grandparent)) {
      Node propNode=grandparent.getChildAtIndex(2);
      if (propNode.isString()) {
        propNames.add(propNode.getString());
      }
    }
 else     if (grandparent.isStringKey() && NodeUtil.isObjectDefinePropertiesDefinition(grandparent.getParent().getParent())) {
      propNames.add(grandparent.getString());
    }
  }
}",0.3020214030915576
27393,"FindCandidateAssignmentTraversal(boolean isConstructor){
  this.isConstructor=isConstructor;
}","FindCandidateAssignmentTraversal(Set<String> getterSetterNames,boolean isConstructor){
  this.getterSetterNames=getterSetterNames;
  this.isConstructor=isConstructor;
}",0.7175572519083969
27394,"static boolean isNegativeZero(double x){
  return x == 0.0 && Math.copySign(1,x) == -1.0;
}","static boolean isNegativeZero(double x){
  return x == 0.0 && 1 / x < 0;
}",0.8484848484848485
27395,"private EnvTypePair analyzeAssignFwd(Node expr,TypeEnv inEnv,JSType requiredType,JSType specializedType){
  if (expr.getBooleanProp(Node.ANALYZED_DURING_GTI)) {
    expr.removeProp(Node.ANALYZED_DURING_GTI);
    return new EnvTypePair(inEnv,requiredType);
  }
  mayWarnAboutConst(expr);
  Node lhs=expr.getFirstChild();
  Node rhs=expr.getLastChild();
  if (lhs.getBooleanProp(Node.ANALYZED_DURING_GTI)) {
    lhs.removeProp(Node.ANALYZED_DURING_GTI);
    JSType declType=markAndGetTypeOfPreanalyzedNode(lhs,inEnv,true);
    if (rhs.matchesQualifiedName(ABSTRACT_METHOD_NAME)) {
      return new EnvTypePair(inEnv,requiredType);
    }
    EnvTypePair rhsPair=analyzeExprFwd(rhs,inEnv,declType);
    if (!rhsPair.type.isSubtypeOf(declType) && !NodeUtil.isPrototypeAssignment(lhs)) {
      warnings.add(JSError.make(expr,MISTYPED_ASSIGN_RHS,declType.toString(),rhsPair.type.toString()));
    }
    return rhsPair;
  }
  LValueResultFwd lvalue=analyzeLValueFwd(lhs,inEnv,requiredType);
  JSType declType=lvalue.declType;
  EnvTypePair rhsPair=analyzeExprFwd(rhs,lvalue.env,requiredType,specializedType);
  if (declType != null && !rhsPair.type.isSubtypeOf(declType)) {
    warnings.add(JSError.make(expr,MISTYPED_ASSIGN_RHS,declType.toString(),rhsPair.type.toString()));
  }
 else {
    rhsPair.env=updateLvalueTypeInEnv(rhsPair.env,lhs,lvalue.ptr,rhsPair.type);
  }
  return rhsPair;
}","private EnvTypePair analyzeAssignFwd(Node expr,TypeEnv inEnv,JSType requiredType,JSType specializedType){
  if (expr.getBooleanProp(Node.ANALYZED_DURING_GTI)) {
    expr.removeProp(Node.ANALYZED_DURING_GTI);
    return new EnvTypePair(inEnv,requiredType);
  }
  mayWarnAboutConst(expr);
  Node lhs=expr.getFirstChild();
  Node rhs=expr.getLastChild();
  if (lhs.getBooleanProp(Node.ANALYZED_DURING_GTI)) {
    lhs.removeProp(Node.ANALYZED_DURING_GTI);
    JSType declType=markAndGetTypeOfPreanalyzedNode(lhs,inEnv,true);
    if (rhs.matchesQualifiedName(ABSTRACT_METHOD_NAME)) {
      return new EnvTypePair(inEnv,requiredType);
    }
    EnvTypePair rhsPair=analyzeExprFwd(rhs,inEnv,declType);
    if (!rhsPair.type.isSubtypeOf(declType) && !NodeUtil.isPrototypeAssignment(lhs)) {
      warnings.add(JSError.make(expr,MISTYPED_ASSIGN_RHS,errorMsgWithTypeDiff(declType,rhsPair.type)));
    }
    return rhsPair;
  }
  LValueResultFwd lvalue=analyzeLValueFwd(lhs,inEnv,requiredType);
  JSType declType=lvalue.declType;
  EnvTypePair rhsPair=analyzeExprFwd(rhs,lvalue.env,requiredType,specializedType);
  if (declType != null && !rhsPair.type.isSubtypeOf(declType)) {
    warnings.add(JSError.make(expr,MISTYPED_ASSIGN_RHS,errorMsgWithTypeDiff(declType,rhsPair.type)));
  }
 else {
    rhsPair.env=updateLvalueTypeInEnv(rhsPair.env,lhs,lvalue.ptr,rhsPair.type);
  }
  return rhsPair;
}",0.950831525668836
27396,"public void testPinpointTypeDiffWhenMismatch(){
  typeCheckMessageContents(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheckMessageContents(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheckMessageContents(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheckMessageContents(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheckMessageContents(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheckMessageContents(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheckMessageContents(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheckMessageContents(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""));
  typeCheckMessageContents(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""));
}","public void testPinpointTypeDiffWhenMismatch(){
  typeCheckMessageContents(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheckMessageContents(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheckMessageContents(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheckMessageContents(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheckMessageContents(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheckMessageContents(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheckMessageContents(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheckMessageContents(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""));
  typeCheckMessageContents(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""));
  typeCheckMessageContents(""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.957351290684624
27397,"private EnvTypePair analyzeAssertionCall(Node callNode,TypeEnv env,AssertionFunctionSpec assertionFunctionSpec){
  Node firstParam=callNode.getSecondChild();
  if (firstParam == null) {
    return new EnvTypePair(env,JSType.UNKNOWN);
  }
  Node assertedNode=assertionFunctionSpec.getAssertedParam(firstParam);
  if (assertedNode == null) {
    return new EnvTypePair(env,JSType.UNKNOWN);
  }
  JSType assertedType=assertionFunctionSpec.getAssertedNewType(callNode,currentScope);
  if (assertedType.isUnknown()) {
    warnings.add(JSError.make(callNode,NewTypeInference.UNKNOWN_ASSERTION_TYPE));
  }
  EnvTypePair pair=analyzeExprFwd(assertedNode,env,JSType.UNKNOWN,assertedType);
  if (pair.type.isBottom()) {
    JSType t=analyzeExprFwd(assertedNode,env).type.substituteGenericsWithUnknown();
    if (t.isSubtypeOf(assertedType)) {
      pair.type=t;
    }
 else {
      warnings.add(JSError.make(assertedNode,NewTypeInference.ASSERT_FALSE));
      pair.type=JSType.UNKNOWN;
      pair.env=env;
    }
  }
  return pair;
}","private EnvTypePair analyzeAssertionCall(Node callNode,TypeEnv env,AssertionFunctionSpec assertionFunctionSpec){
  Node firstParam=callNode.getSecondChild();
  if (firstParam == null) {
    return new EnvTypePair(env,JSType.UNKNOWN);
  }
  Node assertedNode=assertionFunctionSpec.getAssertedParam(firstParam);
  if (assertedNode == null) {
    return new EnvTypePair(env,JSType.UNKNOWN);
  }
  JSType assertedType=assertionFunctionSpec.getAssertedNewType(callNode,currentScope);
  if (assertedType.isUnknown()) {
    warnings.add(JSError.make(callNode,NewTypeInference.UNKNOWN_ASSERTION_TYPE));
  }
  EnvTypePair pair=analyzeExprFwd(assertedNode,env,JSType.UNKNOWN,assertedType);
  if (!pair.type.isSubtypeOf(assertedType) && JSType.haveCommonSubtype(assertedType,pair.type)) {
    pair.type=assertedType;
  }
  if (pair.type.isBottom()) {
    JSType t=analyzeExprFwd(assertedNode,env).type.substituteGenericsWithUnknown();
    if (t.isSubtypeOf(assertedType)) {
      pair.type=t;
    }
 else {
      warnings.add(JSError.make(assertedNode,NewTypeInference.ASSERT_FALSE));
      pair.type=JSType.UNKNOWN;
      pair.env=env;
    }
  }
  return pair;
}",0.940202391904324
27398,"public void testAsserts(){
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testAsserts(){
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
}",0.9003660024400163
27399,"void fillPropertyScopes(){
  List<Symbol> types=new ArrayList<>();
  for (  Symbol sym : getAllSymbols()) {
    if (needsPropertyScope(sym)) {
      types.add(sym);
    }
  }
  Collections.sort(types,getNaturalSymbolOrdering().reverse());
  for (  Symbol s : types) {
    createPropertyScopeFor(s);
  }
  pruneOrphanedNames();
}","void fillPropertyScopes(){
  List<Symbol> types=new ArrayList<>();
  List<Symbol> googModuleExportTypes=new ArrayList<>();
  for (  Symbol sym : getAllSymbols()) {
    if (needsPropertyScope(sym)) {
      if (sym.getName().startsWith(""String_Node_Str"")) {
        googModuleExportTypes.add(sym);
      }
 else {
        types.add(sym);
      }
    }
  }
  Collections.sort(types,getNaturalSymbolOrdering().reverse());
  Collections.sort(googModuleExportTypes,getNaturalSymbolOrdering().reverse());
  for (  Symbol s : Iterables.concat(googModuleExportTypes,types)) {
    createPropertyScopeFor(s);
  }
  pruneOrphanedNames();
}",0.6429319371727749
27400,"@Override public void enterScope(NodeTraversal t){
  Scope scope=t.getScope();
  if (!shouldOptimizeScope(scope)) {
    return;
  }
  Preconditions.checkState(scope.isFunctionScope(),scope);
  ControlFlowGraph<Node> cfg=t.getControlFlowGraph();
  LiveVariablesAnalysis liveness=new LiveVariablesAnalysis(cfg,scope,compiler);
  if (NodeUtil.getFunctionParameters(scope.getRootNode()).getChildCount() == 2) {
    liveness.markAllParametersEscaped();
  }
  liveness.analyze();
  UndiGraph<Var,Void> interferenceGraph=computeVariableNamesInterferenceGraph(t,cfg,(Set<Var>)liveness.getEscapedLocals());
  GraphColoring<Var,Void> coloring=new GreedyGraphColoring<>(interferenceGraph,coloringTieBreaker);
  coloring.color();
  colorings.push(coloring);
}","@Override public void enterScope(NodeTraversal t){
  Scope scope=t.getScope();
  if (!shouldOptimizeScope(scope)) {
    return;
  }
  Preconditions.checkState(scope.isFunctionScope(),scope);
  ControlFlowGraph<Node> cfg=t.getControlFlowGraph();
  LiveVariablesAnalysis liveness=new LiveVariablesAnalysis(cfg,scope,compiler);
  if (compiler.getOptions().getLanguageOut() == CompilerOptions.LanguageMode.ECMASCRIPT3) {
    if (NodeUtil.getFunctionParameters(scope.getRootNode()).getChildCount() == 2) {
      liveness.markAllParametersEscaped();
    }
  }
  liveness.analyze();
  UndiGraph<Var,Void> interferenceGraph=computeVariableNamesInterferenceGraph(t,cfg,(Set<Var>)liveness.getEscapedLocals());
  GraphColoring<Var,Void> coloring=new GreedyGraphColoring<>(interferenceGraph,coloringTieBreaker);
  coloring.color();
  colorings.push(coloring);
}",0.8571428571428571
27401,"public void testParameter4b(){
  test(""String_Node_Str"",""String_Node_Str"");
}","public void testParameter4b(){
  setLanguageOut(LanguageMode.ECMASCRIPT5);
  test(""String_Node_Str"",""String_Node_Str"");
}",0.7777777777777778
27402,"void add(Node n,Context context){
  if (!cc.continueProcessing()) {
    return;
  }
  if (preserveTypeAnnotations && n.getJSDocInfo() != null) {
    add(JSDocInfoPrinter.print(n.getJSDocInfo()));
  }
  int type=n.getType();
  String opstr=NodeUtil.opToStr(type);
  int childCount=n.getChildCount();
  Node first=n.getFirstChild();
  Node last=n.getLastChild();
  if (opstr != null && first != last) {
    Preconditions.checkState(childCount == 2,""String_Node_Str"",opstr,childCount);
    int p=NodeUtil.precedence(type);
    Context rhsContext=getContextForNoInOperator(context);
    boolean needsParens=(context == Context.START_OF_EXPR) && first.isObjectPattern();
    if (n.isAssign() && needsParens) {
      add(""String_Node_Str"");
    }
    if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
      addExpr(first,p,context);
      cc.addOp(opstr,true);
      addExpr(last,p,rhsContext);
    }
 else {
      unrollBinaryOperator(n,type,opstr,context,rhsContext,p,p + 1);
    }
    if (n.isAssign() && needsParens) {
      add(""String_Node_Str"");
    }
    return;
  }
  cc.startSourceMapping(n);
switch (type) {
case Token.TRY:
{
      Preconditions.checkState(first.getNext().isBlock() && !first.getNext().hasMoreThanOneChild());
      Preconditions.checkState(childCount >= 2 && childCount <= 3);
      add(""String_Node_Str"");
      add(first,Context.PRESERVE_BLOCK);
      Node catchblock=first.getNext().getFirstChild();
      if (catchblock != null) {
        add(catchblock);
      }
      if (childCount == 3) {
        cc.maybeInsertSpace();
        add(""String_Node_Str"");
        add(last,Context.PRESERVE_BLOCK);
      }
      break;
    }
case Token.CATCH:
  Preconditions.checkState(childCount == 2);
cc.maybeInsertSpace();
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(last,Context.PRESERVE_BLOCK);
break;
case Token.THROW:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(first);
cc.endStatement(true);
break;
case Token.RETURN:
add(""String_Node_Str"");
if (childCount == 1) {
cc.maybeInsertSpace();
add(first);
}
 else {
Preconditions.checkState(childCount == 0);
}
cc.endStatement();
break;
case Token.VAR:
if (first != null) {
add(""String_Node_Str"");
addList(first,false,getContextForNoInOperator(context),""String_Node_Str"");
}
break;
case Token.CONST:
add(""String_Node_Str"");
addList(first,false,getContextForNoInOperator(context),""String_Node_Str"");
break;
case Token.LET:
add(""String_Node_Str"");
addList(first,false,getContextForNoInOperator(context),""String_Node_Str"");
break;
case Token.LABEL_NAME:
Preconditions.checkState(!n.getString().isEmpty());
addIdentifier(n.getString());
break;
case Token.DESTRUCTURING_LHS:
add(first);
if (first != last) {
Preconditions.checkState(childCount == 2);
cc.addOp(""String_Node_Str"",true);
add(last);
}
break;
case Token.NAME:
addIdentifier(n.getString());
maybeAddOptional(n);
maybeAddTypeDecl(n);
if (first != null && !first.isEmpty()) {
Preconditions.checkState(childCount == 1);
cc.addOp(""String_Node_Str"",true);
if (first.isComma()) {
addExpr(first,NodeUtil.precedence(Token.ASSIGN),Context.OTHER);
}
 else {
addExpr(first,0,getContextForNoInOperator(context));
}
}
break;
case Token.ARRAYLIT:
add(""String_Node_Str"");
addArrayList(first);
add(""String_Node_Str"");
break;
case Token.ARRAY_PATTERN:
add(""String_Node_Str"");
addArrayList(first);
add(""String_Node_Str"");
maybeAddTypeDecl(n);
break;
case Token.PARAM_LIST:
add(""String_Node_Str"");
addList(first);
add(""String_Node_Str"");
break;
case Token.DEFAULT_VALUE:
add(first);
maybeAddTypeDecl(n);
cc.addOp(""String_Node_Str"",true);
add(first.getNext());
break;
case Token.COMMA:
Preconditions.checkState(childCount == 2);
unrollBinaryOperator(n,Token.COMMA,""String_Node_Str"",context,getContextForNoInOperator(context),0,0);
break;
case Token.NUMBER:
Preconditions.checkState(childCount == 0);
cc.addNumber(n.getDouble());
break;
case Token.TYPEOF:
case Token.VOID:
case Token.NOT:
case Token.BITNOT:
case Token.POS:
{
Preconditions.checkState(childCount == 1);
cc.addOp(NodeUtil.opToStrNoFail(type),false);
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
break;
}
case Token.NEG:
{
Preconditions.checkState(childCount == 1);
if (n.getFirstChild().isNumber()) {
cc.addNumber(-n.getFirstChild().getDouble());
}
 else {
cc.addOp(NodeUtil.opToStrNoFail(type),false);
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
}
break;
}
case Token.HOOK:
{
Preconditions.checkState(childCount == 3);
int p=NodeUtil.precedence(type);
Context rhsContext=getContextForNoInOperator(context);
addExpr(first,p + 1,context);
cc.addOp(""String_Node_Str"",true);
addExpr(first.getNext(),1,rhsContext);
cc.addOp(""String_Node_Str"",true);
addExpr(last,1,rhsContext);
break;
}
case Token.REGEXP:
if (!first.isString() || !last.isString()) {
throw new Error(""String_Node_Str"");
}
String regexp=regexpEscape(first.getString(),outputCharsetEncoder);
if (childCount == 2) {
add(regexp + last.getString());
}
 else {
Preconditions.checkState(childCount == 1);
add(regexp);
}
break;
case Token.FUNCTION:
{
if (n.getClass() != Node.class) {
throw new Error(""String_Node_Str"");
}
Preconditions.checkState(childCount == 3);
if (n.isArrowFunction()) {
addArrowFunction(n,first,last,context);
}
 else {
addFunction(n,first,last,context);
}
break;
}
case Token.REST:
add(""String_Node_Str"");
add(first.getString());
maybeAddTypeDecl(n);
break;
case Token.SPREAD:
add(""String_Node_Str"");
add(n.getFirstChild());
break;
case Token.EXPORT:
add(""String_Node_Str"");
if (n.getBooleanProp(Node.EXPORT_DEFAULT)) {
add(""String_Node_Str"");
}
if (n.getBooleanProp(Node.EXPORT_ALL_FROM)) {
add(""String_Node_Str"");
Preconditions.checkState(first != null && first.isEmpty());
}
 else {
add(first);
}
if (childCount == 2) {
add(""String_Node_Str"");
add(last);
}
processEnd(first,context);
break;
case Token.IMPORT:
add(""String_Node_Str"");
Node second=first.getNext();
if (!first.isEmpty()) {
add(first);
if (!second.isEmpty()) {
cc.listSeparator();
}
}
if (!second.isEmpty()) {
add(second);
}
if (!first.isEmpty() || !second.isEmpty()) {
add(""String_Node_Str"");
}
add(last);
cc.endStatement();
break;
case Token.EXPORT_SPECS:
case Token.IMPORT_SPECS:
add(""String_Node_Str"");
for (Node c=first; c != null; c=c.getNext()) {
if (c != first) {
cc.listSeparator();
}
add(c);
}
add(""String_Node_Str"");
break;
case Token.EXPORT_SPEC:
case Token.IMPORT_SPEC:
add(first);
if (first != last) {
add(""String_Node_Str"");
add(last);
}
break;
case Token.IMPORT_STAR:
add(""String_Node_Str"");
add(""String_Node_Str"");
add(n.getString());
break;
case Token.CLASS:
{
Preconditions.checkState(childCount == 3);
boolean classNeedsParens=(context == Context.START_OF_EXPR);
if (classNeedsParens) {
add(""String_Node_Str"");
}
Node name=first;
Node superClass=first.getNext();
Node members=last;
add(""String_Node_Str"");
if (!name.isEmpty()) {
add(name);
}
maybeAddGenericTypes(first);
if (!superClass.isEmpty()) {
add(""String_Node_Str"");
add(superClass);
}
Node interfaces=(Node)n.getProp(Node.IMPLEMENTS);
if (interfaces != null) {
add(""String_Node_Str"");
Node child=interfaces.getFirstChild();
add(child);
while ((child=child.getNext()) != null) {
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(child);
}
}
add(members);
cc.endClass(context == Context.STATEMENT);
if (classNeedsParens) {
add(""String_Node_Str"");
}
}
break;
case Token.CLASS_MEMBERS:
case Token.INTERFACE_MEMBERS:
case Token.NAMESPACE_ELEMENTS:
cc.beginBlock();
for (Node c=first; c != null; c=c.getNext()) {
add(c);
processEnd(c,context);
cc.endLine();
}
cc.endBlock(false);
break;
case Token.ENUM_MEMBERS:
cc.beginBlock();
for (Node c=first; c != null; c=c.getNext()) {
add(c);
if (c.getNext() != null) {
add(""String_Node_Str"");
}
cc.endLine();
}
cc.endBlock(false);
break;
case Token.GETTER_DEF:
case Token.SETTER_DEF:
case Token.MEMBER_FUNCTION_DEF:
case Token.MEMBER_VARIABLE_DEF:
{
n.getParent().toStringTree();
Preconditions.checkState(n.getParent().isObjectLit() || n.getParent().isClassMembers() || n.getParent().isInterfaceMembers()|| n.getParent().isRecordType()|| n.getParent().isIndexSignature());
maybeAddAccessibilityModifier(n);
if (n.isStaticMember()) {
add(""String_Node_Str"");
}
if (!n.isMemberVariableDef() && n.getFirstChild().isGeneratorFunction()) {
Preconditions.checkState(type == Token.MEMBER_FUNCTION_DEF);
add(""String_Node_Str"");
}
switch (type) {
case Token.GETTER_DEF:
Preconditions.checkState(!first.getSecondChild().hasChildren());
add(""String_Node_Str"");
break;
case Token.SETTER_DEF:
Preconditions.checkState(first.getSecondChild().hasOneChild());
add(""String_Node_Str"");
break;
case Token.MEMBER_FUNCTION_DEF:
case Token.MEMBER_VARIABLE_DEF:
break;
}
String name=n.getString();
if (n.isMemberVariableDef()) {
add(n.getString());
maybeAddOptional(n);
maybeAddTypeDecl(n);
}
 else {
Preconditions.checkState(childCount == 1);
Preconditions.checkState(first.isFunction());
Preconditions.checkState(first.getFirstChild().getString().isEmpty());
Node fn=first;
Node parameters=fn.getSecondChild();
Node body=fn.getLastChild();
if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) && NodeUtil.isLatin(name)) {
add(name);
maybeAddGenericTypes(fn.getFirstChild());
}
 else {
double d=getSimpleNumber(name);
if (!Double.isNaN(d)) {
cc.addNumber(d);
}
 else {
addJsString(n);
}
}
maybeAddOptional(fn);
add(parameters);
maybeAddTypeDecl(fn);
add(body,Context.PRESERVE_BLOCK);
}
break;
}
case Token.SCRIPT:
case Token.BLOCK:
{
if (n.getClass() != Node.class) {
throw new Error(""String_Node_Str"");
}
boolean preserveBlock=context == Context.PRESERVE_BLOCK;
if (preserveBlock) {
cc.beginBlock();
}
boolean preferLineBreaks=type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().isScript());
for (Node c=first; c != null; c=c.getNext()) {
add(c,Context.STATEMENT);
if (NodeUtil.isNameDeclaration(c)) {
cc.endStatement();
}
if (c.isFunction() || c.isClass()) {
cc.maybeLineBreak();
}
if (preferLineBreaks) {
cc.notePreferredLineBreak();
}
}
if (preserveBlock) {
cc.endBlock(cc.breakAfterBlockFor(n,context == Context.STATEMENT));
}
break;
}
case Token.FOR:
if (childCount == 4) {
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
if (NodeUtil.isNameDeclaration(first)) {
add(first,Context.IN_FOR_INIT_CLAUSE);
}
 else {
addExpr(first,0,Context.IN_FOR_INIT_CLAUSE);
}
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
add(first.getNext().getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
 else {
Preconditions.checkState(childCount == 3);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
break;
case Token.FOR_OF:
Preconditions.checkState(childCount == 3);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case Token.DO:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
addNonEmptyStatement(first,Context.OTHER,false);
cc.maybeInsertSpace();
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(last);
add(""String_Node_Str"");
cc.endStatement();
break;
case Token.WHILE:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case Token.EMPTY:
Preconditions.checkState(childCount == 0);
break;
case Token.GETPROP:
{
Preconditions.checkState(childCount == 2,""String_Node_Str"",childCount);
Preconditions.checkState(last.isString(),""String_Node_Str"");
boolean needsParens=(first.isNumber());
if (needsParens) {
add(""String_Node_Str"");
}
addExpr(first,NodeUtil.precedence(type),context);
if (needsParens) {
add(""String_Node_Str"");
}
if (quoteKeywordProperties && TokenStream.isKeyword(last.getString())) {
add(""String_Node_Str"");
add(last);
add(""String_Node_Str"");
}
 else {
add(""String_Node_Str"");
addIdentifier(last.getString());
}
break;
}
case Token.GETELEM:
Preconditions.checkState(childCount == 2,""String_Node_Str"",childCount,n);
addExpr(first,NodeUtil.precedence(type),context);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
break;
case Token.WITH:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case Token.INC:
case Token.DEC:
{
Preconditions.checkState(childCount == 1);
String o=type == Token.INC ? ""String_Node_Str"" : ""String_Node_Str"";
boolean postProp=n.getBooleanProp(Node.INCRDECR_PROP);
if (postProp) {
addExpr(first,NodeUtil.precedence(type),context);
cc.addOp(o,false);
}
 else {
cc.addOp(o,false);
add(first);
}
break;
}
case Token.CALL:
if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
add(""String_Node_Str"");
addExpr(first,NodeUtil.precedence(Token.COMMA),Context.OTHER);
add(""String_Node_Str"");
}
 else {
addExpr(first,NodeUtil.precedence(type),context);
}
Node args=first.getNext();
add(""String_Node_Str"");
addList(args);
add(""String_Node_Str"");
break;
case Token.IF:
boolean hasElse=childCount == 3;
boolean ambiguousElseClause=context == Context.BEFORE_DANGLING_ELSE && !hasElse;
if (ambiguousElseClause) {
cc.beginBlock();
}
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
if (childCount == 1) {
break;
}
if (hasElse) {
addNonEmptyStatement(first.getNext(),Context.BEFORE_DANGLING_ELSE,false);
cc.maybeInsertSpace();
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
 else {
addNonEmptyStatement(first.getNext(),Context.OTHER,false);
Preconditions.checkState(childCount == 2);
}
if (ambiguousElseClause) {
cc.endBlock();
}
break;
case Token.NULL:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case Token.THIS:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
break;
case Token.SUPER:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
break;
case Token.YIELD:
add(""String_Node_Str"");
if (n.isYieldFor()) {
Preconditions.checkNotNull(first);
add(""String_Node_Str"");
}
if (first != null) {
cc.maybeInsertSpace();
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
}
break;
case Token.FALSE:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case Token.TRUE:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case Token.CONTINUE:
Preconditions.checkState(childCount <= 1);
add(""String_Node_Str"");
if (childCount == 1) {
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
}
cc.endStatement();
break;
case Token.DEBUGGER:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
cc.endStatement();
break;
case Token.BREAK:
Preconditions.checkState(childCount <= 1);
add(""String_Node_Str"");
if (childCount == 1) {
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
}
cc.endStatement();
break;
case Token.EXPR_RESULT:
Preconditions.checkState(childCount == 1);
add(first,Context.START_OF_EXPR);
cc.endStatement();
break;
case Token.NEW:
add(""String_Node_Str"");
int precedence=NodeUtil.precedence(type);
if (NodeUtil.containsType(first,Token.CALL,NodeUtil.MATCH_NOT_FUNCTION)) {
precedence=NodeUtil.precedence(first.getType()) + 1;
}
addExpr(first,precedence,Context.OTHER);
Node next=first.getNext();
if (next != null) {
add(""String_Node_Str"");
addList(next);
add(""String_Node_Str"");
}
break;
case Token.STRING_KEY:
addStringKey(n);
break;
case Token.STRING:
Preconditions.checkState(childCount == 0,""String_Node_Str"");
addJsString(n);
break;
case Token.DELPROP:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
add(first);
break;
case Token.OBJECTLIT:
{
boolean needsParens=(context == Context.START_OF_EXPR);
if (needsParens) {
add(""String_Node_Str"");
}
add(""String_Node_Str"");
for (Node c=first; c != null; c=c.getNext()) {
if (c != first) {
cc.listSeparator();
}
Preconditions.checkState(c.isComputedProp() || c.isGetterDef() || c.isSetterDef()|| c.isStringKey()|| c.isMemberFunctionDef());
add(c);
}
add(""String_Node_Str"");
if (needsParens) {
add(""String_Node_Str"");
}
break;
}
case Token.COMPUTED_PROP:
maybeAddAccessibilityModifier(n);
if (n.getBooleanProp(Node.STATIC_MEMBER)) {
add(""String_Node_Str"");
}
if (n.getBooleanProp(Node.COMPUTED_PROP_GETTER)) {
add(""String_Node_Str"");
}
 else if (n.getBooleanProp(Node.COMPUTED_PROP_SETTER)) {
add(""String_Node_Str"");
}
 else if (last.getBooleanProp(Node.GENERATOR_FN)) {
add(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
maybeAddTypeDecl(n);
if (n.getBooleanProp(Node.COMPUTED_PROP_METHOD) || n.getBooleanProp(Node.COMPUTED_PROP_GETTER) || n.getBooleanProp(Node.COMPUTED_PROP_SETTER)) {
Node function=first.getNext();
Node params=function.getSecondChild();
Node body=function.getLastChild();
add(params);
add(body,Context.PRESERVE_BLOCK);
}
 else {
boolean isInClass=n.getParent().getType() == Token.CLASS_MEMBERS;
Node initializer=first.getNext();
if (initializer != null) {
Preconditions.checkState(!isInClass,""String_Node_Str"");
cc.addOp(""String_Node_Str"",false);
add(initializer);
}
 else {
Preconditions.checkState(n.getBooleanProp(Node.COMPUTED_PROP_VARIABLE),n);
}
}
break;
case Token.OBJECT_PATTERN:
addObjectPattern(n);
maybeAddTypeDecl(n);
break;
case Token.SWITCH:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
cc.beginBlock();
addAllSiblings(first.getNext());
cc.endBlock(context == Context.STATEMENT);
break;
case Token.CASE:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
add(first);
addCaseBody(last);
break;
case Token.DEFAULT_CASE:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
addCaseBody(first);
break;
case Token.LABEL:
Preconditions.checkState(childCount == 2);
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(first);
add(""String_Node_Str"");
if (!last.isBlock()) {
cc.maybeInsertSpace();
}
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),true);
break;
case Token.CAST:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
break;
case Token.TAGGED_TEMPLATELIT:
add(first,Context.START_OF_EXPR);
add(first.getNext());
break;
case Token.TEMPLATELIT:
add(""String_Node_Str"");
for (Node c=first; c != null; c=c.getNext()) {
if (c.isString()) {
add(c.getString());
}
 else {
cc.append(""String_Node_Str"");
add(c.getFirstChild(),Context.START_OF_EXPR);
add(""String_Node_Str"");
}
}
add(""String_Node_Str"");
break;
case Token.STRING_TYPE:
add(""String_Node_Str"");
break;
case Token.BOOLEAN_TYPE:
add(""String_Node_Str"");
break;
case Token.NUMBER_TYPE:
add(""String_Node_Str"");
break;
case Token.ANY_TYPE:
add(""String_Node_Str"");
break;
case Token.VOID_TYPE:
add(""String_Node_Str"");
break;
case Token.NAMED_TYPE:
add(first);
break;
case Token.ARRAY_TYPE:
addExpr(first,NodeUtil.precedence(Token.ARRAY_TYPE),context);
add(""String_Node_Str"");
break;
case Token.FUNCTION_TYPE:
Node returnType=first;
add(""String_Node_Str"");
addList(first.getNext());
add(""String_Node_Str"");
cc.addOp(""String_Node_Str"",true);
add(returnType);
break;
case Token.UNION_TYPE:
addList(first,""String_Node_Str"");
break;
case Token.RECORD_TYPE:
add(""String_Node_Str"");
addList(first,false,Context.OTHER,""String_Node_Str"");
add(""String_Node_Str"");
break;
case Token.PARAMETERIZED_TYPE:
add(first);
add(""String_Node_Str"");
addList(first.getNext());
add(""String_Node_Str"");
break;
case Token.GENERIC_TYPE_LIST:
add(""String_Node_Str"");
addList(first,false,Context.STATEMENT,""String_Node_Str"");
add(""String_Node_Str"");
break;
case Token.GENERIC_TYPE:
addIdentifier(n.getString());
if (n.hasChildren()) {
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(n.getFirstChild());
}
break;
case Token.INTERFACE:
{
Preconditions.checkState(childCount == 3);
Node name=first;
Node superTypes=first.getNext();
Node members=last;
add(""String_Node_Str"");
add(name);
maybeAddGenericTypes(name);
if (!superTypes.isEmpty()) {
add(""String_Node_Str"");
Node superType=superTypes.getFirstChild();
add(superType);
while ((superType=superType.getNext()) != null) {
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(superType);
}
}
add(members);
}
break;
case Token.ENUM:
{
Preconditions.checkState(childCount == 2);
Node name=first;
Node members=last;
add(""String_Node_Str"");
add(name);
add(members);
break;
}
case Token.NAMESPACE:
{
Preconditions.checkState(childCount == 2);
Node name=first;
Node elements=last;
add(""String_Node_Str"");
add(name);
add(elements);
break;
}
case Token.TYPE_ALIAS:
add(""String_Node_Str"");
add(n.getString());
cc.addOp(""String_Node_Str"",true);
add(last);
cc.endStatement(true);
break;
case Token.DECLARE:
add(""String_Node_Str"");
add(first);
processEnd(n,context);
break;
case Token.INDEX_SIGNATURE:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
maybeAddTypeDecl(n);
cc.endStatement(true);
break;
case Token.CALL_SIGNATURE:
if (n.getBooleanProp(Node.CONSTRUCT_SIGNATURE)) {
add(""String_Node_Str"");
}
maybeAddGenericTypes(n);
add(first);
maybeAddTypeDecl(n);
cc.endStatement(true);
break;
default :
throw new RuntimeException(""String_Node_Str"" + Token.name(type) + ""String_Node_Str""+ n.toStringTree());
}
cc.endSourceMapping(n);
}","void add(Node n,Context context){
  if (!cc.continueProcessing()) {
    return;
  }
  if (preserveTypeAnnotations && n.getJSDocInfo() != null) {
    String jsdocAsString=JSDocInfoPrinter.print(n.getJSDocInfo());
    if (!jsdocAsString.equals(""String_Node_Str"")) {
      add(jsdocAsString);
    }
  }
  int type=n.getType();
  String opstr=NodeUtil.opToStr(type);
  int childCount=n.getChildCount();
  Node first=n.getFirstChild();
  Node last=n.getLastChild();
  if (opstr != null && first != last) {
    Preconditions.checkState(childCount == 2,""String_Node_Str"",opstr,childCount);
    int p=NodeUtil.precedence(type);
    Context rhsContext=getContextForNoInOperator(context);
    boolean needsParens=(context == Context.START_OF_EXPR) && first.isObjectPattern();
    if (n.isAssign() && needsParens) {
      add(""String_Node_Str"");
    }
    if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
      addExpr(first,p,context);
      cc.addOp(opstr,true);
      addExpr(last,p,rhsContext);
    }
 else {
      unrollBinaryOperator(n,type,opstr,context,rhsContext,p,p + 1);
    }
    if (n.isAssign() && needsParens) {
      add(""String_Node_Str"");
    }
    return;
  }
  cc.startSourceMapping(n);
switch (type) {
case Token.TRY:
{
      Preconditions.checkState(first.getNext().isBlock() && !first.getNext().hasMoreThanOneChild());
      Preconditions.checkState(childCount >= 2 && childCount <= 3);
      add(""String_Node_Str"");
      add(first,Context.PRESERVE_BLOCK);
      Node catchblock=first.getNext().getFirstChild();
      if (catchblock != null) {
        add(catchblock);
      }
      if (childCount == 3) {
        cc.maybeInsertSpace();
        add(""String_Node_Str"");
        add(last,Context.PRESERVE_BLOCK);
      }
      break;
    }
case Token.CATCH:
  Preconditions.checkState(childCount == 2);
cc.maybeInsertSpace();
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(last,Context.PRESERVE_BLOCK);
break;
case Token.THROW:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(first);
cc.endStatement(true);
break;
case Token.RETURN:
add(""String_Node_Str"");
if (childCount == 1) {
cc.maybeInsertSpace();
add(first);
}
 else {
Preconditions.checkState(childCount == 0);
}
cc.endStatement();
break;
case Token.VAR:
if (first != null) {
add(""String_Node_Str"");
addList(first,false,getContextForNoInOperator(context),""String_Node_Str"");
}
break;
case Token.CONST:
add(""String_Node_Str"");
addList(first,false,getContextForNoInOperator(context),""String_Node_Str"");
break;
case Token.LET:
add(""String_Node_Str"");
addList(first,false,getContextForNoInOperator(context),""String_Node_Str"");
break;
case Token.LABEL_NAME:
Preconditions.checkState(!n.getString().isEmpty());
addIdentifier(n.getString());
break;
case Token.DESTRUCTURING_LHS:
add(first);
if (first != last) {
Preconditions.checkState(childCount == 2);
cc.addOp(""String_Node_Str"",true);
add(last);
}
break;
case Token.NAME:
addIdentifier(n.getString());
maybeAddOptional(n);
maybeAddTypeDecl(n);
if (first != null && !first.isEmpty()) {
Preconditions.checkState(childCount == 1);
cc.addOp(""String_Node_Str"",true);
if (first.isComma()) {
addExpr(first,NodeUtil.precedence(Token.ASSIGN),Context.OTHER);
}
 else {
addExpr(first,0,getContextForNoInOperator(context));
}
}
break;
case Token.ARRAYLIT:
add(""String_Node_Str"");
addArrayList(first);
add(""String_Node_Str"");
break;
case Token.ARRAY_PATTERN:
add(""String_Node_Str"");
addArrayList(first);
add(""String_Node_Str"");
maybeAddTypeDecl(n);
break;
case Token.PARAM_LIST:
add(""String_Node_Str"");
addList(first);
add(""String_Node_Str"");
break;
case Token.DEFAULT_VALUE:
add(first);
maybeAddTypeDecl(n);
cc.addOp(""String_Node_Str"",true);
add(first.getNext());
break;
case Token.COMMA:
Preconditions.checkState(childCount == 2);
unrollBinaryOperator(n,Token.COMMA,""String_Node_Str"",context,getContextForNoInOperator(context),0,0);
break;
case Token.NUMBER:
Preconditions.checkState(childCount == 0);
cc.addNumber(n.getDouble());
break;
case Token.TYPEOF:
case Token.VOID:
case Token.NOT:
case Token.BITNOT:
case Token.POS:
{
Preconditions.checkState(childCount == 1);
cc.addOp(NodeUtil.opToStrNoFail(type),false);
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
break;
}
case Token.NEG:
{
Preconditions.checkState(childCount == 1);
if (n.getFirstChild().isNumber()) {
cc.addNumber(-n.getFirstChild().getDouble());
}
 else {
cc.addOp(NodeUtil.opToStrNoFail(type),false);
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
}
break;
}
case Token.HOOK:
{
Preconditions.checkState(childCount == 3);
int p=NodeUtil.precedence(type);
Context rhsContext=getContextForNoInOperator(context);
addExpr(first,p + 1,context);
cc.addOp(""String_Node_Str"",true);
addExpr(first.getNext(),1,rhsContext);
cc.addOp(""String_Node_Str"",true);
addExpr(last,1,rhsContext);
break;
}
case Token.REGEXP:
if (!first.isString() || !last.isString()) {
throw new Error(""String_Node_Str"");
}
String regexp=regexpEscape(first.getString(),outputCharsetEncoder);
if (childCount == 2) {
add(regexp + last.getString());
}
 else {
Preconditions.checkState(childCount == 1);
add(regexp);
}
break;
case Token.FUNCTION:
{
if (n.getClass() != Node.class) {
throw new Error(""String_Node_Str"");
}
Preconditions.checkState(childCount == 3);
if (n.isArrowFunction()) {
addArrowFunction(n,first,last,context);
}
 else {
addFunction(n,first,last,context);
}
break;
}
case Token.REST:
add(""String_Node_Str"");
add(first.getString());
maybeAddTypeDecl(n);
break;
case Token.SPREAD:
add(""String_Node_Str"");
add(n.getFirstChild());
break;
case Token.EXPORT:
add(""String_Node_Str"");
if (n.getBooleanProp(Node.EXPORT_DEFAULT)) {
add(""String_Node_Str"");
}
if (n.getBooleanProp(Node.EXPORT_ALL_FROM)) {
add(""String_Node_Str"");
Preconditions.checkState(first != null && first.isEmpty());
}
 else {
add(first);
}
if (childCount == 2) {
add(""String_Node_Str"");
add(last);
}
processEnd(first,context);
break;
case Token.IMPORT:
add(""String_Node_Str"");
Node second=first.getNext();
if (!first.isEmpty()) {
add(first);
if (!second.isEmpty()) {
cc.listSeparator();
}
}
if (!second.isEmpty()) {
add(second);
}
if (!first.isEmpty() || !second.isEmpty()) {
add(""String_Node_Str"");
}
add(last);
cc.endStatement();
break;
case Token.EXPORT_SPECS:
case Token.IMPORT_SPECS:
add(""String_Node_Str"");
for (Node c=first; c != null; c=c.getNext()) {
if (c != first) {
cc.listSeparator();
}
add(c);
}
add(""String_Node_Str"");
break;
case Token.EXPORT_SPEC:
case Token.IMPORT_SPEC:
add(first);
if (first != last) {
add(""String_Node_Str"");
add(last);
}
break;
case Token.IMPORT_STAR:
add(""String_Node_Str"");
add(""String_Node_Str"");
add(n.getString());
break;
case Token.CLASS:
{
Preconditions.checkState(childCount == 3);
boolean classNeedsParens=(context == Context.START_OF_EXPR);
if (classNeedsParens) {
add(""String_Node_Str"");
}
Node name=first;
Node superClass=first.getNext();
Node members=last;
add(""String_Node_Str"");
if (!name.isEmpty()) {
add(name);
}
maybeAddGenericTypes(first);
if (!superClass.isEmpty()) {
add(""String_Node_Str"");
add(superClass);
}
Node interfaces=(Node)n.getProp(Node.IMPLEMENTS);
if (interfaces != null) {
add(""String_Node_Str"");
Node child=interfaces.getFirstChild();
add(child);
while ((child=child.getNext()) != null) {
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(child);
}
}
add(members);
cc.endClass(context == Context.STATEMENT);
if (classNeedsParens) {
add(""String_Node_Str"");
}
}
break;
case Token.CLASS_MEMBERS:
case Token.INTERFACE_MEMBERS:
case Token.NAMESPACE_ELEMENTS:
cc.beginBlock();
for (Node c=first; c != null; c=c.getNext()) {
add(c);
processEnd(c,context);
cc.endLine();
}
cc.endBlock(false);
break;
case Token.ENUM_MEMBERS:
cc.beginBlock();
for (Node c=first; c != null; c=c.getNext()) {
add(c);
if (c.getNext() != null) {
add(""String_Node_Str"");
}
cc.endLine();
}
cc.endBlock(false);
break;
case Token.GETTER_DEF:
case Token.SETTER_DEF:
case Token.MEMBER_FUNCTION_DEF:
case Token.MEMBER_VARIABLE_DEF:
{
n.getParent().toStringTree();
Preconditions.checkState(n.getParent().isObjectLit() || n.getParent().isClassMembers() || n.getParent().isInterfaceMembers()|| n.getParent().isRecordType()|| n.getParent().isIndexSignature());
maybeAddAccessibilityModifier(n);
if (n.isStaticMember()) {
add(""String_Node_Str"");
}
if (!n.isMemberVariableDef() && n.getFirstChild().isGeneratorFunction()) {
Preconditions.checkState(type == Token.MEMBER_FUNCTION_DEF);
add(""String_Node_Str"");
}
switch (type) {
case Token.GETTER_DEF:
Preconditions.checkState(!first.getSecondChild().hasChildren());
add(""String_Node_Str"");
break;
case Token.SETTER_DEF:
Preconditions.checkState(first.getSecondChild().hasOneChild());
add(""String_Node_Str"");
break;
case Token.MEMBER_FUNCTION_DEF:
case Token.MEMBER_VARIABLE_DEF:
break;
}
String name=n.getString();
if (n.isMemberVariableDef()) {
add(n.getString());
maybeAddOptional(n);
maybeAddTypeDecl(n);
}
 else {
Preconditions.checkState(childCount == 1);
Preconditions.checkState(first.isFunction());
Preconditions.checkState(first.getFirstChild().getString().isEmpty());
Node fn=first;
Node parameters=fn.getSecondChild();
Node body=fn.getLastChild();
if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) && NodeUtil.isLatin(name)) {
add(name);
maybeAddGenericTypes(fn.getFirstChild());
}
 else {
double d=getSimpleNumber(name);
if (!Double.isNaN(d)) {
cc.addNumber(d);
}
 else {
addJsString(n);
}
}
maybeAddOptional(fn);
add(parameters);
maybeAddTypeDecl(fn);
add(body,Context.PRESERVE_BLOCK);
}
break;
}
case Token.SCRIPT:
case Token.BLOCK:
{
if (n.getClass() != Node.class) {
throw new Error(""String_Node_Str"");
}
boolean preserveBlock=context == Context.PRESERVE_BLOCK;
if (preserveBlock) {
cc.beginBlock();
}
boolean preferLineBreaks=type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().isScript());
for (Node c=first; c != null; c=c.getNext()) {
add(c,Context.STATEMENT);
if (NodeUtil.isNameDeclaration(c)) {
cc.endStatement();
}
if (c.isFunction() || c.isClass()) {
cc.maybeLineBreak();
}
if (preferLineBreaks) {
cc.notePreferredLineBreak();
}
}
if (preserveBlock) {
cc.endBlock(cc.breakAfterBlockFor(n,context == Context.STATEMENT));
}
break;
}
case Token.FOR:
if (childCount == 4) {
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
if (NodeUtil.isNameDeclaration(first)) {
add(first,Context.IN_FOR_INIT_CLAUSE);
}
 else {
addExpr(first,0,Context.IN_FOR_INIT_CLAUSE);
}
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
add(first.getNext().getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
 else {
Preconditions.checkState(childCount == 3);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
break;
case Token.FOR_OF:
Preconditions.checkState(childCount == 3);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case Token.DO:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
addNonEmptyStatement(first,Context.OTHER,false);
cc.maybeInsertSpace();
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(last);
add(""String_Node_Str"");
cc.endStatement();
break;
case Token.WHILE:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case Token.EMPTY:
Preconditions.checkState(childCount == 0);
break;
case Token.GETPROP:
{
Preconditions.checkState(childCount == 2,""String_Node_Str"",childCount);
Preconditions.checkState(last.isString(),""String_Node_Str"");
boolean needsParens=(first.isNumber());
if (needsParens) {
add(""String_Node_Str"");
}
addExpr(first,NodeUtil.precedence(type),context);
if (needsParens) {
add(""String_Node_Str"");
}
if (quoteKeywordProperties && TokenStream.isKeyword(last.getString())) {
add(""String_Node_Str"");
add(last);
add(""String_Node_Str"");
}
 else {
add(""String_Node_Str"");
addIdentifier(last.getString());
}
break;
}
case Token.GETELEM:
Preconditions.checkState(childCount == 2,""String_Node_Str"",childCount,n);
addExpr(first,NodeUtil.precedence(type),context);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
break;
case Token.WITH:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case Token.INC:
case Token.DEC:
{
Preconditions.checkState(childCount == 1);
String o=type == Token.INC ? ""String_Node_Str"" : ""String_Node_Str"";
boolean postProp=n.getBooleanProp(Node.INCRDECR_PROP);
if (postProp) {
addExpr(first,NodeUtil.precedence(type),context);
cc.addOp(o,false);
}
 else {
cc.addOp(o,false);
add(first);
}
break;
}
case Token.CALL:
if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
add(""String_Node_Str"");
addExpr(first,NodeUtil.precedence(Token.COMMA),Context.OTHER);
add(""String_Node_Str"");
}
 else {
addExpr(first,NodeUtil.precedence(type),context);
}
Node args=first.getNext();
add(""String_Node_Str"");
addList(args);
add(""String_Node_Str"");
break;
case Token.IF:
boolean hasElse=childCount == 3;
boolean ambiguousElseClause=context == Context.BEFORE_DANGLING_ELSE && !hasElse;
if (ambiguousElseClause) {
cc.beginBlock();
}
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
if (childCount == 1) {
break;
}
if (hasElse) {
addNonEmptyStatement(first.getNext(),Context.BEFORE_DANGLING_ELSE,false);
cc.maybeInsertSpace();
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
 else {
addNonEmptyStatement(first.getNext(),Context.OTHER,false);
Preconditions.checkState(childCount == 2);
}
if (ambiguousElseClause) {
cc.endBlock();
}
break;
case Token.NULL:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case Token.THIS:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
break;
case Token.SUPER:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
break;
case Token.YIELD:
add(""String_Node_Str"");
if (n.isYieldFor()) {
Preconditions.checkNotNull(first);
add(""String_Node_Str"");
}
if (first != null) {
cc.maybeInsertSpace();
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
}
break;
case Token.FALSE:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case Token.TRUE:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case Token.CONTINUE:
Preconditions.checkState(childCount <= 1);
add(""String_Node_Str"");
if (childCount == 1) {
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
}
cc.endStatement();
break;
case Token.DEBUGGER:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
cc.endStatement();
break;
case Token.BREAK:
Preconditions.checkState(childCount <= 1);
add(""String_Node_Str"");
if (childCount == 1) {
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
}
cc.endStatement();
break;
case Token.EXPR_RESULT:
Preconditions.checkState(childCount == 1);
add(first,Context.START_OF_EXPR);
cc.endStatement();
break;
case Token.NEW:
add(""String_Node_Str"");
int precedence=NodeUtil.precedence(type);
if (NodeUtil.containsType(first,Token.CALL,NodeUtil.MATCH_NOT_FUNCTION)) {
precedence=NodeUtil.precedence(first.getType()) + 1;
}
addExpr(first,precedence,Context.OTHER);
Node next=first.getNext();
if (next != null) {
add(""String_Node_Str"");
addList(next);
add(""String_Node_Str"");
}
break;
case Token.STRING_KEY:
addStringKey(n);
break;
case Token.STRING:
Preconditions.checkState(childCount == 0,""String_Node_Str"");
addJsString(n);
break;
case Token.DELPROP:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
add(first);
break;
case Token.OBJECTLIT:
{
boolean needsParens=(context == Context.START_OF_EXPR);
if (needsParens) {
add(""String_Node_Str"");
}
add(""String_Node_Str"");
for (Node c=first; c != null; c=c.getNext()) {
if (c != first) {
cc.listSeparator();
}
Preconditions.checkState(c.isComputedProp() || c.isGetterDef() || c.isSetterDef()|| c.isStringKey()|| c.isMemberFunctionDef());
add(c);
}
add(""String_Node_Str"");
if (needsParens) {
add(""String_Node_Str"");
}
break;
}
case Token.COMPUTED_PROP:
maybeAddAccessibilityModifier(n);
if (n.getBooleanProp(Node.STATIC_MEMBER)) {
add(""String_Node_Str"");
}
if (n.getBooleanProp(Node.COMPUTED_PROP_GETTER)) {
add(""String_Node_Str"");
}
 else if (n.getBooleanProp(Node.COMPUTED_PROP_SETTER)) {
add(""String_Node_Str"");
}
 else if (last.getBooleanProp(Node.GENERATOR_FN)) {
add(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
maybeAddTypeDecl(n);
if (n.getBooleanProp(Node.COMPUTED_PROP_METHOD) || n.getBooleanProp(Node.COMPUTED_PROP_GETTER) || n.getBooleanProp(Node.COMPUTED_PROP_SETTER)) {
Node function=first.getNext();
Node params=function.getSecondChild();
Node body=function.getLastChild();
add(params);
add(body,Context.PRESERVE_BLOCK);
}
 else {
boolean isInClass=n.getParent().getType() == Token.CLASS_MEMBERS;
Node initializer=first.getNext();
if (initializer != null) {
Preconditions.checkState(!isInClass,""String_Node_Str"");
cc.addOp(""String_Node_Str"",false);
add(initializer);
}
 else {
Preconditions.checkState(n.getBooleanProp(Node.COMPUTED_PROP_VARIABLE),n);
}
}
break;
case Token.OBJECT_PATTERN:
addObjectPattern(n);
maybeAddTypeDecl(n);
break;
case Token.SWITCH:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
cc.beginBlock();
addAllSiblings(first.getNext());
cc.endBlock(context == Context.STATEMENT);
break;
case Token.CASE:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
add(first);
addCaseBody(last);
break;
case Token.DEFAULT_CASE:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
addCaseBody(first);
break;
case Token.LABEL:
Preconditions.checkState(childCount == 2);
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(first);
add(""String_Node_Str"");
if (!last.isBlock()) {
cc.maybeInsertSpace();
}
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),true);
break;
case Token.CAST:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
break;
case Token.TAGGED_TEMPLATELIT:
add(first,Context.START_OF_EXPR);
add(first.getNext());
break;
case Token.TEMPLATELIT:
add(""String_Node_Str"");
for (Node c=first; c != null; c=c.getNext()) {
if (c.isString()) {
add(c.getString());
}
 else {
cc.append(""String_Node_Str"");
add(c.getFirstChild(),Context.START_OF_EXPR);
add(""String_Node_Str"");
}
}
add(""String_Node_Str"");
break;
case Token.STRING_TYPE:
add(""String_Node_Str"");
break;
case Token.BOOLEAN_TYPE:
add(""String_Node_Str"");
break;
case Token.NUMBER_TYPE:
add(""String_Node_Str"");
break;
case Token.ANY_TYPE:
add(""String_Node_Str"");
break;
case Token.VOID_TYPE:
add(""String_Node_Str"");
break;
case Token.NAMED_TYPE:
add(first);
break;
case Token.ARRAY_TYPE:
addExpr(first,NodeUtil.precedence(Token.ARRAY_TYPE),context);
add(""String_Node_Str"");
break;
case Token.FUNCTION_TYPE:
Node returnType=first;
add(""String_Node_Str"");
addList(first.getNext());
add(""String_Node_Str"");
cc.addOp(""String_Node_Str"",true);
add(returnType);
break;
case Token.UNION_TYPE:
addList(first,""String_Node_Str"");
break;
case Token.RECORD_TYPE:
add(""String_Node_Str"");
addList(first,false,Context.OTHER,""String_Node_Str"");
add(""String_Node_Str"");
break;
case Token.PARAMETERIZED_TYPE:
add(first);
add(""String_Node_Str"");
addList(first.getNext());
add(""String_Node_Str"");
break;
case Token.GENERIC_TYPE_LIST:
add(""String_Node_Str"");
addList(first,false,Context.STATEMENT,""String_Node_Str"");
add(""String_Node_Str"");
break;
case Token.GENERIC_TYPE:
addIdentifier(n.getString());
if (n.hasChildren()) {
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(n.getFirstChild());
}
break;
case Token.INTERFACE:
{
Preconditions.checkState(childCount == 3);
Node name=first;
Node superTypes=first.getNext();
Node members=last;
add(""String_Node_Str"");
add(name);
maybeAddGenericTypes(name);
if (!superTypes.isEmpty()) {
add(""String_Node_Str"");
Node superType=superTypes.getFirstChild();
add(superType);
while ((superType=superType.getNext()) != null) {
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(superType);
}
}
add(members);
}
break;
case Token.ENUM:
{
Preconditions.checkState(childCount == 2);
Node name=first;
Node members=last;
add(""String_Node_Str"");
add(name);
add(members);
break;
}
case Token.NAMESPACE:
{
Preconditions.checkState(childCount == 2);
Node name=first;
Node elements=last;
add(""String_Node_Str"");
add(name);
add(elements);
break;
}
case Token.TYPE_ALIAS:
add(""String_Node_Str"");
add(n.getString());
cc.addOp(""String_Node_Str"",true);
add(last);
cc.endStatement(true);
break;
case Token.DECLARE:
add(""String_Node_Str"");
add(first);
processEnd(n,context);
break;
case Token.INDEX_SIGNATURE:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
maybeAddTypeDecl(n);
cc.endStatement(true);
break;
case Token.CALL_SIGNATURE:
if (n.getBooleanProp(Node.CONSTRUCT_SIGNATURE)) {
add(""String_Node_Str"");
}
maybeAddGenericTypes(n);
add(first);
maybeAddTypeDecl(n);
cc.endStatement(true);
break;
default :
throw new RuntimeException(""String_Node_Str"" + Token.name(type) + ""String_Node_Str""+ n.toStringTree());
}
cc.endSourceMapping(n);
}",0.9974285976673708
27403,"/** 
 * Appends the exported function and all paths necessary for the path to be declared. For example, for a property ""a.b.c"", the initializers for paths ""a"", ""a.b"" will be appended (if they have not already) and a.b.c will be initialized with the exported version of the function: <pre> var a = {}; a.b = {}; a.b.c = function(x,y) { } </pre>
 */
void appendExtern(String path,Node valueToExport){
  List<String> pathPrefixes=computePathPrefixes(path);
  for (int i=0; i < pathPrefixes.size(); ++i) {
    String pathPrefix=pathPrefixes.get(i);
    boolean isCompletePathPrefix=(i == pathPrefixes.size() - 1);
    boolean skipPathPrefix=pathPrefix.endsWith(""String_Node_Str"") || (alreadyExportedPaths.contains(pathPrefix) && !isCompletePathPrefix);
    if (!skipPathPrefix) {
      Node initializer;
      if (isCompletePathPrefix && valueToExport != null) {
        if (valueToExport.isFunction()) {
          initializer=createExternFunction(valueToExport);
        }
 else {
          Preconditions.checkState(valueToExport.isObjectLit());
          initializer=createExternObjectLit(valueToExport);
        }
      }
 else {
        initializer=IR.empty();
      }
      appendPathDefinition(pathPrefix,initializer);
    }
  }
}","/** 
 * Appends the exported function and all paths necessary for the path to be declared. For example, for a property ""a.b.c"", the initializers for paths ""a"", ""a.b"" will be appended (if they have not already) and a.b.c will be initialized with the exported version of the function: <pre> var a = {}; a.b = {}; a.b.c = function(x,y) { } </pre>
 */
void appendExtern(String path,Node valueToExport){
  List<String> pathPrefixes=computePathPrefixes(path);
  for (int i=0; i < pathPrefixes.size(); ++i) {
    String pathPrefix=pathPrefixes.get(i);
    boolean isCompletePathPrefix=(i == pathPrefixes.size() - 1);
    boolean skipPathPrefix=pathPrefix.endsWith(""String_Node_Str"") || (alreadyExportedPaths.contains(pathPrefix) && !isCompletePathPrefix);
    boolean exportedValueDefinesNewType=false;
    if (valueToExport != null) {
      JSDocInfo jsdoc=NodeUtil.getBestJSDocInfo(valueToExport);
      if (jsdoc != null && jsdoc.containsTypeDefinition()) {
        exportedValueDefinesNewType=true;
      }
    }
    if (!skipPathPrefix) {
      Node initializer;
      JSDocInfo jsdoc=null;
      if (isCompletePathPrefix && valueToExport != null) {
        if (valueToExport.isFunction()) {
          initializer=createExternFunction(valueToExport);
        }
 else {
          Preconditions.checkState(valueToExport.isObjectLit());
          initializer=createExternObjectLit(valueToExport);
        }
      }
 else       if (!isCompletePathPrefix && exportedValueDefinesNewType) {
        jsdoc=buildNamespaceJSDoc();
        initializer=createExternObjectLit(IR.objectlit());
        initializer.setJSDocInfo(null);
      }
 else {
        initializer=IR.empty();
      }
      appendPathDefinition(pathPrefix,initializer,jsdoc);
    }
  }
}",0.825546218487395
27404,"/** 
 * Given a function to export, create the empty function that will be put in the externs file. This extern function should have the same type as the original function and the same parameter name but no function body. We create a warning here if the the function to export is missing parameter or return types.
 */
private Node createExternFunction(Node exportedFunction){
  Node paramList=NodeUtil.getFunctionParameters(exportedFunction).cloneTree();
  Node param=paramList.getFirstChild();
  while (param != null && param.isName()) {
    String originalName=param.getOriginalName();
    if (originalName != null) {
      param.setString(originalName);
    }
    param=param.getNext();
  }
  Node externFunction=IR.function(IR.name(""String_Node_Str""),paramList,IR.block());
  externFunction.setJSType(exportedFunction.getJSType());
  return externFunction;
}","/** 
 * Given a function to export, create the empty function that will be put in the externs file. This extern function should have the same type as the original function and the same parameter name but no function body. We create a warning here if the the function to export is missing parameter or return types.
 */
private Node createExternFunction(Node exportedFunction){
  Node paramList=NodeUtil.getFunctionParameters(exportedFunction).cloneTree();
  Node param=paramList.getFirstChild();
  while (param != null && param.isName()) {
    String originalName=param.getOriginalName();
    if (originalName != null) {
      param.setString(originalName);
    }
    param=param.getNext();
  }
  Node externFunction=IR.function(IR.name(""String_Node_Str""),paramList,IR.block());
  if (exportedFunction.getJSType() != null) {
    externFunction.setJSType(exportedFunction.getJSType());
    deleteInlineJsdocs(externFunction);
  }
  return externFunction;
}",0.8888888888888888
27405,"private void appendPathDefinition(String path,Node initializer){
  Node pathDefinition;
  if (!path.contains(""String_Node_Str"")) {
    if (initializer.isEmpty()) {
      pathDefinition=IR.var(IR.name(path));
    }
 else {
      pathDefinition=NodeUtil.newVarNode(path,initializer);
    }
  }
 else {
    Node qualifiedPath=NodeUtil.newQName(compiler,path);
    if (initializer.isEmpty()) {
      pathDefinition=NodeUtil.newExpr(qualifiedPath);
    }
 else {
      pathDefinition=NodeUtil.newExpr(IR.assign(qualifiedPath,initializer));
    }
  }
  externsRoot.addChildToBack(pathDefinition);
  alreadyExportedPaths.add(path);
}","private void appendPathDefinition(String path,Node initializer,JSDocInfo jsdoc){
  Node pathDefinition;
  if (!path.contains(""String_Node_Str"")) {
    if (initializer.isEmpty()) {
      pathDefinition=IR.var(IR.name(path));
    }
 else {
      pathDefinition=NodeUtil.newVarNode(path,initializer);
    }
  }
 else {
    Node qualifiedPath=NodeUtil.newQName(compiler,path);
    if (initializer.isEmpty()) {
      pathDefinition=NodeUtil.newExpr(qualifiedPath);
    }
 else {
      pathDefinition=NodeUtil.newExpr(IR.assign(qualifiedPath,initializer));
    }
  }
  if (jsdoc != null) {
    if (pathDefinition.isExprResult()) {
      pathDefinition.getFirstChild().setJSDocInfo(jsdoc);
    }
 else {
      Preconditions.checkState(pathDefinition.isVar());
      pathDefinition.setJSDocInfo(jsdoc);
    }
  }
  externsRoot.addChildToBack(pathDefinition);
  alreadyExportedPaths.add(path);
}",0.828042328042328
27406,"public static String print(JSDocInfo info){
  boolean multiline=false;
  List<String> parts=new ArrayList<>();
  parts.add(""String_Node_Str"");
  if (info.isExport()) {
    parts.add(""String_Node_Str"");
  }
 else   if (info.getVisibility() != null && info.getVisibility() != Visibility.INHERITED) {
    parts.add(""String_Node_Str"" + info.getVisibility().toString().toLowerCase());
  }
  if (info.isConstant() && !info.isDefine()) {
    parts.add(""String_Node_Str"");
  }
  if (info.makesDicts()) {
    parts.add(""String_Node_Str"");
  }
  if (info.makesStructs()) {
    parts.add(""String_Node_Str"");
  }
  if (info.makesUnrestricted()) {
    parts.add(""String_Node_Str"");
  }
  if (info.isConstructor()) {
    parts.add(""String_Node_Str"");
  }
  if (info.isInterface() && !info.usesImplicitMatch()) {
    parts.add(""String_Node_Str"");
  }
  if (info.isInterface() && info.usesImplicitMatch()) {
    parts.add(""String_Node_Str"");
  }
  if (info.hasBaseType()) {
    multiline=true;
    Node typeNode=stripBang(info.getBaseType().getRoot());
    parts.add(buildAnnotationWithType(""String_Node_Str"",typeNode));
  }
  for (  JSTypeExpression type : info.getExtendedInterfaces()) {
    multiline=true;
    Node typeNode=stripBang(type.getRoot());
    parts.add(buildAnnotationWithType(""String_Node_Str"",typeNode));
  }
  for (  JSTypeExpression type : info.getImplementedInterfaces()) {
    multiline=true;
    Node typeNode=stripBang(type.getRoot());
    parts.add(buildAnnotationWithType(""String_Node_Str"",typeNode));
  }
  if (info.hasThisType()) {
    multiline=true;
    Node typeNode=stripBang(info.getThisType().getRoot());
    parts.add(buildAnnotationWithType(""String_Node_Str"",typeNode));
  }
  if (info.getParameterCount() > 0) {
    multiline=true;
    for (    String name : info.getParameterNames()) {
      parts.add(""String_Node_Str"" + buildParamType(name,info.getParameterType(name)));
    }
  }
  if (info.hasReturnType()) {
    multiline=true;
    parts.add(buildAnnotationWithType(""String_Node_Str"",info.getReturnType()));
  }
  if (!info.getThrownTypes().isEmpty()) {
    parts.add(buildAnnotationWithType(""String_Node_Str"",info.getThrownTypes().get(0)));
  }
  ImmutableList<String> names=info.getTemplateTypeNames();
  if (!names.isEmpty()) {
    parts.add(""String_Node_Str"" + Joiner.on(',').join(names));
    multiline=true;
  }
  if (info.isOverride()) {
    parts.add(""String_Node_Str"");
  }
  if (info.hasType() && !info.isDefine()) {
    if (info.isInlineType()) {
      parts.add(typeNode(info.getType().getRoot()));
    }
 else {
      parts.add(buildAnnotationWithType(""String_Node_Str"",info.getType()));
    }
  }
  if (info.isDefine()) {
    parts.add(buildAnnotationWithType(""String_Node_Str"",info.getType()));
  }
  if (info.hasTypedefType()) {
    parts.add(buildAnnotationWithType(""String_Node_Str"",info.getTypedefType()));
  }
  if (info.hasEnumParameterType()) {
    parts.add(buildAnnotationWithType(""String_Node_Str"",info.getEnumParameterType()));
  }
  Set<String> suppressions=info.getSuppressions();
  if (!suppressions.isEmpty()) {
    parts.add(""String_Node_Str"" + Joiner.on(',').join(suppressions) + ""String_Node_Str"");
    multiline=true;
  }
  if (info.isDeprecated()) {
    parts.add(""String_Node_Str"" + info.getDeprecationReason());
    multiline=true;
  }
  parts.add(""String_Node_Str"");
  StringBuilder sb=new StringBuilder();
  if (multiline) {
    Joiner.on(""String_Node_Str"").appendTo(sb,parts);
  }
 else {
    Joiner.on(""String_Node_Str"").appendTo(sb,parts);
  }
  sb.append((multiline) ? ""String_Node_Str"" : ""String_Node_Str"");
  return sb.toString();
}","public static String print(JSDocInfo info){
  boolean multiline=false;
  List<String> parts=new ArrayList<>();
  parts.add(""String_Node_Str"");
  if (info.isExport()) {
    parts.add(""String_Node_Str"");
  }
 else   if (info.getVisibility() != null && info.getVisibility() != Visibility.INHERITED) {
    parts.add(""String_Node_Str"" + info.getVisibility().toString().toLowerCase());
  }
  if (info.isConstant() && !info.isDefine()) {
    parts.add(""String_Node_Str"");
  }
  if (info.makesDicts()) {
    parts.add(""String_Node_Str"");
  }
  if (info.makesStructs()) {
    parts.add(""String_Node_Str"");
  }
  if (info.makesUnrestricted()) {
    parts.add(""String_Node_Str"");
  }
  if (info.isConstructor()) {
    parts.add(""String_Node_Str"");
  }
  if (info.isInterface() && !info.usesImplicitMatch()) {
    parts.add(""String_Node_Str"");
  }
  if (info.isInterface() && info.usesImplicitMatch()) {
    parts.add(""String_Node_Str"");
  }
  if (info.hasBaseType()) {
    multiline=true;
    Node typeNode=stripBang(info.getBaseType().getRoot());
    parts.add(buildAnnotationWithType(""String_Node_Str"",typeNode));
  }
  for (  JSTypeExpression type : info.getExtendedInterfaces()) {
    multiline=true;
    Node typeNode=stripBang(type.getRoot());
    parts.add(buildAnnotationWithType(""String_Node_Str"",typeNode));
  }
  for (  JSTypeExpression type : info.getImplementedInterfaces()) {
    multiline=true;
    Node typeNode=stripBang(type.getRoot());
    parts.add(buildAnnotationWithType(""String_Node_Str"",typeNode));
  }
  if (info.hasThisType()) {
    multiline=true;
    Node typeNode=stripBang(info.getThisType().getRoot());
    parts.add(buildAnnotationWithType(""String_Node_Str"",typeNode));
  }
  if (info.getParameterCount() > 0) {
    multiline=true;
    for (    String name : info.getParameterNames()) {
      parts.add(""String_Node_Str"" + buildParamType(name,info.getParameterType(name)));
    }
  }
  if (info.hasReturnType()) {
    multiline=true;
    parts.add(buildAnnotationWithType(""String_Node_Str"",info.getReturnType()));
  }
  if (!info.getThrownTypes().isEmpty()) {
    parts.add(buildAnnotationWithType(""String_Node_Str"",info.getThrownTypes().get(0)));
  }
  ImmutableList<String> names=info.getTemplateTypeNames();
  if (!names.isEmpty()) {
    parts.add(""String_Node_Str"" + Joiner.on(',').join(names));
    multiline=true;
  }
  if (info.isOverride()) {
    parts.add(""String_Node_Str"");
  }
  if (info.hasType() && !info.isDefine()) {
    if (info.isInlineType()) {
      parts.add(typeNode(info.getType().getRoot()));
    }
 else {
      parts.add(buildAnnotationWithType(""String_Node_Str"",info.getType()));
    }
  }
  if (info.isDefine()) {
    parts.add(buildAnnotationWithType(""String_Node_Str"",info.getType()));
  }
  if (info.hasTypedefType()) {
    parts.add(buildAnnotationWithType(""String_Node_Str"",info.getTypedefType()));
  }
  if (info.hasEnumParameterType()) {
    parts.add(buildAnnotationWithType(""String_Node_Str"",info.getEnumParameterType()));
  }
  Set<String> suppressions=info.getSuppressions();
  if (!suppressions.isEmpty()) {
    String[] arr=suppressions.toArray(new String[0]);
    Arrays.sort(arr,Ordering.<String>natural());
    parts.add(""String_Node_Str"" + Joiner.on(',').join(Arrays.asList(arr)) + ""String_Node_Str"");
    multiline=true;
  }
  if (info.isDeprecated()) {
    parts.add(""String_Node_Str"" + info.getDeprecationReason());
    multiline=true;
  }
  parts.add(""String_Node_Str"");
  StringBuilder sb=new StringBuilder();
  if (multiline) {
    Joiner.on(""String_Node_Str"").appendTo(sb,parts);
  }
 else {
    Joiner.on(""String_Node_Str"").appendTo(sb,parts);
  }
  sb.append((multiline) ? ""String_Node_Str"" : ""String_Node_Str"");
  return sb.toString();
}",0.981823151564849
27407,"@Override void add(Node n,Context context){
  Node parent=n.getParent();
  if (parent != null && (parent.isBlock() || parent.isScript())) {
    if (n.isFunction()) {
      add(getFunctionAnnotation(n));
    }
 else     if (n.isExprResult() && n.getFirstChild().isAssign()) {
      Node rhs=n.getFirstChild().getLastChild();
      add(getTypeAnnotation(rhs));
    }
 else     if (n.isVar() && n.getFirstFirstChild() != null) {
      add(getTypeAnnotation(n.getFirstFirstChild()));
    }
  }
  super.add(n,context);
}","@Override void add(Node n,Context context){
  Node parent=n.getParent();
  if (parent != null && (parent.isBlock() || parent.isScript())) {
    if (n.isFunction()) {
      add(getFunctionAnnotation(n));
    }
 else     if (n.isExprResult() && n.getFirstChild().isAssign()) {
      Node assign=n.getFirstChild();
      if (NodeUtil.isNamespaceDecl(assign.getFirstChild())) {
        add(JSDocInfoPrinter.print(assign.getJSDocInfo()));
      }
 else {
        Node rhs=assign.getLastChild();
        add(getTypeAnnotation(rhs));
      }
    }
 else     if (n.isVar() && n.getFirstFirstChild() != null) {
      if (NodeUtil.isNamespaceDecl(n.getFirstChild())) {
        add(JSDocInfoPrinter.print(n.getJSDocInfo()));
      }
 else {
        add(getTypeAnnotation(n.getFirstFirstChild()));
      }
    }
  }
  super.add(n,context);
}",0.7529761904761905
27408,"/** 
 * Gets the r-value (or intializer) of a node returned by getBestLValue. 
 */
static Node getRValueOfLValue(Node n){
  Node parent=n.getParent();
switch (parent.getType()) {
case Token.ASSIGN:
    return n.getNext();
case Token.VAR:
case Token.LET:
case Token.CONST:
case Token.OBJECTLIT:
  return n.getFirstChild();
case Token.FUNCTION:
case Token.CLASS:
return parent;
}
return null;
}","/** 
 * Gets the r-value (or intializer) of a node returned by getBestLValue. 
 */
static Node getRValueOfLValue(Node n){
  Node parent=n.getParent();
switch (parent.getType()) {
case Token.ASSIGN:
case Token.ASSIGN_BITOR:
case Token.ASSIGN_BITXOR:
case Token.ASSIGN_BITAND:
case Token.ASSIGN_LSH:
case Token.ASSIGN_RSH:
case Token.ASSIGN_URSH:
case Token.ASSIGN_ADD:
case Token.ASSIGN_SUB:
case Token.ASSIGN_MUL:
case Token.ASSIGN_DIV:
case Token.ASSIGN_MOD:
    return n.getNext();
case Token.VAR:
case Token.LET:
case Token.CONST:
case Token.OBJECTLIT:
  return n.getFirstChild();
case Token.FUNCTION:
case Token.CLASS:
return parent;
}
return null;
}",0.7495219885277247
27409,"void recordPassStart(String passName,boolean isOneTime){
  currentPass.push(new Stats(passName,isOneTime));
  codeChange.reset();
}","void recordPassStart(String passName,boolean isOneTime){
  currentPass.push(new Stats(passName,isOneTime));
  if (!passName.equals(""String_Node_Str"")) {
    codeChange.reset();
  }
}",0.8370607028753994
27410,"/** 
 * Verifies that the compiler pass's JS output matches the expected output and (optionally) that an expected warning is issued. Or, if an error is expected, this method just verifies that the error is encountered.
 * @param compiler A compiler that has been initialized via{@link Compiler#init}
 * @param expected Expected output, or null if an error is expected
 * @param error Expected error, or null if no error is expected
 * @param warning Expected warning, or null if no warning is expected
 * @param description The description of the expected warning,or null if no warning is expected or if the warning's description should not be examined
 */
private void test(Compiler compiler,List<SourceFile> expected,DiagnosticType error,DiagnosticType warning,String description){
  RecentChange recentChange=new RecentChange();
  compiler.addChangeHandler(recentChange);
  Node root=compiler.parseInputs();
  String errorMsg=LINE_JOINER.join(compiler.getErrors());
  if (root == null && expected == null && error != null) {
    assert_().withFailureMessage(""String_Node_Str"" + errorMsg).that(compiler.getErrorCount()).isEqualTo(1);
    JSError actualError=compiler.getErrors()[0];
    assert_().withFailureMessage(""String_Node_Str"" + errorMsg).that(actualError.getType()).isEqualTo(error);
    if (description != null) {
      assertThat(actualError.description).isEqualTo(description);
    }
    return;
  }
  assert_().withFailureMessage(""String_Node_Str"" + errorMsg).that(root).isNotNull();
  if (!expectParseWarningsThisTest) {
    assertEquals(""String_Node_Str"" + LINE_JOINER.join(compiler.getWarnings()),0,compiler.getWarnings().length);
  }
  if (astValidationEnabled) {
    (new AstValidator(compiler)).validateRoot(root);
  }
  Node externsRoot=root.getFirstChild();
  Node mainRoot=root.getLastChild();
  Node rootClone=root.cloneTree();
  Node externsRootClone=rootClone.getFirstChild();
  Node mainRootClone=rootClone.getLastChild();
  Map<Node,Node> mtoc=NodeUtil.mapMainToClone(mainRoot,mainRootClone);
  int numRepetitions=getNumRepetitions();
  ErrorManager[] errorManagers=new ErrorManager[numRepetitions];
  int aggregateWarningCount=0;
  List<JSError> aggregateWarnings=new ArrayList<>();
  boolean hasCodeChanged=false;
  for (int i=0; i < numRepetitions; ++i) {
    if (compiler.getErrorCount() == 0) {
      errorManagers[i]=new BlackHoleErrorManager();
      compiler.setErrorManager(errorManagers[i]);
      if (rewriteClosureCode && i == 0) {
        new ClosureRewriteClass(compiler).process(null,mainRoot);
        new ClosureRewriteModule(compiler).process(null,mainRoot);
        new ScopedAliases(compiler,null,CompilerOptions.NULL_ALIAS_TRANSFORMATION_HANDLER).process(null,mainRoot);
        hasCodeChanged=hasCodeChanged || recentChange.hasCodeChanged();
      }
      if (closurePassEnabled && i == 0) {
        recentChange.reset();
        new ProcessClosurePrimitives(compiler,null,CheckLevel.ERROR,false).process(null,mainRoot);
        hasCodeChanged=hasCodeChanged || recentChange.hasCodeChanged();
      }
      if (transpileEnabled && i == 0) {
        recentChange.reset();
        transpileToEs5(compiler,externsRoot,mainRoot);
        hasCodeChanged=hasCodeChanged || recentChange.hasCodeChanged();
      }
      if (!runTypeCheckAfterProcessing && typeCheckEnabled && i == 0) {
        TypeCheck check=createTypeCheck(compiler,reportMissingOverrideCheckLevel);
        check.processForTesting(externsRoot,mainRoot);
      }
 else       if (!this.runNTIAfterProcessing && this.newTypeInferenceEnabled && i == 0) {
        runNewTypeInference(compiler,externsRoot,mainRoot);
      }
      if (normalizeEnabled && i == 0) {
        normalizeActualCode(compiler,externsRoot,mainRoot);
      }
      if (enableInferConsts && i == 0) {
        new InferConsts(compiler).process(externsRoot,mainRoot);
      }
      if (computeSideEffects && i == 0) {
        PureFunctionIdentifier.Driver mark=new PureFunctionIdentifier.Driver(compiler,null,false);
        mark.process(externsRoot,mainRoot);
      }
      if (markNoSideEffects && i == 0) {
        MarkNoSideEffectCalls mark=new MarkNoSideEffectCalls(compiler);
        mark.process(externsRoot,mainRoot);
      }
      if (gatherExternPropertiesEnabled && i == 0) {
        (new GatherExternProperties(compiler)).process(externsRoot,mainRoot);
      }
      recentChange.reset();
      getProcessor(compiler).process(externsRoot,mainRoot);
      if (astValidationEnabled) {
        (new AstValidator(compiler)).validateRoot(root);
      }
      if (checkLineNumbers) {
        (new LineNumberCheck(compiler)).process(externsRoot,mainRoot);
      }
      if (runTypeCheckAfterProcessing && typeCheckEnabled && i == 0) {
        TypeCheck check=createTypeCheck(compiler,reportMissingOverrideCheckLevel);
        check.processForTesting(externsRoot,mainRoot);
      }
 else       if (this.runNTIAfterProcessing && this.newTypeInferenceEnabled && i == 0) {
        runNewTypeInference(compiler,externsRoot,mainRoot);
      }
      hasCodeChanged=hasCodeChanged || recentChange.hasCodeChanged();
      aggregateWarningCount+=errorManagers[i].getWarningCount();
      Collections.addAll(aggregateWarnings,compiler.getWarnings());
      if (normalizeEnabled) {
        boolean verifyDeclaredConstants=true;
        new Normalize.VerifyConstants(compiler,verifyDeclaredConstants).process(externsRoot,mainRoot);
      }
    }
  }
  if (error == null) {
    assertEquals(""String_Node_Str"" + LINE_JOINER.join(compiler.getErrors()),0,compiler.getErrorCount());
    ErrorManager symbolTableErrorManager=new BlackHoleErrorManager();
    compiler.setErrorManager(symbolTableErrorManager);
    Node expectedRoot=null;
    if (expected != null) {
      expectedRoot=parseExpectedJs(expected);
      expectedRoot.detachFromParent();
    }
    JSError[] stErrors=symbolTableErrorManager.getErrors();
    if (expectedSymbolTableError != null) {
      assertEquals(""String_Node_Str"",1,stErrors.length);
      assertThat(stErrors[0].getType()).isEqualTo(expectedSymbolTableError);
    }
 else {
      assertEquals(""String_Node_Str"" + LINE_JOINER.join(stErrors),0,stErrors.length);
    }
    if (warning == null) {
      assertEquals(""String_Node_Str"" + LINE_JOINER.join(aggregateWarnings),0,aggregateWarningCount);
    }
 else {
      assertEquals(""String_Node_Str"" + numRepetitions + ""String_Node_Str""+ LINE_JOINER.join(aggregateWarnings),numRepetitions,aggregateWarningCount);
      for (int i=0; i < numRepetitions; ++i) {
        JSError[] warnings=errorManagers[i].getWarnings();
        JSError actual=warnings[0];
        assertThat(actual.getType()).isEqualTo(warning);
        validateSourceLocation(actual);
        if (description != null) {
          assertThat(actual.description).isEqualTo(description);
        }
      }
    }
    if (normalizeEnabled) {
      normalizeActualCode(compiler,externsRootClone,mainRootClone);
    }
    boolean codeChange=!mainRootClone.isEquivalentTo(mainRoot);
    boolean externsChange=!externsRootClone.isEquivalentTo(externsRoot);
    if (externsChange && !allowExternsChanges) {
      String explanation=externsRootClone.checkTreeEquals(externsRoot);
      fail(""String_Node_Str"" + ""String_Node_Str"" + compiler.toSource(externsRootClone) + ""String_Node_Str""+ compiler.toSource(externsRoot)+ ""String_Node_Str""+ explanation);
    }
    if (!codeChange && !externsChange) {
      assertFalse(""String_Node_Str"" + ""String_Node_Str"",hasCodeChanged);
    }
 else {
      assertTrue(""String_Node_Str"" + ""String_Node_Str"" + mainRootClone.toStringTree() + ""String_Node_Str""+ mainRoot.toStringTree(),hasCodeChanged);
    }
    NodeUtil.verifyScopeChanges(mtoc,mainRoot,false);
    if (expected != null) {
      if (compareAsTree) {
        String explanation;
        if (compareJsDoc) {
          explanation=expectedRoot.checkTreeEqualsIncludingJsDoc(mainRoot);
        }
 else {
          explanation=expectedRoot.checkTreeEquals(mainRoot);
        }
        if (explanation != null) {
          String expectedAsSource=compiler.toSource(expectedRoot);
          String mainAsSource=compiler.toSource(mainRoot);
          if (expectedAsSource.equals(mainAsSource)) {
            fail(""String_Node_Str"" + expectedAsSource + ""String_Node_Str""+ explanation);
          }
 else {
            fail(""String_Node_Str"" + expectedAsSource + ""String_Node_Str""+ mainAsSource+ ""String_Node_Str""+ explanation);
          }
        }
      }
 else       if (expected != null) {
        String[] expectedSources=new String[expected.size()];
        for (int i=0; i < expected.size(); ++i) {
          try {
            expectedSources[i]=expected.get(i).getCode();
          }
 catch (          IOException e) {
            throw new RuntimeException(""String_Node_Str"",e);
          }
        }
        assertThat(compiler.toSource(mainRoot)).isEqualTo(Joiner.on(""String_Node_Str"").join(expectedSources));
      }
    }
    Node normalizeCheckRootClone=root.cloneTree();
    Node normalizeCheckExternsRootClone=normalizeCheckRootClone.getFirstChild();
    Node normalizeCheckMainRootClone=normalizeCheckRootClone.getLastChild();
    new PrepareAst(compiler).process(normalizeCheckExternsRootClone,normalizeCheckMainRootClone);
    String explanation=normalizeCheckMainRootClone.checkTreeEquals(mainRoot);
    assertNull(""String_Node_Str"" + ""String_Node_Str"" + compiler.toSource(normalizeCheckMainRootClone) + ""String_Node_Str""+ compiler.toSource(mainRoot)+ ""String_Node_Str""+ explanation,explanation);
    if (normalizeEnabled) {
      new Normalize(compiler,true).process(normalizeCheckExternsRootClone,normalizeCheckMainRootClone);
      explanation=normalizeCheckMainRootClone.checkTreeEquals(mainRoot);
      assertNull(""String_Node_Str"" + ""String_Node_Str"" + compiler.toSource(normalizeCheckMainRootClone) + ""String_Node_Str""+ compiler.toSource(mainRoot)+ ""String_Node_Str""+ explanation,explanation);
    }
  }
 else {
    assertNull(""String_Node_Str"",expected);
    assertEquals(""String_Node_Str"" + errorMsg + ""String_Node_Str""+ Arrays.toString(compiler.getErrors()),1,compiler.getErrorCount());
    JSError actualError=compiler.getErrors()[0];
    assertEquals(errorMsg,error,actualError.getType());
    validateSourceLocation(actualError);
    if (description != null) {
      assertThat(actualError.description).isEqualTo(description);
    }
    assert_().withFailureMessage(""String_Node_Str"").that(actualError.description).doesNotContainMatch(""String_Node_Str"");
    if (warning != null) {
      String warnings=""String_Node_Str"";
      for (      JSError actualWarning : compiler.getWarnings()) {
        warnings+=actualWarning.description + ""String_Node_Str"";
        assert_().withFailureMessage(""String_Node_Str"").that(actualWarning.description).doesNotContainMatch(""String_Node_Str"");
      }
      assertEquals(""String_Node_Str"" + warnings,1,compiler.getWarningCount());
      assertEquals(warnings,warning,compiler.getWarnings()[0].getType());
    }
  }
}","/** 
 * Verifies that the compiler pass's JS output matches the expected output and (optionally) that an expected warning is issued. Or, if an error is expected, this method just verifies that the error is encountered.
 * @param compiler A compiler that has been initialized via{@link Compiler#init}
 * @param expected Expected output, or null if an error is expected
 * @param error Expected error, or null if no error is expected
 * @param warning Expected warning, or null if no warning is expected
 * @param description The description of the expected warning,or null if no warning is expected or if the warning's description should not be examined
 */
private void test(Compiler compiler,List<SourceFile> expected,DiagnosticType error,DiagnosticType warning,String description){
  RecentChange recentChange=new RecentChange();
  compiler.addChangeHandler(recentChange);
  Node root=compiler.parseInputs();
  String errorMsg=LINE_JOINER.join(compiler.getErrors());
  if (root == null && expected == null && error != null) {
    assert_().withFailureMessage(""String_Node_Str"" + errorMsg).that(compiler.getErrorCount()).isEqualTo(1);
    JSError actualError=compiler.getErrors()[0];
    assert_().withFailureMessage(""String_Node_Str"" + errorMsg).that(actualError.getType()).isEqualTo(error);
    if (description != null) {
      assertThat(actualError.description).isEqualTo(description);
    }
    return;
  }
  assert_().withFailureMessage(""String_Node_Str"" + errorMsg).that(root).isNotNull();
  if (!expectParseWarningsThisTest) {
    assertEquals(""String_Node_Str"" + LINE_JOINER.join(compiler.getWarnings()),0,compiler.getWarnings().length);
  }
  if (astValidationEnabled) {
    (new AstValidator(compiler)).validateRoot(root);
  }
  Node externsRoot=root.getFirstChild();
  Node mainRoot=root.getLastChild();
  Node rootClone=root.cloneTree();
  Node externsRootClone=rootClone.getFirstChild();
  Node mainRootClone=rootClone.getLastChild();
  Map<Node,Node> mtoc=NodeUtil.mapMainToClone(mainRoot,mainRootClone);
  int numRepetitions=getNumRepetitions();
  ErrorManager[] errorManagers=new ErrorManager[numRepetitions];
  int aggregateWarningCount=0;
  List<JSError> aggregateWarnings=new ArrayList<>();
  boolean hasCodeChanged=false;
  for (int i=0; i < numRepetitions; ++i) {
    if (compiler.getErrorCount() == 0) {
      errorManagers[i]=new BlackHoleErrorManager();
      compiler.setErrorManager(errorManagers[i]);
      if (rewriteClosureCode && i == 0) {
        new ClosureRewriteClass(compiler).process(null,mainRoot);
        new ClosureRewriteModule(compiler).process(null,mainRoot);
        new ScopedAliases(compiler,null,CompilerOptions.NULL_ALIAS_TRANSFORMATION_HANDLER).process(null,mainRoot);
        hasCodeChanged=hasCodeChanged || recentChange.hasCodeChanged();
      }
      if (closurePassEnabled && i == 0) {
        recentChange.reset();
        new ProcessClosurePrimitives(compiler,null,CheckLevel.ERROR,false).process(null,mainRoot);
        hasCodeChanged=hasCodeChanged || recentChange.hasCodeChanged();
      }
      if (transpileEnabled && i == 0) {
        recentChange.reset();
        transpileToEs5(compiler,externsRoot,mainRoot);
        hasCodeChanged=hasCodeChanged || recentChange.hasCodeChanged();
      }
      if (!runTypeCheckAfterProcessing && typeCheckEnabled && i == 0) {
        TypeCheck check=createTypeCheck(compiler,reportMissingOverrideCheckLevel);
        check.processForTesting(externsRoot,mainRoot);
      }
 else       if (!this.runNTIAfterProcessing && this.newTypeInferenceEnabled && i == 0) {
        runNewTypeInference(compiler,externsRoot,mainRoot);
      }
      if (normalizeEnabled && i == 0) {
        normalizeActualCode(compiler,externsRoot,mainRoot);
      }
      if (enableInferConsts && i == 0) {
        new InferConsts(compiler).process(externsRoot,mainRoot);
      }
      if (computeSideEffects && i == 0) {
        PureFunctionIdentifier.Driver mark=new PureFunctionIdentifier.Driver(compiler,null,false);
        mark.process(externsRoot,mainRoot);
      }
      if (markNoSideEffects && i == 0) {
        MarkNoSideEffectCalls mark=new MarkNoSideEffectCalls(compiler);
        mark.process(externsRoot,mainRoot);
      }
      if (gatherExternPropertiesEnabled && i == 0) {
        (new GatherExternProperties(compiler)).process(externsRoot,mainRoot);
      }
      recentChange.reset();
      getProcessor(compiler).process(externsRoot,mainRoot);
      if (astValidationEnabled) {
        (new AstValidator(compiler)).validateRoot(root);
      }
      if (checkLineNumbers) {
        (new LineNumberCheck(compiler)).process(externsRoot,mainRoot);
      }
      if (runTypeCheckAfterProcessing && typeCheckEnabled && i == 0) {
        TypeCheck check=createTypeCheck(compiler,reportMissingOverrideCheckLevel);
        check.processForTesting(externsRoot,mainRoot);
      }
 else       if (this.runNTIAfterProcessing && this.newTypeInferenceEnabled && i == 0) {
        runNewTypeInference(compiler,externsRoot,mainRoot);
      }
      hasCodeChanged=hasCodeChanged || recentChange.hasCodeChanged();
      aggregateWarningCount+=errorManagers[i].getWarningCount();
      Collections.addAll(aggregateWarnings,compiler.getWarnings());
      if (normalizeEnabled) {
        boolean verifyDeclaredConstants=true;
        new Normalize.VerifyConstants(compiler,verifyDeclaredConstants).process(externsRoot,mainRoot);
      }
    }
  }
  if (error == null) {
    assertEquals(""String_Node_Str"" + LINE_JOINER.join(compiler.getErrors()),0,compiler.getErrorCount());
    ErrorManager symbolTableErrorManager=new BlackHoleErrorManager();
    compiler.setErrorManager(symbolTableErrorManager);
    Node expectedRoot=null;
    if (expected != null) {
      expectedRoot=parseExpectedJs(expected);
      expectedRoot.detachFromParent();
    }
    JSError[] stErrors=symbolTableErrorManager.getErrors();
    if (expectedSymbolTableError != null) {
      assertEquals(""String_Node_Str"",1,stErrors.length);
      assertThat(stErrors[0].getType()).isEqualTo(expectedSymbolTableError);
    }
 else {
      assertEquals(""String_Node_Str"" + LINE_JOINER.join(stErrors),0,stErrors.length);
    }
    if (warning == null) {
      assertEquals(""String_Node_Str"" + LINE_JOINER.join(aggregateWarnings),0,aggregateWarningCount);
    }
 else {
      assertEquals(""String_Node_Str"" + numRepetitions + ""String_Node_Str""+ LINE_JOINER.join(aggregateWarnings),numRepetitions,aggregateWarningCount);
      for (int i=0; i < numRepetitions; ++i) {
        JSError[] warnings=errorManagers[i].getWarnings();
        JSError actual=warnings[0];
        assertThat(actual.getType()).isEqualTo(warning);
        validateSourceLocation(actual);
        if (description != null) {
          assertThat(actual.description).isEqualTo(description);
        }
      }
    }
    if (normalizeEnabled) {
      normalizeActualCode(compiler,externsRootClone,mainRootClone);
    }
    boolean codeChange=!mainRootClone.isEquivalentTo(mainRoot);
    boolean externsChange=!externsRootClone.isEquivalentTo(externsRoot);
    if (externsChange && !allowExternsChanges) {
      String explanation=externsRootClone.checkTreeEquals(externsRoot);
      fail(""String_Node_Str"" + ""String_Node_Str"" + compiler.toSource(externsRootClone) + ""String_Node_Str""+ compiler.toSource(externsRoot)+ ""String_Node_Str""+ explanation);
    }
    if (!codeChange && !externsChange) {
      assertFalse(""String_Node_Str"" + ""String_Node_Str"",hasCodeChanged);
    }
 else {
      assertTrue(""String_Node_Str"" + ""String_Node_Str"" + mainRootClone.toStringTree() + ""String_Node_Str""+ mainRoot.toStringTree(),hasCodeChanged);
    }
    NodeUtil.verifyScopeChanges(mtoc,mainRoot,false);
    if (expected != null) {
      if (compareAsTree) {
        String explanation;
        if (compareJsDoc) {
          explanation=expectedRoot.checkTreeEqualsIncludingJsDoc(mainRoot);
        }
 else {
          explanation=expectedRoot.checkTreeEquals(mainRoot);
        }
        if (explanation != null) {
          String expectedAsSource=compiler.toSource(expectedRoot);
          String mainAsSource=compiler.toSource(mainRoot);
          if (expectedAsSource.equals(mainAsSource)) {
            fail(""String_Node_Str"" + expectedAsSource + ""String_Node_Str""+ explanation);
          }
 else {
            fail(""String_Node_Str"" + expectedAsSource + ""String_Node_Str""+ mainAsSource+ ""String_Node_Str""+ explanation);
          }
        }
      }
 else       if (expected != null) {
        String[] expectedSources=new String[expected.size()];
        for (int i=0; i < expected.size(); ++i) {
          try {
            expectedSources[i]=expected.get(i).getCode();
          }
 catch (          IOException e) {
            throw new RuntimeException(""String_Node_Str"",e);
          }
        }
        assertThat(compiler.toSource(mainRoot)).isEqualTo(Joiner.on(""String_Node_Str"").join(expectedSources));
      }
    }
    Node normalizeCheckRootClone=root.cloneTree();
    Node normalizeCheckExternsRootClone=normalizeCheckRootClone.getFirstChild();
    Node normalizeCheckMainRootClone=normalizeCheckRootClone.getLastChild();
    new PrepareAst(compiler).process(normalizeCheckExternsRootClone,normalizeCheckMainRootClone);
    String explanation=normalizeCheckMainRootClone.checkTreeEquals(mainRoot);
    assertNull(""String_Node_Str"" + ""String_Node_Str"" + compiler.toSource(normalizeCheckMainRootClone) + ""String_Node_Str""+ compiler.toSource(mainRoot)+ ""String_Node_Str""+ explanation,explanation);
    if (normalizeEnabled) {
      new Normalize(compiler,true).process(normalizeCheckExternsRootClone,normalizeCheckMainRootClone);
      explanation=normalizeCheckMainRootClone.checkTreeEquals(mainRoot);
      assertNull(""String_Node_Str"" + ""String_Node_Str"" + compiler.toSource(normalizeCheckMainRootClone) + ""String_Node_Str""+ compiler.toSource(mainRoot)+ ""String_Node_Str""+ explanation,explanation);
    }
  }
 else {
    assertNull(""String_Node_Str"",expected);
    assertEquals(""String_Node_Str"" + error.key + ""String_Node_Str""+ Arrays.toString(compiler.getErrors()),1,compiler.getErrorCount());
    JSError actualError=compiler.getErrors()[0];
    assertEquals(errorMsg,error,actualError.getType());
    validateSourceLocation(actualError);
    if (description != null) {
      assertThat(actualError.description).isEqualTo(description);
    }
    assert_().withFailureMessage(""String_Node_Str"").that(actualError.description).doesNotContainMatch(""String_Node_Str"");
    if (warning != null) {
      String warnings=""String_Node_Str"";
      for (      JSError actualWarning : compiler.getWarnings()) {
        warnings+=actualWarning.description + ""String_Node_Str"";
        assert_().withFailureMessage(""String_Node_Str"").that(actualWarning.description).doesNotContainMatch(""String_Node_Str"");
      }
      assertEquals(""String_Node_Str"" + warnings,1,compiler.getWarningCount());
      assertEquals(warnings,warning,compiler.getWarnings()[0].getType());
    }
  }
}",0.9996811660214074
27411,"/** 
 * If the variable is declared more than once in a basic block, generate a warning. Also check if a variable is used in a given scope before it is declared, which suggest a likely error. Relies on the fact that references is in parse-tree order.
 */
private void checkVar(Var v,List<Reference> references){
  blocksWithDeclarations.clear();
  boolean isDeclaredInScope=false;
  boolean isUnhoistedNamedFunction=false;
  boolean hasErrors=false;
  boolean isRead=false;
  Reference hoistedFn=null;
  Reference unusedAssignment=null;
  for (  Reference reference : references) {
    if (reference.isHoistedFunction()) {
      blocksWithDeclarations.add(reference.getBasicBlock());
      isDeclaredInScope=true;
      hoistedFn=reference;
      break;
    }
 else     if (NodeUtil.isFunctionDeclaration(reference.getNode().getParent())) {
      isUnhoistedNamedFunction=true;
    }
  }
  for (  Reference reference : references) {
    if (reference == hoistedFn) {
      continue;
    }
    BasicBlock basicBlock=reference.getBasicBlock();
    boolean isDeclaration=reference.isDeclaration();
    Node referenceNode=reference.getNode();
    boolean isAssignment=isDeclaration || reference.isLvalue();
    boolean allowDupe=VarCheck.hasDuplicateDeclarationSuppression(referenceNode,v);
    boolean letConstShadowsVar=v.getParentNode().isVar() && (reference.isLetDeclaration() || reference.isConstDeclaration());
    boolean isVarNodeSameAsReferenceNode=v.getNode() == reference.getNode();
    boolean shadowCatchVar=isDeclaration && compiler.getLanguageMode().isEs6OrHigher() && v.getParentNode().isCatch()&& !isVarNodeSameAsReferenceNode;
    boolean shadowParam=isDeclaration && v.isParam() && NodeUtil.isBlockScopedDeclaration(referenceNode)&& v.getScope() == reference.getScope().getParent();
    boolean shadowDetected=false;
    if (isDeclaration && !allowDupe) {
      for (      BasicBlock declaredBlock : blocksWithDeclarations) {
        if (declaredBlock.provablyExecutesBefore(basicBlock)) {
          shadowDetected=true;
          DiagnosticType diagnosticType;
          Node warningNode=referenceNode;
          if (v.isLet() || v.isConst() || v.isClass()|| letConstShadowsVar|| shadowCatchVar|| shadowParam) {
            diagnosticType=REDECLARED_VARIABLE_ERROR;
          }
 else           if (reference.getNode().getParent().isCatch() || allowDupe) {
            return;
          }
 else {
            diagnosticType=v.getScope().isGlobal() ? VarCheck.VAR_MULTIPLY_DECLARED_ERROR : REDECLARED_VARIABLE;
            if (isVarNodeSameAsReferenceNode && hoistedFn != null && v.name.equals(hoistedFn.getNode().getString())) {
              warningNode=hoistedFn.getNode();
            }
          }
          compiler.report(JSError.make(warningNode,diagnosticType,v.name,v.input != null ? v.input.getName() : ""String_Node_Str""));
          hasErrors=true;
          break;
        }
      }
    }
    if (!shadowDetected && isDeclaration && (letConstShadowsVar || shadowCatchVar)&& v.getScope() == reference.getScope()) {
      compiler.report(JSError.make(referenceNode,REDECLARED_VARIABLE_ERROR,v.name));
    }
    if (isAssignment) {
      Reference decl=references.get(0);
      Node declNode=decl.getNode();
      boolean lhsOfForInLoop=(NodeUtil.isForIn(declNode.getParent()) && declNode == declNode.getParent().getFirstChild()) || (NodeUtil.isForIn(declNode.getGrandparent()) && declNode.getParent().getParent().getFirstChild().getFirstChild() == declNode);
      if (decl.getScope().isLocal() && (decl.isVarDeclaration() || decl.isLetDeclaration() || decl.isConstDeclaration()) && !decl.getNode().isFromExterns()&& !lhsOfForInLoop) {
        unusedAssignment=reference;
      }
      if ((reference.getParent().isDec() || reference.getParent().isInc()) && NodeUtil.isExpressionResultUsed(reference.getNode())) {
        isRead=true;
      }
    }
 else {
      isRead=true;
    }
    if (isUnhoistedNamedFunction && !isDeclaration && isDeclaredInScope) {
      for (      BasicBlock declaredBlock : blocksWithDeclarations) {
        if (!declaredBlock.provablyExecutesBefore(basicBlock)) {
          compiler.report(JSError.make(referenceNode,AMBIGUOUS_FUNCTION_DECL,v.name));
          hasErrors=true;
          break;
        }
      }
    }
    boolean isUndeclaredReference=false;
    if (!isDeclaration && !isDeclaredInScope) {
      if (!referenceNode.isFromExterns()) {
        Node grandparent=reference.getGrandparent();
        if ((v.isVar() && grandparent.isName() && grandparent.getString().equals(v.name))) {
          continue;
        }
        if (reference.getScope() == v.scope && !v.getName().equals(""String_Node_Str"")) {
          isUndeclaredReference=true;
          compiler.report(JSError.make(reference.getNode(),(v.isLet() || v.isConst() || v.isClass()|| v.isParam()) ? EARLY_REFERENCE_ERROR : EARLY_REFERENCE,v.name));
          hasErrors=true;
        }
      }
    }
    if (!isDeclaration && !isUndeclaredReference && v.isConst()&& reference.isLvalue()) {
      compiler.report(JSError.make(referenceNode,REASSIGNED_CONSTANT,v.name));
    }
    if (isDeclaration && !reference.isVarDeclaration() && reference.getGrandparent().isAddedBlock()) {
      compiler.report(JSError.make(referenceNode,DECLARATION_NOT_DIRECTLY_IN_BLOCK,v.name));
    }
    if (isDeclaration) {
      blocksWithDeclarations.add(basicBlock);
      isDeclaredInScope=true;
    }
  }
  if (unusedAssignment != null && !isRead && !hasErrors) {
    boolean inGoogScope=false;
    Scope s=v.getScope();
    Node function=null;
    if (s.isFunctionBlockScope()) {
      function=s.getRootNode().getParent();
    }
 else     if (s.isFunctionScope()) {
      function=s.getRootNode();
    }
    if (function != null) {
      Node callee=function.getParent().getChildBefore(function);
      inGoogScope=callee != null && callee.matchesQualifiedName(""String_Node_Str"");
    }
    if (!inGoogScope) {
      compiler.report(JSError.make(unusedAssignment.getNode(),UNUSED_LOCAL_ASSIGNMENT,v.name));
    }
  }
}","/** 
 * If the variable is declared more than once in a basic block, generate a warning. Also check if a variable is used in a given scope before it is declared, which suggest a likely error. Relies on the fact that references is in parse-tree order.
 */
private void checkVar(Var v,List<Reference> references){
  blocksWithDeclarations.clear();
  boolean isDeclaredInScope=false;
  boolean isUnhoistedNamedFunction=false;
  boolean hasErrors=false;
  boolean isRead=false;
  Reference hoistedFn=null;
  Reference unusedAssignment=null;
  for (  Reference reference : references) {
    if (reference.isHoistedFunction()) {
      blocksWithDeclarations.add(reference.getBasicBlock());
      isDeclaredInScope=true;
      hoistedFn=reference;
      break;
    }
 else     if (NodeUtil.isFunctionDeclaration(reference.getNode().getParent())) {
      isUnhoistedNamedFunction=true;
    }
  }
  for (  Reference reference : references) {
    if (reference == hoistedFn) {
      continue;
    }
    BasicBlock basicBlock=reference.getBasicBlock();
    boolean isDeclaration=reference.isDeclaration();
    Node referenceNode=reference.getNode();
    boolean isAssignment=isDeclaration || reference.isLvalue();
    boolean allowDupe=VarCheck.hasDuplicateDeclarationSuppression(referenceNode,v);
    boolean letConstShadowsVar=v.getParentNode().isVar() && (reference.isLetDeclaration() || reference.isConstDeclaration());
    boolean isVarNodeSameAsReferenceNode=v.getNode() == reference.getNode();
    boolean shadowCatchVar=isDeclaration && compiler.getLanguageMode().isEs6OrHigher() && v.getParentNode().isCatch()&& !isVarNodeSameAsReferenceNode;
    boolean shadowParam=isDeclaration && v.isParam() && NodeUtil.isBlockScopedDeclaration(referenceNode)&& v.getScope() == reference.getScope().getParent();
    boolean shadowDetected=false;
    if (isDeclaration && !allowDupe) {
      for (      BasicBlock declaredBlock : blocksWithDeclarations) {
        if (declaredBlock.provablyExecutesBefore(basicBlock)) {
          shadowDetected=true;
          DiagnosticType diagnosticType;
          Node warningNode=referenceNode;
          if (v.isLet() || v.isConst() || v.isClass()|| letConstShadowsVar|| shadowCatchVar|| shadowParam) {
            diagnosticType=REDECLARED_VARIABLE_ERROR;
          }
 else           if (reference.getNode().getParent().isCatch() || allowDupe) {
            return;
          }
 else {
            diagnosticType=v.getScope().isGlobal() ? VarCheck.VAR_MULTIPLY_DECLARED_ERROR : REDECLARED_VARIABLE;
            if (isVarNodeSameAsReferenceNode && hoistedFn != null && v.name.equals(hoistedFn.getNode().getString())) {
              warningNode=hoistedFn.getNode();
            }
          }
          compiler.report(JSError.make(warningNode,diagnosticType,v.name,v.input != null ? v.input.getName() : ""String_Node_Str""));
          hasErrors=true;
          break;
        }
      }
    }
    if (!shadowDetected && isDeclaration && (letConstShadowsVar || shadowCatchVar)&& v.getScope() == reference.getScope()) {
      compiler.report(JSError.make(referenceNode,REDECLARED_VARIABLE_ERROR,v.name));
    }
    if (isAssignment) {
      Reference decl=references.get(0);
      Node declNode=decl.getNode();
      Node gp=declNode.getGrandparent();
      boolean lhsOfForInLoop=NodeUtil.isForIn(gp) && gp.getFirstFirstChild() == declNode;
      if (decl.getScope().isLocal() && (decl.isVarDeclaration() || decl.isLetDeclaration() || decl.isConstDeclaration()) && !decl.getNode().isFromExterns()&& !lhsOfForInLoop) {
        unusedAssignment=reference;
      }
      if ((reference.getParent().isDec() || reference.getParent().isInc()) && NodeUtil.isExpressionResultUsed(reference.getNode())) {
        isRead=true;
      }
    }
 else {
      isRead=true;
    }
    if (isUnhoistedNamedFunction && !isDeclaration && isDeclaredInScope) {
      for (      BasicBlock declaredBlock : blocksWithDeclarations) {
        if (!declaredBlock.provablyExecutesBefore(basicBlock)) {
          compiler.report(JSError.make(referenceNode,AMBIGUOUS_FUNCTION_DECL,v.name));
          hasErrors=true;
          break;
        }
      }
    }
    boolean isUndeclaredReference=false;
    if (!isDeclaration && !isDeclaredInScope) {
      if (!referenceNode.isFromExterns()) {
        Node grandparent=reference.getGrandparent();
        if ((v.isVar() && grandparent.isName() && grandparent.getString().equals(v.name))) {
          continue;
        }
        if (reference.getScope() == v.scope && !v.getName().equals(""String_Node_Str"")) {
          isUndeclaredReference=true;
          compiler.report(JSError.make(reference.getNode(),(v.isLet() || v.isConst() || v.isClass()|| v.isParam()) ? EARLY_REFERENCE_ERROR : EARLY_REFERENCE,v.name));
          hasErrors=true;
        }
      }
    }
    if (!isDeclaration && !isUndeclaredReference && v.isConst()&& reference.isLvalue()) {
      compiler.report(JSError.make(referenceNode,REASSIGNED_CONSTANT,v.name));
    }
    if (isDeclaration && !reference.isVarDeclaration() && reference.getGrandparent().isAddedBlock()) {
      compiler.report(JSError.make(referenceNode,DECLARATION_NOT_DIRECTLY_IN_BLOCK,v.name));
    }
    if (isDeclaration) {
      blocksWithDeclarations.add(basicBlock);
      isDeclaredInScope=true;
    }
  }
  if (unusedAssignment != null && !isRead && !hasErrors) {
    boolean inGoogScope=false;
    Scope s=v.getScope();
    Node function=null;
    if (s.isFunctionBlockScope()) {
      function=s.getRootNode().getParent();
    }
 else     if (s.isFunctionScope()) {
      function=s.getRootNode();
    }
    if (function != null) {
      Node callee=function.getParent().getChildBefore(function);
      inGoogScope=callee != null && callee.matchesQualifiedName(""String_Node_Str"");
    }
    if (!inGoogScope) {
      compiler.report(JSError.make(unusedAssignment.getNode(),UNUSED_LOCAL_ASSIGNMENT,v.name));
    }
  }
}",0.9781278806670576
27412,"public void testForIn(){
  enableUnusedLocalAssignmentCheck=true;
  assertNoWarning(""String_Node_Str"");
}","public void testForIn(){
  enableUnusedLocalAssignmentCheck=true;
  assertNoWarning(""String_Node_Str"");
  assertNoWarning(""String_Node_Str"");
  assertNoWarning(""String_Node_Str"");
}",0.7342657342657343
27413,"@Override public void visit(NodeTraversal t,Node n,Node parent){
switch (n.getType()) {
case Token.CALL:
    Node callee=n.getFirstChild();
  if (callee.matchesQualifiedName(""String_Node_Str"")) {
    if (currentModuleName == null) {
      currentModuleName=extractFirstArgumentName(n);
    }
 else {
      t.report(n,MULTIPLE_MODULES_IN_FILE);
    }
  }
 else   if (callee.matchesQualifiedName(""String_Node_Str"")) {
    t.report(n,MODULE_AND_PROVIDES);
  }
 else   if (callee.matchesQualifiedName(""String_Node_Str"")) {
    checkRequireCall(t,n,parent);
  }
break;
case Token.THIS:
if (t.inGlobalHoistScope()) {
t.report(n,GOOG_MODULE_REFERENCES_THIS);
}
break;
case Token.THROW:
if (t.inGlobalHoistScope()) {
t.report(n,GOOG_MODULE_USES_THROW);
}
break;
case Token.GETPROP:
if (currentModuleName != null && n.matchesQualifiedName(currentModuleName)) {
t.report(n,REFERENCE_TO_MODULE_GLOBAL_NAME);
}
 else if (shortRequiredNamespaces.contains(n.getQualifiedName())) {
t.report(n,REFERENCE_TO_SHORT_IMPORT_BY_LONG_NAME);
}
break;
case Token.SCRIPT:
currentModuleName=null;
shortRequiredNamespaces.clear();
break;
}
}","@Override public void visit(NodeTraversal t,Node n,Node parent){
switch (n.getType()) {
case Token.CALL:
    Node callee=n.getFirstChild();
  if (callee.matchesQualifiedName(""String_Node_Str"")) {
    if (currentModuleName == null) {
      currentModuleName=extractFirstArgumentName(n);
    }
 else {
      t.report(n,MULTIPLE_MODULES_IN_FILE);
    }
  }
 else   if (callee.matchesQualifiedName(""String_Node_Str"")) {
    t.report(n,MODULE_AND_PROVIDES);
  }
 else   if (callee.matchesQualifiedName(""String_Node_Str"")) {
    checkRequireCall(t,n,parent);
  }
break;
case Token.THIS:
if (t.inGlobalHoistScope()) {
t.report(n,GOOG_MODULE_REFERENCES_THIS);
}
break;
case Token.THROW:
if (t.inGlobalHoistScope()) {
t.report(n,GOOG_MODULE_USES_THROW);
}
break;
case Token.GETPROP:
if (currentModuleName != null && n.matchesQualifiedName(currentModuleName)) {
t.report(n,REFERENCE_TO_MODULE_GLOBAL_NAME);
}
 else if (shortRequiredNamespaces.contains(n.getQualifiedName())) {
t.report(n,REFERENCE_TO_SHORT_IMPORT_BY_LONG_NAME,n.getQualifiedName());
}
break;
case Token.SCRIPT:
currentModuleName=null;
shortRequiredNamespaces.clear();
break;
}
}",0.9906625166740772
27414,"public void testTestTypes(){
  try {
    testTypes(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  AssertionError expected) {
  }
}","public void testTestTypes(){
  try {
    testTypes(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    throw new Error(""String_Node_Str"");
  }
 catch (  AssertionError expected) {
  }
}",0.6682577565632458
27415,"private static void lint(Path path,boolean fix) throws IOException {
  SourceFile file=SourceFile.fromFile(path.toString());
  Compiler compiler=new Compiler(System.out);
  CompilerOptions options=new CompilerOptions();
  options.setLanguage(LanguageMode.ECMASCRIPT6_STRICT);
  options.setSkipTranspilationAndCrash(true);
  options.setIdeMode(true);
  options.setCodingConvention(new GoogleCodingConvention());
  options.setWarningLevel(DiagnosticGroups.CHECK_TYPES,CheckLevel.WARNING);
  options.setWarningLevel(DiagnosticGroups.LINT_CHECKS,CheckLevel.WARNING);
  options.setWarningLevel(DiagnosticGroups.MISSING_REQUIRE,CheckLevel.WARNING);
  options.setWarningLevel(DiagnosticGroups.EXTRA_REQUIRE,CheckLevel.WARNING);
  compiler.setPassConfig(new LintPassConfig(options));
  compiler.disableThreads();
  SourceFile externs=SourceFile.fromCode(""String_Node_Str"",""String_Node_Str"");
  compiler.compile(ImmutableList.<SourceFile>of(externs),ImmutableList.of(file),options);
  if (fix) {
    List<SuggestedFix> fixes=new ArrayList<>();
    for (    JSError warning : compiler.getWarnings()) {
      SuggestedFix suggestedFix=ErrorToFixMapper.getFixForJsError(warning,compiler);
      if (suggestedFix != null) {
        fixes.add(suggestedFix);
      }
    }
    ApplySuggestedFixes.applySuggestedFixesToFiles(fixes);
  }
}","private static void lint(Path path,boolean fix) throws IOException {
  SourceFile file=SourceFile.fromFile(path.toString());
  Compiler compiler=new Compiler(System.out);
  CompilerOptions options=new CompilerOptions();
  options.setLanguage(LanguageMode.ECMASCRIPT6_STRICT);
  options.setSkipTranspilationAndCrash(true);
  options.setIdeMode(true);
  options.setCodingConvention(new GoogleCodingConvention());
  options.setWarningLevel(DiagnosticGroups.CHECK_TYPES,CheckLevel.WARNING);
  options.setWarningLevel(DiagnosticGroups.LINT_CHECKS,CheckLevel.WARNING);
  options.setWarningLevel(DiagnosticGroups.MISSING_REQUIRE,CheckLevel.WARNING);
  options.setWarningLevel(DiagnosticGroups.EXTRA_REQUIRE,CheckLevel.WARNING);
  compiler.setPassConfig(new LintPassConfig(options));
  compiler.disableThreads();
  SourceFile externs=SourceFile.fromCode(""String_Node_Str"",""String_Node_Str"");
  compiler.compile(ImmutableList.<SourceFile>of(externs),ImmutableList.of(file),options);
  if (fix) {
    List<SuggestedFix> fixes=new ArrayList<>();
    for (    JSError warning : concat(compiler.getErrors(),compiler.getWarnings(),JSError.class)) {
      SuggestedFix suggestedFix=ErrorToFixMapper.getFixForJsError(warning,compiler);
      if (suggestedFix != null) {
        fixes.add(suggestedFix);
      }
    }
    ApplySuggestedFixes.applySuggestedFixesToFiles(fixes);
  }
}",0.983997022701898
27416,"@Override public JSType caseTemplateType(TemplateType type){
  if (replacements.hasTemplateKey(type)) {
    if (hasVisitedType(type) || !replacements.hasTemplateType(type)) {
      return type;
    }
 else {
      JSType replacement=replacements.getUnresolvedOriginalTemplateType(type);
      JSType restrictedReplacement=replacement.restrictByNotNullOrUndefined();
      if (restrictedReplacement.isTemplatizedType() && restrictedReplacement.toMaybeTemplatizedType().getTemplateTypes().contains(type)) {
        return type;
      }
      visitedTypes.push(type);
      JSType visitedReplacement=replacement.visit(this);
      visitedTypes.pop();
      return visitedReplacement;
    }
  }
 else {
    return type;
  }
}","@Override public JSType caseTemplateType(TemplateType type){
  if (replacements.hasTemplateKey(type)) {
    if (hasVisitedType(type) || !replacements.hasTemplateType(type)) {
      return type;
    }
 else {
      JSType replacement=replacements.getUnresolvedOriginalTemplateType(type);
      JSType restrictedReplacement=replacement.restrictByNotNullOrUndefined();
      if (restrictedReplacement.isTemplatizedType()) {
        Iterable<JSType> replacementTemplateTypes=restrictedReplacement.toMaybeTemplatizedType().getTemplateTypes();
        for (        JSType replacementTemplateType : replacementTemplateTypes) {
          if (!replacementTemplateType.differsFrom(type)) {
            return type;
          }
        }
      }
      visitedTypes.push(type);
      JSType visitedReplacement=replacement.visit(this);
      visitedTypes.pop();
      return visitedReplacement;
    }
  }
 else {
    return type;
  }
}",0.7778454047474133
27417,"@Override public JSType caseTemplateType(TemplateType type){
  if (replacements.hasTemplateKey(type)) {
    if (hasVisitedType(type) || !replacements.hasTemplateType(type)) {
      return type;
    }
 else {
      JSType replacement=replacements.getUnresolvedOriginalTemplateType(type);
      visitedTypes.push(type);
      JSType visitedReplacement=replacement.visit(this);
      visitedTypes.pop();
      return visitedReplacement;
    }
  }
 else {
    return type;
  }
}","@Override public JSType caseTemplateType(TemplateType type){
  if (replacements.hasTemplateKey(type)) {
    if (hasVisitedType(type) || !replacements.hasTemplateType(type)) {
      return type;
    }
 else {
      JSType replacement=replacements.getUnresolvedOriginalTemplateType(type);
      JSType restrictedReplacement=replacement.restrictByNotNullOrUndefined();
      if (restrictedReplacement.isTemplatizedType() && restrictedReplacement.toMaybeTemplatizedType().getTemplateTypes().contains(type)) {
        return type;
      }
      visitedTypes.push(type);
      JSType visitedReplacement=replacement.visit(this);
      visitedTypes.pop();
      return visitedReplacement;
    }
  }
 else {
    return type;
  }
}",0.7414225941422594
27418,"private FlagEntry<JsSourceType> createJsFile(String filename,String fileContent) throws IOException {
  File tempJsFile=File.createTempFile(filename,""String_Node_Str"",Files.createTempDirectory(""String_Node_Str"").toFile());
  try (FileOutputStream fileOutputStream=new FileOutputStream(tempJsFile)){
    fileOutputStream.write(fileContent.getBytes(java.nio.charset.StandardCharsets.UTF_8));
  }
   return new FlagEntry<>(JsSourceType.JS,tempJsFile.getAbsolutePath());
}","private FlagEntry<JsSourceType> createJsFile(String filename,String fileContent) throws IOException {
  File tempJsFile=File.createTempFile(filename,""String_Node_Str"",java.nio.file.Files.createTempDirectory(""String_Node_Str"").toFile());
  try (FileOutputStream fileOutputStream=new FileOutputStream(tempJsFile)){
    fileOutputStream.write(fileContent.getBytes(java.nio.charset.StandardCharsets.UTF_8));
  }
   return new FlagEntry<>(JsSourceType.JS,tempJsFile.getAbsolutePath());
}",0.9852631578947368
27419,"public void testGlobJs2() throws IOException, FlagUsageException {
  FlagEntry<JsSourceType> jsFile1=createJsFile(""String_Node_Str"",""String_Node_Str"");
  FlagEntry<JsSourceType> jsFile2=createJsFile(""String_Node_Str"",""String_Node_Str"");
  new File(jsFile2.value).renameTo(new File(new File(jsFile1.value).getParentFile() + File.separator + ""String_Node_Str""));
  String glob=new File(jsFile1.value).getParent() + File.separator + ""String_Node_Str"";
  compileFiles(""String_Node_Str"",new FlagEntry<>(JsSourceType.JS,glob));
}","public void testGlobJs2() throws IOException {
  try {
    FlagEntry<JsSourceType> jsFile1=createJsFile(""String_Node_Str"",""String_Node_Str"");
    FlagEntry<JsSourceType> jsFile2=createJsFile(""String_Node_Str"",""String_Node_Str"");
    new File(jsFile2.value).renameTo(new File(new File(jsFile1.value).getParentFile() + File.separator + ""String_Node_Str""));
    String glob=new File(jsFile1.value).getParent() + File.separator + ""String_Node_Str"";
    compileFiles(""String_Node_Str"",new FlagEntry<>(JsSourceType.JS,glob));
  }
 catch (  FlagUsageException e) {
    fail(""String_Node_Str"" + e);
  }
}",0.1340482573726541
27420,"private static FlagEntry<JsSourceType> createZipFile(Map<String,String> entryContentsByName) throws IOException {
  File tempZipFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"",Files.createTempDirectory(""String_Node_Str"").toFile());
  try (ZipOutputStream zipOutputStream=new ZipOutputStream(new FileOutputStream(tempZipFile))){
    for (    Entry<String,String> entry : entryContentsByName.entrySet()) {
      zipOutputStream.putNextEntry(new ZipEntry(entry.getKey()));
      zipOutputStream.write(entry.getValue().getBytes(java.nio.charset.StandardCharsets.UTF_8));
    }
  }
   return new FlagEntry<>(JsSourceType.JS_ZIP,tempZipFile.getAbsolutePath());
}","private static FlagEntry<JsSourceType> createZipFile(Map<String,String> entryContentsByName) throws IOException {
  File tempZipFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"",java.nio.file.Files.createTempDirectory(""String_Node_Str"").toFile());
  try (ZipOutputStream zipOutputStream=new ZipOutputStream(new FileOutputStream(tempZipFile))){
    for (    Entry<String,String> entry : entryContentsByName.entrySet()) {
      zipOutputStream.putNextEntry(new ZipEntry(entry.getKey()));
      zipOutputStream.write(entry.getValue().getBytes(java.nio.charset.StandardCharsets.UTF_8));
    }
  }
   return new FlagEntry<>(JsSourceType.JS_ZIP,tempZipFile.getAbsolutePath());
}",0.9896449704142012
27421,"public static JSType plus(JSType lhs,JSType rhs){
  if (lhs.equals(STRING) || rhs.equals(STRING)) {
    return STRING;
  }
  if (lhs.isUnknown() || lhs.isTop() || rhs.isUnknown()|| rhs.isTop()) {
    return UNKNOWN;
  }
  int newtype=(lhs.getMask() | rhs.getMask()) & STRING_MASK;
  if ((lhs.getMask() & ~STRING_MASK) != 0 && (rhs.getMask() & ~STRING_MASK) != 0) {
    newtype|=NUMBER_MASK;
  }
  return makeType(newtype);
}","public static JSType plus(JSType lhs,JSType rhs){
  if (!lhs.isUnknown() && !lhs.isBottom() && lhs.isSubtypeOf(STRING) || !rhs.isUnknown() && !rhs.isBottom() && rhs.isSubtypeOf(STRING)) {
    return STRING;
  }
  if (lhs.isUnknown() || lhs.isTop() || rhs.isUnknown()|| rhs.isTop()) {
    return UNKNOWN;
  }
  int newtype=(lhs.getMask() | rhs.getMask()) & STRING_MASK;
  if ((lhs.getMask() & ~STRING_MASK) != 0 && (rhs.getMask() & ~STRING_MASK) != 0) {
    newtype|=NUMBER_MASK;
  }
  return makeType(newtype);
}",0.8632478632478633
27422,"public void testEnumBasicTyping(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INEXISTENT_PROPERTY);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
}","public void testEnumBasicTyping(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INEXISTENT_PROPERTY);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.9660615627466456
27423,"private ImmutableMap<String,JSType> calcTypeInstantiation(Node callNode,Node receiver,Node firstArg,FunctionType funType,TypeEnv typeEnv,boolean isFwd){
  Preconditions.checkState(receiver == null || isFwd);
  List<String> typeParameters=funType.getTypeParameters();
  Multimap<String,JSType> typeMultimap=LinkedHashMultimap.create();
  JSType funRecvType=funType.getThisType();
  if (receiver != null && funRecvType != null && !funRecvType.isSingletonObj()) {
    EnvTypePair pair=analyzeExprFwd(receiver,typeEnv);
    unifyWithSubtypeWarnIfFail(funRecvType,pair.type,typeParameters,typeMultimap,receiver,isFwd);
    typeEnv=pair.env;
  }
  Node arg=firstArg;
  int i=0;
  while (arg != null) {
    EnvTypePair pair=isFwd ? analyzeExprFwd(arg,typeEnv) : analyzeExprBwd(arg,typeEnv);
    unifyWithSubtypeWarnIfFail(funType.getFormalType(i),pair.type,typeParameters,typeMultimap,arg,isFwd);
    arg=arg.getNext();
    typeEnv=pair.env;
    i++;
  }
  ImmutableMap.Builder<String,JSType> builder=ImmutableMap.builder();
  for (  String typeParam : typeParameters) {
    Collection<JSType> types=typeMultimap.get(typeParam);
    if (types.size() > 1) {
      if (isFwd) {
        warnings.add(JSError.make(callNode,NOT_UNIQUE_INSTANTIATION,funType.toString(),typeParam,types.toString()));
      }
      builder.put(typeParam,JSType.UNKNOWN);
    }
 else     if (types.size() == 1) {
      JSType t=Iterables.getOnlyElement(types);
      builder.put(typeParam,t.isBottom() ? JSType.UNKNOWN : t);
    }
 else {
      builder.put(typeParam,JSType.UNKNOWN);
    }
  }
  return builder.build();
}","/** 
 * We don't use the requiredType of the context to unify with the return type. There are several difficulties: 1) A polymorphic function is allowed to return ANY subtype of the requiredType, so we would need to use a heuristic to determine the type to unify with. 2) It's hard to give good error messages in cases like: id('str') - 5 We want an invalid-operand-type, not a not-unique-instantiation. We don't take the arg evaluation order into account during instantiation. When calculating the instantiation, when do we use the receiver type? See the following snippet: / * @constructor * @template T * @param {T} x * / function Foo(x) {} / * @template T * @param {T} x * / Foo.prototype.f = function(x) {}; Foo.prototype.f.bind(new Foo(123), 'asdf'); Here, the receiver type of f is Foo<T>, but the T is the class's T, not the T of f's template declaration. OTOH, if f had a @this annotation that contained T, T would refer to f's T. There is no way of knowing what's the scope of the type variables in the receiver of the function type. But when THIS comes from the class, it is always a singleton object. So, we use a heuristic: if THIS is not a singleton obj, we know it comes from and we use it for the instantiation.
 */
private ImmutableMap<String,JSType> calcTypeInstantiation(Node callNode,Node receiver,Node firstArg,FunctionType funType,TypeEnv typeEnv,boolean isFwd){
  Preconditions.checkState(receiver == null || isFwd);
  List<String> typeParameters=funType.getTypeParameters();
  Multimap<String,JSType> typeMultimap=LinkedHashMultimap.create();
  JSType funRecvType=funType.getThisType();
  if (receiver != null && funRecvType != null && !funRecvType.isSingletonObj()) {
    EnvTypePair pair=analyzeExprFwd(receiver,typeEnv);
    unifyWithSubtypeWarnIfFail(funRecvType,pair.type,typeParameters,typeMultimap,receiver,isFwd);
    typeEnv=pair.env;
  }
  Node arg=firstArg;
  int i=0;
  while (arg != null) {
    EnvTypePair pair=isFwd ? analyzeExprFwd(arg,typeEnv) : analyzeExprBwd(arg,typeEnv);
    unifyWithSubtypeWarnIfFail(funType.getFormalType(i),pair.type,typeParameters,typeMultimap,arg,isFwd);
    arg=arg.getNext();
    typeEnv=pair.env;
    i++;
  }
  ImmutableMap.Builder<String,JSType> builder=ImmutableMap.builder();
  for (  String typeParam : typeParameters) {
    Collection<JSType> types=typeMultimap.get(typeParam);
    if (types.size() > 1) {
      if (isFwd) {
        warnings.add(JSError.make(callNode,NOT_UNIQUE_INSTANTIATION,funType.toString(),typeParam,types.toString()));
      }
      builder.put(typeParam,JSType.UNKNOWN);
    }
 else     if (types.size() == 1) {
      JSType t=Iterables.getOnlyElement(types);
      builder.put(typeParam,t.isBottom() ? JSType.UNKNOWN : t);
    }
 else {
      builder.put(typeParam,JSType.UNKNOWN);
    }
  }
  return builder.build();
}",0.720508166969147
27424,"@Override public boolean isSubtypeOf(TypeI other){
  JSType type2=(JSType)other;
  if (isLoose() || type2.isLoose()) {
    return autobox().isSubtypeOfHelper(true,type2.autobox());
  }
 else {
    return isSubtypeOfHelper(true,type2);
  }
}","@Override public boolean isSubtypeOf(TypeI other){
  if (this == other) {
    return true;
  }
  JSType type2=(JSType)other;
  if (isLoose() || type2.isLoose()) {
    return autobox().isSubtypeOfHelper(true,type2.autobox());
  }
 else {
    return isSubtypeOfHelper(true,type2);
  }
}",0.916030534351145
27425,"private boolean isInvariantWith(Multimap<String,JSType> typeMultimap,NominalType other){
  Preconditions.checkState(isGeneric());
  Preconditions.checkState(this.rawType == other.rawType);
  Map<String,JSType> newTypeMap=new LinkedHashMap<>();
  for (  String typeVar : typeMultimap.keySet()) {
    Collection<JSType> c=typeMultimap.get(typeVar);
    if (c.size() != 1) {
      return false;
    }
    newTypeMap.put(typeVar,Preconditions.checkNotNull(Iterables.getOnlyElement(c)));
  }
  NominalType instantiated=instantiateGenerics(newTypeMap);
  return Objects.equals(instantiated.typeMap,other.typeMap);
}","private boolean isInvariantWith(Multimap<String,JSType> typeMultimap,NominalType other){
  Preconditions.checkState(isGeneric());
  Preconditions.checkState(this.rawType == other.rawType);
  Map<String,JSType> newTypeMap=new LinkedHashMap<>();
  for (  String typeVar : typeMultimap.keySet()) {
    Collection<JSType> c=typeMultimap.get(typeVar);
    if (c.size() != 1) {
      return false;
    }
    newTypeMap.put(typeVar,Preconditions.checkNotNull(Iterables.getOnlyElement(c)));
  }
  NominalType instantiated=instantiateGenerics(newTypeMap);
  Map<String,JSType> otherMap=other.typeMap;
  for (  Map.Entry<String,JSType> entry : instantiated.typeMap.entrySet()) {
    JSType t1=entry.getValue();
    JSType t2=otherMap.get(entry.getKey());
    if (!t1.isSubtypeOf(t2) || !t2.isSubtypeOf(t1)) {
      return false;
    }
  }
  return true;
}",0.7592847317744154
27426,"public void testDifficultClassGenericsInstantiation(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.RETURN_NONDECLARED_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testDifficultClassGenericsInstantiation(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.RETURN_NONDECLARED_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.8665554628857381
27427,"/** 
 * Creates inputs from a list of source files, zips and json files. Can be overridden by subclasses who want to pull files from different places.
 * @param files A list of flag entries indicates js and zip file names
 * @param jsonFiles A list of json encoded files.
 * @param allowStdIn Whether '-' is allowed appear as a filename to representstdin. If true, '-' is only allowed to appear once.
 * @return An array of inputs
 */
protected List<SourceFile> createInputs(List<FlagEntry<JsSourceType>> files,List<JsonFileSpec> jsonFiles,boolean allowStdIn) throws FlagUsageException, IOException {
  List<SourceFile> inputs=new ArrayList<>(files.size());
  boolean usingStdin=false;
  for (  FlagEntry<JsSourceType> file : files) {
    String filename=file.value;
    if (file.flag == JsSourceType.JS_ZIP) {
      if (!""String_Node_Str"".equals(filename)) {
        List<SourceFile> newFiles=SourceFile.fromZipFile(filename,inputCharset);
        inputs.addAll(newFiles);
      }
    }
 else     if (!""String_Node_Str"".equals(filename)) {
      SourceFile newFile=SourceFile.fromFile(filename,inputCharset);
      inputs.add(newFile);
    }
 else {
      if (!allowStdIn) {
        throw new FlagUsageException(""String_Node_Str"");
      }
      if (usingStdin) {
        throw new FlagUsageException(""String_Node_Str"");
      }
      if (!config.outputManifests.isEmpty()) {
        throw new FlagUsageException(""String_Node_Str"" + ""String_Node_Str"");
      }
      if (!config.outputBundles.isEmpty()) {
        throw new FlagUsageException(""String_Node_Str"" + ""String_Node_Str"");
      }
      this.err.println(WAITING_FOR_INPUT_WARNING);
      inputs.add(SourceFile.fromInputStream(""String_Node_Str"",this.in,inputCharset));
      usingStdin=true;
    }
  }
  if (jsonFiles != null) {
    for (    JsonFileSpec jsonFile : jsonFiles) {
      inputs.add(SourceFile.fromCode(jsonFile.getPath(),jsonFile.getSrc()));
    }
  }
  return inputs;
}","/** 
 * Creates inputs from a list of source files, zips and json files. Can be overridden by subclasses who want to pull files from different places.
 * @param files A list of flag entries indicates js and zip file names
 * @param jsonFiles A list of json encoded files.
 * @param allowStdIn Whether '-' is allowed appear as a filename to representstdin. If true, '-' is only allowed to appear once.
 * @param jsModuleSpecs A list js module specs.
 * @return An array of inputs
 */
protected List<SourceFile> createInputs(List<FlagEntry<JsSourceType>> files,List<JsonFileSpec> jsonFiles,boolean allowStdIn,List<JsModuleSpec> jsModuleSpecs) throws FlagUsageException, IOException {
  List<SourceFile> inputs=new ArrayList<>(files.size());
  boolean usingStdin=false;
  int jsModuleIndex=0;
  JsModuleSpec jsModuleSpec=jsModuleSpecs.isEmpty() ? null : jsModuleSpecs.get(0);
  int cumulatedInputFilesExpected=jsModuleSpec == null ? Integer.MAX_VALUE : jsModuleSpec.numInputs;
  for (int i=0; i < files.size(); i++) {
    FlagEntry<JsSourceType> file=files.get(i);
    String filename=file.value;
    if (file.flag == JsSourceType.JS_ZIP) {
      if (!""String_Node_Str"".equals(filename)) {
        List<SourceFile> newFiles=SourceFile.fromZipFile(filename,inputCharset);
        inputs.addAll(newFiles);
        if (jsModuleSpec != null) {
          jsModuleSpec.numJsFiles+=newFiles.size() - 1;
        }
      }
    }
 else     if (!""String_Node_Str"".equals(filename)) {
      SourceFile newFile=SourceFile.fromFile(filename,inputCharset);
      inputs.add(newFile);
    }
 else {
      if (!allowStdIn) {
        throw new FlagUsageException(""String_Node_Str"");
      }
      if (usingStdin) {
        throw new FlagUsageException(""String_Node_Str"");
      }
      if (!config.outputManifests.isEmpty()) {
        throw new FlagUsageException(""String_Node_Str"" + ""String_Node_Str"");
      }
      if (!config.outputBundles.isEmpty()) {
        throw new FlagUsageException(""String_Node_Str"" + ""String_Node_Str"");
      }
      this.err.println(WAITING_FOR_INPUT_WARNING);
      inputs.add(SourceFile.fromInputStream(""String_Node_Str"",this.in,inputCharset));
      usingStdin=true;
    }
    if (i >= cumulatedInputFilesExpected - 1) {
      jsModuleIndex++;
      if (jsModuleIndex < jsModuleSpecs.size()) {
        jsModuleSpec=jsModuleSpecs.get(jsModuleIndex);
        cumulatedInputFilesExpected+=jsModuleSpec.numInputs;
      }
    }
  }
  if (jsonFiles != null) {
    for (    JsonFileSpec jsonFile : jsonFiles) {
      inputs.add(SourceFile.fromCode(jsonFile.getPath(),jsonFile.getSrc()));
    }
  }
  return inputs;
}",0.8441330998248686
27428,"/** 
 * Creates JS source code inputs from a list of files.
 */
private List<SourceFile> createSourceInputs(List<FlagEntry<JsSourceType>> files,List<JsonFileSpec> jsonFiles) throws FlagUsageException, IOException {
  if (isInTestMode()) {
    return inputsSupplierForTesting != null ? inputsSupplierForTesting.get() : null;
  }
  if (files.isEmpty() && jsonFiles == null) {
    files=Collections.singletonList(new FlagEntry<JsSourceType>(JsSourceType.JS,""String_Node_Str""));
  }
  try {
    if (jsonFiles != null) {
      return createInputs(files,jsonFiles);
    }
 else {
      return createInputs(files,true);
    }
  }
 catch (  FlagUsageException e) {
    throw new FlagUsageException(""String_Node_Str"" + e.getMessage());
  }
}","/** 
 * Creates JS source code inputs from a list of files.
 */
private List<SourceFile> createSourceInputs(List<JsModuleSpec> jsModuleSpecs,List<FlagEntry<JsSourceType>> files,List<JsonFileSpec> jsonFiles) throws FlagUsageException, IOException {
  if (isInTestMode()) {
    return inputsSupplierForTesting != null ? inputsSupplierForTesting.get() : null;
  }
  if (files.isEmpty() && jsonFiles == null) {
    files=Collections.singletonList(new FlagEntry<JsSourceType>(JsSourceType.JS,""String_Node_Str""));
  }
  try {
    if (jsonFiles != null) {
      return createInputs(files,jsonFiles,jsModuleSpecs);
    }
 else {
      return createInputs(files,true,jsModuleSpecs);
    }
  }
 catch (  FlagUsageException e) {
    throw new FlagUsageException(""String_Node_Str"" + e.getMessage());
  }
}",0.96
27429,"/** 
 * Creates JS extern inputs from a list of files.
 */
private List<SourceFile> createExternInputs(List<String> files) throws FlagUsageException, IOException {
  if (files.isEmpty()) {
    return ImmutableList.of(SourceFile.fromCode(""String_Node_Str"",""String_Node_Str""));
  }
  List<FlagEntry<JsSourceType>> externFiles=new ArrayList<>();
  for (  String file : files) {
    externFiles.add(new FlagEntry<JsSourceType>(JsSourceType.EXTERN,file));
  }
  try {
    return createInputs(externFiles,false);
  }
 catch (  FlagUsageException e) {
    throw new FlagUsageException(""String_Node_Str"" + e.getMessage());
  }
}","/** 
 * Creates JS extern inputs from a list of files.
 */
private List<SourceFile> createExternInputs(List<String> files) throws FlagUsageException, IOException {
  if (files.isEmpty()) {
    return ImmutableList.of(SourceFile.fromCode(""String_Node_Str"",""String_Node_Str""));
  }
  List<FlagEntry<JsSourceType>> externFiles=new ArrayList<>();
  for (  String file : files) {
    externFiles.add(new FlagEntry<JsSourceType>(JsSourceType.EXTERN,file));
  }
  try {
    return createInputs(externFiles,false,new ArrayList<JsModuleSpec>());
  }
 catch (  FlagUsageException e) {
    throw new FlagUsageException(""String_Node_Str"" + e.getMessage());
  }
}",0.9763779527559056
27430,"/** 
 * Parses command-line arguments and runs the compiler.
 * @return system exit status
 */
protected int doRun() throws FlagUsageException, IOException {
  Compiler.setLoggingLevel(Level.parse(config.loggingLevel));
  compiler=createCompiler();
  B options=createOptions();
  List<SourceFile> externs=createExterns(options);
  List<JSModule> modules=null;
  Result result=null;
  setRunOptions(options);
  boolean writeOutputToFile=!config.jsOutputFile.isEmpty();
  List<String> outputFileNames=new ArrayList<>();
  if (writeOutputToFile) {
    outputFileNames.add(config.jsOutputFile);
  }
  List<String> moduleSpecs=config.module;
  List<JsonFileSpec> jsonFiles=null;
  if (config.jsonStreamMode == JsonStreamMode.IN || config.jsonStreamMode == JsonStreamMode.BOTH) {
    jsonFiles=parseJsonFilesFromInputStream();
    ImmutableMap.Builder<String,SourceMapInput> inputSourceMaps=new ImmutableMap.Builder<>();
    boolean foundJsonInputSourceMap=false;
    for (    JsonFileSpec jsonFile : jsonFiles) {
      if (jsonFile.getSourceMap() != null && jsonFile.getSourceMap().length() > 0) {
        String sourceMapPath=jsonFile.getPath() + ""String_Node_Str"";
        SourceFile sourceMap=SourceFile.fromCode(sourceMapPath,jsonFile.getSourceMap());
        inputSourceMaps.put(sourceMapPath,new SourceMapInput(sourceMap));
        foundJsonInputSourceMap=true;
      }
    }
    if (foundJsonInputSourceMap) {
      inputSourceMaps.putAll(options.inputSourceMaps);
      options.inputSourceMaps=inputSourceMaps.build();
    }
  }
  boolean createCommonJsModules=false;
  if (options.processCommonJSModules && (moduleSpecs.size() == 1 && ""String_Node_Str"".equals(moduleSpecs.get(0)))) {
    createCommonJsModules=true;
    moduleSpecs.remove(0);
  }
  List<SourceFile> inputs=createSourceInputs(config.mixedJsSources,jsonFiles);
  if (!moduleSpecs.isEmpty()) {
    modules=createJsModules(moduleSpecs,inputs);
    for (    JSModule m : modules) {
      outputFileNames.add(getModuleOutputFileName(m));
    }
    if (config.skipNormalOutputs) {
      compiler.initModules(externs,modules,options);
    }
 else {
      result=compiler.compileModules(externs,modules,options);
    }
  }
 else {
    if (config.skipNormalOutputs) {
      compiler.init(externs,inputs,options);
      compiler.hoistExterns();
    }
 else {
      result=compiler.compile(externs,inputs,options);
    }
  }
  if (createCommonJsModules) {
    modules=ImmutableList.copyOf(compiler.getDegenerateModuleGraph().getAllModules());
    for (    JSModule m : modules) {
      outputFileNames.add(getModuleOutputFileName(m));
    }
  }
  for (  String outputFileName : outputFileNames) {
    if (compiler.getSourceFileByName(outputFileName) != null) {
      compiler.report(JSError.make(OUTPUT_SAME_AS_INPUT_ERROR,outputFileName));
      return 1;
    }
  }
  return processResults(result,modules,options);
}","/** 
 * Parses command-line arguments and runs the compiler.
 * @return system exit status
 */
protected int doRun() throws FlagUsageException, IOException {
  Compiler.setLoggingLevel(Level.parse(config.loggingLevel));
  compiler=createCompiler();
  B options=createOptions();
  List<SourceFile> externs=createExterns(options);
  List<JSModule> modules=null;
  Result result=null;
  setRunOptions(options);
  boolean writeOutputToFile=!config.jsOutputFile.isEmpty();
  List<String> outputFileNames=new ArrayList<>();
  if (writeOutputToFile) {
    outputFileNames.add(config.jsOutputFile);
  }
  boolean createCommonJsModules=false;
  if (options.processCommonJSModules && (config.module.size() == 1 && ""String_Node_Str"".equals(config.module.get(0)))) {
    createCommonJsModules=true;
    config.module.remove(0);
  }
  List<JsModuleSpec> jsModuleSpecs=new ArrayList<>();
  for (int i=0; i < config.module.size(); i++) {
    jsModuleSpecs.add(JsModuleSpec.create(config.module.get(i),i == 0));
  }
  List<JsonFileSpec> jsonFiles=null;
  if (config.jsonStreamMode == JsonStreamMode.IN || config.jsonStreamMode == JsonStreamMode.BOTH) {
    jsonFiles=parseJsonFilesFromInputStream();
    ImmutableMap.Builder<String,SourceMapInput> inputSourceMaps=new ImmutableMap.Builder<>();
    boolean foundJsonInputSourceMap=false;
    for (    JsonFileSpec jsonFile : jsonFiles) {
      if (jsonFile.getSourceMap() != null && jsonFile.getSourceMap().length() > 0) {
        String sourceMapPath=jsonFile.getPath() + ""String_Node_Str"";
        SourceFile sourceMap=SourceFile.fromCode(sourceMapPath,jsonFile.getSourceMap());
        inputSourceMaps.put(sourceMapPath,new SourceMapInput(sourceMap));
        foundJsonInputSourceMap=true;
      }
    }
    if (foundJsonInputSourceMap) {
      inputSourceMaps.putAll(options.inputSourceMaps);
      options.inputSourceMaps=inputSourceMaps.build();
    }
  }
  List<SourceFile> inputs=createSourceInputs(jsModuleSpecs,config.mixedJsSources,jsonFiles);
  if (!jsModuleSpecs.isEmpty()) {
    modules=createJsModules(jsModuleSpecs,inputs);
    for (    JSModule m : modules) {
      outputFileNames.add(getModuleOutputFileName(m));
    }
    if (config.skipNormalOutputs) {
      compiler.initModules(externs,modules,options);
    }
 else {
      result=compiler.compileModules(externs,modules,options);
    }
  }
 else {
    if (config.skipNormalOutputs) {
      compiler.init(externs,inputs,options);
      compiler.hoistExterns();
    }
 else {
      result=compiler.compile(externs,inputs,options);
    }
  }
  if (createCommonJsModules) {
    modules=ImmutableList.copyOf(compiler.getDegenerateModuleGraph().getAllModules());
    for (    JSModule m : modules) {
      outputFileNames.add(getModuleOutputFileName(m));
    }
  }
  for (  String outputFileName : outputFileNames) {
    if (compiler.getSourceFileByName(outputFileName) != null) {
      compiler.report(JSError.make(OUTPUT_SAME_AS_INPUT_ERROR,outputFileName));
      return 1;
    }
  }
  return processResults(result,modules,options);
}",0.8870476834629692
27431,"/** 
 * Creates module objects from a list of module specifications.
 * @param specs A list of module specifications, not null or empty. The specformat is: <code>name:num-js-files[:[dep,...][:]]</code>. Module names must not contain the ':' character.
 * @param inputs A list of JS file paths, not null
 * @return An array of module objects
 */
List<JSModule> createJsModules(List<String> specs,List<SourceFile> inputs) throws FlagUsageException, IOException {
  if (isInTestMode()) {
    return modulesSupplierForTesting.get();
  }
  Preconditions.checkState(specs != null);
  Preconditions.checkState(!specs.isEmpty());
  Preconditions.checkState(inputs != null);
  List<String> moduleNames=new ArrayList<>(specs.size());
  Map<String,JSModule> modulesByName=new LinkedHashMap<>();
  Map<String,Integer> modulesFileCountMap=new LinkedHashMap<>();
  int numJsFilesExpected=0, minJsFilesRequired=0;
  boolean isFirstModule=true;
  for (  String spec : specs) {
    String[] parts=spec.split(""String_Node_Str"");
    if (parts.length < 2 || parts.length > 4) {
      throw new FlagUsageException(""String_Node_Str"" + ""String_Node_Str"" + spec);
    }
    String name=parts[0];
    checkModuleName(name);
    if (modulesByName.containsKey(name)) {
      throw new FlagUsageException(""String_Node_Str"" + name);
    }
    JSModule module=new JSModule(name);
    if (parts.length > 2) {
      String depList=parts[2];
      if (depList.length() > 0) {
        String[] deps=depList.split(""String_Node_Str"");
        for (        String dep : deps) {
          JSModule other=modulesByName.get(dep);
          if (other == null) {
            throw new FlagUsageException(""String_Node_Str"" + name + ""String_Node_Str""+ dep+ ""String_Node_Str"");
          }
          module.addDependency(other);
        }
      }
    }
    int numJsFiles=-1;
    try {
      numJsFiles=Integer.parseInt(parts[1]);
    }
 catch (    NumberFormatException ignored) {
      numJsFiles=-1;
    }
    if (numJsFiles < 0) {
      if (parts.length == 2 && ""String_Node_Str"".equals(parts[1])) {
        if (isFirstModule) {
          numJsFilesExpected=-1;
        }
 else {
          throw new FlagUsageException(""String_Node_Str"" + parts[1] + ""String_Node_Str""+ name+ ""String_Node_Str""+ ""String_Node_Str"");
        }
      }
 else {
        throw new FlagUsageException(""String_Node_Str"" + parts[1] + ""String_Node_Str""+ name);
      }
    }
 else {
      minJsFilesRequired+=numJsFiles;
    }
    if (numJsFilesExpected >= 0) {
      numJsFilesExpected+=numJsFiles;
    }
    moduleNames.add(0,name);
    modulesFileCountMap.put(name,numJsFiles);
    modulesByName.put(name,module);
  }
  final int totalNumJsFiles=inputs.size();
  if (numJsFilesExpected >= 0 || minJsFilesRequired > totalNumJsFiles) {
    if (minJsFilesRequired > totalNumJsFiles) {
      numJsFilesExpected=minJsFilesRequired;
    }
    if (numJsFilesExpected > totalNumJsFiles) {
      throw new FlagUsageException(""String_Node_Str"" + numJsFilesExpected + ""String_Node_Str""+ totalNumJsFiles);
    }
 else     if (numJsFilesExpected < totalNumJsFiles) {
      throw new FlagUsageException(""String_Node_Str"" + numJsFilesExpected + ""String_Node_Str""+ totalNumJsFiles);
    }
  }
  int numJsFilesLeft=totalNumJsFiles, moduleIndex=0;
  for (  String moduleName : moduleNames) {
    int numJsFiles=modulesFileCountMap.get(moduleName);
    JSModule module=modulesByName.get(moduleName);
    if (moduleIndex == moduleNames.size() - 1 && numJsFiles == -1) {
      numJsFiles=numJsFilesLeft;
    }
    List<SourceFile> moduleFiles=inputs.subList(numJsFilesLeft - numJsFiles,numJsFilesLeft);
    for (    SourceFile input : moduleFiles) {
      module.add(input);
    }
    numJsFilesLeft-=numJsFiles;
    moduleIndex++;
  }
  return new ArrayList<>(modulesByName.values());
}","/** 
 * Creates module objects from a list of js module specifications.
 * @param specs A list of js module specifications, not null or empty.
 * @param inputs A list of JS file paths, not null
 * @return An array of module objects
 */
List<JSModule> createJsModules(List<JsModuleSpec> specs,List<SourceFile> inputs) throws FlagUsageException, IOException {
  if (isInTestMode()) {
    return modulesSupplierForTesting.get();
  }
  Preconditions.checkState(specs != null);
  Preconditions.checkState(!specs.isEmpty());
  Preconditions.checkState(inputs != null);
  List<String> moduleNames=new ArrayList<>(specs.size());
  Map<String,JSModule> modulesByName=new LinkedHashMap<>();
  Map<String,Integer> modulesFileCountMap=new LinkedHashMap<>();
  int numJsFilesExpected=0, minJsFilesRequired=0;
  for (  JsModuleSpec spec : specs) {
    checkModuleName(spec.name);
    if (modulesByName.containsKey(spec.name)) {
      throw new FlagUsageException(""String_Node_Str"" + spec.name);
    }
    JSModule module=new JSModule(spec.name);
    for (    String dep : spec.deps) {
      JSModule other=modulesByName.get(dep);
      if (other == null) {
        throw new FlagUsageException(""String_Node_Str"" + spec.name + ""String_Node_Str""+ dep+ ""String_Node_Str"");
      }
      module.addDependency(other);
    }
    if (spec.numJsFiles < 0) {
      numJsFilesExpected=-1;
    }
 else {
      minJsFilesRequired+=spec.numJsFiles;
    }
    if (numJsFilesExpected >= 0) {
      numJsFilesExpected+=spec.numJsFiles;
    }
    moduleNames.add(0,spec.name);
    modulesFileCountMap.put(spec.name,spec.numJsFiles);
    modulesByName.put(spec.name,module);
  }
  final int totalNumJsFiles=inputs.size();
  if (numJsFilesExpected >= 0 || minJsFilesRequired > totalNumJsFiles) {
    if (minJsFilesRequired > totalNumJsFiles) {
      numJsFilesExpected=minJsFilesRequired;
    }
    if (numJsFilesExpected > totalNumJsFiles) {
      throw new FlagUsageException(""String_Node_Str"" + numJsFilesExpected + ""String_Node_Str""+ totalNumJsFiles);
    }
 else     if (numJsFilesExpected < totalNumJsFiles) {
      throw new FlagUsageException(""String_Node_Str"" + numJsFilesExpected + ""String_Node_Str""+ totalNumJsFiles);
    }
  }
  int numJsFilesLeft=totalNumJsFiles, moduleIndex=0;
  for (  String moduleName : moduleNames) {
    int numJsFiles=modulesFileCountMap.get(moduleName);
    JSModule module=modulesByName.get(moduleName);
    if (moduleIndex == moduleNames.size() - 1 && numJsFiles == -1) {
      numJsFiles=numJsFilesLeft;
    }
    List<SourceFile> moduleFiles=inputs.subList(numJsFilesLeft - numJsFiles,numJsFilesLeft);
    for (    SourceFile input : moduleFiles) {
      module.add(input);
    }
    numJsFilesLeft-=numJsFiles;
    moduleIndex++;
  }
  return new ArrayList<>(modulesByName.values());
}",0.6442322267697438
27432,"/** 
 * @param name Closure namespace used as an entry point. May start""goog:"" when provided as a flag from the command line. Closure entry points may also be formatted as: 'moduleName:name.space' which specifies that the module name and provided namespace are different
 */
public static ModuleIdentifier forClosure(String name){
  String normalizedName=name;
  if (normalizedName.startsWith(""String_Node_Str"")) {
    normalizedName=normalizedName.substring(5);
  }
  String namespace=normalizedName;
  String moduleName=normalizedName;
  int splitPoint=normalizedName.indexOf(':');
  if (splitPoint != -1) {
    moduleName=normalizedName.substring(0,splitPoint);
    namespace=normalizedName.substring(Math.min(splitPoint + 1,normalizedName.length() - 1));
  }
  return new ModuleIdentifier(normalizedName,namespace,moduleName);
}","/** 
 * @param name Closure namespace used as an entry point. May start""goog:"" when provided as a flag from the command line. Closure entry points may also be formatted as: 'goog:moduleName:name.space' which specifies that the module name and provided namespace are different
 */
public static ModuleIdentifier forClosure(String name){
  String normalizedName=name;
  if (normalizedName.startsWith(""String_Node_Str"")) {
    normalizedName=normalizedName.substring(""String_Node_Str"".length());
  }
  String namespace=normalizedName;
  String moduleName=normalizedName;
  int splitPoint=normalizedName.indexOf(':');
  if (splitPoint != -1) {
    moduleName=normalizedName.substring(0,splitPoint);
    namespace=normalizedName.substring(Math.min(splitPoint + 1,normalizedName.length() - 1));
  }
  return new ModuleIdentifier(normalizedName,namespace,moduleName);
}",0.9811097992916176
27433,"/** 
 * Creates inputs from a list of source files, zips and json files. Can be overridden by subclasses who want to pull files from different places.
 * @param files A list of filenames.
 * @param zips A list of zip filenames.
 * @param jsonFiles A list of json encoded files.
 * @param allowStdIn Whether '-' is allowed appear as a filename to representstdin. If true, '-' is only allowed to appear once.
 * @return An array of inputs
 */
protected List<SourceFile> createInputs(List<String> files,List<String> zips,List<JsonFileSpec> jsonFiles,boolean allowStdIn) throws FlagUsageException, IOException {
  List<SourceFile> inputs=new ArrayList<>(files.size());
  boolean usingStdin=false;
  for (  String filename : files) {
    if (!""String_Node_Str"".equals(filename)) {
      SourceFile newFile=SourceFile.fromFile(filename,inputCharset);
      inputs.add(newFile);
    }
 else {
      if (!allowStdIn) {
        throw new FlagUsageException(""String_Node_Str"");
      }
      if (usingStdin) {
        throw new FlagUsageException(""String_Node_Str"");
      }
      if (!config.outputManifests.isEmpty()) {
        throw new FlagUsageException(""String_Node_Str"" + ""String_Node_Str"");
      }
      if (!config.outputBundles.isEmpty()) {
        throw new FlagUsageException(""String_Node_Str"" + ""String_Node_Str"");
      }
      this.err.println(WAITING_FOR_INPUT_WARNING);
      inputs.add(SourceFile.fromInputStream(""String_Node_Str"",this.in,inputCharset));
      usingStdin=true;
    }
  }
  for (  String zipName : zips) {
    if (!""String_Node_Str"".equals(zipName)) {
      List<SourceFile> newFiles=SourceFile.fromZipFile(zipName,inputCharset);
      inputs.addAll(newFiles);
    }
  }
  if (jsonFiles != null) {
    for (    JsonFileSpec jsonFile : jsonFiles) {
      inputs.add(SourceFile.fromCode(jsonFile.getPath(),jsonFile.getSrc()));
    }
  }
  return inputs;
}","/** 
 * Creates inputs from a list of source files, zips and json files. Can be overridden by subclasses who want to pull files from different places.
 * @param files A list of flag entries indicates js and zip file names
 * @param jsonFiles A list of json encoded files.
 * @param allowStdIn Whether '-' is allowed appear as a filename to representstdin. If true, '-' is only allowed to appear once.
 * @return An array of inputs
 */
protected List<SourceFile> createInputs(List<FlagEntry<JsSourceType>> files,List<JsonFileSpec> jsonFiles,boolean allowStdIn) throws FlagUsageException, IOException {
  List<SourceFile> inputs=new ArrayList<>(files.size());
  boolean usingStdin=false;
  for (  FlagEntry<JsSourceType> file : files) {
    String filename=file.value;
    if (file.flag == JsSourceType.JS_ZIP) {
      if (!""String_Node_Str"".equals(filename)) {
        List<SourceFile> newFiles=SourceFile.fromZipFile(filename,inputCharset);
        inputs.addAll(newFiles);
      }
    }
 else     if (!""String_Node_Str"".equals(filename)) {
      SourceFile newFile=SourceFile.fromFile(filename,inputCharset);
      inputs.add(newFile);
    }
 else {
      if (!allowStdIn) {
        throw new FlagUsageException(""String_Node_Str"");
      }
      if (usingStdin) {
        throw new FlagUsageException(""String_Node_Str"");
      }
      if (!config.outputManifests.isEmpty()) {
        throw new FlagUsageException(""String_Node_Str"" + ""String_Node_Str"");
      }
      if (!config.outputBundles.isEmpty()) {
        throw new FlagUsageException(""String_Node_Str"" + ""String_Node_Str"");
      }
      this.err.println(WAITING_FOR_INPUT_WARNING);
      inputs.add(SourceFile.fromInputStream(""String_Node_Str"",this.in,inputCharset));
      usingStdin=true;
    }
  }
  if (jsonFiles != null) {
    for (    JsonFileSpec jsonFile : jsonFiles) {
      inputs.add(SourceFile.fromCode(jsonFile.getPath(),jsonFile.getSrc()));
    }
  }
  return inputs;
}",0.837257980115123
27434,"/** 
 * Sets options based on the configurations set flags API. Called during the run() run() method. If you want to ignore the flags API, or interpret flags your own way, then you should override this method.
 */
protected void setRunOptions(CompilerOptions options) throws FlagUsageException, IOException {
  DiagnosticGroups diagnosticGroups=getDiagnosticGroups();
  if (config.warningGuards != null) {
    for (    WarningGuardSpec.Entry entry : config.warningGuards.entries) {
      if (""String_Node_Str"".equals(entry.groupName)) {
        Set<String> groupNames=diagnosticGroups.getRegisteredGroups().keySet();
        for (        String groupName : groupNames) {
          if (!DiagnosticGroups.wildcardExcludedGroups.contains(groupName)) {
            diagnosticGroups.setWarningLevel(options,groupName,entry.level);
          }
        }
      }
 else {
        diagnosticGroups.setWarningLevel(options,entry.groupName,entry.level);
      }
    }
  }
  if (!config.warningsWhitelistFile.isEmpty()) {
    addWhitelistWarningsGuard(options,new File(config.warningsWhitelistFile));
  }
  if (!config.hideWarningsFor.isEmpty()) {
    options.addWarningsGuard(new ShowByPathWarningsGuard(config.hideWarningsFor.toArray(new String[]{}),ShowByPathWarningsGuard.ShowType.EXCLUDE));
  }
  createDefineOrTweakReplacements(config.define,options,false);
  options.setTweakProcessing(config.tweakProcessing);
  createDefineOrTweakReplacements(config.tweak,options,true);
  DependencyOptions depOptions=createDependencyOptions(config.manageClosureDependencies,config.onlyClosureDependencies,config.processCommonJSModules,config.closureEntryPoints);
  if (depOptions != null) {
    options.setDependencyOptions(depOptions);
  }
  options.devMode=config.jscompDevMode;
  options.setCodingConvention(config.codingConvention);
  options.setSummaryDetailLevel(config.summaryDetailLevel);
  options.setTrustedStrings(true);
  legacyOutputCharset=options.outputCharset=getLegacyOutputCharset();
  outputCharset2=getOutputCharset2();
  inputCharset=getInputCharset();
  if (config.jsOutputFile.length() > 0) {
    if (config.skipNormalOutputs) {
      throw new FlagUsageException(""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  if (config.skipNormalOutputs && config.printAst) {
    throw new FlagUsageException(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (config.skipNormalOutputs && config.printTree) {
    throw new FlagUsageException(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (config.createSourceMap.length() > 0) {
    options.sourceMapOutputPath=config.createSourceMap;
  }
 else   if (isOutputInJson()) {
    options.sourceMapOutputPath=""String_Node_Str"";
  }
  options.sourceMapDetailLevel=config.sourceMapDetailLevel;
  options.sourceMapFormat=config.sourceMapFormat;
  options.sourceMapLocationMappings=config.sourceMapLocationMappings;
  ImmutableMap.Builder<String,SourceMapInput> inputSourceMaps=new ImmutableMap.Builder<>();
  for (  Map.Entry<String,String> files : config.sourceMapInputFiles.entrySet()) {
    SourceFile sourceMap=SourceFile.fromFile(files.getValue());
    inputSourceMaps.put(files.getKey(),new SourceMapInput(sourceMap));
  }
  options.inputSourceMaps=inputSourceMaps.build();
  if (!config.variableMapInputFile.isEmpty()) {
    options.inputVariableMap=VariableMap.load(config.variableMapInputFile);
  }
  if (!config.propertyMapInputFile.isEmpty()) {
    options.inputPropertyMap=VariableMap.load(config.propertyMapInputFile);
  }
  if (config.languageIn.length() > 0) {
    CompilerOptions.LanguageMode languageMode=CompilerOptions.LanguageMode.fromString(config.languageIn);
    if (languageMode != null) {
      options.setLanguageIn(languageMode);
    }
 else {
      throw new FlagUsageException(""String_Node_Str"" + config.languageIn + ""String_Node_Str"");
    }
  }
  if (config.languageOut.isEmpty()) {
    options.setLanguageOut(options.getLanguageIn());
  }
 else {
    CompilerOptions.LanguageMode languageMode=CompilerOptions.LanguageMode.fromString(config.languageOut);
    if (languageMode != null) {
      options.setLanguageOut(languageMode);
    }
 else {
      throw new FlagUsageException(""String_Node_Str"" + config.languageOut + ""String_Node_Str"");
    }
  }
  if (!config.outputManifests.isEmpty()) {
    Set<String> uniqueNames=new HashSet<>();
    for (    String filename : config.outputManifests) {
      if (!uniqueNames.add(filename)) {
        throw new FlagUsageException(""String_Node_Str"" + ""String_Node_Str"" + filename);
      }
    }
  }
  if (!config.outputBundles.isEmpty()) {
    Set<String> uniqueNames=new HashSet<>();
    for (    String filename : config.outputBundles) {
      if (!uniqueNames.add(filename)) {
        throw new FlagUsageException(""String_Node_Str"" + ""String_Node_Str"" + filename);
      }
    }
  }
  options.transformAMDToCJSModules=config.transformAMDToCJSModules;
  options.processCommonJSModules=config.processCommonJSModules;
  options.moduleRoots=config.moduleRoots;
  options.angularPass=config.angularPass;
  options.tracer=config.tracerMode;
  options.setNewTypeInference(config.useNewTypeInference);
  options.instrumentationTemplateFile=config.instrumentationTemplateFile;
}","/** 
 * Sets options based on the configurations set flags API. Called during the run() run() method. If you want to ignore the flags API, or interpret flags your own way, then you should override this method.
 */
protected void setRunOptions(CompilerOptions options) throws FlagUsageException, IOException {
  DiagnosticGroups diagnosticGroups=getDiagnosticGroups();
  if (config.warningGuards != null) {
    for (    FlagEntry<CheckLevel> entry : config.warningGuards) {
      if (""String_Node_Str"".equals(entry.value)) {
        Set<String> groupNames=diagnosticGroups.getRegisteredGroups().keySet();
        for (        String groupName : groupNames) {
          if (!DiagnosticGroups.wildcardExcludedGroups.contains(groupName)) {
            diagnosticGroups.setWarningLevel(options,groupName,entry.flag);
          }
        }
      }
 else {
        diagnosticGroups.setWarningLevel(options,entry.value,entry.flag);
      }
    }
  }
  if (!config.warningsWhitelistFile.isEmpty()) {
    addWhitelistWarningsGuard(options,new File(config.warningsWhitelistFile));
  }
  if (!config.hideWarningsFor.isEmpty()) {
    options.addWarningsGuard(new ShowByPathWarningsGuard(config.hideWarningsFor.toArray(new String[]{}),ShowByPathWarningsGuard.ShowType.EXCLUDE));
  }
  createDefineOrTweakReplacements(config.define,options,false);
  options.setTweakProcessing(config.tweakProcessing);
  createDefineOrTweakReplacements(config.tweak,options,true);
  DependencyOptions depOptions=createDependencyOptions(config.manageClosureDependencies,config.onlyClosureDependencies,config.processCommonJSModules,config.closureEntryPoints);
  if (depOptions != null) {
    options.setDependencyOptions(depOptions);
  }
  options.devMode=config.jscompDevMode;
  options.setCodingConvention(config.codingConvention);
  options.setSummaryDetailLevel(config.summaryDetailLevel);
  options.setTrustedStrings(true);
  legacyOutputCharset=options.outputCharset=getLegacyOutputCharset();
  outputCharset2=getOutputCharset2();
  inputCharset=getInputCharset();
  if (config.jsOutputFile.length() > 0) {
    if (config.skipNormalOutputs) {
      throw new FlagUsageException(""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  if (config.skipNormalOutputs && config.printAst) {
    throw new FlagUsageException(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (config.skipNormalOutputs && config.printTree) {
    throw new FlagUsageException(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (config.createSourceMap.length() > 0) {
    options.sourceMapOutputPath=config.createSourceMap;
  }
 else   if (isOutputInJson()) {
    options.sourceMapOutputPath=""String_Node_Str"";
  }
  options.sourceMapDetailLevel=config.sourceMapDetailLevel;
  options.sourceMapFormat=config.sourceMapFormat;
  options.sourceMapLocationMappings=config.sourceMapLocationMappings;
  ImmutableMap.Builder<String,SourceMapInput> inputSourceMaps=new ImmutableMap.Builder<>();
  for (  Map.Entry<String,String> files : config.sourceMapInputFiles.entrySet()) {
    SourceFile sourceMap=SourceFile.fromFile(files.getValue());
    inputSourceMaps.put(files.getKey(),new SourceMapInput(sourceMap));
  }
  options.inputSourceMaps=inputSourceMaps.build();
  if (!config.variableMapInputFile.isEmpty()) {
    options.inputVariableMap=VariableMap.load(config.variableMapInputFile);
  }
  if (!config.propertyMapInputFile.isEmpty()) {
    options.inputPropertyMap=VariableMap.load(config.propertyMapInputFile);
  }
  if (config.languageIn.length() > 0) {
    CompilerOptions.LanguageMode languageMode=CompilerOptions.LanguageMode.fromString(config.languageIn);
    if (languageMode != null) {
      options.setLanguageIn(languageMode);
    }
 else {
      throw new FlagUsageException(""String_Node_Str"" + config.languageIn + ""String_Node_Str"");
    }
  }
  if (config.languageOut.isEmpty()) {
    options.setLanguageOut(options.getLanguageIn());
  }
 else {
    CompilerOptions.LanguageMode languageMode=CompilerOptions.LanguageMode.fromString(config.languageOut);
    if (languageMode != null) {
      options.setLanguageOut(languageMode);
    }
 else {
      throw new FlagUsageException(""String_Node_Str"" + config.languageOut + ""String_Node_Str"");
    }
  }
  if (!config.outputManifests.isEmpty()) {
    Set<String> uniqueNames=new HashSet<>();
    for (    String filename : config.outputManifests) {
      if (!uniqueNames.add(filename)) {
        throw new FlagUsageException(""String_Node_Str"" + ""String_Node_Str"" + filename);
      }
    }
  }
  if (!config.outputBundles.isEmpty()) {
    Set<String> uniqueNames=new HashSet<>();
    for (    String filename : config.outputBundles) {
      if (!uniqueNames.add(filename)) {
        throw new FlagUsageException(""String_Node_Str"" + ""String_Node_Str"" + filename);
      }
    }
  }
  options.transformAMDToCJSModules=config.transformAMDToCJSModules;
  options.processCommonJSModules=config.processCommonJSModules;
  options.moduleRoots=config.moduleRoots;
  options.angularPass=config.angularPass;
  options.tracer=config.tracerMode;
  options.setNewTypeInference(config.useNewTypeInference);
  options.instrumentationTemplateFile=config.instrumentationTemplateFile;
}",0.969942978641152
27435,"/** 
 * Creates JS source code inputs from a list of files.
 */
private List<SourceFile> createSourceInputs(List<String> files,List<String> zips,List<JsonFileSpec> jsonFiles) throws FlagUsageException, IOException {
  if (isInTestMode()) {
    return inputsSupplierForTesting != null ? inputsSupplierForTesting.get() : null;
  }
  if (files.isEmpty() && zips.isEmpty() && jsonFiles == null) {
    files=Collections.singletonList(""String_Node_Str"");
  }
  try {
    if (jsonFiles != null) {
      return createInputs(files,jsonFiles);
    }
 else {
      return createInputs(files,zips,true);
    }
  }
 catch (  FlagUsageException e) {
    throw new FlagUsageException(""String_Node_Str"" + e.getMessage());
  }
}","/** 
 * Creates JS source code inputs from a list of files.
 */
private List<SourceFile> createSourceInputs(List<FlagEntry<JsSourceType>> files,List<JsonFileSpec> jsonFiles) throws FlagUsageException, IOException {
  if (isInTestMode()) {
    return inputsSupplierForTesting != null ? inputsSupplierForTesting.get() : null;
  }
  if (files.isEmpty() && jsonFiles == null) {
    files=Collections.singletonList(new FlagEntry<JsSourceType>(JsSourceType.JS,""String_Node_Str""));
  }
  try {
    if (jsonFiles != null) {
      return createInputs(files,jsonFiles);
    }
 else {
      return createInputs(files,true);
    }
  }
 catch (  FlagUsageException e) {
    throw new FlagUsageException(""String_Node_Str"" + e.getMessage());
  }
}",0.916146916146916
27436,"/** 
 * Creates JS extern inputs from a list of files.
 */
private List<SourceFile> createExternInputs(List<String> files) throws FlagUsageException, IOException {
  if (files.isEmpty()) {
    return ImmutableList.of(SourceFile.fromCode(""String_Node_Str"",""String_Node_Str""));
  }
  try {
    return createInputs(files,false);
  }
 catch (  FlagUsageException e) {
    throw new FlagUsageException(""String_Node_Str"" + e.getMessage());
  }
}","/** 
 * Creates JS extern inputs from a list of files.
 */
private List<SourceFile> createExternInputs(List<String> files) throws FlagUsageException, IOException {
  if (files.isEmpty()) {
    return ImmutableList.of(SourceFile.fromCode(""String_Node_Str"",""String_Node_Str""));
  }
  List<FlagEntry<JsSourceType>> externFiles=new ArrayList<>();
  for (  String file : files) {
    externFiles.add(new FlagEntry<JsSourceType>(JsSourceType.EXTERN,file));
  }
  try {
    return createInputs(externFiles,false);
  }
 catch (  FlagUsageException e) {
    throw new FlagUsageException(""String_Node_Str"" + e.getMessage());
  }
}",0.8215297450424929
27437,"/** 
 * Parses command-line arguments and runs the compiler.
 * @return system exit status
 */
protected int doRun() throws FlagUsageException, IOException {
  Compiler.setLoggingLevel(Level.parse(config.loggingLevel));
  compiler=createCompiler();
  B options=createOptions();
  List<SourceFile> externs=createExterns(options);
  List<JSModule> modules=null;
  Result result=null;
  setRunOptions(options);
  boolean writeOutputToFile=!config.jsOutputFile.isEmpty();
  List<String> outputFileNames=new ArrayList<>();
  if (writeOutputToFile) {
    outputFileNames.add(config.jsOutputFile);
  }
  List<String> jsFiles=config.js;
  List<String> moduleSpecs=config.module;
  List<JsonFileSpec> jsonFiles=null;
  if (config.jsonStreamMode == JsonStreamMode.IN || config.jsonStreamMode == JsonStreamMode.BOTH) {
    jsonFiles=parseJsonFilesFromInputStream();
    ImmutableMap.Builder<String,SourceMapInput> inputSourceMaps=new ImmutableMap.Builder<>();
    boolean foundJsonInputSourceMap=false;
    for (    JsonFileSpec jsonFile : jsonFiles) {
      if (jsonFile.getSourceMap() != null && jsonFile.getSourceMap().length() > 0) {
        String sourceMapPath=jsonFile.getPath() + ""String_Node_Str"";
        SourceFile sourceMap=SourceFile.fromCode(sourceMapPath,jsonFile.getSourceMap());
        inputSourceMaps.put(sourceMapPath,new SourceMapInput(sourceMap));
        foundJsonInputSourceMap=true;
      }
    }
    if (foundJsonInputSourceMap) {
      inputSourceMaps.putAll(options.inputSourceMaps);
      options.inputSourceMaps=inputSourceMaps.build();
    }
  }
  boolean createCommonJsModules=false;
  if (options.processCommonJSModules && (moduleSpecs.size() == 1 && ""String_Node_Str"".equals(moduleSpecs.get(0)))) {
    createCommonJsModules=true;
    moduleSpecs.remove(0);
  }
  List<SourceFile> inputs=createSourceInputs(jsFiles,config.jsZip,jsonFiles);
  if (!moduleSpecs.isEmpty()) {
    modules=createJsModules(moduleSpecs,inputs);
    for (    JSModule m : modules) {
      outputFileNames.add(getModuleOutputFileName(m));
    }
    if (config.skipNormalOutputs) {
      compiler.initModules(externs,modules,options);
    }
 else {
      result=compiler.compileModules(externs,modules,options);
    }
  }
 else {
    if (config.skipNormalOutputs) {
      compiler.init(externs,inputs,options);
      compiler.hoistExterns();
    }
 else {
      result=compiler.compile(externs,inputs,options);
    }
  }
  if (createCommonJsModules) {
    modules=ImmutableList.copyOf(compiler.getDegenerateModuleGraph().getAllModules());
    for (    JSModule m : modules) {
      outputFileNames.add(getModuleOutputFileName(m));
    }
  }
  for (  String outputFileName : outputFileNames) {
    if (compiler.getSourceFileByName(outputFileName) != null) {
      compiler.report(JSError.make(OUTPUT_SAME_AS_INPUT_ERROR,outputFileName));
      return 1;
    }
  }
  return processResults(result,modules,options);
}","/** 
 * Parses command-line arguments and runs the compiler.
 * @return system exit status
 */
protected int doRun() throws FlagUsageException, IOException {
  Compiler.setLoggingLevel(Level.parse(config.loggingLevel));
  compiler=createCompiler();
  B options=createOptions();
  List<SourceFile> externs=createExterns(options);
  List<JSModule> modules=null;
  Result result=null;
  setRunOptions(options);
  boolean writeOutputToFile=!config.jsOutputFile.isEmpty();
  List<String> outputFileNames=new ArrayList<>();
  if (writeOutputToFile) {
    outputFileNames.add(config.jsOutputFile);
  }
  List<String> moduleSpecs=config.module;
  List<JsonFileSpec> jsonFiles=null;
  if (config.jsonStreamMode == JsonStreamMode.IN || config.jsonStreamMode == JsonStreamMode.BOTH) {
    jsonFiles=parseJsonFilesFromInputStream();
    ImmutableMap.Builder<String,SourceMapInput> inputSourceMaps=new ImmutableMap.Builder<>();
    boolean foundJsonInputSourceMap=false;
    for (    JsonFileSpec jsonFile : jsonFiles) {
      if (jsonFile.getSourceMap() != null && jsonFile.getSourceMap().length() > 0) {
        String sourceMapPath=jsonFile.getPath() + ""String_Node_Str"";
        SourceFile sourceMap=SourceFile.fromCode(sourceMapPath,jsonFile.getSourceMap());
        inputSourceMaps.put(sourceMapPath,new SourceMapInput(sourceMap));
        foundJsonInputSourceMap=true;
      }
    }
    if (foundJsonInputSourceMap) {
      inputSourceMaps.putAll(options.inputSourceMaps);
      options.inputSourceMaps=inputSourceMaps.build();
    }
  }
  boolean createCommonJsModules=false;
  if (options.processCommonJSModules && (moduleSpecs.size() == 1 && ""String_Node_Str"".equals(moduleSpecs.get(0)))) {
    createCommonJsModules=true;
    moduleSpecs.remove(0);
  }
  List<SourceFile> inputs=createSourceInputs(config.mixedJsSources,jsonFiles);
  if (!moduleSpecs.isEmpty()) {
    modules=createJsModules(moduleSpecs,inputs);
    for (    JSModule m : modules) {
      outputFileNames.add(getModuleOutputFileName(m));
    }
    if (config.skipNormalOutputs) {
      compiler.initModules(externs,modules,options);
    }
 else {
      result=compiler.compileModules(externs,modules,options);
    }
  }
 else {
    if (config.skipNormalOutputs) {
      compiler.init(externs,inputs,options);
      compiler.hoistExterns();
    }
 else {
      result=compiler.compile(externs,inputs,options);
    }
  }
  if (createCommonJsModules) {
    modules=ImmutableList.copyOf(compiler.getDegenerateModuleGraph().getAllModules());
    for (    JSModule m : modules) {
      outputFileNames.add(getModuleOutputFileName(m));
    }
  }
  for (  String outputFileName : outputFileNames) {
    if (compiler.getSourceFileByName(outputFileName) != null) {
      compiler.report(JSError.make(OUTPUT_SAME_AS_INPUT_ERROR,outputFileName));
      return 1;
    }
  }
  return processResults(result,modules,options);
}",0.9870354364736388
27438,"/** 
 * Enables or disables the preservation of all whitespace and formatting within a JSDoc comment. By default, whitespace is collapsed for all comments except @license and
 * @preserve blocks,<p>Setting this option has no effect if  {@link #isParseJsDocDocumentation()}returns false.
 * @param preserveJsDocWhitespace True to preserve whitespace in text extracted from JSDoc comments.
 */
public void setPreserveJsDocWhitespace(boolean preserveJsDocWhitespace){
  this.preserveJsDocWhitespace=preserveJsDocWhitespace;
}","/** 
 * Enables or disables the preservation of all whitespace and formatting within a JSDoc comment. By default, whitespace is collapsed for all comments except   {@literal @license} and{@literal @preserve} blocks,<p>Setting this option has no effect if  {@link #isParseJsDocDocumentation()}returns false.
 * @param preserveJsDocWhitespace True to preserve whitespace in text extracted from JSDoc comments.
 */
public void setPreserveJsDocWhitespace(boolean preserveJsDocWhitespace){
  this.preserveJsDocWhitespace=preserveJsDocWhitespace;
}",0.943609022556391
27439,"/** 
 * The expected format looks like this: <p>[generatorName1] someId1:someFile:theLine:theColumn ... <p>[[generatorName2] someId2:someFile:theLine:theColumn] ... <p>The returned data is grouped by generator name (the map key). The inner map provides mappings from id to content (file, line and column info). In a glimpse, the structure is Map<geneartor name, BiMap<id, value>>. <p>@throws IllegalArgumentException malformed input where there it 1) has duplicate generator name, or 2) the line has no ':' for id and its content.
 */
public static Map<String,BiMap<String,String>> parseSerializedIdMappings(String idMappings){
  if (Strings.isNullOrEmpty(idMappings)) {
    return Collections.emptyMap();
  }
  Map<String,BiMap<String,String>> resultMap=new HashMap<>();
  BiMap<String,String> currentSectionMap=null;
  int lineIndex=0;
  for (  String line : LINE_SPLITTER.split(idMappings)) {
    lineIndex++;
    if (line.isEmpty()) {
      continue;
    }
    if (line.charAt(0) == '[') {
      String currentSection=line.substring(1,line.length() - 1);
      currentSectionMap=resultMap.get(currentSection);
      if (currentSectionMap == null) {
        currentSectionMap=HashBiMap.create();
        resultMap.put(currentSection,currentSectionMap);
      }
 else {
        throw new IllegalArgumentException(SimpleFormat.format(""String_Node_Str"",idMappings,line,lineIndex));
      }
    }
 else {
      int split=line.indexOf(':');
      if (split != -1) {
        String name=line.substring(0,split);
        String location=line.substring(split + 1,line.length());
        currentSectionMap.put(name,location);
      }
 else {
        throw new IllegalArgumentException(SimpleFormat.format(""String_Node_Str"",idMappings,line,lineIndex));
      }
    }
  }
  return resultMap;
}","/** 
 * The expected format looks like this: <p>[generatorName1] someId1:someFile:theLine:theColumn ... <p>[[generatorName2] someId2:someFile:theLine:theColumn] ... <p>The returned data is grouped by generator name (the map key). The inner map provides mappings from id to content (file, line and column info). In a glimpse, the structure is  {@code Map<generator name, BiMap<id, value>>}. <p>@throws IllegalArgumentException malformed input where there it 1) has duplicate generator name, or 2) the line has no ':' for id and its content.
 */
public static Map<String,BiMap<String,String>> parseSerializedIdMappings(String idMappings){
  if (Strings.isNullOrEmpty(idMappings)) {
    return Collections.emptyMap();
  }
  Map<String,BiMap<String,String>> resultMap=new HashMap<>();
  BiMap<String,String> currentSectionMap=null;
  int lineIndex=0;
  for (  String line : LINE_SPLITTER.split(idMappings)) {
    lineIndex++;
    if (line.isEmpty()) {
      continue;
    }
    if (line.charAt(0) == '[') {
      String currentSection=line.substring(1,line.length() - 1);
      currentSectionMap=resultMap.get(currentSection);
      if (currentSectionMap == null) {
        currentSectionMap=HashBiMap.create();
        resultMap.put(currentSection,currentSectionMap);
      }
 else {
        throw new IllegalArgumentException(SimpleFormat.format(""String_Node_Str"",idMappings,line,lineIndex));
      }
    }
 else {
      int split=line.indexOf(':');
      if (split != -1) {
        String name=line.substring(0,split);
        String location=line.substring(split + 1,line.length());
        currentSectionMap.put(name,location);
      }
 else {
        throw new IllegalArgumentException(SimpleFormat.format(""String_Node_Str"",idMappings,line,lineIndex));
      }
    }
  }
  return resultMap;
}",0.996367700474993
27440,"/** 
 * Get a region around the indicated line number. The exact definition of a region is implementation specific, but it must contain the line indicated by the line number. A region must not start or end by a carriage return.
 * @param lineNumber the line number, 1 being the first line of the file
 * @return the region around the line number indicated, or <code>null</null>if it does not exist
 */
Region getSourceRegion(String sourceName,int lineNumber);","/** 
 * Get a region around the indicated line number. The exact definition of a region is implementation specific, but it must contain the line indicated by the line number. A region must not start or end by a carriage return.
 * @param lineNumber the line number, 1 being the first line of the file
 * @return the region around the line number indicated, or {@code null}if it does not exist
 */
Region getSourceRegion(String sourceName,int lineNumber);",0.968236582694414
27441,"/** 
 * This class depends on an input set that contains the white-list. The format of each white-list string is: <file-name>:<line-number>?  <warning-description> # <optional-comment>
 * @param whitelist The set of JS-warnings that are white-listed. This isexpected to have similar format as  {@code formatWarning(JSError)}.
 */
public WhitelistWarningsGuard(Set<String> whitelist){
  Preconditions.checkNotNull(whitelist);
  this.whitelist=normalizeWhitelist(whitelist);
}","/** 
 * This class depends on an input set that contains the white-list. The format of each white-list string is:  {@code <file-name>:<line-number>?  <warning-description>}{@code # <optional-comment>}
 * @param whitelist The set of JS-warnings that are white-listed. This isexpected to have similar format as  {@code formatWarning(JSError)}.
 */
public WhitelistWarningsGuard(Set<String> whitelist){
  Preconditions.checkNotNull(whitelist);
  this.whitelist=normalizeWhitelist(whitelist);
}",0.983402489626556
27442,"/** 
 * Adds a <entrypoint/> entry Each entrypoint entry must have one attribute, name.
 */
public void addEntryPoint(Parameter entrypoint){
  this.entryPointParams.add(entrypoint);
}","/** 
 * Adds a   {@code <entrypoint/>} entryEach entrypoint entry must have one attribute, name.
 */
public void addEntryPoint(Parameter entrypoint){
  this.entryPointParams.add(entrypoint);
}",0.9706666666666668
27443,"/** 
 * Adds a <warning/> entry Each warning entry must have two attributes, group and level. Group must contain one of the constants from DiagnosticGroups (e.g., ""ACCESS_CONTROLS""), while level must contain one of the CheckLevel constants (""ERROR"", ""WARNING"" or ""OFF"").
 */
public void addWarning(Warning warning){
  this.warnings.add(warning);
}","/** 
 * Adds a   {@code <warning/>} entryEach warning entry must have two attributes, group and level. Group must contain one of the constants from DiagnosticGroups (e.g., ""ACCESS_CONTROLS""), while level must contain one of the CheckLevel constants (""ERROR"", ""WARNING"" or ""OFF"").
 */
public void addWarning(Warning warning){
  this.warnings.add(warning);
}",0.984352773826458
27444,"/** 
 * Constructs a DependencyInfo object with the given list of provides & requires. This does *not* copy the given lists, but uses them directly.
 * @param srcPathRelativeToClosure The closure-relative path of the fileassociated with this DependencyInfo.
 * @param pathOfDefiningFile The path to the file from which this dependencyinformation was extracted.
 * @param provides List of provided symbols.
 * @param requires List of required symbols.
 */
public SimpleDependencyInfo(String srcPathRelativeToClosure,String pathOfDefiningFile,List<String> provides,List<String> requires,boolean isModule){
  this.srcPathRelativeToClosure=srcPathRelativeToClosure;
  this.pathOfDefiningFile=pathOfDefiningFile;
  this.provides=provides;
  this.requires=requires;
  this.isModule=isModule;
}","/** 
 * Constructs a DependencyInfo object with the given list of provides and requires. This does *not* copy the given lists, but uses them directly.
 * @param srcPathRelativeToClosure The closure-relative path of the fileassociated with this DependencyInfo.
 * @param pathOfDefiningFile The path to the file from which this dependencyinformation was extracted.
 * @param provides List of provided symbols.
 * @param requires List of required symbols.
 */
public SimpleDependencyInfo(String srcPathRelativeToClosure,String pathOfDefiningFile,List<String> provides,List<String> requires,boolean isModule){
  this.srcPathRelativeToClosure=srcPathRelativeToClosure;
  this.pathOfDefiningFile=pathOfDefiningFile;
  this.provides=provides;
  this.requires=requires;
  this.isModule=isModule;
}",0.9974619289340102
27445,"/** 
 * Unify   {@code this}, which may contain free type variables, with   {@code other}, a concrete type, modifying the supplied  {@code typeMultimap} to add any new template varaible type bindings.
 * @return Whether unification succeeded
 */
boolean unifyWithSubtype(ObjectType other,List<String> typeParameters,Multimap<String,JSType> typeMultimap){
  if (fn != null) {
    if (other.fn == null || !fn.unifyWithSubtype(other.fn,typeParameters,typeMultimap)) {
      return false;
    }
  }
  if (nominalType != null && other.nominalType != null) {
    return nominalType.unifyWithSubtype(other.nominalType,typeParameters,typeMultimap);
  }
  if (nominalType != null || other.nominalType != null) {
    return false;
  }
  for (  String propName : this.props.keySet()) {
    Property thisProp=props.get(propName);
    Property otherProp=other.props.get(propName);
    if (otherProp != null && !thisProp.unifyWithSubtype(otherProp,typeParameters,typeMultimap)) {
      return false;
    }
  }
  return true;
}","/** 
 * Unify   {@code this}, which may contain free type variables, with   {@code other}, a concrete type, modifying the supplied  {@code typeMultimap} to add any new template varaible type bindings.
 * @return Whether unification succeeded
 */
boolean unifyWithSubtype(ObjectType other,List<String> typeParameters,Multimap<String,JSType> typeMultimap){
  if (fn != null) {
    if (other.fn == null || !fn.unifyWithSubtype(other.fn,typeParameters,typeMultimap)) {
      return false;
    }
  }
  if (nominalType != null && other.nominalType != null) {
    return nominalType.unifyWithSubtype(other.nominalType,typeParameters,typeMultimap);
  }
  if (nominalType != null && other.nominalType == null) {
    return false;
  }
  for (  String propName : this.props.keySet()) {
    Property thisProp=props.get(propName);
    Property otherProp=other.props.get(propName);
    if (otherProp != null && !thisProp.unifyWithSubtype(otherProp,typeParameters,typeMultimap)) {
      return false;
    }
  }
  return true;
}",0.8063241106719368
27446,"public void testUnificationWithSubtyping(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testUnificationWithSubtyping(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.9380191693290736
27447,"/** 
 * Unify the two types symmetrically, given that we have already instantiated the type variables of interest in   {@code t1} and {@code t2}, treating JSType.UNKNOWN as a ""hole"" to be filled.
 * @return The unified type, or null if unification fails
 */
static ObjectType unifyUnknowns(ObjectType t1,ObjectType t2){
  if (!Objects.equals(t1.nominalType,t2.nominalType)) {
    return null;
  }
  FunctionType newFn=null;
  if (t1.fn != null || t2.fn != null) {
    newFn=FunctionType.unifyUnknowns(t1.fn,t2.fn);
    if (newFn == null) {
      return null;
    }
  }
  PersistentMap<String,Property> newProps=PersistentMap.create();
  for (  String propName : t1.props.keySet()) {
    Property prop1=t1.props.get(propName);
    Property prop2=t2.props.get(propName);
    if (prop2 == null) {
      return null;
    }
    Property p=Property.unifyUnknowns(prop1,prop2);
    if (p == null) {
      return null;
    }
    newProps=newProps.with(propName,p);
  }
  return makeObjectType(t1.nominalType,newProps,newFn,t1.isLoose || t2.isLoose,ObjectKind.join(t1.objectKind,t2.objectKind));
}","/** 
 * Unify the two types symmetrically, given that we have already instantiated the type variables of interest in   {@code t1} and {@code t2}, treating JSType.UNKNOWN as a ""hole"" to be filled.
 * @return The unified type, or null if unification fails
 */
static ObjectType unifyUnknowns(ObjectType t1,ObjectType t2){
  NominalType nt1=t1.nominalType;
  NominalType nt2=t2.nominalType;
  NominalType nt;
  if (nt1 == null && nt2 == null) {
    nt=null;
  }
 else   if (nt1 == null || nt2 == null) {
    return null;
  }
 else {
    nt=NominalType.unifyUnknowns(nt1,nt2);
    if (nt == null) {
      return null;
    }
  }
  FunctionType newFn=null;
  if (t1.fn != null || t2.fn != null) {
    newFn=FunctionType.unifyUnknowns(t1.fn,t2.fn);
    if (newFn == null) {
      return null;
    }
  }
  PersistentMap<String,Property> newProps=PersistentMap.create();
  for (  String propName : t1.props.keySet()) {
    Property prop1=t1.props.get(propName);
    Property prop2=t2.props.get(propName);
    if (prop2 == null) {
      return null;
    }
    Property p=Property.unifyUnknowns(prop1,prop2);
    if (p == null) {
      return null;
    }
    newProps=newProps.with(propName,p);
  }
  return makeObjectType(nt,newProps,newFn,t1.isLoose || t2.isLoose,ObjectKind.join(t1.objectKind,t2.objectKind));
}",0.3529903805938937
27448,"public void testFunctionTypeUnifyUnknowns(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NOT_UNIQUE_INSTANTIATION);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NOT_UNIQUE_INSTANTIATION);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NOT_UNIQUE_INSTANTIATION);
}","public void testFunctionTypeUnifyUnknowns(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NOT_UNIQUE_INSTANTIATION);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NOT_UNIQUE_INSTANTIATION);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NOT_UNIQUE_INSTANTIATION);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.9198396793587176
27449,"public void testGenericsSubtyping(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.INVALID_PROP_OVERRIDE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.INVALID_PROP_OVERRIDE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.INVALID_PROP_OVERRIDE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.INVALID_PROP_OVERRIDE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.INVALID_PROP_OVERRIDE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.INVALID_PROP_OVERRIDE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testGenericsSubtyping(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.INVALID_PROP_OVERRIDE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.INVALID_PROP_OVERRIDE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.INVALID_PROP_OVERRIDE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.INVALID_PROP_OVERRIDE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.INVALID_PROP_OVERRIDE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.INVALID_PROP_OVERRIDE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.9726554977854804
27450,"private void visitVar(Node nameNode,Node parent){
  String name=nameNode.getString();
  if (this.currentScope.isNamespace(name) || NodeUtil.isTypedefDecl(nameNode) || NodeUtil.isEnumDecl(nameNode)) {
    if (!this.currentScope.isDefinedLocally(name,false)) {
      this.currentScope.addLocal(name,JSType.UNKNOWN,false,nameNode.isFromExterns());
    }
    return;
  }
  Node initializer=nameNode.getFirstChild();
  if (initializer != null && initializer.isFunction()) {
    return;
  }
 else   if (this.currentScope.isDefinedLocally(name,false)) {
    return;
  }
  if (parent.isCatch()) {
    this.currentScope.addLocal(name,JSType.UNKNOWN,false,false);
  }
 else {
    boolean isConst=isConst(nameNode);
    JSType declType=getVarTypeFromAnnotation(nameNode,this.currentScope);
    if (declType == null) {
      declType=mayInferFromRhsIfConst(nameNode);
    }
    this.currentScope.addLocal(name,declType,isConst,nameNode.isFromExterns());
  }
}","private void visitVar(Node nameNode,Node parent){
  String name=nameNode.getString();
  boolean isDefinedLocally=this.currentScope.isDefinedLocally(name,false);
  if (isDefinedLocally && this.currentScope.isNamespace(name)) {
    return;
  }
  if (NodeUtil.isTypedefDecl(nameNode) || NodeUtil.isEnumDecl(nameNode)) {
    if (!isDefinedLocally) {
      this.currentScope.addLocal(name,JSType.UNKNOWN,false,nameNode.isFromExterns());
    }
    return;
  }
  Node initializer=nameNode.getFirstChild();
  if (initializer != null && initializer.isFunction()) {
    return;
  }
  if (parent.isCatch()) {
    this.currentScope.addLocal(name,JSType.UNKNOWN,false,false);
  }
 else {
    boolean isConst=isConst(nameNode);
    JSType declType=getVarTypeFromAnnotation(nameNode,this.currentScope);
    if (declType == null) {
      declType=mayInferFromRhsIfConst(nameNode);
    }
    this.currentScope.addLocal(name,declType,isConst,nameNode.isFromExterns());
  }
}",0.8060956384655806
27451,"private DeclaredFunctionType computeFnDeclaredType(JSDocInfo fnDoc,String functionName,Node declNode,RawNominalType ownerType,NTIScope parentScope){
  Preconditions.checkArgument(declNode.isFunction() || declNode.isGetProp());
  if (fnDoc == null && !NodeUtil.functionHasInlineJsdocs(declNode)) {
    DeclaredFunctionType t=getDeclaredFunctionTypeFromContext(functionName,declNode,parentScope);
    if (t != null) {
      return t;
    }
  }
  RawNominalType ctorType=declNode.isFunction() ? nominaltypesByNode.get(declNode) : null;
  FunctionAndSlotType result=typeParser.getFunctionType(fnDoc,functionName,declNode,ctorType,ownerType,parentScope);
  Node qnameNode=declNode.isGetProp() ? declNode : NodeUtil.getFunctionNameNode(declNode);
  if (result.slotType != null && qnameNode != null && qnameNode.isName()) {
    parentScope.addSimpleType(qnameNode,result.slotType);
  }
  if (ctorType != null) {
    ctorType.setCtorFunction(result.functionType.toFunctionType(),commonTypes);
  }
  if (declNode.isFunction()) {
    maybeWarnFunctionDeclaration(declNode,result.functionType);
  }
  return result.functionType;
}","private DeclaredFunctionType computeFnDeclaredType(JSDocInfo fnDoc,String functionName,Node declNode,RawNominalType ownerType,NTIScope parentScope){
  Preconditions.checkArgument(declNode.isFunction() || declNode.isGetProp());
  if (fnDoc == null && !NodeUtil.functionHasInlineJsdocs(declNode)) {
    DeclaredFunctionType t=getDeclaredFunctionTypeFromContext(functionName,declNode,parentScope);
    if (t != null) {
      return t;
    }
  }
  RawNominalType ctorType=declNode.isFunction() ? nominaltypesByNode.get(declNode) : null;
  FunctionAndSlotType result=typeParser.getFunctionType(fnDoc,functionName,declNode,ctorType,ownerType,parentScope);
  Node qnameNode=declNode.isGetProp() ? declNode : NodeUtil.getFunctionNameNode(declNode);
  if (result.slotType != null && qnameNode != null && qnameNode.isName()) {
    parentScope.addLocal(qnameNode.getString(),result.slotType,false,qnameNode.isFromExterns());
  }
  if (ctorType != null) {
    ctorType.setCtorFunction(result.functionType.toFunctionType(),commonTypes);
  }
  if (declNode.isFunction()) {
    maybeWarnFunctionDeclaration(declNode,result.functionType);
  }
  return result.functionType;
}",0.9600351339481774
27452,"void addLocal(String name,JSType declType,boolean isConstant,boolean isFromExterns){
  Preconditions.checkArgument(!name.contains(""String_Node_Str""));
  Preconditions.checkArgument(!isDefinedLocally(name,false));
  if (isConstant) {
    constVars.add(name);
  }
  if (isFromExterns) {
    externs.put(name,declType);
  }
 else {
    locals.put(name,declType);
  }
}","void addLocal(String name,JSType declType,boolean isConstant,boolean isFromExterns){
  Preconditions.checkArgument(!name.contains(""String_Node_Str""));
  if (isConstant) {
    constVars.add(name);
  }
  if (isFromExterns) {
    externs.put(name,declType);
  }
 else {
    locals.put(name,declType);
  }
}",0.907185628742515
27453,"private void addNamespaceLit(Node qnameNode,NamespaceLit nslit){
  Preconditions.checkArgument(!isNamespace(qnameNode));
  if (qnameNode.isName()) {
    String varName=qnameNode.getString();
    localNamespaces.put(varName,nslit);
    if (qnameNode.isFromExterns() && !externs.containsKey(varName)) {
      externs.put(qnameNode.getString(),null);
    }
  }
 else {
    QualifiedName qname=QualifiedName.fromNode(qnameNode);
    Namespace ns=getNamespace(qname.getLeftmostName());
    ns.addSubnamespace(qname.getAllButLeftmost(),nslit);
  }
}","private void addNamespaceLit(Node qnameNode,NamespaceLit nslit){
  if (qnameNode.isName()) {
    String varName=qnameNode.getString();
    Preconditions.checkArgument(!isDefinedLocally(varName,false) || !isNamespace(qnameNode));
    localNamespaces.put(varName,nslit);
    if (qnameNode.isFromExterns() && !externs.containsKey(varName)) {
      externs.put(qnameNode.getString(),null);
    }
  }
 else {
    Preconditions.checkArgument(!isNamespace(qnameNode));
    QualifiedName qname=QualifiedName.fromNode(qnameNode);
    Namespace ns=getNamespace(qname.getLeftmostName());
    ns.addSubnamespace(qname.getAllButLeftmost(),nslit);
  }
}",0.7783417935702199
27454,"public void testVarDefinitionsInExterns(){
  typeCheckCustomExterns(DEFAULT_EXTERNS + ""String_Node_Str"",""String_Node_Str"");
  typeCheckCustomExterns(DEFAULT_EXTERNS + ""String_Node_Str"",""String_Node_Str"");
  typeCheckCustomExterns(DEFAULT_EXTERNS + ""String_Node_Str"",""String_Node_Str"");
  typeCheckCustomExterns(DEFAULT_EXTERNS + ""String_Node_Str"",""String_Node_Str"");
  typeCheckCustomExterns(DEFAULT_EXTERNS + ""String_Node_Str"",""String_Node_Str"");
  typeCheckCustomExterns(DEFAULT_EXTERNS + ""String_Node_Str"",""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheckCustomExterns(DEFAULT_EXTERNS + ""String_Node_Str"",""String_Node_Str"");
  typeCheckCustomExterns(DEFAULT_EXTERNS + ""String_Node_Str"",""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheckCustomExterns(DEFAULT_EXTERNS + ""String_Node_Str"",Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
}","public void testVarDefinitionsInExterns(){
  typeCheckCustomExterns(DEFAULT_EXTERNS + ""String_Node_Str"",""String_Node_Str"");
  typeCheckCustomExterns(DEFAULT_EXTERNS + ""String_Node_Str"",""String_Node_Str"");
  typeCheckCustomExterns(DEFAULT_EXTERNS + ""String_Node_Str"",""String_Node_Str"");
  typeCheckCustomExterns(DEFAULT_EXTERNS + ""String_Node_Str"",""String_Node_Str"");
  typeCheckCustomExterns(DEFAULT_EXTERNS + ""String_Node_Str"",""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheckCustomExterns(DEFAULT_EXTERNS + ""String_Node_Str"",""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheckCustomExterns(DEFAULT_EXTERNS + ""String_Node_Str"",""String_Node_Str"");
  typeCheckCustomExterns(DEFAULT_EXTERNS + ""String_Node_Str"",""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheckCustomExterns(DEFAULT_EXTERNS + ""String_Node_Str"",Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
}",0.981
27455,"public static SuggestedFix getFixForJsError(JSError error,AbstractCompiler compiler){
switch (error.getType().key) {
case ""String_Node_Str"":
    return getFixForDebuggerStatement(error);
case ""String_Node_Str"":
  return getFixForInexistentProperty(error);
case ""String_Node_Str"":
return getFixForMissingRequire(error,compiler);
case ""String_Node_Str"":
case ""String_Node_Str"":
return getFixForExtraRequire(error,compiler);
case ""String_Node_Str"":
return getFixForUnnecessaryCast(error,compiler);
default :
return null;
}
}","/** 
 * Creates a SuggestedFix for the given error. Note that some errors have multiple fixes so getFixesForJsError should often be used instead of this.
 */
public static SuggestedFix getFixForJsError(JSError error,AbstractCompiler compiler){
switch (error.getType().key) {
case ""String_Node_Str"":
    return getFixForDebuggerStatement(error);
case ""String_Node_Str"":
  return getFixForInexistentProperty(error);
case ""String_Node_Str"":
return getFixForMissingRequire(error,compiler);
case ""String_Node_Str"":
case ""String_Node_Str"":
return getFixForExtraRequire(error,compiler);
case ""String_Node_Str"":
return getFixForUnnecessaryCast(error,compiler);
default :
return null;
}
}",0.8683333333333333
27456,"private JSType fromReceiverToFirstFormal(){
  if (this.receiverType == null) {
    return JSType.UNKNOWN;
  }
  NominalType nt=this.receiverType.getNominalTypeIfSingletonObj();
  if (nt == null) {
    return this.receiverType;
  }
  if (nt.isGeneric()) {
    return nt.instantiateGenerics(JSType.MAP_TO_UNKNOWN).getInstanceAsJSType();
  }
  return nt.getInstanceAsJSType();
}","private JSType fromReceiverToFirstFormal(){
  if (this.receiverType == null) {
    return JSType.UNKNOWN;
  }
  NominalType nt=this.receiverType.getNominalTypeIfSingletonObj();
  if (nt == null || nt.isBuiltinObject()) {
    return this.receiverType;
  }
  if (nt.isGeneric()) {
    return nt.instantiateGenerics(JSType.MAP_TO_UNKNOWN).getInstanceAsJSType();
  }
  return nt.getInstanceAsJSType();
}",0.9689922480620154
27457,"boolean isClassy(){
  return !isFunction() && !isObject();
}","boolean isClassy(){
  return !isFunction() && !isBuiltinObject();
}",0.9448818897637796
27458,"public void testThisOverridesPrototype(){
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testThisOverridesPrototype(){
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
}",0.9257606490872212
27459,"private void visitAssign(Node n){
  if (classNames.contains(n.getLastChild().getQualifiedName())) {
    String maybeAlias=n.getFirstChild().getQualifiedName();
    if (maybeAlias != null) {
      classNames.add(maybeAlias);
      staticMethods.putAll(maybeAlias,staticMethods.get(n.getLastChild().getQualifiedName()));
    }
  }
 else   if (n.getFirstChild().isGetProp()) {
    Node getProp=n.getFirstChild();
    String maybeClassName=getProp.getFirstChild().getQualifiedName();
    if (classNames.contains(maybeClassName)) {
      staticMethods.put(maybeClassName,n);
    }
  }
}","private void visitAssign(Node n){
  String existingClassQname=n.getLastChild().getQualifiedName();
  if (classNames.contains(existingClassQname)) {
    String maybeAlias=n.getFirstChild().getQualifiedName();
    if (maybeAlias != null) {
      classNames.add(maybeAlias);
      staticMethods.put(maybeAlias,getSet(staticMethods,existingClassQname));
    }
  }
 else   if (n.getFirstChild().isGetProp()) {
    Node getProp=n.getFirstChild();
    String maybeClassName=getProp.getFirstChild().getQualifiedName();
    if (classNames.contains(maybeClassName)) {
      getSet(staticMethods,maybeClassName).add(n);
    }
  }
}",0.5495420482930891
27460,"private void copyStaticMethod(Node staticMember,Node superclassNameNode,Node subclassNameNode,Node insertionPoint){
  Preconditions.checkState(staticMember.isAssign(),staticMember);
  String memberName=staticMember.getFirstChild().getLastChild().getString();
  for (  Node subclassMember : staticMethods.get(subclassNameNode.getQualifiedName())) {
    Preconditions.checkState(subclassMember.isAssign(),subclassMember);
    if (subclassMember.getFirstChild().getLastChild().getString().equals(memberName)) {
      return;
    }
  }
  JSDocInfoBuilder info=JSDocInfoBuilder.maybeCopyFrom(staticMember.getJSDocInfo());
  Node assign=IR.assign(IR.getprop(subclassNameNode.cloneTree(),IR.string(memberName)),IR.getprop(superclassNameNode.cloneTree(),IR.string(memberName)));
  info.addSuppression(""String_Node_Str"");
  assign.setJSDocInfo(info.build());
  Node exprResult=IR.exprResult(assign);
  exprResult.useSourceInfoIfMissingFromForTree(superclassNameNode);
  insertionPoint.getParent().addChildAfter(exprResult,insertionPoint);
  staticMethods.put(subclassNameNode.getQualifiedName(),assign);
  compiler.reportCodeChange();
}","private void copyStaticMethod(Node staticMember,Node superclassNameNode,Node subclassNameNode,String subclassQname,Node insertionPoint){
  Preconditions.checkState(staticMember.isAssign(),staticMember);
  String memberName=staticMember.getFirstChild().getLastChild().getString();
  LinkedHashSet<Node> subclassMethods=getSet(staticMethods,subclassQname);
  for (  Node subclassMember : subclassMethods) {
    Preconditions.checkState(subclassMember.isAssign(),subclassMember);
    if (subclassMember.getFirstChild().getLastChild().getString().equals(memberName)) {
      return;
    }
  }
  JSDocInfoBuilder info=JSDocInfoBuilder.maybeCopyFrom(staticMember.getJSDocInfo());
  Node assign=IR.assign(IR.getprop(subclassNameNode.cloneTree(),IR.string(memberName)),IR.getprop(superclassNameNode.cloneTree(),IR.string(memberName)));
  info.addSuppression(""String_Node_Str"");
  assign.setJSDocInfo(info.build());
  Node exprResult=IR.exprResult(assign);
  exprResult.useSourceInfoIfMissingFromForTree(superclassNameNode);
  insertionPoint.getParent().addChildAfter(exprResult,insertionPoint);
  subclassMethods.add(assign);
  compiler.reportCodeChange();
}",0.8967940272288099
27461,"private void processInherits(List<Node> inheritsCalls){
  for (  Node n : inheritsCalls) {
    Node parent=n.getParent();
    Node superclassNameNode=n.getLastChild();
    Node subclassNameNode=n.getChildBefore(superclassNameNode);
    if (multiplyDefinedClasses.contains(superclassNameNode.getQualifiedName())) {
      compiler.report(JSError.make(n,DUPLICATE_CLASS));
      return;
    }
    for (    Node staticMethod : staticMethods.get(superclassNameNode.getQualifiedName())) {
      copyStaticMethod(staticMethod,superclassNameNode,subclassNameNode,parent);
    }
    for (    Node staticProperty : staticProperties.get(superclassNameNode.getQualifiedName())) {
      Preconditions.checkState(staticProperty.isGetProp(),staticProperty);
      String memberName=staticProperty.getLastChild().getString();
      Node getprop=IR.getprop(subclassNameNode.cloneTree(),IR.string(memberName));
      JSDocInfoBuilder info=JSDocInfoBuilder.maybeCopyFrom(staticProperty.getJSDocInfo());
      JSTypeExpression unknown=new JSTypeExpression(new Node(Token.QMARK),""String_Node_Str"");
      info.recordType(unknown);
      info.addSuppression(""String_Node_Str"");
      getprop.setJSDocInfo(info.build());
      Node declaration=IR.exprResult(getprop);
      declaration.useSourceInfoIfMissingFromForTree(n);
      parent.getParent().addChildAfter(declaration,parent);
      staticProperties.put(subclassNameNode.getQualifiedName(),staticProperty);
      compiler.reportCodeChange();
    }
  }
}","private void processInherits(List<Node> inheritsCalls){
  for (  Node n : inheritsCalls) {
    Node parent=n.getParent();
    Node superclassNameNode=n.getLastChild();
    String superclassQname=superclassNameNode.getQualifiedName();
    Node subclassNameNode=n.getChildBefore(superclassNameNode);
    String subclassQname=subclassNameNode.getQualifiedName();
    if (multiplyDefinedClasses.contains(superclassQname)) {
      compiler.report(JSError.make(n,DUPLICATE_CLASS));
      return;
    }
    for (    Node staticMethod : getSet(staticMethods,superclassQname)) {
      copyStaticMethod(staticMethod,superclassNameNode,subclassNameNode,subclassQname,parent);
    }
    for (    Node staticProperty : getSet(staticProperties,superclassQname)) {
      copyStaticProperty(staticProperty,subclassNameNode,subclassQname,n);
    }
  }
}",0.4959104606112785
27462,"private void visitGetProp(Node n){
  String className=n.getFirstChild().getQualifiedName();
  if (classNames.contains(className)) {
    staticProperties.put(className,n);
  }
}","private void visitGetProp(Node n){
  String className=n.getFirstChild().getQualifiedName();
  if (classNames.contains(className)) {
    getSet(staticProperties,className).add(n);
  }
}",0.9444444444444444
27463,"private void visitVar(Node n){
  Node child=n.getFirstChild();
  if (!child.hasChildren()) {
    return;
  }
  String maybeOriginalName=child.getFirstChild().getQualifiedName();
  if (classNames.contains(maybeOriginalName)) {
    String maybeAlias=child.getQualifiedName();
    if (maybeAlias != null) {
      classNames.add(maybeAlias);
      staticMethods.putAll(maybeAlias,staticMethods.get(maybeOriginalName));
    }
  }
}","private void visitVar(Node n){
  Node child=n.getFirstChild();
  if (!child.hasChildren()) {
    return;
  }
  String maybeOriginalName=child.getFirstChild().getQualifiedName();
  if (classNames.contains(maybeOriginalName)) {
    String maybeAlias=child.getQualifiedName();
    if (maybeAlias != null) {
      classNames.add(maybeAlias);
      staticMethods.put(maybeAlias,getSet(staticMethods,maybeOriginalName));
    }
  }
}",0.9671361502347418
27464,"public void testOverride(){
  test(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testOverride(){
  testSame(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  testSame(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.8792912513842747
27465,"private static JSType pickReqObjType(Node expr){
  int exprKind=expr.getType();
switch (exprKind) {
case Token.GETPROP:
    return JSType.TOP_STRUCT;
case Token.GETELEM:
case Token.IN:
  return JSType.TOP_DICT;
case Token.FOR:
Preconditions.checkState(NodeUtil.isForIn(expr));
return JSType.TOP_DICT;
case Token.OBJECTLIT:
{
JSDocInfo jsdoc=expr.getJSDocInfo();
if (jsdoc != null && jsdoc.makesStructs()) {
return JSType.TOP_STRUCT;
}
if (jsdoc != null && jsdoc.makesDicts()) {
return JSType.TOP_DICT;
}
return JSType.TOP_OBJECT;
}
default :
throw new RuntimeException(""String_Node_Str"" + Token.name(exprKind));
}
}","private static JSType pickReqObjType(Node expr){
  int exprKind=expr.getType();
switch (exprKind) {
case Token.GETPROP:
    return JSType.TOP_STRUCT;
case Token.GETELEM:
  return JSType.TOP_DICT;
case Token.OBJECTLIT:
{
  JSDocInfo jsdoc=expr.getJSDocInfo();
  if (jsdoc != null && jsdoc.makesStructs()) {
    return JSType.TOP_STRUCT;
  }
  if (jsdoc != null && jsdoc.makesDicts()) {
    return JSType.TOP_DICT;
  }
  return JSType.TOP_OBJECT;
}
case Token.FOR:
Preconditions.checkState(NodeUtil.isForIn(expr));
return JSType.TOP_OBJECT;
case Token.IN:
return JSType.TOP_OBJECT;
default :
throw new RuntimeException(""String_Node_Str"" + Token.name(exprKind));
}
}",0.3067292644757433
27466,"/** 
 * Generates JavaScript source code for an AST.
 */
private String toSource(Node n,SourceMap sourceMap,boolean firstOutput){
  CodePrinter.Builder builder=new CodePrinter.Builder(n);
  builder.setCompilerOptions(options);
  builder.setSourceMap(sourceMap);
  builder.setTagAsStrict(firstOutput && options.getLanguageOut().isStrict());
  return builder.build();
}","/** 
 * Generates JavaScript source code for an AST.
 */
private String toSource(Node n,SourceMap sourceMap,boolean firstOutput){
  CodePrinter.Builder builder=new CodePrinter.Builder(n);
  builder.setTypeRegistry(this.typeRegistry);
  builder.setCompilerOptions(options);
  builder.setSourceMap(sourceMap);
  builder.setTagAsStrict(firstOutput && options.getLanguageOut().isStrict());
  return builder.build();
}",0.941025641025641
27467,"boolean isSubtypeOf(ObjectKind other){
  return mask == (mask & other.mask);
}","boolean isSubtypeOf(ObjectKind other){
  return this.mask == (this.mask & other.mask);
}",0.9397590361445785
27468,"boolean isDict(){
  return (mask & DICT_MASK) != 0;
}","boolean isDict(){
  return (this.mask & DICT_MASK) != 0;
}",0.954954954954955
27469,"boolean isStruct(){
  return (mask & STRUCT_MASK) != 0;
}","boolean isStruct(){
  return (this.mask & STRUCT_MASK) != 0;
}",0.957983193277311
27470,"ObjectType specialize(ObjectType other){
  Preconditions.checkState(areRelatedClasses(this.nominalType,other.nominalType));
  if (this == TOP_OBJECT) {
    return other;
  }
  NominalType resultNomType=NominalType.pickSubclass(this.nominalType,other.nominalType);
  ObjectKind ok=ObjectKind.meet(this.objectKind,other.objectKind);
  if (resultNomType != null && resultNomType.isClassy()) {
    Preconditions.checkState(this.fn == null && other.fn == null);
    PersistentMap<String,Property> newProps=meetPropsHelper(true,resultNomType,this.props,other.props);
    if (newProps == BOTTOM_MAP) {
      return BOTTOM_OBJECT;
    }
    return new ObjectType(resultNomType,newProps,null,false,ok);
  }
  FunctionType thisFn=this.fn;
  boolean isLoose=this.isLoose;
  if (resultNomType != null && resultNomType.isFunction() && this.fn == null) {
    thisFn=other.fn;
    isLoose=other.fn.isLoose();
  }
  PersistentMap<String,Property> newProps=meetPropsHelper(true,resultNomType,this.props,other.props);
  if (newProps == BOTTOM_MAP) {
    return BOTTOM_OBJECT;
  }
  FunctionType newFn=thisFn == null ? null : thisFn.specialize(other.fn);
  if (!FunctionType.isInhabitable(newFn)) {
    return BOTTOM_OBJECT;
  }
  return new ObjectType(resultNomType,newProps,newFn,isLoose,ok);
}","ObjectType specialize(ObjectType other){
  Preconditions.checkState(areRelatedClasses(this.nominalType,other.nominalType));
  if (this == TOP_OBJECT && other.objectKind.isUnrestricted()) {
    return other;
  }
  NominalType resultNomType=NominalType.pickSubclass(this.nominalType,other.nominalType);
  ObjectKind ok=ObjectKind.meet(this.objectKind,other.objectKind);
  if (resultNomType != null && resultNomType.isClassy()) {
    Preconditions.checkState(this.fn == null && other.fn == null);
    PersistentMap<String,Property> newProps=meetPropsHelper(true,resultNomType,this.props,other.props);
    if (newProps == BOTTOM_MAP) {
      return BOTTOM_OBJECT;
    }
    return new ObjectType(resultNomType,newProps,null,false,ok);
  }
  FunctionType thisFn=this.fn;
  boolean isLoose=this.isLoose;
  if (resultNomType != null && resultNomType.isFunction() && this.fn == null) {
    thisFn=other.fn;
    isLoose=other.fn.isLoose();
  }
  PersistentMap<String,Property> newProps=meetPropsHelper(true,resultNomType,this.props,other.props);
  if (newProps == BOTTOM_MAP) {
    return BOTTOM_OBJECT;
  }
  FunctionType newFn=thisFn == null ? null : thisFn.specialize(other.fn);
  if (!FunctionType.isInhabitable(newFn)) {
    return BOTTOM_OBJECT;
  }
  return new ObjectType(resultNomType,newProps,newFn,isLoose,ok);
}",0.9857197993052876
27471,"public void testDictPropAccess(){
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str""));
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(""String_Node_Str"",NewTypeInference.ILLEGAL_OBJLIT_KEY);
  typeCheck(""String_Node_Str"",NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(""String_Node_Str"",NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
}","public void testDictPropAccess(){
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str""));
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(""String_Node_Str"",NewTypeInference.ILLEGAL_OBJLIT_KEY);
  typeCheck(""String_Node_Str"",NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(""String_Node_Str"",NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.8973941368078175
27472,"boolean hasAnyTemplateTypesInternal(){
  for (  JSType templateValue : templateValues) {
    if (templateValue.hasAnyTemplateTypes()) {
      return true;
    }
  }
  return false;
}","boolean hasAnyTemplateTypesInternal(){
  for (  JSType templateValue : addUnknownValues().resolvedTemplateValues) {
    if (templateValue.hasAnyTemplateTypes()) {
      return true;
    }
  }
  return false;
}",0.9258312020460358
27473,"private void reportUnused(NodeTraversal t){
  for (  Node n : candidates) {
    String propName=getPropName(n);
    if (!used.contains(propName)) {
      t.report(n,UNUSED_PRIVATE_PROPERTY);
    }
  }
}","private void reportUnused(NodeTraversal t){
  for (  Node n : candidates) {
    String propName=getPropName(n);
    if (!used.contains(propName)) {
      t.report(n,UNUSED_PRIVATE_PROPERTY,propName);
    }
  }
}",0.9782082324455206
27474,"private ParseTree parseObjectPatternField(PatternKind kind){
  SourcePosition start=getTreeStartLocation();
  if (peekType() == TokenType.OPEN_SQUARE) {
    ParseTree key=parseComputedPropertyName();
    eat(TokenType.COLON);
    ParseTree value=parseObjectPatternFieldTail(kind);
    return new ComputedPropertyDefinitionTree(getTreeLocation(start),key,value);
  }
  Token name;
  if (peekId() || Keywords.isKeyword(peekType())) {
    name=eatIdOrKeywordAsId();
    if (!peek(TokenType.COLON)) {
      IdentifierToken idToken=(IdentifierToken)name;
      if (Keywords.isKeyword(idToken.value)) {
        reportError(""String_Node_Str"" + name + ""String_Node_Str"");
      }
      if (peek(TokenType.EQUAL)) {
        IdentifierExpressionTree idTree=new IdentifierExpressionTree(getTreeLocation(start),idToken);
        eat(TokenType.EQUAL);
        ParseTree defaultValue=parseAssignmentExpression();
        return new DefaultParameterTree(getTreeLocation(start),idTree,defaultValue);
      }
      return new PropertyNameAssignmentTree(getTreeLocation(start),name,null);
    }
  }
 else {
    name=parseLiteralExpression().literalToken;
  }
  eat(TokenType.COLON);
  ParseTree value=parseObjectPatternFieldTail(kind);
  return new PropertyNameAssignmentTree(getTreeLocation(start),name,value);
}","private ParseTree parseObjectPatternField(PatternKind kind){
  SourcePosition start=getTreeStartLocation();
  if (peekType() == TokenType.OPEN_SQUARE) {
    ParseTree key=parseComputedPropertyName();
    eat(TokenType.COLON);
    ParseTree value=parseObjectPatternFieldTail(kind);
    return new ComputedPropertyDefinitionTree(getTreeLocation(start),key,value);
  }
  Token name;
  if (peekId() || Keywords.isKeyword(peekType())) {
    name=eatIdOrKeywordAsId();
    if (!peek(TokenType.COLON)) {
      IdentifierToken idToken=(IdentifierToken)name;
      if (Keywords.isKeyword(idToken.value) && !Keywords.isTypeScriptSpecificKeyword(idToken.value)) {
        reportError(""String_Node_Str"" + name + ""String_Node_Str"");
      }
      if (peek(TokenType.EQUAL)) {
        IdentifierExpressionTree idTree=new IdentifierExpressionTree(getTreeLocation(start),idToken);
        eat(TokenType.EQUAL);
        ParseTree defaultValue=parseAssignmentExpression();
        return new DefaultParameterTree(getTreeLocation(start),idTree,defaultValue);
      }
      return new PropertyNameAssignmentTree(getTreeLocation(start),name,null);
    }
  }
 else {
    name=parseLiteralExpression().literalToken;
  }
  eat(TokenType.COLON);
  ParseTree value=parseObjectPatternFieldTail(kind);
  return new PropertyNameAssignmentTree(getTreeLocation(start),name,value);
}",0.9788359788359788
27475,"private ParseTree parsePropertyNameAssignment(){
  SourcePosition start=getTreeStartLocation();
  Token name=eatObjectLiteralPropertyName();
  Token colon=eatOpt(TokenType.COLON);
  if (colon == null) {
    if (name.type != TokenType.IDENTIFIER) {
      reportExpectedError(peekToken(),TokenType.COLON);
    }
 else     if (Keywords.isKeyword(name.asIdentifier().value)) {
      reportError(name,""String_Node_Str"");
    }
  }
  ParseTree value=colon == null ? null : parseAssignmentExpression();
  return new PropertyNameAssignmentTree(getTreeLocation(start),name,value);
}","private ParseTree parsePropertyNameAssignment(){
  SourcePosition start=getTreeStartLocation();
  Token name=eatObjectLiteralPropertyName();
  Token colon=eatOpt(TokenType.COLON);
  if (colon == null) {
    if (name.type != TokenType.IDENTIFIER) {
      reportExpectedError(peekToken(),TokenType.COLON);
    }
 else     if (Keywords.isKeyword(name.asIdentifier().value) && !Keywords.isTypeScriptSpecificKeyword(name.asIdentifier().value)) {
      reportError(name,""String_Node_Str"");
    }
  }
  ParseTree value=colon == null ? null : parseAssignmentExpression();
  return new PropertyNameAssignmentTree(getTreeLocation(start),name,value);
}",0.943986820428336
27476,"public void testObjectDestructuringKeywordKeys(){
  mode=LanguageMode.ECMASCRIPT6;
  parse(""String_Node_Str"");
  parse(""String_Node_Str"");
  parseError(""String_Node_Str"",""String_Node_Str"");
  parseError(""String_Node_Str"",""String_Node_Str"");
}","public void testObjectDestructuringKeywordKeys(){
  mode=LanguageMode.ECMASCRIPT6;
  parse(""String_Node_Str"");
  parse(""String_Node_Str"");
  parse(""String_Node_Str"");
  parse(""String_Node_Str"");
  parse(""String_Node_Str"");
  parse(""String_Node_Str"");
  parseError(""String_Node_Str"",""String_Node_Str"");
  parseError(""String_Node_Str"",""String_Node_Str"");
}",0.8120805369127517
27477,"/** 
 * Add node to the list of injectables.
 * @param n node to add.
 * @param t node traversal instance.
 */
private void addNode(Node n,NodeTraversal t){
  Node target=null;
  Node fn=null;
  String name=null;
switch (n.getType()) {
case Token.ASSIGN:
    name=n.getFirstChild().getQualifiedName();
  fn=n;
while (fn.isAssign()) {
  fn=fn.getLastChild();
}
target=n.getParent();
break;
case Token.FUNCTION:
name=NodeUtil.getFunctionName(n);
fn=n;
target=n;
break;
case Token.VAR:
case Token.LET:
case Token.CONST:
name=n.getFirstChild().getString();
fn=getDeclarationRValue(n);
target=n;
break;
case Token.MEMBER_FUNCTION_DEF:
Node parent=n.getParent();
if (parent.isClassMembers()) {
Node classNode=parent.getParent();
String midPart=n.isStaticMember() ? ""String_Node_Str"" : ""String_Node_Str"";
name=NodeUtil.getClassName(classNode) + midPart + n.getString();
if (n.getString().equals(""String_Node_Str"")) {
name=NodeUtil.getClassName(classNode);
}
fn=n.getFirstChild();
if (classNode.getParent().isAssign()) {
target=classNode.getParent().getParent();
}
 else {
target=classNode;
}
}
break;
}
if (fn == null || !fn.isFunction()) {
compiler.report(t.makeError(n,INJECT_NON_FUNCTION_ERROR));
return;
}
if (!target.getParent().isScript() && !target.getParent().isBlock()) {
compiler.report(t.makeError(n,INJECT_IN_NON_GLOBAL_OR_BLOCK_ERROR));
return;
}
Preconditions.checkNotNull(name);
injectables.add(new NodeContext(name,n,fn,target));
}","/** 
 * Add node to the list of injectables.
 * @param n node to add.
 * @param t node traversal instance.
 */
private void addNode(Node n,NodeTraversal t){
  Node target=null;
  Node fn=null;
  String name=null;
switch (n.getType()) {
case Token.ASSIGN:
    name=n.getFirstChild().getQualifiedName();
  fn=n;
while (fn.isAssign()) {
  fn=fn.getLastChild();
}
target=n.getParent();
break;
case Token.FUNCTION:
name=NodeUtil.getFunctionName(n);
fn=n;
target=n;
break;
case Token.VAR:
case Token.LET:
case Token.CONST:
name=n.getFirstChild().getString();
fn=getDeclarationRValue(n);
target=n;
break;
case Token.MEMBER_FUNCTION_DEF:
Node parent=n.getParent();
if (parent.isClassMembers()) {
Node classNode=parent.getParent();
String midPart=n.isStaticMember() ? ""String_Node_Str"" : ""String_Node_Str"";
name=NodeUtil.getClassName(classNode) + midPart + n.getString();
if (n.getString().equals(""String_Node_Str"")) {
name=NodeUtil.getClassName(classNode);
}
fn=n.getFirstChild();
if (classNode.getParent().isAssign() || classNode.getParent().isName()) {
target=classNode.getParent().getParent();
}
 else {
target=classNode;
}
}
break;
}
if (fn == null || !fn.isFunction()) {
compiler.report(t.makeError(n,INJECT_NON_FUNCTION_ERROR));
return;
}
if (!target.getParent().isScript() && !target.getParent().isBlock()) {
compiler.report(t.makeError(n,INJECT_IN_NON_GLOBAL_OR_BLOCK_ERROR));
return;
}
Preconditions.checkNotNull(name);
injectables.add(new NodeContext(name,n,fn,target));
}",0.9883321894303364
27478,"/** 
 * @return True if our parameter spec is equal to {@code that}'s parameter spec.
 */
boolean hasEqualParameters(ArrowType that,EquivalenceMethod eqMethod){
  Node thisParam=parameters.getFirstChild();
  Node otherParam=that.parameters.getFirstChild();
  while (thisParam != null && otherParam != null) {
    JSType thisParamType=thisParam.getJSType();
    JSType otherParamType=otherParam.getJSType();
    if (thisParamType != null) {
      if (otherParamType != null && !thisParamType.checkEquivalenceHelper(otherParamType,eqMethod)) {
        return false;
      }
    }
 else {
      if (otherParamType != null) {
        return false;
      }
    }
    if (thisParam.isOptionalArg() != otherParam.isOptionalArg()) {
      return false;
    }
    if (thisParam.isVarArgs() != otherParam.isVarArgs()) {
      return false;
    }
    thisParam=thisParam.getNext();
    otherParam=otherParam.getNext();
  }
  return thisParam == otherParam;
}","/** 
 * @return True if our parameter spec is equal to {@code that}'s parameter spec.
 */
boolean hasEqualParameters(ArrowType that,EquivalenceMethod eqMethod,EqCache eqCache){
  Node thisParam=parameters.getFirstChild();
  Node otherParam=that.parameters.getFirstChild();
  while (thisParam != null && otherParam != null) {
    JSType thisParamType=thisParam.getJSType();
    JSType otherParamType=otherParam.getJSType();
    if (thisParamType != null) {
      if (otherParamType != null && !thisParamType.checkEquivalenceHelper(otherParamType,eqMethod,eqCache)) {
        return false;
      }
    }
 else {
      if (otherParamType != null) {
        return false;
      }
    }
    if (thisParam.isOptionalArg() != otherParam.isOptionalArg()) {
      return false;
    }
    if (thisParam.isVarArgs() != otherParam.isVarArgs()) {
      return false;
    }
    thisParam=thisParam.getNext();
    otherParam=otherParam.getNext();
  }
  return thisParam == otherParam;
}",0.9874869655891554
27479,"boolean checkArrowEquivalenceHelper(ArrowType that,EquivalenceMethod eqMethod,EqCache eqCache){
  if (!returnType.checkEquivalenceHelper(that.returnType,eqMethod,eqCache)) {
    return false;
  }
  return hasEqualParameters(that,eqMethod);
}","boolean checkArrowEquivalenceHelper(ArrowType that,EquivalenceMethod eqMethod,EqCache eqCache){
  if (!returnType.checkEquivalenceHelper(that.returnType,eqMethod,eqCache)) {
    return false;
  }
  return hasEqualParameters(that,eqMethod,eqCache);
}",0.9836734693877552
27480,"/** 
 * Try to get the sup/inf of two functions by looking at the piecewise components.
 */
private FunctionType tryMergeFunctionPiecewise(FunctionType other,boolean leastSuper){
  Node newParamsNode=null;
  if (call.hasEqualParameters(other.call,EquivalenceMethod.IDENTITY)) {
    newParamsNode=call.parameters;
  }
 else {
    return null;
  }
  JSType newReturnType=leastSuper ? call.returnType.getLeastSupertype(other.call.returnType) : call.returnType.getGreatestSubtype(other.call.returnType);
  JSType newTypeOfThis=null;
  if (isEquivalent(typeOfThis,other.typeOfThis)) {
    newTypeOfThis=typeOfThis;
  }
 else {
    JSType maybeNewTypeOfThis=leastSuper ? typeOfThis.getLeastSupertype(other.typeOfThis) : typeOfThis.getGreatestSubtype(other.typeOfThis);
    newTypeOfThis=maybeNewTypeOfThis;
  }
  boolean newReturnTypeInferred=call.returnTypeInferred || other.call.returnTypeInferred;
  return new FunctionType(registry,null,null,new ArrowType(registry,newParamsNode,newReturnType,newReturnTypeInferred),newTypeOfThis,null,false,false);
}","/** 
 * Try to get the sup/inf of two functions by looking at the piecewise components.
 */
private FunctionType tryMergeFunctionPiecewise(FunctionType other,boolean leastSuper){
  Node newParamsNode=null;
  if (call.hasEqualParameters(other.call,EquivalenceMethod.IDENTITY,EqCache.create())) {
    newParamsNode=call.parameters;
  }
 else {
    return null;
  }
  JSType newReturnType=leastSuper ? call.returnType.getLeastSupertype(other.call.returnType) : call.returnType.getGreatestSubtype(other.call.returnType);
  JSType newTypeOfThis=null;
  if (isEquivalent(typeOfThis,other.typeOfThis)) {
    newTypeOfThis=typeOfThis;
  }
 else {
    JSType maybeNewTypeOfThis=leastSuper ? typeOfThis.getLeastSupertype(other.typeOfThis) : typeOfThis.getGreatestSubtype(other.typeOfThis);
    newTypeOfThis=maybeNewTypeOfThis;
  }
  boolean newReturnTypeInferred=call.returnTypeInferred || other.call.returnTypeInferred;
  return new FunctionType(registry,null,null,new ArrowType(registry,newParamsNode,newReturnType,newReturnTypeInferred),newTypeOfThis,null,false,false);
}",0.9919545669663984
27481,"@Override public void visit(NodeTraversal t,Node n,Node parent){
switch (n.getType()) {
case Token.FUNCTION:
    Node grandparent=parent.getParent();
  if (grandparent == null || !isPrototypePropertyDeclaration(grandparent)) {
    visitFunctionLate(n,null);
  }
break;
case Token.NAME:
{
String name=n.getString();
if (name == null || ""String_Node_Str"".equals(name) || parent.isFunction()) {
  return;
}
if (parent.isVar() || parent.isCatch()) {
  visitVar(n,parent);
}
 else if (currentScope.isOuterVarEarly(name)) {
  currentScope.addOuterVar(name);
}
 else if (currentScope.getTypedef(name) != null || !name.equals(currentScope.getName()) && !currentScope.isDefinedLocally(name,false)) {
}
break;
}
case Token.GETPROP:
if (parent.isExprResult() && n.isQualifiedName()) {
visitPropertyDeclaration(n);
}
break;
case Token.ASSIGN:
{
Node lvalue=n.getFirstChild();
if (lvalue.isGetProp() && lvalue.isQualifiedName() && parent.isExprResult()) {
visitPropertyDeclaration(lvalue);
}
break;
}
case Token.CAST:
castTypes.put(n,getDeclaredTypeOfNode(n.getJSDocInfo(),currentScope));
break;
case Token.OBJECTLIT:
visitObjectLit(n,parent);
break;
case Token.CALL:
visitCall(n);
break;
}
}","@Override public void visit(NodeTraversal t,Node n,Node parent){
switch (n.getType()) {
case Token.FUNCTION:
    Node grandparent=parent.getParent();
  if (grandparent == null || !isPrototypePropertyDeclaration(grandparent)) {
    RawNominalType ownerType=maybeGetOwnerType(n,parent);
    visitFunctionLate(n,ownerType);
  }
break;
case Token.NAME:
{
String name=n.getString();
if (name == null || ""String_Node_Str"".equals(name) || parent.isFunction()) {
  return;
}
if (parent.isVar() || parent.isCatch()) {
  visitVar(n,parent);
}
 else if (currentScope.isOuterVarEarly(name)) {
  currentScope.addOuterVar(name);
}
 else if (currentScope.getTypedef(name) != null || !name.equals(currentScope.getName()) && !currentScope.isDefinedLocally(name,false)) {
}
break;
}
case Token.GETPROP:
if (parent.isExprResult() && n.isQualifiedName()) {
visitPropertyDeclaration(n);
}
break;
case Token.ASSIGN:
{
Node lvalue=n.getFirstChild();
if (lvalue.isGetProp() && lvalue.isQualifiedName() && parent.isExprResult()) {
visitPropertyDeclaration(lvalue);
}
break;
}
case Token.CAST:
castTypes.put(n,getDeclaredTypeOfNode(n.getJSDocInfo(),currentScope));
break;
case Token.OBJECTLIT:
visitObjectLit(n,parent);
break;
case Token.CALL:
visitCall(n);
break;
}
}",0.9706732755059893
27482,"private DeclaredFunctionType getFunTypeFromTypicalFunctionJsdoc(JSDocInfo jsdoc,String functionName,Node funNode,RawNominalType constructorType,RawNominalType ownerType,DeclaredTypeRegistry registry,FunctionTypeBuilder builder,boolean ignoreJsdoc){
  Preconditions.checkArgument(!ignoreJsdoc || jsdoc == null);
  Preconditions.checkArgument(!ignoreJsdoc || funNode.isFunction());
  ImmutableList<String> typeParameters=ImmutableList.of();
  Node parent=funNode.getParent();
  if (jsdoc != null) {
    typeParameters=jsdoc.getTemplateTypeNames();
    if (!typeParameters.isEmpty()) {
      if (parent.isSetterDef() || parent.isGetterDef()) {
        ignoreJsdoc=true;
        jsdoc=null;
        warn(""String_Node_Str"",funNode);
      }
 else {
        builder.addTypeParameters(typeParameters);
      }
    }
  }
  if (ownerType != null) {
    ImmutableList.Builder<String> paramsBuilder=new ImmutableList.Builder<>();
    paramsBuilder.addAll(typeParameters);
    paramsBuilder.addAll(ownerType.getTypeParameters());
    typeParameters=paramsBuilder.build();
  }
  fillInFormalParameterTypes(jsdoc,funNode,typeParameters,registry,builder,ignoreJsdoc);
  fillInReturnType(jsdoc,funNode,parent,typeParameters,registry,builder,ignoreJsdoc);
  if (jsdoc == null) {
    return builder.buildDeclaration();
  }
  NominalType parentClass=getMaybeParentClass(jsdoc,functionName,funNode,typeParameters,registry);
  ImmutableSet<NominalType> implementedIntfs=getImplementedInterfaces(jsdoc,registry,typeParameters);
  if (constructorType == null && jsdoc.isConstructorOrInterface()) {
    return builder.buildDeclaration();
  }
 else   if (jsdoc.isConstructor()) {
    handleConstructorAnnotation(functionName,funNode,constructorType,parentClass,implementedIntfs,registry,builder);
  }
 else   if (jsdoc.isInterface()) {
    handleInterfaceAnnotation(jsdoc,functionName,funNode,constructorType,implementedIntfs,typeParameters,registry,builder);
  }
 else   if (!implementedIntfs.isEmpty()) {
    warnings.add(JSError.make(funNode,IMPLEMENTS_WITHOUT_CONSTRUCTOR,functionName));
  }
  if (jsdoc.hasThisType() && ownerType == null) {
    Node thisRoot=jsdoc.getThisType().getRoot();
    Preconditions.checkState(thisRoot.getType() == Token.BANG);
    Node thisNode=thisRoot.getFirstChild();
    JSType thisType=getMaybeTypeFromComment(thisNode,registry,typeParameters);
    if (thisType != null) {
      thisType=thisType.removeType(JSType.NULL);
    }
    NominalType nt=thisType == null ? null : thisType.getNominalTypeIfSingletonObj();
    NominalType builtinObject=registry.getCommonTypes().getObjectType();
    builder.addReceiverType(nt == null ? builtinObject : nt);
  }
  return builder.buildDeclaration();
}","private DeclaredFunctionType getFunTypeFromTypicalFunctionJsdoc(JSDocInfo jsdoc,String functionName,Node funNode,RawNominalType constructorType,RawNominalType ownerType,DeclaredTypeRegistry registry,FunctionTypeBuilder builder,boolean ignoreJsdoc){
  Preconditions.checkArgument(!ignoreJsdoc || jsdoc == null);
  Preconditions.checkArgument(!ignoreJsdoc || funNode.isFunction());
  ImmutableList<String> typeParameters=ImmutableList.of();
  Node parent=funNode.getParent();
  if (jsdoc != null) {
    typeParameters=jsdoc.getTemplateTypeNames();
    if (typeParameters.isEmpty()) {
      typeParameters=jsdoc.getTypeTransformations().keySet().asList();
    }
    if (!typeParameters.isEmpty()) {
      if (parent.isSetterDef() || parent.isGetterDef()) {
        ignoreJsdoc=true;
        jsdoc=null;
        warn(""String_Node_Str"",funNode);
      }
 else {
        builder.addTypeParameters(typeParameters);
      }
    }
  }
  if (ownerType != null) {
    ImmutableList.Builder<String> paramsBuilder=new ImmutableList.Builder<>();
    paramsBuilder.addAll(typeParameters);
    paramsBuilder.addAll(ownerType.getTypeParameters());
    typeParameters=paramsBuilder.build();
  }
  fillInFormalParameterTypes(jsdoc,funNode,typeParameters,registry,builder,ignoreJsdoc);
  fillInReturnType(jsdoc,funNode,parent,typeParameters,registry,builder,ignoreJsdoc);
  if (jsdoc == null) {
    return builder.buildDeclaration();
  }
  NominalType parentClass=getMaybeParentClass(jsdoc,functionName,funNode,typeParameters,registry);
  ImmutableSet<NominalType> implementedIntfs=getImplementedInterfaces(jsdoc,registry,typeParameters);
  if (constructorType == null && jsdoc.isConstructorOrInterface()) {
    return builder.buildDeclaration();
  }
 else   if (jsdoc.isConstructor()) {
    handleConstructorAnnotation(functionName,funNode,constructorType,parentClass,implementedIntfs,registry,builder);
  }
 else   if (jsdoc.isInterface()) {
    handleInterfaceAnnotation(jsdoc,functionName,funNode,constructorType,implementedIntfs,typeParameters,registry,builder);
  }
 else   if (!implementedIntfs.isEmpty()) {
    warnings.add(JSError.make(funNode,IMPLEMENTS_WITHOUT_CONSTRUCTOR,functionName));
  }
  if (jsdoc.hasThisType() && ownerType == null) {
    Node thisRoot=jsdoc.getThisType().getRoot();
    Preconditions.checkState(thisRoot.getType() == Token.BANG);
    Node thisNode=thisRoot.getFirstChild();
    JSType thisType=getMaybeTypeFromComment(thisNode,registry,typeParameters);
    if (thisType != null) {
      thisType=thisType.removeType(JSType.NULL);
    }
    NominalType nt=thisType == null ? null : thisType.getNominalTypeIfSingletonObj();
    NominalType builtinObject=registry.getCommonTypes().getObjectType();
    builder.addReceiverType(nt == null ? builtinObject : nt);
  }
  return builder.buildDeclaration();
}",0.9795252763181737
27483,"/** 
 * @return a mutable list
 * @throws IOException
 */
public static List<SourceFile> getBuiltinExterns(CompilerOptions options) throws IOException {
  InputStream input=CommandLineRunner.class.getResourceAsStream(""String_Node_Str"");
  if (input == null) {
    input=CommandLineRunner.class.getResourceAsStream(""String_Node_Str"");
  }
  Preconditions.checkNotNull(input);
  ZipInputStream zip=new ZipInputStream(input);
  final String envPrefix=options.getEnvironment().toString().toLowerCase() + ""String_Node_Str"";
  ImmutableList.Builder<ZipEntry> builder=ImmutableList.builder();
  for (ZipEntry entry=null; (entry=zip.getNextEntry()) != null; ) {
    builder.add(entry);
  }
  ImmutableList<ZipEntry> zipEntries=builder.build();
  boolean flatExternStructure=true;
  String browserEnv=CompilerOptions.Environment.BROWSER.toString().toLowerCase();
  for (  ZipEntry entry : zipEntries) {
    if (entry.getName().contains(browserEnv)) {
      flatExternStructure=false;
      break;
    }
  }
  Map<String,SourceFile> externsMap=new HashMap<>();
  for (  ZipEntry entry : zipEntries) {
    if (entry.getName().indexOf('/') < 0 || flatExternStructure || (entry.getName().indexOf(envPrefix) == 0 && entry.getName().length() > envPrefix.length())) {
      BufferedInputStream entryStream=new BufferedInputStream(ByteStreams.limit(zip,entry.getSize()));
      externsMap.put(entry.getName(),SourceFile.fromInputStream(""String_Node_Str"" + entry.getName(),entryStream,UTF_8));
    }
  }
  List<SourceFile> externs=new ArrayList<>();
  for (  String key : BUILTIN_LANG_EXTERNS) {
    Preconditions.checkState(externsMap.containsKey(key),""String_Node_Str"",key);
    externs.add(externsMap.remove(key));
  }
  for (  String key : BUILTIN_EXTERN_DEP_ORDER) {
    if (!key.contains(envPrefix)) {
      continue;
    }
    Preconditions.checkState(externsMap.containsKey(key),""String_Node_Str"",key,options.getEnvironment());
    externs.add(externsMap.remove(key));
  }
  externs.addAll(externsMap.values());
  return externs;
}","/** 
 * @return a mutable list
 * @throws IOException
 */
public static List<SourceFile> getBuiltinExterns(CompilerOptions options) throws IOException {
  InputStream input=CommandLineRunner.class.getResourceAsStream(""String_Node_Str"");
  if (input == null) {
    input=CommandLineRunner.class.getResourceAsStream(""String_Node_Str"");
  }
  Preconditions.checkNotNull(input);
  ZipInputStream zip=new ZipInputStream(input);
  CompilerOptions.Environment env=options.getEnvironment();
  String envPrefix=env.toString().toLowerCase() + ""String_Node_Str"";
  String browserEnv=CompilerOptions.Environment.BROWSER.toString().toLowerCase();
  boolean flatExternStructure=true;
  Map<String,SourceFile> mapFromExternsZip=new HashMap<>();
  for (ZipEntry entry=null; (entry=zip.getNextEntry()) != null; ) {
    String filename=entry.getName();
    if (filename.contains(browserEnv)) {
      flatExternStructure=false;
    }
    if (!filename.contains(""String_Node_Str"") || (filename.indexOf(envPrefix) == 0 && filename.length() > envPrefix.length())) {
      BufferedInputStream entryStream=new BufferedInputStream(ByteStreams.limit(zip,entry.getSize()));
      mapFromExternsZip.put(filename,SourceFile.fromInputStream(""String_Node_Str"" + filename,entryStream,UTF_8));
    }
  }
  List<SourceFile> externs=new ArrayList<>();
  for (  String key : BUILTIN_LANG_EXTERNS) {
    Preconditions.checkState(mapFromExternsZip.containsKey(key),""String_Node_Str"",key);
    externs.add(mapFromExternsZip.remove(key));
  }
  for (  String key : BUILTIN_EXTERN_DEP_ORDER) {
    if (!flatExternStructure && !key.contains(envPrefix)) {
      continue;
    }
    if (flatExternStructure) {
      key=key.substring(key.indexOf('/') + 1);
    }
    Preconditions.checkState(mapFromExternsZip.containsKey(key),""String_Node_Str"",key,env);
    externs.add(mapFromExternsZip.remove(key));
  }
  externs.addAll(mapFromExternsZip.values());
  return externs;
}",0.683210939478349
27484,"private void addExtern(){
  Node name=IR.name(PROTECTOR_FN);
  name.putBooleanProp(Node.IS_CONSTANT_NAME,true);
  Node var=IR.var(name);
  JSDocInfoBuilder builder=new JSDocInfoBuilder(false);
  builder.recordNoAlias();
  var.setJSDocInfo(builder.build());
  CompilerInput input=compiler.getSynthesizedExternsInput();
  input.getAstRoot(compiler).addChildrenToBack(var);
  compiler.reportCodeChange();
}","private void addExtern(){
  Node name=IR.name(PROTECTOR_FN);
  name.putBooleanProp(Node.IS_CONSTANT_NAME,true);
  Node var=IR.var(name);
  JSDocInfoBuilder builder=new JSDocInfoBuilder(false);
  builder.recordNoAlias();
  var.setJSDocInfo(builder.build());
  CompilerInput input=compiler.getSynthesizedExternsInput();
  name.setStaticSourceFile(input.getSourceFile());
  var.setStaticSourceFile(input.getSourceFile());
  input.getAstRoot(compiler).addChildrenToBack(var);
  compiler.reportCodeChange();
}",0.8886438809261301
27485,"void add(JSError warning){
  if (getFileWhereWarningOccurred(warning).startsWith(""String_Node_Str"") || JSType.mockToString) {
    return;
  }
  compiler.report(warning);
}","void add(JSError warning){
  String filename=warning.node.getSourceFileName();
  if (filename != null && filename.startsWith(""String_Node_Str"") || JSType.mockToString) {
    return;
  }
  compiler.report(warning);
}",0.7046632124352331
27486,"Node processSetAccessor(SetAccessorTree tree){
  Node key=processObjectLitKeyAsString(tree.propertyName);
  key.setType(Token.SETTER_DEF);
  Node body=transform(tree.body);
  Node dummyName=IR.name(""String_Node_Str"");
  setSourceInfo(dummyName,tree.propertyName);
  Node paramList=IR.paramList(safeProcessName(tree.parameter));
  setSourceInfo(paramList,tree.parameter);
  Node value=IR.function(dummyName,paramList,body);
  setSourceInfo(value,tree.body);
  key.addChildToFront(value);
  key.setStaticMember(tree.isStatic);
  return key;
}","Node processSetAccessor(SetAccessorTree tree){
  Node key=processObjectLitKeyAsString(tree.propertyName);
  key.setType(Token.SETTER_DEF);
  Node body=transform(tree.body);
  Node dummyName=IR.name(""String_Node_Str"");
  setSourceInfo(dummyName,tree.propertyName);
  Node paramList=IR.paramList(safeProcessName(tree.parameter));
  setSourceInfo(paramList,tree.parameter);
  Node value=newNode(Token.FUNCTION,dummyName,paramList,body);
  setSourceInfo(value,tree.body);
  key.addChildToFront(value);
  key.setStaticMember(tree.isStatic);
  return key;
}",0.9697525206232814
27487,"Node processGetAccessor(GetAccessorTree tree){
  Node key=processObjectLitKeyAsString(tree.propertyName);
  key.setType(Token.GETTER_DEF);
  Node body=transform(tree.body);
  Node dummyName=IR.name(""String_Node_Str"");
  setSourceInfo(dummyName,tree.body);
  Node paramList=IR.paramList();
  setSourceInfo(paramList,tree.body);
  Node value=IR.function(dummyName,paramList,body);
  setSourceInfo(value,tree.body);
  key.addChildToFront(value);
  key.setStaticMember(tree.isStatic);
  return key;
}","Node processGetAccessor(GetAccessorTree tree){
  Node key=processObjectLitKeyAsString(tree.propertyName);
  key.setType(Token.GETTER_DEF);
  Node body=transform(tree.body);
  Node dummyName=IR.name(""String_Node_Str"");
  setSourceInfo(dummyName,tree.body);
  Node paramList=IR.paramList();
  setSourceInfo(paramList,tree.body);
  Node value=newNode(Token.FUNCTION,dummyName,paramList,body);
  setSourceInfo(value,tree.body);
  key.addChildToFront(value);
  key.setStaticMember(tree.isStatic);
  return key;
}",0.967098703888335
27488,"private final void typeCheck(String externs,String js,DiagnosticType... warningKinds){
  parseAndTypeCheck(externs,js);
  JSError[] warnings=compiler.getWarnings();
  JSError[] errors=compiler.getErrors();
  String errorMessage=""String_Node_Str"" + ""String_Node_Str"" + Arrays.toString(warningKinds) + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ Arrays.toString(warnings)+ ""String_Node_Str""+ ""String_Node_Str"";
  assertEquals(errorMessage + ""String_Node_Str"",warningKinds.length,warnings.length + errors.length);
  for (  JSError warning : warnings) {
    assertTrue(""String_Node_Str"" + errorMessage,Arrays.asList(warningKinds).contains(warning.getType()));
  }
  for (  JSError error : errors) {
    assertTrue(""String_Node_Str"" + errorMessage,Arrays.asList(warningKinds).contains(error.getType()));
  }
}","private final void typeCheck(String externs,String js,DiagnosticType... warningKinds){
  parseAndTypeCheck(externs,js);
  JSError[] warnings=compiler.getWarnings();
  JSError[] errors=compiler.getErrors();
  String errorMessage=""String_Node_Str"" + ""String_Node_Str"" + Arrays.toString(warningKinds) + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ Arrays.toString(errors)+ Arrays.toString(warnings)+ ""String_Node_Str""+ ""String_Node_Str"";
  assertEquals(errorMessage + ""String_Node_Str"",warningKinds.length,warnings.length + errors.length);
  for (  JSError warning : warnings) {
    assertTrue(""String_Node_Str"" + errorMessage,Arrays.asList(warningKinds).contains(warning.getType()));
  }
  for (  JSError error : errors) {
    assertTrue(""String_Node_Str"" + errorMessage,Arrays.asList(warningKinds).contains(error.getType()));
  }
}",0.9849306811332128
27489,"protected final void parseAndTypeCheck(String externs,String js){
  setUp();
  final CompilerOptions options=compiler.getOptions();
  options.setClosurePass(true);
  options.setWarningLevel(DiagnosticGroups.NEW_CHECK_TYPES_ALL_CHECKS,CheckLevel.WARNING);
  compiler.init(ImmutableList.of(SourceFile.fromCode(""String_Node_Str"",externs)),ImmutableList.of(SourceFile.fromCode(""String_Node_Str"",js)),options);
  Node externsRoot=IR.block();
  externsRoot.setIsSyntheticBlock(true);
  externsRoot.addChildToFront(compiler.getInput(new InputId(""String_Node_Str"")).getAstRoot(compiler));
  Node astRoot=IR.block();
  astRoot.setIsSyntheticBlock(true);
  astRoot.addChildToFront(compiler.getInput(new InputId(""String_Node_Str"")).getAstRoot(compiler));
  assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(compiler.getErrors()),0,compiler.getErrorCount());
  assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(compiler.getWarnings()),0,compiler.getWarningCount());
  Node block=IR.block(externsRoot,astRoot);
  block.setIsSyntheticBlock(true);
  (new AstValidator(compiler)).validateRoot(block);
  GlobalTypeInfo symbolTable=new GlobalTypeInfo(compiler);
  passes.add(makePassFactory(""String_Node_Str"",symbolTable));
  compiler.setSymbolTable(symbolTable);
  passes.add(makePassFactory(""String_Node_Str"",new NewTypeInference(compiler,options.closurePass)));
  PhaseOptimizer phaseopt=new PhaseOptimizer(compiler,null,null);
  phaseopt.consume(passes);
  phaseopt.process(externsRoot,astRoot);
}","private final void parseAndTypeCheck(String externs,String js){
  setUp();
  final CompilerOptions options=compiler.getOptions();
  options.setClosurePass(true);
  options.setWarningLevel(DiagnosticGroups.NEW_CHECK_TYPES_ALL_CHECKS,CheckLevel.WARNING);
  compiler.init(ImmutableList.of(SourceFile.fromCode(""String_Node_Str"",externs)),ImmutableList.of(SourceFile.fromCode(""String_Node_Str"",js)),options);
  Node externsRoot=IR.block();
  externsRoot.setIsSyntheticBlock(true);
  externsRoot.addChildToFront(compiler.getInput(new InputId(""String_Node_Str"")).getAstRoot(compiler));
  Node astRoot=IR.block();
  astRoot.setIsSyntheticBlock(true);
  astRoot.addChildToFront(compiler.getInput(new InputId(""String_Node_Str"")).getAstRoot(compiler));
  assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(compiler.getErrors()),0,compiler.getErrorCount());
  assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(compiler.getWarnings()),0,compiler.getWarningCount());
  Node block=IR.block(externsRoot,astRoot);
  block.setIsSyntheticBlock(true);
  (new AstValidator(compiler)).validateRoot(block);
  GlobalTypeInfo symbolTable=new GlobalTypeInfo(compiler);
  passes.add(makePassFactory(""String_Node_Str"",symbolTable));
  compiler.setSymbolTable(symbolTable);
  passes.add(makePassFactory(""String_Node_Str"",new NewTypeInference(compiler,options.closurePass)));
  PhaseOptimizer phaseopt=new PhaseOptimizer(compiler,null,null);
  phaseopt.consume(passes);
  phaseopt.process(externsRoot,astRoot);
}",0.996042216358839
27490,"/** 
 * Returns the qualified name node of the function whose scope we're in, or null if it cannot be found.
 */
private static Node getEnclosingDeclNameNode(Node n){
  Node fn=NodeUtil.getEnclosingFunction(n);
  return fn == null ? null : NodeUtil.getFunctionNameNode(enclosingFunction);
}","/** 
 * Returns the qualified name node of the function whose scope we're in, or null if it cannot be found.
 */
private static Node getEnclosingDeclNameNode(Node n){
  Node fn=NodeUtil.getEnclosingFunction(n);
  return fn == null ? null : NodeUtil.getFunctionNameNode(fn);
}",0.9699115044247788
27491,"/** 
 * Returns whether the given property can possibly be set on the given type.
 */
public boolean canPropertyBeDefined(JSType type,String propertyName){
  if (type.isStruct()) {
    return type.hasProperty(propertyName);
  }
 else {
    if (typesIndexedByProperty.containsKey(propertyName)) {
      for (      JSType alt : typesIndexedByProperty.get(propertyName).getAlternates()) {
        JSType greatestSubtype=alt.getGreatestSubtype(type);
        if (!greatestSubtype.isEmptyType()) {
          RecordType maybeRecordType=greatestSubtype.toMaybeRecordType();
          if (maybeRecordType != null && maybeRecordType.isSynthetic()) {
            continue;
          }
          return true;
        }
      }
    }
  }
  return false;
}","/** 
 * Returns whether the given property can possibly be set on the given type.
 */
public boolean canPropertyBeDefined(JSType type,String propertyName){
  if (type.isStruct()) {
    return type.hasProperty(propertyName);
  }
 else {
    if (!type.isEmptyType() && !type.isUnknownType() && type.hasProperty(propertyName)) {
      return true;
    }
    if (typesIndexedByProperty.containsKey(propertyName)) {
      for (      JSType alt : typesIndexedByProperty.get(propertyName).getAlternates()) {
        JSType greatestSubtype=alt.getGreatestSubtype(type);
        if (!greatestSubtype.isEmptyType()) {
          RecordType maybeRecordType=greatestSubtype.toMaybeRecordType();
          if (maybeRecordType != null && maybeRecordType.isSynthetic()) {
            continue;
          }
          return true;
        }
      }
    }
  }
  return false;
}",0.9281698938163648
27492,"public void testIObject14() throws Exception {
  testTypesWithExtraExterns(EXTERNS_WITH_IOBJECT_DECLS,lineJoiner.join(""String_Node_Str"",""String_Node_Str""),lineJoiner.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testIObject14() throws Exception {
  testTypesWithExtraExterns(EXTERNS_WITH_IOBJECT_DECLS,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.917391304347826
27493,"public void testIObject13() throws Exception {
  testTypesWithExtraExterns(EXTERNS_WITH_IOBJECT_DECLS,lineJoiner.join(""String_Node_Str"",""String_Node_Str""),lineJoiner.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testIObject13() throws Exception {
  testTypesWithExtraExterns(EXTERNS_WITH_IOBJECT_DECLS,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.917391304347826
27494,"public void testIObject12() throws Exception {
  testTypesWithExtraExterns(EXTERNS_WITH_IOBJECT_DECLS,lineJoiner.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),lineJoiner.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testIObject12() throws Exception {
  testTypesWithExtraExterns(EXTERNS_WITH_IOBJECT_DECLS,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.9233870967741936
27495,"public void testIObject11() throws Exception {
  testTypesWithExtraExterns(EXTERNS_WITH_IOBJECT_DECLS,lineJoiner.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),lineJoiner.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testIObject11() throws Exception {
  testTypesWithExtraExterns(EXTERNS_WITH_IOBJECT_DECLS,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.9233870967741936
27496,"public void testIObject10() throws Exception {
  testTypesWithExtraExterns(EXTERNS_WITH_IOBJECT_DECLS,lineJoiner.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testIObject10() throws Exception {
  testTypesWithExtraExterns(EXTERNS_WITH_IOBJECT_DECLS,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.9461756373937678
27497,"public void testIArrayLike13() throws Exception {
  testTypesWithExtraExterns(EXTERNS_WITH_IARRAYLIKE_DECLS,lineJoiner.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),lineJoiner.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testIArrayLike13() throws Exception {
  testTypesWithExtraExterns(EXTERNS_WITH_IARRAYLIKE_DECLS,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.9251968503937008
27498,"public void testIArrayLike12() throws Exception {
  testTypesWithExtraExterns(EXTERNS_WITH_IARRAYLIKE_DECLS,lineJoiner.join(""String_Node_Str"",""String_Node_Str""),lineJoiner.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testIArrayLike12() throws Exception {
  testTypesWithExtraExterns(EXTERNS_WITH_IARRAYLIKE_DECLS,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.9194915254237288
27499,"public void testIArrayLike11() throws Exception {
  testTypesWithExtraExterns(EXTERNS_WITH_IARRAYLIKE_DECLS,lineJoiner.join(""String_Node_Str"",""String_Node_Str""),lineJoiner.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testIArrayLike11() throws Exception {
  testTypesWithExtraExterns(EXTERNS_WITH_IARRAYLIKE_DECLS,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.9194915254237288
27500,"public void testIArrayLike10() throws Exception {
  testTypesWithExtraExterns(EXTERNS_WITH_IARRAYLIKE_DECLS,lineJoiner.join(""String_Node_Str"",""String_Node_Str""),lineJoiner.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testIArrayLike10() throws Exception {
  testTypesWithExtraExterns(EXTERNS_WITH_IARRAYLIKE_DECLS,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.9194915254237288
27501,"public void testIObject9() throws Exception {
  testTypesWithExtraExterns(EXTERNS_WITH_IOBJECT_DECLS,lineJoiner.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testIObject9() throws Exception {
  testTypesWithExtraExterns(EXTERNS_WITH_IOBJECT_DECLS,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.945868945868946
27502,"public void testIObject8() throws Exception {
  testTypesWithExtraExterns(EXTERNS_WITH_IOBJECT_DECLS,lineJoiner.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),lineJoiner.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testIObject8() throws Exception {
  testTypesWithExtraExterns(EXTERNS_WITH_IOBJECT_DECLS,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.9230769230769232
27503,"public void testIObject7() throws Exception {
  testTypesWithExtraExterns(EXTERNS_WITH_IOBJECT_DECLS,lineJoiner.join(""String_Node_Str"",""String_Node_Str""),lineJoiner.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testIObject7() throws Exception {
  testTypesWithExtraExterns(EXTERNS_WITH_IOBJECT_DECLS,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.9170305676855895
27504,"public void testIObject6() throws Exception {
  testTypesWithExtraExterns(EXTERNS_WITH_IOBJECT_DECLS,lineJoiner.join(""String_Node_Str"",""String_Node_Str""),lineJoiner.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testIObject6() throws Exception {
  testTypesWithExtraExterns(EXTERNS_WITH_IOBJECT_DECLS,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.9170305676855895
27505,"public void testIObject1() throws Exception {
  testTypesWithExtraExterns(EXTERNS_WITH_IOBJECT_DECLS,lineJoiner.join(""String_Node_Str"",""String_Node_Str""));
}","public void testIObject1() throws Exception {
  testTypesWithExtraExterns(EXTERNS_WITH_IOBJECT_DECLS,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""));
}",0.9396825396825396
27506,"public void testIObject5() throws Exception {
  testTypesWithExtraExterns(EXTERNS_WITH_IOBJECT_DECLS,lineJoiner.join(""String_Node_Str"",""String_Node_Str""),lineJoiner.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testIObject5() throws Exception {
  testTypesWithExtraExterns(EXTERNS_WITH_IOBJECT_DECLS,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.9170305676855895
27507,"public void testIObject4() throws Exception {
  testTypesWithExtraExterns(EXTERNS_WITH_IOBJECT_DECLS,lineJoiner.join(""String_Node_Str"",""String_Node_Str""),lineJoiner.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testIObject4() throws Exception {
  testTypesWithExtraExterns(EXTERNS_WITH_IOBJECT_DECLS,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.9170305676855895
27508,"public void testIObject3() throws Exception {
  testTypesWithExtraExterns(EXTERNS_WITH_IOBJECT_DECLS,lineJoiner.join(""String_Node_Str"",""String_Node_Str""),lineJoiner.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testIObject3() throws Exception {
  testTypesWithExtraExterns(EXTERNS_WITH_IOBJECT_DECLS,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.9170305676855895
27509,"public void testIObject2() throws Exception {
  testTypesWithExtraExterns(EXTERNS_WITH_IOBJECT_DECLS,lineJoiner.join(""String_Node_Str"",""String_Node_Str""));
}","public void testIObject2() throws Exception {
  testTypesWithExtraExterns(EXTERNS_WITH_IOBJECT_DECLS,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""));
}",0.9396825396825396
27510,"public void testIArrayLike9() throws Exception {
  testTypesWithExtraExterns(EXTERNS_WITH_IARRAYLIKE_DECLS,lineJoiner.join(""String_Node_Str"",""String_Node_Str""),lineJoiner.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testIArrayLike9() throws Exception {
  testTypesWithExtraExterns(EXTERNS_WITH_IARRAYLIKE_DECLS,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.9191489361702128
27511,"public void testIArrayLike8() throws Exception {
  testTypesWithExtraExterns(EXTERNS_WITH_IARRAYLIKE_DECLS,lineJoiner.join(""String_Node_Str"",""String_Node_Str""),lineJoiner.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testIArrayLike8() throws Exception {
  testTypesWithExtraExterns(EXTERNS_WITH_IARRAYLIKE_DECLS,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.9191489361702128
27512,"public static String print(JSDocInfo info){
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  if (info.isConstructor()) {
    sb.append(""String_Node_Str"");
  }
  if (info.isInterface() && !info.usesImplicitMatch()) {
    sb.append(""String_Node_Str"");
  }
  if (info.isInterface() && info.usesImplicitMatch()) {
    sb.append(""String_Node_Str"");
  }
  if (info.makesDicts()) {
    sb.append(""String_Node_Str"");
  }
  if (info.makesStructs()) {
    sb.append(""String_Node_Str"");
  }
  if (info.makesUnrestricted()) {
    sb.append(""String_Node_Str"");
  }
  if (info.isDefine()) {
    sb.append(""String_Node_Str"");
    appendTypeNode(sb,info.getType().getRoot());
    sb.append(""String_Node_Str"");
  }
  if (info.isOverride()) {
    sb.append(""String_Node_Str"");
  }
  if (info.isConstant()) {
    sb.append(""String_Node_Str"");
  }
  if (info.isExport()) {
    sb.append(""String_Node_Str"");
  }
  if (info.isDeprecated()) {
    sb.append(""String_Node_Str"");
    sb.append(info.getDeprecationReason() + ""String_Node_Str"");
  }
  if (info.getVisibility() != null && info.getVisibility() != Visibility.INHERITED) {
    sb.append(""String_Node_Str"" + info.getVisibility().toString().toLowerCase() + ""String_Node_Str"");
  }
  for (  String suppression : info.getSuppressions()) {
    sb.append(""String_Node_Str"" + suppression + ""String_Node_Str"");
  }
  ImmutableList<String> names=info.getTemplateTypeNames();
  if (!names.isEmpty()) {
    sb.append(""String_Node_Str"");
    Joiner.on(',').appendTo(sb,names);
    sb.append(""String_Node_Str"");
  }
  if (info.getParameterCount() > 0) {
    for (    String name : info.getParameterNames()) {
      sb.append(""String_Node_Str"");
      appendTypeNode(sb,info.getParameterType(name).getRoot());
      sb.append(""String_Node_Str"");
      sb.append(name);
      sb.append(' ');
    }
  }
  if (info.hasReturnType()) {
    sb.append(""String_Node_Str"");
    appendTypeNode(sb,info.getReturnType().getRoot());
    sb.append(""String_Node_Str"");
  }
  if (info.hasThisType()) {
    sb.append(""String_Node_Str"");
    Node typeNode=info.getThisType().getRoot();
    if (typeNode.getType() == Token.BANG) {
      appendTypeNode(sb,typeNode.getFirstChild());
    }
 else {
      appendTypeNode(sb,typeNode);
    }
    sb.append(""String_Node_Str"");
  }
  if (info.hasBaseType()) {
    sb.append(""String_Node_Str"");
    Node typeNode=info.getBaseType().getRoot();
    if (typeNode.getType() == Token.BANG) {
      appendTypeNode(sb,typeNode.getFirstChild());
    }
 else {
      appendTypeNode(sb,typeNode);
    }
    sb.append(""String_Node_Str"");
  }
  for (  JSTypeExpression type : info.getImplementedInterfaces()) {
    sb.append(""String_Node_Str"");
    Node typeNode=type.getRoot();
    if (typeNode.getType() == Token.BANG) {
      appendTypeNode(sb,typeNode.getFirstChild());
    }
 else {
      appendTypeNode(sb,typeNode);
    }
    sb.append(""String_Node_Str"");
  }
  if (info.hasTypedefType()) {
    sb.append(""String_Node_Str"");
    appendTypeNode(sb,info.getTypedefType().getRoot());
    sb.append(""String_Node_Str"");
  }
  if (info.hasType()) {
    if (info.isInlineType()) {
      sb.append(""String_Node_Str"");
      appendTypeNode(sb,info.getType().getRoot());
      sb.append(""String_Node_Str"");
    }
 else {
      sb.append(""String_Node_Str"");
      appendTypeNode(sb,info.getType().getRoot());
      sb.append(""String_Node_Str"");
    }
  }
  if (!info.getThrownTypes().isEmpty()) {
    sb.append(""String_Node_Str"");
    appendTypeNode(sb,info.getThrownTypes().get(0).getRoot());
    sb.append(""String_Node_Str"");
  }
  if (info.hasEnumParameterType()) {
    sb.append(""String_Node_Str"");
    appendTypeNode(sb,info.getEnumParameterType().getRoot());
    sb.append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}","public static String print(JSDocInfo info){
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  if (info.isConstructor()) {
    sb.append(""String_Node_Str"");
  }
  if (info.isInterface() && !info.usesImplicitMatch()) {
    sb.append(""String_Node_Str"");
  }
  if (info.isInterface() && info.usesImplicitMatch()) {
    sb.append(""String_Node_Str"");
  }
  if (info.makesDicts()) {
    sb.append(""String_Node_Str"");
  }
  if (info.makesStructs()) {
    sb.append(""String_Node_Str"");
  }
  if (info.makesUnrestricted()) {
    sb.append(""String_Node_Str"");
  }
  if (info.isDefine()) {
    sb.append(""String_Node_Str"");
    appendTypeNode(sb,info.getType().getRoot());
    sb.append(""String_Node_Str"");
  }
  if (info.isOverride()) {
    sb.append(""String_Node_Str"");
  }
  if (info.isConstant()) {
    sb.append(""String_Node_Str"");
  }
  if (info.isExport()) {
    sb.append(""String_Node_Str"");
  }
  if (info.isDeprecated()) {
    sb.append(""String_Node_Str"");
    sb.append(info.getDeprecationReason() + ""String_Node_Str"");
  }
  if (info.getVisibility() != null && info.getVisibility() != Visibility.INHERITED) {
    sb.append(""String_Node_Str"" + info.getVisibility().toString().toLowerCase() + ""String_Node_Str"");
  }
  for (  String suppression : info.getSuppressions()) {
    sb.append(""String_Node_Str"" + suppression + ""String_Node_Str"");
  }
  ImmutableList<String> names=info.getTemplateTypeNames();
  if (!names.isEmpty()) {
    sb.append(""String_Node_Str"");
    Joiner.on(',').appendTo(sb,names);
    sb.append(""String_Node_Str"");
  }
  if (info.getParameterCount() > 0) {
    for (    String name : info.getParameterNames()) {
      sb.append(""String_Node_Str"");
      if (info.getParameterType(name) != null) {
        sb.append(""String_Node_Str"");
        appendTypeNode(sb,info.getParameterType(name).getRoot());
        sb.append(""String_Node_Str"");
      }
      sb.append(name);
      sb.append(' ');
    }
  }
  if (info.hasReturnType()) {
    sb.append(""String_Node_Str"");
    appendTypeNode(sb,info.getReturnType().getRoot());
    sb.append(""String_Node_Str"");
  }
  if (info.hasThisType()) {
    sb.append(""String_Node_Str"");
    Node typeNode=info.getThisType().getRoot();
    if (typeNode.getType() == Token.BANG) {
      appendTypeNode(sb,typeNode.getFirstChild());
    }
 else {
      appendTypeNode(sb,typeNode);
    }
    sb.append(""String_Node_Str"");
  }
  if (info.hasBaseType()) {
    sb.append(""String_Node_Str"");
    Node typeNode=info.getBaseType().getRoot();
    if (typeNode.getType() == Token.BANG) {
      appendTypeNode(sb,typeNode.getFirstChild());
    }
 else {
      appendTypeNode(sb,typeNode);
    }
    sb.append(""String_Node_Str"");
  }
  for (  JSTypeExpression type : info.getImplementedInterfaces()) {
    sb.append(""String_Node_Str"");
    Node typeNode=type.getRoot();
    if (typeNode.getType() == Token.BANG) {
      appendTypeNode(sb,typeNode.getFirstChild());
    }
 else {
      appendTypeNode(sb,typeNode);
    }
    sb.append(""String_Node_Str"");
  }
  if (info.hasTypedefType()) {
    sb.append(""String_Node_Str"");
    appendTypeNode(sb,info.getTypedefType().getRoot());
    sb.append(""String_Node_Str"");
  }
  if (info.hasType()) {
    if (info.isInlineType()) {
      sb.append(""String_Node_Str"");
      appendTypeNode(sb,info.getType().getRoot());
      sb.append(""String_Node_Str"");
    }
 else {
      sb.append(""String_Node_Str"");
      appendTypeNode(sb,info.getType().getRoot());
      sb.append(""String_Node_Str"");
    }
  }
  if (!info.getThrownTypes().isEmpty()) {
    sb.append(""String_Node_Str"");
    appendTypeNode(sb,info.getThrownTypes().get(0).getRoot());
    sb.append(""String_Node_Str"");
  }
  if (info.hasEnumParameterType()) {
    sb.append(""String_Node_Str"");
    appendTypeNode(sb,info.getEnumParameterType().getRoot());
    sb.append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}",0.9795971410006498
27513,"public void testParam(){
  builder.recordParameter(""String_Node_Str"",new JSTypeExpression(JsDocInfoParser.parseTypeString(""String_Node_Str""),""String_Node_Str""));
  builder.recordParameter(""String_Node_Str"",new JSTypeExpression(JsDocInfoParser.parseTypeString(""String_Node_Str""),""String_Node_Str""));
  JSDocInfo info=builder.buildAndReset();
  assertEquals(""String_Node_Str"",JSDocInfoPrinter.print(info));
  builder.recordParameter(""String_Node_Str"",new JSTypeExpression(new Node(Token.EQUALS,IR.string(""String_Node_Str"")),""String_Node_Str""));
  info=builder.buildAndReset();
  assertEquals(""String_Node_Str"",JSDocInfoPrinter.print(info));
  builder.recordParameter(""String_Node_Str"",new JSTypeExpression(new Node(Token.ELLIPSIS,IR.string(""String_Node_Str"")),""String_Node_Str""));
  info=builder.buildAndReset();
  assertEquals(""String_Node_Str"",JSDocInfoPrinter.print(info));
}","public void testParam(){
  builder.recordParameter(""String_Node_Str"",new JSTypeExpression(JsDocInfoParser.parseTypeString(""String_Node_Str""),""String_Node_Str""));
  builder.recordParameter(""String_Node_Str"",new JSTypeExpression(JsDocInfoParser.parseTypeString(""String_Node_Str""),""String_Node_Str""));
  JSDocInfo info=builder.buildAndReset();
  assertEquals(""String_Node_Str"",JSDocInfoPrinter.print(info));
  builder.recordParameter(""String_Node_Str"",new JSTypeExpression(new Node(Token.EQUALS,IR.string(""String_Node_Str"")),""String_Node_Str""));
  info=builder.buildAndReset();
  assertEquals(""String_Node_Str"",JSDocInfoPrinter.print(info));
  builder.recordParameter(""String_Node_Str"",new JSTypeExpression(new Node(Token.ELLIPSIS,IR.string(""String_Node_Str"")),""String_Node_Str""));
  info=builder.buildAndReset();
  assertEquals(""String_Node_Str"",JSDocInfoPrinter.print(info));
  builder.recordParameter(""String_Node_Str"",null);
  info=builder.buildAndReset();
  assertEquals(""String_Node_Str"",JSDocInfoPrinter.print(info));
}",0.9225908372827804
27514,"/** 
 * If the variable is declared more than once in a basic block, generate a warning. Also check if a variable is used in a given scope before it is declared, which suggest a likely error. Relies on the fact that references is in parse-tree order.
 */
private void checkVar(Var v,List<Reference> references){
  blocksWithDeclarations.clear();
  boolean isDeclaredInScope=false;
  boolean isUnhoistedNamedFunction=false;
  Reference hoistedFn=null;
  for (  Reference reference : references) {
    if (reference.isHoistedFunction()) {
      blocksWithDeclarations.add(reference.getBasicBlock());
      isDeclaredInScope=true;
      hoistedFn=reference;
      break;
    }
 else     if (NodeUtil.isFunctionDeclaration(reference.getNode().getParent())) {
      isUnhoistedNamedFunction=true;
    }
  }
  for (  Reference reference : references) {
    if (reference == hoistedFn) {
      continue;
    }
    BasicBlock basicBlock=reference.getBasicBlock();
    boolean isDeclaration=reference.isDeclaration();
    Node referenceNode=reference.getNode();
    boolean allowDupe=VarCheck.hasDuplicateDeclarationSuppression(referenceNode,v);
    boolean letConstShadowsVar=v.getParentNode().isVar() && (reference.isLetDeclaration() || reference.isConstDeclaration());
    boolean shadowCatchVar=compiler.getLanguageMode().isEs6OrHigher() && v.getParentNode().isCatch() && reference.isDeclaration()&& reference.getNode() != v.getNode();
    boolean shadowDetected=false;
    if (isDeclaration && !allowDupe) {
      for (      BasicBlock declaredBlock : blocksWithDeclarations) {
        if (declaredBlock.provablyExecutesBefore(basicBlock)) {
          shadowDetected=true;
          DiagnosticType diagnosticType;
          if (v.isLet() || v.isConst() || letConstShadowsVar|| shadowCatchVar) {
            diagnosticType=REDECLARED_VARIABLE_ERROR;
          }
 else {
            diagnosticType=REDECLARED_VARIABLE;
          }
          compiler.report(JSError.make(referenceNode,diagnosticType,v.name));
          break;
        }
      }
    }
    if (!shadowDetected && isDeclaration && (letConstShadowsVar || shadowCatchVar)&& v.getScope() == reference.getScope()) {
      compiler.report(JSError.make(referenceNode,REDECLARED_VARIABLE_ERROR,v.name));
    }
    if (isUnhoistedNamedFunction && !isDeclaration && isDeclaredInScope) {
      for (      BasicBlock declaredBlock : blocksWithDeclarations) {
        if (!declaredBlock.provablyExecutesBefore(basicBlock)) {
          compiler.report(JSError.make(referenceNode,AMBIGUOUS_FUNCTION_DECL,v.name));
          break;
        }
      }
    }
    boolean isUndeclaredReference=false;
    if (!isDeclaration && !isDeclaredInScope) {
      if (!referenceNode.isFromExterns()) {
        Node grandparent=reference.getGrandparent();
        if ((v.isVar() && grandparent.isName() && grandparent.getString().equals(v.name))) {
          continue;
        }
        if (reference.getScope() == v.scope && !v.getName().equals(""String_Node_Str"")) {
          isUndeclaredReference=true;
          compiler.report(JSError.make(reference.getNode(),(v.isLet() || v.isConst() || v.isParam()) ? EARLY_REFERENCE_ERROR : EARLY_REFERENCE,v.name));
        }
      }
    }
    if (!isDeclaration && !isUndeclaredReference && v.isConst()&& reference.isLvalue()) {
      compiler.report(JSError.make(referenceNode,REASSIGNED_CONSTANT,v.name));
    }
    if (isDeclaration && !v.isVar() && reference.getGrandparent().isAddedBlock()) {
      compiler.report(JSError.make(referenceNode,DECLARATION_NOT_DIRECTLY_IN_BLOCK,v.name));
    }
    if (isDeclaration) {
      blocksWithDeclarations.add(basicBlock);
      isDeclaredInScope=true;
    }
  }
}","/** 
 * If the variable is declared more than once in a basic block, generate a warning. Also check if a variable is used in a given scope before it is declared, which suggest a likely error. Relies on the fact that references is in parse-tree order.
 */
private void checkVar(Var v,List<Reference> references){
  blocksWithDeclarations.clear();
  boolean isDeclaredInScope=false;
  boolean isUnhoistedNamedFunction=false;
  Reference hoistedFn=null;
  for (  Reference reference : references) {
    if (reference.isHoistedFunction()) {
      blocksWithDeclarations.add(reference.getBasicBlock());
      isDeclaredInScope=true;
      hoistedFn=reference;
      break;
    }
 else     if (NodeUtil.isFunctionDeclaration(reference.getNode().getParent())) {
      isUnhoistedNamedFunction=true;
    }
  }
  for (  Reference reference : references) {
    if (reference == hoistedFn) {
      continue;
    }
    BasicBlock basicBlock=reference.getBasicBlock();
    boolean isDeclaration=reference.isDeclaration();
    Node referenceNode=reference.getNode();
    boolean allowDupe=VarCheck.hasDuplicateDeclarationSuppression(referenceNode,v);
    boolean letConstShadowsVar=v.getParentNode().isVar() && (reference.isLetDeclaration() || reference.isConstDeclaration());
    boolean shadowCatchVar=compiler.getLanguageMode().isEs6OrHigher() && v.getParentNode().isCatch() && reference.isDeclaration()&& reference.getNode() != v.getNode();
    boolean shadowDetected=false;
    if (isDeclaration && !allowDupe) {
      for (      BasicBlock declaredBlock : blocksWithDeclarations) {
        if (declaredBlock.provablyExecutesBefore(basicBlock)) {
          shadowDetected=true;
          DiagnosticType diagnosticType;
          if (v.isLet() || v.isConst() || letConstShadowsVar|| shadowCatchVar) {
            diagnosticType=REDECLARED_VARIABLE_ERROR;
          }
 else {
            diagnosticType=REDECLARED_VARIABLE;
          }
          compiler.report(JSError.make(referenceNode,diagnosticType,v.name));
          break;
        }
      }
    }
    if (!shadowDetected && isDeclaration && (letConstShadowsVar || shadowCatchVar)&& v.getScope() == reference.getScope()) {
      compiler.report(JSError.make(referenceNode,REDECLARED_VARIABLE_ERROR,v.name));
    }
    if (isUnhoistedNamedFunction && !isDeclaration && isDeclaredInScope) {
      for (      BasicBlock declaredBlock : blocksWithDeclarations) {
        if (!declaredBlock.provablyExecutesBefore(basicBlock)) {
          compiler.report(JSError.make(referenceNode,AMBIGUOUS_FUNCTION_DECL,v.name));
          break;
        }
      }
    }
    boolean isUndeclaredReference=false;
    if (!isDeclaration && !isDeclaredInScope) {
      if (!referenceNode.isFromExterns()) {
        Node grandparent=reference.getGrandparent();
        if ((v.isVar() && grandparent.isName() && grandparent.getString().equals(v.name))) {
          continue;
        }
        if (reference.getScope() == v.scope && !v.getName().equals(""String_Node_Str"")) {
          isUndeclaredReference=true;
          compiler.report(JSError.make(reference.getNode(),(v.isLet() || v.isConst() || v.isParam()) ? EARLY_REFERENCE_ERROR : EARLY_REFERENCE,v.name));
        }
      }
    }
    if (!isDeclaration && !isUndeclaredReference && v.isConst()&& reference.isLvalue()) {
      compiler.report(JSError.make(referenceNode,REASSIGNED_CONSTANT,v.name));
    }
    if (isDeclaration && !reference.isVarDeclaration() && reference.getGrandparent().isAddedBlock()) {
      compiler.report(JSError.make(referenceNode,DECLARATION_NOT_DIRECTLY_IN_BLOCK,v.name));
    }
    if (isDeclaration) {
      blocksWithDeclarations.add(basicBlock);
      isDeclaredInScope=true;
    }
  }
}",0.9971548570654384
27515,"public void testRedeclare(){
  assertRedeclare(""String_Node_Str"");
  assertRedeclare(""String_Node_Str"");
}","public void testRedeclare(){
  assertRedeclare(""String_Node_Str"");
  assertRedeclare(""String_Node_Str"");
  assertRedeclare(""String_Node_Str"");
}",0.848
27516,"void add(Node n,Context context){
  if (!cc.continueProcessing()) {
    return;
  }
  if (preserveTypeAnnotations && n.getJSDocInfo() != null) {
    add(JSDocInfoPrinter.print(n.getJSDocInfo()));
  }
  int type=n.getType();
  String opstr=NodeUtil.opToStr(type);
  int childCount=n.getChildCount();
  Node first=n.getFirstChild();
  Node last=n.getLastChild();
  if (opstr != null && first != last) {
    Preconditions.checkState(childCount == 2,""String_Node_Str"",opstr,childCount);
    int p=NodeUtil.precedence(type);
    Context rhsContext=getContextForNoInOperator(context);
    if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
      addExpr(first,p,context);
      cc.addOp(opstr,true);
      addExpr(last,p,rhsContext);
    }
 else {
      unrollBinaryOperator(n,type,opstr,context,rhsContext,p,p + 1);
    }
    return;
  }
  cc.startSourceMapping(n);
switch (type) {
case Token.TRY:
{
      Preconditions.checkState(first.getNext().isBlock() && !first.getNext().hasMoreThanOneChild());
      Preconditions.checkState(childCount >= 2 && childCount <= 3);
      add(""String_Node_Str"");
      add(first,Context.PRESERVE_BLOCK);
      Node catchblock=first.getNext().getFirstChild();
      if (catchblock != null) {
        add(catchblock);
      }
      if (childCount == 3) {
        cc.maybeInsertSpace();
        add(""String_Node_Str"");
        add(last,Context.PRESERVE_BLOCK);
      }
      break;
    }
case Token.CATCH:
  Preconditions.checkState(childCount == 2);
cc.maybeInsertSpace();
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(last,Context.PRESERVE_BLOCK);
break;
case Token.THROW:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(first);
cc.endStatement(true);
break;
case Token.RETURN:
add(""String_Node_Str"");
if (childCount == 1) {
cc.maybeInsertSpace();
add(first);
}
 else {
Preconditions.checkState(childCount == 0);
}
cc.endStatement();
break;
case Token.VAR:
if (first != null) {
add(""String_Node_Str"");
addList(first,false,getContextForNoInOperator(context),""String_Node_Str"");
}
break;
case Token.CONST:
add(""String_Node_Str"");
addList(first,false,getContextForNoInOperator(context),""String_Node_Str"");
break;
case Token.LET:
add(""String_Node_Str"");
addList(first,false,getContextForNoInOperator(context),""String_Node_Str"");
break;
case Token.LABEL_NAME:
Preconditions.checkState(!n.getString().isEmpty());
addIdentifier(n.getString());
break;
case Token.NAME:
addIdentifier(n.getString());
maybeAddOptional(n);
maybeAddTypeDecl(n);
if (first != null && !first.isEmpty()) {
Preconditions.checkState(childCount == 1);
cc.addOp(""String_Node_Str"",true);
if (first.isComma()) {
addExpr(first,NodeUtil.precedence(Token.ASSIGN),Context.OTHER);
}
 else {
addExpr(first,0,getContextForNoInOperator(context));
}
}
break;
case Token.ARRAYLIT:
add(""String_Node_Str"");
addArrayList(first);
add(""String_Node_Str"");
break;
case Token.ARRAY_PATTERN:
addArrayPattern(n);
maybeAddTypeDecl(n);
break;
case Token.PARAM_LIST:
add(""String_Node_Str"");
addList(first);
add(""String_Node_Str"");
break;
case Token.DEFAULT_VALUE:
add(first);
maybeAddTypeDecl(n);
cc.addOp(""String_Node_Str"",true);
add(first.getNext());
break;
case Token.COMMA:
Preconditions.checkState(childCount == 2);
unrollBinaryOperator(n,Token.COMMA,""String_Node_Str"",context,getContextForNoInOperator(context),0,0);
break;
case Token.NUMBER:
Preconditions.checkState(childCount == 0);
cc.addNumber(n.getDouble());
break;
case Token.TYPEOF:
case Token.VOID:
case Token.NOT:
case Token.BITNOT:
case Token.POS:
{
Preconditions.checkState(childCount == 1);
cc.addOp(NodeUtil.opToStrNoFail(type),false);
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
break;
}
case Token.NEG:
{
Preconditions.checkState(childCount == 1);
if (n.getFirstChild().isNumber()) {
cc.addNumber(-n.getFirstChild().getDouble());
}
 else {
cc.addOp(NodeUtil.opToStrNoFail(type),false);
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
}
break;
}
case Token.HOOK:
{
Preconditions.checkState(childCount == 3);
int p=NodeUtil.precedence(type);
Context rhsContext=getContextForNoInOperator(context);
addExpr(first,p + 1,context);
cc.addOp(""String_Node_Str"",true);
addExpr(first.getNext(),1,rhsContext);
cc.addOp(""String_Node_Str"",true);
addExpr(last,1,rhsContext);
break;
}
case Token.REGEXP:
if (!first.isString() || !last.isString()) {
throw new Error(""String_Node_Str"");
}
String regexp=regexpEscape(first.getString(),outputCharsetEncoder);
if (childCount == 2) {
add(regexp + last.getString());
}
 else {
Preconditions.checkState(childCount == 1);
add(regexp);
}
break;
case Token.FUNCTION:
{
if (n.getClass() != Node.class) {
throw new Error(""String_Node_Str"");
}
Preconditions.checkState(childCount == 3);
boolean isArrow=n.isArrowFunction();
boolean notSingleExpr=n.getParent() == null || !n.getParent().isExprResult();
boolean funcNeedsParens=(context == Context.START_OF_EXPR) && (!isArrow || notSingleExpr);
if (funcNeedsParens) {
add(""String_Node_Str"");
}
if (!isArrow) {
add(""String_Node_Str"");
}
if (n.isGeneratorFunction()) {
add(""String_Node_Str"");
if (!first.getString().isEmpty()) {
cc.maybeInsertSpace();
}
}
add(first);
maybeAddGenericTypes(first);
add(first.getNext());
maybeAddTypeDecl(n);
if (isArrow) {
cc.addOp(""String_Node_Str"",true);
}
add(last,Context.PRESERVE_BLOCK);
cc.endFunction(context == Context.STATEMENT);
if (funcNeedsParens) {
add(""String_Node_Str"");
}
break;
}
case Token.REST:
add(""String_Node_Str"");
add(n.getString());
maybeAddTypeDecl(n);
break;
case Token.SPREAD:
add(""String_Node_Str"");
add(n.getFirstChild());
break;
case Token.EXPORT:
add(""String_Node_Str"");
if (n.getBooleanProp(Node.EXPORT_DEFAULT)) {
add(""String_Node_Str"");
}
if (n.getBooleanProp(Node.EXPORT_ALL_FROM)) {
add(""String_Node_Str"");
Preconditions.checkState(first != null && first.isEmpty());
}
 else {
add(first);
}
if (childCount == 2) {
add(""String_Node_Str"");
add(last);
}
cc.endStatement();
break;
case Token.MODULE:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(last);
cc.endStatement();
break;
case Token.IMPORT:
add(""String_Node_Str"");
Node second=first.getNext();
if (!first.isEmpty()) {
add(first);
if (!second.isEmpty()) {
cc.listSeparator();
}
}
if (!second.isEmpty()) {
add(second);
}
if (!first.isEmpty() || !second.isEmpty()) {
add(""String_Node_Str"");
}
add(last);
cc.endStatement();
break;
case Token.EXPORT_SPECS:
case Token.IMPORT_SPECS:
add(""String_Node_Str"");
for (Node c=first; c != null; c=c.getNext()) {
if (c != first) {
cc.listSeparator();
}
add(c);
}
add(""String_Node_Str"");
break;
case Token.EXPORT_SPEC:
case Token.IMPORT_SPEC:
add(first);
if (first != last) {
add(""String_Node_Str"");
add(last);
}
break;
case Token.IMPORT_STAR:
add(""String_Node_Str"");
add(""String_Node_Str"");
add(n.getString());
break;
case Token.CLASS:
{
Preconditions.checkState(childCount == 3);
boolean classNeedsParens=(context == Context.START_OF_EXPR);
if (classNeedsParens) {
add(""String_Node_Str"");
}
Node name=first;
Node superClass=first.getNext();
Node members=last;
add(""String_Node_Str"");
if (!name.isEmpty()) {
add(name);
}
maybeAddGenericTypes(first);
if (!superClass.isEmpty()) {
add(""String_Node_Str"");
add(superClass);
}
Node interfaces=(Node)n.getProp(Node.IMPLEMENTS);
if (interfaces != null) {
add(""String_Node_Str"");
Node child=interfaces.getFirstChild();
add(child);
while ((child=child.getNext()) != null) {
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(child);
}
}
add(members);
cc.endClass(context == Context.STATEMENT);
if (classNeedsParens) {
add(""String_Node_Str"");
}
}
break;
case Token.CLASS_MEMBERS:
case Token.INTERFACE_MEMBERS:
cc.beginBlock();
for (Node c=first; c != null; c=c.getNext()) {
add(c);
cc.endLine();
}
cc.endBlock(false);
break;
case Token.ENUM_MEMBERS:
cc.beginBlock();
for (Node c=first; c != null; c=c.getNext()) {
add(c);
if (c.getNext() != null) {
add(""String_Node_Str"");
}
cc.endLine();
}
cc.endBlock(false);
break;
case Token.GETTER_DEF:
case Token.SETTER_DEF:
case Token.MEMBER_FUNCTION_DEF:
case Token.MEMBER_VARIABLE_DEF:
{
n.getParent().toStringTree();
Preconditions.checkState(n.getParent().isObjectLit() || n.getParent().isClassMembers() || n.getParent().isInterfaceMembers()|| n.getParent().isRecordType());
if (n.isStaticMember()) {
add(""String_Node_Str"");
}
if (!n.isMemberVariableDef() && n.getFirstChild().isGeneratorFunction()) {
Preconditions.checkState(type == Token.MEMBER_FUNCTION_DEF);
add(""String_Node_Str"");
}
switch (type) {
case Token.GETTER_DEF:
Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
add(""String_Node_Str"");
break;
case Token.SETTER_DEF:
Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
add(""String_Node_Str"");
break;
case Token.MEMBER_FUNCTION_DEF:
case Token.MEMBER_VARIABLE_DEF:
break;
}
String name=n.getString();
if (n.isMemberVariableDef()) {
add(n.getString());
maybeAddOptional(n);
maybeAddTypeDecl(n);
if (!n.getParent().isRecordType()) {
add(""String_Node_Str"");
}
}
 else {
Preconditions.checkState(childCount == 1);
Preconditions.checkState(first.isFunction());
Preconditions.checkState(first.getFirstChild().getString().isEmpty());
Node fn=first;
Node parameters=fn.getChildAtIndex(1);
Node body=fn.getLastChild();
if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) && NodeUtil.isLatin(name)) {
add(name);
maybeAddGenericTypes(fn.getFirstChild());
}
 else {
double d=getSimpleNumber(name);
if (!Double.isNaN(d)) {
cc.addNumber(d);
}
 else {
addJsString(n);
}
}
maybeAddOptional(fn);
add(parameters);
maybeAddTypeDecl(fn);
if (body.isEmpty()) {
add(""String_Node_Str"");
}
 else {
add(body,Context.PRESERVE_BLOCK);
}
}
break;
}
case Token.SCRIPT:
case Token.BLOCK:
{
if (n.getClass() != Node.class) {
throw new Error(""String_Node_Str"");
}
boolean preserveBlock=context == Context.PRESERVE_BLOCK;
if (preserveBlock) {
cc.beginBlock();
}
boolean preferLineBreaks=type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().isScript());
for (Node c=first; c != null; c=c.getNext()) {
add(c,Context.STATEMENT);
if (NodeUtil.isNameDeclaration(c)) {
cc.endStatement();
}
if (c.isFunction() || c.isClass()) {
cc.maybeLineBreak();
}
if (preferLineBreaks) {
cc.notePreferredLineBreak();
}
}
if (preserveBlock) {
cc.endBlock(cc.breakAfterBlockFor(n,context == Context.STATEMENT));
}
break;
}
case Token.FOR:
if (childCount == 4) {
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
if (NodeUtil.isNameDeclaration(first)) {
add(first,Context.IN_FOR_INIT_CLAUSE);
}
 else {
addExpr(first,0,Context.IN_FOR_INIT_CLAUSE);
}
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
add(first.getNext().getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
 else {
Preconditions.checkState(childCount == 3);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
break;
case Token.FOR_OF:
Preconditions.checkState(childCount == 3);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case Token.DO:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
addNonEmptyStatement(first,Context.OTHER,false);
cc.maybeInsertSpace();
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(last);
add(""String_Node_Str"");
cc.endStatement();
break;
case Token.WHILE:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case Token.EMPTY:
Preconditions.checkState(childCount == 0);
break;
case Token.GETPROP:
{
Preconditions.checkState(childCount == 2,""String_Node_Str"",childCount);
Preconditions.checkState(last.isString(),""String_Node_Str"");
boolean needsParens=(first.isNumber());
if (needsParens) {
add(""String_Node_Str"");
}
addExpr(first,NodeUtil.precedence(type),context);
if (needsParens) {
add(""String_Node_Str"");
}
if (this.languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(last.getString())) {
add(""String_Node_Str"");
add(last);
add(""String_Node_Str"");
}
 else {
add(""String_Node_Str"");
addIdentifier(last.getString());
}
break;
}
case Token.GETELEM:
Preconditions.checkState(childCount == 2,""String_Node_Str"",childCount);
addExpr(first,NodeUtil.precedence(type),context);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
break;
case Token.WITH:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case Token.INC:
case Token.DEC:
{
Preconditions.checkState(childCount == 1);
String o=type == Token.INC ? ""String_Node_Str"" : ""String_Node_Str"";
boolean postProp=n.getBooleanProp(Node.INCRDECR_PROP);
if (postProp) {
addExpr(first,NodeUtil.precedence(type),context);
cc.addOp(o,false);
}
 else {
cc.addOp(o,false);
add(first);
}
break;
}
case Token.CALL:
if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
add(""String_Node_Str"");
addExpr(first,NodeUtil.precedence(Token.COMMA),Context.OTHER);
add(""String_Node_Str"");
}
 else {
addExpr(first,NodeUtil.precedence(type),context);
}
Node args=first.getNext();
add(""String_Node_Str"");
addList(args);
add(""String_Node_Str"");
break;
case Token.IF:
boolean hasElse=childCount == 3;
boolean ambiguousElseClause=context == Context.BEFORE_DANGLING_ELSE && !hasElse;
if (ambiguousElseClause) {
cc.beginBlock();
}
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
if (childCount == 1) {
break;
}
if (hasElse) {
addNonEmptyStatement(first.getNext(),Context.BEFORE_DANGLING_ELSE,false);
cc.maybeInsertSpace();
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
 else {
addNonEmptyStatement(first.getNext(),Context.OTHER,false);
Preconditions.checkState(childCount == 2);
}
if (ambiguousElseClause) {
cc.endBlock();
}
break;
case Token.NULL:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case Token.THIS:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
break;
case Token.SUPER:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
break;
case Token.YIELD:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
cc.maybeInsertSpace();
if (n.isYieldFor()) {
add(""String_Node_Str"");
}
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
break;
case Token.FALSE:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case Token.TRUE:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case Token.CONTINUE:
Preconditions.checkState(childCount <= 1);
add(""String_Node_Str"");
if (childCount == 1) {
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
}
cc.endStatement();
break;
case Token.DEBUGGER:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
cc.endStatement();
break;
case Token.BREAK:
Preconditions.checkState(childCount <= 1);
add(""String_Node_Str"");
if (childCount == 1) {
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
}
cc.endStatement();
break;
case Token.EXPR_RESULT:
Preconditions.checkState(childCount == 1);
add(first,Context.START_OF_EXPR);
cc.endStatement();
break;
case Token.NEW:
add(""String_Node_Str"");
int precedence=NodeUtil.precedence(type);
if (NodeUtil.containsType(first,Token.CALL,NodeUtil.MATCH_NOT_FUNCTION)) {
precedence=NodeUtil.precedence(first.getType()) + 1;
}
addExpr(first,precedence,Context.OTHER);
Node next=first.getNext();
if (next != null) {
add(""String_Node_Str"");
addList(next);
add(""String_Node_Str"");
}
break;
case Token.STRING_KEY:
addStringKey(n);
break;
case Token.STRING:
Preconditions.checkState(childCount == 0,""String_Node_Str"");
if (n.getBooleanProp(Node.COOKED_STRING)) {
add(""String_Node_Str"" + n.getString() + ""String_Node_Str"");
}
 else {
addJsString(n);
}
break;
case Token.DELPROP:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
add(first);
break;
case Token.OBJECTLIT:
{
boolean needsParens=(context == Context.START_OF_EXPR);
if (needsParens) {
add(""String_Node_Str"");
}
add(""String_Node_Str"");
for (Node c=first; c != null; c=c.getNext()) {
if (c != first) {
cc.listSeparator();
}
Preconditions.checkState(c.isComputedProp() || c.isGetterDef() || c.isSetterDef()|| c.isStringKey()|| c.isMemberFunctionDef());
add(c);
}
add(""String_Node_Str"");
if (needsParens) {
add(""String_Node_Str"");
}
break;
}
case Token.COMPUTED_PROP:
if (n.getBooleanProp(Node.COMPUTED_PROP_GETTER)) {
add(""String_Node_Str"");
}
 else if (n.getBooleanProp(Node.COMPUTED_PROP_SETTER)) {
add(""String_Node_Str"");
}
 else if (last.getBooleanProp(Node.GENERATOR_FN)) {
add(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
maybeAddTypeDecl(n);
if (n.getBooleanProp(Node.COMPUTED_PROP_METHOD) || n.getBooleanProp(Node.COMPUTED_PROP_GETTER) || n.getBooleanProp(Node.COMPUTED_PROP_SETTER)) {
Node function=first.getNext();
Node params=function.getFirstChild().getNext();
Node body=function.getLastChild();
add(params);
add(body,Context.PRESERVE_BLOCK);
}
 else {
boolean isInClass=n.getParent().getType() == Token.CLASS_MEMBERS;
Node initializer=first.getNext();
if (initializer != null) {
Preconditions.checkState(!isInClass,""String_Node_Str"");
cc.addOp(""String_Node_Str"",false);
add(initializer);
}
 else {
Preconditions.checkState(n.getBooleanProp(Node.COMPUTED_PROP_VARIABLE));
}
if (isInClass) {
add(""String_Node_Str"");
}
}
break;
case Token.OBJECT_PATTERN:
addObjectPattern(n,context);
maybeAddTypeDecl(n);
break;
case Token.SWITCH:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
cc.beginBlock();
addAllSiblings(first.getNext());
cc.endBlock(context == Context.STATEMENT);
break;
case Token.CASE:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
add(first);
addCaseBody(last);
break;
case Token.DEFAULT_CASE:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
addCaseBody(first);
break;
case Token.LABEL:
Preconditions.checkState(childCount == 2);
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(first);
add(""String_Node_Str"");
if (!last.isBlock()) {
cc.maybeInsertSpace();
}
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),true);
break;
case Token.CAST:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
break;
case Token.TAGGED_TEMPLATELIT:
add(first,Context.START_OF_EXPR);
add(first.getNext());
break;
case Token.TEMPLATELIT:
add(""String_Node_Str"");
for (Node c=first; c != null; c=c.getNext()) {
if (c.isString()) {
add(c.getString());
}
 else {
cc.append(""String_Node_Str"");
add(c.getFirstChild(),Context.START_OF_EXPR);
add(""String_Node_Str"");
}
}
add(""String_Node_Str"");
break;
case Token.STRING_TYPE:
add(""String_Node_Str"");
break;
case Token.BOOLEAN_TYPE:
add(""String_Node_Str"");
break;
case Token.NUMBER_TYPE:
add(""String_Node_Str"");
break;
case Token.ANY_TYPE:
add(""String_Node_Str"");
break;
case Token.VOID_TYPE:
add(""String_Node_Str"");
break;
case Token.NAMED_TYPE:
add(first);
break;
case Token.ARRAY_TYPE:
addExpr(first,NodeUtil.precedence(Token.ARRAY_TYPE),context);
add(""String_Node_Str"");
break;
case Token.FUNCTION_TYPE:
Node returnType=first;
add(""String_Node_Str"");
addList(first.getNext());
add(""String_Node_Str"");
cc.addOp(""String_Node_Str"",true);
add(returnType);
break;
case Token.UNION_TYPE:
addList(first,""String_Node_Str"");
break;
case Token.RECORD_TYPE:
add(""String_Node_Str"");
addList(first,false,Context.OTHER,""String_Node_Str"");
add(""String_Node_Str"");
break;
case Token.PARAMETERIZED_TYPE:
add(first);
add(""String_Node_Str"");
addList(first.getNext());
add(""String_Node_Str"");
break;
case Token.GENERIC_TYPE_LIST:
add(""String_Node_Str"");
addList(first,false,Context.STATEMENT,""String_Node_Str"");
add(""String_Node_Str"");
break;
case Token.GENERIC_TYPE:
addIdentifier(n.getString());
if (n.hasChildren()) {
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(n.getFirstChild());
}
break;
case Token.INTERFACE:
{
Preconditions.checkState(childCount == 3);
Node name=first;
Node superTypes=first.getNext();
Node members=last;
add(""String_Node_Str"");
add(name);
maybeAddGenericTypes(name);
if (!superTypes.isEmpty()) {
add(""String_Node_Str"");
Node superType=superTypes.getFirstChild();
add(superType);
while ((superType=superType.getNext()) != null) {
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(superType);
}
}
add(members);
}
break;
case Token.ENUM:
{
Preconditions.checkState(childCount == 2);
Node name=first;
Node members=last;
add(""String_Node_Str"");
add(name);
add(members);
break;
}
case Token.TYPE_ALIAS:
add(""String_Node_Str"");
add(n.getString());
cc.addOp(""String_Node_Str"",true);
add(last);
cc.endStatement();
break;
case Token.DECLARE:
add(""String_Node_Str"");
add(first);
cc.endStatement();
break;
default :
throw new RuntimeException(""String_Node_Str"" + Token.name(type) + ""String_Node_Str""+ n.toStringTree());
}
cc.endSourceMapping(n);
}","void add(Node n,Context context){
  if (!cc.continueProcessing()) {
    return;
  }
  if (preserveTypeAnnotations && n.getJSDocInfo() != null) {
    add(JSDocInfoPrinter.print(n.getJSDocInfo()));
  }
  int type=n.getType();
  String opstr=NodeUtil.opToStr(type);
  int childCount=n.getChildCount();
  Node first=n.getFirstChild();
  Node last=n.getLastChild();
  if (opstr != null && first != last) {
    Preconditions.checkState(childCount == 2,""String_Node_Str"",opstr,childCount);
    int p=NodeUtil.precedence(type);
    Context rhsContext=getContextForNoInOperator(context);
    if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
      addExpr(first,p,context);
      cc.addOp(opstr,true);
      addExpr(last,p,rhsContext);
    }
 else {
      unrollBinaryOperator(n,type,opstr,context,rhsContext,p,p + 1);
    }
    return;
  }
  cc.startSourceMapping(n);
switch (type) {
case Token.TRY:
{
      Preconditions.checkState(first.getNext().isBlock() && !first.getNext().hasMoreThanOneChild());
      Preconditions.checkState(childCount >= 2 && childCount <= 3);
      add(""String_Node_Str"");
      add(first,Context.PRESERVE_BLOCK);
      Node catchblock=first.getNext().getFirstChild();
      if (catchblock != null) {
        add(catchblock);
      }
      if (childCount == 3) {
        cc.maybeInsertSpace();
        add(""String_Node_Str"");
        add(last,Context.PRESERVE_BLOCK);
      }
      break;
    }
case Token.CATCH:
  Preconditions.checkState(childCount == 2);
cc.maybeInsertSpace();
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(last,Context.PRESERVE_BLOCK);
break;
case Token.THROW:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(first);
cc.endStatement(true);
break;
case Token.RETURN:
add(""String_Node_Str"");
if (childCount == 1) {
cc.maybeInsertSpace();
add(first);
}
 else {
Preconditions.checkState(childCount == 0);
}
cc.endStatement();
break;
case Token.VAR:
if (first != null) {
add(""String_Node_Str"");
addList(first,false,getContextForNoInOperator(context),""String_Node_Str"");
}
break;
case Token.CONST:
add(""String_Node_Str"");
addList(first,false,getContextForNoInOperator(context),""String_Node_Str"");
break;
case Token.LET:
add(""String_Node_Str"");
addList(first,false,getContextForNoInOperator(context),""String_Node_Str"");
break;
case Token.LABEL_NAME:
Preconditions.checkState(!n.getString().isEmpty());
addIdentifier(n.getString());
break;
case Token.NAME:
addIdentifier(n.getString());
maybeAddOptional(n);
maybeAddTypeDecl(n);
if (first != null && !first.isEmpty()) {
Preconditions.checkState(childCount == 1);
cc.addOp(""String_Node_Str"",true);
if (first.isComma()) {
addExpr(first,NodeUtil.precedence(Token.ASSIGN),Context.OTHER);
}
 else {
addExpr(first,0,getContextForNoInOperator(context));
}
}
break;
case Token.ARRAYLIT:
add(""String_Node_Str"");
addArrayList(first);
add(""String_Node_Str"");
break;
case Token.ARRAY_PATTERN:
addArrayPattern(n);
maybeAddTypeDecl(n);
break;
case Token.PARAM_LIST:
add(""String_Node_Str"");
addList(first);
add(""String_Node_Str"");
break;
case Token.DEFAULT_VALUE:
add(first);
maybeAddTypeDecl(n);
cc.addOp(""String_Node_Str"",true);
add(first.getNext());
break;
case Token.COMMA:
Preconditions.checkState(childCount == 2);
unrollBinaryOperator(n,Token.COMMA,""String_Node_Str"",context,getContextForNoInOperator(context),0,0);
break;
case Token.NUMBER:
Preconditions.checkState(childCount == 0);
cc.addNumber(n.getDouble());
break;
case Token.TYPEOF:
case Token.VOID:
case Token.NOT:
case Token.BITNOT:
case Token.POS:
{
Preconditions.checkState(childCount == 1);
cc.addOp(NodeUtil.opToStrNoFail(type),false);
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
break;
}
case Token.NEG:
{
Preconditions.checkState(childCount == 1);
if (n.getFirstChild().isNumber()) {
cc.addNumber(-n.getFirstChild().getDouble());
}
 else {
cc.addOp(NodeUtil.opToStrNoFail(type),false);
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
}
break;
}
case Token.HOOK:
{
Preconditions.checkState(childCount == 3);
int p=NodeUtil.precedence(type);
Context rhsContext=getContextForNoInOperator(context);
addExpr(first,p + 1,context);
cc.addOp(""String_Node_Str"",true);
addExpr(first.getNext(),1,rhsContext);
cc.addOp(""String_Node_Str"",true);
addExpr(last,1,rhsContext);
break;
}
case Token.REGEXP:
if (!first.isString() || !last.isString()) {
throw new Error(""String_Node_Str"");
}
String regexp=regexpEscape(first.getString(),outputCharsetEncoder);
if (childCount == 2) {
add(regexp + last.getString());
}
 else {
Preconditions.checkState(childCount == 1);
add(regexp);
}
break;
case Token.FUNCTION:
{
if (n.getClass() != Node.class) {
throw new Error(""String_Node_Str"");
}
Preconditions.checkState(childCount == 3);
if (n.isArrowFunction()) {
addArrowFunction(n,first,last,context);
}
 else {
addFunction(n,first,last,context);
}
break;
}
case Token.REST:
add(""String_Node_Str"");
add(n.getString());
maybeAddTypeDecl(n);
break;
case Token.SPREAD:
add(""String_Node_Str"");
add(n.getFirstChild());
break;
case Token.EXPORT:
add(""String_Node_Str"");
if (n.getBooleanProp(Node.EXPORT_DEFAULT)) {
add(""String_Node_Str"");
}
if (n.getBooleanProp(Node.EXPORT_ALL_FROM)) {
add(""String_Node_Str"");
Preconditions.checkState(first != null && first.isEmpty());
}
 else {
add(first);
}
if (childCount == 2) {
add(""String_Node_Str"");
add(last);
}
cc.endStatement();
break;
case Token.MODULE:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(last);
cc.endStatement();
break;
case Token.IMPORT:
add(""String_Node_Str"");
Node second=first.getNext();
if (!first.isEmpty()) {
add(first);
if (!second.isEmpty()) {
cc.listSeparator();
}
}
if (!second.isEmpty()) {
add(second);
}
if (!first.isEmpty() || !second.isEmpty()) {
add(""String_Node_Str"");
}
add(last);
cc.endStatement();
break;
case Token.EXPORT_SPECS:
case Token.IMPORT_SPECS:
add(""String_Node_Str"");
for (Node c=first; c != null; c=c.getNext()) {
if (c != first) {
cc.listSeparator();
}
add(c);
}
add(""String_Node_Str"");
break;
case Token.EXPORT_SPEC:
case Token.IMPORT_SPEC:
add(first);
if (first != last) {
add(""String_Node_Str"");
add(last);
}
break;
case Token.IMPORT_STAR:
add(""String_Node_Str"");
add(""String_Node_Str"");
add(n.getString());
break;
case Token.CLASS:
{
Preconditions.checkState(childCount == 3);
boolean classNeedsParens=(context == Context.START_OF_EXPR);
if (classNeedsParens) {
add(""String_Node_Str"");
}
Node name=first;
Node superClass=first.getNext();
Node members=last;
add(""String_Node_Str"");
if (!name.isEmpty()) {
add(name);
}
maybeAddGenericTypes(first);
if (!superClass.isEmpty()) {
add(""String_Node_Str"");
add(superClass);
}
Node interfaces=(Node)n.getProp(Node.IMPLEMENTS);
if (interfaces != null) {
add(""String_Node_Str"");
Node child=interfaces.getFirstChild();
add(child);
while ((child=child.getNext()) != null) {
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(child);
}
}
add(members);
cc.endClass(context == Context.STATEMENT);
if (classNeedsParens) {
add(""String_Node_Str"");
}
}
break;
case Token.CLASS_MEMBERS:
case Token.INTERFACE_MEMBERS:
cc.beginBlock();
for (Node c=first; c != null; c=c.getNext()) {
add(c);
cc.endLine();
}
cc.endBlock(false);
break;
case Token.ENUM_MEMBERS:
cc.beginBlock();
for (Node c=first; c != null; c=c.getNext()) {
add(c);
if (c.getNext() != null) {
add(""String_Node_Str"");
}
cc.endLine();
}
cc.endBlock(false);
break;
case Token.GETTER_DEF:
case Token.SETTER_DEF:
case Token.MEMBER_FUNCTION_DEF:
case Token.MEMBER_VARIABLE_DEF:
{
n.getParent().toStringTree();
Preconditions.checkState(n.getParent().isObjectLit() || n.getParent().isClassMembers() || n.getParent().isInterfaceMembers()|| n.getParent().isRecordType());
if (n.isStaticMember()) {
add(""String_Node_Str"");
}
if (!n.isMemberVariableDef() && n.getFirstChild().isGeneratorFunction()) {
Preconditions.checkState(type == Token.MEMBER_FUNCTION_DEF);
add(""String_Node_Str"");
}
switch (type) {
case Token.GETTER_DEF:
Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
add(""String_Node_Str"");
break;
case Token.SETTER_DEF:
Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
add(""String_Node_Str"");
break;
case Token.MEMBER_FUNCTION_DEF:
case Token.MEMBER_VARIABLE_DEF:
break;
}
String name=n.getString();
if (n.isMemberVariableDef()) {
add(n.getString());
maybeAddOptional(n);
maybeAddTypeDecl(n);
if (!n.getParent().isRecordType()) {
add(""String_Node_Str"");
}
}
 else {
Preconditions.checkState(childCount == 1);
Preconditions.checkState(first.isFunction());
Preconditions.checkState(first.getFirstChild().getString().isEmpty());
Node fn=first;
Node parameters=fn.getChildAtIndex(1);
Node body=fn.getLastChild();
if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) && NodeUtil.isLatin(name)) {
add(name);
maybeAddGenericTypes(fn.getFirstChild());
}
 else {
double d=getSimpleNumber(name);
if (!Double.isNaN(d)) {
cc.addNumber(d);
}
 else {
addJsString(n);
}
}
maybeAddOptional(fn);
add(parameters);
maybeAddTypeDecl(fn);
if (body.isEmpty()) {
add(""String_Node_Str"");
}
 else {
add(body,Context.PRESERVE_BLOCK);
}
}
break;
}
case Token.SCRIPT:
case Token.BLOCK:
{
if (n.getClass() != Node.class) {
throw new Error(""String_Node_Str"");
}
boolean preserveBlock=context == Context.PRESERVE_BLOCK;
if (preserveBlock) {
cc.beginBlock();
}
boolean preferLineBreaks=type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().isScript());
for (Node c=first; c != null; c=c.getNext()) {
add(c,Context.STATEMENT);
if (NodeUtil.isNameDeclaration(c)) {
cc.endStatement();
}
if (c.isFunction() || c.isClass()) {
cc.maybeLineBreak();
}
if (preferLineBreaks) {
cc.notePreferredLineBreak();
}
}
if (preserveBlock) {
cc.endBlock(cc.breakAfterBlockFor(n,context == Context.STATEMENT));
}
break;
}
case Token.FOR:
if (childCount == 4) {
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
if (NodeUtil.isNameDeclaration(first)) {
add(first,Context.IN_FOR_INIT_CLAUSE);
}
 else {
addExpr(first,0,Context.IN_FOR_INIT_CLAUSE);
}
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
add(first.getNext().getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
 else {
Preconditions.checkState(childCount == 3);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
break;
case Token.FOR_OF:
Preconditions.checkState(childCount == 3);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case Token.DO:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
addNonEmptyStatement(first,Context.OTHER,false);
cc.maybeInsertSpace();
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(last);
add(""String_Node_Str"");
cc.endStatement();
break;
case Token.WHILE:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case Token.EMPTY:
Preconditions.checkState(childCount == 0);
break;
case Token.GETPROP:
{
Preconditions.checkState(childCount == 2,""String_Node_Str"",childCount);
Preconditions.checkState(last.isString(),""String_Node_Str"");
boolean needsParens=(first.isNumber());
if (needsParens) {
add(""String_Node_Str"");
}
addExpr(first,NodeUtil.precedence(type),context);
if (needsParens) {
add(""String_Node_Str"");
}
if (this.languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(last.getString())) {
add(""String_Node_Str"");
add(last);
add(""String_Node_Str"");
}
 else {
add(""String_Node_Str"");
addIdentifier(last.getString());
}
break;
}
case Token.GETELEM:
Preconditions.checkState(childCount == 2,""String_Node_Str"",childCount);
addExpr(first,NodeUtil.precedence(type),context);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
break;
case Token.WITH:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case Token.INC:
case Token.DEC:
{
Preconditions.checkState(childCount == 1);
String o=type == Token.INC ? ""String_Node_Str"" : ""String_Node_Str"";
boolean postProp=n.getBooleanProp(Node.INCRDECR_PROP);
if (postProp) {
addExpr(first,NodeUtil.precedence(type),context);
cc.addOp(o,false);
}
 else {
cc.addOp(o,false);
add(first);
}
break;
}
case Token.CALL:
if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
add(""String_Node_Str"");
addExpr(first,NodeUtil.precedence(Token.COMMA),Context.OTHER);
add(""String_Node_Str"");
}
 else {
addExpr(first,NodeUtil.precedence(type),context);
}
Node args=first.getNext();
add(""String_Node_Str"");
addList(args);
add(""String_Node_Str"");
break;
case Token.IF:
boolean hasElse=childCount == 3;
boolean ambiguousElseClause=context == Context.BEFORE_DANGLING_ELSE && !hasElse;
if (ambiguousElseClause) {
cc.beginBlock();
}
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
if (childCount == 1) {
break;
}
if (hasElse) {
addNonEmptyStatement(first.getNext(),Context.BEFORE_DANGLING_ELSE,false);
cc.maybeInsertSpace();
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
 else {
addNonEmptyStatement(first.getNext(),Context.OTHER,false);
Preconditions.checkState(childCount == 2);
}
if (ambiguousElseClause) {
cc.endBlock();
}
break;
case Token.NULL:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case Token.THIS:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
break;
case Token.SUPER:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
break;
case Token.YIELD:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
cc.maybeInsertSpace();
if (n.isYieldFor()) {
add(""String_Node_Str"");
}
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
break;
case Token.FALSE:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case Token.TRUE:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case Token.CONTINUE:
Preconditions.checkState(childCount <= 1);
add(""String_Node_Str"");
if (childCount == 1) {
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
}
cc.endStatement();
break;
case Token.DEBUGGER:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
cc.endStatement();
break;
case Token.BREAK:
Preconditions.checkState(childCount <= 1);
add(""String_Node_Str"");
if (childCount == 1) {
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
}
cc.endStatement();
break;
case Token.EXPR_RESULT:
Preconditions.checkState(childCount == 1);
add(first,Context.START_OF_EXPR);
cc.endStatement();
break;
case Token.NEW:
add(""String_Node_Str"");
int precedence=NodeUtil.precedence(type);
if (NodeUtil.containsType(first,Token.CALL,NodeUtil.MATCH_NOT_FUNCTION)) {
precedence=NodeUtil.precedence(first.getType()) + 1;
}
addExpr(first,precedence,Context.OTHER);
Node next=first.getNext();
if (next != null) {
add(""String_Node_Str"");
addList(next);
add(""String_Node_Str"");
}
break;
case Token.STRING_KEY:
addStringKey(n);
break;
case Token.STRING:
Preconditions.checkState(childCount == 0,""String_Node_Str"");
if (n.getBooleanProp(Node.COOKED_STRING)) {
add(""String_Node_Str"" + n.getString() + ""String_Node_Str"");
}
 else {
addJsString(n);
}
break;
case Token.DELPROP:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
add(first);
break;
case Token.OBJECTLIT:
{
boolean needsParens=(context == Context.START_OF_EXPR);
if (needsParens) {
add(""String_Node_Str"");
}
add(""String_Node_Str"");
for (Node c=first; c != null; c=c.getNext()) {
if (c != first) {
cc.listSeparator();
}
Preconditions.checkState(c.isComputedProp() || c.isGetterDef() || c.isSetterDef()|| c.isStringKey()|| c.isMemberFunctionDef());
add(c);
}
add(""String_Node_Str"");
if (needsParens) {
add(""String_Node_Str"");
}
break;
}
case Token.COMPUTED_PROP:
if (n.getBooleanProp(Node.COMPUTED_PROP_GETTER)) {
add(""String_Node_Str"");
}
 else if (n.getBooleanProp(Node.COMPUTED_PROP_SETTER)) {
add(""String_Node_Str"");
}
 else if (last.getBooleanProp(Node.GENERATOR_FN)) {
add(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
maybeAddTypeDecl(n);
if (n.getBooleanProp(Node.COMPUTED_PROP_METHOD) || n.getBooleanProp(Node.COMPUTED_PROP_GETTER) || n.getBooleanProp(Node.COMPUTED_PROP_SETTER)) {
Node function=first.getNext();
Node params=function.getFirstChild().getNext();
Node body=function.getLastChild();
add(params);
add(body,Context.PRESERVE_BLOCK);
}
 else {
boolean isInClass=n.getParent().getType() == Token.CLASS_MEMBERS;
Node initializer=first.getNext();
if (initializer != null) {
Preconditions.checkState(!isInClass,""String_Node_Str"");
cc.addOp(""String_Node_Str"",false);
add(initializer);
}
 else {
Preconditions.checkState(n.getBooleanProp(Node.COMPUTED_PROP_VARIABLE));
}
if (isInClass) {
add(""String_Node_Str"");
}
}
break;
case Token.OBJECT_PATTERN:
addObjectPattern(n,context);
maybeAddTypeDecl(n);
break;
case Token.SWITCH:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
cc.beginBlock();
addAllSiblings(first.getNext());
cc.endBlock(context == Context.STATEMENT);
break;
case Token.CASE:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
add(first);
addCaseBody(last);
break;
case Token.DEFAULT_CASE:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
addCaseBody(first);
break;
case Token.LABEL:
Preconditions.checkState(childCount == 2);
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(first);
add(""String_Node_Str"");
if (!last.isBlock()) {
cc.maybeInsertSpace();
}
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),true);
break;
case Token.CAST:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
break;
case Token.TAGGED_TEMPLATELIT:
add(first,Context.START_OF_EXPR);
add(first.getNext());
break;
case Token.TEMPLATELIT:
add(""String_Node_Str"");
for (Node c=first; c != null; c=c.getNext()) {
if (c.isString()) {
add(c.getString());
}
 else {
cc.append(""String_Node_Str"");
add(c.getFirstChild(),Context.START_OF_EXPR);
add(""String_Node_Str"");
}
}
add(""String_Node_Str"");
break;
case Token.STRING_TYPE:
add(""String_Node_Str"");
break;
case Token.BOOLEAN_TYPE:
add(""String_Node_Str"");
break;
case Token.NUMBER_TYPE:
add(""String_Node_Str"");
break;
case Token.ANY_TYPE:
add(""String_Node_Str"");
break;
case Token.VOID_TYPE:
add(""String_Node_Str"");
break;
case Token.NAMED_TYPE:
add(first);
break;
case Token.ARRAY_TYPE:
addExpr(first,NodeUtil.precedence(Token.ARRAY_TYPE),context);
add(""String_Node_Str"");
break;
case Token.FUNCTION_TYPE:
Node returnType=first;
add(""String_Node_Str"");
addList(first.getNext());
add(""String_Node_Str"");
cc.addOp(""String_Node_Str"",true);
add(returnType);
break;
case Token.UNION_TYPE:
addList(first,""String_Node_Str"");
break;
case Token.RECORD_TYPE:
add(""String_Node_Str"");
addList(first,false,Context.OTHER,""String_Node_Str"");
add(""String_Node_Str"");
break;
case Token.PARAMETERIZED_TYPE:
add(first);
add(""String_Node_Str"");
addList(first.getNext());
add(""String_Node_Str"");
break;
case Token.GENERIC_TYPE_LIST:
add(""String_Node_Str"");
addList(first,false,Context.STATEMENT,""String_Node_Str"");
add(""String_Node_Str"");
break;
case Token.GENERIC_TYPE:
addIdentifier(n.getString());
if (n.hasChildren()) {
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(n.getFirstChild());
}
break;
case Token.INTERFACE:
{
Preconditions.checkState(childCount == 3);
Node name=first;
Node superTypes=first.getNext();
Node members=last;
add(""String_Node_Str"");
add(name);
maybeAddGenericTypes(name);
if (!superTypes.isEmpty()) {
add(""String_Node_Str"");
Node superType=superTypes.getFirstChild();
add(superType);
while ((superType=superType.getNext()) != null) {
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(superType);
}
}
add(members);
}
break;
case Token.ENUM:
{
Preconditions.checkState(childCount == 2);
Node name=first;
Node members=last;
add(""String_Node_Str"");
add(name);
add(members);
break;
}
case Token.TYPE_ALIAS:
add(""String_Node_Str"");
add(n.getString());
cc.addOp(""String_Node_Str"",true);
add(last);
cc.endStatement();
break;
case Token.DECLARE:
add(""String_Node_Str"");
add(first);
cc.endStatement();
break;
default :
throw new RuntimeException(""String_Node_Str"" + Token.name(type) + ""String_Node_Str""+ n.toStringTree());
}
cc.endSourceMapping(n);
}",0.984162842687375
27517,"public void testArrowFunction(){
  languageMode=LanguageMode.ECMASCRIPT6;
  assertPrintSame(""String_Node_Str"");
  assertPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrintSame(""String_Node_Str"");
  assertPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrintSame(""String_Node_Str"");
  assertPrint(""String_Node_Str"",""String_Node_Str"");
}","public void testArrowFunction(){
  languageMode=LanguageMode.ECMASCRIPT6;
  assertPrintSame(""String_Node_Str"");
  assertPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrintSame(""String_Node_Str"");
  assertPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrintSame(""String_Node_Str"");
  assertPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrintSame(""String_Node_Str"");
  assertPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrint(""String_Node_Str"",""String_Node_Str"");
}",0.8482905982905983
27518,"/** 
 * If any of the variables are well-defined and alias other variables, mark them as aliasing candidates.
 */
private void collectAliasCandidates(NodeTraversal t,ReferenceMap referenceMap){
  if (mode != Mode.CONSTANTS_ONLY) {
    for (Iterator<Var> it=t.getScope().getVars(); it.hasNext(); ) {
      Var v=it.next();
      ReferenceCollection referenceInfo=referenceMap.getReferences(v);
      if (referenceInfo != null && referenceInfo.references.size() >= 2 && referenceInfo.isWellDefined() && referenceInfo.isAssignedOnceInLifetime()) {
        Reference init=referenceInfo.getInitializingReference();
        Node value=init.getAssignedValue();
        if (value != null && value.isName()) {
          aliasCandidates.put(value,new AliasCandidate(v,referenceInfo));
        }
      }
    }
  }
}","/** 
 * If any of the variables are well-defined and alias other variables, mark them as aliasing candidates.
 */
private void collectAliasCandidates(NodeTraversal t,ReferenceMap referenceMap){
  if (mode != Mode.CONSTANTS_ONLY) {
    for (Iterator<Var> it=t.getScope().getVars(); it.hasNext(); ) {
      Var v=it.next();
      ReferenceCollection referenceInfo=referenceMap.getReferences(v);
      if (referenceInfo != null && referenceInfo.references.size() >= 2 && referenceInfo.isWellDefined() && referenceInfo.isAssignedOnceInLifetime()) {
        Reference init=referenceInfo.getInitializingReference();
        Node value=init.getAssignedValue();
        if (value != null && value.isName() && !value.getString().equals(v.getName())) {
          aliasCandidates.put(value,new AliasCandidate(v,referenceInfo));
        }
      }
    }
  }
}",0.9745454545454544
27519,"private void visitPrototypePropertyDeclaration(Node getProp){
  Preconditions.checkArgument(getProp.isGetProp());
  Node parent=getProp.getParent();
  Node initializer=parent.isAssign() ? parent.getLastChild() : null;
  Node ctorNameNode=NodeUtil.getPrototypeClassName(getProp);
  QualifiedName ctorQname=QualifiedName.fromNode(ctorNameNode);
  RawNominalType rawType=currentScope.getNominalType(ctorQname);
  if (rawType == null) {
    if (initializer != null && initializer.isFunction()) {
      visitFunctionLate(initializer,null);
    }
    return;
  }
  if (initializer != null && initializer.isFunction()) {
    parent.putBooleanProp(Node.ANALYZED_DURING_GTI,true);
  }
  if (!currentScope.isDefined(ctorNameNode)) {
    warnings.add(JSError.make(getProp,CTOR_IN_DIFFERENT_SCOPE));
    if (initializer != null && initializer.isFunction()) {
      visitFunctionLate(initializer,rawType);
    }
    return;
  }
  mayWarnAboutInterfacePropInit(rawType,initializer);
  String pname=NodeUtil.getPrototypePropertyName(getProp);
  mayAddPropToPrototype(rawType,pname,getProp,initializer);
}","private void visitPrototypePropertyDeclaration(Node getProp){
  Preconditions.checkArgument(getProp.isGetProp());
  Node parent=getProp.getParent();
  Node initializer=parent.isAssign() ? parent.getLastChild() : null;
  Node ctorNameNode=NodeUtil.getPrototypeClassName(getProp);
  QualifiedName ctorQname=QualifiedName.fromNode(ctorNameNode);
  RawNominalType rawType=currentScope.getNominalType(ctorQname);
  if (rawType == null) {
    if (initializer != null && initializer.isFunction()) {
      visitFunctionLate(initializer,null);
    }
    return;
  }
  if (initializer != null && initializer.isFunction()) {
    parent.putBooleanProp(Node.ANALYZED_DURING_GTI,true);
  }
  if (!currentScope.isDefined(ctorNameNode)) {
    warnings.add(JSError.make(getProp,CTOR_IN_DIFFERENT_SCOPE));
    if (initializer != null && initializer.isFunction()) {
      visitFunctionLate(initializer,rawType);
    }
    return;
  }
  mayWarnAboutInterfacePropInit(rawType,initializer);
  mayAddPropToPrototype(rawType,getProp.getLastChild().getString(),getProp,initializer);
}",0.9543761638733704
27520,"private static boolean isAllowedToNotReturn(Scope methodScope){
  Node fn=methodScope.getRoot();
  if (fn.isFromExterns()) {
    return true;
  }
  if (!NodeUtil.isPrototypeMethod(fn)) {
    return false;
  }
  String typeName=NodeUtil.getRootOfQualifiedName(fn.getParent().getFirstChild()).getString();
  JSType t=methodScope.getDeclaredTypeOf(typeName);
  return t != null && t.isInterfaceDefinition();
}","private static boolean isAllowedToNotReturn(Scope methodScope){
  Node fn=methodScope.getRoot();
  if (fn.isFromExterns()) {
    return true;
  }
  if (!NodeUtil.isPrototypeMethod(fn)) {
    return false;
  }
  JSType maybeInterface;
  Node ntQnameNode=NodeUtil.getPrototypeClassName(fn.getParent().getFirstChild());
  if (ntQnameNode.isName()) {
    maybeInterface=methodScope.getDeclaredTypeOf(ntQnameNode.getString());
  }
 else {
    QualifiedName ntQname=QualifiedName.fromNode(ntQnameNode);
    JSType rootNamespace=methodScope.getDeclaredTypeOf(ntQname.getLeftmostName());
    maybeInterface=rootNamespace == null ? null : rootNamespace.getProp(ntQname.getAllButLeftmost());
  }
  return maybeInterface != null && maybeInterface.isInterfaceDefinition();
}",0.4811643835616438
27521,"private boolean matchesNodeShape(Node template,Node ast){
  if (isTemplateParameterNode(template)) {
    return !NodeUtil.isStatement(ast);
  }
 else   if (isTemplateLocalNameNode(template)) {
    if (!ast.isName()) {
      return false;
    }
  }
 else   if (!template.isEquivalentToShallow(ast)) {
    return false;
  }
  Node templateChild=template.getFirstChild();
  Node astChild=ast.getFirstChild();
  while (templateChild != null) {
    if (!matchesNodeShape(templateChild,astChild)) {
      return false;
    }
    templateChild=templateChild.getNext();
    astChild=astChild.getNext();
  }
  return true;
}","private boolean matchesNodeShape(Node template,Node ast){
  if (isTemplateParameterNode(template)) {
    return !NodeUtil.isStatement(ast);
  }
 else   if (isTemplateLocalNameNode(template)) {
    if (!ast.isName()) {
      return false;
    }
  }
 else   if (template.isCall()) {
    if (ast == null || !ast.isCall() || ast.getChildCount() != template.getChildCount()) {
      return false;
    }
  }
 else   if (!template.isEquivalentToShallow(ast)) {
    return false;
  }
  Node templateChild=template.getFirstChild();
  Node astChild=ast.getFirstChild();
  while (templateChild != null) {
    if (!matchesNodeShape(templateChild,astChild)) {
      return false;
    }
    templateChild=templateChild.getNext();
    astChild=astChild.getNext();
  }
  return true;
}",0.888728323699422
27522,"/** 
 * Transforms the template node to a replacement node by mapping the template names to the ones that were matched against in the JsSourceMatcher.
 */
private Node transformNode(Node templateNode,Map<String,Node> templateNodeToMatchMap){
  Node clone=templateNode.cloneNode();
  if (templateNode.isName()) {
    String name=templateNode.getString();
    if (templateNodeToMatchMap.containsKey(name)) {
      Node templateMatch=templateNodeToMatchMap.get(name);
      Preconditions.checkNotNull(templateMatch,""String_Node_Str"",name);
      if (templateNode.getParent().isVar()) {
        clone.setString(templateMatch.getString());
      }
 else {
        return templateMatch.cloneTree();
      }
    }
  }
  for (  Node child : templateNode.children()) {
    clone.addChildToBack(transformNode(child,templateNodeToMatchMap));
  }
  return clone;
}","/** 
 * Transforms the template node to a replacement node by mapping the template names to the ones that were matched against in the JsSourceMatcher.
 */
private Node transformNode(Node templateNode,Map<String,Node> templateNodeToMatchMap){
  Node clone=templateNode.cloneNode();
  if (templateNode.isName()) {
    String name=templateNode.getString();
    if (templateNodeToMatchMap.containsKey(name)) {
      Node templateMatch=templateNodeToMatchMap.get(name);
      Preconditions.checkNotNull(templateMatch,""String_Node_Str"",name);
      if (templateNode.getParent().isVar()) {
        clone.setString(templateMatch.getString());
      }
 else {
        return templateMatch.cloneTree();
      }
    }
  }
 else   if (templateNode.isCall() && templateNode.getBooleanProp(Node.FREE_CALL) && templateNode.getFirstChild().isName()) {
    String name=templateNode.getFirstChild().getString();
    if (templateNodeToMatchMap.containsKey(name)) {
      clone.putBooleanProp(Node.FREE_CALL,false);
    }
  }
  for (  Node child : templateNode.children()) {
    clone.addChildToBack(transformNode(child,templateNodeToMatchMap));
  }
  return clone;
}",0.8514257128564282
27523,"private void visitOtherPropertyDeclaration(Node getProp){
  Preconditions.checkArgument(getProp.isGetProp());
  if (isAnnotatedAsConst(getProp)) {
    warnings.add(JSError.make(getProp,MISPLACED_CONST_ANNOTATION));
  }
  RawNominalType rawType=getRawTypeFromJSType(simpleInferExprType(getProp.getFirstChild()));
  if (rawType == null) {
    return;
  }
  String pname=getProp.getLastChild().getString();
  JSType declType=getDeclaredTypeOfNode(NodeUtil.getBestJSDocInfo(getProp),currentScope);
  if (declType != null) {
    declType=declType.substituteGenericsWithUnknown();
    if (mayWarnAboutExistingProp(rawType,pname,getProp,declType)) {
      return;
    }
    rawType.addPropertyWhichMayNotBeOnAllInstances(pname,declType);
  }
 else   if (!rawType.mayHaveProp(pname)) {
    rawType.addPropertyWhichMayNotBeOnAllInstances(pname,null);
  }
}","private void visitOtherPropertyDeclaration(Node getProp){
  Preconditions.checkArgument(getProp.isGetProp());
  if (isAnnotatedAsConst(getProp)) {
    warnings.add(JSError.make(getProp,MISPLACED_CONST_ANNOTATION));
  }
  JSType recvType=simpleInferExprType(getProp.getFirstChild());
  if (recvType == null) {
    return;
  }
  NominalType nt=recvType.getNominalTypeIfSingletonObj();
  if (nt == null || nt.equals(commonTypes.getObjectType())) {
    return;
  }
  RawNominalType rawType=nt.getRawNominalType();
  String pname=getProp.getLastChild().getString();
  JSType declType=getDeclaredTypeOfNode(NodeUtil.getBestJSDocInfo(getProp),currentScope);
  if (declType != null) {
    declType=declType.substituteGenericsWithUnknown();
    if (mayWarnAboutExistingProp(rawType,pname,getProp,declType)) {
      return;
    }
    rawType.addPropertyWhichMayNotBeOnAllInstances(pname,declType);
  }
 else   if (!rawType.mayHaveProp(pname)) {
    rawType.addPropertyWhichMayNotBeOnAllInstances(pname,null);
  }
}",0.8708806050783361
27524,"public NominalType getNominalType(){
  return nominalType;
}","NominalType getNominalType(){
  return this.nominalType == null ? ObjectType.builtinObject : this.nominalType;
}",0.6162790697674418
27525,"public void testInvalidThisReference(){
  typeCheck(""String_Node_Str"",CheckGlobalThis.GLOBAL_THIS);
  typeCheck(""String_Node_Str"");
  typeCheck(""String_Node_Str"");
  typeCheck(""String_Node_Str"",CheckGlobalThis.GLOBAL_THIS);
  typeCheck(""String_Node_Str"",CheckGlobalThis.GLOBAL_THIS);
  typeCheck(""String_Node_Str"",CheckGlobalThis.GLOBAL_THIS);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),CheckGlobalThis.GLOBAL_THIS);
}","public void testInvalidThisReference(){
  typeCheck(""String_Node_Str"",CheckGlobalThis.GLOBAL_THIS);
  typeCheck(""String_Node_Str"");
  typeCheck(""String_Node_Str"");
  typeCheck(""String_Node_Str"",CheckGlobalThis.GLOBAL_THIS);
  typeCheck(""String_Node_Str"",CheckGlobalThis.GLOBAL_THIS);
  typeCheck(""String_Node_Str"",CheckGlobalThis.GLOBAL_THIS);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),CheckGlobalThis.GLOBAL_THIS);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.9110378912685336
27526,"/** 
 * Classes are processed in 3 phases: <ol> <li>The class name is extracted. <li>Class members are processed and rewritten. <li>The constructor is built. </ol>
 */
private void visitClass(Node classNode,Node parent){
  checkClassReassignment(classNode);
  ClassDeclarationMetadata metadata=ClassDeclarationMetadata.create(classNode,parent);
  if (metadata == null || metadata.fullClassName == null) {
    cannotConvert(parent,""String_Node_Str"" + ""String_Node_Str"");
    return;
  }
  if (metadata.hasSuperClass() && !metadata.superClassNameNode.isQualifiedName()) {
    compiler.report(JSError.make(metadata.superClassNameNode,DYNAMIC_EXTENDS_TYPE));
    return;
  }
  boolean useUnique=NodeUtil.isStatement(classNode) && !NodeUtil.isInFunction(classNode);
  String uniqueFullClassName=useUnique ? getUniqueClassName(metadata.fullClassName) : metadata.fullClassName;
  Node classNameAccess=NodeUtil.newQName(compiler,uniqueFullClassName);
  Node prototypeAccess=NodeUtil.newPropertyAccess(compiler,classNameAccess,""String_Node_Str"");
  Preconditions.checkState(NodeUtil.isStatement(metadata.insertionPoint),""String_Node_Str"",metadata.insertionPoint);
  Node constructor=null;
  JSDocInfo ctorJSDocInfo=null;
  Node classMembers=classNode.getLastChild();
  Map<String,JSTypeExpression> membersToDeclare=new LinkedHashMap<>();
  for (  Node member : classMembers.children()) {
    if (member.isEmpty()) {
      continue;
    }
    Preconditions.checkState(member.isMemberFunctionDef() || member.isGetterDef() || member.isSetterDef()|| (member.isComputedProp() && !member.getBooleanProp(Node.COMPUTED_PROP_VARIABLE)),""String_Node_Str"",member);
    if (member.isGetterDef() || member.isSetterDef()) {
      if (member.isStaticMember()) {
        compiler.report(JSError.make(member,CANNOT_CONVERT_YET,""String_Node_Str""));
      }
      JSTypeExpression typeExpr=getTypeFromGetterOrSetter(member).clone();
      addToDefinePropertiesObject(metadata,member);
      JSTypeExpression existingType=membersToDeclare.get(member.getString());
      if (existingType != null && !existingType.equals(typeExpr)) {
        compiler.report(JSError.make(member,CONFLICTING_GETTER_SETTER_TYPE));
      }
 else {
        membersToDeclare.put(member.getString(),typeExpr);
      }
    }
 else     if (member.isMemberFunctionDef() && member.getString().equals(""String_Node_Str"")) {
      ctorJSDocInfo=member.getJSDocInfo();
      constructor=member.getFirstChild().detachFromParent();
      if (!metadata.anonymous) {
        constructor.replaceChild(constructor.getFirstChild(),metadata.classNameNode.cloneNode());
      }
    }
 else {
      Node qualifiedMemberAccess=getQualifiedMemberAccess(compiler,member,classNameAccess,prototypeAccess);
      Node method=member.getLastChild().detachFromParent();
      Node assign=IR.assign(qualifiedMemberAccess,method);
      assign.useSourceInfoIfMissingFromForTree(member);
      JSDocInfo info=member.getJSDocInfo();
      if (member.isStaticMember() && NodeUtil.referencesThis(assign.getLastChild())) {
        JSDocInfoBuilder memberDoc=JSDocInfoBuilder.maybeCopyFrom(info);
        memberDoc.recordThisType(new JSTypeExpression(new Node(Token.BANG,new Node(Token.QMARK)),member.getSourceFileName()));
        info=memberDoc.build();
      }
      if (info != null) {
        assign.setJSDocInfo(info);
      }
      Node newNode=NodeUtil.newExpr(assign);
      metadata.insertStaticMember(newNode);
    }
  }
  for (  Map.Entry<String,JSTypeExpression> entry : membersToDeclare.entrySet()) {
    String declaredMember=entry.getKey();
    Node declaration=IR.getprop(prototypeAccess.cloneTree(),IR.string(declaredMember));
    JSDocInfoBuilder declInfo=new JSDocInfoBuilder(true);
    declInfo.recordType(entry.getValue());
    declaration.setJSDocInfo(declInfo.build());
    metadata.insertStaticMember(IR.exprResult(declaration).useSourceInfoIfMissingFromForTree(classNode));
  }
  if (metadata.defineProperties.hasChildren()) {
    Node definePropsCall=IR.exprResult(IR.call(NodeUtil.newQName(compiler,""String_Node_Str""),prototypeAccess.cloneTree(),metadata.defineProperties));
    definePropsCall.useSourceInfoIfMissingFromForTree(classNode);
    metadata.insertStaticMember(definePropsCall);
  }
  Preconditions.checkNotNull(constructor);
  JSDocInfo classJSDoc=NodeUtil.getBestJSDocInfo(classNode);
  JSDocInfoBuilder newInfo=JSDocInfoBuilder.maybeCopyFrom(classJSDoc);
  newInfo.recordConstructor();
  if (metadata.hasSuperClass()) {
    String superClassString=metadata.superClassNameNode.getQualifiedName();
    if (newInfo.isInterfaceRecorded()) {
      newInfo.recordExtendedInterface(new JSTypeExpression(new Node(Token.BANG,IR.string(superClassString)),metadata.superClassNameNode.getSourceFileName()));
    }
 else {
      Node inherits=IR.call(NodeUtil.newQName(compiler,INHERITS),NodeUtil.newQName(compiler,metadata.fullClassName),NodeUtil.newQName(compiler,superClassString));
      Node inheritsCall=IR.exprResult(inherits);
      compiler.needsEs6Runtime=true;
      inheritsCall.useSourceInfoIfMissingFromForTree(classNode);
      Node enclosingStatement=NodeUtil.getEnclosingStatement(classNode);
      enclosingStatement.getParent().addChildAfter(inheritsCall,enclosingStatement);
      newInfo.recordBaseType(new JSTypeExpression(new Node(Token.BANG,IR.string(superClassString)),metadata.superClassNameNode.getSourceFileName()));
      Node copyProps=IR.call(NodeUtil.newQName(compiler,COPY_PROP),NodeUtil.newQName(compiler,metadata.fullClassName),NodeUtil.newQName(compiler,superClassString));
      compiler.needsEs6Runtime=true;
      copyProps.useSourceInfoIfMissingFromForTree(classNode);
      enclosingStatement.getParent().addChildAfter(IR.exprResult(copyProps).srcref(classNode),enclosingStatement);
    }
  }
  if (!newInfo.isUnrestrictedRecorded() && !newInfo.isDictRecorded() && !newInfo.isStructRecorded()) {
    newInfo.recordStruct();
  }
  if (ctorJSDocInfo != null) {
    newInfo.recordSuppressions(ctorJSDocInfo.getSuppressions());
    for (    String param : ctorJSDocInfo.getParameterNames()) {
      newInfo.recordParameter(param,ctorJSDocInfo.getParameterType(param));
    }
    newInfo.mergePropertyBitfieldFrom(ctorJSDocInfo);
  }
  if (NodeUtil.isStatement(classNode)) {
    constructor.getFirstChild().setString(""String_Node_Str"");
    Node ctorVar=IR.var(IR.name(metadata.fullClassName),constructor);
    ctorVar.useSourceInfoIfMissingFromForTree(classNode);
    parent.replaceChild(classNode,ctorVar);
  }
 else {
    parent.replaceChild(classNode,constructor);
  }
  if (NodeUtil.isStatement(constructor)) {
    constructor.setJSDocInfo(newInfo.build());
  }
 else   if (parent.isName()) {
    Node var=parent.getParent();
    var.setJSDocInfo(newInfo.build());
  }
 else   if (constructor.getParent().isName()) {
    Node var=constructor.getParent().getParent();
    var.setJSDocInfo(newInfo.build());
  }
 else   if (parent.isAssign()) {
    parent.setJSDocInfo(newInfo.build());
  }
 else {
    throw new IllegalStateException(""String_Node_Str"" + parent);
  }
  compiler.reportCodeChange();
}","/** 
 * Classes are processed in 3 phases: <ol> <li>The class name is extracted. <li>Class members are processed and rewritten. <li>The constructor is built. </ol>
 */
private void visitClass(Node classNode,Node parent){
  checkClassReassignment(classNode);
  ClassDeclarationMetadata metadata=ClassDeclarationMetadata.create(classNode,parent);
  if (metadata == null || metadata.fullClassName == null) {
    cannotConvert(parent,""String_Node_Str"" + ""String_Node_Str"");
    return;
  }
  if (metadata.hasSuperClass() && !metadata.superClassNameNode.isQualifiedName()) {
    compiler.report(JSError.make(metadata.superClassNameNode,DYNAMIC_EXTENDS_TYPE));
    return;
  }
  boolean useUnique=NodeUtil.isStatement(classNode) && !NodeUtil.isInFunction(classNode);
  String uniqueFullClassName=useUnique ? getUniqueClassName(metadata.fullClassName) : metadata.fullClassName;
  Node classNameAccess=NodeUtil.newQName(compiler,uniqueFullClassName);
  Node prototypeAccess=NodeUtil.newPropertyAccess(compiler,classNameAccess,""String_Node_Str"");
  Preconditions.checkState(NodeUtil.isStatement(metadata.insertionPoint),""String_Node_Str"",metadata.insertionPoint);
  Node constructor=null;
  JSDocInfo ctorJSDocInfo=null;
  Node classMembers=classNode.getLastChild();
  Map<String,JSTypeExpression> membersToDeclare=new LinkedHashMap<>();
  for (  Node member : classMembers.children()) {
    if (member.isEmpty()) {
      continue;
    }
    Preconditions.checkState(member.isMemberFunctionDef() || member.isGetterDef() || member.isSetterDef()|| (member.isComputedProp() && !member.getBooleanProp(Node.COMPUTED_PROP_VARIABLE)),""String_Node_Str"",member);
    if (member.isGetterDef() || member.isSetterDef()) {
      if (member.isStaticMember()) {
        compiler.report(JSError.make(member,CANNOT_CONVERT_YET,""String_Node_Str""));
      }
      JSTypeExpression typeExpr=getTypeFromGetterOrSetter(member).clone();
      addToDefinePropertiesObject(metadata,member);
      JSTypeExpression existingType=membersToDeclare.get(member.getString());
      if (existingType != null && !existingType.equals(typeExpr)) {
        compiler.report(JSError.make(member,CONFLICTING_GETTER_SETTER_TYPE,member.getString()));
      }
 else {
        membersToDeclare.put(member.getString(),typeExpr);
      }
    }
 else     if (member.isMemberFunctionDef() && member.getString().equals(""String_Node_Str"")) {
      ctorJSDocInfo=member.getJSDocInfo();
      constructor=member.getFirstChild().detachFromParent();
      if (!metadata.anonymous) {
        constructor.replaceChild(constructor.getFirstChild(),metadata.classNameNode.cloneNode());
      }
    }
 else {
      Node qualifiedMemberAccess=getQualifiedMemberAccess(compiler,member,classNameAccess,prototypeAccess);
      Node method=member.getLastChild().detachFromParent();
      Node assign=IR.assign(qualifiedMemberAccess,method);
      assign.useSourceInfoIfMissingFromForTree(member);
      JSDocInfo info=member.getJSDocInfo();
      if (member.isStaticMember() && NodeUtil.referencesThis(assign.getLastChild())) {
        JSDocInfoBuilder memberDoc=JSDocInfoBuilder.maybeCopyFrom(info);
        memberDoc.recordThisType(new JSTypeExpression(new Node(Token.BANG,new Node(Token.QMARK)),member.getSourceFileName()));
        info=memberDoc.build();
      }
      if (info != null) {
        assign.setJSDocInfo(info);
      }
      Node newNode=NodeUtil.newExpr(assign);
      metadata.insertStaticMember(newNode);
    }
  }
  for (  Map.Entry<String,JSTypeExpression> entry : membersToDeclare.entrySet()) {
    String declaredMember=entry.getKey();
    Node declaration=IR.getprop(prototypeAccess.cloneTree(),IR.string(declaredMember));
    JSDocInfoBuilder declInfo=new JSDocInfoBuilder(true);
    declInfo.recordType(entry.getValue());
    declaration.setJSDocInfo(declInfo.build());
    metadata.insertStaticMember(IR.exprResult(declaration).useSourceInfoIfMissingFromForTree(classNode));
  }
  if (metadata.defineProperties.hasChildren()) {
    Node definePropsCall=IR.exprResult(IR.call(NodeUtil.newQName(compiler,""String_Node_Str""),prototypeAccess.cloneTree(),metadata.defineProperties));
    definePropsCall.useSourceInfoIfMissingFromForTree(classNode);
    metadata.insertStaticMember(definePropsCall);
  }
  Preconditions.checkNotNull(constructor);
  JSDocInfo classJSDoc=NodeUtil.getBestJSDocInfo(classNode);
  JSDocInfoBuilder newInfo=JSDocInfoBuilder.maybeCopyFrom(classJSDoc);
  newInfo.recordConstructor();
  if (metadata.hasSuperClass()) {
    String superClassString=metadata.superClassNameNode.getQualifiedName();
    if (newInfo.isInterfaceRecorded()) {
      newInfo.recordExtendedInterface(new JSTypeExpression(new Node(Token.BANG,IR.string(superClassString)),metadata.superClassNameNode.getSourceFileName()));
    }
 else {
      Node inherits=IR.call(NodeUtil.newQName(compiler,INHERITS),NodeUtil.newQName(compiler,metadata.fullClassName),NodeUtil.newQName(compiler,superClassString));
      Node inheritsCall=IR.exprResult(inherits);
      compiler.needsEs6Runtime=true;
      inheritsCall.useSourceInfoIfMissingFromForTree(classNode);
      Node enclosingStatement=NodeUtil.getEnclosingStatement(classNode);
      enclosingStatement.getParent().addChildAfter(inheritsCall,enclosingStatement);
      newInfo.recordBaseType(new JSTypeExpression(new Node(Token.BANG,IR.string(superClassString)),metadata.superClassNameNode.getSourceFileName()));
      Node copyProps=IR.call(NodeUtil.newQName(compiler,COPY_PROP),NodeUtil.newQName(compiler,metadata.fullClassName),NodeUtil.newQName(compiler,superClassString));
      compiler.needsEs6Runtime=true;
      copyProps.useSourceInfoIfMissingFromForTree(classNode);
      enclosingStatement.getParent().addChildAfter(IR.exprResult(copyProps).srcref(classNode),enclosingStatement);
    }
  }
  if (!newInfo.isUnrestrictedRecorded() && !newInfo.isDictRecorded() && !newInfo.isStructRecorded()) {
    newInfo.recordStruct();
  }
  if (ctorJSDocInfo != null) {
    newInfo.recordSuppressions(ctorJSDocInfo.getSuppressions());
    for (    String param : ctorJSDocInfo.getParameterNames()) {
      newInfo.recordParameter(param,ctorJSDocInfo.getParameterType(param));
    }
    newInfo.mergePropertyBitfieldFrom(ctorJSDocInfo);
  }
  if (NodeUtil.isStatement(classNode)) {
    constructor.getFirstChild().setString(""String_Node_Str"");
    Node ctorVar=IR.var(IR.name(metadata.fullClassName),constructor);
    ctorVar.useSourceInfoIfMissingFromForTree(classNode);
    parent.replaceChild(classNode,ctorVar);
  }
 else {
    parent.replaceChild(classNode,constructor);
  }
  if (NodeUtil.isStatement(constructor)) {
    constructor.setJSDocInfo(newInfo.build());
  }
 else   if (parent.isName()) {
    Node var=parent.getParent();
    var.setJSDocInfo(newInfo.build());
  }
 else   if (constructor.getParent().isName()) {
    Node var=constructor.getParent().getParent();
    var.setJSDocInfo(newInfo.build());
  }
 else   if (parent.isAssign()) {
    parent.setJSDocInfo(newInfo.build());
  }
 else {
    throw new IllegalStateException(""String_Node_Str"" + parent);
  }
  compiler.reportCodeChange();
}",0.9986599901262432
27527,"private RawNominalType(Node defSite,String name,ImmutableList<String> typeParameters,boolean isInterface,ObjectKind objectKind){
  Preconditions.checkNotNull(objectKind);
  Preconditions.checkState(defSite == null || defSite.isFunction());
  if (typeParameters == null) {
    typeParameters=ImmutableList.of();
  }
  this.name=name;
  this.defSite=defSite;
  this.typeParameters=typeParameters;
  this.isInterface=isInterface;
  this.objectKind=objectKind;
  this.wrappedAsNominal=new NominalType(ImmutableMap.<String,JSType>of(),this);
  ObjectType objInstance=""String_Node_Str"".equals(name) ? ObjectType.fromFunction(FunctionType.TOP_FUNCTION,this.wrappedAsNominal) : ObjectType.fromNominalType(this.wrappedAsNominal);
  this.wrappedAsJSType=JSType.fromObjectType(objInstance);
  this.wrappedAsNullableJSType=JSType.join(JSType.NULL,this.wrappedAsJSType);
}","private RawNominalType(Node defSite,String name,ImmutableList<String> typeParameters,boolean isInterface,ObjectKind objectKind){
  Preconditions.checkNotNull(objectKind);
  Preconditions.checkState(defSite == null || defSite.isFunction());
  if (typeParameters == null) {
    typeParameters=ImmutableList.of();
  }
  this.name=name;
  this.defSite=defSite;
  this.typeParameters=typeParameters;
  this.isInterface=isInterface;
  this.objectKind=objectKind;
  this.wrappedAsNominal=new NominalType(ImmutableMap.<String,JSType>of(),this);
  ObjectType objInstance;
switch (name) {
case ""String_Node_Str"":
    objInstance=ObjectType.fromFunction(FunctionType.TOP_FUNCTION,this.wrappedAsNominal);
  break;
case ""String_Node_Str"":
objInstance=ObjectType.TOP_OBJECT;
break;
default :
objInstance=ObjectType.fromNominalType(this.wrappedAsNominal);
}
this.wrappedAsJSType=JSType.fromObjectType(objInstance);
this.wrappedAsNullableJSType=JSType.join(JSType.NULL,this.wrappedAsJSType);
}",0.9106753812636166
27528,"public void testObjectType(){
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str""));
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
}","public void testObjectType(){
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str""));
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"");
}",0.9550561797752808
27529,"private DeclaredFunctionType getDeclaredFunctionTypeFromContext(String functionName,Node declNode,Scope parentScope){
  Node parent=declNode.getParent();
  if (NodeUtil.isFunctionBind(parent) && !NodeUtil.isGoogPartial(parent)) {
    Node call=parent.isCall() ? parent : parent.getParent();
    Bind bindComponents=convention.describeFunctionBind(call,true,false);
    JSType recvType=simpleInferExprType(bindComponents.thisValue);
    if (recvType == null) {
      return null;
    }
    DeclaredFunctionType allButRecvType=typeParser.getFunctionType(null,functionName,declNode,null,null,parentScope);
    DeclaredFunctionType onlyHasRecvType=(new FunctionTypeBuilder()).addReceiverType(recvType.getNominalTypeIfSingletonObj()).buildDeclaration();
    return onlyHasRecvType.withTypeInfoFromSuper(allButRecvType,true);
  }
  if (parent.isCall() && declNode != parent.getFirstChild()) {
    DeclaredFunctionType calleeDeclType=getDeclaredFunctionTypeOfCalleeIfAny(parent.getFirstChild(),parentScope);
    if (calleeDeclType != null && !calleeDeclType.isGeneric()) {
      int index=parent.getIndexOfChild(declNode) - 1;
      JSType declTypeFromCallee=calleeDeclType.getFormalType(index);
      if (declTypeFromCallee != null) {
        DeclaredFunctionType t=computeFnDeclaredTypeFromCallee(declNode,declTypeFromCallee);
        if (t != null) {
          return t;
        }
      }
    }
  }
  return null;
}","private DeclaredFunctionType getDeclaredFunctionTypeFromContext(String functionName,Node declNode,Scope parentScope){
  Node parent=declNode.getParent();
  Node maybeBind=parent.isCall() ? parent.getFirstChild() : parent;
  if (NodeUtil.isFunctionBind(maybeBind) && !NodeUtil.isGoogPartial(maybeBind)) {
    Node call=maybeBind.getParent();
    Bind bindComponents=convention.describeFunctionBind(call,true,false);
    JSType recvType=simpleInferExprType(bindComponents.thisValue);
    if (recvType == null) {
      return null;
    }
    DeclaredFunctionType allButRecvType=typeParser.getFunctionType(null,functionName,declNode,null,null,parentScope);
    DeclaredFunctionType onlyHasRecvType=(new FunctionTypeBuilder()).addReceiverType(recvType.getNominalTypeIfSingletonObj()).buildDeclaration();
    return onlyHasRecvType.withTypeInfoFromSuper(allButRecvType,true);
  }
  if (parent.isCall() && declNode != parent.getFirstChild()) {
    DeclaredFunctionType calleeDeclType=getDeclaredFunctionTypeOfCalleeIfAny(parent.getFirstChild(),parentScope);
    if (calleeDeclType != null && !calleeDeclType.isGeneric()) {
      int index=parent.getIndexOfChild(declNode) - 1;
      JSType declTypeFromCallee=calleeDeclType.getFormalType(index);
      if (declTypeFromCallee != null) {
        DeclaredFunctionType t=computeFnDeclaredTypeFromCallee(declNode,declTypeFromCallee);
        if (t != null) {
          return t;
        }
      }
    }
  }
  return null;
}",0.9512534818941504
27530,"private EnvTypePair analyzeFunctionBindFwd(Node call,TypeEnv inEnv){
  Preconditions.checkArgument(call.isCall());
  Bind bindComponents=convention.describeFunctionBind(call,true,false);
  Node boundFunNode=bindComponents.target;
  EnvTypePair pair=analyzeExprFwd(boundFunNode,inEnv);
  TypeEnv env=pair.env;
  FunctionType boundFunType=pair.type.getFunTypeIfSingletonObj();
  if (!pair.type.isSubtypeOf(commonTypes.topFunction())) {
    warnings.add(JSError.make(boundFunNode,GOOG_BIND_EXPECTS_FUNCTION));
  }
  if (boundFunType == null || boundFunType.isTopFunction() || boundFunType.isQmarkFunction() || boundFunType.isLoose()) {
    return analyzeCallNodeArgsFwdWhenError(call,env);
  }
  if (boundFunType.isConstructor()) {
    warnings.add(JSError.make(call,CANNOT_BIND_CTOR));
    return new EnvTypePair(env,JSType.UNKNOWN);
  }
  if (NodeUtil.isGoogBind(call) && call.getChildCount() <= 2 || !NodeUtil.isGoogPartial(call) && call.getChildCount() == 1) {
    warnings.add(JSError.make(call,TypeCheck.WRONG_ARGUMENT_COUNT,getReadableCalleeName(call.getFirstChild()),""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  int maxArity=boundFunType.hasRestFormals() ? Integer.MAX_VALUE : boundFunType.getMaxArity();
  int numArgs=bindComponents.getBoundParameterCount();
  if (numArgs > maxArity) {
    warnings.add(JSError.make(call,TypeCheck.WRONG_ARGUMENT_COUNT,getReadableCalleeName(call.getFirstChild()),Integer.toString(numArgs),""String_Node_Str"",""String_Node_Str"" + maxArity));
    return analyzeCallNodeArgsFwdWhenError(call,inEnv);
  }
  if (boundFunType.isGeneric()) {
    Map<String,JSType> typeMap=calcTypeInstantiationFwd(call,bindComponents.parameters,boundFunType,env);
    boundFunType=boundFunType.instantiateGenerics(typeMap);
  }
  FunctionTypeBuilder builder=new FunctionTypeBuilder();
  Node receiver=bindComponents.thisValue;
  if (receiver != null) {
    JSType reqThisType=boundFunType.getThisType();
    if (reqThisType == null || boundFunType.isConstructor()) {
      reqThisType=JSType.join(JSType.NULL,JSType.TOP_OBJECT);
    }
    pair=analyzeExprFwd(receiver,env,reqThisType);
    env=pair.env;
    if (!pair.type.isSubtypeOf(reqThisType)) {
      warnings.add(JSError.make(call,INVALID_THIS_TYPE_IN_BIND,pair.type.toString(),reqThisType.toString()));
    }
  }
  env=analyzeCallNodeArgumentsFwd(call,bindComponents.parameters,boundFunType,new ArrayList<JSType>(),env);
  for (int j=numArgs; j < boundFunType.getMaxArityWithoutRestFormals(); j++) {
    JSType formalType=boundFunType.getFormalType(j);
    if (boundFunType.isRequiredArg(j)) {
      builder.addReqFormal(formalType);
    }
 else {
      builder.addOptFormal(formalType);
    }
  }
  if (boundFunType.hasRestFormals()) {
    builder.addRestFormals(boundFunType.getRestFormalsType());
  }
  return new EnvTypePair(env,commonTypes.fromFunctionType(builder.addRetType(boundFunType.getReturnType()).buildFunction()));
}","private EnvTypePair analyzeFunctionBindFwd(Node call,TypeEnv inEnv){
  Preconditions.checkArgument(call.isCall());
  Bind bindComponents=convention.describeFunctionBind(call,true,false);
  Node boundFunNode=bindComponents.target;
  EnvTypePair pair=analyzeExprFwd(boundFunNode,inEnv);
  TypeEnv env=pair.env;
  FunctionType boundFunType=pair.type.getFunTypeIfSingletonObj();
  if (!pair.type.isSubtypeOf(commonTypes.topFunction())) {
    warnings.add(JSError.make(boundFunNode,GOOG_BIND_EXPECTS_FUNCTION));
  }
  if (boundFunType == null || boundFunType.isTopFunction() || boundFunType.isQmarkFunction() || boundFunType.isLoose()) {
    return analyzeCallNodeArgsFwdWhenError(call,env);
  }
  if (boundFunType.isConstructor()) {
    warnings.add(JSError.make(call,CANNOT_BIND_CTOR));
    return new EnvTypePair(env,JSType.UNKNOWN);
  }
  if (NodeUtil.isGoogBind(call.getFirstChild()) && call.getChildCount() <= 2 || !NodeUtil.isGoogPartial(call.getFirstChild()) && call.getChildCount() == 1) {
    warnings.add(JSError.make(call,TypeCheck.WRONG_ARGUMENT_COUNT,getReadableCalleeName(call.getFirstChild()),""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  int maxArity=boundFunType.hasRestFormals() ? Integer.MAX_VALUE : boundFunType.getMaxArity();
  int numArgs=bindComponents.getBoundParameterCount();
  if (numArgs > maxArity) {
    warnings.add(JSError.make(call,TypeCheck.WRONG_ARGUMENT_COUNT,getReadableCalleeName(call.getFirstChild()),Integer.toString(numArgs),""String_Node_Str"",""String_Node_Str"" + maxArity));
    return analyzeCallNodeArgsFwdWhenError(call,inEnv);
  }
  if (boundFunType.isGeneric()) {
    Map<String,JSType> typeMap=calcTypeInstantiationFwd(call,bindComponents.parameters,boundFunType,env);
    boundFunType=boundFunType.instantiateGenerics(typeMap);
  }
  FunctionTypeBuilder builder=new FunctionTypeBuilder();
  Node receiver=bindComponents.thisValue;
  if (receiver != null) {
    JSType reqThisType=boundFunType.getThisType();
    if (reqThisType == null || boundFunType.isConstructor()) {
      reqThisType=JSType.join(JSType.NULL,JSType.TOP_OBJECT);
    }
    pair=analyzeExprFwd(receiver,env,reqThisType);
    env=pair.env;
    if (!pair.type.isSubtypeOf(reqThisType)) {
      warnings.add(JSError.make(call,INVALID_THIS_TYPE_IN_BIND,pair.type.toString(),reqThisType.toString()));
    }
  }
  env=analyzeCallNodeArgumentsFwd(call,bindComponents.parameters,boundFunType,new ArrayList<JSType>(),env);
  for (int j=numArgs; j < boundFunType.getMaxArityWithoutRestFormals(); j++) {
    JSType formalType=boundFunType.getFormalType(j);
    if (boundFunType.isRequiredArg(j)) {
      builder.addReqFormal(formalType);
    }
 else {
      builder.addOptFormal(formalType);
    }
  }
  if (boundFunType.hasRestFormals()) {
    builder.addRestFormals(boundFunType.getRestFormalsType());
  }
  return new EnvTypePair(env,commonTypes.fromFunctionType(builder.addRetType(boundFunType.getReturnType()).buildFunction()));
}",0.9945541184479236
27531,"static boolean isGoogPartial(Node n){
  return n.isCall() && n.getFirstChild().isQualifiedName() && n.getFirstChild().matchesQualifiedName(""String_Node_Str"");
}","static boolean isGoogPartial(Node n){
  return n.isGetProp() && n.matchesQualifiedName(""String_Node_Str"");
}",0.753731343283582
27532,"static boolean isGoogBind(Node n){
  return n.isCall() && n.getFirstChild().isQualifiedName() && n.getFirstChild().matchesQualifiedName(""String_Node_Str"");
}","static boolean isGoogBind(Node n){
  return n.isGetProp() && n.matchesQualifiedName(""String_Node_Str"");
}",0.7480916030534351
27533,"static boolean isFunctionBind(Node expr){
  if (expr.isCall()) {
    expr=expr.getFirstChild();
  }
  if (!expr.isGetProp()) {
    return false;
  }
  if (isGoogBind(expr.getParent()) || isGoogPartial(expr.getParent())) {
    return true;
  }
  return expr.getFirstChild().isFunction() && expr.getLastChild().getString().equals(""String_Node_Str"");
}","static boolean isFunctionBind(Node expr){
  if (!expr.isGetProp()) {
    return false;
  }
  if (isGoogBind(expr) || isGoogPartial(expr)) {
    return true;
  }
  return expr.getFirstChild().isFunction() && expr.getLastChild().getString().equals(""String_Node_Str"");
}",0.4188311688311688
27534,"public void addPropertyWhichMayNotBeOnAllInstances(String pname,JSType type){
  Preconditions.checkState(!isFinalized);
  Preconditions.checkState(!this.classProps.containsKey(pname));
  Preconditions.checkState(!this.protoProps.containsKey(pname));
  if (this.objectKind == ObjectKind.UNRESTRICTED) {
    this.randomProps=this.randomProps.with(pname,Property.make(type == null ? JSType.UNKNOWN : type,type));
  }
}","public void addPropertyWhichMayNotBeOnAllInstances(String pname,JSType type){
  Preconditions.checkState(!isFinalized);
  if (this.classProps.containsKey(pname) || this.protoProps.containsKey(pname)) {
    return;
  }
  if (this.objectKind == ObjectKind.UNRESTRICTED) {
    this.randomProps=this.randomProps.with(pname,Property.make(type == null ? JSType.UNKNOWN : type,type));
  }
}",0.731829573934837
27535,"public void testClosureStyleFunctionBind(){
  typeCheck(""String_Node_Str"",NewTypeInference.GOOG_BIND_EXPECTS_FUNCTION);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str""),TypeCheck.WRONG_ARGUMENT_COUNT);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str""),TypeCheck.WRONG_ARGUMENT_COUNT);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_THIS_TYPE_IN_BIND);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"");
}","public void testClosureStyleFunctionBind(){
  typeCheck(""String_Node_Str"",NewTypeInference.GOOG_BIND_EXPECTS_FUNCTION);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str""),TypeCheck.WRONG_ARGUMENT_COUNT);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str""),TypeCheck.WRONG_ARGUMENT_COUNT);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_THIS_TYPE_IN_BIND);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"");
  typeCheck(""String_Node_Str"");
}",0.9862896315338476
27536,"public void testAddingPropsToExpandosInWhateverScopes(){
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),TypeCheck.INEXISTENT_PROPERTY);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.MISPLACED_CONST_ANNOTATION);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.REDECLARED_PROPERTY,NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testAddingPropsToExpandosInWhateverScopes(){
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),TypeCheck.INEXISTENT_PROPERTY);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.MISPLACED_CONST_ANNOTATION);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.REDECLARED_PROPERTY,NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.9273021001615508
27537,"private void visitYieldExpression(Node n){
  if (n.getParent().isExprResult()) {
    return;
  }
  if (decomposer.canExposeExpression(n) != ExpressionDecomposer.DecompositionType.UNDECOMPOSABLE) {
    decomposer.exposeExpression(n);
    compiler.reportCodeChange();
  }
 else {
    compiler.report(JSError.make(currentStatement,Es6ToEs3Converter.CANNOT_CONVERT,""String_Node_Str""));
  }
}","private void visitYieldExpression(Node n){
  if (n.getParent().isExprResult()) {
    return;
  }
  if (decomposer.canExposeExpression(n) != ExpressionDecomposer.DecompositionType.UNDECOMPOSABLE) {
    decomposer.exposeExpression(n);
    compiler.reportCodeChange();
  }
 else {
    compiler.report(JSError.make(n,Es6ToEs3Converter.CANNOT_CONVERT,""String_Node_Str""));
  }
}",0.9776021080368906
27538,"/** 
 * Replaces a CALL node with an inlined message value. <p> The call tree looks something like: <pre> call |-- getprop |   |-- name 'goog' |   +-- string 'getMsg' | |-- string 'Hi {$userName}! Welcome to {$product}.' +-- objlit |-- string 'userName' |-- name 'someUserName' |-- string 'product' +-- call +-- name 'getProductName' <pre> <p> For that example, we'd return: <pre> add |-- string 'Hi ' +-- add |-- name someUserName +-- add |-- string '! Welcome to ' +-- add |-- call |   +-- name 'getProductName' +-- string '.' </pre>
 * @param message  a message
 * @param callNode  the message's original CALL value node
 * @return a STRING node, or an ADD node that does string concatenation, ifthe message has one or more placeholders
 * @throws MalformedException if the passed node's subtree structure isnot as expected
 */
private Node replaceCallNode(JsMessage message,Node callNode) throws MalformedException {
  checkNode(callNode,Token.CALL);
  Node getPropNode=callNode.getFirstChild();
  checkNode(getPropNode,Token.GETPROP);
  Node stringExprNode=getPropNode.getNext();
  checkStringExprNode(stringExprNode);
  Node objLitNode=stringExprNode.getNext();
  return constructStringExprNode(message.parts().iterator(),objLitNode);
}","/** 
 * Replaces a CALL node with an inlined message value. <p> The call tree looks something like: <pre> call |-- getprop |   |-- name 'goog' |   +-- string 'getMsg' | |-- string 'Hi {$userName}! Welcome to {$product}.' +-- objlit |-- string 'userName' |-- name 'someUserName' |-- string 'product' +-- call +-- name 'getProductName' <pre> <p> For that example, we'd return: <pre> add |-- string 'Hi ' +-- add |-- name someUserName +-- add |-- string '! Welcome to ' +-- add |-- call |   +-- name 'getProductName' +-- string '.' </pre>
 * @param message  a message
 * @param callNode  the message's original CALL value node
 * @return a STRING node, or an ADD node that does string concatenation, ifthe message has one or more placeholders
 * @throws MalformedException if the passed node's subtree structure isnot as expected
 */
private Node replaceCallNode(JsMessage message,Node callNode) throws MalformedException {
  checkNode(callNode,Token.CALL);
  Node getPropNode=callNode.getFirstChild();
  checkNode(getPropNode,Token.GETPROP);
  Node stringExprNode=getPropNode.getNext();
  checkStringExprNode(stringExprNode);
  Node objLitNode=stringExprNode.getNext();
  return constructStringExprNode(message.parts().iterator(),objLitNode,callNode);
}",0.9963898916967509
27539,"/** 
 * Creates a parse tree corresponding to the remaining message parts in an iteration. The result consists of one or more STRING nodes, placeholder replacement value nodes (which can be arbitrary expressions), and ADD nodes.
 * @param parts  an iterator over message parts
 * @param objLitNode  an OBJLIT node mapping placeholder names to values
 * @return the root of the constructed parse tree
 * @throws MalformedException if {@code parts} contains a placeholderreference that does not correspond to a valid placeholder name
 */
private static Node constructStringExprNode(Iterator<CharSequence> parts,Node objLitNode) throws MalformedException {
  CharSequence part=parts.next();
  Node partNode=null;
  if (part instanceof JsMessage.PlaceholderReference) {
    JsMessage.PlaceholderReference phRef=(JsMessage.PlaceholderReference)part;
    if (objLitNode == null) {
      throw new MalformedException(""String_Node_Str"" + ""String_Node_Str"",objLitNode);
    }
    for (Node key=objLitNode.getFirstChild(); key != null; key=key.getNext()) {
      if (key.getString().equals(phRef.getName())) {
        Node valueNode=key.getFirstChild();
        partNode=valueNode.cloneTree();
      }
    }
    if (partNode == null) {
      throw new MalformedException(""String_Node_Str"" + phRef.getName(),objLitNode);
    }
  }
 else {
    partNode=IR.string(part.toString());
  }
  if (parts.hasNext()) {
    return IR.add(partNode,constructStringExprNode(parts,objLitNode));
  }
 else {
    return partNode;
  }
}","/** 
 * Creates a parse tree corresponding to the remaining message parts in an iteration. The result consists of one or more STRING nodes, placeholder replacement value nodes (which can be arbitrary expressions), and ADD nodes.
 * @param parts  an iterator over message parts
 * @param objLitNode  an OBJLIT node mapping placeholder names to values
 * @return the root of the constructed parse tree
 * @throws MalformedException if {@code parts} contains a placeholderreference that does not correspond to a valid placeholder name
 */
private static Node constructStringExprNode(Iterator<CharSequence> parts,Node objLitNode,Node refNode) throws MalformedException {
  Preconditions.checkNotNull(refNode);
  CharSequence part=parts.next();
  Node partNode=null;
  if (part instanceof JsMessage.PlaceholderReference) {
    JsMessage.PlaceholderReference phRef=(JsMessage.PlaceholderReference)part;
    if (objLitNode == null) {
      throw new MalformedException(""String_Node_Str"" + ""String_Node_Str"",refNode);
    }
    for (Node key=objLitNode.getFirstChild(); key != null; key=key.getNext()) {
      if (key.getString().equals(phRef.getName())) {
        Node valueNode=key.getFirstChild();
        partNode=valueNode.cloneTree();
      }
    }
    if (partNode == null) {
      throw new MalformedException(""String_Node_Str"" + phRef.getName(),objLitNode);
    }
  }
 else {
    partNode=IR.string(part.toString());
  }
  if (parts.hasNext()) {
    return IR.add(partNode,constructStringExprNode(parts,objLitNode,refNode));
  }
 else {
    return partNode;
  }
}",0.6675350048844024
27540,"/** 
 * Initializes a message builder from a CALL node. <p> The tree should look something like: <pre> call |-- getprop |   |-- name 'goog' |   +-- string 'getMsg' | |-- string 'Hi {$userName}! Welcome to {$product}.' +-- objlit |-- string 'userName' |-- name 'someUserName' |-- string 'product' +-- call +-- name 'getProductName' </pre>
 * @param builder the message builder
 * @param node the call node from where we extract the message
 * @throws MalformedException if the parsed message is invalid
 */
private void extractFromCallNode(Builder builder,Node node) throws MalformedException {
  if (!node.isCall()) {
    throw new MalformedException(""String_Node_Str"" + MSG_FUNCTION_NAME + ""String_Node_Str"",node);
  }
  Node fnNameNode=node.getFirstChild();
  if (!fnNameNode.matchesQualifiedName(MSG_FUNCTION_NAME)) {
    throw new MalformedException(""String_Node_Str"" + ""String_Node_Str"" + MSG_FUNCTION_NAME + ""String_Node_Str"",fnNameNode);
  }
  Node stringLiteralNode=fnNameNode.getNext();
  if (stringLiteralNode == null) {
    throw new MalformedException(""String_Node_Str"",stringLiteralNode);
  }
  parseMessageTextNode(builder,stringLiteralNode);
  Node objLitNode=stringLiteralNode.getNext();
  Set<String> phNames=new HashSet<>();
  if (objLitNode != null) {
    if (!objLitNode.isObjectLit()) {
      throw new MalformedException(""String_Node_Str"",objLitNode);
    }
    for (Node aNode=objLitNode.getFirstChild(); aNode != null; aNode=aNode.getNext()) {
      if (!aNode.isStringKey()) {
        throw new MalformedException(""String_Node_Str"",aNode);
      }
      String phName=aNode.getString();
      if (!isLowerCamelCaseWithNumericSuffixes(phName)) {
        throw new MalformedException(""String_Node_Str"" + phName,aNode);
      }
      if (phNames.contains(phName)) {
        throw new MalformedException(""String_Node_Str"" + phName,aNode);
      }
      phNames.add(phName);
    }
  }
  Set<String> usedPlaceholders=builder.getPlaceholders();
  for (  String phName : usedPlaceholders) {
    if (!phNames.contains(phName)) {
      throw new MalformedException(""String_Node_Str"" + phName,objLitNode);
    }
  }
  for (  String phName : phNames) {
    if (!usedPlaceholders.contains(phName)) {
      throw new MalformedException(""String_Node_Str"" + phName,objLitNode);
    }
  }
}","/** 
 * Initializes a message builder from a CALL node. <p> The tree should look something like: <pre> call |-- getprop |   |-- name 'goog' |   +-- string 'getMsg' | |-- string 'Hi {$userName}! Welcome to {$product}.' +-- objlit |-- string 'userName' |-- name 'someUserName' |-- string 'product' +-- call +-- name 'getProductName' </pre>
 * @param builder the message builder
 * @param node the call node from where we extract the message
 * @throws MalformedException if the parsed message is invalid
 */
private void extractFromCallNode(Builder builder,Node node) throws MalformedException {
  if (!node.isCall()) {
    throw new MalformedException(""String_Node_Str"" + MSG_FUNCTION_NAME + ""String_Node_Str"",node);
  }
  Node fnNameNode=node.getFirstChild();
  if (!fnNameNode.matchesQualifiedName(MSG_FUNCTION_NAME)) {
    throw new MalformedException(""String_Node_Str"" + ""String_Node_Str"" + MSG_FUNCTION_NAME + ""String_Node_Str"",fnNameNode);
  }
  Node stringLiteralNode=fnNameNode.getNext();
  if (stringLiteralNode == null) {
    throw new MalformedException(""String_Node_Str"",stringLiteralNode);
  }
  parseMessageTextNode(builder,stringLiteralNode);
  Node objLitNode=stringLiteralNode.getNext();
  Set<String> phNames=new HashSet<>();
  if (objLitNode != null) {
    if (!objLitNode.isObjectLit()) {
      throw new MalformedException(""String_Node_Str"",objLitNode);
    }
    for (Node aNode=objLitNode.getFirstChild(); aNode != null; aNode=aNode.getNext()) {
      if (!aNode.isStringKey()) {
        throw new MalformedException(""String_Node_Str"",aNode);
      }
      String phName=aNode.getString();
      if (!isLowerCamelCaseWithNumericSuffixes(phName)) {
        throw new MalformedException(""String_Node_Str"" + phName,aNode);
      }
      if (phNames.contains(phName)) {
        throw new MalformedException(""String_Node_Str"" + phName,aNode);
      }
      phNames.add(phName);
    }
  }
  Set<String> usedPlaceholders=builder.getPlaceholders();
  for (  String phName : usedPlaceholders) {
    if (!phNames.contains(phName)) {
      throw new MalformedException(""String_Node_Str"" + phName,node);
    }
  }
  for (  String phName : phNames) {
    if (!usedPlaceholders.contains(phName)) {
      throw new MalformedException(""String_Node_Str"" + phName,node);
    }
  }
}",0.9965095986038396
27541,"private void visitPrototypePropertyDeclaration(Node getProp){
  Preconditions.checkArgument(getProp.isGetProp());
  Node parent=getProp.getParent();
  Node initializer=parent.isAssign() ? parent.getLastChild() : null;
  Node ctorNameNode=NodeUtil.getPrototypeClassName(getProp);
  QualifiedName ctorQname=QualifiedName.fromNode(ctorNameNode);
  RawNominalType rawType=currentScope.getNominalType(ctorQname);
  if (rawType == null) {
    if (initializer != null && initializer.isFunction()) {
      visitFunctionLate(initializer,null);
    }
    return;
  }
  if (!currentScope.isDefined(ctorNameNode)) {
    warnings.add(JSError.make(getProp,CTOR_IN_DIFFERENT_SCOPE));
    if (initializer != null && initializer.isFunction()) {
      visitFunctionLate(initializer,rawType);
    }
    return;
  }
  mayWarnAboutInterfacePropInit(rawType,initializer);
  String pname=NodeUtil.getPrototypePropertyName(getProp);
  mayAddPropToPrototype(rawType,pname,getProp,initializer);
}","private void visitPrototypePropertyDeclaration(Node getProp){
  Preconditions.checkArgument(getProp.isGetProp());
  Node parent=getProp.getParent();
  Node initializer=parent.isAssign() ? parent.getLastChild() : null;
  Node ctorNameNode=NodeUtil.getPrototypeClassName(getProp);
  QualifiedName ctorQname=QualifiedName.fromNode(ctorNameNode);
  RawNominalType rawType=currentScope.getNominalType(ctorQname);
  if (rawType == null) {
    if (initializer != null && initializer.isFunction()) {
      visitFunctionLate(initializer,null);
    }
    return;
  }
  if (initializer != null && initializer.isFunction()) {
    parent.putBooleanProp(Node.ANALYZED_DURING_GTI,true);
  }
  if (!currentScope.isDefined(ctorNameNode)) {
    warnings.add(JSError.make(getProp,CTOR_IN_DIFFERENT_SCOPE));
    if (initializer != null && initializer.isFunction()) {
      visitFunctionLate(initializer,rawType);
    }
    return;
  }
  mayWarnAboutInterfacePropInit(rawType,initializer);
  String pname=NodeUtil.getPrototypePropertyName(getProp);
  mayAddPropToPrototype(rawType,pname,getProp,initializer);
}",0.9422049538610976
27542,"/** 
 * Unify   {@code this}, which may contain free type variables, with   {@code other}, a concrete subtype, modifying the supplied  {@code typeMultimap} to add any new template variable type bindings.Note that if  {@code this} is a union type, some of the union members maybe ignored if they are not present in  {@code other}.
 * @return Whether unification succeeded
 */
public boolean unifyWithSubtype(JSType other,List<String> typeParameters,Multimap<String,JSType> typeMultimap){
  Preconditions.checkNotNull(other);
  if (this.isUnknown() || this.isTop()) {
    return true;
  }
 else   if (getMask() == TYPEVAR_MASK && typeParameters.contains(getTypeVar())) {
    updateTypemap(typeMultimap,getTypeVar(),other);
    return true;
  }
 else   if (other.isUnknown()) {
    return true;
  }
 else   if (other.isTop()) {
    return false;
  }
  Set<EnumType> ununifiedEnums=ImmutableSet.of();
  if (!other.getEnums().isEmpty()) {
    ununifiedEnums=new LinkedHashSet<>();
    for (    EnumType e : other.getEnums()) {
      if (!fromEnum(e).isSubtypeOf(this)) {
        ununifiedEnums.add(e);
      }
    }
  }
  Set<ObjectType> ununifiedObjs=new LinkedHashSet<>(other.getObjs());
  for (  ObjectType targetObj : getObjs()) {
    for (    ObjectType sourceObj : other.getObjs()) {
      if (targetObj.unifyWithSubtype(sourceObj,typeParameters,typeMultimap)) {
        ununifiedObjs.remove(sourceObj);
      }
    }
  }
  String thisTypevar=getTypeVar();
  String otherTypevar=other.getTypeVar();
  if (thisTypevar == null || !typeParameters.contains(thisTypevar)) {
    return ununifiedObjs.isEmpty() && ununifiedEnums.isEmpty() && (otherTypevar == null || otherTypevar.equals(thisTypevar))&& getMask() == (getMask() | (other.getMask() & ~ENUM_MASK));
  }
 else {
    int templateMask=BOTTOM_MASK;
    int thisScalarBits=getMask() & ~NON_SCALAR_MASK & ~TYPEVAR_MASK;
    int otherScalarBits=other.getMask() & ~NON_SCALAR_MASK;
    templateMask|=otherScalarBits & ~thisScalarBits;
    if (templateMask == BOTTOM_MASK) {
      return ununifiedObjs.isEmpty() && ununifiedEnums.isEmpty();
    }
    JSType templateType=makeType(promoteBoolean(templateMask),ImmutableSet.copyOf(ununifiedObjs),otherTypevar,ImmutableSet.copyOf(ununifiedEnums));
    updateTypemap(typeMultimap,getTypeVar(),templateType);
    return true;
  }
}","/** 
 * Unify   {@code this}, which may contain free type variables, with   {@code other}, a concrete subtype, modifying the supplied  {@code typeMultimap} to add any new template variable type bindings.Note that if  {@code this} is a union type, some of the union members maybe ignored if they are not present in  {@code other}.
 * @return Whether unification succeeded
 */
public boolean unifyWithSubtype(JSType other,List<String> typeParameters,Multimap<String,JSType> typeMultimap){
  Preconditions.checkNotNull(other);
  if (this.isUnknown() || this.isTop()) {
    return true;
  }
 else   if (getMask() == TYPEVAR_MASK && typeParameters.contains(getTypeVar())) {
    updateTypemap(typeMultimap,getTypeVar(),other);
    return true;
  }
 else   if (other.isUnknown()) {
    return true;
  }
 else   if (other.isTop()) {
    return false;
  }
  Set<EnumType> ununifiedEnums=ImmutableSet.of();
  if (!other.getEnums().isEmpty()) {
    ununifiedEnums=new LinkedHashSet<>();
    for (    EnumType e : other.getEnums()) {
      if (!fromEnum(e).isSubtypeOf(this)) {
        ununifiedEnums.add(e);
      }
    }
  }
  Set<ObjectType> ununifiedObjs=new LinkedHashSet<>(other.getObjs());
  for (  ObjectType targetObj : getObjs()) {
    for (    ObjectType sourceObj : other.getObjs()) {
      if (targetObj.unifyWithSubtype(sourceObj,typeParameters,typeMultimap)) {
        ununifiedObjs.remove(sourceObj);
      }
    }
  }
  String thisTypevar=getTypeVar();
  String otherTypevar=other.getTypeVar();
  if (thisTypevar == null || !typeParameters.contains(thisTypevar)) {
    return ununifiedObjs.isEmpty() && ununifiedEnums.isEmpty() && (otherTypevar == null || otherTypevar.equals(thisTypevar))&& getMask() == (getMask() | (other.getMask() & ~ENUM_MASK));
  }
 else {
    int thisScalarBits=getMask() & ~NON_SCALAR_MASK & ~TYPEVAR_MASK;
    int templateMask=other.getMask() & ~thisScalarBits;
    if (ununifiedObjs.isEmpty()) {
      templateMask&=~NON_SCALAR_MASK;
    }
    if (templateMask == BOTTOM_MASK) {
      return ununifiedObjs.isEmpty() && ununifiedEnums.isEmpty();
    }
    JSType templateType=makeType(promoteBoolean(templateMask),ImmutableSet.copyOf(ununifiedObjs),otherTypevar,ImmutableSet.copyOf(ununifiedEnums));
    updateTypemap(typeMultimap,getTypeVar(),templateType);
    return true;
  }
}",0.957290767903365
27543,"boolean isSubtypeOf(NominalType other){
  RawNominalType thisRaw=this.rawType;
  if (thisRaw == other.rawType) {
    return areTypeParametersSubtypes(other);
  }
  if (other.isInterface()) {
    for (    NominalType i : thisRaw.getInterfaces()) {
      if (i.instantiateGenerics(this.typeMap).isSubtypeOf(other)) {
        return true;
      }
    }
  }
  return isClass() && thisRaw.superClass != null && thisRaw.superClass.instantiateGenerics(this.typeMap).isSubtypeOf(other);
}","boolean isSubtypeOf(NominalType other){
  RawNominalType thisRaw=this.rawType;
  if (thisRaw == other.rawType) {
    return areTypeMapsCompatible(other);
  }
  if (other.isInterface()) {
    for (    NominalType i : thisRaw.getInterfaces()) {
      if (i.instantiateGenerics(this.typeMap).isSubtypeOf(other)) {
        return true;
      }
    }
  }
  return isClass() && thisRaw.superClass != null && thisRaw.superClass.instantiateGenerics(this.typeMap).isSubtypeOf(other);
}",0.9707112970711296
27544,"boolean unifyWithSubtype(NominalType other,List<String> typeParameters,Multimap<String,JSType> typeMultimap){
  other=other.findMatchingAncestorWith(this);
  if (other == null) {
    return false;
  }
  if (!isGeneric()) {
    return true;
  }
  Preconditions.checkState(!typeMap.isEmpty());
  if (other.typeMap.isEmpty()) {
    return true;
  }
  boolean hasUnified=true;
  for (  String typeParam : this.rawType.typeParameters) {
    JSType fromOtherMap=other.typeMap.get(typeParam);
    Preconditions.checkNotNull(fromOtherMap,""String_Node_Str"",typeParam,other.typeMap);
    hasUnified=hasUnified && this.typeMap.get(typeParam).unifyWithSubtype(fromOtherMap,typeParameters,typeMultimap);
  }
  return hasUnified && isInvariantWith(typeMultimap,other);
}","boolean unifyWithSubtype(NominalType other,List<String> typeParameters,Multimap<String,JSType> typeMultimap){
  other=other.findMatchingAncestorWith(this);
  if (other == null) {
    return false;
  }
  if (!isGeneric()) {
    return true;
  }
  Preconditions.checkState(!typeMap.isEmpty());
  if (other.typeMap.isEmpty()) {
    return true;
  }
  boolean hasUnified=true;
  for (  String typeParam : this.rawType.typeParameters) {
    JSType fromOtherMap=other.typeMap.get(typeParam);
    Preconditions.checkNotNull(fromOtherMap,""String_Node_Str"",typeParam,other.typeMap);
    hasUnified=hasUnified && this.typeMap.get(typeParam).unifyWithSubtype(fromOtherMap,typeParameters,typeMultimap);
  }
  return hasUnified && (allowCovariantGenerics(this) || isInvariantWith(typeMultimap,other));
}",0.9780077619663649
27545,"public void testUnificationWithGenericUnion(){
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.FAILED_TO_UNIFY);
}","public void testUnificationWithGenericUnion(){
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.942134831460674
27546,"public void testGenericsVariance(){
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
}","public void testGenericsVariance(){
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
}",0.7186392629340893
27547,"static FunctionType join(FunctionType f1,FunctionType f2){
  if (f1 == null) {
    return f2;
  }
 else   if (f2 == null || f1.equals(f2)) {
    return f1;
  }
 else   if (f1.isTopFunction() || f2.isTopFunction()) {
    return TOP_FUNCTION;
  }
  if (f1.isLoose() || f2.isLoose()) {
    return FunctionType.looseJoin(f1,f2);
  }
  if (f1.isGeneric() && f2.isSubtypeOf(f1)) {
    return f1;
  }
 else   if (f2.isGeneric() && f1.isSubtypeOf(f2)) {
    return f2;
  }
  if (f1.isGeneric()) {
    f1=instantiateGenericsWithUnknown(f1);
  }
  if (f2.isGeneric()) {
    f2=instantiateGenericsWithUnknown(f2);
  }
  FunctionTypeBuilder builder=new FunctionTypeBuilder();
  int maxRequiredArity=Math.max(f1.requiredFormals.size(),f2.requiredFormals.size());
  for (int i=0; i < maxRequiredArity; i++) {
    JSType reqFormal=nullAcceptingMeet(f1.getFormalType(i),f2.getFormalType(i));
    builder.addReqFormal(reqFormal);
  }
  int maxTotalArity=Math.max(f1.requiredFormals.size() + f1.optionalFormals.size(),f2.requiredFormals.size() + f2.optionalFormals.size());
  for (int i=maxRequiredArity; i < maxTotalArity; i++) {
    JSType optFormal=nullAcceptingMeet(f1.getFormalType(i),f2.getFormalType(i));
    builder.addOptFormal(optFormal);
  }
  if (f1.restFormals != null && f2.restFormals != null) {
    builder.addRestFormals(nullAcceptingMeet(f1.restFormals,f2.restFormals));
  }
  builder.addRetType(JSType.join(f1.returnType,f2.returnType));
  builder.addNominalType(NominalType.pickSuperclass(f1.nominalType,f2.nominalType));
  builder.addReceiverType(NominalType.pickSuperclass(f1.receiverType,f2.receiverType));
  return builder.buildFunction();
}","static FunctionType join(FunctionType f1,FunctionType f2){
  if (f1 == null) {
    return f2;
  }
 else   if (f2 == null || f1.equals(f2)) {
    return f1;
  }
 else   if (f1.isQmarkFunction() || f2.isQmarkFunction()) {
    return QMARK_FUNCTION;
  }
 else   if (f1.isTopFunction() || f2.isTopFunction()) {
    return TOP_FUNCTION;
  }
  if (f1.isLoose() || f2.isLoose()) {
    return looseJoin(f1,f2);
  }
  if (f1.isGeneric() && f2.isSubtypeOf(f1)) {
    return f1;
  }
 else   if (f2.isGeneric() && f1.isSubtypeOf(f2)) {
    return f2;
  }
  if (f1.isGeneric()) {
    f1=instantiateGenericsWithUnknown(f1);
  }
  if (f2.isGeneric()) {
    f2=instantiateGenericsWithUnknown(f2);
  }
  FunctionTypeBuilder builder=new FunctionTypeBuilder();
  int maxRequiredArity=Math.max(f1.requiredFormals.size(),f2.requiredFormals.size());
  for (int i=0; i < maxRequiredArity; i++) {
    JSType reqFormal=nullAcceptingMeet(f1.getFormalType(i),f2.getFormalType(i));
    builder.addReqFormal(reqFormal);
  }
  int maxTotalArity=Math.max(f1.requiredFormals.size() + f1.optionalFormals.size(),f2.requiredFormals.size() + f2.optionalFormals.size());
  for (int i=maxRequiredArity; i < maxTotalArity; i++) {
    JSType optFormal=nullAcceptingMeet(f1.getFormalType(i),f2.getFormalType(i));
    builder.addOptFormal(optFormal);
  }
  if (f1.restFormals != null && f2.restFormals != null) {
    builder.addRestFormals(nullAcceptingMeet(f1.restFormals,f2.restFormals));
  }
  builder.addRetType(JSType.join(f1.returnType,f2.returnType));
  builder.addNominalType(NominalType.pickSuperclass(f1.nominalType,f2.nominalType));
  builder.addReceiverType(NominalType.pickSuperclass(f1.receiverType,f2.receiverType));
  return builder.buildFunction();
}",0.9691577698695136
27548,"public DeclaredFunctionType toDeclaredFunctionType(){
  if (isQmarkFunction()) {
    return FunctionTypeBuilder.qmarkFunctionBuilder().buildDeclaration();
  }
  Preconditions.checkState(!isLoose());
  if (isGeneric()) {
    return null;
  }
  if (nominalType != null) {
    return null;
  }
  FunctionTypeBuilder builder=new FunctionTypeBuilder();
  for (  JSType type : requiredFormals) {
    builder.addReqFormal(type);
  }
  for (  JSType type : optionalFormals) {
    builder.addOptFormal(type);
  }
  builder.addRestFormals(restFormals);
  builder.addRetType(returnType);
  builder.addNominalType(nominalType);
  builder.addReceiverType(receiverType);
  return builder.buildDeclaration();
}","public DeclaredFunctionType toDeclaredFunctionType(){
  if (isQmarkFunction()) {
    return FunctionTypeBuilder.qmarkFunctionBuilder().buildDeclaration();
  }
  Preconditions.checkState(!isLoose(),""String_Node_Str"",this);
  if (isGeneric()) {
    return null;
  }
  if (nominalType != null) {
    return null;
  }
  FunctionTypeBuilder builder=new FunctionTypeBuilder();
  for (  JSType type : requiredFormals) {
    builder.addReqFormal(type);
  }
  for (  JSType type : optionalFormals) {
    builder.addOptFormal(type);
  }
  builder.addRestFormals(restFormals);
  builder.addRetType(returnType);
  builder.addNominalType(nominalType);
  builder.addReceiverType(receiverType);
  return builder.buildDeclaration();
}",0.983722576079264
27549,"static FunctionType meet(FunctionType f1,FunctionType f2){
  if (f1 == null || f2 == null) {
    return null;
  }
 else   if (f2.isTopFunction() || f1.equals(f2)) {
    return f1;
  }
 else   if (f1.isTopFunction()) {
    return f2;
  }
  if (f1.isLoose() || f2.isLoose()) {
    return FunctionType.looseJoin(f1,f2);
  }
  if (f1.isGeneric() && f1.isSubtypeOf(f2)) {
    return f1;
  }
 else   if (f2.isGeneric() && f2.isSubtypeOf(f1)) {
    return f2;
  }
  if (f1.isGeneric()) {
    f1=instantiateGenericsWithUnknown(f1);
  }
  if (f2.isGeneric()) {
    f2=instantiateGenericsWithUnknown(f2);
  }
  FunctionTypeBuilder builder=new FunctionTypeBuilder();
  int minRequiredArity=Math.min(f1.requiredFormals.size(),f2.requiredFormals.size());
  for (int i=0; i < minRequiredArity; i++) {
    builder.addReqFormal(JSType.nullAcceptingJoin(f1.getFormalType(i),f2.getFormalType(i)));
  }
  int maxTotalArity=Math.max(f1.requiredFormals.size() + f1.optionalFormals.size(),f2.requiredFormals.size() + f2.optionalFormals.size());
  for (int i=minRequiredArity; i < maxTotalArity; i++) {
    builder.addOptFormal(JSType.nullAcceptingJoin(f1.getFormalType(i),f2.getFormalType(i)));
  }
  if (f1.restFormals != null || f2.restFormals != null) {
    builder.addRestFormals(JSType.nullAcceptingJoin(f1.restFormals,f2.restFormals));
  }
  JSType retType=JSType.meet(f1.returnType,f2.returnType);
  if (retType.isBottom()) {
    return BOTTOM_FUNCTION;
  }
  builder.addRetType(retType);
  builder.addNominalType(NominalType.pickSubclass(f1.nominalType,f2.nominalType));
  builder.addReceiverType(NominalType.pickSubclass(f1.receiverType,f2.receiverType));
  return builder.buildFunction();
}","static FunctionType meet(FunctionType f1,FunctionType f2){
  if (f1 == null || f2 == null) {
    return null;
  }
 else   if (f2.isTopFunction() || f1.equals(f2)) {
    return f1;
  }
 else   if (f1.isTopFunction()) {
    return f2;
  }
  if (f1.isLoose() || f2.isLoose()) {
    return looseJoin(f1,f2);
  }
  if (f1.isGeneric() && f1.isSubtypeOf(f2)) {
    return f1;
  }
 else   if (f2.isGeneric() && f2.isSubtypeOf(f1)) {
    return f2;
  }
  if (f1.isGeneric()) {
    f1=instantiateGenericsWithUnknown(f1);
  }
  if (f2.isGeneric()) {
    f2=instantiateGenericsWithUnknown(f2);
  }
  FunctionTypeBuilder builder=new FunctionTypeBuilder();
  int minRequiredArity=Math.min(f1.requiredFormals.size(),f2.requiredFormals.size());
  for (int i=0; i < minRequiredArity; i++) {
    builder.addReqFormal(JSType.nullAcceptingJoin(f1.getFormalType(i),f2.getFormalType(i)));
  }
  int maxTotalArity=Math.max(f1.requiredFormals.size() + f1.optionalFormals.size(),f2.requiredFormals.size() + f2.optionalFormals.size());
  for (int i=minRequiredArity; i < maxTotalArity; i++) {
    builder.addOptFormal(JSType.nullAcceptingJoin(f1.getFormalType(i),f2.getFormalType(i)));
  }
  if (f1.restFormals != null || f2.restFormals != null) {
    builder.addRestFormals(JSType.nullAcceptingJoin(f1.restFormals,f2.restFormals));
  }
  JSType retType=JSType.meet(f1.returnType,f2.returnType);
  if (retType.isBottom()) {
    return BOTTOM_FUNCTION;
  }
  builder.addRetType(retType);
  builder.addNominalType(NominalType.pickSubclass(f1.nominalType,f2.nominalType));
  builder.addReceiverType(NominalType.pickSubclass(f1.receiverType,f2.receiverType));
  return builder.buildFunction();
}",0.996111277295842
27550,"FunctionType specialize(FunctionType other){
  if (other == null || other.isQmarkFunction() || !this.isLoose() && other.isLoose()) {
    return this;
  }
  FunctionType result=FunctionType.meet(this,other);
  if (this.isLoose() && !result.isLoose()) {
    result=result.withLoose();
  }
  return result;
}","FunctionType specialize(FunctionType other){
  if (other == null || other.isQmarkFunction() || !this.isLoose() && other.isLoose()) {
    return this;
  }
  FunctionType result=meet(this,other);
  if (this.isLoose() && !result.isLoose()) {
    result=result.withLoose();
  }
  return result;
}",0.9782244556113904
27551,"public void testLooseFunctions(){
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_INFERRED_RETURN_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_INFERRED_RETURN_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testLooseFunctions(){
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_INFERRED_RETURN_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_INFERRED_RETURN_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9747937671860678
27552,"public void testGoogIsPredicatesTrue(){
  typeCheck(CLOSURE_BASE + ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(CLOSURE_BASE + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(CLOSURE_BASE + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(CLOSURE_BASE + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(CLOSURE_BASE + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(CLOSURE_BASE + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(CLOSURE_BASE + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(CLOSURE_BASE + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(CLOSURE_BASE + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(CLOSURE_BASE + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testGoogIsPredicatesTrue(){
  typeCheck(CLOSURE_BASE + ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(CLOSURE_BASE + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(CLOSURE_BASE + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(CLOSURE_BASE + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(CLOSURE_BASE + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(CLOSURE_BASE + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(CLOSURE_BASE + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(CLOSURE_BASE + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(CLOSURE_BASE + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(CLOSURE_BASE + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(CLOSURE_BASE + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9231197771587744
27553,"private void checkSuperProperty(RawNominalType current,NominalType superType,String pname,Multimap<String,DeclaredFunctionType> propMethodTypesToProcess,Multimap<String,JSType> propTypesToProcess){
  JSType inheritedPropType=superType.getPropDeclaredType(pname);
  if (inheritedPropType == null) {
    return;
  }
  Collection<PropertyDef> inheritedPropDefs;
  if (superType.isInterface()) {
    inheritedPropDefs=getPropDefsFromInterface(superType,pname);
  }
 else {
    inheritedPropDefs=ImmutableSet.of(getPropDefFromClass(superType,pname));
  }
  if (superType.isInterface() && current.isClass() && !current.mayHaveProp(pname)) {
    warnings.add(JSError.make(inheritedPropDefs.iterator().next().defSite,TypeValidator.INTERFACE_METHOD_NOT_IMPLEMENTED,pname,superType.toString(),current.toString()));
    return;
  }
  PropertyDef localPropDef=propertyDefs.get(current,pname);
  JSType localPropType=localPropDef == null ? null : current.getInstancePropDeclaredType(pname);
  if (localPropDef != null && superType.isClass() && localPropType.getFunType() != null && superType.hasConstantProp(pname)) {
    warnings.add(JSError.make(localPropDef.defSite,CANNOT_OVERRIDE_FINAL_METHOD,pname));
    return;
  }
  if (localPropType == null) {
    propTypesToProcess.put(pname,inheritedPropType);
  }
 else   if (!localPropType.isSubtypeOf(inheritedPropType)) {
    warnings.add(JSError.make(localPropDef.defSite,INVALID_PROP_OVERRIDE,pname,inheritedPropType.toString(),localPropType.toString()));
  }
 else   if (localPropDef.methodType != null) {
    for (    PropertyDef inheritedPropDef : inheritedPropDefs) {
      if (inheritedPropDef.methodType != null) {
        propMethodTypesToProcess.put(pname,inheritedPropDef.methodType.substituteNominalGenerics(superType));
      }
    }
  }
}","private void checkSuperProperty(RawNominalType current,NominalType superType,String pname,Multimap<String,DeclaredFunctionType> propMethodTypesToProcess,Multimap<String,JSType> propTypesToProcess){
  JSType inheritedPropType=superType.getPropDeclaredType(pname);
  if (inheritedPropType == null) {
    return;
  }
  Collection<PropertyDef> inheritedPropDefs;
  if (superType.isInterface()) {
    inheritedPropDefs=getPropDefsFromInterface(superType,pname);
  }
 else {
    inheritedPropDefs=ImmutableSet.of(getPropDefFromClass(superType,pname));
  }
  if (superType.isInterface() && current.isClass() && !current.mayHaveProp(pname)) {
    warnings.add(JSError.make(inheritedPropDefs.iterator().next().defSite,TypeValidator.INTERFACE_METHOD_NOT_IMPLEMENTED,pname,superType.toString(),current.toString()));
    return;
  }
  PropertyDef localPropDef=propertyDefs.get(current,pname);
  JSType localPropType=localPropDef == null ? null : current.getInstancePropDeclaredType(pname);
  if (localPropDef != null && superType.isClass() && localPropType.getFunType() != null && superType.hasConstantProp(pname)) {
    warnings.add(JSError.make(localPropDef.defSite,CANNOT_OVERRIDE_FINAL_METHOD,pname));
    return;
  }
  if (localPropType == null) {
    propTypesToProcess.put(pname,inheritedPropType);
  }
 else   if (!getsTypeInfoFromParentMethod(localPropDef) && !localPropType.isSubtypeOf(inheritedPropType)) {
    warnings.add(JSError.make(localPropDef.defSite,INVALID_PROP_OVERRIDE,pname,inheritedPropType.toString(),localPropType.toString()));
  }
 else   if (localPropDef.methodType != null) {
    for (    PropertyDef inheritedPropDef : inheritedPropDefs) {
      if (inheritedPropDef.methodType != null) {
        propMethodTypesToProcess.put(pname,inheritedPropDef.methodType.substituteNominalGenerics(superType));
      }
    }
  }
}",0.9870344827586208
27554,"PropertyDef(Node defSite,DeclaredFunctionType methodType,Scope methodScope){
  Preconditions.checkArgument(defSite.isGetProp() || NodeUtil.isObjectLitKey(defSite));
  this.defSite=defSite;
  this.methodType=methodType;
  this.methodScope=methodScope;
}","PropertyDef(Node defSite,DeclaredFunctionType methodType,Scope methodScope){
  Preconditions.checkNotNull(defSite);
  Preconditions.checkArgument(defSite.isGetProp() || NodeUtil.isObjectLitKey(defSite));
  this.defSite=defSite;
  this.methodType=methodType;
  this.methodScope=methodScope;
}",0.9281767955801103
27555,"/** 
 * Report all errors that must be checked at the end of GlobalTypeInfo 
 */
private void reportInheritanceErrors(){
  Deque<Node> workset=new LinkedList<>(nominaltypesByNode.keySet());
  int iterations=0;
  final int MAX_ITERATIONS=50000;
  workset_loop:   while (!workset.isEmpty()) {
    Preconditions.checkState(iterations < MAX_ITERATIONS);
    Node funNode=workset.removeFirst();
    RawNominalType rawNominalType=nominaltypesByNode.get(funNode);
    NominalType superClass=rawNominalType.getSuperClass();
    Set<String> nonInheritedPropNames=rawNominalType.getAllOwnProps();
    if (superClass != null && !superClass.isFinalized()) {
      workset.addLast(funNode);
      iterations++;
      continue workset_loop;
    }
    for (    NominalType superInterf : rawNominalType.getInterfaces()) {
      if (!superInterf.isFinalized()) {
        workset.addLast(funNode);
        iterations++;
        continue workset_loop;
      }
    }
    Multimap<String,DeclaredFunctionType> propMethodTypesToProcess=LinkedHashMultimap.create();
    Multimap<String,JSType> propTypesToProcess=LinkedHashMultimap.create();
    if (superClass != null) {
      Preconditions.checkState(superClass.isFinalized());
      for (      String pname : superClass.getAllPropsOfClass()) {
        nonInheritedPropNames.remove(pname);
        checkSuperProperty(rawNominalType,superClass,pname,propMethodTypesToProcess,propTypesToProcess);
      }
    }
    for (    NominalType superInterf : rawNominalType.getInterfaces()) {
      Preconditions.checkState(superInterf.isFinalized());
      for (      String pname : superInterf.getAllPropsOfInterface()) {
        nonInheritedPropNames.remove(pname);
        checkSuperProperty(rawNominalType,superInterf,pname,propMethodTypesToProcess,propTypesToProcess);
      }
    }
    for (    String pname : propMethodTypesToProcess.keySet()) {
      Collection<DeclaredFunctionType> methodTypes=propMethodTypesToProcess.get(pname);
      Preconditions.checkState(!methodTypes.isEmpty());
      PropertyDef localPropDef=propertyDefs.get(rawNominalType,pname);
      DeclaredFunctionType superMethodType=DeclaredFunctionType.meet(methodTypes);
      DeclaredFunctionType updatedMethodType=localPropDef.methodType.withTypeInfoFromSuper(superMethodType);
      localPropDef.updateMethodType(updatedMethodType);
      propTypesToProcess.put(pname,commonTypes.fromFunctionType(updatedMethodType.toFunctionType()));
    }
    add_interface_props:     for (    String pname : propTypesToProcess.keySet()) {
      Collection<JSType> defs=propTypesToProcess.get(pname);
      Preconditions.checkState(!defs.isEmpty());
      JSType resultType=JSType.TOP;
      for (      JSType inheritedType : defs) {
        resultType=JSType.meet(resultType,inheritedType);
        if (!resultType.isBottom()) {
          resultType=inheritedType;
        }
 else {
          warnings.add(JSError.make(funNode,TypeCheck.INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,NodeUtil.getFunctionName(funNode),pname,""String_Node_Str"",""String_Node_Str""));
          continue add_interface_props;
        }
      }
      rawNominalType.addProtoProperty(pname,null,resultType,false);
    }
    for (    String pname : nonInheritedPropNames) {
      Node defSite=propertyDefs.get(rawNominalType,pname).defSite;
      JSDocInfo jsdoc=NodeUtil.getBestJSDocInfo(defSite);
      if (jsdoc != null && jsdoc.isOverride()) {
        warnings.add(JSError.make(defSite,TypeCheck.UNKNOWN_OVERRIDE,pname,rawNominalType.getName()));
      }
    }
    rawNominalType.finalizeNominalType();
  }
}","/** 
 * Report all errors that must be checked at the end of GlobalTypeInfo 
 */
private void reportInheritanceErrors(){
  Deque<Node> workset=new LinkedList<>(nominaltypesByNode.keySet());
  int iterations=0;
  final int MAX_ITERATIONS=50000;
  workset_loop:   while (!workset.isEmpty()) {
    Preconditions.checkState(iterations < MAX_ITERATIONS);
    Node funNode=workset.removeFirst();
    RawNominalType rawNominalType=nominaltypesByNode.get(funNode);
    NominalType superClass=rawNominalType.getSuperClass();
    Set<String> nonInheritedPropNames=rawNominalType.getAllOwnProps();
    if (superClass != null && !superClass.isFinalized()) {
      workset.addLast(funNode);
      iterations++;
      continue workset_loop;
    }
    for (    NominalType superInterf : rawNominalType.getInterfaces()) {
      if (!superInterf.isFinalized()) {
        workset.addLast(funNode);
        iterations++;
        continue workset_loop;
      }
    }
    Multimap<String,DeclaredFunctionType> propMethodTypesToProcess=LinkedHashMultimap.create();
    Multimap<String,JSType> propTypesToProcess=LinkedHashMultimap.create();
    if (superClass != null) {
      Preconditions.checkState(superClass.isFinalized());
      for (      String pname : superClass.getAllPropsOfClass()) {
        nonInheritedPropNames.remove(pname);
        checkSuperProperty(rawNominalType,superClass,pname,propMethodTypesToProcess,propTypesToProcess);
      }
    }
    for (    NominalType superInterf : rawNominalType.getInterfaces()) {
      Preconditions.checkState(superInterf.isFinalized());
      for (      String pname : superInterf.getAllPropsOfInterface()) {
        nonInheritedPropNames.remove(pname);
        checkSuperProperty(rawNominalType,superInterf,pname,propMethodTypesToProcess,propTypesToProcess);
      }
    }
    for (    String pname : propMethodTypesToProcess.keySet()) {
      Collection<DeclaredFunctionType> methodTypes=propMethodTypesToProcess.get(pname);
      Preconditions.checkState(!methodTypes.isEmpty());
      PropertyDef localPropDef=propertyDefs.get(rawNominalType,pname);
      DeclaredFunctionType superMethodType=DeclaredFunctionType.meet(methodTypes);
      DeclaredFunctionType updatedMethodType=localPropDef.methodType.withTypeInfoFromSuper(superMethodType,getsTypeInfoFromParentMethod(localPropDef));
      localPropDef.updateMethodType(updatedMethodType);
      propTypesToProcess.put(pname,commonTypes.fromFunctionType(updatedMethodType.toFunctionType()));
    }
    add_interface_props:     for (    String pname : propTypesToProcess.keySet()) {
      Collection<JSType> defs=propTypesToProcess.get(pname);
      Preconditions.checkState(!defs.isEmpty());
      JSType resultType=JSType.TOP;
      for (      JSType inheritedType : defs) {
        resultType=JSType.meet(resultType,inheritedType);
        if (!resultType.isBottom()) {
          resultType=inheritedType;
        }
 else {
          warnings.add(JSError.make(funNode,TypeCheck.INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,NodeUtil.getFunctionName(funNode),pname,""String_Node_Str"",""String_Node_Str""));
          continue add_interface_props;
        }
      }
      rawNominalType.addProtoProperty(pname,null,resultType,false);
    }
    for (    String pname : nonInheritedPropNames) {
      Node defSite=propertyDefs.get(rawNominalType,pname).defSite;
      JSDocInfo jsdoc=NodeUtil.getBestJSDocInfo(defSite);
      if (jsdoc != null && jsdoc.isOverride()) {
        warnings.add(JSError.make(defSite,TypeCheck.UNKNOWN_OVERRIDE,pname,rawNominalType.getName()));
      }
    }
    rawNominalType.finalizeNominalType();
  }
}",0.9940019528525595
27556,"public DeclaredFunctionType withTypeInfoFromSuper(DeclaredFunctionType superType){
  FunctionTypeBuilder builder=new FunctionTypeBuilder();
  int i=0;
  for (  JSType formal : requiredFormals) {
    builder.addReqFormal(formal != null ? formal : superType.getFormalType(i));
    i++;
  }
  for (  JSType formal : optionalFormals) {
    builder.addOptFormal(formal != null ? formal : superType.getFormalType(i));
    i++;
  }
  if (restFormals != null) {
    builder.addRestFormals(restFormals);
  }
 else   if (superType.hasRestFormals()) {
    builder.addRestFormals(superType.restFormals);
  }
  builder.addRetType(returnType != null ? returnType : superType.returnType);
  builder.addNominalType(nominalType);
  builder.addReceiverType(receiverType);
  if (!typeParameters.isEmpty()) {
    builder.addTypeParameters(typeParameters);
  }
 else   if (!superType.typeParameters.isEmpty()) {
    builder.addTypeParameters(superType.typeParameters);
  }
  return builder.buildDeclaration();
}","public DeclaredFunctionType withTypeInfoFromSuper(DeclaredFunctionType superType,boolean getsTypeInfoFromParentMethod){
  if (getsTypeInfoFromParentMethod) {
    return new DeclaredFunctionType(superType.requiredFormals,superType.optionalFormals,superType.restFormals,superType.returnType,superType.nominalType,this.receiverType,superType.typeParameters);
  }
  FunctionTypeBuilder builder=new FunctionTypeBuilder();
  int i=0;
  for (  JSType formal : requiredFormals) {
    builder.addReqFormal(formal != null ? formal : superType.getFormalType(i));
    i++;
  }
  for (  JSType formal : optionalFormals) {
    builder.addOptFormal(formal != null ? formal : superType.getFormalType(i));
    i++;
  }
  if (restFormals != null) {
    builder.addRestFormals(restFormals);
  }
 else   if (superType.hasRestFormals()) {
    builder.addRestFormals(superType.restFormals);
  }
  builder.addRetType(returnType != null ? returnType : superType.returnType);
  builder.addNominalType(nominalType);
  builder.addReceiverType(receiverType);
  if (!typeParameters.isEmpty()) {
    builder.addTypeParameters(typeParameters);
  }
 else   if (!superType.typeParameters.isEmpty()) {
    builder.addTypeParameters(superType.typeParameters);
  }
  return builder.buildDeclaration();
}",0.8772707133362871
27557,"public void testOverride(){
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",TypeCheck.UNKNOWN_OVERRIDE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",TypeCheck.UNKNOWN_OVERRIDE);
}","public void testOverride(){
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",TypeCheck.UNKNOWN_OVERRIDE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",TypeCheck.UNKNOWN_OVERRIDE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
}",0.8714436248682824
27558,"private void checkSuperProperty(RawNominalType current,NominalType superType,String pname,Multimap<String,DeclaredFunctionType> propMethodTypesToProcess,Multimap<String,JSType> propTypesToProcess){
  JSType inheritedPropType=superType.getPropDeclaredType(pname);
  if (inheritedPropType == null) {
    return;
  }
  Collection<PropertyDef> inheritedPropDefs;
  if (superType.isInterface()) {
    inheritedPropDefs=getPropDefsFromInterface(superType,pname);
  }
 else {
    inheritedPropDefs=ImmutableSet.of(getPropDefFromClass(superType,pname));
  }
  if (superType.isInterface() && current.isClass() && !current.mayHaveProp(pname)) {
    warnings.add(JSError.make(inheritedPropDefs.iterator().next().defSite,TypeValidator.INTERFACE_METHOD_NOT_IMPLEMENTED,pname,superType.toString(),current.toString()));
    return;
  }
  PropertyDef localPropDef=propertyDefs.get(current,pname);
  JSType localPropType=localPropDef == null ? null : current.getInstancePropDeclaredType(pname);
  if (localPropDef != null && superType.isClass() && localPropType.getFunType() != null && superType.hasConstantProp(pname)) {
    warnings.add(JSError.make(localPropDef.defSite,CANNOT_OVERRIDE_FINAL_METHOD,pname));
    return;
  }
  if (localPropType == null) {
    propTypesToProcess.put(pname,inheritedPropType);
  }
 else   if (!localPropType.isSubtypeOf(inheritedPropType)) {
    warnings.add(JSError.make(localPropDef.defSite,INVALID_PROP_OVERRIDE,pname,inheritedPropType.toString(),localPropType.toString()));
  }
 else   if (localPropDef.methodType != null) {
    for (    PropertyDef inheritedPropDef : inheritedPropDefs) {
      if (inheritedPropDef.methodType != null) {
        propMethodTypesToProcess.put(pname,inheritedPropDef.methodType);
      }
    }
  }
}","private void checkSuperProperty(RawNominalType current,NominalType superType,String pname,Multimap<String,DeclaredFunctionType> propMethodTypesToProcess,Multimap<String,JSType> propTypesToProcess){
  JSType inheritedPropType=superType.getPropDeclaredType(pname);
  if (inheritedPropType == null) {
    return;
  }
  Collection<PropertyDef> inheritedPropDefs;
  if (superType.isInterface()) {
    inheritedPropDefs=getPropDefsFromInterface(superType,pname);
  }
 else {
    inheritedPropDefs=ImmutableSet.of(getPropDefFromClass(superType,pname));
  }
  if (superType.isInterface() && current.isClass() && !current.mayHaveProp(pname)) {
    warnings.add(JSError.make(inheritedPropDefs.iterator().next().defSite,TypeValidator.INTERFACE_METHOD_NOT_IMPLEMENTED,pname,superType.toString(),current.toString()));
    return;
  }
  PropertyDef localPropDef=propertyDefs.get(current,pname);
  JSType localPropType=localPropDef == null ? null : current.getInstancePropDeclaredType(pname);
  if (localPropDef != null && superType.isClass() && localPropType.getFunType() != null && superType.hasConstantProp(pname)) {
    warnings.add(JSError.make(localPropDef.defSite,CANNOT_OVERRIDE_FINAL_METHOD,pname));
    return;
  }
  if (localPropType == null) {
    propTypesToProcess.put(pname,inheritedPropType);
  }
 else   if (!localPropType.isSubtypeOf(inheritedPropType)) {
    warnings.add(JSError.make(localPropDef.defSite,INVALID_PROP_OVERRIDE,pname,inheritedPropType.toString(),localPropType.toString()));
  }
 else   if (localPropDef.methodType != null) {
    for (    PropertyDef inheritedPropDef : inheritedPropDefs) {
      if (inheritedPropDef.methodType != null) {
        propMethodTypesToProcess.put(pname,inheritedPropDef.methodType.substituteNominalGenerics(superType));
      }
    }
  }
}",0.9895509743010448
27559,"public DeclaredFunctionType withTypeInfoFromSuper(DeclaredFunctionType superType){
  FunctionTypeBuilder builder=new FunctionTypeBuilder();
  int i=0;
  for (  JSType formal : requiredFormals) {
    builder.addReqFormal(formal != null ? formal : superType.getFormalType(i));
    i++;
  }
  for (  JSType formal : optionalFormals) {
    builder.addOptFormal(formal != null ? formal : superType.getFormalType(i));
    i++;
  }
  if (restFormals != null) {
    builder.addRestFormals(restFormals);
  }
 else   if (superType.hasRestFormals()) {
    builder.addRestFormals(superType.restFormals);
  }
  builder.addRetType(returnType != null ? returnType : superType.returnType);
  builder.addNominalType(nominalType);
  builder.addReceiverType(receiverType);
  builder.addTypeParameters(typeParameters);
  return builder.buildDeclaration();
}","public DeclaredFunctionType withTypeInfoFromSuper(DeclaredFunctionType superType){
  FunctionTypeBuilder builder=new FunctionTypeBuilder();
  int i=0;
  for (  JSType formal : requiredFormals) {
    builder.addReqFormal(formal != null ? formal : superType.getFormalType(i));
    i++;
  }
  for (  JSType formal : optionalFormals) {
    builder.addOptFormal(formal != null ? formal : superType.getFormalType(i));
    i++;
  }
  if (restFormals != null) {
    builder.addRestFormals(restFormals);
  }
 else   if (superType.hasRestFormals()) {
    builder.addRestFormals(superType.restFormals);
  }
  builder.addRetType(returnType != null ? returnType : superType.returnType);
  builder.addNominalType(nominalType);
  builder.addReceiverType(receiverType);
  if (!typeParameters.isEmpty()) {
    builder.addTypeParameters(typeParameters);
  }
 else   if (!superType.typeParameters.isEmpty()) {
    builder.addTypeParameters(superType.typeParameters);
  }
  return builder.buildDeclaration();
}",0.8987411056376574
27560,"public void testInheritanceSubtyping(){
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
}","public void testInheritanceSubtyping(){
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9621489621489622
27561,"public void testInheritanceWithGenerics(){
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",GlobalTypeInfo.INVALID_PROP_OVERRIDE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",GlobalTypeInfo.INVALID_PROP_OVERRIDE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",GlobalTypeInfo.INVALID_PROP_OVERRIDE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",JSTypeCreatorFromJSDoc.INVALID_GENERICS_INSTANTIATION);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testInheritanceWithGenerics(){
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",GlobalTypeInfo.INVALID_PROP_OVERRIDE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",GlobalTypeInfo.INVALID_PROP_OVERRIDE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",GlobalTypeInfo.INVALID_PROP_OVERRIDE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",JSTypeCreatorFromJSDoc.INVALID_GENERICS_INSTANTIATION);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.8680272108843538
27562,"static ObjectType join(ObjectType obj1,ObjectType obj2){
  Preconditions.checkState(areRelatedClasses(obj1.nominalType,obj2.nominalType));
  if (obj1.equals(obj2)) {
    return obj1;
  }
  boolean isLoose=obj1.isLoose || obj2.isLoose;
  FunctionType fn=FunctionType.join(obj1.fn,obj2.fn);
  PersistentMap<String,Property> props;
  if (isLoose) {
    fn=fn == null ? null : fn.withLoose();
    props=joinPropsLoosely(obj1.props,obj2.props);
  }
 else {
    props=joinProps(obj1.props,obj2.props);
  }
  NominalType nominal=NominalType.pickSuperclass(obj1.nominalType,obj2.nominalType);
  if (nominal == null || !nominal.isFunction()) {
    fn=null;
  }
  return ObjectType.makeObjectType(nominal,props,fn,isLoose,ObjectKind.join(obj1.objectKind,obj2.objectKind));
}","static ObjectType join(ObjectType obj1,ObjectType obj2){
  NominalType nom1=obj1.nominalType;
  NominalType nom2=obj2.nominalType;
  Preconditions.checkState(areRelatedClasses(nom1,nom2));
  if (obj1.equals(obj2)) {
    return obj1;
  }
  boolean isLoose=obj1.isLoose || obj2.isLoose;
  FunctionType fn=FunctionType.join(obj1.fn,obj2.fn);
  PersistentMap<String,Property> props;
  if (isLoose) {
    fn=fn == null ? null : fn.withLoose();
    props=joinPropsLoosely(obj1.props,obj2.props);
  }
 else {
    props=joinProps(obj1.props,obj2.props,nom1,nom2);
  }
  NominalType nominal=NominalType.pickSuperclass(nom1,nom2);
  if (nominal == null || !nominal.isFunction()) {
    fn=null;
  }
  return ObjectType.makeObjectType(nominal,props,fn,isLoose,ObjectKind.join(obj1.objectKind,obj2.objectKind));
}",0.8925831202046036
27563,"private static PersistentMap<String,Property> joinProps(Map<String,Property> props1,Map<String,Property> props2){
  PersistentMap<String,Property> newProps=PersistentMap.create();
  for (  Map.Entry<String,Property> propsEntry : props1.entrySet()) {
    String pname=propsEntry.getKey();
    if (!props2.containsKey(pname)) {
      newProps=newProps.with(pname,propsEntry.getValue().withOptional());
    }
  }
  for (  Map.Entry<String,Property> propsEntry : props2.entrySet()) {
    String pname=propsEntry.getKey();
    Property prop2=propsEntry.getValue();
    if (props1.containsKey(pname)) {
      newProps=newProps.with(pname,Property.join(props1.get(pname),prop2));
    }
 else {
      newProps=newProps.with(pname,prop2.withOptional());
    }
  }
  return newProps;
}","private static PersistentMap<String,Property> joinProps(Map<String,Property> props1,Map<String,Property> props2,NominalType nom1,NominalType nom2){
  PersistentMap<String,Property> newProps=PersistentMap.create();
  for (  String pname : Sets.union(props1.keySet(),props2.keySet())) {
    Property prop1=getProp(props1,nom1,pname);
    Property prop2=getProp(props2,nom2,pname);
    Property newProp=null;
    if (prop1 == null) {
      newProp=prop2.withOptional();
    }
 else     if (prop2 == null) {
      newProp=prop1.withOptional();
    }
 else {
      newProp=Property.join(prop1,prop2);
    }
    newProps=newProps.with(pname,newProp);
  }
  return newProps;
}",0.4404432132963989
27564,"static ImmutableSet<ObjectType> joinSets(ImmutableSet<ObjectType> objs1,ImmutableSet<ObjectType> objs2){
  if (objs1.isEmpty()) {
    return objs2;
  }
 else   if (objs2.isEmpty()) {
    return objs1;
  }
  ObjectType[] objs1Arr=objs1.toArray(new ObjectType[0]);
  ObjectType[] keptFrom1=objs1Arr.clone();
  ImmutableSet.Builder<ObjectType> newObjs=ImmutableSet.builder();
  for (  ObjectType obj2 : objs2) {
    boolean addedObj2=false;
    for (int i=0; i < objs1Arr.length; i++) {
      ObjectType obj1=objs1Arr[i];
      NominalType nominalType1=obj1.nominalType;
      NominalType nominalType2=obj2.nominalType;
      if (areRelatedClasses(nominalType1,nominalType2)) {
        if (nominalType2 == null && nominalType1 != null && !obj1.isSubtypeOf(obj2) || nominalType1 == null && nominalType2 != null && !obj2.isSubtypeOf(obj1)) {
          break;
        }
        keptFrom1[i]=null;
        newObjs.add(join(obj1,obj2));
        addedObj2=true;
        break;
      }
    }
    if (!addedObj2) {
      newObjs.add(obj2);
    }
  }
  for (  ObjectType o : keptFrom1) {
    if (o != null) {
      newObjs.add(o);
    }
  }
  return newObjs.build();
}","static ImmutableSet<ObjectType> joinSets(ImmutableSet<ObjectType> objs1,ImmutableSet<ObjectType> objs2){
  if (objs1.isEmpty()) {
    return objs2;
  }
 else   if (objs2.isEmpty()) {
    return objs1;
  }
  ObjectType[] objs1Arr=objs1.toArray(new ObjectType[0]);
  ObjectType[] keptFrom1=objs1Arr.clone();
  ImmutableSet.Builder<ObjectType> newObjs=ImmutableSet.builder();
  for (  ObjectType obj2 : objs2) {
    boolean addedObj2=false;
    for (int i=0; i < objs1Arr.length; i++) {
      ObjectType obj1=objs1Arr[i];
      NominalType nominalType1=obj1.nominalType;
      NominalType nominalType2=obj2.nominalType;
      if (areRelatedClasses(nominalType1,nominalType2)) {
        if (nominalType2 == null && nominalType1 != null && !obj1.isSubtypeOf(obj2) || nominalType1 == null && nominalType2 != null && !obj2.isSubtypeOf(obj1)) {
          break;
        }
        keptFrom1[i]=null;
        addedObj2=true;
        newObjs.add(join(obj1,obj2));
        break;
      }
    }
    if (!addedObj2) {
      newObjs.add(obj2);
    }
  }
  for (  ObjectType o : keptFrom1) {
    if (o != null) {
      newObjs.add(o);
    }
  }
  return newObjs.build();
}",0.9792387543252596
27565,"Property withOptional(){
  return new Property(defSite,inferredType,declaredType,Attribute.OPTIONAL);
}","Property withOptional(){
  return isOptional() ? this : new Property(defSite,inferredType,declaredType,Attribute.OPTIONAL);
}",0.9035087719298246
27566,"Property withRequired(){
  return new Property(defSite,inferredType,declaredType,Attribute.REQUIRED);
}","Property withRequired(){
  return isRequired() ? this : new Property(defSite,inferredType,declaredType,Attribute.REQUIRED);
}",0.9035087719298246
27567,"private StringBuilder appendGenericSuffixTo(StringBuilder builder,Map<String,JSType> typeMap){
  Preconditions.checkState(typeMap.isEmpty() || typeMap.keySet().containsAll(typeParameters));
  if (typeParameters.isEmpty()) {
    return builder;
  }
  boolean firstIteration=true;
  builder.append(""String_Node_Str"");
  for (  String typeParam : typeParameters) {
    if (!firstIteration) {
      builder.append(',');
    }
    JSType concrete=typeMap.get(typeParam);
    if (concrete != null) {
      concrete.appendTo(builder);
    }
 else {
      builder.append(typeParam);
    }
  }
  builder.append('>');
  return builder;
}","private StringBuilder appendGenericSuffixTo(StringBuilder builder,Map<String,JSType> typeMap){
  Preconditions.checkState(typeMap.isEmpty() || typeMap.keySet().containsAll(typeParameters));
  if (typeParameters.isEmpty()) {
    return builder;
  }
  boolean firstIteration=true;
  builder.append(""String_Node_Str"");
  for (  String typeParam : typeParameters) {
    if (firstIteration) {
      firstIteration=false;
    }
 else {
      builder.append(',');
    }
    JSType concrete=typeMap.get(typeParam);
    if (concrete != null) {
      concrete.appendTo(builder);
    }
 else {
      builder.append(typeParam);
    }
  }
  builder.append('>');
  return builder;
}",0.9667953667953668
27568,"boolean unifyWithSubtype(NominalType other,List<String> typeParameters,Multimap<String,JSType> typeMultimap){
  if (this.rawType != other.rawType) {
    return false;
  }
  if (this.rawType.typeParameters.isEmpty()) {
    return true;
  }
  Preconditions.checkState(!typeMap.isEmpty());
  if (other.typeMap.isEmpty()) {
    return true;
  }
  boolean hasUnified=true;
  for (  String typeParam : rawType.typeParameters) {
    hasUnified=hasUnified && typeMap.get(typeParam).unifyWithSubtype(other.typeMap.get(typeParam),typeParameters,typeMultimap);
  }
  return hasUnified;
}","boolean unifyWithSubtype(NominalType other,List<String> typeParameters,Multimap<String,JSType> typeMultimap){
  if (this.rawType != other.rawType) {
    return false;
  }
  if (!isGeneric()) {
    return true;
  }
  Preconditions.checkState(!typeMap.isEmpty());
  if (other.typeMap.isEmpty()) {
    return true;
  }
  boolean hasUnified=true;
  for (  String typeParam : rawType.typeParameters) {
    hasUnified=hasUnified && typeMap.get(typeParam).unifyWithSubtype(other.typeMap.get(typeParam),typeParameters,typeMultimap);
  }
  return hasUnified && isInvariantWith(typeMultimap,other);
}",0.6123499142367067
27569,"public void testUnifyWithGenericUnion(){
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
}","public void testUnifyWithGenericUnion(){
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.FAILED_TO_UNIFY);
}",0.900101591601761
27570,"private void visitCallNode(Node call,Node parent){
  String required=codingConvention.extractClassNameIfRequire(call,parent);
  if (required != null) {
    requires.put(required,call);
  }
  for (Node qNameNode=call.getFirstChild(); qNameNode != null; qNameNode=qNameNode.getFirstChild()) {
    weakUsages.put(qNameNode.getQualifiedName(),qNameNode);
  }
}","private void visitCallNode(Node call,Node parent){
  String required=codingConvention.extractClassNameIfRequire(call,parent);
  if (required != null) {
    requires.put(required,call);
  }
}",0.6959706959706959
27571,"private void visitScriptNode(NodeTraversal t){
  Set<String> classNames=new HashSet<>();
  for (  Map.Entry<String,Node> entry : usages.entrySet()) {
    String className=entry.getKey();
    Node node=entry.getValue();
    String outermostClassName=getOutermostClassName(className);
    String nonNullClassName=outermostClassName != null ? outermostClassName : className;
    String parentNamespace=null;
    int separatorIndex=nonNullClassName.lastIndexOf('.');
    if (separatorIndex > 0) {
      parentNamespace=nonNullClassName.substring(0,separatorIndex);
    }
    boolean notProvidedByConstructors=(constructors == null || (!constructors.contains(className) && !constructors.contains(outermostClassName)));
    boolean notProvidedByRequires=(requires == null || (!requires.containsKey(className) && !requires.containsKey(outermostClassName) && !requires.containsKey(parentNamespace)));
    if (notProvidedByConstructors && notProvidedByRequires && !classNames.contains(className)) {
      compiler.report(t.makeError(node,MISSING_REQUIRE_WARNING,className));
      classNames.add(className);
    }
  }
  for (  Map.Entry<String,Node> entry : requires.entrySet()) {
    String require=entry.getKey();
    Node call=entry.getValue();
    Node parent=call.getParent();
    if (parent.isAssign()) {
      continue;
    }
    if (!usages.containsKey(require) && !weakUsages.containsKey(require)) {
      compiler.report(t.makeError(call,EXTRA_REQUIRE_WARNING,require));
    }
  }
  this.usages.clear();
  this.weakUsages.clear();
  this.requires.clear();
  this.constructors.clear();
}","private void visitScriptNode(NodeTraversal t){
  Set<String> classNames=new HashSet<>();
  for (  Map.Entry<String,Node> entry : usages.entrySet()) {
    String className=entry.getKey();
    Node node=entry.getValue();
    String outermostClassName=getOutermostClassName(className);
    String nonNullClassName=outermostClassName != null ? outermostClassName : className;
    String parentNamespace=null;
    int separatorIndex=nonNullClassName.lastIndexOf('.');
    if (separatorIndex > 0) {
      parentNamespace=nonNullClassName.substring(0,separatorIndex);
    }
    boolean notProvidedByConstructors=(constructors == null || (!constructors.contains(className) && !constructors.contains(outermostClassName)));
    boolean notProvidedByRequires=(requires == null || (!requires.containsKey(className) && !requires.containsKey(outermostClassName) && !requires.containsKey(parentNamespace)));
    if (notProvidedByConstructors && notProvidedByRequires && !classNames.contains(className)) {
      compiler.report(t.makeError(node,MISSING_REQUIRE_WARNING,className));
      classNames.add(className);
    }
  }
  for (  Map.Entry<String,Node> entry : requires.entrySet()) {
    String require=entry.getKey();
    Node call=entry.getValue();
    Node parent=call.getParent();
    if (parent.isAssign()) {
      continue;
    }
    if (!usages.containsKey(require) && !weakUsages.containsKey(require)) {
      reportExtraRequireWarning(call,require);
    }
  }
  this.usages.clear();
  this.weakUsages.clear();
  this.requires.clear();
  this.constructors.clear();
}",0.9768180374722134
27572,"@Override protected List<PassFactory> getChecks(){
  List<PassFactory> checks=Lists.newArrayList();
  checks.add(createEmptyPass(""String_Node_Str""));
  if (options.closurePass) {
    checks.add(closureRewriteModule);
  }
  if (options.lowerFromEs6() || options.aggressiveVarCheck.isOn()) {
    checks.add(checkVariableReferences);
  }
  if (options.getLanguageIn() == LanguageMode.ECMASCRIPT6_TYPED && options.getLanguageOut() != LanguageMode.ECMASCRIPT6_TYPED) {
    checks.add(convertDeclaredTypesToJSDoc);
  }
  if (options.lowerFromEs6()) {
    checks.add(es6RenameVariablesInParamLists);
    checks.add(es6SplitVariableDeclarations);
    checks.add(es6ConvertSuper);
  }
  if (options.getLanguageIn() == LanguageMode.ECMASCRIPT6_TYPED && options.getLanguageOut() != LanguageMode.ECMASCRIPT6_TYPED) {
    checks.add(convertEs6TypedToEs6);
  }
  if (options.lowerFromEs6()) {
    checks.add(convertEs6ToEs3);
    checks.add(rewriteLetConst);
    checks.add(rewriteGenerators);
    checks.add(markTranspilationDone);
  }
  if (options.raiseToEs6Typed()) {
    checks.add(convertToTypedES6);
  }
  if (options.transpileOnly) {
    return checks;
  }
  if (options.lowerFromEs6()) {
    checks.add(es6RuntimeLibrary);
  }
  checks.add(convertStaticInheritance);
  if (options.declaredGlobalExternsOnWindow) {
    checks.add(declaredGlobalExternsOnWindow);
  }
  if (options.closurePass) {
    checks.add(closureGoogScopeAliases);
    checks.add(closureRewriteClass);
  }
  if (options.jqueryPass) {
    checks.add(jqueryAliases);
  }
  if (options.angularPass) {
    checks.add(angularPass);
  }
  if (options.polymerPass) {
    checks.add(polymerPass);
  }
  checks.add(checkSideEffects);
  if (options.checkSuspiciousCode || options.enables(DiagnosticGroups.GLOBAL_THIS) || options.enables(DiagnosticGroups.DEBUGGER_STATEMENT_PRESENT)) {
    checks.add(suspiciousCode);
  }
  if (options.enables(DiagnosticGroups.MISSING_REQUIRE)) {
    checks.add(checkRequires);
  }
  if (options.checkProvides.isOn()) {
    checks.add(checkProvides);
  }
  if (options.generateExports) {
    checks.add(generateExports);
  }
  if (options.exportTestFunctions) {
    checks.add(exportTestFunctions);
  }
  if (options.closurePass) {
    checks.add(closurePrimitives);
  }
  if (options.closurePass && options.checkMissingGetCssNameLevel.isOn()) {
    checks.add(closureCheckGetCssName);
  }
  if (options.syntheticBlockStartMarker != null) {
    checks.add(createSyntheticBlocks);
  }
  checks.add(checkVars);
  if (options.inferConsts) {
    checks.add(inferConsts);
  }
  if (options.computeFunctionSideEffects) {
    checks.add(checkRegExp);
  }
  if (options.processObjectPropertyString) {
    checks.add(objectPropertyStringPreprocess);
  }
  checks.add(createEmptyPass(""String_Node_Str""));
  if (options.useNewTypeInference) {
    checks.add(symbolTableForNewTypeInference);
    checks.add(newTypeInference);
  }
  if (options.checkTypes || options.inferTypes) {
    checks.add(resolveTypes);
    checks.add(inferTypes);
    if (options.checkTypes) {
      checks.add(checkTypes);
    }
 else {
      checks.add(inferJsDocInfo);
    }
    if (!options.ideMode) {
      checks.add(clearTypedScopePass);
    }
  }
  if (!options.disables(DiagnosticGroups.CHECK_USELESS_CODE) || options.checkMissingReturn.isOn()) {
    checks.add(checkControlFlow);
  }
  if (options.checkTypes && (!options.disables(DiagnosticGroups.ACCESS_CONTROLS) || options.enables(DiagnosticGroups.CONSTANT_PROPERTY))) {
    checks.add(checkAccessControls);
  }
  if (options.enables(DiagnosticGroups.LINT_CHECKS)) {
    checks.add(lintChecks);
  }
  if (options.checkEventfulObjectDisposalPolicy != CheckEventfulObjectDisposal.DisposalCheckingPolicy.OFF) {
    checks.add(checkEventfulObjectDisposal);
  }
  if (options.checkGlobalNamesLevel.isOn()) {
    checks.add(checkGlobalNames);
  }
  if (options.enables(DiagnosticGroups.ES5_STRICT)) {
    checks.add(checkStrictMode);
  }
  if (!options.getConformanceConfigs().isEmpty()) {
    checks.add(checkConformance);
  }
  if (options.closurePass) {
    checks.add(closureReplaceGetCssName);
  }
  if (options.replaceMessagesWithChromeI18n) {
    checks.add(replaceMessagesForChrome);
  }
 else   if (options.messageBundle != null) {
    checks.add(replaceMessages);
  }
  if (options.getTweakProcessing().isOn()) {
    checks.add(processTweaks);
  }
  checks.add(processDefines);
  if (options.instrumentationTemplate != null || options.recordFunctionInformation) {
    checks.add(computeFunctionNames);
  }
  if (options.nameReferenceGraphPath != null && !options.nameReferenceGraphPath.isEmpty()) {
    checks.add(printNameReferenceGraph);
  }
  if (options.nameReferenceReportPath != null && !options.nameReferenceReportPath.isEmpty()) {
    checks.add(printNameReferenceReport);
  }
  checks.add(createEmptyPass(""String_Node_Str""));
  assertAllOneTimePasses(checks);
  return checks;
}","@Override protected List<PassFactory> getChecks(){
  List<PassFactory> checks=Lists.newArrayList();
  checks.add(createEmptyPass(""String_Node_Str""));
  if (options.closurePass) {
    checks.add(closureRewriteModule);
  }
  if (options.lowerFromEs6() || options.aggressiveVarCheck.isOn()) {
    checks.add(checkVariableReferences);
  }
  if (options.getLanguageIn() == LanguageMode.ECMASCRIPT6_TYPED && options.getLanguageOut() != LanguageMode.ECMASCRIPT6_TYPED) {
    checks.add(convertDeclaredTypesToJSDoc);
  }
  if (options.lowerFromEs6()) {
    checks.add(es6RenameVariablesInParamLists);
    checks.add(es6SplitVariableDeclarations);
    checks.add(es6ConvertSuper);
  }
  if (options.getLanguageIn() == LanguageMode.ECMASCRIPT6_TYPED && options.getLanguageOut() != LanguageMode.ECMASCRIPT6_TYPED) {
    checks.add(convertEs6TypedToEs6);
  }
  if (options.lowerFromEs6()) {
    checks.add(convertEs6ToEs3);
    checks.add(rewriteLetConst);
    checks.add(rewriteGenerators);
    checks.add(markTranspilationDone);
  }
  if (options.raiseToEs6Typed()) {
    checks.add(convertToTypedES6);
  }
  if (options.transpileOnly) {
    return checks;
  }
  if (options.lowerFromEs6()) {
    checks.add(es6RuntimeLibrary);
  }
  checks.add(convertStaticInheritance);
  if (options.declaredGlobalExternsOnWindow) {
    checks.add(declaredGlobalExternsOnWindow);
  }
  if (options.closurePass) {
    checks.add(closureGoogScopeAliases);
    checks.add(closureRewriteClass);
  }
  if (options.jqueryPass) {
    checks.add(jqueryAliases);
  }
  if (options.angularPass) {
    checks.add(angularPass);
  }
  if (options.polymerPass) {
    checks.add(polymerPass);
  }
  checks.add(checkSideEffects);
  if (options.checkSuspiciousCode || options.enables(DiagnosticGroups.GLOBAL_THIS) || options.enables(DiagnosticGroups.DEBUGGER_STATEMENT_PRESENT)) {
    checks.add(suspiciousCode);
  }
  if (options.enables(DiagnosticGroups.MISSING_REQUIRE) || options.enables(DiagnosticGroups.EXTRA_REQUIRE)) {
    checks.add(checkRequires);
  }
  if (options.checkProvides.isOn()) {
    checks.add(checkProvides);
  }
  if (options.generateExports) {
    checks.add(generateExports);
  }
  if (options.exportTestFunctions) {
    checks.add(exportTestFunctions);
  }
  if (options.closurePass) {
    checks.add(closurePrimitives);
  }
  if (options.closurePass && options.checkMissingGetCssNameLevel.isOn()) {
    checks.add(closureCheckGetCssName);
  }
  if (options.syntheticBlockStartMarker != null) {
    checks.add(createSyntheticBlocks);
  }
  checks.add(checkVars);
  if (options.inferConsts) {
    checks.add(inferConsts);
  }
  if (options.computeFunctionSideEffects) {
    checks.add(checkRegExp);
  }
  if (options.processObjectPropertyString) {
    checks.add(objectPropertyStringPreprocess);
  }
  checks.add(createEmptyPass(""String_Node_Str""));
  if (options.useNewTypeInference) {
    checks.add(symbolTableForNewTypeInference);
    checks.add(newTypeInference);
  }
  if (options.checkTypes || options.inferTypes) {
    checks.add(resolveTypes);
    checks.add(inferTypes);
    if (options.checkTypes) {
      checks.add(checkTypes);
    }
 else {
      checks.add(inferJsDocInfo);
    }
    if (!options.ideMode) {
      checks.add(clearTypedScopePass);
    }
  }
  if (!options.disables(DiagnosticGroups.CHECK_USELESS_CODE) || options.checkMissingReturn.isOn()) {
    checks.add(checkControlFlow);
  }
  if (options.checkTypes && (!options.disables(DiagnosticGroups.ACCESS_CONTROLS) || options.enables(DiagnosticGroups.CONSTANT_PROPERTY))) {
    checks.add(checkAccessControls);
  }
  if (options.enables(DiagnosticGroups.LINT_CHECKS)) {
    checks.add(lintChecks);
  }
  if (options.checkEventfulObjectDisposalPolicy != CheckEventfulObjectDisposal.DisposalCheckingPolicy.OFF) {
    checks.add(checkEventfulObjectDisposal);
  }
  if (options.checkGlobalNamesLevel.isOn()) {
    checks.add(checkGlobalNames);
  }
  if (options.enables(DiagnosticGroups.ES5_STRICT)) {
    checks.add(checkStrictMode);
  }
  if (!options.getConformanceConfigs().isEmpty()) {
    checks.add(checkConformance);
  }
  if (options.closurePass) {
    checks.add(closureReplaceGetCssName);
  }
  if (options.replaceMessagesWithChromeI18n) {
    checks.add(replaceMessagesForChrome);
  }
 else   if (options.messageBundle != null) {
    checks.add(replaceMessages);
  }
  if (options.getTweakProcessing().isOn()) {
    checks.add(processTweaks);
  }
  checks.add(processDefines);
  if (options.instrumentationTemplate != null || options.recordFunctionInformation) {
    checks.add(computeFunctionNames);
  }
  if (options.nameReferenceGraphPath != null && !options.nameReferenceGraphPath.isEmpty()) {
    checks.add(printNameReferenceGraph);
  }
  if (options.nameReferenceReportPath != null && !options.nameReferenceReportPath.isEmpty()) {
    checks.add(printNameReferenceReport);
  }
  checks.add(createEmptyPass(""String_Node_Str""));
  assertAllOneTimePasses(checks);
  return checks;
}",0.9948270615681104
27573,"public void testWarning(){
  testSame(""String_Node_Str"",EXTRA_REQUIRE_WARNING);
}","public void testWarning(){
  testError(""String_Node_Str"",EXTRA_REQUIRE_WARNING);
  testError(""String_Node_Str"",EXTRA_REQUIRE_WARNING);
}",0.728110599078341
27574,"public void testNoWarning(){
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
}","public void testNoWarning(){
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
}",0.8219633943427621
27575,"@Override protected CompilerOptions getOptions(CompilerOptions options){
  options.setWarningLevel(DiagnosticGroups.EXTRA_REQUIRE,CheckLevel.WARNING);
  return super.getOptions(options);
}","@Override protected CompilerOptions getOptions(CompilerOptions options){
  options.setWarningLevel(DiagnosticGroups.EXTRA_REQUIRE,CheckLevel.ERROR);
  return super.getOptions(options);
}",0.9732620320855616
27576,"@Override public void visit(NodeTraversal t,Node n,Node parent){
  TypeDeclarationNode type=n.getDeclaredTypeExpression();
  if (type == null) {
    return;
  }
  JSDocInfo info=n.getJSDocInfo();
  Preconditions.checkState(info == null || info.getType() == null,""String_Node_Str"");
  JSDocInfoBuilder builder=JSDocInfoBuilder.maybeCopyFrom(info);
  Node typeRoot=convertWithLocation(type);
  JSTypeExpression typeExpression=new JSTypeExpression(typeRoot,n.getSourceFileName());
  if (n.isFunction()) {
    builder.recordReturnType(typeExpression);
  }
 else {
    builder.recordType(typeExpression);
    builder.recordInlineType();
  }
  info=builder.build(n);
  n.setJSDocInfo(info);
  n.setDeclaredTypeExpression(null);
}","@Override public void visit(NodeTraversal t,Node n,Node parent){
  TypeDeclarationNode type=n.getDeclaredTypeExpression();
  if (type == null) {
    return;
  }
  JSDocInfo info=n.getJSDocInfo();
  Preconditions.checkState(info == null || info.getType() == null,""String_Node_Str"");
  JSDocInfoBuilder builder=JSDocInfoBuilder.maybeCopyFrom(info);
  Node typeRoot=convertWithLocation(type);
  JSTypeExpression typeExpression=new JSTypeExpression(typeRoot,n.getSourceFileName());
  if (n.isFunction()) {
    builder.recordReturnType(typeExpression);
  }
 else   if (n.getType() == Token.MEMBER_VARIABLE_DEF) {
    builder.recordType(typeExpression);
  }
 else {
    builder.recordType(typeExpression);
    builder.recordInlineType();
  }
  info=builder.build(n);
  n.setJSDocInfo(info);
  n.setDeclaredTypeExpression(null);
}",0.9353169469598964
27577,"private boolean mayAddPropToType(Node getProp,RawNominalType rawType){
  if (!rawType.isStruct()) {
    return true;
  }
  Node parent=getProp.getParent();
  return parent.isAssign() && getProp == parent.getFirstChild() && currentScope.isConstructor();
}","private boolean mayAddPropToType(Node getProp,RawNominalType rawType){
  if (!rawType.isStruct()) {
    return true;
  }
  Node parent=getProp.getParent();
  return (parent.isAssign() && getProp == parent.getFirstChild() || parent.isExprResult()) && currentScope.isConstructor();
}",0.9495327102803738
27578,"public void testBasicTypeCheck_error() throws Exception {
  test(createCompilerOptions(),""String_Node_Str"",TypeValidator.TYPE_MISMATCH_WARNING);
}","public void testBasicTypeCheck_error(){
  test(createCompilerOptions(),""String_Node_Str"",TypeValidator.TYPE_MISMATCH_WARNING);
}",0.9343065693430656
27579,"public void testFunctionParameter_error() throws Exception {
  test(createCompilerOptions(),""String_Node_Str"",TypeValidator.TYPE_MISMATCH_WARNING);
}","public void testFunctionParameter_error(){
  test(createCompilerOptions(),""String_Node_Str"",TypeValidator.TYPE_MISMATCH_WARNING);
}",0.9357142857142856
27580,"public void testFunctionParameter() throws Exception {
  test(createCompilerOptions(),""String_Node_Str"",""String_Node_Str"");
}","public void testFunctionParameter(){
  test(createCompilerOptions(),""String_Node_Str"",""String_Node_Str"");
}",0.9224137931034484
27581,"public void testClassMemberVariable() throws Exception {
  test(createCompilerOptions(),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"");
  test(createCompilerOptions(),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",TypeValidator.TYPE_MISMATCH_WARNING);
}","public void testClassMemberVariable(){
  test(createCompilerOptions(),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"");
  test(createCompilerOptions(),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",TypeValidator.TYPE_MISMATCH_WARNING);
}",0.9703947368421052
27582,"public void testFunctionType_error() throws Exception {
  test(createCompilerOptions(),""String_Node_Str"",TypeValidator.TYPE_MISMATCH_WARNING);
}","public void testFunctionType_error(){
  test(createCompilerOptions(),""String_Node_Str"",TypeValidator.TYPE_MISMATCH_WARNING);
}",0.9333333333333332
27583,"public void testFunctionType_correct() throws Exception {
  test(createCompilerOptions(),""String_Node_Str"",""String_Node_Str"");
}","public void testFunctionType_correct(){
  test(createCompilerOptions(),""String_Node_Str"",""String_Node_Str"");
}",0.9243697478991596
27584,"public void testBasicTypeCheck() throws Exception {
  test(createCompilerOptions(),""String_Node_Str"",""String_Node_Str"");
}","public void testBasicTypeCheck(){
  test(createCompilerOptions(),""String_Node_Str"",""String_Node_Str"");
}",0.9203539823008848
27585,"public void testClassMemberVariable_static() throws Exception {
  test(createCompilerOptions(),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"");
  test(createCompilerOptions(),""String_Node_Str"" + ""String_Node_Str"",TypeValidator.TYPE_MISMATCH_WARNING);
}","public void testClassMemberVariable_static(){
  test(createCompilerOptions(),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"");
  test(createCompilerOptions(),""String_Node_Str"" + ""String_Node_Str"",TypeValidator.TYPE_MISMATCH_WARNING);
}",0.9669117647058824
27586,"public void testStructPropAccess(){
  typeCheck(""String_Node_Str"" + ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"",TypeValidator.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",TypeValidator.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",TypeValidator.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"",TypeValidator.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"",TypeValidator.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"",TypeValidator.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",TypeValidator.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(""String_Node_Str"",TypeCheck.ILLEGAL_OBJLIT_KEY);
  typeCheck(""String_Node_Str"",TypeValidator.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",TypeValidator.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",TypeValidator.ILLEGAL_PROPERTY_ACCESS);
}","public void testStructPropAccess(){
  typeCheck(""String_Node_Str"" + ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"",TypeValidator.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",TypeValidator.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",TypeValidator.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"",TypeValidator.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"",TypeValidator.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"",TypeValidator.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",TypeValidator.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(""String_Node_Str"",TypeCheck.ILLEGAL_OBJLIT_KEY);
  typeCheck(""String_Node_Str"",TypeValidator.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",TypeValidator.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",TypeValidator.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
}",0.8767274737423991
27587,"protected final void addES6TranspilationPasses(){
  passes.add(makePassFactory(""String_Node_Str"",new Es6RenameVariablesInParamLists(compiler)));
  passes.add(makePassFactory(""String_Node_Str"",new Es6SplitVariableDeclarations(compiler)));
  passes.add(makePassFactory(""String_Node_Str"",new Es6ConvertSuper(compiler)));
  passes.add(makePassFactory(""String_Node_Str"",new Es6ToEs3Converter(compiler)));
  passes.add(makePassFactory(""String_Node_Str"",new Es6RewriteLetConst(compiler)));
  passes.add(makePassFactory(""String_Node_Str"",new Es6RewriteGenerators(compiler)));
  passes.add(makePassFactory(""String_Node_Str"",new InjectEs6RuntimeLibrary(compiler)));
  passes.add(makePassFactory(""String_Node_Str"",new Es6ToEs3ClassSideInheritance(compiler)));
}","protected final void addES6TranspilationPasses(){
  passes.add(makePassFactory(""String_Node_Str"",new Es6RenameVariablesInParamLists(compiler)));
  passes.add(makePassFactory(""String_Node_Str"",new Es6SplitVariableDeclarations(compiler)));
  passes.add(makePassFactory(""String_Node_Str"",new Es6ConvertSuper(compiler)));
  passes.add(makePassFactory(""String_Node_Str"",new Es6TypedToEs6Converter(compiler)));
  passes.add(makePassFactory(""String_Node_Str"",new Es6ToEs3Converter(compiler)));
  passes.add(makePassFactory(""String_Node_Str"",new Es6RewriteLetConst(compiler)));
  passes.add(makePassFactory(""String_Node_Str"",new Es6RewriteGenerators(compiler)));
  passes.add(makePassFactory(""String_Node_Str"",new InjectEs6RuntimeLibrary(compiler)));
  passes.add(makePassFactory(""String_Node_Str"",new Es6ToEs3ClassSideInheritance(compiler)));
}",0.945179584120983
27588,"private void visitExport(NodeTraversal t,Node n,Node parent){
  if (n.getBooleanProp(Node.EXPORT_DEFAULT)) {
    Node var=IR.var(IR.name(DEFAULT_EXPORT_NAME),n.removeFirstChild());
    var.useSourceInfoIfMissingFromForTree(n);
    var.setJSDocInfo(n.getJSDocInfo());
    n.setJSDocInfo(null);
    n.getParent().replaceChild(n,var);
    exportMap.put(""String_Node_Str"",DEFAULT_EXPORT_NAME);
  }
 else   if (n.getBooleanProp(Node.EXPORT_ALL_FROM)) {
    compiler.report(JSError.make(n,Es6ToEs3Converter.CANNOT_CONVERT_YET,""String_Node_Str""));
  }
 else   if (n.getChildCount() == 2) {
    Node moduleIdentifier=n.getLastChild();
    Node importNode=new Node(Token.IMPORT,moduleIdentifier.cloneNode());
    importNode.copyInformationFrom(n);
    parent.addChildBefore(importNode,n);
    visit(t,importNode,parent);
    String loadAddress=loader.locate(moduleIdentifier.getString(),t.getInput());
    String moduleName=toModuleName(loadAddress);
    for (    Node exportSpec : n.getFirstChild().children()) {
      String nameFromOtherModule=exportSpec.getFirstChild().getString();
      String exportedName=exportSpec.getLastChild().getString();
      exportMap.put(exportedName,moduleName + ""String_Node_Str"" + nameFromOtherModule);
    }
    parent.removeChild(n);
  }
 else {
    if (n.getFirstChild().getType() == Token.EXPORT_SPECS) {
      for (      Node exportSpec : n.getFirstChild().children()) {
        Node origName=exportSpec.getFirstChild();
        exportMap.put(exportSpec.getChildCount() == 2 ? exportSpec.getLastChild().getString() : origName.getString(),origName.getString());
      }
      parent.removeChild(n);
    }
 else {
      Node declaration=n.getFirstChild();
      for (int i=0; i < declaration.getChildCount(); i++) {
        Node maybeName=declaration.getChildAtIndex(i);
        if (!maybeName.isName()) {
          break;
        }
        if (declaration.isClass() && i > 0) {
          break;
        }
        String name=maybeName.getString();
        Var v=t.getScope().getVar(name);
        if (v == null || v.isGlobal()) {
          exportMap.put(name,name);
        }
        if (declaration.isClass()) {
          types.add(name);
        }
      }
      declaration.setJSDocInfo(n.getJSDocInfo());
      n.setJSDocInfo(null);
      parent.replaceChild(n,declaration.detachFromParent());
    }
    compiler.reportCodeChange();
  }
}","private void visitExport(NodeTraversal t,Node export,Node parent){
  if (export.getBooleanProp(Node.EXPORT_DEFAULT)) {
    Node child=export.getFirstChild();
    String name=null;
    if (child.isFunction()) {
      name=NodeUtil.getFunctionName(child);
    }
 else     if (child.isClass()) {
      name=NodeUtil.getClassName(child);
    }
    if (name != null) {
      Node decl=child.cloneTree();
      decl.setJSDocInfo(export.getJSDocInfo());
      parent.replaceChild(export,decl);
      exportMap.put(""String_Node_Str"",name);
    }
 else {
      Node var=IR.var(IR.name(DEFAULT_EXPORT_NAME),export.removeFirstChild());
      var.useSourceInfoIfMissingFromForTree(export);
      parent.replaceChild(export,var);
      exportMap.put(""String_Node_Str"",DEFAULT_EXPORT_NAME);
    }
  }
 else   if (export.getBooleanProp(Node.EXPORT_ALL_FROM)) {
    compiler.report(JSError.make(export,Es6ToEs3Converter.CANNOT_CONVERT_YET,""String_Node_Str""));
  }
 else   if (export.getChildCount() == 2) {
    Node moduleIdentifier=export.getLastChild();
    Node importNode=new Node(Token.IMPORT,moduleIdentifier.cloneNode());
    importNode.copyInformationFrom(export);
    parent.addChildBefore(importNode,export);
    visit(t,importNode,parent);
    String loadAddress=loader.locate(moduleIdentifier.getString(),t.getInput());
    String moduleName=toModuleName(loadAddress);
    for (    Node exportSpec : export.getFirstChild().children()) {
      String nameFromOtherModule=exportSpec.getFirstChild().getString();
      String exportedName=exportSpec.getLastChild().getString();
      exportMap.put(exportedName,moduleName + ""String_Node_Str"" + nameFromOtherModule);
    }
    parent.removeChild(export);
  }
 else {
    if (export.getFirstChild().getType() == Token.EXPORT_SPECS) {
      for (      Node exportSpec : export.getFirstChild().children()) {
        Node origName=exportSpec.getFirstChild();
        exportMap.put(exportSpec.getChildCount() == 2 ? exportSpec.getLastChild().getString() : origName.getString(),origName.getString());
      }
      parent.removeChild(export);
    }
 else {
      Node declaration=export.getFirstChild();
      for (int i=0; i < declaration.getChildCount(); i++) {
        Node maybeName=declaration.getChildAtIndex(i);
        if (!maybeName.isName()) {
          break;
        }
        if (declaration.isClass() && i > 0) {
          break;
        }
        String name=maybeName.getString();
        Var v=t.getScope().getVar(name);
        if (v == null || v.isGlobal()) {
          exportMap.put(name,name);
        }
        if (declaration.isClass()) {
          types.add(name);
        }
      }
      declaration.setJSDocInfo(export.getJSDocInfo());
      export.setJSDocInfo(null);
      parent.replaceChild(export,declaration.detachFromParent());
    }
    compiler.reportCodeChange();
  }
}",0.8642117376294591
27589,"public void testExportDefault(){
  test(""String_Node_Str"",Joiner.on('\n').join(FILEOVERVIEW,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  test(""String_Node_Str"",Joiner.on('\n').join(FILEOVERVIEW,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testExportDefault(){
  test(""String_Node_Str"",Joiner.on('\n').join(FILEOVERVIEW,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  test(""String_Node_Str"",Joiner.on('\n').join(FILEOVERVIEW,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  test(""String_Node_Str"",Joiner.on('\n').join(FILEOVERVIEW,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  test(""String_Node_Str"",Joiner.on('\n').join(FILEOVERVIEW,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.652267818574514
27590,"private EnvTypePair analyzeLogicalOpFwd(Node expr,TypeEnv inEnv,JSType requiredType,JSType specializedType){
  int exprKind=expr.getType();
  Node lhs=expr.getFirstChild();
  Node rhs=expr.getLastChild();
  if ((specializedType.isTruthy() && exprKind == Token.AND) || (specializedType.isFalsy() && exprKind == Token.OR)) {
    EnvTypePair lhsPair=analyzeExprFwd(lhs,inEnv,JSType.UNKNOWN,specializedType);
    EnvTypePair rhsPair=analyzeExprFwd(rhs,lhsPair.env,JSType.UNKNOWN,specializedType);
    return rhsPair;
  }
 else   if ((specializedType.isFalsy() && exprKind == Token.AND) || (specializedType.isTruthy() && exprKind == Token.OR)) {
    EnvTypePair shortCircuitPair=analyzeExprFwd(lhs,inEnv,JSType.UNKNOWN,specializedType);
    EnvTypePair lhsPair=analyzeExprFwd(lhs,inEnv,JSType.UNKNOWN,specializedType.negate());
    EnvTypePair rhsPair=analyzeExprFwd(rhs,lhsPair.env,JSType.UNKNOWN,specializedType);
    return EnvTypePair.join(rhsPair,shortCircuitPair);
  }
 else {
    JSType stopAfterLhsType=exprKind == Token.AND ? JSType.FALSY : JSType.TRUTHY;
    EnvTypePair shortCircuitPair=analyzeExprFwd(lhs,inEnv,requiredType,stopAfterLhsType);
    EnvTypePair lhsPair=analyzeExprFwd(lhs,inEnv,JSType.UNKNOWN,stopAfterLhsType.negate());
    EnvTypePair rhsPair=analyzeExprFwd(rhs,lhsPair.env,requiredType,specializedType);
    return EnvTypePair.join(rhsPair,shortCircuitPair);
  }
}","private EnvTypePair analyzeLogicalOpFwd(Node expr,TypeEnv inEnv,JSType requiredType,JSType specializedType){
  int exprKind=expr.getType();
  Node lhs=expr.getFirstChild();
  Node rhs=expr.getLastChild();
  if ((specializedType.isTruthy() && exprKind == Token.AND) || (specializedType.isFalsy() && exprKind == Token.OR)) {
    EnvTypePair lhsPair=analyzeExprFwd(lhs,inEnv,JSType.UNKNOWN,specializedType);
    EnvTypePair rhsPair=analyzeExprFwd(rhs,lhsPair.env,JSType.UNKNOWN,specializedType);
    return rhsPair;
  }
 else   if ((specializedType.isFalsy() && exprKind == Token.AND) || (specializedType.isTruthy() && exprKind == Token.OR)) {
    EnvTypePair shortCircuitPair=analyzeExprFwd(lhs,inEnv,JSType.UNKNOWN,specializedType);
    EnvTypePair lhsPair=analyzeExprFwd(lhs,inEnv,JSType.UNKNOWN,specializedType.negate());
    EnvTypePair rhsPair=analyzeExprFwd(rhs,lhsPair.env,JSType.UNKNOWN,specializedType);
    return EnvTypePair.join(rhsPair,shortCircuitPair);
  }
 else {
    JSType stopAfterLhsType=exprKind == Token.AND ? JSType.FALSY : JSType.TRUTHY;
    EnvTypePair shortCircuitPair=analyzeExprFwd(lhs,inEnv,JSType.UNKNOWN,stopAfterLhsType);
    EnvTypePair lhsPair=analyzeExprFwd(lhs,inEnv,JSType.UNKNOWN,stopAfterLhsType.negate());
    EnvTypePair rhsPair=analyzeExprFwd(rhs,lhsPair.env,requiredType,specializedType);
    return EnvTypePair.join(rhsPair,shortCircuitPair);
  }
}",0.8264938804895609
27591,"public void testAndOr(){
  typeCheck(""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
}","public void testAndOr(){
  typeCheck(""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
}",0.7931034482758621
27592,"private boolean isSubtypeOfHelper(boolean keepLoosenessOfThis,JSType other){
  if (isUnknown() || other.isUnknown() || other.isTop()) {
    return true;
  }
  if (!EnumType.areSubtypes(this,other)) {
    return false;
  }
  int mask=getMask() & ~ENUM_MASK;
  if ((mask | other.getMask()) != other.getMask()) {
    return false;
  }
  if (!Objects.equals(getTypeVar(),other.getTypeVar())) {
    return false;
  }
  if (getObjs() == null) {
    return true;
  }
  return ObjectType.isUnionSubtype(keepLoosenessOfThis,getObjs(),other.getObjs());
}","private boolean isSubtypeOfHelper(boolean keepLoosenessOfThis,JSType other){
  if (isUnknown() || other.isUnknown() || other.isTop()) {
    return true;
  }
  if (!EnumType.areSubtypes(this,other)) {
    return false;
  }
  int mask=getMask() & ~ENUM_MASK;
  if ((mask | other.getMask()) != other.getMask()) {
    return false;
  }
  if (getTypeVar() != null && !getTypeVar().equals(other.getTypeVar())) {
    return false;
  }
  if (getObjs() == null) {
    return true;
  }
  return ObjectType.isUnionSubtype(keepLoosenessOfThis,getObjs(),other.getObjs());
}",0.9492753623188406
27593,"/** 
 * Removes a cast from the given node.
 */
public Builder removeCast(Node n,AbstractCompiler compiler){
  Preconditions.checkArgument(n.isCast());
  JSDocInfo jsDoc=n.getJSDocInfo();
  Node child=n.getFirstChild();
  replacements.put(n.getSourceFileName(),new CodeReplacement(jsDoc.getOriginalCommentPosition(),n.getSourceOffset() + n.getLength() - jsDoc.getOriginalCommentPosition(),generateCode(compiler,child)));
  return this;
}","/** 
 * Removes a cast from the given node.
 */
public Builder removeCast(Node n,AbstractCompiler compiler){
  Preconditions.checkArgument(n.isCast());
  JSDocInfo jsDoc=n.getJSDocInfo();
  replacements.put(n.getSourceFileName(),new CodeReplacement(jsDoc.getOriginalCommentPosition(),n.getSourceOffset() - jsDoc.getOriginalCommentPosition() + 1,""String_Node_Str""));
  replacements.put(n.getSourceFileName(),new CodeReplacement(n.getSourceOffset() + n.getLength() - 1,1,""String_Node_Str""));
  return this;
}",0.4178154825026511
27594,"@Test public void testRemoveCast(){
  String before=""String_Node_Str"";
  String after=""String_Node_Str"";
  Compiler compiler=getCompiler(before + after);
  JSError[] errors=compiler.getErrors();
  assertEquals(Arrays.toString(errors),1,errors.length);
  SuggestedFix fix=ErrorToFixMapper.getFixForJsError(errors[0],compiler);
  CodeReplacement replacement=new CodeReplacement(before.length(),after.length() - 1,""String_Node_Str"");
  assertReplacement(fix,replacement);
}","@Test public void testRemoveCast(){
  String code=""String_Node_Str"";
  String expectedCode=""String_Node_Str"";
  Compiler compiler=getCompiler(code);
  JSError[] errors=compiler.getErrors();
  assertEquals(Arrays.toString(errors),1,errors.length);
  SuggestedFix fix=ErrorToFixMapper.getFixForJsError(errors[0],compiler);
  assertChanges(fix,""String_Node_Str"",code,expectedCode);
}",0.7694117647058824
27595,"@Test public void testRemoveCast(){
  String input=""String_Node_Str"";
  Compiler compiler=getCompiler(input);
  Node root=compileToScriptRoot(compiler);
  Node castNode=root.getFirstChild().getFirstChild().getFirstChild();
  assertTrue(castNode.isCast());
  SuggestedFix fix=new SuggestedFix.Builder().removeCast(castNode,compiler).build();
  CodeReplacement replacement=new CodeReplacement(""String_Node_Str"".length(),""String_Node_Str"".length(),""String_Node_Str"");
  assertReplacement(fix,replacement);
}","@Test public void testRemoveCast(){
  String input=""String_Node_Str"";
  String expectedCode=""String_Node_Str"";
  Compiler compiler=getCompiler(input);
  Node root=compileToScriptRoot(compiler);
  Node castNode=root.getFirstChild().getFirstChild().getFirstChild();
  assertTrue(castNode.isCast());
  SuggestedFix fix=new SuggestedFix.Builder().removeCast(castNode,compiler).build();
  assertChanges(fix,""String_Node_Str"",input,expectedCode);
}",0.7780126849894292
27596,"void add(String newcode){
  maybeEndStatement();
  if (newcode.isEmpty()) {
    return;
  }
  char c=newcode.charAt(0);
  if ((isWordChar(c) || c == '\\') && isWordChar(getLastChar())) {
    append(""String_Node_Str"");
  }
 else   if (c == '/' && getLastChar() == '/') {
    append(""String_Node_Str"");
  }
 else   if (c == '""' && isWordChar(getLastChar())) {
    maybeInsertSpace();
  }
  append(newcode);
}","void add(String newcode){
  maybeEndStatement();
  if (newcode.isEmpty()) {
    return;
  }
  char c=newcode.charAt(0);
  if ((isWordChar(c) || c == '\\') && isWordChar(getLastChar())) {
    append(""String_Node_Str"");
  }
 else   if (c == '/' && getLastChar() == '/') {
    append(""String_Node_Str"");
  }
 else   if ((c == '""' || c == '\'') && isWordChar(getLastChar())) {
    maybeInsertSpace();
  }
  append(newcode);
}",0.9818621523579202
27597,"void add(Node n,Context context){
  if (!cc.continueProcessing()) {
    return;
  }
  if (preserveTypeAnnotations) {
    if (n.getJSDocInfo() != null) {
      add(JSDocInfoPrinter.print(n.getJSDocInfo()));
    }
  }
  int type=n.getType();
  String opstr=NodeUtil.opToStr(type);
  int childCount=n.getChildCount();
  Node first=n.getFirstChild();
  Node last=n.getLastChild();
  if (opstr != null && first != last) {
    Preconditions.checkState(childCount == 2,""String_Node_Str"",opstr,childCount);
    int p=NodeUtil.precedence(type);
    Context rhsContext=getContextForNoInOperator(context);
    if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
      addExpr(first,p,context);
      cc.addOp(opstr,true);
      addExpr(last,p,rhsContext);
    }
 else {
      unrollBinaryOperator(n,type,opstr,context,rhsContext,p,p + 1);
    }
    return;
  }
  cc.startSourceMapping(n);
switch (type) {
case Token.TRY:
{
      Preconditions.checkState(first.getNext().isBlock() && !first.getNext().hasMoreThanOneChild());
      Preconditions.checkState(childCount >= 2 && childCount <= 3);
      add(""String_Node_Str"");
      add(first,Context.PRESERVE_BLOCK);
      Node catchblock=first.getNext().getFirstChild();
      if (catchblock != null) {
        add(catchblock);
      }
      if (childCount == 3) {
        cc.maybeInsertSpace();
        add(""String_Node_Str"");
        add(last,Context.PRESERVE_BLOCK);
      }
      break;
    }
case Token.CATCH:
  Preconditions.checkState(childCount == 2);
cc.maybeInsertSpace();
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(last,Context.PRESERVE_BLOCK);
break;
case Token.THROW:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
add(first);
cc.endStatement(true);
break;
case Token.RETURN:
add(""String_Node_Str"");
if (childCount == 1) {
add(first);
}
 else {
Preconditions.checkState(childCount == 0);
}
cc.endStatement();
break;
case Token.VAR:
if (first != null) {
add(""String_Node_Str"");
addList(first,false,getContextForNoInOperator(context));
}
break;
case Token.CONST:
add(""String_Node_Str"");
addList(first,false,getContextForNoInOperator(context));
break;
case Token.LET:
add(""String_Node_Str"");
addList(first,false,getContextForNoInOperator(context));
break;
case Token.LABEL_NAME:
Preconditions.checkState(!n.getString().isEmpty());
addIdentifier(n.getString());
break;
case Token.NAME:
addIdentifier(n.getString());
maybeAddTypeDecl(n);
if (first != null && !first.isEmpty()) {
Preconditions.checkState(childCount == 1);
cc.addOp(""String_Node_Str"",true);
if (first.isComma()) {
addExpr(first,NodeUtil.precedence(Token.ASSIGN),Context.OTHER);
}
 else {
addExpr(first,0,getContextForNoInOperator(context));
}
}
break;
case Token.ARRAYLIT:
add(""String_Node_Str"");
addArrayList(first);
add(""String_Node_Str"");
break;
case Token.ARRAY_PATTERN:
addArrayPattern(n);
break;
case Token.PARAM_LIST:
add(""String_Node_Str"");
addList(first);
add(""String_Node_Str"");
break;
case Token.DEFAULT_VALUE:
add(first);
maybeAddTypeDecl(n);
cc.addOp(""String_Node_Str"",true);
add(first.getNext());
break;
case Token.COMMA:
Preconditions.checkState(childCount == 2);
unrollBinaryOperator(n,Token.COMMA,""String_Node_Str"",context,getContextForNoInOperator(context),0,0);
break;
case Token.NUMBER:
Preconditions.checkState(childCount == 0);
cc.addNumber(n.getDouble());
break;
case Token.TYPEOF:
case Token.VOID:
case Token.NOT:
case Token.BITNOT:
case Token.POS:
{
Preconditions.checkState(childCount == 1);
cc.addOp(NodeUtil.opToStrNoFail(type),false);
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
break;
}
case Token.NEG:
{
Preconditions.checkState(childCount == 1);
if (n.getFirstChild().isNumber()) {
cc.addNumber(-n.getFirstChild().getDouble());
}
 else {
cc.addOp(NodeUtil.opToStrNoFail(type),false);
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
}
break;
}
case Token.HOOK:
{
Preconditions.checkState(childCount == 3);
int p=NodeUtil.precedence(type);
Context rhsContext=getContextForNoInOperator(context);
addExpr(first,p + 1,context);
cc.addOp(""String_Node_Str"",true);
addExpr(first.getNext(),1,rhsContext);
cc.addOp(""String_Node_Str"",true);
addExpr(last,1,rhsContext);
break;
}
case Token.REGEXP:
if (!first.isString() || !last.isString()) {
throw new Error(""String_Node_Str"");
}
String regexp=regexpEscape(first.getString(),outputCharsetEncoder);
if (childCount == 2) {
add(regexp + last.getString());
}
 else {
Preconditions.checkState(childCount == 1);
add(regexp);
}
break;
case Token.FUNCTION:
if (n.getClass() != Node.class) {
throw new Error(""String_Node_Str"");
}
Preconditions.checkState(childCount == 3);
boolean isArrow=n.isArrowFunction();
boolean notSingleExpr=n.getParent() == null || !n.getParent().isExprResult();
boolean funcNeedsParens=(context == Context.START_OF_EXPR) && (!isArrow || notSingleExpr);
if (funcNeedsParens) {
add(""String_Node_Str"");
}
if (!isArrow) {
add(""String_Node_Str"");
}
if (n.isGeneratorFunction()) {
add(""String_Node_Str"");
}
add(first);
add(first.getNext());
maybeAddTypeDecl(n);
if (isArrow) {
cc.addOp(""String_Node_Str"",true);
}
add(last,Context.PRESERVE_BLOCK);
cc.endFunction(context == Context.STATEMENT);
if (funcNeedsParens) {
add(""String_Node_Str"");
}
break;
case Token.REST:
add(""String_Node_Str"");
add(n.getString());
break;
case Token.SPREAD:
add(""String_Node_Str"");
add(n.getFirstChild());
break;
case Token.EXPORT:
add(""String_Node_Str"");
if (n.getBooleanProp(Node.EXPORT_DEFAULT)) {
add(""String_Node_Str"");
}
if (n.getBooleanProp(Node.EXPORT_ALL_FROM)) {
add(""String_Node_Str"");
Preconditions.checkState(first != null && first.isEmpty());
}
 else {
add(first);
}
if (childCount == 2) {
add(""String_Node_Str"");
add(last);
}
cc.endStatement();
break;
case Token.MODULE:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(last);
cc.endStatement();
break;
case Token.IMPORT:
add(""String_Node_Str"");
Node second=first.getNext();
if (!first.isEmpty()) {
add(first);
if (!second.isEmpty()) {
cc.listSeparator();
}
}
if (!second.isEmpty()) {
add(second);
}
if (!first.isEmpty() || !second.isEmpty()) {
add(""String_Node_Str"");
}
add(last);
cc.endStatement();
break;
case Token.EXPORT_SPECS:
case Token.IMPORT_SPECS:
add(""String_Node_Str"");
for (Node c=first; c != null; c=c.getNext()) {
if (c != first) {
cc.listSeparator();
}
add(c);
}
add(""String_Node_Str"");
break;
case Token.EXPORT_SPEC:
case Token.IMPORT_SPEC:
add(first);
if (first != last) {
add(""String_Node_Str"");
add(last);
}
break;
case Token.IMPORT_STAR:
add(""String_Node_Str"");
add(""String_Node_Str"");
add(n.getString());
break;
case Token.CLASS:
{
Preconditions.checkState(childCount == 3);
boolean classNeedsParens=(context == Context.START_OF_EXPR);
if (classNeedsParens) {
add(""String_Node_Str"");
}
Node name=first;
Node superClass=first.getNext();
Node members=last;
add(""String_Node_Str"");
if (!name.isEmpty()) {
add(name);
}
if (!superClass.isEmpty()) {
add(""String_Node_Str"");
add(superClass);
}
add(members);
cc.endClass(context == Context.STATEMENT);
if (classNeedsParens) {
add(""String_Node_Str"");
}
}
break;
case Token.CLASS_MEMBERS:
cc.beginBlock();
for (Node c=first; c != null; c=c.getNext()) {
add(c);
cc.maybeLineBreak();
}
cc.endBlock(false);
break;
case Token.GETTER_DEF:
case Token.SETTER_DEF:
case Token.MEMBER_DEF:
{
n.getParent().toStringTree();
Preconditions.checkState(n.getParent().isObjectLit() || n.getParent().isClassMembers());
Preconditions.checkState(childCount == 1);
Preconditions.checkState(first.isFunction());
Preconditions.checkState(first.getFirstChild().getString().isEmpty());
if (n.isStaticMember()) {
add(""String_Node_Str"");
}
if (n.getFirstChild().isGeneratorFunction()) {
Preconditions.checkState(type == Token.MEMBER_DEF);
add(""String_Node_Str"");
}
switch (type) {
case Token.GETTER_DEF:
Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
add(""String_Node_Str"");
break;
case Token.SETTER_DEF:
Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
add(""String_Node_Str"");
break;
case Token.MEMBER_DEF:
break;
}
String name=n.getString();
Node fn=first;
Node parameters=fn.getChildAtIndex(1);
Node body=fn.getLastChild();
if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) && NodeUtil.isLatin(name)) {
add(name);
}
 else {
double d=getSimpleNumber(name);
if (!Double.isNaN(d)) {
cc.addNumber(d);
}
 else {
addJsString(n);
}
}
add(parameters);
add(body,Context.PRESERVE_BLOCK);
break;
}
case Token.SCRIPT:
case Token.BLOCK:
{
if (n.getClass() != Node.class) {
throw new Error(""String_Node_Str"");
}
boolean preserveBlock=context == Context.PRESERVE_BLOCK;
if (preserveBlock) {
cc.beginBlock();
}
boolean preferLineBreaks=type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().isScript());
for (Node c=first; c != null; c=c.getNext()) {
add(c,Context.STATEMENT);
if (c.isVar() || c.isLet() || c.isConst()) {
cc.endStatement();
}
if (c.isFunction() || c.isClass()) {
cc.maybeLineBreak();
}
if (preferLineBreaks) {
cc.notePreferredLineBreak();
}
}
if (preserveBlock) {
cc.endBlock(cc.breakAfterBlockFor(n,context == Context.STATEMENT));
}
break;
}
case Token.FOR:
if (childCount == 4) {
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
if (first.isVar() || first.isLet() || first.isConst()) {
add(first,Context.IN_FOR_INIT_CLAUSE);
}
 else {
addExpr(first,0,Context.IN_FOR_INIT_CLAUSE);
}
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
add(first.getNext().getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
 else {
Preconditions.checkState(childCount == 3);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
break;
case Token.FOR_OF:
Preconditions.checkState(childCount == 3);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case Token.DO:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
addNonEmptyStatement(first,Context.OTHER,false);
cc.maybeInsertSpace();
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(last);
add(""String_Node_Str"");
cc.endStatement();
break;
case Token.WHILE:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case Token.EMPTY:
Preconditions.checkState(childCount == 0);
break;
case Token.GETPROP:
{
Preconditions.checkState(childCount == 2,""String_Node_Str"",childCount);
Preconditions.checkState(last.isString(),""String_Node_Str"");
boolean needsParens=(first.isNumber());
if (needsParens) {
add(""String_Node_Str"");
}
addExpr(first,NodeUtil.precedence(type),context);
if (needsParens) {
add(""String_Node_Str"");
}
if (this.languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(last.getString())) {
add(""String_Node_Str"");
add(last);
add(""String_Node_Str"");
}
 else {
add(""String_Node_Str"");
addIdentifier(last.getString());
}
break;
}
case Token.GETELEM:
Preconditions.checkState(childCount == 2,""String_Node_Str"",childCount);
addExpr(first,NodeUtil.precedence(type),context);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
break;
case Token.WITH:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case Token.INC:
case Token.DEC:
{
Preconditions.checkState(childCount == 1);
String o=type == Token.INC ? ""String_Node_Str"" : ""String_Node_Str"";
boolean postProp=n.getBooleanProp(Node.INCRDECR_PROP);
if (postProp) {
addExpr(first,NodeUtil.precedence(type),context);
cc.addOp(o,false);
}
 else {
cc.addOp(o,false);
add(first);
}
break;
}
case Token.CALL:
if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
add(""String_Node_Str"");
addExpr(first,NodeUtil.precedence(Token.COMMA),Context.OTHER);
add(""String_Node_Str"");
}
 else {
addExpr(first,NodeUtil.precedence(type),context);
}
Node args=first.getNext();
add(""String_Node_Str"");
addList(args);
add(""String_Node_Str"");
break;
case Token.IF:
boolean hasElse=childCount == 3;
boolean ambiguousElseClause=context == Context.BEFORE_DANGLING_ELSE && !hasElse;
if (ambiguousElseClause) {
cc.beginBlock();
}
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
if (childCount == 1) {
break;
}
if (hasElse) {
addNonEmptyStatement(first.getNext(),Context.BEFORE_DANGLING_ELSE,false);
cc.maybeInsertSpace();
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
 else {
addNonEmptyStatement(first.getNext(),Context.OTHER,false);
Preconditions.checkState(childCount == 2);
}
if (ambiguousElseClause) {
cc.endBlock();
}
break;
case Token.NULL:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case Token.THIS:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
break;
case Token.SUPER:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
break;
case Token.YIELD:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
if (n.isYieldFor()) {
add(""String_Node_Str"");
}
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
break;
case Token.FALSE:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case Token.TRUE:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case Token.CONTINUE:
Preconditions.checkState(childCount <= 1);
add(""String_Node_Str"");
if (childCount == 1) {
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
}
cc.endStatement();
break;
case Token.DEBUGGER:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
cc.endStatement();
break;
case Token.BREAK:
Preconditions.checkState(childCount <= 1);
add(""String_Node_Str"");
if (childCount == 1) {
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
}
cc.endStatement();
break;
case Token.EXPR_RESULT:
Preconditions.checkState(childCount == 1);
add(first,Context.START_OF_EXPR);
cc.endStatement();
break;
case Token.NEW:
add(""String_Node_Str"");
int precedence=NodeUtil.precedence(type);
if (NodeUtil.containsType(first,Token.CALL,NodeUtil.MATCH_NOT_FUNCTION)) {
precedence=NodeUtil.precedence(first.getType()) + 1;
}
addExpr(first,precedence,Context.OTHER);
Node next=first.getNext();
if (next != null) {
add(""String_Node_Str"");
addList(next);
add(""String_Node_Str"");
}
break;
case Token.STRING_KEY:
addStringKey(n);
break;
case Token.STRING:
Preconditions.checkState(childCount == 0,""String_Node_Str"");
if (n.getBooleanProp(Node.COOKED_STRING)) {
add(""String_Node_Str"" + n.getString() + ""String_Node_Str"");
}
 else {
addJsString(n);
}
break;
case Token.DELPROP:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
add(first);
break;
case Token.OBJECTLIT:
{
boolean needsParens=(context == Context.START_OF_EXPR);
if (needsParens) {
add(""String_Node_Str"");
}
add(""String_Node_Str"");
for (Node c=first; c != null; c=c.getNext()) {
if (c != first) {
cc.listSeparator();
}
Preconditions.checkState(c.isComputedProp() || c.isGetterDef() || c.isSetterDef()|| c.isStringKey()|| c.isMemberDef());
add(c);
}
add(""String_Node_Str"");
if (needsParens) {
add(""String_Node_Str"");
}
break;
}
case Token.COMPUTED_PROP:
if (n.getBooleanProp(Node.COMPUTED_PROP_GETTER)) {
add(""String_Node_Str"");
}
 else if (n.getBooleanProp(Node.COMPUTED_PROP_SETTER)) {
add(""String_Node_Str"");
}
 else if (last.getBooleanProp(Node.GENERATOR_FN)) {
add(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
if (n.getBooleanProp(Node.COMPUTED_PROP_METHOD) || n.getBooleanProp(Node.COMPUTED_PROP_GETTER) || n.getBooleanProp(Node.COMPUTED_PROP_SETTER)) {
Node function=first.getNext();
Node params=function.getFirstChild().getNext();
Node body=function.getLastChild();
add(params);
add(body,Context.PRESERVE_BLOCK);
}
 else {
add(""String_Node_Str"");
add(first.getNext());
}
break;
case Token.OBJECT_PATTERN:
addObjectPattern(n,context);
break;
case Token.SWITCH:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
cc.beginBlock();
addAllSiblings(first.getNext());
cc.endBlock(context == Context.STATEMENT);
break;
case Token.CASE:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
add(first);
addCaseBody(last);
break;
case Token.DEFAULT_CASE:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
addCaseBody(first);
break;
case Token.LABEL:
Preconditions.checkState(childCount == 2);
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(first);
add(""String_Node_Str"");
if (!last.isBlock()) {
cc.maybeInsertSpace();
}
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),true);
break;
case Token.CAST:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
break;
case Token.TEMPLATELIT:
if (!first.isString()) {
add(first,Context.START_OF_EXPR);
first=first.getNext();
}
add(""String_Node_Str"");
for (Node c=first; c != null; c=c.getNext()) {
if (c.isString()) {
add(c.getString());
}
 else {
cc.append(""String_Node_Str"");
add(c.getFirstChild(),Context.START_OF_EXPR);
add(""String_Node_Str"");
}
}
add(""String_Node_Str"");
break;
case Token.STRING_TYPE:
add(""String_Node_Str"");
break;
case Token.BOOLEAN_TYPE:
add(""String_Node_Str"");
break;
case Token.NUMBER_TYPE:
add(""String_Node_Str"");
break;
case Token.ANY_TYPE:
add(""String_Node_Str"");
break;
case Token.NULL_TYPE:
add(""String_Node_Str"");
break;
case Token.VOID_TYPE:
add(""String_Node_Str"");
break;
case Token.UNDEFINED_TYPE:
add(""String_Node_Str"");
break;
case Token.NAMED_TYPE:
add(first);
break;
case Token.ARRAY_TYPE:
add(first);
add(""String_Node_Str"");
break;
default :
throw new RuntimeException(""String_Node_Str"" + Token.name(type) + ""String_Node_Str""+ n.toStringTree());
}
cc.endSourceMapping(n);
}","void add(Node n,Context context){
  if (!cc.continueProcessing()) {
    return;
  }
  if (preserveTypeAnnotations) {
    if (n.getJSDocInfo() != null) {
      add(JSDocInfoPrinter.print(n.getJSDocInfo()));
    }
  }
  int type=n.getType();
  String opstr=NodeUtil.opToStr(type);
  int childCount=n.getChildCount();
  Node first=n.getFirstChild();
  Node last=n.getLastChild();
  if (opstr != null && first != last) {
    Preconditions.checkState(childCount == 2,""String_Node_Str"",opstr,childCount);
    int p=NodeUtil.precedence(type);
    Context rhsContext=getContextForNoInOperator(context);
    if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
      addExpr(first,p,context);
      cc.addOp(opstr,true);
      addExpr(last,p,rhsContext);
    }
 else {
      unrollBinaryOperator(n,type,opstr,context,rhsContext,p,p + 1);
    }
    return;
  }
  cc.startSourceMapping(n);
switch (type) {
case Token.TRY:
{
      Preconditions.checkState(first.getNext().isBlock() && !first.getNext().hasMoreThanOneChild());
      Preconditions.checkState(childCount >= 2 && childCount <= 3);
      add(""String_Node_Str"");
      add(first,Context.PRESERVE_BLOCK);
      Node catchblock=first.getNext().getFirstChild();
      if (catchblock != null) {
        add(catchblock);
      }
      if (childCount == 3) {
        cc.maybeInsertSpace();
        add(""String_Node_Str"");
        add(last,Context.PRESERVE_BLOCK);
      }
      break;
    }
case Token.CATCH:
  Preconditions.checkState(childCount == 2);
cc.maybeInsertSpace();
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(last,Context.PRESERVE_BLOCK);
break;
case Token.THROW:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(first);
cc.endStatement(true);
break;
case Token.RETURN:
add(""String_Node_Str"");
if (childCount == 1) {
cc.maybeInsertSpace();
add(first);
}
 else {
Preconditions.checkState(childCount == 0);
}
cc.endStatement();
break;
case Token.VAR:
if (first != null) {
add(""String_Node_Str"");
addList(first,false,getContextForNoInOperator(context));
}
break;
case Token.CONST:
add(""String_Node_Str"");
addList(first,false,getContextForNoInOperator(context));
break;
case Token.LET:
add(""String_Node_Str"");
addList(first,false,getContextForNoInOperator(context));
break;
case Token.LABEL_NAME:
Preconditions.checkState(!n.getString().isEmpty());
addIdentifier(n.getString());
break;
case Token.NAME:
addIdentifier(n.getString());
maybeAddTypeDecl(n);
if (first != null && !first.isEmpty()) {
Preconditions.checkState(childCount == 1);
cc.addOp(""String_Node_Str"",true);
if (first.isComma()) {
addExpr(first,NodeUtil.precedence(Token.ASSIGN),Context.OTHER);
}
 else {
addExpr(first,0,getContextForNoInOperator(context));
}
}
break;
case Token.ARRAYLIT:
add(""String_Node_Str"");
addArrayList(first);
add(""String_Node_Str"");
break;
case Token.ARRAY_PATTERN:
addArrayPattern(n);
break;
case Token.PARAM_LIST:
add(""String_Node_Str"");
addList(first);
add(""String_Node_Str"");
break;
case Token.DEFAULT_VALUE:
add(first);
maybeAddTypeDecl(n);
cc.addOp(""String_Node_Str"",true);
add(first.getNext());
break;
case Token.COMMA:
Preconditions.checkState(childCount == 2);
unrollBinaryOperator(n,Token.COMMA,""String_Node_Str"",context,getContextForNoInOperator(context),0,0);
break;
case Token.NUMBER:
Preconditions.checkState(childCount == 0);
cc.addNumber(n.getDouble());
break;
case Token.TYPEOF:
case Token.VOID:
case Token.NOT:
case Token.BITNOT:
case Token.POS:
{
Preconditions.checkState(childCount == 1);
cc.addOp(NodeUtil.opToStrNoFail(type),false);
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
break;
}
case Token.NEG:
{
Preconditions.checkState(childCount == 1);
if (n.getFirstChild().isNumber()) {
cc.addNumber(-n.getFirstChild().getDouble());
}
 else {
cc.addOp(NodeUtil.opToStrNoFail(type),false);
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
}
break;
}
case Token.HOOK:
{
Preconditions.checkState(childCount == 3);
int p=NodeUtil.precedence(type);
Context rhsContext=getContextForNoInOperator(context);
addExpr(first,p + 1,context);
cc.addOp(""String_Node_Str"",true);
addExpr(first.getNext(),1,rhsContext);
cc.addOp(""String_Node_Str"",true);
addExpr(last,1,rhsContext);
break;
}
case Token.REGEXP:
if (!first.isString() || !last.isString()) {
throw new Error(""String_Node_Str"");
}
String regexp=regexpEscape(first.getString(),outputCharsetEncoder);
if (childCount == 2) {
add(regexp + last.getString());
}
 else {
Preconditions.checkState(childCount == 1);
add(regexp);
}
break;
case Token.FUNCTION:
if (n.getClass() != Node.class) {
throw new Error(""String_Node_Str"");
}
Preconditions.checkState(childCount == 3);
boolean isArrow=n.isArrowFunction();
boolean notSingleExpr=n.getParent() == null || !n.getParent().isExprResult();
boolean funcNeedsParens=(context == Context.START_OF_EXPR) && (!isArrow || notSingleExpr);
if (funcNeedsParens) {
add(""String_Node_Str"");
}
if (!isArrow) {
add(""String_Node_Str"");
}
if (n.isGeneratorFunction()) {
add(""String_Node_Str"");
}
add(first);
add(first.getNext());
maybeAddTypeDecl(n);
if (isArrow) {
cc.addOp(""String_Node_Str"",true);
}
add(last,Context.PRESERVE_BLOCK);
cc.endFunction(context == Context.STATEMENT);
if (funcNeedsParens) {
add(""String_Node_Str"");
}
break;
case Token.REST:
add(""String_Node_Str"");
add(n.getString());
break;
case Token.SPREAD:
add(""String_Node_Str"");
add(n.getFirstChild());
break;
case Token.EXPORT:
add(""String_Node_Str"");
if (n.getBooleanProp(Node.EXPORT_DEFAULT)) {
add(""String_Node_Str"");
}
if (n.getBooleanProp(Node.EXPORT_ALL_FROM)) {
add(""String_Node_Str"");
Preconditions.checkState(first != null && first.isEmpty());
}
 else {
add(first);
}
if (childCount == 2) {
add(""String_Node_Str"");
add(last);
}
cc.endStatement();
break;
case Token.MODULE:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(last);
cc.endStatement();
break;
case Token.IMPORT:
add(""String_Node_Str"");
Node second=first.getNext();
if (!first.isEmpty()) {
add(first);
if (!second.isEmpty()) {
cc.listSeparator();
}
}
if (!second.isEmpty()) {
add(second);
}
if (!first.isEmpty() || !second.isEmpty()) {
add(""String_Node_Str"");
}
add(last);
cc.endStatement();
break;
case Token.EXPORT_SPECS:
case Token.IMPORT_SPECS:
add(""String_Node_Str"");
for (Node c=first; c != null; c=c.getNext()) {
if (c != first) {
cc.listSeparator();
}
add(c);
}
add(""String_Node_Str"");
break;
case Token.EXPORT_SPEC:
case Token.IMPORT_SPEC:
add(first);
if (first != last) {
add(""String_Node_Str"");
add(last);
}
break;
case Token.IMPORT_STAR:
add(""String_Node_Str"");
add(""String_Node_Str"");
add(n.getString());
break;
case Token.CLASS:
{
Preconditions.checkState(childCount == 3);
boolean classNeedsParens=(context == Context.START_OF_EXPR);
if (classNeedsParens) {
add(""String_Node_Str"");
}
Node name=first;
Node superClass=first.getNext();
Node members=last;
add(""String_Node_Str"");
if (!name.isEmpty()) {
add(name);
}
if (!superClass.isEmpty()) {
add(""String_Node_Str"");
add(superClass);
}
add(members);
cc.endClass(context == Context.STATEMENT);
if (classNeedsParens) {
add(""String_Node_Str"");
}
}
break;
case Token.CLASS_MEMBERS:
cc.beginBlock();
for (Node c=first; c != null; c=c.getNext()) {
add(c);
cc.maybeLineBreak();
}
cc.endBlock(false);
break;
case Token.GETTER_DEF:
case Token.SETTER_DEF:
case Token.MEMBER_DEF:
{
n.getParent().toStringTree();
Preconditions.checkState(n.getParent().isObjectLit() || n.getParent().isClassMembers());
Preconditions.checkState(childCount == 1);
Preconditions.checkState(first.isFunction());
Preconditions.checkState(first.getFirstChild().getString().isEmpty());
if (n.isStaticMember()) {
add(""String_Node_Str"");
}
if (n.getFirstChild().isGeneratorFunction()) {
Preconditions.checkState(type == Token.MEMBER_DEF);
add(""String_Node_Str"");
}
switch (type) {
case Token.GETTER_DEF:
Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
add(""String_Node_Str"");
break;
case Token.SETTER_DEF:
Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
add(""String_Node_Str"");
break;
case Token.MEMBER_DEF:
break;
}
String name=n.getString();
Node fn=first;
Node parameters=fn.getChildAtIndex(1);
Node body=fn.getLastChild();
if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) && NodeUtil.isLatin(name)) {
add(name);
}
 else {
double d=getSimpleNumber(name);
if (!Double.isNaN(d)) {
cc.addNumber(d);
}
 else {
addJsString(n);
}
}
add(parameters);
add(body,Context.PRESERVE_BLOCK);
break;
}
case Token.SCRIPT:
case Token.BLOCK:
{
if (n.getClass() != Node.class) {
throw new Error(""String_Node_Str"");
}
boolean preserveBlock=context == Context.PRESERVE_BLOCK;
if (preserveBlock) {
cc.beginBlock();
}
boolean preferLineBreaks=type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().isScript());
for (Node c=first; c != null; c=c.getNext()) {
add(c,Context.STATEMENT);
if (c.isVar() || c.isLet() || c.isConst()) {
cc.endStatement();
}
if (c.isFunction() || c.isClass()) {
cc.maybeLineBreak();
}
if (preferLineBreaks) {
cc.notePreferredLineBreak();
}
}
if (preserveBlock) {
cc.endBlock(cc.breakAfterBlockFor(n,context == Context.STATEMENT));
}
break;
}
case Token.FOR:
if (childCount == 4) {
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
if (first.isVar() || first.isLet() || first.isConst()) {
add(first,Context.IN_FOR_INIT_CLAUSE);
}
 else {
addExpr(first,0,Context.IN_FOR_INIT_CLAUSE);
}
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
add(first.getNext().getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
 else {
Preconditions.checkState(childCount == 3);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
break;
case Token.FOR_OF:
Preconditions.checkState(childCount == 3);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case Token.DO:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
addNonEmptyStatement(first,Context.OTHER,false);
cc.maybeInsertSpace();
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(last);
add(""String_Node_Str"");
cc.endStatement();
break;
case Token.WHILE:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case Token.EMPTY:
Preconditions.checkState(childCount == 0);
break;
case Token.GETPROP:
{
Preconditions.checkState(childCount == 2,""String_Node_Str"",childCount);
Preconditions.checkState(last.isString(),""String_Node_Str"");
boolean needsParens=(first.isNumber());
if (needsParens) {
add(""String_Node_Str"");
}
addExpr(first,NodeUtil.precedence(type),context);
if (needsParens) {
add(""String_Node_Str"");
}
if (this.languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(last.getString())) {
add(""String_Node_Str"");
add(last);
add(""String_Node_Str"");
}
 else {
add(""String_Node_Str"");
addIdentifier(last.getString());
}
break;
}
case Token.GETELEM:
Preconditions.checkState(childCount == 2,""String_Node_Str"",childCount);
addExpr(first,NodeUtil.precedence(type),context);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
break;
case Token.WITH:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case Token.INC:
case Token.DEC:
{
Preconditions.checkState(childCount == 1);
String o=type == Token.INC ? ""String_Node_Str"" : ""String_Node_Str"";
boolean postProp=n.getBooleanProp(Node.INCRDECR_PROP);
if (postProp) {
addExpr(first,NodeUtil.precedence(type),context);
cc.addOp(o,false);
}
 else {
cc.addOp(o,false);
add(first);
}
break;
}
case Token.CALL:
if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
add(""String_Node_Str"");
addExpr(first,NodeUtil.precedence(Token.COMMA),Context.OTHER);
add(""String_Node_Str"");
}
 else {
addExpr(first,NodeUtil.precedence(type),context);
}
Node args=first.getNext();
add(""String_Node_Str"");
addList(args);
add(""String_Node_Str"");
break;
case Token.IF:
boolean hasElse=childCount == 3;
boolean ambiguousElseClause=context == Context.BEFORE_DANGLING_ELSE && !hasElse;
if (ambiguousElseClause) {
cc.beginBlock();
}
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
if (childCount == 1) {
break;
}
if (hasElse) {
addNonEmptyStatement(first.getNext(),Context.BEFORE_DANGLING_ELSE,false);
cc.maybeInsertSpace();
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
 else {
addNonEmptyStatement(first.getNext(),Context.OTHER,false);
Preconditions.checkState(childCount == 2);
}
if (ambiguousElseClause) {
cc.endBlock();
}
break;
case Token.NULL:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case Token.THIS:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
break;
case Token.SUPER:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
break;
case Token.YIELD:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
cc.maybeInsertSpace();
if (n.isYieldFor()) {
add(""String_Node_Str"");
}
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
break;
case Token.FALSE:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case Token.TRUE:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case Token.CONTINUE:
Preconditions.checkState(childCount <= 1);
add(""String_Node_Str"");
if (childCount == 1) {
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
}
cc.endStatement();
break;
case Token.DEBUGGER:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
cc.endStatement();
break;
case Token.BREAK:
Preconditions.checkState(childCount <= 1);
add(""String_Node_Str"");
if (childCount == 1) {
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
}
cc.endStatement();
break;
case Token.EXPR_RESULT:
Preconditions.checkState(childCount == 1);
add(first,Context.START_OF_EXPR);
cc.endStatement();
break;
case Token.NEW:
add(""String_Node_Str"");
int precedence=NodeUtil.precedence(type);
if (NodeUtil.containsType(first,Token.CALL,NodeUtil.MATCH_NOT_FUNCTION)) {
precedence=NodeUtil.precedence(first.getType()) + 1;
}
addExpr(first,precedence,Context.OTHER);
Node next=first.getNext();
if (next != null) {
add(""String_Node_Str"");
addList(next);
add(""String_Node_Str"");
}
break;
case Token.STRING_KEY:
addStringKey(n);
break;
case Token.STRING:
Preconditions.checkState(childCount == 0,""String_Node_Str"");
if (n.getBooleanProp(Node.COOKED_STRING)) {
add(""String_Node_Str"" + n.getString() + ""String_Node_Str"");
}
 else {
addJsString(n);
}
break;
case Token.DELPROP:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
add(first);
break;
case Token.OBJECTLIT:
{
boolean needsParens=(context == Context.START_OF_EXPR);
if (needsParens) {
add(""String_Node_Str"");
}
add(""String_Node_Str"");
for (Node c=first; c != null; c=c.getNext()) {
if (c != first) {
cc.listSeparator();
}
Preconditions.checkState(c.isComputedProp() || c.isGetterDef() || c.isSetterDef()|| c.isStringKey()|| c.isMemberDef());
add(c);
}
add(""String_Node_Str"");
if (needsParens) {
add(""String_Node_Str"");
}
break;
}
case Token.COMPUTED_PROP:
if (n.getBooleanProp(Node.COMPUTED_PROP_GETTER)) {
add(""String_Node_Str"");
}
 else if (n.getBooleanProp(Node.COMPUTED_PROP_SETTER)) {
add(""String_Node_Str"");
}
 else if (last.getBooleanProp(Node.GENERATOR_FN)) {
add(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
if (n.getBooleanProp(Node.COMPUTED_PROP_METHOD) || n.getBooleanProp(Node.COMPUTED_PROP_GETTER) || n.getBooleanProp(Node.COMPUTED_PROP_SETTER)) {
Node function=first.getNext();
Node params=function.getFirstChild().getNext();
Node body=function.getLastChild();
add(params);
add(body,Context.PRESERVE_BLOCK);
}
 else {
add(""String_Node_Str"");
add(first.getNext());
}
break;
case Token.OBJECT_PATTERN:
addObjectPattern(n,context);
break;
case Token.SWITCH:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
cc.beginBlock();
addAllSiblings(first.getNext());
cc.endBlock(context == Context.STATEMENT);
break;
case Token.CASE:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
add(first);
addCaseBody(last);
break;
case Token.DEFAULT_CASE:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
addCaseBody(first);
break;
case Token.LABEL:
Preconditions.checkState(childCount == 2);
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(first);
add(""String_Node_Str"");
if (!last.isBlock()) {
cc.maybeInsertSpace();
}
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),true);
break;
case Token.CAST:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
break;
case Token.TEMPLATELIT:
if (!first.isString()) {
add(first,Context.START_OF_EXPR);
first=first.getNext();
}
add(""String_Node_Str"");
for (Node c=first; c != null; c=c.getNext()) {
if (c.isString()) {
add(c.getString());
}
 else {
cc.append(""String_Node_Str"");
add(c.getFirstChild(),Context.START_OF_EXPR);
add(""String_Node_Str"");
}
}
add(""String_Node_Str"");
break;
case Token.STRING_TYPE:
add(""String_Node_Str"");
break;
case Token.BOOLEAN_TYPE:
add(""String_Node_Str"");
break;
case Token.NUMBER_TYPE:
add(""String_Node_Str"");
break;
case Token.ANY_TYPE:
add(""String_Node_Str"");
break;
case Token.NULL_TYPE:
add(""String_Node_Str"");
break;
case Token.VOID_TYPE:
add(""String_Node_Str"");
break;
case Token.UNDEFINED_TYPE:
add(""String_Node_Str"");
break;
case Token.NAMED_TYPE:
add(first);
break;
case Token.ARRAY_TYPE:
add(first);
add(""String_Node_Str"");
break;
default :
throw new RuntimeException(""String_Node_Str"" + Token.name(type) + ""String_Node_Str""+ n.toStringTree());
}
cc.endSourceMapping(n);
}",0.998122602236552
27598,"@Override void appendOp(String op,boolean binOp){
  if (binOp) {
    if (getLastChar() != ' ' && op.charAt(0) != ',') {
      append(""String_Node_Str"");
    }
    append(op);
    append(""String_Node_Str"");
  }
 else {
    append(op);
  }
}","@Override void appendOp(String op,boolean binOp){
  if (getLastChar() != ' ' && binOp && op.charAt(0) != ',') {
    append(""String_Node_Str"");
  }
  append(op);
  if (binOp) {
    append(""String_Node_Str"");
  }
}",0.8337028824833703
27599,"public void testStrict(){
  String result=parsePrint(""String_Node_Str"",false,false,0,false,true);
  assertEquals(""String_Node_Str"",result);
}","public void testStrict(){
  String result=new CodePrinter.Builder(parse(""String_Node_Str"",true)).setCompilerOptions(newCompilerOptions(new CompilerOptionBuilder(){
    @Override void setOptions(    CompilerOptions options){
      options.setPrettyPrint(false);
      options.setLineBreak(false);
      options.setLineLengthThreshold(0);
    }
  }
)).setOutputTypes(false).setTypeRegistry(lastCompiler.getTypeRegistry()).setTagAsStrict(true).build();
  assertEquals(""String_Node_Str"",result);
}",0.4069400630914827
27600,"String parsePrint(String js,boolean prettyprint,boolean lineBreak,int lineThreshold,boolean outputTypes,boolean tagAsStrict){
  return new CodePrinter.Builder(parse(js,true)).setCompilerOptions(newCompilerOptions(prettyprint,lineThreshold,lineBreak)).setOutputTypes(outputTypes).setTypeRegistry(lastCompiler.getTypeRegistry()).setTagAsStrict(tagAsStrict).build();
}","String parsePrint(String js,CompilerOptions options){
  return new CodePrinter.Builder(parse(js)).setCompilerOptions(options).build();
}",0.4870259481037924
27601,"private void assertLineLength(String js,String expected){
  assertEquals(expected,parsePrint(js,false,true,10));
}","private void assertLineLength(String js,String expected){
  assertEquals(expected,parsePrint(js,newCompilerOptions(new CompilerOptionBuilder(){
    @Override void setOptions(    CompilerOptions options){
      options.setPrettyPrint(false);
      options.setLineBreak(true);
      options.setLineLengthThreshold(10);
    }
  }
)));
}",0.4966442953020134
27602,"private void assertLineBreakAtEndOfFile(String js,String expectedWithoutBreakAtEnd,String expectedWithBreakAtEnd){
  assertEquals(expectedWithoutBreakAtEnd,parsePrint(js,false,false,false,30));
  assertEquals(expectedWithBreakAtEnd,parsePrint(js,false,false,true,30));
}","private void assertLineBreakAtEndOfFile(String js,String expectedWithoutBreakAtEnd,String expectedWithBreakAtEnd){
  assertEquals(expectedWithoutBreakAtEnd,parsePrint(js,newCompilerOptions(new CompilerOptionBuilder(){
    @Override void setOptions(    CompilerOptions options){
      options.setPrettyPrint(false);
      options.setLineBreak(false);
      options.setLineLengthThreshold(30);
      options.setPreferLineBreakAtEndOfFile(false);
    }
  }
)));
  assertEquals(expectedWithBreakAtEnd,parsePrint(js,newCompilerOptions(new CompilerOptionBuilder(){
    @Override void setOptions(    CompilerOptions options){
      options.setPrettyPrint(false);
      options.setLineBreak(false);
      options.setLineLengthThreshold(30);
      options.setPreferLineBreakAtEndOfFile(true);
    }
  }
)));
}",0.4355140186915888
27603,"private void assertPrint(String js,String expected){
  parse(expected);
  assertEquals(expected,parsePrint(js,false,CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));
}","private void assertPrint(String js,String expected){
  parse(expected);
  assertEquals(expected,parsePrint(js,newCompilerOptions(new CompilerOptionBuilder(){
    @Override void setOptions(    CompilerOptions options){
      options.setPrettyPrint(false);
      options.setLineLengthThreshold(CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD);
    }
  }
)));
}",0.622568093385214
27604,"CompilerOptions newCompilerOptions(boolean prettyprint,int lineThreshold,boolean lineBreak){
  CompilerOptions options=newCompilerOptions(prettyprint,lineThreshold);
  options.setLineBreak(lineBreak);
  return options;
}","CompilerOptions newCompilerOptions(CompilerOptionBuilder builder){
  CompilerOptions options=new CompilerOptions();
  options.setTrustedStrings(trustedStrings);
  options.preserveTypeAnnotations=preserveTypeAnnotations;
  options.setLanguageOut(languageMode);
  builder.setOptions(options);
  return options;
}",0.2528301886792453
27605,"public void testPrettyPrinter(){
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"");
}","public void testPrettyPrinter(){
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrettyPrint(""String_Node_Str"",""String_Node_Str"");
}",0.9867398262459992
27606,"private void assertLineBreak(String js,String expected){
  assertEquals(expected,parsePrint(js,false,true,CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));
}","private void assertLineBreak(String js,String expected){
  assertEquals(expected,parsePrint(js,newCompilerOptions(new CompilerOptionBuilder(){
    @Override void setOptions(    CompilerOptions options){
      options.setPrettyPrint(false);
      options.setLineBreak(true);
      options.setLineLengthThreshold(CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD);
    }
  }
)));
}",0.5697896749521989
27607,"private void assertTypeAnnotations(String js,String expected){
  assertEquals(expected,parsePrint(js,true,false,CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD,true));
}","private void assertTypeAnnotations(String js,String expected){
  assertEquals(expected,new CodePrinter.Builder(parse(js,true)).setCompilerOptions(newCompilerOptions(new CompilerOptionBuilder(){
    @Override void setOptions(    CompilerOptions options){
      options.setPrettyPrint(true);
      options.setLineBreak(false);
      options.setLineLengthThreshold(CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD);
    }
  }
)).setOutputTypes(true).setTypeRegistry(lastCompiler.getTypeRegistry()).build());
}",0.4561933534743202
27608,"private void assertPrettyPrint(String js,String expected){
  assertEquals(expected,parsePrint(js,true,false,CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));
}","private void assertPrettyPrint(String js,String expected,final CompilerOptionBuilder optionBuilder){
  assertEquals(expected,parsePrint(js,newCompilerOptions(new CompilerOptionBuilder(){
    @Override void setOptions(    CompilerOptions options){
      options.setPrettyPrint(true);
      options.setLineBreak(false);
      options.setLineLengthThreshold(CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD);
      optionBuilder.setOptions(options);
    }
  }
)));
}",0.4819672131147541
27609,"private void validateExport(Node n){
  validateNodeType(Token.EXPORT,n);
  if (n.getBooleanProp(Node.EXPORT_ALL_FROM)) {
    validateChildCount(n,2);
    validateNodeType(Token.EMPTY,n.getFirstChild());
    validateString(n.getChildAtIndex(1));
  }
 else   if (n.getBooleanProp(Node.EXPORT_DEFAULT)) {
    validateChildCount(n,1);
    validateAssignmentTarget(n.getFirstChild());
  }
 else {
    validateMinimumChildCount(n,1);
    validateMaximumChildCount(n,2);
    if (n.getFirstChild().getType() == Token.EXPORT_SPECS) {
      validateExportSpecifiers(n.getFirstChild());
    }
 else {
      validateStatement(n.getFirstChild());
    }
    if (n.getChildCount() == 2) {
      validateString(n.getChildAtIndex(1));
    }
  }
}","private void validateExport(Node n){
  validateNodeType(Token.EXPORT,n);
  if (n.getBooleanProp(Node.EXPORT_ALL_FROM)) {
    validateChildCount(n,2);
    validateNodeType(Token.EMPTY,n.getFirstChild());
    validateString(n.getChildAtIndex(1));
  }
 else   if (n.getBooleanProp(Node.EXPORT_DEFAULT)) {
    validateChildCount(n,1);
    validateExpression(n.getFirstChild());
  }
 else {
    validateMinimumChildCount(n,1);
    validateMaximumChildCount(n,2);
    if (n.getFirstChild().getType() == Token.EXPORT_SPECS) {
      validateExportSpecifiers(n.getFirstChild());
    }
 else {
      validateStatement(n.getFirstChild());
    }
    if (n.getChildCount() == 2) {
      validateString(n.getChildAtIndex(1));
    }
  }
}",0.9820936639118456
27610,"/** 
 * Classes are processed in 3 phases: 1) The class name is extracted. 2) Class members are processed and rewritten. 3) The constructor is built.
 */
private void visitClass(Node classNode,Node parent){
  checkClassReassignment(classNode);
  Node className=classNode.getFirstChild();
  Node superClassName=className.getNext();
  Node classMembers=classNode.getLastChild();
  Node insertionPoint;
  if (!superClassName.isEmpty() && !superClassName.isQualifiedName()) {
    compiler.report(JSError.make(superClassName,DYNAMIC_EXTENDS_TYPE));
    return;
  }
  String fullClassName=null;
  boolean anonymous;
  if (NodeUtil.isStatement(classNode)) {
    fullClassName=className.getString();
    anonymous=false;
    insertionPoint=classNode;
  }
 else   if (parent.isAssign() && parent.getParent().isExprResult()) {
    fullClassName=parent.getFirstChild().getQualifiedName();
    if (fullClassName == null) {
      cannotConvert(parent,""String_Node_Str"" + ""String_Node_Str"");
      return;
    }
    anonymous=true;
    insertionPoint=parent.getParent();
  }
 else   if (parent.isName()) {
    fullClassName=parent.getString();
    anonymous=true;
    insertionPoint=parent.getParent();
  }
 else {
    cannotConvert(parent,""String_Node_Str"" + ""String_Node_Str"");
    return;
  }
  if (!className.isEmpty() && !className.getString().equals(fullClassName)) {
    cannotConvertYet(classNode,""String_Node_Str"");
    return;
  }
  boolean useUnique=NodeUtil.isStatement(classNode) && !NodeUtil.isInFunction(classNode);
  String uniqueFullClassName=useUnique ? getUniqueClassName(fullClassName) : fullClassName;
  String superClassString=superClassName.getQualifiedName();
  Verify.verify(NodeUtil.isStatement(insertionPoint));
  Node constructor=null;
  JSDocInfo ctorJSDocInfo=null;
  for (  Node member : classMembers.children()) {
    if (member.isEmpty()) {
      continue;
    }
    if (member.isMemberDef() && member.getString().equals(""String_Node_Str"")) {
      ctorJSDocInfo=member.getJSDocInfo();
      constructor=member.getFirstChild().detachFromParent();
      if (!anonymous) {
        constructor.replaceChild(constructor.getFirstChild(),className.cloneNode());
      }
    }
 else {
      Node qualifiedMemberName;
      Node method;
      if (member.isMemberDef()) {
        if (member.isStaticMember()) {
          qualifiedMemberName=NodeUtil.newQName(compiler,Joiner.on(""String_Node_Str"").join(uniqueFullClassName,member.getString()));
        }
 else {
          qualifiedMemberName=NodeUtil.newQName(compiler,Joiner.on(""String_Node_Str"").join(uniqueFullClassName,""String_Node_Str"",member.getString()));
        }
        method=member.getFirstChild().detachFromParent();
      }
 else       if (member.isComputedProp()) {
        if (member.isStaticMember()) {
          qualifiedMemberName=IR.getelem(NodeUtil.newQName(compiler,uniqueFullClassName),member.removeFirstChild());
        }
 else {
          qualifiedMemberName=IR.getelem(NodeUtil.newQName(compiler,Joiner.on('.').join(uniqueFullClassName,""String_Node_Str"")),member.removeFirstChild());
        }
        method=member.getLastChild().detachFromParent();
      }
 else {
        throw new IllegalStateException(""String_Node_Str"" + member);
      }
      Node assign=IR.assign(qualifiedMemberName,method);
      assign.useSourceInfoIfMissingFromForTree(member);
      JSDocInfo info=member.getJSDocInfo();
      if (member.isStaticMember() && NodeUtil.referencesThis(assign.getLastChild())) {
        JSDocInfoBuilder memberDoc;
        if (info == null) {
          memberDoc=new JSDocInfoBuilder(true);
        }
 else {
          memberDoc=JSDocInfoBuilder.copyFrom(info);
        }
        memberDoc.recordThisType(new JSTypeExpression(new Node(Token.BANG,new Node(Token.QMARK)),member.getSourceFileName()));
        info=memberDoc.build(assign);
      }
      if (info != null) {
        info.setAssociatedNode(assign);
        assign.setJSDocInfo(info);
      }
      Node newNode=NodeUtil.newExpr(assign);
      insertionPoint.getParent().addChildAfter(newNode,insertionPoint);
      insertionPoint=newNode;
    }
  }
  Preconditions.checkNotNull(constructor);
  JSDocInfo classJSDoc=classNode.getJSDocInfo();
  JSDocInfoBuilder newInfo=(classJSDoc != null) ? JSDocInfoBuilder.copyFrom(classJSDoc) : new JSDocInfoBuilder(true);
  newInfo.recordConstructor();
  if (!superClassName.isEmpty()) {
    if (newInfo.isInterfaceRecorded()) {
      newInfo.recordExtendedInterface(new JSTypeExpression(new Node(Token.BANG,IR.string(superClassString)),superClassName.getSourceFileName()));
    }
 else {
      Node inherits=IR.call(NodeUtil.newQName(compiler,INHERITS),NodeUtil.newQName(compiler,fullClassName),NodeUtil.newQName(compiler,superClassString));
      Node inheritsCall=IR.exprResult(inherits);
      compiler.needsEs6Runtime=true;
      inheritsCall.useSourceInfoIfMissingFromForTree(classNode);
      Node enclosingStatement=NodeUtil.getEnclosingStatement(classNode);
      enclosingStatement.getParent().addChildAfter(inheritsCall,enclosingStatement);
      newInfo.recordBaseType(new JSTypeExpression(new Node(Token.BANG,IR.string(superClassString)),superClassName.getSourceFileName()));
      Node copyProps=IR.call(NodeUtil.newQName(compiler,COPY_PROP),NodeUtil.newQName(compiler,fullClassName),NodeUtil.newQName(compiler,superClassString));
      compiler.needsEs6Runtime=true;
      copyProps.useSourceInfoIfMissingFromForTree(classNode);
      enclosingStatement.getParent().addChildAfter(IR.exprResult(copyProps).srcref(classNode),enclosingStatement);
    }
  }
  if (!newInfo.isUnrestrictedRecorded() && !newInfo.isDictRecorded() && !newInfo.isStructRecorded()) {
    newInfo.recordStruct();
  }
  if (ctorJSDocInfo != null) {
    newInfo.recordSuppressions(ctorJSDocInfo.getSuppressions());
    for (    String param : ctorJSDocInfo.getParameterNames()) {
      newInfo.recordParameter(param,ctorJSDocInfo.getParameterType(param));
    }
  }
  insertionPoint=constructor;
  if (NodeUtil.isStatement(classNode)) {
    constructor.getFirstChild().setString(""String_Node_Str"");
    Node ctorVar=IR.var(IR.name(fullClassName),constructor);
    ctorVar.useSourceInfoIfMissingFromForTree(classNode);
    parent.replaceChild(classNode,ctorVar);
  }
 else {
    parent.replaceChild(classNode,constructor);
  }
  if (NodeUtil.isStatement(constructor)) {
    insertionPoint.setJSDocInfo(newInfo.build(insertionPoint));
  }
 else   if (parent.isName()) {
    Node var=parent.getParent();
    var.setJSDocInfo(newInfo.build(var));
  }
 else   if (constructor.getParent().isName()) {
    Node var=constructor.getParent().getParent();
    var.setJSDocInfo(newInfo.build(var));
  }
 else   if (parent.isAssign()) {
    parent.setJSDocInfo(newInfo.build(parent));
  }
 else {
    throw new IllegalStateException(""String_Node_Str"" + parent);
  }
  compiler.reportCodeChange();
}","/** 
 * Classes are processed in 3 phases: 1) The class name is extracted. 2) Class members are processed and rewritten. 3) The constructor is built.
 */
private void visitClass(Node classNode,Node parent){
  checkClassReassignment(classNode);
  Node className=classNode.getFirstChild();
  Node superClassName=className.getNext();
  Node classMembers=classNode.getLastChild();
  Node insertionPoint;
  if (!superClassName.isEmpty() && !superClassName.isQualifiedName()) {
    compiler.report(JSError.make(superClassName,DYNAMIC_EXTENDS_TYPE));
    return;
  }
  String fullClassName=null;
  boolean anonymous;
  if (NodeUtil.isStatement(classNode)) {
    fullClassName=className.getString();
    anonymous=false;
    insertionPoint=classNode;
  }
 else   if (parent.isAssign() && parent.getParent().isExprResult()) {
    fullClassName=parent.getFirstChild().getQualifiedName();
    if (fullClassName == null) {
      cannotConvert(parent,""String_Node_Str"" + ""String_Node_Str"");
      return;
    }
    anonymous=true;
    insertionPoint=parent.getParent();
  }
 else   if (parent.isName()) {
    fullClassName=parent.getString();
    anonymous=true;
    insertionPoint=parent.getParent();
  }
 else {
    cannotConvert(parent,""String_Node_Str"" + ""String_Node_Str"");
    return;
  }
  boolean useUnique=NodeUtil.isStatement(classNode) && !NodeUtil.isInFunction(classNode);
  String uniqueFullClassName=useUnique ? getUniqueClassName(fullClassName) : fullClassName;
  String superClassString=superClassName.getQualifiedName();
  Verify.verify(NodeUtil.isStatement(insertionPoint));
  Node constructor=null;
  JSDocInfo ctorJSDocInfo=null;
  for (  Node member : classMembers.children()) {
    if (member.isEmpty()) {
      continue;
    }
    if (member.isMemberDef() && member.getString().equals(""String_Node_Str"")) {
      ctorJSDocInfo=member.getJSDocInfo();
      constructor=member.getFirstChild().detachFromParent();
      if (!anonymous) {
        constructor.replaceChild(constructor.getFirstChild(),className.cloneNode());
      }
    }
 else {
      Node qualifiedMemberName;
      Node method;
      if (member.isMemberDef()) {
        if (member.isStaticMember()) {
          qualifiedMemberName=NodeUtil.newQName(compiler,Joiner.on(""String_Node_Str"").join(uniqueFullClassName,member.getString()));
        }
 else {
          qualifiedMemberName=NodeUtil.newQName(compiler,Joiner.on(""String_Node_Str"").join(uniqueFullClassName,""String_Node_Str"",member.getString()));
        }
        method=member.getFirstChild().detachFromParent();
      }
 else       if (member.isComputedProp()) {
        if (member.isStaticMember()) {
          qualifiedMemberName=IR.getelem(NodeUtil.newQName(compiler,uniqueFullClassName),member.removeFirstChild());
        }
 else {
          qualifiedMemberName=IR.getelem(NodeUtil.newQName(compiler,Joiner.on('.').join(uniqueFullClassName,""String_Node_Str"")),member.removeFirstChild());
        }
        method=member.getLastChild().detachFromParent();
      }
 else {
        throw new IllegalStateException(""String_Node_Str"" + member);
      }
      Node assign=IR.assign(qualifiedMemberName,method);
      assign.useSourceInfoIfMissingFromForTree(member);
      JSDocInfo info=member.getJSDocInfo();
      if (member.isStaticMember() && NodeUtil.referencesThis(assign.getLastChild())) {
        JSDocInfoBuilder memberDoc;
        if (info == null) {
          memberDoc=new JSDocInfoBuilder(true);
        }
 else {
          memberDoc=JSDocInfoBuilder.copyFrom(info);
        }
        memberDoc.recordThisType(new JSTypeExpression(new Node(Token.BANG,new Node(Token.QMARK)),member.getSourceFileName()));
        info=memberDoc.build(assign);
      }
      if (info != null) {
        info.setAssociatedNode(assign);
        assign.setJSDocInfo(info);
      }
      Node newNode=NodeUtil.newExpr(assign);
      insertionPoint.getParent().addChildAfter(newNode,insertionPoint);
      insertionPoint=newNode;
    }
  }
  Preconditions.checkNotNull(constructor);
  JSDocInfo classJSDoc=classNode.getJSDocInfo();
  JSDocInfoBuilder newInfo=(classJSDoc != null) ? JSDocInfoBuilder.copyFrom(classJSDoc) : new JSDocInfoBuilder(true);
  newInfo.recordConstructor();
  if (!superClassName.isEmpty()) {
    if (newInfo.isInterfaceRecorded()) {
      newInfo.recordExtendedInterface(new JSTypeExpression(new Node(Token.BANG,IR.string(superClassString)),superClassName.getSourceFileName()));
    }
 else {
      Node inherits=IR.call(NodeUtil.newQName(compiler,INHERITS),NodeUtil.newQName(compiler,fullClassName),NodeUtil.newQName(compiler,superClassString));
      Node inheritsCall=IR.exprResult(inherits);
      compiler.needsEs6Runtime=true;
      inheritsCall.useSourceInfoIfMissingFromForTree(classNode);
      Node enclosingStatement=NodeUtil.getEnclosingStatement(classNode);
      enclosingStatement.getParent().addChildAfter(inheritsCall,enclosingStatement);
      newInfo.recordBaseType(new JSTypeExpression(new Node(Token.BANG,IR.string(superClassString)),superClassName.getSourceFileName()));
      Node copyProps=IR.call(NodeUtil.newQName(compiler,COPY_PROP),NodeUtil.newQName(compiler,fullClassName),NodeUtil.newQName(compiler,superClassString));
      compiler.needsEs6Runtime=true;
      copyProps.useSourceInfoIfMissingFromForTree(classNode);
      enclosingStatement.getParent().addChildAfter(IR.exprResult(copyProps).srcref(classNode),enclosingStatement);
    }
  }
  if (!newInfo.isUnrestrictedRecorded() && !newInfo.isDictRecorded() && !newInfo.isStructRecorded()) {
    newInfo.recordStruct();
  }
  if (ctorJSDocInfo != null) {
    newInfo.recordSuppressions(ctorJSDocInfo.getSuppressions());
    for (    String param : ctorJSDocInfo.getParameterNames()) {
      newInfo.recordParameter(param,ctorJSDocInfo.getParameterType(param));
    }
  }
  insertionPoint=constructor;
  if (NodeUtil.isStatement(classNode)) {
    constructor.getFirstChild().setString(""String_Node_Str"");
    Node ctorVar=IR.var(IR.name(fullClassName),constructor);
    ctorVar.useSourceInfoIfMissingFromForTree(classNode);
    parent.replaceChild(classNode,ctorVar);
  }
 else {
    parent.replaceChild(classNode,constructor);
  }
  if (NodeUtil.isStatement(constructor)) {
    insertionPoint.setJSDocInfo(newInfo.build(insertionPoint));
  }
 else   if (parent.isName()) {
    Node var=parent.getParent();
    var.setJSDocInfo(newInfo.build(var));
  }
 else   if (constructor.getParent().isName()) {
    Node var=constructor.getParent().getParent();
    var.setJSDocInfo(newInfo.build(var));
  }
 else   if (parent.isAssign()) {
    parent.setJSDocInfo(newInfo.build(parent));
  }
 else {
    throw new IllegalStateException(""String_Node_Str"" + parent);
  }
  compiler.reportCodeChange();
}",0.9893280341502908
27611,"private void visitExport(NodeTraversal t,Node n,Node parent){
  if (n.getBooleanProp(Node.EXPORT_DEFAULT)) {
    Node var=IR.var(IR.name(DEFAULT_EXPORT_NAME),n.removeFirstChild());
    var.setJSDocInfo(n.getJSDocInfo());
    n.setJSDocInfo(null);
    n.getParent().replaceChild(n,var);
    exportMap.put(""String_Node_Str"",DEFAULT_EXPORT_NAME);
  }
 else   if (n.getBooleanProp(Node.EXPORT_ALL_FROM)) {
    compiler.report(JSError.make(n,Es6ToEs3Converter.CANNOT_CONVERT_YET,""String_Node_Str""));
  }
 else   if (n.getChildCount() == 2) {
    Node moduleIdentifier=n.getLastChild();
    Node importNode=new Node(Token.IMPORT,moduleIdentifier.cloneNode());
    importNode.copyInformationFrom(n);
    parent.addChildBefore(importNode,n);
    visit(t,importNode,parent);
    String loadAddress=loader.locate(moduleIdentifier.getString(),t.getInput());
    String moduleName=toModuleName(loadAddress);
    for (    Node exportSpec : n.getFirstChild().children()) {
      String nameFromOtherModule=exportSpec.getFirstChild().getString();
      String exportedName=exportSpec.getLastChild().getString();
      exportMap.put(exportedName,moduleName + ""String_Node_Str"" + nameFromOtherModule);
    }
    parent.removeChild(n);
  }
 else {
    if (n.getFirstChild().getType() == Token.EXPORT_SPECS) {
      for (      Node exportSpec : n.getFirstChild().children()) {
        Node origName=exportSpec.getFirstChild();
        exportMap.put(exportSpec.getChildCount() == 2 ? exportSpec.getLastChild().getString() : origName.getString(),origName.getString());
      }
      parent.removeChild(n);
    }
 else {
      Node declaration=n.getFirstChild();
      for (int i=0; i < declaration.getChildCount(); i++) {
        Node maybeName=declaration.getChildAtIndex(i);
        if (!maybeName.isName()) {
          break;
        }
        if (declaration.isClass() && i > 0) {
          break;
        }
        String name=maybeName.getString();
        Var v=t.getScope().getVar(name);
        if (v == null || v.isGlobal()) {
          exportMap.put(name,name);
        }
        if (declaration.isClass()) {
          types.add(name);
        }
      }
      declaration.setJSDocInfo(n.getJSDocInfo());
      n.setJSDocInfo(null);
      parent.replaceChild(n,declaration.detachFromParent());
    }
    compiler.reportCodeChange();
  }
}","private void visitExport(NodeTraversal t,Node n,Node parent){
  if (n.getBooleanProp(Node.EXPORT_DEFAULT)) {
    Node var=IR.var(IR.name(DEFAULT_EXPORT_NAME),n.removeFirstChild());
    var.useSourceInfoIfMissingFromForTree(n);
    var.setJSDocInfo(n.getJSDocInfo());
    n.setJSDocInfo(null);
    n.getParent().replaceChild(n,var);
    exportMap.put(""String_Node_Str"",DEFAULT_EXPORT_NAME);
  }
 else   if (n.getBooleanProp(Node.EXPORT_ALL_FROM)) {
    compiler.report(JSError.make(n,Es6ToEs3Converter.CANNOT_CONVERT_YET,""String_Node_Str""));
  }
 else   if (n.getChildCount() == 2) {
    Node moduleIdentifier=n.getLastChild();
    Node importNode=new Node(Token.IMPORT,moduleIdentifier.cloneNode());
    importNode.copyInformationFrom(n);
    parent.addChildBefore(importNode,n);
    visit(t,importNode,parent);
    String loadAddress=loader.locate(moduleIdentifier.getString(),t.getInput());
    String moduleName=toModuleName(loadAddress);
    for (    Node exportSpec : n.getFirstChild().children()) {
      String nameFromOtherModule=exportSpec.getFirstChild().getString();
      String exportedName=exportSpec.getLastChild().getString();
      exportMap.put(exportedName,moduleName + ""String_Node_Str"" + nameFromOtherModule);
    }
    parent.removeChild(n);
  }
 else {
    if (n.getFirstChild().getType() == Token.EXPORT_SPECS) {
      for (      Node exportSpec : n.getFirstChild().children()) {
        Node origName=exportSpec.getFirstChild();
        exportMap.put(exportSpec.getChildCount() == 2 ? exportSpec.getLastChild().getString() : origName.getString(),origName.getString());
      }
      parent.removeChild(n);
    }
 else {
      Node declaration=n.getFirstChild();
      for (int i=0; i < declaration.getChildCount(); i++) {
        Node maybeName=declaration.getChildAtIndex(i);
        if (!maybeName.isName()) {
          break;
        }
        if (declaration.isClass() && i > 0) {
          break;
        }
        String name=maybeName.getString();
        Var v=t.getScope().getVar(name);
        if (v == null || v.isGlobal()) {
          exportMap.put(name,name);
        }
        if (declaration.isClass()) {
          types.add(name);
        }
      }
      declaration.setJSDocInfo(n.getJSDocInfo());
      n.setJSDocInfo(null);
      parent.replaceChild(n,declaration.detachFromParent());
    }
    compiler.reportCodeChange();
  }
}",0.9902127659574468
27612,"public static Node declaration(Node lhs,Node value,int type){
  if (lhs.isName()) {
    Preconditions.checkState(!lhs.hasChildren());
  }
 else {
    Preconditions.checkState(lhs.isArrayPattern() || lhs.isObjectPattern());
  }
  Preconditions.checkState(mayBeExpression(value));
  lhs.addChildToBack(value);
  return new Node(type,lhs);
}","public static Node declaration(Node lhs,Node value,int type){
  if (lhs.isName()) {
    Preconditions.checkState(!lhs.hasChildren());
  }
 else {
    Preconditions.checkState(lhs.isArrayPattern() || lhs.isObjectPattern());
  }
  Preconditions.checkState(mayBeExpression(value),""String_Node_Str"",value);
  lhs.addChildToBack(value);
  return new Node(type,lhs);
}",0.9657142857142856
27613,"/** 
 * It isn't possible to always determine if a detached node is a expression, so make a best guess.
 */
private static boolean mayBeExpression(Node n){
switch (n.getType()) {
case Token.FUNCTION:
    return true;
case Token.ADD:
case Token.AND:
case Token.ARRAYLIT:
case Token.ASSIGN:
case Token.ASSIGN_BITOR:
case Token.ASSIGN_BITXOR:
case Token.ASSIGN_BITAND:
case Token.ASSIGN_LSH:
case Token.ASSIGN_RSH:
case Token.ASSIGN_URSH:
case Token.ASSIGN_ADD:
case Token.ASSIGN_SUB:
case Token.ASSIGN_MUL:
case Token.ASSIGN_DIV:
case Token.ASSIGN_MOD:
case Token.BITAND:
case Token.BITOR:
case Token.BITNOT:
case Token.BITXOR:
case Token.CALL:
case Token.CAST:
case Token.COMMA:
case Token.DEC:
case Token.DELPROP:
case Token.DIV:
case Token.EQ:
case Token.FALSE:
case Token.GE:
case Token.GETPROP:
case Token.GETELEM:
case Token.GT:
case Token.HOOK:
case Token.IN:
case Token.INC:
case Token.INSTANCEOF:
case Token.LE:
case Token.LSH:
case Token.LT:
case Token.MOD:
case Token.MUL:
case Token.NAME:
case Token.NE:
case Token.NEG:
case Token.NEW:
case Token.NOT:
case Token.NUMBER:
case Token.NULL:
case Token.OBJECTLIT:
case Token.OR:
case Token.POS:
case Token.REGEXP:
case Token.RSH:
case Token.SHEQ:
case Token.SHNE:
case Token.SPREAD:
case Token.STRING:
case Token.SUB:
case Token.SUPER:
case Token.TEMPLATELIT:
case Token.THIS:
case Token.TYPEOF:
case Token.TRUE:
case Token.URSH:
case Token.VOID:
case Token.YIELD:
  return true;
default :
return false;
}
}","/** 
 * It isn't possible to always determine if a detached node is a expression, so make a best guess.
 */
private static boolean mayBeExpression(Node n){
switch (n.getType()) {
case Token.FUNCTION:
case Token.CLASS:
    return true;
case Token.ADD:
case Token.AND:
case Token.ARRAYLIT:
case Token.ASSIGN:
case Token.ASSIGN_BITOR:
case Token.ASSIGN_BITXOR:
case Token.ASSIGN_BITAND:
case Token.ASSIGN_LSH:
case Token.ASSIGN_RSH:
case Token.ASSIGN_URSH:
case Token.ASSIGN_ADD:
case Token.ASSIGN_SUB:
case Token.ASSIGN_MUL:
case Token.ASSIGN_DIV:
case Token.ASSIGN_MOD:
case Token.BITAND:
case Token.BITOR:
case Token.BITNOT:
case Token.BITXOR:
case Token.CALL:
case Token.CAST:
case Token.COMMA:
case Token.DEC:
case Token.DELPROP:
case Token.DIV:
case Token.EQ:
case Token.FALSE:
case Token.GE:
case Token.GETPROP:
case Token.GETELEM:
case Token.GT:
case Token.HOOK:
case Token.IN:
case Token.INC:
case Token.INSTANCEOF:
case Token.LE:
case Token.LSH:
case Token.LT:
case Token.MOD:
case Token.MUL:
case Token.NAME:
case Token.NE:
case Token.NEG:
case Token.NEW:
case Token.NOT:
case Token.NUMBER:
case Token.NULL:
case Token.OBJECTLIT:
case Token.OR:
case Token.POS:
case Token.REGEXP:
case Token.RSH:
case Token.SHEQ:
case Token.SHNE:
case Token.SPREAD:
case Token.STRING:
case Token.SUB:
case Token.SUPER:
case Token.TEMPLATELIT:
case Token.THIS:
case Token.TYPEOF:
case Token.TRUE:
case Token.URSH:
case Token.VOID:
case Token.YIELD:
  return true;
default :
return false;
}
}",0.9938858695652174
27614,"public void testMultiNameClass(){
  test(""String_Node_Str"",null,Es6ToEs3Converter.CANNOT_CONVERT_YET);
  test(""String_Node_Str"",null,Es6ToEs3Converter.CANNOT_CONVERT_YET);
}","public void testMultiNameClass(){
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
}",0.6644295302013423
27615,"void add(String newcode){
  maybeEndStatement();
  if (newcode.isEmpty()) {
    return;
  }
  char c=newcode.charAt(0);
  if ((isWordChar(c) || c == '\\') && isWordChar(getLastChar())) {
    append(""String_Node_Str"");
  }
 else   if (c == '/' && getLastChar() == '/') {
    append(""String_Node_Str"");
  }
 else   if (c == '""' && isWordChar(getLastChar())) {
    maybeInsertSpace();
  }
  append(newcode);
}","void add(String newcode){
  maybeEndStatement();
  if (newcode.isEmpty()) {
    return;
  }
  char c=newcode.charAt(0);
  if ((isWordChar(c) || c == '\\') && isWordChar(getLastChar())) {
    append(""String_Node_Str"");
  }
 else   if (c == '/' && getLastChar() == '/') {
    append(""String_Node_Str"");
  }
 else   if ((c == '""' || c == '\'') && isWordChar(getLastChar())) {
    maybeInsertSpace();
  }
  append(newcode);
}",0.9818621523579202
27616,"@Override void appendOp(String op,boolean binOp){
  if (binOp) {
    if (getLastChar() != ' ' && op.charAt(0) != ',') {
      append(""String_Node_Str"");
    }
    append(op);
    append(""String_Node_Str"");
  }
 else {
    append(op);
  }
}","@Override void appendOp(String op,boolean binOp){
  if (getLastChar() != ' ' && op.charAt(0) != ',') {
    append(""String_Node_Str"");
  }
  append(op);
  if (binOp) {
    append(""String_Node_Str"");
  }
}",0.8506787330316742
27617,"public void testStrict(){
  String result=parsePrint(""String_Node_Str"",false,false,0,false,true);
  assertEquals(""String_Node_Str"",result);
}","public void testStrict(){
  String result=new CodePrinter.Builder(parse(""String_Node_Str"",true)).setCompilerOptions(newCompilerOptions(new CompilerOptionBuilder(){
    @Override void setOptions(    CompilerOptions options){
      options.setPrettyPrint(false);
      options.setLineBreak(false);
      options.setLineLengthThreshold(0);
    }
  }
)).setOutputTypes(false).setTypeRegistry(lastCompiler.getTypeRegistry()).setTagAsStrict(true).build();
  assertEquals(""String_Node_Str"",result);
}",0.4069400630914827
27618,"String parsePrint(String js,boolean prettyprint,boolean lineBreak,int lineThreshold,boolean outputTypes,boolean tagAsStrict){
  return new CodePrinter.Builder(parse(js,true)).setCompilerOptions(newCompilerOptions(prettyprint,lineThreshold,lineBreak)).setOutputTypes(outputTypes).setTypeRegistry(lastCompiler.getTypeRegistry()).setTagAsStrict(tagAsStrict).build();
}","String parsePrint(String js,CompilerOptions options){
  return new CodePrinter.Builder(parse(js)).setCompilerOptions(options).build();
}",0.4870259481037924
27619,"private void assertLineLength(String js,String expected){
  assertEquals(expected,parsePrint(js,false,true,10));
}","private void assertLineLength(String js,String expected){
  assertEquals(expected,parsePrint(js,newCompilerOptions(new CompilerOptionBuilder(){
    @Override void setOptions(    CompilerOptions options){
      options.setPrettyPrint(false);
      options.setLineBreak(true);
      options.setLineLengthThreshold(10);
    }
  }
)));
}",0.4966442953020134
27620,"private void assertLineBreakAtEndOfFile(String js,String expectedWithoutBreakAtEnd,String expectedWithBreakAtEnd){
  assertEquals(expectedWithoutBreakAtEnd,parsePrint(js,false,false,false,30));
  assertEquals(expectedWithBreakAtEnd,parsePrint(js,false,false,true,30));
}","private void assertLineBreakAtEndOfFile(String js,String expectedWithoutBreakAtEnd,String expectedWithBreakAtEnd){
  assertEquals(expectedWithoutBreakAtEnd,parsePrint(js,newCompilerOptions(new CompilerOptionBuilder(){
    @Override void setOptions(    CompilerOptions options){
      options.setPrettyPrint(false);
      options.setLineBreak(false);
      options.setLineLengthThreshold(30);
      options.setPreferLineBreakAtEndOfFile(false);
    }
  }
)));
  assertEquals(expectedWithBreakAtEnd,parsePrint(js,newCompilerOptions(new CompilerOptionBuilder(){
    @Override void setOptions(    CompilerOptions options){
      options.setPrettyPrint(false);
      options.setLineBreak(false);
      options.setLineLengthThreshold(30);
      options.setPreferLineBreakAtEndOfFile(true);
    }
  }
)));
}",0.4355140186915888
27621,"private void assertPrint(String js,String expected){
  parse(expected);
  assertEquals(expected,parsePrint(js,false,CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));
}","private void assertPrint(String js,String expected){
  parse(expected);
  assertEquals(expected,parsePrint(js,newCompilerOptions(new CompilerOptionBuilder(){
    @Override void setOptions(    CompilerOptions options){
      options.setPrettyPrint(false);
      options.setLineLengthThreshold(CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD);
    }
  }
)));
}",0.622568093385214
27622,"CompilerOptions newCompilerOptions(boolean prettyprint,int lineThreshold,boolean lineBreak){
  CompilerOptions options=newCompilerOptions(prettyprint,lineThreshold);
  options.setLineBreak(lineBreak);
  return options;
}","CompilerOptions newCompilerOptions(CompilerOptionBuilder builder){
  CompilerOptions options=new CompilerOptions();
  options.setTrustedStrings(trustedStrings);
  options.preserveTypeAnnotations=preserveTypeAnnotations;
  options.setLanguageOut(languageMode);
  builder.setOptions(options);
  return options;
}",0.2528301886792453
27623,"private void assertLineBreak(String js,String expected){
  assertEquals(expected,parsePrint(js,false,true,CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));
}","private void assertLineBreak(String js,String expected){
  assertEquals(expected,parsePrint(js,newCompilerOptions(new CompilerOptionBuilder(){
    @Override void setOptions(    CompilerOptions options){
      options.setPrettyPrint(false);
      options.setLineBreak(true);
      options.setLineLengthThreshold(CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD);
    }
  }
)));
}",0.5697896749521989
27624,"private void assertTypeAnnotations(String js,String expected){
  assertEquals(expected,parsePrint(js,true,false,CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD,true));
}","private void assertTypeAnnotations(String js,String expected){
  assertEquals(expected,new CodePrinter.Builder(parse(js,true)).setCompilerOptions(newCompilerOptions(new CompilerOptionBuilder(){
    @Override void setOptions(    CompilerOptions options){
      options.setPrettyPrint(true);
      options.setLineBreak(false);
      options.setLineLengthThreshold(CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD);
    }
  }
)).setOutputTypes(true).setTypeRegistry(lastCompiler.getTypeRegistry()).build());
}",0.4561933534743202
27625,"private void assertPrettyPrint(String js,String expected){
  assertEquals(expected,parsePrint(js,true,false,CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));
}","private void assertPrettyPrint(String js,String expected,final CompilerOptionBuilder optionBuilder){
  assertEquals(expected,parsePrint(js,newCompilerOptions(new CompilerOptionBuilder(){
    @Override void setOptions(    CompilerOptions options){
      options.setPrettyPrint(true);
      options.setLineBreak(false);
      options.setLineLengthThreshold(CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD);
      optionBuilder.setOptions(options);
    }
  }
)));
}",0.4819672131147541
27626,"void add(String newcode){
  maybeEndStatement();
  if (newcode.isEmpty()) {
    return;
  }
  char c=newcode.charAt(0);
  if ((isWordChar(c) || c == '\\') && isWordChar(getLastChar())) {
    append(""String_Node_Str"");
  }
 else   if (c == '/' && getLastChar() == '/') {
    append(""String_Node_Str"");
  }
 else   if (c == '""' && isWordChar(getLastChar())) {
    maybeInsertSpace();
  }
  append(newcode);
}","void add(String newcode){
  maybeEndStatement();
  if (newcode.isEmpty()) {
    return;
  }
  char c=newcode.charAt(0);
  if ((isWordChar(c) || c == '\\') && isWordChar(getLastChar())) {
    append(""String_Node_Str"");
  }
 else   if (c == '/' && getLastChar() == '/') {
    append(""String_Node_Str"");
  }
 else   if ((c == '""' || c == '\'') && isWordChar(getLastChar())) {
    maybeInsertSpace();
  }
  append(newcode);
}",0.9818621523579202
27627,"@Override void appendOp(String op,boolean binOp){
  if (binOp) {
    if (getLastChar() != ' ' && op.charAt(0) != ',') {
      append(""String_Node_Str"");
    }
    append(op);
    append(""String_Node_Str"");
  }
 else {
    append(op);
  }
}","@Override void appendOp(String op,boolean binOp){
  if (binOp) {
    if (getLastChar() != ' ' && op.charAt(0) != ',') {
      append(""String_Node_Str"");
    }
    append(op);
    append(""String_Node_Str"");
  }
 else {
    append(""String_Node_Str"");
    append(op);
  }
}",0.899803536345776
27628,"public void testStrict(){
  String result=parsePrint(""String_Node_Str"",false,false,0,false,true);
  assertEquals(""String_Node_Str"",result);
}","public void testStrict(){
  String result=new CodePrinter.Builder(parse(""String_Node_Str"",true)).setCompilerOptions(newCompilerOptions(new CompilerOptionBuilder(){
    @Override void setOptions(    CompilerOptions options){
      options.setPrettyPrint(false);
      options.setLineBreak(false);
      options.setLineLengthThreshold(0);
    }
  }
)).setOutputTypes(false).setTypeRegistry(lastCompiler.getTypeRegistry()).setTagAsStrict(true).build();
  assertEquals(""String_Node_Str"",result);
}",0.4069400630914827
27629,"String parsePrint(String js,boolean prettyprint,boolean lineBreak,int lineThreshold,boolean outputTypes,boolean tagAsStrict){
  return new CodePrinter.Builder(parse(js,true)).setCompilerOptions(newCompilerOptions(prettyprint,lineThreshold,lineBreak)).setOutputTypes(outputTypes).setTypeRegistry(lastCompiler.getTypeRegistry()).setTagAsStrict(tagAsStrict).build();
}","String parsePrint(String js,CompilerOptions options){
  return new CodePrinter.Builder(parse(js)).setCompilerOptions(options).build();
}",0.4870259481037924
27630,"private void assertLineLength(String js,String expected){
  assertEquals(expected,parsePrint(js,false,true,10));
}","private void assertLineLength(String js,String expected){
  assertEquals(expected,parsePrint(js,newCompilerOptions(new CompilerOptionBuilder(){
    @Override void setOptions(    CompilerOptions options){
      options.setPrettyPrint(false);
      options.setLineBreak(true);
      options.setLineLengthThreshold(10);
    }
  }
)));
}",0.4966442953020134
27631,"private void assertLineBreakAtEndOfFile(String js,String expectedWithoutBreakAtEnd,String expectedWithBreakAtEnd){
  assertEquals(expectedWithoutBreakAtEnd,parsePrint(js,false,false,false,30));
  assertEquals(expectedWithBreakAtEnd,parsePrint(js,false,false,true,30));
}","private void assertLineBreakAtEndOfFile(String js,String expectedWithoutBreakAtEnd,String expectedWithBreakAtEnd){
  assertEquals(expectedWithoutBreakAtEnd,parsePrint(js,newCompilerOptions(new CompilerOptionBuilder(){
    @Override void setOptions(    CompilerOptions options){
      options.setPrettyPrint(false);
      options.setLineBreak(false);
      options.setLineLengthThreshold(30);
      options.setPreferLineBreakAtEndOfFile(false);
    }
  }
)));
  assertEquals(expectedWithBreakAtEnd,parsePrint(js,newCompilerOptions(new CompilerOptionBuilder(){
    @Override void setOptions(    CompilerOptions options){
      options.setPrettyPrint(false);
      options.setLineBreak(false);
      options.setLineLengthThreshold(30);
      options.setPreferLineBreakAtEndOfFile(true);
    }
  }
)));
}",0.4355140186915888
27632,"private void assertPrint(String js,String expected){
  parse(expected);
  assertEquals(expected,parsePrint(js,false,CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));
}","private void assertPrint(String js,String expected){
  parse(expected);
  assertEquals(expected,parsePrint(js,newCompilerOptions(new CompilerOptionBuilder(){
    @Override void setOptions(    CompilerOptions options){
      options.setPrettyPrint(false);
      options.setLineLengthThreshold(CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD);
    }
  }
)));
}",0.622568093385214
27633,"CompilerOptions newCompilerOptions(boolean prettyprint,int lineThreshold,boolean lineBreak){
  CompilerOptions options=newCompilerOptions(prettyprint,lineThreshold);
  options.setLineBreak(lineBreak);
  return options;
}","CompilerOptions newCompilerOptions(CompilerOptionBuilder builder){
  CompilerOptions options=new CompilerOptions();
  options.setTrustedStrings(trustedStrings);
  options.preserveTypeAnnotations=preserveTypeAnnotations;
  options.setLanguageOut(languageMode);
  builder.setOptions(options);
  return options;
}",0.2528301886792453
27634,"private void assertLineBreak(String js,String expected){
  assertEquals(expected,parsePrint(js,false,true,CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));
}","private void assertLineBreak(String js,String expected){
  assertEquals(expected,parsePrint(js,newCompilerOptions(new CompilerOptionBuilder(){
    @Override void setOptions(    CompilerOptions options){
      options.setPrettyPrint(false);
      options.setLineBreak(true);
      options.setLineLengthThreshold(CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD);
    }
  }
)));
}",0.5697896749521989
27635,"private void assertTypeAnnotations(String js,String expected){
  assertEquals(expected,parsePrint(js,true,false,CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD,true));
}","private void assertTypeAnnotations(String js,String expected){
  assertEquals(expected,new CodePrinter.Builder(parse(js,true)).setCompilerOptions(newCompilerOptions(new CompilerOptionBuilder(){
    @Override void setOptions(    CompilerOptions options){
      options.setPrettyPrint(true);
      options.setLineBreak(false);
      options.setLineLengthThreshold(CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD);
    }
  }
)).setOutputTypes(true).setTypeRegistry(lastCompiler.getTypeRegistry()).build());
}",0.4561933534743202
27636,"private void assertPrettyPrint(String js,String expected){
  assertEquals(expected,parsePrint(js,true,false,CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));
}","private void assertPrettyPrint(String js,String expected,final CompilerOptionBuilder optionBuilder){
  assertEquals(expected,parsePrint(js,newCompilerOptions(new CompilerOptionBuilder(){
    @Override void setOptions(    CompilerOptions options){
      options.setPrettyPrint(true);
      options.setLineBreak(false);
      options.setLineLengthThreshold(CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD);
      optionBuilder.setOptions(options);
    }
  }
)));
}",0.4819672131147541
27637,"public FunctionType instantiateGenerics(Map<String,JSType> typeMap){
  return applyInstantiation(false,typeMap);
}","public FunctionType instantiateGenerics(Map<String,JSType> typeMap){
  Preconditions.checkNotNull(typeParameters);
  return substituteParametricGenerics(typeMap);
}",0.6834532374100719
27638,"/** 
 * FunctionType#substituteGenerics is called while instantiating prototype methods of generic nominal types.
 */
FunctionType substituteGenerics(Map<String,JSType> concreteTypes){
  Preconditions.checkState(outerVarPreconditions.isEmpty());
  Map<String,JSType> typeMap=concreteTypes;
  if (typeParameters != null) {
    ImmutableMap.Builder<String,JSType> builder=ImmutableMap.builder();
    for (    Map.Entry<String,JSType> concreteTypeEntry : concreteTypes.entrySet()) {
      if (!typeParameters.contains(concreteTypeEntry.getKey())) {
        builder.put(concreteTypeEntry);
      }
    }
    typeMap=builder.build();
  }
  return applyInstantiation(true,typeMap);
}","/** 
 * FunctionType#substituteGenerics is called while instantiating prototype methods of generic nominal types.
 */
FunctionType substituteGenerics(Map<String,JSType> concreteTypes){
  Preconditions.checkState(outerVarPreconditions.isEmpty());
  Map<String,JSType> typeMap=concreteTypes;
  if (typeParameters != null) {
    ImmutableMap.Builder<String,JSType> builder=ImmutableMap.builder();
    for (    Map.Entry<String,JSType> concreteTypeEntry : concreteTypes.entrySet()) {
      if (!typeParameters.contains(concreteTypeEntry.getKey())) {
        builder.put(concreteTypeEntry);
      }
    }
    typeMap=builder.build();
  }
  return substituteNominalGenerics(typeMap);
}",0.9631268436578172
27639,"public FunctionType instantiateGenericsFromArgumentTypes(List<JSType> argTypes){
  if (argTypes.size() < getMinArity() || argTypes.size() > getMaxArity()) {
    return null;
  }
  Multimap<String,JSType> typeMultimap=HashMultimap.create();
  for (int i=0, size=argTypes.size(); i < size; i++) {
    if (!this.getFormalType(i).unifyWith(argTypes.get(i),typeParameters,typeMultimap)) {
      return null;
    }
  }
  ImmutableMap.Builder<String,JSType> builder=ImmutableMap.builder();
  for (  String typeParam : typeParameters) {
    Collection<JSType> types=typeMultimap.get(typeParam);
    if (types.size() != 1) {
      return null;
    }
    builder.put(typeParam,Iterables.getOnlyElement(types));
  }
  return applyInstantiation(false,builder.build());
}","public FunctionType instantiateGenericsFromArgumentTypes(List<JSType> argTypes){
  Preconditions.checkNotNull(typeParameters);
  if (argTypes.size() < getMinArity() || argTypes.size() > getMaxArity()) {
    return null;
  }
  Multimap<String,JSType> typeMultimap=HashMultimap.create();
  for (int i=0, size=argTypes.size(); i < size; i++) {
    if (!this.getFormalType(i).unifyWith(argTypes.get(i),typeParameters,typeMultimap)) {
      return null;
    }
  }
  ImmutableMap.Builder<String,JSType> builder=ImmutableMap.builder();
  for (  String typeParam : typeParameters) {
    Collection<JSType> types=typeMultimap.get(typeParam);
    if (types.size() != 1) {
      return null;
    }
    builder.put(typeParam,Iterables.getOnlyElement(types));
  }
  return substituteParametricGenerics(builder.build());
}",0.9361430395913156
27640,"NominalType instantiateGenerics(Map<String,JSType> newTypeMap){
  if (newTypeMap.isEmpty()) {
    return this;
  }
  if (!this.rawType.isGeneric()) {
    return this.rawType.wrappedAsNominal;
  }
  ImmutableMap.Builder<String,JSType> builder=ImmutableMap.builder();
  if (!typeMap.isEmpty()) {
    for (    String oldKey : typeMap.keySet()) {
      builder.put(oldKey,typeMap.get(oldKey).substituteGenerics(newTypeMap));
    }
  }
 else {
    for (    String newKey : rawType.typeParameters) {
      if (newTypeMap.containsKey(newKey)) {
        builder.put(newKey,newTypeMap.get(newKey));
      }
    }
  }
  return new NominalType(builder.build(),this.rawType);
}","NominalType instantiateGenerics(Map<String,JSType> newTypeMap){
  if (newTypeMap.isEmpty()) {
    return this;
  }
  if (!this.rawType.isGeneric()) {
    return this.rawType.wrappedAsNominal;
  }
  ImmutableMap.Builder<String,JSType> builder=ImmutableMap.builder();
  ImmutableMap<String,JSType> resultMap;
  if (!typeMap.isEmpty()) {
    for (    String oldKey : typeMap.keySet()) {
      builder.put(oldKey,typeMap.get(oldKey).substituteGenerics(newTypeMap));
    }
    resultMap=builder.build();
  }
 else {
    for (    String newKey : rawType.typeParameters) {
      if (newTypeMap.containsKey(newKey)) {
        builder.put(newKey,newTypeMap.get(newKey));
      }
    }
    resultMap=builder.build();
    if (resultMap.isEmpty()) {
      return this;
    }
    if (resultMap.size() < rawType.typeParameters.size()) {
      return this;
    }
  }
  return new NominalType(resultMap,this.rawType);
}",0.8290816326530612
27641,"public void testDifficultClassGenericsInstantiation(){
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.RETURN_NONDECLARED_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
}","public void testDifficultClassGenericsInstantiation(){
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.RETURN_NONDECLARED_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.7076537013801757
27642,"void add(String newcode){
  maybeEndStatement();
  if (newcode.isEmpty()) {
    return;
  }
  char c=newcode.charAt(0);
  if ((isWordChar(c) || c == '\\') && isWordChar(getLastChar())) {
    append(""String_Node_Str"");
  }
 else   if (c == '/' && getLastChar() == '/') {
    append(""String_Node_Str"");
  }
 else   if ((c == '""' || c == '\'') && isWordChar(getLastChar())) {
    maybeInsertSpace();
  }
  append(newcode);
}","void add(String newcode){
  maybeEndStatement();
  if (newcode.isEmpty()) {
    return;
  }
  char c=newcode.charAt(0);
  if ((isWordChar(c) || c == '\\') && isWordChar(getLastChar())) {
    append(""String_Node_Str"");
  }
 else   if (c == '/' && getLastChar() == '/') {
    append(""String_Node_Str"");
  }
 else   if (c == '""' && isWordChar(getLastChar())) {
    maybeInsertSpace();
  }
  append(newcode);
}",0.9818621523579202
27643,"@Override void appendOp(String op,boolean binOp){
  if (getLastChar() != ' ' && op.charAt(0) != ',') {
    append(""String_Node_Str"");
  }
  append(op);
  if (binOp) {
    append(""String_Node_Str"");
  }
}","@Override void appendOp(String op,boolean binOp){
  if (binOp) {
    if (getLastChar() != ' ' && op.charAt(0) != ',') {
      append(""String_Node_Str"");
    }
    append(op);
    append(""String_Node_Str"");
  }
 else {
    append(op);
  }
}",0.7782805429864253
27644,"public void testStrict(){
  String result=new CodePrinter.Builder(parse(""String_Node_Str"",true)).setCompilerOptions(newCompilerOptions(new CompilerOptionBuilder(){
    @Override void setOptions(    CompilerOptions options){
      options.setPrettyPrint(false);
      options.setLineBreak(false);
      options.setLineLengthThreshold(0);
    }
  }
)).setOutputTypes(false).setTypeRegistry(lastCompiler.getTypeRegistry()).setTagAsStrict(true).build();
  assertEquals(""String_Node_Str"",result);
}","public void testStrict(){
  String result=parsePrint(""String_Node_Str"",false,false,0,false,true);
  assertEquals(""String_Node_Str"",result);
}",0.4195583596214511
27645,"String parsePrint(String js,CompilerOptions options){
  return new CodePrinter.Builder(parse(js)).setCompilerOptions(options).build();
}","String parsePrint(String js,boolean prettyprint,boolean lineBreak,int lineThreshold,boolean outputTypes,boolean tagAsStrict){
  return new CodePrinter.Builder(parse(js,true)).setCompilerOptions(newCompilerOptions(prettyprint,lineThreshold,lineBreak)).setOutputTypes(outputTypes).setTypeRegistry(lastCompiler.getTypeRegistry()).setTagAsStrict(tagAsStrict).build();
}",0.4231536926147705
27646,"private void assertLineLength(String js,String expected){
  assertEquals(expected,parsePrint(js,newCompilerOptions(new CompilerOptionBuilder(){
    @Override void setOptions(    CompilerOptions options){
      options.setPrettyPrint(false);
      options.setLineBreak(true);
      options.setLineLengthThreshold(10);
    }
  }
)));
}","private void assertLineLength(String js,String expected){
  assertEquals(expected,parsePrint(js,false,true,10));
}",0.5011185682326622
27647,"private void assertLineBreakAtEndOfFile(String js,String expectedWithoutBreakAtEnd,String expectedWithBreakAtEnd){
  assertEquals(expectedWithoutBreakAtEnd,parsePrint(js,newCompilerOptions(new CompilerOptionBuilder(){
    @Override void setOptions(    CompilerOptions options){
      options.setPrettyPrint(false);
      options.setLineBreak(false);
      options.setLineLengthThreshold(30);
      options.setPreferLineBreakAtEndOfFile(false);
    }
  }
)));
  assertEquals(expectedWithBreakAtEnd,parsePrint(js,newCompilerOptions(new CompilerOptionBuilder(){
    @Override void setOptions(    CompilerOptions options){
      options.setPrettyPrint(false);
      options.setLineBreak(false);
      options.setLineLengthThreshold(30);
      options.setPreferLineBreakAtEndOfFile(true);
    }
  }
)));
}","private void assertLineBreakAtEndOfFile(String js,String expectedWithoutBreakAtEnd,String expectedWithBreakAtEnd){
  assertEquals(expectedWithoutBreakAtEnd,parsePrint(js,false,false,false,30));
  assertEquals(expectedWithBreakAtEnd,parsePrint(js,false,false,true,30));
}",0.3401869158878505
27648,"private void assertPrint(String js,String expected){
  parse(expected);
  assertEquals(expected,parsePrint(js,newCompilerOptions(new CompilerOptionBuilder(){
    @Override void setOptions(    CompilerOptions options){
      options.setPrettyPrint(false);
      options.setLineLengthThreshold(CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD);
    }
  }
)));
}","private void assertPrint(String js,String expected){
  parse(expected);
  assertEquals(expected,parsePrint(js,false,CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));
}",0.6264591439688716
27649,"CompilerOptions newCompilerOptions(CompilerOptionBuilder builder){
  CompilerOptions options=new CompilerOptions();
  options.setTrustedStrings(trustedStrings);
  options.preserveTypeAnnotations=preserveTypeAnnotations;
  options.setLanguageOut(languageMode);
  builder.setOptions(options);
  return options;
}","CompilerOptions newCompilerOptions(boolean prettyprint,int lineThreshold,boolean lineBreak){
  CompilerOptions options=newCompilerOptions(prettyprint,lineThreshold);
  options.setLineBreak(lineBreak);
  return options;
}",0.430188679245283
27650,"private void assertLineBreak(String js,String expected){
  assertEquals(expected,parsePrint(js,newCompilerOptions(new CompilerOptionBuilder(){
    @Override void setOptions(    CompilerOptions options){
      options.setPrettyPrint(false);
      options.setLineBreak(true);
      options.setLineLengthThreshold(CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD);
    }
  }
)));
}","private void assertLineBreak(String js,String expected){
  assertEquals(expected,parsePrint(js,false,true,CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));
}",0.5736137667304015
27651,"private void assertTypeAnnotations(String js,String expected){
  assertEquals(expected,new CodePrinter.Builder(parse(js,true)).setCompilerOptions(newCompilerOptions(new CompilerOptionBuilder(){
    @Override void setOptions(    CompilerOptions options){
      options.setPrettyPrint(true);
      options.setLineBreak(false);
      options.setLineLengthThreshold(CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD);
    }
  }
)).setOutputTypes(true).setTypeRegistry(lastCompiler.getTypeRegistry()).build());
}","private void assertTypeAnnotations(String js,String expected){
  assertEquals(expected,parsePrint(js,true,false,CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD,true));
}",0.4712990936555891
27652,"private void assertPrettyPrint(String js,String expected,final CompilerOptionBuilder optionBuilder){
  assertEquals(expected,parsePrint(js,newCompilerOptions(new CompilerOptionBuilder(){
    @Override void setOptions(    CompilerOptions options){
      options.setPrettyPrint(true);
      options.setLineBreak(false);
      options.setLineLengthThreshold(CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD);
      optionBuilder.setOptions(options);
    }
  }
)));
}","private void assertPrettyPrint(String js,String expected){
  assertEquals(expected,parsePrint(js,true,false,CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));
}",0.4983606557377049
27653,"private TypeEnv analyzeCallNodeArgumentsFwd(Node call,Node firstArg,FunctionType funType,List<JSType> argTypesForDeferredCheck,TypeEnv inEnv){
  TypeEnv env=inEnv;
  Node arg=firstArg;
  int i=0;
  while (arg != null) {
    JSType formalType=funType.getFormalType(i);
    if (formalType.isBottom()) {
      warnings.add(JSError.make(call,CALL_FUNCTION_WITH_BOTTOM_FORMAL,Integer.toString(i)));
      formalType=JSType.UNKNOWN;
    }
    EnvTypePair pair=analyzeExprFwd(arg,env,formalType);
    JSType argTypeForDeferredCheck=pair.type;
    if (funType.isOptionalArg(i) && pair.type.equals(JSType.UNDEFINED)) {
      argTypeForDeferredCheck=null;
    }
 else     if (!pair.type.isSubtypeOf(formalType)) {
      warnings.add(JSError.make(arg,INVALID_ARGUMENT_TYPE,Integer.toString(i + 1),""String_Node_Str"",formalType.toString(),pair.type.toString()));
      argTypeForDeferredCheck=null;
    }
    argTypesForDeferredCheck.add(argTypeForDeferredCheck);
    env=pair.env;
    arg=arg.getNext();
    i++;
  }
  return env;
}","private TypeEnv analyzeCallNodeArgumentsFwd(Node call,Node firstArg,FunctionType funType,List<JSType> argTypesForDeferredCheck,TypeEnv inEnv){
  TypeEnv env=inEnv;
  Node arg=firstArg;
  int i=0;
  while (arg != null) {
    JSType formalType=funType.getFormalType(i);
    if (formalType.isBottom()) {
      warnings.add(JSError.make(call,CALL_FUNCTION_WITH_BOTTOM_FORMAL,Integer.toString(i)));
      formalType=JSType.UNKNOWN;
    }
    EnvTypePair pair=analyzeExprFwd(arg,env,formalType);
    JSType argTypeForDeferredCheck=pair.type;
    if (funType.isOptionalArg(i) && pair.type.equals(JSType.UNDEFINED)) {
      argTypeForDeferredCheck=null;
    }
 else     if (!pair.type.isSubtypeOf(formalType)) {
      String fnName=getReadableCalleeName(call.getFirstChild());
      warnings.add(JSError.make(arg,INVALID_ARGUMENT_TYPE,Integer.toString(i + 1),fnName,formalType.toString(),pair.type.toString()));
      argTypeForDeferredCheck=null;
    }
    argTypesForDeferredCheck.add(argTypeForDeferredCheck);
    env=pair.env;
    arg=arg.getNext();
    i++;
  }
  return env;
}",0.9579751671442216
27654,"private EnvTypePair analyzePropAccessBwd(Node receiver,String pname,TypeEnv outEnv,JSType requiredType){
  QualifiedName qname=new QualifiedName(pname);
  EnvTypePair pair=analyzeExprBwd(receiver,outEnv,pickReqObjType(receiver.getParent()).withLoose().withProperty(qname,requiredType));
  JSType receiverType=pair.type;
  JSType propAccessType=receiverType.mayHaveProp(qname) ? receiverType.getProp(qname) : requiredType;
  pair.type=propAccessType;
  return pair;
}","private EnvTypePair analyzePropAccessBwd(Node receiver,String pname,TypeEnv outEnv,JSType requiredType){
  Node propAccessNode=receiver.getParent();
  QualifiedName qname=new QualifiedName(pname);
  JSType reqObjType=pickReqObjType(propAccessNode).withLoose();
  if (!NodeUtil.isPropertyTest(compiler,propAccessNode)) {
    reqObjType=reqObjType.withProperty(qname,requiredType);
  }
  EnvTypePair pair=analyzeExprBwd(receiver,outEnv,reqObjType);
  JSType receiverType=pair.type;
  JSType propAccessType=receiverType.mayHaveProp(qname) ? receiverType.getProp(qname) : requiredType;
  pair.type=propAccessType;
  return pair;
}",0.717948717948718
27655,"private void checkPropertyAccessHelper(JSType objectType,String propName,NodeTraversal t,Node n){
  if (!objectType.isEmptyType() && reportMissingProperties && (!isPropertyTest(n) || objectType.isStruct())) {
    if (!typeRegistry.canPropertyBeDefined(objectType,propName)) {
      boolean lowConfidence=objectType.isUnknownType() || objectType.isEquivalentTo(getNativeType(OBJECT_TYPE));
      SuggestionPair pair=null;
      if (!lowConfidence) {
        pair=getClosestPropertySuggestion(objectType,propName);
      }
      if (pair != null && pair.distance * 4 < propName.length()) {
        report(t,n.getLastChild(),INEXISTENT_PROPERTY_WITH_SUGGESTION,propName,validator.getReadableJSTypeName(n.getFirstChild(),true),pair.suggestion);
      }
 else {
        DiagnosticType reportType=lowConfidence ? POSSIBLE_INEXISTENT_PROPERTY : INEXISTENT_PROPERTY;
        report(t,n.getLastChild(),reportType,propName,validator.getReadableJSTypeName(n.getFirstChild(),true));
      }
    }
  }
}","private void checkPropertyAccessHelper(JSType objectType,String propName,NodeTraversal t,Node n){
  if (!objectType.isEmptyType() && reportMissingProperties && (!NodeUtil.isPropertyTest(compiler,n) || objectType.isStruct())) {
    if (!typeRegistry.canPropertyBeDefined(objectType,propName)) {
      boolean lowConfidence=objectType.isUnknownType() || objectType.isEquivalentTo(getNativeType(OBJECT_TYPE));
      SuggestionPair pair=null;
      if (!lowConfidence) {
        pair=getClosestPropertySuggestion(objectType,propName);
      }
      if (pair != null && pair.distance * 4 < propName.length()) {
        report(t,n.getLastChild(),INEXISTENT_PROPERTY_WITH_SUGGESTION,propName,validator.getReadableJSTypeName(n.getFirstChild(),true),pair.suggestion);
      }
 else {
        DiagnosticType reportType=lowConfidence ? POSSIBLE_INEXISTENT_PROPERTY : INEXISTENT_PROPERTY;
        report(t,n.getLastChild(),reportType,propName,validator.getReadableJSTypeName(n.getFirstChild(),true));
      }
    }
  }
}",0.975975975975976
27656,"boolean isLooseSubtypeOf(ObjectType obj2){
  Preconditions.checkState(isLoose || obj2.isLoose);
  if (obj2 == TOP_OBJECT) {
    return true;
  }
  if (!isLoose) {
    if (!objectKind.isSubtypeOf(obj2.objectKind)) {
      return false;
    }
    for (    String pname : obj2.props.keySet()) {
      QualifiedName qname=new QualifiedName(pname);
      if (!mayHaveProp(qname) || !getProp(qname).isSubtypeOf(obj2.getProp(qname))) {
        return false;
      }
    }
  }
 else {
    for (    String pname : props.keySet()) {
      QualifiedName qname=new QualifiedName(pname);
      if (obj2.mayHaveProp(qname) && !getProp(qname).isSubtypeOf(obj2.getProp(qname))) {
        return false;
      }
    }
  }
  if (obj2.fn == null) {
    return this.fn == null || obj2.isLoose();
  }
 else   if (this.fn == null) {
    return false;
  }
  return fn.isLooseSubtypeOf(obj2.fn);
}","boolean isLooseSubtypeOf(ObjectType obj2){
  Preconditions.checkState(isLoose || obj2.isLoose);
  if (obj2 == TOP_OBJECT) {
    return true;
  }
  if (!isLoose) {
    if (!objectKind.isSubtypeOf(obj2.objectKind)) {
      return false;
    }
    for (    String pname : obj2.props.keySet()) {
      QualifiedName qname=new QualifiedName(pname);
      if (!mayHaveProp(qname) || !getProp(qname).isSubtypeOf(obj2.getProp(qname))) {
        return false;
      }
    }
  }
 else {
    for (    String pname : props.keySet()) {
      QualifiedName qname=new QualifiedName(pname);
      if (obj2.mayHaveProp(qname) && !getProp(qname).isSubtypeOf(obj2.getProp(qname))) {
        return false;
      }
    }
  }
  if (obj2.fn == null) {
    return this.fn == null || obj2.isLoose();
  }
 else   if (this.fn == null) {
    return isLoose;
  }
  return fn.isLooseSubtypeOf(obj2.fn);
}",0.972508591065292
27657,"public void testLooseObjectSubtyping(){
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",ImmutableList.of(NewTypeInference.INVALID_ARGUMENT_TYPE,NewTypeInference.MISTYPED_ASSIGN_RHS));
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testLooseObjectSubtyping(){
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",ImmutableList.of(NewTypeInference.INVALID_ARGUMENT_TYPE,NewTypeInference.MISTYPED_ASSIGN_RHS));
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.8207985143918292
27658,"/** 
 * Returns the array of warnings (never null).
 */
public JSError[] getWarnings(){
  return errorManager.getWarnings();
}","/** 
 * Returns the array of warnings (never null).
 */
public JSError[] getWarnings(){
  if (errorManager == null) {
    return new JSError[]{};
  }
  return errorManager.getWarnings();
}",0.802547770700637
27659,"/** 
 * Returns the array of errors (never null).
 */
public JSError[] getErrors(){
  return errorManager.getErrors();
}","/** 
 * Returns the array of errors (never null).
 */
public JSError[] getErrors(){
  if (errorManager == null) {
    return new JSError[]{};
  }
  return errorManager.getErrors();
}",0.7947019867549668
27660,"/** 
 * Renames a given node to the provided name.
 * @param n The node to rename.
 * @param name The new name for the node.
 * @param replaceEntireName True to replace the entire name of the node. Thedefault is to replace just the last property in the node with the new name. For instance, if  {@code replaceEntireName} is false, then{@code this.foo()} will be renamed to {@code this.bar()}. However, if it is true, it will be renamed to   {@code bar()}.
 */
public Builder rename(Node n,String name,boolean replaceEntireName){
  Node nodeToRename=null;
  if (n.isCall()) {
    Node child=n.getFirstChild();
    nodeToRename=child;
    if (!replaceEntireName && child.isGetProp()) {
      nodeToRename=child.getLastChild();
    }
  }
 else   if (n.isGetProp()) {
    nodeToRename=n.getLastChild();
    if (replaceEntireName) {
      while (nodeToRename.getParent().isGetProp()) {
        nodeToRename=nodeToRename.getParent();
      }
    }
  }
 else   if (n.isStringKey()) {
    nodeToRename=n;
  }
 else {
    throw new UnsupportedOperationException(""String_Node_Str"" + n.getType());
  }
  replacements.put(nodeToRename.getSourceFileName(),new CodeReplacement(nodeToRename.getSourceOffset(),nodeToRename.getLength(),name));
  return this;
}","/** 
 * Renames a given node to the provided name.
 * @param n The node to rename.
 * @param name The new name for the node.
 * @param replaceEntireName True to replace the entire name of the node. Thedefault is to replace just the last property in the node with the new name. For instance, if  {@code replaceEntireName} is false, then{@code this.foo()} will be renamed to {@code this.bar()}. However, if it is true, it will be renamed to   {@code bar()}.
 */
public Builder rename(Node n,String name,boolean replaceEntireName){
  Node nodeToRename=null;
  if (n.isCall()) {
    Node child=n.getFirstChild();
    nodeToRename=child;
    if (!replaceEntireName && child.isGetProp()) {
      nodeToRename=child.getLastChild();
    }
  }
 else   if (n.isGetProp()) {
    nodeToRename=n.getLastChild();
    if (replaceEntireName) {
      while (nodeToRename.getParent().isGetProp()) {
        nodeToRename=nodeToRename.getParent();
      }
    }
  }
 else   if (n.isStringKey()) {
    nodeToRename=n;
  }
 else   if (n.isString()) {
    Preconditions.checkState(n.getParent().isGetProp());
    nodeToRename=n;
  }
 else {
    throw new UnsupportedOperationException(""String_Node_Str"" + n);
  }
  replacements.put(nodeToRename.getSourceFileName(),new CodeReplacement(nodeToRename.getSourceOffset(),nodeToRename.getLength(),name));
  return this;
}",0.9539651837524178
27661,"/** 
 * Applies the provided set of code replacements to the code and returns the transformed code. The code replacements may not have any overlap.
 */
public static String applyCodeReplacements(Iterable<CodeReplacement> replacements,String code){
  List<CodeReplacement> sortedReplacements=ORDER_CODE_REPLACEMENTS.sortedCopy(replacements);
  validateNoOverlaps(sortedReplacements);
  StringBuilder sb=new StringBuilder();
  int lastIndex=0;
  for (  CodeReplacement replacement : sortedReplacements) {
    sb.append(code,lastIndex,replacement.getStartPosition());
    sb.append(replacement.getNewContent());
    lastIndex=replacement.getStartPosition() + replacement.getLength();
  }
  if (lastIndex <= sb.length()) {
    sb.append(code.substring(lastIndex));
  }
  return sb.toString();
}","/** 
 * Applies the provided set of code replacements to the code and returns the transformed code. The code replacements may not have any overlap.
 */
public static String applyCodeReplacements(Iterable<CodeReplacement> replacements,String code){
  List<CodeReplacement> sortedReplacements=ORDER_CODE_REPLACEMENTS.sortedCopy(replacements);
  validateNoOverlaps(sortedReplacements);
  StringBuilder sb=new StringBuilder();
  int lastIndex=0;
  for (  CodeReplacement replacement : sortedReplacements) {
    sb.append(code,lastIndex,replacement.getStartPosition());
    sb.append(replacement.getNewContent());
    lastIndex=replacement.getStartPosition() + replacement.getLength();
  }
  if (lastIndex <= code.length()) {
    sb.append(code.substring(lastIndex));
  }
  return sb.toString();
}",0.9962073324905184
27662,"@Override public List<SuggestedFix> processMatch(Match match){
  SuggestedFix.Builder fix=new SuggestedFix.Builder();
  Node newNode=transformNode(matchedTemplate.afterTemplate.getLastChild(),matchedTemplate.matcher.getTemplateNodeToMatchMap());
  Node nodeToReplace=match.getNode();
  if (nodeToReplace.getParent().isExprResult()) {
    nodeToReplace=nodeToReplace.getParent();
  }
  fix.replace(nodeToReplace,newNode,match.getMetadata().getCompiler());
  Node n=match.getNode().getNext();
  for (int i=1; i < matchedTemplate.beforeTemplate.getLastChild().getChildCount(); i++) {
    Preconditions.checkNotNull(n,""String_Node_Str"" + ""String_Node_Str"",matchedTemplate.beforeTemplate.getLastChild(),match.getNode());
    fix.delete(n);
    n=n.getNext();
  }
  for (  String require : matchedTemplate.getGoogRequiresToAdd()) {
    fix.addGoogRequire(match,require);
  }
  for (  String require : matchedTemplate.getGoogRequiresToRemove()) {
    fix.removeGoogRequire(match,require);
  }
  return ImmutableList.of(fix.build());
}","@Override public List<SuggestedFix> processMatch(Match match){
  SuggestedFix.Builder fix=new SuggestedFix.Builder();
  Node newNode=transformNode(matchedTemplate.afterTemplate.getLastChild(),matchedTemplate.matcher.getTemplateNodeToMatchMap());
  Node nodeToReplace=match.getNode();
  fix.replace(nodeToReplace,newNode,match.getMetadata().getCompiler());
  Node n=match.getNode().getNext();
  for (int i=1; i < matchedTemplate.beforeTemplate.getLastChild().getChildCount(); i++) {
    Preconditions.checkNotNull(n,""String_Node_Str"" + ""String_Node_Str"",matchedTemplate.beforeTemplate.getLastChild(),match.getNode());
    fix.delete(n);
    n=n.getNext();
  }
  for (  String require : matchedTemplate.getGoogRequiresToAdd()) {
    fix.addGoogRequire(match,require);
  }
  for (  String require : matchedTemplate.getGoogRequiresToRemove()) {
    fix.removeGoogRequire(match,require);
  }
  return ImmutableList.of(fix.build());
}",0.9493606138107415
27663,"/** 
 * Replaces the provided node with new node in the source file.
 */
public Builder replace(Node original,Node newNode,AbstractCompiler compiler){
  replacements.put(original.getSourceFileName(),new CodeReplacement(original.getSourceOffset(),original.getLength(),generateCode(compiler,newNode)));
  return this;
}","/** 
 * Replaces the provided node with new node in the source file.
 */
public Builder replace(Node original,Node newNode,AbstractCompiler compiler){
  Node parent=original.getParent();
  if (original.getParent().isExprResult()) {
    original=original.getParent();
  }
  String newCode=generateCode(compiler,newNode);
  if (newCode.endsWith(""String_Node_Str"")) {
    newCode=newCode.substring(0,newCode.length() - 1);
  }
  boolean needsSemicolon=parent.isExprResult() || parent.isBlock() || parent.isScript();
  if (newCode.endsWith(""String_Node_Str"") && !needsSemicolon) {
    newCode=newCode.substring(0,newCode.length() - 1);
  }
  replacements.put(original.getSourceFileName(),new CodeReplacement(original.getSourceOffset(),original.getLength(),newCode));
  return this;
}",0.5237226277372263
27664,"/** 
 * Unify   {@code this}, which may contain free type variables, with   {@code other}, a concrete type, modifying the supplied  {@code typeMultimap} to add any new template variable type bindings.
 * @return Whether unification succeeded
 */
public boolean unifyWith(JSType other,List<String> typeParameters,Multimap<String,JSType> typeMultimap){
  if (this.isUnknown()) {
    return true;
  }
 else   if (this.isTop()) {
    return other.isTop();
  }
 else   if (getMask() == TYPEVAR_MASK && typeParameters.contains(getTypeVar())) {
    updateTypemap(typeMultimap,getTypeVar(),makeType(promoteBoolean(other.getMask()),other.getObjs(),other.getTypeVar(),other.getEnums()));
    return true;
  }
 else   if (other.isTop()) {
    return false;
  }
 else   if (other.isUnknown()) {
    return true;
  }
  Set<EnumType> ununifiedEnums=null;
  if (getEnums() == null) {
    ununifiedEnums=other.getEnums();
  }
 else   if (other.getEnums() == null) {
    return false;
  }
 else {
    ununifiedEnums=new HashSet<>();
    for (    EnumType e : getEnums()) {
      if (!other.getEnums().contains(e)) {
        return false;
      }
    }
    for (    EnumType e : other.getEnums()) {
      if (!getEnums().contains(e)) {
        ununifiedEnums.add(e);
      }
    }
    if (ununifiedEnums.isEmpty()) {
      ununifiedEnums=null;
    }
  }
  Set<ObjectType> ununified=ImmutableSet.of();
  if (other.getObjs() != null) {
    ununified=new HashSet<>(other.getObjs());
  }
  if (getObjs() != null) {
    if (other.getObjs() == null) {
      return false;
    }
    for (    ObjectType targetObj : getObjs()) {
      boolean hasUnified=false;
      for (      ObjectType sourceObj : other.getObjs()) {
        if (targetObj.unifyWith(sourceObj,typeParameters,typeMultimap)) {
          ununified.remove(sourceObj);
          hasUnified=true;
        }
      }
      if (!hasUnified) {
        return false;
      }
    }
  }
  String thisTypevar=getTypeVar();
  String otherTypevar=other.getTypeVar();
  if (thisTypevar == null) {
    return otherTypevar == null && getMask() == other.getMask();
  }
 else   if (!typeParameters.contains(thisTypevar)) {
    return thisTypevar.equals(otherTypevar) && getMask() == other.getMask();
  }
 else {
    int templateMask=0;
    int thisScalarBits=getMask() & ~NON_SCALAR_MASK & ~TYPEVAR_MASK;
    int otherScalarBits=other.getMask() & ~NON_SCALAR_MASK & ~TYPEVAR_MASK;
    templateMask|=otherScalarBits & ~thisScalarBits;
    if (templateMask == BOTTOM_MASK) {
      return false;
    }
    JSType templateType=makeType(promoteBoolean(templateMask),ImmutableSet.copyOf(ununified),otherTypevar,ununifiedEnums == null ? null : ImmutableSet.copyOf(ununifiedEnums));
    updateTypemap(typeMultimap,getTypeVar(),templateType);
    return true;
  }
}","/** 
 * Unify   {@code this}, which may contain free type variables, with   {@code other}, a concrete type, modifying the supplied  {@code typeMultimap} to add any new template variable type bindings.
 * @return Whether unification succeeded
 */
public boolean unifyWith(JSType other,List<String> typeParameters,Multimap<String,JSType> typeMultimap){
  if (this.isUnknown()) {
    return true;
  }
 else   if (this.isTop()) {
    return other.isTop();
  }
 else   if (getMask() == TYPEVAR_MASK && typeParameters.contains(getTypeVar())) {
    updateTypemap(typeMultimap,getTypeVar(),makeType(promoteBoolean(other.getMask()),other.getObjs(),other.getTypeVar(),other.getEnums()));
    return true;
  }
 else   if (other.isTop()) {
    return false;
  }
 else   if (other.isUnknown()) {
    return true;
  }
  Set<EnumType> ununifiedEnums=null;
  if (getEnums() == null) {
    ununifiedEnums=other.getEnums();
  }
 else   if (other.getEnums() == null) {
    return false;
  }
 else {
    ununifiedEnums=new HashSet<>();
    for (    EnumType e : getEnums()) {
      if (!other.getEnums().contains(e)) {
        return false;
      }
    }
    for (    EnumType e : other.getEnums()) {
      if (!getEnums().contains(e)) {
        ununifiedEnums.add(e);
      }
    }
    if (ununifiedEnums.isEmpty()) {
      ununifiedEnums=null;
    }
  }
  Set<ObjectType> ununified=ImmutableSet.of();
  if (other.getObjs() != null) {
    ununified=new HashSet<>(other.getObjs());
  }
  if (getObjs() != null) {
    if (other.getObjs() == null) {
      return false;
    }
    for (    ObjectType targetObj : getObjs()) {
      boolean hasUnified=false;
      for (      ObjectType sourceObj : other.getObjs()) {
        if (targetObj.unifyWith(sourceObj,typeParameters,typeMultimap)) {
          ununified.remove(sourceObj);
          hasUnified=true;
        }
      }
      if (!hasUnified) {
        return false;
      }
    }
  }
  String thisTypevar=getTypeVar();
  String otherTypevar=other.getTypeVar();
  if (thisTypevar == null) {
    return otherTypevar == null && getMask() == other.getMask();
  }
 else   if (!typeParameters.contains(thisTypevar)) {
    return thisTypevar.equals(otherTypevar) && getMask() == other.getMask();
  }
 else {
    int templateMask=BOTTOM_MASK;
    int thisScalarBits=getMask() & ~NON_SCALAR_MASK & ~TYPEVAR_MASK;
    int otherScalarBits=other.getMask() & ~NON_SCALAR_MASK;
    templateMask|=otherScalarBits & ~thisScalarBits;
    if (templateMask == BOTTOM_MASK) {
      return false;
    }
    JSType templateType=makeType(promoteBoolean(templateMask),ImmutableSet.copyOf(ununified),otherTypevar,ununifiedEnums == null ? null : ImmutableSet.copyOf(ununifiedEnums));
    updateTypemap(typeMultimap,getTypeVar(),templateType);
    return true;
  }
}",0.994954954954955
27665,"public void testUnification(){
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.NOT_UNIQUE_INSTANTIATION);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.NOT_UNIQUE_INSTANTIATION);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
}","public void testUnification(){
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.NOT_UNIQUE_INSTANTIATION);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.NOT_UNIQUE_INSTANTIATION);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
}",0.8014751075599262
27666,"private EnvTypePair mayWarnAboutNullableReferenceAndTighten(Node obj,JSType recvType,TypeEnv inEnv){
  if (!recvType.isUnknown() && (JSType.NULL.isSubtypeOf(recvType) || JSType.UNDEFINED.isSubtypeOf(recvType))) {
    JSType minusNull=recvType.removeType(JSType.NULL_OR_UNDEF);
    if (!minusNull.isBottom() && minusNull != recvType && minusNull.isSubtypeOf(JSType.TOP_OBJECT)) {
      warnings.add(JSError.make(obj,NULLABLE_DEREFERENCE,recvType.toString()));
      EnvTypePair pair=analyzeExprFwd(obj,inEnv,minusNull);
      pair.type=minusNull;
      return pair;
    }
  }
  return new EnvTypePair(inEnv,recvType);
}","private EnvTypePair mayWarnAboutNullableReferenceAndTighten(Node obj,JSType recvType,TypeEnv inEnv){
  if (!recvType.isUnknown() && (JSType.NULL.isSubtypeOf(recvType) || JSType.UNDEFINED.isSubtypeOf(recvType))) {
    JSType minusNull=recvType.removeType(JSType.NULL_OR_UNDEF);
    if (!minusNull.isBottom() && !minusNull.equals(recvType) && minusNull.isSubtypeOf(JSType.TOP_OBJECT)) {
      warnings.add(JSError.make(obj,NULLABLE_DEREFERENCE,recvType.toString()));
      TypeEnv outEnv=inEnv;
      if (obj.isQualifiedName()) {
        QualifiedName qname=QualifiedName.fromNode(obj);
        outEnv=updateLvalueTypeInEnv(inEnv,obj,qname,minusNull);
      }
      return new EnvTypePair(outEnv,minusNull);
    }
  }
  return new EnvTypePair(inEnv,recvType);
}",0.6695715323166304
27667,"void addNumber(double x){
  char prev=getLastChar();
  boolean negativeZero=isNegativeZero(x);
  if ((x < 0 || negativeZero) && prev == '-') {
    add(""String_Node_Str"");
  }
  if (negativeZero) {
    addConstant(""String_Node_Str"");
  }
 else   if ((long)x == x) {
    long value=(long)x;
    long mantissa=value;
    int exp=0;
    if (Math.abs(x) >= 100) {
      while (mantissa / 10 * Math.pow(10,exp + 1) == value) {
        mantissa/=10;
        exp++;
      }
    }
    if (exp > 2) {
      addConstant(Long.toString(mantissa) + ""String_Node_Str"" + Integer.toString(exp));
    }
 else {
      long valueAbs=Math.abs(value);
      if (valueAbs > 1000000000000L && Long.toHexString(valueAbs).length() + 2 < Long.toString(valueAbs).length()) {
        addConstant((value < 0 ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + Long.toHexString(valueAbs));
      }
 else {
        addConstant(Long.toString(value));
      }
    }
  }
 else {
    addConstant(String.valueOf(x).replace(""String_Node_Str"",""String_Node_Str"").replaceFirst(""String_Node_Str"",""String_Node_Str""));
  }
}","void addNumber(double x){
  char prev=getLastChar();
  boolean negativeZero=isNegativeZero(x);
  if ((x < 0 || negativeZero) && prev == '-') {
    add(""String_Node_Str"");
  }
  if (negativeZero) {
    addConstant(""String_Node_Str"");
  }
 else   if ((long)x == x) {
    long value=(long)x;
    long mantissa=value;
    int exp=0;
    if (Math.abs(x) >= 100) {
      while (mantissa / 10 * ((long)Math.pow(10,exp + 1)) == value) {
        mantissa/=10;
        exp++;
      }
    }
    if (exp > 2) {
      addConstant(Long.toString(mantissa) + ""String_Node_Str"" + Integer.toString(exp));
    }
 else {
      long valueAbs=Math.abs(value);
      if (valueAbs > 1000000000000L && Long.toHexString(valueAbs).length() + 2 < Long.toString(valueAbs).length()) {
        addConstant((value < 0 ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + Long.toHexString(valueAbs));
      }
 else {
        addConstant(Long.toString(value));
      }
    }
  }
 else {
    addConstant(String.valueOf(x).replace(""String_Node_Str"",""String_Node_Str"").replaceFirst(""String_Node_Str"",""String_Node_Str""));
  }
}",0.9963470319634704
27668,"double normalizeNumber(LiteralToken token){
  String value=token.value;
  SourceRange location=token.location;
  int length=value.length();
  Preconditions.checkState(length > 0);
  Preconditions.checkState(value.charAt(0) != '-' && value.charAt(0) != '+');
  if (value.charAt(0) == '.') {
    return Double.valueOf('0' + value);
  }
 else   if (value.charAt(0) == '0' && length > 1) {
switch (value.charAt(1)) {
case '.':
case 'e':
case 'E':
      return Double.valueOf(value);
case 'b':
case 'B':
{
      if (!isEs6Mode()) {
        errorReporter.warning(BINARY_NUMBER_LITERAL_WARNING,sourceName,lineno(token.location.start),charno(token.location.start));
      }
      long v=0;
      int c=1;
      while (++c < length) {
        v=(v * 2) + binarydigit(value.charAt(c));
      }
      return Double.valueOf(v);
    }
case 'o':
case 'O':
{
    if (!isEs6Mode()) {
      errorReporter.warning(OCTAL_NUMBER_LITERAL_WARNING,sourceName,lineno(token.location.start),charno(token.location.start));
    }
    long v=0;
    int c=1;
    while (++c < length) {
      v=(v * 8) + octaldigit(value.charAt(c));
    }
    return Double.valueOf(v);
  }
case 'x':
case 'X':
{
  long v=0;
  int c=1;
  while (++c < length) {
    v=(v * 0x10) + hexdigit(value.charAt(c));
  }
  return Double.valueOf(v);
}
case '0':
case '1':
case '2':
case '3':
case '4':
case '5':
case '6':
case '7':
errorReporter.warning(INVALID_ES5_STRICT_OCTAL,sourceName,lineno(location.start),charno(location.start));
if (!inStrictContext()) {
long v=0;
int c=0;
while (++c < length) {
v=(v * 8) + octaldigit(value.charAt(c));
}
return Double.valueOf(v);
}
 else {
return Double.valueOf(value);
}
default :
errorReporter.error(INVALID_NUMBER_LITERAL,sourceName,lineno(location.start),charno(location.start));
return 0;
}
}
 else {
return Double.valueOf(value);
}
}","double normalizeNumber(LiteralToken token){
  String value=token.value;
  SourceRange location=token.location;
  int length=value.length();
  Preconditions.checkState(length > 0);
  Preconditions.checkState(value.charAt(0) != '-' && value.charAt(0) != '+');
  if (value.charAt(0) == '.') {
    return Double.valueOf('0' + value);
  }
 else   if (value.charAt(0) == '0' && length > 1) {
switch (value.charAt(1)) {
case '.':
case 'e':
case 'E':
      return Double.valueOf(value);
case 'b':
case 'B':
{
      if (!isEs6Mode()) {
        errorReporter.warning(BINARY_NUMBER_LITERAL_WARNING,sourceName,lineno(token.location.start),charno(token.location.start));
      }
      double v=0;
      int c=1;
      while (++c < length) {
        v=(v * 2) + binarydigit(value.charAt(c));
      }
      return v;
    }
case 'o':
case 'O':
{
    if (!isEs6Mode()) {
      errorReporter.warning(OCTAL_NUMBER_LITERAL_WARNING,sourceName,lineno(token.location.start),charno(token.location.start));
    }
    double v=0;
    int c=1;
    while (++c < length) {
      v=(v * 8) + octaldigit(value.charAt(c));
    }
    return v;
  }
case 'x':
case 'X':
{
  double v=0;
  int c=1;
  while (++c < length) {
    v=(v * 0x10) + hexdigit(value.charAt(c));
  }
  return v;
}
case '0':
case '1':
case '2':
case '3':
case '4':
case '5':
case '6':
case '7':
errorReporter.warning(INVALID_ES5_STRICT_OCTAL,sourceName,lineno(location.start),charno(location.start));
if (!inStrictContext()) {
double v=0;
int c=0;
while (++c < length) {
v=(v * 8) + octaldigit(value.charAt(c));
}
return v;
}
 else {
return Double.valueOf(value);
}
default :
errorReporter.error(INVALID_NUMBER_LITERAL,sourceName,lineno(location.start),charno(location.start));
return 0;
}
}
 else {
return Double.valueOf(value);
}
}",0.9549248747913188
27669,"public void testExponents(){
  assertPrintNumber(""String_Node_Str"",1);
  assertPrintNumber(""String_Node_Str"",10);
  assertPrintNumber(""String_Node_Str"",100);
  assertPrintNumber(""String_Node_Str"",1000);
  assertPrintNumber(""String_Node_Str"",10000);
  assertPrintNumber(""String_Node_Str"",100000);
  assertPrintNumber(""String_Node_Str"",-1);
  assertPrintNumber(""String_Node_Str"",-10);
  assertPrintNumber(""String_Node_Str"",-100);
  assertPrintNumber(""String_Node_Str"",-1000);
  assertPrintNumber(""String_Node_Str"",-123412340000L);
  assertPrintNumber(""String_Node_Str"",1000000000000000000L);
  assertPrintNumber(""String_Node_Str"",100000.0);
  assertPrintNumber(""String_Node_Str"",100000.1);
  assertPrintNumber(""String_Node_Str"",0.000001);
  assertPrintNumber(""String_Node_Str"",-0x38d7ea4c68001L);
  assertPrintNumber(""String_Node_Str"",0x38d7ea4c68001L);
  assertPrintNumber(""String_Node_Str"",-1.01);
  assertPrintNumber(""String_Node_Str"",-0.01);
  assertPrintNumber(""String_Node_Str"",0.01);
  assertPrintNumber(""String_Node_Str"",1.01);
}","public void testExponents(){
  assertPrintNumber(""String_Node_Str"",1);
  assertPrintNumber(""String_Node_Str"",10);
  assertPrintNumber(""String_Node_Str"",100);
  assertPrintNumber(""String_Node_Str"",1000);
  assertPrintNumber(""String_Node_Str"",10000);
  assertPrintNumber(""String_Node_Str"",100000);
  assertPrintNumber(""String_Node_Str"",-1);
  assertPrintNumber(""String_Node_Str"",-10);
  assertPrintNumber(""String_Node_Str"",-100);
  assertPrintNumber(""String_Node_Str"",-1000);
  assertPrintNumber(""String_Node_Str"",-123412340000L);
  assertPrintNumber(""String_Node_Str"",1000000000000000000L);
  assertPrintNumber(""String_Node_Str"",100000.0);
  assertPrintNumber(""String_Node_Str"",100000.1);
  assertPrintNumber(""String_Node_Str"",0.000001);
  assertPrintNumber(""String_Node_Str"",-0x38d7ea4c68001L);
  assertPrintNumber(""String_Node_Str"",0x38d7ea4c68001L);
  assertPrintNumber(""String_Node_Str"",0x7fffffffffffffffL);
  assertPrintNumber(""String_Node_Str"",-1.01);
  assertPrintNumber(""String_Node_Str"",-0.01);
  assertPrintNumber(""String_Node_Str"",0.01);
  assertPrintNumber(""String_Node_Str"",1.01);
}",0.971830985915493
27670,"private static JSType pickReqObjType(Node expr){
  int exprKind=expr.getType();
switch (exprKind) {
case Token.GETELEM:
case Token.IN:
    return JSType.TOP_DICT;
case Token.FOR:
  Preconditions.checkState(NodeUtil.isForIn(expr));
return JSType.TOP_DICT;
case Token.OBJECTLIT:
{
JSDocInfo jsdoc=expr.getJSDocInfo();
if (jsdoc != null && jsdoc.makesStructs()) {
  return JSType.TOP_STRUCT;
}
if (jsdoc != null && jsdoc.makesDicts()) {
  return JSType.TOP_DICT;
}
return JSType.TOP_OBJECT;
}
default :
{
Node parent=expr.getParent();
if (parent.isGetProp()) {
return JSType.TOP_STRUCT;
}
if (parent.isGetElem()) {
return JSType.TOP_DICT;
}
throw new RuntimeException(""String_Node_Str"" + Token.name(exprKind));
}
}
}","private static JSType pickReqObjType(Node expr){
  int exprKind=expr.getType();
switch (exprKind) {
case Token.GETPROP:
    return JSType.TOP_STRUCT;
case Token.GETELEM:
case Token.IN:
  return JSType.TOP_DICT;
case Token.FOR:
Preconditions.checkState(NodeUtil.isForIn(expr));
return JSType.TOP_DICT;
case Token.OBJECTLIT:
{
JSDocInfo jsdoc=expr.getJSDocInfo();
if (jsdoc != null && jsdoc.makesStructs()) {
return JSType.TOP_STRUCT;
}
if (jsdoc != null && jsdoc.makesDicts()) {
return JSType.TOP_DICT;
}
return JSType.TOP_OBJECT;
}
default :
throw new RuntimeException(""String_Node_Str"" + Token.name(exprKind));
}
}",0.7545180722891566
27671,"private EnvTypePair analyzePropAccessFwd(Node receiver,String pname,TypeEnv inEnv,JSType requiredType,JSType specializedType){
  QualifiedName propQname=new QualifiedName(pname);
  Node propAccessNode=receiver.getParent();
  EnvTypePair pair;
  JSType objWithProp=pickReqObjType(receiver).withLoose().withProperty(propQname,requiredType);
  JSType recvReqType, recvSpecType, recvType;
  if (specializedType.isTruthy() || specializedType.isFalsy()) {
    recvReqType=JSType.UNKNOWN;
    recvSpecType=objWithProp;
  }
 else {
    recvReqType=recvSpecType=objWithProp;
  }
  pair=analyzeExprFwd(receiver,inEnv,recvReqType,recvSpecType);
  recvType=pair.type;
  if (recvType.isUnknown() || mayWarnAboutNonObject(receiver,pname,recvType,specializedType)) {
    return new EnvTypePair(pair.env,requiredType);
  }
  if (propAccessNode.isGetProp() && mayWarnAboutDictPropAccess(receiver,recvType)) {
    return new EnvTypePair(pair.env,requiredType);
  }
  QualifiedName getterPname=new QualifiedName(GETTER_PREFIX + pname);
  if (recvType.hasProp(getterPname)) {
    return new EnvTypePair(pair.env,recvType.getProp(getterPname));
  }
  JSType resultType=recvType.getProp(propQname);
  if (!propAccessNode.getParent().isExprResult() && !specializedType.isTruthy() && !specializedType.isFalsy()) {
    if (!recvType.mayHaveProp(propQname)) {
      warnings.add(JSError.make(propAccessNode,TypeCheck.INEXISTENT_PROPERTY,pname,recvType.toString()));
    }
 else     if (!recvType.hasProp(propQname)) {
      warnings.add(JSError.make(propAccessNode,POSSIBLY_INEXISTENT_PROPERTY,pname,recvType.toString()));
    }
 else     if (recvType.hasProp(propQname) && !resultType.isSubtypeOf(requiredType) && tightenTypeAndDontWarn(receiver.isName() ? receiver.getString() : null,recvType.getDeclaredProp(propQname),resultType,requiredType)) {
      resultType=resultType.specialize(requiredType);
      LValueResultFwd lvr=analyzeLValueFwd(propAccessNode,inEnv,resultType);
      TypeEnv updatedEnv=updateLvalueTypeInEnv(lvr.env,propAccessNode,lvr.ptr,resultType);
      return new EnvTypePair(updatedEnv,resultType);
    }
  }
  if (resultType == null) {
    resultType=JSType.UNKNOWN;
  }
  return new EnvTypePair(pair.env,resultType);
}","private EnvTypePair analyzePropAccessFwd(Node receiver,String pname,TypeEnv inEnv,JSType requiredType,JSType specializedType){
  QualifiedName propQname=new QualifiedName(pname);
  Node propAccessNode=receiver.getParent();
  EnvTypePair pair;
  JSType objWithProp=pickReqObjType(propAccessNode).withLoose().withProperty(propQname,requiredType);
  JSType recvReqType, recvSpecType, recvType;
  if (specializedType.isTruthy() || specializedType.isFalsy()) {
    recvReqType=JSType.UNKNOWN;
    recvSpecType=objWithProp;
  }
 else {
    recvReqType=recvSpecType=objWithProp;
  }
  pair=analyzeExprFwd(receiver,inEnv,recvReqType,recvSpecType);
  recvType=pair.type;
  if (recvType.isUnknown() || mayWarnAboutNonObject(receiver,pname,recvType,specializedType)) {
    return new EnvTypePair(pair.env,requiredType);
  }
  if (propAccessNode.isGetProp() && mayWarnAboutDictPropAccess(receiver,recvType)) {
    return new EnvTypePair(pair.env,requiredType);
  }
  QualifiedName getterPname=new QualifiedName(GETTER_PREFIX + pname);
  if (recvType.hasProp(getterPname)) {
    return new EnvTypePair(pair.env,recvType.getProp(getterPname));
  }
  JSType resultType=recvType.getProp(propQname);
  if (!propAccessNode.getParent().isExprResult() && !specializedType.isTruthy() && !specializedType.isFalsy()) {
    if (!recvType.mayHaveProp(propQname)) {
      warnings.add(JSError.make(propAccessNode,TypeCheck.INEXISTENT_PROPERTY,pname,recvType.toString()));
    }
 else     if (!recvType.hasProp(propQname)) {
      warnings.add(JSError.make(propAccessNode,POSSIBLY_INEXISTENT_PROPERTY,pname,recvType.toString()));
    }
 else     if (recvType.hasProp(propQname) && !resultType.isSubtypeOf(requiredType) && tightenTypeAndDontWarn(receiver.isName() ? receiver.getString() : null,recvType.getDeclaredProp(propQname),resultType,requiredType)) {
      resultType=resultType.specialize(requiredType);
      LValueResultFwd lvr=analyzeLValueFwd(propAccessNode,inEnv,resultType);
      TypeEnv updatedEnv=updateLvalueTypeInEnv(lvr.env,propAccessNode,lvr.ptr,resultType);
      return new EnvTypePair(updatedEnv,resultType);
    }
  }
  if (resultType == null) {
    resultType=JSType.UNKNOWN;
  }
  return new EnvTypePair(pair.env,resultType);
}",0.9950517318938372
27672,"private EnvTypePair analyzePropAccessBwd(Node receiver,String pname,TypeEnv outEnv,JSType requiredType){
  QualifiedName qname=new QualifiedName(pname);
  EnvTypePair pair=analyzeExprBwd(receiver,outEnv,pickReqObjType(receiver).withLoose().withProperty(qname,requiredType));
  JSType receiverType=pair.type;
  JSType propAccessType=receiverType.mayHaveProp(qname) ? receiverType.getProp(qname) : requiredType;
  pair.type=propAccessType;
  return pair;
}","private EnvTypePair analyzePropAccessBwd(Node receiver,String pname,TypeEnv outEnv,JSType requiredType){
  QualifiedName qname=new QualifiedName(pname);
  EnvTypePair pair=analyzeExprBwd(receiver,outEnv,pickReqObjType(receiver.getParent()).withLoose().withProperty(qname,requiredType));
  JSType receiverType=pair.type;
  JSType propAccessType=receiverType.mayHaveProp(qname) ? receiverType.getProp(qname) : requiredType;
  pair.type=propAccessType;
  return pair;
}",0.9869565217391304
27673,"private LValueResultFwd analyzePropLValFwd(Node obj,QualifiedName pname,TypeEnv inEnv,JSType type,boolean insideQualifiedName){
  Preconditions.checkArgument(pname.isIdentifier());
  String pnameAsString=pname.getLeftmostName();
  JSType reqObjType=pickReqObjType(obj).withLoose().withProperty(pname,type);
  LValueResultFwd lvalue=analyzeLValueFwd(obj,inEnv,reqObjType,true);
  TypeEnv lvalueEnv=lvalue.env;
  JSType lvalueType=lvalue.type;
  if (!lvalueType.isSubtypeOf(JSType.TOP_OBJECT)) {
    warnPropAccessOnNonobject(obj,pnameAsString,lvalueType);
    return new LValueResultFwd(lvalueEnv,type,null,null);
  }
  Node propAccessNode=obj.getParent();
  if (propAccessNode.isGetProp() && propAccessNode.getParent().isAssign() && mayWarnAboutPropCreation(pname,propAccessNode,lvalueType)) {
    return new LValueResultFwd(lvalueEnv,type,null,null);
  }
  if (!insideQualifiedName && mayWarnAboutConstProp(propAccessNode,lvalueType,pname)) {
    return new LValueResultFwd(lvalueEnv,type,null,null);
  }
  if (!lvalueType.mayHaveProp(pname)) {
    if (insideQualifiedName && lvalueType.isLoose()) {
      lvalueType=lvalueType.withProperty(pname,JSType.TOP_OBJECT.withLoose());
      if (lvalueType.isDict() && propAccessNode.isGetProp()) {
        lvalueType=lvalueType.specialize(JSType.TOP_STRUCT);
      }
 else       if (lvalueType.isStruct() && propAccessNode.isGetElem()) {
        lvalueType=lvalueType.specialize(JSType.TOP_DICT);
      }
      lvalueEnv=updateLvalueTypeInEnv(lvalueEnv,obj,lvalue.ptr,lvalueType);
    }
 else {
      boolean warnForInexistentProp=insideQualifiedName || propAccessNode.getParent().getType() != Token.ASSIGN;
      if (warnForInexistentProp && !lvalueType.isUnknown() && !lvalueType.isDict()) {
        warnings.add(JSError.make(obj,TypeCheck.INEXISTENT_PROPERTY,pnameAsString,lvalueType.toString()));
        return new LValueResultFwd(lvalueEnv,type,null,null);
      }
    }
  }
  if (propAccessNode.isGetElem()) {
    mayWarnAboutStructPropAccess(obj,lvalueType);
  }
 else   if (propAccessNode.isGetProp()) {
    mayWarnAboutDictPropAccess(obj,lvalueType);
  }
  QualifiedName setterPname=new QualifiedName(SETTER_PREFIX + pnameAsString);
  if (lvalueType.hasProp(setterPname)) {
    FunctionType funType=lvalueType.getProp(setterPname).getFunType();
    Preconditions.checkNotNull(funType);
    JSType formalType=funType.getFormalType(0);
    Preconditions.checkState(!formalType.isBottom());
    return new LValueResultFwd(lvalueEnv,formalType,formalType,null);
  }
  return new LValueResultFwd(lvalueEnv,lvalueType.mayHaveProp(pname) ? lvalueType.getProp(pname) : JSType.UNKNOWN,lvalueType.mayHaveProp(pname) ? lvalueType.getDeclaredProp(pname) : null,lvalue.ptr == null ? null : QualifiedName.join(lvalue.ptr,pname));
}","private LValueResultFwd analyzePropLValFwd(Node obj,QualifiedName pname,TypeEnv inEnv,JSType type,boolean insideQualifiedName){
  Preconditions.checkArgument(pname.isIdentifier());
  String pnameAsString=pname.getLeftmostName();
  JSType reqObjType=pickReqObjType(obj.getParent()).withLoose().withProperty(pname,type);
  LValueResultFwd lvalue=analyzeLValueFwd(obj,inEnv,reqObjType,true);
  TypeEnv lvalueEnv=lvalue.env;
  JSType lvalueType=lvalue.type;
  if (!lvalueType.isSubtypeOf(JSType.TOP_OBJECT)) {
    warnPropAccessOnNonobject(obj,pnameAsString,lvalueType);
    return new LValueResultFwd(lvalueEnv,type,null,null);
  }
  Node propAccessNode=obj.getParent();
  if (propAccessNode.isGetProp() && propAccessNode.getParent().isAssign() && mayWarnAboutPropCreation(pname,propAccessNode,lvalueType)) {
    return new LValueResultFwd(lvalueEnv,type,null,null);
  }
  if (!insideQualifiedName && mayWarnAboutConstProp(propAccessNode,lvalueType,pname)) {
    return new LValueResultFwd(lvalueEnv,type,null,null);
  }
  if (!lvalueType.mayHaveProp(pname)) {
    if (insideQualifiedName && lvalueType.isLoose()) {
      lvalueType=lvalueType.withProperty(pname,JSType.TOP_OBJECT.withLoose());
      if (lvalueType.isDict() && propAccessNode.isGetProp()) {
        lvalueType=lvalueType.specialize(JSType.TOP_STRUCT);
      }
 else       if (lvalueType.isStruct() && propAccessNode.isGetElem()) {
        lvalueType=lvalueType.specialize(JSType.TOP_DICT);
      }
      lvalueEnv=updateLvalueTypeInEnv(lvalueEnv,obj,lvalue.ptr,lvalueType);
    }
 else {
      boolean warnForInexistentProp=insideQualifiedName || propAccessNode.getParent().getType() != Token.ASSIGN;
      if (warnForInexistentProp && !lvalueType.isUnknown() && !lvalueType.isDict()) {
        warnings.add(JSError.make(obj,TypeCheck.INEXISTENT_PROPERTY,pnameAsString,lvalueType.toString()));
        return new LValueResultFwd(lvalueEnv,type,null,null);
      }
    }
  }
  if (propAccessNode.isGetElem()) {
    mayWarnAboutStructPropAccess(obj,lvalueType);
  }
 else   if (propAccessNode.isGetProp()) {
    mayWarnAboutDictPropAccess(obj,lvalueType);
  }
  QualifiedName setterPname=new QualifiedName(SETTER_PREFIX + pnameAsString);
  if (lvalueType.hasProp(setterPname)) {
    FunctionType funType=lvalueType.getProp(setterPname).getFunType();
    Preconditions.checkNotNull(funType);
    JSType formalType=funType.getFormalType(0);
    Preconditions.checkState(!formalType.isBottom());
    return new LValueResultFwd(lvalueEnv,formalType,formalType,null);
  }
  return new LValueResultFwd(lvalueEnv,lvalueType.mayHaveProp(pname) ? lvalueType.getProp(pname) : JSType.UNKNOWN,lvalueType.mayHaveProp(pname) ? lvalueType.getDeclaredProp(pname) : null,lvalue.ptr == null ? null : QualifiedName.join(lvalue.ptr,pname));
}",0.9978401727861772
27674,"private LValueResultBwd analyzePropLValBwd(Node obj,QualifiedName pname,TypeEnv outEnv,JSType type,boolean doSlicing){
  Preconditions.checkArgument(pname.isIdentifier());
  JSType reqObjType=pickReqObjType(obj).withLoose().withProperty(pname,type);
  LValueResultBwd lvalue=analyzeLValueBwd(obj,outEnv,reqObjType,false,true);
  if (lvalue.ptr != null) {
    lvalue.ptr=QualifiedName.join(lvalue.ptr,pname);
    if (doSlicing) {
      String objName=lvalue.ptr.getLeftmostName();
      QualifiedName props=lvalue.ptr.getAllButLeftmost();
      JSType objType=envGetType(lvalue.env,objName);
      JSType slicedObjType=objType.withoutProperty(props);
      lvalue.env=envPutType(lvalue.env,objName,slicedObjType);
    }
  }
  lvalue.type=lvalue.type.mayHaveProp(pname) ? lvalue.type.getProp(pname) : JSType.UNKNOWN;
  return lvalue;
}","private LValueResultBwd analyzePropLValBwd(Node obj,QualifiedName pname,TypeEnv outEnv,JSType type,boolean doSlicing){
  Preconditions.checkArgument(pname.isIdentifier());
  JSType reqObjType=pickReqObjType(obj.getParent()).withLoose().withProperty(pname,type);
  LValueResultBwd lvalue=analyzeLValueBwd(obj,outEnv,reqObjType,false,true);
  if (lvalue.ptr != null) {
    lvalue.ptr=QualifiedName.join(lvalue.ptr,pname);
    if (doSlicing) {
      String objName=lvalue.ptr.getLeftmostName();
      QualifiedName props=lvalue.ptr.getAllButLeftmost();
      JSType objType=envGetType(lvalue.env,objName);
      JSType slicedObjType=objType.withoutProperty(props);
      lvalue.env=envPutType(lvalue.env,objName,slicedObjType);
    }
  }
  lvalue.type=lvalue.type.mayHaveProp(pname) ? lvalue.type.getProp(pname) : JSType.UNKNOWN;
  return lvalue;
}",0.9928486293206198
27675,"public void testGetElem(){
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testGetElem(){
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  checkNoWarnings(""String_Node_Str"");
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9786995515695068
27676,"/** 
 * Translates an Ant Path into the file list format that the compiler expects.
 */
private List<SourceFile> findJavaScriptFiles(Path path){
  List<SourceFile> files=Lists.newArrayList();
  for (  String included : path.list()) {
    files.add(SourceFile.fromFile(new File(included),Charset.forName(encoding)));
  }
  return files;
}","/** 
 * Translates an Ant resource collection into the file list format that  the compiler expects.
 */
private List<SourceFile> findJavaScriptFiles(ResourceCollection rc){
  List<SourceFile> files=Lists.newLinkedList();
  Iterator<Resource> iter=rc.iterator();
  while (iter.hasNext()) {
    FileResource fr=iter.next().as(FileResource.class);
    File file=Paths.get(""String_Node_Str"").toAbsolutePath().relativize(fr.getFile().toPath()).toFile();
    files.add(SourceFile.fromFile(file,Charset.forName(encoding)));
  }
  return files;
}",0.5851428571428572
27677,"private CompilerOptions createCompilerOptions(){
  CompilerOptions options=new CompilerOptions();
  this.compilationLevel.setOptionsForCompilationLevel(options);
  if (this.debugOptions) {
    this.compilationLevel.setDebugOptionsForCompilationLevel(options);
  }
  options.prettyPrint=this.prettyPrint;
  options.printInputDelimiter=this.printInputDelimiter;
  options.generateExports=this.generateExports;
  options.setLanguageIn(this.languageIn);
  options.setOutputCharset(this.outputEncoding);
  this.warningLevel.setOptionsForWarningLevel(options);
  options.setManageClosureDependencies(manageDependencies);
  convertEntryPointParameters(options);
  options.setTrustedStrings(true);
  if (replaceProperties) {
    convertPropertiesMap(options);
  }
  convertDefineParameters(options);
  for (  Warning warning : warnings) {
    CheckLevel level=warning.getLevel();
    String groupName=warning.getGroup();
    DiagnosticGroup group=new DiagnosticGroups().forName(groupName);
    if (group == null) {
      throw new BuildException(""String_Node_Str"" + groupName + ""String_Node_Str"");
    }
    options.setWarningLevel(group,level);
  }
  if (!Strings.isNullOrEmpty(sourceMapFormat)) {
    options.sourceMapFormat=Format.valueOf(sourceMapFormat);
  }
  if (sourceMapOutputFile != null) {
    File parentFile=sourceMapOutputFile.getParentFile();
    if (parentFile.mkdirs()) {
      log(""String_Node_Str"" + parentFile,Project.MSG_DEBUG);
    }
    options.sourceMapOutputPath=parentFile.getAbsolutePath();
  }
  return options;
}","private CompilerOptions createCompilerOptions(){
  CompilerOptions options=new CompilerOptions();
  this.compilationLevel.setOptionsForCompilationLevel(options);
  if (this.debugOptions) {
    this.compilationLevel.setDebugOptionsForCompilationLevel(options);
  }
  options.prettyPrint=this.prettyPrint;
  options.printInputDelimiter=this.printInputDelimiter;
  options.generateExports=this.generateExports;
  options.setLanguageIn(this.languageIn);
  options.setOutputCharset(this.outputEncoding);
  this.warningLevel.setOptionsForWarningLevel(options);
  options.setManageClosureDependencies(manageDependencies);
  convertEntryPointParameters(options);
  options.setTrustedStrings(true);
  if (replaceProperties) {
    convertPropertiesMap(options);
  }
  convertDefineParameters(options);
  for (  Warning warning : warnings) {
    CheckLevel level=warning.getLevel();
    String groupName=warning.getGroup();
    DiagnosticGroup group=new DiagnosticGroups().forName(groupName);
    if (group == null) {
      throw new BuildException(""String_Node_Str"" + groupName + ""String_Node_Str"");
    }
    options.setWarningLevel(group,level);
  }
  if (!Strings.isNullOrEmpty(sourceMapFormat)) {
    options.sourceMapFormat=Format.valueOf(sourceMapFormat);
  }
  if (!Strings.isNullOrEmpty(sourceMapLocationMapping)) {
    String tokens[]=sourceMapLocationMapping.split(""String_Node_Str"",-1);
    LocationMapping lm=new LocationMapping(tokens[0],tokens[1]);
    options.sourceMapLocationMappings=Arrays.asList(lm);
  }
  if (sourceMapOutputFile != null) {
    File parentFile=sourceMapOutputFile.getParentFile();
    if (parentFile.mkdirs()) {
      log(""String_Node_Str"" + parentFile,Project.MSG_DEBUG);
    }
    options.sourceMapOutputPath=parentFile.getAbsolutePath();
  }
  return options;
}",0.9223826714801444
27678,"private JSType getTypeAtPropDeclNode(Node declNode,JSDocInfo jsdoc){
  Node initializer=NodeUtil.getInitializer(declNode);
  if (initializer != null && initializer.isFunction()) {
    return JSType.fromFunctionType(currentScope.getScope(getFunInternalName(initializer)).getDeclaredType().toFunctionType());
  }
  EnumType et=currentScope.getEnum(declNode.getQualifiedName());
  if (et != null) {
    return et.toJSType();
  }
  return getTypeDeclarationFromJsdoc(jsdoc,currentScope);
}","private JSType getTypeAtPropDeclNode(Node declNode,JSDocInfo jsdoc){
  Preconditions.checkArgument(!currentScope.isNamespace(declNode));
  Node initializer=NodeUtil.getInitializer(declNode);
  if (initializer != null && initializer.isFunction()) {
    return JSType.fromFunctionType(currentScope.getScope(getFunInternalName(initializer)).getDeclaredType().toFunctionType());
  }
  return getTypeDeclarationFromJsdoc(jsdoc,currentScope);
}",0.8017334777898159
27679,"private void visitConstructorPropertyDeclaration(Node getProp){
  Preconditions.checkArgument(getProp.isGetProp());
  String ctorName=getProp.getFirstChild().getQualifiedName();
  QualifiedName ctorQname=QualifiedName.fromNode(getProp.getFirstChild());
  Preconditions.checkState(currentScope.isLocalFunDef(ctorName));
  RawNominalType classType=currentScope.getNominalType(ctorQname);
  String pname=getProp.getLastChild().getString();
  JSDocInfo jsdoc=NodeUtil.getBestJSDocInfo(getProp);
  JSType propDeclType=getTypeAtPropDeclNode(getProp,jsdoc);
  boolean isConst=isConst(getProp);
  if (propDeclType != null || isConst) {
    JSType previousPropType=classType.getCtorPropDeclaredType(pname);
    if (classType.hasCtorProp(pname) && previousPropType != null && !suppressDupPropWarning(jsdoc,propDeclType,previousPropType)) {
      warnings.add(JSError.make(getProp,REDECLARED_PROPERTY,pname,classType.toString()));
      return;
    }
    if (isConst && !mayWarnAboutNoInit(getProp) && propDeclType == null) {
      propDeclType=inferConstTypeFromRhs(getProp);
    }
    classType.addCtorProperty(pname,propDeclType,isConst);
    getProp.putBooleanProp(Node.ANALYZED_DURING_GTI,true);
    if (isConst) {
      getProp.putBooleanProp(Node.CONSTANT_PROPERTY_DEF,true);
    }
  }
 else {
    classType.addUndeclaredCtorProperty(pname);
  }
}","private void visitConstructorPropertyDeclaration(Node getProp){
  Preconditions.checkArgument(getProp.isGetProp());
  if (isNamedType(getProp)) {
    return;
  }
  String ctorName=getProp.getFirstChild().getQualifiedName();
  QualifiedName ctorQname=QualifiedName.fromNode(getProp.getFirstChild());
  Preconditions.checkState(currentScope.isLocalFunDef(ctorName));
  RawNominalType classType=currentScope.getNominalType(ctorQname);
  String pname=getProp.getLastChild().getString();
  JSDocInfo jsdoc=NodeUtil.getBestJSDocInfo(getProp);
  JSType propDeclType=getTypeAtPropDeclNode(getProp,jsdoc);
  boolean isConst=isConst(getProp);
  if (propDeclType != null || isConst) {
    JSType previousPropType=classType.getCtorPropDeclaredType(pname);
    if (classType.hasCtorProp(pname) && previousPropType != null && !suppressDupPropWarning(jsdoc,propDeclType,previousPropType)) {
      warnings.add(JSError.make(getProp,REDECLARED_PROPERTY,pname,classType.toString()));
      return;
    }
    if (isConst && !mayWarnAboutNoInit(getProp) && propDeclType == null) {
      propDeclType=inferConstTypeFromRhs(getProp);
    }
    classType.addCtorProperty(pname,propDeclType,isConst);
    getProp.putBooleanProp(Node.ANALYZED_DURING_GTI,true);
    if (isConst) {
      getProp.putBooleanProp(Node.CONSTANT_PROPERTY_DEF,true);
    }
  }
 else {
    classType.addUndeclaredCtorProperty(pname);
  }
}",0.9831625183016104
27680,"public void testEnumsAsNamespaces(){
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OBJLIT_PROPERTY_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OBJLIT_PROPERTY_TYPE);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testEnumsAsNamespaces(){
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OBJLIT_PROPERTY_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OBJLIT_PROPERTY_TYPE);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",TypeCheck.CONSTRUCTOR_NOT_CALLABLE);
}",0.7531055900621118
27681,"boolean isSubclassOf(NominalType other){
  RawNominalType otherRawType=other.rawType;
  if (rawType.isInterface && !otherRawType.isInterface) {
    return false;
  }
  if (!rawType.isInterface && otherRawType.isInterface) {
    if (rawType.interfaces == null) {
      return false;
    }
    for (    NominalType i : rawType.interfaces) {
      if (i.instantiateGenerics(typeMap).isSubclassOf(other)) {
        return true;
      }
    }
    return false;
  }
  if (rawType.isInterface && otherRawType.isInterface) {
    if (rawType.equals(otherRawType)) {
      if (!typeMap.isEmpty()) {
        for (        String typeVar : rawType.getTypeParameters()) {
          Preconditions.checkState(other.typeMap.containsKey(typeVar),""String_Node_Str"",other,typeVar,typeMap.get(typeVar),this);
          if (!typeMap.get(typeVar).isSubtypeOf(other.typeMap.get(typeVar))) {
            return false;
          }
        }
      }
 else       if (!other.typeMap.isEmpty()) {
        return false;
      }
      return true;
    }
 else     if (rawType.interfaces == null) {
      return false;
    }
 else {
      for (      NominalType i : rawType.interfaces) {
        if (i.instantiateGenerics(typeMap).isSubclassOf(other)) {
          return true;
        }
      }
      return false;
    }
  }
  if (rawType.equals(otherRawType)) {
    if (!typeMap.isEmpty()) {
      for (      String typeVar : rawType.getTypeParameters()) {
        Preconditions.checkState(typeMap.containsKey(typeVar),""String_Node_Str"",typeVar,typeMap.keySet());
        JSType otherType=other.typeMap.containsKey(typeVar) ? other.typeMap.get(typeVar) : JSType.fromTypeVar(typeVar);
        if (!typeMap.get(typeVar).isSubtypeOf(otherType)) {
          return false;
        }
      }
    }
 else     if (!other.typeMap.isEmpty()) {
      return false;
    }
    return true;
  }
 else   if (rawType.superClass == null) {
    return false;
  }
 else {
    return rawType.superClass.instantiateGenerics(typeMap).isSubclassOf(other);
  }
}","boolean isSubclassOf(NominalType other){
  RawNominalType otherRawType=other.rawType;
  if (rawType.isInterface && !otherRawType.isInterface) {
    return false;
  }
  if (!rawType.isInterface && otherRawType.isInterface) {
    if (rawType.interfaces == null) {
      return false;
    }
    for (    NominalType i : rawType.interfaces) {
      if (i.instantiateGenerics(typeMap).isSubclassOf(other)) {
        return true;
      }
    }
    return false;
  }
  if (rawType.isInterface && otherRawType.isInterface) {
    if (rawType.equals(otherRawType)) {
      if (!typeMap.isEmpty()) {
        for (        String typeVar : rawType.getTypeParameters()) {
          Preconditions.checkState(other.typeMap.containsKey(typeVar),""String_Node_Str"",other,typeVar,typeMap.get(typeVar),this);
          if (!typeMap.get(typeVar).isSubtypeOf(other.typeMap.get(typeVar))) {
            return false;
          }
        }
      }
 else       if (!other.typeMap.isEmpty()) {
        return false;
      }
      return true;
    }
 else     if (rawType.interfaces == null) {
      return false;
    }
 else {
      for (      NominalType i : rawType.interfaces) {
        if (i.instantiateGenerics(typeMap).isSubclassOf(other)) {
          return true;
        }
      }
      return false;
    }
  }
  if (rawType.equals(otherRawType)) {
    if (typeMap.isEmpty()) {
      return instantiationIsUnknownOrIdentity(other);
    }
    if (other.typeMap.isEmpty()) {
      return instantiationIsUnknownOrIdentity(this);
    }
    for (    String typeVar : rawType.getTypeParameters()) {
      Preconditions.checkState(typeMap.containsKey(typeVar),""String_Node_Str"",typeVar,typeMap.keySet());
      Preconditions.checkState(other.typeMap.containsKey(typeVar),""String_Node_Str"",other,typeVar,typeMap.get(typeVar),this);
      if (!typeMap.get(typeVar).isSubtypeOf(other.typeMap.get(typeVar))) {
        return false;
      }
    }
    return true;
  }
 else   if (rawType.superClass == null) {
    return false;
  }
 else {
    return rawType.superClass.instantiateGenerics(typeMap).isSubclassOf(other);
  }
}",0.8697560975609756
27682,"private JSType simpleInferExprType(Node n){
switch (n.getType()) {
case Token.REGEXP:
    return getRegexpType();
case Token.ARRAYLIT:
{
    if (!n.hasChildren()) {
      return null;
    }
    Node child=n.getFirstChild();
    JSType arrayType=simpleInferExprType(child);
    if (arrayType == null) {
      return null;
    }
    while (null != (child=child.getNext())) {
      if (!arrayType.equals(simpleInferExprType(child))) {
        return null;
      }
    }
    return getArrayType(arrayType);
  }
case Token.TRUE:
return JSType.TRUE_TYPE;
case Token.FALSE:
return JSType.FALSE_TYPE;
case Token.NAME:
{
String varName=n.getString();
if (varName.equals(""String_Node_Str"")) {
return JSType.UNDEFINED;
}
 else if (currentScope.isNamespaceLiteral(varName)) {
return null;
}
return currentScope.getDeclaredTypeOf(varName);
}
case Token.OBJECTLIT:
{
JSType objLitType=JSType.TOP_OBJECT;
for (Node prop : n.children()) {
JSType propType=simpleInferExprType(prop.getFirstChild());
if (propType == null) {
return null;
}
objLitType=objLitType.withProperty(new QualifiedName(NodeUtil.getObjectLitKeyName(prop)),propType);
}
return objLitType;
}
case Token.GETPROP:
JSType recvType=simpleInferExprType(n.getFirstChild());
if (recvType == null) {
return null;
}
QualifiedName qname=new QualifiedName(n.getLastChild().getString());
if (!recvType.mayHaveProp(qname)) {
return null;
}
return recvType.getProp(qname);
case Token.COMMA:
case Token.ASSIGN:
return simpleInferExprType(n.getLastChild());
case Token.CALL:
case Token.NEW:
JSType ratorType=simpleInferExprType(n.getFirstChild());
if (ratorType == null) {
return null;
}
FunctionType funType=ratorType.getFunType();
if (funType == null) {
return null;
}
if (funType.isGeneric()) {
ImmutableList.Builder<JSType> argTypes=ImmutableList.builder();
for (Node argNode=n.getFirstChild().getNext(); argNode != null; argNode=argNode.getNext()) {
JSType t=simpleInferExprType(argNode);
if (t == null) {
return null;
}
argTypes.add(t);
}
funType=funType.instantiateGenericsFromArgumentList(argTypes.build());
if (funType == null) {
return null;
}
}
return funType.getReturnType();
default :
switch (NodeUtil.getKnownValueType(n)) {
case NULL:
return JSType.NULL;
case VOID:
return JSType.UNDEFINED;
case NUMBER:
return JSType.NUMBER;
case STRING:
return JSType.STRING;
case BOOLEAN:
return JSType.BOOLEAN;
case UNDETERMINED:
default :
return null;
}
}
}","private JSType simpleInferExprType(Node n){
switch (n.getType()) {
case Token.REGEXP:
    return getRegexpType();
case Token.ARRAYLIT:
{
    if (!n.hasChildren()) {
      return null;
    }
    Node child=n.getFirstChild();
    JSType arrayType=simpleInferExprType(child);
    if (arrayType == null) {
      return null;
    }
    while (null != (child=child.getNext())) {
      if (!arrayType.equals(simpleInferExprType(child))) {
        return null;
      }
    }
    return getArrayType(arrayType);
  }
case Token.TRUE:
return JSType.TRUE_TYPE;
case Token.FALSE:
return JSType.FALSE_TYPE;
case Token.NAME:
{
String varName=n.getString();
if (varName.equals(""String_Node_Str"")) {
return JSType.UNDEFINED;
}
 else if (currentScope.isNamespaceLiteral(varName)) {
return null;
}
return currentScope.getDeclaredTypeOf(varName);
}
case Token.OBJECTLIT:
{
JSType objLitType=JSType.TOP_OBJECT;
for (Node prop : n.children()) {
JSType propType=simpleInferExprType(prop.getFirstChild());
if (propType == null) {
return null;
}
objLitType=objLitType.withProperty(new QualifiedName(NodeUtil.getObjectLitKeyName(prop)),propType);
}
return objLitType;
}
case Token.GETPROP:
JSType recvType=simpleInferExprType(n.getFirstChild());
if (recvType == null) {
return null;
}
QualifiedName qname=new QualifiedName(n.getLastChild().getString());
if (!recvType.mayHaveProp(qname)) {
return null;
}
return recvType.getProp(qname);
case Token.COMMA:
case Token.ASSIGN:
return simpleInferExprType(n.getLastChild());
case Token.CALL:
case Token.NEW:
JSType ratorType=simpleInferExprType(n.getFirstChild());
if (ratorType == null) {
return null;
}
FunctionType funType=ratorType.getFunType();
if (funType == null) {
return null;
}
if (funType.isGeneric()) {
ImmutableList.Builder<JSType> argTypes=ImmutableList.builder();
for (Node argNode=n.getFirstChild().getNext(); argNode != null; argNode=argNode.getNext()) {
JSType t=simpleInferExprType(argNode);
if (t == null) {
return null;
}
argTypes.add(t);
}
funType=funType.instantiateGenericsFromArgumentTypes(argTypes.build());
if (funType == null) {
return null;
}
}
return funType.getReturnType();
default :
switch (NodeUtil.getKnownValueType(n)) {
case NULL:
return JSType.NULL;
case VOID:
return JSType.UNDEFINED;
case NUMBER:
return JSType.NUMBER;
case STRING:
return JSType.STRING;
case BOOLEAN:
return JSType.BOOLEAN;
case UNDETERMINED:
default :
return null;
}
}
}",0.998122261631546
27683,"public boolean isSubtypeOf(FunctionType other){
  if (other.isTopFunction() || other.isQmarkFunction() || this.isQmarkFunction()) {
    return true;
  }
  if (isTopFunction()) {
    return false;
  }
  Preconditions.checkState(!isLoose && !other.isLoose);
  if (this.isGeneric()) {
    return true;
  }
  if (requiredFormals.size() > other.requiredFormals.size()) {
    return false;
  }
  int otherMaxTotalArity=other.requiredFormals.size() + other.optionalFormals.size();
  for (int i=0; i < otherMaxTotalArity; i++) {
    JSType thisFormal=getFormalType(i);
    JSType otherFormal=other.getFormalType(i);
    if (thisFormal != null && !thisFormal.isUnknown() && !otherFormal.isUnknown() && !otherFormal.isSubtypeOf(thisFormal)) {
      return false;
    }
  }
  if (other.restFormals != null) {
    int thisMaxTotalArity=this.requiredFormals.size() + this.optionalFormals.size();
    if (this.restFormals != null) {
      thisMaxTotalArity++;
    }
    for (int i=otherMaxTotalArity; i < thisMaxTotalArity; i++) {
      JSType thisFormal=getFormalType(i);
      JSType otherFormal=other.getFormalType(i);
      if (thisFormal != null && !thisFormal.isUnknown() && !otherFormal.isUnknown() && !otherFormal.isSubtypeOf(thisFormal)) {
        return false;
      }
    }
  }
  if (nominalType == null && other.nominalType != null || nominalType != null && other.nominalType == null || nominalType != null && other.nominalType != null && !nominalType.isSubclassOf(other.nominalType)) {
    return false;
  }
  if (receiverType != null && other.receiverType == null || receiverType != null && other.receiverType != null && !receiverType.isSubclassOf(other.receiverType)) {
    return false;
  }
  return returnType.isUnknown() || other.returnType.isUnknown() || returnType.isSubtypeOf(other.returnType);
}","public boolean isSubtypeOf(FunctionType other){
  if (other.isTopFunction() || other.isQmarkFunction() || this.isQmarkFunction()) {
    return true;
  }
  if (isTopFunction()) {
    return false;
  }
  Preconditions.checkState(!isLoose && !other.isLoose);
  if (this.isGeneric()) {
    if (this.equals(other)) {
      return true;
    }
    return instantiateGenericsWithUnknown(this).isSubtypeOf(other);
  }
  if (requiredFormals.size() > other.requiredFormals.size()) {
    return false;
  }
  int otherMaxTotalArity=other.requiredFormals.size() + other.optionalFormals.size();
  for (int i=0; i < otherMaxTotalArity; i++) {
    JSType thisFormal=getFormalType(i);
    JSType otherFormal=other.getFormalType(i);
    if (thisFormal != null && !thisFormal.isUnknown() && !otherFormal.isUnknown() && !otherFormal.isSubtypeOf(thisFormal)) {
      return false;
    }
  }
  if (other.restFormals != null) {
    int thisMaxTotalArity=this.requiredFormals.size() + this.optionalFormals.size();
    if (this.restFormals != null) {
      thisMaxTotalArity++;
    }
    for (int i=otherMaxTotalArity; i < thisMaxTotalArity; i++) {
      JSType thisFormal=getFormalType(i);
      JSType otherFormal=other.getFormalType(i);
      if (thisFormal != null && !thisFormal.isUnknown() && !otherFormal.isUnknown() && !otherFormal.isSubtypeOf(thisFormal)) {
        return false;
      }
    }
  }
  if (nominalType == null && other.nominalType != null || nominalType != null && other.nominalType == null || nominalType != null && other.nominalType != null && !nominalType.isSubclassOf(other.nominalType)) {
    return false;
  }
  if (receiverType != null && other.receiverType == null || receiverType != null && other.receiverType != null && !receiverType.isSubclassOf(other.receiverType)) {
    return false;
  }
  return returnType.isUnknown() || other.returnType.isUnknown() || returnType.isSubtypeOf(other.returnType);
}",0.9655172413793104
27684,"static FunctionType meet(FunctionType f1,FunctionType f2){
  if (f1 == null || f2 == null) {
    return null;
  }
 else   if (f2.isTopFunction() || f1.equals(f2)) {
    return f1;
  }
 else   if (f1.isTopFunction()) {
    return f2;
  }
  if (f1.isLoose() || f2.isLoose()) {
    return FunctionType.looseJoin(f1,f2);
  }
  FunctionTypeBuilder builder=new FunctionTypeBuilder();
  int minRequiredArity=Math.min(f1.requiredFormals.size(),f2.requiredFormals.size());
  for (int i=0; i < minRequiredArity; i++) {
    builder.addReqFormal(JSType.nullAcceptingJoin(f1.getFormalType(i),f2.getFormalType(i)));
  }
  int maxTotalArity=Math.max(f1.requiredFormals.size() + f1.optionalFormals.size(),f2.requiredFormals.size() + f2.optionalFormals.size());
  for (int i=minRequiredArity; i < maxTotalArity; i++) {
    builder.addOptFormal(JSType.nullAcceptingJoin(f1.getFormalType(i),f2.getFormalType(i)));
  }
  if (f1.restFormals != null || f2.restFormals != null) {
    builder.addRestFormals(JSType.nullAcceptingJoin(f1.restFormals,f2.restFormals));
  }
  builder.addRetType(JSType.meet(f1.returnType,f2.returnType));
  builder.addNominalType(NominalType.pickSubclass(f1.nominalType,f2.nominalType));
  builder.addReceiverType(NominalType.pickSubclass(f1.receiverType,f2.receiverType));
  return builder.buildFunction();
}","static FunctionType meet(FunctionType f1,FunctionType f2){
  if (f1 == null || f2 == null) {
    return null;
  }
 else   if (f2.isTopFunction() || f1.equals(f2)) {
    return f1;
  }
 else   if (f1.isTopFunction()) {
    return f2;
  }
  if (f1.isLoose() || f2.isLoose()) {
    return FunctionType.looseJoin(f1,f2);
  }
  if (f1.isGeneric() && f1.isSubtypeOf(f2)) {
    return f1;
  }
 else   if (f2.isGeneric() && f2.isSubtypeOf(f1)) {
    return f2;
  }
  Preconditions.checkState(!f1.isGeneric());
  Preconditions.checkState(!f2.isGeneric());
  FunctionTypeBuilder builder=new FunctionTypeBuilder();
  int minRequiredArity=Math.min(f1.requiredFormals.size(),f2.requiredFormals.size());
  for (int i=0; i < minRequiredArity; i++) {
    builder.addReqFormal(JSType.nullAcceptingJoin(f1.getFormalType(i),f2.getFormalType(i)));
  }
  int maxTotalArity=Math.max(f1.requiredFormals.size() + f1.optionalFormals.size(),f2.requiredFormals.size() + f2.optionalFormals.size());
  for (int i=minRequiredArity; i < maxTotalArity; i++) {
    builder.addOptFormal(JSType.nullAcceptingJoin(f1.getFormalType(i),f2.getFormalType(i)));
  }
  if (f1.restFormals != null || f2.restFormals != null) {
    builder.addRestFormals(JSType.nullAcceptingJoin(f1.restFormals,f2.restFormals));
  }
  builder.addRetType(JSType.meet(f1.returnType,f2.returnType));
  builder.addNominalType(NominalType.pickSubclass(f1.nominalType,f2.nominalType));
  builder.addReceiverType(NominalType.pickSubclass(f1.receiverType,f2.receiverType));
  return builder.buildFunction();
}",0.920812894183602
27685,"FunctionType specialize(FunctionType other){
  if (other == null || !this.isLoose() && other.isLoose()) {
    return this;
  }
 else {
    FunctionType result=FunctionType.meet(this,other);
    if (this.isLoose && !result.isLoose()) {
      result=result.withLoose();
    }
    return result;
  }
}","FunctionType specialize(FunctionType other){
  if (other == null || !this.isLoose() && other.isLoose()) {
    return this;
  }
  FunctionType result=FunctionType.meet(this,other);
  if (this.isLoose && !result.isLoose()) {
    result=result.withLoose();
  }
  return result;
}",0.5888501742160279
27686,"public void testInferConstTypeFromGenerics(){
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",GlobalTypeInfo.COULD_NOT_INFER_CONST_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",ImmutableList.of(GlobalTypeInfo.COULD_NOT_INFER_CONST_TYPE,NewTypeInference.NOT_UNIQUE_INSTANTIATION));
}","public void testInferConstTypeFromGenerics(){
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",GlobalTypeInfo.COULD_NOT_INFER_CONST_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",ImmutableList.of(GlobalTypeInfo.COULD_NOT_INFER_CONST_TYPE,NewTypeInference.NOT_UNIQUE_INSTANTIATION));
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",ImmutableList.of(GlobalTypeInfo.COULD_NOT_INFER_CONST_TYPE,TypeCheck.WRONG_ARGUMENT_COUNT));
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",ImmutableList.of(GlobalTypeInfo.COULD_NOT_INFER_CONST_TYPE,TypeCheck.WRONG_ARGUMENT_COUNT));
}",0.783375314861461
27687,"public void testArrayLiteralUsedGenericallyDoesntCrash(){
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
}","public void testArrayLiteralUsedGenericallyDoesntCrash(){
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.7828571428571428
27688,"/** 
 * Declares a variable.
 * @param s The scope to declare the variable in.
 * @param n The node corresponding to the variable name.
 */
private void declareVar(Scope s,Node n){
  Preconditions.checkState(n.isName() || n.isRest() || n.isStringKey());
  String name=n.getString();
  if (s.getVar(name) != null && s.getVar(name).getNode() == n) {
    return;
  }
  CompilerInput input=compiler.getInput(inputId);
  if (s.isDeclared(name,false) || (s.isLocal() && name.equals(ARGUMENTS))) {
    redeclarationHandler.onRedeclaration(s,name,n,input);
  }
 else {
    s.declare(name,n,null,input);
  }
}","/** 
 * Declares a variable.
 * @param s The scope to declare the variable in.
 * @param n The node corresponding to the variable name.
 */
private void declareVar(Scope s,Node n){
  Preconditions.checkState(n.isName() || n.isRest() || n.isStringKey(),""String_Node_Str"",n);
  String name=n.getString();
  if (s.getVar(name) != null && s.getVar(name).getNode() == n) {
    return;
  }
  CompilerInput input=compiler.getInput(inputId);
  if (s.isDeclared(name,false) || (s.isLocal() && name.equals(ARGUMENTS))) {
    redeclarationHandler.onRedeclaration(s,name,n,input);
  }
 else {
    s.declare(name,n,null,input);
  }
}",0.9836065573770492
27689,"private void declareLHS(Scope declarationScope,Node lhs){
  if (lhs.isStringKey()) {
    if (lhs.hasChildren()) {
      declareLHS(declarationScope,lhs.getFirstChild());
    }
 else {
      declareVar(declarationScope,lhs);
    }
  }
 else   if (lhs.isName() || lhs.isRest()) {
    declareVar(declarationScope,lhs);
  }
 else   if (lhs.isDefaultValue()) {
    declareVar(declarationScope,lhs.getFirstChild());
  }
 else   if (lhs.isArrayPattern() || lhs.isObjectPattern()) {
    for (Node child=lhs.getFirstChild(); child != null; child=child.getNext()) {
      if (NodeUtil.isNameDeclaration(lhs.getParent()) && child.getNext() == null) {
        return;
      }
      declareLHS(declarationScope,child);
    }
  }
 else {
    Preconditions.checkState(lhs.isEmpty(),""String_Node_Str"",lhs);
  }
}","private void declareLHS(Scope declarationScope,Node lhs){
  if (lhs.isStringKey()) {
    if (lhs.hasChildren()) {
      declareLHS(declarationScope,lhs.getFirstChild());
    }
 else {
      declareVar(declarationScope,lhs);
    }
  }
 else   if (lhs.isName() || lhs.isRest()) {
    declareVar(declarationScope,lhs);
  }
 else   if (lhs.isDefaultValue()) {
    declareLHS(declarationScope,lhs.getFirstChild());
  }
 else   if (lhs.isArrayPattern() || lhs.isObjectPattern()) {
    for (Node child=lhs.getFirstChild(); child != null; child=child.getNext()) {
      if (NodeUtil.isNameDeclaration(lhs.getParent()) && child.getNext() == null) {
        return;
      }
      declareLHS(declarationScope,child);
    }
  }
 else {
    Preconditions.checkState(lhs.isEmpty(),""String_Node_Str"",lhs);
  }
}",0.9962311557788944
27690,"/** 
 * For each node, update the block stack and reference collection as appropriate.
 */
@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (n.isName()) {
    Var v;
    if (n.getString().equals(""String_Node_Str"")) {
      v=t.getScope().getArgumentsVar();
    }
 else {
      v=t.getScope().getVar(n.getString());
    }
    if (v != null) {
      if (varFilter.apply(v)) {
        addReference(v,new Reference(n,t,peek(blockStack)));
      }
      if (v.getParentNode() != null && NodeUtil.isHoistedFunctionDeclaration(v.getParentNode()) && (narrowScope == null || narrowScope.getDepth() <= v.getScope().getDepth())) {
        outOfBandTraversal(v);
      }
    }
  }
  if (isBlockBoundary(n,parent)) {
    pop(blockStack);
  }
}","/** 
 * For each node, update the block stack and reference collection as appropriate.
 */
@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (n.isName() || (n.isStringKey() && parent.isObjectPattern() && !n.hasChildren())) {
    Var v;
    if (n.getString().equals(""String_Node_Str"")) {
      v=t.getScope().getArgumentsVar();
    }
 else {
      v=t.getScope().getVar(n.getString());
    }
    if (v != null) {
      if (varFilter.apply(v)) {
        addReference(v,new Reference(n,t,peek(blockStack)));
      }
      if (v.getParentNode() != null && NodeUtil.isHoistedFunctionDeclaration(v.getParentNode()) && (narrowScope == null || narrowScope.getDepth() <= v.getScope().getDepth())) {
        outOfBandTraversal(v);
      }
    }
  }
  if (isBlockBoundary(n,parent)) {
    pop(blockStack);
  }
}",0.9560789306174412
27691,"boolean isDeclaration(){
  Node parent=getParent();
  if (parent.isClass() && nameNode != parent.getFirstChild()) {
    return false;
  }
  while (parent.isArrayPattern()) {
    parent=parent.getParent();
  }
  if (parent.isDefaultValue() && nameNode == parent.getFirstChild()) {
    return true;
  }
  return DECLARATION_PARENTS.contains(parent.getType());
}","boolean isDeclaration(){
  return isDeclarationHelper(nameNode);
}",0.2211764705882353
27692,"/** 
 * @param n The name node to check.
 * @param origVar The associated Var.
 * @return Whether duplicated declarations warnings should be suppressedfor the given node.
 */
static boolean hasDuplicateDeclarationSuppression(Node n,Scope.Var origVar){
  Preconditions.checkState(n.isName());
  Node parent=n.getParent();
  Node origParent=origVar.getParentNode();
  JSDocInfo info=n.getJSDocInfo();
  if (info == null) {
    info=parent.getJSDocInfo();
  }
  if (info != null && info.getSuppressions().contains(""String_Node_Str"")) {
    return true;
  }
  info=origVar.nameNode.getJSDocInfo();
  if (info == null) {
    info=origParent.getJSDocInfo();
  }
  return (info != null && info.getSuppressions().contains(""String_Node_Str""));
}","/** 
 * @param n The name node to check.
 * @param origVar The associated Var.
 * @return Whether duplicated declarations warnings should be suppressedfor the given node.
 */
static boolean hasDuplicateDeclarationSuppression(Node n,Scope.Var origVar){
  Preconditions.checkState(n.isName() || n.isStringKey());
  Node parent=n.getParent();
  Node origParent=origVar.getParentNode();
  JSDocInfo info=n.getJSDocInfo();
  if (info == null) {
    info=parent.getJSDocInfo();
  }
  if (info != null && info.getSuppressions().contains(""String_Node_Str"")) {
    return true;
  }
  info=origVar.nameNode.getJSDocInfo();
  if (info == null) {
    info=origParent.getJSDocInfo();
  }
  return (info != null && info.getSuppressions().contains(""String_Node_Str""));
}",0.9872568745808182
27693,"@Override Node processDefaultParameter(DefaultParameterTree tree){
  maybeWarnEs6Feature(tree,""String_Node_Str"");
  Node lhs=transform(tree.lhs);
  if (tree.lhs instanceof ArrayLiteralExpressionTree) {
    lhs.setType(Token.ARRAY_PATTERN);
  }
  return newNode(Token.DEFAULT_VALUE,lhs,transform(tree.defaultValue));
}","@Override Node processDefaultParameter(DefaultParameterTree tree){
  maybeWarnEs6Feature(tree,""String_Node_Str"");
  Node lhs=transform(tree.lhs);
  if (tree.lhs instanceof ArrayLiteralExpressionTree) {
    lhs.setType(Token.ARRAY_PATTERN);
  }
 else   if (tree.lhs instanceof ObjectLiteralExpressionTree) {
    lhs.setType(Token.OBJECT_PATTERN);
  }
  return newNode(Token.DEFAULT_VALUE,lhs,transform(tree.defaultValue));
}",0.8567567567567568
27694,"private ParseTree parsePatternElement(PatternKind kind,EnumSet<TokenType> follow){
  if (peekParenPattern(kind,follow)) {
    return parseParenPattern(kind);
  }
  boolean rest=false;
  SourcePosition start=getTreeStartLocation();
  if (peek(TokenType.SPREAD)) {
    eat(TokenType.SPREAD);
    rest=true;
  }
  ParseTree lvalue=parseLeftHandSideExpression();
  if ((rest || kind == PatternKind.INITIALIZER) && lvalue.type != ParseTreeType.IDENTIFIER_EXPRESSION) {
    reportError(""String_Node_Str"");
    return lvalue;
  }
  if (rest) {
    return new AssignmentRestElementTree(getTreeLocation(start),lvalue.asIdentifierExpression().identifierToken);
  }
  Token eq=eatOpt(TokenType.EQUAL);
  if (eq != null) {
    ParseTree defaultValue=parseAssignmentExpression();
    return new DefaultParameterTree(getTreeLocation(start),lvalue,defaultValue);
  }
  return lvalue;
}","private ParseTree parsePatternElement(PatternKind kind,EnumSet<TokenType> follow){
  if (peekParenPattern(kind,follow)) {
    return parseParenPattern(kind);
  }
  boolean rest=false;
  SourcePosition start=getTreeStartLocation();
  if (peek(TokenType.SPREAD)) {
    eat(TokenType.SPREAD);
    rest=true;
  }
  ParseTree lvalue=parseLeftHandSideExpression();
  if (rest && lvalue.type != ParseTreeType.IDENTIFIER_EXPRESSION) {
    reportError(""String_Node_Str"");
    return lvalue;
  }
  if (rest) {
    return new AssignmentRestElementTree(getTreeLocation(start),lvalue.asIdentifierExpression().identifierToken);
  }
  Token eq=eatOpt(TokenType.EQUAL);
  if (eq != null) {
    ParseTree defaultValue=parseAssignmentExpression();
    return new DefaultParameterTree(getTreeLocation(start),lvalue,defaultValue);
  }
  return lvalue;
}",0.9735760422783324
27695,"private DeclaredFunctionType computeFnDeclaredType(JSDocInfo fnDoc,String functionName,Node declNode,RawNominalType ownerType,Scope parentScope){
  Preconditions.checkArgument(declNode.isFunction() || declNode.isGetProp());
  Node parent=declNode.getParent();
  if (fnDoc == null && !NodeUtil.functionHasInlineJsdocs(declNode) && parent.isCall() && declNode != parent.getFirstChild()) {
    FunctionType calleeDeclType=getDeclaredFunctionTypeOfCalleeIfAny(parent.getFirstChild(),parentScope);
    if (calleeDeclType != null) {
      int index=parent.getIndexOfChild(declNode) - 1;
      JSType declTypeFromCallee=calleeDeclType.getFormalType(index);
      if (declTypeFromCallee != null) {
        DeclaredFunctionType t=computeFnDeclaredTypeFromCallee(declNode,declTypeFromCallee);
        if (t != null) {
          return t;
        }
      }
    }
  }
  ImmutableList<String> typeParameters=fnDoc == null ? null : fnDoc.getTemplateTypeNames();
  FunctionTypeBuilder builder=typeParser.getFunctionType(fnDoc,declNode,ownerType,parentScope);
  RawNominalType ctorType=null;
  if (fnDoc != null) {
    NominalType parentClass=""String_Node_Str"".equals(functionName) ? null : getObjectNominalType();
    if (fnDoc.hasBaseType()) {
      if (!fnDoc.isConstructor()) {
        warnings.add(JSError.make(declNode,EXTENDS_NOT_ON_CTOR_OR_INTERF,functionName));
      }
 else {
        Node docNode=fnDoc.getBaseType().getRootNode();
        if (typeParser.hasKnownType(docNode,ownerType,parentScope,typeParameters)) {
          parentClass=typeParser.getNominalType(docNode,ownerType,parentScope,typeParameters);
          if (parentClass == null) {
            warnings.add(JSError.make(declNode,EXTENDS_NON_OBJECT,functionName,docNode.toStringTree()));
          }
 else           if (parentClass.isInterface()) {
            warnings.add(JSError.make(declNode,TypeCheck.CONFLICTING_EXTENDED_TYPE,""String_Node_Str"",functionName));
            parentClass=null;
          }
        }
      }
    }
    ctorType=declNode.isFunction() ? nominaltypesByNode.get(declNode) : null;
    ImmutableSet<NominalType> implementedIntfs=typeParser.getImplementedInterfaces(fnDoc,ownerType,parentScope,typeParameters);
    if (ctorType == null && (fnDoc.isConstructor() || fnDoc.isInterface())) {
      return builder.buildDeclaration();
    }
 else     if (fnDoc.isConstructor()) {
      String className=ctorType.toString();
      if (parentClass != null) {
        if (!ctorType.addSuperClass(parentClass)) {
          warnings.add(JSError.make(declNode,INHERITANCE_CYCLE,className));
        }
 else         if (ctorType.isStruct() && !parentClass.isStruct()) {
          warnings.add(JSError.make(declNode,TypeCheck.CONFLICTING_SHAPE_TYPE,className,""String_Node_Str"",""String_Node_Str""));
        }
 else         if (ctorType.isDict() && !parentClass.isDict()) {
          warnings.add(JSError.make(declNode,TypeCheck.CONFLICTING_SHAPE_TYPE,className,""String_Node_Str"",""String_Node_Str""));
        }
      }
      if (ctorType.isDict() && !implementedIntfs.isEmpty()) {
        warnings.add(JSError.make(declNode,DICT_IMPLEMENTS_INTERF,className));
      }
      boolean noCycles=ctorType.addInterfaces(implementedIntfs);
      Preconditions.checkState(noCycles);
      builder.addNominalType(ctorType.getAsNominalType());
    }
 else     if (fnDoc.isInterface()) {
      if (declNode.isFunction() && !NodeUtil.isEmptyBlock(NodeUtil.getFunctionBody(declNode))) {
        warnings.add(JSError.make(declNode,INTERFACE_WITH_A_BODY));
      }
      if (!implementedIntfs.isEmpty()) {
        warnings.add(JSError.make(declNode,TypeCheck.CONFLICTING_IMPLEMENTED_TYPE,functionName));
      }
      boolean noCycles=ctorType.addInterfaces(typeParser.getExtendedInterfaces(fnDoc,ownerType,parentScope,typeParameters));
      if (!noCycles) {
        warnings.add(JSError.make(declNode,INHERITANCE_CYCLE,ctorType.toString()));
      }
      builder.addNominalType(ctorType.getAsNominalType());
    }
 else     if (!implementedIntfs.isEmpty()) {
      warnings.add(JSError.make(declNode,IMPLEMENTS_WITHOUT_CONSTRUCTOR,functionName));
    }
  }
  if (ownerType != null) {
    builder.addReceiverType(ownerType.getAsNominalType());
  }
  DeclaredFunctionType result=builder.buildDeclaration();
  if (ctorType != null) {
    ctorType.setCtorFunction(result.toFunctionType());
  }
  return result;
}","private DeclaredFunctionType computeFnDeclaredType(JSDocInfo fnDoc,String functionName,Node declNode,RawNominalType ownerType,Scope parentScope){
  Preconditions.checkArgument(declNode.isFunction() || declNode.isGetProp());
  Node parent=declNode.getParent();
  if (fnDoc == null && !NodeUtil.functionHasInlineJsdocs(declNode) && parent.isCall() && declNode != parent.getFirstChild()) {
    FunctionType calleeDeclType=getDeclaredFunctionTypeOfCalleeIfAny(parent.getFirstChild(),parentScope);
    if (calleeDeclType != null) {
      int index=parent.getIndexOfChild(declNode) - 1;
      JSType declTypeFromCallee=calleeDeclType.getFormalType(index);
      if (declTypeFromCallee != null) {
        DeclaredFunctionType t=computeFnDeclaredTypeFromCallee(declNode,declTypeFromCallee);
        if (t != null) {
          return t;
        }
      }
    }
  }
  ImmutableList<String> typeParameters=fnDoc == null ? null : fnDoc.getTemplateTypeNames();
  FunctionTypeBuilder builder=typeParser.getFunctionType(fnDoc,declNode,ownerType,parentScope);
  RawNominalType ctorType=null;
  if (fnDoc != null) {
    NominalType parentClass=""String_Node_Str"".equals(functionName) ? null : getObjectNominalType();
    if (fnDoc.hasBaseType()) {
      if (!fnDoc.isConstructor()) {
        warnings.add(JSError.make(declNode,EXTENDS_NOT_ON_CTOR_OR_INTERF,functionName));
      }
 else {
        Node docNode=fnDoc.getBaseType().getRootNode();
        if (typeParser.hasKnownType(docNode,ownerType,parentScope,typeParameters)) {
          parentClass=typeParser.getNominalType(docNode,ownerType,parentScope,typeParameters);
          if (parentClass == null) {
            warnings.add(JSError.make(declNode,EXTENDS_NON_OBJECT,functionName,docNode.toStringTree()));
          }
 else           if (parentClass.isInterface()) {
            warnings.add(JSError.make(declNode,TypeCheck.CONFLICTING_EXTENDED_TYPE,""String_Node_Str"",functionName));
            parentClass=null;
          }
        }
      }
    }
    ctorType=declNode.isFunction() ? nominaltypesByNode.get(declNode) : null;
    ImmutableSet<NominalType> implementedIntfs=typeParser.getImplementedInterfaces(fnDoc,ownerType,parentScope,typeParameters);
    if (ctorType == null && (fnDoc.isConstructor() || fnDoc.isInterface())) {
      return builder.buildDeclaration();
    }
 else     if (fnDoc.isConstructor()) {
      String className=ctorType.toString();
      if (parentClass != null) {
        if (!ctorType.addSuperClass(parentClass)) {
          warnings.add(JSError.make(declNode,INHERITANCE_CYCLE,className));
        }
 else         if (ctorType.isStruct() && !parentClass.isStruct()) {
          warnings.add(JSError.make(declNode,TypeCheck.CONFLICTING_SHAPE_TYPE,""String_Node_Str"",className));
        }
 else         if (ctorType.isDict() && !parentClass.isDict()) {
          warnings.add(JSError.make(declNode,TypeCheck.CONFLICTING_SHAPE_TYPE,""String_Node_Str"",className));
        }
      }
      if (ctorType.isDict() && !implementedIntfs.isEmpty()) {
        warnings.add(JSError.make(declNode,DICT_IMPLEMENTS_INTERF,className));
      }
      boolean noCycles=ctorType.addInterfaces(implementedIntfs);
      Preconditions.checkState(noCycles);
      builder.addNominalType(ctorType.getAsNominalType());
    }
 else     if (fnDoc.isInterface()) {
      if (declNode.isFunction() && !NodeUtil.isEmptyBlock(NodeUtil.getFunctionBody(declNode))) {
        warnings.add(JSError.make(declNode,INTERFACE_WITH_A_BODY));
      }
      if (!implementedIntfs.isEmpty()) {
        warnings.add(JSError.make(declNode,TypeCheck.CONFLICTING_IMPLEMENTED_TYPE,functionName));
      }
      boolean noCycles=ctorType.addInterfaces(typeParser.getExtendedInterfaces(fnDoc,ownerType,parentScope,typeParameters));
      if (!noCycles) {
        warnings.add(JSError.make(declNode,INHERITANCE_CYCLE,ctorType.toString()));
      }
      builder.addNominalType(ctorType.getAsNominalType());
    }
 else     if (!implementedIntfs.isEmpty()) {
      warnings.add(JSError.make(declNode,IMPLEMENTS_WITHOUT_CONSTRUCTOR,functionName));
    }
  }
  if (ownerType != null) {
    builder.addReceiverType(ownerType.getAsNominalType());
  }
  DeclaredFunctionType result=builder.buildDeclaration();
  if (ctorType != null) {
    ctorType.setCtorFunction(result.toFunctionType());
  }
  return result;
}",0.9917260399908068
27696,"private JSType evalMaprecord(Node ttlAst,NameResolver nameResolver){
  ImmutableList<Node> params=getCallParams(ttlAst);
  Node recParam=params.get(0);
  JSType recType=evalInternal(recParam,nameResolver);
  if (!recType.isRecordType()) {
    reportWarning(ttlAst,RECTYPE_INVALID,recType.toString());
    return getUnknownType();
  }
  ObjectType objRecType=((ObjectType)recType);
  Set<String> ownPropsNames=objRecType.getOwnPropertyNames();
  Node mapFunction=params.get(1);
  String paramKey=getFunctionParameter(mapFunction,0);
  String paramValue=getFunctionParameter(mapFunction,1);
  if (nameResolver.nameVars.containsKey(paramKey)) {
    reportWarning(ttlAst,DUPLICATE_VARIABLE,paramKey);
    return getUnknownType();
  }
  if (nameResolver.typeVars.containsKey(paramValue)) {
    reportWarning(ttlAst,DUPLICATE_VARIABLE,paramValue);
    return getUnknownType();
  }
  Node mapFnBody=getFunctionBody(mapFunction);
  ImmutableMap.Builder<String,JSType> newPropsBuilder=new ImmutableMap.Builder<String,JSType>();
  for (  String propName : ownPropsNames) {
    JSType propValue=objRecType.getSlot(propName).getType();
    NameResolver newNameResolver=new NameResolver(addNewEntry(nameResolver.typeVars,paramValue,propValue),addNewEntry(nameResolver.nameVars,paramKey,propName));
    JSType mapFnBodyResult=evalInternal(mapFnBody,newNameResolver);
    if (mapFnBodyResult.isNoType()) {
      continue;
    }
    if (!mapFnBodyResult.isRecordType()) {
      reportWarning(ttlAst,MAPRECORD_BODY_INVALID,mapFnBodyResult.toString());
      return getUnknownType();
    }
    ObjectType mapFnBodyAsObjType=((ObjectType)mapFnBodyResult);
    for (    String newPropName : mapFnBodyAsObjType.getOwnPropertyNames()) {
      JSType newPropValue=mapFnBodyAsObjType.getSlot(newPropName).getType();
      newPropsBuilder.put(newPropName,newPropValue);
    }
  }
  return createRecordType(newPropsBuilder.build());
}","private JSType evalMaprecord(Node ttlAst,NameResolver nameResolver){
  ImmutableList<Node> params=getCallParams(ttlAst);
  Node recParam=params.get(0);
  JSType recType=evalInternal(recParam,nameResolver);
  if (!recType.isRecordType()) {
    reportWarning(ttlAst,RECTYPE_INVALID,recType.toString());
    return getUnknownType();
  }
  ObjectType objRecType=((ObjectType)recType);
  Set<String> ownPropsNames=objRecType.getOwnPropertyNames();
  Node mapFunction=params.get(1);
  String paramKey=getFunctionParameter(mapFunction,0);
  String paramValue=getFunctionParameter(mapFunction,1);
  if (nameResolver.nameVars.containsKey(paramKey)) {
    reportWarning(ttlAst,DUPLICATE_VARIABLE,paramKey);
    return getUnknownType();
  }
  if (nameResolver.typeVars.containsKey(paramValue)) {
    reportWarning(ttlAst,DUPLICATE_VARIABLE,paramValue);
    return getUnknownType();
  }
  Node mapFnBody=getFunctionBody(mapFunction);
  Map<String,JSType> newProps=new HashMap<String,JSType>();
  for (  String propName : ownPropsNames) {
    JSType propValue=objRecType.getSlot(propName).getType();
    NameResolver newNameResolver=new NameResolver(addNewEntry(nameResolver.typeVars,paramValue,propValue),addNewEntry(nameResolver.nameVars,paramKey,propName));
    JSType mapFnBodyResult=evalInternal(mapFnBody,newNameResolver);
    if (mapFnBodyResult.isNoType()) {
      continue;
    }
    if (!mapFnBodyResult.isRecordType()) {
      reportWarning(ttlAst,MAPRECORD_BODY_INVALID,mapFnBodyResult.toString());
      return getUnknownType();
    }
    ObjectType mapFnBodyAsObjType=((ObjectType)mapFnBodyResult);
    for (    String newPropName : mapFnBodyAsObjType.getOwnPropertyNames()) {
      JSType newPropValue=mapFnBodyAsObjType.getSlot(newPropName).getType();
      putNewPropInPropertyMap(newProps,newPropName,newPropValue);
    }
  }
  return createRecordType(new ImmutableMap.Builder<String,JSType>().putAll(newProps).build());
}",0.9204693611473272
27697,"private static void appendTypeNode(StringBuilder sb,Node typeNode){
  if (typeNode.getType() == Token.BANG) {
    sb.append(""String_Node_Str"");
    appendTypeNode(sb,typeNode.getFirstChild());
  }
 else   if (typeNode.getType() == Token.EQUALS) {
    appendTypeNode(sb,typeNode.getFirstChild());
    sb.append(""String_Node_Str"");
  }
 else   if (typeNode.getType() == Token.PIPE) {
    for (int i=0; i < typeNode.getChildCount() - 1; i++) {
      appendTypeNode(sb,typeNode.getChildAtIndex(i));
      sb.append(""String_Node_Str"");
    }
    appendTypeNode(sb,typeNode.getLastChild());
  }
 else   if (typeNode.getType() == Token.ELLIPSIS) {
    sb.append(""String_Node_Str"");
    appendTypeNode(sb,typeNode.getFirstChild());
  }
 else   if (typeNode.getType() == Token.STAR) {
    sb.append(""String_Node_Str"");
  }
 else   if (typeNode.getType() == Token.QMARK) {
    sb.append(""String_Node_Str"");
  }
 else   if (typeNode.isFunction()) {
    sb.append(""String_Node_Str"");
    Node paramList=typeNode.getFirstChild();
    if (paramList.isEmpty()) {
      sb.append(""String_Node_Str"");
    }
 else {
      for (int i=0; i < paramList.getChildCount() - 1; i++) {
        appendTypeNode(sb,paramList.getChildAtIndex(i));
        sb.append(""String_Node_Str"");
      }
      appendTypeNode(sb,paramList.getLastChild());
      sb.append(""String_Node_Str"");
    }
    Node returnType=typeNode.getLastChild();
    if (!returnType.isEmpty()) {
      sb.append(""String_Node_Str"");
      appendTypeNode(sb,returnType);
    }
  }
 else   if (typeNode.getType() == Token.LC) {
    sb.append(""String_Node_Str"");
    Node lb=typeNode.getFirstChild();
    for (int i=0; i < lb.getChildCount() - 1; i++) {
      Node colon=lb.getChildAtIndex(i);
      sb.append(colon.getFirstChild().getString() + ""String_Node_Str"");
      appendTypeNode(sb,colon.getLastChild());
      sb.append(""String_Node_Str"");
    }
    Node lastColon=lb.getLastChild();
    sb.append(lastColon.getFirstChild().getString() + ""String_Node_Str"");
    appendTypeNode(sb,lastColon.getLastChild());
    sb.append(""String_Node_Str"");
  }
 else {
    if (typeNode.getString().equals(""String_Node_Str"")) {
      sb.append(""String_Node_Str"");
      appendTypeNode(sb,typeNode.getFirstChild().getFirstChild());
      sb.append(""String_Node_Str"");
    }
 else {
      sb.append(typeNode.getString());
    }
  }
}","private static void appendTypeNode(StringBuilder sb,Node typeNode){
  if (typeNode.getType() == Token.BANG) {
    sb.append(""String_Node_Str"");
    appendTypeNode(sb,typeNode.getFirstChild());
  }
 else   if (typeNode.getType() == Token.EQUALS) {
    appendTypeNode(sb,typeNode.getFirstChild());
    sb.append(""String_Node_Str"");
  }
 else   if (typeNode.getType() == Token.PIPE) {
    for (int i=0; i < typeNode.getChildCount() - 1; i++) {
      appendTypeNode(sb,typeNode.getChildAtIndex(i));
      sb.append(""String_Node_Str"");
    }
    appendTypeNode(sb,typeNode.getLastChild());
  }
 else   if (typeNode.getType() == Token.ELLIPSIS) {
    sb.append(""String_Node_Str"");
    if (typeNode.hasChildren()) {
      boolean inFunction=typeNode.getParent() != null && typeNode.getParent().getParent() != null && typeNode.getParent().getParent().isFunction();
      if (inFunction) {
        sb.append(""String_Node_Str"");
      }
      appendTypeNode(sb,typeNode.getFirstChild());
      if (inFunction) {
        sb.append(""String_Node_Str"");
      }
    }
  }
 else   if (typeNode.getType() == Token.STAR) {
    sb.append(""String_Node_Str"");
  }
 else   if (typeNode.getType() == Token.QMARK) {
    sb.append(""String_Node_Str"");
  }
 else   if (typeNode.isFunction()) {
    sb.append(""String_Node_Str"");
    Node first=typeNode.getFirstChild();
    if (first.isNew()) {
      sb.append(""String_Node_Str"");
      appendTypeNode(sb,typeNode.getFirstChild().getFirstChild());
      sb.append(""String_Node_Str"");
    }
 else     if (first.isThis()) {
      sb.append(""String_Node_Str"");
      appendTypeNode(sb,typeNode.getFirstChild().getFirstChild());
      sb.append(""String_Node_Str"");
    }
 else     if (first.isEmpty()) {
      sb.append(""String_Node_Str"");
      return;
    }
 else     if (first.isVoid()) {
      sb.append(""String_Node_Str"");
      return;
    }
    Node paramList=typeNode.getFirstChild().isParamList() ? typeNode.getFirstChild() : typeNode.getChildAtIndex(1);
    for (int i=0; i < paramList.getChildCount() - 1; i++) {
      appendTypeNode(sb,paramList.getChildAtIndex(i));
      sb.append(""String_Node_Str"");
    }
    appendTypeNode(sb,paramList.getLastChild());
    sb.append(""String_Node_Str"");
    Node returnType=typeNode.getLastChild();
    if (!returnType.isEmpty()) {
      sb.append(""String_Node_Str"");
      appendTypeNode(sb,returnType);
    }
  }
 else   if (typeNode.getType() == Token.LC) {
    sb.append(""String_Node_Str"");
    Node lb=typeNode.getFirstChild();
    for (int i=0; i < lb.getChildCount() - 1; i++) {
      Node colon=lb.getChildAtIndex(i);
      sb.append(colon.getFirstChild().getString() + ""String_Node_Str"");
      appendTypeNode(sb,colon.getLastChild());
      sb.append(""String_Node_Str"");
    }
    Node lastColon=lb.getLastChild();
    sb.append(lastColon.getFirstChild().getString() + ""String_Node_Str"");
    appendTypeNode(sb,lastColon.getLastChild());
    sb.append(""String_Node_Str"");
  }
 else   if (typeNode.getType() == Token.VOID) {
    sb.append(""String_Node_Str"");
  }
 else {
    if (typeNode.getString().equals(""String_Node_Str"")) {
      if (typeNode.hasChildren()) {
        sb.append(""String_Node_Str"");
        appendTypeNode(sb,typeNode.getFirstChild().getFirstChild());
        sb.append(""String_Node_Str"");
      }
 else {
        sb.append(""String_Node_Str"");
      }
    }
 else {
      sb.append(typeNode.getString());
    }
  }
}",0.5129093744584994
27698,"public void testParam(){
  builder.recordParameter(""String_Node_Str"",new JSTypeExpression(IR.string(""String_Node_Str""),""String_Node_Str""));
  builder.recordParameter(""String_Node_Str"",new JSTypeExpression(IR.string(""String_Node_Str""),""String_Node_Str""));
  JSDocInfo info=builder.build(null);
  assertEquals(""String_Node_Str"",JSDocInfoPrinter.print(info));
}","public void testParam(){
  builder.recordParameter(""String_Node_Str"",new JSTypeExpression(JsDocInfoParser.parseTypeString(""String_Node_Str""),""String_Node_Str""));
  builder.recordParameter(""String_Node_Str"",new JSTypeExpression(JsDocInfoParser.parseTypeString(""String_Node_Str""),""String_Node_Str""));
  JSDocInfo info=builder.build(null);
  assertEquals(""String_Node_Str"",JSDocInfoPrinter.print(info));
  builder.recordParameter(""String_Node_Str"",new JSTypeExpression(new Node(Token.EQUALS,IR.string(""String_Node_Str"")),""String_Node_Str""));
  info=builder.build(null);
  assertEquals(""String_Node_Str"",JSDocInfoPrinter.print(info));
  builder.recordParameter(""String_Node_Str"",new JSTypeExpression(new Node(Token.ELLIPSIS,IR.string(""String_Node_Str"")),""String_Node_Str""));
  info=builder.build(null);
  assertEquals(""String_Node_Str"",JSDocInfoPrinter.print(info));
}",0.4157119476268412
27699,"public void testTypes(){
  builder.recordReturnType(new JSTypeExpression(IR.string(""String_Node_Str""),""String_Node_Str""));
  JSDocInfo info=builder.build(null);
  assertEquals(""String_Node_Str"",JSDocInfoPrinter.print(info));
  builder.recordThisType(new JSTypeExpression(IR.string(""String_Node_Str""),""String_Node_Str""));
  info=builder.build(null);
  assertEquals(""String_Node_Str"",JSDocInfoPrinter.print(info));
  builder.recordThrowType(new JSTypeExpression(IR.string(""String_Node_Str""),""String_Node_Str""));
  info=builder.build(null);
  assertEquals(""String_Node_Str"",JSDocInfoPrinter.print(info));
  builder.recordTypedef(new JSTypeExpression(IR.string(""String_Node_Str""),""String_Node_Str""));
  info=builder.build(null);
  assertEquals(""String_Node_Str"",JSDocInfoPrinter.print(info));
  builder.recordEnumParameterType(new JSTypeExpression(IR.string(""String_Node_Str""),""String_Node_Str""));
  info=builder.build(null);
  assertEquals(""String_Node_Str"",JSDocInfoPrinter.print(info));
  builder.recordType(new JSTypeExpression(IR.string(""String_Node_Str""),""String_Node_Str""));
  info=builder.build(null);
  assertEquals(""String_Node_Str"",JSDocInfoPrinter.print(info));
}","public void testTypes(){
  builder.recordReturnType(new JSTypeExpression(JsDocInfoParser.parseTypeString(""String_Node_Str""),""String_Node_Str""));
  JSDocInfo info=builder.build(null);
  assertEquals(""String_Node_Str"",JSDocInfoPrinter.print(info));
  builder.recordParameter(""String_Node_Str"",new JSTypeExpression(new Node(Token.ELLIPSIS,IR.string(""String_Node_Str"")),""String_Node_Str""));
  info=builder.build(null);
  assertEquals(""String_Node_Str"",JSDocInfoPrinter.print(info));
  builder.recordThrowType(new JSTypeExpression(new Node(Token.STAR),""String_Node_Str""));
  info=builder.build(null);
  assertEquals(""String_Node_Str"",JSDocInfoPrinter.print(info));
  builder.recordTypedef(new JSTypeExpression(new Node(Token.QMARK),""String_Node_Str""));
  info=builder.build(null);
  assertEquals(""String_Node_Str"",JSDocInfoPrinter.print(info));
  builder.recordType(new JSTypeExpression(new Node(Token.VOID),""String_Node_Str""));
  info=builder.build(null);
  assertEquals(""String_Node_Str"",JSDocInfoPrinter.print(info));
  builder.recordEnumParameterType(new JSTypeExpression(JsDocInfoParser.parseTypeString(""String_Node_Str""),""String_Node_Str""));
  info=builder.build(null);
  assertEquals(""String_Node_Str"",JSDocInfoPrinter.print(info));
  builder.recordType(new JSTypeExpression(JsDocInfoParser.parseTypeString(""String_Node_Str""),""String_Node_Str""));
  info=builder.build(null);
  assertEquals(""String_Node_Str"",JSDocInfoPrinter.print(info));
  builder.recordType(new JSTypeExpression(JsDocInfoParser.parseTypeString(""String_Node_Str""),""String_Node_Str""));
  builder.recordInlineType();
  info=builder.build(null);
  assertEquals(""String_Node_Str"",JSDocInfoPrinter.print(info));
  builder.recordType(new JSTypeExpression(JsDocInfoParser.parseTypeString(""String_Node_Str""),""String_Node_Str""));
  info=builder.build(null);
  assertEquals(""String_Node_Str"",JSDocInfoPrinter.print(info));
  builder.recordType(new JSTypeExpression(JsDocInfoParser.parseTypeString(""String_Node_Str""),""String_Node_Str""));
  info=builder.build(null);
  assertEquals(""String_Node_Str"",JSDocInfoPrinter.print(info));
  builder.recordType(new JSTypeExpression(JsDocInfoParser.parseTypeString(""String_Node_Str""),""String_Node_Str""));
  info=builder.build(null);
  assertEquals(""String_Node_Str"",JSDocInfoPrinter.print(info));
  builder.recordType(new JSTypeExpression(JsDocInfoParser.parseTypeString(""String_Node_Str""),""String_Node_Str""));
  info=builder.build(null);
  assertEquals(""String_Node_Str"",JSDocInfoPrinter.print(info));
  builder.recordType(new JSTypeExpression(JsDocInfoParser.parseTypeString(""String_Node_Str""),""String_Node_Str""));
  info=builder.build(null);
  assertEquals(""String_Node_Str"",JSDocInfoPrinter.print(info));
  builder.recordType(new JSTypeExpression(JsDocInfoParser.parseTypeString(""String_Node_Str""),""String_Node_Str""));
  info=builder.build(null);
  assertEquals(""String_Node_Str"",JSDocInfoPrinter.print(info));
  builder.recordType(new JSTypeExpression(JsDocInfoParser.parseTypeString(""String_Node_Str""),""String_Node_Str""));
  info=builder.build(null);
  assertEquals(""String_Node_Str"",JSDocInfoPrinter.print(info));
}",0.4959216965742251
27700,"private void visitArrayPattern(NodeTraversal t,Node arrayPattern,Node parent){
  Node rhs, nodeToDetach;
  if (NodeUtil.isNameDeclaration(parent)) {
    Preconditions.checkState(arrayPattern.getNext() == null);
    rhs=arrayPattern.getLastChild();
    nodeToDetach=parent;
  }
 else   if (parent.isAssign()) {
    rhs=arrayPattern.getNext();
    nodeToDetach=parent.getParent();
    Preconditions.checkState(nodeToDetach.isExprResult());
  }
 else   if (parent.isArrayPattern()) {
    return;
  }
 else {
    cannotConvertYet(arrayPattern,""String_Node_Str"" + Token.name(parent.getType()));
    return;
  }
  String tempVarName=DESTRUCTURING_TEMP_VAR + (destructuringVarCounter++);
  Node tempDecl=IR.var(IR.name(tempVarName),rhs.detachFromParent()).useSourceInfoFromForTree(arrayPattern);
  nodeToDetach.getParent().addChildBefore(tempDecl,nodeToDetach);
  int i=0;
  for (Node child=arrayPattern.getFirstChild(), next; child != null; child=next, i++) {
    next=child.getNext();
    if (child.isEmpty()) {
      continue;
    }
    Node newRHS=IR.getelem(IR.name(tempVarName),IR.number(i));
    Node newNode;
    if (parent.isAssign()) {
      Node assignment=IR.assign(child.detachFromParent(),newRHS);
      newNode=IR.exprResult(assignment);
    }
 else {
      newNode=IR.declaration(child.detachFromParent(),newRHS,parent.getType());
    }
    newNode.useSourceInfoFromForTree(arrayPattern);
    nodeToDetach.getParent().addChildBefore(newNode,nodeToDetach);
    visit(t,child,newNode);
  }
  nodeToDetach.detachFromParent();
  compiler.reportCodeChange();
}","private void visitArrayPattern(NodeTraversal t,Node arrayPattern,Node parent){
  Node rhs, nodeToDetach;
  if (NodeUtil.isNameDeclaration(parent)) {
    Preconditions.checkState(arrayPattern.getNext() == null);
    rhs=arrayPattern.getLastChild();
    nodeToDetach=parent;
  }
 else   if (parent.isAssign()) {
    rhs=arrayPattern.getNext();
    nodeToDetach=parent.getParent();
    Preconditions.checkState(nodeToDetach.isExprResult());
  }
 else   if (parent.isArrayPattern()) {
    return;
  }
 else {
    cannotConvertYet(arrayPattern,""String_Node_Str"" + Token.name(parent.getType()));
    return;
  }
  String tempVarName=DESTRUCTURING_TEMP_VAR + (destructuringVarCounter++);
  Node tempDecl=IR.var(IR.name(tempVarName),rhs.detachFromParent()).useSourceInfoFromForTree(arrayPattern);
  nodeToDetach.getParent().addChildBefore(tempDecl,nodeToDetach);
  int i=0;
  for (Node child=arrayPattern.getFirstChild(), next; child != null; child=next, i++) {
    next=child.getNext();
    if (child.isEmpty()) {
      continue;
    }
    Node newRHS=IR.getelem(IR.name(tempVarName),IR.number(i));
    Node newNode;
    if (parent.isAssign()) {
      Node assignment=IR.assign(child.detachFromParent(),newRHS);
      newNode=IR.exprResult(assignment);
    }
 else {
      newNode=IR.declaration(child.detachFromParent(),newRHS,parent.getType());
    }
    newNode.useSourceInfoFromForTree(arrayPattern);
    nodeToDetach.getParent().addChildBefore(newNode,nodeToDetach);
    visit(t,child,child.getParent());
  }
  nodeToDetach.detachFromParent();
  compiler.reportCodeChange();
}",0.9923518164435946
27701,"@Override public void process(Node externs,Node root){
  if (addExtern) {
    addExternForGlobalSymbolNamespace();
  }
  NodeTraversal.traverse(compiler,root,new RewriteGlobalFunctionStatementsToVarAssignmentsCallback());
  List<Callback> nonMutatingPasses=new ArrayList<>();
  nonMutatingPasses.add(new FindCrossModuleNamesCallback());
  nonMutatingPasses.add(new FindNamesReferencingThis());
  CombinedCompilerPass.traverse(compiler,root,nonMutatingPasses);
  NodeTraversal.traverse(compiler,root,new RewriteScopeCallback());
  NodeTraversal.traverse(compiler,root,new RemoveGlobalVarCallback());
  NodeTraversal.traverse(compiler,root,new MakeExternsReferenceWindowExplicitly());
}","@Override public void process(Node externs,Node root){
  if (addExtern) {
    addExternForGlobalSymbolNamespace();
  }
  NodeTraversal.traverse(compiler,root,new RewriteGlobalFunctionStatementsToVarAssignmentsCallback());
  List<Callback> nonMutatingPasses=new ArrayList<>();
  nonMutatingPasses.add(new FindCrossModuleNamesCallback());
  nonMutatingPasses.add(new FindNamesReferencingThis());
  CombinedCompilerPass.traverse(compiler,root,nonMutatingPasses);
  RewriteScopeCallback rewriteScope=new RewriteScopeCallback();
  NodeTraversal.traverse(compiler,root,rewriteScope);
  NodeTraversal.traverse(compiler,root,new RemoveGlobalVarCallback());
  rewriteScope.declareModuleGlobals();
  NodeTraversal.traverse(compiler,root,new MakeExternsReferenceWindowExplicitly());
}",0.8387096774193549
27702,"private void replaceSymbol(Node node,String name,CompilerInput input){
  Node parent=node.getParent();
  boolean isCrossModule=isCrossModuleName(name);
  if (!isCrossModule) {
    if (!parent.isVar()) {
      return;
    }
    boolean hasCrossModuleChildren=false;
    for (    Node c : parent.children()) {
      if (!c.isName() || isCrossModuleName(c.getString())) {
        hasCrossModuleChildren=true;
        break;
      }
    }
    if (!hasCrossModuleChildren) {
      return;
    }
  }
  Node replacement=isCrossModule ? IR.getprop(IR.name(globalSymbolNamespace).srcref(node),IR.string(name).srcref(node)) : IR.name(name).srcref(node);
  replacement.srcref(node);
  if (node.hasChildren()) {
    Node assign=IR.assign(replacement,node.removeFirstChild());
    parent.replaceChild(node,assign);
  }
 else   if (isCrossModule) {
    parent.replaceChild(node,replacement);
    if (parent.isCall() && !maybeReferencesThis.contains(name)) {
      parent.putBooleanProp(Node.FREE_CALL,false);
    }
  }
  if (!isCrossModule && parent.isVar()) {
    input.getAstRoot(compiler).addChildToFront(IR.var(IR.name(name).srcref(node)).srcref(node));
  }
  compiler.reportCodeChange();
}","private void replaceSymbol(Node node,String name,CompilerInput input){
  Node parent=node.getParent();
  boolean isCrossModule=isCrossModuleName(name);
  if (!isCrossModule) {
    if (!parent.isVar()) {
      return;
    }
    boolean hasCrossModuleChildren=false;
    for (    Node c : parent.children()) {
      if (!c.isName() || isCrossModuleName(c.getString())) {
        hasCrossModuleChildren=true;
        break;
      }
    }
    if (!hasCrossModuleChildren) {
      return;
    }
  }
  Node replacement=isCrossModule ? IR.getprop(IR.name(globalSymbolNamespace).srcref(node),IR.string(name).srcref(node)) : IR.name(name).srcref(node);
  replacement.srcref(node);
  if (node.hasChildren()) {
    Node assign=IR.assign(replacement,node.removeFirstChild());
    parent.replaceChild(node,assign);
  }
 else   if (isCrossModule) {
    parent.replaceChild(node,replacement);
    if (parent.isCall() && !maybeReferencesThis.contains(name)) {
      parent.putBooleanProp(Node.FREE_CALL,false);
    }
  }
  if (!isCrossModule && parent.isVar()) {
    preDeclarations.add(new ModuleGlobal(input.getAstRoot(compiler),IR.name(name).srcref(node)));
  }
  compiler.reportCodeChange();
}",0.9487505294366794
27703,"public void testVarDeclarations_acrossModules(){
  assumeCrossModuleNames=false;
  test(createModules(""String_Node_Str"",""String_Node_Str""),new String[]{""String_Node_Str"",""String_Node_Str""});
  test(createModules(""String_Node_Str"",""String_Node_Str""),new String[]{""String_Node_Str"",""String_Node_Str""});
  test(createModules(""String_Node_Str"",""String_Node_Str""),new String[]{""String_Node_Str"",""String_Node_Str""});
  test(createModules(""String_Node_Str"",""String_Node_Str""),new String[]{""String_Node_Str"",""String_Node_Str""});
  test(createModules(""String_Node_Str"",""String_Node_Str""),new String[]{""String_Node_Str"",""String_Node_Str""});
}","public void testVarDeclarations_acrossModules(){
  assumeCrossModuleNames=false;
  test(createModules(""String_Node_Str"",""String_Node_Str""),new String[]{""String_Node_Str"",""String_Node_Str""});
  test(createModules(""String_Node_Str"",""String_Node_Str""),new String[]{""String_Node_Str"",""String_Node_Str""});
  test(createModules(""String_Node_Str"",""String_Node_Str""),new String[]{""String_Node_Str"",""String_Node_Str""});
  test(createModules(""String_Node_Str"",""String_Node_Str""),new String[]{""String_Node_Str"",""String_Node_Str""});
  test(createModules(""String_Node_Str"",""String_Node_Str""),new String[]{""String_Node_Str"",""String_Node_Str""});
  test(createModules(""String_Node_Str"",""String_Node_Str""),new String[]{""String_Node_Str"",""String_Node_Str""});
  test(createModules(""String_Node_Str"",""String_Node_Str""),new String[]{""String_Node_Str"",""String_Node_Str""});
  test(createModules(""String_Node_Str"",""String_Node_Str""),new String[]{""String_Node_Str"",""String_Node_Str""});
  test(createModules(""String_Node_Str"",""String_Node_Str""),new String[]{""String_Node_Str"",""String_Node_Str""});
}",0.7417840375586855
27704,"private void resolveTypedefs(JSTypeCreatorFromJSDoc typeParser){
  for (  Map.Entry<String,Typedef> entry : localTypedefs.entrySet()) {
    String name=entry.getKey();
    Typedef td=entry.getValue();
    if (!td.isResolved()) {
      typeParser.resolveTypedef(name,this);
    }
  }
}","private void resolveTypedefs(JSTypeCreatorFromJSDoc typeParser){
  for (  Typedef td : localTypedefs.values()) {
    if (!td.isResolved()) {
      typeParser.resolveTypedef(td,this);
    }
  }
}",0.7782426778242678
27705,"private void addEnum(Node qnameNode,EnumType e){
  if (qnameNode.isName()) {
    Preconditions.checkState(!localEnums.containsKey(qnameNode.getString()));
    localEnums.put(qnameNode.getString(),e);
  }
 else {
    Preconditions.checkState(!isDefined(qnameNode));
    QualifiedName qname=QualifiedName.fromGetprop(qnameNode);
    Namespace ns=getNamespace(qname.getLeftmostName());
    ns.addEnum(qname.getAllButLeftmost(),e);
  }
}","private void addEnum(Node qnameNode,EnumType e){
  if (qnameNode.isName()) {
    Preconditions.checkState(!localEnums.containsKey(qnameNode.getString()));
    localEnums.put(qnameNode.getString(),e);
  }
 else {
    Preconditions.checkState(!isDefined(qnameNode));
    QualifiedName qname=QualifiedName.fromGetprop(qnameNode);
    Namespace ns=getNamespace(qname.getLeftmostName());
    ns.addEnum(qname.getAllButLeftmost(),e);
    qualifiedEnums.add(e);
  }
}",0.96976483762598
27706,"private void removeTmpData(){
  Iterator<String> it=localFunDefs.keySet().iterator();
  while (it.hasNext()) {
    String name=it.next();
    if (name.contains(""String_Node_Str"")) {
      it.remove();
    }
  }
  for (  Map.Entry<String,NamespaceLit> entry : localNamespaces.entrySet()) {
    locals.put(entry.getKey(),entry.getValue().toJSType());
  }
  localNamespaces=null;
  localClassDefs=null;
  localTypedefs=null;
}","private void removeTmpData(){
  Iterator<String> it=localFunDefs.keySet().iterator();
  while (it.hasNext()) {
    String name=it.next();
    if (name.contains(""String_Node_Str"")) {
      it.remove();
    }
  }
  for (  Map.Entry<String,NamespaceLit> entry : localNamespaces.entrySet()) {
    locals.put(entry.getKey(),entry.getValue().toJSType());
  }
  for (  Map.Entry<String,EnumType> entry : localEnums.entrySet()) {
    locals.put(entry.getKey(),entry.getValue().toJSType());
  }
  localNamespaces=null;
  localClassDefs=null;
  localTypedefs=null;
  localEnums=null;
}",0.8476953907815631
27707,"private void resolveEnums(JSTypeCreatorFromJSDoc typeParser){
  for (  Map.Entry<String,EnumType> entry : localEnums.entrySet()) {
    String name=entry.getKey();
    EnumType e=entry.getValue();
    if (!e.isResolved()) {
      typeParser.resolveEnum(name,this);
    }
    locals.put(name,e.getObjLitType());
  }
}","private void resolveEnums(JSTypeCreatorFromJSDoc typeParser){
  for (  EnumType e : localEnums.values()) {
    if (!e.isResolved()) {
      typeParser.resolveEnum(e,this);
    }
  }
  for (  EnumType e : qualifiedEnums) {
    if (!e.isResolved()) {
      typeParser.resolveEnum(e,this);
    }
  }
  qualifiedEnums=null;
}",0.270440251572327
27708,"private EnvTypePair analyzeAssignFwd(Node expr,TypeEnv inEnv,JSType requiredType,JSType specializedType){
  mayWarnAboutConst(expr);
  Node lhs=expr.getFirstChild();
  Node rhs=expr.getLastChild();
  LValueResultFwd lvalue=analyzeLValueFwd(lhs,inEnv,requiredType);
  JSType declType=lvalue.declType;
  EnvTypePair rhsPair=analyzeExprFwd(rhs,lvalue.env,requiredType,specializedType);
  if (declType != null && !rhsPair.type.isSubtypeOf(declType)) {
    warnings.add(JSError.make(expr,MISTYPED_ASSIGN_RHS,declType.toString(),rhsPair.type.toString()));
  }
 else {
    rhsPair.env=updateLvalueTypeInEnv(rhsPair.env,lhs,lvalue.ptr,rhsPair.type);
  }
  return rhsPair;
}","private EnvTypePair analyzeAssignFwd(Node expr,TypeEnv inEnv,JSType requiredType,JSType specializedType){
  mayWarnAboutConst(expr);
  Node lhs=expr.getFirstChild();
  Node rhs=expr.getLastChild();
  LValueResultFwd lvalue=analyzeLValueFwd(lhs,inEnv,requiredType);
  JSType declType=lvalue.declType;
  if (NodeUtil.isEnumDecl(expr) && rhs.isObjectLit()) {
    return analyzeEnumObjLitFwd(rhs,lvalue.env,lvalue.type);
  }
  EnvTypePair rhsPair=analyzeExprFwd(rhs,lvalue.env,requiredType,specializedType);
  if (declType != null && !rhsPair.type.isSubtypeOf(declType)) {
    warnings.add(JSError.make(expr,MISTYPED_ASSIGN_RHS,declType.toString(),rhsPair.type.toString()));
  }
 else {
    rhsPair.env=updateLvalueTypeInEnv(rhsPair.env,lhs,lvalue.ptr,rhsPair.type);
  }
  return rhsPair;
}",0.9166092350103378
27709,"private EnvTypePair analyzeObjLitFwd(Node objLit,TypeEnv inEnv,JSType requiredType,JSType specializedType){
  if (NodeUtil.isEnumDecl(objLit.getParent().getParent())) {
    return analyzeEnumObjLitFwd(objLit,inEnv,requiredType);
  }
  JSDocInfo jsdoc=objLit.getJSDocInfo();
  boolean isStruct=jsdoc != null && jsdoc.makesStructs();
  boolean isDict=jsdoc != null && jsdoc.makesDicts();
  TypeEnv env=inEnv;
  JSType result=pickReqObjType(objLit);
  for (  Node prop : objLit.children()) {
    if (isStruct && prop.isQuotedString()) {
      warnings.add(JSError.make(prop,TypeCheck.ILLEGAL_OBJLIT_KEY,""String_Node_Str""));
    }
 else     if (isDict && !prop.isQuotedString()) {
      warnings.add(JSError.make(prop,TypeCheck.ILLEGAL_OBJLIT_KEY,""String_Node_Str""));
    }
    String pname=NodeUtil.getObjectLitKeyName(prop);
    if (prop.isGetterDef() || prop.isSetterDef()) {
      EnvTypePair pair=analyzeExprFwd(prop.getFirstChild(),env);
      FunctionType funType=pair.type.getFunType();
      Preconditions.checkNotNull(funType);
      String specialPropName;
      JSType propType;
      if (prop.isGetterDef()) {
        specialPropName=GETTER_PREFIX + pname;
        propType=funType.getReturnType();
      }
 else {
        specialPropName=SETTER_PREFIX + pname;
        propType=pair.type;
      }
      result=result.withProperty(new QualifiedName(specialPropName),propType);
      env=pair.env;
    }
 else {
      QualifiedName qname=new QualifiedName(pname);
      JSType jsdocType=symbolTable.getPropDeclaredType(prop);
      JSType reqPtype, specPtype;
      if (jsdocType != null) {
        reqPtype=specPtype=jsdocType;
      }
 else       if (requiredType.mayHaveProp(qname)) {
        reqPtype=specPtype=requiredType.getProp(qname);
        if (specializedType.mayHaveProp(qname)) {
          specPtype=specializedType.getProp(qname);
        }
      }
 else {
        reqPtype=specPtype=JSType.UNKNOWN;
      }
      EnvTypePair pair=analyzeExprFwd(prop.getFirstChild(),env,reqPtype,specPtype);
      if (jsdocType != null) {
        result=result.withDeclaredProperty(qname,jsdocType,false);
        if (!pair.type.isSubtypeOf(jsdocType)) {
          warnings.add(JSError.make(prop,INVALID_OBJLIT_PROPERTY_TYPE,jsdocType.toString(),pair.type.toString()));
          pair.type=jsdocType;
        }
      }
      result=result.withProperty(qname,pair.type);
      env=pair.env;
    }
  }
  return new EnvTypePair(env,result);
}","private EnvTypePair analyzeObjLitFwd(Node objLit,TypeEnv inEnv,JSType requiredType,JSType specializedType){
  if (NodeUtil.isEnumDecl(objLit.getParent())) {
    return analyzeEnumObjLitFwd(objLit,inEnv,requiredType);
  }
  JSDocInfo jsdoc=objLit.getJSDocInfo();
  boolean isStruct=jsdoc != null && jsdoc.makesStructs();
  boolean isDict=jsdoc != null && jsdoc.makesDicts();
  TypeEnv env=inEnv;
  JSType result=pickReqObjType(objLit);
  for (  Node prop : objLit.children()) {
    if (isStruct && prop.isQuotedString()) {
      warnings.add(JSError.make(prop,TypeCheck.ILLEGAL_OBJLIT_KEY,""String_Node_Str""));
    }
 else     if (isDict && !prop.isQuotedString()) {
      warnings.add(JSError.make(prop,TypeCheck.ILLEGAL_OBJLIT_KEY,""String_Node_Str""));
    }
    String pname=NodeUtil.getObjectLitKeyName(prop);
    if (prop.isGetterDef() || prop.isSetterDef()) {
      EnvTypePair pair=analyzeExprFwd(prop.getFirstChild(),env);
      FunctionType funType=pair.type.getFunType();
      Preconditions.checkNotNull(funType);
      String specialPropName;
      JSType propType;
      if (prop.isGetterDef()) {
        specialPropName=GETTER_PREFIX + pname;
        propType=funType.getReturnType();
      }
 else {
        specialPropName=SETTER_PREFIX + pname;
        propType=pair.type;
      }
      result=result.withProperty(new QualifiedName(specialPropName),propType);
      env=pair.env;
    }
 else {
      QualifiedName qname=new QualifiedName(pname);
      JSType jsdocType=symbolTable.getPropDeclaredType(prop);
      JSType reqPtype, specPtype;
      if (jsdocType != null) {
        reqPtype=specPtype=jsdocType;
      }
 else       if (requiredType.mayHaveProp(qname)) {
        reqPtype=specPtype=requiredType.getProp(qname);
        if (specializedType.mayHaveProp(qname)) {
          specPtype=specializedType.getProp(qname);
        }
      }
 else {
        reqPtype=specPtype=JSType.UNKNOWN;
      }
      EnvTypePair pair=analyzeExprFwd(prop.getFirstChild(),env,reqPtype,specPtype);
      if (jsdocType != null) {
        result=result.withDeclaredProperty(qname,jsdocType,false);
        if (!pair.type.isSubtypeOf(jsdocType)) {
          warnings.add(JSError.make(prop,INVALID_OBJLIT_PROPERTY_TYPE,jsdocType.toString(),pair.type.toString()));
          pair.type=jsdocType;
        }
      }
      result=result.withProperty(qname,pair.type);
      env=pair.env;
    }
  }
  return new EnvTypePair(env,result);
}",0.9975409836065574
27710,"private EnvTypePair analyzeObjLitBwd(Node objLit,TypeEnv outEnv,JSType requiredType){
  if (NodeUtil.isEnumDecl(objLit.getParent().getParent())) {
    return analyzeEnumObjLitBwd(objLit,outEnv,requiredType);
  }
  TypeEnv env=outEnv;
  JSType result=pickReqObjType(objLit);
  for (Node prop=objLit.getLastChild(); prop != null; prop=objLit.getChildBefore(prop)) {
    QualifiedName pname=new QualifiedName(NodeUtil.getObjectLitKeyName(prop));
    if (prop.isGetterDef() || prop.isSetterDef()) {
      env=analyzeExprBwd(prop.getFirstChild(),env).env;
    }
 else {
      JSType jsdocType=symbolTable.getPropDeclaredType(prop);
      JSType reqPtype;
      if (jsdocType != null) {
        reqPtype=jsdocType;
      }
 else       if (requiredType.mayHaveProp(pname)) {
        reqPtype=requiredType.getProp(pname);
      }
 else {
        reqPtype=JSType.UNKNOWN;
      }
      EnvTypePair pair=analyzeExprBwd(prop.getFirstChild(),env,reqPtype);
      result=result.withProperty(pname,pair.type);
      env=pair.env;
    }
  }
  return new EnvTypePair(env,result);
}","private EnvTypePair analyzeObjLitBwd(Node objLit,TypeEnv outEnv,JSType requiredType){
  if (NodeUtil.isEnumDecl(objLit.getParent())) {
    return analyzeEnumObjLitBwd(objLit,outEnv,requiredType);
  }
  TypeEnv env=outEnv;
  JSType result=pickReqObjType(objLit);
  for (Node prop=objLit.getLastChild(); prop != null; prop=objLit.getChildBefore(prop)) {
    QualifiedName pname=new QualifiedName(NodeUtil.getObjectLitKeyName(prop));
    if (prop.isGetterDef() || prop.isSetterDef()) {
      env=analyzeExprBwd(prop.getFirstChild(),env).env;
    }
 else {
      JSType jsdocType=symbolTable.getPropDeclaredType(prop);
      JSType reqPtype;
      if (jsdocType != null) {
        reqPtype=jsdocType;
      }
 else       if (requiredType.mayHaveProp(pname)) {
        reqPtype=requiredType.getProp(pname);
      }
 else {
        reqPtype=JSType.UNKNOWN;
      }
      EnvTypePair pair=analyzeExprBwd(prop.getFirstChild(),env,reqPtype);
      result=result.withProperty(pname,pair.type);
      env=pair.env;
    }
  }
  return new EnvTypePair(env,result);
}",0.9943342776203966
27711,"static boolean isEnumDecl(Node n){
  if (n.isVar() || n.isName() && n.getParent().isVar() || (n.isGetProp() && n.getParent().isAssign() && n.getParent().getParent().isExprResult())) {
    JSDocInfo jsdoc=getBestJSDocInfo(n);
    return jsdoc != null && jsdoc.hasEnumParameterType();
  }
  return false;
}","static boolean isEnumDecl(Node n){
  if (n.isVar() || n.isName() && n.getParent().isVar() || (n.isGetProp() && n.getParent().isAssign() && n.getParent().getParent().isExprResult()) || (n.isAssign() && n.getParent().isExprResult())) {
    JSDocInfo jsdoc=getBestJSDocInfo(n);
    return jsdoc != null && jsdoc.hasEnumParameterType();
  }
  return false;
}",0.9240121580547112
27712,"public JSType toJSType(){
  return enumObjType;
}","public JSType toJSType(){
  Preconditions.checkState(state == State.RESOLVED);
  if (enumObjType == null) {
    enumObjType=computeObjType();
  }
  return enumObjType;
}",0.4495412844036697
27713,"void resolveEnum(JSType t){
  Preconditions.checkNotNull(t);
  if (state == State.RESOLVED) {
    return;
  }
  Preconditions.checkState(state == State.DURING_RESOLUTION,""String_Node_Str"",state.toString());
  state=State.RESOLVED;
  typeExpr=null;
  declaredType=t;
  enumPropType=JSType.fromEnum(this);
  enumObjType=computeObjType();
}","void resolveEnum(JSType t){
  Preconditions.checkNotNull(t);
  if (state == State.RESOLVED) {
    return;
  }
  Preconditions.checkState(state == State.DURING_RESOLUTION,""String_Node_Str"",state.toString());
  state=State.RESOLVED;
  typeExpr=null;
  declaredType=t;
  enumPropType=JSType.fromEnum(this);
}",0.9501557632398754
27714,"public void resolveEnum(String name,DeclaredTypeRegistry registry){
  EnumType e=registry.getEnum(name);
  Preconditions.checkState(e != null,""String_Node_Str"" + ""String_Node_Str"");
  if (e.isResolved()) {
    return;
  }
  JSTypeExpression texp=e.getTypeExpr();
  JSType enumeratedType;
  if (texp == null) {
    warn(""String_Node_Str"",e.getTypeExprForErrorReporting().getRootNode());
    enumeratedType=JSType.UNKNOWN;
  }
 else {
    int numTypeVars=howmanyTypeVars;
    enumeratedType=getTypeFromJSTypeExpression(texp,null,registry,null);
    if (howmanyTypeVars > numTypeVars) {
      warn(""String_Node_Str"",texp.getRootNode());
      enumeratedType=JSType.UNKNOWN;
      howmanyTypeVars=numTypeVars;
    }
 else     if (enumeratedType.isTop()) {
      warn(""String_Node_Str"" + ""String_Node_Str"",texp.getRootNode());
      enumeratedType=JSType.UNKNOWN;
    }
 else     if (enumeratedType.isUnion()) {
      warn(""String_Node_Str"",texp.getRootNode());
      enumeratedType=JSType.UNKNOWN;
    }
  }
  e.resolveEnum(enumeratedType);
}","public void resolveEnum(EnumType e,DeclaredTypeRegistry registry){
  Preconditions.checkState(e != null,""String_Node_Str"" + ""String_Node_Str"");
  if (e.isResolved()) {
    return;
  }
  JSTypeExpression texp=e.getTypeExpr();
  JSType enumeratedType;
  if (texp == null) {
    warn(""String_Node_Str"",e.getTypeExprForErrorReporting().getRootNode());
    enumeratedType=JSType.UNKNOWN;
  }
 else {
    int numTypeVars=howmanyTypeVars;
    enumeratedType=getTypeFromJSTypeExpression(texp,null,registry,null);
    if (howmanyTypeVars > numTypeVars) {
      warn(""String_Node_Str"",texp.getRootNode());
      enumeratedType=JSType.UNKNOWN;
      howmanyTypeVars=numTypeVars;
    }
 else     if (enumeratedType.isTop()) {
      warn(""String_Node_Str"" + ""String_Node_Str"",texp.getRootNode());
      enumeratedType=JSType.UNKNOWN;
    }
 else     if (enumeratedType.isUnion()) {
      warn(""String_Node_Str"",texp.getRootNode());
      enumeratedType=JSType.UNKNOWN;
    }
  }
  e.resolveEnum(enumeratedType);
}",0.97252208047105
27715,"public void resolveTypedef(String name,DeclaredTypeRegistry registry){
  Typedef td=registry.getTypedef(name);
  Preconditions.checkState(td != null,""String_Node_Str"" + ""String_Node_Str"");
  if (td.isResolved()) {
    return;
  }
  JSTypeExpression texp=td.getTypeExpr();
  JSType tdType;
  if (texp == null) {
    warn(""String_Node_Str"",td.getTypeExprForErrorReporting().getRootNode());
    tdType=JSType.UNKNOWN;
  }
 else {
    tdType=getTypeFromJSTypeExpression(texp,null,registry,null);
  }
  td.resolveTypedef(tdType);
}","public void resolveTypedef(Typedef td,DeclaredTypeRegistry registry){
  Preconditions.checkState(td != null,""String_Node_Str"" + ""String_Node_Str"");
  if (td.isResolved()) {
    return;
  }
  JSTypeExpression texp=td.getTypeExpr();
  JSType tdType;
  if (texp == null) {
    warn(""String_Node_Str"",td.getTypeExprForErrorReporting().getRootNode());
    tdType=JSType.UNKNOWN;
  }
 else {
    tdType=getTypeFromJSTypeExpression(texp,null,registry,null);
  }
  td.resolveTypedef(tdType);
}",0.9297725024727992
27716,"private JSType getTypedefType(String name,DeclaredTypeRegistry registry){
  resolveTypedef(name,registry);
  return registry.getTypedef(name).getType();
}","private JSType getTypedefType(Typedef td,DeclaredTypeRegistry registry){
  resolveTypedef(td,registry);
  return td.getType();
}",0.8297872340425532
27717,"private JSType getEnumPropType(String name,DeclaredTypeRegistry registry){
  resolveEnum(name,registry);
  return registry.getEnum(name).getPropType();
}","private JSType getEnumPropType(EnumType e,DeclaredTypeRegistry registry){
  resolveEnum(e,registry);
  return e.getPropType();
}",0.8612099644128114
27718,"private JSType getNamedTypeHelper(Node n,RawNominalType ownerType,DeclaredTypeRegistry registry,ImmutableList<String> outerTypeParameters) throws UnknownTypeException {
  String typeName=n.getString();
switch (typeName) {
case ""String_Node_Str"":
    return JSType.BOOLEAN;
case ""String_Node_Str"":
  return JSType.NULL;
case ""String_Node_Str"":
return JSType.NUMBER;
case ""String_Node_Str"":
return JSType.STRING;
case ""String_Node_Str"":
case ""String_Node_Str"":
return JSType.UNDEFINED;
case ""String_Node_Str"":
return UNKNOWN_FUNCTION_OR_NULL;
case ""String_Node_Str"":
return OBJECT_OR_NULL;
default :
{
if (hasTypeVariable(outerTypeParameters,ownerType,typeName)) {
return JSType.fromTypeVar(typeName);
}
 else {
if (registry.getTypedef(typeName) != null) {
return getTypedefType(typeName,registry);
}
if (registry.getEnum(typeName) != null) {
return getEnumPropType(typeName,registry);
}
JSType namedType=registry.lookupTypeByName(typeName);
if (namedType == null) {
unknownTypeNames.put(n,typeName);
throw new UnknownTypeException(""String_Node_Str"" + typeName);
}
if (namedType.isTypeVariable()) {
howmanyTypeVars++;
return namedType;
}
return getNominalTypeHelper(namedType,n,ownerType,registry,outerTypeParameters);
}
}
}
}","private JSType getNamedTypeHelper(Node n,RawNominalType ownerType,DeclaredTypeRegistry registry,ImmutableList<String> outerTypeParameters) throws UnknownTypeException {
  String typeName=n.getString();
switch (typeName) {
case ""String_Node_Str"":
    return JSType.BOOLEAN;
case ""String_Node_Str"":
  return JSType.NULL;
case ""String_Node_Str"":
return JSType.NUMBER;
case ""String_Node_Str"":
return JSType.STRING;
case ""String_Node_Str"":
case ""String_Node_Str"":
return JSType.UNDEFINED;
case ""String_Node_Str"":
return UNKNOWN_FUNCTION_OR_NULL;
case ""String_Node_Str"":
return OBJECT_OR_NULL;
default :
{
if (hasTypeVariable(outerTypeParameters,ownerType,typeName)) {
return JSType.fromTypeVar(typeName);
}
 else {
Typedef td=registry.getTypedef(typeName);
if (td != null) {
return getTypedefType(td,registry);
}
EnumType e=registry.getEnum(typeName);
if (e != null) {
return getEnumPropType(e,registry);
}
JSType namedType=registry.lookupTypeByName(typeName);
if (namedType == null) {
unknownTypeNames.put(n,typeName);
throw new UnknownTypeException(""String_Node_Str"" + typeName);
}
if (namedType.isTypeVariable()) {
howmanyTypeVars++;
return namedType;
}
return getNominalTypeHelper(namedType,n,ownerType,registry,outerTypeParameters);
}
}
}
}",0.9594155844155844
27719,"private void visitExport(NodeTraversal t,Node n,Node parent){
  if (n.getBooleanProp(Node.EXPORT_DEFAULT)) {
    compiler.report(JSError.make(n,Es6ToEs3Converter.CANNOT_CONVERT_YET,""String_Node_Str""));
  }
 else   if (n.getBooleanProp(Node.EXPORT_ALL_FROM)) {
    compiler.report(JSError.make(n,Es6ToEs3Converter.CANNOT_CONVERT_YET,""String_Node_Str""));
  }
 else {
    if (n.getChildCount() == 2) {
      compiler.report(JSError.make(n,Es6ToEs3Converter.CANNOT_CONVERT_YET,""String_Node_Str""));
      return;
    }
    if (n.getFirstChild().getType() == Token.EXPORT_SPECS) {
      for (      Node grandChild : n.getFirstChild().children()) {
        Node origName=grandChild.getFirstChild();
        exportMap.put(grandChild.getChildCount() == 2 ? grandChild.getLastChild().getString() : origName.getString(),origName.getString());
      }
      parent.removeChild(n);
    }
 else {
      String name=n.getFirstChild().getFirstChild().getString();
      Var v=t.getScope().getVar(name);
      if (v == null || v.isGlobal()) {
        exportMap.put(name,name);
      }
      parent.replaceChild(n,n.removeFirstChild());
    }
    compiler.reportCodeChange();
  }
}","private void visitExport(NodeTraversal t,Node n,Node parent){
  if (n.getBooleanProp(Node.EXPORT_DEFAULT)) {
    compiler.report(JSError.make(n,Es6ToEs3Converter.CANNOT_CONVERT_YET,""String_Node_Str""));
  }
 else   if (n.getBooleanProp(Node.EXPORT_ALL_FROM)) {
    compiler.report(JSError.make(n,Es6ToEs3Converter.CANNOT_CONVERT_YET,""String_Node_Str""));
  }
 else {
    if (n.getChildCount() == 2) {
      compiler.report(JSError.make(n,Es6ToEs3Converter.CANNOT_CONVERT_YET,""String_Node_Str""));
      return;
    }
    if (n.getFirstChild().getType() == Token.EXPORT_SPECS) {
      for (      Node grandChild : n.getFirstChild().children()) {
        Node origName=grandChild.getFirstChild();
        exportMap.put(grandChild.getChildCount() == 2 ? grandChild.getLastChild().getString() : origName.getString(),origName.getString());
      }
      parent.removeChild(n);
    }
 else {
      for (      Node grandChild : n.getFirstChild().children()) {
        if (!grandChild.isName()) {
          break;
        }
        String name=grandChild.getString();
        Var v=t.getScope().getVar(name);
        if (v == null || v.isGlobal()) {
          exportMap.put(name,name);
        }
      }
      parent.replaceChild(n,n.removeFirstChild());
    }
    compiler.reportCodeChange();
  }
}",0.9220726234190126
27720,"public void testExport(){
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
}","public void testExport(){
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
}",0.7222222222222222
27721,"@Override public void visit(NodeTraversal t,Node n,Node parent){
switch (n.getType()) {
case Token.LABEL:
    tryMinimizeExits(n.getLastChild(),Token.BREAK,n.getFirstChild().getString());
  break;
case Token.FOR:
case Token.WHILE:
tryMinimizeExits(NodeUtil.getLoopCodeBlock(n),Token.CONTINUE,null);
break;
case Token.DO:
tryMinimizeExits(NodeUtil.getLoopCodeBlock(n),Token.CONTINUE,null);
Node cond=NodeUtil.getConditionExpression(n);
if (NodeUtil.getImpureBooleanValue(cond) == TernaryValue.FALSE) {
tryMinimizeExits(n.getFirstChild(),Token.BREAK,null);
}
break;
case Token.FUNCTION:
tryMinimizeExits(n.getLastChild(),Token.RETURN,null);
break;
}
}","@Override public void visit(NodeTraversal t,Node n,Node parent){
switch (n.getType()) {
case Token.LABEL:
    tryMinimizeExits(n.getLastChild(),Token.BREAK,n.getFirstChild().getString());
  break;
case Token.FOR:
case Token.WHILE:
tryMinimizeExits(NodeUtil.getLoopCodeBlock(n),Token.CONTINUE,null);
break;
case Token.DO:
tryMinimizeExits(NodeUtil.getLoopCodeBlock(n),Token.CONTINUE,null);
Node cond=NodeUtil.getConditionExpression(n);
if (NodeUtil.getPureBooleanValue(cond) == TernaryValue.FALSE) {
tryMinimizeExits(n.getFirstChild(),Token.BREAK,null);
}
break;
case Token.FUNCTION:
tryMinimizeExits(n.getLastChild(),Token.RETURN,null);
break;
}
}",0.9969135802469136
27722,"/** 
 * Gets the boolean value of a node that represents a expression. This method effectively emulates the <code>Boolean()</code> JavaScript cast function. Note: unlike getBooleanValue this function does not return UNKNOWN for expressions with side-effects.
 */
static TernaryValue getImpureBooleanValue(Node n){
switch (n.getType()) {
case Token.ASSIGN:
case Token.COMMA:
    return getImpureBooleanValue(n.getLastChild());
case Token.NOT:
  TernaryValue value=getImpureBooleanValue(n.getLastChild());
return value.not();
case Token.AND:
{
TernaryValue lhs=getImpureBooleanValue(n.getFirstChild());
TernaryValue rhs=getImpureBooleanValue(n.getLastChild());
return lhs.and(rhs);
}
case Token.OR:
{
TernaryValue lhs=getImpureBooleanValue(n.getFirstChild());
TernaryValue rhs=getImpureBooleanValue(n.getLastChild());
return lhs.or(rhs);
}
case Token.HOOK:
{
TernaryValue trueValue=getImpureBooleanValue(n.getFirstChild().getNext());
TernaryValue falseValue=getImpureBooleanValue(n.getLastChild());
if (trueValue.equals(falseValue)) {
return trueValue;
}
 else {
return TernaryValue.UNKNOWN;
}
}
case Token.ARRAYLIT:
case Token.OBJECTLIT:
return TernaryValue.TRUE;
case Token.VOID:
return TernaryValue.FALSE;
default :
return getPureBooleanValue(n);
}
}","/** 
 * Gets the boolean value of a node that represents a expression. This method effectively emulates the <code>Boolean()</code> JavaScript cast function. Note: unlike getPureBooleanValue this function does not return UNKNOWN for expressions with side-effects.
 */
static TernaryValue getImpureBooleanValue(Node n){
switch (n.getType()) {
case Token.ASSIGN:
case Token.COMMA:
    return getImpureBooleanValue(n.getLastChild());
case Token.NOT:
  TernaryValue value=getImpureBooleanValue(n.getLastChild());
return value.not();
case Token.AND:
{
TernaryValue lhs=getImpureBooleanValue(n.getFirstChild());
TernaryValue rhs=getImpureBooleanValue(n.getLastChild());
return lhs.and(rhs);
}
case Token.OR:
{
TernaryValue lhs=getImpureBooleanValue(n.getFirstChild());
TernaryValue rhs=getImpureBooleanValue(n.getLastChild());
return lhs.or(rhs);
}
case Token.HOOK:
{
TernaryValue trueValue=getImpureBooleanValue(n.getFirstChild().getNext());
TernaryValue falseValue=getImpureBooleanValue(n.getLastChild());
if (trueValue.equals(falseValue)) {
return trueValue;
}
 else {
return TernaryValue.UNKNOWN;
}
}
case Token.ARRAYLIT:
case Token.OBJECTLIT:
return TernaryValue.TRUE;
case Token.VOID:
return TernaryValue.FALSE;
default :
return getPureBooleanValue(n);
}
}",0.9984038308060654
27723,"/** 
 * Vars are hoisted into the closure containing the iterator to preserve their state accross multiple calls to next().
 */
private void visitVar(Node varStatement,Node enclosingCase,Node hoistRoot){
  Node name=varStatement.getFirstChild();
  enclosingCase.getLastChild().addChildToBack(IR.exprResult(IR.assign(name.detachFromParent(),name.removeFirstChild())));
  hoistRoot.getParent().addChildAfter(IR.var(name.cloneTree()),hoistRoot);
}","/** 
 * Vars are hoisted into the closure containing the iterator to preserve their state accross multiple calls to next().
 */
private void visitVar(Node varStatement,Node enclosingCase,Node hoistRoot){
  Node name=varStatement.removeFirstChild();
  while (name != null) {
    enclosingCase.getLastChild().addChildToBack(IR.exprResult(IR.assign(name,name.removeFirstChild())));
    hoistRoot.getParent().addChildAfter(IR.var(name.cloneTree()),hoistRoot);
    name=varStatement.removeFirstChild();
  }
}",0.8658922914466737
27724,"public void testSimpleGenerator(){
  test(""String_Node_Str"",Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  test(""String_Node_Str"",Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  test(""String_Node_Str"",Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testSimpleGenerator(){
  test(""String_Node_Str"",Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  test(""String_Node_Str"",Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  test(""String_Node_Str"",Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  test(""String_Node_Str"",Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.8630929425376013
27725,"private Scope getScopeHelper(String fnName){
  Scope s=localFunDefs.get(fnName);
  if (s != null) {
    return s;
  }
 else   if (parent != null) {
    return parent.getScopeHelper(fnName);
  }
  return null;
}","private Scope getScopeHelper(String fnName){
  Scope s=localFunDefs.get(fnName);
  if (s != null) {
    return s;
  }
 else   if (parent != null && !isDefinedLocally(fnName)) {
    return parent.getScopeHelper(fnName);
  }
  return null;
}",0.935412026726058
27726,"/** 
 * @param requiredType The context requires this type; warn if the expressiondoesn't have this type.
 * @param specializedType Used in boolean contexts to infer types of names.Invariant: specializedType is a subtype of requiredType.
 */
private EnvTypePair analyzeExprFwd(Node expr,TypeEnv inEnv,JSType requiredType,JSType specializedType){
  Preconditions.checkArgument(requiredType != null && !requiredType.isBottom());
  int exprKind=expr.getType();
switch (exprKind) {
case Token.EMPTY:
    return new EnvTypePair(inEnv,JSType.UNKNOWN);
case Token.FUNCTION:
{
    String fnName=symbolTable.getFunInternalName(expr);
    JSType fnType=envGetType(inEnv,fnName);
    Preconditions.checkState(fnType != null,""String_Node_Str"",fnName);
    return new EnvTypePair(inEnv,fnType);
  }
case Token.FALSE:
case Token.NULL:
case Token.NUMBER:
case Token.STRING:
case Token.TRUE:
return new EnvTypePair(inEnv,scalarValueToType(exprKind));
case Token.OBJECTLIT:
return analyzeObjLitFwd(expr,inEnv,requiredType,specializedType);
case Token.THIS:
{
if (!currentScope.hasThis()) {
warnings.add(JSError.make(expr,CheckGlobalThis.GLOBAL_THIS));
return new EnvTypePair(inEnv,JSType.UNKNOWN);
}
JSType thisType=currentScope.getDeclaredTypeOf(""String_Node_Str"");
return new EnvTypePair(inEnv,thisType);
}
case Token.NAME:
{
if (expr.matchesQualifiedName(""String_Node_Str"")) {
return new EnvTypePair(inEnv,JSType.UNDEFINED);
}
String varName=expr.getString();
if (currentScope.isLocalVar(varName) || currentScope.isFormalParam(varName) || currentScope.isLocalFunDef(varName)|| currentScope.isOuterVar(varName)|| varName.equals(currentScope.getName())) {
JSType inferredType=envGetType(inEnv,varName);
println(varName,""String_Node_Str"",inferredType,""String_Node_Str"",requiredType,""String_Node_Str"",specializedType);
if (!inferredType.isSubtypeOf(requiredType)) {
JSType declType=currentScope.getDeclaredTypeOf(varName);
if (tightenTypeAndDontWarn(declType,inferredType,requiredType)) {
  inferredType=inferredType.specialize(requiredType);
}
 else {
  return new EnvTypePair(inEnv,inferredType);
}
}
JSType preciseType=inferredType.specialize(specializedType);
println(varName,""String_Node_Str"",preciseType);
if (!preciseType.isBottom() && currentScope.isUndeclaredFormal(varName) && preciseType.hasNonScalar()) {
preciseType=preciseType.withLoose();
}
return EnvTypePair.addBinding(inEnv,varName,preciseType);
}
println(""String_Node_Str"",varName);
return new EnvTypePair(inEnv,JSType.UNKNOWN);
}
case Token.AND:
case Token.OR:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
if ((specializedType.isTruthy() && exprKind == Token.AND) || (specializedType.isFalsy() && exprKind == Token.OR)) {
EnvTypePair lhsPair=analyzeExprFwd(lhs,inEnv,JSType.UNKNOWN,specializedType);
EnvTypePair rhsPair=analyzeExprFwd(rhs,lhsPair.env,JSType.UNKNOWN,specializedType);
return rhsPair;
}
 else if ((specializedType.isFalsy() && exprKind == Token.AND) || (specializedType.isTruthy() && exprKind == Token.OR)) {
inEnv=inEnv.split();
EnvTypePair shortCircuitPair=analyzeExprFwd(lhs,inEnv,JSType.UNKNOWN,specializedType);
EnvTypePair lhsPair=analyzeExprFwd(lhs,inEnv,JSType.UNKNOWN,specializedType.negate());
EnvTypePair rhsPair=analyzeExprFwd(rhs,lhsPair.env,JSType.UNKNOWN,specializedType);
return EnvTypePair.join(rhsPair,shortCircuitPair);
}
 else {
inEnv=inEnv.split();
JSType stopAfterLhsType=exprKind == Token.AND ? JSType.FALSY : JSType.TRUTHY;
EnvTypePair shortCircuitPair=analyzeExprFwd(lhs,inEnv,requiredType,stopAfterLhsType);
EnvTypePair lhsPair=analyzeExprFwd(lhs,inEnv,JSType.UNKNOWN,stopAfterLhsType.negate());
EnvTypePair rhsPair=analyzeExprFwd(rhs,lhsPair.env,requiredType,specializedType);
return EnvTypePair.join(rhsPair,shortCircuitPair);
}
}
case Token.INC:
case Token.DEC:
{
mayWarnAboutConst(expr);
Node ch=expr.getFirstChild();
if (ch.isGetProp() || ch.isGetElem() && ch.getLastChild().isString()) {
Node recv=ch.getFirstChild();
String pname=ch.getLastChild().getString();
EnvTypePair pair=analyzeExprFwd(recv,inEnv);
JSType recvType=pair.type;
if (mayWarnAboutConstProp(ch,recvType,new QualifiedName(pname))) {
pair.type=requiredType;
return pair;
}
}
}
case Token.BITNOT:
case Token.POS:
case Token.NEG:
{
Node child=expr.getFirstChild();
EnvTypePair pair=analyzeExprFwd(child,inEnv,JSType.NUMBER);
if (!pair.type.isSubtypeOf(JSType.NUMBER)) {
warnInvalidOperand(child,expr.getType(),JSType.NUMBER,pair.type);
}
pair.type=JSType.NUMBER;
return pair;
}
case Token.TYPEOF:
{
EnvTypePair pair=analyzeExprFwd(expr.getFirstChild(),inEnv);
pair.type=JSType.STRING;
return pair;
}
case Token.INSTANCEOF:
{
Node obj=expr.getFirstChild();
Node ctor=expr.getLastChild();
EnvTypePair objPair, ctorPair;
objPair=analyzeExprFwd(obj,inEnv);
JSType objType=objPair.type;
if (!objType.equals(JSType.TOP) && !objType.equals(JSType.UNKNOWN) && !objType.hasNonScalar()) {
warnInvalidOperand(obj,Token.INSTANCEOF,""String_Node_Str"",objPair.type);
}
ctorPair=analyzeExprFwd(ctor,objPair.env,JSType.topFunction());
JSType ctorType=ctorPair.type;
FunctionType ctorFunType=ctorType.getFunType();
if (!ctorType.isUnknown() && (!ctorType.isSubtypeOf(JSType.topFunction()) || !ctorFunType.isConstructor())) {
warnInvalidOperand(ctor,Token.INSTANCEOF,""String_Node_Str"",ctorType);
}
if (ctorFunType == null || !ctorFunType.isConstructor() || (!specializedType.isTruthy() && !specializedType.isFalsy())) {
ctorPair.type=JSType.BOOLEAN;
return ctorPair;
}
JSType instanceType=ctorFunType.getTypeOfThis();
objPair=analyzeExprFwd(obj,inEnv,JSType.UNKNOWN,specializedType.isTruthy() ? objPair.type.specialize(instanceType) : objPair.type.removeType(instanceType));
ctorPair=analyzeExprFwd(ctor,objPair.env,JSType.topFunction());
ctorPair.type=JSType.BOOLEAN;
return ctorPair;
}
case Token.ADD:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
EnvTypePair lhsPair=analyzeExprFwd(lhs,inEnv,JSType.NUM_OR_STR);
EnvTypePair rhsPair=analyzeExprFwd(rhs,lhsPair.env,JSType.NUM_OR_STR);
JSType lhsType=lhsPair.type;
JSType rhsType=rhsPair.type;
if (!lhsType.isSubtypeOf(JSType.NUM_OR_STR)) {
warnInvalidOperand(lhs,expr.getType(),JSType.NUM_OR_STR,lhsType);
}
if (!rhsType.isSubtypeOf(JSType.NUM_OR_STR)) {
warnInvalidOperand(rhs,expr.getType(),JSType.NUM_OR_STR,rhsType);
}
return new EnvTypePair(rhsPair.env,JSType.plus(lhsType,rhsType));
}
case Token.BITOR:
case Token.BITAND:
case Token.BITXOR:
case Token.DIV:
case Token.LSH:
case Token.MOD:
case Token.MUL:
case Token.RSH:
case Token.SUB:
case Token.URSH:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
EnvTypePair lhsPair=analyzeExprFwd(lhs,inEnv,JSType.NUMBER);
EnvTypePair rhsPair=analyzeExprFwd(rhs,lhsPair.env,JSType.NUMBER);
if (!lhsPair.type.isSubtypeOf(JSType.NUMBER)) {
warnInvalidOperand(lhs,expr.getType(),JSType.NUMBER,lhsPair.type);
}
if (!rhsPair.type.isSubtypeOf(JSType.NUMBER)) {
warnInvalidOperand(rhs,expr.getType(),JSType.NUMBER,rhsPair.type);
}
rhsPair.type=JSType.NUMBER;
return rhsPair;
}
case Token.ASSIGN:
{
mayWarnAboutConst(expr);
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
LValueResultFwd lvalue=analyzeLValueFwd(lhs,inEnv,requiredType);
JSType declType=lvalue.declType;
EnvTypePair rhsPair=analyzeExprFwd(rhs,lvalue.env,requiredType,specializedType);
if (declType != null && !rhsPair.type.isSubtypeOf(declType)) {
warnings.add(JSError.make(expr,MISTYPED_ASSIGN_RHS,declType.toString(),rhsPair.type.toString()));
}
 else {
rhsPair.env=updateLvalueTypeInEnv(rhsPair.env,lhs,lvalue.ptr,rhsPair.type);
}
return rhsPair;
}
case Token.ASSIGN_ADD:
{
mayWarnAboutConst(expr);
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
JSType lhsReqType=specializeWithCorrection(requiredType,JSType.NUM_OR_STR);
LValueResultFwd lvalue=analyzeLValueFwd(lhs,inEnv,lhsReqType);
JSType lhsType=lvalue.type;
if (!lhsType.isSubtypeOf(JSType.NUM_OR_STR)) {
warnInvalidOperand(lhs,Token.ASSIGN_ADD,JSType.NUM_OR_STR,lhsType);
}
JSType rhsReqType=lhsType.equals(JSType.NUMBER) ? JSType.NUMBER : JSType.NUM_OR_STR;
EnvTypePair pair=analyzeExprFwd(rhs,lvalue.env,rhsReqType);
if (!pair.type.isSubtypeOf(rhsReqType)) {
warnInvalidOperand(rhs,Token.ASSIGN_ADD,rhsReqType,pair.type);
}
return pair;
}
case Token.ASSIGN_BITOR:
case Token.ASSIGN_BITXOR:
case Token.ASSIGN_BITAND:
case Token.ASSIGN_LSH:
case Token.ASSIGN_RSH:
case Token.ASSIGN_URSH:
case Token.ASSIGN_SUB:
case Token.ASSIGN_MUL:
case Token.ASSIGN_DIV:
case Token.ASSIGN_MOD:
{
mayWarnAboutConst(expr);
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
LValueResultFwd lvalue=analyzeLValueFwd(lhs,inEnv,JSType.NUMBER);
JSType lhsType=lvalue.type;
boolean lhsWarned=false;
if (!lhsType.isSubtypeOf(JSType.NUMBER)) {
warnInvalidOperand(lhs,expr.getType(),JSType.NUMBER,lhsType);
lhsWarned=true;
}
EnvTypePair pair=analyzeExprFwd(rhs,lvalue.env,JSType.NUMBER);
if (!pair.type.isSubtypeOf(JSType.NUMBER)) {
warnInvalidOperand(rhs,expr.getType(),JSType.NUMBER,pair.type);
}
if (!lhsWarned) {
pair.env=updateLvalueTypeInEnv(pair.env,lhs,lvalue.ptr,JSType.NUMBER);
}
pair.type=JSType.NUMBER;
return pair;
}
case Token.SHEQ:
case Token.SHNE:
return analyzeStrictComparisonFwd(exprKind,expr.getFirstChild(),expr.getLastChild(),inEnv,specializedType);
case Token.EQ:
case Token.NE:
return analyzeNonStrictComparisonFwd(expr,inEnv,specializedType);
case Token.LT:
case Token.GT:
case Token.LE:
case Token.GE:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
EnvTypePair lhsPair=analyzeExprFwd(lhs,inEnv);
EnvTypePair rhsPair=analyzeExprFwd(rhs,lhsPair.env);
if (lhsPair.type.isScalar() && !rhsPair.type.isScalar()) {
rhsPair=analyzeExprFwd(rhs,lhsPair.env,lhsPair.type);
}
 else if (rhsPair.type.isScalar()) {
lhsPair=analyzeExprFwd(lhs,inEnv,rhsPair.type);
rhsPair=analyzeExprFwd(rhs,lhsPair.env,rhsPair.type);
}
 else if (lhs.isName() && lhsPair.type.isUnknown() && rhs.isName()&& rhsPair.type.isUnknown()) {
TypeEnv env=envPutType(rhsPair.env,lhs.getString(),JSType.TOP_SCALAR);
env=envPutType(rhsPair.env,rhs.getString(),JSType.TOP_SCALAR);
return new EnvTypePair(env,JSType.BOOLEAN);
}
JSType lhsType=lhsPair.type;
JSType rhsType=rhsPair.type;
if (!lhsType.isSubtypeOf(JSType.TOP_SCALAR) || !rhsType.isSubtypeOf(JSType.TOP_SCALAR) || !JSType.areCompatibleScalarTypes(lhsType,rhsType)) {
warnInvalidOperand(expr,exprKind,""String_Node_Str"",lhsType.toString() + ""String_Node_Str"" + rhsType.toString());
}
rhsPair.type=JSType.BOOLEAN;
return rhsPair;
}
case Token.GETPROP:
Preconditions.checkState(!NodeUtil.isAssignmentOp(expr.getParent()) || !NodeUtil.isLValue(expr));
return analyzePropAccessFwd(expr.getFirstChild(),expr.getLastChild().getString(),inEnv,requiredType,specializedType);
case Token.HOOK:
{
Node cond=expr.getFirstChild();
Node thenBranch=cond.getNext();
Node elseBranch=thenBranch.getNext();
inEnv=inEnv.split();
TypeEnv trueEnv=analyzeExprFwd(cond,inEnv,JSType.UNKNOWN,JSType.TRUE_TYPE).env;
TypeEnv falseEnv=analyzeExprFwd(cond,inEnv,JSType.UNKNOWN,JSType.FALSE_TYPE).env;
EnvTypePair thenPair=analyzeExprFwd(thenBranch,trueEnv,requiredType,specializedType);
EnvTypePair elsePair=analyzeExprFwd(elseBranch,falseEnv,requiredType,specializedType);
return EnvTypePair.join(thenPair,elsePair);
}
case Token.CALL:
case Token.NEW:
{
if (isClosureSpecificCall(expr)) {
return analyzeClosureCallFwd(expr,inEnv,specializedType);
}
Node callee=expr.getFirstChild();
EnvTypePair calleePair=analyzeExprFwd(callee,inEnv,JSType.topFunction());
JSType calleeType=calleePair.type;
if (!calleeType.isSubtypeOf(JSType.topFunction())) {
warnings.add(JSError.make(expr,TypeCheck.NOT_CALLABLE,calleeType.toString()));
}
FunctionType funType=calleeType.getFunType();
if (funType == null || funType.isTopFunction() || funType.isQmarkFunction()) {
return analyzeCallNodeArgumentsFwd(expr,inEnv);
}
 else if (funType.isLoose()) {
return analyzeLooseCallNodeFwd(expr,inEnv,requiredType);
}
 else if (expr.isCall() && funType.isConstructor()) {
warnings.add(JSError.make(expr,TypeCheck.CONSTRUCTOR_NOT_CALLABLE,funType.toString()));
return analyzeCallNodeArgumentsFwd(expr,inEnv);
}
 else if (expr.isNew() && !funType.isConstructor()) {
warnings.add(JSError.make(expr,NOT_A_CONSTRUCTOR,funType.toString()));
return analyzeCallNodeArgumentsFwd(expr,inEnv);
}
int maxArity=funType.getMaxArity();
int minArity=funType.getMinArity();
int numArgs=expr.getChildCount() - 1;
if (numArgs < minArity || numArgs > maxArity) {
warnings.add(JSError.make(expr,TypeCheck.WRONG_ARGUMENT_COUNT,""String_Node_Str"",Integer.toString(numArgs),Integer.toString(minArity),""String_Node_Str"" + maxArity));
return analyzeCallNodeArgumentsFwd(expr,inEnv);
}
FunctionType origFunType=funType;
if (funType.isGeneric()) {
Map<String,JSType> typeMap=calcTypeInstantiationFwd(expr,funType,inEnv);
funType=funType.instantiateGenerics(typeMap);
println(""String_Node_Str"" + funType);
}
List<JSType> argTypes=Lists.newArrayList();
TypeEnv tmpEnv=inEnv;
Node arg=expr.getChildAtIndex(1);
for (int i=0; i < numArgs; i++) {
JSType formalType=funType.getFormalType(i);
if (formalType.isBottom()) {
warnings.add(JSError.make(expr,CALL_FUNCTION_WITH_BOTTOM_FORMAL,Integer.toString(i)));
formalType=JSType.UNKNOWN;
}
EnvTypePair pair=analyzeExprFwd(arg,tmpEnv,formalType);
JSType argTypeForDeferredCheck=pair.type;
if (i >= minArity && pair.type.equals(JSType.UNDEFINED)) {
argTypeForDeferredCheck=null;
}
 else if (!pair.type.isSubtypeOf(formalType)) {
warnings.add(JSError.make(arg,INVALID_ARGUMENT_TYPE,Integer.toString(i + 1),""String_Node_Str"",formalType.toString(),pair.type.toString()));
argTypeForDeferredCheck=null;
}
argTypes.add(argTypeForDeferredCheck);
tmpEnv=pair.env;
arg=arg.getNext();
}
JSType retType=funType.getReturnType();
if (callee.isName()) {
String calleeName=callee.getQualifiedName();
if (currentScope.isKnownFunction(calleeName)) {
if (currentScope.isLocalFunDef(calleeName)) {
collectTypesForFreeVarsFwd(callee,tmpEnv);
}
 else if (!origFunType.isGeneric()) {
JSType expectedRetType=requiredType;
println(""String_Node_Str"",expectedRetType,""String_Node_Str"",argTypes);
DeferredCheck dc;
if (expr.isCall()) {
dc=deferredChecks.get(expr);
if (dc == null) {
Preconditions.checkState(!currentScope.hasUndeclaredFormalsOrOuters(),""String_Node_Str"",expr);
dc=new DeferredCheck(expr,expectedRetType,currentScope,currentScope.getScope(calleeName));
}
 else {
dc.updateReturn(expectedRetType);
}
}
 else {
dc=new DeferredCheck(expr,null,currentScope,currentScope.getScope(calleeName));
deferredChecks.put(expr,dc);
}
dc.updateArgTypes(argTypes);
}
}
}
return new EnvTypePair(tmpEnv,retType);
}
case Token.COMMA:
return analyzeExprFwd(expr.getLastChild(),analyzeExprFwd(expr.getFirstChild(),inEnv).env,requiredType,specializedType);
case Token.NOT:
{
EnvTypePair pair=analyzeExprFwd(expr.getFirstChild(),inEnv,JSType.UNKNOWN,specializedType.negate());
pair.type=pair.type.negate().toBoolean();
return pair;
}
case Token.GETELEM:
{
Node receiver=expr.getFirstChild();
Node index=expr.getLastChild();
JSType reqObjType=pickReqObjType(expr);
EnvTypePair pair=analyzeExprFwd(receiver,inEnv,reqObjType);
JSType recvType=pair.type;
if (!mayWarnAboutNonObject(receiver,""String_Node_Str"",recvType,specializedType) && !mayWarnAboutStructPropAccess(receiver,recvType)) {
if (isArrayType(recvType)) {
pair=analyzeExprFwd(index,pair.env,JSType.NUMBER);
if (!pair.type.isSubtypeOf(JSType.NUMBER)) {
warnings.add(JSError.make(index,NewTypeInference.NON_NUMERIC_ARRAY_INDEX,pair.type.toString()));
}
}
 else if (index.isString()) {
return analyzePropAccessFwd(receiver,index.getString(),inEnv,requiredType,specializedType);
}
}
pair=analyzeExprFwd(index,pair.env);
pair.type=requiredType;
return pair;
}
case Token.VOID:
{
EnvTypePair pair=analyzeExprFwd(expr.getFirstChild(),inEnv);
pair.type=JSType.UNDEFINED;
return pair;
}
case Token.IN:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
JSType reqObjType=pickReqObjType(expr);
EnvTypePair pair;
pair=analyzeExprFwd(lhs,inEnv,JSType.NUM_OR_STR);
if (!pair.type.isSubtypeOf(JSType.NUM_OR_STR)) {
warnInvalidOperand(lhs,Token.IN,JSType.NUM_OR_STR,pair.type);
}
pair=analyzeExprFwd(rhs,pair.env,reqObjType);
if (!pair.type.isSubtypeOf(JSType.TOP_OBJECT)) {
warnInvalidOperand(rhs,Token.IN,""String_Node_Str"",pair.type);
pair.type=JSType.BOOLEAN;
return pair;
}
if (pair.type.isStruct()) {
warnings.add(JSError.make(rhs,TypeCheck.IN_USED_WITH_STRUCT));
pair.type=JSType.BOOLEAN;
return pair;
}
JSType resultType=JSType.BOOLEAN;
if (lhs.isString()) {
QualifiedName pname=new QualifiedName(lhs.getString());
if (specializedType.isTruthy()) {
pair=analyzeExprFwd(rhs,inEnv,reqObjType,reqObjType.withPropertyRequired(pname.getLeftmostName()));
resultType=JSType.TRUE_TYPE;
}
 else if (specializedType.isFalsy()) {
pair=analyzeExprFwd(rhs,inEnv,reqObjType);
pair=analyzeExprFwd(rhs,inEnv,reqObjType,pair.type.withoutProperty(pname));
resultType=JSType.FALSE_TYPE;
}
}
pair.type=resultType;
return pair;
}
case Token.DELPROP:
{
EnvTypePair pair=analyzeExprFwd(expr.getFirstChild(),inEnv);
pair.type=JSType.BOOLEAN;
return pair;
}
case Token.REGEXP:
return new EnvTypePair(inEnv,regexpType);
case Token.ARRAYLIT:
{
TypeEnv env=inEnv;
for (Node arrayElm=expr.getFirstChild(); arrayElm != null; arrayElm=arrayElm.getNext()) {
env=analyzeExprFwd(arrayElm,env).env;
}
return new EnvTypePair(env,arrayType);
}
case Token.CAST:
{
EnvTypePair pair=analyzeExprFwd(expr.getFirstChild(),inEnv);
JSType fromType=pair.type;
JSType toType=symbolTable.getCastType(expr);
if (!toType.isSubtypeOf(fromType) && !fromType.isSubtypeOf(toType)) {
warnings.add(JSError.make(expr,TypeValidator.INVALID_CAST,fromType.toString(),toType.toString()));
}
pair.type=toType;
return pair;
}
case Token.CASE:
return analyzeStrictComparisonFwd(Token.SHEQ,expr.getParent().getFirstChild(),expr.getFirstChild(),inEnv,specializedType);
default :
throw new RuntimeException(""String_Node_Str"" + Token.name(expr.getType()));
}
}","/** 
 * @param requiredType The context requires this type; warn if the expressiondoesn't have this type.
 * @param specializedType Used in boolean contexts to infer types of names.Invariant: specializedType is a subtype of requiredType.
 */
private EnvTypePair analyzeExprFwd(Node expr,TypeEnv inEnv,JSType requiredType,JSType specializedType){
  Preconditions.checkArgument(requiredType != null && !requiredType.isBottom());
  int exprKind=expr.getType();
switch (exprKind) {
case Token.EMPTY:
    return new EnvTypePair(inEnv,JSType.UNKNOWN);
case Token.FUNCTION:
{
    String fnName=symbolTable.getFunInternalName(expr);
    JSType fnType=envGetType(inEnv,fnName);
    Preconditions.checkState(fnType != null,""String_Node_Str"",fnName);
    return new EnvTypePair(inEnv,fnType);
  }
case Token.FALSE:
case Token.NULL:
case Token.NUMBER:
case Token.STRING:
case Token.TRUE:
return new EnvTypePair(inEnv,scalarValueToType(exprKind));
case Token.OBJECTLIT:
return analyzeObjLitFwd(expr,inEnv,requiredType,specializedType);
case Token.THIS:
{
if (!currentScope.hasThis()) {
warnings.add(JSError.make(expr,CheckGlobalThis.GLOBAL_THIS));
return new EnvTypePair(inEnv,JSType.UNKNOWN);
}
JSType thisType=currentScope.getDeclaredTypeOf(""String_Node_Str"");
return new EnvTypePair(inEnv,thisType);
}
case Token.NAME:
{
if (expr.matchesQualifiedName(""String_Node_Str"")) {
return new EnvTypePair(inEnv,JSType.UNDEFINED);
}
String varName=expr.getString();
if (currentScope.isLocalVar(varName) || currentScope.isFormalParam(varName) || currentScope.isLocalFunDef(varName)|| currentScope.isOuterVar(varName)|| varName.equals(currentScope.getName())) {
JSType inferredType=envGetType(inEnv,varName);
println(varName,""String_Node_Str"",inferredType,""String_Node_Str"",requiredType,""String_Node_Str"",specializedType);
if (!inferredType.isSubtypeOf(requiredType)) {
JSType declType=currentScope.getDeclaredTypeOf(varName);
if (tightenTypeAndDontWarn(declType,inferredType,requiredType)) {
  inferredType=inferredType.specialize(requiredType);
}
 else {
  return new EnvTypePair(inEnv,inferredType);
}
}
JSType preciseType=inferredType.specialize(specializedType);
println(varName,""String_Node_Str"",preciseType);
if (!preciseType.isBottom() && currentScope.isUndeclaredFormal(varName) && preciseType.hasNonScalar()) {
preciseType=preciseType.withLoose();
}
return EnvTypePair.addBinding(inEnv,varName,preciseType);
}
println(""String_Node_Str"",varName);
return new EnvTypePair(inEnv,JSType.UNKNOWN);
}
case Token.AND:
case Token.OR:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
if ((specializedType.isTruthy() && exprKind == Token.AND) || (specializedType.isFalsy() && exprKind == Token.OR)) {
EnvTypePair lhsPair=analyzeExprFwd(lhs,inEnv,JSType.UNKNOWN,specializedType);
EnvTypePair rhsPair=analyzeExprFwd(rhs,lhsPair.env,JSType.UNKNOWN,specializedType);
return rhsPair;
}
 else if ((specializedType.isFalsy() && exprKind == Token.AND) || (specializedType.isTruthy() && exprKind == Token.OR)) {
inEnv=inEnv.split();
EnvTypePair shortCircuitPair=analyzeExprFwd(lhs,inEnv,JSType.UNKNOWN,specializedType);
EnvTypePair lhsPair=analyzeExprFwd(lhs,inEnv,JSType.UNKNOWN,specializedType.negate());
EnvTypePair rhsPair=analyzeExprFwd(rhs,lhsPair.env,JSType.UNKNOWN,specializedType);
return EnvTypePair.join(rhsPair,shortCircuitPair);
}
 else {
inEnv=inEnv.split();
JSType stopAfterLhsType=exprKind == Token.AND ? JSType.FALSY : JSType.TRUTHY;
EnvTypePair shortCircuitPair=analyzeExprFwd(lhs,inEnv,requiredType,stopAfterLhsType);
EnvTypePair lhsPair=analyzeExprFwd(lhs,inEnv,JSType.UNKNOWN,stopAfterLhsType.negate());
EnvTypePair rhsPair=analyzeExprFwd(rhs,lhsPair.env,requiredType,specializedType);
return EnvTypePair.join(rhsPair,shortCircuitPair);
}
}
case Token.INC:
case Token.DEC:
{
mayWarnAboutConst(expr);
Node ch=expr.getFirstChild();
if (ch.isGetProp() || ch.isGetElem() && ch.getLastChild().isString()) {
Node recv=ch.getFirstChild();
String pname=ch.getLastChild().getString();
EnvTypePair pair=analyzeExprFwd(recv,inEnv);
JSType recvType=pair.type;
if (mayWarnAboutConstProp(ch,recvType,new QualifiedName(pname))) {
pair.type=requiredType;
return pair;
}
}
}
case Token.BITNOT:
case Token.POS:
case Token.NEG:
{
Node child=expr.getFirstChild();
EnvTypePair pair=analyzeExprFwd(child,inEnv,JSType.NUMBER);
if (!pair.type.isSubtypeOf(JSType.NUMBER)) {
warnInvalidOperand(child,expr.getType(),JSType.NUMBER,pair.type);
}
pair.type=JSType.NUMBER;
return pair;
}
case Token.TYPEOF:
{
EnvTypePair pair=analyzeExprFwd(expr.getFirstChild(),inEnv);
pair.type=JSType.STRING;
return pair;
}
case Token.INSTANCEOF:
{
Node obj=expr.getFirstChild();
Node ctor=expr.getLastChild();
EnvTypePair objPair, ctorPair;
objPair=analyzeExprFwd(obj,inEnv);
JSType objType=objPair.type;
if (!objType.equals(JSType.TOP) && !objType.equals(JSType.UNKNOWN) && !objType.hasNonScalar()) {
warnInvalidOperand(obj,Token.INSTANCEOF,""String_Node_Str"",objPair.type);
}
ctorPair=analyzeExprFwd(ctor,objPair.env,JSType.topFunction());
JSType ctorType=ctorPair.type;
FunctionType ctorFunType=ctorType.getFunType();
if (!ctorType.isUnknown() && (!ctorType.isSubtypeOf(JSType.topFunction()) || !ctorFunType.isConstructor())) {
warnInvalidOperand(ctor,Token.INSTANCEOF,""String_Node_Str"",ctorType);
}
if (ctorFunType == null || !ctorFunType.isConstructor() || (!specializedType.isTruthy() && !specializedType.isFalsy())) {
ctorPair.type=JSType.BOOLEAN;
return ctorPair;
}
JSType instanceType=ctorFunType.getTypeOfThis();
objPair=analyzeExprFwd(obj,inEnv,JSType.UNKNOWN,specializedType.isTruthy() ? objPair.type.specialize(instanceType) : objPair.type.removeType(instanceType));
ctorPair=analyzeExprFwd(ctor,objPair.env,JSType.topFunction());
ctorPair.type=JSType.BOOLEAN;
return ctorPair;
}
case Token.ADD:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
EnvTypePair lhsPair=analyzeExprFwd(lhs,inEnv,JSType.NUM_OR_STR);
EnvTypePair rhsPair=analyzeExprFwd(rhs,lhsPair.env,JSType.NUM_OR_STR);
JSType lhsType=lhsPair.type;
JSType rhsType=rhsPair.type;
if (!lhsType.isSubtypeOf(JSType.NUM_OR_STR)) {
warnInvalidOperand(lhs,expr.getType(),JSType.NUM_OR_STR,lhsType);
}
if (!rhsType.isSubtypeOf(JSType.NUM_OR_STR)) {
warnInvalidOperand(rhs,expr.getType(),JSType.NUM_OR_STR,rhsType);
}
return new EnvTypePair(rhsPair.env,JSType.plus(lhsType,rhsType));
}
case Token.BITOR:
case Token.BITAND:
case Token.BITXOR:
case Token.DIV:
case Token.LSH:
case Token.MOD:
case Token.MUL:
case Token.RSH:
case Token.SUB:
case Token.URSH:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
EnvTypePair lhsPair=analyzeExprFwd(lhs,inEnv,JSType.NUMBER);
EnvTypePair rhsPair=analyzeExprFwd(rhs,lhsPair.env,JSType.NUMBER);
if (!lhsPair.type.isSubtypeOf(JSType.NUMBER)) {
warnInvalidOperand(lhs,expr.getType(),JSType.NUMBER,lhsPair.type);
}
if (!rhsPair.type.isSubtypeOf(JSType.NUMBER)) {
warnInvalidOperand(rhs,expr.getType(),JSType.NUMBER,rhsPair.type);
}
rhsPair.type=JSType.NUMBER;
return rhsPair;
}
case Token.ASSIGN:
{
mayWarnAboutConst(expr);
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
LValueResultFwd lvalue=analyzeLValueFwd(lhs,inEnv,requiredType);
JSType declType=lvalue.declType;
EnvTypePair rhsPair=analyzeExprFwd(rhs,lvalue.env,requiredType,specializedType);
if (declType != null && !rhsPair.type.isSubtypeOf(declType)) {
warnings.add(JSError.make(expr,MISTYPED_ASSIGN_RHS,declType.toString(),rhsPair.type.toString()));
}
 else {
rhsPair.env=updateLvalueTypeInEnv(rhsPair.env,lhs,lvalue.ptr,rhsPair.type);
}
return rhsPair;
}
case Token.ASSIGN_ADD:
{
mayWarnAboutConst(expr);
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
JSType lhsReqType=specializeWithCorrection(requiredType,JSType.NUM_OR_STR);
LValueResultFwd lvalue=analyzeLValueFwd(lhs,inEnv,lhsReqType);
JSType lhsType=lvalue.type;
if (!lhsType.isSubtypeOf(JSType.NUM_OR_STR)) {
warnInvalidOperand(lhs,Token.ASSIGN_ADD,JSType.NUM_OR_STR,lhsType);
}
JSType rhsReqType=lhsType.equals(JSType.NUMBER) ? JSType.NUMBER : JSType.NUM_OR_STR;
EnvTypePair pair=analyzeExprFwd(rhs,lvalue.env,rhsReqType);
if (!pair.type.isSubtypeOf(rhsReqType)) {
warnInvalidOperand(rhs,Token.ASSIGN_ADD,rhsReqType,pair.type);
}
return pair;
}
case Token.ASSIGN_BITOR:
case Token.ASSIGN_BITXOR:
case Token.ASSIGN_BITAND:
case Token.ASSIGN_LSH:
case Token.ASSIGN_RSH:
case Token.ASSIGN_URSH:
case Token.ASSIGN_SUB:
case Token.ASSIGN_MUL:
case Token.ASSIGN_DIV:
case Token.ASSIGN_MOD:
{
mayWarnAboutConst(expr);
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
LValueResultFwd lvalue=analyzeLValueFwd(lhs,inEnv,JSType.NUMBER);
JSType lhsType=lvalue.type;
boolean lhsWarned=false;
if (!lhsType.isSubtypeOf(JSType.NUMBER)) {
warnInvalidOperand(lhs,expr.getType(),JSType.NUMBER,lhsType);
lhsWarned=true;
}
EnvTypePair pair=analyzeExprFwd(rhs,lvalue.env,JSType.NUMBER);
if (!pair.type.isSubtypeOf(JSType.NUMBER)) {
warnInvalidOperand(rhs,expr.getType(),JSType.NUMBER,pair.type);
}
if (!lhsWarned) {
pair.env=updateLvalueTypeInEnv(pair.env,lhs,lvalue.ptr,JSType.NUMBER);
}
pair.type=JSType.NUMBER;
return pair;
}
case Token.SHEQ:
case Token.SHNE:
return analyzeStrictComparisonFwd(exprKind,expr.getFirstChild(),expr.getLastChild(),inEnv,specializedType);
case Token.EQ:
case Token.NE:
return analyzeNonStrictComparisonFwd(expr,inEnv,specializedType);
case Token.LT:
case Token.GT:
case Token.LE:
case Token.GE:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
EnvTypePair lhsPair=analyzeExprFwd(lhs,inEnv);
EnvTypePair rhsPair=analyzeExprFwd(rhs,lhsPair.env);
if (lhsPair.type.isScalar() && !rhsPair.type.isScalar()) {
rhsPair=analyzeExprFwd(rhs,lhsPair.env,lhsPair.type);
}
 else if (rhsPair.type.isScalar()) {
lhsPair=analyzeExprFwd(lhs,inEnv,rhsPair.type);
rhsPair=analyzeExprFwd(rhs,lhsPair.env,rhsPair.type);
}
 else if (lhs.isName() && lhsPair.type.isUnknown() && rhs.isName()&& rhsPair.type.isUnknown()) {
TypeEnv env=envPutType(rhsPair.env,lhs.getString(),JSType.TOP_SCALAR);
env=envPutType(rhsPair.env,rhs.getString(),JSType.TOP_SCALAR);
return new EnvTypePair(env,JSType.BOOLEAN);
}
JSType lhsType=lhsPair.type;
JSType rhsType=rhsPair.type;
if (!lhsType.isSubtypeOf(JSType.TOP_SCALAR) || !rhsType.isSubtypeOf(JSType.TOP_SCALAR) || !JSType.areCompatibleScalarTypes(lhsType,rhsType)) {
warnInvalidOperand(expr,exprKind,""String_Node_Str"",lhsType.toString() + ""String_Node_Str"" + rhsType.toString());
}
rhsPair.type=JSType.BOOLEAN;
return rhsPair;
}
case Token.GETPROP:
Preconditions.checkState(!NodeUtil.isAssignmentOp(expr.getParent()) || !NodeUtil.isLValue(expr));
return analyzePropAccessFwd(expr.getFirstChild(),expr.getLastChild().getString(),inEnv,requiredType,specializedType);
case Token.HOOK:
{
Node cond=expr.getFirstChild();
Node thenBranch=cond.getNext();
Node elseBranch=thenBranch.getNext();
inEnv=inEnv.split();
TypeEnv trueEnv=analyzeExprFwd(cond,inEnv,JSType.UNKNOWN,JSType.TRUE_TYPE).env;
TypeEnv falseEnv=analyzeExprFwd(cond,inEnv,JSType.UNKNOWN,JSType.FALSE_TYPE).env;
EnvTypePair thenPair=analyzeExprFwd(thenBranch,trueEnv,requiredType,specializedType);
EnvTypePair elsePair=analyzeExprFwd(elseBranch,falseEnv,requiredType,specializedType);
return EnvTypePair.join(thenPair,elsePair);
}
case Token.CALL:
case Token.NEW:
{
if (isClosureSpecificCall(expr)) {
return analyzeClosureCallFwd(expr,inEnv,specializedType);
}
Node callee=expr.getFirstChild();
EnvTypePair calleePair=analyzeExprFwd(callee,inEnv,JSType.topFunction());
JSType calleeType=calleePair.type;
if (!calleeType.isSubtypeOf(JSType.topFunction())) {
warnings.add(JSError.make(expr,TypeCheck.NOT_CALLABLE,calleeType.toString()));
}
FunctionType funType=calleeType.getFunType();
if (funType == null || funType.isTopFunction() || funType.isQmarkFunction()) {
return analyzeCallNodeArgumentsFwd(expr,inEnv);
}
 else if (funType.isLoose()) {
return analyzeLooseCallNodeFwd(expr,inEnv,requiredType);
}
 else if (expr.isCall() && funType.isConstructor()) {
warnings.add(JSError.make(expr,TypeCheck.CONSTRUCTOR_NOT_CALLABLE,funType.toString()));
return analyzeCallNodeArgumentsFwd(expr,inEnv);
}
 else if (expr.isNew() && !funType.isConstructor()) {
warnings.add(JSError.make(expr,NOT_A_CONSTRUCTOR,funType.toString()));
return analyzeCallNodeArgumentsFwd(expr,inEnv);
}
int maxArity=funType.getMaxArity();
int minArity=funType.getMinArity();
int numArgs=expr.getChildCount() - 1;
if (numArgs < minArity || numArgs > maxArity) {
warnings.add(JSError.make(expr,TypeCheck.WRONG_ARGUMENT_COUNT,""String_Node_Str"",Integer.toString(numArgs),Integer.toString(minArity),""String_Node_Str"" + maxArity));
return analyzeCallNodeArgumentsFwd(expr,inEnv);
}
FunctionType origFunType=funType;
if (funType.isGeneric()) {
Map<String,JSType> typeMap=calcTypeInstantiationFwd(expr,funType,inEnv);
funType=funType.instantiateGenerics(typeMap);
println(""String_Node_Str"" + funType);
}
List<JSType> argTypes=Lists.newArrayList();
TypeEnv tmpEnv=inEnv;
Node arg=expr.getChildAtIndex(1);
for (int i=0; i < numArgs; i++) {
JSType formalType=funType.getFormalType(i);
if (formalType.isBottom()) {
warnings.add(JSError.make(expr,CALL_FUNCTION_WITH_BOTTOM_FORMAL,Integer.toString(i)));
formalType=JSType.UNKNOWN;
}
EnvTypePair pair=analyzeExprFwd(arg,tmpEnv,formalType);
JSType argTypeForDeferredCheck=pair.type;
if (i >= minArity && pair.type.equals(JSType.UNDEFINED)) {
argTypeForDeferredCheck=null;
}
 else if (!pair.type.isSubtypeOf(formalType)) {
warnings.add(JSError.make(arg,INVALID_ARGUMENT_TYPE,Integer.toString(i + 1),""String_Node_Str"",formalType.toString(),pair.type.toString()));
argTypeForDeferredCheck=null;
}
argTypes.add(argTypeForDeferredCheck);
tmpEnv=pair.env;
arg=arg.getNext();
}
JSType retType=funType.getReturnType();
if (callee.isName()) {
String calleeName=callee.getQualifiedName();
if (currentScope.isKnownFunction(calleeName)) {
if (currentScope.isLocalFunDef(calleeName)) {
collectTypesForFreeVarsFwd(callee,tmpEnv);
}
 else if (!origFunType.isGeneric()) {
JSType expectedRetType=requiredType;
println(""String_Node_Str"",expectedRetType,""String_Node_Str"",argTypes);
DeferredCheck dc;
if (expr.isCall()) {
dc=deferredChecks.get(expr);
if (dc != null) {
dc.updateReturn(expectedRetType);
}
 else {
Preconditions.checkState(!currentScope.hasUndeclaredFormalsOrOuters(),""String_Node_Str"",expr);
}
}
 else {
dc=new DeferredCheck(expr,null,currentScope,currentScope.getScope(calleeName));
deferredChecks.put(expr,dc);
}
if (dc != null) {
dc.updateArgTypes(argTypes);
}
}
}
}
return new EnvTypePair(tmpEnv,retType);
}
case Token.COMMA:
return analyzeExprFwd(expr.getLastChild(),analyzeExprFwd(expr.getFirstChild(),inEnv).env,requiredType,specializedType);
case Token.NOT:
{
EnvTypePair pair=analyzeExprFwd(expr.getFirstChild(),inEnv,JSType.UNKNOWN,specializedType.negate());
pair.type=pair.type.negate().toBoolean();
return pair;
}
case Token.GETELEM:
{
Node receiver=expr.getFirstChild();
Node index=expr.getLastChild();
JSType reqObjType=pickReqObjType(expr);
EnvTypePair pair=analyzeExprFwd(receiver,inEnv,reqObjType);
JSType recvType=pair.type;
if (!mayWarnAboutNonObject(receiver,""String_Node_Str"",recvType,specializedType) && !mayWarnAboutStructPropAccess(receiver,recvType)) {
if (isArrayType(recvType)) {
pair=analyzeExprFwd(index,pair.env,JSType.NUMBER);
if (!pair.type.isSubtypeOf(JSType.NUMBER)) {
warnings.add(JSError.make(index,NewTypeInference.NON_NUMERIC_ARRAY_INDEX,pair.type.toString()));
}
}
 else if (index.isString()) {
return analyzePropAccessFwd(receiver,index.getString(),inEnv,requiredType,specializedType);
}
}
pair=analyzeExprFwd(index,pair.env);
pair.type=requiredType;
return pair;
}
case Token.VOID:
{
EnvTypePair pair=analyzeExprFwd(expr.getFirstChild(),inEnv);
pair.type=JSType.UNDEFINED;
return pair;
}
case Token.IN:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
JSType reqObjType=pickReqObjType(expr);
EnvTypePair pair;
pair=analyzeExprFwd(lhs,inEnv,JSType.NUM_OR_STR);
if (!pair.type.isSubtypeOf(JSType.NUM_OR_STR)) {
warnInvalidOperand(lhs,Token.IN,JSType.NUM_OR_STR,pair.type);
}
pair=analyzeExprFwd(rhs,pair.env,reqObjType);
if (!pair.type.isSubtypeOf(JSType.TOP_OBJECT)) {
warnInvalidOperand(rhs,Token.IN,""String_Node_Str"",pair.type);
pair.type=JSType.BOOLEAN;
return pair;
}
if (pair.type.isStruct()) {
warnings.add(JSError.make(rhs,TypeCheck.IN_USED_WITH_STRUCT));
pair.type=JSType.BOOLEAN;
return pair;
}
JSType resultType=JSType.BOOLEAN;
if (lhs.isString()) {
QualifiedName pname=new QualifiedName(lhs.getString());
if (specializedType.isTruthy()) {
pair=analyzeExprFwd(rhs,inEnv,reqObjType,reqObjType.withPropertyRequired(pname.getLeftmostName()));
resultType=JSType.TRUE_TYPE;
}
 else if (specializedType.isFalsy()) {
pair=analyzeExprFwd(rhs,inEnv,reqObjType);
pair=analyzeExprFwd(rhs,inEnv,reqObjType,pair.type.withoutProperty(pname));
resultType=JSType.FALSE_TYPE;
}
}
pair.type=resultType;
return pair;
}
case Token.DELPROP:
{
EnvTypePair pair=analyzeExprFwd(expr.getFirstChild(),inEnv);
pair.type=JSType.BOOLEAN;
return pair;
}
case Token.REGEXP:
return new EnvTypePair(inEnv,regexpType);
case Token.ARRAYLIT:
{
TypeEnv env=inEnv;
for (Node arrayElm=expr.getFirstChild(); arrayElm != null; arrayElm=arrayElm.getNext()) {
env=analyzeExprFwd(arrayElm,env).env;
}
return new EnvTypePair(env,arrayType);
}
case Token.CAST:
{
EnvTypePair pair=analyzeExprFwd(expr.getFirstChild(),inEnv);
JSType fromType=pair.type;
JSType toType=symbolTable.getCastType(expr);
if (!toType.isSubtypeOf(fromType) && !fromType.isSubtypeOf(toType)) {
warnings.add(JSError.make(expr,TypeValidator.INVALID_CAST,fromType.toString(),toType.toString()));
}
pair.type=toType;
return pair;
}
case Token.CASE:
return analyzeStrictComparisonFwd(Token.SHEQ,expr.getParent().getFirstChild(),expr.getFirstChild(),inEnv,specializedType);
default :
throw new RuntimeException(""String_Node_Str"" + Token.name(expr.getType()));
}
}",0.9886902590295512
27727,"public void testDeferredChecks(){
  typeCheck(""String_Node_Str"" + ""String_Node_Str"",NewTypeInference.INVALID_INFERRED_RETURN_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"",TypeCheck.WRONG_ARGUMENT_COUNT);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"",NewTypeInference.INVALID_INFERRED_RETURN_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_INFERRED_RETURN_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",TypeCheck.WRONG_ARGUMENT_COUNT);
}","public void testDeferredChecks(){
  typeCheck(""String_Node_Str"" + ""String_Node_Str"",NewTypeInference.INVALID_INFERRED_RETURN_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"",TypeCheck.WRONG_ARGUMENT_COUNT);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"",NewTypeInference.INVALID_INFERRED_RETURN_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_INFERRED_RETURN_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",TypeCheck.WRONG_ARGUMENT_COUNT);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9504587155963304
27728,"private JsDocToken parseAnnotation(JsDocToken token,List<ExtendedTypeInfo> extendedTypes){
  JSTypeExpression type;
  int lineno=stream.getLineno();
  int charno=stream.getCharno();
  String annotationName=stream.getString();
  Annotation annotation=annotationNames.get(annotationName);
  if (annotation == null) {
    parser.addParserWarning(""String_Node_Str"",annotationName,stream.getLineno(),stream.getCharno());
  }
 else {
    jsdocBuilder.markAnnotation(annotationName,lineno,charno);
switch (annotation) {
case NG_INJECT:
      if (jsdocBuilder.isNgInjectRecorded()) {
        parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
      }
 else {
        jsdocBuilder.recordNgInject(true);
      }
    return eatUntilEOLIfNotAnnotation();
case JAGGER_INJECT:
  if (jsdocBuilder.isJaggerInjectRecorded()) {
    parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
  }
 else {
    jsdocBuilder.recordJaggerInject(true);
  }
return eatUntilEOLIfNotAnnotation();
case JAGGER_MODULE:
if (jsdocBuilder.isJaggerModuleRecorded()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
 else {
jsdocBuilder.recordJaggerModule(true);
}
return eatUntilEOLIfNotAnnotation();
case JAGGER_PROVIDE:
if (jsdocBuilder.isJaggerProvideRecorded()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
 else {
jsdocBuilder.recordJaggerProvide(true);
}
return eatUntilEOLIfNotAnnotation();
case JAGGER_PROVIDE_PROMISE:
if (jsdocBuilder.isJaggerProvidePromiseRecorded()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
 else {
jsdocBuilder.recordJaggerProvidePromise(true);
}
return eatUntilEOLIfNotAnnotation();
case AUTHOR:
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo authorInfo=extractSingleLineBlock();
String author=authorInfo.string;
if (author.isEmpty()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
 else {
jsdocBuilder.addAuthor(author);
}
token=authorInfo.token;
}
 else {
token=eatUntilEOLIfNotAnnotation();
}
return token;
case CONSISTENTIDGENERATOR:
if (!jsdocBuilder.recordConsistentIdGenerator()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case UNRESTRICTED:
if (!jsdocBuilder.recordUnrestricted()) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case STRUCT:
if (!jsdocBuilder.recordStruct()) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case DICT:
if (!jsdocBuilder.recordDict()) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case CONSTRUCTOR:
if (!jsdocBuilder.recordConstructor()) {
if (jsdocBuilder.isInterfaceRecorded()) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
 else {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
}
return eatUntilEOLIfNotAnnotation();
case DEPRECATED:
if (!jsdocBuilder.recordDeprecated()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
ExtractionInfo reasonInfo=extractMultilineTextualBlock(token);
String reason=reasonInfo.string;
if (reason.length() > 0) {
jsdocBuilder.recordDeprecationReason(reason);
}
token=reasonInfo.token;
return token;
case INTERFACE:
if (!jsdocBuilder.recordInterface()) {
if (jsdocBuilder.isConstructorRecorded()) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
 else {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
}
return eatUntilEOLIfNotAnnotation();
case DESC:
if (jsdocBuilder.isDescriptionRecorded()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
return eatUntilEOLIfNotAnnotation();
}
 else {
ExtractionInfo descriptionInfo=extractMultilineTextualBlock(token);
String description=descriptionInfo.string;
jsdocBuilder.recordDescription(description);
token=descriptionInfo.token;
return token;
}
case FILE_OVERVIEW:
String fileOverview=""String_Node_Str"";
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo fileOverviewInfo=extractMultilineTextualBlock(token,WhitespaceOption.TRIM);
fileOverview=fileOverviewInfo.string;
token=fileOverviewInfo.token;
}
 else {
token=eatTokensUntilEOL(token);
}
if (!jsdocBuilder.recordFileOverview(fileOverview)) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return token;
case LICENSE:
case PRESERVE:
ExtractionInfo preserveInfo=extractMultilineTextualBlock(token,WhitespaceOption.PRESERVE);
String preserve=preserveInfo.string;
if (preserve.length() > 0) {
if (fileLevelJsDocBuilder != null) {
fileLevelJsDocBuilder.append(preserve);
}
}
token=preserveInfo.token;
return token;
case ENUM:
token=next();
lineno=stream.getLineno();
charno=stream.getCharno();
type=null;
if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
type=createJSTypeExpression(parseAndRecordTypeNode(token));
}
if (type == null) {
type=createJSTypeExpression(newStringNode(""String_Node_Str""));
}
if (!jsdocBuilder.recordEnumParameterType(type)) {
parser.addTypeWarning(""String_Node_Str"",lineno,charno);
}
token=eatUntilEOLIfNotAnnotation(token);
return token;
case EXPORT:
if (!jsdocBuilder.recordExport()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case EXPOSE:
if (!jsdocBuilder.recordExpose()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case EXTERNS:
if (!jsdocBuilder.recordExterns()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case JAVA_DISPATCH:
if (!jsdocBuilder.recordJavaDispatch()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case EXTENDS:
case IMPLEMENTS:
skipEOLs();
token=next();
lineno=stream.getLineno();
charno=stream.getCharno();
boolean matchingRc=false;
if (token == JsDocToken.LC) {
token=next();
matchingRc=true;
}
if (token == JsDocToken.STRING) {
Node typeNode=parseAndRecordTypeNameNode(token,lineno,charno,matchingRc);
lineno=stream.getLineno();
charno=stream.getCharno();
typeNode=wrapNode(Token.BANG,typeNode);
type=createJSTypeExpression(typeNode);
if (annotation == Annotation.EXTENDS) {
extendedTypes.add(new ExtendedTypeInfo(type,stream.getLineno(),stream.getCharno()));
}
 else {
Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
if (!jsdocBuilder.recordImplementedInterface(type)) {
parser.addTypeWarning(""String_Node_Str"",lineno,charno);
}
}
token=next();
if (matchingRc) {
if (token != JsDocToken.RC) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
 else {
token=next();
}
}
 else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
}
 else {
parser.addTypeWarning(""String_Node_Str"",lineno,charno);
}
token=eatUntilEOLIfNotAnnotation(token);
return token;
case HIDDEN:
if (!jsdocBuilder.recordHiddenness()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case LENDS:
skipEOLs();
matchingRc=false;
if (match(JsDocToken.LC)) {
token=next();
matchingRc=true;
}
if (match(JsDocToken.STRING)) {
token=next();
if (!jsdocBuilder.recordLends(stream.getString())) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
}
 else {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
if (matchingRc && !match(JsDocToken.RC)) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case MEANING:
ExtractionInfo meaningInfo=extractMultilineTextualBlock(token);
String meaning=meaningInfo.string;
token=meaningInfo.token;
if (!jsdocBuilder.recordMeaning(meaning)) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return token;
case NO_ALIAS:
if (!jsdocBuilder.recordNoAlias()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case NO_COMPILE:
if (!jsdocBuilder.recordNoCompile()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case NO_TYPE_CHECK:
if (!jsdocBuilder.recordNoTypeCheck()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case NOT_IMPLEMENTED:
return eatUntilEOLIfNotAnnotation();
case INHERIT_DOC:
case OVERRIDE:
if (!jsdocBuilder.recordOverride()) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case THROWS:
{
skipEOLs();
token=next();
lineno=stream.getLineno();
charno=stream.getCharno();
type=null;
if (token == JsDocToken.LC) {
type=createJSTypeExpression(parseAndRecordTypeNode(token));
if (type == null) {
return eatUntilEOLIfNotAnnotation();
}
}
token=current();
jsdocBuilder.recordThrowType(type);
boolean isAnnotationNext=lookAheadForAnnotation();
if (jsdocBuilder.shouldParseDocumentation() && !isAnnotationNext) {
ExtractionInfo descriptionInfo=extractMultilineTextualBlock(token);
String description=descriptionInfo.string;
if (description.length() > 0) {
jsdocBuilder.recordThrowDescription(type,description);
}
token=descriptionInfo.token;
}
 else {
token=eatUntilEOLIfNotAnnotation();
}
return token;
}
case PARAM:
skipEOLs();
token=next();
lineno=stream.getLineno();
charno=stream.getCharno();
type=null;
if (token == JsDocToken.LC) {
type=createJSTypeExpression(parseAndRecordParamTypeNode(token));
if (type == null) {
return eatUntilEOLIfNotAnnotation();
}
skipEOLs();
token=next();
lineno=stream.getLineno();
charno=stream.getCharno();
}
String name=null;
boolean isBracketedParam=JsDocToken.LB == token;
if (isBracketedParam) {
token=next();
}
if (JsDocToken.STRING != token) {
parser.addTypeWarning(""String_Node_Str"",lineno,charno);
}
 else {
name=stream.getString();
if (isBracketedParam) {
token=next();
if (JsDocToken.EQUALS == token) {
token=next();
if (JsDocToken.STRING == token) {
token=next();
}
}
if (JsDocToken.RB != token) {
reportTypeSyntaxWarning(""String_Node_Str"");
}
 else if (type != null) {
type=JSTypeExpression.makeOptionalArg(type);
}
}
if (name.indexOf('.') > -1) {
name=null;
}
 else if (!jsdocBuilder.recordParameter(name,type)) {
if (jsdocBuilder.hasParameter(name)) {
parser.addTypeWarning(""String_Node_Str"",name,lineno,charno);
}
 else {
parser.addTypeWarning(""String_Node_Str"",name,lineno,charno);
}
}
}
if (name == null) {
token=eatUntilEOLIfNotAnnotation(token);
return token;
}
jsdocBuilder.markName(name,sourceFile,lineno,charno);
if (jsdocBuilder.shouldParseDocumentation() && token != JsDocToken.ANNOTATION) {
ExtractionInfo paramDescriptionInfo=extractMultilineTextualBlock(token);
String paramDescription=paramDescriptionInfo.string;
if (paramDescription.length() > 0) {
jsdocBuilder.recordParameterDescription(name,paramDescription);
}
token=paramDescriptionInfo.token;
}
 else if (token != JsDocToken.EOC && token != JsDocToken.EOF) {
token=eatUntilEOLIfNotAnnotation();
}
return token;
case PRESERVE_TRY:
if (!jsdocBuilder.recordPreserveTry()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case NO_SHADOW:
if (!jsdocBuilder.recordNoShadow()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case NO_SIDE_EFFECTS:
if (!jsdocBuilder.recordNoSideEffects()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case MODIFIES:
token=parseModifiesTag(next());
return token;
case IMPLICIT_CAST:
if (!jsdocBuilder.recordImplicitCast()) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case SEE:
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo referenceInfo=extractSingleLineBlock();
String reference=referenceInfo.string;
if (reference.isEmpty()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
 else {
jsdocBuilder.addReference(reference);
}
token=referenceInfo.token;
}
 else {
token=eatUntilEOLIfNotAnnotation();
}
return token;
case STABLEIDGENERATOR:
if (!jsdocBuilder.recordStableIdGenerator()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case SUPPRESS:
token=parseSuppressTag(next());
return token;
case TEMPLATE:
{
ExtractionInfo templateInfo=extractMultilineTextualBlock(token);
List<String> templateString=Splitter.on(""String_Node_Str"").trimResults().splitToList(templateInfo.string);
boolean isTypeTransformation=false;
if (templateString.size() >= 2) {
isTypeTransformation=true;
if (templateString.get(1).isEmpty()) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
if (templateString.size() >= 3) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
}
List<String> names=Lists.newArrayList(Splitter.on(',').trimResults().split(templateString.get(0)));
if (names.size() == 1 && names.get(0).isEmpty()) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
 else {
for (String typeName : names) {
if (!validTemplateTypeName(typeName)) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
 else if (!jsdocBuilder.recordTemplateTypeName(typeName)) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
}
}
if (isTypeTransformation && names.size() > 1) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
token=templateInfo.token;
return token;
}
case IDGENERATOR:
token=parseIdGeneratorTag(next());
return token;
case WIZACTION:
if (!jsdocBuilder.recordWizaction()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case DISPOSES:
{
ExtractionInfo templateInfo=extractSingleLineBlock();
List<String> names=Lists.newArrayList(Splitter.on(',').trimResults().split(templateInfo.string));
if (names.isEmpty() || names.get(0).isEmpty()) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
 else if (!jsdocBuilder.recordDisposesParameter(names)) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
token=templateInfo.token;
return token;
}
case VERSION:
ExtractionInfo versionInfo=extractSingleLineBlock();
String version=versionInfo.string;
if (version.isEmpty()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
 else {
if (!jsdocBuilder.recordVersion(version)) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
}
token=versionInfo.token;
return token;
case CONSTANT:
case DEFINE:
case RETURN:
case PACKAGE:
case PRIVATE:
case PROTECTED:
case PUBLIC:
case THIS:
case TYPE:
case TYPEDEF:
lineno=stream.getLineno();
charno=stream.getCharno();
Node typeNode=null;
boolean hasType=lookAheadForType();
boolean isAlternateTypeAnnotation=(annotation == Annotation.PACKAGE || annotation == Annotation.PRIVATE || annotation == Annotation.PROTECTED || annotation == Annotation.PUBLIC || annotation == Annotation.CONSTANT);
boolean canSkipTypeAnnotation=(isAlternateTypeAnnotation || annotation == Annotation.RETURN);
type=null;
if (hasType || !canSkipTypeAnnotation) {
skipEOLs();
token=next();
typeNode=parseAndRecordTypeNode(token);
if (annotation == Annotation.THIS) {
typeNode=wrapNode(Token.BANG,typeNode);
}
type=createJSTypeExpression(typeNode);
}
boolean hasError=type == null && !canSkipTypeAnnotation;
if (!hasError) {
if ((type != null && isAlternateTypeAnnotation) || annotation == Annotation.TYPE) {
if (!jsdocBuilder.recordType(type)) {
parser.addTypeWarning(""String_Node_Str"",lineno,charno);
}
}
boolean isAnnotationNext=lookAheadForAnnotation();
switch (annotation) {
case CONSTANT:
if (!jsdocBuilder.recordConstancy()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
break;
case DEFINE:
if (!jsdocBuilder.recordDefineType(type)) {
parser.addParserWarning(""String_Node_Str"",lineno,charno);
}
if (!isAnnotationNext) {
return recordDescription(token);
}
break;
case PRIVATE:
if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
parser.addParserWarning(""String_Node_Str"",lineno,charno);
}
if (!isAnnotationNext) {
return recordDescription(token);
}
break;
case PACKAGE:
if (!jsdocBuilder.recordVisibility(Visibility.PACKAGE)) {
parser.addParserWarning(""String_Node_Str"",lineno,charno);
}
if (!isAnnotationNext) {
return recordDescription(token);
}
break;
case PROTECTED:
if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
parser.addParserWarning(""String_Node_Str"",lineno,charno);
}
if (!isAnnotationNext) {
return recordDescription(token);
}
break;
case PUBLIC:
if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
parser.addParserWarning(""String_Node_Str"",lineno,charno);
}
if (!isAnnotationNext) {
return recordDescription(token);
}
break;
case RETURN:
if (type == null) {
type=createJSTypeExpression(newNode(Token.QMARK));
}
if (!jsdocBuilder.recordReturnType(type)) {
parser.addTypeWarning(""String_Node_Str"",lineno,charno);
break;
}
if (jsdocBuilder.shouldParseDocumentation() && !isAnnotationNext) {
ExtractionInfo returnDescriptionInfo=extractMultilineTextualBlock(token);
String returnDescription=returnDescriptionInfo.string;
if (returnDescription.length() > 0) {
jsdocBuilder.recordReturnDescription(returnDescription);
}
token=returnDescriptionInfo.token;
}
 else {
token=eatUntilEOLIfNotAnnotation();
}
return token;
case THIS:
if (!jsdocBuilder.recordThisType(type)) {
parser.addTypeWarning(""String_Node_Str"",lineno,charno);
}
break;
case TYPEDEF:
if (!jsdocBuilder.recordTypedef(type)) {
parser.addTypeWarning(""String_Node_Str"",lineno,charno);
}
break;
}
}
return eatUntilEOLIfNotAnnotation();
}
}
return next();
}","private JsDocToken parseAnnotation(JsDocToken token,List<ExtendedTypeInfo> extendedTypes){
  JSTypeExpression type;
  int lineno=stream.getLineno();
  int charno=stream.getCharno();
  String annotationName=stream.getString();
  Annotation annotation=annotationNames.get(annotationName);
  if (annotation == null) {
    parser.addParserWarning(""String_Node_Str"",annotationName,stream.getLineno(),stream.getCharno());
  }
 else {
    jsdocBuilder.markAnnotation(annotationName,lineno,charno);
switch (annotation) {
case NG_INJECT:
      if (jsdocBuilder.isNgInjectRecorded()) {
        parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
      }
 else {
        jsdocBuilder.recordNgInject(true);
      }
    return eatUntilEOLIfNotAnnotation();
case JAGGER_INJECT:
  if (jsdocBuilder.isJaggerInjectRecorded()) {
    parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
  }
 else {
    jsdocBuilder.recordJaggerInject(true);
  }
return eatUntilEOLIfNotAnnotation();
case JAGGER_MODULE:
if (jsdocBuilder.isJaggerModuleRecorded()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
 else {
jsdocBuilder.recordJaggerModule(true);
}
return eatUntilEOLIfNotAnnotation();
case JAGGER_PROVIDE:
if (jsdocBuilder.isJaggerProvideRecorded()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
 else {
jsdocBuilder.recordJaggerProvide(true);
}
return eatUntilEOLIfNotAnnotation();
case JAGGER_PROVIDE_PROMISE:
if (jsdocBuilder.isJaggerProvidePromiseRecorded()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
 else {
jsdocBuilder.recordJaggerProvidePromise(true);
}
return eatUntilEOLIfNotAnnotation();
case AUTHOR:
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo authorInfo=extractSingleLineBlock();
String author=authorInfo.string;
if (author.isEmpty()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
 else {
jsdocBuilder.addAuthor(author);
}
token=authorInfo.token;
}
 else {
token=eatUntilEOLIfNotAnnotation();
}
return token;
case CONSISTENTIDGENERATOR:
if (!jsdocBuilder.recordConsistentIdGenerator()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case UNRESTRICTED:
if (!jsdocBuilder.recordUnrestricted()) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case STRUCT:
if (!jsdocBuilder.recordStruct()) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case DICT:
if (!jsdocBuilder.recordDict()) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case CONSTRUCTOR:
if (!jsdocBuilder.recordConstructor()) {
if (jsdocBuilder.isInterfaceRecorded()) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
 else {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
}
return eatUntilEOLIfNotAnnotation();
case DEPRECATED:
if (!jsdocBuilder.recordDeprecated()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
ExtractionInfo reasonInfo=extractMultilineTextualBlock(token);
String reason=reasonInfo.string;
if (reason.length() > 0) {
jsdocBuilder.recordDeprecationReason(reason);
}
token=reasonInfo.token;
return token;
case INTERFACE:
if (!jsdocBuilder.recordInterface()) {
if (jsdocBuilder.isConstructorRecorded()) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
 else {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
}
return eatUntilEOLIfNotAnnotation();
case DESC:
if (jsdocBuilder.isDescriptionRecorded()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
return eatUntilEOLIfNotAnnotation();
}
 else {
ExtractionInfo descriptionInfo=extractMultilineTextualBlock(token);
String description=descriptionInfo.string;
jsdocBuilder.recordDescription(description);
token=descriptionInfo.token;
return token;
}
case FILE_OVERVIEW:
String fileOverview=""String_Node_Str"";
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo fileOverviewInfo=extractMultilineTextualBlock(token,WhitespaceOption.TRIM);
fileOverview=fileOverviewInfo.string;
token=fileOverviewInfo.token;
}
 else {
token=eatTokensUntilEOL(token);
}
if (!jsdocBuilder.recordFileOverview(fileOverview)) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return token;
case LICENSE:
case PRESERVE:
ExtractionInfo preserveInfo=extractMultilineTextualBlock(token,WhitespaceOption.PRESERVE);
String preserve=preserveInfo.string;
if (preserve.length() > 0) {
if (fileLevelJsDocBuilder != null) {
fileLevelJsDocBuilder.append(preserve);
}
}
token=preserveInfo.token;
return token;
case ENUM:
token=next();
lineno=stream.getLineno();
charno=stream.getCharno();
type=null;
if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
type=createJSTypeExpression(parseAndRecordTypeNode(token));
}
if (type == null) {
type=createJSTypeExpression(newStringNode(""String_Node_Str""));
}
if (!jsdocBuilder.recordEnumParameterType(type)) {
parser.addTypeWarning(""String_Node_Str"",lineno,charno);
}
token=eatUntilEOLIfNotAnnotation(token);
return token;
case EXPORT:
if (!jsdocBuilder.recordExport()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case EXPOSE:
if (!jsdocBuilder.recordExpose()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case EXTERNS:
if (!jsdocBuilder.recordExterns()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case JAVA_DISPATCH:
if (!jsdocBuilder.recordJavaDispatch()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case EXTENDS:
case IMPLEMENTS:
skipEOLs();
token=next();
lineno=stream.getLineno();
charno=stream.getCharno();
boolean matchingRc=false;
if (token == JsDocToken.LC) {
token=next();
matchingRc=true;
}
if (token == JsDocToken.STRING) {
Node typeNode=parseAndRecordTypeNameNode(token,lineno,charno,matchingRc);
lineno=stream.getLineno();
charno=stream.getCharno();
typeNode=wrapNode(Token.BANG,typeNode);
type=createJSTypeExpression(typeNode);
if (annotation == Annotation.EXTENDS) {
extendedTypes.add(new ExtendedTypeInfo(type,stream.getLineno(),stream.getCharno()));
}
 else {
Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
if (!jsdocBuilder.recordImplementedInterface(type)) {
parser.addTypeWarning(""String_Node_Str"",lineno,charno);
}
}
token=next();
if (matchingRc) {
if (token != JsDocToken.RC) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
 else {
token=next();
}
}
 else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
}
 else {
parser.addTypeWarning(""String_Node_Str"",lineno,charno);
}
token=eatUntilEOLIfNotAnnotation(token);
return token;
case HIDDEN:
if (!jsdocBuilder.recordHiddenness()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case LENDS:
skipEOLs();
matchingRc=false;
if (match(JsDocToken.LC)) {
token=next();
matchingRc=true;
}
if (match(JsDocToken.STRING)) {
token=next();
if (!jsdocBuilder.recordLends(stream.getString())) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
}
 else {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
if (matchingRc && !match(JsDocToken.RC)) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case MEANING:
ExtractionInfo meaningInfo=extractMultilineTextualBlock(token);
String meaning=meaningInfo.string;
token=meaningInfo.token;
if (!jsdocBuilder.recordMeaning(meaning)) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return token;
case NO_ALIAS:
if (!jsdocBuilder.recordNoAlias()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case NO_COMPILE:
if (!jsdocBuilder.recordNoCompile()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case NO_TYPE_CHECK:
if (!jsdocBuilder.recordNoTypeCheck()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case NOT_IMPLEMENTED:
return eatUntilEOLIfNotAnnotation();
case INHERIT_DOC:
case OVERRIDE:
if (!jsdocBuilder.recordOverride()) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case THROWS:
{
skipEOLs();
token=next();
lineno=stream.getLineno();
charno=stream.getCharno();
type=null;
if (token == JsDocToken.LC) {
type=createJSTypeExpression(parseAndRecordTypeNode(token));
if (type == null) {
return eatUntilEOLIfNotAnnotation();
}
}
token=current();
jsdocBuilder.recordThrowType(type);
boolean isAnnotationNext=lookAheadForAnnotation();
if (jsdocBuilder.shouldParseDocumentation() && !isAnnotationNext) {
ExtractionInfo descriptionInfo=extractMultilineTextualBlock(token);
String description=descriptionInfo.string;
if (description.length() > 0) {
jsdocBuilder.recordThrowDescription(type,description);
}
token=descriptionInfo.token;
}
 else {
token=eatUntilEOLIfNotAnnotation();
}
return token;
}
case PARAM:
skipEOLs();
token=next();
lineno=stream.getLineno();
charno=stream.getCharno();
type=null;
if (token == JsDocToken.LC) {
type=createJSTypeExpression(parseAndRecordParamTypeNode(token));
if (type == null) {
return eatUntilEOLIfNotAnnotation();
}
skipEOLs();
token=next();
lineno=stream.getLineno();
charno=stream.getCharno();
}
String name=null;
boolean isBracketedParam=JsDocToken.LB == token;
if (isBracketedParam) {
token=next();
}
if (JsDocToken.STRING != token) {
parser.addTypeWarning(""String_Node_Str"",lineno,charno);
}
 else {
name=stream.getString();
if (isBracketedParam) {
token=next();
if (JsDocToken.EQUALS == token) {
token=next();
if (JsDocToken.STRING == token) {
token=next();
}
}
if (JsDocToken.RB != token) {
reportTypeSyntaxWarning(""String_Node_Str"");
}
 else if (type != null) {
type=JSTypeExpression.makeOptionalArg(type);
}
}
if (name.indexOf('.') > -1) {
name=null;
}
 else if (!jsdocBuilder.recordParameter(name,type)) {
if (jsdocBuilder.hasParameter(name)) {
parser.addTypeWarning(""String_Node_Str"",name,lineno,charno);
}
 else {
parser.addTypeWarning(""String_Node_Str"",name,lineno,charno);
}
}
}
if (name == null) {
token=eatUntilEOLIfNotAnnotation(token);
return token;
}
jsdocBuilder.markName(name,sourceFile,lineno,charno);
if (jsdocBuilder.shouldParseDocumentation() && token != JsDocToken.ANNOTATION) {
ExtractionInfo paramDescriptionInfo=extractMultilineTextualBlock(token);
String paramDescription=paramDescriptionInfo.string;
if (paramDescription.length() > 0) {
jsdocBuilder.recordParameterDescription(name,paramDescription);
}
token=paramDescriptionInfo.token;
}
 else if (token != JsDocToken.EOC && token != JsDocToken.EOF) {
token=eatUntilEOLIfNotAnnotation();
}
return token;
case PRESERVE_TRY:
if (!jsdocBuilder.recordPreserveTry()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case NO_SHADOW:
if (!jsdocBuilder.recordNoShadow()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case NO_SIDE_EFFECTS:
if (!jsdocBuilder.recordNoSideEffects()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case MODIFIES:
token=parseModifiesTag(next());
return token;
case IMPLICIT_CAST:
if (!jsdocBuilder.recordImplicitCast()) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case SEE:
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo referenceInfo=extractSingleLineBlock();
String reference=referenceInfo.string;
if (reference.isEmpty()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
 else {
jsdocBuilder.addReference(reference);
}
token=referenceInfo.token;
}
 else {
token=eatUntilEOLIfNotAnnotation();
}
return token;
case STABLEIDGENERATOR:
if (!jsdocBuilder.recordStableIdGenerator()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case SUPPRESS:
token=parseSuppressTag(next());
return token;
case TEMPLATE:
{
ExtractionInfo templateInfo=extractSingleLineBlock();
boolean isTypeTransformation=false;
String templateNames;
String typeTransformationStart=""String_Node_Str"";
if (templateInfo.string.contains(""String_Node_Str"")) {
isTypeTransformation=true;
int typeTransformationIndex=templateInfo.string.indexOf(""String_Node_Str"");
templateNames=templateInfo.string.substring(0,typeTransformationIndex);
typeTransformationStart=templateInfo.string.substring(typeTransformationIndex + 3);
}
 else {
templateNames=templateInfo.string;
}
List<String> names=Lists.newArrayList(Splitter.on(',').trimResults().split(templateNames));
if (names.size() == 1 && names.get(0).isEmpty()) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
 else {
for (String typeName : names) {
if (!validTemplateTypeName(typeName)) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
 else if (!jsdocBuilder.recordTemplateTypeName(typeName)) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
}
}
if (isTypeTransformation) {
if (names.size() > 1) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
ExtractionInfo typeTransformationInfo=extractMultilineTextualBlock(templateInfo.token);
String typeTransformationEnd=typeTransformationInfo.string;
String typeTransformationString=typeTransformationStart + typeTransformationEnd;
if (typeTransformationString.equals(""String_Node_Str"")) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
token=typeTransformationInfo.token;
}
 else {
token=templateInfo.token;
}
return token;
}
case IDGENERATOR:
token=parseIdGeneratorTag(next());
return token;
case WIZACTION:
if (!jsdocBuilder.recordWizaction()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case DISPOSES:
{
ExtractionInfo templateInfo=extractSingleLineBlock();
List<String> names=Lists.newArrayList(Splitter.on(',').trimResults().split(templateInfo.string));
if (names.isEmpty() || names.get(0).isEmpty()) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
 else if (!jsdocBuilder.recordDisposesParameter(names)) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
token=templateInfo.token;
return token;
}
case VERSION:
ExtractionInfo versionInfo=extractSingleLineBlock();
String version=versionInfo.string;
if (version.isEmpty()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
 else {
if (!jsdocBuilder.recordVersion(version)) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
}
token=versionInfo.token;
return token;
case CONSTANT:
case DEFINE:
case RETURN:
case PACKAGE:
case PRIVATE:
case PROTECTED:
case PUBLIC:
case THIS:
case TYPE:
case TYPEDEF:
lineno=stream.getLineno();
charno=stream.getCharno();
Node typeNode=null;
boolean hasType=lookAheadForType();
boolean isAlternateTypeAnnotation=(annotation == Annotation.PACKAGE || annotation == Annotation.PRIVATE || annotation == Annotation.PROTECTED || annotation == Annotation.PUBLIC || annotation == Annotation.CONSTANT);
boolean canSkipTypeAnnotation=(isAlternateTypeAnnotation || annotation == Annotation.RETURN);
type=null;
if (hasType || !canSkipTypeAnnotation) {
skipEOLs();
token=next();
typeNode=parseAndRecordTypeNode(token);
if (annotation == Annotation.THIS) {
typeNode=wrapNode(Token.BANG,typeNode);
}
type=createJSTypeExpression(typeNode);
}
boolean hasError=type == null && !canSkipTypeAnnotation;
if (!hasError) {
if ((type != null && isAlternateTypeAnnotation) || annotation == Annotation.TYPE) {
if (!jsdocBuilder.recordType(type)) {
parser.addTypeWarning(""String_Node_Str"",lineno,charno);
}
}
boolean isAnnotationNext=lookAheadForAnnotation();
switch (annotation) {
case CONSTANT:
if (!jsdocBuilder.recordConstancy()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
break;
case DEFINE:
if (!jsdocBuilder.recordDefineType(type)) {
parser.addParserWarning(""String_Node_Str"",lineno,charno);
}
if (!isAnnotationNext) {
return recordDescription(token);
}
break;
case PRIVATE:
if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
parser.addParserWarning(""String_Node_Str"",lineno,charno);
}
if (!isAnnotationNext) {
return recordDescription(token);
}
break;
case PACKAGE:
if (!jsdocBuilder.recordVisibility(Visibility.PACKAGE)) {
parser.addParserWarning(""String_Node_Str"",lineno,charno);
}
if (!isAnnotationNext) {
return recordDescription(token);
}
break;
case PROTECTED:
if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
parser.addParserWarning(""String_Node_Str"",lineno,charno);
}
if (!isAnnotationNext) {
return recordDescription(token);
}
break;
case PUBLIC:
if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
parser.addParserWarning(""String_Node_Str"",lineno,charno);
}
if (!isAnnotationNext) {
return recordDescription(token);
}
break;
case RETURN:
if (type == null) {
type=createJSTypeExpression(newNode(Token.QMARK));
}
if (!jsdocBuilder.recordReturnType(type)) {
parser.addTypeWarning(""String_Node_Str"",lineno,charno);
break;
}
if (jsdocBuilder.shouldParseDocumentation() && !isAnnotationNext) {
ExtractionInfo returnDescriptionInfo=extractMultilineTextualBlock(token);
String returnDescription=returnDescriptionInfo.string;
if (returnDescription.length() > 0) {
jsdocBuilder.recordReturnDescription(returnDescription);
}
token=returnDescriptionInfo.token;
}
 else {
token=eatUntilEOLIfNotAnnotation();
}
return token;
case THIS:
if (!jsdocBuilder.recordThisType(type)) {
parser.addTypeWarning(""String_Node_Str"",lineno,charno);
}
break;
case TYPEDEF:
if (!jsdocBuilder.recordTypedef(type)) {
parser.addTypeWarning(""String_Node_Str"",lineno,charno);
}
break;
}
}
return eatUntilEOLIfNotAnnotation();
}
}
return next();
}",0.9654600866171202
27729,"public void testParserWithTypeTransformationNewline(){
  parse(""String_Node_Str"");
}","public void testParserWithTypeTransformationNewline(){
  parse(""String_Node_Str"",""String_Node_Str"");
}",0.9032258064516128
27730,"@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (n.isCall() && !NodeUtil.isExpressionResultUsed(n) && (n.getFirstChild().isName() || n.getFirstChild().isString())) {
    JSType targetType=n.getFirstChild().getJSType();
    if (targetType != null && targetType.isFunctionType()) {
      targetType=targetType.restrictByNotNullOrUndefined();
      FunctionType functionType=targetType.toMaybeFunctionType();
      JSDocInfo functionJSDocInfo=functionType.getJSDocInfo();
      if (functionJSDocInfo != null && functionJSDocInfo.isNoSideEffects() && functionJSDocInfo.getAssociatedNode() != null && functionJSDocInfo.getAssociatedNode().isFromExterns()) {
        t.getCompiler().report(t.makeError(n,level,USELESS_CODE_ERROR,n.getFirstChild().getString()));
        problemNodes.add(n);
      }
    }
  }
}","@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (n.isCall() && !NodeUtil.isExpressionResultUsed(n) && (n.getFirstChild().isName() || n.getFirstChild().isString() || n.getFirstChild().isGetProp())) {
    JSType targetType=n.getFirstChild().getJSType();
    if (targetType != null && targetType.isFunctionType()) {
      targetType=targetType.restrictByNotNullOrUndefined();
      FunctionType functionType=targetType.toMaybeFunctionType();
      JSDocInfo functionJSDocInfo=functionType.getJSDocInfo();
      if (functionJSDocInfo != null && functionJSDocInfo.isNoSideEffects() && functionJSDocInfo.getAssociatedNode() != null && functionJSDocInfo.getAssociatedNode().isFromExterns()) {
        t.getCompiler().report(t.makeError(n,level,USELESS_CODE_ERROR,n.getFirstChild().getQualifiedName()));
        problemNodes.add(n);
      }
    }
  }
}",0.9692671394799054
27731,"public void testUselessCode(){
  String externs=""String_Node_Str"" + ""String_Node_Str"";
  test(externs,""String_Node_Str"",""String_Node_Str"",ok,null);
  test(externs,""String_Node_Str"",""String_Node_Str"",null,e,""String_Node_Str"" + ""String_Node_Str"");
}","public void testUselessCode(){
  String externs=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  test(externs,""String_Node_Str"",""String_Node_Str"",ok,null);
  test(externs,""String_Node_Str"",""String_Node_Str"",null,e,""String_Node_Str"" + ""String_Node_Str"");
  test(externs,""String_Node_Str"",""String_Node_Str"",ok,null);
  test(externs,""String_Node_Str"",""String_Node_Str"",null,e,""String_Node_Str"" + ""String_Node_Str"");
}",0.6947960618846695
27732,"double normalizeNumber(LiteralToken token){
  String value=token.value;
  SourceRange location=token.location;
  int length=value.length();
  Preconditions.checkState(length > 0);
  Preconditions.checkState(value.charAt(0) != '-' && value.charAt(0) != '+');
  if (value.charAt(0) == '.') {
    return Double.valueOf('0' + value);
  }
 else   if (value.charAt(0) == '0' && length > 1) {
switch (value.charAt(1)) {
case '.':
      return Double.valueOf(value);
case 'b':
case 'B':
{
      if (!isEs6Mode()) {
        errorReporter.warning(BINARY_NUMBER_LITERAL_WARNING,sourceName,lineno(token.location.start),charno(token.location.start));
      }
      long v=0;
      int c=1;
      while (++c < length) {
        v=(v * 2) + binarydigit(value.charAt(c));
      }
      return Double.valueOf(v);
    }
case 'o':
case 'O':
{
    if (!isEs6Mode()) {
      errorReporter.warning(OCTAL_NUMBER_LITERAL_WARNING,sourceName,lineno(token.location.start),charno(token.location.start));
    }
    long v=0;
    int c=1;
    while (++c < length) {
      v=(v * 8) + octaldigit(value.charAt(c));
    }
    return Double.valueOf(v);
  }
case 'x':
case 'X':
{
  long v=0;
  int c=1;
  while (++c < length) {
    v=(v * 16) + hexdigit(value.charAt(c));
  }
  return Double.valueOf(v);
}
case '0':
case '1':
case '2':
case '3':
case '4':
case '5':
case '6':
case '7':
errorReporter.warning(INVALID_ES5_STRICT_OCTAL,sourceName,lineno(location.start),charno(location.start));
if (!inStrictContext()) {
long v=0;
int c=0;
while (++c < length) {
v=(v * 8) + octaldigit(value.charAt(c));
}
return Double.valueOf(v);
}
 else {
return Double.valueOf(value);
}
default :
errorReporter.error(INVALID_NUMBER_LITERAL,sourceName,lineno(location.start),charno(location.start));
return 0;
}
}
 else {
return Double.valueOf(value);
}
}","double normalizeNumber(LiteralToken token){
  String value=token.value;
  SourceRange location=token.location;
  int length=value.length();
  Preconditions.checkState(length > 0);
  Preconditions.checkState(value.charAt(0) != '-' && value.charAt(0) != '+');
  if (value.charAt(0) == '.') {
    return Double.valueOf('0' + value);
  }
 else   if (value.charAt(0) == '0' && length > 1) {
switch (value.charAt(1)) {
case '.':
case 'e':
case 'E':
      return Double.valueOf(value);
case 'b':
case 'B':
{
      if (!isEs6Mode()) {
        errorReporter.warning(BINARY_NUMBER_LITERAL_WARNING,sourceName,lineno(token.location.start),charno(token.location.start));
      }
      long v=0;
      int c=1;
      while (++c < length) {
        v=(v * 2) + binarydigit(value.charAt(c));
      }
      return Double.valueOf(v);
    }
case 'o':
case 'O':
{
    if (!isEs6Mode()) {
      errorReporter.warning(OCTAL_NUMBER_LITERAL_WARNING,sourceName,lineno(token.location.start),charno(token.location.start));
    }
    long v=0;
    int c=1;
    while (++c < length) {
      v=(v * 8) + octaldigit(value.charAt(c));
    }
    return Double.valueOf(v);
  }
case 'x':
case 'X':
{
  long v=0;
  int c=1;
  while (++c < length) {
    v=(v * 16) + hexdigit(value.charAt(c));
  }
  return Double.valueOf(v);
}
case '0':
case '1':
case '2':
case '3':
case '4':
case '5':
case '6':
case '7':
errorReporter.warning(INVALID_ES5_STRICT_OCTAL,sourceName,lineno(location.start),charno(location.start));
if (!inStrictContext()) {
long v=0;
int c=0;
while (++c < length) {
v=(v * 8) + octaldigit(value.charAt(c));
}
return Double.valueOf(v);
}
 else {
return Double.valueOf(value);
}
default :
errorReporter.error(INVALID_NUMBER_LITERAL,sourceName,lineno(location.start),charno(location.start));
return 0;
}
}
 else {
return Double.valueOf(value);
}
}",0.994484280198566
27733,"private Token scanPostZero(int beginToken){
switch (peekChar()) {
case 'b':
case 'B':
    nextChar();
  if (!isBinaryDigit(peekChar())) {
    reportError(""String_Node_Str"");
  }
skipBinaryDigits();
return new LiteralToken(TokenType.NUMBER,getTokenString(beginToken),getTokenRange(beginToken));
case 'o':
case 'O':
nextChar();
if (!isOctalDigit(peekChar())) {
reportError(""String_Node_Str"");
}
skipOctalDigits();
return new LiteralToken(TokenType.NUMBER,getTokenString(beginToken),getTokenRange(beginToken));
case 'x':
case 'X':
nextChar();
if (!isHexDigit(peekChar())) {
reportError(""String_Node_Str"");
}
skipHexDigits();
return new LiteralToken(TokenType.NUMBER,getTokenString(beginToken),getTokenRange(beginToken));
case '.':
return scanFractionalNumericLiteral(beginToken);
case '0':
case '1':
case '2':
case '3':
case '4':
case '5':
case '6':
case '7':
case '8':
case '9':
return scanPostDigit(beginToken);
default :
return new LiteralToken(TokenType.NUMBER,getTokenString(beginToken),getTokenRange(beginToken));
}
}","private Token scanPostZero(int beginToken){
switch (peekChar()) {
case 'b':
case 'B':
    nextChar();
  if (!isBinaryDigit(peekChar())) {
    reportError(""String_Node_Str"");
  }
skipBinaryDigits();
return new LiteralToken(TokenType.NUMBER,getTokenString(beginToken),getTokenRange(beginToken));
case 'o':
case 'O':
nextChar();
if (!isOctalDigit(peekChar())) {
reportError(""String_Node_Str"");
}
skipOctalDigits();
return new LiteralToken(TokenType.NUMBER,getTokenString(beginToken),getTokenRange(beginToken));
case 'x':
case 'X':
nextChar();
if (!isHexDigit(peekChar())) {
reportError(""String_Node_Str"");
}
skipHexDigits();
return new LiteralToken(TokenType.NUMBER,getTokenString(beginToken),getTokenRange(beginToken));
case 'e':
case 'E':
return scanExponentOfNumericLiteral(beginToken);
case '.':
return scanFractionalNumericLiteral(beginToken);
case '0':
case '1':
case '2':
case '3':
case '4':
case '5':
case '6':
case '7':
case '8':
case '9':
skipDecimalDigits();
if (peek('.')) {
nextChar();
skipDecimalDigits();
}
return new LiteralToken(TokenType.NUMBER,getTokenString(beginToken),getTokenRange(beginToken));
default :
return new LiteralToken(TokenType.NUMBER,getTokenString(beginToken),getTokenRange(beginToken));
}
}",0.8734402852049911
27734,"private static boolean collectObjectProperty(Node objectLiteral,Node propertyCandidate){
  Node assignment=propertyCandidate.getFirstChild();
  Node lhs=assignment.getFirstChild(), rhs=lhs.getNext();
  Node obj=lhs.getFirstChild();
  Node property=obj.getNext();
  if (lhs.isGetElem() && (!property.isString() && !property.isNumber())) {
    return false;
  }
  String propertyName;
  if (property.isNumber()) {
    propertyName=NodeUtil.getStringValue(property);
  }
 else {
    propertyName=property.getString();
  }
  Node newProperty=IR.stringKey(propertyName).copyInformationFrom(property);
  if (lhs.isGetElem()) {
    newProperty.setQuotedString();
  }
  Node newValue=rhs.detachFromParent();
  newProperty.addChildToBack(newValue);
  objectLiteral.addChildToBack(newProperty);
  propertyCandidate.detachFromParent();
  return true;
}","private static boolean collectObjectProperty(Node objectLiteral,Node propertyCandidate){
  Node assignment=propertyCandidate.getFirstChild();
  Node lhs=assignment.getFirstChild(), rhs=lhs.getNext();
  Node obj=lhs.getFirstChild();
  Node property=obj.getNext();
  if (lhs.isGetElem() && (!property.isString() && !property.isNumber())) {
    return false;
  }
  String propertyName;
  if (property.isNumber()) {
    propertyName=NodeUtil.getStringValue(property);
  }
 else {
    propertyName=property.getString();
  }
  Node newProperty=IR.stringKey(propertyName).copyInformationFrom(property);
  if (lhs.isGetElem()) {
    newProperty.setQuotedString();
  }
  Node newValue=rhs.detachFromParent();
  newProperty.addChildToBack(newValue);
  boolean propertyExists=false;
  for (  Node currentProperty : objectLiteral.children()) {
    String currentPropertyName=currentProperty.getString();
    Node currentValue=currentProperty.getFirstChild();
    if (currentPropertyName.equals(propertyName)) {
      propertyExists=true;
      boolean isCurrentValueSideEffect=NodeUtil.canBeSideEffected(currentValue);
      boolean isNewValueSideEffect=NodeUtil.canBeSideEffected(newValue);
      if (!isCurrentValueSideEffect && !isNewValueSideEffect) {
        objectLiteral.removeChild(currentProperty);
        objectLiteral.addChildToBack(newProperty);
        propertyCandidate.detachFromParent();
        return true;
      }
      break;
    }
  }
  if (!propertyExists) {
    objectLiteral.addChildToBack(newProperty);
  }
  propertyCandidate.detachFromParent();
  return true;
}",0.684863523573201
27735,"private ParseTree parseComputedProperty(){
  SourcePosition start=getTreeStartLocation();
  eat(TokenType.OPEN_SQUARE);
  ParseTree assign=parseAssignmentExpression();
  eat(TokenType.CLOSE_SQUARE);
  eat(TokenType.COLON);
  ParseTree value=parseExpression();
  return new ComputedPropertyAssignmentTree(getTreeLocation(start),assign,value);
}","private ParseTree parseComputedProperty(){
  SourcePosition start=getTreeStartLocation();
  eat(TokenType.OPEN_SQUARE);
  ParseTree assign=parseAssignmentExpression();
  eat(TokenType.CLOSE_SQUARE);
  eat(TokenType.COLON);
  ParseTree value=parseAssignmentExpression();
  return new ComputedPropertyAssignmentTree(getTreeLocation(start),assign,value);
}",0.985632183908046
27736,"static boolean areSubtypes(JSType t1,JSType t2){
  ImmutableSet<EnumType> s1=t1.getEnums();
  if (s1 == null) {
    return true;
  }
  ImmutableSet<EnumType> s2=t2.getEnums();
  for (  EnumType e : s1) {
    if (s2 != null && s2.contains(e)) {
      continue;
    }
    if (!e.getEnumeratedType().isSubtypeOf(t2)) {
      return false;
    }
  }
  return true;
}","static boolean areSubtypes(JSType t1,JSType t2){
  ImmutableSet<EnumType> s1=t1.getEnums();
  if (s1 == null) {
    return true;
  }
  ImmutableSet<EnumType> s2=t2.getEnums();
  for (  EnumType e : s1) {
    if (s2 != null && s2.contains(e)) {
      continue;
    }
    if (!e.declaredType.isSubtypeOf(t2)) {
      return false;
    }
  }
  return true;
}",0.9595536959553695
27737,"static ImmutableSet<EnumType> normalizeForJoin(ImmutableSet<EnumType> newEnums,JSType joinWithoutEnums){
  boolean recreateEnums=false;
  for (  EnumType e : newEnums) {
    if (e.getEnumeratedType().isSubtypeOf(joinWithoutEnums)) {
      recreateEnums=true;
      break;
    }
  }
  if (!recreateEnums) {
    return newEnums;
  }
  ImmutableSet.Builder<EnumType> builder=ImmutableSet.builder();
  for (  EnumType e : newEnums) {
    if (!e.getEnumeratedType().isSubtypeOf(joinWithoutEnums)) {
      builder.add(e);
    }
  }
  return builder.build();
}","static ImmutableSet<EnumType> normalizeForJoin(ImmutableSet<EnumType> newEnums,JSType joinWithoutEnums){
  boolean recreateEnums=false;
  for (  EnumType e : newEnums) {
    if (e.declaredType.isSubtypeOf(joinWithoutEnums)) {
      recreateEnums=true;
      break;
    }
  }
  if (!recreateEnums) {
    return newEnums;
  }
  ImmutableSet.Builder<EnumType> builder=ImmutableSet.builder();
  for (  EnumType e : newEnums) {
    if (!e.declaredType.isSubtypeOf(joinWithoutEnums)) {
      builder.add(e);
    }
  }
  return builder.build();
}",0.9432234432234432
27738,"/** 
 * Turns the class-less object of this type (if any) into a loose object 
 */
public JSType withLoose(){
  Preconditions.checkNotNull(this.objs);
  return new JSType(this.mask,this.location,ObjectType.withLooseObjects(this.objs),typeVar,enums);
}","/** 
 * Turns the class-less object of this type (if any) into a loose object 
 */
public JSType withLoose(){
  if (objs == null) {
    Preconditions.checkState(enums != null);
    return this;
  }
  return new JSType(this.mask,this.location,ObjectType.withLooseObjects(this.objs),typeVar,enums);
}",0.8524590163934426
27739,"public JSType removeType(JSType other){
  if (isUnknown()) {
    return this;
  }
  int otherMask=other.mask;
  if (isTop()) {
    if ((otherMask & NON_SCALAR_MASK) == 0 && (otherMask & TYPEVAR_MASK) == 0 && (otherMask & ENUM_MASK) == 0) {
      return ALMOST_TOP.removeType(other);
    }
    return this;
  }
  if ((otherMask & NON_SCALAR_MASK) == 0 && (otherMask & TYPEVAR_MASK) == 0 && (otherMask & ENUM_MASK) == 0) {
    return new JSType(mask & ~otherMask,location,objs,typeVar,enums);
  }
  if (objs == null || (otherMask & ~NON_SCALAR_MASK) != 0) {
    return this;
  }
  Preconditions.checkState(otherMask == NON_SCALAR_MASK && other.objs.size() == 1,""String_Node_Str"" + other);
  NominalType otherKlass=Iterables.getOnlyElement(other.objs).getNominalType();
  ImmutableSet.Builder<ObjectType> newObjs=ImmutableSet.builder();
  for (  ObjectType obj : objs) {
    if (!Objects.equal(obj.getNominalType(),otherKlass)) {
      newObjs.add(obj);
    }
  }
  return new JSType(mask,location,newObjs.build(),typeVar,enums);
}","public JSType removeType(JSType other){
  int otherMask=other.mask;
  Preconditions.checkState(!other.isTop() && !other.isUnknown() && (otherMask & TYPEVAR_MASK) == 0 && (otherMask & ENUM_MASK) == 0);
  if (isUnknown()) {
    return this;
  }
  if (isTop()) {
    return ALMOST_TOP.removeType(other);
  }
  int newMask=mask & ~otherMask;
  if ((otherMask & NON_SCALAR_MASK) == 0) {
    return new JSType(newMask,location,objs,typeVar,enums);
  }
  Preconditions.checkState(other.objs.size() == 1,""String_Node_Str"",other);
  ObjectType otherObj=Iterables.getOnlyElement(other.objs);
  ImmutableSet<ObjectType> newObjs=null;
  ImmutableSet<EnumType> newEnums=null;
  if (objs != null) {
    ImmutableSet.Builder<ObjectType> builder=ImmutableSet.builder();
    for (    ObjectType obj : objs) {
      if (!obj.isSubtypeOf(otherObj)) {
        builder.add(obj);
      }
    }
    newObjs=builder.build();
  }
  if (enums != null) {
    ImmutableSet.Builder<EnumType> builder=ImmutableSet.builder();
    for (    EnumType e : enums) {
      if (!e.getEnumeratedType().isSubtypeOf(other)) {
        builder.add(e);
      }
    }
    newEnums=builder.build();
  }
  return new JSType(newMask,location,newObjs,typeVar,newEnums);
}",0.2817777777777778
27740,"public boolean hasNonScalar(){
  return objs != null;
}","public boolean hasNonScalar(){
  return objs != null || EnumType.hasNonScalar(enums);
}",0.7746478873239436
27741,"public void testInstanceof(){
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"",VarCheck.UNDEFINED_VAR_ERROR);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"",ImmutableList.of(NewTypeInference.INVALID_OPERAND_TYPE,NewTypeInference.PROPERTY_ACCESS_ON_NONOBJECT));
}","public void testInstanceof(){
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"",VarCheck.UNDEFINED_VAR_ERROR);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"",ImmutableList.of(NewTypeInference.INVALID_OPERAND_TYPE,NewTypeInference.PROPERTY_ACCESS_ON_NONOBJECT));
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.8807579222476315
27742,"public void testEnumsWithNonScalarDeclaredType(){
  typeCheck(""String_Node_Str"" + ""String_Node_Str"",TypeCheck.INEXISTENT_PROPERTY);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.CONST_REASSIGNED);
}","public void testEnumsWithNonScalarDeclaredType(){
  typeCheck(""String_Node_Str"" + ""String_Node_Str"",TypeCheck.INEXISTENT_PROPERTY);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.CONST_REASSIGNED);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.905996758508914
27743,"public void testTypeof(){
  typeCheck(""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"",TypeValidator.UNKNOWN_TYPEOF_VALUE);
  typeCheck(""String_Node_Str"",TypeValidator.UNKNOWN_TYPEOF_VALUE);
}","public void testTypeof(){
  typeCheck(""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"",TypeValidator.UNKNOWN_TYPEOF_VALUE);
  typeCheck(""String_Node_Str"",TypeValidator.UNKNOWN_TYPEOF_VALUE);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9517931609674728
27744,"public JSType negate(){
  if (isTop() || isUnknown()) {
    return this;
  }
  if (isTruthy()) {
    return FALSY;
  }
 else   if (isFalsy()) {
    return TRUTHY;
  }
 else   if (objs == null && typeVar == null) {
    return new JSType(TOP_SCALAR_MASK & ~mask);
  }
  return UNKNOWN;
}","public JSType negate(){
  if (isTop() || isUnknown()) {
    return this;
  }
  if (isTruthy()) {
    return FALSY;
  }
 else   if (isFalsy()) {
    return TRUTHY;
  }
  return UNKNOWN.removeType(this);
}",0.75
27745,"public void testTypeof(){
  typeCheck(""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"",TypeValidator.UNKNOWN_TYPEOF_VALUE);
  typeCheck(""String_Node_Str"",TypeValidator.UNKNOWN_TYPEOF_VALUE);
}","public void testTypeof(){
  typeCheck(""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"",TypeValidator.UNKNOWN_TYPEOF_VALUE);
  typeCheck(""String_Node_Str"",TypeValidator.UNKNOWN_TYPEOF_VALUE);
}",0.954603933100533
27746,"private EnvTypePair analyzeSpecializedTypeof(Node typeof,Node typeString,int comparisonOp,TypeEnv inEnv,JSType specializedType){
  EnvTypePair pair;
  Node typeofRand=typeof.getFirstChild();
  JSType comparedType=getTypeFromString(typeString);
  checkInvalidTypename(typeString);
  if (comparedType.isUnknown()) {
    pair=analyzeExprFwd(typeofRand,inEnv);
    pair=analyzeExprFwd(typeString,pair.env);
  }
 else   if ((specializedType.isTruthy() && (comparisonOp == Token.SHEQ || comparisonOp == Token.EQ)) || (specializedType.isFalsy() && (comparisonOp == Token.SHNE || comparisonOp == Token.NE))) {
    pair=analyzeExprFwd(typeofRand,inEnv,JSType.UNKNOWN,comparedType);
  }
 else {
    pair=analyzeExprFwd(typeofRand,inEnv,JSType.UNKNOWN,comparedType.negate());
  }
  pair.type=specializedType.toBoolean();
  return pair;
}","private EnvTypePair analyzeSpecializedTypeof(Node typeof,Node typeString,int comparisonOp,TypeEnv inEnv,JSType specializedType){
  EnvTypePair pair;
  Node typeofRand=typeof.getFirstChild();
  JSType comparedType=getTypeFromString(typeString);
  checkInvalidTypename(typeString);
  if (comparedType.isUnknown()) {
    pair=analyzeExprFwd(typeofRand,inEnv);
    pair=analyzeExprFwd(typeString,pair.env);
  }
 else   if ((specializedType.isTruthy() && (comparisonOp == Token.SHEQ || comparisonOp == Token.EQ)) || (specializedType.isFalsy() && (comparisonOp == Token.SHNE || comparisonOp == Token.NE))) {
    pair=analyzeExprFwd(typeofRand,inEnv,JSType.UNKNOWN,comparedType);
  }
 else {
    pair=analyzeExprFwd(typeofRand,inEnv);
    pair=analyzeExprFwd(typeofRand,inEnv,JSType.UNKNOWN,pair.type.removeType(comparedType));
  }
  pair.type=specializedType.toBoolean();
  return pair;
}",0.9437939110070258
27747,"private EnvTypePair analyzeNonStrictComparisonFwd(Node expr,TypeEnv inEnv,JSType specializedType){
  int tokenType=expr.getType();
  Node lhs=expr.getFirstChild();
  Node rhs=expr.getLastChild();
  if ((specializedType.isTruthy() || specializedType.isFalsy()) && (lhs.isTypeOf() || rhs.isTypeOf())) {
    if (lhs.isTypeOf()) {
      return analyzeSpecializedTypeof(lhs,rhs,tokenType,inEnv,specializedType);
    }
 else {
      return analyzeSpecializedTypeof(rhs,lhs,tokenType,inEnv,specializedType);
    }
  }
  EnvTypePair lhsPair=analyzeExprFwd(lhs,inEnv);
  EnvTypePair rhsPair=analyzeExprFwd(rhs,lhsPair.env);
  JSType lhsType=lhsPair.type;
  JSType rhsType=rhsPair.type;
  if (tokenType == Token.EQ && specializedType.isTruthy() || tokenType == Token.NE && specializedType.isFalsy()) {
    if (lhsType.isNullOrUndef()) {
      rhsPair=analyzeExprFwd(rhs,lhsPair.env,JSType.UNKNOWN,JSType.NULL_OR_UNDEF);
    }
 else     if (rhsType.isNullOrUndef()) {
      lhsPair=analyzeExprFwd(lhs,inEnv,JSType.UNKNOWN,JSType.NULL_OR_UNDEF);
      rhsPair=analyzeExprFwd(rhs,lhsPair.env);
    }
 else     if (!JSType.NULL_OR_UNDEF.isSubtypeOf(lhsType)) {
      rhsType=rhsType.removeType(JSType.NULL).removeType(JSType.UNDEFINED);
      rhsPair=analyzeExprFwd(rhs,lhsPair.env,JSType.UNKNOWN,rhsType);
    }
 else     if (!JSType.NULL_OR_UNDEF.isSubtypeOf(rhsType)) {
      lhsType=lhsType.removeType(JSType.NULL).removeType(JSType.UNDEFINED);
      lhsPair=analyzeExprFwd(lhs,inEnv,JSType.UNKNOWN,lhsType);
      rhsPair=analyzeExprFwd(rhs,lhsPair.env);
    }
  }
 else   if (tokenType == Token.EQ && specializedType.isFalsy() || tokenType == Token.NE && specializedType.isTruthy()) {
    if (lhsType.isNullOrUndef()) {
      rhsType=rhsType.removeType(JSType.NULL).removeType(JSType.UNDEFINED);
      rhsPair=analyzeExprFwd(rhs,lhsPair.env,JSType.UNKNOWN,rhsType);
    }
 else     if (rhsType.isNullOrUndef()) {
      lhsType=lhsType.removeType(JSType.NULL).removeType(JSType.UNDEFINED);
      lhsPair=analyzeExprFwd(lhs,inEnv,JSType.UNKNOWN,lhsType);
      rhsPair=analyzeExprFwd(rhs,lhsPair.env);
    }
  }
  rhsPair.type=JSType.BOOLEAN;
  return rhsPair;
}","private EnvTypePair analyzeNonStrictComparisonFwd(Node expr,TypeEnv inEnv,JSType specializedType){
  int tokenType=expr.getType();
  Node lhs=expr.getFirstChild();
  Node rhs=expr.getLastChild();
  if ((specializedType.isTruthy() || specializedType.isFalsy()) && (lhs.isTypeOf() || rhs.isTypeOf())) {
    if (lhs.isTypeOf()) {
      return analyzeSpecializedTypeof(lhs,rhs,tokenType,inEnv,specializedType);
    }
 else {
      return analyzeSpecializedTypeof(rhs,lhs,tokenType,inEnv,specializedType);
    }
  }
  EnvTypePair lhsPair=analyzeExprFwd(lhs,inEnv);
  EnvTypePair rhsPair=analyzeExprFwd(rhs,lhsPair.env);
  JSType lhsType=lhsPair.type;
  JSType rhsType=rhsPair.type;
  if (tokenType == Token.EQ && specializedType.isTruthy() || tokenType == Token.NE && specializedType.isFalsy()) {
    if (lhsType.isNullOrUndef()) {
      rhsPair=analyzeExprFwd(rhs,lhsPair.env,JSType.UNKNOWN,JSType.NULL_OR_UNDEF);
    }
 else     if (rhsType.isNullOrUndef()) {
      lhsPair=analyzeExprFwd(lhs,inEnv,JSType.UNKNOWN,JSType.NULL_OR_UNDEF);
      rhsPair=analyzeExprFwd(rhs,lhsPair.env);
    }
 else     if (!JSType.NULL_OR_UNDEF.isSubtypeOf(lhsType)) {
      rhsType=rhsType.removeType(JSType.NULL_OR_UNDEF);
      rhsPair=analyzeExprFwd(rhs,lhsPair.env,JSType.UNKNOWN,rhsType);
    }
 else     if (!JSType.NULL_OR_UNDEF.isSubtypeOf(rhsType)) {
      lhsType=lhsType.removeType(JSType.NULL_OR_UNDEF);
      lhsPair=analyzeExprFwd(lhs,inEnv,JSType.UNKNOWN,lhsType);
      rhsPair=analyzeExprFwd(rhs,lhsPair.env);
    }
  }
 else   if (tokenType == Token.EQ && specializedType.isFalsy() || tokenType == Token.NE && specializedType.isTruthy()) {
    if (lhsType.isNullOrUndef()) {
      rhsType=rhsType.removeType(JSType.NULL_OR_UNDEF);
      rhsPair=analyzeExprFwd(rhs,lhsPair.env,JSType.UNKNOWN,rhsType);
    }
 else     if (rhsType.isNullOrUndef()) {
      lhsType=lhsType.removeType(JSType.NULL_OR_UNDEF);
      lhsPair=analyzeExprFwd(lhs,inEnv,JSType.UNKNOWN,lhsType);
      rhsPair=analyzeExprFwd(rhs,lhsPair.env);
    }
  }
  rhsPair.type=JSType.BOOLEAN;
  return rhsPair;
}",0.9071969696969696
27748,"private EnvTypePair analyzeCallNodeArgumentsFwd(Node callNode,TypeEnv inEnv){
  TypeEnv env=inEnv;
  for (Node arg=callNode.getFirstChild(); arg != null; arg=arg.getNext()) {
    env=analyzeExprFwd(arg,env).env;
  }
  return new EnvTypePair(env,JSType.UNKNOWN);
}","private EnvTypePair analyzeCallNodeArgumentsFwd(Node callNode,TypeEnv inEnv){
  TypeEnv env=inEnv;
  for (Node arg=callNode.getFirstChild().getNext(); arg != null; arg=arg.getNext()) {
    env=analyzeExprFwd(arg,env).env;
  }
  return new EnvTypePair(env,JSType.UNKNOWN);
}",0.9813432835820896
27749,"public JSType removeType(JSType other){
  if ((isTop() || isUnknown()) && other.equals(NULL)) {
    return TOP_MINUS_NULL;
  }
  if ((isTop() || isUnknown()) && other.equals(UNDEFINED)) {
    return TOP_MINUS_UNDEF;
  }
  if (other.equals(NULL) || other.equals(UNDEFINED)) {
    return new JSType(mask & ~other.mask,location,objs,typeVar,enums);
  }
  if (objs == null) {
    return this;
  }
  Preconditions.checkState((other.mask & ~NON_SCALAR_MASK) == 0 && other.objs.size() == 1);
  NominalType otherKlass=Iterables.getOnlyElement(other.objs).getNominalType();
  ImmutableSet.Builder<ObjectType> newObjs=ImmutableSet.builder();
  for (  ObjectType obj : objs) {
    if (!Objects.equal(obj.getNominalType(),otherKlass)) {
      newObjs.add(obj);
    }
  }
  return new JSType(mask,location,newObjs.build(),typeVar,enums);
}","public JSType removeType(JSType other){
  if (isUnknown()) {
    return this;
  }
  int otherMask=other.mask;
  if (isTop()) {
    if ((otherMask & NON_SCALAR_MASK) == 0 && (otherMask & TYPEVAR_MASK) == 0 && (otherMask & ENUM_MASK) == 0) {
      return ALMOST_TOP.removeType(other);
    }
    return this;
  }
  if ((otherMask & NON_SCALAR_MASK) == 0 && (otherMask & TYPEVAR_MASK) == 0 && (otherMask & ENUM_MASK) == 0) {
    return new JSType(mask & ~otherMask,location,objs,typeVar,enums);
  }
  if (objs == null || (otherMask & ~NON_SCALAR_MASK) != 0) {
    return this;
  }
  Preconditions.checkState(otherMask == NON_SCALAR_MASK && other.objs.size() == 1,""String_Node_Str"" + other);
  NominalType otherKlass=Iterables.getOnlyElement(other.objs).getNominalType();
  ImmutableSet.Builder<ObjectType> newObjs=ImmutableSet.builder();
  for (  ObjectType obj : objs) {
    if (!Objects.equal(obj.getNominalType(),otherKlass)) {
      newObjs.add(obj);
    }
  }
  return new JSType(mask,location,newObjs.build(),typeVar,enums);
}",0.4293419633225458
27750,"public JSType negate(){
  if (isTop() || isUnknown()) {
    return this;
  }
  if (isTruthy()) {
    return FALSY;
  }
 else   if (isFalsy()) {
    return TRUTHY;
  }
  return UNKNOWN.removeType(this);
}","public JSType negate(){
  if (isTop() || isUnknown()) {
    return this;
  }
  if (isTruthy()) {
    return FALSY;
  }
 else   if (isFalsy()) {
    return TRUTHY;
  }
  return UNKNOWN;
}",0.9562982005141388
27751,"public void testNonStringComparisons(){
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
}","public void testNonStringComparisons(){
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
}",0.962690230731468
27752,"public void testInstanceof(){
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"",VarCheck.UNDEFINED_VAR_ERROR);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"",ImmutableList.of(NewTypeInference.INVALID_OPERAND_TYPE,NewTypeInference.PROPERTY_ACCESS_ON_NONOBJECT));
}","public void testInstanceof(){
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"",VarCheck.UNDEFINED_VAR_ERROR);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"",ImmutableList.of(NewTypeInference.INVALID_OPERAND_TYPE,NewTypeInference.PROPERTY_ACCESS_ON_NONOBJECT));
}",0.9626779530588688
27753,"public void testTypeof(){
  typeCheck(""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"",TypeValidator.UNKNOWN_TYPEOF_VALUE);
  typeCheck(""String_Node_Str"",TypeValidator.UNKNOWN_TYPEOF_VALUE);
}","public void testTypeof(){
  typeCheck(""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"",TypeValidator.UNKNOWN_TYPEOF_VALUE);
  typeCheck(""String_Node_Str"",TypeValidator.UNKNOWN_TYPEOF_VALUE);
}",0.9899097185342538
27754,"private void initConfigFromFlags(String[] args,PrintStream err){
  List<String> processedArgs=processArgs(args);
  Flags.guardLevels.clear();
  isConfigValid=true;
  List<String> jsFiles=null;
  try {
    flags.parse(processedArgs);
    if (!flags.flagFile.isEmpty()) {
      processFlagFile(err);
    }
    jsFiles=flags.getJsFiles();
  }
 catch (  CmdLineException e) {
    err.println(e.getMessage());
    isConfigValid=false;
  }
catch (  IOException ioErr) {
    err.println(""String_Node_Str"" + flags.flagFile + ""String_Node_Str"");
    isConfigValid=false;
  }
  if (flags.version) {
    err.println(""String_Node_Str"" + ""String_Node_Str"" + Compiler.getReleaseVersion() + ""String_Node_Str""+ ""String_Node_Str""+ Compiler.getReleaseDate());
    err.flush();
  }
  if (flags.processCommonJsModules) {
    flags.processClosurePrimitives=true;
    flags.manageClosureDependencies=true;
    if (flags.commonJsEntryModule == null) {
      err.println(""String_Node_Str"");
      err.flush();
      isConfigValid=false;
    }
    flags.closureEntryPoint=Lists.newArrayList(ProcessCommonJSModules.toModuleName(flags.commonJsEntryModule));
  }
  if (!(flags.outputWrapper == null || flags.outputWrapper.contains(CommandLineRunner.OUTPUT_MARKER))) {
    err.println(""String_Node_Str"" + CommandLineRunner.OUTPUT_MARKER + ""String_Node_Str"");
    isConfigValid=false;
  }
  if (!isConfigValid || flags.displayHelp) {
    isConfigValid=false;
    flags.printUsage(err);
  }
 else {
    CodingConvention conv;
    if (flags.thirdParty) {
      conv=CodingConventions.getDefault();
    }
 else     if (flags.processJqueryPrimitives) {
      conv=new JqueryCodingConvention();
    }
 else {
      conv=new ClosureCodingConvention();
    }
    getCommandLineConfig().setPrintTree(flags.printTree).setPrintAst(flags.printAst).setPrintPassGraph(flags.printPassGraph).setJscompDevMode(flags.jscompDevMode).setLoggingLevel(flags.loggingLevel).setExterns(flags.externs).setJs(jsFiles).setJsOutputFile(flags.jsOutputFile).setModule(flags.module).setCodingConvention(conv).setSummaryDetailLevel(flags.summaryDetailLevel).setOutputWrapper(flags.outputWrapper).setModuleWrapper(flags.moduleWrapper).setModuleOutputPathPrefix(flags.moduleOutputPathPrefix).setCreateSourceMap(flags.createSourceMap).setSourceMapFormat(flags.sourceMapFormat).setWarningGuardSpec(Flags.getWarningGuardSpec()).setDefine(flags.define).setCharset(flags.charset).setManageClosureDependencies(flags.manageClosureDependencies).setOnlyClosureDependencies(flags.onlyClosureDependencies).setClosureEntryPoints(flags.closureEntryPoint).setOutputManifest(ImmutableList.of(flags.outputManifest)).setOutputModuleDependencies(flags.outputModuleDependencies).setAcceptConstKeyword(flags.acceptConstKeyword).setLanguageIn(flags.languageIn).setLanguageOut(flags.languageOut).setProcessCommonJSModules(flags.processCommonJsModules).setCommonJSModulePathPrefix(flags.commonJsPathPrefix).setTransformAMDToCJSModules(flags.transformAmdModules).setWarningsWhitelistFile(flags.warningsWhitelistFile).setAngularPass(flags.angularPass).setTracerMode(flags.tracerMode).setNewTypeInference(flags.useNewTypeInference);
  }
}","private void initConfigFromFlags(String[] args,PrintStream err){
  List<String> processedArgs=processArgs(args);
  Flags.guardLevels.clear();
  isConfigValid=true;
  List<String> jsFiles=null;
  try {
    flags.parse(processedArgs);
    if (!flags.flagFile.isEmpty()) {
      processFlagFile(err);
    }
    jsFiles=flags.getJsFiles();
  }
 catch (  CmdLineException e) {
    err.println(e.getMessage());
    isConfigValid=false;
  }
catch (  IOException ioErr) {
    err.println(""String_Node_Str"" + flags.flagFile + ""String_Node_Str"");
    isConfigValid=false;
  }
  if (flags.version) {
    err.println(""String_Node_Str"" + ""String_Node_Str"" + Compiler.getReleaseVersion() + ""String_Node_Str""+ ""String_Node_Str""+ Compiler.getReleaseDate());
    err.flush();
  }
  if (flags.processCommonJsModules) {
    flags.processClosurePrimitives=true;
    flags.manageClosureDependencies=true;
    if (flags.commonJsEntryModule == null) {
      err.println(""String_Node_Str"");
      err.flush();
      isConfigValid=false;
    }
    flags.closureEntryPoint=Lists.newArrayList(ProcessCommonJSModules.toModuleName(flags.commonJsEntryModule));
  }
  if (flags.outputWrapper != null && !flags.outputWrapper.isEmpty() && !flags.outputWrapper.contains(CommandLineRunner.OUTPUT_MARKER)) {
    err.println(""String_Node_Str"" + CommandLineRunner.OUTPUT_MARKER + ""String_Node_Str"");
    isConfigValid=false;
  }
  if (!isConfigValid || flags.displayHelp) {
    isConfigValid=false;
    flags.printUsage(err);
  }
 else {
    CodingConvention conv;
    if (flags.thirdParty) {
      conv=CodingConventions.getDefault();
    }
 else     if (flags.processJqueryPrimitives) {
      conv=new JqueryCodingConvention();
    }
 else {
      conv=new ClosureCodingConvention();
    }
    getCommandLineConfig().setPrintTree(flags.printTree).setPrintAst(flags.printAst).setPrintPassGraph(flags.printPassGraph).setJscompDevMode(flags.jscompDevMode).setLoggingLevel(flags.loggingLevel).setExterns(flags.externs).setJs(jsFiles).setJsOutputFile(flags.jsOutputFile).setModule(flags.module).setCodingConvention(conv).setSummaryDetailLevel(flags.summaryDetailLevel).setOutputWrapper(flags.outputWrapper).setModuleWrapper(flags.moduleWrapper).setModuleOutputPathPrefix(flags.moduleOutputPathPrefix).setCreateSourceMap(flags.createSourceMap).setSourceMapFormat(flags.sourceMapFormat).setWarningGuardSpec(Flags.getWarningGuardSpec()).setDefine(flags.define).setCharset(flags.charset).setManageClosureDependencies(flags.manageClosureDependencies).setOnlyClosureDependencies(flags.onlyClosureDependencies).setClosureEntryPoints(flags.closureEntryPoint).setOutputManifest(ImmutableList.of(flags.outputManifest)).setOutputModuleDependencies(flags.outputModuleDependencies).setAcceptConstKeyword(flags.acceptConstKeyword).setLanguageIn(flags.languageIn).setLanguageOut(flags.languageOut).setProcessCommonJSModules(flags.processCommonJsModules).setCommonJSModulePathPrefix(flags.commonJsPathPrefix).setTransformAMDToCJSModules(flags.transformAmdModules).setWarningsWhitelistFile(flags.warningsWhitelistFile).setAngularPass(flags.angularPass).setTracerMode(flags.tracerMode).setNewTypeInference(flags.useNewTypeInference);
  }
}",0.9905183312262958
27755,"/** 
 * Runs the sanity check if it is available.
 */
private void maybeSanityCheck(Node externs,Node root){
  if (sanityCheck != null) {
    sanityCheck.create(compiler).process(externs,root);
    if (inLoop) {
      NodeUtil.verifyScopeChanges(mtoc,jsRoot,true,compiler);
      setSanityCheckState();
    }
  }
}","/** 
 * Runs the sanity check if it is available.
 */
private void maybeSanityCheck(Node externs,Node root){
  if (sanityCheck != null) {
    sanityCheck.create(compiler).process(externs,root);
    if (inLoop) {
      NodeUtil.verifyScopeChanges(mtoc,jsRoot,true,compiler);
    }
  }
}",0.9515859766277128
27756,"private void setSanityCheckState(){
  lastAst=jsRoot.cloneTree();
  mtoc=NodeUtil.mapMainToClone(jsRoot,lastAst);
}","private void setSanityCheckState(){
  if (inLoop) {
    lastAst=jsRoot.cloneTree();
    mtoc=NodeUtil.mapMainToClone(jsRoot,lastAst);
  }
}",0.905511811023622
27757,"@Override protected CompilerPass create(AbstractCompiler compiler){
  return new RemoveUnusedVars(compiler,false,false,false);
}","@Override protected CompilerPass create(final AbstractCompiler compiler){
  return new CompilerPass(){
    @Override public void process(    Node externs,    Node root){
      NameAnalyzer na=new NameAnalyzer(compiler,false);
      na.process(externs,root);
      na.removeUnreferenced();
    }
  }
;
}",0.4883720930232558
27758,"private EnvTypePair analyzeNonStrictComparisonFwd(Node expr,TypeEnv inEnv,JSType specializedType){
  int tokenType=expr.getType();
  Node lhs=expr.getFirstChild();
  Node rhs=expr.getLastChild();
  if ((specializedType.isTruthy() || specializedType.isFalsy()) && (lhs.isTypeOf() || rhs.isTypeOf())) {
    if (lhs.isTypeOf()) {
      return analyzeSpecializedTypeof(lhs,rhs,expr.getType(),inEnv,specializedType);
    }
 else {
      return analyzeSpecializedTypeof(rhs,lhs,expr.getType(),inEnv,specializedType);
    }
  }
  EnvTypePair lhsPair=analyzeExprFwd(lhs,inEnv);
  EnvTypePair rhsPair=analyzeExprFwd(rhs,lhsPair.env);
  JSType lhsType=lhsPair.type;
  JSType rhsType=rhsPair.type;
  if (tokenType == Token.EQ && specializedType.isTruthy() || tokenType == Token.NE && specializedType.isFalsy()) {
    if (lhsType.isNullOrUndef()) {
      rhsPair=analyzeExprFwd(rhs,lhsPair.env,JSType.UNKNOWN,JSType.NULL_OR_UNDEF);
    }
 else     if (rhsType.isNullOrUndef()) {
      lhsPair=analyzeExprFwd(lhs,inEnv,JSType.UNKNOWN,JSType.NULL_OR_UNDEF);
      rhsPair=analyzeExprFwd(rhs,lhsPair.env);
    }
 else     if (!JSType.NULL_OR_UNDEF.isSubtypeOf(lhsType)) {
      rhsType=rhsType.removeType(JSType.NULL).removeType(JSType.UNDEFINED);
      rhsPair=analyzeExprFwd(rhs,lhsPair.env,JSType.UNKNOWN,rhsType);
    }
 else     if (!JSType.NULL_OR_UNDEF.isSubtypeOf(rhsType)) {
      lhsType=lhsType.removeType(JSType.NULL).removeType(JSType.UNDEFINED);
      lhsPair=analyzeExprFwd(lhs,inEnv,JSType.UNKNOWN,lhsType);
      rhsPair=analyzeExprFwd(rhs,lhsPair.env);
    }
  }
 else   if (tokenType == Token.EQ && specializedType.isFalsy() || tokenType == Token.NE && specializedType.isTruthy()) {
    if (lhsType.isNullOrUndef()) {
      rhsType=rhsType.removeType(JSType.NULL).removeType(JSType.UNDEFINED);
      rhsPair=analyzeExprFwd(rhs,lhsPair.env,JSType.UNKNOWN,rhsType);
    }
 else     if (rhsType.isNullOrUndef()) {
      lhsType=lhsType.removeType(JSType.NULL).removeType(JSType.UNDEFINED);
      lhsPair=analyzeExprFwd(lhs,inEnv,JSType.UNKNOWN,lhsType);
      rhsPair=analyzeExprFwd(rhs,lhsPair.env);
    }
  }
  rhsPair.type=JSType.BOOLEAN;
  return rhsPair;
}","private EnvTypePair analyzeNonStrictComparisonFwd(Node expr,TypeEnv inEnv,JSType specializedType){
  int tokenType=expr.getType();
  Node lhs=expr.getFirstChild();
  Node rhs=expr.getLastChild();
  if ((specializedType.isTruthy() || specializedType.isFalsy()) && (lhs.isTypeOf() || rhs.isTypeOf())) {
    if (lhs.isTypeOf()) {
      return analyzeSpecializedTypeof(lhs,rhs,tokenType,inEnv,specializedType);
    }
 else {
      return analyzeSpecializedTypeof(rhs,lhs,tokenType,inEnv,specializedType);
    }
  }
  EnvTypePair lhsPair=analyzeExprFwd(lhs,inEnv);
  EnvTypePair rhsPair=analyzeExprFwd(rhs,lhsPair.env);
  JSType lhsType=lhsPair.type;
  JSType rhsType=rhsPair.type;
  if (tokenType == Token.EQ && specializedType.isTruthy() || tokenType == Token.NE && specializedType.isFalsy()) {
    if (lhsType.isNullOrUndef()) {
      rhsPair=analyzeExprFwd(rhs,lhsPair.env,JSType.UNKNOWN,JSType.NULL_OR_UNDEF);
    }
 else     if (rhsType.isNullOrUndef()) {
      lhsPair=analyzeExprFwd(lhs,inEnv,JSType.UNKNOWN,JSType.NULL_OR_UNDEF);
      rhsPair=analyzeExprFwd(rhs,lhsPair.env);
    }
 else     if (!JSType.NULL_OR_UNDEF.isSubtypeOf(lhsType)) {
      rhsType=rhsType.removeType(JSType.NULL).removeType(JSType.UNDEFINED);
      rhsPair=analyzeExprFwd(rhs,lhsPair.env,JSType.UNKNOWN,rhsType);
    }
 else     if (!JSType.NULL_OR_UNDEF.isSubtypeOf(rhsType)) {
      lhsType=lhsType.removeType(JSType.NULL).removeType(JSType.UNDEFINED);
      lhsPair=analyzeExprFwd(lhs,inEnv,JSType.UNKNOWN,lhsType);
      rhsPair=analyzeExprFwd(rhs,lhsPair.env);
    }
  }
 else   if (tokenType == Token.EQ && specializedType.isFalsy() || tokenType == Token.NE && specializedType.isTruthy()) {
    if (lhsType.isNullOrUndef()) {
      rhsType=rhsType.removeType(JSType.NULL).removeType(JSType.UNDEFINED);
      rhsPair=analyzeExprFwd(rhs,lhsPair.env,JSType.UNKNOWN,rhsType);
    }
 else     if (rhsType.isNullOrUndef()) {
      lhsType=lhsType.removeType(JSType.NULL).removeType(JSType.UNDEFINED);
      lhsPair=analyzeExprFwd(lhs,inEnv,JSType.UNKNOWN,lhsType);
      rhsPair=analyzeExprFwd(rhs,lhsPair.env);
    }
  }
  rhsPair.type=JSType.BOOLEAN;
  return rhsPair;
}",0.9893370421882244
27759,"public JSType negate(){
  if (isTop() || isUnknown() || objs != null || typeVar != null) {
    return this;
  }
  if (isTruthy()) {
    return FALSY;
  }
 else   if (isFalsy()) {
    return TRUTHY;
  }
  return new JSType(TOP_SCALAR_MASK & ~mask);
}","public JSType negate(){
  if (isTop() || isUnknown()) {
    return this;
  }
  if (isTruthy()) {
    return FALSY;
  }
 else   if (isFalsy()) {
    return TRUTHY;
  }
 else   if (objs == null && typeVar == null) {
    return new JSType(TOP_SCALAR_MASK & ~mask);
  }
  return UNKNOWN;
}",0.4194756554307116
27760,"public void testTypeof(){
  typeCheck(""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"",TypeValidator.UNKNOWN_TYPEOF_VALUE);
  typeCheck(""String_Node_Str"",TypeValidator.UNKNOWN_TYPEOF_VALUE);
}","public void testTypeof(){
  typeCheck(""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  checkNoWarnings(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  typeCheck(""String_Node_Str"",TypeValidator.UNKNOWN_TYPEOF_VALUE);
  typeCheck(""String_Node_Str"",TypeValidator.UNKNOWN_TYPEOF_VALUE);
}",0.9775802087359876
27761,"private ObjectType(NominalType nominalType,PersistentMap<String,Property> props,FunctionType fn,boolean isLoose,ObjectKind objectKind){
  this.nominalType=nominalType;
  this.props=props;
  this.fn=fn;
  this.isLoose=isLoose;
  this.objectKind=objectKind;
}","private ObjectType(NominalType nominalType,PersistentMap<String,Property> props,FunctionType fn,boolean isLoose,ObjectKind objectKind){
  Preconditions.checkState(nominalType == null || !isLoose);
  this.nominalType=nominalType;
  this.props=props;
  this.fn=fn;
  this.isLoose=isLoose;
  this.objectKind=objectKind;
}",0.8939130434782608
27762,"boolean isLooseSubtypeOf(ObjectType obj2){
  if (obj2 == TOP_OBJECT) {
    return true;
  }
  for (  String pname : obj2.props.keySet()) {
    if (props.containsKey(pname)) {
      if (!props.get(pname).getType().isSubtypeOf(obj2.props.get(pname).getType())) {
        return false;
      }
    }
  }
  if (obj2.fn == null) {
    return true;
  }
 else   if (this.fn == null) {
    return false;
  }
  return fn.isLooseSubtypeOf(obj2.fn);
}","boolean isLooseSubtypeOf(ObjectType obj2){
  Preconditions.checkState(isLoose || obj2.isLoose);
  if (obj2 == TOP_OBJECT) {
    return true;
  }
  if (!isLoose) {
    if (!objectKind.isSubtypeOf(obj2.objectKind)) {
      return false;
    }
    for (    String pname : obj2.props.keySet()) {
      QualifiedName qname=new QualifiedName(pname);
      if (!mayHaveProp(qname) || !getProp(qname).isSubtypeOf(obj2.getProp(qname))) {
        return false;
      }
    }
  }
 else {
    for (    String pname : props.keySet()) {
      QualifiedName qname=new QualifiedName(pname);
      if (obj2.mayHaveProp(qname) && !getProp(qname).isSubtypeOf(obj2.getProp(qname))) {
        return false;
      }
    }
  }
  if (obj2.fn == null) {
    return true;
  }
 else   if (this.fn == null) {
    return false;
  }
  return fn.isLooseSubtypeOf(obj2.fn);
}",0.5674201091192518
27763,"/** 
 * Required properties are acceptable where an optional is required, but not vice versa. Optional properties create cycles in the type lattice, eg, { } \le { p: num= }  and also   { p: num= } \le { }.
 */
boolean isSubtypeOf(ObjectType obj2){
  if (obj2 == TOP_OBJECT) {
    return true;
  }
  if (!objectKind.isSubtypeOf(obj2.objectKind)) {
    return false;
  }
  if (this.isLoose || obj2.isLoose) {
    return this.isLooseSubtypeOf(obj2);
  }
  for (  String pname : obj2.props.keySet()) {
    Property prop2=obj2.props.get(pname);
    Property prop1=this.getLeftmostProp(new QualifiedName(pname));
    if (prop2.isOptional()) {
      if (prop1 != null && !prop1.getType().isSubtypeOf(prop2.getType())) {
        return false;
      }
    }
 else {
      if (prop1 == null || prop1.isOptional() || !prop1.getType().isSubtypeOf(prop2.getType())) {
        return false;
      }
    }
  }
  if ((this.nominalType == null && obj2.nominalType != null) || this.nominalType != null && obj2.nominalType != null && !this.nominalType.isSubclassOf(obj2.nominalType)) {
    return false;
  }
  if (obj2.fn == null) {
    return true;
  }
 else   if (this.fn == null) {
    return false;
  }
  return this.fn.isSubtypeOf(obj2.fn);
}","/** 
 * Required properties are acceptable where an optional is required, but not vice versa. Optional properties create cycles in the type lattice, eg, { } \le { p: num= }  and also   { p: num= } \le { }.
 */
boolean isSubtypeOf(ObjectType obj2){
  if (obj2 == TOP_OBJECT) {
    return true;
  }
  if (this.isLoose || obj2.isLoose) {
    return this.isLooseSubtypeOf(obj2);
  }
  if (!objectKind.isSubtypeOf(obj2.objectKind)) {
    return false;
  }
  for (  String pname : obj2.props.keySet()) {
    Property prop2=obj2.props.get(pname);
    Property prop1=this.getLeftmostProp(new QualifiedName(pname));
    if (prop2.isOptional()) {
      if (prop1 != null && !prop1.getType().isSubtypeOf(prop2.getType())) {
        return false;
      }
    }
 else {
      if (prop1 == null || prop1.isOptional() || !prop1.getType().isSubtypeOf(prop2.getType())) {
        return false;
      }
    }
  }
  if ((this.nominalType == null && obj2.nominalType != null) || this.nominalType != null && obj2.nominalType != null && !this.nominalType.isSubclassOf(obj2.nominalType)) {
    return false;
  }
  if (obj2.fn == null) {
    return true;
  }
 else   if (this.fn == null) {
    return false;
  }
  return this.fn.isSubtypeOf(obj2.fn);
}",0.9413680781758956
27764,"ObjectType specialize(ObjectType other){
  Preconditions.checkState(areRelatedClasses(this.nominalType,other.nominalType));
  NominalType resultNominalType=NominalType.pickSubclass(this.nominalType,other.nominalType);
  return ObjectType.makeObjectType(resultNominalType,meetPropsHelper(true,resultNominalType,this.props,other.props),(fn == null) ? null : fn.specialize(other.fn),this.isLoose || other.isLoose,ObjectKind.meet(this.objectKind,other.objectKind));
}","ObjectType specialize(ObjectType other){
  Preconditions.checkState(areRelatedClasses(this.nominalType,other.nominalType));
  NominalType resultNominalType=NominalType.pickSubclass(this.nominalType,other.nominalType);
  return ObjectType.makeObjectType(resultNominalType,meetPropsHelper(true,resultNominalType,this.props,other.props),(fn == null) ? null : fn.specialize(other.fn),resultNominalType == null && this.isLoose,ObjectKind.meet(this.objectKind,other.objectKind));
}",0.9424307036247336
27765,"@Override JSType resolveInternal(ErrorReporter t,StaticScope<JSType> scope){
  setResolvedTypeInternal(this);
  call=(ArrowType)safeResolve(call,t,scope);
  if (prototypeSlot != null) {
    prototypeSlot.setType(safeResolve(prototypeSlot.getType(),t,scope));
  }
  JSType maybeTypeOfThis=safeResolve(typeOfThis,t,scope);
  if (maybeTypeOfThis != null) {
    if (maybeTypeOfThis.isNullType() || maybeTypeOfThis.isVoidType()) {
      typeOfThis=maybeTypeOfThis;
    }
 else {
      maybeTypeOfThis=ObjectType.cast(maybeTypeOfThis.restrictByNotNullOrUndefined());
      if (maybeTypeOfThis != null) {
        typeOfThis=maybeTypeOfThis;
      }
    }
  }
  boolean changed=false;
  ImmutableList.Builder<ObjectType> resolvedInterfaces=ImmutableList.builder();
  for (  ObjectType iface : implementedInterfaces) {
    ObjectType resolvedIface=(ObjectType)iface.resolve(t,scope);
    resolvedInterfaces.add(resolvedIface);
    changed|=(resolvedIface != iface);
  }
  if (changed) {
    implementedInterfaces=resolvedInterfaces.build();
  }
  if (subTypes != null) {
    for (int i=0; i < subTypes.size(); i++) {
      subTypes.set(i,JSType.toMaybeFunctionType(subTypes.get(i).resolve(t,scope)));
    }
  }
  return super.resolveInternal(t,scope);
}","@Override JSType resolveInternal(ErrorReporter t,StaticScope<JSType> scope){
  setResolvedTypeInternal(this);
  call=(ArrowType)safeResolve(call,t,scope);
  if (prototypeSlot != null) {
    prototypeSlot.setType(safeResolve(prototypeSlot.getType(),t,scope));
  }
  JSType maybeTypeOfThis=safeResolve(typeOfThis,t,scope);
  if (maybeTypeOfThis != null) {
    if (maybeTypeOfThis.isNullType() || maybeTypeOfThis.isVoidType()) {
      typeOfThis=maybeTypeOfThis;
    }
 else {
      maybeTypeOfThis=ObjectType.cast(maybeTypeOfThis.restrictByNotNullOrUndefined());
      if (maybeTypeOfThis != null) {
        typeOfThis=maybeTypeOfThis;
      }
    }
  }
  ImmutableList<ObjectType> resolvedImplemented=resolveTypeListHelper(implementedInterfaces,t,scope);
  if (resolvedImplemented != null) {
    implementedInterfaces=resolvedImplemented;
  }
  ImmutableList<ObjectType> resolvedExtended=resolveTypeListHelper(extendedInterfaces,t,scope);
  if (resolvedExtended != null) {
    extendedInterfaces=resolvedExtended;
  }
  if (subTypes != null) {
    for (int i=0; i < subTypes.size(); i++) {
      subTypes.set(i,JSType.toMaybeFunctionType(subTypes.get(i).resolve(t,scope)));
    }
  }
  return super.resolveInternal(t,scope);
}",0.7687322802754152
27766,"private void addRelatedInterfaces(ObjectType instance,Set<ObjectType> set){
  FunctionType constructor=instance.getConstructor();
  if (constructor != null) {
    if (!constructor.isInterface()) {
      return;
    }
    set.add(instance);
    for (    ObjectType interfaceType : instance.getCtorExtendedInterfaces()) {
      addRelatedInterfaces(interfaceType,set);
    }
  }
}","private void addRelatedInterfaces(ObjectType instance,Set<ObjectType> set){
  FunctionType constructor=instance.getConstructor();
  if (constructor != null) {
    if (!constructor.isInterface()) {
      return;
    }
    if (!set.add(instance)) {
      return;
    }
    for (    ObjectType interfaceType : instance.getCtorExtendedInterfaces()) {
      addRelatedInterfaces(interfaceType,set);
    }
  }
}",0.9655172413793104
27767,"private void addRelatedExtendedInterfaces(ObjectType instance,Set<ObjectType> set){
  FunctionType constructor=instance.getConstructor();
  if (constructor != null) {
    set.add(instance);
    for (    ObjectType interfaceType : constructor.getExtendedInterfaces()) {
      addRelatedExtendedInterfaces(interfaceType,set);
    }
  }
}","private void addRelatedExtendedInterfaces(ObjectType instance,Set<ObjectType> set){
  FunctionType constructor=instance.getConstructor();
  if (constructor != null) {
    if (!set.add(instance)) {
      return;
    }
    for (    ObjectType interfaceType : constructor.getExtendedInterfaces()) {
      addRelatedExtendedInterfaces(interfaceType,set);
    }
  }
}",0.9612625538020086
27768,"public void testInterfaceExtendsLoop() throws Exception {
  testClosureTypesMultipleWarnings(suppressMissingProperty(""String_Node_Str"") + ""String_Node_Str"" + ""String_Node_Str"",Lists.newArrayList(""String_Node_Str""));
}","public void testInterfaceExtendsLoop() throws Exception {
  testClosureTypesMultipleWarnings(suppressMissingProperty(""String_Node_Str"") + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",Lists.<String>newArrayList());
}",0.8639308855291576
27769,"/** 
 * Returns whether a node corresponds to a simple or a qualified name, such as <code>x</code> or <code>a.b.c</code> or <code>this.a</code>.
 */
public boolean isQualifiedName(){
switch (getType()) {
case Token.NAME:
    return getString().isEmpty() ? false : true;
case Token.THIS:
  return true;
case Token.GETPROP:
return getFirstChild().isQualifiedName();
default :
return false;
}
}","/** 
 * Returns whether a node corresponds to a simple or a qualified name, such as <code>x</code> or <code>a.b.c</code> or <code>this.a</code>.
 */
public boolean isQualifiedName(){
switch (getType()) {
case Token.NAME:
    return !getString().isEmpty();
case Token.THIS:
  return true;
case Token.GETPROP:
return getFirstChild().isQualifiedName();
default :
return false;
}
}",0.9791666666666666
27770,"/** 
 * Returns whether a node corresponds to a simple or a qualified name without a ""this"" reference, such as <code>a.b.c</code>, but not <code>this.a</code> .
 */
public boolean isUnscopedQualifiedName(){
switch (getType()) {
case Token.NAME:
    return getString().isEmpty() ? false : true;
case Token.GETPROP:
  return getFirstChild().isUnscopedQualifiedName();
default :
return false;
}
}","/** 
 * Returns whether a node corresponds to a simple or a qualified name without a ""this"" reference, such as <code>a.b.c</code>, but not <code>this.a</code> .
 */
public boolean isUnscopedQualifiedName(){
switch (getType()) {
case Token.NAME:
    return !getString().isEmpty();
case Token.GETPROP:
  return getFirstChild().isUnscopedQualifiedName();
default :
return false;
}
}",0.9792746113989638
27771,"private boolean inlineAliasIfPossible(Ref alias,GlobalNamespace namespace){
  Node aliasParent=alias.node.getParent();
  if (aliasParent.isName()) {
    Scope scope=alias.scope;
    Var aliasVar=scope.getVar(aliasParent.getString());
    ReferenceCollectingCallback collector=new ReferenceCollectingCallback(compiler,ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,Predicates.<Var>equalTo(aliasVar));
    (new NodeTraversal(compiler,collector)).traverseAtScope(scope);
    ReferenceCollection aliasRefs=collector.getReferences(aliasVar);
    List<AstChange> newNodes=Lists.newArrayList();
    if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {
      int size=aliasRefs.references.size();
      for (int i=1; i < size; i++) {
        ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);
        Node newNode=alias.node.cloneTree();
        aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);
        newNodes.add(new AstChange(getRefModule(aliasRef),aliasRef.getScope(),newNode));
      }
      aliasParent.replaceChild(alias.node,IR.nullNode());
      compiler.reportCodeChange();
      namespace.scanNewNodes(newNodes);
      return true;
    }
  }
  return false;
}","private boolean inlineAliasIfPossible(Ref alias,GlobalNamespace namespace){
  Node aliasParent=alias.node.getParent();
  if (aliasParent.isName()) {
    Scope scope=alias.scope;
    Var aliasVar=scope.getVar(aliasParent.getString());
    ReferenceCollectingCallback collector=new ReferenceCollectingCallback(compiler,ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,Predicates.<Var>equalTo(aliasVar));
    collector.processScope(scope);
    ReferenceCollection aliasRefs=collector.getReferences(aliasVar);
    List<AstChange> newNodes=Lists.newArrayList();
    if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {
      int size=aliasRefs.references.size();
      for (int i=1; i < size; i++) {
        ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);
        Node newNode=alias.node.cloneTree();
        aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);
        newNodes.add(new AstChange(getRefModule(aliasRef),aliasRef.getScope(),newNode));
      }
      aliasParent.replaceChild(alias.node,IR.nullNode());
      compiler.reportCodeChange();
      namespace.scanNewNodes(newNodes);
      return true;
    }
  }
  return false;
}",0.9733810091378624
27772,"/** 
 * Traverses an inner node recursively with a refined scope. An inner node may be any node with a non   {@code null} parent (i.e. all nodes except theroot).
 * @param node the node to traverse
 * @param parent the node's parent, it may not be {@code null}
 * @param refinedScope the refined scope of the scope currently at the top ofthe scope stack or in trivial cases that very scope or  {@code null}
 */
protected void traverseInnerNode(Node node,Node parent,Scope refinedScope){
  Preconditions.checkNotNull(parent);
  if (refinedScope != null && getScope() != refinedScope) {
    curNode=node;
    pushScope(refinedScope);
    traverseBranch(node,parent);
    popScope();
  }
 else {
    traverseBranch(node,parent);
  }
}","/** 
 * Traverses an inner node recursively with a refined scope. An inner node may be any node with a non   {@code null} parent (i.e. all nodes except theroot).
 * @param node the node to traverse
 * @param parent the node's parent, it may not be {@code null}
 * @param refinedScope the refined scope of the scope currently at the top ofthe scope stack or in trivial cases that very scope or  {@code null}
 */
protected void traverseInnerNode(Node node,Node parent,Scope refinedScope){
  Preconditions.checkNotNull(parent);
  if (inputId == null) {
    inputId=NodeUtil.getInputId(node);
  }
  if (refinedScope != null && getScope() != refinedScope) {
    curNode=node;
    pushScope(refinedScope);
    traverseBranch(node,parent);
    popScope();
  }
 else {
    traverseBranch(node,parent);
  }
}",0.9555555555555556
27773,"/** 
 * Creates a new scope (e.g. when entering a function). 
 */
private void pushScope(Scope s){
  Preconditions.checkState(curNode != null);
  compiler.setScope(s.getRootNode());
  scopes.push(s);
  cfgs.push(null);
  if (scopeCallback != null) {
    scopeCallback.enterScope(this);
  }
}","/** 
 * Creates a new scope (e.g. when entering a function).
 * @param quietly Don't fire an enterScope callback.
 */
private void pushScope(Scope s,boolean quietly){
  Preconditions.checkState(curNode != null);
  compiler.setScope(s.getRootNode());
  scopes.push(s);
  cfgs.push(null);
  if (!quietly && scopeCallback != null) {
    scopeCallback.enterScope(this);
  }
}",0.8761329305135952
27774,"/** 
 * Pops back to the previous scope (e.g. when leaving a function). 
 */
private void popScope(){
  if (scopeCallback != null) {
    scopeCallback.exitScope(this);
  }
  if (scopeRoots.isEmpty()) {
    scopes.pop();
  }
 else {
    scopeRoots.pop();
  }
  cfgs.pop();
  if (hasScope()) {
    compiler.setScope(getScopeRoot());
  }
}","/** 
 * Pops back to the previous scope (e.g. when leaving a function).
 * @param quietly Don't fire the exitScope callback.
 */
private void popScope(boolean quietly){
  if (!quietly && scopeCallback != null) {
    scopeCallback.exitScope(this);
  }
  if (scopeRoots.isEmpty()) {
    scopes.pop();
  }
 else {
    scopeRoots.pop();
  }
  cfgs.pop();
  if (hasScope()) {
    compiler.setScope(getScopeRoot());
  }
}",0.8921438082556591
27775,"/** 
 * Updates block stack and invokes any additional behavior.
 */
@Override public void enterScope(NodeTraversal t){
  Node n=t.getScope().getRootNode();
  BasicBlock parent=blockStack.isEmpty() ? null : blockStack.peek();
  blockStack.push(new BasicBlock(parent,n));
}","/** 
 * Updates block stack and invokes any additional behavior.
 */
@Override public void enterScope(NodeTraversal t){
  Node n=t.getScope().getRootNode();
  BasicBlock parent=blockStack.isEmpty() ? null : peek(blockStack);
  blockStack.add(new BasicBlock(parent,n));
}",0.9298892988929888
27776,"/** 
 * Creates a new block.
 * @param parent The containing block.
 * @param root The root node of the block.
 */
BasicBlock(BasicBlock parent,Node root){
  this.parent=parent;
  this.isHoisted=NodeUtil.isHoistedFunctionDeclaration(root);
  this.isFunction=root.isFunction();
  if (root.getParent() != null) {
    int pType=root.getParent().getType();
    this.isLoop=pType == Token.DO || pType == Token.WHILE || pType == Token.FOR;
  }
 else {
    this.isLoop=false;
  }
}","/** 
 * Creates a new block.
 * @param parent The containing block.
 * @param root The root node of the block.
 */
BasicBlock(BasicBlock parent,Node root){
  this.parent=parent;
  this.root=root;
  this.isFunction=root.isFunction();
  if (root.getParent() != null) {
    int pType=root.getParent().getType();
    this.isLoop=pType == Token.DO || pType == Token.WHILE || pType == Token.FOR;
  }
 else {
    this.isLoop=false;
  }
}",0.9314159292035398
27777,"/** 
 * Updates block stack.
 */
@Override public boolean shouldTraverse(NodeTraversal nodeTraversal,Node n,Node parent){
  if (isBlockBoundary(n,parent)) {
    blockStack.push(new BasicBlock(blockStack.peek(),n));
  }
  return true;
}","/** 
 * Updates block stack.
 */
@Override public boolean shouldTraverse(NodeTraversal nodeTraversal,Node n,Node parent){
  if (NodeUtil.isHoistedFunctionDeclaration(n)) {
    Node nameNode=n.getFirstChild();
    Var functionVar=nodeTraversal.getScope().getVar(nameNode.getString());
    if (functionVar != null) {
      if (finishedFunctionTraverse.contains(functionVar)) {
        return false;
      }
      startedFunctionTraverse.add(functionVar);
    }
  }
  if (isBlockBoundary(n,parent)) {
    blockStack.add(new BasicBlock(peek(blockStack),n));
  }
  return true;
}",0.5241038318912238
27778,"/** 
 * For each node, update the block stack and reference collection as appropriate.
 */
@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (n.isName()) {
    Var v;
    if (n.getString().equals(""String_Node_Str"")) {
      v=t.getScope().getArgumentsVar();
    }
 else {
      v=t.getScope().getVar(n.getString());
    }
    if (v != null && varFilter.apply(v)) {
      addReference(v,new Reference(n,t,blockStack.peek()));
    }
  }
  if (isBlockBoundary(n,parent)) {
    blockStack.pop();
  }
}","/** 
 * For each node, update the block stack and reference collection as appropriate.
 */
@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (n.isName()) {
    Var v;
    if (n.getString().equals(""String_Node_Str"")) {
      v=t.getScope().getArgumentsVar();
    }
 else {
      v=t.getScope().getVar(n.getString());
    }
    if (v != null) {
      if (varFilter.apply(v)) {
        addReference(v,new Reference(n,t,peek(blockStack)));
      }
      if (v.getParentNode() != null && NodeUtil.isHoistedFunctionDeclaration(v.getParentNode()) && (narrowScope == null || narrowScope.getDepth() <= v.getScope().getDepth())) {
        outOfBandTraversal(v);
      }
    }
  }
  if (isBlockBoundary(n,parent)) {
    pop(blockStack);
  }
}",0.7018927444794952
27779,"/** 
 * Updates block stack and invokes any additional behavior.
 */
@Override public void exitScope(NodeTraversal t){
  blockStack.pop();
  if (t.getScope().isGlobal()) {
    compiler.updateGlobalVarReferences(referenceMap,t.getScopeRoot());
    behavior.afterExitScope(t,compiler.getGlobalVarReferences());
  }
 else {
    behavior.afterExitScope(t,new ReferenceMapWrapper(referenceMap));
  }
}","/** 
 * Updates block stack and invokes any additional behavior.
 */
@Override public void exitScope(NodeTraversal t){
  pop(blockStack);
  if (t.getScope().isGlobal()) {
    compiler.updateGlobalVarReferences(referenceMap,t.getScopeRoot());
    behavior.afterExitScope(t,compiler.getGlobalVarReferences());
  }
 else {
    behavior.afterExitScope(t,new ReferenceMapWrapper(referenceMap));
  }
}",0.963337547408344
27780,"/** 
 * Determines whether this block is guaranteed to begin executing before the given block does.
 */
boolean provablyExecutesBefore(BasicBlock thatBlock){
  BasicBlock currentBlock;
  for (currentBlock=thatBlock; currentBlock != null && currentBlock != this; currentBlock=currentBlock.getParent()) {
    if (currentBlock.isHoisted) {
      return false;
    }
  }
  if (currentBlock == this) {
    return true;
  }
  if (isGlobalScopeBlock() && thatBlock.isGlobalScopeBlock()) {
    return true;
  }
  return false;
}","/** 
 * Determines whether this block is guaranteed to begin executing before the given block does.
 */
boolean provablyExecutesBefore(BasicBlock thatBlock){
  BasicBlock currentBlock;
  for (currentBlock=thatBlock; currentBlock != null && currentBlock != this; currentBlock=currentBlock.getParent()) {
  }
  if (currentBlock == this) {
    return true;
  }
  if (isGlobalScopeBlock() && thatBlock.isGlobalScopeBlock()) {
    return true;
  }
  return false;
}",0.9387755102040816
27781,"/** 
 * Visits a CALL node.
 * @param t The node traversal object that supplies context, such as thescope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 */
private void visitCall(NodeTraversal t,Node n){
  Node child=n.getFirstChild();
  JSType childType=getJSType(child).restrictByNotNullOrUndefined();
  if (!childType.canBeCalled()) {
    report(t,n,NOT_CALLABLE,childType.toString());
    ensureTyped(t,n);
    return;
  }
  if (childType.isFunctionType()) {
    FunctionType functionType=childType.toMaybeFunctionType();
    if (functionType.isConstructor() && !functionType.isNativeObjectType() && (functionType.getReturnType().isUnknownType() || functionType.getReturnType().isVoidType())) {
      report(t,n,CONSTRUCTOR_NOT_CALLABLE,childType.toString());
    }
    if (functionType.isOrdinaryFunction() && !functionType.getTypeOfThis().isUnknownType() && !(functionType.getTypeOfThis().toObjectType() != null && functionType.getTypeOfThis().toObjectType().isNativeObjectType())&& !(child.isGetElem() || child.isGetProp())) {
      report(t,n,EXPECTED_THIS_TYPE,functionType.toString());
    }
    visitParameterList(t,n,functionType);
    ensureTyped(t,n,functionType.getReturnType());
  }
 else {
    ensureTyped(t,n);
  }
}","/** 
 * Visits a CALL node.
 * @param t The node traversal object that supplies context, such as thescope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 */
private void visitCall(NodeTraversal t,Node n){
  checkCallConventions(t,n);
  Node child=n.getFirstChild();
  JSType childType=getJSType(child).restrictByNotNullOrUndefined();
  if (!childType.canBeCalled()) {
    report(t,n,NOT_CALLABLE,childType.toString());
    ensureTyped(t,n);
    return;
  }
  if (childType.isFunctionType()) {
    FunctionType functionType=childType.toMaybeFunctionType();
    if (functionType.isConstructor() && !functionType.isNativeObjectType() && (functionType.getReturnType().isUnknownType() || functionType.getReturnType().isVoidType())) {
      report(t,n,CONSTRUCTOR_NOT_CALLABLE,childType.toString());
    }
    if (functionType.isOrdinaryFunction() && !functionType.getTypeOfThis().isUnknownType() && !(functionType.getTypeOfThis().toObjectType() != null && functionType.getTypeOfThis().toObjectType().isNativeObjectType())&& !(child.isGetElem() || child.isGetProp())) {
      report(t,n,EXPECTED_THIS_TYPE,functionType.toString());
    }
    visitParameterList(t,n,functionType);
    ensureTyped(t,n,functionType.getReturnType());
  }
 else {
    ensureTyped(t,n);
  }
}",0.9888074102663064
27782,"/** 
 * Look for class-defining calls. Because JS has no 'native' syntax for defining classes, this is often very coding-convention dependent and business-logic heavy.
 */
private void checkForClassDefiningCalls(NodeTraversal t,Node n){
  SubclassRelationship relationship=codingConvention.getClassesDefinedByCall(n);
  if (relationship != null) {
    FunctionType superCtor=getFunctionType(scope.getVar(relationship.superclassName));
    FunctionType subCtor=getFunctionType(scope.getVar(relationship.subclassName));
    if (superCtor != null && superCtor.isConstructor() && subCtor != null && subCtor.isConstructor()) {
      ObjectType superClass=superCtor.getInstanceType();
      ObjectType subClass=subCtor.getInstanceType();
      superCtor=superClass.getConstructor();
      subCtor=subClass.getConstructor();
      if (relationship.type == SubclassType.INHERITS && !superClass.isEmptyType() && !subClass.isEmptyType()) {
        validator.expectSuperType(t,n,superClass,subClass);
      }
      if (superCtor != null && subCtor != null) {
        codingConvention.applySubclassRelationship(superCtor,subCtor,relationship.type);
      }
    }
  }
  String singletonGetterClassName=codingConvention.getSingletonGetterClassName(n);
  if (singletonGetterClassName != null) {
    ObjectType objectType=ObjectType.cast(typeRegistry.getType(singletonGetterClassName));
    if (objectType != null) {
      FunctionType functionType=objectType.getConstructor();
      if (functionType != null) {
        FunctionType getterType=typeRegistry.createFunctionType(objectType);
        codingConvention.applySingletonGetter(functionType,getterType,objectType);
      }
    }
  }
  DelegateRelationship delegateRelationship=codingConvention.getDelegateRelationship(n);
  if (delegateRelationship != null) {
    applyDelegateRelationship(delegateRelationship);
  }
  ObjectLiteralCast objectLiteralCast=codingConvention.getObjectLiteralCast(n);
  if (objectLiteralCast != null) {
    if (objectLiteralCast.diagnosticType == null) {
      ObjectType type=ObjectType.cast(typeRegistry.getType(objectLiteralCast.typeName));
      if (type != null && type.getConstructor() != null) {
        setDeferredType(objectLiteralCast.objectNode,type);
        objectLiteralCast.objectNode.putBooleanProp(Node.REFLECTED_OBJECT,true);
      }
 else {
        compiler.report(JSError.make(t.getSourceName(),n,CONSTRUCTOR_EXPECTED));
      }
    }
 else {
      compiler.report(JSError.make(t.getSourceName(),n,objectLiteralCast.diagnosticType));
    }
  }
}","/** 
 * Look for class-defining calls. Because JS has no 'native' syntax for defining classes, this is often very coding-convention dependent and business-logic heavy.
 */
private void checkForClassDefiningCalls(NodeTraversal t,Node n){
  SubclassRelationship relationship=codingConvention.getClassesDefinedByCall(n);
  if (relationship != null) {
    ObjectType superClass=TypeValidator.getInstanceOfCtor(scope.getVar(relationship.superclassName));
    ObjectType subClass=TypeValidator.getInstanceOfCtor(scope.getVar(relationship.subclassName));
    if (superClass != null && subClass != null) {
      FunctionType superCtor=superClass.getConstructor();
      FunctionType subCtor=subClass.getConstructor();
      if (superCtor != null && subCtor != null) {
        codingConvention.applySubclassRelationship(superCtor,subCtor,relationship.type);
      }
    }
  }
  String singletonGetterClassName=codingConvention.getSingletonGetterClassName(n);
  if (singletonGetterClassName != null) {
    ObjectType objectType=ObjectType.cast(typeRegistry.getType(singletonGetterClassName));
    if (objectType != null) {
      FunctionType functionType=objectType.getConstructor();
      if (functionType != null) {
        FunctionType getterType=typeRegistry.createFunctionType(objectType);
        codingConvention.applySingletonGetter(functionType,getterType,objectType);
      }
    }
  }
  DelegateRelationship delegateRelationship=codingConvention.getDelegateRelationship(n);
  if (delegateRelationship != null) {
    applyDelegateRelationship(delegateRelationship);
  }
  ObjectLiteralCast objectLiteralCast=codingConvention.getObjectLiteralCast(n);
  if (objectLiteralCast != null) {
    if (objectLiteralCast.diagnosticType == null) {
      ObjectType type=ObjectType.cast(typeRegistry.getType(objectLiteralCast.typeName));
      if (type != null && type.getConstructor() != null) {
        setDeferredType(objectLiteralCast.objectNode,type);
        objectLiteralCast.objectNode.putBooleanProp(Node.REFLECTED_OBJECT,true);
      }
 else {
        compiler.report(JSError.make(t.getSourceName(),n,CONSTRUCTOR_EXPECTED));
      }
    }
 else {
      compiler.report(JSError.make(t.getSourceName(),n,objectLiteralCast.diagnosticType));
    }
  }
}",0.8452530322040988
27783,"/** 
 * Creates a new function type, based on the given nodes. This handles two cases that are semantically very different, but are not mutually exclusive: - A function literal that needs a type attached to it. - An assignment expression with function-type info in the JsDoc. All parameters are optional, and we will do the best we can to create a function type. This function will always create a function type, so only call it if you're sure that's what you want.
 * @param rValue The function node.
 * @param name the function's name
 * @param info the {@link JSDocInfo} attached to the function definition
 * @param lvalueNode The node where this function is beingassigned. For example,  {@code A.prototype.foo = ...} would be used todetermine that this function is a method of A.prototype. May be null to indicate that this is not being assigned to a qualified name.
 */
private FunctionType createFunctionTypeFromNodes(@Nullable Node rValue,@Nullable String name,@Nullable JSDocInfo info,@Nullable Node lvalueNode){
  FunctionType functionType=null;
  if (rValue != null && rValue.isQualifiedName() && scope.isGlobal()) {
    Var var=scope.getVar(rValue.getQualifiedName());
    if (var != null && var.getType() != null && var.getType().isFunctionType()) {
      FunctionType aliasedType=var.getType().toMaybeFunctionType();
      if ((aliasedType.isConstructor() || aliasedType.isInterface()) && !aliasedType.isNativeObjectType()) {
        functionType=aliasedType;
        if (name != null && scope.isGlobal()) {
          typeRegistry.declareType(name,functionType.getInstanceType());
        }
      }
    }
  }
  if (functionType == null) {
    Node errorRoot=rValue == null ? lvalueNode : rValue;
    boolean isFnLiteral=rValue != null && rValue.isFunction();
    Node fnRoot=isFnLiteral ? rValue : null;
    Node parametersNode=isFnLiteral ? rValue.getFirstChild().getNext() : null;
    if (info != null && info.hasType()) {
      JSType type=info.getType().evaluate(scope,typeRegistry);
      type=type.restrictByNotNullOrUndefined();
      if (type.isFunctionType()) {
        functionType=type.toMaybeFunctionType();
        functionType.setJSDocInfo(info);
      }
    }
    if (functionType == null) {
      Node ownerNode=NodeUtil.getBestLValueOwner(lvalueNode);
      String ownerName=NodeUtil.getBestLValueName(ownerNode);
      Var ownerVar=null;
      String propName=null;
      ObjectType ownerType=null;
      if (ownerName != null) {
        ownerVar=scope.getVar(ownerName);
        if (ownerVar != null) {
          ownerType=ObjectType.cast(ownerVar.getType());
        }
        if (name != null) {
          propName=name.substring(ownerName.length() + 1);
        }
      }
      ObjectType prototypeOwner=getPrototypeOwnerType(ownerType);
      TemplateTypeMap prototypeOwnerTypeMap=null;
      if (prototypeOwner != null && prototypeOwner.getTypeOfThis() != null) {
        prototypeOwnerTypeMap=prototypeOwner.getTypeOfThis().getTemplateTypeMap();
      }
      FunctionType overriddenType=null;
      if (ownerType != null && propName != null) {
        overriddenType=findOverriddenFunction(ownerType,propName,prototypeOwnerTypeMap);
      }
      FunctionTypeBuilder builder=new FunctionTypeBuilder(name,compiler,errorRoot,sourceName,scope).setContents(getFunctionAnalysisResults(fnRoot)).inferFromOverriddenFunction(overriddenType,parametersNode).inferTemplateTypeName(info,prototypeOwner).inferInheritance(info);
      if (info == null || !info.hasReturnType()) {
        if (rValue != null && rValue.isFunction() && rValue.getFirstChild() != null) {
          JSDocInfo nameDocInfo=rValue.getFirstChild().getJSDocInfo();
          builder.inferReturnType(nameDocInfo,true);
        }
      }
 else {
        builder.inferReturnType(info,false);
      }
      boolean searchedForThisType=false;
      if (ownerType != null && ownerType.isFunctionPrototypeType() && ownerType.getOwnerFunction().hasInstanceType()) {
        builder.inferThisType(info,ownerType.getOwnerFunction().getInstanceType());
        searchedForThisType=true;
      }
 else       if (ownerNode != null && ownerNode.isThis()) {
        JSType injectedThisType=ownerNode.getJSType();
        builder.inferThisType(info,injectedThisType == null ? scope.getTypeOfThis() : injectedThisType);
        searchedForThisType=true;
      }
      if (!searchedForThisType) {
        builder.inferThisType(info);
      }
      functionType=builder.inferParameterTypes(parametersNode,info).buildAndRegister();
    }
  }
  return functionType;
}","/** 
 * Creates a new function type, based on the given nodes. This handles two cases that are semantically very different, but are not mutually exclusive: - A function literal that needs a type attached to it. - An assignment expression with function-type info in the JsDoc. All parameters are optional, and we will do the best we can to create a function type. This function will always create a function type, so only call it if you're sure that's what you want.
 * @param rValue The function node.
 * @param name the function's name
 * @param info the {@link JSDocInfo} attached to the function definition
 * @param lvalueNode The node where this function is beingassigned. For example,  {@code A.prototype.foo = ...} would be used todetermine that this function is a method of A.prototype. May be null to indicate that this is not being assigned to a qualified name.
 */
private FunctionType createFunctionTypeFromNodes(@Nullable Node rValue,@Nullable String name,@Nullable JSDocInfo info,@Nullable Node lvalueNode){
  FunctionType functionType=null;
  if (rValue != null && rValue.isQualifiedName() && scope.isGlobal()) {
    Var var=scope.getVar(rValue.getQualifiedName());
    if (var != null && var.getType() != null && var.getType().isFunctionType()) {
      FunctionType aliasedType=var.getType().toMaybeFunctionType();
      if ((aliasedType.isConstructor() || aliasedType.isInterface()) && !aliasedType.isNativeObjectType()) {
        functionType=aliasedType;
        if (name != null && scope.isGlobal()) {
          typeRegistry.declareType(name,functionType.getInstanceType());
        }
      }
    }
  }
  if (functionType == null) {
    Node errorRoot=rValue == null ? lvalueNode : rValue;
    boolean isFnLiteral=rValue != null && rValue.isFunction();
    Node fnRoot=isFnLiteral ? rValue : null;
    Node parametersNode=isFnLiteral ? rValue.getFirstChild().getNext() : null;
    if (info != null && info.hasType()) {
      JSType type=info.getType().evaluate(scope,typeRegistry);
      type=type.restrictByNotNullOrUndefined();
      if (type.isFunctionType()) {
        functionType=type.toMaybeFunctionType();
        functionType.setJSDocInfo(info);
      }
    }
    if (functionType == null) {
      Node ownerNode=NodeUtil.getBestLValueOwner(lvalueNode);
      String ownerName=NodeUtil.getBestLValueName(ownerNode);
      Var ownerVar=null;
      String propName=null;
      ObjectType ownerType=null;
      if (ownerName != null) {
        ownerVar=scope.getVar(ownerName);
        if (ownerVar != null) {
          ownerType=ObjectType.cast(ownerVar.getType());
        }
        if (name != null) {
          propName=name.substring(ownerName.length() + 1);
        }
      }
      ObjectType prototypeOwner=getPrototypeOwnerType(ownerType);
      TemplateTypeMap prototypeOwnerTypeMap=null;
      if (prototypeOwner != null && prototypeOwner.getTypeOfThis() != null) {
        prototypeOwnerTypeMap=prototypeOwner.getTypeOfThis().getTemplateTypeMap();
      }
      FunctionType overriddenType=null;
      if (ownerType != null && propName != null) {
        overriddenType=findOverriddenFunction(ownerType,propName,prototypeOwnerTypeMap);
      }
      FunctionTypeBuilder builder=new FunctionTypeBuilder(name,compiler,errorRoot,sourceName,scope).setContents(getFunctionAnalysisResults(fnRoot)).inferFromOverriddenFunction(overriddenType,parametersNode).inferTemplateTypeName(info,prototypeOwner).inferInheritance(info);
      if (info == null || !info.hasReturnType()) {
        if (rValue != null && rValue.isFunction() && rValue.getFirstChild() != null) {
          JSDocInfo nameDocInfo=rValue.getFirstChild().getJSDocInfo();
          builder.inferReturnType(nameDocInfo,true);
        }
      }
 else {
        builder.inferReturnType(info,false);
      }
      boolean searchedForThisType=false;
      if (ownerType != null && ownerType.isFunctionPrototypeType() && ownerType.getOwnerFunction().hasInstanceType()) {
        builder.inferThisType(info,ownerType.getOwnerFunction().getInstanceType());
        searchedForThisType=true;
      }
 else       if (ownerNode != null && ownerNode.isThis()) {
        JSType injectedThisType=ownerNode.getJSType();
        builder.inferThisType(info,scope.getTypeOfThis());
        searchedForThisType=true;
      }
      if (!searchedForThisType) {
        builder.inferThisType(info);
      }
      functionType=builder.inferParameterTypes(parametersNode,info).buildAndRegister();
    }
  }
  return functionType;
}",0.9949137549756744
27784,"private void maybeCollectMember(Node member,Node nodeWithJsDocInfo,@Nullable Node value){
  JSDocInfo info=nodeWithJsDocInfo.getJSDocInfo();
  if (info == null || !member.isGetProp() || !member.getFirstChild().isThis()) {
    return;
  }
  member.getFirstChild().setJSType(thisType);
  JSType thisObjectType=thisType.toObjectType();
  if (thisObjectType != null) {
    ImmutableList<TemplateType> keys=thisObjectType.getTemplateTypeMap().getTemplateKeys();
    typeRegistry.setTemplateTypeNames(keys);
  }
  JSType jsType=getDeclaredType(info,member,value);
  if (thisObjectType != null) {
    typeRegistry.clearTemplateTypeNames();
  }
  Node name=member.getLastChild();
  if (jsType != null && (name.isName() || name.isString()) && thisType.toObjectType() != null) {
    thisType.toObjectType().defineDeclaredProperty(name.getString(),jsType,member);
  }
}","private void maybeCollectMember(Node member,Node nodeWithJsDocInfo,@Nullable Node value){
  JSDocInfo info=nodeWithJsDocInfo.getJSDocInfo();
  if (info == null || !member.isGetProp() || !member.getFirstChild().isThis()) {
    return;
  }
  JSType jsType=getDeclaredType(info,member,value);
  Node name=member.getLastChild();
  if (jsType != null) {
    thisTypeForProperties.defineDeclaredProperty(name.getString(),jsType,member);
  }
}",0.4049459041731066
27785,"/** 
 * Look for a type declaration on a property assignment (in an ASSIGN or an object literal key).
 * @param info The doc info for this property.
 * @param lValue The l-value node.
 * @param rValue The node that {@code n} is being initialized to,or  {@code null} if this is a stub declaration.
 */
private JSType getDeclaredType(JSDocInfo info,Node lValue,@Nullable Node rValue){
  if (info != null && info.hasType()) {
    return getDeclaredTypeInAnnotation(lValue,info);
  }
 else   if (rValue != null && rValue.isFunction() && shouldUseFunctionLiteralType(JSType.toMaybeFunctionType(rValue.getJSType()),info,lValue)) {
    return rValue.getJSType();
  }
 else   if (info != null) {
    if (info.hasEnumParameterType()) {
      if (rValue != null && rValue.isObjectLit()) {
        return rValue.getJSType();
      }
 else {
        return createEnumTypeFromNodes(rValue,lValue.getQualifiedName(),info,lValue);
      }
    }
 else     if (info.isConstructor() || info.isInterface()) {
      return createFunctionTypeFromNodes(rValue,lValue.getQualifiedName(),info,lValue);
    }
  }
  if (isConstantSymbol(info,lValue)) {
    if (rValue != null) {
      JSType rValueType=getDeclaredRValueType(lValue,rValue);
      if (rValueType != null) {
        return rValueType;
      }
    }
  }
  return getDeclaredTypeInAnnotation(lValue,info);
}","/** 
 * Look for a type declaration on a property assignment (in an ASSIGN or an object literal key).
 * @param info The doc info for this property.
 * @param lValue The l-value node.
 * @param rValue The node that {@code n} is being initialized to,or  {@code null} if this is a stub declaration.
 */
JSType getDeclaredType(JSDocInfo info,Node lValue,@Nullable Node rValue){
  if (info != null && info.hasType()) {
    return getDeclaredTypeInAnnotation(lValue,info);
  }
 else   if (rValue != null && rValue.isFunction() && shouldUseFunctionLiteralType(JSType.toMaybeFunctionType(rValue.getJSType()),info,lValue)) {
    return rValue.getJSType();
  }
 else   if (info != null) {
    if (info.hasEnumParameterType()) {
      if (rValue != null && rValue.isObjectLit()) {
        return rValue.getJSType();
      }
 else {
        return createEnumTypeFromNodes(rValue,lValue.getQualifiedName(),info,lValue);
      }
    }
 else     if (info.isConstructor() || info.isInterface()) {
      return createFunctionTypeFromNodes(rValue,lValue.getQualifiedName(),info,lValue);
    }
  }
  if (isConstantSymbol(info,lValue)) {
    if (rValue != null) {
      JSType rValueType=getDeclaredRValueType(lValue,rValue);
      if (rValueType != null) {
        return rValueType;
      }
    }
  }
  return getDeclaredTypeInAnnotation(lValue,info);
}",0.9970149253731344
27786,"/** 
 * Creates a scope with all types declared. Declares newly discovered types and type properties in the type registry.
 */
@Override public Scope createScope(Node root,Scope parent){
  Scope newScope=null;
  AbstractScopeBuilder scopeBuilder=null;
  if (parent == null) {
    JSType globalThis=typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);
    root.setJSType(globalThis);
    root.getFirstChild().setJSType(globalThis);
    root.getLastChild().setJSType(globalThis);
    (new FirstOrderFunctionAnalyzer(compiler,functionAnalysisResults)).process(root.getFirstChild(),root.getLastChild());
    newScope=createInitialScope(root);
    GlobalScopeBuilder globalScopeBuilder=new GlobalScopeBuilder(newScope);
    scopeBuilder=globalScopeBuilder;
    NodeTraversal.traverse(compiler,root,scopeBuilder);
  }
 else {
    newScope=new Scope(parent,root);
    LocalScopeBuilder localScopeBuilder=new LocalScopeBuilder(newScope);
    scopeBuilder=localScopeBuilder;
    localScopeBuilder.build();
  }
  scopeBuilder.resolveStubDeclarations();
  for (  Node functionNode : scopeBuilder.nonExternFunctions) {
    JSType type=functionNode.getJSType();
    if (type != null && type.isFunctionType()) {
      FunctionType fnType=type.toMaybeFunctionType();
      JSType fnThisType=fnType.getTypeOfThis();
      if (!fnThisType.isUnknownType()) {
        NodeTraversal.traverse(compiler,functionNode.getLastChild(),scopeBuilder.new CollectProperties(fnThisType));
      }
    }
  }
  if (parent == null) {
    codingConvention.defineDelegateProxyPrototypeProperties(typeRegistry,newScope,delegateProxyPrototypes,delegateCallingConventions);
  }
  newScope.setTypeResolver(scopeBuilder);
  return newScope;
}","/** 
 * Creates a scope with all types declared. Declares newly discovered types and type properties in the type registry.
 */
@Override public Scope createScope(Node root,Scope parent){
  Scope newScope=null;
  AbstractScopeBuilder scopeBuilder=null;
  if (parent == null) {
    JSType globalThis=typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);
    root.setJSType(globalThis);
    root.getFirstChild().setJSType(globalThis);
    root.getLastChild().setJSType(globalThis);
    (new FirstOrderFunctionAnalyzer(compiler,functionAnalysisResults)).process(root.getFirstChild(),root.getLastChild());
    newScope=createInitialScope(root);
    GlobalScopeBuilder globalScopeBuilder=new GlobalScopeBuilder(newScope);
    scopeBuilder=globalScopeBuilder;
    NodeTraversal.traverse(compiler,root,scopeBuilder);
  }
 else {
    newScope=new Scope(parent,root);
    LocalScopeBuilder localScopeBuilder=new LocalScopeBuilder(newScope);
    scopeBuilder=localScopeBuilder;
    localScopeBuilder.build();
  }
  scopeBuilder.resolveStubDeclarations();
  if (parent == null) {
    codingConvention.defineDelegateProxyPrototypeProperties(typeRegistry,newScope,delegateProxyPrototypes,delegateCallingConventions);
  }
  newScope.setTypeResolver(scopeBuilder);
  return newScope;
}",0.8548441166610794
27787,"/** 
 * @param scope The scope that we're building.
 */
private LocalScopeBuilder(Scope scope){
  super(scope);
}","/** 
 * @param scope The scope that we're building.
 */
private LocalScopeBuilder(Scope scope){
  super(scope);
  thisTypeForProperties=getThisTypeForCollectingProperties();
}",0.7847222222222222
27788,"public void testClassTemplateInheritance3(){
  testSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  assertEquals(""String_Node_Str"",findNameType(""String_Node_Str"",globalScope).toString());
  assertEquals(""String_Node_Str"",findNameType(""String_Node_Str"",globalScope).toString());
}","public void testClassTemplateInheritance3(){
  testSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  assertEquals(""String_Node_Str"",findNameType(""String_Node_Str"",globalScope).toString());
}",0.9265905383360522
27789,"@Override JSType resolveInternal(ErrorReporter t,StaticScope<JSType> scope){
  setResolvedTypeInternal(this);
  call=(ArrowType)safeResolve(call,t,scope);
  if (prototypeSlot != null) {
    prototypeSlot.setType(safeResolve(prototypeSlot.getType(),t,scope));
  }
  JSType maybeTypeOfThis=safeResolve(typeOfThis,t,scope);
  if (maybeTypeOfThis != null) {
    maybeTypeOfThis=maybeTypeOfThis.restrictByNotNullOrUndefined();
  }
  if (maybeTypeOfThis instanceof ObjectType) {
    typeOfThis=maybeTypeOfThis;
  }
  boolean changed=false;
  ImmutableList.Builder<ObjectType> resolvedInterfaces=ImmutableList.builder();
  for (  ObjectType iface : implementedInterfaces) {
    ObjectType resolvedIface=(ObjectType)iface.resolve(t,scope);
    resolvedInterfaces.add(resolvedIface);
    changed|=(resolvedIface != iface);
  }
  if (changed) {
    implementedInterfaces=resolvedInterfaces.build();
  }
  if (subTypes != null) {
    for (int i=0; i < subTypes.size(); i++) {
      subTypes.set(i,JSType.toMaybeFunctionType(subTypes.get(i).resolve(t,scope)));
    }
  }
  return super.resolveInternal(t,scope);
}","@Override JSType resolveInternal(ErrorReporter t,StaticScope<JSType> scope){
  setResolvedTypeInternal(this);
  call=(ArrowType)safeResolve(call,t,scope);
  if (prototypeSlot != null) {
    prototypeSlot.setType(safeResolve(prototypeSlot.getType(),t,scope));
  }
  JSType maybeTypeOfThis=safeResolve(typeOfThis,t,scope);
  if (maybeTypeOfThis != null) {
    if (maybeTypeOfThis.isNullType() || maybeTypeOfThis.isVoidType()) {
      typeOfThis=maybeTypeOfThis;
    }
 else {
      maybeTypeOfThis=ObjectType.cast(maybeTypeOfThis.restrictByNotNullOrUndefined());
      if (maybeTypeOfThis != null) {
        typeOfThis=maybeTypeOfThis;
      }
    }
  }
  boolean changed=false;
  ImmutableList.Builder<ObjectType> resolvedInterfaces=ImmutableList.builder();
  for (  ObjectType iface : implementedInterfaces) {
    ObjectType resolvedIface=(ObjectType)iface.resolve(t,scope);
    resolvedInterfaces.add(resolvedIface);
    changed|=(resolvedIface != iface);
  }
  if (changed) {
    implementedInterfaces=resolvedInterfaces.build();
  }
  if (subTypes != null) {
    for (int i=0; i < subTypes.size(); i++) {
      subTypes.set(i,JSType.toMaybeFunctionType(subTypes.get(i).resolve(t,scope)));
    }
  }
  return super.resolveInternal(t,scope);
}",0.8588486140724947
27790,"/** 
 * @see #createFromTypeNodes(Node,String,StaticScope) 
 */
private JSType createFromTypeNodesInternal(Node n,String sourceName,StaticScope<JSType> scope){
switch (n.getType()) {
case Token.LC:
    return createRecordTypeFromNodes(n.getFirstChild(),sourceName,scope);
case Token.BANG:
  return createFromTypeNodesInternal(n.getFirstChild(),sourceName,scope).restrictByNotNullOrUndefined();
case Token.QMARK:
Node firstChild=n.getFirstChild();
if (firstChild == null) {
return getNativeType(UNKNOWN_TYPE);
}
return createDefaultObjectUnion(createFromTypeNodesInternal(firstChild,sourceName,scope));
case Token.EQUALS:
return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(),sourceName,scope));
case Token.ELLIPSIS:
return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(),sourceName,scope));
case Token.STAR:
return getNativeType(ALL_TYPE);
case Token.LB:
return getNativeType(ARRAY_TYPE);
case Token.PIPE:
UnionTypeBuilder builder=new UnionTypeBuilder(this);
for (Node child=n.getFirstChild(); child != null; child=child.getNext()) {
builder.addAlternate(createFromTypeNodesInternal(child,sourceName,scope));
}
return builder.build();
case Token.EMPTY:
return getNativeType(UNKNOWN_TYPE);
case Token.VOID:
return getNativeType(VOID_TYPE);
case Token.STRING:
JSType namedType=getType(scope,n.getString(),sourceName,n.getLineno(),n.getCharno());
if ((namedType instanceof ObjectType) && !(namedType instanceof NamespaceType) && !(nonNullableTypeNames.contains(n.getString()))) {
Node typeList=n.getFirstChild();
int nAllowedTypes=namedType.getTemplateTypeMap().numUnfilledTemplateKeys();
if (typeList != null && nAllowedTypes > 0) {
ImmutableList.Builder<JSType> templateTypes=ImmutableList.builder();
if (n.getString().equals(""String_Node_Str"") && typeList.getFirstChild() == typeList.getLastChild()) {
templateTypes.add(getNativeType(UNKNOWN_TYPE));
}
int templateNodeIndex=0;
for (Node templateNode : typeList.getFirstChild().siblings()) {
if (++templateNodeIndex > nAllowedTypes) {
break;
}
templateTypes.add(createFromTypeNodesInternal(templateNode,sourceName,scope));
}
namedType=createTemplatizedType((ObjectType)namedType,templateTypes.build());
Preconditions.checkNotNull(namedType);
}
return createDefaultObjectUnion(namedType);
}
 else {
return namedType;
}
case Token.FUNCTION:
ObjectType thisType=null;
boolean isConstructor=false;
Node current=n.getFirstChild();
if (current.getType() == Token.THIS || current.getType() == Token.NEW) {
Node contextNode=current.getFirstChild();
thisType=ObjectType.cast(createFromTypeNodesInternal(contextNode,sourceName,scope).restrictByNotNullOrUndefined());
if (thisType == null) {
reporter.warning(SimpleErrorReporter.getMessage0(current.getType() == Token.THIS ? ""String_Node_Str"" : ""String_Node_Str""),sourceName,contextNode.getLineno(),contextNode.getCharno());
}
isConstructor=current.getType() == Token.NEW;
current=current.getNext();
}
FunctionParamBuilder paramBuilder=new FunctionParamBuilder(this);
if (current.getType() == Token.PARAM_LIST) {
for (Node arg=current.getFirstChild(); arg != null; arg=arg.getNext()) {
if (arg.getType() == Token.ELLIPSIS) {
if (arg.getChildCount() == 0) {
paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));
}
 else {
paramBuilder.addVarArgs(createFromTypeNodesInternal(arg.getFirstChild(),sourceName,scope));
}
}
 else {
JSType type=createFromTypeNodesInternal(arg,sourceName,scope);
if (arg.getType() == Token.EQUALS) {
boolean addSuccess=paramBuilder.addOptionalParams(type);
if (!addSuccess) {
reporter.warning(SimpleErrorReporter.getMessage0(""String_Node_Str""),sourceName,arg.getLineno(),arg.getCharno());
}
}
 else {
paramBuilder.addRequiredParams(type);
}
}
}
current=current.getNext();
}
JSType returnType=createFromTypeNodesInternal(current,sourceName,scope);
return new FunctionBuilder(this).withParams(paramBuilder).withReturnType(returnType).withTypeOfThis(thisType).setIsConstructor(isConstructor).build();
}
throw new IllegalStateException(""String_Node_Str"" + n.toString());
}","/** 
 * @see #createFromTypeNodes(Node,String,StaticScope) 
 */
private JSType createFromTypeNodesInternal(Node n,String sourceName,StaticScope<JSType> scope){
switch (n.getType()) {
case Token.LC:
    return createRecordTypeFromNodes(n.getFirstChild(),sourceName,scope);
case Token.BANG:
  return createFromTypeNodesInternal(n.getFirstChild(),sourceName,scope).restrictByNotNullOrUndefined();
case Token.QMARK:
Node firstChild=n.getFirstChild();
if (firstChild == null) {
return getNativeType(UNKNOWN_TYPE);
}
return createDefaultObjectUnion(createFromTypeNodesInternal(firstChild,sourceName,scope));
case Token.EQUALS:
return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(),sourceName,scope));
case Token.ELLIPSIS:
return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(),sourceName,scope));
case Token.STAR:
return getNativeType(ALL_TYPE);
case Token.LB:
return getNativeType(ARRAY_TYPE);
case Token.PIPE:
UnionTypeBuilder builder=new UnionTypeBuilder(this);
for (Node child=n.getFirstChild(); child != null; child=child.getNext()) {
builder.addAlternate(createFromTypeNodesInternal(child,sourceName,scope));
}
return builder.build();
case Token.EMPTY:
return getNativeType(UNKNOWN_TYPE);
case Token.VOID:
return getNativeType(VOID_TYPE);
case Token.STRING:
JSType namedType=getType(scope,n.getString(),sourceName,n.getLineno(),n.getCharno());
if ((namedType instanceof ObjectType) && !(namedType instanceof NamespaceType) && !(nonNullableTypeNames.contains(n.getString()))) {
Node typeList=n.getFirstChild();
int nAllowedTypes=namedType.getTemplateTypeMap().numUnfilledTemplateKeys();
if (typeList != null && nAllowedTypes > 0) {
ImmutableList.Builder<JSType> templateTypes=ImmutableList.builder();
if (n.getString().equals(""String_Node_Str"") && typeList.getFirstChild() == typeList.getLastChild()) {
templateTypes.add(getNativeType(UNKNOWN_TYPE));
}
int templateNodeIndex=0;
for (Node templateNode : typeList.getFirstChild().siblings()) {
if (++templateNodeIndex > nAllowedTypes) {
break;
}
templateTypes.add(createFromTypeNodesInternal(templateNode,sourceName,scope));
}
namedType=createTemplatizedType((ObjectType)namedType,templateTypes.build());
Preconditions.checkNotNull(namedType);
}
return createDefaultObjectUnion(namedType);
}
 else {
return namedType;
}
case Token.FUNCTION:
JSType thisType=null;
boolean isConstructor=false;
Node current=n.getFirstChild();
if (current.getType() == Token.THIS || current.getType() == Token.NEW) {
Node contextNode=current.getFirstChild();
JSType candidateThisType=createFromTypeNodesInternal(contextNode,sourceName,scope);
if (candidateThisType.isNullType() || candidateThisType.isVoidType()) {
thisType=candidateThisType;
}
 else {
thisType=ObjectType.cast(candidateThisType.restrictByNotNullOrUndefined());
if (thisType == null) {
reporter.warning(SimpleErrorReporter.getMessage0(current.getType() == Token.THIS ? ""String_Node_Str"" : ""String_Node_Str""),sourceName,contextNode.getLineno(),contextNode.getCharno());
}
}
isConstructor=current.getType() == Token.NEW;
current=current.getNext();
}
FunctionParamBuilder paramBuilder=new FunctionParamBuilder(this);
if (current.getType() == Token.PARAM_LIST) {
for (Node arg=current.getFirstChild(); arg != null; arg=arg.getNext()) {
if (arg.getType() == Token.ELLIPSIS) {
if (arg.getChildCount() == 0) {
paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));
}
 else {
paramBuilder.addVarArgs(createFromTypeNodesInternal(arg.getFirstChild(),sourceName,scope));
}
}
 else {
JSType type=createFromTypeNodesInternal(arg,sourceName,scope);
if (arg.getType() == Token.EQUALS) {
boolean addSuccess=paramBuilder.addOptionalParams(type);
if (!addSuccess) {
reporter.warning(SimpleErrorReporter.getMessage0(""String_Node_Str""),sourceName,arg.getLineno(),arg.getCharno());
}
}
 else {
paramBuilder.addRequiredParams(type);
}
}
}
current=current.getNext();
}
JSType returnType=createFromTypeNodesInternal(current,sourceName,scope);
return new FunctionBuilder(this).withParams(paramBuilder).withReturnType(returnType).withTypeOfThis(thisType).setIsConstructor(isConstructor).build();
}
throw new IllegalStateException(""String_Node_Str"" + n.toString());
}",0.8690127077223851
27791,"/** 
 * Records the assignment of a value to a global name.
 * @param name Fully qualified name
 * @param node The top node representing the name (GETPROP, NAME, or STRING[objlit key])
 */
private void recordSet(String name,Node node){
  JsName jsn=getName(name,true);
  JsNameRefNode nameRefNode=new JsNameRefNode(jsn,node);
  refNodes.add(nameRefNode);
  if (node.isGetElem()) {
    recordWriteOnProperties(name);
  }
 else   if (name.indexOf('.') != -1) {
    recordWriteOnProperties(name.substring(0,name.lastIndexOf('.')));
  }
}","/** 
 * Records the assignment of a value to a global name.
 * @param name Fully qualified name
 * @param node The top node representing the name (GETPROP, NAME, or STRING[objlit key])
 */
private void recordSet(String name,Node node){
  JsName jsn=getName(name,true);
  JsNameRefNode nameRefNode=new JsNameRefNode(jsn,node);
  refNodes.add(nameRefNode);
  jsn.hasSetterReference=true;
  if (node.isGetElem()) {
    recordWriteOnProperties(name);
  }
 else   if (name.indexOf('.') != -1) {
    recordWriteOnProperties(name.substring(0,name.lastIndexOf('.')));
  }
}",0.9717925386715196
27792,"@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (!(n.isName() || (NodeUtil.isGet(n) && !parent.isGetProp()))) {
    return;
  }
  NameInformation nameInfo=createNameInformation(t,n);
  if (nameInfo == null) {
    return;
  }
  if (nameInfo.onlyAffectsClassDef) {
    if (nameInfo.superclass != null) {
      recordReference(nameInfo.name,nameInfo.superclass,RefType.INHERITANCE);
    }
    String nodeName=n.getQualifiedName();
    if (nodeName != null) {
      recordReference(nameInfo.name,nodeName,RefType.REGULAR);
    }
    return;
  }
  if (parent.isInstanceOf() && parent.getLastChild() == n && n.isQualifiedName()) {
    JsName checkedClass=getName(nameInfo.name,true);
    refNodes.add(new InstanceOfCheckNode(checkedClass,n));
    checkedClass.hasInstanceOfReference=true;
    return;
  }
  List<NameInformation> referers=getDependencyScope(n);
  if (referers.isEmpty()) {
    maybeRecordReferenceOrAlias(t,n,parent,nameInfo,null);
  }
 else {
    for (    NameInformation referring : referers) {
      maybeRecordReferenceOrAlias(t,n,parent,nameInfo,referring);
    }
    recordAliases(referers);
  }
}","@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (!(n.isName() || (NodeUtil.isGet(n) && !parent.isGetProp()))) {
    return;
  }
  NameInformation nameInfo=createNameInformation(t,n);
  if (nameInfo == null) {
    return;
  }
  if (nameInfo.onlyAffectsClassDef) {
    if (nameInfo.superclass != null) {
      recordReference(nameInfo.name,nameInfo.superclass,RefType.INHERITANCE);
    }
    String nodeName=n.getQualifiedName();
    if (nodeName != null) {
      recordReference(nameInfo.name,nodeName,RefType.REGULAR);
    }
    return;
  }
  boolean isInstanceOfCheck=parent.isInstanceOf() && parent.getLastChild() == n;
  if (isInstanceOfCheck) {
    JsName checkedClass=getName(nameInfo.name,true);
    if (checkedClass.hasSetterReference && !nameInfo.isExternallyReferenceable && n.isQualifiedName()) {
      refNodes.add(new InstanceOfCheckNode(checkedClass,n));
      checkedClass.hasInstanceOfReference=true;
      return;
    }
  }
  List<NameInformation> referers=getDependencyScope(n);
  if (referers.isEmpty()) {
    maybeRecordReferenceOrAlias(t,n,parent,nameInfo,null);
  }
 else {
    for (    NameInformation referring : referers) {
      maybeRecordReferenceOrAlias(t,n,parent,nameInfo,referring);
    }
    recordAliases(referers);
  }
}",0.7797594359187059
27793,"@Override public void process(Node externs,Node root){
  logger.fine(""String_Node_Str"");
  if (graph != null && graph.getModuleCount() > 1) {
    NodeTraversal.traverse(compiler,root,this);
    if (parentModuleCanSeeSymbolsDeclaredInChildren) {
      makeInstanceOfCodeOrderIndependent();
    }
    moveCode();
  }
}","@Override public void process(Node externs,Node root){
  logger.fine(""String_Node_Str"");
  if (graph != null && graph.getModuleCount() > 1) {
    collectReferences(root);
    if (parentModuleCanSeeSymbolsDeclaredInChildren) {
      makeInstanceOfCodeOrderIndependent();
    }
    moveCode();
  }
}",0.8972267536704731
27794,"/** 
 * Process the references to named variables
 */
private void processReference(NodeTraversal t,NamedInfo info,String name){
  boolean recursive=false;
  Node rootNode=t.getScope().getRootNode();
  if (rootNode.isFunction()) {
    String scopeFuncName=rootNode.getFirstChild().getString();
    Node scopeFuncParent=rootNode.getParent();
    if (scopeFuncName.equals(name)) {
      recursive=true;
    }
 else     if (scopeFuncParent.isName() && scopeFuncParent.getString().equals(name)) {
      recursive=true;
    }
 else {
      for (Scope s=t.getScope(); s.getParent() != null; s=s.getParent()) {
        Node curRoot=s.getRootNode();
        if (curRoot.getParent().isAssign()) {
          Node owner=curRoot.getParent().getFirstChild();
          while (owner.isGetProp()) {
            owner=owner.getFirstChild();
          }
          if (owner.isName() && owner.getString().equals(name)) {
            recursive=true;
            break;
          }
        }
      }
    }
  }
  if (!recursive) {
    info.addUsedModule(t.getModule());
  }
}","private void processReference(ReferenceCollectingCallback collector,Reference ref,NamedInfo info){
  Node n=ref.getNode();
  Node parent=n.getParent();
  if (info.allowMove) {
    if (maybeProcessDeclaration(collector,ref,info)) {
      if (hasConditionalAncestor(parent.getParent())) {
        info.allowMove=false;
      }
    }
 else {
      if (parentModuleCanSeeSymbolsDeclaredInChildren && parent.isInstanceOf() && parent.getLastChild() == n) {
        instanceofNodes.put(parent,new InstanceofInfo(getModule(ref),info));
      }
 else {
        processRead(ref,info);
      }
    }
  }
}",0.0631067961165048
27795,"/** 
 * Determines whether the given NAME node belongs to a declaration that can be moved across modules. If it is, registers it properly. There are four types of movable declarations: 1) var NAME = [movable object]; 2) function NAME() {} 3) NAME = [movable object]; NAME.prop = [movable object]; NAME.prop.prop2 = [movable object]; etc. 4) Class-defining function calls, like ""inherits"" and ""mixin"". NAME.inherits([some other name]); where ""movable object"" is a literal or a function.
 */
private boolean maybeProcessDeclaration(NodeTraversal t,Node name,Node parent,NamedInfo info){
  Node gramps=parent.getParent();
switch (parent.getType()) {
case Token.VAR:
    if (canMoveValue(name.getFirstChild())) {
      return info.addDeclaration(new Declaration(t.getModule(),name));
    }
  return false;
case Token.FUNCTION:
if (NodeUtil.isFunctionDeclaration(parent)) {
  return info.addDeclaration(new Declaration(t.getModule(),name));
}
return false;
case Token.ASSIGN:
case Token.GETPROP:
Node child=name;
for (Node current : name.getAncestors()) {
if (current.isGetProp()) {
}
 else if (current.isAssign() && current.getFirstChild() == child) {
Node currentParent=current.getParent();
if (currentParent.isExprResult() && canMoveValue(current.getLastChild())) {
return info.addDeclaration(new Declaration(t.getModule(),current));
}
}
 else {
return false;
}
child=current;
}
return false;
case Token.CALL:
if (NodeUtil.isExprCall(gramps)) {
SubclassRelationship relationship=compiler.getCodingConvention().getClassesDefinedByCall(parent);
if (relationship != null && name.getString().equals(relationship.subclassName)) {
return info.addDeclaration(new Declaration(t.getModule(),parent));
}
}
return false;
default :
return false;
}
}","/** 
 * Determines whether the given NAME node belongs to a declaration that can be moved across modules. If it is, registers it properly. There are four types of movable declarations: 1) var NAME = [movable object]; 2) function NAME() {} 3) NAME = [movable object]; NAME.prop = [movable object]; NAME.prop.prop2 = [movable object]; etc. 4) Class-defining function calls, like ""inherits"" and ""mixin"". NAME.inherits([some other name]); where ""movable object"" is a literal or a function.
 */
private boolean maybeProcessDeclaration(ReferenceCollectingCallback collector,Reference ref,NamedInfo info){
  Node name=ref.getNode();
  Node parent=name.getParent();
  Node gramps=parent.getParent();
switch (parent.getType()) {
case Token.VAR:
    if (canMoveValue(collector,ref.getScope(),name.getFirstChild())) {
      return info.addDeclaration(new Declaration(getModule(ref),name));
    }
  return false;
case Token.FUNCTION:
if (NodeUtil.isFunctionDeclaration(parent)) {
  return info.addDeclaration(new Declaration(getModule(ref),name));
}
return false;
case Token.ASSIGN:
case Token.GETPROP:
Node child=name;
for (Node current : name.getAncestors()) {
if (current.isGetProp()) {
}
 else if (current.isAssign() && current.getFirstChild() == child) {
Node currentParent=current.getParent();
if (currentParent.isExprResult() && canMoveValue(collector,ref.getScope(),current.getLastChild())) {
return info.addDeclaration(new Declaration(getModule(ref),current));
}
}
 else {
return false;
}
child=current;
}
return false;
case Token.CALL:
if (NodeUtil.isExprCall(gramps)) {
SubclassRelationship relationship=compiler.getCodingConvention().getClassesDefinedByCall(parent);
if (relationship != null && name.getString().equals(relationship.subclassName)) {
return info.addDeclaration(new Declaration(getModule(ref),parent));
}
}
return false;
default :
return false;
}
}",0.9402279677509036
27796,"/** 
 * Determines whether the given value is eligible to be moved across modules.
 */
private boolean canMoveValue(Node n){
  if (n == null || NodeUtil.isLiteralValue(n,true) || n.isFunction()) {
    return true;
  }
 else   if (n.isCall()) {
    Node functionName=n.getFirstChild();
    return functionName.isName() && (functionName.getString().equals(CrossModuleMethodMotion.STUB_METHOD_NAME) || functionName.getString().equals(CrossModuleMethodMotion.UNSTUB_METHOD_NAME));
  }
 else   if (n.isArrayLit() || n.isObjectLit()) {
    boolean isObjectLit=n.isObjectLit();
    for (Node child=n.getFirstChild(); child != null; child=child.getNext()) {
      if (!canMoveValue(isObjectLit ? child.getFirstChild() : child)) {
        return false;
      }
    }
    return true;
  }
  return false;
}","/** 
 * Determines whether the given value is eligible to be moved across modules.
 */
private boolean canMoveValue(ReferenceCollectingCallback collector,Scope scope,Node n){
  if (n == null || NodeUtil.isLiteralValue(n,true) || n.isFunction()) {
    return true;
  }
 else   if (n.isCall()) {
    Node functionName=n.getFirstChild();
    return functionName.isName() && (functionName.getString().equals(CrossModuleMethodMotion.STUB_METHOD_NAME) || functionName.getString().equals(CrossModuleMethodMotion.UNSTUB_METHOD_NAME));
  }
 else   if (n.isArrayLit() || n.isObjectLit()) {
    boolean isObjectLit=n.isObjectLit();
    for (Node child=n.getFirstChild(); child != null; child=child.getNext()) {
      if (!canMoveValue(collector,scope,isObjectLit ? child.getFirstChild() : child)) {
        return false;
      }
    }
    return true;
  }
 else   if (n.isName()) {
    Var v=scope.getVar(n.getString());
    if (v != null && v.isGlobal()) {
      ReferenceCollection refCollection=collector.getReferences(v);
      if (refCollection != null && refCollection.isWellDefined() && refCollection.isAssignedOnceInLifetime()) {
        return true;
      }
    }
  }
  return false;
}",0.7913087417887822
27797,"/** 
 * FieldName := NameExpression | StringLiteral | NumberLiteral | ReservedIdentifier
 */
private Node parseFieldName(JsDocToken token){
switch (token) {
case STRING:
    String string=stream.getString();
  return newStringNode(string);
default :
return null;
}
}","/** 
 * FieldName := NameExpression | StringLiteral | NumberLiteral | ReservedIdentifier
 */
private Node parseFieldName(JsDocToken token){
switch (token) {
case STRING:
    String s=stream.getString();
  Node n=Node.newString(Token.STRING_KEY,s,stream.getLineno(),stream.getCharno()).clonePropsFrom(templateNode);
n.setLength(s.length());
return n;
default :
return null;
}
}",0.7538940809968847
27798,"private Node getBody(){
  if (root.isFunction()) {
    return NodeUtil.getFunctionBody(root);
  }
 else {
    return root;
  }
}","private Node getBody(){
  Preconditions.checkState(root.isFunction());
  return NodeUtil.getFunctionBody(root);
}",0.7385892116182573
27799,"/** 
 * @param requiredType The context requires this type; warn if the expressiondoesn't have this type.
 * @param specializedType Used in boolean contexts to infer types of names.Invariant: specializedType is a subtype of requiredType.
 */
private EnvTypePair analyzeExprFwd(Node expr,TypeEnv inEnv,JSType requiredType,JSType specializedType){
  Preconditions.checkArgument(requiredType != null && !requiredType.isBottom());
  int exprKind=expr.getType();
switch (exprKind) {
case Token.EMPTY:
    return new EnvTypePair(inEnv,JSType.UNKNOWN);
case Token.FUNCTION:
{
    String fnName=symbolTable.getFunInternalName(expr);
    return new EnvTypePair(inEnv,envGetType(inEnv,fnName));
  }
case Token.FALSE:
case Token.NULL:
case Token.NUMBER:
case Token.STRING:
case Token.TRUE:
return new EnvTypePair(inEnv,scalarValueToType(exprKind));
case Token.OBJECTLIT:
{
JSType result=JSType.TOP_OBJECT;
TypeEnv env=inEnv;
for (Node key : expr.children()) {
  String pname=NodeUtil.getObjectLitKeyName(key);
  JSType reqPtype=requiredType.mayHaveProp(pname) ? requiredType.getProp(pname) : JSType.TOP;
  JSType specPtype=specializedType.mayHaveProp(pname) ? specializedType.getProp(pname) : JSType.TOP;
  EnvTypePair pair=analyzeExprFwd(key.getLastChild(),env,reqPtype,specPtype);
  result=result.withProperty(pname,pair.type);
  env=pair.env;
}
return new EnvTypePair(env,result);
}
case Token.THIS:
{
if (!currentScope.hasThis()) {
warnings.add(JSError.make(expr,CheckGlobalThis.GLOBAL_THIS));
return new EnvTypePair(inEnv,JSType.UNKNOWN);
}
JSType thisType=currentScope.getDeclaredTypeOf(""String_Node_Str"");
return new EnvTypePair(inEnv,thisType);
}
case Token.NAME:
{
String varName=expr.getQualifiedName();
if (varName.equals(""String_Node_Str"")) {
return new EnvTypePair(inEnv,JSType.UNDEFINED);
}
if (currentScope.isLocalVar(varName) || currentScope.isFormalParam(varName) || currentScope.isLocalFunDef(varName)|| currentScope.isOuterVar(varName)) {
JSType inferredType=envGetType(inEnv,varName);
println(varName,""String_Node_Str"",inferredType,""String_Node_Str"",requiredType);
if (!inferredType.isSubtypeOf(requiredType)) {
if (currentScope.getDeclaredTypeOf(varName) == null && inferredType.equals(JSType.NUM_OR_STR) && requiredType.isSubtypeOf(inferredType)) {
  inferredType=requiredType;
}
 else {
  return new EnvTypePair(inEnv,inferredType);
}
}
JSType preciseType=inferredType.specialize(specializedType);
println(varName,""String_Node_Str"",preciseType);
if (!preciseType.isBottom() && currentScope.isUndeclaredFormal(varName) && requiredType.hasNonScalar()) {
preciseType=preciseType.withLoose();
}
return EnvTypePair.addBinding(inEnv,varName,preciseType);
}
println(""String_Node_Str"",varName);
return new EnvTypePair(inEnv,JSType.UNKNOWN);
}
case Token.AND:
case Token.OR:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
if ((specializedType.isTruthy() && exprKind == Token.AND) || (specializedType.isFalsy() && exprKind == Token.OR)) {
EnvTypePair lhsPair=analyzeExprFwd(lhs,inEnv,JSType.TOP,specializedType);
EnvTypePair rhsPair=analyzeExprFwd(rhs,lhsPair.env,JSType.TOP,specializedType);
return rhsPair;
}
 else if ((specializedType.isFalsy() && exprKind == Token.AND) || (specializedType.isTruthy() && exprKind == Token.OR)) {
EnvTypePair shortCircuitPair=analyzeExprFwd(lhs,inEnv,JSType.TOP,specializedType);
JSType negatedType=specializedType.isTruthy() ? JSType.FALSY : JSType.TRUTHY;
EnvTypePair lhsPair=analyzeExprFwd(lhs,inEnv,JSType.TOP,negatedType);
EnvTypePair rhsPair=analyzeExprFwd(rhs,lhsPair.env,JSType.TOP,specializedType);
return EnvTypePair.join(rhsPair,shortCircuitPair);
}
 else {
EnvTypePair lhsPair=analyzeExprFwd(lhs,inEnv);
EnvTypePair rhsPair=analyzeExprFwd(rhs,lhsPair.env);
return rhsPair;
}
}
case Token.INC:
case Token.DEC:
case Token.BITNOT:
case Token.POS:
case Token.NEG:
{
Node child=expr.getFirstChild();
EnvTypePair pair=analyzeExprFwd(child,inEnv,JSType.NUMBER);
if (!pair.type.isSubtypeOf(JSType.NUMBER)) {
warnInvalidOperand(child,expr.getType(),JSType.NUMBER,pair.type);
}
pair.type=JSType.NUMBER;
return pair;
}
case Token.TYPEOF:
{
EnvTypePair pair=analyzeExprFwd(expr.getFirstChild(),inEnv);
pair.type=JSType.STRING;
return pair;
}
case Token.INSTANCEOF:
{
Node obj=expr.getFirstChild();
Node ctor=expr.getLastChild();
EnvTypePair objPair, ctorPair;
objPair=analyzeExprFwd(obj,inEnv);
JSType objType=objPair.type;
if (!objType.equals(JSType.TOP) && !objType.equals(JSType.UNKNOWN) && !objType.hasNonScalar()) {
warnInvalidOperand(obj,Token.INSTANCEOF,""String_Node_Str"",objPair.type);
}
ctorPair=analyzeExprFwd(ctor,objPair.env,JSType.topFunction());
JSType ctorType=ctorPair.type;
FunctionType ctorFunType=ctorType.getFunType();
if (!ctorType.isUnknown() && (!ctorType.isSubtypeOf(JSType.topFunction()) || !ctorFunType.isConstructor())) {
warnInvalidOperand(ctor,Token.INSTANCEOF,""String_Node_Str"",ctorType);
}
if (ctorFunType == null || !ctorFunType.isConstructor() || (!specializedType.isTruthy() && !specializedType.isFalsy())) {
ctorPair.type=JSType.BOOLEAN;
return ctorPair;
}
JSType instanceType=ctorFunType.getTypeOfThis();
objPair=analyzeExprFwd(obj,inEnv,JSType.TOP,specializedType.isTruthy() ? objPair.type.specialize(instanceType) : objPair.type.removeType(instanceType));
ctorPair=analyzeExprFwd(ctor,objPair.env,JSType.topFunction());
ctorPair.type=JSType.BOOLEAN;
return ctorPair;
}
case Token.ADD:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
EnvTypePair lhsPair=analyzeExprFwd(lhs,inEnv,JSType.NUM_OR_STR);
EnvTypePair rhsPair=analyzeExprFwd(rhs,lhsPair.env,JSType.NUM_OR_STR);
JSType lhsType=lhsPair.type;
JSType rhsType=rhsPair.type;
if (!lhsType.isSubtypeOf(JSType.NUM_OR_STR)) {
warnInvalidOperand(lhs,expr.getType(),JSType.NUM_OR_STR,lhsType);
}
if (!rhsType.isSubtypeOf(JSType.NUM_OR_STR)) {
warnInvalidOperand(rhs,expr.getType(),JSType.NUM_OR_STR,rhsType);
}
return new EnvTypePair(rhsPair.env,JSType.plus(lhsType,rhsType));
}
case Token.BITOR:
case Token.BITAND:
case Token.BITXOR:
case Token.DIV:
case Token.LSH:
case Token.MOD:
case Token.MUL:
case Token.RSH:
case Token.SUB:
case Token.URSH:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
EnvTypePair lhsPair=analyzeExprFwd(lhs,inEnv,JSType.NUMBER);
EnvTypePair rhsPair=analyzeExprFwd(rhs,lhsPair.env,JSType.NUMBER);
if (!lhsPair.type.isSubtypeOf(JSType.NUMBER)) {
warnInvalidOperand(lhs,expr.getType(),JSType.NUMBER,lhsPair.type);
}
if (!rhsPair.type.isSubtypeOf(JSType.NUMBER)) {
warnInvalidOperand(rhs,expr.getType(),JSType.NUMBER,rhsPair.type);
}
rhsPair.type=JSType.NUMBER;
return rhsPair;
}
case Token.ASSIGN:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
LValueResult lvalue=analyzeLValueFwd(lhs,inEnv,requiredType);
JSType declType=lvalue.declType;
EnvTypePair rhsPair=analyzeExprFwd(rhs,lvalue.env,requiredType,specializedType);
JSType rhsType=rhsPair.type;
if (declType != null && !rhsType.isSubtypeOf(declType)) {
warnings.add(JSError.make(expr,MISTYPED_ASSIGN_RHS,declType.toString(),rhsType.toString()));
rhsType=declType;
}
return new EnvTypePair(updateLvalueTypeInEnv(rhsPair.env,lhs,lvalue.ptr,rhsType),rhsType);
}
case Token.ASSIGN_ADD:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
JSType lhsReqType=specializeWithCorrection(requiredType,JSType.NUM_OR_STR);
LValueResult lvalue=analyzeLValueFwd(lhs,inEnv,lhsReqType);
JSType lhsType=lvalue.type;
if (!lhsType.isSubtypeOf(JSType.NUM_OR_STR)) {
warnInvalidOperand(lhs,Token.ASSIGN_ADD,JSType.NUM_OR_STR,lhsType);
}
JSType rhsReqType=lhsType.equals(JSType.NUMBER) ? JSType.NUMBER : JSType.NUM_OR_STR;
EnvTypePair pair=analyzeExprFwd(rhs,lvalue.env,rhsReqType);
if (!pair.type.isSubtypeOf(rhsReqType)) {
warnInvalidOperand(rhs,Token.ASSIGN_ADD,rhsReqType,pair.type);
}
return pair;
}
case Token.ASSIGN_BITOR:
case Token.ASSIGN_BITXOR:
case Token.ASSIGN_BITAND:
case Token.ASSIGN_LSH:
case Token.ASSIGN_RSH:
case Token.ASSIGN_URSH:
case Token.ASSIGN_SUB:
case Token.ASSIGN_MUL:
case Token.ASSIGN_DIV:
case Token.ASSIGN_MOD:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
LValueResult lvalue=analyzeLValueFwd(lhs,inEnv,JSType.NUMBER);
JSType lhsType=lvalue.type;
if (!lhsType.isSubtypeOf(JSType.NUMBER)) {
warnInvalidOperand(lhs,expr.getType(),JSType.NUMBER,lhsType);
}
EnvTypePair pair=analyzeExprFwd(rhs,lvalue.env,JSType.NUMBER);
if (!pair.type.isSubtypeOf(JSType.NUMBER)) {
warnInvalidOperand(rhs,expr.getType(),JSType.NUMBER,pair.type);
}
return new EnvTypePair(updateLvalueTypeInEnv(pair.env,lhs,lvalue.ptr,JSType.NUMBER),JSType.NUMBER);
}
case Token.SHEQ:
case Token.SHNE:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
EnvTypePair lhsPair=analyzeExprFwd(lhs,inEnv);
EnvTypePair rhsPair=analyzeExprFwd(rhs,lhsPair.env);
if ((exprKind == Token.SHEQ && specializedType.isTruthy()) || (exprKind == Token.SHNE && specializedType.isFalsy())) {
JSType meetType=JSType.meet(lhsPair.type,rhsPair.type);
lhsPair=analyzeExprFwd(lhs,rhsPair.env,JSType.TOP,meetType);
rhsPair=analyzeExprFwd(rhs,lhsPair.env,JSType.TOP,meetType);
}
 else if ((exprKind == Token.SHEQ && specializedType.isFalsy()) || (exprKind == Token.SHNE && specializedType.isTruthy())) {
JSType lhsType=lhsPair.type;
JSType rhsType=rhsPair.type;
if (lhsType.equals(JSType.NULL) || lhsType.equals(JSType.UNDEFINED)) {
rhsType=rhsType.removeType(lhsType);
}
 else if (rhsType.equals(JSType.NULL) || rhsType.equals(JSType.UNDEFINED)) {
lhsType=lhsType.removeType(rhsType);
}
lhsPair=analyzeExprFwd(lhs,rhsPair.env,JSType.TOP,lhsType);
rhsPair=analyzeExprFwd(rhs,lhsPair.env,JSType.TOP,rhsType);
}
rhsPair.type=JSType.BOOLEAN;
return rhsPair;
}
case Token.EQ:
case Token.NE:
return analyzeNonStrictComparisonFwd(expr,inEnv,requiredType,specializedType);
case Token.LT:
case Token.GT:
case Token.LE:
case Token.GE:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
EnvTypePair lhsPair=analyzeExprFwd(lhs,inEnv);
EnvTypePair rhsPair=analyzeExprFwd(rhs,lhsPair.env);
if (lhsPair.type.isScalar() && rhsPair.type.isUnknown()) {
rhsPair=analyzeExprFwd(rhs,lhsPair.env,lhsPair.type);
}
 else if (lhsPair.type.isUnknown() && rhsPair.type.isScalar()) {
lhsPair=analyzeExprFwd(lhs,inEnv,rhsPair.type);
rhsPair=analyzeExprFwd(rhs,lhsPair.env,rhsPair.type);
}
 else if (lhs.isVar() && lhsPair.type.isUnknown() && rhs.isVar()&& rhsPair.type.isUnknown()) {
TypeEnv env=envPutType(rhsPair.env,lhs.getQualifiedName(),JSType.TOP_SCALAR);
env=envPutType(rhsPair.env,rhs.getQualifiedName(),JSType.TOP_SCALAR);
return new EnvTypePair(env,JSType.BOOLEAN);
}
JSType lhsType=lhsPair.type;
JSType rhsType=rhsPair.type;
if (!lhsType.isSubtypeOf(JSType.TOP_SCALAR) || !rhsType.isSubtypeOf(JSType.TOP_SCALAR) || !JSType.areCompatibleScalarTypes(lhsType,rhsType)) {
warnInvalidOperand(expr,exprKind,""String_Node_Str"",lhsType.toString() + ""String_Node_Str"" + rhsType.toString());
}
rhsPair.type=JSType.BOOLEAN;
return rhsPair;
}
case Token.GETPROP:
Preconditions.checkState(!NodeUtil.isAssignmentOp(expr.getParent()) || !NodeUtil.isLValue(expr));
return analyzePropAccessFwd(expr.getFirstChild(),expr.getLastChild().getString(),inEnv,requiredType,specializedType);
case Token.HOOK:
{
Node cond=expr.getFirstChild();
Node thenBranch=cond.getNext();
Node elseBranch=thenBranch.getNext();
TypeEnv trueEnv=analyzeExprFwd(cond,inEnv,JSType.TOP,JSType.TRUE_TYPE).env;
TypeEnv falseEnv=analyzeExprFwd(cond,inEnv,JSType.TOP,JSType.FALSE_TYPE).env;
EnvTypePair thenPair=analyzeExprFwd(thenBranch,trueEnv,requiredType,specializedType);
EnvTypePair elsePair=analyzeExprFwd(elseBranch,falseEnv,requiredType,specializedType);
return EnvTypePair.join(thenPair,elsePair);
}
case Token.CALL:
case Token.NEW:
{
Node callee=expr.getFirstChild();
EnvTypePair calleePair=analyzeExprFwd(callee,inEnv,JSType.topFunction());
JSType calleeType=calleePair.type;
if (!calleeType.isSubtypeOf(JSType.topFunction())) {
warnings.add(JSError.make(expr,TypeCheck.NOT_CALLABLE,calleeType.toString()));
}
FunctionType funType=calleeType.getFunType();
if (funType == null || funType.isTopFunction()) {
return new EnvTypePair(inEnv,requiredType);
}
 else if (funType.isLoose()) {
return analyzeLooseCallNodeFwd(expr,inEnv,requiredType);
}
 else if (expr.isCall() && funType.isConstructor()) {
warnings.add(JSError.make(expr,TypeCheck.CONSTRUCTOR_NOT_CALLABLE,funType.toString()));
return new EnvTypePair(inEnv,requiredType);
}
 else if (expr.isNew() && !funType.isConstructor()) {
warnings.add(JSError.make(expr,TypeCheck.NOT_A_CONSTRUCTOR,funType.toString()));
return new EnvTypePair(inEnv,requiredType);
}
int maxArity=funType.getMaxArity();
int minArity=funType.getMinArity();
int numArgs=expr.getChildCount() - 1;
if (numArgs < minArity || numArgs > maxArity) {
warnings.add(JSError.make(expr,TypeCheck.WRONG_ARGUMENT_COUNT,""String_Node_Str"",Integer.toString(numArgs),Integer.toString(minArity),""String_Node_Str"" + maxArity));
}
List<JSType> argTypes=Lists.newArrayList();
TypeEnv tmpEnv=inEnv;
for (int i=0; i < numArgs; i++) {
JSType formalType=(i < maxArity) ? funType.getFormalType(i) : JSType.TOP;
if (formalType.isBottom()) {
warnings.add(JSError.make(expr,CALL_FUNCTION_WITH_BOTTOM_FORMAL,Integer.toString(i)));
formalType=JSType.TOP;
}
Node arg=expr.getChildAtIndex(i + 1);
EnvTypePair pair=analyzeExprFwd(arg,tmpEnv,formalType);
if (!pair.type.isSubtypeOf(formalType)) {
warnings.add(JSError.make(arg,INVALID_ARGUMENT_TYPE,Integer.toString(i + 1),""String_Node_Str"",formalType.toString(),pair.type.toString()));
pair.type=JSType.UNKNOWN;
}
if (i < maxArity) {
Preconditions.checkState(!pair.type.equals(JSType.topFunction()));
argTypes.add(pair.type);
}
tmpEnv=pair.env;
}
JSType retType=funType.getReturnType();
if (callee.isName()) {
String calleeName=callee.getQualifiedName();
if (currentScope.isKnownFunction(calleeName)) {
if (currentScope.isLocalFunDef(calleeName)) {
collectTypesForFreeVarsFwd(callee,tmpEnv);
}
 else {
JSType expectedRetType=requiredType;
println(""String_Node_Str"",expectedRetType,""String_Node_Str"",argTypes);
DeferredCheck dc;
if (expr.isCall()) {
dc=deferredChecks.get(expr);
dc.updateReturn(expectedRetType);
}
 else {
dc=new DeferredCheck(expr,currentScope,currentScope.getScope(calleeName));
dc.updateReturn(JSType.TOP);
deferredChecks.put(expr,dc);
}
dc.updateArgTypes(argTypes);
}
}
}
return new EnvTypePair(tmpEnv,retType);
}
case Token.COMMA:
return analyzeExprFwd(expr.getLastChild(),analyzeExprFwd(expr.getFirstChild(),inEnv).env,requiredType,specializedType);
case Token.NOT:
{
EnvTypePair pair=analyzeExprFwd(expr.getFirstChild(),inEnv,JSType.TOP,specializedType.negate());
pair.type=pair.type.negate().toBoolean();
return pair;
}
case Token.GETELEM:
{
Node receiver=expr.getFirstChild();
Node index=expr.getLastChild();
if (index.isString()) {
return analyzePropAccessFwd(receiver,index.getString(),inEnv,requiredType,specializedType);
}
EnvTypePair pair=analyzeExprFwd(index,inEnv);
pair=analyzeExprFwd(receiver,pair.env,JSType.TOP_OBJECT);
pair.type=requiredType;
return pair;
}
case Token.VOID:
{
EnvTypePair pair=analyzeExprFwd(expr.getFirstChild(),inEnv);
pair.type=JSType.UNDEFINED;
return pair;
}
case Token.IN:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
EnvTypePair pair;
pair=analyzeExprFwd(lhs,inEnv,JSType.NUM_OR_STR);
if (!pair.type.isSubtypeOf(JSType.NUM_OR_STR)) {
warnInvalidOperand(lhs,Token.IN,JSType.NUM_OR_STR,pair.type);
}
pair=analyzeExprFwd(rhs,pair.env,JSType.TOP_OBJECT);
if (!pair.type.isSubtypeOf(JSType.TOP_OBJECT)) {
warnInvalidOperand(rhs,Token.IN,""String_Node_Str"",pair.type);
pair.type=JSType.BOOLEAN;
return pair;
}
JSType resultType=JSType.BOOLEAN;
if (lhs.isString()) {
String pname=lhs.getString();
if (specializedType.isTruthy()) {
pair=analyzeExprFwd(rhs,inEnv,JSType.TOP_OBJECT,JSType.TOP_OBJECT.withPropertyRequired(pname));
resultType=JSType.TRUE_TYPE;
}
 else if (specializedType.isFalsy()) {
pair=analyzeExprFwd(rhs,inEnv,JSType.TOP_OBJECT);
pair=analyzeExprFwd(rhs,inEnv,JSType.TOP_OBJECT,pair.type.withoutProperty(pname));
resultType=JSType.FALSE_TYPE;
}
}
pair.type=resultType;
return pair;
}
case Token.DELPROP:
{
EnvTypePair pair=analyzeExprFwd(expr.getFirstChild(),inEnv);
pair.type=JSType.BOOLEAN;
return pair;
}
case Token.VAR:
{
Node vdecl=expr.getFirstChild();
String name=vdecl.getQualifiedName();
Node rhs=vdecl.getFirstChild();
TypeEnv env=inEnv;
if (rhs != null) {
env=analyzeExprFwd(rhs,inEnv).env;
}
return new EnvTypePair(envPutType(env,name,JSType.STRING),JSType.STRING);
}
case Token.REGEXP:
return new EnvTypePair(inEnv,regexpType);
case Token.ARRAYLIT:
TypeEnv env=inEnv;
for (Node arrayElm=expr.getFirstChild(); arrayElm != null; arrayElm=arrayElm.getNext()) {
env=analyzeExprFwd(arrayElm,env).env;
}
return new EnvTypePair(env,arrayType);
default :
throw new RuntimeException(""String_Node_Str"" + Token.name(expr.getType()));
}
}","/** 
 * @param requiredType The context requires this type; warn if the expressiondoesn't have this type.
 * @param specializedType Used in boolean contexts to infer types of names.Invariant: specializedType is a subtype of requiredType.
 */
private EnvTypePair analyzeExprFwd(Node expr,TypeEnv inEnv,JSType requiredType,JSType specializedType){
  Preconditions.checkArgument(requiredType != null && !requiredType.isBottom());
  int exprKind=expr.getType();
switch (exprKind) {
case Token.EMPTY:
    return new EnvTypePair(inEnv,JSType.UNKNOWN);
case Token.FUNCTION:
{
    String fnName=symbolTable.getFunInternalName(expr);
    return new EnvTypePair(inEnv,envGetType(inEnv,fnName));
  }
case Token.FALSE:
case Token.NULL:
case Token.NUMBER:
case Token.STRING:
case Token.TRUE:
return new EnvTypePair(inEnv,scalarValueToType(exprKind));
case Token.OBJECTLIT:
{
JSType result=JSType.TOP_OBJECT;
TypeEnv env=inEnv;
for (Node key : expr.children()) {
  String pname=NodeUtil.getObjectLitKeyName(key);
  JSType reqPtype=requiredType.mayHaveProp(pname) ? requiredType.getProp(pname) : JSType.TOP;
  JSType specPtype=specializedType.mayHaveProp(pname) ? specializedType.getProp(pname) : JSType.TOP;
  EnvTypePair pair=analyzeExprFwd(key.getLastChild(),env,reqPtype,specPtype);
  result=result.withProperty(pname,pair.type);
  env=pair.env;
}
return new EnvTypePair(env,result);
}
case Token.THIS:
{
if (!currentScope.hasThis()) {
warnings.add(JSError.make(expr,CheckGlobalThis.GLOBAL_THIS));
return new EnvTypePair(inEnv,JSType.UNKNOWN);
}
JSType thisType=currentScope.getDeclaredTypeOf(""String_Node_Str"");
return new EnvTypePair(inEnv,thisType);
}
case Token.NAME:
{
String varName=expr.getQualifiedName();
if (varName.equals(""String_Node_Str"")) {
return new EnvTypePair(inEnv,JSType.UNDEFINED);
}
if (currentScope.isLocalVar(varName) || currentScope.isFormalParam(varName) || currentScope.isLocalFunDef(varName)|| currentScope.isOuterVar(varName)) {
JSType inferredType=envGetType(inEnv,varName);
println(varName,""String_Node_Str"",inferredType,""String_Node_Str"",requiredType);
if (!inferredType.isSubtypeOf(requiredType)) {
if (currentScope.getDeclaredTypeOf(varName) == null && inferredType.equals(JSType.NUM_OR_STR) && requiredType.isSubtypeOf(inferredType)) {
  inferredType=requiredType;
}
 else {
  return new EnvTypePair(inEnv,inferredType);
}
}
JSType preciseType=inferredType.specialize(specializedType);
println(varName,""String_Node_Str"",preciseType);
if (!preciseType.isBottom() && currentScope.isUndeclaredFormal(varName) && requiredType.hasNonScalar()) {
preciseType=preciseType.withLoose();
}
return EnvTypePair.addBinding(inEnv,varName,preciseType);
}
println(""String_Node_Str"",varName);
return new EnvTypePair(inEnv,JSType.UNKNOWN);
}
case Token.AND:
case Token.OR:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
if ((specializedType.isTruthy() && exprKind == Token.AND) || (specializedType.isFalsy() && exprKind == Token.OR)) {
EnvTypePair lhsPair=analyzeExprFwd(lhs,inEnv,JSType.TOP,specializedType);
EnvTypePair rhsPair=analyzeExprFwd(rhs,lhsPair.env,JSType.TOP,specializedType);
return rhsPair;
}
 else if ((specializedType.isFalsy() && exprKind == Token.AND) || (specializedType.isTruthy() && exprKind == Token.OR)) {
EnvTypePair shortCircuitPair=analyzeExprFwd(lhs,inEnv,JSType.TOP,specializedType);
JSType negatedType=specializedType.isTruthy() ? JSType.FALSY : JSType.TRUTHY;
EnvTypePair lhsPair=analyzeExprFwd(lhs,inEnv,JSType.TOP,negatedType);
EnvTypePair rhsPair=analyzeExprFwd(rhs,lhsPair.env,JSType.TOP,specializedType);
return EnvTypePair.join(rhsPair,shortCircuitPair);
}
 else {
EnvTypePair lhsPair=analyzeExprFwd(lhs,inEnv);
EnvTypePair rhsPair=analyzeExprFwd(rhs,lhsPair.env);
return rhsPair;
}
}
case Token.INC:
case Token.DEC:
case Token.BITNOT:
case Token.POS:
case Token.NEG:
{
Node child=expr.getFirstChild();
EnvTypePair pair=analyzeExprFwd(child,inEnv,JSType.NUMBER);
if (!pair.type.isSubtypeOf(JSType.NUMBER)) {
warnInvalidOperand(child,expr.getType(),JSType.NUMBER,pair.type);
}
pair.type=JSType.NUMBER;
return pair;
}
case Token.TYPEOF:
{
EnvTypePair pair=analyzeExprFwd(expr.getFirstChild(),inEnv);
pair.type=JSType.STRING;
return pair;
}
case Token.INSTANCEOF:
{
Node obj=expr.getFirstChild();
Node ctor=expr.getLastChild();
EnvTypePair objPair, ctorPair;
objPair=analyzeExprFwd(obj,inEnv);
JSType objType=objPair.type;
if (!objType.equals(JSType.TOP) && !objType.equals(JSType.UNKNOWN) && !objType.hasNonScalar()) {
warnInvalidOperand(obj,Token.INSTANCEOF,""String_Node_Str"",objPair.type);
}
ctorPair=analyzeExprFwd(ctor,objPair.env,JSType.topFunction());
JSType ctorType=ctorPair.type;
FunctionType ctorFunType=ctorType.getFunType();
if (!ctorType.isUnknown() && (!ctorType.isSubtypeOf(JSType.topFunction()) || !ctorFunType.isConstructor())) {
warnInvalidOperand(ctor,Token.INSTANCEOF,""String_Node_Str"",ctorType);
}
if (ctorFunType == null || !ctorFunType.isConstructor() || (!specializedType.isTruthy() && !specializedType.isFalsy())) {
ctorPair.type=JSType.BOOLEAN;
return ctorPair;
}
JSType instanceType=ctorFunType.getTypeOfThis();
objPair=analyzeExprFwd(obj,inEnv,JSType.TOP,specializedType.isTruthy() ? objPair.type.specialize(instanceType) : objPair.type.removeType(instanceType));
ctorPair=analyzeExprFwd(ctor,objPair.env,JSType.topFunction());
ctorPair.type=JSType.BOOLEAN;
return ctorPair;
}
case Token.ADD:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
EnvTypePair lhsPair=analyzeExprFwd(lhs,inEnv,JSType.NUM_OR_STR);
EnvTypePair rhsPair=analyzeExprFwd(rhs,lhsPair.env,JSType.NUM_OR_STR);
JSType lhsType=lhsPair.type;
JSType rhsType=rhsPair.type;
if (!lhsType.isSubtypeOf(JSType.NUM_OR_STR)) {
warnInvalidOperand(lhs,expr.getType(),JSType.NUM_OR_STR,lhsType);
}
if (!rhsType.isSubtypeOf(JSType.NUM_OR_STR)) {
warnInvalidOperand(rhs,expr.getType(),JSType.NUM_OR_STR,rhsType);
}
return new EnvTypePair(rhsPair.env,JSType.plus(lhsType,rhsType));
}
case Token.BITOR:
case Token.BITAND:
case Token.BITXOR:
case Token.DIV:
case Token.LSH:
case Token.MOD:
case Token.MUL:
case Token.RSH:
case Token.SUB:
case Token.URSH:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
EnvTypePair lhsPair=analyzeExprFwd(lhs,inEnv,JSType.NUMBER);
EnvTypePair rhsPair=analyzeExprFwd(rhs,lhsPair.env,JSType.NUMBER);
if (!lhsPair.type.isSubtypeOf(JSType.NUMBER)) {
warnInvalidOperand(lhs,expr.getType(),JSType.NUMBER,lhsPair.type);
}
if (!rhsPair.type.isSubtypeOf(JSType.NUMBER)) {
warnInvalidOperand(rhs,expr.getType(),JSType.NUMBER,rhsPair.type);
}
rhsPair.type=JSType.NUMBER;
return rhsPair;
}
case Token.ASSIGN:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
LValueResult lvalue=analyzeLValueFwd(lhs,inEnv,requiredType);
JSType declType=lvalue.declType;
EnvTypePair rhsPair=analyzeExprFwd(rhs,lvalue.env,requiredType,specializedType);
JSType rhsType=rhsPair.type;
if (declType != null && !rhsType.isSubtypeOf(declType)) {
warnings.add(JSError.make(expr,MISTYPED_ASSIGN_RHS,declType.toString(),rhsType.toString()));
rhsType=declType;
}
return new EnvTypePair(updateLvalueTypeInEnv(rhsPair.env,lhs,lvalue.ptr,rhsType),rhsType);
}
case Token.ASSIGN_ADD:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
JSType lhsReqType=specializeWithCorrection(requiredType,JSType.NUM_OR_STR);
LValueResult lvalue=analyzeLValueFwd(lhs,inEnv,lhsReqType);
JSType lhsType=lvalue.type;
if (!lhsType.isSubtypeOf(JSType.NUM_OR_STR)) {
warnInvalidOperand(lhs,Token.ASSIGN_ADD,JSType.NUM_OR_STR,lhsType);
}
JSType rhsReqType=lhsType.equals(JSType.NUMBER) ? JSType.NUMBER : JSType.NUM_OR_STR;
EnvTypePair pair=analyzeExprFwd(rhs,lvalue.env,rhsReqType);
if (!pair.type.isSubtypeOf(rhsReqType)) {
warnInvalidOperand(rhs,Token.ASSIGN_ADD,rhsReqType,pair.type);
}
return pair;
}
case Token.ASSIGN_BITOR:
case Token.ASSIGN_BITXOR:
case Token.ASSIGN_BITAND:
case Token.ASSIGN_LSH:
case Token.ASSIGN_RSH:
case Token.ASSIGN_URSH:
case Token.ASSIGN_SUB:
case Token.ASSIGN_MUL:
case Token.ASSIGN_DIV:
case Token.ASSIGN_MOD:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
LValueResult lvalue=analyzeLValueFwd(lhs,inEnv,JSType.NUMBER);
JSType lhsType=lvalue.type;
if (!lhsType.isSubtypeOf(JSType.NUMBER)) {
warnInvalidOperand(lhs,expr.getType(),JSType.NUMBER,lhsType);
}
EnvTypePair pair=analyzeExprFwd(rhs,lvalue.env,JSType.NUMBER);
if (!pair.type.isSubtypeOf(JSType.NUMBER)) {
warnInvalidOperand(rhs,expr.getType(),JSType.NUMBER,pair.type);
}
return new EnvTypePair(updateLvalueTypeInEnv(pair.env,lhs,lvalue.ptr,JSType.NUMBER),JSType.NUMBER);
}
case Token.SHEQ:
case Token.SHNE:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
EnvTypePair lhsPair=analyzeExprFwd(lhs,inEnv);
EnvTypePair rhsPair=analyzeExprFwd(rhs,lhsPair.env);
if ((exprKind == Token.SHEQ && specializedType.isTruthy()) || (exprKind == Token.SHNE && specializedType.isFalsy())) {
JSType meetType=JSType.meet(lhsPair.type,rhsPair.type);
lhsPair=analyzeExprFwd(lhs,rhsPair.env,JSType.TOP,meetType);
rhsPair=analyzeExprFwd(rhs,lhsPair.env,JSType.TOP,meetType);
}
 else if ((exprKind == Token.SHEQ && specializedType.isFalsy()) || (exprKind == Token.SHNE && specializedType.isTruthy())) {
JSType lhsType=lhsPair.type;
JSType rhsType=rhsPair.type;
if (lhsType.equals(JSType.NULL) || lhsType.equals(JSType.UNDEFINED)) {
rhsType=rhsType.removeType(lhsType);
}
 else if (rhsType.equals(JSType.NULL) || rhsType.equals(JSType.UNDEFINED)) {
lhsType=lhsType.removeType(rhsType);
}
lhsPair=analyzeExprFwd(lhs,rhsPair.env,JSType.TOP,lhsType);
rhsPair=analyzeExprFwd(rhs,lhsPair.env,JSType.TOP,rhsType);
}
rhsPair.type=JSType.BOOLEAN;
return rhsPair;
}
case Token.EQ:
case Token.NE:
return analyzeNonStrictComparisonFwd(expr,inEnv,requiredType,specializedType);
case Token.LT:
case Token.GT:
case Token.LE:
case Token.GE:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
EnvTypePair lhsPair=analyzeExprFwd(lhs,inEnv);
EnvTypePair rhsPair=analyzeExprFwd(rhs,lhsPair.env);
if (lhsPair.type.isScalar() && rhsPair.type.isUnknown()) {
rhsPair=analyzeExprFwd(rhs,lhsPair.env,lhsPair.type);
}
 else if (lhsPair.type.isUnknown() && rhsPair.type.isScalar()) {
lhsPair=analyzeExprFwd(lhs,inEnv,rhsPair.type);
rhsPair=analyzeExprFwd(rhs,lhsPair.env,rhsPair.type);
}
 else if (lhs.isName() && lhsPair.type.isUnknown() && rhs.isName()&& rhsPair.type.isUnknown()) {
TypeEnv env=envPutType(rhsPair.env,lhs.getQualifiedName(),JSType.TOP_SCALAR);
env=envPutType(rhsPair.env,rhs.getQualifiedName(),JSType.TOP_SCALAR);
return new EnvTypePair(env,JSType.BOOLEAN);
}
JSType lhsType=lhsPair.type;
JSType rhsType=rhsPair.type;
if (!lhsType.isSubtypeOf(JSType.TOP_SCALAR) || !rhsType.isSubtypeOf(JSType.TOP_SCALAR) || !JSType.areCompatibleScalarTypes(lhsType,rhsType)) {
warnInvalidOperand(expr,exprKind,""String_Node_Str"",lhsType.toString() + ""String_Node_Str"" + rhsType.toString());
}
rhsPair.type=JSType.BOOLEAN;
return rhsPair;
}
case Token.GETPROP:
Preconditions.checkState(!NodeUtil.isAssignmentOp(expr.getParent()) || !NodeUtil.isLValue(expr));
return analyzePropAccessFwd(expr.getFirstChild(),expr.getLastChild().getString(),inEnv,requiredType,specializedType);
case Token.HOOK:
{
Node cond=expr.getFirstChild();
Node thenBranch=cond.getNext();
Node elseBranch=thenBranch.getNext();
TypeEnv trueEnv=analyzeExprFwd(cond,inEnv,JSType.TOP,JSType.TRUE_TYPE).env;
TypeEnv falseEnv=analyzeExprFwd(cond,inEnv,JSType.TOP,JSType.FALSE_TYPE).env;
EnvTypePair thenPair=analyzeExprFwd(thenBranch,trueEnv,requiredType,specializedType);
EnvTypePair elsePair=analyzeExprFwd(elseBranch,falseEnv,requiredType,specializedType);
return EnvTypePair.join(thenPair,elsePair);
}
case Token.CALL:
case Token.NEW:
{
Node callee=expr.getFirstChild();
EnvTypePair calleePair=analyzeExprFwd(callee,inEnv,JSType.topFunction());
JSType calleeType=calleePair.type;
if (!calleeType.isSubtypeOf(JSType.topFunction())) {
warnings.add(JSError.make(expr,TypeCheck.NOT_CALLABLE,calleeType.toString()));
}
FunctionType funType=calleeType.getFunType();
if (funType == null || funType.isTopFunction()) {
return new EnvTypePair(inEnv,requiredType);
}
 else if (funType.isLoose()) {
return analyzeLooseCallNodeFwd(expr,inEnv,requiredType);
}
 else if (expr.isCall() && funType.isConstructor()) {
warnings.add(JSError.make(expr,TypeCheck.CONSTRUCTOR_NOT_CALLABLE,funType.toString()));
return new EnvTypePair(inEnv,requiredType);
}
 else if (expr.isNew() && !funType.isConstructor()) {
warnings.add(JSError.make(expr,TypeCheck.NOT_A_CONSTRUCTOR,funType.toString()));
return new EnvTypePair(inEnv,requiredType);
}
int maxArity=funType.getMaxArity();
int minArity=funType.getMinArity();
int numArgs=expr.getChildCount() - 1;
if (numArgs < minArity || numArgs > maxArity) {
warnings.add(JSError.make(expr,TypeCheck.WRONG_ARGUMENT_COUNT,""String_Node_Str"",Integer.toString(numArgs),Integer.toString(minArity),""String_Node_Str"" + maxArity));
}
List<JSType> argTypes=Lists.newArrayList();
TypeEnv tmpEnv=inEnv;
for (int i=0; i < numArgs; i++) {
JSType formalType=(i < maxArity) ? funType.getFormalType(i) : JSType.TOP;
if (formalType.isBottom()) {
warnings.add(JSError.make(expr,CALL_FUNCTION_WITH_BOTTOM_FORMAL,Integer.toString(i)));
formalType=JSType.TOP;
}
Node arg=expr.getChildAtIndex(i + 1);
EnvTypePair pair=analyzeExprFwd(arg,tmpEnv,formalType);
if (!pair.type.isSubtypeOf(formalType)) {
warnings.add(JSError.make(arg,INVALID_ARGUMENT_TYPE,Integer.toString(i + 1),""String_Node_Str"",formalType.toString(),pair.type.toString()));
pair.type=JSType.UNKNOWN;
}
if (i < maxArity) {
Preconditions.checkState(!pair.type.equals(JSType.topFunction()));
argTypes.add(pair.type);
}
tmpEnv=pair.env;
}
JSType retType=funType.getReturnType();
if (callee.isName()) {
String calleeName=callee.getQualifiedName();
if (currentScope.isKnownFunction(calleeName)) {
if (currentScope.isLocalFunDef(calleeName)) {
collectTypesForFreeVarsFwd(callee,tmpEnv);
}
 else {
JSType expectedRetType=requiredType;
println(""String_Node_Str"",expectedRetType,""String_Node_Str"",argTypes);
DeferredCheck dc;
if (expr.isCall()) {
dc=deferredChecks.get(expr);
dc.updateReturn(expectedRetType);
}
 else {
dc=new DeferredCheck(expr,currentScope,currentScope.getScope(calleeName));
dc.updateReturn(JSType.TOP);
deferredChecks.put(expr,dc);
}
dc.updateArgTypes(argTypes);
}
}
}
return new EnvTypePair(tmpEnv,retType);
}
case Token.COMMA:
return analyzeExprFwd(expr.getLastChild(),analyzeExprFwd(expr.getFirstChild(),inEnv).env,requiredType,specializedType);
case Token.NOT:
{
EnvTypePair pair=analyzeExprFwd(expr.getFirstChild(),inEnv,JSType.TOP,specializedType.negate());
pair.type=pair.type.negate().toBoolean();
return pair;
}
case Token.GETELEM:
{
Node receiver=expr.getFirstChild();
Node index=expr.getLastChild();
if (index.isString()) {
return analyzePropAccessFwd(receiver,index.getString(),inEnv,requiredType,specializedType);
}
EnvTypePair pair=analyzeExprFwd(index,inEnv);
pair=analyzeExprFwd(receiver,pair.env,JSType.TOP_OBJECT);
pair.type=requiredType;
return pair;
}
case Token.VOID:
{
EnvTypePair pair=analyzeExprFwd(expr.getFirstChild(),inEnv);
pair.type=JSType.UNDEFINED;
return pair;
}
case Token.IN:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
EnvTypePair pair;
pair=analyzeExprFwd(lhs,inEnv,JSType.NUM_OR_STR);
if (!pair.type.isSubtypeOf(JSType.NUM_OR_STR)) {
warnInvalidOperand(lhs,Token.IN,JSType.NUM_OR_STR,pair.type);
}
pair=analyzeExprFwd(rhs,pair.env,JSType.TOP_OBJECT);
if (!pair.type.isSubtypeOf(JSType.TOP_OBJECT)) {
warnInvalidOperand(rhs,Token.IN,""String_Node_Str"",pair.type);
pair.type=JSType.BOOLEAN;
return pair;
}
JSType resultType=JSType.BOOLEAN;
if (lhs.isString()) {
String pname=lhs.getString();
if (specializedType.isTruthy()) {
pair=analyzeExprFwd(rhs,inEnv,JSType.TOP_OBJECT,JSType.TOP_OBJECT.withPropertyRequired(pname));
resultType=JSType.TRUE_TYPE;
}
 else if (specializedType.isFalsy()) {
pair=analyzeExprFwd(rhs,inEnv,JSType.TOP_OBJECT);
pair=analyzeExprFwd(rhs,inEnv,JSType.TOP_OBJECT,pair.type.withoutProperty(pname));
resultType=JSType.FALSE_TYPE;
}
}
pair.type=resultType;
return pair;
}
case Token.DELPROP:
{
EnvTypePair pair=analyzeExprFwd(expr.getFirstChild(),inEnv);
pair.type=JSType.BOOLEAN;
return pair;
}
case Token.VAR:
{
Node vdecl=expr.getFirstChild();
String name=vdecl.getQualifiedName();
Preconditions.checkState(!vdecl.hasChildren());
return new EnvTypePair(envPutType(inEnv,name,JSType.STRING),JSType.STRING);
}
case Token.REGEXP:
return new EnvTypePair(inEnv,regexpType);
case Token.ARRAYLIT:
TypeEnv env=inEnv;
for (Node arrayElm=expr.getFirstChild(); arrayElm != null; arrayElm=arrayElm.getNext()) {
env=analyzeExprFwd(arrayElm,env).env;
}
return new EnvTypePair(env,arrayType);
default :
throw new RuntimeException(""String_Node_Str"" + Token.name(expr.getType()));
}
}",0.9931631586804
27800,"/** 
 * For now, we won't emit any warnings bwd.
 */
private EnvTypePair analyzeExprBwd(Node expr,TypeEnv outEnv,JSType requiredType){
  Preconditions.checkArgument(requiredType != null && !requiredType.isBottom());
  int exprKind=expr.getType();
switch (exprKind) {
case Token.EMPTY:
    return new EnvTypePair(outEnv,JSType.UNKNOWN);
case Token.FUNCTION:
{
    String fnName=symbolTable.getFunInternalName(expr);
    return new EnvTypePair(outEnv,envGetType(outEnv,fnName));
  }
case Token.FALSE:
case Token.NULL:
case Token.NUMBER:
case Token.STRING:
case Token.TRUE:
return new EnvTypePair(outEnv,scalarValueToType(exprKind));
case Token.OBJECTLIT:
{
JSType result=JSType.TOP_OBJECT;
TypeEnv env=outEnv;
for (Node key=expr.getLastChild(); key != null; key=expr.getChildBefore(key)) {
  String pname=NodeUtil.getObjectLitKeyName(key);
  JSType reqPtype=requiredType.mayHaveProp(pname) ? requiredType.getProp(pname) : JSType.TOP;
  EnvTypePair pair=analyzeExprBwd(key.getLastChild(),env,reqPtype);
  result=result.withProperty(pname,pair.type);
  env=pair.env;
}
return new EnvTypePair(env,result);
}
case Token.THIS:
{
if (!currentScope.hasThis()) {
return new EnvTypePair(outEnv,JSType.UNKNOWN);
}
JSType thisType=currentScope.getDeclaredTypeOf(""String_Node_Str"");
return new EnvTypePair(outEnv,thisType);
}
case Token.NAME:
{
String varName=expr.getQualifiedName();
if (varName.equals(""String_Node_Str"")) {
return new EnvTypePair(outEnv,JSType.UNDEFINED);
}
JSType inferredType=envGetType(outEnv,varName);
if (inferredType == null) {
inferredType=JSType.TOP;
}
JSType preciseType=inferredType.specialize(requiredType);
if (currentScope.isUndeclaredFormal(varName) && requiredType.hasNonScalar()) {
preciseType=preciseType.withLoose();
}
if (!preciseType.isInhabitable()) {
JSType declType=currentScope.getDeclaredTypeOf(varName);
preciseType=declType == null ? requiredType : declType;
}
return EnvTypePair.addBinding(outEnv,varName,preciseType);
}
case Token.INC:
case Token.DEC:
case Token.BITNOT:
case Token.POS:
case Token.NEG:
return analyzeExprBwd(expr.getFirstChild(),outEnv,JSType.NUMBER);
case Token.TYPEOF:
{
EnvTypePair pair=analyzeExprBwd(expr.getFirstChild(),outEnv);
pair.type=JSType.STRING;
return pair;
}
case Token.INSTANCEOF:
{
TypeEnv env=analyzeExprBwd(expr.getLastChild(),outEnv,JSType.topFunction()).env;
EnvTypePair pair=analyzeExprBwd(expr.getFirstChild(),env);
pair.type=JSType.BOOLEAN;
return pair;
}
case Token.BITOR:
case Token.BITAND:
case Token.BITXOR:
case Token.DIV:
case Token.LSH:
case Token.MOD:
case Token.MUL:
case Token.RSH:
case Token.SUB:
case Token.URSH:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
TypeEnv rhsEnv=analyzeExprBwd(rhs,outEnv,JSType.NUMBER).env;
EnvTypePair pair=analyzeExprBwd(lhs,rhsEnv,JSType.NUMBER);
pair.type=JSType.NUMBER;
return pair;
}
case Token.ADD:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
EnvTypePair rhsPair=analyzeExprBwd(rhs,outEnv,JSType.NUM_OR_STR);
EnvTypePair lhsPair=analyzeExprBwd(lhs,rhsPair.env,JSType.NUM_OR_STR);
lhsPair.type=JSType.plus(lhsPair.type,rhsPair.type);
return lhsPair;
}
case Token.OR:
case Token.AND:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
EnvTypePair rhsPair=analyzeExprBwd(rhs,outEnv);
EnvTypePair lhsPair=analyzeExprBwd(lhs,rhsPair.env);
lhsPair.type=JSType.join(rhsPair.type,lhsPair.type);
return lhsPair;
}
case Token.SHEQ:
case Token.SHNE:
case Token.EQ:
case Token.NE:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
TypeEnv rhsEnv=analyzeExprBwd(rhs,outEnv).env;
EnvTypePair pair=analyzeExprBwd(lhs,rhsEnv);
pair.type=JSType.BOOLEAN;
return pair;
}
case Token.LT:
case Token.GT:
case Token.LE:
case Token.GE:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
EnvTypePair rhsPair=analyzeExprBwd(rhs,outEnv);
EnvTypePair lhsPair=analyzeExprBwd(lhs,rhsPair.env);
JSType meetType=JSType.meet(lhsPair.type,rhsPair.type);
if (meetType.isBottom()) {
lhsPair.type=JSType.BOOLEAN;
return lhsPair;
}
rhsPair=analyzeExprBwd(rhs,outEnv,meetType);
lhsPair=analyzeExprBwd(lhs,rhsPair.env,meetType);
lhsPair.type=JSType.BOOLEAN;
return lhsPair;
}
case Token.ASSIGN:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
LValueResult lvalue=analyzeLValueBwd(lhs,outEnv,requiredType,true);
TypeEnv slicedEnv=lvalue.env;
JSType rhsReqType=specializeWithCorrection(lvalue.type,requiredType);
EnvTypePair pair=analyzeExprBwd(rhs,slicedEnv,rhsReqType);
pair.env=analyzeLValueBwd(lhs,pair.env,requiredType,true).env;
return pair;
}
case Token.ASSIGN_ADD:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
JSType lhsReqType=specializeWithCorrection(requiredType,JSType.NUM_OR_STR);
LValueResult lvalue=analyzeLValueBwd(lhs,outEnv,lhsReqType,false);
JSType rhsReqType=lvalue.type.equals(JSType.NUMBER) ? JSType.NUMBER : JSType.NUM_OR_STR;
EnvTypePair pair=analyzeExprBwd(rhs,outEnv,rhsReqType);
pair.env=analyzeLValueBwd(lhs,pair.env,lhsReqType,false).env;
return pair;
}
case Token.ASSIGN_BITOR:
case Token.ASSIGN_BITXOR:
case Token.ASSIGN_BITAND:
case Token.ASSIGN_LSH:
case Token.ASSIGN_RSH:
case Token.ASSIGN_URSH:
case Token.ASSIGN_SUB:
case Token.ASSIGN_MUL:
case Token.ASSIGN_DIV:
case Token.ASSIGN_MOD:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
EnvTypePair pair=analyzeExprBwd(rhs,outEnv,JSType.NUMBER);
LValueResult lvalue=analyzeLValueBwd(lhs,pair.env,JSType.NUMBER,false);
return new EnvTypePair(lvalue.env,JSType.NUMBER);
}
case Token.GETPROP:
{
Preconditions.checkState(!NodeUtil.isAssignmentOp(expr.getParent()) || !NodeUtil.isLValue(expr));
return analyzePropAccessBwd(expr.getFirstChild(),expr.getLastChild().getString(),outEnv,requiredType);
}
case Token.HOOK:
{
Node cond=expr.getFirstChild();
Node thenBranch=cond.getNext();
Node elseBranch=thenBranch.getNext();
EnvTypePair thenPair=analyzeExprBwd(thenBranch,outEnv,requiredType);
EnvTypePair elsePair=analyzeExprBwd(elseBranch,outEnv,requiredType);
return analyzeExprBwd(cond,TypeEnv.join(thenPair.env,elsePair.env));
}
case Token.CALL:
case Token.NEW:
{
Node callee=expr.getFirstChild();
JSType calleeTypeGeneral=analyzeExprBwd(callee,outEnv,JSType.topFunction()).type;
FunctionType funType=calleeTypeGeneral.getFunType();
if (funType == null) {
return new EnvTypePair(outEnv,requiredType);
}
 else if (funType.isLoose()) {
return analyzeLooseCallNodeBwd(expr,outEnv,requiredType);
}
 else if (expr.isCall() && funType.isConstructor() || expr.isNew() && !funType.isConstructor()) {
return new EnvTypePair(outEnv,requiredType);
}
 else if (funType.isTopFunction()) {
return new EnvTypePair(outEnv,requiredType);
}
int arity=funType.getMaxArity();
TypeEnv tmpEnv=outEnv;
for (int i=expr.getChildCount() - 2; i >= 0; i--) {
JSType formalType=i < arity ? funType.getFormalType(i) : JSType.TOP;
if (formalType.isBottom()) {
formalType=JSType.TOP;
}
Node arg=expr.getChildAtIndex(i + 1);
tmpEnv=analyzeExprBwd(arg,tmpEnv,formalType).env;
}
if (callee.isName()) {
String calleeName=callee.getQualifiedName();
if (currentScope.isKnownFunction(calleeName)) {
if (currentScope.isLocalFunDef(calleeName)) {
tmpEnv=collectTypesForFreeVarsBwd(callee,tmpEnv);
}
 else if (expr.isCall()) {
Scope s=currentScope.getScope(calleeName);
JSType expectedRetType=JSType.TOP;
if (s.getDeclaredType().getReturnType() == null) {
expectedRetType=requiredType;
}
println(""String_Node_Str"",calleeName,""String_Node_Str"",expectedRetType);
DeferredCheck dc=new DeferredCheck(expr,currentScope,s);
dc.updateReturn(expectedRetType);
deferredChecks.put(expr,dc);
}
}
}
return new EnvTypePair(tmpEnv,funType.getReturnType());
}
case Token.COMMA:
{
EnvTypePair pair=analyzeExprBwd(expr.getLastChild(),outEnv,requiredType);
pair.env=analyzeExprBwd(expr.getFirstChild(),pair.env).env;
return pair;
}
case Token.NOT:
{
EnvTypePair pair=analyzeExprBwd(expr.getFirstChild(),outEnv);
pair.type=pair.type.negate();
return pair;
}
case Token.GETELEM:
{
Node receiver=expr.getFirstChild();
Node index=expr.getLastChild();
if (index.isString()) {
return analyzePropAccessBwd(receiver,index.getString(),outEnv,requiredType);
}
EnvTypePair pair=analyzeExprBwd(index,outEnv);
pair=analyzeExprBwd(receiver,pair.env,JSType.TOP_OBJECT);
pair.type=requiredType;
return pair;
}
case Token.VOID:
{
EnvTypePair pair=analyzeExprBwd(expr.getFirstChild(),outEnv);
pair.type=JSType.UNDEFINED;
return pair;
}
case Token.IN:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
EnvTypePair pair=analyzeExprBwd(rhs,outEnv,JSType.TOP_OBJECT);
pair=analyzeExprBwd(lhs,pair.env,JSType.NUM_OR_STR);
pair.type=JSType.BOOLEAN;
return pair;
}
case Token.DELPROP:
{
EnvTypePair pair=analyzeExprBwd(expr.getFirstChild(),outEnv);
pair.type=JSType.BOOLEAN;
return pair;
}
case Token.VAR:
{
Node vdecl=expr.getFirstChild();
String name=vdecl.getQualifiedName();
Node rhs=vdecl.getFirstChild();
TypeEnv env=outEnv;
if (rhs != null) {
env=analyzeExprBwd(rhs,outEnv).env;
}
return new EnvTypePair(envPutType(env,name,JSType.UNKNOWN),JSType.UNKNOWN);
}
case Token.REGEXP:
return new EnvTypePair(outEnv,regexpType);
case Token.ARRAYLIT:
TypeEnv env=outEnv;
for (int i=expr.getChildCount() - 1; i >= 0; i--) {
Node arrayElm=expr.getChildAtIndex(i);
env=analyzeExprBwd(arrayElm,env).env;
}
return new EnvTypePair(env,arrayType);
default :
throw new RuntimeException(""String_Node_Str"" + Token.name(expr.getType()) + ""String_Node_Str""+ expr.getParent());
}
}","/** 
 * For now, we won't emit any warnings bwd.
 */
private EnvTypePair analyzeExprBwd(Node expr,TypeEnv outEnv,JSType requiredType){
  Preconditions.checkArgument(requiredType != null && !requiredType.isBottom());
  int exprKind=expr.getType();
switch (exprKind) {
case Token.EMPTY:
    return new EnvTypePair(outEnv,JSType.UNKNOWN);
case Token.FUNCTION:
{
    String fnName=symbolTable.getFunInternalName(expr);
    return new EnvTypePair(outEnv,envGetType(outEnv,fnName));
  }
case Token.FALSE:
case Token.NULL:
case Token.NUMBER:
case Token.STRING:
case Token.TRUE:
return new EnvTypePair(outEnv,scalarValueToType(exprKind));
case Token.OBJECTLIT:
{
JSType result=JSType.TOP_OBJECT;
TypeEnv env=outEnv;
for (Node key=expr.getLastChild(); key != null; key=expr.getChildBefore(key)) {
  String pname=NodeUtil.getObjectLitKeyName(key);
  JSType reqPtype=requiredType.mayHaveProp(pname) ? requiredType.getProp(pname) : JSType.TOP;
  EnvTypePair pair=analyzeExprBwd(key.getLastChild(),env,reqPtype);
  result=result.withProperty(pname,pair.type);
  env=pair.env;
}
return new EnvTypePair(env,result);
}
case Token.THIS:
{
if (!currentScope.hasThis()) {
return new EnvTypePair(outEnv,JSType.UNKNOWN);
}
JSType thisType=currentScope.getDeclaredTypeOf(""String_Node_Str"");
return new EnvTypePair(outEnv,thisType);
}
case Token.NAME:
{
String varName=expr.getQualifiedName();
if (varName.equals(""String_Node_Str"")) {
return new EnvTypePair(outEnv,JSType.UNDEFINED);
}
JSType inferredType=envGetType(outEnv,varName);
if (inferredType == null) {
inferredType=JSType.TOP;
}
JSType preciseType=inferredType.specialize(requiredType);
if (currentScope.isUndeclaredFormal(varName) && requiredType.hasNonScalar()) {
preciseType=preciseType.withLoose();
}
if (!preciseType.isInhabitable()) {
JSType declType=currentScope.getDeclaredTypeOf(varName);
preciseType=declType == null ? requiredType : declType;
}
return EnvTypePair.addBinding(outEnv,varName,preciseType);
}
case Token.INC:
case Token.DEC:
case Token.BITNOT:
case Token.POS:
case Token.NEG:
return analyzeExprBwd(expr.getFirstChild(),outEnv,JSType.NUMBER);
case Token.TYPEOF:
{
EnvTypePair pair=analyzeExprBwd(expr.getFirstChild(),outEnv);
pair.type=JSType.STRING;
return pair;
}
case Token.INSTANCEOF:
{
TypeEnv env=analyzeExprBwd(expr.getLastChild(),outEnv,JSType.topFunction()).env;
EnvTypePair pair=analyzeExprBwd(expr.getFirstChild(),env);
pair.type=JSType.BOOLEAN;
return pair;
}
case Token.BITOR:
case Token.BITAND:
case Token.BITXOR:
case Token.DIV:
case Token.LSH:
case Token.MOD:
case Token.MUL:
case Token.RSH:
case Token.SUB:
case Token.URSH:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
TypeEnv rhsEnv=analyzeExprBwd(rhs,outEnv,JSType.NUMBER).env;
EnvTypePair pair=analyzeExprBwd(lhs,rhsEnv,JSType.NUMBER);
pair.type=JSType.NUMBER;
return pair;
}
case Token.ADD:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
EnvTypePair rhsPair=analyzeExprBwd(rhs,outEnv,JSType.NUM_OR_STR);
EnvTypePair lhsPair=analyzeExprBwd(lhs,rhsPair.env,JSType.NUM_OR_STR);
lhsPair.type=JSType.plus(lhsPair.type,rhsPair.type);
return lhsPair;
}
case Token.OR:
case Token.AND:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
EnvTypePair rhsPair=analyzeExprBwd(rhs,outEnv);
EnvTypePair lhsPair=analyzeExprBwd(lhs,rhsPair.env);
lhsPair.type=JSType.join(rhsPair.type,lhsPair.type);
return lhsPair;
}
case Token.SHEQ:
case Token.SHNE:
case Token.EQ:
case Token.NE:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
TypeEnv rhsEnv=analyzeExprBwd(rhs,outEnv).env;
EnvTypePair pair=analyzeExprBwd(lhs,rhsEnv);
pair.type=JSType.BOOLEAN;
return pair;
}
case Token.LT:
case Token.GT:
case Token.LE:
case Token.GE:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
EnvTypePair rhsPair=analyzeExprBwd(rhs,outEnv);
EnvTypePair lhsPair=analyzeExprBwd(lhs,rhsPair.env);
JSType meetType=JSType.meet(lhsPair.type,rhsPair.type);
if (meetType.isBottom()) {
lhsPair.type=JSType.BOOLEAN;
return lhsPair;
}
rhsPair=analyzeExprBwd(rhs,outEnv,meetType);
lhsPair=analyzeExprBwd(lhs,rhsPair.env,meetType);
lhsPair.type=JSType.BOOLEAN;
return lhsPair;
}
case Token.ASSIGN:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
LValueResult lvalue=analyzeLValueBwd(lhs,outEnv,requiredType,true);
TypeEnv slicedEnv=lvalue.env;
JSType rhsReqType=specializeWithCorrection(lvalue.type,requiredType);
EnvTypePair pair=analyzeExprBwd(rhs,slicedEnv,rhsReqType);
pair.env=analyzeLValueBwd(lhs,pair.env,requiredType,true).env;
return pair;
}
case Token.ASSIGN_ADD:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
JSType lhsReqType=specializeWithCorrection(requiredType,JSType.NUM_OR_STR);
LValueResult lvalue=analyzeLValueBwd(lhs,outEnv,lhsReqType,false);
JSType rhsReqType=lvalue.type.equals(JSType.NUMBER) ? JSType.NUMBER : JSType.NUM_OR_STR;
EnvTypePair pair=analyzeExprBwd(rhs,outEnv,rhsReqType);
pair.env=analyzeLValueBwd(lhs,pair.env,lhsReqType,false).env;
return pair;
}
case Token.ASSIGN_BITOR:
case Token.ASSIGN_BITXOR:
case Token.ASSIGN_BITAND:
case Token.ASSIGN_LSH:
case Token.ASSIGN_RSH:
case Token.ASSIGN_URSH:
case Token.ASSIGN_SUB:
case Token.ASSIGN_MUL:
case Token.ASSIGN_DIV:
case Token.ASSIGN_MOD:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
EnvTypePair pair=analyzeExprBwd(rhs,outEnv,JSType.NUMBER);
LValueResult lvalue=analyzeLValueBwd(lhs,pair.env,JSType.NUMBER,false);
return new EnvTypePair(lvalue.env,JSType.NUMBER);
}
case Token.GETPROP:
{
Preconditions.checkState(!NodeUtil.isAssignmentOp(expr.getParent()) || !NodeUtil.isLValue(expr));
return analyzePropAccessBwd(expr.getFirstChild(),expr.getLastChild().getString(),outEnv,requiredType);
}
case Token.HOOK:
{
Node cond=expr.getFirstChild();
Node thenBranch=cond.getNext();
Node elseBranch=thenBranch.getNext();
EnvTypePair thenPair=analyzeExprBwd(thenBranch,outEnv,requiredType);
EnvTypePair elsePair=analyzeExprBwd(elseBranch,outEnv,requiredType);
return analyzeExprBwd(cond,TypeEnv.join(thenPair.env,elsePair.env));
}
case Token.CALL:
case Token.NEW:
{
Node callee=expr.getFirstChild();
JSType calleeTypeGeneral=analyzeExprBwd(callee,outEnv,JSType.topFunction()).type;
FunctionType funType=calleeTypeGeneral.getFunType();
if (funType == null) {
return new EnvTypePair(outEnv,requiredType);
}
 else if (funType.isLoose()) {
return analyzeLooseCallNodeBwd(expr,outEnv,requiredType);
}
 else if (expr.isCall() && funType.isConstructor() || expr.isNew() && !funType.isConstructor()) {
return new EnvTypePair(outEnv,requiredType);
}
 else if (funType.isTopFunction()) {
return new EnvTypePair(outEnv,requiredType);
}
int arity=funType.getMaxArity();
TypeEnv tmpEnv=outEnv;
for (int i=expr.getChildCount() - 2; i >= 0; i--) {
JSType formalType=i < arity ? funType.getFormalType(i) : JSType.TOP;
if (formalType.isBottom()) {
formalType=JSType.TOP;
}
Node arg=expr.getChildAtIndex(i + 1);
tmpEnv=analyzeExprBwd(arg,tmpEnv,formalType).env;
}
if (callee.isName()) {
String calleeName=callee.getQualifiedName();
if (currentScope.isKnownFunction(calleeName)) {
if (currentScope.isLocalFunDef(calleeName)) {
tmpEnv=collectTypesForFreeVarsBwd(callee,tmpEnv);
}
 else if (expr.isCall()) {
Scope s=currentScope.getScope(calleeName);
JSType expectedRetType=JSType.TOP;
if (s.getDeclaredType().getReturnType() == null) {
expectedRetType=requiredType;
}
println(""String_Node_Str"",calleeName,""String_Node_Str"",expectedRetType);
DeferredCheck dc=new DeferredCheck(expr,currentScope,s);
dc.updateReturn(expectedRetType);
deferredChecks.put(expr,dc);
}
}
}
return new EnvTypePair(tmpEnv,funType.getReturnType());
}
case Token.COMMA:
{
EnvTypePair pair=analyzeExprBwd(expr.getLastChild(),outEnv,requiredType);
pair.env=analyzeExprBwd(expr.getFirstChild(),pair.env).env;
return pair;
}
case Token.NOT:
{
EnvTypePair pair=analyzeExprBwd(expr.getFirstChild(),outEnv);
pair.type=pair.type.negate();
return pair;
}
case Token.GETELEM:
{
Node receiver=expr.getFirstChild();
Node index=expr.getLastChild();
if (index.isString()) {
return analyzePropAccessBwd(receiver,index.getString(),outEnv,requiredType);
}
EnvTypePair pair=analyzeExprBwd(index,outEnv);
pair=analyzeExprBwd(receiver,pair.env,JSType.TOP_OBJECT);
pair.type=requiredType;
return pair;
}
case Token.VOID:
{
EnvTypePair pair=analyzeExprBwd(expr.getFirstChild(),outEnv);
pair.type=JSType.UNDEFINED;
return pair;
}
case Token.IN:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
EnvTypePair pair=analyzeExprBwd(rhs,outEnv,JSType.TOP_OBJECT);
pair=analyzeExprBwd(lhs,pair.env,JSType.NUM_OR_STR);
pair.type=JSType.BOOLEAN;
return pair;
}
case Token.DELPROP:
{
EnvTypePair pair=analyzeExprBwd(expr.getFirstChild(),outEnv);
pair.type=JSType.BOOLEAN;
return pair;
}
case Token.VAR:
{
Node vdecl=expr.getFirstChild();
String name=vdecl.getQualifiedName();
Preconditions.checkState(!vdecl.hasChildren());
return new EnvTypePair(envPutType(outEnv,name,JSType.UNKNOWN),JSType.UNKNOWN);
}
case Token.REGEXP:
return new EnvTypePair(outEnv,regexpType);
case Token.ARRAYLIT:
TypeEnv env=outEnv;
for (int i=expr.getChildCount() - 1; i >= 0; i--) {
Node arrayElm=expr.getChildAtIndex(i);
env=analyzeExprBwd(arrayElm,env).env;
}
return new EnvTypePair(env,arrayType);
default :
throw new RuntimeException(""String_Node_Str"" + Token.name(expr.getType()) + ""String_Node_Str""+ expr.getParent());
}
}",0.988338504332941
27801,"private void findAliases(NodeTraversal t){
  Scope scope=t.getScope();
  for (  Var v : scope.getVarIterable()) {
    Node n=v.getNode();
    Node parent=n.getParent();
    boolean isVar=parent.isVar();
    boolean isFunctionDecl=NodeUtil.isFunctionDeclaration(parent);
    if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {
      recordAlias(v);
    }
 else     if (v.isBleedingFunction()) {
    }
 else     if (parent.getType() == Token.LP) {
    }
 else     if (isVar || isFunctionDecl) {
      boolean isHoisted=NodeUtil.isHoistedFunctionDeclaration(parent);
      Node grandparent=parent.getParent();
      Node value=v.getInitialValue() != null ? v.getInitialValue() : null;
      Node varNode=null;
      String name=n.getString();
      int nameCount=scopedAliasNames.count(name);
      scopedAliasNames.add(name);
      String globalName=""String_Node_Str"" + name + (nameCount == 0 ? ""String_Node_Str"" : (""String_Node_Str"" + nameCount));
      compiler.ensureLibraryInjected(""String_Node_Str"");
      if (isFunctionDecl) {
        Node existingName=v.getNameNode();
        Node newName=IR.name(""String_Node_Str"").useSourceInfoFrom(existingName);
        value.replaceChild(existingName,newName);
        varNode=IR.var(existingName).useSourceInfoFrom(existingName);
        grandparent.replaceChild(parent,varNode);
      }
 else {
        if (value != null) {
          value.detachFromParent();
        }
        varNode=parent;
      }
      if (value != null || v.getJSDocInfo() != null) {
        Node newDecl=NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(),globalName,value,v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);
        NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(),n,name);
        if (isHoisted) {
          grandparent.addChildToFront(newDecl);
        }
 else {
          grandparent.addChildBefore(newDecl,varNode);
        }
        injectedDecls.add(newDecl.getFirstChild());
      }
      v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(),globalName,n,name));
      recordAlias(v);
    }
 else {
      report(t,n,GOOG_SCOPE_NON_ALIAS_LOCAL,n.getString());
    }
  }
}","private void findAliases(NodeTraversal t){
  Scope scope=t.getScope();
  for (  Var v : scope.getVarIterable()) {
    Node n=v.getNode();
    Node parent=n.getParent();
    boolean isVar=parent.isVar();
    boolean isFunctionDecl=NodeUtil.isFunctionDeclaration(parent);
    if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {
      recordAlias(v);
    }
 else     if (v.isBleedingFunction()) {
    }
 else     if (parent.getType() == Token.LP) {
    }
 else     if (isVar || isFunctionDecl) {
      boolean isHoisted=NodeUtil.isHoistedFunctionDeclaration(parent);
      Node grandparent=parent.getParent();
      Node value=v.getInitialValue() != null ? v.getInitialValue() : null;
      Node varNode=null;
      JSDocInfo varDocInfo=v.getJSDocInfo();
      String name=n.getString();
      int nameCount=scopedAliasNames.count(name);
      scopedAliasNames.add(name);
      String globalName=""String_Node_Str"" + name + (nameCount == 0 ? ""String_Node_Str"" : (""String_Node_Str"" + nameCount));
      compiler.ensureLibraryInjected(""String_Node_Str"");
      if (isFunctionDecl) {
        Node existingName=v.getNameNode();
        Node newName=IR.name(""String_Node_Str"").useSourceInfoFrom(existingName);
        value.replaceChild(existingName,newName);
        varNode=IR.var(existingName).useSourceInfoFrom(existingName);
        grandparent.replaceChild(parent,varNode);
      }
 else {
        if (value != null) {
          value.detachFromParent();
        }
        varNode=parent;
      }
      if (value != null || varDocInfo != null) {
        Node newDecl=NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(),globalName,value,varDocInfo).useSourceInfoIfMissingFromForTree(n);
        NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(),n,name);
        if (isHoisted) {
          grandparent.addChildToFront(newDecl);
        }
 else {
          grandparent.addChildBefore(newDecl,varNode);
        }
        injectedDecls.add(newDecl.getFirstChild());
      }
      v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(),globalName,n,name));
      recordAlias(v);
    }
 else {
      report(t,n,GOOG_SCOPE_NON_ALIAS_LOCAL,n.getString());
    }
  }
}",0.5956783247939408
27802,"/** 
 * Declares global variables to serve as aliases for the values in an object literal, optionally removing all of the object literal's keys and values.
 * @param alias The object literal's flattened name (e.g. ""a$b$c"")
 * @param objlit The OBJLIT node
 * @param varNode The VAR node to which new global variables should be addedas children
 * @param nameToAddAfter The child of {@code varNode} after which newvariables should be added (may be null)
 * @param varParent {@code varNode}'s parent
 * @return The number of variables added
 */
private int declareVarsForObjLitValues(Name objlitName,String alias,Node objlit,Node varNode,Node nameToAddAfter,Node varParent){
  int numVars=0;
  int arbitraryNameCounter=0;
  boolean discardKeys=!objlitName.shouldKeepKeys();
  for (Node key=objlit.getFirstChild(), nextKey; key != null; key=nextKey) {
    Node value=key.getFirstChild();
    nextKey=key.getNext();
    if (key.isGetterDef() || key.isSetterDef()) {
      continue;
    }
    boolean isJsIdentifier=!key.isNumber() && TokenStream.isJSIdentifier(key.getString());
    String propName=isJsIdentifier ? key.getString() : String.valueOf(++arbitraryNameCounter);
    String qName=objlitName.getFullName() + '.' + propName;
    Name p=nameMap.get(qName);
    if (p != null && !p.canCollapse()) {
      continue;
    }
    String propAlias=appendPropForAlias(alias,propName);
    Node refNode=null;
    if (discardKeys) {
      objlit.removeChild(key);
      value.detachFromParent();
    }
 else {
      refNode=IR.name(propAlias);
      if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) {
        refNode.putBooleanProp(Node.IS_CONSTANT_NAME,true);
      }
      key.replaceChild(value,refNode);
    }
    Node nameNode=IR.name(propAlias);
    nameNode.addChildToFront(value);
    if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) {
      nameNode.putBooleanProp(Node.IS_CONSTANT_NAME,true);
    }
    Node newVar=IR.var(nameNode).copyInformationFromForTree(key);
    if (nameToAddAfter != null) {
      varParent.addChildAfter(newVar,nameToAddAfter);
    }
 else {
      varParent.addChildBefore(newVar,varNode);
    }
    compiler.reportCodeChange();
    nameToAddAfter=newVar;
    if (isJsIdentifier && p != null) {
      if (!discardKeys) {
        Ref newAlias=p.getDeclaration().cloneAndReclassify(Ref.Type.ALIASING_GET);
        newAlias.node=refNode;
        p.addRef(newAlias);
      }
      p.getDeclaration().node=nameNode;
      if (value.isFunction()) {
        checkForHosedThisReferences(value,value.getJSDocInfo(),p);
      }
    }
    numVars++;
  }
  return numVars;
}","/** 
 * Declares global variables to serve as aliases for the values in an object literal, optionally removing all of the object literal's keys and values.
 * @param alias The object literal's flattened name (e.g. ""a$b$c"")
 * @param objlit The OBJLIT node
 * @param varNode The VAR node to which new global variables should be addedas children
 * @param nameToAddAfter The child of {@code varNode} after which newvariables should be added (may be null)
 * @param varParent {@code varNode}'s parent
 * @return The number of variables added
 */
private int declareVarsForObjLitValues(Name objlitName,String alias,Node objlit,Node varNode,Node nameToAddAfter,Node varParent){
  int numVars=0;
  int arbitraryNameCounter=0;
  boolean discardKeys=!objlitName.shouldKeepKeys();
  for (Node key=objlit.getFirstChild(), nextKey; key != null; key=nextKey) {
    Node value=key.getFirstChild();
    nextKey=key.getNext();
    if (!NodeUtil.isOptimizableObjectLitKey(key)) {
      continue;
    }
    boolean isJsIdentifier=!key.isNumber() && TokenStream.isJSIdentifier(key.getString());
    String propName=isJsIdentifier ? key.getString() : String.valueOf(++arbitraryNameCounter);
    String qName=objlitName.getFullName() + '.' + propName;
    Name p=nameMap.get(qName);
    if (p != null && !p.canCollapse()) {
      continue;
    }
    String propAlias=appendPropForAlias(alias,propName);
    Node refNode=null;
    if (discardKeys) {
      objlit.removeChild(key);
      value.detachFromParent();
    }
 else {
      refNode=IR.name(propAlias);
      if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) {
        refNode.putBooleanProp(Node.IS_CONSTANT_NAME,true);
      }
      key.replaceChild(value,refNode);
    }
    Node nameNode=IR.name(propAlias);
    nameNode.addChildToFront(value);
    if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) {
      nameNode.putBooleanProp(Node.IS_CONSTANT_NAME,true);
    }
    Node newVar=IR.var(nameNode).copyInformationFromForTree(key);
    if (nameToAddAfter != null) {
      varParent.addChildAfter(newVar,nameToAddAfter);
    }
 else {
      varParent.addChildBefore(newVar,varNode);
    }
    compiler.reportCodeChange();
    nameToAddAfter=newVar;
    if (isJsIdentifier && p != null) {
      if (!discardKeys) {
        Ref newAlias=p.getDeclaration().cloneAndReclassify(Ref.Type.ALIASING_GET);
        newAlias.node=refNode;
        p.addRef(newAlias);
      }
      p.getDeclaration().node=nameNode;
      if (value.isFunction()) {
        checkForHosedThisReferences(value,value.getJSDocInfo(),p);
      }
    }
    numVars++;
  }
  return numVars;
}",0.9864760432766616
27803,"public void collect(JSModule module,Scope scope,Node n){
  Node parent=n.getParent();
  String name;
  boolean isSet=false;
  Name.Type type=Name.Type.OTHER;
  boolean isPropAssign=false;
switch (n.getType()) {
case Token.GETTER_DEF:
case Token.SETTER_DEF:
case Token.STRING_KEY:
    name=null;
  if (parent != null && parent.isObjectLit()) {
    name=getNameForObjLitKey(n);
  }
if (name == null) {
  return;
}
isSet=true;
switch (n.getType()) {
case Token.STRING_KEY:
type=getValueType(n.getFirstChild());
break;
case Token.GETTER_DEF:
type=Name.Type.GET;
break;
case Token.SETTER_DEF:
type=Name.Type.SET;
break;
default :
throw new IllegalStateException(""String_Node_Str"" + n);
}
break;
case Token.NAME:
if (parent != null) {
switch (parent.getType()) {
case Token.VAR:
isSet=true;
Node rvalue=n.getFirstChild();
type=rvalue == null ? Name.Type.OTHER : getValueType(rvalue);
break;
case Token.ASSIGN:
if (parent.getFirstChild() == n) {
isSet=true;
type=getValueType(n.getNext());
}
break;
case Token.GETPROP:
return;
case Token.FUNCTION:
Node gramps=parent.getParent();
if (gramps == null || NodeUtil.isFunctionExpression(parent)) {
return;
}
isSet=true;
type=Name.Type.FUNCTION;
break;
case Token.CATCH:
case Token.INC:
case Token.DEC:
isSet=true;
type=Name.Type.OTHER;
break;
default :
if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) {
isSet=true;
type=Name.Type.OTHER;
}
}
}
name=n.getString();
break;
case Token.GETPROP:
if (parent != null) {
switch (parent.getType()) {
case Token.ASSIGN:
if (parent.getFirstChild() == n) {
isSet=true;
type=getValueType(n.getNext());
isPropAssign=true;
}
break;
case Token.INC:
case Token.DEC:
isSet=true;
type=Name.Type.OTHER;
break;
case Token.GETPROP:
return;
default :
if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) {
isSet=true;
type=Name.Type.OTHER;
}
}
}
name=n.getQualifiedName();
if (name == null) {
return;
}
break;
default :
return;
}
if (!isGlobalNameReference(name,scope)) {
return;
}
if (isSet) {
if (isGlobalScope(scope)) {
handleSetFromGlobal(module,scope,n,parent,name,isPropAssign,type);
}
 else {
handleSetFromLocal(module,scope,n,parent,name);
}
}
 else {
handleGet(module,scope,n,parent,name);
}
}","public void collect(JSModule module,Scope scope,Node n){
  Node parent=n.getParent();
  String name;
  boolean isSet=false;
  Name.Type type=Name.Type.OTHER;
  boolean isPropAssign=false;
switch (n.getType()) {
case Token.GETTER_DEF:
case Token.SETTER_DEF:
case Token.STRING_KEY:
    name=null;
  if (parent != null && parent.isObjectLit()) {
    name=getNameForObjLitKey(n);
  }
if (name == null) {
  return;
}
isSet=true;
switch (n.getType()) {
case Token.STRING_KEY:
if (n.isQuotedString()) {
return;
}
 else {
type=getValueType(n.getFirstChild());
}
break;
case Token.GETTER_DEF:
type=Name.Type.GET;
break;
case Token.SETTER_DEF:
type=Name.Type.SET;
break;
default :
throw new IllegalStateException(""String_Node_Str"" + n);
}
break;
case Token.NAME:
if (parent != null) {
switch (parent.getType()) {
case Token.VAR:
isSet=true;
Node rvalue=n.getFirstChild();
type=rvalue == null ? Name.Type.OTHER : getValueType(rvalue);
break;
case Token.ASSIGN:
if (parent.getFirstChild() == n) {
isSet=true;
type=getValueType(n.getNext());
}
break;
case Token.GETPROP:
return;
case Token.FUNCTION:
Node gramps=parent.getParent();
if (gramps == null || NodeUtil.isFunctionExpression(parent)) {
return;
}
isSet=true;
type=Name.Type.FUNCTION;
break;
case Token.CATCH:
case Token.INC:
case Token.DEC:
isSet=true;
type=Name.Type.OTHER;
break;
default :
if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) {
isSet=true;
type=Name.Type.OTHER;
}
}
}
name=n.getString();
break;
case Token.GETPROP:
if (parent != null) {
switch (parent.getType()) {
case Token.ASSIGN:
if (parent.getFirstChild() == n) {
isSet=true;
type=getValueType(n.getNext());
isPropAssign=true;
}
break;
case Token.INC:
case Token.DEC:
isSet=true;
type=Name.Type.OTHER;
break;
case Token.GETPROP:
return;
default :
if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) {
isSet=true;
type=Name.Type.OTHER;
}
}
}
name=n.getQualifiedName();
if (name == null) {
return;
}
break;
default :
return;
}
if (!isGlobalNameReference(name,scope)) {
return;
}
if (isSet) {
if (isGlobalScope(scope)) {
handleSetFromGlobal(module,scope,n,parent,name,isPropAssign,type);
}
 else {
handleSetFromLocal(module,scope,n,parent,name);
}
}
 else {
handleGet(module,scope,n,parent,name);
}
}",0.989658273381295
27804,"/** 
 * Counts the number of direct (full) references to an object. Specifically, we check for references of the following type: <pre> x; x.fn(); </pre>
 */
private boolean isInlinableObject(List<Reference> refs){
  boolean ret=false;
  Set<String> validProperties=Sets.newHashSet();
  for (  Reference ref : refs) {
    Node name=ref.getNode();
    Node parent=ref.getParent();
    Node gramps=ref.getGrandparent();
    if (parent.isGetProp()) {
      Preconditions.checkState(parent.getFirstChild() == name);
      if (gramps.isCall() && gramps.getFirstChild() == parent) {
        return false;
      }
      if (gramps.isDelProp()) {
        return false;
      }
      String propName=parent.getLastChild().getString();
      if (!validProperties.contains(propName)) {
        if (NodeUtil.isVarOrSimpleAssignLhs(parent,gramps)) {
          validProperties.add(propName);
        }
 else {
          return false;
        }
      }
      continue;
    }
    if (!isVarOrAssignExprLhs(name)) {
      return false;
    }
    Node val=ref.getAssignedValue();
    if (val == null) {
      continue;
    }
    if (!val.isObjectLit()) {
      return false;
    }
    for (Node child=val.getFirstChild(); child != null; child=child.getNext()) {
      if (child.isGetterDef() || child.isSetterDef()) {
        return false;
      }
      validProperties.add(child.getString());
      Node childVal=child.getFirstChild();
      for (      Reference t : refs) {
        Node refNode=t.getParent();
        while (!NodeUtil.isStatementBlock(refNode)) {
          if (refNode == childVal) {
            return false;
          }
          refNode=refNode.getParent();
        }
      }
    }
    ret=true;
  }
  return ret;
}","/** 
 * Counts the number of direct (full) references to an object. Specifically, we check for references of the following type: <pre> x; x.fn(); </pre>
 */
private boolean isInlinableObject(List<Reference> refs){
  boolean ret=false;
  Set<String> validProperties=Sets.newHashSet();
  for (  Reference ref : refs) {
    Node name=ref.getNode();
    Node parent=ref.getParent();
    Node gramps=ref.getGrandparent();
    if (parent.isGetProp()) {
      Preconditions.checkState(parent.getFirstChild() == name);
      if (gramps.isCall() && gramps.getFirstChild() == parent) {
        return false;
      }
      if (gramps.isDelProp()) {
        return false;
      }
      String propName=parent.getLastChild().getString();
      if (!validProperties.contains(propName)) {
        if (NodeUtil.isVarOrSimpleAssignLhs(parent,gramps)) {
          validProperties.add(propName);
        }
 else {
          return false;
        }
      }
      continue;
    }
    if (!isVarOrAssignExprLhs(name)) {
      return false;
    }
    Node val=ref.getAssignedValue();
    if (val == null) {
      continue;
    }
    if (!val.isObjectLit()) {
      return false;
    }
    for (Node child=val.getFirstChild(); child != null; child=child.getNext()) {
      if (!NodeUtil.isOptimizableObjectLitKey(child)) {
        return false;
      }
      validProperties.add(child.getString());
      Node childVal=child.getFirstChild();
      for (      Reference t : refs) {
        Node refNode=t.getParent();
        while (!NodeUtil.isStatementBlock(refNode)) {
          if (refNode == childVal) {
            return false;
          }
          refNode=refNode.getParent();
        }
      }
    }
    ret=true;
  }
  return ret;
}",0.7584400465657741
27805,"/** 
 * Inline a function into the call site.
 */
private void inlineFunction(NodeTraversal t,Node callNode,FunctionState fs,InliningMode mode){
  Function fn=fs.getFn();
  String fnName=fn.getName();
  Node fnNode=fs.getSafeFnNode();
  t.getCompiler().reportChangeToEnclosingScope(callNode);
  injector.inline(callNode,fnName,fnNode,mode);
  t.getCompiler().addToDebugLog(""String_Node_Str"" + fn.getName());
}","/** 
 * Inline a function into the call site.
 */
private void inlineFunction(NodeTraversal t,Node callNode,FunctionState fs,InliningMode mode){
  Function fn=fs.getFn();
  String fnName=fn.getName();
  Node fnNode=fs.getSafeFnNode();
  Node newExpr=injector.inline(callNode,fnName,fnNode,mode);
  if (!newExpr.isEquivalentTo(callNode)) {
    t.getCompiler().reportChangeToEnclosingScope(newExpr);
  }
  t.getCompiler().addToDebugLog(""String_Node_Str"" + fn.getName());
}",0.7986348122866894
27806,"/** 
 * Creates a dotted namespace assignment expression (e.g. <code>foo.bar = {};</code>).
 */
private Node makeAssignmentExprNode(){
  Node decl=IR.exprResult(IR.assign(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(),namespace,firstNode,namespace),createNamespaceLiteral()));
  decl.putBooleanProp(Node.IS_NAMESPACE,true);
  if (candidateDefinition == null) {
    decl.getFirstChild().setJSDocInfo(createConstantJsDoc());
  }
  Preconditions.checkState(isNamespacePlaceholder(decl));
  setSourceInfo(decl);
  return decl;
}","/** 
 * Creates a dotted namespace assignment expression (e.g. <code>foo.bar = {};</code>).
 */
private Node makeAssignmentExprNode(){
  Node decl=IR.exprResult(IR.assign(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(),namespace,firstNode,namespace),createNamespaceLiteral()));
  decl.putBooleanProp(Node.IS_NAMESPACE,true);
  if (candidateDefinition == null) {
    decl.getFirstChild().setJSDocInfo(NodeUtil.createConstantJsDoc());
  }
  Preconditions.checkState(isNamespacePlaceholder(decl));
  setSourceInfo(decl);
  return decl;
}",0.991705069124424
27807,"/** 
 * Creates a simple namespace variable declaration (e.g. <code>var foo = {};</code>).
 */
private Node makeVarDeclNode(){
  Node name=IR.name(namespace);
  name.addChildToFront(createNamespaceLiteral());
  Node decl=IR.var(name);
  decl.putBooleanProp(Node.IS_NAMESPACE,true);
  if (compiler.getCodingConvention().isConstant(namespace)) {
    name.putBooleanProp(Node.IS_CONSTANT_NAME,true);
  }
  if (candidateDefinition == null) {
    name.setJSDocInfo(createConstantJsDoc());
  }
  Preconditions.checkState(isNamespacePlaceholder(decl));
  setSourceInfo(decl);
  return decl;
}","/** 
 * Creates a simple namespace variable declaration (e.g. <code>var foo = {};</code>).
 */
private Node makeVarDeclNode(){
  Node name=IR.name(namespace);
  name.addChildToFront(createNamespaceLiteral());
  Node decl=IR.var(name);
  decl.putBooleanProp(Node.IS_NAMESPACE,true);
  if (compiler.getCodingConvention().isConstant(namespace)) {
    name.putBooleanProp(Node.IS_CONSTANT_NAME,true);
  }
  if (candidateDefinition == null) {
    name.setJSDocInfo(NodeUtil.createConstantJsDoc());
  }
  Preconditions.checkState(isNamespacePlaceholder(decl));
  setSourceInfo(decl);
  return decl;
}",0.9923664122137404
27808,"/** 
 * Emit goog.provide and add suffix to all global vars to avoid conflicts with other modules.
 */
private void visitScript(NodeTraversal t,Node script){
  Preconditions.checkArgument(scriptNodeCount == 1,""String_Node_Str"" + ""String_Node_Str"");
  String moduleName=guessCJSModuleName(script.getSourceFileName());
  script.addChildToFront(IR.var(IR.name(moduleName),IR.objectlit()).copyInformationFromForTree(script));
  if (reportDependencies) {
    CompilerInput ci=t.getInput();
    ci.addProvide(moduleName);
    JSModule m=new JSModule(moduleName);
    m.addAndOverrideModule(ci);
    module=m;
  }
  script.addChildToFront(IR.exprResult(IR.call(IR.getprop(IR.name(""String_Node_Str""),IR.string(""String_Node_Str"")),IR.string(moduleName))).copyInformationFromForTree(script));
  emitOptionalModuleExportsOverride(script,moduleName);
  NodeTraversal.traverse(compiler,script,new SuffixVarsCallback(moduleName));
  compiler.reportCodeChange();
}","/** 
 * Emit goog.provide and add suffix to all global vars to avoid conflicts with other modules.
 */
private void visitScript(NodeTraversal t,Node script){
  Preconditions.checkArgument(scriptNodeCount == 1,""String_Node_Str"" + ""String_Node_Str"");
  String moduleName=guessCJSModuleName(script.getSourceFileName());
  NodeTraversal.traverse(compiler,script,new SuffixVarsCallback(moduleName));
  processExports(script,moduleName);
  moduleExportRefs.clear();
  exportRefs.clear();
  if (reportDependencies) {
    CompilerInput ci=t.getInput();
    ci.addProvide(moduleName);
    JSModule m=new JSModule(moduleName);
    m.addAndOverrideModule(ci);
    module=m;
  }
  script.addChildToFront(IR.exprResult(IR.call(IR.getprop(IR.name(""String_Node_Str""),IR.string(""String_Node_Str"")),IR.string(moduleName))).copyInformationFromForTree(script));
  compiler.reportCodeChange();
}",0.5120614035087719
27809,"@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (n.isName()) {
    String name=n.getString();
    if (suffix.equals(name)) {
      return;
    }
    if (EXPORTS.equals(name)) {
      n.setString(suffix);
      n.putProp(Node.ORIGINALNAME_PROP,EXPORTS);
    }
 else {
      Scope.Var var=t.getScope().getVar(name);
      if (var != null && var.isGlobal()) {
        n.setString(name + ""String_Node_Str"" + suffix);
        n.putProp(Node.ORIGINALNAME_PROP,name);
      }
    }
  }
}","@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (n.isName()) {
    String name=n.getString();
    if (suffix.equals(name)) {
      return;
    }
    if (EXPORTS.equals(name)) {
      return;
    }
    Scope.Var var=t.getScope().getVar(name);
    if (var != null && var.isGlobal()) {
      n.setString(name + ""String_Node_Str"" + suffix);
      n.putProp(Node.ORIGINALNAME_PROP,name);
    }
  }
}",0.5816993464052288
27810,"/** 
 * When define is called with an object literal, assign it to exports and we're done.
 */
private void handleDefineObjectLiteral(Node parent,Node onlyExport,Node script){
  onlyExport.getParent().removeChild(onlyExport);
  script.replaceChild(parent,IR.exprResult(IR.assign(IR.name(""String_Node_Str""),onlyExport)).copyInformationFromForTree(onlyExport));
  compiler.reportCodeChange();
}","/** 
 * When define is called with an object literal, assign it to module.exports and we're done.
 */
private void handleDefineObjectLiteral(Node parent,Node onlyExport,Node script){
  onlyExport.getParent().removeChild(onlyExport);
  script.replaceChild(parent,IR.exprResult(IR.assign(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(),""String_Node_Str""),onlyExport)).copyInformationFromForTree(onlyExport));
  compiler.reportCodeChange();
}",0.909952606635071
27811,"/** 
 * Declares global variables to serve as aliases for the values in an object literal, optionally removing all of the object literal's keys and values.
 * @param alias The object literal's flattened name (e.g. ""a$b$c"")
 * @param objlit The OBJLIT node
 * @param varNode The VAR node to which new global variables should be addedas children
 * @param nameToAddAfter The child of {@code varNode} after which newvariables should be added (may be null)
 * @param varParent {@code varNode}'s parent
 * @return The number of variables added
 */
private int declareVarsForObjLitValues(Name objlitName,String alias,Node objlit,Node varNode,Node nameToAddAfter,Node varParent){
  int numVars=0;
  int arbitraryNameCounter=0;
  boolean discardKeys=!objlitName.shouldKeepKeys();
  for (Node key=objlit.getFirstChild(), nextKey; key != null; key=nextKey) {
    Node value=key.getFirstChild();
    nextKey=key.getNext();
    if (!NodeUtil.isOptimizableObjectLitKey(key)) {
      continue;
    }
    boolean isJsIdentifier=!key.isNumber() && TokenStream.isJSIdentifier(key.getString());
    String propName=isJsIdentifier ? key.getString() : String.valueOf(++arbitraryNameCounter);
    String qName=objlitName.getFullName() + '.' + propName;
    Name p=nameMap.get(qName);
    if (p != null && !p.canCollapse()) {
      continue;
    }
    String propAlias=appendPropForAlias(alias,propName);
    Node refNode=null;
    if (discardKeys) {
      objlit.removeChild(key);
      value.detachFromParent();
    }
 else {
      refNode=IR.name(propAlias);
      if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) {
        refNode.putBooleanProp(Node.IS_CONSTANT_NAME,true);
      }
      key.replaceChild(value,refNode);
    }
    Node nameNode=IR.name(propAlias);
    nameNode.addChildToFront(value);
    if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) {
      nameNode.putBooleanProp(Node.IS_CONSTANT_NAME,true);
    }
    Node newVar=IR.var(nameNode).copyInformationFromForTree(key);
    if (nameToAddAfter != null) {
      varParent.addChildAfter(newVar,nameToAddAfter);
    }
 else {
      varParent.addChildBefore(newVar,varNode);
    }
    compiler.reportCodeChange();
    nameToAddAfter=newVar;
    if (isJsIdentifier && p != null) {
      if (!discardKeys) {
        Ref newAlias=p.getDeclaration().cloneAndReclassify(Ref.Type.ALIASING_GET);
        newAlias.node=refNode;
        p.addRef(newAlias);
      }
      p.getDeclaration().node=nameNode;
      if (value.isFunction()) {
        checkForHosedThisReferences(value,value.getJSDocInfo(),p);
      }
    }
    numVars++;
  }
  return numVars;
}","/** 
 * Declares global variables to serve as aliases for the values in an object literal, optionally removing all of the object literal's keys and values.
 * @param alias The object literal's flattened name (e.g. ""a$b$c"")
 * @param objlit The OBJLIT node
 * @param varNode The VAR node to which new global variables should be addedas children
 * @param nameToAddAfter The child of {@code varNode} after which newvariables should be added (may be null)
 * @param varParent {@code varNode}'s parent
 * @return The number of variables added
 */
private int declareVarsForObjLitValues(Name objlitName,String alias,Node objlit,Node varNode,Node nameToAddAfter,Node varParent){
  int numVars=0;
  int arbitraryNameCounter=0;
  boolean discardKeys=!objlitName.shouldKeepKeys();
  for (Node key=objlit.getFirstChild(), nextKey; key != null; key=nextKey) {
    Node value=key.getFirstChild();
    nextKey=key.getNext();
    if (key.isGetterDef() || key.isSetterDef()) {
      continue;
    }
    boolean isJsIdentifier=!key.isNumber() && TokenStream.isJSIdentifier(key.getString());
    String propName=isJsIdentifier ? key.getString() : String.valueOf(++arbitraryNameCounter);
    String qName=objlitName.getFullName() + '.' + propName;
    Name p=nameMap.get(qName);
    if (p != null && !p.canCollapse()) {
      continue;
    }
    String propAlias=appendPropForAlias(alias,propName);
    Node refNode=null;
    if (discardKeys) {
      objlit.removeChild(key);
      value.detachFromParent();
    }
 else {
      refNode=IR.name(propAlias);
      if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) {
        refNode.putBooleanProp(Node.IS_CONSTANT_NAME,true);
      }
      key.replaceChild(value,refNode);
    }
    Node nameNode=IR.name(propAlias);
    nameNode.addChildToFront(value);
    if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) {
      nameNode.putBooleanProp(Node.IS_CONSTANT_NAME,true);
    }
    Node newVar=IR.var(nameNode).copyInformationFromForTree(key);
    if (nameToAddAfter != null) {
      varParent.addChildAfter(newVar,nameToAddAfter);
    }
 else {
      varParent.addChildBefore(newVar,varNode);
    }
    compiler.reportCodeChange();
    nameToAddAfter=newVar;
    if (isJsIdentifier && p != null) {
      if (!discardKeys) {
        Ref newAlias=p.getDeclaration().cloneAndReclassify(Ref.Type.ALIASING_GET);
        newAlias.node=refNode;
        p.addRef(newAlias);
      }
      p.getDeclaration().node=nameNode;
      if (value.isFunction()) {
        checkForHosedThisReferences(value,value.getJSDocInfo(),p);
      }
    }
    numVars++;
  }
  return numVars;
}",0.9864760432766616
27812,"public void collect(JSModule module,Scope scope,Node n){
  Node parent=n.getParent();
  String name;
  boolean isSet=false;
  Name.Type type=Name.Type.OTHER;
  boolean isPropAssign=false;
switch (n.getType()) {
case Token.GETTER_DEF:
case Token.SETTER_DEF:
case Token.STRING_KEY:
    name=null;
  if (parent != null && parent.isObjectLit()) {
    name=getNameForObjLitKey(n);
  }
if (name == null) {
  return;
}
isSet=true;
switch (n.getType()) {
case Token.STRING_KEY:
if (n.isQuotedString()) {
return;
}
 else {
type=getValueType(n.getFirstChild());
}
break;
case Token.GETTER_DEF:
type=Name.Type.GET;
break;
case Token.SETTER_DEF:
type=Name.Type.SET;
break;
default :
throw new IllegalStateException(""String_Node_Str"" + n);
}
break;
case Token.NAME:
if (parent != null) {
switch (parent.getType()) {
case Token.VAR:
isSet=true;
Node rvalue=n.getFirstChild();
type=rvalue == null ? Name.Type.OTHER : getValueType(rvalue);
break;
case Token.ASSIGN:
if (parent.getFirstChild() == n) {
isSet=true;
type=getValueType(n.getNext());
}
break;
case Token.GETPROP:
return;
case Token.FUNCTION:
Node gramps=parent.getParent();
if (gramps == null || NodeUtil.isFunctionExpression(parent)) {
return;
}
isSet=true;
type=Name.Type.FUNCTION;
break;
case Token.CATCH:
case Token.INC:
case Token.DEC:
isSet=true;
type=Name.Type.OTHER;
break;
default :
if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) {
isSet=true;
type=Name.Type.OTHER;
}
}
}
name=n.getString();
break;
case Token.GETPROP:
if (parent != null) {
switch (parent.getType()) {
case Token.ASSIGN:
if (parent.getFirstChild() == n) {
isSet=true;
type=getValueType(n.getNext());
isPropAssign=true;
}
break;
case Token.INC:
case Token.DEC:
isSet=true;
type=Name.Type.OTHER;
break;
case Token.GETPROP:
return;
default :
if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) {
isSet=true;
type=Name.Type.OTHER;
}
}
}
name=n.getQualifiedName();
if (name == null) {
return;
}
break;
default :
return;
}
if (!isGlobalNameReference(name,scope)) {
return;
}
if (isSet) {
if (isGlobalScope(scope)) {
handleSetFromGlobal(module,scope,n,parent,name,isPropAssign,type);
}
 else {
handleSetFromLocal(module,scope,n,parent,name);
}
}
 else {
handleGet(module,scope,n,parent,name);
}
}","public void collect(JSModule module,Scope scope,Node n){
  Node parent=n.getParent();
  String name;
  boolean isSet=false;
  Name.Type type=Name.Type.OTHER;
  boolean isPropAssign=false;
switch (n.getType()) {
case Token.GETTER_DEF:
case Token.SETTER_DEF:
case Token.STRING_KEY:
    name=null;
  if (parent != null && parent.isObjectLit()) {
    name=getNameForObjLitKey(n);
  }
if (name == null) {
  return;
}
isSet=true;
switch (n.getType()) {
case Token.STRING_KEY:
type=getValueType(n.getFirstChild());
break;
case Token.GETTER_DEF:
type=Name.Type.GET;
break;
case Token.SETTER_DEF:
type=Name.Type.SET;
break;
default :
throw new IllegalStateException(""String_Node_Str"" + n);
}
break;
case Token.NAME:
if (parent != null) {
switch (parent.getType()) {
case Token.VAR:
isSet=true;
Node rvalue=n.getFirstChild();
type=rvalue == null ? Name.Type.OTHER : getValueType(rvalue);
break;
case Token.ASSIGN:
if (parent.getFirstChild() == n) {
isSet=true;
type=getValueType(n.getNext());
}
break;
case Token.GETPROP:
return;
case Token.FUNCTION:
Node gramps=parent.getParent();
if (gramps == null || NodeUtil.isFunctionExpression(parent)) {
return;
}
isSet=true;
type=Name.Type.FUNCTION;
break;
case Token.CATCH:
case Token.INC:
case Token.DEC:
isSet=true;
type=Name.Type.OTHER;
break;
default :
if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) {
isSet=true;
type=Name.Type.OTHER;
}
}
}
name=n.getString();
break;
case Token.GETPROP:
if (parent != null) {
switch (parent.getType()) {
case Token.ASSIGN:
if (parent.getFirstChild() == n) {
isSet=true;
type=getValueType(n.getNext());
isPropAssign=true;
}
break;
case Token.INC:
case Token.DEC:
isSet=true;
type=Name.Type.OTHER;
break;
case Token.GETPROP:
return;
default :
if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) {
isSet=true;
type=Name.Type.OTHER;
}
}
}
name=n.getQualifiedName();
if (name == null) {
return;
}
break;
default :
return;
}
if (!isGlobalNameReference(name,scope)) {
return;
}
if (isSet) {
if (isGlobalScope(scope)) {
handleSetFromGlobal(module,scope,n,parent,name,isPropAssign,type);
}
 else {
handleSetFromLocal(module,scope,n,parent,name);
}
}
 else {
handleGet(module,scope,n,parent,name);
}
}",0.989658273381295
27813,"/** 
 * Counts the number of direct (full) references to an object. Specifically, we check for references of the following type: <pre> x; x.fn(); </pre>
 */
private boolean isInlinableObject(List<Reference> refs){
  boolean ret=false;
  Set<String> validProperties=Sets.newHashSet();
  for (  Reference ref : refs) {
    Node name=ref.getNode();
    Node parent=ref.getParent();
    Node gramps=ref.getGrandparent();
    if (parent.isGetProp()) {
      Preconditions.checkState(parent.getFirstChild() == name);
      if (gramps.isCall() && gramps.getFirstChild() == parent) {
        return false;
      }
      if (gramps.isDelProp()) {
        return false;
      }
      String propName=parent.getLastChild().getString();
      if (!validProperties.contains(propName)) {
        if (NodeUtil.isVarOrSimpleAssignLhs(parent,gramps)) {
          validProperties.add(propName);
        }
 else {
          return false;
        }
      }
      continue;
    }
    if (!isVarOrAssignExprLhs(name)) {
      return false;
    }
    Node val=ref.getAssignedValue();
    if (val == null) {
      continue;
    }
    if (!val.isObjectLit()) {
      return false;
    }
    for (Node child=val.getFirstChild(); child != null; child=child.getNext()) {
      if (!NodeUtil.isOptimizableObjectLitKey(child)) {
        return false;
      }
      validProperties.add(child.getString());
      Node childVal=child.getFirstChild();
      for (      Reference t : refs) {
        Node refNode=t.getParent();
        while (!NodeUtil.isStatementBlock(refNode)) {
          if (refNode == childVal) {
            return false;
          }
          refNode=refNode.getParent();
        }
      }
    }
    ret=true;
  }
  return ret;
}","/** 
 * Counts the number of direct (full) references to an object. Specifically, we check for references of the following type: <pre> x; x.fn(); </pre>
 */
private boolean isInlinableObject(List<Reference> refs){
  boolean ret=false;
  Set<String> validProperties=Sets.newHashSet();
  for (  Reference ref : refs) {
    Node name=ref.getNode();
    Node parent=ref.getParent();
    Node gramps=ref.getGrandparent();
    if (parent.isGetProp()) {
      Preconditions.checkState(parent.getFirstChild() == name);
      if (gramps.isCall() && gramps.getFirstChild() == parent) {
        return false;
      }
      if (gramps.isDelProp()) {
        return false;
      }
      String propName=parent.getLastChild().getString();
      if (!validProperties.contains(propName)) {
        if (NodeUtil.isVarOrSimpleAssignLhs(parent,gramps)) {
          validProperties.add(propName);
        }
 else {
          return false;
        }
      }
      continue;
    }
    if (!isVarOrAssignExprLhs(name)) {
      return false;
    }
    Node val=ref.getAssignedValue();
    if (val == null) {
      continue;
    }
    if (!val.isObjectLit()) {
      return false;
    }
    for (Node child=val.getFirstChild(); child != null; child=child.getNext()) {
      if (child.isGetterDef() || child.isSetterDef()) {
        return false;
      }
      validProperties.add(child.getString());
      Node childVal=child.getFirstChild();
      for (      Reference t : refs) {
        Node refNode=t.getParent();
        while (!NodeUtil.isStatementBlock(refNode)) {
          if (refNode == childVal) {
            return false;
          }
          refNode=refNode.getParent();
        }
      }
    }
    ret=true;
  }
  return ret;
}",0.7660069848661234
27814,"private Logger getLogger(){
  if (logger == null) {
    logger=Logger.getLogger(Driver.class.getName());
    logger.setLevel(level.getLevel());
  }
  return logger;
}","private Logger getLogger(){
  if (logger == null) {
    logger=Logger.getLogger(Driver.class.getName());
    logger.setLevel(level.getLevel());
    for (    Handler handler : logger.getHandlers()) {
      handler.setLevel(Level.ALL);
    }
  }
  return logger;
}",0.7757009345794392
27815,"private void run(){
  if (seed != -1) {
    numberOfRuns=1;
  }
  for (int i=0; forever() || i < numberOfRuns; i++) {
    getLogger().info(""String_Node_Str"" + i + ""String_Node_Str""+ numberOfRuns+ ""String_Node_Str"");
    Node script=fuzz();
    if (script == null) {
      if (forever()) {
        break;
      }
    }
    String code1=ScriptFuzzer.getPrettyCode(script);
    StringBuffer sb=new StringBuffer(""String_Node_Str"").append(seed);
    sb.append(""String_Node_Str"").append(code1);
    String debugInfo=sb.toString();
    try {
      Result result=compile(script);
      if (result.success && result.warnings.length == 0) {
        getLogger().info(""String_Node_Str"");
        getLogger().info(debugInfo);
      }
 else {
        getLogger().warning(""String_Node_Str"");
        getLogger().info(debugInfo);
      }
    }
 catch (    Exception e) {
      getLogger().log(Level.SEVERE,""String_Node_Str"",e);
      getLogger().warning(debugInfo);
      if (forever()) {
        break;
      }
    }
    String code2=ScriptFuzzer.getPrettyCode(script);
    getLogger().info(""String_Node_Str"" + code2);
    if (execute) {
      if (!executeJS(code1,code2) && forever()) {
        break;
      }
    }
  }
}","private void run(){
  if (seed != -1) {
    numberOfRuns=1;
  }
  for (int i=0; forever() || i < numberOfRuns; i++) {
    getLogger().info(""String_Node_Str"" + i + ""String_Node_Str""+ numberOfRuns+ ""String_Node_Str"");
    Node script=fuzz();
    if (script == null) {
      if (forever()) {
        break;
      }
    }
    String code1=ScriptFuzzer.getPrettyCode(script);
    StringBuffer sb=new StringBuffer(""String_Node_Str"").append(seed);
    sb.append(""String_Node_Str"").append(code1);
    String debugInfo=sb.toString();
    try {
      Result result=compile(script);
      if (result.success) {
        if (result.warnings.length == 0) {
          getLogger().info(debugInfo);
        }
 else {
          getLogger().warning(debugInfo);
        }
      }
 else {
        getLogger().severe(debugInfo);
        if (forever()) {
          break;
        }
      }
    }
 catch (    Exception e) {
      getLogger().log(Level.SEVERE,""String_Node_Str"",e);
      getLogger().severe(debugInfo);
      if (forever()) {
        break;
      }
    }
    String code2=ScriptFuzzer.getPrettyCode(script);
    getLogger().info(""String_Node_Str"" + code2);
    if (execute) {
      if (!executeJS(code1,code2) && forever()) {
        break;
      }
    }
  }
}",0.9178193653376728
27816,"private JSONObject getConfig(){
  File file=new File(configFileName);
  try {
    return new JSONObject(Files.toString(file,StandardCharsets.UTF_8));
  }
 catch (  JSONException|IOException e) {
    e.printStackTrace();
    return null;
  }
}","private JSONObject getConfig(){
  if (config == null) {
    File file=new File(configFileName);
    try {
      config=new JSONObject(Files.toString(file,StandardCharsets.UTF_8));
    }
 catch (    JSONException|IOException e) {
      e.printStackTrace();
    }
  }
  return config;
}",0.8517110266159695
27817,"public static boolean isSame(String error1,String error2){
  if (error1 == null && error2 == null) {
    return true;
  }
 else   if (error1 == null || error2 == null) {
    return false;
  }
 else {
    if (error1.equals(error2)) {
      return true;
    }
    String lineSeparator=System.getProperty(""String_Node_Str"");
    String[] lines1=error1.trim().split(lineSeparator);
    String[] lines2=error2.trim().split(lineSeparator);
    if (lines1.length == lines2.length && lines1[1].trim().startsWith(""String_Node_Str"") && lines2[1].trim().startsWith(""String_Node_Str"")) {
      return true;
    }
    if (error1.contains(""String_Node_Str"") && error2.contains(""String_Node_Str"")) {
      return true;
    }
  }
  return false;
}","public static boolean isSame(String error1,String error2){
  if (error1 == null && error2 == null) {
    return true;
  }
 else   if (error1 == null || error2 == null) {
    return false;
  }
 else {
    if (error1.equals(error2)) {
      return true;
    }
    String lineSeparator=System.getProperty(""String_Node_Str"");
    String[] lines1=error1.trim().split(lineSeparator);
    String[] lines2=error2.trim().split(lineSeparator);
    if (lines1.length == lines2.length && lines1[1].trim().contains(""String_Node_Str"") && lines2[1].trim().contains(""String_Node_Str"")) {
      return true;
    }
    if (error1.contains(""String_Node_Str"") && error2.contains(""String_Node_Str"")) {
      return true;
    }
    if (error1.contains(""String_Node_Str"") && error2.contains(""String_Node_Str"")) {
      return true;
    }
  }
  return false;
}",0.9074664964901084
27818,"private boolean forever(){
  return numberOfRuns < 1;
}","private boolean forever(){
  return numberOfRuns == -1;
}",0.9642857142857144
27819,"@Override protected Node generate(int budget){
  String name=null;
  if (scopeManager.hasNonLocals() && random.nextDouble() < config.optJSONObject(""String_Node_Str"").optDouble(""String_Node_Str"")) {
    name=scopeManager.getRandomSymbol(true).name;
  }
  if (name == null) {
    name=""String_Node_Str"" + snGenerator.getNextNumber();
  }
  scopeManager.addSymbol(new Symbol(name));
  return Node.newString(Token.NAME,name);
}","@Override protected Node generate(int budget){
  String name=null;
  if (scopeManager.hasNonLocals() && random.nextDouble() < config.optJSONObject(""String_Node_Str"").optDouble(""String_Node_Str"")) {
    Symbol symbol=scopeManager.getRandomSymbol(true);
    if (symbol != null) {
      name=symbol.name;
    }
  }
  if (name == null) {
    name=""String_Node_Str"" + snGenerator.getNextNumber();
  }
  scopeManager.addSymbol(new Symbol(name));
  return Node.newString(Token.NAME,name);
}",0.911699779249448
27820,"public ScopeManager(Random random){
  this.random=random;
  Scope globalScope=new Scope();
  globalScope.symbols=Lists.newArrayList(new Symbol(""String_Node_Str"",Type.FUNCTION),new Symbol(""String_Node_Str"",Type.FUNCTION),new Symbol(""String_Node_Str"",Type.FUNCTION),new Symbol(""String_Node_Str"",Type.FUNCTION),new Symbol(""String_Node_Str"",Type.FUNCTION),new Symbol(""String_Node_Str"",Type.FUNCTION),new Symbol(""String_Node_Str"",Type.FUNCTION),new Symbol(""String_Node_Str"",Type.FUNCTION),new Symbol(""String_Node_Str"",Type.OBJECT),new Symbol(""String_Node_Str"",Type.FUNCTION));
  numSym=globalScope.symbols.size();
  scopeStack.push(globalScope);
}","public ScopeManager(Random random){
  this.random=random;
  Scope globalScope=new Scope();
  globalScope.symbols=Lists.newArrayList(new Symbol(""String_Node_Str"",Type.FUNCTION),new Symbol(""String_Node_Str"",Type.FUNCTION),new Symbol(""String_Node_Str"",Type.FUNCTION),new Symbol(""String_Node_Str"",Type.FUNCTION),new Symbol(""String_Node_Str"",Type.FUNCTION),new Symbol(""String_Node_Str"",Type.FUNCTION),new Symbol(""String_Node_Str"",Type.FUNCTION),new Symbol(""String_Node_Str"",Type.OBJECT),new Symbol(""String_Node_Str"",Type.OBJECT),new Symbol(""String_Node_Str"",Type.FUNCTION));
  numSym=globalScope.symbols.size();
  scopeStack.push(globalScope);
}",0.9329173166926678
27821,"public Symbol getRandomSymbol(Type type,boolean excludeLocal){
  if (excludeLocal) {
    Preconditions.checkArgument(getNumScopes() > 1);
  }
 else {
    Preconditions.checkArgument(getNumScopes() > 0);
  }
  List<Symbol> symbols=new ArrayList<>();
  ArrayList<Scope> scopes=new ArrayList<Scope>(scopeStack);
  int i;
  if (excludeLocal) {
    i=1;
  }
 else {
    i=0;
  }
  while (i < scopes.size()) {
    Scope scope=scopes.get(i);
    for (    Symbol s : scope.symbols) {
      if (type == null || s.type == type) {
        symbols.add(s);
      }
    }
    i++;
  }
  int numCandidates=symbols.size();
  if (numCandidates == 0) {
    return null;
  }
  Symbol sym=symbols.get(random.nextInt(numCandidates));
  if (excludeLocal && localSymbols().indexOf(sym) != -1) {
    return null;
  }
 else {
    return sym;
  }
}","public Symbol getRandomSymbol(Type type,boolean excludeLocal){
  if (excludeLocal) {
    Preconditions.checkArgument(getNumScopes() > 1);
  }
 else {
    Preconditions.checkArgument(getNumScopes() > 0);
  }
  List<Symbol> symbols=new ArrayList<>();
  ArrayList<Scope> scopes=new ArrayList<Scope>(scopeStack);
  int i;
  if (excludeLocal) {
    i=1;
  }
 else {
    i=0;
  }
  while (i < scopes.size()) {
    Scope scope=scopes.get(i);
    for (    Symbol s : scope.symbols) {
      if (type == null || s.type == type) {
        symbols.add(s);
      }
    }
    i++;
  }
  int numCandidates=symbols.size();
  if (numCandidates == 0) {
    return null;
  }
  Symbol sym=symbols.get(random.nextInt(numCandidates));
  if (excludeLocal && searchLocalFor(sym.name) != null) {
    return null;
  }
 else {
    return sym;
  }
}",0.9007912355447352
27822,"public void removeSymbol(String symbolName){
  Symbol symbol=null;
  for (  Symbol s : localSymbols()) {
    if (s.name.equals(symbolName)) {
      symbol=s;
      break;
    }
  }
  if (symbol != null && localSymbols().remove(symbol)) {
    numSym--;
  }
}","public void removeSymbol(String symbolName){
  Symbol symbol=searchLocalFor(symbolName);
  if (symbol != null && localSymbols().remove(symbol)) {
    numSym--;
  }
}",0.7440758293838863
27823,"@Override protected CompilerOptions createOptions(){
  CompilerOptions options=new CompilerOptions();
  if (flags.processJqueryPrimitives) {
    options.setCodingConvention(new JqueryCodingConvention());
  }
 else {
    options.setCodingConvention(new ClosureCodingConvention());
  }
  options.setExtraAnnotationNames(flags.extraAnnotationName);
  CompilationLevel level=flags.compilationLevel;
  level.setOptionsForCompilationLevel(options);
  if (flags.debug) {
    level.setDebugOptionsForCompilationLevel(options);
  }
  if (flags.useTypesForOptimization) {
    level.setTypeBasedOptimizationOptions(options);
  }
  if (flags.generateExports) {
    options.setGenerateExports(flags.generateExports);
  }
  WarningLevel wLevel=flags.warningLevel;
  wLevel.setOptionsForWarningLevel(options);
  for (  FormattingOption formattingOption : flags.formatting) {
    formattingOption.applyToOptions(options);
  }
  options.closurePass=flags.processClosurePrimitives;
  options.jqueryPass=CompilationLevel.ADVANCED_OPTIMIZATIONS == level && flags.processJqueryPrimitives;
  options.angularPass=flags.angularPass;
  if (!flags.translationsFile.isEmpty()) {
    try {
      options.messageBundle=new XtbMessageBundle(new FileInputStream(flags.translationsFile),flags.translationsProject);
    }
 catch (    IOException e) {
      throw new RuntimeException(""String_Node_Str"",e);
    }
  }
 else   if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) {
    options.messageBundle=new EmptyMessageBundle();
  }
  return options;
}","@Override protected CompilerOptions createOptions(){
  CompilerOptions options=new CompilerOptions();
  if (flags.processJqueryPrimitives) {
    options.setCodingConvention(new JqueryCodingConvention());
  }
 else {
    options.setCodingConvention(new ClosureCodingConvention());
  }
  options.setExtraAnnotationNames(flags.extraAnnotationName);
  CompilationLevel level=flags.compilationLevel;
  level.setOptionsForCompilationLevel(options);
  if (flags.debug) {
    level.setDebugOptionsForCompilationLevel(options);
  }
  if (flags.useTypesForOptimization) {
    level.setTypeBasedOptimizationOptions(options);
  }
  if (flags.generateExports) {
    options.setGenerateExports(flags.generateExports);
  }
  WarningLevel wLevel=flags.warningLevel;
  wLevel.setOptionsForWarningLevel(options);
  for (  FormattingOption formattingOption : flags.formatting) {
    formattingOption.applyToOptions(options);
  }
  options.closurePass=flags.processClosurePrimitives;
  options.jqueryPass=CompilationLevel.ADVANCED_OPTIMIZATIONS == level && flags.processJqueryPrimitives;
  options.angularPass=flags.angularPass;
  if (!flags.translationsFile.isEmpty()) {
    try {
      options.messageBundle=new XtbMessageBundle(new FileInputStream(flags.translationsFile),flags.translationsProject);
    }
 catch (    IOException e) {
      throw new RuntimeException(""String_Node_Str"",e);
    }
  }
 else   if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) {
    options.messageBundle=new EmptyMessageBundle();
    options.setWarningLevel(JsMessageVisitor.MSG_CONVENTIONS,CheckLevel.OFF);
  }
  return options;
}",0.9750160153747598
27824,"/** 
 * Updates the scope according to the result of a type change, like an assignment or a type cast.
 */
private void updateScopeForTypeChange(FlowScope scope,Node left,JSType leftType,JSType resultType){
  Preconditions.checkNotNull(resultType);
switch (left.getType()) {
case Token.NAME:
    String varName=left.getString();
  Var var=syntacticScope.getVar(varName);
boolean isVarDeclaration=left.hasChildren();
if (!isVarDeclaration || var == null || var.isTypeInferred()) {
redeclareSimpleVar(scope,left,resultType);
}
left.setJSType(isVarDeclaration || leftType == null ? resultType : null);
if (var != null && var.isTypeInferred()) {
JSType oldType=var.getType();
var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType));
}
break;
case Token.GETPROP:
String qualifiedName=left.getQualifiedName();
if (qualifiedName != null) {
scope.inferQualifiedSlot(left,qualifiedName,leftType == null ? unknownType : leftType,resultType);
}
left.setJSType(resultType);
ensurePropertyDefined(left,resultType);
break;
}
}","/** 
 * Updates the scope according to the result of a type change, like an assignment or a type cast.
 */
private void updateScopeForTypeChange(FlowScope scope,Node left,JSType leftType,JSType resultType){
  Preconditions.checkNotNull(resultType);
switch (left.getType()) {
case Token.NAME:
    String varName=left.getString();
  Var var=syntacticScope.getVar(varName);
JSType varType=var == null ? null : var.getType();
boolean isVarDeclaration=left.hasChildren() && varType != null && !var.isTypeInferred();
boolean isVarTypeBetter=isVarDeclaration && !resultType.isNullType() && !resultType.isVoidType();
if (isVarTypeBetter) {
redeclareSimpleVar(scope,left,varType);
}
 else {
redeclareSimpleVar(scope,left,resultType);
}
left.setJSType(resultType);
if (var != null && var.isTypeInferred()) {
JSType oldType=var.getType();
var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType));
}
break;
case Token.GETPROP:
String qualifiedName=left.getQualifiedName();
if (qualifiedName != null) {
scope.inferQualifiedSlot(left,qualifiedName,leftType == null ? unknownType : leftType,resultType);
}
left.setJSType(resultType);
ensurePropertyDefined(left,resultType);
break;
}
}",0.8351254480286738
27825,"private void findAliases(NodeTraversal t){
  Scope scope=t.getScope();
  for (  Var v : scope.getVarIterable()) {
    Node n=v.getNode();
    Node parent=n.getParent();
    boolean isVar=parent.isVar();
    boolean isFunctionDecl=NodeUtil.isFunctionDeclaration(parent);
    if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {
      recordAlias(v);
    }
 else     if (v.isBleedingFunction()) {
    }
 else     if (parent.getType() == Token.LP) {
    }
 else     if (isVar || isFunctionDecl) {
      boolean isHoisted=NodeUtil.isHoistedFunctionDeclaration(parent);
      Node grandparent=parent.getParent();
      Node value=v.getInitialValue() != null ? v.getInitialValue() : null;
      Node varNode=null;
      String name=n.getString();
      int nameCount=scopedAliasNames.count(name);
      scopedAliasNames.add(name);
      String globalName=""String_Node_Str"" + name + (nameCount == 0 ? ""String_Node_Str"" : (""String_Node_Str"" + nameCount));
      compiler.ensureLibraryInjected(""String_Node_Str"");
      if (isFunctionDecl) {
        Node existingName=v.getNameNode();
        Node newName=IR.name(""String_Node_Str"").useSourceInfoFrom(existingName);
        value.replaceChild(existingName,newName);
        varNode=IR.var(existingName).useSourceInfoFrom(existingName);
        grandparent.replaceChild(parent,varNode);
      }
 else {
        if (value != null) {
          value.detachFromParent();
        }
        varNode=parent;
      }
      if (value != null || v.getJSDocInfo() != null) {
        Node newDecl=NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(),globalName,value,v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);
        NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(),n,name);
        if (isHoisted) {
          grandparent.addChildToFront(newDecl);
        }
 else {
          grandparent.addChildBefore(newDecl,varNode);
        }
      }
      v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(),globalName,n,name));
      recordAlias(v);
    }
 else {
      report(t,n,GOOG_SCOPE_NON_ALIAS_LOCAL,n.getString());
    }
  }
}","private void findAliases(NodeTraversal t){
  Scope scope=t.getScope();
  for (  Var v : scope.getVarIterable()) {
    Node n=v.getNode();
    Node parent=n.getParent();
    boolean isVar=parent.isVar();
    boolean isFunctionDecl=NodeUtil.isFunctionDeclaration(parent);
    if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {
      recordAlias(v);
    }
 else     if (v.isBleedingFunction()) {
    }
 else     if (parent.getType() == Token.LP) {
    }
 else     if (isVar || isFunctionDecl) {
      boolean isHoisted=NodeUtil.isHoistedFunctionDeclaration(parent);
      Node grandparent=parent.getParent();
      Node value=v.getInitialValue() != null ? v.getInitialValue() : null;
      Node varNode=null;
      String name=n.getString();
      int nameCount=scopedAliasNames.count(name);
      scopedAliasNames.add(name);
      String globalName=""String_Node_Str"" + name + (nameCount == 0 ? ""String_Node_Str"" : (""String_Node_Str"" + nameCount));
      compiler.ensureLibraryInjected(""String_Node_Str"");
      if (isFunctionDecl) {
        Node existingName=v.getNameNode();
        Node newName=IR.name(""String_Node_Str"").useSourceInfoFrom(existingName);
        value.replaceChild(existingName,newName);
        varNode=IR.var(existingName).useSourceInfoFrom(existingName);
        grandparent.replaceChild(parent,varNode);
      }
 else {
        if (value != null) {
          value.detachFromParent();
        }
        varNode=parent;
      }
      if (value != null || v.getJSDocInfo() != null) {
        Node newDecl=NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(),globalName,value,v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);
        NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(),n,name);
        if (isHoisted) {
          grandparent.addChildToFront(newDecl);
        }
 else {
          grandparent.addChildBefore(newDecl,varNode);
        }
        injectedDecls.add(newDecl.getFirstChild());
      }
      v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(),globalName,n,name));
      recordAlias(v);
    }
 else {
      report(t,n,GOOG_SCOPE_NON_ALIAS_LOCAL,n.getString());
    }
  }
}",0.9881925522252498
27826,"@Override public void exitScope(NodeTraversal t){
  if (t.getScopeDepth() > 2) {
    findNamespaceShadows(t);
  }
  if (t.getScopeDepth() == 2) {
    renameNamespaceShadows(t);
    aliases.clear();
    forbiddenLocals.clear();
    transformation=null;
    hasNamespaceShadows=false;
  }
}","@Override public void exitScope(NodeTraversal t){
  if (t.getScopeDepth() > 2) {
    findNamespaceShadows(t);
  }
  if (t.getScopeDepth() == 2) {
    renameNamespaceShadows(t);
    injectedDecls.clear();
    aliases.clear();
    forbiddenLocals.clear();
    transformation=null;
    hasNamespaceShadows=false;
  }
}",0.9552238805970148
27827,"@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (isCallToScopeMethod(n)) {
    validateScopeCall(t,n,n.getParent());
  }
  if (t.getScopeDepth() < 2) {
    return;
  }
  int type=n.getType();
  Var aliasVar=null;
  if (type == Token.NAME) {
    String name=n.getString();
    Var lexicalVar=t.getScope().getVar(n.getString());
    if (lexicalVar != null && lexicalVar == aliases.get(name)) {
      aliasVar=lexicalVar;
    }
  }
  if (t.getScopeDepth() == 2) {
    if (aliasVar != null && NodeUtil.isLValue(n)) {
      if (aliasVar.getNode() == n) {
        aliasDefinitionsInOrder.add(n);
        return;
      }
 else {
        report(t,n,GOOG_SCOPE_ALIAS_REDEFINED,n.getString());
      }
    }
    if (type == Token.RETURN) {
      report(t,n,GOOG_SCOPE_USES_RETURN);
    }
 else     if (type == Token.THIS) {
      report(t,n,GOOG_SCOPE_REFERENCES_THIS);
    }
 else     if (type == Token.THROW) {
      report(t,n,GOOG_SCOPE_USES_THROW);
    }
  }
  if (t.getScopeDepth() >= 2) {
    if (aliasVar != null) {
      aliasUsages.add(new AliasedNode(aliasVar,n));
    }
    JSDocInfo info=n.getJSDocInfo();
    if (info != null) {
      for (      Node node : info.getTypeNodes()) {
        fixTypeNode(node);
      }
    }
  }
}","@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (isCallToScopeMethod(n)) {
    validateScopeCall(t,n,n.getParent());
  }
  if (t.getScopeDepth() < 2) {
    return;
  }
  int type=n.getType();
  Var aliasVar=null;
  if (type == Token.NAME) {
    String name=n.getString();
    Var lexicalVar=t.getScope().getVar(n.getString());
    if (lexicalVar != null && lexicalVar == aliases.get(name)) {
      aliasVar=lexicalVar;
    }
  }
  if (t.getScopeDepth() == 2) {
    if (aliasVar != null && NodeUtil.isLValue(n)) {
      if (aliasVar.getNode() == n) {
        aliasDefinitionsInOrder.add(n);
        return;
      }
 else {
        report(t,n,GOOG_SCOPE_ALIAS_REDEFINED,n.getString());
      }
    }
    if (type == Token.RETURN) {
      report(t,n,GOOG_SCOPE_USES_RETURN);
    }
 else     if (type == Token.THIS) {
      report(t,n,GOOG_SCOPE_REFERENCES_THIS);
    }
 else     if (type == Token.THROW) {
      report(t,n,GOOG_SCOPE_USES_THROW);
    }
  }
  if (t.getScopeDepth() >= 2) {
    if (aliasVar != null) {
      aliasUsages.add(new AliasedNode(aliasVar,n));
    }
    JSDocInfo info=n.getJSDocInfo();
    if (info != null && !injectedDecls.contains(n)) {
      for (      Node node : info.getTypeNodes()) {
        fixTypeNode(node);
      }
    }
  }
}",0.9881703470031544
27828,"public static void main(String[] args){
  int numberOfRuns=1;
  if (args.length >= 1) {
    numberOfRuns=Integer.valueOf(args[0]);
  }
  int maxASTSize=10;
  if (args.length >= 2) {
    maxASTSize=Integer.valueOf(args[1]);
  }
  Driver driver=new Driver();
  for (int i=0; i < numberOfRuns; i++) {
    long seed=System.currentTimeMillis();
    Random random=new Random(seed);
    System.out.println(""String_Node_Str"" + seed);
    Fuzzer fuzzer=new Fuzzer(random);
    Node[] nodes=fuzzer.generateProgram(maxASTSize);
    Node script=driver.getScript(nodes);
    String code=Fuzzer.getPrettyCode(script);
    System.out.println(code.trim());
    Compiler compiler=driver.compile(script);
    Result result=compiler.getResult();
    if (result.success) {
      System.out.println(""String_Node_Str"");
    }
  }
}","public static void main(String[] args){
  int numberOfRuns=1;
  if (args.length >= 1) {
    numberOfRuns=Integer.valueOf(args[0]);
  }
  int maxASTSize=10;
  if (args.length >= 2) {
    maxASTSize=Integer.valueOf(args[1]);
  }
  Driver driver=new Driver();
  for (int i=0; i < numberOfRuns; i++) {
    long seed=System.currentTimeMillis();
    Random random=new Random(seed);
    System.out.println(""String_Node_Str"" + seed);
    Fuzzer fuzzer=new Fuzzer(random);
    Node[] nodes=fuzzer.generateProgram(maxASTSize);
    Node script=Fuzzer.buildScript(nodes);
    String code=Fuzzer.getPrettyCode(script);
    System.out.println(code.trim());
    Compiler compiler=driver.compile(script);
    Result result=compiler.getResult();
    if (result.success) {
      System.out.println(""String_Node_Str"");
    }
  }
}",0.9864197530864196
27829,"Node generateExpression(int budget){
  Preconditions.checkArgument(budget >= 1);
  Map<Expression,Double> pmf=Maps.newHashMap();
  for (  Expression expr : Expression.values()) {
    if (expr.minBudget <= budget) {
      if (expr == Expression.FUNCTION_CALL && symbolTable.getSize() == 0 && budget < 4) {
        continue;
      }
 else {
        pmf.put(expr,expr.weight);
      }
    }
  }
  DiscreteDistribution<Expression> dd=new DiscreteDistribution<Expression>(random,pmf);
  Expression expr=dd.nextItem();
switch (expr) {
case LITERAL:
    return generateLiteral(budget);
case FUNCTION_CALL:
  return generateFunctionCall(budget);
case UNARY_EXPR:
return generateUnaryExpression(budget);
case BINARY_EXPR:
return generateBinaryExpression(budget);
case FUNCTION_EXPR:
return generateFunctionExpression(budget);
case TERNARY_EXPR:
return generateTernaryExpression(budget);
}
return null;
}","Node generateExpression(int budget){
  Preconditions.checkArgument(budget >= 1);
  Map<Expression,Double> pmf=Maps.newHashMap();
  for (  Expression expr : Expression.values()) {
    if (expr.minBudget <= budget) {
      if (expr == Expression.FUNCTION_CALL && symbolTable.getSize() == 0 && budget < 4) {
        continue;
      }
 else       if (expr == Expression.IDENTIFIER && symbolTable.getSize() == 0) {
        continue;
      }
 else {
        pmf.put(expr,expr.weight);
      }
    }
  }
  DiscreteDistribution<Expression> dd=new DiscreteDistribution<Expression>(random,pmf);
  Expression expr=dd.nextItem();
switch (expr) {
case THIS:
    return generateThis(budget);
case IDENTIFIER:
  return generateIdentifier(budget,true);
case LITERAL:
return generateLiteral(budget);
case FUNCTION_CALL:
return generateFunctionCall(budget);
case UNARY_EXPR:
return generateUnaryExpression(budget);
case BINARY_EXPR:
return generateBinaryExpression(budget);
case FUNCTION_EXPR:
return generateFunctionExpression(budget);
case TERNARY_EXPR:
return generateTernaryExpression(budget);
}
return null;
}",0.892462311557789
27830,"private Node generateFunction(int budget,boolean anonymous){
  int remainingBudget;
  Node name;
  if (anonymous) {
    Preconditions.checkArgument(budget >= 3);
    name=Node.newString(Token.NAME,""String_Node_Str"");
    remainingBudget=budget - 3;
  }
 else {
    Preconditions.checkArgument(budget >= 4);
    name=generateIdentifier(1,false);
    remainingBudget=budget - 4;
  }
  functionNesting++;
  symbolTable.addScope();
  Node paramList=new Node(Token.PARAM_LIST);
  Node body=new Node(Token.BLOCK);
  int numComponents=random.nextInt(remainingBudget + 1);
  if (numComponents > 0) {
    int[] componentBudgets=distribute(remainingBudget + 1,numComponents,1);
    componentBudgets[0]--;
    for (int i=0; i < componentBudgets[0]; i++) {
      paramList.addChildToBack(generateIdentifier(1,false));
    }
    for (int i=1; i < numComponents; i++) {
      body.addChildToBack(generateSourceElement(componentBudgets[i]));
    }
    symbolTable.removeScope();
    functionNesting--;
  }
  Node function=new Node(Token.FUNCTION,name,paramList,body);
  return function;
}","private Node generateFunction(int budget,boolean anonymous){
  int remainingBudget;
  Node name;
  if (anonymous) {
    Preconditions.checkArgument(budget >= 3);
    name=Node.newString(Token.NAME,""String_Node_Str"");
    remainingBudget=budget - 3;
  }
 else {
    Preconditions.checkArgument(budget >= 4);
    name=generateIdentifier(1,false);
    remainingBudget=budget - 4;
  }
  functionNesting++;
  symbolTable.addScope();
  Node paramList=new Node(Token.PARAM_LIST);
  Node body=new Node(Token.BLOCK);
  int numComponents=random.nextInt(remainingBudget + 1);
  if (numComponents > 0) {
    int[] componentBudgets=distribute(remainingBudget + 1,numComponents,1);
    componentBudgets[0]--;
    for (int i=0; i < componentBudgets[0]; i++) {
      paramList.addChildToBack(generateIdentifier(1,false));
    }
    for (int i=1; i < numComponents; i++) {
      body.addChildToBack(generateSourceElement(componentBudgets[i]));
    }
  }
  symbolTable.removeScope();
  functionNesting--;
  Node function=new Node(Token.FUNCTION,name,paramList,body);
  return function;
}",0.996265172735761
27831,"Node[] generateProgram(int budget){
  int numElements=random.nextInt(budget) + 1;
  if (numElements > 0) {
    int[] elemBudgets=distribute(budget,numElements,1);
    Node[] elements=new Node[numElements];
    for (int i=0; i < numElements; i++) {
      elements[i]=generateSourceElement(elemBudgets[i]);
    }
    return elements;
  }
 else {
    return new Node[]{generateEmptyStatement(budget)};
  }
}","Node[] generateProgram(int budget){
  int numElements=random.nextInt(budget) / 5 + 1;
  if (numElements > 0) {
    int[] elemBudgets=distribute(budget,numElements,1);
    Node[] elements=new Node[numElements];
    for (int i=0; i < numElements; i++) {
      elements[i]=generateSourceElement(elemBudgets[i]);
    }
    return elements;
  }
 else {
    return new Node[]{generateEmptyStatement(budget)};
  }
}",0.9950738916256158
27832,"public void testExpression(){
  Random random=new Random();
  Fuzzer fuzzer=spy(new Fuzzer(random));
  int budget=1;
  fuzzer.generateExpression(budget);
  verify(fuzzer).generateLiteral(budget);
  verify(fuzzer,never()).generateFunctionCall(budget);
  verify(fuzzer,never()).generateUnaryExpression(budget);
  budget=2;
  fuzzer.generateExpression(budget);
  verify(fuzzer,never()).generateBinaryExpression(budget);
  verify(fuzzer,never()).generateFunctionExpression(budget);
  budget=3;
  verify(fuzzer,never()).generateTernaryExpression(budget);
}","public void testExpression(){
  Random random=new Random();
  Fuzzer fuzzer=spy(new Fuzzer(random));
  int budget=1;
  fuzzer.generateExpression(budget);
  verify(fuzzer,never()).generateIdentifier(budget,true);
  verify(fuzzer,never()).generateFunctionCall(budget);
  verify(fuzzer,never()).generateUnaryExpression(budget);
  budget=2;
  fuzzer.generateExpression(budget);
  verify(fuzzer,never()).generateBinaryExpression(budget);
  verify(fuzzer,never()).generateFunctionExpression(budget);
  budget=3;
  verify(fuzzer,never()).generateTernaryExpression(budget);
}",0.9427549194991056
27833,"/** 
 * FunctionType := 'function' FunctionSignatureType FunctionSignatureType := TypeParameters '(' 'this' ':' TypeName, ParametersType ')' ResultType
 */
private Node parseFunctionType(JsDocToken token){
  if (token != JsDocToken.LP) {
    restoreLookAhead(token);
    return reportTypeSyntaxWarning(""String_Node_Str"");
  }
  Node functionType=newNode(Token.FUNCTION);
  Node parameters=null;
  skipEOLs();
  if (!match(JsDocToken.RP)) {
    token=next();
    boolean hasParams=true;
    if (token == JsDocToken.STRING) {
      String tokenStr=stream.getString();
      boolean isThis=""String_Node_Str"".equals(tokenStr);
      boolean isNew=""String_Node_Str"".equals(tokenStr);
      if (isThis || isNew) {
        if (match(JsDocToken.COLON)) {
          next();
          skipEOLs();
          Node contextType=wrapNode(isThis ? Token.THIS : Token.NEW,parseTypeName(next()));
          if (contextType == null) {
            return null;
          }
          functionType.addChildToFront(contextType);
        }
 else {
          return reportTypeSyntaxWarning(""String_Node_Str"");
        }
        if (match(JsDocToken.COMMA)) {
          next();
          skipEOLs();
          token=next();
        }
 else {
          hasParams=false;
        }
      }
    }
    if (hasParams) {
      parameters=parseParametersType(token);
      if (parameters == null) {
        return null;
      }
    }
  }
  if (parameters != null) {
    functionType.addChildToBack(parameters);
  }
  skipEOLs();
  if (!match(JsDocToken.RP)) {
    return reportTypeSyntaxWarning(""String_Node_Str"");
  }
  skipEOLs();
  Node resultType=parseResultType(next());
  if (resultType == null) {
    return null;
  }
 else {
    functionType.addChildToBack(resultType);
  }
  return functionType;
}","/** 
 * FunctionType := 'function' FunctionSignatureType FunctionSignatureType := TypeParameters '(' 'this' ':' TypeName, ParametersType ')' ResultType
 */
private Node parseFunctionType(JsDocToken token){
  if (token != JsDocToken.LP) {
    restoreLookAhead(token);
    return reportTypeSyntaxWarning(""String_Node_Str"");
  }
  Node functionType=newNode(Token.FUNCTION);
  Node parameters=null;
  skipEOLs();
  if (!match(JsDocToken.RP)) {
    token=next();
    boolean hasParams=true;
    if (token == JsDocToken.STRING) {
      String tokenStr=stream.getString();
      boolean isThis=""String_Node_Str"".equals(tokenStr);
      boolean isNew=""String_Node_Str"".equals(tokenStr);
      if (isThis || isNew) {
        if (match(JsDocToken.COLON)) {
          next();
          skipEOLs();
          Node contextType=wrapNode(isThis ? Token.THIS : Token.NEW,parseContextTypeExpression(next()));
          if (contextType == null) {
            return null;
          }
          functionType.addChildToFront(contextType);
        }
 else {
          return reportTypeSyntaxWarning(""String_Node_Str"");
        }
        if (match(JsDocToken.COMMA)) {
          next();
          skipEOLs();
          token=next();
        }
 else {
          hasParams=false;
        }
      }
    }
    if (hasParams) {
      parameters=parseParametersType(token);
      if (parameters == null) {
        return null;
      }
    }
  }
  if (parameters != null) {
    functionType.addChildToBack(parameters);
  }
  skipEOLs();
  if (!match(JsDocToken.RP)) {
    return reportTypeSyntaxWarning(""String_Node_Str"");
  }
  skipEOLs();
  Node resultType=parseResultType(next());
  if (resultType == null) {
    return null;
  }
 else {
    functionType.addChildToBack(resultType);
  }
  return functionType;
}",0.9918470621310091
27834,"/** 
 * Create a diagnostic group that matches only the given type. 
 */
public static DiagnosticGroup forType(DiagnosticType type){
  if (!singletons.containsKey(type)) {
    singletons.put(type,new DiagnosticGroup(type));
  }
  return singletons.get(type);
}","/** 
 * Create a diagnostic group that matches only the given type. 
 */
public static synchronized DiagnosticGroup forType(DiagnosticType type){
  if (!singletons.containsKey(type)) {
    singletons.put(type,new DiagnosticGroup(type));
  }
  return singletons.get(type);
}",0.975609756097561
27835,"/** 
 * Remove useless switches and cases.
 */
private Node tryOptimizeSwitch(Node n){
  Preconditions.checkState(n.isSwitch());
  Node defaultCase=tryOptimizeDefaultCase(n);
  if (defaultCase == null) {
    Node cond=n.getFirstChild(), prev=null, next=null, cur;
    for (cur=cond.getNext(); cur != null; cur=next) {
      next=cur.getNext();
      if (!mayHaveSideEffects(cur.getFirstChild()) && isUselessCase(cur,prev)) {
        removeCase(n,cur);
      }
 else {
        prev=cur;
      }
    }
    if (NodeUtil.isLiteralValue(cond,false)) {
      Node caseLabel;
      TernaryValue caseMatches=TernaryValue.TRUE;
      for (cur=cond.getNext(); cur != null; cur=next) {
        next=cur.getNext();
        caseLabel=cur.getFirstChild();
        caseMatches=PeepholeFoldConstants.evaluateComparison(Token.SHEQ,cond,caseLabel);
        if (caseMatches == TernaryValue.TRUE) {
          break;
        }
 else         if (caseMatches == TernaryValue.UNKNOWN) {
          break;
        }
 else {
          removeCase(n,cur);
        }
      }
      if (caseMatches != TernaryValue.UNKNOWN) {
        Node block, lastStm;
        while (cur != null) {
          block=cur.getLastChild();
          lastStm=block.getLastChild();
          cur=cur.getNext();
          if (lastStm != null && lastStm.isBreak()) {
            block.removeChild(lastStm);
            reportCodeChange();
            break;
          }
        }
        for (; cur != null; cur=next) {
          next=cur.getNext();
          removeCase(n,cur);
        }
        cur=cond.getNext();
        if (cur != null && cur.getNext() == null) {
          block=cur.getLastChild();
          if (!(NodeUtil.containsType(block,Token.BREAK,NodeUtil.MATCH_NOT_FUNCTION))) {
            cur.removeChild(block);
            n.getParent().replaceChild(n,block);
            reportCodeChange();
            return block;
          }
        }
      }
    }
  }
  if (n.hasOneChild()) {
    Node condition=n.removeFirstChild();
    Node replacement=IR.exprResult(condition).srcref(n);
    n.getParent().replaceChild(n,replacement);
    reportCodeChange();
    return replacement;
  }
  return null;
}","/** 
 * Remove useless switches and cases.
 */
private Node tryOptimizeSwitch(Node n){
  Preconditions.checkState(n.isSwitch());
  Node defaultCase=tryOptimizeDefaultCase(n);
  if (defaultCase == null) {
    Node cond=n.getFirstChild(), prev=null, next=null, cur;
    for (cur=cond.getNext(); cur != null; cur=next) {
      next=cur.getNext();
      if (!mayHaveSideEffects(cur.getFirstChild()) && isUselessCase(cur,prev)) {
        removeCase(n,cur);
      }
 else {
        prev=cur;
      }
    }
    if (NodeUtil.isLiteralValue(cond,false)) {
      Node caseLabel;
      TernaryValue caseMatches=TernaryValue.TRUE;
      for (cur=cond.getNext(); cur != null; cur=next) {
        next=cur.getNext();
        caseLabel=cur.getFirstChild();
        caseMatches=PeepholeFoldConstants.evaluateComparison(Token.SHEQ,cond,caseLabel);
        if (caseMatches == TernaryValue.TRUE) {
          break;
        }
 else         if (caseMatches == TernaryValue.UNKNOWN) {
          break;
        }
 else {
          removeCase(n,cur);
        }
      }
      if (caseMatches != TernaryValue.UNKNOWN) {
        Node block, lastStm;
        while (cur != null) {
          block=cur.getLastChild();
          lastStm=block.getLastChild();
          cur=cur.getNext();
          if (lastStm != null && lastStm.isBreak() && !lastStm.hasChildren()) {
            block.removeChild(lastStm);
            reportCodeChange();
            break;
          }
        }
        for (; cur != null; cur=next) {
          next=cur.getNext();
          removeCase(n,cur);
        }
        cur=cond.getNext();
        if (cur != null && cur.getNext() == null) {
          block=cur.getLastChild();
          if (!(NodeUtil.has(block,MATCH_UNNAMED_BREAK,NodeUtil.MATCH_NOT_FUNCTION))) {
            cur.removeChild(block);
            block.setIsSyntheticBlock(false);
            n.getParent().replaceChild(n,block);
            reportCodeChange();
            return block;
          }
        }
      }
    }
  }
  if (n.hasOneChild()) {
    Node condition=n.removeFirstChild();
    Node replacement=IR.exprResult(condition).srcref(n);
    n.getParent().replaceChild(n,replacement);
    reportCodeChange();
    return replacement;
  }
  return null;
}",0.8426326577089501
27836,"public void testGoogIsArray2() throws Exception {
  testClosureFunction(""String_Node_Str"",ALL_TYPE,ALL_TYPE,ALL_TYPE);
}","public void testGoogIsArray2() throws Exception {
  testClosureFunction(""String_Node_Str"",ALL_TYPE,ARRAY_TYPE,ALL_TYPE);
}",0.975206611570248
27837,"private int position2charno(int position){
  int lineIndex=sourceString.lastIndexOf('\n',position);
  if (lineIndex == -1) {
    return position;
  }
 else {
    return position - lineIndex - 1;
  }
}","private int position2charno(int position){
  int newlineIndex=Collections.binarySearch(newlines,position);
  int lineIndex=-1;
  if (newlineIndex >= 0) {
    lineIndex=newlines.get(newlineIndex);
  }
 else   if (newlineIndex <= -2) {
    lineIndex=newlines.get(-newlineIndex - 2);
  }
  if (lineIndex == -1) {
    return position;
  }
 else {
    return position - lineIndex - 1;
  }
}",0.1777777777777777
27838,"private IRFactory(String sourceString,StaticSourceFile sourceFile,Config config,ErrorReporter errorReporter){
  this.sourceString=sourceString;
  this.sourceFile=sourceFile;
  this.sourceName=sourceFile == null ? null : sourceFile.getName();
  this.config=config;
  this.errorReporter=errorReporter;
  this.transformDispatcher=new TransformDispatcher();
  this.templateNode=createTemplateNode();
switch (config.languageMode) {
case ECMASCRIPT3:
    reservedKeywords=null;
  break;
case ECMASCRIPT5:
reservedKeywords=ES5_RESERVED_KEYWORDS;
break;
case ECMASCRIPT5_STRICT:
reservedKeywords=ES5_STRICT_RESERVED_KEYWORDS;
break;
default :
throw new IllegalStateException(""String_Node_Str"");
}
}","private IRFactory(String sourceString,StaticSourceFile sourceFile,Config config,ErrorReporter errorReporter){
  this.sourceString=sourceString;
  this.newlines=Lists.newArrayList();
  this.sourceFile=sourceFile;
  for (int charNo=0; true; charNo++) {
    charNo=sourceString.indexOf('\n',charNo);
    if (charNo == -1)     break;
    newlines.add(Integer.valueOf(charNo));
  }
  this.sourceName=sourceFile == null ? null : sourceFile.getName();
  this.config=config;
  this.errorReporter=errorReporter;
  this.transformDispatcher=new TransformDispatcher();
  this.templateNode=createTemplateNode();
switch (config.languageMode) {
case ECMASCRIPT3:
    reservedKeywords=null;
  break;
case ECMASCRIPT5:
reservedKeywords=ES5_RESERVED_KEYWORDS;
break;
case ECMASCRIPT5_STRICT:
reservedKeywords=ES5_STRICT_RESERVED_KEYWORDS;
break;
default :
throw new IllegalStateException(""String_Node_Str"");
}
}",0.8717624763108023
27839,"private void findAliases(NodeTraversal t){
  Scope scope=t.getScope();
  for (  Var v : scope.getVarIterable()) {
    Node n=v.getNode();
    Node parent=n.getParent();
    boolean isVar=parent.isVar();
    if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {
      recordAlias(v);
    }
 else     if (v.isBleedingFunction()) {
    }
 else     if (parent.getType() == Token.LP) {
    }
 else     if (isVar) {
      Node value=n.hasChildren() ? v.getInitialValue().detachFromParent() : null;
      String name=n.getString();
      int nameCount=scopedAliasNames.count(name);
      scopedAliasNames.add(name);
      String globalName=""String_Node_Str"" + name + (nameCount == 0 ? ""String_Node_Str"" : (""String_Node_Str"" + nameCount));
      compiler.ensureLibraryInjected(""String_Node_Str"");
      if (value != null || v.getJSDocInfo() != null) {
        Node newDecl=NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(),globalName,value,v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);
        NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(),n,name);
        parent.getParent().addChildBefore(newDecl,parent);
      }
      v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(),globalName,n,name));
      recordAlias(v);
    }
 else {
      report(t,n,GOOG_SCOPE_NON_ALIAS_LOCAL,n.getString());
    }
  }
}","private void findAliases(NodeTraversal t){
  Scope scope=t.getScope();
  for (  Var v : scope.getVarIterable()) {
    Node n=v.getNode();
    Node parent=n.getParent();
    boolean isVar=parent.isVar();
    boolean isFunctionDecl=NodeUtil.isFunctionDeclaration(parent);
    if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {
      recordAlias(v);
    }
 else     if (v.isBleedingFunction()) {
    }
 else     if (parent.getType() == Token.LP) {
    }
 else     if (isVar || isFunctionDecl) {
      boolean isHoisted=NodeUtil.isHoistedFunctionDeclaration(parent);
      Node grandparent=parent.getParent();
      Node value=v.getInitialValue() != null ? v.getInitialValue() : null;
      Node varNode=null;
      String name=n.getString();
      int nameCount=scopedAliasNames.count(name);
      scopedAliasNames.add(name);
      String globalName=""String_Node_Str"" + name + (nameCount == 0 ? ""String_Node_Str"" : (""String_Node_Str"" + nameCount));
      compiler.ensureLibraryInjected(""String_Node_Str"");
      if (isFunctionDecl) {
        Node existingName=v.getNameNode();
        Node newName=IR.name(""String_Node_Str"").useSourceInfoFrom(existingName);
        value.replaceChild(existingName,newName);
        varNode=IR.var(existingName).useSourceInfoFrom(existingName);
        grandparent.replaceChild(parent,varNode);
      }
 else {
        if (value != null) {
          value.detachFromParent();
        }
        varNode=parent;
      }
      if (value != null || v.getJSDocInfo() != null) {
        Node newDecl=NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(),globalName,value,v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);
        NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(),n,name);
        if (isHoisted) {
          grandparent.addChildToFront(newDecl);
        }
 else {
          grandparent.addChildBefore(newDecl,varNode);
        }
      }
      v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(),globalName,n,name));
      recordAlias(v);
    }
 else {
      report(t,n,GOOG_SCOPE_NON_ALIAS_LOCAL,n.getString());
    }
  }
}",0.5777901475090453
27840,"public Node getChildBefore(Node child){
  if (child == first) {
    return null;
  }
  Node n=first;
  while (n.next != child) {
    n=n.next;
    if (n == null) {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
  return n;
}","public Node getChildBefore(Node child){
  if (child == first) {
    return null;
  }
  Node n=first;
  if (n == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  while (n.next != child) {
    n=n.next;
    if (n == null) {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
  return n;
}",0.5631768953068592
27841,"final int getToken() throws IOException {
  int c;
  retry:   for (; ; ) {
    for (; ; ) {
      c=getChar();
      if (c == EOF_CHAR) {
        tokenBeg=cursor - 1;
        tokenEnd=cursor;
        return Token.EOF;
      }
 else       if (c == '\n') {
        dirtyLine=false;
        tokenBeg=cursor - 1;
        tokenEnd=cursor;
        return Token.EOL;
      }
 else       if (!isJSSpace(c)) {
        if (c != '-') {
          dirtyLine=true;
        }
        break;
      }
    }
    tokenBeg=cursor - 1;
    tokenEnd=cursor;
    if (c == '@')     return Token.XMLATTR;
    boolean identifierStart;
    boolean isUnicodeEscapeStart=false;
    if (c == '\\') {
      c=getChar();
      if (c == 'u') {
        identifierStart=true;
        isUnicodeEscapeStart=true;
        stringBufferTop=0;
      }
 else {
        identifierStart=false;
        ungetChar(c);
        c='\\';
      }
    }
 else {
      identifierStart=Character.isJavaIdentifierStart((char)c);
      if (identifierStart) {
        stringBufferTop=0;
        addToString(c);
      }
    }
    if (identifierStart) {
      boolean containsEscape=isUnicodeEscapeStart;
      for (; ; ) {
        if (isUnicodeEscapeStart) {
          int escapeVal=0;
          for (int i=0; i != 4; ++i) {
            c=getChar();
            escapeVal=Kit.xDigitToInt(c,escapeVal);
            if (escapeVal < 0) {
              break;
            }
          }
          if (escapeVal < 0) {
            parser.addError(""String_Node_Str"");
            return Token.ERROR;
          }
          addToString(escapeVal);
          isUnicodeEscapeStart=false;
        }
 else {
          c=getChar();
          if (c == '\\') {
            c=getChar();
            if (c == 'u') {
              isUnicodeEscapeStart=true;
              containsEscape=true;
            }
 else {
              parser.addError(""String_Node_Str"");
              return Token.ERROR;
            }
          }
 else {
            if (c == EOF_CHAR || c == BYTE_ORDER_MARK || !Character.isJavaIdentifierPart((char)c)) {
              break;
            }
            addToString(c);
          }
        }
      }
      ungetChar(c);
      String str=getStringFromBuffer();
      if (!containsEscape) {
        int result=stringToKeyword(str);
        if (result != Token.EOF) {
          if ((result == Token.LET || result == Token.YIELD) && parser.compilerEnv.getLanguageVersion() < Context.VERSION_1_7) {
            string=result == Token.LET ? ""String_Node_Str"" : ""String_Node_Str"";
            result=Token.NAME;
          }
          this.string=(String)allStrings.intern(str);
          if (result != Token.RESERVED) {
            return result;
          }
 else           if (!parser.compilerEnv.isReservedKeywordAsIdentifier()) {
            return result;
          }
        }
      }
 else       if (isKeyword(str)) {
        str=convertLastCharToHex(str);
      }
      this.string=(String)allStrings.intern(str);
      return Token.NAME;
    }
    if (isDigit(c) || (c == '.' && isDigit(peekChar()))) {
      isOctal=false;
      stringBufferTop=0;
      int base=10;
      if (c == '0') {
        c=getChar();
        if (c == 'x' || c == 'X') {
          base=16;
          c=getChar();
        }
 else         if (isDigit(c)) {
          base=8;
          isOctal=true;
        }
 else {
          addToString('0');
        }
      }
      if (base == 16) {
        while (0 <= Kit.xDigitToInt(c,0)) {
          addToString(c);
          c=getChar();
        }
      }
 else {
        while ('0' <= c && c <= '9') {
          if (base == 8 && c >= '8') {
            parser.addWarning(""String_Node_Str"",c == '8' ? ""String_Node_Str"" : ""String_Node_Str"");
            base=10;
          }
          addToString(c);
          c=getChar();
        }
      }
      boolean isInteger=true;
      if (base == 10 && (c == '.' || c == 'e' || c == 'E')) {
        isInteger=false;
        if (c == '.') {
          do {
            addToString(c);
            c=getChar();
          }
 while (isDigit(c));
        }
        if (c == 'e' || c == 'E') {
          addToString(c);
          c=getChar();
          if (c == '+' || c == '-') {
            addToString(c);
            c=getChar();
          }
          if (!isDigit(c)) {
            parser.addError(""String_Node_Str"");
            return Token.ERROR;
          }
          do {
            addToString(c);
            c=getChar();
          }
 while (isDigit(c));
        }
      }
      ungetChar(c);
      String numString=getStringFromBuffer();
      this.string=numString;
      double dval;
      if (base == 10 && !isInteger) {
        try {
          dval=Double.parseDouble(numString);
        }
 catch (        NumberFormatException ex) {
          parser.addError(""String_Node_Str"");
          return Token.ERROR;
        }
      }
 else {
        dval=ScriptRuntime.stringToNumber(numString,0,base);
      }
      this.number=dval;
      return Token.NUMBER;
    }
    if (c == '""' || c == '\'') {
      quoteChar=c;
      stringBufferTop=0;
      c=getChar(false);
      strLoop:       while (c != quoteChar) {
        if (c == '\n' || c == EOF_CHAR) {
          ungetChar(c);
          tokenEnd=cursor;
          parser.addError(""String_Node_Str"");
          return Token.ERROR;
        }
        if (c == '\\') {
          int escapeVal;
          c=getChar();
switch (c) {
case 'b':
            c='\b';
          break;
case 'f':
        c='\f';
      break;
case 'n':
    c='\n';
  break;
case 'r':
c='\r';
break;
case 't':
c='\t';
break;
case 'v':
c=0xb;
break;
case 'u':
int escapeStart=stringBufferTop;
addToString('u');
escapeVal=0;
for (int i=0; i != 4; ++i) {
c=getChar();
escapeVal=Kit.xDigitToInt(c,escapeVal);
if (escapeVal < 0) {
continue strLoop;
}
addToString(c);
}
stringBufferTop=escapeStart;
c=escapeVal;
break;
case 'x':
c=getChar();
escapeVal=Kit.xDigitToInt(c,0);
if (escapeVal < 0) {
addToString('x');
continue strLoop;
}
 else {
int c1=c;
c=getChar();
escapeVal=Kit.xDigitToInt(c,escapeVal);
if (escapeVal < 0) {
addToString('x');
addToString(c1);
continue strLoop;
}
 else {
c=escapeVal;
}
}
break;
case '\n':
c=getChar();
continue strLoop;
default :
if ('0' <= c && c < '8') {
int val=c - '0';
c=getChar();
if ('0' <= c && c < '8') {
val=8 * val + c - '0';
c=getChar();
if ('0' <= c && c < '8' && val <= 037) {
val=8 * val + c - '0';
c=getChar();
}
}
ungetChar(c);
c=val;
}
}
}
addToString(c);
c=getChar(false);
}
String str=getStringFromBuffer();
this.string=(String)allStrings.intern(str);
return Token.STRING;
}
switch (c) {
case ';':
return Token.SEMI;
case '[':
return Token.LB;
case ']':
return Token.RB;
case '{':
return Token.LC;
case '}':
return Token.RC;
case '(':
return Token.LP;
case ')':
return Token.RP;
case ',':
return Token.COMMA;
case '?':
return Token.HOOK;
case ':':
if (matchChar(':')) {
return Token.COLONCOLON;
}
 else {
return Token.COLON;
}
case '.':
if (matchChar('.')) {
return Token.DOTDOT;
}
 else if (matchChar('(')) {
return Token.DOTQUERY;
}
 else {
return Token.DOT;
}
case '|':
if (matchChar('|')) {
return Token.OR;
}
 else if (matchChar('=')) {
return Token.ASSIGN_BITOR;
}
 else {
return Token.BITOR;
}
case '^':
if (matchChar('=')) {
return Token.ASSIGN_BITXOR;
}
 else {
return Token.BITXOR;
}
case '&':
if (matchChar('&')) {
return Token.AND;
}
 else if (matchChar('=')) {
return Token.ASSIGN_BITAND;
}
 else {
return Token.BITAND;
}
case '=':
if (matchChar('=')) {
if (matchChar('=')) {
return Token.SHEQ;
}
 else {
return Token.EQ;
}
}
 else {
return Token.ASSIGN;
}
case '!':
if (matchChar('=')) {
if (matchChar('=')) {
return Token.SHNE;
}
 else {
return Token.NE;
}
}
 else {
return Token.NOT;
}
case '<':
if (matchChar('!')) {
if (matchChar('-')) {
if (matchChar('-')) {
tokenBeg=cursor - 4;
skipLine();
commentType=Token.CommentType.HTML;
return Token.COMMENT;
}
ungetCharIgnoreLineEnd('-');
}
ungetCharIgnoreLineEnd('!');
}
if (matchChar('<')) {
if (matchChar('=')) {
return Token.ASSIGN_LSH;
}
 else {
return Token.LSH;
}
}
 else {
if (matchChar('=')) {
return Token.LE;
}
 else {
return Token.LT;
}
}
case '>':
if (matchChar('>')) {
if (matchChar('>')) {
if (matchChar('=')) {
return Token.ASSIGN_URSH;
}
 else {
return Token.URSH;
}
}
 else {
if (matchChar('=')) {
return Token.ASSIGN_RSH;
}
 else {
return Token.RSH;
}
}
}
 else {
if (matchChar('=')) {
return Token.GE;
}
 else {
return Token.GT;
}
}
case '*':
if (matchChar('=')) {
return Token.ASSIGN_MUL;
}
 else {
return Token.MUL;
}
case '/':
markCommentStart();
if (matchChar('/')) {
tokenBeg=cursor - 2;
skipLine();
commentType=Token.CommentType.LINE;
return Token.COMMENT;
}
if (matchChar('*')) {
boolean lookForSlash=false;
tokenBeg=cursor - 2;
if (matchChar('*')) {
lookForSlash=true;
commentType=Token.CommentType.JSDOC;
}
 else {
commentType=Token.CommentType.BLOCK_COMMENT;
}
for (; ; ) {
c=getChar();
if (c == EOF_CHAR) {
tokenEnd=cursor - 1;
parser.addError(""String_Node_Str"");
return Token.COMMENT;
}
 else if (c == '*') {
lookForSlash=true;
}
 else if (c == '/') {
if (lookForSlash) {
tokenEnd=cursor;
return Token.COMMENT;
}
}
 else {
lookForSlash=false;
tokenEnd=cursor;
}
}
}
if (matchChar('=')) {
return Token.ASSIGN_DIV;
}
 else {
return Token.DIV;
}
case '%':
if (matchChar('=')) {
return Token.ASSIGN_MOD;
}
 else {
return Token.MOD;
}
case '~':
return Token.BITNOT;
case '+':
if (matchChar('=')) {
return Token.ASSIGN_ADD;
}
 else if (matchChar('+')) {
return Token.INC;
}
 else {
return Token.ADD;
}
case '-':
if (matchChar('=')) {
c=Token.ASSIGN_SUB;
}
 else if (matchChar('-')) {
if (!dirtyLine) {
if (matchChar('>')) {
markCommentStart(""String_Node_Str"");
skipLine();
commentType=Token.CommentType.HTML;
return Token.COMMENT;
}
}
c=Token.DEC;
}
 else {
c=Token.SUB;
}
dirtyLine=true;
return c;
default :
parser.addError(""String_Node_Str"");
return Token.ERROR;
}
}
}","final int getToken() throws IOException {
  int c;
  retry:   for (; ; ) {
    for (; ; ) {
      c=getChar();
      if (c == EOF_CHAR) {
        tokenBeg=cursor - 1;
        tokenEnd=cursor;
        return Token.EOF;
      }
 else       if (c == '\n') {
        dirtyLine=false;
        tokenBeg=cursor - 1;
        tokenEnd=cursor;
        return Token.EOL;
      }
 else       if (!isJSSpace(c)) {
        if (c != '-') {
          dirtyLine=true;
        }
        break;
      }
    }
    tokenBeg=cursor - 1;
    tokenEnd=cursor;
    if (c == '@')     return Token.XMLATTR;
    boolean identifierStart;
    boolean isUnicodeEscapeStart=false;
    if (c == '\\') {
      c=getChar();
      if (c == 'u') {
        identifierStart=true;
        isUnicodeEscapeStart=true;
        stringBufferTop=0;
      }
 else {
        identifierStart=false;
        ungetChar(c);
        c='\\';
      }
    }
 else {
      identifierStart=Character.isJavaIdentifierStart((char)c);
      if (identifierStart) {
        stringBufferTop=0;
        addToString(c);
      }
    }
    if (identifierStart) {
      boolean containsEscape=isUnicodeEscapeStart;
      for (; ; ) {
        if (isUnicodeEscapeStart) {
          int escapeVal=0;
          for (int i=0; i != 4; ++i) {
            c=getChar();
            escapeVal=Kit.xDigitToInt(c,escapeVal);
            if (escapeVal < 0) {
              break;
            }
          }
          if (escapeVal < 0) {
            parser.addError(""String_Node_Str"");
            return Token.ERROR;
          }
          addToString(escapeVal);
          isUnicodeEscapeStart=false;
        }
 else {
          c=getChar();
          if (c == '\\') {
            c=getChar();
            if (c == 'u') {
              isUnicodeEscapeStart=true;
              containsEscape=true;
            }
 else {
              parser.addError(""String_Node_Str"");
              return Token.ERROR;
            }
          }
 else {
            if (c == EOF_CHAR || c == BYTE_ORDER_MARK || !Character.isJavaIdentifierPart((char)c)) {
              break;
            }
            addToString(c);
          }
        }
      }
      ungetChar(c);
      String str=getStringFromBuffer();
      if (!containsEscape) {
        int result=stringToKeyword(str);
        if (result != Token.EOF) {
          if ((result == Token.LET || result == Token.YIELD) && parser.compilerEnv.getLanguageVersion() < Context.VERSION_1_7) {
            string=result == Token.LET ? ""String_Node_Str"" : ""String_Node_Str"";
            result=Token.NAME;
          }
          this.string=(String)allStrings.intern(str);
          if (result != Token.RESERVED) {
            return result;
          }
 else           if (!parser.compilerEnv.isReservedKeywordAsIdentifier()) {
            return result;
          }
        }
      }
 else       if (isKeyword(str)) {
        str=convertLastCharToHex(str);
      }
      this.string=(String)allStrings.intern(str);
      return Token.NAME;
    }
    if (isDigit(c) || (c == '.' && isDigit(peekChar()))) {
      isOctal=false;
      stringBufferTop=0;
      int base=10;
      if (c == '0') {
        c=getChar();
        if (c == 'x' || c == 'X') {
          base=16;
          c=getChar();
        }
 else         if (isDigit(c)) {
          base=8;
          isOctal=true;
        }
 else {
          addToString('0');
        }
      }
      if (base == 16) {
        while (0 <= Kit.xDigitToInt(c,0)) {
          addToString(c);
          c=getChar();
        }
      }
 else {
        while ('0' <= c && c <= '9') {
          if (base == 8 && c >= '8') {
            parser.addWarning(""String_Node_Str"",c == '8' ? ""String_Node_Str"" : ""String_Node_Str"");
            base=10;
          }
          addToString(c);
          c=getChar();
        }
      }
      boolean isInteger=true;
      if (base == 10 && (c == '.' || c == 'e' || c == 'E')) {
        isInteger=false;
        if (c == '.') {
          do {
            addToString(c);
            c=getChar();
          }
 while (isDigit(c));
        }
        if (c == 'e' || c == 'E') {
          addToString(c);
          c=getChar();
          if (c == '+' || c == '-') {
            addToString(c);
            c=getChar();
          }
          if (!isDigit(c)) {
            parser.addError(""String_Node_Str"");
            return Token.ERROR;
          }
          do {
            addToString(c);
            c=getChar();
          }
 while (isDigit(c));
        }
      }
      ungetChar(c);
      String numString=getStringFromBuffer();
      this.string=numString;
      double dval;
      if (base == 10 && !isInteger) {
        try {
          dval=Double.parseDouble(numString);
        }
 catch (        NumberFormatException ex) {
          parser.addError(""String_Node_Str"");
          return Token.ERROR;
        }
      }
 else {
        dval=ScriptRuntime.stringToNumber(numString,0,base);
      }
      this.number=dval;
      return Token.NUMBER;
    }
    if (c == '""' || c == '\'') {
      quoteChar=c;
      stringBufferTop=0;
      c=getChar(false);
      strLoop:       while (c != quoteChar) {
        if (c == '\n' || c == EOF_CHAR) {
          ungetChar(c);
          tokenEnd=cursor;
          parser.addError(""String_Node_Str"");
          return Token.ERROR;
        }
        if (c == '\\') {
          int escapeVal;
          c=getChar();
switch (c) {
case 'b':
            c='\b';
          break;
case 'f':
        c='\f';
      break;
case 'n':
    c='\n';
  break;
case 'r':
c='\r';
break;
case 't':
c='\t';
break;
case 'v':
c=0xb;
break;
case 'u':
int escapeStart=stringBufferTop;
addToString('u');
escapeVal=0;
for (int i=0; i != 4; ++i) {
c=getChar();
escapeVal=Kit.xDigitToInt(c,escapeVal);
if (escapeVal < 0) {
continue strLoop;
}
addToString(c);
}
stringBufferTop=escapeStart;
c=escapeVal;
break;
case 'x':
c=getChar();
escapeVal=Kit.xDigitToInt(c,0);
if (escapeVal < 0) {
addToString('x');
continue strLoop;
}
 else {
int c1=c;
c=getChar();
escapeVal=Kit.xDigitToInt(c,escapeVal);
if (escapeVal < 0) {
addToString('x');
addToString(c1);
continue strLoop;
}
 else {
c=escapeVal;
}
}
break;
case '\n':
c=getChar();
continue strLoop;
default :
if ('0' <= c && c < '8') {
int val=c - '0';
c=getChar();
if ('0' <= c && c < '8') {
val=8 * val + c - '0';
c=getChar();
if ('0' <= c && c < '8' && val <= 037) {
val=8 * val + c - '0';
c=getChar();
}
}
ungetChar(c);
c=val;
}
}
}
addToString(c);
c=getChar(false);
}
String str=getStringFromBuffer();
this.string=(String)allStrings.intern(str);
return Token.STRING;
}
switch (c) {
case ';':
return Token.SEMI;
case '[':
return Token.LB;
case ']':
return Token.RB;
case '{':
return Token.LC;
case '}':
return Token.RC;
case '(':
return Token.LP;
case ')':
return Token.RP;
case ',':
return Token.COMMA;
case '?':
return Token.HOOK;
case ':':
if (matchChar(':')) {
return Token.COLONCOLON;
}
 else {
return Token.COLON;
}
case '.':
if (matchChar('.')) {
return Token.DOTDOT;
}
 else if (matchChar('(')) {
return Token.DOTQUERY;
}
 else {
return Token.DOT;
}
case '|':
if (matchChar('|')) {
return Token.OR;
}
 else if (matchChar('=')) {
return Token.ASSIGN_BITOR;
}
 else {
return Token.BITOR;
}
case '^':
if (matchChar('=')) {
return Token.ASSIGN_BITXOR;
}
 else {
return Token.BITXOR;
}
case '&':
if (matchChar('&')) {
return Token.AND;
}
 else if (matchChar('=')) {
return Token.ASSIGN_BITAND;
}
 else {
return Token.BITAND;
}
case '=':
if (matchChar('=')) {
if (matchChar('=')) {
return Token.SHEQ;
}
 else {
return Token.EQ;
}
}
 else {
return Token.ASSIGN;
}
case '!':
if (matchChar('=')) {
if (matchChar('=')) {
return Token.SHNE;
}
 else {
return Token.NE;
}
}
 else {
return Token.NOT;
}
case '<':
if (matchChar('!')) {
if (matchChar('-')) {
if (matchChar('-')) {
tokenBeg=cursor - 4;
skipLine();
commentType=Token.CommentType.HTML;
return Token.COMMENT;
}
ungetCharIgnoreLineEnd('-');
}
ungetCharIgnoreLineEnd('!');
}
if (matchChar('<')) {
if (matchChar('=')) {
return Token.ASSIGN_LSH;
}
 else {
return Token.LSH;
}
}
 else {
if (matchChar('=')) {
return Token.LE;
}
 else {
return Token.LT;
}
}
case '>':
if (matchChar('>')) {
if (matchChar('>')) {
if (matchChar('=')) {
return Token.ASSIGN_URSH;
}
 else {
return Token.URSH;
}
}
 else {
if (matchChar('=')) {
return Token.ASSIGN_RSH;
}
 else {
return Token.RSH;
}
}
}
 else {
if (matchChar('=')) {
return Token.GE;
}
 else {
return Token.GT;
}
}
case '*':
if (matchChar('=')) {
return Token.ASSIGN_MUL;
}
 else {
return Token.MUL;
}
case '/':
markCommentStart();
if (matchChar('/')) {
tokenBeg=cursor - 2;
skipLine();
commentType=Token.CommentType.LINE;
return Token.COMMENT;
}
if (matchChar('*')) {
boolean lookForSlash=false;
tokenBeg=cursor - 2;
if (matchChar('*')) {
lookForSlash=true;
commentType=Token.CommentType.JSDOC;
if (matchChar('/')) {
commentType=Token.CommentType.BLOCK_COMMENT;
return Token.COMMENT;
}
}
 else {
commentType=Token.CommentType.BLOCK_COMMENT;
}
for (; ; ) {
c=getChar();
if (c == EOF_CHAR) {
tokenEnd=cursor - 1;
parser.addError(""String_Node_Str"");
return Token.COMMENT;
}
 else if (c == '*') {
lookForSlash=true;
}
 else if (c == '/') {
if (lookForSlash) {
tokenEnd=cursor;
return Token.COMMENT;
}
}
 else {
lookForSlash=false;
tokenEnd=cursor;
}
}
}
if (matchChar('=')) {
return Token.ASSIGN_DIV;
}
 else {
return Token.DIV;
}
case '%':
if (matchChar('=')) {
return Token.ASSIGN_MOD;
}
 else {
return Token.MOD;
}
case '~':
return Token.BITNOT;
case '+':
if (matchChar('=')) {
return Token.ASSIGN_ADD;
}
 else if (matchChar('+')) {
return Token.INC;
}
 else {
return Token.ADD;
}
case '-':
if (matchChar('=')) {
c=Token.ASSIGN_SUB;
}
 else if (matchChar('-')) {
if (!dirtyLine) {
if (matchChar('>')) {
markCommentStart(""String_Node_Str"");
skipLine();
commentType=Token.CommentType.HTML;
return Token.COMMENT;
}
}
c=Token.DEC;
}
 else {
c=Token.SUB;
}
dirtyLine=true;
return c;
default :
parser.addError(""String_Node_Str"");
return Token.ERROR;
}
}
}",0.9953982300884956
27842,"/** 
 * Handles a goog.require call.
 */
private void processRequireCall(NodeTraversal t,Node n,Node parent){
  Node left=n.getFirstChild();
  Node arg=left.getNext();
  if (verifyLastArgumentIsString(t,left,arg)) {
    String ns=arg.getString();
    ProvidedName provided=providedNames.get(ns);
    if (provided == null || !provided.isExplicitlyProvided()) {
      unrecognizedRequires.add(new UnrecognizedRequire(n,ns,t.getSourceName()));
    }
 else {
      JSModule providedModule=provided.explicitModule;
      Preconditions.checkNotNull(providedModule);
      JSModule module=t.getModule();
      if (moduleGraph != null && module != providedModule && !moduleGraph.dependsOn(module,providedModule)) {
        compiler.report(t.makeError(n,XMODULE_REQUIRE_ERROR,ns,providedModule.getName(),module.getName()));
      }
    }
    maybeAddToSymbolTable(left);
    maybeAddStringNodeToSymbolTable(arg);
    if (provided != null || requiresLevel.isOn()) {
      parent.detachFromParent();
      compiler.reportCodeChange();
    }
  }
}","/** 
 * Handles a goog.require call.
 */
private void processRequireCall(NodeTraversal t,Node n,Node parent){
  Node left=n.getFirstChild();
  Node arg=left.getNext();
  if (verifyLastArgumentIsString(t,left,arg)) {
    String ns=arg.getString();
    ProvidedName provided=providedNames.get(ns);
    if (provided == null || !provided.isExplicitlyProvided()) {
      unrecognizedRequires.add(new UnrecognizedRequire(n,ns,t.getSourceName()));
    }
 else {
      JSModule providedModule=provided.explicitModule;
      Preconditions.checkNotNull(providedModule);
      JSModule module=t.getModule();
      if (moduleGraph != null && module != providedModule && !moduleGraph.dependsOn(module,providedModule)) {
        compiler.report(t.makeError(n,XMODULE_REQUIRE_ERROR,ns,providedModule.getName(),module.getName()));
      }
    }
    maybeAddToSymbolTable(left);
    maybeAddStringNodeToSymbolTable(arg);
    if (provided != null) {
      parent.detachFromParent();
      compiler.reportCodeChange();
    }
  }
}",0.9882697947214076
27843,"/** 
 * Given a FUNCTION node returns array of STRING nodes representing function parameters.
 * @param n the FUNCTION node.
 * @return STRING nodes.
 */
private List<Node> createDependenciesList(Node n){
  Preconditions.checkArgument(n.isFunction());
  Node params=NodeUtil.getFunctionParameters(n);
  if (params != null) {
    return createStringsFromParamList(params);
  }
  return Lists.newArrayList();
}","/** 
 * Given a FUNCTION node returns array of STRING nodes representing function parameters.
 * @param n the FUNCTION node.
 * @return STRING nodes.
 */
private static List<Node> createDependenciesList(Node n){
  Preconditions.checkArgument(n.isFunction());
  Node params=NodeUtil.getFunctionParameters(n);
  if (params != null) {
    return createStringsFromParamList(params);
  }
  return Lists.newArrayList();
}",0.991494532199271
27844,"/** 
 * Given a PARAM_LIST node creates an array of corresponding STRING nodes.
 * @param params PARAM_LIST node.
 * @return array of STRING nodes.
 */
private List<Node> createStringsFromParamList(Node params){
  Node param=params.getFirstChild();
  ArrayList<Node> names=Lists.newArrayList();
  while (param != null && param.isName()) {
    names.add(IR.string(param.getString()).srcref(param));
    param=param.getNext();
  }
  return names;
}","/** 
 * Given a PARAM_LIST node creates an array of corresponding STRING nodes.
 * @param params PARAM_LIST node.
 * @return array of STRING nodes.
 */
private static List<Node> createStringsFromParamList(Node params){
  Node param=params.getFirstChild();
  ArrayList<Node> names=Lists.newArrayList();
  while (param != null && param.isName()) {
    names.add(IR.string(param.getString()).srcref(param));
    param=param.getNext();
  }
  return names;
}",0.9922135706340378
27845,"/** 
 * Given a VAR node (variable declaration) returns the node of initial value. <pre>  {@code var x;  // null var y = ""value""; // STRING ""value"" node}var z = x = y = function()  ; // FUNCTION node }</pre>
 * @param n VAR node.
 * @return the assigned intial value, or the rightmost rvalue of an assignmentchain, or null.
 */
private Node getDeclarationRValue(Node n){
  Preconditions.checkNotNull(n);
  Preconditions.checkArgument(n.isVar());
  n=n.getFirstChild().getFirstChild();
  if (n == null) {
    return null;
  }
  while (n.isAssign()) {
    n=n.getLastChild();
  }
  return n;
}","/** 
 * Given a VAR node (variable declaration) returns the node of initial value. <pre>  {@code var x;  // null var y = ""value""; // STRING ""value"" node}var z = x = y = function()  ; // FUNCTION node }</pre>
 * @param n VAR node.
 * @return the assigned intial value, or the rightmost rvalue of an assignmentchain, or null.
 */
private static Node getDeclarationRValue(Node n){
  Preconditions.checkNotNull(n);
  Preconditions.checkArgument(n.isVar());
  n=n.getFirstChild().getFirstChild();
  if (n == null) {
    return null;
  }
  while (n.isAssign()) {
    n=n.getLastChild();
  }
  return n;
}",0.9941126997476872
27846,"/** 
 * @param compiler the compiler that owns/creates this.
 * @param tracker an optional performance tracker
 * @param progressRange the progress range for the process function or nullif progress should not be reported.
 */
PhaseOptimizer(AbstractCompiler comp,PerformanceTracker tracker,ProgressRange range){
  this.compiler=comp;
  this.jsRoot=comp.getJsRoot();
  this.tracker=tracker;
  this.passes=Lists.newArrayList();
  this.progressRange=range;
  this.inLoop=false;
  this.crossScopeReporting=false;
  this.timestamp=this.lastChange=START_TIME;
}","/** 
 * @param comp the compiler that owns/creates this.
 * @param tracker an optional performance tracker
 * @param range the progress range for the process function or nullif progress should not be reported.
 */
PhaseOptimizer(AbstractCompiler comp,PerformanceTracker tracker,ProgressRange range){
  this.compiler=comp;
  this.jsRoot=comp.getJsRoot();
  this.tracker=tracker;
  this.passes=Lists.newArrayList();
  this.progressRange=range;
  this.inLoop=false;
  this.crossScopeReporting=false;
  this.timestamp=this.lastChange=START_TIME;
}",0.9872495446265938
27847,"private boolean isJSDocString(int c){
switch (c) {
case '@':
case '*':
case ',':
case '>':
case ':':
case '(':
case ')':
case '{':
case '}':
case '[':
case ']':
case '?':
case '!':
case '|':
case '=':
case EOF_CHAR:
case '\n':
    return false;
default :
  return !isJSSpace(c);
}
}","private static boolean isJSDocString(int c){
switch (c) {
case '@':
case '*':
case ',':
case '>':
case ':':
case '(':
case ')':
case '{':
case '}':
case '[':
case ']':
case '?':
case '!':
case '|':
case '=':
case EOF_CHAR:
case '\n':
    return false;
default :
  return !isJSSpace(c);
}
}",0.9877408056042032
27848,"private void initializeBuiltInTypes(){
  objectIndexTemplateKey=new TemplateType(this,OBJECT_INDEX_TEMPLATE);
  objectElementTemplateKey=new TemplateType(this,OBJECT_ELEMENT_TEMPLATE);
  BooleanType BOOLEAN_TYPE=new BooleanType(this);
  registerNativeType(JSTypeNative.BOOLEAN_TYPE,BOOLEAN_TYPE);
  NullType NULL_TYPE=new NullType(this);
  registerNativeType(JSTypeNative.NULL_TYPE,NULL_TYPE);
  NumberType NUMBER_TYPE=new NumberType(this);
  registerNativeType(JSTypeNative.NUMBER_TYPE,NUMBER_TYPE);
  StringType STRING_TYPE=new StringType(this);
  registerNativeType(JSTypeNative.STRING_TYPE,STRING_TYPE);
  UnknownType UNKNOWN_TYPE=new UnknownType(this,false);
  registerNativeType(JSTypeNative.UNKNOWN_TYPE,UNKNOWN_TYPE);
  UnknownType checkedUnknownType=new UnknownType(this,true);
  registerNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE,checkedUnknownType);
  VoidType VOID_TYPE=new VoidType(this);
  registerNativeType(JSTypeNative.VOID_TYPE,VOID_TYPE);
  AllType ALL_TYPE=new AllType(this);
  registerNativeType(JSTypeNative.ALL_TYPE,ALL_TYPE);
  PrototypeObjectType TOP_LEVEL_PROTOTYPE=new PrototypeObjectType(this,null,null,true,null);
  registerNativeType(JSTypeNative.TOP_LEVEL_PROTOTYPE,TOP_LEVEL_PROTOTYPE);
  FunctionType OBJECT_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createOptionalParameters(ALL_TYPE),UNKNOWN_TYPE),null,createTemplateTypeMap(ImmutableList.of(objectIndexTemplateKey,objectElementTemplateKey),null),true,true);
  OBJECT_FUNCTION_TYPE.setPrototype(TOP_LEVEL_PROTOTYPE,null);
  registerNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE,OBJECT_FUNCTION_TYPE);
  ObjectType OBJECT_TYPE=OBJECT_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.OBJECT_TYPE,OBJECT_TYPE);
  ObjectType OBJECT_PROTOTYPE=OBJECT_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.OBJECT_PROTOTYPE,OBJECT_PROTOTYPE);
  FunctionType FUNCTION_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createParametersWithVarArgs(ALL_TYPE),UNKNOWN_TYPE),null,null,true,true);
  FUNCTION_FUNCTION_TYPE.setPrototypeBasedOn(OBJECT_TYPE);
  registerNativeType(JSTypeNative.FUNCTION_FUNCTION_TYPE,FUNCTION_FUNCTION_TYPE);
  ObjectType FUNCTION_PROTOTYPE=FUNCTION_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.FUNCTION_PROTOTYPE,FUNCTION_PROTOTYPE);
  NoType NO_TYPE=new NoType(this);
  registerNativeType(JSTypeNative.NO_TYPE,NO_TYPE);
  NoObjectType NO_OBJECT_TYPE=new NoObjectType(this);
  registerNativeType(JSTypeNative.NO_OBJECT_TYPE,NO_OBJECT_TYPE);
  NoObjectType NO_RESOLVED_TYPE=new NoResolvedType(this);
  registerNativeType(JSTypeNative.NO_RESOLVED_TYPE,NO_RESOLVED_TYPE);
  FunctionType ARRAY_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createParametersWithVarArgs(ALL_TYPE),null),null,createTemplateTypeMap(ImmutableList.of(objectElementTemplateKey),null),true,true);
  ARRAY_FUNCTION_TYPE.getInternalArrowType().returnType=ARRAY_FUNCTION_TYPE.getInstanceType();
  ObjectType arrayPrototype=ARRAY_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.ARRAY_FUNCTION_TYPE,ARRAY_FUNCTION_TYPE);
  ObjectType ARRAY_TYPE=ARRAY_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.ARRAY_TYPE,ARRAY_TYPE);
  FunctionType BOOLEAN_OBJECT_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createOptionalParameters(ALL_TYPE),BOOLEAN_TYPE),null,null,true,true);
  ObjectType booleanPrototype=BOOLEAN_OBJECT_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE,BOOLEAN_OBJECT_FUNCTION_TYPE);
  ObjectType BOOLEAN_OBJECT_TYPE=BOOLEAN_OBJECT_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.BOOLEAN_OBJECT_TYPE,BOOLEAN_OBJECT_TYPE);
  FunctionType DATE_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createOptionalParameters(UNKNOWN_TYPE,UNKNOWN_TYPE,UNKNOWN_TYPE,UNKNOWN_TYPE,UNKNOWN_TYPE,UNKNOWN_TYPE,UNKNOWN_TYPE),STRING_TYPE),null,null,true,true);
  ObjectType datePrototype=DATE_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.DATE_FUNCTION_TYPE,DATE_FUNCTION_TYPE);
  ObjectType DATE_TYPE=DATE_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.DATE_TYPE,DATE_TYPE);
  FunctionType ERROR_FUNCTION_TYPE=new ErrorFunctionType(this,""String_Node_Str"");
  registerNativeType(JSTypeNative.ERROR_FUNCTION_TYPE,ERROR_FUNCTION_TYPE);
  ObjectType ERROR_TYPE=ERROR_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.ERROR_TYPE,ERROR_TYPE);
  FunctionType EVAL_ERROR_FUNCTION_TYPE=new ErrorFunctionType(this,""String_Node_Str"");
  EVAL_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);
  registerNativeType(JSTypeNative.EVAL_ERROR_FUNCTION_TYPE,EVAL_ERROR_FUNCTION_TYPE);
  ObjectType EVAL_ERROR_TYPE=EVAL_ERROR_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.EVAL_ERROR_TYPE,EVAL_ERROR_TYPE);
  FunctionType RANGE_ERROR_FUNCTION_TYPE=new ErrorFunctionType(this,""String_Node_Str"");
  RANGE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);
  registerNativeType(JSTypeNative.RANGE_ERROR_FUNCTION_TYPE,RANGE_ERROR_FUNCTION_TYPE);
  ObjectType RANGE_ERROR_TYPE=RANGE_ERROR_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.RANGE_ERROR_TYPE,RANGE_ERROR_TYPE);
  FunctionType REFERENCE_ERROR_FUNCTION_TYPE=new ErrorFunctionType(this,""String_Node_Str"");
  REFERENCE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);
  registerNativeType(JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE,REFERENCE_ERROR_FUNCTION_TYPE);
  ObjectType REFERENCE_ERROR_TYPE=REFERENCE_ERROR_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.REFERENCE_ERROR_TYPE,REFERENCE_ERROR_TYPE);
  FunctionType SYNTAX_ERROR_FUNCTION_TYPE=new ErrorFunctionType(this,""String_Node_Str"");
  SYNTAX_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);
  registerNativeType(JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE,SYNTAX_ERROR_FUNCTION_TYPE);
  ObjectType SYNTAX_ERROR_TYPE=SYNTAX_ERROR_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.SYNTAX_ERROR_TYPE,SYNTAX_ERROR_TYPE);
  FunctionType TYPE_ERROR_FUNCTION_TYPE=new ErrorFunctionType(this,""String_Node_Str"");
  TYPE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);
  registerNativeType(JSTypeNative.TYPE_ERROR_FUNCTION_TYPE,TYPE_ERROR_FUNCTION_TYPE);
  ObjectType TYPE_ERROR_TYPE=TYPE_ERROR_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.TYPE_ERROR_TYPE,TYPE_ERROR_TYPE);
  FunctionType URI_ERROR_FUNCTION_TYPE=new ErrorFunctionType(this,""String_Node_Str"");
  URI_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);
  registerNativeType(JSTypeNative.URI_ERROR_FUNCTION_TYPE,URI_ERROR_FUNCTION_TYPE);
  ObjectType URI_ERROR_TYPE=URI_ERROR_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.URI_ERROR_TYPE,URI_ERROR_TYPE);
  FunctionType NUMBER_OBJECT_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createOptionalParameters(ALL_TYPE),NUMBER_TYPE),null,null,true,true);
  ObjectType numberPrototype=NUMBER_OBJECT_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE,NUMBER_OBJECT_FUNCTION_TYPE);
  ObjectType NUMBER_OBJECT_TYPE=NUMBER_OBJECT_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.NUMBER_OBJECT_TYPE,NUMBER_OBJECT_TYPE);
  FunctionType REGEXP_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createOptionalParameters(ALL_TYPE,ALL_TYPE)),null,null,true,true);
  REGEXP_FUNCTION_TYPE.getInternalArrowType().returnType=REGEXP_FUNCTION_TYPE.getInstanceType();
  ObjectType regexpPrototype=REGEXP_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.REGEXP_FUNCTION_TYPE,REGEXP_FUNCTION_TYPE);
  ObjectType REGEXP_TYPE=REGEXP_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.REGEXP_TYPE,REGEXP_TYPE);
  FunctionType STRING_OBJECT_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createOptionalParameters(ALL_TYPE),STRING_TYPE),null,null,true,true);
  ObjectType stringPrototype=STRING_OBJECT_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.STRING_OBJECT_FUNCTION_TYPE,STRING_OBJECT_FUNCTION_TYPE);
  ObjectType STRING_OBJECT_TYPE=STRING_OBJECT_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.STRING_OBJECT_TYPE,STRING_OBJECT_TYPE);
  JSType NULL_VOID=createUnionType(NULL_TYPE,VOID_TYPE);
  registerNativeType(JSTypeNative.NULL_VOID,NULL_VOID);
  JSType OBJECT_NUMBER_STRING=createUnionType(OBJECT_TYPE,NUMBER_TYPE,STRING_TYPE);
  registerNativeType(JSTypeNative.OBJECT_NUMBER_STRING,OBJECT_NUMBER_STRING);
  JSType OBJECT_NUMBER_STRING_BOOLEAN=createUnionType(OBJECT_TYPE,NUMBER_TYPE,STRING_TYPE,BOOLEAN_TYPE);
  registerNativeType(JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN,OBJECT_NUMBER_STRING_BOOLEAN);
  JSType NUMBER_STRING_BOOLEAN=createUnionType(NUMBER_TYPE,STRING_TYPE,BOOLEAN_TYPE);
  registerNativeType(JSTypeNative.NUMBER_STRING_BOOLEAN,NUMBER_STRING_BOOLEAN);
  JSType NUMBER_STRING=createUnionType(NUMBER_TYPE,STRING_TYPE);
  registerNativeType(JSTypeNative.NUMBER_STRING,NUMBER_STRING);
  JSType STRING_VALUE_OR_OBJECT_TYPE=createUnionType(STRING_OBJECT_TYPE,STRING_TYPE);
  registerNativeType(JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE,STRING_VALUE_OR_OBJECT_TYPE);
  JSType NUMBER_VALUE_OR_OBJECT_TYPE=createUnionType(NUMBER_OBJECT_TYPE,NUMBER_TYPE);
  registerNativeType(JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE,NUMBER_VALUE_OR_OBJECT_TYPE);
  FunctionType U2U_FUNCTION_TYPE=createFunctionType(UNKNOWN_TYPE,true,UNKNOWN_TYPE);
  registerNativeType(JSTypeNative.U2U_FUNCTION_TYPE,U2U_FUNCTION_TYPE);
  FunctionType U2U_CONSTRUCTOR_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createParametersWithVarArgs(UNKNOWN_TYPE),UNKNOWN_TYPE),UNKNOWN_TYPE,null,true,true){
    private static final long serialVersionUID=1L;
    @Override public FunctionType getConstructor(){
      return registry.getNativeFunctionType(JSTypeNative.FUNCTION_FUNCTION_TYPE);
    }
  }
;
  registerNativeType(JSTypeNative.U2U_CONSTRUCTOR_TYPE,U2U_CONSTRUCTOR_TYPE);
  registerNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE,U2U_CONSTRUCTOR_TYPE);
  FUNCTION_FUNCTION_TYPE.setInstanceType(U2U_CONSTRUCTOR_TYPE);
  U2U_CONSTRUCTOR_TYPE.setImplicitPrototype(FUNCTION_PROTOTYPE);
  FunctionType LEAST_FUNCTION_TYPE=createNativeFunctionTypeWithVarArgs(NO_TYPE,ALL_TYPE);
  registerNativeType(JSTypeNative.LEAST_FUNCTION_TYPE,LEAST_FUNCTION_TYPE);
  FunctionType GLOBAL_THIS_CTOR=new FunctionType(this,""String_Node_Str"",null,createArrowType(createParameters(false,ALL_TYPE),NUMBER_TYPE),null,null,true,true);
  ObjectType GLOBAL_THIS=GLOBAL_THIS_CTOR.getInstanceType();
  registerNativeType(JSTypeNative.GLOBAL_THIS,GLOBAL_THIS);
  FunctionType GREATEST_FUNCTION_TYPE=createNativeFunctionTypeWithVarArgs(ALL_TYPE,NO_TYPE);
  registerNativeType(JSTypeNative.GREATEST_FUNCTION_TYPE,GREATEST_FUNCTION_TYPE);
  registerPropertyOnType(""String_Node_Str"",OBJECT_FUNCTION_TYPE);
}","private void initializeBuiltInTypes(){
  objectIndexTemplateKey=new TemplateType(this,OBJECT_INDEX_TEMPLATE);
  objectElementTemplateKey=new TemplateType(this,OBJECT_ELEMENT_TEMPLATE);
  BooleanType BOOLEAN_TYPE=new BooleanType(this);
  registerNativeType(JSTypeNative.BOOLEAN_TYPE,BOOLEAN_TYPE);
  NullType NULL_TYPE=new NullType(this);
  registerNativeType(JSTypeNative.NULL_TYPE,NULL_TYPE);
  NumberType NUMBER_TYPE=new NumberType(this);
  registerNativeType(JSTypeNative.NUMBER_TYPE,NUMBER_TYPE);
  StringType STRING_TYPE=new StringType(this);
  registerNativeType(JSTypeNative.STRING_TYPE,STRING_TYPE);
  UnknownType UNKNOWN_TYPE=new UnknownType(this,false);
  registerNativeType(JSTypeNative.UNKNOWN_TYPE,UNKNOWN_TYPE);
  UnknownType checkedUnknownType=new UnknownType(this,true);
  registerNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE,checkedUnknownType);
  VoidType VOID_TYPE=new VoidType(this);
  registerNativeType(JSTypeNative.VOID_TYPE,VOID_TYPE);
  AllType ALL_TYPE=new AllType(this);
  registerNativeType(JSTypeNative.ALL_TYPE,ALL_TYPE);
  PrototypeObjectType TOP_LEVEL_PROTOTYPE=new PrototypeObjectType(this,null,null,true,null);
  registerNativeType(JSTypeNative.TOP_LEVEL_PROTOTYPE,TOP_LEVEL_PROTOTYPE);
  FunctionType OBJECT_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createOptionalParameters(ALL_TYPE),UNKNOWN_TYPE),null,createTemplateTypeMap(ImmutableList.of(objectIndexTemplateKey,objectElementTemplateKey),null),true,true);
  OBJECT_FUNCTION_TYPE.setPrototype(TOP_LEVEL_PROTOTYPE,null);
  registerNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE,OBJECT_FUNCTION_TYPE);
  ObjectType OBJECT_TYPE=OBJECT_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.OBJECT_TYPE,OBJECT_TYPE);
  ObjectType OBJECT_PROTOTYPE=OBJECT_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.OBJECT_PROTOTYPE,OBJECT_PROTOTYPE);
  FunctionType FUNCTION_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createParametersWithVarArgs(ALL_TYPE),UNKNOWN_TYPE),null,null,true,true);
  FUNCTION_FUNCTION_TYPE.setPrototypeBasedOn(OBJECT_TYPE);
  registerNativeType(JSTypeNative.FUNCTION_FUNCTION_TYPE,FUNCTION_FUNCTION_TYPE);
  ObjectType FUNCTION_PROTOTYPE=FUNCTION_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.FUNCTION_PROTOTYPE,FUNCTION_PROTOTYPE);
  NoType NO_TYPE=new NoType(this);
  registerNativeType(JSTypeNative.NO_TYPE,NO_TYPE);
  NoObjectType NO_OBJECT_TYPE=new NoObjectType(this);
  registerNativeType(JSTypeNative.NO_OBJECT_TYPE,NO_OBJECT_TYPE);
  NoObjectType NO_RESOLVED_TYPE=new NoResolvedType(this);
  registerNativeType(JSTypeNative.NO_RESOLVED_TYPE,NO_RESOLVED_TYPE);
  FunctionType ARRAY_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createParametersWithVarArgs(ALL_TYPE),null),null,createTemplateTypeMap(ImmutableList.of(objectElementTemplateKey),null),true,true);
  ARRAY_FUNCTION_TYPE.getInternalArrowType().returnType=ARRAY_FUNCTION_TYPE.getInstanceType();
  ARRAY_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.ARRAY_FUNCTION_TYPE,ARRAY_FUNCTION_TYPE);
  ObjectType ARRAY_TYPE=ARRAY_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.ARRAY_TYPE,ARRAY_TYPE);
  FunctionType BOOLEAN_OBJECT_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createOptionalParameters(ALL_TYPE),BOOLEAN_TYPE),null,null,true,true);
  BOOLEAN_OBJECT_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE,BOOLEAN_OBJECT_FUNCTION_TYPE);
  ObjectType BOOLEAN_OBJECT_TYPE=BOOLEAN_OBJECT_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.BOOLEAN_OBJECT_TYPE,BOOLEAN_OBJECT_TYPE);
  FunctionType DATE_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createOptionalParameters(UNKNOWN_TYPE,UNKNOWN_TYPE,UNKNOWN_TYPE,UNKNOWN_TYPE,UNKNOWN_TYPE,UNKNOWN_TYPE,UNKNOWN_TYPE),STRING_TYPE),null,null,true,true);
  DATE_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.DATE_FUNCTION_TYPE,DATE_FUNCTION_TYPE);
  ObjectType DATE_TYPE=DATE_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.DATE_TYPE,DATE_TYPE);
  FunctionType ERROR_FUNCTION_TYPE=new ErrorFunctionType(this,""String_Node_Str"");
  registerNativeType(JSTypeNative.ERROR_FUNCTION_TYPE,ERROR_FUNCTION_TYPE);
  ObjectType ERROR_TYPE=ERROR_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.ERROR_TYPE,ERROR_TYPE);
  FunctionType EVAL_ERROR_FUNCTION_TYPE=new ErrorFunctionType(this,""String_Node_Str"");
  EVAL_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);
  registerNativeType(JSTypeNative.EVAL_ERROR_FUNCTION_TYPE,EVAL_ERROR_FUNCTION_TYPE);
  ObjectType EVAL_ERROR_TYPE=EVAL_ERROR_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.EVAL_ERROR_TYPE,EVAL_ERROR_TYPE);
  FunctionType RANGE_ERROR_FUNCTION_TYPE=new ErrorFunctionType(this,""String_Node_Str"");
  RANGE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);
  registerNativeType(JSTypeNative.RANGE_ERROR_FUNCTION_TYPE,RANGE_ERROR_FUNCTION_TYPE);
  ObjectType RANGE_ERROR_TYPE=RANGE_ERROR_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.RANGE_ERROR_TYPE,RANGE_ERROR_TYPE);
  FunctionType REFERENCE_ERROR_FUNCTION_TYPE=new ErrorFunctionType(this,""String_Node_Str"");
  REFERENCE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);
  registerNativeType(JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE,REFERENCE_ERROR_FUNCTION_TYPE);
  ObjectType REFERENCE_ERROR_TYPE=REFERENCE_ERROR_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.REFERENCE_ERROR_TYPE,REFERENCE_ERROR_TYPE);
  FunctionType SYNTAX_ERROR_FUNCTION_TYPE=new ErrorFunctionType(this,""String_Node_Str"");
  SYNTAX_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);
  registerNativeType(JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE,SYNTAX_ERROR_FUNCTION_TYPE);
  ObjectType SYNTAX_ERROR_TYPE=SYNTAX_ERROR_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.SYNTAX_ERROR_TYPE,SYNTAX_ERROR_TYPE);
  FunctionType TYPE_ERROR_FUNCTION_TYPE=new ErrorFunctionType(this,""String_Node_Str"");
  TYPE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);
  registerNativeType(JSTypeNative.TYPE_ERROR_FUNCTION_TYPE,TYPE_ERROR_FUNCTION_TYPE);
  ObjectType TYPE_ERROR_TYPE=TYPE_ERROR_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.TYPE_ERROR_TYPE,TYPE_ERROR_TYPE);
  FunctionType URI_ERROR_FUNCTION_TYPE=new ErrorFunctionType(this,""String_Node_Str"");
  URI_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);
  registerNativeType(JSTypeNative.URI_ERROR_FUNCTION_TYPE,URI_ERROR_FUNCTION_TYPE);
  ObjectType URI_ERROR_TYPE=URI_ERROR_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.URI_ERROR_TYPE,URI_ERROR_TYPE);
  FunctionType NUMBER_OBJECT_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createOptionalParameters(ALL_TYPE),NUMBER_TYPE),null,null,true,true);
  NUMBER_OBJECT_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE,NUMBER_OBJECT_FUNCTION_TYPE);
  ObjectType NUMBER_OBJECT_TYPE=NUMBER_OBJECT_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.NUMBER_OBJECT_TYPE,NUMBER_OBJECT_TYPE);
  FunctionType REGEXP_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createOptionalParameters(ALL_TYPE,ALL_TYPE)),null,null,true,true);
  REGEXP_FUNCTION_TYPE.getInternalArrowType().returnType=REGEXP_FUNCTION_TYPE.getInstanceType();
  REGEXP_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.REGEXP_FUNCTION_TYPE,REGEXP_FUNCTION_TYPE);
  ObjectType REGEXP_TYPE=REGEXP_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.REGEXP_TYPE,REGEXP_TYPE);
  FunctionType STRING_OBJECT_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createOptionalParameters(ALL_TYPE),STRING_TYPE),null,null,true,true);
  STRING_OBJECT_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.STRING_OBJECT_FUNCTION_TYPE,STRING_OBJECT_FUNCTION_TYPE);
  ObjectType STRING_OBJECT_TYPE=STRING_OBJECT_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.STRING_OBJECT_TYPE,STRING_OBJECT_TYPE);
  JSType NULL_VOID=createUnionType(NULL_TYPE,VOID_TYPE);
  registerNativeType(JSTypeNative.NULL_VOID,NULL_VOID);
  JSType OBJECT_NUMBER_STRING=createUnionType(OBJECT_TYPE,NUMBER_TYPE,STRING_TYPE);
  registerNativeType(JSTypeNative.OBJECT_NUMBER_STRING,OBJECT_NUMBER_STRING);
  JSType OBJECT_NUMBER_STRING_BOOLEAN=createUnionType(OBJECT_TYPE,NUMBER_TYPE,STRING_TYPE,BOOLEAN_TYPE);
  registerNativeType(JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN,OBJECT_NUMBER_STRING_BOOLEAN);
  JSType NUMBER_STRING_BOOLEAN=createUnionType(NUMBER_TYPE,STRING_TYPE,BOOLEAN_TYPE);
  registerNativeType(JSTypeNative.NUMBER_STRING_BOOLEAN,NUMBER_STRING_BOOLEAN);
  JSType NUMBER_STRING=createUnionType(NUMBER_TYPE,STRING_TYPE);
  registerNativeType(JSTypeNative.NUMBER_STRING,NUMBER_STRING);
  JSType STRING_VALUE_OR_OBJECT_TYPE=createUnionType(STRING_OBJECT_TYPE,STRING_TYPE);
  registerNativeType(JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE,STRING_VALUE_OR_OBJECT_TYPE);
  JSType NUMBER_VALUE_OR_OBJECT_TYPE=createUnionType(NUMBER_OBJECT_TYPE,NUMBER_TYPE);
  registerNativeType(JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE,NUMBER_VALUE_OR_OBJECT_TYPE);
  FunctionType U2U_FUNCTION_TYPE=createFunctionType(UNKNOWN_TYPE,true,UNKNOWN_TYPE);
  registerNativeType(JSTypeNative.U2U_FUNCTION_TYPE,U2U_FUNCTION_TYPE);
  FunctionType U2U_CONSTRUCTOR_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createParametersWithVarArgs(UNKNOWN_TYPE),UNKNOWN_TYPE),UNKNOWN_TYPE,null,true,true){
    private static final long serialVersionUID=1L;
    @Override public FunctionType getConstructor(){
      return registry.getNativeFunctionType(JSTypeNative.FUNCTION_FUNCTION_TYPE);
    }
  }
;
  registerNativeType(JSTypeNative.U2U_CONSTRUCTOR_TYPE,U2U_CONSTRUCTOR_TYPE);
  registerNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE,U2U_CONSTRUCTOR_TYPE);
  FUNCTION_FUNCTION_TYPE.setInstanceType(U2U_CONSTRUCTOR_TYPE);
  U2U_CONSTRUCTOR_TYPE.setImplicitPrototype(FUNCTION_PROTOTYPE);
  FunctionType LEAST_FUNCTION_TYPE=createNativeFunctionTypeWithVarArgs(NO_TYPE,ALL_TYPE);
  registerNativeType(JSTypeNative.LEAST_FUNCTION_TYPE,LEAST_FUNCTION_TYPE);
  FunctionType GLOBAL_THIS_CTOR=new FunctionType(this,""String_Node_Str"",null,createArrowType(createParameters(false,ALL_TYPE),NUMBER_TYPE),null,null,true,true);
  ObjectType GLOBAL_THIS=GLOBAL_THIS_CTOR.getInstanceType();
  registerNativeType(JSTypeNative.GLOBAL_THIS,GLOBAL_THIS);
  FunctionType GREATEST_FUNCTION_TYPE=createNativeFunctionTypeWithVarArgs(ALL_TYPE,NO_TYPE);
  registerNativeType(JSTypeNative.GREATEST_FUNCTION_TYPE,GREATEST_FUNCTION_TYPE);
  registerPropertyOnType(""String_Node_Str"",OBJECT_FUNCTION_TYPE);
}",0.5959864381929808
27849,"private Node tryRotateAssociativeOperator(Node n){
  if (!late) {
    return n;
  }
  Preconditions.checkArgument(NodeUtil.isAssociative(n.getType()));
  Node rhs=n.getLastChild();
  if (n.getType() == rhs.getType()) {
    Node first=n.getFirstChild().detachFromParent();
    Node second=rhs.getFirstChild().detachFromParent();
    Node third=rhs.getLastChild().detachFromParent();
    Node newLhs=new Node(n.getType(),first,second).copyInformationFrom(n);
    Node newRoot=new Node(rhs.getType(),newLhs,third).copyInformationFrom(rhs);
    n.getParent().replaceChild(n,newRoot);
    reportCodeChange();
    return newRoot;
  }
 else   if (NodeUtil.isCommutative(n.getType()) && !NodeUtil.mayHaveSideEffects(n)) {
    Node lhs=n.getFirstChild();
    int precedence=NodeUtil.precedence(n.getType());
    int lhsPrecedence=NodeUtil.precedence(lhs.getType());
    int rhsPrecedence=NodeUtil.precedence(rhs.getType());
    if (rhsPrecedence == precedence && (lhs.getType() == n.getType() || lhsPrecedence != precedence)) {
      n.removeChild(rhs);
      n.addChildToFront(rhs);
      reportCodeChange();
      return n;
    }
  }
  return n;
}","private Node tryRotateAssociativeOperator(Node n){
  if (!late) {
    return n;
  }
  Preconditions.checkArgument(NodeUtil.isAssociative(n.getType()));
  Node rhs=n.getLastChild();
  if (n.getType() == rhs.getType()) {
    Node first=n.getFirstChild().detachFromParent();
    Node second=rhs.getFirstChild().detachFromParent();
    Node third=rhs.getLastChild().detachFromParent();
    Node newLhs=new Node(n.getType(),first,second).copyInformationFrom(n);
    Node newRoot=new Node(rhs.getType(),newLhs,third).copyInformationFrom(rhs);
    n.getParent().replaceChild(n,newRoot);
    reportCodeChange();
    return newRoot;
  }
 else   if (NodeUtil.isCommutative(n.getType()) && !NodeUtil.mayHaveSideEffects(n)) {
    Node lhs=n.getFirstChild();
    while (lhs.getType() == n.getType()) {
      lhs=lhs.getFirstChild();
    }
    int precedence=NodeUtil.precedence(n.getType());
    int lhsPrecedence=NodeUtil.precedence(lhs.getType());
    int rhsPrecedence=NodeUtil.precedence(rhs.getType());
    if (rhsPrecedence == precedence && lhsPrecedence != precedence) {
      n.removeChild(rhs);
      lhs.getParent().replaceChild(lhs,rhs);
      n.addChildToBack(lhs);
      reportCodeChange();
      return n;
    }
  }
  return n;
}",0.8649789029535865
27850,"public void testRotateAssociativeOperators(){
  test(""String_Node_Str"",""String_Node_Str"");
  testSame(""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
}","public void testRotateAssociativeOperators(){
  test(""String_Node_Str"",""String_Node_Str"");
  testSame(""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
}",0.8258064516129032
27851,"/** 
 * Runs the Compiler and calls System.exit() with the exit status of the compiler.
 */
public final void run(){
  int result=0;
  int runs=1;
  try {
    for (int i=0; i < runs && result == 0; i++) {
      result=doRun();
    }
  }
 catch (  AbstractCommandLineRunner.FlagUsageException e) {
    System.err.println(e.getMessage());
    result=-1;
  }
catch (  Throwable t) {
    t.printStackTrace();
    result=-2;
  }
  try {
    if (jsOutput instanceof Closeable) {
      ((Closeable)jsOutput).close();
    }
  }
 catch (  IOException e) {
    throw Throwables.propagate(e);
  }
  if (testMode) {
    exitCodeReceiverForTesting.apply(result);
  }
 else {
    System.exit(result);
  }
}","/** 
 * Runs the Compiler and calls System.exit() with the exit status of the compiler.
 */
public final void run(){
  int result=0;
  int runs=1;
  try {
    for (int i=0; i < runs && result == 0; i++) {
      result=doRun();
    }
  }
 catch (  AbstractCommandLineRunner.FlagUsageException e) {
    System.err.println(e.getMessage());
    result=-1;
  }
catch (  Throwable t) {
    t.printStackTrace();
    result=-2;
  }
  if (testMode) {
    exitCodeReceiverForTesting.apply(result);
  }
 else {
    System.exit(result);
  }
}",0.867430441898527
27852,"void outputSingleBinary() throws IOException {
  Function<String,String> escaper=null;
  String marker=OUTPUT_MARKER;
  if (config.outputWrapper.contains(OUTPUT_MARKER_JS_STRING)) {
    marker=OUTPUT_MARKER_JS_STRING;
    escaper=getJavascriptEscaper();
  }
  writeOutput(jsOutput,compiler,compiler.toSource(),config.outputWrapper,marker,escaper);
}","void outputSingleBinary() throws IOException {
  Function<String,String> escaper=null;
  String marker=OUTPUT_MARKER;
  if (config.outputWrapper.contains(OUTPUT_MARKER_JS_STRING)) {
    marker=OUTPUT_MARKER_JS_STRING;
    escaper=getJavascriptEscaper();
  }
  Appendable jsOutput=createDefaultOutput();
  writeOutput(jsOutput,compiler,compiler.toSource(),config.outputWrapper,marker,escaper);
  closeAppendable(jsOutput);
}",0.9041450777202072
27853,"/** 
 * Parses command-line arguments and runs the compiler.
 * @return system exit status
 */
protected int doRun() throws FlagUsageException, IOException {
  Compiler.setLoggingLevel(Level.parse(config.loggingLevel));
  List<SourceFile> externs=createExterns();
  compiler=createCompiler();
  B options=createOptions();
  List<JSModule> modules=null;
  Result result=null;
  setRunOptions(options);
  boolean writeOutputToFile=!config.jsOutputFile.isEmpty();
  List<String> outputFileNames=Lists.newArrayList();
  if (writeOutputToFile) {
    outputFileNames.add(config.jsOutputFile);
    jsOutput=fileNameToLegacyOutputWriter(config.jsOutputFile);
  }
 else   if (jsOutput instanceof OutputStream) {
    jsOutput=streamToLegacyOutputWriter((OutputStream)jsOutput);
  }
  List<String> jsFiles=config.js;
  List<String> moduleSpecs=config.module;
  boolean createCommonJsModules=false;
  if (options.processCommonJSModules) {
    if (moduleSpecs.size() == 1 && ""String_Node_Str"".equals(moduleSpecs.get(0))) {
      createCommonJsModules=true;
      moduleSpecs.remove(0);
    }
  }
  if (!moduleSpecs.isEmpty()) {
    modules=createJsModules(moduleSpecs,jsFiles);
    for (    JSModule m : modules) {
      outputFileNames.add(getModuleOutputFileName(m));
    }
    if (config.skipNormalOutputs) {
      compiler.initModules(externs,modules,options);
    }
 else {
      result=compiler.compileModules(externs,modules,options);
    }
  }
 else {
    List<SourceFile> inputs=createSourceInputs(jsFiles);
    if (config.skipNormalOutputs) {
      compiler.init(externs,inputs,options);
    }
 else {
      result=compiler.compile(externs,inputs,options);
    }
  }
  if (createCommonJsModules) {
    modules=Lists.newArrayList(compiler.getDegenerateModuleGraph().getAllModules());
    for (    JSModule m : modules) {
      outputFileNames.add(getModuleOutputFileName(m));
    }
  }
  for (  String outputFileName : outputFileNames) {
    if (compiler.getSourceFileByName(outputFileName) != null) {
      compiler.report(JSError.make(OUTPUT_SAME_AS_INPUT_ERROR,outputFileName));
      return 1;
    }
  }
  int errCode=processResults(result,modules,options);
  if (jsOutput instanceof Flushable) {
    ((Flushable)jsOutput).flush();
  }
  return errCode;
}","/** 
 * Parses command-line arguments and runs the compiler.
 * @return system exit status
 */
protected int doRun() throws FlagUsageException, IOException {
  Compiler.setLoggingLevel(Level.parse(config.loggingLevel));
  List<SourceFile> externs=createExterns();
  compiler=createCompiler();
  B options=createOptions();
  List<JSModule> modules=null;
  Result result=null;
  setRunOptions(options);
  boolean writeOutputToFile=!config.jsOutputFile.isEmpty();
  List<String> outputFileNames=Lists.newArrayList();
  if (writeOutputToFile) {
    outputFileNames.add(config.jsOutputFile);
  }
  List<String> jsFiles=config.js;
  List<String> moduleSpecs=config.module;
  boolean createCommonJsModules=false;
  if (options.processCommonJSModules) {
    if (moduleSpecs.size() == 1 && ""String_Node_Str"".equals(moduleSpecs.get(0))) {
      createCommonJsModules=true;
      moduleSpecs.remove(0);
    }
  }
  if (!moduleSpecs.isEmpty()) {
    modules=createJsModules(moduleSpecs,jsFiles);
    for (    JSModule m : modules) {
      outputFileNames.add(getModuleOutputFileName(m));
    }
    if (config.skipNormalOutputs) {
      compiler.initModules(externs,modules,options);
    }
 else {
      result=compiler.compileModules(externs,modules,options);
    }
  }
 else {
    List<SourceFile> inputs=createSourceInputs(jsFiles);
    if (config.skipNormalOutputs) {
      compiler.init(externs,inputs,options);
    }
 else {
      result=compiler.compile(externs,inputs,options);
    }
  }
  if (createCommonJsModules) {
    modules=Lists.newArrayList(compiler.getDegenerateModuleGraph().getAllModules());
    for (    JSModule m : modules) {
      outputFileNames.add(getModuleOutputFileName(m));
    }
  }
  for (  String outputFileName : outputFileNames) {
    if (compiler.getSourceFileByName(outputFileName) != null) {
      compiler.report(JSError.make(OUTPUT_SAME_AS_INPUT_ERROR,outputFileName));
      return 1;
    }
  }
  return processResults(result,modules,options);
}",0.9299905392620624
27854,"AbstractCommandLineRunner(PrintStream out,PrintStream err){
  this.config=new CommandLineConfig();
  this.jsOutput=Preconditions.checkNotNull(out);
  this.err=Preconditions.checkNotNull(err);
}","AbstractCommandLineRunner(PrintStream out,PrintStream err){
  this.config=new CommandLineConfig();
  this.defaultJsOutput=Preconditions.checkNotNull(out);
  this.err=Preconditions.checkNotNull(err);
}",0.9770992366412212
27855,"/** 
 * Processes the results of the compile job, and returns an error code.
 */
int processResults(Result result,List<JSModule> modules,B options) throws FlagUsageException, IOException {
  if (config.printPassGraph) {
    if (compiler.getRoot() == null) {
      return 1;
    }
 else {
      jsOutput.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph()));
      jsOutput.append('\n');
      return 0;
    }
  }
  if (config.printAst) {
    if (compiler.getRoot() == null) {
      return 1;
    }
 else {
      ControlFlowGraph<Node> cfg=compiler.computeCFG();
      DotFormatter.appendDot(compiler.getRoot().getLastChild(),cfg,jsOutput);
      jsOutput.append('\n');
      return 0;
    }
  }
  if (config.printTree) {
    if (compiler.getRoot() == null) {
      jsOutput.append(""String_Node_Str"");
      return 1;
    }
 else {
      compiler.getRoot().appendStringTree(jsOutput);
      jsOutput.append(""String_Node_Str"");
      return 0;
    }
  }
  rootRelativePathsMap=constructRootRelativePathsMap();
  if (config.skipNormalOutputs) {
    outputManifest();
    outputBundle();
    outputModuleGraphJson();
    return 0;
  }
 else   if (result.success) {
    outputModuleGraphJson();
    if (modules == null) {
      outputSingleBinary();
      outputSourceMap(options,config.jsOutputFile);
    }
 else {
      outputModuleBinaryAndSourceMaps(modules,options);
    }
    if (options.externExportsPath != null) {
      Writer eeOut=openExternExportsStream(options,config.jsOutputFile);
      eeOut.append(result.externExport);
      eeOut.close();
    }
    outputNameMaps();
    outputManifest();
    outputBundle();
  }
  return Math.min(result.errors.length,0x7f);
}","/** 
 * Processes the results of the compile job, and returns an error code.
 */
int processResults(Result result,List<JSModule> modules,B options) throws FlagUsageException, IOException {
  if (config.printPassGraph) {
    if (compiler.getRoot() == null) {
      return 1;
    }
 else {
      Appendable jsOutput=createDefaultOutput();
      jsOutput.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph()));
      jsOutput.append('\n');
      closeAppendable(jsOutput);
      return 0;
    }
  }
  if (config.printAst) {
    if (compiler.getRoot() == null) {
      return 1;
    }
 else {
      Appendable jsOutput=createDefaultOutput();
      ControlFlowGraph<Node> cfg=compiler.computeCFG();
      DotFormatter.appendDot(compiler.getRoot().getLastChild(),cfg,jsOutput);
      jsOutput.append('\n');
      closeAppendable(jsOutput);
      return 0;
    }
  }
  if (config.printTree) {
    if (compiler.getRoot() == null) {
      compiler.report(JSError.make(NO_TREE_GENERATED_ERROR));
      return 1;
    }
 else {
      Appendable jsOutput=createDefaultOutput();
      compiler.getRoot().appendStringTree(jsOutput);
      jsOutput.append(""String_Node_Str"");
      closeAppendable(jsOutput);
      return 0;
    }
  }
  rootRelativePathsMap=constructRootRelativePathsMap();
  if (config.skipNormalOutputs) {
    outputManifest();
    outputBundle();
    outputModuleGraphJson();
    return 0;
  }
 else   if (result.success) {
    outputModuleGraphJson();
    if (modules == null) {
      outputSingleBinary();
      outputSourceMap(options,config.jsOutputFile);
    }
 else {
      outputModuleBinaryAndSourceMaps(modules,options);
    }
    if (options.externExportsPath != null) {
      Writer eeOut=openExternExportsStream(options,config.jsOutputFile);
      eeOut.append(result.externExport);
      eeOut.close();
    }
    outputNameMaps();
    outputManifest();
    outputBundle();
  }
  return Math.min(result.errors.length,0x7f);
}",0.8687534321801208
27856,"/** 
 * Creates a file containing the current module graph in JSON serialization.
 */
private void outputModuleGraphJson() throws IOException {
  if (config.outputModuleDependencies != null && config.outputModuleDependencies != ""String_Node_Str"") {
    Writer out=fileNameToOutputWriter2(config.outputModuleDependencies);
    printModuleGraphJsonTo(out);
    out.close();
  }
}","/** 
 * Creates a file containing the current module graph in JSON serialization.
 */
private void outputModuleGraphJson() throws IOException {
  if (config.outputModuleDependencies != null && config.outputModuleDependencies.length() != 0) {
    Writer out=fileNameToOutputWriter2(config.outputModuleDependencies);
    printModuleGraphJsonTo(out);
    out.close();
  }
}",0.6746987951807228
27857,"private Appendable createDefaultOutput() throws IOException {
  boolean writeOutputToFile=!config.jsOutputFile.isEmpty();
  File test=new File(config.jsOutputFile);
  if (writeOutputToFile) {
    return fileNameToLegacyOutputWriter(config.jsOutputFile);
  }
 else {
    return streamToLegacyOutputWriter(defaultJsOutput);
  }
}","private Appendable createDefaultOutput() throws IOException {
  boolean writeOutputToFile=!config.jsOutputFile.isEmpty();
  if (writeOutputToFile) {
    return fileNameToLegacyOutputWriter(config.jsOutputFile);
  }
 else {
    return streamToLegacyOutputWriter(defaultJsOutput);
  }
}",0.6382978723404256
27858,"void add(Node n,Context context){
  if (!cc.continueProcessing()) {
    return;
  }
  int type=n.getType();
  String opstr=NodeUtil.opToStr(type);
  int childCount=n.getChildCount();
  Node first=n.getFirstChild();
  Node last=n.getLastChild();
  if (opstr != null && first != last) {
    Preconditions.checkState(childCount == 2,""String_Node_Str"",opstr,childCount);
    int p=NodeUtil.precedence(type);
    Context rhsContext=getContextForNoInOperator(context);
    if (last.getType() == type && NodeUtil.isAssociative(type)) {
      addExpr(first,p,context);
      cc.addOp(opstr,true);
      addExpr(last,p,rhsContext);
    }
 else     if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
      addExpr(first,p,context);
      cc.addOp(opstr,true);
      addExpr(last,p,rhsContext);
    }
 else {
      unrollBinaryOperator(n,type,opstr,context,rhsContext,p,p + 1);
    }
    return;
  }
  cc.startSourceMapping(n);
switch (type) {
case Token.TRY:
{
      Preconditions.checkState(first.getNext().isBlock() && !first.getNext().hasMoreThanOneChild());
      Preconditions.checkState(childCount >= 2 && childCount <= 3);
      add(""String_Node_Str"");
      add(first,Context.PRESERVE_BLOCK);
      Node catchblock=first.getNext().getFirstChild();
      if (catchblock != null) {
        add(catchblock);
      }
      if (childCount == 3) {
        add(""String_Node_Str"");
        add(last,Context.PRESERVE_BLOCK);
      }
      break;
    }
case Token.CATCH:
  Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(last,Context.PRESERVE_BLOCK);
break;
case Token.THROW:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
add(first);
cc.endStatement(true);
break;
case Token.RETURN:
add(""String_Node_Str"");
if (childCount == 1) {
add(first);
}
 else {
Preconditions.checkState(childCount == 0);
}
cc.endStatement();
break;
case Token.VAR:
if (first != null) {
add(""String_Node_Str"");
addList(first,false,getContextForNoInOperator(context));
}
break;
case Token.LABEL_NAME:
Preconditions.checkState(!n.getString().isEmpty());
addIdentifier(n.getString());
break;
case Token.NAME:
if (first == null || first.isEmpty()) {
addIdentifier(n.getString());
}
 else {
Preconditions.checkState(childCount == 1);
addIdentifier(n.getString());
cc.addOp(""String_Node_Str"",true);
if (first.isComma()) {
addExpr(first,NodeUtil.precedence(Token.ASSIGN),Context.OTHER);
}
 else {
addExpr(first,0,getContextForNoInOperator(context));
}
}
break;
case Token.ARRAYLIT:
add(""String_Node_Str"");
addArrayList(first);
add(""String_Node_Str"");
break;
case Token.PARAM_LIST:
add(""String_Node_Str"");
addList(first);
add(""String_Node_Str"");
break;
case Token.COMMA:
Preconditions.checkState(childCount == 2);
unrollBinaryOperator(n,Token.COMMA,""String_Node_Str"",context,getContextForNoInOperator(context),0,0);
break;
case Token.NUMBER:
Preconditions.checkState(childCount == 0);
cc.addNumber(n.getDouble());
break;
case Token.TYPEOF:
case Token.VOID:
case Token.NOT:
case Token.BITNOT:
case Token.POS:
{
Preconditions.checkState(childCount == 1);
cc.addOp(NodeUtil.opToStrNoFail(type),false);
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
break;
}
case Token.NEG:
{
Preconditions.checkState(childCount == 1);
if (n.getFirstChild().isNumber()) {
cc.addNumber(-n.getFirstChild().getDouble());
}
 else {
cc.addOp(NodeUtil.opToStrNoFail(type),false);
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
}
break;
}
case Token.HOOK:
{
Preconditions.checkState(childCount == 3);
int p=NodeUtil.precedence(type);
Context rhsContext=getContextForNoInOperator(context);
addExpr(first,p + 1,context);
cc.addOp(""String_Node_Str"",true);
addExpr(first.getNext(),1,rhsContext);
cc.addOp(""String_Node_Str"",true);
addExpr(last,1,rhsContext);
break;
}
case Token.REGEXP:
if (!first.isString() || !last.isString()) {
throw new Error(""String_Node_Str"");
}
String regexp=regexpEscape(first.getString(),outputCharsetEncoder);
if (childCount == 2) {
add(regexp + last.getString());
}
 else {
Preconditions.checkState(childCount == 1);
add(regexp);
}
break;
case Token.FUNCTION:
if (n.getClass() != Node.class) {
throw new Error(""String_Node_Str"");
}
Preconditions.checkState(childCount == 3);
boolean funcNeedsParens=(context == Context.START_OF_EXPR);
if (funcNeedsParens) {
add(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
add(first.getNext());
add(last,Context.PRESERVE_BLOCK);
cc.endFunction(context == Context.STATEMENT);
if (funcNeedsParens) {
add(""String_Node_Str"");
}
break;
case Token.GETTER_DEF:
case Token.SETTER_DEF:
Preconditions.checkState(n.getParent().isObjectLit());
Preconditions.checkState(childCount == 1);
Preconditions.checkState(first.isFunction());
Preconditions.checkState(first.getFirstChild().getString().isEmpty());
if (type == Token.GETTER_DEF) {
Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
add(""String_Node_Str"");
}
 else {
Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
add(""String_Node_Str"");
}
String name=n.getString();
Node fn=first;
Node parameters=fn.getChildAtIndex(1);
Node body=fn.getLastChild();
if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) && NodeUtil.isLatin(name)) {
add(name);
}
 else {
double d=getSimpleNumber(name);
if (!Double.isNaN(d)) {
cc.addNumber(d);
}
 else {
addJsString(n);
}
}
add(parameters);
add(body,Context.PRESERVE_BLOCK);
break;
case Token.SCRIPT:
case Token.BLOCK:
{
if (n.getClass() != Node.class) {
throw new Error(""String_Node_Str"");
}
boolean preserveBlock=context == Context.PRESERVE_BLOCK;
if (preserveBlock) {
cc.beginBlock();
}
boolean preferLineBreaks=type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().isScript());
for (Node c=first; c != null; c=c.getNext()) {
add(c,Context.STATEMENT);
if (c.isVar()) {
cc.endStatement();
}
if (c.isFunction()) {
cc.maybeLineBreak();
}
if (preferLineBreaks) {
cc.notePreferredLineBreak();
}
}
if (preserveBlock) {
cc.endBlock(cc.breakAfterBlockFor(n,context == Context.STATEMENT));
}
break;
}
case Token.FOR:
if (childCount == 4) {
add(""String_Node_Str"");
if (first.isVar()) {
add(first,Context.IN_FOR_INIT_CLAUSE);
}
 else {
addExpr(first,0,Context.IN_FOR_INIT_CLAUSE);
}
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
add(first.getNext().getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
 else {
Preconditions.checkState(childCount == 3);
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
break;
case Token.DO:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
addNonEmptyStatement(first,Context.OTHER,false);
add(""String_Node_Str"");
add(last);
add(""String_Node_Str"");
cc.endStatement();
break;
case Token.WHILE:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case Token.EMPTY:
Preconditions.checkState(childCount == 0);
break;
case Token.GETPROP:
{
Preconditions.checkState(childCount == 2,""String_Node_Str"",childCount);
Preconditions.checkState(last.isString(),""String_Node_Str"");
boolean needsParens=(first.isNumber());
if (needsParens) {
add(""String_Node_Str"");
}
addExpr(first,NodeUtil.precedence(type),context);
if (needsParens) {
add(""String_Node_Str"");
}
if (this.languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(last.getString())) {
add(""String_Node_Str"");
add(last);
add(""String_Node_Str"");
}
 else {
add(""String_Node_Str"");
addIdentifier(last.getString());
}
break;
}
case Token.GETELEM:
Preconditions.checkState(childCount == 2,""String_Node_Str"",childCount);
addExpr(first,NodeUtil.precedence(type),context);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
break;
case Token.WITH:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case Token.INC:
case Token.DEC:
{
Preconditions.checkState(childCount == 1);
String o=type == Token.INC ? ""String_Node_Str"" : ""String_Node_Str"";
int postProp=n.getIntProp(Node.INCRDECR_PROP);
if (postProp != 0) {
addExpr(first,NodeUtil.precedence(type),context);
cc.addOp(o,false);
}
 else {
cc.addOp(o,false);
add(first);
}
break;
}
case Token.CALL:
if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
add(""String_Node_Str"");
addExpr(first,NodeUtil.precedence(Token.COMMA),Context.OTHER);
add(""String_Node_Str"");
}
 else {
addExpr(first,NodeUtil.precedence(type),context);
}
add(""String_Node_Str"");
addList(first.getNext());
add(""String_Node_Str"");
break;
case Token.IF:
boolean hasElse=childCount == 3;
boolean ambiguousElseClause=context == Context.BEFORE_DANGLING_ELSE && !hasElse;
if (ambiguousElseClause) {
cc.beginBlock();
}
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
if (hasElse) {
addNonEmptyStatement(first.getNext(),Context.BEFORE_DANGLING_ELSE,false);
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
 else {
addNonEmptyStatement(first.getNext(),Context.OTHER,false);
Preconditions.checkState(childCount == 2);
}
if (ambiguousElseClause) {
cc.endBlock();
}
break;
case Token.NULL:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case Token.THIS:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
break;
case Token.FALSE:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case Token.TRUE:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case Token.CONTINUE:
Preconditions.checkState(childCount <= 1);
add(""String_Node_Str"");
if (childCount == 1) {
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
}
cc.endStatement();
break;
case Token.DEBUGGER:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
cc.endStatement();
break;
case Token.BREAK:
Preconditions.checkState(childCount <= 1);
add(""String_Node_Str"");
if (childCount == 1) {
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
}
cc.endStatement();
break;
case Token.EXPR_RESULT:
Preconditions.checkState(childCount == 1);
add(first,Context.START_OF_EXPR);
cc.endStatement();
break;
case Token.NEW:
add(""String_Node_Str"");
int precedence=NodeUtil.precedence(type);
if (NodeUtil.containsType(first,Token.CALL,NodeUtil.MATCH_NOT_FUNCTION)) {
precedence=NodeUtil.precedence(first.getType()) + 1;
}
addExpr(first,precedence,Context.OTHER);
Node next=first.getNext();
if (next != null) {
add(""String_Node_Str"");
addList(next);
add(""String_Node_Str"");
}
break;
case Token.STRING_KEY:
Preconditions.checkState(childCount == 1,""String_Node_Str"");
addJsString(n);
break;
case Token.STRING:
Preconditions.checkState(childCount == 0,""String_Node_Str"");
addJsString(n);
break;
case Token.DELPROP:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
add(first);
break;
case Token.OBJECTLIT:
{
boolean needsParens=(context == Context.START_OF_EXPR);
if (needsParens) {
add(""String_Node_Str"");
}
add(""String_Node_Str"");
for (Node c=first; c != null; c=c.getNext()) {
if (c != first) {
cc.listSeparator();
}
if (c.isGetterDef() || c.isSetterDef()) {
add(c);
}
 else {
Preconditions.checkState(c.isStringKey());
String key=c.getString();
if (!c.isQuotedString() && !(languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(key)) && TokenStream.isJSIdentifier(key)&& NodeUtil.isLatin(key)) {
add(key);
}
 else {
double d=getSimpleNumber(key);
if (!Double.isNaN(d)) {
cc.addNumber(d);
}
 else {
addExpr(c,1,Context.OTHER);
}
}
add(""String_Node_Str"");
addExpr(c.getFirstChild(),1,Context.OTHER);
}
}
add(""String_Node_Str"");
if (needsParens) {
add(""String_Node_Str"");
}
break;
}
case Token.SWITCH:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
cc.beginBlock();
addAllSiblings(first.getNext());
cc.endBlock(context == Context.STATEMENT);
break;
case Token.CASE:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
add(first);
addCaseBody(last);
break;
case Token.DEFAULT_CASE:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
addCaseBody(first);
break;
case Token.LABEL:
Preconditions.checkState(childCount == 2);
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(first);
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),true);
break;
case Token.CAST:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
break;
default :
throw new Error(""String_Node_Str"" + type + ""String_Node_Str""+ n.toStringTree());
}
cc.endSourceMapping(n);
}","void add(Node n,Context context){
  if (!cc.continueProcessing()) {
    return;
  }
  int type=n.getType();
  String opstr=NodeUtil.opToStr(type);
  int childCount=n.getChildCount();
  Node first=n.getFirstChild();
  Node last=n.getLastChild();
  if (opstr != null && first != last) {
    Preconditions.checkState(childCount == 2,""String_Node_Str"",opstr,childCount);
    int p=NodeUtil.precedence(type);
    Context rhsContext=getContextForNoInOperator(context);
    if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
      addExpr(first,p,context);
      cc.addOp(opstr,true);
      addExpr(last,p,rhsContext);
    }
 else {
      unrollBinaryOperator(n,type,opstr,context,rhsContext,p,p + 1);
    }
    return;
  }
  cc.startSourceMapping(n);
switch (type) {
case Token.TRY:
{
      Preconditions.checkState(first.getNext().isBlock() && !first.getNext().hasMoreThanOneChild());
      Preconditions.checkState(childCount >= 2 && childCount <= 3);
      add(""String_Node_Str"");
      add(first,Context.PRESERVE_BLOCK);
      Node catchblock=first.getNext().getFirstChild();
      if (catchblock != null) {
        add(catchblock);
      }
      if (childCount == 3) {
        add(""String_Node_Str"");
        add(last,Context.PRESERVE_BLOCK);
      }
      break;
    }
case Token.CATCH:
  Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(last,Context.PRESERVE_BLOCK);
break;
case Token.THROW:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
add(first);
cc.endStatement(true);
break;
case Token.RETURN:
add(""String_Node_Str"");
if (childCount == 1) {
add(first);
}
 else {
Preconditions.checkState(childCount == 0);
}
cc.endStatement();
break;
case Token.VAR:
if (first != null) {
add(""String_Node_Str"");
addList(first,false,getContextForNoInOperator(context));
}
break;
case Token.LABEL_NAME:
Preconditions.checkState(!n.getString().isEmpty());
addIdentifier(n.getString());
break;
case Token.NAME:
if (first == null || first.isEmpty()) {
addIdentifier(n.getString());
}
 else {
Preconditions.checkState(childCount == 1);
addIdentifier(n.getString());
cc.addOp(""String_Node_Str"",true);
if (first.isComma()) {
addExpr(first,NodeUtil.precedence(Token.ASSIGN),Context.OTHER);
}
 else {
addExpr(first,0,getContextForNoInOperator(context));
}
}
break;
case Token.ARRAYLIT:
add(""String_Node_Str"");
addArrayList(first);
add(""String_Node_Str"");
break;
case Token.PARAM_LIST:
add(""String_Node_Str"");
addList(first);
add(""String_Node_Str"");
break;
case Token.COMMA:
Preconditions.checkState(childCount == 2);
unrollBinaryOperator(n,Token.COMMA,""String_Node_Str"",context,getContextForNoInOperator(context),0,0);
break;
case Token.NUMBER:
Preconditions.checkState(childCount == 0);
cc.addNumber(n.getDouble());
break;
case Token.TYPEOF:
case Token.VOID:
case Token.NOT:
case Token.BITNOT:
case Token.POS:
{
Preconditions.checkState(childCount == 1);
cc.addOp(NodeUtil.opToStrNoFail(type),false);
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
break;
}
case Token.NEG:
{
Preconditions.checkState(childCount == 1);
if (n.getFirstChild().isNumber()) {
cc.addNumber(-n.getFirstChild().getDouble());
}
 else {
cc.addOp(NodeUtil.opToStrNoFail(type),false);
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
}
break;
}
case Token.HOOK:
{
Preconditions.checkState(childCount == 3);
int p=NodeUtil.precedence(type);
Context rhsContext=getContextForNoInOperator(context);
addExpr(first,p + 1,context);
cc.addOp(""String_Node_Str"",true);
addExpr(first.getNext(),1,rhsContext);
cc.addOp(""String_Node_Str"",true);
addExpr(last,1,rhsContext);
break;
}
case Token.REGEXP:
if (!first.isString() || !last.isString()) {
throw new Error(""String_Node_Str"");
}
String regexp=regexpEscape(first.getString(),outputCharsetEncoder);
if (childCount == 2) {
add(regexp + last.getString());
}
 else {
Preconditions.checkState(childCount == 1);
add(regexp);
}
break;
case Token.FUNCTION:
if (n.getClass() != Node.class) {
throw new Error(""String_Node_Str"");
}
Preconditions.checkState(childCount == 3);
boolean funcNeedsParens=(context == Context.START_OF_EXPR);
if (funcNeedsParens) {
add(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
add(first.getNext());
add(last,Context.PRESERVE_BLOCK);
cc.endFunction(context == Context.STATEMENT);
if (funcNeedsParens) {
add(""String_Node_Str"");
}
break;
case Token.GETTER_DEF:
case Token.SETTER_DEF:
Preconditions.checkState(n.getParent().isObjectLit());
Preconditions.checkState(childCount == 1);
Preconditions.checkState(first.isFunction());
Preconditions.checkState(first.getFirstChild().getString().isEmpty());
if (type == Token.GETTER_DEF) {
Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
add(""String_Node_Str"");
}
 else {
Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
add(""String_Node_Str"");
}
String name=n.getString();
Node fn=first;
Node parameters=fn.getChildAtIndex(1);
Node body=fn.getLastChild();
if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) && NodeUtil.isLatin(name)) {
add(name);
}
 else {
double d=getSimpleNumber(name);
if (!Double.isNaN(d)) {
cc.addNumber(d);
}
 else {
addJsString(n);
}
}
add(parameters);
add(body,Context.PRESERVE_BLOCK);
break;
case Token.SCRIPT:
case Token.BLOCK:
{
if (n.getClass() != Node.class) {
throw new Error(""String_Node_Str"");
}
boolean preserveBlock=context == Context.PRESERVE_BLOCK;
if (preserveBlock) {
cc.beginBlock();
}
boolean preferLineBreaks=type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().isScript());
for (Node c=first; c != null; c=c.getNext()) {
add(c,Context.STATEMENT);
if (c.isVar()) {
cc.endStatement();
}
if (c.isFunction()) {
cc.maybeLineBreak();
}
if (preferLineBreaks) {
cc.notePreferredLineBreak();
}
}
if (preserveBlock) {
cc.endBlock(cc.breakAfterBlockFor(n,context == Context.STATEMENT));
}
break;
}
case Token.FOR:
if (childCount == 4) {
add(""String_Node_Str"");
if (first.isVar()) {
add(first,Context.IN_FOR_INIT_CLAUSE);
}
 else {
addExpr(first,0,Context.IN_FOR_INIT_CLAUSE);
}
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
add(first.getNext().getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
 else {
Preconditions.checkState(childCount == 3);
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
break;
case Token.DO:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
addNonEmptyStatement(first,Context.OTHER,false);
add(""String_Node_Str"");
add(last);
add(""String_Node_Str"");
cc.endStatement();
break;
case Token.WHILE:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case Token.EMPTY:
Preconditions.checkState(childCount == 0);
break;
case Token.GETPROP:
{
Preconditions.checkState(childCount == 2,""String_Node_Str"",childCount);
Preconditions.checkState(last.isString(),""String_Node_Str"");
boolean needsParens=(first.isNumber());
if (needsParens) {
add(""String_Node_Str"");
}
addExpr(first,NodeUtil.precedence(type),context);
if (needsParens) {
add(""String_Node_Str"");
}
if (this.languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(last.getString())) {
add(""String_Node_Str"");
add(last);
add(""String_Node_Str"");
}
 else {
add(""String_Node_Str"");
addIdentifier(last.getString());
}
break;
}
case Token.GETELEM:
Preconditions.checkState(childCount == 2,""String_Node_Str"",childCount);
addExpr(first,NodeUtil.precedence(type),context);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
break;
case Token.WITH:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case Token.INC:
case Token.DEC:
{
Preconditions.checkState(childCount == 1);
String o=type == Token.INC ? ""String_Node_Str"" : ""String_Node_Str"";
int postProp=n.getIntProp(Node.INCRDECR_PROP);
if (postProp != 0) {
addExpr(first,NodeUtil.precedence(type),context);
cc.addOp(o,false);
}
 else {
cc.addOp(o,false);
add(first);
}
break;
}
case Token.CALL:
if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
add(""String_Node_Str"");
addExpr(first,NodeUtil.precedence(Token.COMMA),Context.OTHER);
add(""String_Node_Str"");
}
 else {
addExpr(first,NodeUtil.precedence(type),context);
}
add(""String_Node_Str"");
addList(first.getNext());
add(""String_Node_Str"");
break;
case Token.IF:
boolean hasElse=childCount == 3;
boolean ambiguousElseClause=context == Context.BEFORE_DANGLING_ELSE && !hasElse;
if (ambiguousElseClause) {
cc.beginBlock();
}
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
if (hasElse) {
addNonEmptyStatement(first.getNext(),Context.BEFORE_DANGLING_ELSE,false);
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
 else {
addNonEmptyStatement(first.getNext(),Context.OTHER,false);
Preconditions.checkState(childCount == 2);
}
if (ambiguousElseClause) {
cc.endBlock();
}
break;
case Token.NULL:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case Token.THIS:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
break;
case Token.FALSE:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case Token.TRUE:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case Token.CONTINUE:
Preconditions.checkState(childCount <= 1);
add(""String_Node_Str"");
if (childCount == 1) {
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
}
cc.endStatement();
break;
case Token.DEBUGGER:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
cc.endStatement();
break;
case Token.BREAK:
Preconditions.checkState(childCount <= 1);
add(""String_Node_Str"");
if (childCount == 1) {
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
}
cc.endStatement();
break;
case Token.EXPR_RESULT:
Preconditions.checkState(childCount == 1);
add(first,Context.START_OF_EXPR);
cc.endStatement();
break;
case Token.NEW:
add(""String_Node_Str"");
int precedence=NodeUtil.precedence(type);
if (NodeUtil.containsType(first,Token.CALL,NodeUtil.MATCH_NOT_FUNCTION)) {
precedence=NodeUtil.precedence(first.getType()) + 1;
}
addExpr(first,precedence,Context.OTHER);
Node next=first.getNext();
if (next != null) {
add(""String_Node_Str"");
addList(next);
add(""String_Node_Str"");
}
break;
case Token.STRING_KEY:
Preconditions.checkState(childCount == 1,""String_Node_Str"");
addJsString(n);
break;
case Token.STRING:
Preconditions.checkState(childCount == 0,""String_Node_Str"");
addJsString(n);
break;
case Token.DELPROP:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
add(first);
break;
case Token.OBJECTLIT:
{
boolean needsParens=(context == Context.START_OF_EXPR);
if (needsParens) {
add(""String_Node_Str"");
}
add(""String_Node_Str"");
for (Node c=first; c != null; c=c.getNext()) {
if (c != first) {
cc.listSeparator();
}
if (c.isGetterDef() || c.isSetterDef()) {
add(c);
}
 else {
Preconditions.checkState(c.isStringKey());
String key=c.getString();
if (!c.isQuotedString() && !(languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(key)) && TokenStream.isJSIdentifier(key)&& NodeUtil.isLatin(key)) {
add(key);
}
 else {
double d=getSimpleNumber(key);
if (!Double.isNaN(d)) {
cc.addNumber(d);
}
 else {
addExpr(c,1,Context.OTHER);
}
}
add(""String_Node_Str"");
addExpr(c.getFirstChild(),1,Context.OTHER);
}
}
add(""String_Node_Str"");
if (needsParens) {
add(""String_Node_Str"");
}
break;
}
case Token.SWITCH:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
cc.beginBlock();
addAllSiblings(first.getNext());
cc.endBlock(context == Context.STATEMENT);
break;
case Token.CASE:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
add(first);
addCaseBody(last);
break;
case Token.DEFAULT_CASE:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
addCaseBody(first);
break;
case Token.LABEL:
Preconditions.checkState(childCount == 2);
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(first);
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),true);
break;
case Token.CAST:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
break;
default :
throw new Error(""String_Node_Str"" + type + ""String_Node_Str""+ n.toStringTree());
}
cc.endSourceMapping(n);
}",0.9933094756496031
27859,"/** 
 * Tries apply our various peephole minimizations on the passed in node.
 */
@Override @SuppressWarnings(""String_Node_Str"") public Node optimizeSubtree(Node node){
switch (node.getType()) {
case Token.TRUE:
case Token.FALSE:
    return reduceTrueFalse(node);
case Token.NEW:
  node=tryFoldStandardConstructors(node);
if (!node.isCall()) {
  return node;
}
case Token.CALL:
Node result=tryFoldLiteralConstructor(node);
if (result == node) {
result=tryFoldSimpleFunctionCall(node);
if (result == node) {
result=tryFoldImmediateCallToBoundFunction(node);
}
}
return result;
case Token.RETURN:
return tryReduceReturn(node);
case Token.COMMA:
return trySplitComma(node);
case Token.NAME:
return tryReplaceUndefined(node);
case Token.ARRAYLIT:
return tryMinimizeArrayLiteral(node);
default :
return node;
}
}","/** 
 * Tries apply our various peephole minimizations on the passed in node.
 */
@Override @SuppressWarnings(""String_Node_Str"") public Node optimizeSubtree(Node node){
switch (node.getType()) {
case Token.TRUE:
case Token.FALSE:
    return reduceTrueFalse(node);
case Token.NEW:
  node=tryFoldStandardConstructors(node);
if (!node.isCall()) {
  return node;
}
case Token.CALL:
Node result=tryFoldLiteralConstructor(node);
if (result == node) {
result=tryFoldSimpleFunctionCall(node);
if (result == node) {
result=tryFoldImmediateCallToBoundFunction(node);
}
}
return result;
case Token.RETURN:
return tryReduceReturn(node);
case Token.COMMA:
return trySplitComma(node);
case Token.NAME:
return tryReplaceUndefined(node);
case Token.ARRAYLIT:
return tryMinimizeArrayLiteral(node);
case Token.MUL:
case Token.AND:
case Token.OR:
case Token.BITOR:
case Token.BITXOR:
case Token.BITAND:
return tryRotateAssociativeOperator(node);
default :
return node;
}
}",0.9170454545454544
27860,"/** 
 * After a struct object is created, we can't add new properties to it, with one exception. We allow creation of ""static"" properties like Foo.prototype.bar = baz; where Foo.prototype is a struct, if the assignment happens at the top level and the constructor Foo is defined in the same file.
 */
private void checkPropCreation(NodeTraversal t,Node lvalue){
  if (lvalue.isGetProp()) {
    Node obj=lvalue.getFirstChild();
    Node prop=lvalue.getLastChild();
    JSType objType=getJSType(obj);
    String pname=prop.getString();
    if (!objType.isStruct() || objType.hasProperty(pname)) {
      return;
    }
    Scope s=t.getScope();
    if (obj.isThis() && getJSType(s.getRootNode()).isConstructor()) {
      return;
    }
    Node assgnExp=lvalue.getParent();
    Node assgnStm=assgnExp.getParent();
    if (objType instanceof ObjectType && s.isGlobal() && NodeUtil.isPrototypePropertyDeclaration(assgnStm)) {
      ObjectType instance=objType.toObjectType().getOwnerFunction().getInstanceType();
      String file=lvalue.getSourceFileName();
      Node ctor=instance.getConstructor().getSource();
      if (ctor != null && ctor.getSourceFileName().equals(file)) {
        JSType rvalueType=assgnExp.getLastChild().getJSType();
        instance.defineInferredProperty(pname,rvalueType,lvalue);
        return;
      }
    }
    report(t,prop,ILLEGAL_PROPERTY_CREATION);
  }
}","private void checkPropCreation(NodeTraversal t,Node lvalue){
  if (lvalue.isGetProp()) {
    JSType objType=getJSType(lvalue.getFirstChild());
    Node prop=lvalue.getLastChild();
    if (objType.isStruct() && !objType.hasProperty(prop.getString())) {
      report(t,prop,ILLEGAL_PROPERTY_CREATION);
    }
  }
}",0.0979351032448377
27861,"/** 
 * Defines a property if the property has not been defined yet.
 */
private void ensurePropertyDefined(Node getprop,JSType rightType){
  String propName=getprop.getLastChild().getString();
  Node obj=getprop.getFirstChild();
  JSType nodeType=getJSType(obj);
  ObjectType objectType=ObjectType.cast(nodeType.restrictByNotNullOrUndefined());
  if (objectType == null) {
    registry.registerPropertyOnType(propName,nodeType);
  }
 else {
    if (nodeType.isStruct() && !objectType.hasProperty(propName)) {
      if (!(obj.isThis() && getJSType(syntacticScope.getRootNode()).isConstructor())) {
        return;
      }
    }
    if (ensurePropertyDeclaredHelper(getprop,objectType)) {
      return;
    }
    if (!objectType.isPropertyTypeDeclared(propName)) {
      if (objectType.hasProperty(propName) || !objectType.isInstanceType()) {
        if (""String_Node_Str"".equals(propName)) {
          objectType.defineDeclaredProperty(propName,rightType,getprop);
        }
 else {
          objectType.defineInferredProperty(propName,rightType,getprop);
        }
      }
 else       if (obj.isThis() && getJSType(syntacticScope.getRootNode()).isConstructor()) {
        objectType.defineInferredProperty(propName,rightType,getprop);
      }
 else {
        registry.registerPropertyOnType(propName,objectType);
      }
    }
  }
}","/** 
 * Defines a property if the property has not been defined yet.
 */
private void ensurePropertyDefined(Node getprop,JSType rightType){
  String propName=getprop.getLastChild().getString();
  Node obj=getprop.getFirstChild();
  JSType nodeType=getJSType(obj);
  ObjectType objectType=ObjectType.cast(nodeType.restrictByNotNullOrUndefined());
  boolean propCreationInConstructor=obj.isThis() && getJSType(syntacticScope.getRootNode()).isConstructor();
  if (objectType == null) {
    registry.registerPropertyOnType(propName,nodeType);
  }
 else {
    if (nodeType.isStruct() && !objectType.hasProperty(propName)) {
      boolean staticPropCreation=false;
      Node maybeAssignStm=getprop.getParent().getParent();
      if (syntacticScope.isGlobal() && NodeUtil.isPrototypePropertyDeclaration(maybeAssignStm)) {
        String propCreationFilename=maybeAssignStm.getSourceFileName();
        Node ctor=objectType.getOwnerFunction().getSource();
        if (ctor != null && ctor.getSourceFileName().equals(propCreationFilename)) {
          staticPropCreation=true;
        }
      }
      if (!propCreationInConstructor && !staticPropCreation) {
        return;
      }
    }
    if (ensurePropertyDeclaredHelper(getprop,objectType)) {
      return;
    }
    if (!objectType.isPropertyTypeDeclared(propName)) {
      if (objectType.hasProperty(propName) || !objectType.isInstanceType()) {
        if (""String_Node_Str"".equals(propName)) {
          objectType.defineDeclaredProperty(propName,rightType,getprop);
        }
 else {
          objectType.defineInferredProperty(propName,rightType,getprop);
        }
      }
 else       if (propCreationInConstructor) {
        objectType.defineInferredProperty(propName,rightType,getprop);
      }
 else {
        registry.registerPropertyOnType(propName,objectType);
      }
    }
  }
}",0.6740226986128626
27862,"private ThrowStatement throwStatement() throws IOException {
  if (currentToken != Token.THROW)   codeBug();
  consumeToken();
  int pos=ts.tokenBeg, lineno=ts.lineno;
  if (peekTokenOrEOL() == Token.EOL) {
    reportError(""String_Node_Str"");
  }
  AstNode expr=expr();
  ThrowStatement pn=new ThrowStatement(pos,getNodeEnd(expr),expr);
  pn.setLineno(lineno);
  return pn;
}","private ThrowStatement throwStatement() throws IOException {
  if (currentToken != Token.THROW)   codeBug();
  consumeToken();
  int pos=ts.tokenBeg, lineno=ts.lineno;
  if (peekTokenOrEOL() == Token.EOL) {
    reportError(""String_Node_Str"");
  }
  AstNode expr=expr();
  ThrowStatement pn=new ThrowStatement(pos,getNodeEnd(expr) - pos,expr);
  pn.setLineno(lineno);
  return pn;
}",0.992063492063492
27863,"/** 
 * Given a node, get a human-readable name for the type of that node so that will be easy for the programmer to find the original declaration. For example, if SubFoo's property ""bar"" might have the human-readable name ""Foo.prototype.bar"".
 * @param n The node.
 * @param dereference If true, the type of the node will be dereferencedto an Object type, if possible.
 */
String getReadableJSTypeName(Node n,boolean dereference){
  if (n.isGetProp()) {
    ObjectType objectType=getJSType(n.getFirstChild()).dereference();
    if (objectType != null) {
      String propName=n.getLastChild().getString();
      if (objectType.getConstructor() != null && objectType.getConstructor().isInterface()) {
        objectType=FunctionType.getTopDefiningInterface(objectType,propName);
      }
 else {
        while (objectType != null && !objectType.hasOwnProperty(propName)) {
          objectType=objectType.getImplicitPrototype();
        }
      }
      if (objectType != null && (objectType.getConstructor() != null || objectType.isFunctionPrototypeType())) {
        return objectType.toString() + ""String_Node_Str"" + propName;
      }
    }
  }
  JSType type=getJSType(n);
  if (dereference) {
    ObjectType dereferenced=type.dereference();
    if (dereferenced != null) {
      type=dereferenced;
    }
  }
  String qualifiedName=n.getQualifiedName();
  if (type.isFunctionPrototypeType() || (type.toObjectType() != null && type.toObjectType().getConstructor() != null)) {
    return type.toString();
  }
 else   if (qualifiedName != null) {
    return qualifiedName;
  }
 else   if (type.isFunctionType()) {
    return ""String_Node_Str"";
  }
 else {
    return type.toString();
  }
}","/** 
 * Given a node, get a human-readable name for the type of that node so that will be easy for the programmer to find the original declaration. For example, if SubFoo's property ""bar"" might have the human-readable name ""Foo.prototype.bar"".
 * @param n The node.
 * @param dereference If true, the type of the node will be dereferencedto an Object type, if possible.
 */
String getReadableJSTypeName(Node n,boolean dereference){
  JSType type=getJSType(n);
  if (dereference) {
    ObjectType dereferenced=type.dereference();
    if (dereferenced != null) {
      type=dereferenced;
    }
  }
  if (type.isFunctionPrototypeType() || (type.toObjectType() != null && type.toObjectType().getConstructor() != null)) {
    return type.toString();
  }
  if (n.isGetProp()) {
    ObjectType objectType=getJSType(n.getFirstChild()).dereference();
    if (objectType != null) {
      String propName=n.getLastChild().getString();
      if (objectType.getConstructor() != null && objectType.getConstructor().isInterface()) {
        objectType=FunctionType.getTopDefiningInterface(objectType,propName);
      }
 else {
        while (objectType != null && !objectType.hasOwnProperty(propName)) {
          objectType=objectType.getImplicitPrototype();
        }
      }
      if (objectType != null && (objectType.getConstructor() != null || objectType.isFunctionPrototypeType())) {
        return objectType.toString() + ""String_Node_Str"" + propName;
      }
    }
  }
  String qualifiedName=n.getQualifiedName();
  if (qualifiedName != null) {
    return qualifiedName;
  }
 else   if (type.isFunctionType()) {
    return ""String_Node_Str"";
  }
 else {
    return type.toString();
  }
}",0.7505938242280285
27864,"public void collect(JSModule module,Scope scope,Node n){
  Node parent=n.getParent();
  String name;
  boolean isSet=false;
  Name.Type type=Name.Type.OTHER;
  boolean isPropAssign=false;
switch (n.getType()) {
case Token.GETTER_DEF:
case Token.SETTER_DEF:
case Token.STRING_KEY:
    name=null;
  if (parent != null && parent.isObjectLit()) {
    name=getNameForObjLitKey(n);
  }
if (name == null) {
  return;
}
isSet=true;
switch (n.getType()) {
case Token.STRING_KEY:
type=getValueType(n.getFirstChild());
break;
case Token.GETTER_DEF:
type=Name.Type.GET;
break;
case Token.SETTER_DEF:
type=Name.Type.SET;
break;
default :
throw new IllegalStateException(""String_Node_Str"" + n);
}
break;
case Token.NAME:
if (parent != null) {
switch (parent.getType()) {
case Token.VAR:
isSet=true;
Node rvalue=n.getFirstChild();
type=rvalue == null ? Name.Type.OTHER : getValueType(rvalue);
break;
case Token.ASSIGN:
if (parent.getFirstChild() == n) {
isSet=true;
type=getValueType(n.getNext());
}
break;
case Token.GETPROP:
return;
case Token.FUNCTION:
Node gramps=parent.getParent();
if (gramps == null || NodeUtil.isFunctionExpression(parent)) {
return;
}
isSet=true;
type=Name.Type.FUNCTION;
break;
case Token.INC:
case Token.DEC:
isSet=true;
type=Name.Type.OTHER;
break;
default :
if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) {
isSet=true;
type=Name.Type.OTHER;
}
}
}
name=n.getString();
break;
case Token.GETPROP:
if (parent != null) {
switch (parent.getType()) {
case Token.ASSIGN:
if (parent.getFirstChild() == n) {
isSet=true;
type=getValueType(n.getNext());
isPropAssign=true;
}
break;
case Token.INC:
case Token.DEC:
isSet=true;
type=Name.Type.OTHER;
break;
case Token.GETPROP:
return;
default :
if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) {
isSet=true;
type=Name.Type.OTHER;
}
}
}
name=n.getQualifiedName();
if (name == null) {
return;
}
break;
default :
return;
}
if (!isGlobalNameReference(name,scope)) {
return;
}
if (isSet) {
if (isGlobalScope(scope)) {
handleSetFromGlobal(module,scope,n,parent,name,isPropAssign,type);
}
 else {
handleSetFromLocal(module,scope,n,parent,name);
}
}
 else {
handleGet(module,scope,n,parent,name);
}
}","public void collect(JSModule module,Scope scope,Node n){
  Node parent=n.getParent();
  String name;
  boolean isSet=false;
  Name.Type type=Name.Type.OTHER;
  boolean isPropAssign=false;
switch (n.getType()) {
case Token.GETTER_DEF:
case Token.SETTER_DEF:
case Token.STRING_KEY:
    name=null;
  if (parent != null && parent.isObjectLit()) {
    name=getNameForObjLitKey(n);
  }
if (name == null) {
  return;
}
isSet=true;
switch (n.getType()) {
case Token.STRING_KEY:
type=getValueType(n.getFirstChild());
break;
case Token.GETTER_DEF:
type=Name.Type.GET;
break;
case Token.SETTER_DEF:
type=Name.Type.SET;
break;
default :
throw new IllegalStateException(""String_Node_Str"" + n);
}
break;
case Token.NAME:
if (parent != null) {
switch (parent.getType()) {
case Token.VAR:
isSet=true;
Node rvalue=n.getFirstChild();
type=rvalue == null ? Name.Type.OTHER : getValueType(rvalue);
break;
case Token.ASSIGN:
if (parent.getFirstChild() == n) {
isSet=true;
type=getValueType(n.getNext());
}
break;
case Token.GETPROP:
return;
case Token.FUNCTION:
Node gramps=parent.getParent();
if (gramps == null || NodeUtil.isFunctionExpression(parent)) {
return;
}
isSet=true;
type=Name.Type.FUNCTION;
break;
case Token.CATCH:
case Token.INC:
case Token.DEC:
isSet=true;
type=Name.Type.OTHER;
break;
default :
if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) {
isSet=true;
type=Name.Type.OTHER;
}
}
}
name=n.getString();
break;
case Token.GETPROP:
if (parent != null) {
switch (parent.getType()) {
case Token.ASSIGN:
if (parent.getFirstChild() == n) {
isSet=true;
type=getValueType(n.getNext());
isPropAssign=true;
}
break;
case Token.INC:
case Token.DEC:
isSet=true;
type=Name.Type.OTHER;
break;
case Token.GETPROP:
return;
default :
if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) {
isSet=true;
type=Name.Type.OTHER;
}
}
}
name=n.getQualifiedName();
if (name == null) {
return;
}
break;
default :
return;
}
if (!isGlobalNameReference(name,scope)) {
return;
}
if (isSet) {
if (isGlobalScope(scope)) {
handleSetFromGlobal(module,scope,n,parent,name,isPropAssign,type);
}
 else {
handleSetFromLocal(module,scope,n,parent,name);
}
}
 else {
handleGet(module,scope,n,parent,name);
}
}",0.9958941605839416
27865,"/** 
 * Creates a JSType from the nodes representing a type.
 * @param n The node with type info.
 * @param sourceName The source file name.
 * @param scope A scope for doing type name lookups.
 */
public JSType createFromTypeNodes(Node n,String sourceName,StaticScope<JSType> scope){
  if (resolveMode == ResolveMode.LAZY_EXPRESSIONS) {
    boolean hasNames=hasTypeName(n);
    if (hasNames) {
      return new UnresolvedTypeExpression(this,n,sourceName);
    }
  }
  return createFromTypeNodesInternal(n,sourceName,scope);
}","/** 
 * Creates a JSType from the nodes representing a type.
 * @param n The node with type info.
 * @param sourceName The source file name.
 * @param scope A scope for doing type name lookups.
 */
public JSType createFromTypeNodes(Node n,String sourceName,StaticScope<JSType> scope){
  return createFromTypeNodesInternal(n,sourceName,scope);
}",0.671264367816092
27866,"/** 
 * @see #createFromTypeNodes(Node,String,StaticScope) 
 */
private JSType createFromTypeNodesInternal(Node n,String sourceName,StaticScope<JSType> scope){
switch (n.getType()) {
case Token.LC:
    return createRecordTypeFromNodes(n.getFirstChild(),sourceName,scope);
case Token.BANG:
  return createFromTypeNodesInternal(n.getFirstChild(),sourceName,scope).restrictByNotNullOrUndefined();
case Token.QMARK:
Node firstChild=n.getFirstChild();
if (firstChild == null) {
return getNativeType(UNKNOWN_TYPE);
}
return createDefaultObjectUnion(createFromTypeNodesInternal(firstChild,sourceName,scope));
case Token.EQUALS:
return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(),sourceName,scope));
case Token.ELLIPSIS:
return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(),sourceName,scope));
case Token.STAR:
return getNativeType(ALL_TYPE);
case Token.LB:
return getNativeType(ARRAY_TYPE);
case Token.PIPE:
UnionTypeBuilder builder=new UnionTypeBuilder(this);
for (Node child=n.getFirstChild(); child != null; child=child.getNext()) {
builder.addAlternate(createFromTypeNodesInternal(child,sourceName,scope));
}
return builder.build();
case Token.EMPTY:
return getNativeType(UNKNOWN_TYPE);
case Token.VOID:
return getNativeType(VOID_TYPE);
case Token.STRING:
JSType namedType=getType(scope,n.getString(),sourceName,n.getLineno(),n.getCharno());
if (resolveMode != ResolveMode.LAZY_NAMES) {
namedType=namedType.resolveInternal(reporter,scope);
}
if ((namedType instanceof ObjectType) && !(nonNullableTypeNames.contains(n.getString()))) {
Node typeList=n.getFirstChild();
int nAllowedTypes=namedType.getTemplateTypeMap().numUnfilledTemplateKeys();
if (typeList != null && nAllowedTypes > 0) {
ImmutableList.Builder<JSType> templateTypes=ImmutableList.builder();
if (n.getString().equals(""String_Node_Str"") && typeList.getFirstChild() == typeList.getLastChild()) {
templateTypes.add(getNativeType(UNKNOWN_TYPE));
}
int templateNodeIndex=0;
for (Node templateNode : typeList.getFirstChild().siblings()) {
if (++templateNodeIndex > nAllowedTypes) {
break;
}
templateTypes.add(createFromTypeNodesInternal(templateNode,sourceName,scope));
}
namedType=createTemplatizedType((ObjectType)namedType,templateTypes.build());
Preconditions.checkNotNull(namedType);
}
return createDefaultObjectUnion(namedType);
}
 else {
return namedType;
}
case Token.FUNCTION:
ObjectType thisType=null;
boolean isConstructor=false;
Node current=n.getFirstChild();
if (current.getType() == Token.THIS || current.getType() == Token.NEW) {
Node contextNode=current.getFirstChild();
thisType=ObjectType.cast(createFromTypeNodesInternal(contextNode,sourceName,scope).restrictByNotNullOrUndefined());
if (thisType == null) {
reporter.warning(SimpleErrorReporter.getMessage0(current.getType() == Token.THIS ? ""String_Node_Str"" : ""String_Node_Str""),sourceName,contextNode.getLineno(),contextNode.getCharno());
}
isConstructor=current.getType() == Token.NEW;
current=current.getNext();
}
FunctionParamBuilder paramBuilder=new FunctionParamBuilder(this);
if (current.getType() == Token.PARAM_LIST) {
for (Node arg=current.getFirstChild(); arg != null; arg=arg.getNext()) {
if (arg.getType() == Token.ELLIPSIS) {
if (arg.getChildCount() == 0) {
paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));
}
 else {
paramBuilder.addVarArgs(createFromTypeNodesInternal(arg.getFirstChild(),sourceName,scope));
}
}
 else {
JSType type=createFromTypeNodesInternal(arg,sourceName,scope);
if (arg.getType() == Token.EQUALS) {
boolean addSuccess=paramBuilder.addOptionalParams(type);
if (!addSuccess) {
reporter.warning(SimpleErrorReporter.getMessage0(""String_Node_Str""),sourceName,arg.getLineno(),arg.getCharno());
}
}
 else {
paramBuilder.addRequiredParams(type);
}
}
}
current=current.getNext();
}
JSType returnType=createFromTypeNodesInternal(current,sourceName,scope);
return new FunctionBuilder(this).withParams(paramBuilder).withReturnType(returnType).withTypeOfThis(thisType).setIsConstructor(isConstructor).build();
}
throw new IllegalStateException(""String_Node_Str"" + n.toString());
}","/** 
 * @see #createFromTypeNodes(Node,String,StaticScope) 
 */
private JSType createFromTypeNodesInternal(Node n,String sourceName,StaticScope<JSType> scope){
switch (n.getType()) {
case Token.LC:
    return createRecordTypeFromNodes(n.getFirstChild(),sourceName,scope);
case Token.BANG:
  return createFromTypeNodesInternal(n.getFirstChild(),sourceName,scope).restrictByNotNullOrUndefined();
case Token.QMARK:
Node firstChild=n.getFirstChild();
if (firstChild == null) {
return getNativeType(UNKNOWN_TYPE);
}
return createDefaultObjectUnion(createFromTypeNodesInternal(firstChild,sourceName,scope));
case Token.EQUALS:
return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(),sourceName,scope));
case Token.ELLIPSIS:
return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(),sourceName,scope));
case Token.STAR:
return getNativeType(ALL_TYPE);
case Token.LB:
return getNativeType(ARRAY_TYPE);
case Token.PIPE:
UnionTypeBuilder builder=new UnionTypeBuilder(this);
for (Node child=n.getFirstChild(); child != null; child=child.getNext()) {
builder.addAlternate(createFromTypeNodesInternal(child,sourceName,scope));
}
return builder.build();
case Token.EMPTY:
return getNativeType(UNKNOWN_TYPE);
case Token.VOID:
return getNativeType(VOID_TYPE);
case Token.STRING:
JSType namedType=getType(scope,n.getString(),sourceName,n.getLineno(),n.getCharno());
if ((namedType instanceof ObjectType) && !(nonNullableTypeNames.contains(n.getString()))) {
Node typeList=n.getFirstChild();
int nAllowedTypes=namedType.getTemplateTypeMap().numUnfilledTemplateKeys();
if (typeList != null && nAllowedTypes > 0) {
ImmutableList.Builder<JSType> templateTypes=ImmutableList.builder();
if (n.getString().equals(""String_Node_Str"") && typeList.getFirstChild() == typeList.getLastChild()) {
templateTypes.add(getNativeType(UNKNOWN_TYPE));
}
int templateNodeIndex=0;
for (Node templateNode : typeList.getFirstChild().siblings()) {
if (++templateNodeIndex > nAllowedTypes) {
break;
}
templateTypes.add(createFromTypeNodesInternal(templateNode,sourceName,scope));
}
namedType=createTemplatizedType((ObjectType)namedType,templateTypes.build());
Preconditions.checkNotNull(namedType);
}
return createDefaultObjectUnion(namedType);
}
 else {
return namedType;
}
case Token.FUNCTION:
ObjectType thisType=null;
boolean isConstructor=false;
Node current=n.getFirstChild();
if (current.getType() == Token.THIS || current.getType() == Token.NEW) {
Node contextNode=current.getFirstChild();
thisType=ObjectType.cast(createFromTypeNodesInternal(contextNode,sourceName,scope).restrictByNotNullOrUndefined());
if (thisType == null) {
reporter.warning(SimpleErrorReporter.getMessage0(current.getType() == Token.THIS ? ""String_Node_Str"" : ""String_Node_Str""),sourceName,contextNode.getLineno(),contextNode.getCharno());
}
isConstructor=current.getType() == Token.NEW;
current=current.getNext();
}
FunctionParamBuilder paramBuilder=new FunctionParamBuilder(this);
if (current.getType() == Token.PARAM_LIST) {
for (Node arg=current.getFirstChild(); arg != null; arg=arg.getNext()) {
if (arg.getType() == Token.ELLIPSIS) {
if (arg.getChildCount() == 0) {
paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));
}
 else {
paramBuilder.addVarArgs(createFromTypeNodesInternal(arg.getFirstChild(),sourceName,scope));
}
}
 else {
JSType type=createFromTypeNodesInternal(arg,sourceName,scope);
if (arg.getType() == Token.EQUALS) {
boolean addSuccess=paramBuilder.addOptionalParams(type);
if (!addSuccess) {
reporter.warning(SimpleErrorReporter.getMessage0(""String_Node_Str""),sourceName,arg.getLineno(),arg.getCharno());
}
}
 else {
paramBuilder.addRequiredParams(type);
}
}
}
current=current.getNext();
}
JSType returnType=createFromTypeNodesInternal(current,sourceName,scope);
return new FunctionBuilder(this).withParams(paramBuilder).withReturnType(returnType).withTypeOfThis(thisType).setIsConstructor(isConstructor).build();
}
throw new IllegalStateException(""String_Node_Str"" + n.toString());
}",0.9875776397515528
27867,"/** 
 * Tries to attach currentJsdoc to n or one of its descendants. If the jsdoc starts after n, we return null. If the jsdoc is attached, we return the node on which it was attached. Last, if it was contained in n but didn't get attached, we return some node close to where the comment would get attached. The node that gets returned from this function is where the search for attaching the next comment will start from. A comment never gets attached to a node that appears before it in the code.
 * @param parapos n's parent's absolute position; we calculate it manuallyb/c it's slow to call getAbsolutePosition for every node.
 */
private NodePos attachComment(AstNode n,int parapos){
  int napos=parapos + n.getPosition();
  if (finishesAfterJsdoc(n,napos)) {
    if (capos < napos && !attachToChildren(n,napos)) {
      return setJsdoc(n,napos);
    }
  }
 else {
    return null;
  }
  int ntype=n.getType();
  NodePos res;
switch (ntype) {
case Token.BREAK:
case Token.CONTINUE:
    return new NodePos(n,napos);
case Token.CASE:
  SwitchCase cas=(SwitchCase)n;
if (!cas.isDefault()) {
  res=attachComment(cas.getExpression(),napos);
  if (res != null) {
    return res;
  }
}
if (cas.getStatements() != null) {
for (AstNode stm : cas.getStatements()) {
  res=attachComment(stm,napos);
  if (res != null) {
    return res;
  }
}
}
return new NodePos(n,napos);
case Token.DO:
DoLoop dl=(DoLoop)n;
res=attachComment(dl.getBody(),napos);
if (res != null) {
return res;
}
if (capos < dl.getWhilePosition()) {
return new NodePos(n,napos);
}
res=attachComment(dl.getCondition(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.EXPR_RESULT:
case Token.EXPR_VOID:
if (n instanceof ExpressionStatement) {
res=attachComment(((ExpressionStatement)n).getExpression(),napos);
}
 else {
res=attachComment(((LabeledStatement)n).getStatement(),napos);
}
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.FOR:
Loop loop=(Loop)n;
if (n instanceof ForInLoop) {
res=attachForInHeader((ForInLoop)loop,napos);
}
 else {
res=attachForLoopHeader((ForLoop)loop,napos);
}
if (res != null) {
return res;
}
res=attachComment(loop.getBody(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.IF:
IfStatement ifstm=(IfStatement)n;
res=attachComment(ifstm.getCondition(),napos);
if (res != null) {
return res;
}
res=attachComment(ifstm.getThenPart(),napos);
if (res != null) {
return res;
}
if (capos < ifstm.getElsePosition()) {
return new NodePos(n,napos);
}
res=attachComment(ifstm.getElsePart(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.FUNCTION:
FunctionNode fun=(FunctionNode)n;
Name nam=fun.getFunctionName();
if (nam != null) {
res=attachComment(nam,napos);
if (res != null) {
return res;
}
}
for (AstNode param : fun.getParams()) {
res=attachComment(param,napos);
if (res != null) {
return res;
}
}
res=attachComment(fun.getBody(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.RETURN:
res=attachComment(((ReturnStatement)n).getReturnValue(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.SWITCH:
SwitchStatement sw=(SwitchStatement)n;
res=attachComment(sw.getExpression(),napos);
if (res != null) {
return res;
}
for (SwitchCase c : sw.getCases()) {
res=attachComment(c,napos);
}
return new NodePos(n,napos);
case Token.THROW:
res=attachComment(((ThrowStatement)n).getExpression(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.TRY:
TryStatement t=(TryStatement)n;
res=attachComment(t.getTryBlock(),napos);
if (res != null) {
return res;
}
for (CatchClause cc : t.getCatchClauses()) {
int catchstart=napos + cc.getPosition();
if (capos < catchstart) {
return new NodePos(n,napos);
}
res=attachComment(cc.getVarName(),catchstart);
if (res != null) {
return res;
}
res=attachComment(cc.getBody(),catchstart);
if (res != null) {
return res;
}
}
int finpos=t.getFinallyPosition();
if (finpos != -1) {
if (capos < finpos) {
return new NodePos(n,napos);
}
res=attachComment(t.getFinallyBlock(),napos);
if (res != null) {
return res;
}
}
return new NodePos(n,napos);
case Token.VAR:
if (n instanceof VariableDeclaration) {
for (VariableInitializer vi : ((VariableDeclaration)n).getVariables()) {
res=attachComment(vi,napos);
if (res != null) {
return res;
}
}
}
 else {
res=attachComment(((VariableInitializer)n).getInitializer(),napos);
if (res != null) {
return res;
}
}
return new NodePos(n,napos);
case Token.WHILE:
WhileLoop wh=(WhileLoop)n;
res=attachComment(wh.getCondition(),napos);
if (res != null) {
return res;
}
if (capos < wh.getRp()) {
return new NodePos(n,napos);
}
res=attachComment(wh.getBody(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.WITH:
WithStatement w=(WithStatement)n;
res=attachComment(w.getExpression(),napos);
if (res != null) {
return res;
}
if (capos < w.getRp()) {
return new NodePos(n,napos);
}
res=attachComment(w.getStatement(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.ADD:
case Token.AND:
case Token.ASSIGN:
case Token.ASSIGN_ADD:
case Token.ASSIGN_BITAND:
case Token.ASSIGN_BITOR:
case Token.ASSIGN_BITXOR:
case Token.ASSIGN_DIV:
case Token.ASSIGN_LSH:
case Token.ASSIGN_MOD:
case Token.ASSIGN_MUL:
case Token.ASSIGN_RSH:
case Token.ASSIGN_SUB:
case Token.ASSIGN_URSH:
case Token.BITAND:
case Token.BITOR:
case Token.BITXOR:
case Token.COLON:
case Token.COMMA:
case Token.DIV:
case Token.EQ:
case Token.GE:
case Token.GET:
case Token.GETPROP:
case Token.GT:
case Token.IN:
case Token.INSTANCEOF:
case Token.LE:
case Token.LSH:
case Token.LT:
case Token.MOD:
case Token.MUL:
case Token.NE:
case Token.OR:
case Token.RSH:
case Token.SET:
case Token.SHEQ:
case Token.SHNE:
case Token.SUB:
case Token.URSH:
InfixExpression ie=(InfixExpression)n;
res=attachComment(ie.getLeft(),napos);
if (res != null) {
return res;
}
if (capos < ie.getOperatorPosition()) {
return new NodePos(n,napos);
}
res=attachComment(ie.getRight(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.ARRAYLIT:
for (AstNode elm : ((ArrayLiteral)n).getElements()) {
res=attachComment(elm,napos);
if (res != null) {
return res;
}
}
return new NodePos(n,napos);
case Token.BITNOT:
case Token.DEC:
case Token.DELPROP:
case Token.INC:
case Token.NEG:
case Token.NOT:
case Token.POS:
case Token.TYPEOF:
case Token.VOID:
UnaryExpression ue=(UnaryExpression)n;
res=attachComment(ue.getOperand(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.CALL:
case Token.NEW:
FunctionCall call=(FunctionCall)n;
res=attachComment(call.getTarget(),napos);
if (res != null) {
return res;
}
if (capos < call.getLp()) {
return new NodePos(n,napos);
}
for (AstNode param : call.getArguments()) {
res=attachComment(param,napos);
if (res != null) {
return res;
}
}
return new NodePos(n,napos);
case Token.GETELEM:
ElementGet elm=(ElementGet)n;
res=attachComment(elm.getTarget(),napos);
if (res != null) {
return res;
}
if (capos < elm.getLb()) {
return new NodePos(n,napos);
}
res=attachComment(elm.getElement(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.HOOK:
ConditionalExpression hook=(ConditionalExpression)n;
res=attachComment(hook.getTestExpression(),napos);
if (res != null) {
return res;
}
if (capos < hook.getQuestionMarkPosition()) {
return new NodePos(n,napos);
}
res=attachComment(hook.getTrueExpression(),napos);
if (res != null) {
return res;
}
if (capos < hook.getColonPosition()) {
return new NodePos(n,napos);
}
res=attachComment(hook.getFalseExpression(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.LP:
res=attachComment(((ParenthesizedExpression)n).getExpression(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.OBJECTLIT:
for (InfixExpression prop : ((ObjectLiteral)n).getElements()) {
res=attachComment(prop,napos);
if (res != null) {
return res;
}
}
return new NodePos(n,napos);
case Token.BLOCK:
case Token.SCRIPT:
AstNode kid=(AstNode)n.getFirstChild();
while (kid != null) {
res=attachComment(kid,napos);
if (res != null) {
return res;
}
kid=(AstNode)kid.getNext();
}
return new NodePos(n,napos);
default :
throw new RuntimeException(""String_Node_Str"" + ntype);
}
}","/** 
 * Tries to attach currentJsdoc to n or one of its descendants. If the jsdoc starts after n, we return null. If the jsdoc is attached, we return the node on which it was attached. Last, if it was contained in n but didn't get attached, we return some node close to where the comment would get attached. The node that gets returned from this function is where the search for attaching the next comment will start from. A comment never gets attached to a node that appears before it in the code.
 * @param parapos n's parent's absolute position; we calculate it manuallyb/c it's slow to call getAbsolutePosition for every node.
 */
private NodePos attachComment(AstNode n,int parapos){
  int napos=parapos + n.getPosition();
  if (finishesAfterJsdoc(n,napos)) {
    if (capos < napos && !attachToChildren(n,napos)) {
      return setJsdoc(n,napos);
    }
  }
 else {
    return null;
  }
  int ntype=n.getType();
  NodePos res;
switch (ntype) {
case Token.BREAK:
case Token.CONTINUE:
    return new NodePos(n,napos);
case Token.CASE:
  SwitchCase cas=(SwitchCase)n;
if (!cas.isDefault()) {
  res=attachComment(cas.getExpression(),napos);
  if (res != null) {
    return res;
  }
}
if (cas.getStatements() != null) {
for (AstNode stm : cas.getStatements()) {
  res=attachComment(stm,napos);
  if (res != null) {
    return res;
  }
}
}
return new NodePos(n,napos);
case Token.DO:
DoLoop dl=(DoLoop)n;
res=attachComment(dl.getBody(),napos);
if (res != null) {
return res;
}
if (capos < dl.getWhilePosition()) {
return new NodePos(n,napos);
}
res=attachComment(dl.getCondition(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.EXPR_RESULT:
case Token.EXPR_VOID:
if (n instanceof ExpressionStatement) {
res=attachComment(((ExpressionStatement)n).getExpression(),napos);
}
 else {
res=attachComment(((LabeledStatement)n).getStatement(),napos);
}
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.FOR:
Loop loop=(Loop)n;
if (n instanceof ForInLoop) {
res=attachForInHeader((ForInLoop)loop,napos);
}
 else {
res=attachForLoopHeader((ForLoop)loop,napos);
}
if (res != null) {
return res;
}
res=attachComment(loop.getBody(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.IF:
IfStatement ifstm=(IfStatement)n;
res=attachComment(ifstm.getCondition(),napos);
if (res != null) {
return res;
}
res=attachComment(ifstm.getThenPart(),napos);
if (res != null) {
return res;
}
if (capos < ifstm.getElsePosition()) {
return new NodePos(n,napos);
}
res=attachComment(ifstm.getElsePart(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.FUNCTION:
FunctionNode fun=(FunctionNode)n;
Name nam=fun.getFunctionName();
if (nam != null) {
res=attachComment(nam,napos);
if (res != null) {
return res;
}
}
for (AstNode param : fun.getParams()) {
res=attachComment(param,napos);
if (res != null) {
return res;
}
}
res=attachComment(fun.getBody(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.RETURN:
AstNode retValue=((ReturnStatement)n).getReturnValue();
if (retValue != null) {
res=attachComment(retValue,napos);
if (res != null) {
return res;
}
}
return new NodePos(n,napos);
case Token.SWITCH:
SwitchStatement sw=(SwitchStatement)n;
res=attachComment(sw.getExpression(),napos);
if (res != null) {
return res;
}
for (SwitchCase c : sw.getCases()) {
res=attachComment(c,napos);
}
return new NodePos(n,napos);
case Token.THROW:
res=attachComment(((ThrowStatement)n).getExpression(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.TRY:
TryStatement t=(TryStatement)n;
res=attachComment(t.getTryBlock(),napos);
if (res != null) {
return res;
}
for (CatchClause cc : t.getCatchClauses()) {
int catchstart=napos + cc.getPosition();
if (capos < catchstart) {
return new NodePos(n,napos);
}
res=attachComment(cc.getVarName(),catchstart);
if (res != null) {
return res;
}
res=attachComment(cc.getBody(),catchstart);
if (res != null) {
return res;
}
}
int finpos=t.getFinallyPosition();
if (finpos != -1) {
if (capos < finpos) {
return new NodePos(n,napos);
}
res=attachComment(t.getFinallyBlock(),napos);
if (res != null) {
return res;
}
}
return new NodePos(n,napos);
case Token.VAR:
if (n instanceof VariableDeclaration) {
for (VariableInitializer vi : ((VariableDeclaration)n).getVariables()) {
res=attachComment(vi,napos);
if (res != null) {
return res;
}
}
}
 else {
res=attachComment(((VariableInitializer)n).getInitializer(),napos);
if (res != null) {
return res;
}
}
return new NodePos(n,napos);
case Token.WHILE:
WhileLoop wh=(WhileLoop)n;
res=attachComment(wh.getCondition(),napos);
if (res != null) {
return res;
}
if (capos < wh.getRp()) {
return new NodePos(n,napos);
}
res=attachComment(wh.getBody(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.WITH:
WithStatement w=(WithStatement)n;
res=attachComment(w.getExpression(),napos);
if (res != null) {
return res;
}
if (capos < w.getRp()) {
return new NodePos(n,napos);
}
res=attachComment(w.getStatement(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.ADD:
case Token.AND:
case Token.ASSIGN:
case Token.ASSIGN_ADD:
case Token.ASSIGN_BITAND:
case Token.ASSIGN_BITOR:
case Token.ASSIGN_BITXOR:
case Token.ASSIGN_DIV:
case Token.ASSIGN_LSH:
case Token.ASSIGN_MOD:
case Token.ASSIGN_MUL:
case Token.ASSIGN_RSH:
case Token.ASSIGN_SUB:
case Token.ASSIGN_URSH:
case Token.BITAND:
case Token.BITOR:
case Token.BITXOR:
case Token.COLON:
case Token.COMMA:
case Token.DIV:
case Token.EQ:
case Token.GE:
case Token.GET:
case Token.GETPROP:
case Token.GT:
case Token.IN:
case Token.INSTANCEOF:
case Token.LE:
case Token.LSH:
case Token.LT:
case Token.MOD:
case Token.MUL:
case Token.NE:
case Token.OR:
case Token.RSH:
case Token.SET:
case Token.SHEQ:
case Token.SHNE:
case Token.SUB:
case Token.URSH:
InfixExpression ie=(InfixExpression)n;
res=attachComment(ie.getLeft(),napos);
if (res != null) {
return res;
}
if (capos < ie.getOperatorPosition()) {
return new NodePos(n,napos);
}
res=attachComment(ie.getRight(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.ARRAYLIT:
for (AstNode elm : ((ArrayLiteral)n).getElements()) {
res=attachComment(elm,napos);
if (res != null) {
return res;
}
}
return new NodePos(n,napos);
case Token.BITNOT:
case Token.DEC:
case Token.DELPROP:
case Token.INC:
case Token.NEG:
case Token.NOT:
case Token.POS:
case Token.TYPEOF:
case Token.VOID:
UnaryExpression ue=(UnaryExpression)n;
res=attachComment(ue.getOperand(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.CALL:
case Token.NEW:
FunctionCall call=(FunctionCall)n;
res=attachComment(call.getTarget(),napos);
if (res != null) {
return res;
}
if (capos < call.getLp()) {
return new NodePos(n,napos);
}
for (AstNode param : call.getArguments()) {
res=attachComment(param,napos);
if (res != null) {
return res;
}
}
return new NodePos(n,napos);
case Token.GETELEM:
ElementGet elm=(ElementGet)n;
res=attachComment(elm.getTarget(),napos);
if (res != null) {
return res;
}
if (capos < elm.getLb()) {
return new NodePos(n,napos);
}
res=attachComment(elm.getElement(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.HOOK:
ConditionalExpression hook=(ConditionalExpression)n;
res=attachComment(hook.getTestExpression(),napos);
if (res != null) {
return res;
}
if (capos < hook.getQuestionMarkPosition()) {
return new NodePos(n,napos);
}
res=attachComment(hook.getTrueExpression(),napos);
if (res != null) {
return res;
}
if (capos < hook.getColonPosition()) {
return new NodePos(n,napos);
}
res=attachComment(hook.getFalseExpression(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.LP:
res=attachComment(((ParenthesizedExpression)n).getExpression(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.OBJECTLIT:
for (InfixExpression prop : ((ObjectLiteral)n).getElements()) {
res=attachComment(prop,napos);
if (res != null) {
return res;
}
}
return new NodePos(n,napos);
case Token.BLOCK:
case Token.SCRIPT:
AstNode kid=(AstNode)n.getFirstChild();
while (kid != null) {
res=attachComment(kid,napos);
if (res != null) {
return res;
}
kid=(AstNode)kid.getNext();
}
return new NodePos(n,napos);
default :
throw new RuntimeException(""String_Node_Str"" + ntype);
}
}",0.9929927531891956
27868,"/** 
 * @return Whether the variable is only assigned a value once for itslifetime.
 */
boolean isAssignedOnceInLifetime(){
  Reference ref=getOneAndOnlyAssignment();
  if (ref == null) {
    return false;
  }
  for (BasicBlock block=ref.getBasicBlock(); block != null; block=block.getParent()) {
    if (block.isFunction) {
      break;
    }
 else     if (block.isLoop) {
      return false;
    }
  }
  return true;
}","/** 
 * @return Whether the variable is only assigned a value once for itslifetime.
 */
boolean isAssignedOnceInLifetime(){
  Reference ref=getOneAndOnlyAssignment();
  if (ref == null) {
    return false;
  }
  for (BasicBlock block=ref.getBasicBlock(); block != null; block=block.getParent()) {
    if (block.isFunction) {
      if (ref.getSymbol().getScope() != ref.scope) {
        return false;
      }
      break;
    }
 else     if (block.isLoop) {
      return false;
    }
  }
  return true;
}",0.894907908992416
27869,"public void testInlineVariablesConstantsJsDocStyle(){
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
}","public void testInlineVariablesConstantsJsDocStyle(){
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
}",0.8958333333333334
27870,"public void testInlineVariablesConstants(){
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  testSame(""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
}","public void testInlineVariablesConstants(){
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
}",0.9526813880126184
27871,"private void inlineNonConstants(Var v,ReferenceCollection referenceInfo,boolean maybeModifiedArguments){
  int refCount=referenceInfo.references.size();
  Reference declaration=referenceInfo.references.get(0);
  Reference init=referenceInfo.getInitializingReference();
  int firstRefAfterInit=(declaration == init) ? 2 : 3;
  if (refCount > 1 && isImmutableAndWellDefinedVariable(v,referenceInfo)) {
    Node value;
    if (init != null) {
      value=init.getAssignedValue();
    }
 else {
      Node srcLocation=declaration.getNode();
      value=NodeUtil.newUndefinedNode(srcLocation);
    }
    Preconditions.checkNotNull(value);
    inlineWellDefinedVariable(v,value,referenceInfo.references);
    staleVars.add(v);
  }
 else   if (refCount == firstRefAfterInit) {
    Reference reference=referenceInfo.references.get(firstRefAfterInit - 1);
    if (canInline(declaration,init,reference)) {
      inline(v,declaration,init,reference);
      staleVars.add(v);
    }
  }
 else   if (declaration != init && refCount == 2) {
    if (isValidDeclaration(declaration) && isValidInitialization(init)) {
      Node value=init.getAssignedValue();
      Preconditions.checkNotNull(value);
      inlineWellDefinedVariable(v,value,referenceInfo.references);
      staleVars.add(v);
    }
  }
  if (!maybeModifiedArguments && !staleVars.contains(v) && referenceInfo.isWellDefined()&& referenceInfo.isAssignedOnceInLifetime()) {
    List<Reference> refs=referenceInfo.references;
    for (int i=1; i < refs.size(); i++) {
      Node nameNode=refs.get(i).getNode();
      if (aliasCandidates.containsKey(nameNode)) {
        AliasCandidate candidate=aliasCandidates.get(nameNode);
        if (!staleVars.contains(candidate.alias) && !isVarInlineForbidden(candidate.alias)) {
          Reference aliasInit;
          aliasInit=candidate.refInfo.getInitializingReference();
          Node value=aliasInit.getAssignedValue();
          Preconditions.checkNotNull(value);
          inlineWellDefinedVariable(candidate.alias,value,candidate.refInfo.references);
          staleVars.add(candidate.alias);
        }
      }
    }
  }
}","private void inlineNonConstants(Var v,ReferenceCollection referenceInfo,boolean maybeModifiedArguments){
  int refCount=referenceInfo.references.size();
  Reference declaration=referenceInfo.references.get(0);
  Reference init=referenceInfo.getInitializingReference();
  int firstRefAfterInit=(declaration == init) ? 2 : 3;
  if (refCount > 1 && isImmutableAndWellDefinedVariable(v,referenceInfo)) {
    Node value;
    if (init != null) {
      value=init.getAssignedValue();
    }
 else {
      Node srcLocation=declaration.getNode();
      value=NodeUtil.newUndefinedNode(srcLocation);
    }
    Preconditions.checkNotNull(value);
    inlineWellDefinedVariable(v,value,referenceInfo.references);
    staleVars.add(v);
  }
 else   if (refCount == firstRefAfterInit) {
    Reference reference=referenceInfo.references.get(firstRefAfterInit - 1);
    if (canInline(declaration,init,reference)) {
      inline(v,declaration,init,reference);
      staleVars.add(v);
    }
  }
 else   if (declaration != init && refCount == 2) {
    if (isValidDeclaration(declaration) && isValidInitialization(init)) {
      Node value=init.getAssignedValue();
      Preconditions.checkNotNull(value);
      inlineWellDefinedVariable(v,value,referenceInfo.references);
      staleVars.add(v);
    }
  }
  if (!maybeModifiedArguments && !staleVars.contains(v) && referenceInfo.isWellDefined()&& referenceInfo.isAssignedOnceInLifetime()&& (isInlineableDeclaredConstant(v,referenceInfo) || referenceInfo.isOnlyAssignmentSameScopeAsDeclaration())) {
    List<Reference> refs=referenceInfo.references;
    for (int i=1; i < refs.size(); i++) {
      Node nameNode=refs.get(i).getNode();
      if (aliasCandidates.containsKey(nameNode)) {
        AliasCandidate candidate=aliasCandidates.get(nameNode);
        if (!staleVars.contains(candidate.alias) && !isVarInlineForbidden(candidate.alias)) {
          Reference aliasInit;
          aliasInit=candidate.refInfo.getInitializingReference();
          Node value=aliasInit.getAssignedValue();
          Preconditions.checkNotNull(value);
          inlineWellDefinedVariable(candidate.alias,value,candidate.refInfo.references);
          staleVars.add(candidate.alias);
        }
      }
    }
  }
}",0.9751266697374482
27872,"private void resolvedTemplateType(Map<TemplateType,JSType> map,TemplateType template,JSType resolved){
  JSType previous=map.get(template);
  if (!resolved.isUnknownType()) {
    if (previous == null) {
      map.put(template,resolved);
    }
 else {
      JSType join=previous.getLeastSupertype(resolved);
      map.put(template,join);
    }
  }
}","private static void resolvedTemplateType(Map<TemplateType,JSType> map,TemplateType template,JSType resolved){
  JSType previous=map.get(template);
  if (!resolved.isUnknownType()) {
    if (previous == null) {
      map.put(template,resolved);
    }
 else {
      JSType join=previous.getLeastSupertype(resolved);
      map.put(template,join);
    }
  }
}",0.9900426742532006
27873,"/** 
 * Suppose X is an object with inferred properties. Suppose also that X is used in a way where it would only type-check correctly if some of those properties are widened. Then we should be polite and automatically widen X's properties for him. For a concrete example, consider: param x {{prop: (number|undefined)}} function f(x) {} f({}); If we give the anonymous object an inferred property of (number|undefined), then this code will type-check appropriately.
 */
private void inferPropertyTypesToMatchConstraint(JSType type,JSType constraint){
  if (type == null || constraint == null) {
    return;
  }
  type.matchConstraint(constraint);
}","/** 
 * Suppose X is an object with inferred properties. Suppose also that X is used in a way where it would only type-check correctly if some of those properties are widened. Then we should be polite and automatically widen X's properties for him. For a concrete example, consider: param x {{prop: (number|undefined)}} function f(x) {} f({}); If we give the anonymous object an inferred property of (number|undefined), then this code will type-check appropriately.
 */
private static void inferPropertyTypesToMatchConstraint(JSType type,JSType constraint){
  if (type == null || constraint == null) {
    return;
  }
  type.matchConstraint(constraint);
}",0.9946277820414428
27874,"private FlowScope traverseObjectLiteral(Node n,FlowScope scope){
  JSType type=n.getJSType();
  Preconditions.checkNotNull(type);
  for (Node name=n.getFirstChild(); name != null; name=name.getNext()) {
    scope=traverse(name.getFirstChild(),scope);
  }
  ObjectType objectType=ObjectType.cast(type);
  if (objectType == null || n.getBooleanProp(Node.REFLECTED_OBJECT)) {
    return scope;
  }
  String qObjName=NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));
  for (Node name=n.getFirstChild(); name != null; name=name.getNext()) {
    String memberName=NodeUtil.getObjectLitKeyName(name);
    if (memberName != null) {
      JSType rawValueType=name.getFirstChild().getJSType();
      JSType valueType=NodeUtil.getObjectLitKeyTypeFromValueType(name,rawValueType);
      if (valueType == null) {
        valueType=unknownType;
      }
      objectType.defineInferredProperty(memberName,valueType,name);
      if (qObjName != null && name.isStringKey()) {
        String qKeyName=qObjName + ""String_Node_Str"" + memberName;
        Var var=syntacticScope.getVar(qKeyName);
        JSType oldType=var == null ? null : var.getType();
        if (var != null && var.isTypeInferred()) {
          var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));
        }
        scope.inferQualifiedSlot(name,qKeyName,oldType == null ? unknownType : oldType,valueType);
      }
    }
 else {
      n.setJSType(unknownType);
    }
  }
  return scope;
}","private FlowScope traverseObjectLiteral(Node n,FlowScope scope){
  JSType type=n.getJSType();
  Preconditions.checkNotNull(type);
  for (Node name=n.getFirstChild(); name != null; name=name.getNext()) {
    scope=traverse(name.getFirstChild(),scope);
  }
  ObjectType objectType=ObjectType.cast(type);
  if (objectType == null || n.getBooleanProp(Node.REFLECTED_OBJECT) || objectType.isEnumType()) {
    return scope;
  }
  String qObjName=NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));
  for (Node name=n.getFirstChild(); name != null; name=name.getNext()) {
    String memberName=NodeUtil.getObjectLitKeyName(name);
    if (memberName != null) {
      JSType rawValueType=name.getFirstChild().getJSType();
      JSType valueType=NodeUtil.getObjectLitKeyTypeFromValueType(name,rawValueType);
      if (valueType == null) {
        valueType=unknownType;
      }
      objectType.defineInferredProperty(memberName,valueType,name);
      if (qObjName != null && name.isStringKey()) {
        String qKeyName=qObjName + ""String_Node_Str"" + memberName;
        Var var=syntacticScope.getVar(qKeyName);
        JSType oldType=var == null ? null : var.getType();
        if (var != null && var.isTypeInferred()) {
          var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));
        }
        scope.inferQualifiedSlot(name,qKeyName,oldType == null ? unknownType : oldType,valueType);
      }
    }
 else {
      n.setJSType(unknownType);
    }
  }
  return scope;
}",0.990893760539629
27875,"/** 
 * Add node to the list of injectables.
 * @param n node to add.
 * @param t node traversal instance.
 */
private void addNode(Node n,NodeTraversal t){
  Node target=null;
  Node fn=null;
  String name=null;
switch (n.getType()) {
case Token.ASSIGN:
    name=n.getFirstChild().getQualifiedName();
  fn=n;
while (fn.isAssign()) {
  fn=fn.getLastChild();
}
target=n.getParent();
break;
case Token.FUNCTION:
name=NodeUtil.getFunctionName(n);
fn=n;
target=n;
break;
case Token.VAR:
name=n.getFirstChild().getString();
fn=getDeclarationRValue(n);
target=n;
break;
}
if (!target.getParent().isScript() && !target.getParent().isBlock()) {
compiler.report(t.makeError(n,INJECT_IN_NON_GLOBAL_OR_BLOCK_ERROR));
return;
}
if (fn == null || !fn.isFunction()) {
compiler.report(t.makeError(n,INJECT_NON_FUNCTION_ERROR));
return;
}
Preconditions.checkNotNull(name);
injectables.add(new NodeContext(name,n,fn,target));
}","/** 
 * Add node to the list of injectables.
 * @param n node to add.
 * @param t node traversal instance.
 */
private void addNode(Node n,NodeTraversal t){
  Node target=null;
  Node fn=null;
  String name=null;
switch (n.getType()) {
case Token.ASSIGN:
    name=n.getFirstChild().getQualifiedName();
  fn=n;
while (fn.isAssign()) {
  fn=fn.getLastChild();
}
target=n.getParent();
break;
case Token.FUNCTION:
name=NodeUtil.getFunctionName(n);
fn=n;
target=n;
break;
case Token.VAR:
name=n.getFirstChild().getString();
fn=getDeclarationRValue(n);
target=n;
break;
}
if (fn == null || !fn.isFunction()) {
compiler.report(t.makeError(n,INJECT_NON_FUNCTION_ERROR));
return;
}
if (!target.getParent().isScript() && !target.getParent().isBlock()) {
compiler.report(t.makeError(n,INJECT_IN_NON_GLOBAL_OR_BLOCK_ERROR));
return;
}
Preconditions.checkNotNull(name);
injectables.add(new NodeContext(name,n,fn,target));
}",0.7923076923076923
27876,"public void testNgInjectNonFunction() throws Exception {
  test(""String_Node_Str"",null,AngularPass.INJECT_NON_FUNCTION_ERROR);
  test(""String_Node_Str"",null,AngularPass.INJECT_NON_FUNCTION_ERROR);
}","public void testNgInjectNonFunction() throws Exception {
  test(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",null,AngularPass.INJECT_NON_FUNCTION_ERROR);
  test(""String_Node_Str"",null,AngularPass.INJECT_NON_FUNCTION_ERROR);
  test(""String_Node_Str"",null,AngularPass.INJECT_NON_FUNCTION_ERROR);
}",0.782608695652174
27877,"private void maybeSetBaseType(FunctionType fnType){
  if (!fnType.isInterface() && baseType != null) {
    fnType.setPrototypeBasedOn(baseType);
  }
}","private void maybeSetBaseType(FunctionType fnType){
  if (!fnType.isInterface() && baseType != null) {
    fnType.setPrototypeBasedOn(baseType);
    fnType.extendTemplateTypeMapBasedOn(baseType);
  }
}",0.8547008547008547
27878,"/** 
 * Expect that the first type is the direct superclass of the second type.
 * @param t The node traversal.
 * @param n The node where warnings should point to.
 * @param superObject The expected super instance type.
 * @param subObject The sub instance type.
 */
void expectSuperType(NodeTraversal t,Node n,ObjectType superObject,ObjectType subObject){
  FunctionType subCtor=subObject.getConstructor();
  ObjectType implicitProto=subObject.getImplicitPrototype();
  ObjectType declaredSuper=implicitProto == null ? null : implicitProto.getImplicitPrototype();
  if (declaredSuper != null && !(superObject instanceof UnknownType) && !declaredSuper.isEquivalentTo(superObject)) {
    if (declaredSuper.isEquivalentTo(getNativeType(OBJECT_TYPE))) {
      registerMismatch(superObject,declaredSuper,report(t.makeError(n,MISSING_EXTENDS_TAG_WARNING,subObject.toString())));
    }
 else {
      mismatch(t.getSourceName(),n,""String_Node_Str"",superObject,declaredSuper);
    }
    if (!subCtor.hasCachedValues()) {
      subCtor.setPrototypeBasedOn(superObject);
    }
  }
}","/** 
 * Expect that the first type is the direct superclass of the second type.
 * @param t The node traversal.
 * @param n The node where warnings should point to.
 * @param superObject The expected super instance type.
 * @param subObject The sub instance type.
 */
void expectSuperType(NodeTraversal t,Node n,ObjectType superObject,ObjectType subObject){
  FunctionType subCtor=subObject.getConstructor();
  ObjectType implicitProto=subObject.getImplicitPrototype();
  ObjectType declaredSuper=implicitProto == null ? null : implicitProto.getImplicitPrototype();
  if (declaredSuper != null && declaredSuper.isTemplatizedType()) {
    declaredSuper=declaredSuper.toMaybeTemplatizedType().getReferencedType();
  }
  if (declaredSuper != null && !(superObject instanceof UnknownType) && !declaredSuper.isEquivalentTo(superObject)) {
    if (declaredSuper.isEquivalentTo(getNativeType(OBJECT_TYPE))) {
      registerMismatch(superObject,declaredSuper,report(t.makeError(n,MISSING_EXTENDS_TAG_WARNING,subObject.toString())));
    }
 else {
      mismatch(t.getSourceName(),n,""String_Node_Str"",superObject,declaredSuper);
    }
    if (!subCtor.hasCachedValues()) {
      subCtor.setPrototypeBasedOn(superObject);
    }
  }
}",0.9346689895470384
27879,"void setPrototypeBasedOn(ObjectType baseType,Node propertyNode){
  if (baseType.hasReferenceName() || isNativeObjectType() || baseType.isFunctionPrototypeType()) {
    typeOfThis.extendTemplateTypeMap(baseType.getTemplateTypeMap());
    baseType=new PrototypeObjectType(registry,getReferenceName() + ""String_Node_Str"",baseType);
  }
  setPrototype(baseType,propertyNode);
}","void setPrototypeBasedOn(ObjectType baseType,Node propertyNode){
  if (baseType.hasReferenceName() || isNativeObjectType() || baseType.isFunctionPrototypeType()) {
    baseType=new PrototypeObjectType(registry,getReferenceName() + ""String_Node_Str"",baseType);
  }
  setPrototype(baseType,propertyNode);
}",0.8980797636632201
27880,"private FlowScope traverseObjectLiteral(Node n,FlowScope scope){
  JSType type=n.getJSType();
  Preconditions.checkNotNull(type);
  for (Node name=n.getFirstChild(); name != null; name=name.getNext()) {
    scope=traverse(name.getFirstChild(),scope);
  }
  ObjectType objectType=ObjectType.cast(type);
  if (objectType == null) {
    return scope;
  }
  boolean hasLendsName=n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;
  if (objectType.hasReferenceName() && !hasLendsName) {
    return scope;
  }
  String qObjName=NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));
  for (Node name=n.getFirstChild(); name != null; name=name.getNext()) {
    String memberName=NodeUtil.getObjectLitKeyName(name);
    if (memberName != null) {
      JSType rawValueType=name.getFirstChild().getJSType();
      JSType valueType=NodeUtil.getObjectLitKeyTypeFromValueType(name,rawValueType);
      if (valueType == null) {
        valueType=unknownType;
      }
      objectType.defineInferredProperty(memberName,valueType,name);
      if (qObjName != null && name.isStringKey()) {
        String qKeyName=qObjName + ""String_Node_Str"" + memberName;
        Var var=syntacticScope.getVar(qKeyName);
        JSType oldType=var == null ? null : var.getType();
        if (var != null && var.isTypeInferred()) {
          var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));
        }
        scope.inferQualifiedSlot(name,qKeyName,oldType == null ? unknownType : oldType,valueType);
      }
    }
 else {
      n.setJSType(unknownType);
    }
  }
  return scope;
}","private FlowScope traverseObjectLiteral(Node n,FlowScope scope){
  JSType type=n.getJSType();
  Preconditions.checkNotNull(type);
  for (Node name=n.getFirstChild(); name != null; name=name.getNext()) {
    scope=traverse(name.getFirstChild(),scope);
  }
  ObjectType objectType=ObjectType.cast(type);
  if (objectType == null || n.getBooleanProp(Node.REFLECTED_OBJECT)) {
    return scope;
  }
  String qObjName=NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));
  for (Node name=n.getFirstChild(); name != null; name=name.getNext()) {
    String memberName=NodeUtil.getObjectLitKeyName(name);
    if (memberName != null) {
      JSType rawValueType=name.getFirstChild().getJSType();
      JSType valueType=NodeUtil.getObjectLitKeyTypeFromValueType(name,rawValueType);
      if (valueType == null) {
        valueType=unknownType;
      }
      objectType.defineInferredProperty(memberName,valueType,name);
      if (qObjName != null && name.isStringKey()) {
        String qKeyName=qObjName + ""String_Node_Str"" + memberName;
        Var var=syntacticScope.getVar(qKeyName);
        JSType oldType=var == null ? null : var.getType();
        if (var != null && var.isTypeInferred()) {
          var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));
        }
        scope.inferQualifiedSlot(name,qKeyName,oldType == null ? unknownType : oldType,valueType);
      }
    }
 else {
      n.setJSType(unknownType);
    }
  }
  return scope;
}",0.931810766721044
27881,"/** 
 * Look for class-defining calls. Because JS has no 'native' syntax for defining classes, this is often very coding-convention dependent and business-logic heavy.
 */
private void checkForClassDefiningCalls(NodeTraversal t,Node n){
  SubclassRelationship relationship=codingConvention.getClassesDefinedByCall(n);
  if (relationship != null) {
    FunctionType superCtor=getFunctionType(scope.getVar(relationship.superclassName));
    FunctionType subCtor=getFunctionType(scope.getVar(relationship.subclassName));
    if (superCtor != null && superCtor.isConstructor() && subCtor != null && subCtor.isConstructor()) {
      ObjectType superClass=superCtor.getInstanceType();
      ObjectType subClass=subCtor.getInstanceType();
      superCtor=superClass.getConstructor();
      subCtor=subClass.getConstructor();
      if (relationship.type == SubclassType.INHERITS && !superClass.isEmptyType() && !subClass.isEmptyType()) {
        validator.expectSuperType(t,n,superClass,subClass);
      }
      if (superCtor != null && subCtor != null) {
        codingConvention.applySubclassRelationship(superCtor,subCtor,relationship.type);
      }
    }
  }
  String singletonGetterClassName=codingConvention.getSingletonGetterClassName(n);
  if (singletonGetterClassName != null) {
    ObjectType objectType=ObjectType.cast(typeRegistry.getType(singletonGetterClassName));
    if (objectType != null) {
      FunctionType functionType=objectType.getConstructor();
      if (functionType != null) {
        FunctionType getterType=typeRegistry.createFunctionType(objectType);
        codingConvention.applySingletonGetter(functionType,getterType,objectType);
      }
    }
  }
  DelegateRelationship delegateRelationship=codingConvention.getDelegateRelationship(n);
  if (delegateRelationship != null) {
    applyDelegateRelationship(delegateRelationship);
  }
  ObjectLiteralCast objectLiteralCast=codingConvention.getObjectLiteralCast(n);
  if (objectLiteralCast != null) {
    if (objectLiteralCast.diagnosticType == null) {
      ObjectType type=ObjectType.cast(typeRegistry.getType(objectLiteralCast.typeName));
      if (type != null && type.getConstructor() != null) {
        setDeferredType(objectLiteralCast.objectNode,type);
      }
 else {
        compiler.report(JSError.make(t.getSourceName(),n,CONSTRUCTOR_EXPECTED));
      }
    }
 else {
      compiler.report(JSError.make(t.getSourceName(),n,objectLiteralCast.diagnosticType));
    }
  }
}","/** 
 * Look for class-defining calls. Because JS has no 'native' syntax for defining classes, this is often very coding-convention dependent and business-logic heavy.
 */
private void checkForClassDefiningCalls(NodeTraversal t,Node n){
  SubclassRelationship relationship=codingConvention.getClassesDefinedByCall(n);
  if (relationship != null) {
    FunctionType superCtor=getFunctionType(scope.getVar(relationship.superclassName));
    FunctionType subCtor=getFunctionType(scope.getVar(relationship.subclassName));
    if (superCtor != null && superCtor.isConstructor() && subCtor != null && subCtor.isConstructor()) {
      ObjectType superClass=superCtor.getInstanceType();
      ObjectType subClass=subCtor.getInstanceType();
      superCtor=superClass.getConstructor();
      subCtor=subClass.getConstructor();
      if (relationship.type == SubclassType.INHERITS && !superClass.isEmptyType() && !subClass.isEmptyType()) {
        validator.expectSuperType(t,n,superClass,subClass);
      }
      if (superCtor != null && subCtor != null) {
        codingConvention.applySubclassRelationship(superCtor,subCtor,relationship.type);
      }
    }
  }
  String singletonGetterClassName=codingConvention.getSingletonGetterClassName(n);
  if (singletonGetterClassName != null) {
    ObjectType objectType=ObjectType.cast(typeRegistry.getType(singletonGetterClassName));
    if (objectType != null) {
      FunctionType functionType=objectType.getConstructor();
      if (functionType != null) {
        FunctionType getterType=typeRegistry.createFunctionType(objectType);
        codingConvention.applySingletonGetter(functionType,getterType,objectType);
      }
    }
  }
  DelegateRelationship delegateRelationship=codingConvention.getDelegateRelationship(n);
  if (delegateRelationship != null) {
    applyDelegateRelationship(delegateRelationship);
  }
  ObjectLiteralCast objectLiteralCast=codingConvention.getObjectLiteralCast(n);
  if (objectLiteralCast != null) {
    if (objectLiteralCast.diagnosticType == null) {
      ObjectType type=ObjectType.cast(typeRegistry.getType(objectLiteralCast.typeName));
      if (type != null && type.getConstructor() != null) {
        setDeferredType(objectLiteralCast.objectNode,type);
        objectLiteralCast.objectNode.putBooleanProp(Node.REFLECTED_OBJECT,true);
      }
 else {
        compiler.report(JSError.make(t.getSourceName(),n,CONSTRUCTOR_EXPECTED));
      }
    }
 else {
      compiler.report(JSError.make(t.getSourceName(),n,objectLiteralCast.diagnosticType));
    }
  }
}",0.983764281419122
27882,"/** 
 * Determines whether a qualified name is inferred. NOTE(nicksantos): Determining whether a property is declared or not is really really obnoxious. The problem is that there are two (equally valid) coding styles: (function() { /* The authoritative definition of goog.bar. / goog.bar = function() {}; })(); function f() { goog.bar(); /* Reset goog.bar to a no-op. / goog.bar = function() {}; } In a dynamic language with first-class functions, it's very difficult to know which one the user intended without looking at lots of contextual information (the second example demonstrates a small case of this, but there are some really pathological cases as well). The current algorithm checks if either the declaration has JsDoc type information, or @const with a known type, or a function literal with a name we haven't seen before.
 */
private boolean isQualifiedNameInferred(String qName,Node n,JSDocInfo info,Node rhsValue,JSType valueType){
  if (valueType == null) {
    return true;
  }
  boolean inferred=true;
  if (info != null) {
    inferred=!(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info,n) && valueType != null && !valueType.isUnknownType())|| FunctionTypeBuilder.isFunctionTypeDeclaration(info));
  }
  if (inferred && rhsValue != null && rhsValue.isFunction()) {
    if (info != null) {
      return false;
    }
 else     if (!scope.isDeclared(qName,false) && n.isUnscopedQualifiedName()) {
      for (Node current=n.getParent(); !(current.isScript() || current.isFunction()); current=current.getParent()) {
        if (NodeUtil.isControlStructure(current)) {
          return true;
        }
      }
      AstFunctionContents contents=getFunctionAnalysisResults(scope.getRootNode());
      if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {
        return false;
      }
    }
  }
  return inferred;
}","/** 
 * Determines whether a qualified name is inferred. NOTE(nicksantos): Determining whether a property is declared or not is really really obnoxious. The problem is that there are two (equally valid) coding styles: (function() { /* The authoritative definition of goog.bar. / goog.bar = function() {}; })(); function f() { goog.bar(); /* Reset goog.bar to a no-op. / goog.bar = function() {}; } In a dynamic language with first-class functions, it's very difficult to know which one the user intended without looking at lots of contextual information (the second example demonstrates a small case of this, but there are some really pathological cases as well). The current algorithm checks if either the declaration has JsDoc type information, or @const with a known type, or a function literal with a name we haven't seen before.
 */
private boolean isQualifiedNameInferred(String qName,Node n,JSDocInfo info,Node rhsValue,JSType valueType){
  if (valueType == null) {
    return true;
  }
  if (qName != null && qName.endsWith(""String_Node_Str"")) {
    return false;
  }
  boolean inferred=true;
  if (info != null) {
    inferred=!(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info,n) && valueType != null && !valueType.isUnknownType())|| FunctionTypeBuilder.isFunctionTypeDeclaration(info));
  }
  if (inferred && rhsValue != null && rhsValue.isFunction()) {
    if (info != null) {
      return false;
    }
 else     if (!scope.isDeclared(qName,false) && n.isUnscopedQualifiedName()) {
      for (Node current=n.getParent(); !(current.isScript() || current.isFunction()); current=current.getParent()) {
        if (NodeUtil.isControlStructure(current)) {
          return true;
        }
      }
      AstFunctionContents contents=getFunctionAnalysisResults(scope.getRootNode());
      if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {
        return false;
      }
    }
  }
  return inferred;
}",0.9613778705636744
27883,"private static final String propToString(int propType){
switch (propType) {
case VAR_ARGS_NAME:
    return ""String_Node_Str"";
case JSDOC_INFO_PROP:
  return ""String_Node_Str"";
case INCRDECR_PROP:
return ""String_Node_Str"";
case QUOTED_PROP:
return ""String_Node_Str"";
case OPT_ARG_NAME:
return ""String_Node_Str"";
case SYNTHETIC_BLOCK_PROP:
return ""String_Node_Str"";
case EMPTY_BLOCK:
return ""String_Node_Str"";
case ORIGINALNAME_PROP:
return ""String_Node_Str"";
case SIDE_EFFECT_FLAGS:
return ""String_Node_Str"";
case IS_CONSTANT_NAME:
return ""String_Node_Str"";
case IS_NAMESPACE:
return ""String_Node_Str"";
case IS_DISPATCHER:
return ""String_Node_Str"";
case DIRECTIVES:
return ""String_Node_Str"";
case DIRECT_EVAL:
return ""String_Node_Str"";
case FREE_CALL:
return ""String_Node_Str"";
case STATIC_SOURCE_FILE:
return ""String_Node_Str"";
case INPUT_ID:
return ""String_Node_Str"";
case LENGTH:
return ""String_Node_Str"";
case SLASH_V:
return ""String_Node_Str"";
case INFERRED_FUNCTION:
return ""String_Node_Str"";
case CHANGE_TIME:
return ""String_Node_Str"";
default :
throw new IllegalStateException(""String_Node_Str"" + propType);
}
}","private static final String propToString(int propType){
switch (propType) {
case VAR_ARGS_NAME:
    return ""String_Node_Str"";
case JSDOC_INFO_PROP:
  return ""String_Node_Str"";
case INCRDECR_PROP:
return ""String_Node_Str"";
case QUOTED_PROP:
return ""String_Node_Str"";
case OPT_ARG_NAME:
return ""String_Node_Str"";
case SYNTHETIC_BLOCK_PROP:
return ""String_Node_Str"";
case EMPTY_BLOCK:
return ""String_Node_Str"";
case ORIGINALNAME_PROP:
return ""String_Node_Str"";
case SIDE_EFFECT_FLAGS:
return ""String_Node_Str"";
case IS_CONSTANT_NAME:
return ""String_Node_Str"";
case IS_NAMESPACE:
return ""String_Node_Str"";
case IS_DISPATCHER:
return ""String_Node_Str"";
case DIRECTIVES:
return ""String_Node_Str"";
case DIRECT_EVAL:
return ""String_Node_Str"";
case FREE_CALL:
return ""String_Node_Str"";
case STATIC_SOURCE_FILE:
return ""String_Node_Str"";
case INPUT_ID:
return ""String_Node_Str"";
case LENGTH:
return ""String_Node_Str"";
case SLASH_V:
return ""String_Node_Str"";
case INFERRED_FUNCTION:
return ""String_Node_Str"";
case CHANGE_TIME:
return ""String_Node_Str"";
case REFLECTED_OBJECT:
return ""String_Node_Str"";
default :
throw new IllegalStateException(""String_Node_Str"" + propType);
}
}",0.9785557986870898
27884,"public void testPropertiesOnInterface2() throws Exception {
  testSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  Var i=globalScope.getVar(""String_Node_Str"");
  assertEquals(""String_Node_Str"",i.getType().toString());
  assertTrue(i.getType().isInterface());
  ObjectType iPrototype=(ObjectType)((ObjectType)i.getType()).getPropertyType(""String_Node_Str"");
  assertEquals(""String_Node_Str"",iPrototype.toString());
  assertTrue(iPrototype.isFunctionPrototypeType());
  assertEquals(""String_Node_Str"",iPrototype.getPropertyType(""String_Node_Str"").toString());
  assertEquals(""String_Node_Str"",iPrototype.getPropertyType(""String_Node_Str"").toString());
  assertNull(globalScope.getVar(""String_Node_Str""));
}","public void testPropertiesOnInterface2() throws Exception {
  testSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  Var i=globalScope.getVar(""String_Node_Str"");
  assertEquals(""String_Node_Str"",i.getType().toString());
  assertTrue(i.getType().isInterface());
  ObjectType iPrototype=(ObjectType)((ObjectType)i.getType()).getPropertyType(""String_Node_Str"");
  assertEquals(""String_Node_Str"",iPrototype.toString());
  assertTrue(iPrototype.isFunctionPrototypeType());
  assertEquals(""String_Node_Str"",iPrototype.getPropertyType(""String_Node_Str"").toString());
  assertEquals(""String_Node_Str"",iPrototype.getPropertyType(""String_Node_Str"").toString());
  assertEquals(iPrototype,globalScope.getVar(""String_Node_Str"").getType());
}",0.9775051124744376
27885,"/** 
 * Determines whether we know enough about the given value to be able to collapse it into subsequent expressions. For example, we can collapse booleans and variable names: <code> x = 3; y = x; // y = x = 3; a = true; b = true; // b = a = true; <code> But we won't try to collapse complex expressions.
 * @param value The value node.
 * @param isLValue Whether it's on the left-hand side of an expr.
 */
private boolean isCollapsibleValue(Node value,boolean isLValue){
switch (value.getType()) {
case Token.GETPROP:
    return !isLValue || value.getFirstChild().isThis();
case Token.NAME:
  return true;
default :
return NodeUtil.isImmutableValue(value);
}
}","/** 
 * Determines whether we know enough about the given value to be able to collapse it into subsequent expressions. For example, we can collapse booleans and variable names: <code> x = 3; y = x; // y = x = 3; a = true; b = true; // b = a = true; <code> But we won't try to collapse complex expressions.
 * @param value The value node.
 * @param isLValue Whether it's on the left-hand side of an expr.
 */
private static boolean isCollapsibleValue(Node value,boolean isLValue){
switch (value.getType()) {
case Token.GETPROP:
    return !isLValue || value.getFirstChild().isThis();
case Token.NAME:
  return true;
default :
return NodeUtil.isImmutableValue(value);
}
}",0.994740796393689
27886,"/** 
 * Checks name referenced in node to determine if it might have changed.
 * @return Whether the replacement can be made.
 */
private boolean isSafeReplacement(Node node,Node replacement){
  if (node.isName()) {
    return true;
  }
  Preconditions.checkArgument(node.isGetProp());
  Node name=node.getFirstChild();
  if (name.isName() && isNameAssignedTo(name.getString(),replacement)) {
    return false;
  }
  return true;
}","/** 
 * Checks name referenced in node to determine if it might have changed.
 * @return Whether the replacement can be made.
 */
private boolean isSafeReplacement(Node node,Node replacement){
  if (node.isName()) {
    return true;
  }
  Preconditions.checkArgument(node.isGetProp());
  while (node.isGetProp()) {
    node=node.getFirstChild();
  }
  if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {
    return false;
  }
  return true;
}",0.9282511210762332
27887,"/** 
 * Tries to attach currentJsdoc to n or one of its descendants. If the jsdoc starts after n, we return null. If the jsdoc is attached, we return the node on which it was attached. Last, if it was contained in n but didn't get attached, we return some node close to where the comment would get attached. The node that gets returned from this function is where the search for attaching the next comment will start from. A comment never gets attached to a node that appears before it in the code.
 * @param parapos n's parent's absolute position; we calculate it manuallyb/c it's slow to call getAbsolutePosition for every node.
 */
private NodePos attachComment(AstNode n,int parapos){
  int napos=parapos + n.getPosition();
  if (finishesAfterJsdoc(n,napos)) {
    if (capos < napos && !attachToChildren(n,napos)) {
      return setJsdoc(n,napos);
    }
  }
 else {
    return null;
  }
  int ntype=n.getType();
  NodePos res;
switch (ntype) {
case Token.BREAK:
case Token.CONTINUE:
    return new NodePos(n,napos);
case Token.CASE:
  SwitchCase cas=(SwitchCase)n;
if (!cas.isDefault()) {
  res=attachComment(cas.getExpression(),napos);
  if (res != null) {
    return res;
  }
}
if (cas.getStatements() != null) {
for (AstNode stm : cas.getStatements()) {
  res=attachComment(stm,napos);
  if (res != null) {
    return res;
  }
}
}
return new NodePos(n,napos);
case Token.DO:
DoLoop dl=(DoLoop)n;
res=attachComment(dl.getBody(),napos);
if (res != null) {
return res;
}
if (capos < dl.getWhilePosition()) {
return new NodePos(n,napos);
}
res=attachComment(dl.getCondition(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.EXPR_RESULT:
case Token.EXPR_VOID:
if (n instanceof ExpressionStatement) {
res=attachComment(((ExpressionStatement)n).getExpression(),napos);
}
 else {
res=attachComment(((LabeledStatement)n).getStatement(),napos);
}
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.FOR:
Loop loop=(Loop)n;
if (n instanceof ForInLoop) {
res=attachForInHeader((ForInLoop)loop,napos);
}
 else {
res=attachForLoopHeader((ForLoop)loop,napos);
}
if (res != null) {
return res;
}
res=attachComment(loop.getBody(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.IF:
IfStatement ifstm=(IfStatement)n;
res=attachComment(ifstm.getCondition(),napos);
if (res != null) {
return res;
}
res=attachComment(ifstm.getThenPart(),napos);
if (res != null) {
return res;
}
if (capos < ifstm.getElsePosition()) {
return new NodePos(n,napos);
}
res=attachComment(ifstm.getElsePart(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.FUNCTION:
FunctionNode fun=(FunctionNode)n;
Name nam=fun.getFunctionName();
if (nam != null) {
res=attachComment(nam,napos);
if (res != null) {
return res;
}
}
for (AstNode param : fun.getParams()) {
res=attachComment(param,napos);
if (res != null) {
return res;
}
}
res=attachComment(fun.getBody(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.RETURN:
res=attachComment(((ReturnStatement)n).getReturnValue(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.SWITCH:
SwitchStatement sw=(SwitchStatement)n;
res=attachComment(sw.getExpression(),napos);
if (res != null) {
return res;
}
for (SwitchCase c : sw.getCases()) {
res=attachComment(c,napos);
}
return new NodePos(n,napos);
case Token.THROW:
res=attachComment(((ThrowStatement)n).getExpression(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.TRY:
TryStatement t=(TryStatement)n;
res=attachComment(t.getTryBlock(),napos);
if (res != null) {
return res;
}
for (CatchClause cc : t.getCatchClauses()) {
int catchstart=napos + cc.getPosition();
if (capos < catchstart) {
return new NodePos(n,napos);
}
res=attachComment(cc.getVarName(),catchstart);
if (res != null) {
return res;
}
res=attachComment(cc.getBody(),catchstart);
if (res != null) {
return res;
}
}
return new NodePos(n,napos);
case Token.VAR:
if (n instanceof VariableDeclaration) {
for (VariableInitializer vi : ((VariableDeclaration)n).getVariables()) {
res=attachComment(vi,napos);
if (res != null) {
return res;
}
}
}
 else {
res=attachComment(((VariableInitializer)n).getInitializer(),napos);
if (res != null) {
return res;
}
}
return new NodePos(n,napos);
case Token.WHILE:
WhileLoop wh=(WhileLoop)n;
res=attachComment(wh.getCondition(),napos);
if (res != null) {
return res;
}
if (capos < wh.getRp()) {
return new NodePos(n,napos);
}
res=attachComment(wh.getBody(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.WITH:
WithStatement w=(WithStatement)n;
res=attachComment(w.getExpression(),napos);
if (res != null) {
return res;
}
if (capos < w.getRp()) {
return new NodePos(n,napos);
}
res=attachComment(w.getStatement(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.ADD:
case Token.AND:
case Token.ASSIGN:
case Token.ASSIGN_ADD:
case Token.ASSIGN_BITAND:
case Token.ASSIGN_BITOR:
case Token.ASSIGN_BITXOR:
case Token.ASSIGN_DIV:
case Token.ASSIGN_LSH:
case Token.ASSIGN_MOD:
case Token.ASSIGN_MUL:
case Token.ASSIGN_RSH:
case Token.ASSIGN_SUB:
case Token.ASSIGN_URSH:
case Token.BITAND:
case Token.BITOR:
case Token.BITXOR:
case Token.COLON:
case Token.COMMA:
case Token.DIV:
case Token.EQ:
case Token.GE:
case Token.GET:
case Token.GETPROP:
case Token.GT:
case Token.IN:
case Token.INSTANCEOF:
case Token.LE:
case Token.LSH:
case Token.LT:
case Token.MOD:
case Token.MUL:
case Token.NE:
case Token.OR:
case Token.RSH:
case Token.SET:
case Token.SHEQ:
case Token.SHNE:
case Token.SUB:
case Token.URSH:
InfixExpression ie=(InfixExpression)n;
res=attachComment(ie.getLeft(),napos);
if (res != null) {
return res;
}
if (capos < ie.getOperatorPosition()) {
return new NodePos(n,napos);
}
res=attachComment(ie.getRight(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.ARRAYLIT:
for (AstNode elm : ((ArrayLiteral)n).getElements()) {
res=attachComment(elm,napos);
if (res != null) {
return res;
}
}
return new NodePos(n,napos);
case Token.BITNOT:
case Token.DEC:
case Token.DELPROP:
case Token.INC:
case Token.NEG:
case Token.NOT:
case Token.POS:
case Token.TYPEOF:
case Token.VOID:
UnaryExpression ue=(UnaryExpression)n;
res=attachComment(ue.getOperand(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.CALL:
case Token.NEW:
FunctionCall call=(FunctionCall)n;
res=attachComment(call.getTarget(),napos);
if (res != null) {
return res;
}
if (capos < call.getLp()) {
return new NodePos(n,napos);
}
for (AstNode param : call.getArguments()) {
res=attachComment(param,napos);
if (res != null) {
return res;
}
}
return new NodePos(n,napos);
case Token.GETELEM:
ElementGet elm=(ElementGet)n;
res=attachComment(elm.getTarget(),napos);
if (res != null) {
return res;
}
if (capos < elm.getLb()) {
return new NodePos(n,napos);
}
res=attachComment(elm.getElement(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.HOOK:
ConditionalExpression hook=(ConditionalExpression)n;
res=attachComment(hook.getTestExpression(),napos);
if (res != null) {
return res;
}
if (capos < hook.getQuestionMarkPosition()) {
return new NodePos(n,napos);
}
res=attachComment(hook.getTrueExpression(),napos);
if (res != null) {
return res;
}
if (capos < hook.getColonPosition()) {
return new NodePos(n,napos);
}
res=attachComment(hook.getFalseExpression(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.LP:
res=attachComment(((ParenthesizedExpression)n).getExpression(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.OBJECTLIT:
for (InfixExpression prop : ((ObjectLiteral)n).getElements()) {
res=attachComment(prop,napos);
if (res != null) {
return res;
}
}
return new NodePos(n,napos);
case Token.BLOCK:
case Token.SCRIPT:
AstNode kid=(AstNode)n.getFirstChild();
while (kid != null) {
res=attachComment(kid,napos);
if (res != null) {
return res;
}
kid=(AstNode)kid.getNext();
}
return new NodePos(n,napos);
default :
throw new RuntimeException(""String_Node_Str"" + ntype);
}
}","/** 
 * Tries to attach currentJsdoc to n or one of its descendants. If the jsdoc starts after n, we return null. If the jsdoc is attached, we return the node on which it was attached. Last, if it was contained in n but didn't get attached, we return some node close to where the comment would get attached. The node that gets returned from this function is where the search for attaching the next comment will start from. A comment never gets attached to a node that appears before it in the code.
 * @param parapos n's parent's absolute position; we calculate it manuallyb/c it's slow to call getAbsolutePosition for every node.
 */
private NodePos attachComment(AstNode n,int parapos){
  int napos=parapos + n.getPosition();
  if (finishesAfterJsdoc(n,napos)) {
    if (capos < napos && !attachToChildren(n,napos)) {
      return setJsdoc(n,napos);
    }
  }
 else {
    return null;
  }
  int ntype=n.getType();
  NodePos res;
switch (ntype) {
case Token.BREAK:
case Token.CONTINUE:
    return new NodePos(n,napos);
case Token.CASE:
  SwitchCase cas=(SwitchCase)n;
if (!cas.isDefault()) {
  res=attachComment(cas.getExpression(),napos);
  if (res != null) {
    return res;
  }
}
if (cas.getStatements() != null) {
for (AstNode stm : cas.getStatements()) {
  res=attachComment(stm,napos);
  if (res != null) {
    return res;
  }
}
}
return new NodePos(n,napos);
case Token.DO:
DoLoop dl=(DoLoop)n;
res=attachComment(dl.getBody(),napos);
if (res != null) {
return res;
}
if (capos < dl.getWhilePosition()) {
return new NodePos(n,napos);
}
res=attachComment(dl.getCondition(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.EXPR_RESULT:
case Token.EXPR_VOID:
if (n instanceof ExpressionStatement) {
res=attachComment(((ExpressionStatement)n).getExpression(),napos);
}
 else {
res=attachComment(((LabeledStatement)n).getStatement(),napos);
}
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.FOR:
Loop loop=(Loop)n;
if (n instanceof ForInLoop) {
res=attachForInHeader((ForInLoop)loop,napos);
}
 else {
res=attachForLoopHeader((ForLoop)loop,napos);
}
if (res != null) {
return res;
}
res=attachComment(loop.getBody(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.IF:
IfStatement ifstm=(IfStatement)n;
res=attachComment(ifstm.getCondition(),napos);
if (res != null) {
return res;
}
res=attachComment(ifstm.getThenPart(),napos);
if (res != null) {
return res;
}
if (capos < ifstm.getElsePosition()) {
return new NodePos(n,napos);
}
res=attachComment(ifstm.getElsePart(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.FUNCTION:
FunctionNode fun=(FunctionNode)n;
Name nam=fun.getFunctionName();
if (nam != null) {
res=attachComment(nam,napos);
if (res != null) {
return res;
}
}
for (AstNode param : fun.getParams()) {
res=attachComment(param,napos);
if (res != null) {
return res;
}
}
res=attachComment(fun.getBody(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.RETURN:
res=attachComment(((ReturnStatement)n).getReturnValue(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.SWITCH:
SwitchStatement sw=(SwitchStatement)n;
res=attachComment(sw.getExpression(),napos);
if (res != null) {
return res;
}
for (SwitchCase c : sw.getCases()) {
res=attachComment(c,napos);
}
return new NodePos(n,napos);
case Token.THROW:
res=attachComment(((ThrowStatement)n).getExpression(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.TRY:
TryStatement t=(TryStatement)n;
res=attachComment(t.getTryBlock(),napos);
if (res != null) {
return res;
}
for (CatchClause cc : t.getCatchClauses()) {
int catchstart=napos + cc.getPosition();
if (capos < catchstart) {
return new NodePos(n,napos);
}
res=attachComment(cc.getVarName(),catchstart);
if (res != null) {
return res;
}
res=attachComment(cc.getBody(),catchstart);
if (res != null) {
return res;
}
}
int finpos=t.getFinallyPosition();
if (finpos != -1) {
if (capos < finpos) {
return new NodePos(n,napos);
}
res=attachComment(t.getFinallyBlock(),napos);
if (res != null) {
return res;
}
}
return new NodePos(n,napos);
case Token.VAR:
if (n instanceof VariableDeclaration) {
for (VariableInitializer vi : ((VariableDeclaration)n).getVariables()) {
res=attachComment(vi,napos);
if (res != null) {
return res;
}
}
}
 else {
res=attachComment(((VariableInitializer)n).getInitializer(),napos);
if (res != null) {
return res;
}
}
return new NodePos(n,napos);
case Token.WHILE:
WhileLoop wh=(WhileLoop)n;
res=attachComment(wh.getCondition(),napos);
if (res != null) {
return res;
}
if (capos < wh.getRp()) {
return new NodePos(n,napos);
}
res=attachComment(wh.getBody(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.WITH:
WithStatement w=(WithStatement)n;
res=attachComment(w.getExpression(),napos);
if (res != null) {
return res;
}
if (capos < w.getRp()) {
return new NodePos(n,napos);
}
res=attachComment(w.getStatement(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.ADD:
case Token.AND:
case Token.ASSIGN:
case Token.ASSIGN_ADD:
case Token.ASSIGN_BITAND:
case Token.ASSIGN_BITOR:
case Token.ASSIGN_BITXOR:
case Token.ASSIGN_DIV:
case Token.ASSIGN_LSH:
case Token.ASSIGN_MOD:
case Token.ASSIGN_MUL:
case Token.ASSIGN_RSH:
case Token.ASSIGN_SUB:
case Token.ASSIGN_URSH:
case Token.BITAND:
case Token.BITOR:
case Token.BITXOR:
case Token.COLON:
case Token.COMMA:
case Token.DIV:
case Token.EQ:
case Token.GE:
case Token.GET:
case Token.GETPROP:
case Token.GT:
case Token.IN:
case Token.INSTANCEOF:
case Token.LE:
case Token.LSH:
case Token.LT:
case Token.MOD:
case Token.MUL:
case Token.NE:
case Token.OR:
case Token.RSH:
case Token.SET:
case Token.SHEQ:
case Token.SHNE:
case Token.SUB:
case Token.URSH:
InfixExpression ie=(InfixExpression)n;
res=attachComment(ie.getLeft(),napos);
if (res != null) {
return res;
}
if (capos < ie.getOperatorPosition()) {
return new NodePos(n,napos);
}
res=attachComment(ie.getRight(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.ARRAYLIT:
for (AstNode elm : ((ArrayLiteral)n).getElements()) {
res=attachComment(elm,napos);
if (res != null) {
return res;
}
}
return new NodePos(n,napos);
case Token.BITNOT:
case Token.DEC:
case Token.DELPROP:
case Token.INC:
case Token.NEG:
case Token.NOT:
case Token.POS:
case Token.TYPEOF:
case Token.VOID:
UnaryExpression ue=(UnaryExpression)n;
res=attachComment(ue.getOperand(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.CALL:
case Token.NEW:
FunctionCall call=(FunctionCall)n;
res=attachComment(call.getTarget(),napos);
if (res != null) {
return res;
}
if (capos < call.getLp()) {
return new NodePos(n,napos);
}
for (AstNode param : call.getArguments()) {
res=attachComment(param,napos);
if (res != null) {
return res;
}
}
return new NodePos(n,napos);
case Token.GETELEM:
ElementGet elm=(ElementGet)n;
res=attachComment(elm.getTarget(),napos);
if (res != null) {
return res;
}
if (capos < elm.getLb()) {
return new NodePos(n,napos);
}
res=attachComment(elm.getElement(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.HOOK:
ConditionalExpression hook=(ConditionalExpression)n;
res=attachComment(hook.getTestExpression(),napos);
if (res != null) {
return res;
}
if (capos < hook.getQuestionMarkPosition()) {
return new NodePos(n,napos);
}
res=attachComment(hook.getTrueExpression(),napos);
if (res != null) {
return res;
}
if (capos < hook.getColonPosition()) {
return new NodePos(n,napos);
}
res=attachComment(hook.getFalseExpression(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.LP:
res=attachComment(((ParenthesizedExpression)n).getExpression(),napos);
if (res != null) {
return res;
}
return new NodePos(n,napos);
case Token.OBJECTLIT:
for (InfixExpression prop : ((ObjectLiteral)n).getElements()) {
res=attachComment(prop,napos);
if (res != null) {
return res;
}
}
return new NodePos(n,napos);
case Token.BLOCK:
case Token.SCRIPT:
AstNode kid=(AstNode)n.getFirstChild();
while (kid != null) {
res=attachComment(kid,napos);
if (res != null) {
return res;
}
kid=(AstNode)kid.getNext();
}
return new NodePos(n,napos);
default :
throw new RuntimeException(""String_Node_Str"" + ntype);
}
}",0.988514129443938
27888,"/** 
 * Set no side effect property at pure-function call sites.
 */
private void markPureFunctionCalls(){
  for (  Node callNode : allFunctionCalls) {
    Node name=callNode.getFirstChild();
    Collection<Definition> defs=getCallableDefinitions(definitionProvider,name);
    Node.SideEffectFlags flags=new Node.SideEffectFlags();
    if (defs == null) {
      flags.setMutatesGlobalState();
      flags.setThrows();
      flags.setReturnsTainted();
    }
 else {
      flags.clearAllFlags();
      for (      Definition def : defs) {
        FunctionInformation functionInfo=functionSideEffectMap.get(def.getRValue());
        Preconditions.checkNotNull(functionInfo);
        if (functionInfo.mutatesGlobalState()) {
          flags.setMutatesGlobalState();
        }
        if (functionInfo.functionThrows) {
          flags.setThrows();
        }
        if (!callNode.isNew()) {
          if (functionInfo.taintsThis) {
            flags.setMutatesThis();
          }
        }
        if (functionInfo.taintsReturn) {
          flags.setReturnsTainted();
        }
        if (flags.areAllFlagsSet()) {
          break;
        }
      }
    }
    if (callNode.isCall()) {
      Preconditions.checkState(compiler != null);
      if (!NodeUtil.functionCallHasSideEffects(callNode,compiler)) {
        flags.clearSideEffectFlags();
      }
    }
 else     if (callNode.isNew()) {
      if (!NodeUtil.constructorCallHasSideEffects(callNode)) {
        flags.clearSideEffectFlags();
      }
    }
    callNode.setSideEffectFlags(flags.valueOf());
  }
}","/** 
 * Set no side effect property at pure-function call sites.
 */
private void markPureFunctionCalls(){
  for (  Node callNode : allFunctionCalls) {
    Node name=callNode.getFirstChild();
    Collection<Definition> defs=getCallableDefinitions(definitionProvider,name);
    Node.SideEffectFlags flags=new Node.SideEffectFlags();
    if (defs == null) {
      flags.setMutatesGlobalState();
      flags.setThrows();
      flags.setReturnsTainted();
    }
 else {
      flags.clearAllFlags();
      for (      Definition def : defs) {
        FunctionInformation functionInfo=functionSideEffectMap.get(def.getRValue());
        Preconditions.checkNotNull(functionInfo);
        if (functionInfo.mutatesGlobalState()) {
          flags.setMutatesGlobalState();
        }
        if (functionInfo.functionThrows) {
          flags.setThrows();
        }
        if (!callNode.isNew()) {
          if (functionInfo.taintsThis) {
            if (isCallOrApply(callNode)) {
              flags.setMutatesArguments();
            }
 else {
              flags.setMutatesThis();
            }
          }
        }
        if (functionInfo.taintsReturn) {
          flags.setReturnsTainted();
        }
        if (flags.areAllFlagsSet()) {
          break;
        }
      }
    }
    if (callNode.isCall()) {
      Preconditions.checkState(compiler != null);
      if (!NodeUtil.functionCallHasSideEffects(callNode,compiler)) {
        flags.clearSideEffectFlags();
      }
    }
 else     if (callNode.isNew()) {
      if (!NodeUtil.constructorCallHasSideEffects(callNode)) {
        flags.clearSideEffectFlags();
      }
    }
    callNode.setSideEffectFlags(flags.valueOf());
  }
}",0.96168108776267
27889,"@Override public boolean traverseEdge(FunctionInformation callee,Node callSite,FunctionInformation caller){
  Preconditions.checkArgument(callSite.isCall() || callSite.isNew());
  boolean changed=false;
  if (!caller.mutatesGlobalState() && callee.mutatesGlobalState()) {
    caller.setTaintsGlobalState();
    changed=true;
  }
  if (!caller.functionThrows() && callee.functionThrows()) {
    caller.setFunctionThrows();
    changed=true;
  }
  if (callee.mutatesThis()) {
    if (!callSite.isNew()) {
      Node objectNode=getCallThisObject(callSite);
      if (objectNode != null && objectNode.isName() && !isCallOrApply(callSite)) {
        if (!caller.mutatesGlobalState()) {
          caller.setTaintsGlobalState();
          changed=true;
        }
      }
 else       if (objectNode != null && objectNode.isThis()) {
        if (!caller.mutatesThis()) {
          caller.setTaintsThis();
          changed=true;
        }
      }
 else       if (objectNode != null && NodeUtil.evaluatesToLocalValue(objectNode) && !isCallOrApply(callSite)) {
      }
 else       if (!caller.mutatesGlobalState()) {
        caller.setTaintsGlobalState();
        changed=true;
      }
    }
  }
  return changed;
}","@Override public boolean traverseEdge(FunctionInformation callee,Node callSite,FunctionInformation caller){
  Preconditions.checkArgument(callSite.isCall() || callSite.isNew());
  boolean changed=false;
  if (!caller.mutatesGlobalState() && callee.mutatesGlobalState()) {
    caller.setTaintsGlobalState();
    changed=true;
  }
  if (!caller.functionThrows() && callee.functionThrows()) {
    caller.setFunctionThrows();
    changed=true;
  }
  if (callee.mutatesThis()) {
    if (!callSite.isNew()) {
      boolean isCallOrApply=isCallOrApply(callSite);
      Node objectNode=isCallOrApply ? callSite.getFirstChild().getNext() : callSite.getFirstChild().getFirstChild();
      if (objectNode != null && objectNode.isName() && !isCallOrApply) {
        if (!caller.mutatesGlobalState()) {
          caller.setTaintsGlobalState();
          changed=true;
        }
      }
 else       if (objectNode != null && objectNode.isThis()) {
        if (!caller.mutatesThis()) {
          caller.setTaintsThis();
          changed=true;
        }
      }
 else       if (objectNode != null && NodeUtil.evaluatesToLocalValue(objectNode) && !isCallOrApply) {
      }
 else       if (!caller.mutatesGlobalState()) {
        caller.setTaintsGlobalState();
        changed=true;
      }
    }
  }
  return changed;
}",0.5496609493418428
27890,"private static boolean isCallOrApply(Node callSite){
  Node callTarget=callSite.getFirstChild();
  if (NodeUtil.isGet(callTarget)) {
    String propString=callTarget.getLastChild().getString();
    if (propString.equals(""String_Node_Str"") || propString.equals(""String_Node_Str"")) {
      return true;
    }
  }
  return false;
}","private static boolean isCallOrApply(Node callSite){
  return NodeUtil.isFunctionObjectCall(callSite) || NodeUtil.isFunctionObjectApply(callSite);
}",0.407563025210084
27891,"public void setMutatesArguments(){
  removeFlag(Node.FLAG_ARGUMENTS_UNMODIFIED);
}","public SideEffectFlags setMutatesArguments(){
  removeFlag(Node.FLAG_ARGUMENTS_UNMODIFIED);
  return this;
}",0.8421052631578947
27892,"public void setMutatesGlobalState(){
  removeFlag(Node.FLAG_GLOBAL_STATE_UNMODIFIED);
  removeFlag(Node.FLAG_ARGUMENTS_UNMODIFIED);
  removeFlag(Node.FLAG_THIS_UNMODIFIED);
}","public SideEffectFlags setMutatesGlobalState(){
  removeFlag(Node.FLAG_GLOBAL_STATE_UNMODIFIED);
  removeFlag(Node.FLAG_ARGUMENTS_UNMODIFIED);
  removeFlag(Node.FLAG_THIS_UNMODIFIED);
  return this;
}",0.0641711229946524
27893,"/** 
 * No side-effects occur and the returned results are local. 
 */
public void clearAllFlags(){
  value=Node.NO_SIDE_EFFECTS | Node.FLAG_LOCAL_RESULTS;
}","/** 
 * No side-effects occur and the returned results are local. 
 */
public SideEffectFlags clearAllFlags(){
  value=Node.NO_SIDE_EFFECTS | Node.FLAG_LOCAL_RESULTS;
  return this;
}",0.9117647058823528
27894,"public void setThrows(){
  removeFlag(Node.FLAG_NO_THROWS);
}","public SideEffectFlags setThrows(){
  removeFlag(Node.FLAG_NO_THROWS);
  return this;
}",0.7972972972972973
27895,"public void setReturnsTainted(){
  removeFlag(Node.FLAG_LOCAL_RESULTS);
}","public SideEffectFlags setReturnsTainted(){
  removeFlag(Node.FLAG_LOCAL_RESULTS);
  return this;
}",0.8255813953488372
27896,"/** 
 * All side-effect occur and the returned results are non-local. 
 */
public void setAllFlags(){
  value=Node.SIDE_EFFECTS_ALL;
}","/** 
 * All side-effect occur and the returned results are non-local. 
 */
public SideEffectFlags setAllFlags(){
  value=Node.SIDE_EFFECTS_ALL;
  return this;
}",0.8979591836734694
27897,"public void setMutatesThis(){
  removeFlag(Node.FLAG_THIS_UNMODIFIED);
}","public SideEffectFlags setMutatesThis(){
  removeFlag(Node.FLAG_THIS_UNMODIFIED);
  return this;
}",0.8235294117647058
27898,"void addList(Node firstInList,boolean isArrayOrFunctionArgument,Context lhsContext){
  for (Node n=firstInList; n != null; n=n.getNext()) {
    boolean isFirst=n == firstInList;
    if (isFirst) {
      addExpr(n,isArrayOrFunctionArgument ? 1 : 0,lhsContext);
    }
 else {
      cc.listSeparator();
      addExpr(n,isArrayOrFunctionArgument ? 1 : 0,Context.OTHER);
    }
  }
}","void addList(Node firstInList,boolean isArrayOrFunctionArgument,Context lhsContext){
  for (Node n=firstInList; n != null; n=n.getNext()) {
    boolean isFirst=n == firstInList;
    if (isFirst) {
      addExpr(n,isArrayOrFunctionArgument ? 1 : 0,lhsContext);
    }
 else {
      cc.listSeparator();
      addExpr(n,isArrayOrFunctionArgument ? 1 : 0,getContextForNoInOperator(lhsContext));
    }
  }
}",0.9562982005141388
27899,"void add(Node n,Context context){
  if (!cc.continueProcessing()) {
    return;
  }
  int type=n.getType();
  String opstr=NodeUtil.opToStr(type);
  int childCount=n.getChildCount();
  Node first=n.getFirstChild();
  Node last=n.getLastChild();
  if (opstr != null && first != last) {
    Preconditions.checkState(childCount == 2,""String_Node_Str"",opstr,childCount);
    int p=NodeUtil.precedence(type);
    Context rhsContext=getContextForNoInOperator(context);
    if (last.getType() == type && NodeUtil.isAssociative(type)) {
      addExpr(first,p,context);
      cc.addOp(opstr,true);
      addExpr(last,p,rhsContext);
    }
 else     if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
      addExpr(first,p,context);
      cc.addOp(opstr,true);
      addExpr(last,p,rhsContext);
    }
 else {
      unrollBinaryOperator(n,type,opstr,context,rhsContext,p,p + 1);
    }
    return;
  }
  cc.startSourceMapping(n);
switch (type) {
case Token.TRY:
{
      Preconditions.checkState(first.getNext().isBlock() && !first.getNext().hasMoreThanOneChild());
      Preconditions.checkState(childCount >= 2 && childCount <= 3);
      add(""String_Node_Str"");
      add(first,Context.PRESERVE_BLOCK);
      Node catchblock=first.getNext().getFirstChild();
      if (catchblock != null) {
        add(catchblock);
      }
      if (childCount == 3) {
        add(""String_Node_Str"");
        add(last,Context.PRESERVE_BLOCK);
      }
      break;
    }
case Token.CATCH:
  Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(last,Context.PRESERVE_BLOCK);
break;
case Token.THROW:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
add(first);
cc.endStatement(true);
break;
case Token.RETURN:
add(""String_Node_Str"");
if (childCount == 1) {
add(first);
}
 else {
Preconditions.checkState(childCount == 0);
}
cc.endStatement();
break;
case Token.VAR:
if (first != null) {
add(""String_Node_Str"");
addList(first,false,getContextForNoInOperator(context));
}
break;
case Token.LABEL_NAME:
Preconditions.checkState(!n.getString().isEmpty());
addIdentifier(n.getString());
break;
case Token.NAME:
if (first == null || first.isEmpty()) {
addIdentifier(n.getString());
}
 else {
Preconditions.checkState(childCount == 1);
addIdentifier(n.getString());
cc.addOp(""String_Node_Str"",true);
if (first.isComma()) {
addExpr(first,NodeUtil.precedence(Token.ASSIGN),Context.OTHER);
}
 else {
addExpr(first,0,getContextForNoInOperator(context));
}
}
break;
case Token.ARRAYLIT:
add(""String_Node_Str"");
addArrayList(first);
add(""String_Node_Str"");
break;
case Token.PARAM_LIST:
add(""String_Node_Str"");
addList(first);
add(""String_Node_Str"");
break;
case Token.COMMA:
Preconditions.checkState(childCount == 2);
unrollBinaryOperator(n,Token.COMMA,""String_Node_Str"",context,Context.OTHER,0,0);
break;
case Token.NUMBER:
Preconditions.checkState(childCount == 0);
cc.addNumber(n.getDouble());
break;
case Token.TYPEOF:
case Token.VOID:
case Token.NOT:
case Token.BITNOT:
case Token.POS:
{
Preconditions.checkState(childCount == 1);
cc.addOp(NodeUtil.opToStrNoFail(type),false);
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
break;
}
case Token.NEG:
{
Preconditions.checkState(childCount == 1);
if (n.getFirstChild().isNumber()) {
cc.addNumber(-n.getFirstChild().getDouble());
}
 else {
cc.addOp(NodeUtil.opToStrNoFail(type),false);
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
}
break;
}
case Token.HOOK:
{
Preconditions.checkState(childCount == 3);
int p=NodeUtil.precedence(type);
addExpr(first,p + 1,context);
cc.addOp(""String_Node_Str"",true);
addExpr(first.getNext(),1,Context.OTHER);
cc.addOp(""String_Node_Str"",true);
addExpr(last,1,Context.OTHER);
break;
}
case Token.REGEXP:
if (!first.isString() || !last.isString()) {
throw new Error(""String_Node_Str"");
}
String regexp=regexpEscape(first.getString(),outputCharsetEncoder);
if (childCount == 2) {
add(regexp + last.getString());
}
 else {
Preconditions.checkState(childCount == 1);
add(regexp);
}
break;
case Token.FUNCTION:
if (n.getClass() != Node.class) {
throw new Error(""String_Node_Str"");
}
Preconditions.checkState(childCount == 3);
boolean funcNeedsParens=(context == Context.START_OF_EXPR);
if (funcNeedsParens) {
add(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
add(first.getNext());
add(last,Context.PRESERVE_BLOCK);
cc.endFunction(context == Context.STATEMENT);
if (funcNeedsParens) {
add(""String_Node_Str"");
}
break;
case Token.GETTER_DEF:
case Token.SETTER_DEF:
Preconditions.checkState(n.getParent().isObjectLit());
Preconditions.checkState(childCount == 1);
Preconditions.checkState(first.isFunction());
Preconditions.checkState(first.getFirstChild().getString().isEmpty());
if (type == Token.GETTER_DEF) {
Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
add(""String_Node_Str"");
}
 else {
Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
add(""String_Node_Str"");
}
String name=n.getString();
Node fn=first;
Node parameters=fn.getChildAtIndex(1);
Node body=fn.getLastChild();
if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) && NodeUtil.isLatin(name)) {
add(name);
}
 else {
double d=getSimpleNumber(name);
if (!Double.isNaN(d)) {
cc.addNumber(d);
}
 else {
addJsString(n);
}
}
add(parameters);
add(body,Context.PRESERVE_BLOCK);
break;
case Token.SCRIPT:
case Token.BLOCK:
{
if (n.getClass() != Node.class) {
throw new Error(""String_Node_Str"");
}
boolean preserveBlock=context == Context.PRESERVE_BLOCK;
if (preserveBlock) {
cc.beginBlock();
}
boolean preferLineBreaks=type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().isScript());
for (Node c=first; c != null; c=c.getNext()) {
add(c,Context.STATEMENT);
if (c.isVar()) {
cc.endStatement();
}
if (c.isFunction()) {
cc.maybeLineBreak();
}
if (preferLineBreaks) {
cc.notePreferredLineBreak();
}
}
if (preserveBlock) {
cc.endBlock(cc.breakAfterBlockFor(n,context == Context.STATEMENT));
}
break;
}
case Token.FOR:
if (childCount == 4) {
add(""String_Node_Str"");
if (first.isVar()) {
add(first,Context.IN_FOR_INIT_CLAUSE);
}
 else {
addExpr(first,0,Context.IN_FOR_INIT_CLAUSE);
}
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
add(first.getNext().getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
 else {
Preconditions.checkState(childCount == 3);
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
break;
case Token.DO:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
addNonEmptyStatement(first,Context.OTHER,false);
add(""String_Node_Str"");
add(last);
add(""String_Node_Str"");
cc.endStatement();
break;
case Token.WHILE:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case Token.EMPTY:
Preconditions.checkState(childCount == 0);
break;
case Token.GETPROP:
{
Preconditions.checkState(childCount == 2,""String_Node_Str"",childCount);
Preconditions.checkState(last.isString(),""String_Node_Str"");
boolean needsParens=(first.isNumber());
if (needsParens) {
add(""String_Node_Str"");
}
addExpr(first,NodeUtil.precedence(type),context);
if (needsParens) {
add(""String_Node_Str"");
}
add(""String_Node_Str"");
addIdentifier(last.getString());
break;
}
case Token.GETELEM:
Preconditions.checkState(childCount == 2,""String_Node_Str"",childCount);
addExpr(first,NodeUtil.precedence(type),context);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
break;
case Token.WITH:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case Token.INC:
case Token.DEC:
{
Preconditions.checkState(childCount == 1);
String o=type == Token.INC ? ""String_Node_Str"" : ""String_Node_Str"";
int postProp=n.getIntProp(Node.INCRDECR_PROP);
if (postProp != 0) {
addExpr(first,NodeUtil.precedence(type),context);
cc.addOp(o,false);
}
 else {
cc.addOp(o,false);
add(first);
}
break;
}
case Token.CALL:
if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
add(""String_Node_Str"");
addExpr(first,NodeUtil.precedence(Token.COMMA),Context.OTHER);
add(""String_Node_Str"");
}
 else {
addExpr(first,NodeUtil.precedence(type),context);
}
add(""String_Node_Str"");
addList(first.getNext());
add(""String_Node_Str"");
break;
case Token.IF:
boolean hasElse=childCount == 3;
boolean ambiguousElseClause=context == Context.BEFORE_DANGLING_ELSE && !hasElse;
if (ambiguousElseClause) {
cc.beginBlock();
}
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
if (hasElse) {
addNonEmptyStatement(first.getNext(),Context.BEFORE_DANGLING_ELSE,false);
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
 else {
addNonEmptyStatement(first.getNext(),Context.OTHER,false);
Preconditions.checkState(childCount == 2);
}
if (ambiguousElseClause) {
cc.endBlock();
}
break;
case Token.NULL:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case Token.THIS:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
break;
case Token.FALSE:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case Token.TRUE:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case Token.CONTINUE:
Preconditions.checkState(childCount <= 1);
add(""String_Node_Str"");
if (childCount == 1) {
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
}
cc.endStatement();
break;
case Token.DEBUGGER:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
cc.endStatement();
break;
case Token.BREAK:
Preconditions.checkState(childCount <= 1);
add(""String_Node_Str"");
if (childCount == 1) {
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
}
cc.endStatement();
break;
case Token.EXPR_RESULT:
Preconditions.checkState(childCount == 1);
add(first,Context.START_OF_EXPR);
cc.endStatement();
break;
case Token.NEW:
add(""String_Node_Str"");
int precedence=NodeUtil.precedence(type);
if (NodeUtil.containsType(first,Token.CALL,NodeUtil.MATCH_NOT_FUNCTION)) {
precedence=NodeUtil.precedence(first.getType()) + 1;
}
addExpr(first,precedence,Context.OTHER);
Node next=first.getNext();
if (next != null) {
add(""String_Node_Str"");
addList(next);
add(""String_Node_Str"");
}
break;
case Token.STRING_KEY:
Preconditions.checkState(childCount == 1,""String_Node_Str"");
addJsString(n);
break;
case Token.STRING:
Preconditions.checkState(childCount == 0,""String_Node_Str"");
addJsString(n);
break;
case Token.DELPROP:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
add(first);
break;
case Token.OBJECTLIT:
{
boolean needsParens=(context == Context.START_OF_EXPR);
if (needsParens) {
add(""String_Node_Str"");
}
add(""String_Node_Str"");
for (Node c=first; c != null; c=c.getNext()) {
if (c != first) {
cc.listSeparator();
}
if (c.isGetterDef() || c.isSetterDef()) {
add(c);
}
 else {
Preconditions.checkState(c.isStringKey());
String key=c.getString();
if (!c.isQuotedString() && !TokenStream.isKeyword(key) && TokenStream.isJSIdentifier(key)&& NodeUtil.isLatin(key)) {
add(key);
}
 else {
double d=getSimpleNumber(key);
if (!Double.isNaN(d)) {
cc.addNumber(d);
}
 else {
addExpr(c,1,Context.OTHER);
}
}
add(""String_Node_Str"");
addExpr(c.getFirstChild(),1,Context.OTHER);
}
}
add(""String_Node_Str"");
if (needsParens) {
add(""String_Node_Str"");
}
break;
}
case Token.SWITCH:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
cc.beginBlock();
addAllSiblings(first.getNext());
cc.endBlock(context == Context.STATEMENT);
break;
case Token.CASE:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
add(first);
addCaseBody(last);
break;
case Token.DEFAULT_CASE:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
addCaseBody(first);
break;
case Token.LABEL:
Preconditions.checkState(childCount == 2);
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(first);
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),true);
break;
case Token.CAST:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
break;
default :
throw new Error(""String_Node_Str"" + type + ""String_Node_Str""+ n.toStringTree());
}
cc.endSourceMapping(n);
}","void add(Node n,Context context){
  if (!cc.continueProcessing()) {
    return;
  }
  int type=n.getType();
  String opstr=NodeUtil.opToStr(type);
  int childCount=n.getChildCount();
  Node first=n.getFirstChild();
  Node last=n.getLastChild();
  if (opstr != null && first != last) {
    Preconditions.checkState(childCount == 2,""String_Node_Str"",opstr,childCount);
    int p=NodeUtil.precedence(type);
    Context rhsContext=getContextForNoInOperator(context);
    if (last.getType() == type && NodeUtil.isAssociative(type)) {
      addExpr(first,p,context);
      cc.addOp(opstr,true);
      addExpr(last,p,rhsContext);
    }
 else     if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
      addExpr(first,p,context);
      cc.addOp(opstr,true);
      addExpr(last,p,rhsContext);
    }
 else {
      unrollBinaryOperator(n,type,opstr,context,rhsContext,p,p + 1);
    }
    return;
  }
  cc.startSourceMapping(n);
switch (type) {
case Token.TRY:
{
      Preconditions.checkState(first.getNext().isBlock() && !first.getNext().hasMoreThanOneChild());
      Preconditions.checkState(childCount >= 2 && childCount <= 3);
      add(""String_Node_Str"");
      add(first,Context.PRESERVE_BLOCK);
      Node catchblock=first.getNext().getFirstChild();
      if (catchblock != null) {
        add(catchblock);
      }
      if (childCount == 3) {
        add(""String_Node_Str"");
        add(last,Context.PRESERVE_BLOCK);
      }
      break;
    }
case Token.CATCH:
  Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(last,Context.PRESERVE_BLOCK);
break;
case Token.THROW:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
add(first);
cc.endStatement(true);
break;
case Token.RETURN:
add(""String_Node_Str"");
if (childCount == 1) {
add(first);
}
 else {
Preconditions.checkState(childCount == 0);
}
cc.endStatement();
break;
case Token.VAR:
if (first != null) {
add(""String_Node_Str"");
addList(first,false,getContextForNoInOperator(context));
}
break;
case Token.LABEL_NAME:
Preconditions.checkState(!n.getString().isEmpty());
addIdentifier(n.getString());
break;
case Token.NAME:
if (first == null || first.isEmpty()) {
addIdentifier(n.getString());
}
 else {
Preconditions.checkState(childCount == 1);
addIdentifier(n.getString());
cc.addOp(""String_Node_Str"",true);
if (first.isComma()) {
addExpr(first,NodeUtil.precedence(Token.ASSIGN),Context.OTHER);
}
 else {
addExpr(first,0,getContextForNoInOperator(context));
}
}
break;
case Token.ARRAYLIT:
add(""String_Node_Str"");
addArrayList(first);
add(""String_Node_Str"");
break;
case Token.PARAM_LIST:
add(""String_Node_Str"");
addList(first);
add(""String_Node_Str"");
break;
case Token.COMMA:
Preconditions.checkState(childCount == 2);
unrollBinaryOperator(n,Token.COMMA,""String_Node_Str"",context,getContextForNoInOperator(context),0,0);
break;
case Token.NUMBER:
Preconditions.checkState(childCount == 0);
cc.addNumber(n.getDouble());
break;
case Token.TYPEOF:
case Token.VOID:
case Token.NOT:
case Token.BITNOT:
case Token.POS:
{
Preconditions.checkState(childCount == 1);
cc.addOp(NodeUtil.opToStrNoFail(type),false);
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
break;
}
case Token.NEG:
{
Preconditions.checkState(childCount == 1);
if (n.getFirstChild().isNumber()) {
cc.addNumber(-n.getFirstChild().getDouble());
}
 else {
cc.addOp(NodeUtil.opToStrNoFail(type),false);
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
}
break;
}
case Token.HOOK:
{
Preconditions.checkState(childCount == 3);
int p=NodeUtil.precedence(type);
addExpr(first,p + 1,context);
cc.addOp(""String_Node_Str"",true);
addExpr(first.getNext(),1,Context.OTHER);
cc.addOp(""String_Node_Str"",true);
addExpr(last,1,Context.OTHER);
break;
}
case Token.REGEXP:
if (!first.isString() || !last.isString()) {
throw new Error(""String_Node_Str"");
}
String regexp=regexpEscape(first.getString(),outputCharsetEncoder);
if (childCount == 2) {
add(regexp + last.getString());
}
 else {
Preconditions.checkState(childCount == 1);
add(regexp);
}
break;
case Token.FUNCTION:
if (n.getClass() != Node.class) {
throw new Error(""String_Node_Str"");
}
Preconditions.checkState(childCount == 3);
boolean funcNeedsParens=(context == Context.START_OF_EXPR);
if (funcNeedsParens) {
add(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
add(first.getNext());
add(last,Context.PRESERVE_BLOCK);
cc.endFunction(context == Context.STATEMENT);
if (funcNeedsParens) {
add(""String_Node_Str"");
}
break;
case Token.GETTER_DEF:
case Token.SETTER_DEF:
Preconditions.checkState(n.getParent().isObjectLit());
Preconditions.checkState(childCount == 1);
Preconditions.checkState(first.isFunction());
Preconditions.checkState(first.getFirstChild().getString().isEmpty());
if (type == Token.GETTER_DEF) {
Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
add(""String_Node_Str"");
}
 else {
Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
add(""String_Node_Str"");
}
String name=n.getString();
Node fn=first;
Node parameters=fn.getChildAtIndex(1);
Node body=fn.getLastChild();
if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) && NodeUtil.isLatin(name)) {
add(name);
}
 else {
double d=getSimpleNumber(name);
if (!Double.isNaN(d)) {
cc.addNumber(d);
}
 else {
addJsString(n);
}
}
add(parameters);
add(body,Context.PRESERVE_BLOCK);
break;
case Token.SCRIPT:
case Token.BLOCK:
{
if (n.getClass() != Node.class) {
throw new Error(""String_Node_Str"");
}
boolean preserveBlock=context == Context.PRESERVE_BLOCK;
if (preserveBlock) {
cc.beginBlock();
}
boolean preferLineBreaks=type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().isScript());
for (Node c=first; c != null; c=c.getNext()) {
add(c,Context.STATEMENT);
if (c.isVar()) {
cc.endStatement();
}
if (c.isFunction()) {
cc.maybeLineBreak();
}
if (preferLineBreaks) {
cc.notePreferredLineBreak();
}
}
if (preserveBlock) {
cc.endBlock(cc.breakAfterBlockFor(n,context == Context.STATEMENT));
}
break;
}
case Token.FOR:
if (childCount == 4) {
add(""String_Node_Str"");
if (first.isVar()) {
add(first,Context.IN_FOR_INIT_CLAUSE);
}
 else {
addExpr(first,0,Context.IN_FOR_INIT_CLAUSE);
}
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
add(first.getNext().getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
 else {
Preconditions.checkState(childCount == 3);
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
break;
case Token.DO:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
addNonEmptyStatement(first,Context.OTHER,false);
add(""String_Node_Str"");
add(last);
add(""String_Node_Str"");
cc.endStatement();
break;
case Token.WHILE:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case Token.EMPTY:
Preconditions.checkState(childCount == 0);
break;
case Token.GETPROP:
{
Preconditions.checkState(childCount == 2,""String_Node_Str"",childCount);
Preconditions.checkState(last.isString(),""String_Node_Str"");
boolean needsParens=(first.isNumber());
if (needsParens) {
add(""String_Node_Str"");
}
addExpr(first,NodeUtil.precedence(type),context);
if (needsParens) {
add(""String_Node_Str"");
}
add(""String_Node_Str"");
addIdentifier(last.getString());
break;
}
case Token.GETELEM:
Preconditions.checkState(childCount == 2,""String_Node_Str"",childCount);
addExpr(first,NodeUtil.precedence(type),context);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
break;
case Token.WITH:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case Token.INC:
case Token.DEC:
{
Preconditions.checkState(childCount == 1);
String o=type == Token.INC ? ""String_Node_Str"" : ""String_Node_Str"";
int postProp=n.getIntProp(Node.INCRDECR_PROP);
if (postProp != 0) {
addExpr(first,NodeUtil.precedence(type),context);
cc.addOp(o,false);
}
 else {
cc.addOp(o,false);
add(first);
}
break;
}
case Token.CALL:
if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
add(""String_Node_Str"");
addExpr(first,NodeUtil.precedence(Token.COMMA),Context.OTHER);
add(""String_Node_Str"");
}
 else {
addExpr(first,NodeUtil.precedence(type),context);
}
add(""String_Node_Str"");
addList(first.getNext());
add(""String_Node_Str"");
break;
case Token.IF:
boolean hasElse=childCount == 3;
boolean ambiguousElseClause=context == Context.BEFORE_DANGLING_ELSE && !hasElse;
if (ambiguousElseClause) {
cc.beginBlock();
}
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
if (hasElse) {
addNonEmptyStatement(first.getNext(),Context.BEFORE_DANGLING_ELSE,false);
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
 else {
addNonEmptyStatement(first.getNext(),Context.OTHER,false);
Preconditions.checkState(childCount == 2);
}
if (ambiguousElseClause) {
cc.endBlock();
}
break;
case Token.NULL:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case Token.THIS:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
break;
case Token.FALSE:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case Token.TRUE:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case Token.CONTINUE:
Preconditions.checkState(childCount <= 1);
add(""String_Node_Str"");
if (childCount == 1) {
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
}
cc.endStatement();
break;
case Token.DEBUGGER:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
cc.endStatement();
break;
case Token.BREAK:
Preconditions.checkState(childCount <= 1);
add(""String_Node_Str"");
if (childCount == 1) {
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
}
cc.endStatement();
break;
case Token.EXPR_RESULT:
Preconditions.checkState(childCount == 1);
add(first,Context.START_OF_EXPR);
cc.endStatement();
break;
case Token.NEW:
add(""String_Node_Str"");
int precedence=NodeUtil.precedence(type);
if (NodeUtil.containsType(first,Token.CALL,NodeUtil.MATCH_NOT_FUNCTION)) {
precedence=NodeUtil.precedence(first.getType()) + 1;
}
addExpr(first,precedence,Context.OTHER);
Node next=first.getNext();
if (next != null) {
add(""String_Node_Str"");
addList(next);
add(""String_Node_Str"");
}
break;
case Token.STRING_KEY:
Preconditions.checkState(childCount == 1,""String_Node_Str"");
addJsString(n);
break;
case Token.STRING:
Preconditions.checkState(childCount == 0,""String_Node_Str"");
addJsString(n);
break;
case Token.DELPROP:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
add(first);
break;
case Token.OBJECTLIT:
{
boolean needsParens=(context == Context.START_OF_EXPR);
if (needsParens) {
add(""String_Node_Str"");
}
add(""String_Node_Str"");
for (Node c=first; c != null; c=c.getNext()) {
if (c != first) {
cc.listSeparator();
}
if (c.isGetterDef() || c.isSetterDef()) {
add(c);
}
 else {
Preconditions.checkState(c.isStringKey());
String key=c.getString();
if (!c.isQuotedString() && !TokenStream.isKeyword(key) && TokenStream.isJSIdentifier(key)&& NodeUtil.isLatin(key)) {
add(key);
}
 else {
double d=getSimpleNumber(key);
if (!Double.isNaN(d)) {
cc.addNumber(d);
}
 else {
addExpr(c,1,Context.OTHER);
}
}
add(""String_Node_Str"");
addExpr(c.getFirstChild(),1,Context.OTHER);
}
}
add(""String_Node_Str"");
if (needsParens) {
add(""String_Node_Str"");
}
break;
}
case Token.SWITCH:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
cc.beginBlock();
addAllSiblings(first.getNext());
cc.endBlock(context == Context.STATEMENT);
break;
case Token.CASE:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
add(first);
addCaseBody(last);
break;
case Token.DEFAULT_CASE:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
addCaseBody(first);
break;
case Token.LABEL:
Preconditions.checkState(childCount == 2);
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(first);
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),true);
break;
case Token.CAST:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
break;
default :
throw new Error(""String_Node_Str"" + type + ""String_Node_Str""+ n.toStringTree());
}
cc.endSourceMapping(n);
}",0.9987763962897178
27900,"public void testPrintInOperatorInForLoop(){
  assertPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrint(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
  assertPrint(""String_Node_Str"",""String_Node_Str"");
}","public void testPrintInOperatorInForLoop(){
  assertPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrint(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
  assertPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrintSame(""String_Node_Str"");
  assertPrintSame(""String_Node_Str"");
}",0.9294990723562152
27901,"AliasedTypeNode(Node typeReference,Node aliasDefinition,String aliasName){
  this.typeReference=typeReference;
  this.aliasDefinition=aliasDefinition;
  this.aliasName=aliasName;
}","AliasedTypeNode(Var aliasVar,Node aliasReference){
  super(aliasVar,aliasReference);
}",0.3909774436090225
27902,"@Override public void applyAlias(){
  String typeName=typeReference.getString();
  String aliasExpanded=Preconditions.checkNotNull(aliasDefinition.getQualifiedName());
  Preconditions.checkState(typeName.startsWith(aliasName));
  typeReference.setString(typeName.replaceFirst(aliasName,aliasExpanded));
}","@Override public void applyAlias(){
  Node aliasDefinition=aliasVar.getInitialValue();
  String aliasName=aliasVar.getName();
  String typeName=aliasReference.getString();
  String aliasExpanded=Preconditions.checkNotNull(aliasDefinition.getQualifiedName());
  Preconditions.checkState(typeName.startsWith(aliasName));
  aliasReference.setString(typeName.replaceFirst(aliasName,aliasExpanded));
}",0.8457142857142858
27903,"private void fixTypeNode(Node typeNode){
  if (typeNode.isString()) {
    String name=typeNode.getString();
    int endIndex=name.indexOf('.');
    if (endIndex == -1) {
      endIndex=name.length();
    }
    String baseName=name.substring(0,endIndex);
    Var aliasVar=aliases.get(baseName);
    if (aliasVar != null) {
      Node aliasedNode=aliasVar.getInitialValue();
      aliasUsages.add(new AliasedTypeNode(typeNode,aliasedNode,baseName));
    }
  }
  for (Node child=typeNode.getFirstChild(); child != null; child=child.getNext()) {
    fixTypeNode(child);
  }
}","private void fixTypeNode(Node typeNode){
  if (typeNode.isString()) {
    String name=typeNode.getString();
    int endIndex=name.indexOf('.');
    if (endIndex == -1) {
      endIndex=name.length();
    }
    String baseName=name.substring(0,endIndex);
    Var aliasVar=aliases.get(baseName);
    if (aliasVar != null) {
      aliasUsages.add(new AliasedTypeNode(aliasVar,typeNode));
    }
  }
  for (Node child=typeNode.getFirstChild(); child != null; child=child.getNext()) {
    fixTypeNode(child);
  }
}",0.6506024096385542
27904,"AliasedNode(Node aliasReference,Node aliasDefinition){
  this.aliasReference=aliasReference;
  this.aliasDefinition=aliasDefinition;
}","AliasedNode(Var aliasVar,Node aliasReference){
  super(aliasVar,aliasReference);
}",0.5
27905,"@Override public void hotSwapScript(Node root,Node originalRoot){
  Traversal traversal=new Traversal();
  NodeTraversal.traverse(compiler,root,traversal);
  if (!traversal.hasErrors()) {
    for (    AliasUsage aliasUsage : traversal.getAliasUsages()) {
      aliasUsage.applyAlias();
    }
    for (    Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) {
      if (aliasDefinition.getParent().isVar() && aliasDefinition.getParent().hasOneChild()) {
        aliasDefinition.getParent().detachFromParent();
      }
 else {
        aliasDefinition.detachFromParent();
      }
    }
    for (    Node scopeCall : traversal.getScopeCalls()) {
      Node expressionWithScopeCall=scopeCall.getParent();
      Node scopeClosureBlock=scopeCall.getLastChild().getLastChild();
      scopeClosureBlock.detachFromParent();
      expressionWithScopeCall.getParent().replaceChild(expressionWithScopeCall,scopeClosureBlock);
      NodeUtil.tryMergeBlock(scopeClosureBlock);
    }
    if (traversal.getAliasUsages().size() > 0 || traversal.getAliasDefinitionsInOrder().size() > 0 || traversal.getScopeCalls().size() > 0) {
      compiler.reportCodeChange();
    }
  }
}","@Override public void hotSwapScript(Node root,Node originalRoot){
  Traversal traversal=new Traversal();
  NodeTraversal.traverse(compiler,root,traversal);
  if (!traversal.hasErrors()) {
    List<AliasUsage> aliasWorkQueue=Lists.newArrayList(traversal.getAliasUsages());
    while (!aliasWorkQueue.isEmpty()) {
      List<AliasUsage> newQueue=Lists.newArrayList();
      for (      AliasUsage aliasUsage : aliasWorkQueue) {
        if (aliasUsage.referencesOtherAlias()) {
          newQueue.add(aliasUsage);
        }
 else {
          aliasUsage.applyAlias();
        }
      }
      if (newQueue.size() == aliasWorkQueue.size()) {
        Var cycleVar=newQueue.get(0).aliasVar;
        compiler.report(JSError.make(cycleVar.getNode(),GOOG_SCOPE_ALIAS_CYCLE,cycleVar.getName()));
        break;
      }
 else {
        aliasWorkQueue=newQueue;
      }
    }
    for (    Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) {
      if (aliasDefinition.getParent().isVar() && aliasDefinition.getParent().hasOneChild()) {
        aliasDefinition.getParent().detachFromParent();
      }
 else {
        aliasDefinition.detachFromParent();
      }
    }
    for (    Node scopeCall : traversal.getScopeCalls()) {
      Node expressionWithScopeCall=scopeCall.getParent();
      Node scopeClosureBlock=scopeCall.getLastChild().getLastChild();
      scopeClosureBlock.detachFromParent();
      expressionWithScopeCall.getParent().replaceChild(expressionWithScopeCall,scopeClosureBlock);
      NodeUtil.tryMergeBlock(scopeClosureBlock);
    }
    if (traversal.getAliasUsages().size() > 0 || traversal.getAliasDefinitionsInOrder().size() > 0 || traversal.getScopeCalls().size() > 0) {
      compiler.reportCodeChange();
    }
  }
}",0.792283844299001
27906,"@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (isCallToScopeMethod(n)) {
    validateScopeCall(t,n,n.getParent());
  }
  if (t.getScopeDepth() < 2) {
    return;
  }
  int type=n.getType();
  Var aliasVar=null;
  if (type == Token.NAME) {
    String name=n.getString();
    Var lexicalVar=t.getScope().getVar(n.getString());
    if (lexicalVar != null && lexicalVar == aliases.get(name)) {
      aliasVar=lexicalVar;
    }
  }
  if (t.getScopeDepth() == 2) {
    if (aliasVar != null && NodeUtil.isLValue(n)) {
      if (aliasVar.getNode() == n) {
        aliasDefinitionsInOrder.add(n);
        return;
      }
 else {
        report(t,n,GOOG_SCOPE_ALIAS_REDEFINED,n.getString());
      }
    }
    if (type == Token.RETURN) {
      report(t,n,GOOG_SCOPE_USES_RETURN);
    }
 else     if (type == Token.THIS) {
      report(t,n,GOOG_SCOPE_REFERENCES_THIS);
    }
 else     if (type == Token.THROW) {
      report(t,n,GOOG_SCOPE_USES_THROW);
    }
  }
  if (t.getScopeDepth() >= 2) {
    if (aliasVar != null) {
      Node aliasedNode=aliasVar.getInitialValue();
      aliasUsages.add(new AliasedNode(n,aliasedNode));
    }
    JSDocInfo info=n.getJSDocInfo();
    if (info != null) {
      for (      Node node : info.getTypeNodes()) {
        fixTypeNode(node);
      }
    }
  }
}","@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (isCallToScopeMethod(n)) {
    validateScopeCall(t,n,n.getParent());
  }
  if (t.getScopeDepth() < 2) {
    return;
  }
  int type=n.getType();
  Var aliasVar=null;
  if (type == Token.NAME) {
    String name=n.getString();
    Var lexicalVar=t.getScope().getVar(n.getString());
    if (lexicalVar != null && lexicalVar == aliases.get(name)) {
      aliasVar=lexicalVar;
    }
  }
  if (t.getScopeDepth() == 2) {
    if (aliasVar != null && NodeUtil.isLValue(n)) {
      if (aliasVar.getNode() == n) {
        aliasDefinitionsInOrder.add(n);
        return;
      }
 else {
        report(t,n,GOOG_SCOPE_ALIAS_REDEFINED,n.getString());
      }
    }
    if (type == Token.RETURN) {
      report(t,n,GOOG_SCOPE_USES_RETURN);
    }
 else     if (type == Token.THIS) {
      report(t,n,GOOG_SCOPE_REFERENCES_THIS);
    }
 else     if (type == Token.THROW) {
      report(t,n,GOOG_SCOPE_USES_THROW);
    }
  }
  if (t.getScopeDepth() >= 2) {
    if (aliasVar != null) {
      aliasUsages.add(new AliasedNode(aliasVar,n));
    }
    JSDocInfo info=n.getJSDocInfo();
    if (info != null) {
      for (      Node node : info.getTypeNodes()) {
        fixTypeNode(node);
      }
    }
  }
}",0.97109375
27907,"/** 
 * Computes the number of uses of the variable varName and store it in numUseWithinUseCfgNode.
 */
private void getNumUseInUseCfgNode(Node n){
  AbstractCfgNodeTraversalCallback gatherCb=new AbstractCfgNodeTraversalCallback(){
    @Override public void visit(    NodeTraversal t,    Node n,    Node parent){
      if (n.isName() && n.getString().equals(varName) && !(parent.isAssign() && (parent.getFirstChild() == n))) {
        numUseWithinUseCfgNode++;
      }
    }
  }
;
  NodeTraversal.traverse(compiler,n,gatherCb);
}","/** 
 * Computes the number of uses of the variable varName and store it in numUseWithinUseCfgNode.
 */
private void getNumUseInUseCfgNode(final Node cfgNode){
  numUsesWithinCfgNode=0;
  AbstractCfgNodeTraversalCallback gatherCb=new AbstractCfgNodeTraversalCallback(){
    @Override public void visit(    NodeTraversal t,    Node n,    Node parent){
      if (n.isName() && n.getString().equals(varName)) {
        if (parent.isAssign() && (parent.getFirstChild() == n) && isAssignChain(parent,cfgNode)) {
          return;
        }
 else {
          numUsesWithinCfgNode++;
        }
      }
    }
    private boolean isAssignChain(    Node child,    Node ancestor){
      for (Node n=child; n != ancestor; n=n.getParent()) {
        if (!n.isAssign()) {
          return false;
        }
      }
      return true;
    }
  }
;
  NodeTraversal.traverse(compiler,cfgNode,gatherCb);
}",0.6888260254596889
27908,"private boolean canInline(final Scope scope){
  if (getDefCfgNode().isFunction()) {
    return false;
  }
  for (  Var dependency : defMetadata.depends) {
    if (inlinedNewDependencies.contains(dependency)) {
      return false;
    }
  }
  getDefinition(getDefCfgNode());
  getNumUseInUseCfgNode(useCfgNode);
  if (def == null) {
    return false;
  }
  if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {
    return false;
  }
  if (checkRightOf(def,getDefCfgNode(),SIDE_EFFECT_PREDICATE)) {
    return false;
  }
  if (checkLeftOf(use,useCfgNode,SIDE_EFFECT_PREDICATE)) {
    return false;
  }
  if (NodeUtil.mayHaveSideEffects(def.getLastChild(),compiler)) {
    return false;
  }
  if (numUseWithinUseCfgNode != 1) {
    return false;
  }
  if (NodeUtil.isWithinLoop(use)) {
    return false;
  }
  Collection<Node> uses=reachingUses.getUses(varName,getDefCfgNode());
  if (uses.size() != 1) {
    return false;
  }
  if (NodeUtil.has(def.getLastChild(),new Predicate<Node>(){
    @Override public boolean apply(    Node input){
switch (input.getType()) {
case Token.GETELEM:
case Token.GETPROP:
case Token.ARRAYLIT:
case Token.OBJECTLIT:
case Token.REGEXP:
case Token.NEW:
        return true;
case Token.NAME:
      Var var=scope.getOwnSlot(input.getString());
    if (var != null && var.getParentNode().isCatch()) {
      return true;
    }
}
return false;
}
}
,new Predicate<Node>(){
@Override public boolean apply(Node input){
return !input.isFunction();
}
}
)) {
return false;
}
if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {
CheckPathsBetweenNodes<Node,ControlFlowGraph.Branch> pathCheck=new CheckPathsBetweenNodes<Node,ControlFlowGraph.Branch>(cfg,cfg.getDirectedGraphNode(getDefCfgNode()),cfg.getDirectedGraphNode(useCfgNode),SIDE_EFFECT_PREDICATE,Predicates.<DiGraphEdge<Node,ControlFlowGraph.Branch>>alwaysTrue(),false);
if (pathCheck.somePathsSatisfyPredicate()) {
return false;
}
}
return true;
}","private boolean canInline(final Scope scope){
  if (getDefCfgNode().isFunction()) {
    return false;
  }
  for (  Var dependency : defMetadata.depends) {
    if (inlinedNewDependencies.contains(dependency)) {
      return false;
    }
  }
  getDefinition(getDefCfgNode());
  getNumUseInUseCfgNode(useCfgNode);
  if (def == null) {
    return false;
  }
  if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {
    return false;
  }
  if (checkRightOf(def,getDefCfgNode(),SIDE_EFFECT_PREDICATE)) {
    return false;
  }
  if (checkLeftOf(use,useCfgNode,SIDE_EFFECT_PREDICATE)) {
    return false;
  }
  if (NodeUtil.mayHaveSideEffects(def.getLastChild(),compiler)) {
    return false;
  }
  if (numUsesWithinCfgNode != 1) {
    return false;
  }
  if (NodeUtil.isWithinLoop(use)) {
    return false;
  }
  Collection<Node> uses=reachingUses.getUses(varName,getDefCfgNode());
  if (uses.size() != 1) {
    return false;
  }
  if (NodeUtil.has(def.getLastChild(),new Predicate<Node>(){
    @Override public boolean apply(    Node input){
switch (input.getType()) {
case Token.GETELEM:
case Token.GETPROP:
case Token.ARRAYLIT:
case Token.OBJECTLIT:
case Token.REGEXP:
case Token.NEW:
        return true;
case Token.NAME:
      Var var=scope.getOwnSlot(input.getString());
    if (var != null && var.getParentNode().isCatch()) {
      return true;
    }
}
return false;
}
}
,new Predicate<Node>(){
@Override public boolean apply(Node input){
return !input.isFunction();
}
}
)) {
return false;
}
if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {
CheckPathsBetweenNodes<Node,ControlFlowGraph.Branch> pathCheck=new CheckPathsBetweenNodes<Node,ControlFlowGraph.Branch>(cfg,cfg.getDirectedGraphNode(getDefCfgNode()),cfg.getDirectedGraphNode(useCfgNode),SIDE_EFFECT_PREDICATE,Predicates.<DiGraphEdge<Node,ControlFlowGraph.Branch>>alwaysTrue(),false);
if (pathCheck.somePathsSatisfyPredicate()) {
return false;
}
}
return true;
}",0.998992443324937
27909,"/** 
 * Given an expression by its root and sub-expression n, return true if there the predicate is true for some expression on the left of n. Example: Checked(), Checked(), n, NotChecked(), NotChecked();
 */
private static boolean checkLeftOf(Node n,Node expressionRoot,Predicate<Node> predicate){
  for (Node p=n.getParent(); p != expressionRoot; p=p.getParent()) {
    for (Node cur=p.getParent().getFirstChild(); cur != p; cur=cur.getNext()) {
      if (predicate.apply(cur)) {
        return true;
      }
    }
  }
  return false;
}","/** 
 * Given an expression by its root and sub-expression n, return true if there the predicate is true for some expression on the left of n. Example: Checked(), Checked(), n, NotChecked(), NotChecked();
 */
private static boolean checkLeftOf(Node n,Node expressionRoot,Predicate<Node> predicate){
  for (Node p=n; p != expressionRoot; p=p.getParent()) {
    for (Node cur=p.getParent().getFirstChild(); cur != p; cur=cur.getNext()) {
      if (predicate.apply(cur)) {
        return true;
      }
    }
  }
  return false;
}",0.8176691729323309
27910,"@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (n.isName() && n.getString().equals(varName) && !(parent.isAssign() && (parent.getFirstChild() == n))) {
    numUseWithinUseCfgNode++;
  }
}","@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (n.isName() && n.getString().equals(varName)) {
    if (parent.isAssign() && (parent.getFirstChild() == n) && isAssignChain(parent,cfgNode)) {
      return;
    }
 else {
      numUsesWithinCfgNode++;
    }
  }
}",0.7886178861788617
27911,"/** 
 * After a struct object is created, we can't add new properties to it, with one exception. We allow creation of ""static"" properties like Foo.prototype.bar = baz; where Foo.prototype is a struct, if the assignment happens at the top level and the constructor Foo is defined in the same file.
 */
private void checkPropCreation(NodeTraversal t,Node lvalue){
  if (lvalue.isGetProp()) {
    Node obj=lvalue.getFirstChild();
    Node prop=lvalue.getLastChild();
    JSType objType=getJSType(obj);
    String pname=prop.getString();
    if (!objType.isStruct() || objType.hasProperty(pname)) {
      return;
    }
    Scope s=t.getScope();
    if (obj.isThis() && getJSType(s.getRootNode()).isConstructor()) {
      return;
    }
    Node assgnStm=lvalue.getParent().getParent();
    if (objType instanceof ObjectType && s.isGlobal() && NodeUtil.isPrototypePropertyDeclaration(assgnStm)) {
      ObjectType instance=objType.toObjectType().getOwnerFunction().getInstanceType();
      String file=lvalue.getSourceFileName();
      Node ctor=instance.getConstructor().getSource();
      if (ctor != null && ctor.getSourceFileName().equals(file)) {
        return;
      }
    }
    report(t,prop,ILLEGAL_PROPERTY_CREATION);
  }
}","/** 
 * After a struct object is created, we can't add new properties to it, with one exception. We allow creation of ""static"" properties like Foo.prototype.bar = baz; where Foo.prototype is a struct, if the assignment happens at the top level and the constructor Foo is defined in the same file.
 */
private void checkPropCreation(NodeTraversal t,Node lvalue){
  if (lvalue.isGetProp()) {
    Node obj=lvalue.getFirstChild();
    Node prop=lvalue.getLastChild();
    JSType objType=getJSType(obj);
    String pname=prop.getString();
    if (!objType.isStruct() || objType.hasProperty(pname)) {
      return;
    }
    Scope s=t.getScope();
    if (obj.isThis() && getJSType(s.getRootNode()).isConstructor()) {
      return;
    }
    Node assgnExp=lvalue.getParent();
    Node assgnStm=assgnExp.getParent();
    if (objType instanceof ObjectType && s.isGlobal() && NodeUtil.isPrototypePropertyDeclaration(assgnStm)) {
      ObjectType instance=objType.toObjectType().getOwnerFunction().getInstanceType();
      String file=lvalue.getSourceFileName();
      Node ctor=instance.getConstructor().getSource();
      if (ctor != null && ctor.getSourceFileName().equals(file)) {
        JSType rvalueType=assgnExp.getLastChild().getJSType();
        instance.defineInferredProperty(pname,rvalueType,lvalue);
        return;
      }
    }
    report(t,prop,ILLEGAL_PROPERTY_CREATION);
  }
}",0.926081960934508
27912,"@Override public void remove(){
  map.removeChild(key);
}","@Override public void remove(AbstractCompiler compiler){
  compiler.reportChangeToEnclosingScope(key);
  map.removeChild(key);
}",0.6162162162162163
27913,"/** 
 * Inline a function into the call site.
 */
private void inlineFunction(NodeTraversal t,Node callNode,FunctionState fs,InliningMode mode){
  Function fn=fs.getFn();
  String fnName=fn.getName();
  Node fnNode=fs.getSafeFnNode();
  injector.inline(callNode,fnName,fnNode,mode);
  t.getCompiler().reportCodeChange();
  t.getCompiler().addToDebugLog(""String_Node_Str"" + fn.getName());
}","/** 
 * Inline a function into the call site.
 */
private void inlineFunction(NodeTraversal t,Node callNode,FunctionState fs,InliningMode mode){
  Function fn=fs.getFn();
  String fnName=fn.getName();
  Node fnNode=fs.getSafeFnNode();
  t.getCompiler().reportChangeToEnclosingScope(callNode);
  injector.inline(callNode,fnName,fnNode,mode);
  t.getCompiler().addToDebugLog(""String_Node_Str"" + fn.getName());
}",0.8421052631578947
27914,"/** 
 * Splits up the object literal into individual variables, and updates all uses.
 */
private void splitObject(Var v,Reference init,ReferenceCollection referenceInfo){
  Map<String,String> varmap=computeVarList(referenceInfo);
  Map<String,Node> initvals=Maps.newHashMap();
  Node vnode;
  boolean defined=referenceInfo.isWellDefined() && init.getParent().isVar();
  if (defined) {
    vnode=init.getParent();
    fillInitialValues(init,initvals);
  }
 else {
    vnode=v.getScope().getRootNode().getLastChild().getFirstChild();
  }
  for (  Map.Entry<String,String> entry : varmap.entrySet()) {
    Node val=initvals.get(entry.getKey());
    Node varnode=NodeUtil.newVarNode(entry.getValue(),val);
    if (val == null) {
      varnode.copyInformationFromForTree(vnode);
    }
 else {
      blacklistVarReferencesInTree(val,v.scope);
    }
    vnode.getParent().addChildBefore(varnode,vnode);
  }
  if (defined) {
    vnode.getParent().removeChild(vnode);
  }
  for (  Reference ref : referenceInfo.references) {
    if (defined && ref == init) {
      continue;
    }
    if (ref.isLvalue()) {
      replaceAssignmentExpression(v,ref,varmap);
    }
 else     if (ref.getParent().isVar()) {
      ref.getGrandparent().removeChild(ref.getParent());
    }
 else {
      Node getprop=ref.getParent();
      Preconditions.checkState(getprop.isGetProp());
      String var=getprop.getChildAtIndex(1).getString();
      Preconditions.checkState(varmap.containsKey(var));
      Node replacement=IR.name(varmap.get(var));
      replacement.copyInformationFrom(getprop);
      ref.getGrandparent().replaceChild(ref.getParent(),replacement);
    }
  }
  compiler.reportCodeChange();
}","/** 
 * Splits up the object literal into individual variables, and updates all uses.
 */
private void splitObject(Var v,Reference init,ReferenceCollection referenceInfo){
  Map<String,String> varmap=computeVarList(referenceInfo);
  Map<String,Node> initvals=Maps.newHashMap();
  Node vnode;
  boolean defined=referenceInfo.isWellDefined() && init.getParent().isVar();
  if (defined) {
    vnode=init.getParent();
    fillInitialValues(init,initvals);
  }
 else {
    vnode=v.getScope().getRootNode().getLastChild().getFirstChild();
  }
  for (  Map.Entry<String,String> entry : varmap.entrySet()) {
    Node val=initvals.get(entry.getKey());
    Node varnode=NodeUtil.newVarNode(entry.getValue(),val);
    if (val == null) {
      varnode.copyInformationFromForTree(vnode);
    }
 else {
      blacklistVarReferencesInTree(val,v.scope);
    }
    vnode.getParent().addChildBefore(varnode,vnode);
    compiler.reportChangeToEnclosingScope(vnode);
  }
  if (defined) {
    vnode.getParent().removeChild(vnode);
  }
  for (  Reference ref : referenceInfo.references) {
    compiler.reportChangeToEnclosingScope(ref.getNode());
    if (defined && ref == init) {
      continue;
    }
    if (ref.isLvalue()) {
      replaceAssignmentExpression(v,ref,varmap);
    }
 else     if (ref.getParent().isVar()) {
      ref.getGrandparent().removeChild(ref.getParent());
    }
 else {
      Node getprop=ref.getParent();
      Preconditions.checkState(getprop.isGetProp());
      String var=getprop.getChildAtIndex(1).getString();
      Preconditions.checkState(varmap.containsKey(var));
      Node replacement=IR.name(varmap.get(var));
      replacement.copyInformationFrom(getprop);
      ref.getGrandparent().replaceChild(ref.getParent(),replacement);
    }
  }
}",0.9303815904456744
27915,"/** 
 * Do the actual work of inlining a single declaration into a single reference.
 */
private void inline(Var v,Reference decl,Reference init,Reference ref){
  Node value=init.getAssignedValue();
  Preconditions.checkState(value != null);
  boolean isFunctionDeclaration=NodeUtil.isFunctionDeclaration(value);
  compiler.reportChangeToEnclosingScope(decl.getNode());
  compiler.reportChangeToEnclosingScope(ref.getNode());
  inlineValue(v,ref,value.detachFromParent());
  if (decl != init) {
    Node expressRoot=init.getGrandparent();
    Preconditions.checkState(expressRoot.isExprResult());
    NodeUtil.removeChild(expressRoot.getParent(),expressRoot);
  }
  if (!isFunctionDeclaration) {
    removeDeclaration(decl);
  }
}","/** 
 * Do the actual work of inlining a single declaration into a single reference.
 */
private void inline(Var v,Reference decl,Reference init,Reference ref){
  Node value=init.getAssignedValue();
  Preconditions.checkState(value != null);
  boolean isFunctionDeclaration=NodeUtil.isFunctionDeclaration(value);
  compiler.reportChangeToEnclosingScope(ref.getNode());
  inlineValue(v,ref,value.detachFromParent());
  if (decl != init) {
    Node expressRoot=init.getGrandparent();
    Preconditions.checkState(expressRoot.isExprResult());
    NodeUtil.removeChild(expressRoot.getParent(),expressRoot);
  }
  if (!isFunctionDeclaration) {
    compiler.reportChangeToEnclosingScope(decl.getNode());
    removeDeclaration(decl);
  }
}",0.5280437756497948
27916,"/** 
 * Look for exits (returns, breaks, or continues, depending on the context) at the end of a block and removes them by moving the if node's siblings, if any, into the opposite condition block.
 * @param srcBlock The block to inspect.
 * @param destBlock The block to move sibling nodes into.
 * @param ifNode The if node to work with.
 * @param exitType The type of exit to look for.
 * @param labelName The name associated with the exit, if any.
 * @nullable labelName null for anything excepted for named-break associatedwith a label.
 */
private void tryMinimizeIfBlockExits(Node srcBlock,Node destBlock,Node ifNode,int exitType,String labelName){
  Node exitNodeParent=null;
  Node exitNode=null;
  if (srcBlock.isBlock()) {
    if (!srcBlock.hasChildren()) {
      return;
    }
    exitNodeParent=srcBlock;
    exitNode=exitNodeParent.getLastChild();
  }
 else {
    exitNodeParent=ifNode;
    exitNode=srcBlock;
  }
  if (!matchingExitNode(exitNode,exitType,labelName)) {
    return;
  }
  if (ifNode.getNext() != null) {
    Node newDestBlock=IR.block().srcref(ifNode);
    if (destBlock == null) {
      ifNode.addChildToBack(newDestBlock);
    }
 else     if (destBlock.isEmpty()) {
      ifNode.replaceChild(destBlock,newDestBlock);
    }
 else     if (destBlock.isBlock()) {
      newDestBlock=destBlock;
    }
 else {
      ifNode.replaceChild(destBlock,newDestBlock);
      newDestBlock.addChildToBack(destBlock);
    }
    moveAllFollowing(ifNode,ifNode.getParent(),newDestBlock);
    compiler.reportCodeChange();
  }
}","/** 
 * Look for exits (returns, breaks, or continues, depending on the context) at the end of a block and removes them by moving the if node's siblings, if any, into the opposite condition block.
 * @param srcBlock The block to inspect.
 * @param destBlock The block to move sibling nodes into.
 * @param ifNode The if node to work with.
 * @param exitType The type of exit to look for.
 * @param labelName The name associated with the exit, if any.
 * @nullable labelName null for anything excepted for named-break associatedwith a label.
 */
private void tryMinimizeIfBlockExits(Node srcBlock,Node destBlock,Node ifNode,int exitType,String labelName){
  Node exitNodeParent=null;
  Node exitNode=null;
  if (srcBlock.isBlock()) {
    if (!srcBlock.hasChildren()) {
      return;
    }
    exitNodeParent=srcBlock;
    exitNode=exitNodeParent.getLastChild();
  }
 else {
    exitNodeParent=ifNode;
    exitNode=srcBlock;
  }
  if (!matchingExitNode(exitNode,exitType,labelName)) {
    return;
  }
  if (ifNode.getNext() != null) {
    Node newDestBlock=IR.block().srcref(ifNode);
    if (destBlock == null) {
      ifNode.addChildToBack(newDestBlock);
    }
 else     if (destBlock.isEmpty()) {
      ifNode.replaceChild(destBlock,newDestBlock);
    }
 else     if (destBlock.isBlock()) {
      newDestBlock=destBlock;
    }
 else {
      ifNode.replaceChild(destBlock,newDestBlock);
      newDestBlock.addChildToBack(destBlock);
    }
    moveAllFollowing(ifNode,ifNode.getParent(),newDestBlock);
    compiler.reportChangeToEnclosingScope(ifNode);
  }
}",0.990950226244344
27917,"/** 
 * Attempts to minimize the number of explicit exit points in a control structure to take advantage of the implied exit at the end of the structure.  This is accomplished by removing redundant statements, and moving statements following a qualifying IF node into that node. For example: function () { if (x) return; else blah(); foo(); } becomes: function () { if (x) ; else { blah(); foo(); }
 * @param n The execution node of a parent to inspect.
 * @param exitType The type of exit to look for.
 * @param labelName If parent is a label the name of the label to look for,null otherwise.
 * @nullable labelName non-null only for breaks within labels.
 */
void tryMinimizeExits(Node n,int exitType,String labelName){
  if (matchingExitNode(n,exitType,labelName)) {
    NodeUtil.removeChild(n.getParent(),n);
    compiler.reportCodeChange();
    return;
  }
  if (n.isIf()) {
    Node ifBlock=n.getFirstChild().getNext();
    tryMinimizeExits(ifBlock,exitType,labelName);
    Node elseBlock=ifBlock.getNext();
    if (elseBlock != null) {
      tryMinimizeExits(elseBlock,exitType,labelName);
    }
    return;
  }
  if (n.isTry()) {
    Node tryBlock=n.getFirstChild();
    tryMinimizeExits(tryBlock,exitType,labelName);
    Node allCatchNodes=NodeUtil.getCatchBlock(n);
    if (NodeUtil.hasCatchHandler(allCatchNodes)) {
      Preconditions.checkState(allCatchNodes.hasOneChild());
      Node catchNode=allCatchNodes.getFirstChild();
      Node catchCodeBlock=catchNode.getLastChild();
      tryMinimizeExits(catchCodeBlock,exitType,labelName);
    }
  }
  if (n.isLabel()) {
    Node labelBlock=n.getLastChild();
    tryMinimizeExits(labelBlock,exitType,labelName);
  }
  if (!n.isBlock() || n.getLastChild() == null) {
    return;
  }
  for (  Node c : n.children()) {
    if (c.isIf()) {
      Node ifTree=c;
      Node trueBlock, falseBlock;
      trueBlock=ifTree.getFirstChild().getNext();
      falseBlock=trueBlock.getNext();
      tryMinimizeIfBlockExits(trueBlock,falseBlock,ifTree,exitType,labelName);
      trueBlock=ifTree.getFirstChild().getNext();
      falseBlock=trueBlock.getNext();
      if (falseBlock != null) {
        tryMinimizeIfBlockExits(falseBlock,trueBlock,ifTree,exitType,labelName);
      }
    }
    if (c == n.getLastChild()) {
      break;
    }
  }
  for (Node c=n.getLastChild(); c != null; c=n.getLastChild()) {
    tryMinimizeExits(c,exitType,labelName);
    if (c == n.getLastChild()) {
      break;
    }
  }
}","/** 
 * Attempts to minimize the number of explicit exit points in a control structure to take advantage of the implied exit at the end of the structure.  This is accomplished by removing redundant statements, and moving statements following a qualifying IF node into that node. For example: function () { if (x) return; else blah(); foo(); } becomes: function () { if (x) ; else { blah(); foo(); }
 * @param n The execution node of a parent to inspect.
 * @param exitType The type of exit to look for.
 * @param labelName If parent is a label the name of the label to look for,null otherwise.
 * @nullable labelName non-null only for breaks within labels.
 */
void tryMinimizeExits(Node n,int exitType,String labelName){
  if (matchingExitNode(n,exitType,labelName)) {
    compiler.reportChangeToEnclosingScope(n);
    NodeUtil.removeChild(n.getParent(),n);
    return;
  }
  if (n.isIf()) {
    Node ifBlock=n.getFirstChild().getNext();
    tryMinimizeExits(ifBlock,exitType,labelName);
    Node elseBlock=ifBlock.getNext();
    if (elseBlock != null) {
      tryMinimizeExits(elseBlock,exitType,labelName);
    }
    return;
  }
  if (n.isTry()) {
    Node tryBlock=n.getFirstChild();
    tryMinimizeExits(tryBlock,exitType,labelName);
    Node allCatchNodes=NodeUtil.getCatchBlock(n);
    if (NodeUtil.hasCatchHandler(allCatchNodes)) {
      Preconditions.checkState(allCatchNodes.hasOneChild());
      Node catchNode=allCatchNodes.getFirstChild();
      Node catchCodeBlock=catchNode.getLastChild();
      tryMinimizeExits(catchCodeBlock,exitType,labelName);
    }
  }
  if (n.isLabel()) {
    Node labelBlock=n.getLastChild();
    tryMinimizeExits(labelBlock,exitType,labelName);
  }
  if (!n.isBlock() || n.getLastChild() == null) {
    return;
  }
  for (  Node c : n.children()) {
    if (c.isIf()) {
      Node ifTree=c;
      Node trueBlock, falseBlock;
      trueBlock=ifTree.getFirstChild().getNext();
      falseBlock=trueBlock.getNext();
      tryMinimizeIfBlockExits(trueBlock,falseBlock,ifTree,exitType,labelName);
      trueBlock=ifTree.getFirstChild().getNext();
      falseBlock=trueBlock.getNext();
      if (falseBlock != null) {
        tryMinimizeIfBlockExits(falseBlock,trueBlock,ifTree,exitType,labelName);
      }
    }
    if (c == n.getLastChild()) {
      break;
    }
  }
  for (Node c=n.getLastChild(); c != null; c=n.getLastChild()) {
    tryMinimizeExits(c,exitType,labelName);
    if (c == n.getLastChild()) {
      break;
    }
  }
}",0.983959390862944
27918,"/** 
 * Traversal for passes that work only on changed functions. Suppose a loopable pass P1 uses this traversal. Then, if a function doesn't change between two runs of P1, it won't look at the function the second time. (We're assuming that P1 runs to a fixpoint, o/w we may miss optimizations.)
 */
public static void traverseChangedFunctions(AbstractCompiler compiler,FunctionCallback callback){
  final AbstractCompiler comp=compiler;
  final FunctionCallback cb=callback;
  final Node jsRoot=comp.getJsRoot();
  if (comp.hasScopeChanged(jsRoot)) {
    cb.visit(comp,jsRoot);
  }
  traverse(comp,jsRoot,new AbstractPreOrderCallback(){
    @Override public final boolean shouldTraverse(    NodeTraversal t,    Node n,    Node p){
      if (n.isFunction() && comp.hasScopeChanged(n)) {
        cb.visit(comp,n);
      }
      return true;
    }
  }
);
}","/** 
 * Traversal for passes that work only on changed functions. Suppose a loopable pass P1 uses this traversal. Then, if a function doesn't change between two runs of P1, it won't look at the function the second time. (We're assuming that P1 runs to a fixpoint, o/w we may miss optimizations.) Most changes are reported with calls to Compiler.reportCodeChange(), which doesn't know which scope changed. We keep track of the current scope by calling Compiler.setScope inside pushScope and popScope. The automatic tracking can be wrong in rare cases when a pass changes scope w/out causing a call to pushScope or popScope. It's very hard to find the places where this happens unless a bug is triggered. Passes that do cross-scope modifications call Compiler.reportChangeToEnclosingScope(Node n).
 */
public static void traverseChangedFunctions(AbstractCompiler compiler,FunctionCallback callback){
  final AbstractCompiler comp=compiler;
  final FunctionCallback cb=callback;
  final Node jsRoot=comp.getJsRoot();
  NodeTraversal t=new NodeTraversal(comp,new AbstractPreOrderCallback(){
    @Override public final boolean shouldTraverse(    NodeTraversal t,    Node n,    Node p){
      if ((n == jsRoot || n.isFunction()) && comp.hasScopeChanged(n)) {
        cb.visit(comp,n);
      }
      return true;
    }
  }
);
  t.traverse(jsRoot);
}",0.7012750455373407
27919,"/** 
 * Pops back to the previous scope (e.g. when leaving a function). 
 */
private void popScope(){
  if (scopeCallback != null) {
    scopeCallback.exitScope(this);
  }
  if (scopeRoots.isEmpty()) {
    scopes.pop();
  }
 else {
    scopeRoots.pop();
  }
  cfgs.pop();
  if (!scopes.isEmpty()) {
    compiler.setScope(scopes.peek().getRootNode());
  }
}","/** 
 * Pops back to the previous scope (e.g. when leaving a function). 
 */
private void popScope(){
  if (scopeCallback != null) {
    scopeCallback.exitScope(this);
  }
  if (scopeRoots.isEmpty()) {
    scopes.pop();
  }
 else {
    scopeRoots.pop();
  }
  cfgs.pop();
  if (hasScope()) {
    compiler.setScope(getScopeRoot());
  }
}",0.869942196531792
27920,"@Override public final boolean shouldTraverse(NodeTraversal t,Node n,Node p){
  if (n.isFunction() && comp.hasScopeChanged(n)) {
    cb.visit(comp,n);
  }
  return true;
}","@Override public final boolean shouldTraverse(NodeTraversal t,Node n,Node p){
  if ((n == jsRoot || n.isFunction()) && comp.hasScopeChanged(n)) {
    cb.visit(comp,n);
  }
  return true;
}",0.9526462395543176
27921,"/** 
 * Checks that the scope roots marked as changed have indeed changed 
 */
public static void verifyScopeChanges(Map<Node,Node> map,Node main,boolean verifyUnchangedNodes){
  final Map<Node,Node> mtoc=map;
  final boolean checkUnchanged=verifyUnchangedNodes;
  Node clone=mtoc.get(main);
  if (main.getChangeTime() > clone.getChangeTime()) {
    Preconditions.checkState(!main.isEquivalentToShallow(clone));
  }
 else   if (checkUnchanged) {
    Preconditions.checkState(main.isEquivalentToShallow(clone));
  }
  visitPreOrder(main,new Visitor(){
    @Override public void visit(    Node n){
      if (n.isFunction() && mtoc.containsKey(n)) {
        Node clone=mtoc.get(n);
        if (n.getChangeTime() > clone.getChangeTime()) {
          Preconditions.checkState(!n.isEquivalentToShallow(clone));
        }
 else         if (checkUnchanged) {
          Preconditions.checkState(n.isEquivalentToShallow(clone));
        }
      }
    }
  }
,Predicates.<Node>alwaysTrue());
}","/** 
 * Checks that the scope roots marked as changed have indeed changed 
 */
public static void verifyScopeChanges(Map<Node,Node> map,Node main,boolean verifyUnchangedNodes,AbstractCompiler compiler){
  final Map<Node,Node> mtoc=map;
  final boolean checkUnchanged=verifyUnchangedNodes;
  Node clone=mtoc.get(main);
  if (main.getChangeTime() > clone.getChangeTime()) {
    Preconditions.checkState(!main.isEquivalentToShallow(clone));
  }
 else   if (checkUnchanged) {
    Preconditions.checkState(main.isEquivalentToShallow(clone));
  }
  visitPreOrder(main,new Visitor(){
    @Override public void visit(    Node n){
      if (n.isFunction() && mtoc.containsKey(n)) {
        Node clone=mtoc.get(n);
        if (n.getChangeTime() > clone.getChangeTime()) {
          Preconditions.checkState(!n.isEquivalentToShallow(clone));
        }
 else         if (checkUnchanged) {
          Preconditions.checkState(n.isEquivalentToShallow(clone));
        }
      }
    }
  }
,Predicates.<Node>alwaysTrue());
}",0.9869215291750504
27922,"/** 
 * Runs the sanity check if it is available.
 */
private void maybeSanityCheck(Node externs,Node root){
  if (sanityCheck != null) {
    sanityCheck.create(compiler).process(externs,root);
    if (inLoop) {
      NodeUtil.verifyScopeChanges(mtoc,jsRoot,true);
      setSanityCheckState();
    }
  }
}","/** 
 * Runs the sanity check if it is available.
 */
private void maybeSanityCheck(Node externs,Node root){
  if (sanityCheck != null) {
    sanityCheck.create(compiler).process(externs,root);
    if (inLoop) {
      NodeUtil.verifyScopeChanges(mtoc,jsRoot,true,compiler);
      setSanityCheckState();
    }
  }
}",0.9854604200323102
27923,"private void removeUnused(){
  for (  Node n : candidates) {
    Preconditions.checkState(n.isGetProp());
    if (!used.contains(n.getLastChild().getString())) {
      Node parent=n.getParent();
      if (NodeUtil.isAssignmentOp(parent)) {
        Node assign=parent;
        Preconditions.checkState(assign != null && NodeUtil.isAssignmentOp(assign) && assign.getFirstChild() == n);
        assign.getParent().replaceChild(assign,assign.getLastChild().detachFromParent());
      }
 else       if (parent.isInc() || parent.isDec()) {
        parent.getParent().replaceChild(parent,IR.number(0));
      }
 else {
        throw new IllegalStateException(""String_Node_Str"" + parent);
      }
      compiler.reportCodeChange();
    }
  }
}","private void removeUnused(){
  for (  Node n : candidates) {
    Preconditions.checkState(n.isGetProp());
    if (!used.contains(n.getLastChild().getString())) {
      Node parent=n.getParent();
      if (NodeUtil.isAssignmentOp(parent)) {
        Node assign=parent;
        Preconditions.checkState(assign != null && NodeUtil.isAssignmentOp(assign) && assign.getFirstChild() == n);
        compiler.reportChangeToEnclosingScope(assign);
        assign.getParent().replaceChild(assign,assign.getLastChild().detachFromParent());
      }
 else       if (parent.isInc() || parent.isDec()) {
        compiler.reportChangeToEnclosingScope(parent);
        parent.getParent().replaceChild(parent,IR.number(0));
      }
 else {
        throw new IllegalStateException(""String_Node_Str"" + parent);
      }
    }
  }
}",0.906148867313916
27924,"/** 
 * Remove all properties under a given name if the property name is never referenced.
 */
private void removeUnusedSymbols(Collection<NameInfo> allNameInfo){
  boolean changed=false;
  for (  NameInfo nameInfo : allNameInfo) {
    if (!nameInfo.isReferenced()) {
      for (      Symbol declaration : nameInfo.getDeclarations()) {
        boolean canRemove=false;
        if (specializationState == null) {
          canRemove=true;
        }
 else {
          Node specializableFunction=getSpecializableFunctionFromSymbol(declaration);
          if (specializableFunction != null) {
            specializationState.reportRemovedFunction(specializableFunction,null);
            canRemove=true;
          }
        }
        if (canRemove) {
          declaration.remove();
          changed=true;
        }
      }
      logger.fine(""String_Node_Str"" + nameInfo.name);
    }
  }
  if (changed) {
    compiler.reportCodeChange();
  }
}","/** 
 * Remove all properties under a given name if the property name is never referenced.
 */
private void removeUnusedSymbols(Collection<NameInfo> allNameInfo){
  for (  NameInfo nameInfo : allNameInfo) {
    if (!nameInfo.isReferenced()) {
      for (      Symbol declaration : nameInfo.getDeclarations()) {
        boolean canRemove=false;
        if (specializationState == null) {
          canRemove=true;
        }
 else {
          Node specializableFunction=getSpecializableFunctionFromSymbol(declaration);
          if (specializableFunction != null) {
            specializationState.reportRemovedFunction(specializableFunction,null);
            canRemove=true;
          }
        }
        if (canRemove) {
          declaration.remove(compiler);
        }
      }
      logger.fine(""String_Node_Str"" + nameInfo.name);
    }
  }
}",0.9366946778711484
27925,"/** 
 * Removes any vars in the scope that were not referenced. Removes any assignments to those variables as well.
 */
private void removeUnreferencedVars(){
  for (Iterator<Var> it=maybeUnreferenced.iterator(); it.hasNext(); ) {
    Var var=it.next();
    for (    Node exprCallNode : classDefiningCalls.get(var)) {
      NodeUtil.removeChild(exprCallNode.getParent(),exprCallNode);
      compiler.reportCodeChange();
    }
    removeAllAssigns(var);
    compiler.addToDebugLog(""String_Node_Str"" + var.name);
    Node nameNode=var.nameNode;
    Node toRemove=nameNode.getParent();
    Node parent=toRemove.getParent();
    Preconditions.checkState(toRemove.isVar() || toRemove.isFunction() || toRemove.isParamList() && parent.isFunction(),""String_Node_Str"");
    if (toRemove.isParamList() && parent.isFunction()) {
    }
 else     if (NodeUtil.isFunctionExpression(toRemove)) {
      if (!preserveFunctionExpressionNames) {
        toRemove.getFirstChild().setString(""String_Node_Str"");
        compiler.reportCodeChange();
      }
    }
 else     if (parent != null && parent.isFor() && parent.getChildCount() < 4) {
    }
 else     if (toRemove.isVar() && nameNode.hasChildren() && NodeUtil.mayHaveSideEffects(nameNode.getFirstChild(),compiler)) {
      if (toRemove.getChildCount() == 1) {
        parent.replaceChild(toRemove,IR.exprResult(nameNode.removeFirstChild()));
        compiler.reportCodeChange();
      }
    }
 else     if (toRemove.isVar() && toRemove.getChildCount() > 1) {
      toRemove.removeChild(nameNode);
      compiler.reportCodeChange();
    }
 else     if (parent != null) {
      NodeUtil.removeChild(parent,toRemove);
      compiler.reportCodeChange();
    }
  }
}","/** 
 * Removes any vars in the scope that were not referenced. Removes any assignments to those variables as well.
 */
private void removeUnreferencedVars(){
  for (Iterator<Var> it=maybeUnreferenced.iterator(); it.hasNext(); ) {
    Var var=it.next();
    for (    Node exprCallNode : classDefiningCalls.get(var)) {
      compiler.reportChangeToEnclosingScope(exprCallNode);
      NodeUtil.removeChild(exprCallNode.getParent(),exprCallNode);
    }
    removeAllAssigns(var);
    compiler.addToDebugLog(""String_Node_Str"" + var.name);
    Node nameNode=var.nameNode;
    Node toRemove=nameNode.getParent();
    Node parent=toRemove.getParent();
    Preconditions.checkState(toRemove.isVar() || toRemove.isFunction() || toRemove.isParamList() && parent.isFunction(),""String_Node_Str"");
    if (toRemove.isParamList() && parent.isFunction()) {
    }
 else     if (NodeUtil.isFunctionExpression(toRemove)) {
      if (!preserveFunctionExpressionNames) {
        compiler.reportChangeToEnclosingScope(toRemove);
        toRemove.getFirstChild().setString(""String_Node_Str"");
      }
    }
 else     if (parent != null && parent.isFor() && parent.getChildCount() < 4) {
    }
 else     if (toRemove.isVar() && nameNode.hasChildren() && NodeUtil.mayHaveSideEffects(nameNode.getFirstChild(),compiler)) {
      if (toRemove.getChildCount() == 1) {
        compiler.reportChangeToEnclosingScope(toRemove);
        parent.replaceChild(toRemove,IR.exprResult(nameNode.removeFirstChild()));
      }
    }
 else     if (toRemove.isVar() && toRemove.getChildCount() > 1) {
      compiler.reportChangeToEnclosingScope(toRemove);
      toRemove.removeChild(nameNode);
    }
 else     if (parent != null) {
      compiler.reportChangeToEnclosingScope(toRemove);
      NodeUtil.removeChild(parent,toRemove);
    }
  }
}",0.8570611778158947
27926,"/** 
 * Applies optimizations to all previously marked nodes.
 */
public void applyChanges(){
  for (  Node n : toRemove) {
    n.getParent().removeChild(n);
    compiler.reportCodeChange();
  }
  for (  Node n : toReplaceWithZero) {
    n.getParent().replaceChild(n,IR.number(0).srcref(n));
    compiler.reportCodeChange();
  }
}","/** 
 * Applies optimizations to all previously marked nodes.
 */
public void applyChanges(){
  for (  Node n : toRemove) {
    compiler.reportChangeToEnclosingScope(n);
    n.getParent().removeChild(n);
  }
  for (  Node n : toReplaceWithZero) {
    compiler.reportChangeToEnclosingScope(n);
    n.getParent().replaceChild(n,IR.number(0).srcref(n));
  }
}",0.6588921282798834
27927,"/** 
 * Remove all assigns to a var.
 */
private void removeAllAssigns(Var var){
  for (  Assign assign : assignsByVar.get(var)) {
    assign.remove();
    compiler.reportCodeChange();
  }
}","/** 
 * Remove all assigns to a var.
 */
private void removeAllAssigns(Var var){
  for (  Assign assign : assignsByVar.get(var)) {
    compiler.reportChangeToEnclosingScope(assign.assignNode);
    assign.remove();
  }
}",0.8019559902200489
27928,"/** 
 * Removes unreferenced arguments from a function declaration and when possible the function's callSites.
 * @param fnScope The scope inside the function
 */
private void removeUnreferencedFunctionArgs(Scope fnScope){
  if (!removeGlobals) {
    return;
  }
  Node function=fnScope.getRootNode();
  Preconditions.checkState(function.isFunction());
  if (NodeUtil.isGetOrSetKey(function.getParent())) {
    return;
  }
  Node argList=getFunctionArgList(function);
  boolean modifyCallers=modifyCallSites && callSiteOptimizer.canModifyCallers(function);
  if (!modifyCallers) {
    Node lastArg;
    while ((lastArg=argList.getLastChild()) != null) {
      Var var=fnScope.getVar(lastArg.getString());
      if (!referenced.contains(var)) {
        argList.removeChild(lastArg);
        compiler.reportCodeChange();
      }
 else {
        break;
      }
    }
  }
 else {
    callSiteOptimizer.optimize(fnScope,referenced);
  }
}","/** 
 * Removes unreferenced arguments from a function declaration and when possible the function's callSites.
 * @param fnScope The scope inside the function
 */
private void removeUnreferencedFunctionArgs(Scope fnScope){
  if (!removeGlobals) {
    return;
  }
  Node function=fnScope.getRootNode();
  Preconditions.checkState(function.isFunction());
  if (NodeUtil.isGetOrSetKey(function.getParent())) {
    return;
  }
  Node argList=getFunctionArgList(function);
  boolean modifyCallers=modifyCallSites && callSiteOptimizer.canModifyCallers(function);
  if (!modifyCallers) {
    Node lastArg;
    while ((lastArg=argList.getLastChild()) != null) {
      Var var=fnScope.getVar(lastArg.getString());
      if (!referenced.contains(var)) {
        compiler.reportChangeToEnclosingScope(lastArg);
        argList.removeChild(lastArg);
      }
 else {
        break;
      }
    }
  }
 else {
    callSiteOptimizer.optimize(fnScope,referenced);
  }
}",0.9474801061007958
27929,"private void removeNode(Node n){
  codeChanged=true;
  NodeUtil.redeclareVarsInsideBranch(n);
  compiler.reportCodeChange();
  if (logger.isLoggable(Level.FINE)) {
    logger.fine(""String_Node_Str"" + n.toString());
  }
  NodeUtil.removeChild(n.getParent(),n);
}","private void removeNode(Node n){
  codeChanged=true;
  NodeUtil.redeclareVarsInsideBranch(n);
  compiler.reportChangeToEnclosingScope(n);
  if (logger.isLoggable(Level.FINE)) {
    logger.fine(""String_Node_Str"" + n.toString());
  }
  NodeUtil.removeChild(n.getParent(),n);
}",0.9383177570093458
27930,"/** 
 * Verifies that the compiler pass's JS output matches the expected output and (optionally) that an expected warning is issued. Or, if an error is expected, this method just verifies that the error is encountered.
 * @param compiler A compiler that has been initialized via{@link Compiler#init}
 * @param expected Expected output, or null if an error is expected
 * @param error Expected error, or null if no error is expected
 * @param warning Expected warning, or null if no warning is expected
 * @param description The description of the expected warning,or null if no warning is expected or if the warning's description should not be examined
 */
private void test(Compiler compiler,String[] expected,DiagnosticType error,DiagnosticType warning,String description){
  RecentChange recentChange=new RecentChange();
  compiler.addChangeHandler(recentChange);
  Node root=compiler.parseInputs();
  assertTrue(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(compiler.getErrors()),root != null);
  if (!expectParseWarningsThisTest) {
    assertTrue(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(compiler.getWarnings()),compiler.getWarnings().length == 0);
  }
  if (astValidationEnabled) {
    (new AstValidator()).validateRoot(root);
  }
  Node externsRoot=root.getFirstChild();
  Node mainRoot=root.getLastChild();
  Node rootClone=root.cloneTree();
  Node externsRootClone=rootClone.getFirstChild();
  Node mainRootClone=rootClone.getLastChild();
  Map<Node,Node> mtoc=NodeUtil.mapMainToClone(mainRoot,mainRootClone);
  int numRepetitions=getNumRepetitions();
  ErrorManager[] errorManagers=new ErrorManager[numRepetitions];
  int aggregateWarningCount=0;
  List<JSError> aggregateWarnings=Lists.newArrayList();
  boolean hasCodeChanged=false;
  assertFalse(""String_Node_Str"",recentChange.hasCodeChanged());
  for (int i=0; i < numRepetitions; ++i) {
    if (compiler.getErrorCount() == 0) {
      errorManagers[i]=new BlackHoleErrorManager(compiler);
      if (closurePassEnabled && i == 0) {
        recentChange.reset();
        new ProcessClosurePrimitives(compiler,null,CheckLevel.ERROR).process(null,mainRoot);
        hasCodeChanged=hasCodeChanged || recentChange.hasCodeChanged();
      }
      if (typeCheckEnabled && i == 0) {
        TypeCheck check=createTypeCheck(compiler,typeCheckLevel);
        check.processForTesting(externsRoot,mainRoot);
      }
      if (normalizeEnabled && i == 0) {
        normalizeActualCode(compiler,externsRoot,mainRoot);
      }
      if (markNoSideEffects && i == 0) {
        MarkNoSideEffectCalls mark=new MarkNoSideEffectCalls(compiler);
        mark.process(externsRoot,mainRoot);
      }
      recentChange.reset();
      getProcessor(compiler).process(externsRoot,mainRoot);
      if (astValidationEnabled) {
        (new AstValidator()).validateRoot(root);
      }
      if (checkLineNumbers) {
        (new LineNumberCheck(compiler)).process(externsRoot,mainRoot);
      }
      hasCodeChanged=hasCodeChanged || recentChange.hasCodeChanged();
      aggregateWarningCount+=errorManagers[i].getWarningCount();
      aggregateWarnings.addAll(Lists.newArrayList(compiler.getWarnings()));
      if (normalizeEnabled) {
        boolean verifyDeclaredConstants=true;
        new Normalize.VerifyConstants(compiler,verifyDeclaredConstants).process(externsRoot,mainRoot);
      }
    }
  }
  if (error == null) {
    assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(compiler.getErrors()),0,compiler.getErrorCount());
    ErrorManager symbolTableErrorManager=new BlackHoleErrorManager(compiler);
    Node expectedRoot=null;
    if (expected != null) {
      expectedRoot=parseExpectedJs(expected);
      expectedRoot.detachFromParent();
    }
    JSError[] stErrors=symbolTableErrorManager.getErrors();
    if (expectedSymbolTableError != null) {
      assertEquals(""String_Node_Str"",1,stErrors.length);
      assertEquals(expectedSymbolTableError,stErrors[0].getType());
    }
 else {
      assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(stErrors),0,stErrors.length);
    }
    if (warning == null) {
      assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(aggregateWarnings),0,aggregateWarningCount);
    }
 else {
      assertEquals(""String_Node_Str"" + numRepetitions + ""String_Node_Str"",numRepetitions,aggregateWarningCount);
      for (int i=0; i < numRepetitions; ++i) {
        JSError[] warnings=errorManagers[i].getWarnings();
        JSError actual=warnings[0];
        assertEquals(warning,actual.getType());
        if (!allowSourcelessWarnings) {
          assertTrue(""String_Node_Str"",actual.sourceName != null && !actual.sourceName.isEmpty());
          assertTrue(""String_Node_Str"",-1 != actual.lineNumber);
          assertTrue(""String_Node_Str"",-1 != actual.getCharno());
        }
        if (description != null) {
          assertEquals(description,actual.description);
        }
      }
    }
    if (normalizeEnabled) {
      normalizeActualCode(compiler,externsRootClone,mainRootClone);
    }
    boolean codeChange=!mainRootClone.isEquivalentTo(mainRoot);
    boolean externsChange=!externsRootClone.isEquivalentTo(externsRoot);
    if (externsChange && !allowExternsChanges) {
      String explanation=externsRootClone.checkTreeEquals(externsRoot);
      fail(""String_Node_Str"" + ""String_Node_Str"" + compiler.toSource(externsRootClone) + ""String_Node_Str""+ compiler.toSource(externsRoot)+ ""String_Node_Str""+ explanation);
    }
    if (!codeChange && !externsChange) {
      assertFalse(""String_Node_Str"" + ""String_Node_Str"",hasCodeChanged);
    }
 else {
      assertTrue(""String_Node_Str"",hasCodeChanged);
    }
    NodeUtil.verifyScopeChanges(mtoc,mainRoot,false);
    if (expected != null) {
      if (compareAsTree) {
        String explanation=expectedRoot.checkTreeEquals(mainRoot);
        assertNull(""String_Node_Str"" + compiler.toSource(expectedRoot) + ""String_Node_Str""+ compiler.toSource(mainRoot)+ ""String_Node_Str""+ explanation,explanation);
      }
 else       if (expected != null) {
        assertEquals(Joiner.on(""String_Node_Str"").join(expected),compiler.toSource(mainRoot));
      }
    }
    Node normalizeCheckRootClone=root.cloneTree();
    Node normalizeCheckExternsRootClone=normalizeCheckRootClone.getFirstChild();
    Node normalizeCheckMainRootClone=normalizeCheckRootClone.getLastChild();
    new PrepareAst(compiler).process(normalizeCheckExternsRootClone,normalizeCheckMainRootClone);
    String explanation=normalizeCheckMainRootClone.checkTreeEquals(mainRoot);
    assertNull(""String_Node_Str"" + compiler.toSource(normalizeCheckMainRootClone) + ""String_Node_Str""+ compiler.toSource(mainRoot)+ ""String_Node_Str""+ explanation,explanation);
    if (normalizeEnabled) {
      new Normalize(compiler,true).process(normalizeCheckExternsRootClone,normalizeCheckMainRootClone);
      explanation=normalizeCheckMainRootClone.checkTreeEquals(mainRoot);
      assertNull(""String_Node_Str"" + compiler.toSource(normalizeCheckMainRootClone) + ""String_Node_Str""+ compiler.toSource(mainRoot)+ ""String_Node_Str""+ explanation,explanation);
    }
  }
 else {
    String errors=""String_Node_Str"";
    for (    JSError actualError : compiler.getErrors()) {
      errors+=actualError.description + ""String_Node_Str"";
    }
    assertEquals(""String_Node_Str"" + errors,1,compiler.getErrorCount());
    assertEquals(errors,error,compiler.getErrors()[0].getType());
    if (warning != null) {
      String warnings=""String_Node_Str"";
      for (      JSError actualError : compiler.getWarnings()) {
        warnings+=actualError.description + ""String_Node_Str"";
      }
      assertEquals(""String_Node_Str"" + warnings,1,compiler.getWarningCount());
      assertEquals(warnings,warning,compiler.getWarnings()[0].getType());
    }
  }
}","/** 
 * Verifies that the compiler pass's JS output matches the expected output and (optionally) that an expected warning is issued. Or, if an error is expected, this method just verifies that the error is encountered.
 * @param compiler A compiler that has been initialized via{@link Compiler#init}
 * @param expected Expected output, or null if an error is expected
 * @param error Expected error, or null if no error is expected
 * @param warning Expected warning, or null if no warning is expected
 * @param description The description of the expected warning,or null if no warning is expected or if the warning's description should not be examined
 */
private void test(Compiler compiler,String[] expected,DiagnosticType error,DiagnosticType warning,String description){
  RecentChange recentChange=new RecentChange();
  compiler.addChangeHandler(recentChange);
  Node root=compiler.parseInputs();
  assertTrue(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(compiler.getErrors()),root != null);
  if (!expectParseWarningsThisTest) {
    assertTrue(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(compiler.getWarnings()),compiler.getWarnings().length == 0);
  }
  if (astValidationEnabled) {
    (new AstValidator()).validateRoot(root);
  }
  Node externsRoot=root.getFirstChild();
  Node mainRoot=root.getLastChild();
  Node rootClone=root.cloneTree();
  Node externsRootClone=rootClone.getFirstChild();
  Node mainRootClone=rootClone.getLastChild();
  Map<Node,Node> mtoc=NodeUtil.mapMainToClone(mainRoot,mainRootClone);
  int numRepetitions=getNumRepetitions();
  ErrorManager[] errorManagers=new ErrorManager[numRepetitions];
  int aggregateWarningCount=0;
  List<JSError> aggregateWarnings=Lists.newArrayList();
  boolean hasCodeChanged=false;
  assertFalse(""String_Node_Str"",recentChange.hasCodeChanged());
  for (int i=0; i < numRepetitions; ++i) {
    if (compiler.getErrorCount() == 0) {
      errorManagers[i]=new BlackHoleErrorManager(compiler);
      if (closurePassEnabled && i == 0) {
        recentChange.reset();
        new ProcessClosurePrimitives(compiler,null,CheckLevel.ERROR).process(null,mainRoot);
        hasCodeChanged=hasCodeChanged || recentChange.hasCodeChanged();
      }
      if (typeCheckEnabled && i == 0) {
        TypeCheck check=createTypeCheck(compiler,typeCheckLevel);
        check.processForTesting(externsRoot,mainRoot);
      }
      if (normalizeEnabled && i == 0) {
        normalizeActualCode(compiler,externsRoot,mainRoot);
      }
      if (markNoSideEffects && i == 0) {
        MarkNoSideEffectCalls mark=new MarkNoSideEffectCalls(compiler);
        mark.process(externsRoot,mainRoot);
      }
      recentChange.reset();
      getProcessor(compiler).process(externsRoot,mainRoot);
      if (astValidationEnabled) {
        (new AstValidator()).validateRoot(root);
      }
      if (checkLineNumbers) {
        (new LineNumberCheck(compiler)).process(externsRoot,mainRoot);
      }
      hasCodeChanged=hasCodeChanged || recentChange.hasCodeChanged();
      aggregateWarningCount+=errorManagers[i].getWarningCount();
      aggregateWarnings.addAll(Lists.newArrayList(compiler.getWarnings()));
      if (normalizeEnabled) {
        boolean verifyDeclaredConstants=true;
        new Normalize.VerifyConstants(compiler,verifyDeclaredConstants).process(externsRoot,mainRoot);
      }
    }
  }
  if (error == null) {
    assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(compiler.getErrors()),0,compiler.getErrorCount());
    ErrorManager symbolTableErrorManager=new BlackHoleErrorManager(compiler);
    Node expectedRoot=null;
    if (expected != null) {
      expectedRoot=parseExpectedJs(expected);
      expectedRoot.detachFromParent();
    }
    JSError[] stErrors=symbolTableErrorManager.getErrors();
    if (expectedSymbolTableError != null) {
      assertEquals(""String_Node_Str"",1,stErrors.length);
      assertEquals(expectedSymbolTableError,stErrors[0].getType());
    }
 else {
      assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(stErrors),0,stErrors.length);
    }
    if (warning == null) {
      assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(aggregateWarnings),0,aggregateWarningCount);
    }
 else {
      assertEquals(""String_Node_Str"" + numRepetitions + ""String_Node_Str"",numRepetitions,aggregateWarningCount);
      for (int i=0; i < numRepetitions; ++i) {
        JSError[] warnings=errorManagers[i].getWarnings();
        JSError actual=warnings[0];
        assertEquals(warning,actual.getType());
        if (!allowSourcelessWarnings) {
          assertTrue(""String_Node_Str"",actual.sourceName != null && !actual.sourceName.isEmpty());
          assertTrue(""String_Node_Str"",-1 != actual.lineNumber);
          assertTrue(""String_Node_Str"",-1 != actual.getCharno());
        }
        if (description != null) {
          assertEquals(description,actual.description);
        }
      }
    }
    if (normalizeEnabled) {
      normalizeActualCode(compiler,externsRootClone,mainRootClone);
    }
    boolean codeChange=!mainRootClone.isEquivalentTo(mainRoot);
    boolean externsChange=!externsRootClone.isEquivalentTo(externsRoot);
    if (externsChange && !allowExternsChanges) {
      String explanation=externsRootClone.checkTreeEquals(externsRoot);
      fail(""String_Node_Str"" + ""String_Node_Str"" + compiler.toSource(externsRootClone) + ""String_Node_Str""+ compiler.toSource(externsRoot)+ ""String_Node_Str""+ explanation);
    }
    if (!codeChange && !externsChange) {
      assertFalse(""String_Node_Str"" + ""String_Node_Str"",hasCodeChanged);
    }
 else {
      assertTrue(""String_Node_Str"",hasCodeChanged);
    }
    NodeUtil.verifyScopeChanges(mtoc,mainRoot,false,compiler);
    if (expected != null) {
      if (compareAsTree) {
        String explanation=expectedRoot.checkTreeEquals(mainRoot);
        assertNull(""String_Node_Str"" + compiler.toSource(expectedRoot) + ""String_Node_Str""+ compiler.toSource(mainRoot)+ ""String_Node_Str""+ explanation,explanation);
      }
 else       if (expected != null) {
        assertEquals(Joiner.on(""String_Node_Str"").join(expected),compiler.toSource(mainRoot));
      }
    }
    Node normalizeCheckRootClone=root.cloneTree();
    Node normalizeCheckExternsRootClone=normalizeCheckRootClone.getFirstChild();
    Node normalizeCheckMainRootClone=normalizeCheckRootClone.getLastChild();
    new PrepareAst(compiler).process(normalizeCheckExternsRootClone,normalizeCheckMainRootClone);
    String explanation=normalizeCheckMainRootClone.checkTreeEquals(mainRoot);
    assertNull(""String_Node_Str"" + compiler.toSource(normalizeCheckMainRootClone) + ""String_Node_Str""+ compiler.toSource(mainRoot)+ ""String_Node_Str""+ explanation,explanation);
    if (normalizeEnabled) {
      new Normalize(compiler,true).process(normalizeCheckExternsRootClone,normalizeCheckMainRootClone);
      explanation=normalizeCheckMainRootClone.checkTreeEquals(mainRoot);
      assertNull(""String_Node_Str"" + compiler.toSource(normalizeCheckMainRootClone) + ""String_Node_Str""+ compiler.toSource(mainRoot)+ ""String_Node_Str""+ explanation,explanation);
    }
  }
 else {
    String errors=""String_Node_Str"";
    for (    JSError actualError : compiler.getErrors()) {
      errors+=actualError.description + ""String_Node_Str"";
    }
    assertEquals(""String_Node_Str"" + errors,1,compiler.getErrorCount());
    assertEquals(errors,error,compiler.getErrors()[0].getType());
    if (warning != null) {
      String warnings=""String_Node_Str"";
      for (      JSError actualError : compiler.getWarnings()) {
        warnings+=actualError.description + ""String_Node_Str"";
      }
      assertEquals(""String_Node_Str"" + warnings,1,compiler.getWarningCount());
      assertEquals(warnings,warning,compiler.getWarnings()[0].getType());
    }
  }
}",0.999422521655438
27931,"/** 
 * Attempts to minimize the number of explicit exit points in a control structure to take advantage of the implied exit at the end of the structure.  This is accomplished by removing redundant statements, and moving statements following a qualifying IF node into that node. For example: function () { if (x) return; else blah(); foo(); } becomes: function () { if (x) ; else { blah(); foo(); }
 * @param n The execution node of a parent to inspect.
 * @param exitType The type of exit to look for.
 * @param labelName If parent is a label the name of the label to look for,null otherwise.
 * @nullable labelName non-null only for breaks within labels.
 */
void tryMinimizeExits(Node n,int exitType,String labelName){
  if (matchingExitNode(n,exitType,labelName)) {
    NodeUtil.removeChild(n.getParent(),n);
    compiler.reportCodeChange();
    return;
  }
  if (n.isIf()) {
    Node ifBlock=n.getFirstChild().getNext();
    tryMinimizeExits(ifBlock,exitType,labelName);
    Node elseBlock=ifBlock.getNext();
    if (elseBlock != null) {
      tryMinimizeExits(elseBlock,exitType,labelName);
    }
    return;
  }
  if (n.isTry()) {
    Node tryBlock=n.getFirstChild();
    tryMinimizeExits(tryBlock,exitType,labelName);
    Node allCatchNodes=NodeUtil.getCatchBlock(n);
    if (NodeUtil.hasCatchHandler(allCatchNodes)) {
      Preconditions.checkState(allCatchNodes.hasOneChild());
      Node catchNode=allCatchNodes.getFirstChild();
      Node catchCodeBlock=catchNode.getLastChild();
      tryMinimizeExits(catchCodeBlock,exitType,labelName);
    }
    if (NodeUtil.hasFinally(n)) {
      Node finallyBlock=n.getLastChild();
      tryMinimizeExits(finallyBlock,exitType,labelName);
    }
  }
  if (n.isLabel()) {
    Node labelBlock=n.getLastChild();
    tryMinimizeExits(labelBlock,exitType,labelName);
  }
  if (!n.isBlock() || n.getLastChild() == null) {
    return;
  }
  for (  Node c : n.children()) {
    if (c.isIf()) {
      Node ifTree=c;
      Node trueBlock, falseBlock;
      trueBlock=ifTree.getFirstChild().getNext();
      falseBlock=trueBlock.getNext();
      tryMinimizeIfBlockExits(trueBlock,falseBlock,ifTree,exitType,labelName);
      trueBlock=ifTree.getFirstChild().getNext();
      falseBlock=trueBlock.getNext();
      if (falseBlock != null) {
        tryMinimizeIfBlockExits(falseBlock,trueBlock,ifTree,exitType,labelName);
      }
    }
    if (c == n.getLastChild()) {
      break;
    }
  }
  for (Node c=n.getLastChild(); c != null; c=n.getLastChild()) {
    tryMinimizeExits(c,exitType,labelName);
    if (c == n.getLastChild()) {
      break;
    }
  }
}","/** 
 * Attempts to minimize the number of explicit exit points in a control structure to take advantage of the implied exit at the end of the structure.  This is accomplished by removing redundant statements, and moving statements following a qualifying IF node into that node. For example: function () { if (x) return; else blah(); foo(); } becomes: function () { if (x) ; else { blah(); foo(); }
 * @param n The execution node of a parent to inspect.
 * @param exitType The type of exit to look for.
 * @param labelName If parent is a label the name of the label to look for,null otherwise.
 * @nullable labelName non-null only for breaks within labels.
 */
void tryMinimizeExits(Node n,int exitType,String labelName){
  if (matchingExitNode(n,exitType,labelName)) {
    NodeUtil.removeChild(n.getParent(),n);
    compiler.reportCodeChange();
    return;
  }
  if (n.isIf()) {
    Node ifBlock=n.getFirstChild().getNext();
    tryMinimizeExits(ifBlock,exitType,labelName);
    Node elseBlock=ifBlock.getNext();
    if (elseBlock != null) {
      tryMinimizeExits(elseBlock,exitType,labelName);
    }
    return;
  }
  if (n.isTry()) {
    Node tryBlock=n.getFirstChild();
    tryMinimizeExits(tryBlock,exitType,labelName);
    Node allCatchNodes=NodeUtil.getCatchBlock(n);
    if (NodeUtil.hasCatchHandler(allCatchNodes)) {
      Preconditions.checkState(allCatchNodes.hasOneChild());
      Node catchNode=allCatchNodes.getFirstChild();
      Node catchCodeBlock=catchNode.getLastChild();
      tryMinimizeExits(catchCodeBlock,exitType,labelName);
    }
  }
  if (n.isLabel()) {
    Node labelBlock=n.getLastChild();
    tryMinimizeExits(labelBlock,exitType,labelName);
  }
  if (!n.isBlock() || n.getLastChild() == null) {
    return;
  }
  for (  Node c : n.children()) {
    if (c.isIf()) {
      Node ifTree=c;
      Node trueBlock, falseBlock;
      trueBlock=ifTree.getFirstChild().getNext();
      falseBlock=trueBlock.getNext();
      tryMinimizeIfBlockExits(trueBlock,falseBlock,ifTree,exitType,labelName);
      trueBlock=ifTree.getFirstChild().getNext();
      falseBlock=trueBlock.getNext();
      if (falseBlock != null) {
        tryMinimizeIfBlockExits(falseBlock,trueBlock,ifTree,exitType,labelName);
      }
    }
    if (c == n.getLastChild()) {
      break;
    }
  }
  for (Node c=n.getLastChild(); c != null; c=n.getLastChild()) {
    tryMinimizeExits(c,exitType,labelName);
    if (c == n.getLastChild()) {
      break;
    }
  }
}",0.9724806968917046
27932,"public void testFunctionReturnOptimization() throws Exception {
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  foldSame(""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  foldSame(""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
}","public void testFunctionReturnOptimization() throws Exception {
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  foldSame(""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  foldSame(""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  foldSame(""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
}",0.9881773399014778
27933,"/** 
 * Report code changes.
 */
public abstract void reportCodeChange();","/** 
 * Report code changes. Passes should call reportCodeChange when they alter the JS tree. This is verified by CompilerTestCase. This allows us to optimize to a fixed point.
 */
public abstract void reportCodeChange();",0.4965986394557823
27934,"/** 
 * All passes should call reportCodeChange() when they alter the JS tree structure. This is verified by CompilerTestCase. This allows us to optimize to a fixed point.
 */
@Override public void reportCodeChange(){
  for (  CodeChangeHandler handler : codeChangeHandlers) {
    handler.reportChange();
  }
}","@Override public void reportCodeChange(){
  for (  CodeChangeHandler handler : codeChangeHandlers) {
    handler.reportChange();
  }
}",0.6036036036036037
27935,"@Override boolean hasScopeChanged(Node n){
  if (phaseOptimizer != null) {
    return phaseOptimizer.hasScopeChanged(n);
  }
  return true;
}","@Override boolean hasScopeChanged(Node n){
  if (!analyzeChangedScopesOnly || phaseOptimizer == null) {
    return true;
  }
  return phaseOptimizer.hasScopeChanged(n);
}",0.7781350482315113
27936,"/** 
 * Remove the given VAR declaration.
 */
private void removeDeclaration(Reference decl){
  Node varNode=decl.getParent();
  Node grandparent=decl.getGrandparent();
  compiler.reportChangeToScope(compiler.getEnclosingScope(decl.getNode()));
  varNode.removeChild(decl.getNode());
  if (!varNode.hasChildren()) {
    Preconditions.checkState(varNode.isVar());
    NodeUtil.removeChild(grandparent,varNode);
  }
}","/** 
 * Remove the given VAR declaration.
 */
private void removeDeclaration(Reference decl){
  Node varNode=decl.getParent();
  Node grandparent=decl.getGrandparent();
  compiler.reportChangeToEnclosingScope(decl.getNode());
  varNode.removeChild(decl.getNode());
  if (!varNode.hasChildren()) {
    Preconditions.checkState(varNode.isVar());
    NodeUtil.removeChild(grandparent,varNode);
  }
}",0.9223181257706536
27937,"/** 
 * Replace the given reference with the given value node.
 * @param v The variable that's referenced.
 * @param ref The reference to replace.
 * @param value The node tree to replace it with. This tree should be safeto re-parent.
 */
private void inlineValue(Var v,Reference ref,Node value){
  compiler.reportChangeToScope(compiler.getEnclosingScope(ref.getNode()));
  if (ref.isSimpleAssignmentToName()) {
    ref.getGrandparent().replaceChild(ref.getParent(),value);
  }
 else {
    ref.getParent().replaceChild(ref.getNode(),value);
  }
  blacklistVarReferencesInTree(value,v.scope);
}","/** 
 * Replace the given reference with the given value node.
 * @param v The variable that's referenced.
 * @param ref The reference to replace.
 * @param value The node tree to replace it with. This tree should be safeto re-parent.
 */
private void inlineValue(Var v,Reference ref,Node value){
  compiler.reportChangeToEnclosingScope(ref.getNode());
  if (ref.isSimpleAssignmentToName()) {
    ref.getGrandparent().replaceChild(ref.getParent(),value);
  }
 else {
    ref.getParent().replaceChild(ref.getNode(),value);
  }
  blacklistVarReferencesInTree(value,v.scope);
}",0.6152527849185947
27938,"/** 
 * Do the actual work of inlining a single declaration into a single reference.
 */
private void inline(Var v,Reference decl,Reference init,Reference ref){
  Node value=init.getAssignedValue();
  Preconditions.checkState(value != null);
  boolean isFunctionDeclaration=NodeUtil.isFunctionDeclaration(value);
  compiler.reportChangeToScope(compiler.getEnclosingScope(decl.getNode()));
  compiler.reportChangeToScope(compiler.getEnclosingScope(ref.getNode()));
  inlineValue(v,ref,value.detachFromParent());
  if (decl != init) {
    Node expressRoot=init.getGrandparent();
    Preconditions.checkState(expressRoot.isExprResult());
    NodeUtil.removeChild(expressRoot.getParent(),expressRoot);
  }
  if (!isFunctionDeclaration) {
    removeDeclaration(decl);
  }
}","/** 
 * Do the actual work of inlining a single declaration into a single reference.
 */
private void inline(Var v,Reference decl,Reference init,Reference ref){
  Node value=init.getAssignedValue();
  Preconditions.checkState(value != null);
  boolean isFunctionDeclaration=NodeUtil.isFunctionDeclaration(value);
  compiler.reportChangeToEnclosingScope(decl.getNode());
  compiler.reportChangeToEnclosingScope(ref.getNode());
  inlineValue(v,ref,value.detachFromParent());
  if (decl != init) {
    Node expressRoot=init.getGrandparent();
    Preconditions.checkState(expressRoot.isExprResult());
    NodeUtil.removeChild(expressRoot.getParent(),expressRoot);
  }
  if (!isFunctionDeclaration) {
    removeDeclaration(decl);
  }
}",0.9506008010680908
27939,"/** 
 * Add the pass generated by the given factory to the compile sequence. This pass will be run once.
 */
void addOneTimePass(PassFactory factory){
  passes.add(new NamedPass(factory));
}","/** 
 * Add the pass generated by the given factory to the compile sequence. This pass will be run once.
 */
@VisibleForTesting void addOneTimePass(PassFactory factory){
  passes.add(new NamedPass(factory));
}",0.9523809523809524
27940,"/** 
 * Runs the sanity check if it is available.
 */
private void maybeSanityCheck(Node externs,Node root){
  if (sanityCheck != null) {
    sanityCheck.create(compiler).process(externs,root);
    NodeUtil.verifyScopeChanges(mtoc,jsRoot,true);
    setSanityCheckState();
  }
}","/** 
 * Runs the sanity check if it is available.
 */
private void maybeSanityCheck(Node externs,Node root){
  if (sanityCheck != null) {
    sanityCheck.create(compiler).process(externs,root);
    if (inLoop) {
      NodeUtil.verifyScopeChanges(mtoc,jsRoot,true);
      setSanityCheckState();
    }
  }
}",0.9518900343642612
27941,"/** 
 * {@code n} is either a function or the top-level node of the AST 
 */
void setScope(Node n){
  if (inLoop) {
    currentScope=n.isFunction() ? n : compiler.getEnclosingScope(n);
  }
}","/** 
 * {@code n} is either a function or the top-level node of the AST 
 */
void setScope(Node n){
  if (inLoop) {
    currentScope=n.isFunction() ? n : getEnclosingScope(n);
  }
}",0.9757412398921832
27942,"public MultiPassTest(){
}","public MultiPassTest(){
  enableNormalize();
}",0.704225352112676
27943,"/** 
 * Extracts the text found on the current line starting at token. Note that token = token.info; should be called after this method is used to update the token properly in the parser.
 * @return The extraction information.
 */
private ExtractionInfo extractSingleLineBlock(){
  stream.update();
  int lineno=stream.getLineno();
  int charno=stream.getCharno() + 1;
  String line=stream.getRemainingJSDocLine().trim();
  if (line.length() > 0) {
    jsdocBuilder.markText(line,lineno,charno,lineno,charno + line.length());
  }
  return new ExtractionInfo(line,next());
}","/** 
 * Extracts the text found on the current line starting at token. Note that token = token.info; should be called after this method is used to update the token properly in the parser.
 * @return The extraction information.
 */
private ExtractionInfo extractSingleLineBlock(){
  stream.update();
  int lineno=stream.getLineno();
  int charno=stream.getCharno() + 1;
  String line=getRemainingJSDocLine().trim();
  if (line.length() > 0) {
    jsdocBuilder.markText(line,lineno,charno,lineno,charno + line.length());
  }
  return new ExtractionInfo(line,next());
}",0.9938542581211588
27944,"/** 
 * Extracts the text found on the current line and all subsequent until either an annotation, end of comment or end of file is reached. Note that if this method detects an end of line as the first token, it will quit immediately (indicating that there is no text where it was expected).  Note that token = info.token; should be called after this method is used to update the token properly in the parser.
 * @param token The start token.
 * @param option How to handle whitespace.
 * @return The extraction information.
 */
@SuppressWarnings(""String_Node_Str"") private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,WhitespaceOption option){
  if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {
    return new ExtractionInfo(""String_Node_Str"",token);
  }
  stream.update();
  int startLineno=stream.getLineno();
  int startCharno=stream.getCharno() + 1;
  String line=stream.getRemainingJSDocLine();
  if (option != WhitespaceOption.PRESERVE) {
    line=line.trim();
  }
  StringBuilder builder=new StringBuilder();
  builder.append(line);
  state=State.SEARCHING_ANNOTATION;
  token=next();
  boolean ignoreStar=false;
  int lineStartChar=-1;
  do {
switch (token) {
case STAR:
      if (ignoreStar) {
        lineStartChar=stream.getCharno() + 1;
      }
 else {
        if (builder.length() > 0) {
          builder.append(' ');
        }
        builder.append('*');
      }
    token=next();
  continue;
case EOL:
if (option != WhitespaceOption.SINGLE_LINE) {
  builder.append(""String_Node_Str"");
}
ignoreStar=true;
lineStartChar=0;
token=next();
continue;
default :
ignoreStar=false;
state=State.SEARCHING_ANNOTATION;
boolean isEOC=token == JsDocToken.EOC;
if (!isEOC) {
if (lineStartChar != -1 && option == WhitespaceOption.PRESERVE) {
int numSpaces=stream.getCharno() - lineStartChar;
for (int i=0; i < numSpaces; i++) {
builder.append(' ');
}
lineStartChar=-1;
}
 else if (builder.length() > 0) {
builder.append(' ');
}
}
if (token == JsDocToken.EOC || token == JsDocToken.EOF || (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) {
String multilineText=builder.toString();
if (option != WhitespaceOption.PRESERVE) {
multilineText=multilineText.trim();
}
int endLineno=stream.getLineno();
int endCharno=stream.getCharno();
if (multilineText.length() > 0) {
jsdocBuilder.markText(multilineText,startLineno,startCharno,endLineno,endCharno);
}
return new ExtractionInfo(multilineText,token);
}
builder.append(toString(token));
line=stream.getRemainingJSDocLine();
if (option != WhitespaceOption.PRESERVE) {
line=trimEnd(line);
}
builder.append(line);
token=next();
}
}
 while (true);
}","/** 
 * Extracts the text found on the current line and all subsequent until either an annotation, end of comment or end of file is reached. Note that if this method detects an end of line as the first token, it will quit immediately (indicating that there is no text where it was expected).  Note that token = info.token; should be called after this method is used to update the token properly in the parser.
 * @param token The start token.
 * @param option How to handle whitespace.
 * @return The extraction information.
 */
@SuppressWarnings(""String_Node_Str"") private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,WhitespaceOption option){
  if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {
    return new ExtractionInfo(""String_Node_Str"",token);
  }
  stream.update();
  int startLineno=stream.getLineno();
  int startCharno=stream.getCharno() + 1;
  String line=getRemainingJSDocLine();
  if (option != WhitespaceOption.PRESERVE) {
    line=line.trim();
  }
  StringBuilder builder=new StringBuilder();
  builder.append(line);
  state=State.SEARCHING_ANNOTATION;
  token=next();
  boolean ignoreStar=false;
  int lineStartChar=-1;
  do {
switch (token) {
case STAR:
      if (ignoreStar) {
        lineStartChar=stream.getCharno() + 1;
      }
 else {
        if (builder.length() > 0) {
          builder.append(' ');
        }
        builder.append('*');
      }
    token=next();
  continue;
case EOL:
if (option != WhitespaceOption.SINGLE_LINE) {
  builder.append(""String_Node_Str"");
}
ignoreStar=true;
lineStartChar=0;
token=next();
continue;
default :
ignoreStar=false;
state=State.SEARCHING_ANNOTATION;
boolean isEOC=token == JsDocToken.EOC;
if (!isEOC) {
if (lineStartChar != -1 && option == WhitespaceOption.PRESERVE) {
int numSpaces=stream.getCharno() - lineStartChar;
for (int i=0; i < numSpaces; i++) {
builder.append(' ');
}
lineStartChar=-1;
}
 else if (builder.length() > 0) {
builder.append(' ');
}
}
if (token == JsDocToken.EOC || token == JsDocToken.EOF || (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) {
String multilineText=builder.toString();
if (option != WhitespaceOption.PRESERVE) {
multilineText=multilineText.trim();
}
int endLineno=stream.getLineno();
int endCharno=stream.getCharno();
if (multilineText.length() > 0) {
jsdocBuilder.markText(multilineText,startLineno,startCharno,endLineno,endCharno);
}
return new ExtractionInfo(multilineText,token);
}
builder.append(toString(token));
line=getRemainingJSDocLine();
if (option != WhitespaceOption.PRESERVE) {
line=trimEnd(line);
}
builder.append(line);
token=next();
}
}
 while (true);
}",0.9973674313651748
27945,"/** 
 * Extracts the top-level block comment from the JsDoc comment, if any. This method differs from the extractMultilineTextualBlock in that it terminates under different conditions (it doesn't have the same prechecks), it does not first read in the remaining of the current line and its conditions for ignoring the ""*"" (STAR) are different.
 * @param token The starting token.
 * @return The extraction information.
 */
private ExtractionInfo extractBlockComment(JsDocToken token){
  StringBuilder builder=new StringBuilder();
  boolean ignoreStar=true;
  do {
switch (token) {
case ANNOTATION:
case EOC:
case EOF:
      return new ExtractionInfo(builder.toString().trim(),token);
case STAR:
    if (!ignoreStar) {
      if (builder.length() > 0) {
        builder.append(' ');
      }
      builder.append('*');
    }
  token=next();
continue;
case EOL:
ignoreStar=true;
builder.append('\n');
token=next();
continue;
default :
if (!ignoreStar && builder.length() > 0) {
builder.append(' ');
}
ignoreStar=false;
builder.append(toString(token));
String line=stream.getRemainingJSDocLine();
line=trimEnd(line);
builder.append(line);
token=next();
}
}
 while (true);
}","/** 
 * Extracts the top-level block comment from the JsDoc comment, if any. This method differs from the extractMultilineTextualBlock in that it terminates under different conditions (it doesn't have the same prechecks), it does not first read in the remaining of the current line and its conditions for ignoring the ""*"" (STAR) are different.
 * @param token The starting token.
 * @return The extraction information.
 */
private ExtractionInfo extractBlockComment(JsDocToken token){
  StringBuilder builder=new StringBuilder();
  boolean ignoreStar=true;
  do {
switch (token) {
case ANNOTATION:
case EOC:
case EOF:
      return new ExtractionInfo(builder.toString().trim(),token);
case STAR:
    if (!ignoreStar) {
      if (builder.length() > 0) {
        builder.append(' ');
      }
      builder.append('*');
    }
  token=next();
continue;
case EOL:
ignoreStar=true;
builder.append('\n');
token=next();
continue;
default :
if (!ignoreStar && builder.length() > 0) {
builder.append(' ');
}
ignoreStar=false;
builder.append(toString(token));
String line=getRemainingJSDocLine();
line=trimEnd(line);
builder.append(line);
token=next();
}
}
 while (true);
}",0.9969944182052384
27946,"/** 
 * Two union types are equal if they have the same number of alternates and all alternates are equal.
 */
boolean checkUnionEquivalenceHelper(UnionType that,EquivalenceMethod eqMethod){
  if (eqMethod == EquivalenceMethod.IDENTITY && alternates.size() != that.alternates.size()) {
    return false;
  }
  for (  JSType alternate : that.alternates) {
    if (!hasAlternate(alternate,eqMethod)) {
      return false;
    }
  }
  return true;
}","/** 
 * Two union types are equal if, after flattening nested union types, they have the same number of alternates and all alternates are equal.
 */
boolean checkUnionEquivalenceHelper(UnionType that,EquivalenceMethod eqMethod){
  Collection<JSType> thatAlternates=that.getAlternates();
  if (eqMethod == EquivalenceMethod.IDENTITY && getAlternates().size() != thatAlternates.size()) {
    return false;
  }
  for (  JSType alternate : thatAlternates) {
    if (!hasAlternate(alternate,eqMethod)) {
      return false;
    }
  }
  return true;
}",0.8718466195761857
27947,"private boolean hasAlternate(JSType type,EquivalenceMethod eqMethod){
  for (  JSType alternate : alternates) {
    if (alternate.checkEquivalenceHelper(type,eqMethod)) {
      return true;
    }
  }
  return false;
}","private boolean hasAlternate(JSType type,EquivalenceMethod eqMethod){
  for (  JSType alternate : getAlternates()) {
    if (alternate.checkEquivalenceHelper(type,eqMethod)) {
      return true;
    }
  }
  return false;
}",0.9840546697038725
27948,"/** 
 * Gets the alternate types of this union type.
 * @return The alternate types of this union type. The returned set isimmutable.
 */
public Iterable<JSType> getAlternates(){
  return alternates;
}","/** 
 * Gets the alternate types of this union type.
 * @return The alternate types of this union type. The returned set isimmutable.
 */
public Collection<JSType> getAlternates(){
  for (  JSType t : alternates) {
    if (t.isUnionType()) {
      rebuildAlternates();
      break;
    }
  }
  return alternates;
}",0.683495145631068
27949,"Iterable<JSType> getAlternates(){
  JSType specialCaseType=reduceAlternatesWithoutUnion();
  if (specialCaseType != null) {
    return ImmutableList.of(specialCaseType);
  }
  return Collections.unmodifiableList(alternates);
}","Collection<JSType> getAlternates(){
  JSType specialCaseType=reduceAlternatesWithoutUnion();
  if (specialCaseType != null) {
    return ImmutableList.of(specialCaseType);
  }
  return Collections.unmodifiableList(alternates);
}",0.960352422907489
27950,"/** 
 * Verifies that the compiler pass's JS output matches the expected output and (optionally) that an expected warning is issued. Or, if an error is expected, this method just verifies that the error is encountered.
 * @param compiler A compiler that has been initialized via{@link Compiler#init}
 * @param expected Expected output, or null if an error is expected
 * @param error Expected error, or null if no error is expected
 * @param warning Expected warning, or null if no warning is expected
 * @param description The description of the expected warning,or null if no warning is expected or if the warning's description should not be examined
 */
private void test(Compiler compiler,String[] expected,DiagnosticType error,DiagnosticType warning,String description){
  RecentChange recentChange=new RecentChange();
  compiler.addChangeHandler(recentChange);
  Node root=compiler.parseInputs();
  assertTrue(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(compiler.getErrors()),root != null);
  if (astValidationEnabled) {
    (new AstValidator()).validateRoot(root);
  }
  Node externsRoot=root.getFirstChild();
  Node mainRoot=root.getLastChild();
  Node rootClone=root.cloneTree();
  Node externsRootClone=rootClone.getFirstChild();
  Node mainRootClone=rootClone.getLastChild();
  int numRepetitions=getNumRepetitions();
  ErrorManager[] errorManagers=new ErrorManager[numRepetitions];
  int aggregateWarningCount=0;
  List<JSError> aggregateWarnings=Lists.newArrayList();
  boolean hasCodeChanged=false;
  assertFalse(""String_Node_Str"",recentChange.hasCodeChanged());
  for (int i=0; i < numRepetitions; ++i) {
    if (compiler.getErrorCount() == 0) {
      errorManagers[i]=new BlackHoleErrorManager(compiler);
      if (closurePassEnabled && i == 0) {
        recentChange.reset();
        new ProcessClosurePrimitives(compiler,null,CheckLevel.ERROR).process(null,mainRoot);
        hasCodeChanged=hasCodeChanged || recentChange.hasCodeChanged();
      }
      if (typeCheckEnabled && i == 0) {
        TypeCheck check=createTypeCheck(compiler,typeCheckLevel);
        check.processForTesting(externsRoot,mainRoot);
      }
      if (normalizeEnabled && i == 0) {
        normalizeActualCode(compiler,externsRoot,mainRoot);
      }
      if (markNoSideEffects && i == 0) {
        MarkNoSideEffectCalls mark=new MarkNoSideEffectCalls(compiler);
        mark.process(externsRoot,mainRoot);
      }
      recentChange.reset();
      getProcessor(compiler).process(externsRoot,mainRoot);
      if (astValidationEnabled) {
        (new AstValidator()).validateRoot(root);
      }
      if (checkLineNumbers) {
        (new LineNumberCheck(compiler)).process(externsRoot,mainRoot);
      }
      hasCodeChanged=hasCodeChanged || recentChange.hasCodeChanged();
      aggregateWarningCount+=errorManagers[i].getWarningCount();
      aggregateWarnings.addAll(Lists.newArrayList(compiler.getWarnings()));
      if (normalizeEnabled) {
        boolean verifyDeclaredConstants=true;
        new Normalize.VerifyConstants(compiler,verifyDeclaredConstants).process(externsRoot,mainRoot);
      }
    }
  }
  if (error == null) {
    assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(compiler.getErrors()),0,compiler.getErrorCount());
    ErrorManager symbolTableErrorManager=new BlackHoleErrorManager(compiler);
    Node expectedRoot=null;
    if (expected != null) {
      expectedRoot=parseExpectedJs(expected);
      expectedRoot.detachFromParent();
    }
    JSError[] stErrors=symbolTableErrorManager.getErrors();
    if (expectedSymbolTableError != null) {
      assertEquals(""String_Node_Str"",1,stErrors.length);
      assertEquals(expectedSymbolTableError,stErrors[0].getType());
    }
 else {
      assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(stErrors),0,stErrors.length);
    }
    if (warning == null) {
      assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(aggregateWarnings),0,aggregateWarningCount);
    }
 else {
      assertEquals(""String_Node_Str"" + numRepetitions + ""String_Node_Str"",numRepetitions,aggregateWarningCount);
      for (int i=0; i < numRepetitions; ++i) {
        JSError[] warnings=errorManagers[i].getWarnings();
        JSError actual=warnings[0];
        assertEquals(warning,actual.getType());
        if (!allowSourcelessWarnings) {
          assertTrue(""String_Node_Str"",actual.sourceName != null && !actual.sourceName.isEmpty());
          assertTrue(""String_Node_Str"",-1 != actual.lineNumber);
          assertTrue(""String_Node_Str"",-1 != actual.getCharno());
        }
        if (description != null) {
          assertEquals(description,actual.description);
        }
      }
    }
    if (normalizeEnabled) {
      normalizeActualCode(compiler,externsRootClone,mainRootClone);
    }
    boolean codeChange=!mainRootClone.isEquivalentTo(mainRoot);
    boolean externsChange=!externsRootClone.isEquivalentTo(externsRoot);
    if (externsChange && !allowExternsChanges) {
      String explanation=externsRootClone.checkTreeEquals(externsRoot);
      fail(""String_Node_Str"" + ""String_Node_Str"" + compiler.toSource(externsRootClone) + ""String_Node_Str""+ compiler.toSource(externsRoot)+ ""String_Node_Str""+ explanation);
    }
    if (!codeChange && !externsChange) {
      assertFalse(""String_Node_Str"" + ""String_Node_Str"",hasCodeChanged);
    }
 else {
      assertTrue(""String_Node_Str"",hasCodeChanged);
    }
    if (expected != null) {
      if (compareAsTree) {
        String explanation=expectedRoot.checkTreeEquals(mainRoot);
        assertNull(""String_Node_Str"" + compiler.toSource(expectedRoot) + ""String_Node_Str""+ compiler.toSource(mainRoot)+ ""String_Node_Str""+ explanation,explanation);
      }
 else       if (expected != null) {
        assertEquals(Joiner.on(""String_Node_Str"").join(expected),compiler.toSource(mainRoot));
      }
    }
    Node normalizeCheckRootClone=root.cloneTree();
    Node normalizeCheckExternsRootClone=root.getFirstChild();
    Node normalizeCheckMainRootClone=root.getLastChild();
    new PrepareAst(compiler).process(normalizeCheckExternsRootClone,normalizeCheckMainRootClone);
    String explanation=normalizeCheckMainRootClone.checkTreeEquals(mainRoot);
    assertNull(""String_Node_Str"" + compiler.toSource(normalizeCheckMainRootClone) + ""String_Node_Str""+ compiler.toSource(mainRoot)+ ""String_Node_Str""+ explanation,explanation);
    if (normalizeEnabled) {
      new Normalize(compiler,true).process(normalizeCheckExternsRootClone,normalizeCheckMainRootClone);
      explanation=normalizeCheckMainRootClone.checkTreeEquals(mainRoot);
      assertNull(""String_Node_Str"" + compiler.toSource(normalizeCheckMainRootClone) + ""String_Node_Str""+ compiler.toSource(mainRoot)+ ""String_Node_Str""+ explanation,explanation);
    }
  }
 else {
    String errors=""String_Node_Str"";
    for (    JSError actualError : compiler.getErrors()) {
      errors+=actualError.description + ""String_Node_Str"";
    }
    assertEquals(""String_Node_Str"" + errors,1,compiler.getErrorCount());
    assertEquals(errors,error,compiler.getErrors()[0].getType());
    if (warning != null) {
      String warnings=""String_Node_Str"";
      for (      JSError actualError : compiler.getWarnings()) {
        warnings+=actualError.description + ""String_Node_Str"";
      }
      assertEquals(""String_Node_Str"" + warnings,1,compiler.getWarningCount());
      assertEquals(warnings,warning,compiler.getWarnings()[0].getType());
    }
  }
}","/** 
 * Verifies that the compiler pass's JS output matches the expected output and (optionally) that an expected warning is issued. Or, if an error is expected, this method just verifies that the error is encountered.
 * @param compiler A compiler that has been initialized via{@link Compiler#init}
 * @param expected Expected output, or null if an error is expected
 * @param error Expected error, or null if no error is expected
 * @param warning Expected warning, or null if no warning is expected
 * @param description The description of the expected warning,or null if no warning is expected or if the warning's description should not be examined
 */
private void test(Compiler compiler,String[] expected,DiagnosticType error,DiagnosticType warning,String description){
  RecentChange recentChange=new RecentChange();
  compiler.addChangeHandler(recentChange);
  Node root=compiler.parseInputs();
  assertTrue(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(compiler.getErrors()),root != null);
  if (astValidationEnabled) {
    (new AstValidator()).validateRoot(root);
  }
  Node externsRoot=root.getFirstChild();
  Node mainRoot=root.getLastChild();
  Node rootClone=root.cloneTree();
  Node externsRootClone=rootClone.getFirstChild();
  Node mainRootClone=rootClone.getLastChild();
  int numRepetitions=getNumRepetitions();
  ErrorManager[] errorManagers=new ErrorManager[numRepetitions];
  int aggregateWarningCount=0;
  List<JSError> aggregateWarnings=Lists.newArrayList();
  boolean hasCodeChanged=false;
  assertFalse(""String_Node_Str"",recentChange.hasCodeChanged());
  for (int i=0; i < numRepetitions; ++i) {
    if (compiler.getErrorCount() == 0) {
      errorManagers[i]=new BlackHoleErrorManager(compiler);
      if (closurePassEnabled && i == 0) {
        recentChange.reset();
        new ProcessClosurePrimitives(compiler,null,CheckLevel.ERROR).process(null,mainRoot);
        hasCodeChanged=hasCodeChanged || recentChange.hasCodeChanged();
      }
      if (typeCheckEnabled && i == 0) {
        TypeCheck check=createTypeCheck(compiler,typeCheckLevel);
        check.processForTesting(externsRoot,mainRoot);
      }
      if (normalizeEnabled && i == 0) {
        normalizeActualCode(compiler,externsRoot,mainRoot);
      }
      if (markNoSideEffects && i == 0) {
        MarkNoSideEffectCalls mark=new MarkNoSideEffectCalls(compiler);
        mark.process(externsRoot,mainRoot);
      }
      recentChange.reset();
      getProcessor(compiler).process(externsRoot,mainRoot);
      if (astValidationEnabled) {
        (new AstValidator()).validateRoot(root);
      }
      if (checkLineNumbers) {
        (new LineNumberCheck(compiler)).process(externsRoot,mainRoot);
      }
      hasCodeChanged=hasCodeChanged || recentChange.hasCodeChanged();
      aggregateWarningCount+=errorManagers[i].getWarningCount();
      aggregateWarnings.addAll(Lists.newArrayList(compiler.getWarnings()));
      if (normalizeEnabled) {
        boolean verifyDeclaredConstants=true;
        new Normalize.VerifyConstants(compiler,verifyDeclaredConstants).process(externsRoot,mainRoot);
      }
    }
  }
  if (error == null) {
    assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(compiler.getErrors()),0,compiler.getErrorCount());
    ErrorManager symbolTableErrorManager=new BlackHoleErrorManager(compiler);
    Node expectedRoot=null;
    if (expected != null) {
      expectedRoot=parseExpectedJs(expected);
      expectedRoot.detachFromParent();
    }
    JSError[] stErrors=symbolTableErrorManager.getErrors();
    if (expectedSymbolTableError != null) {
      assertEquals(""String_Node_Str"",1,stErrors.length);
      assertEquals(expectedSymbolTableError,stErrors[0].getType());
    }
 else {
      assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(stErrors),0,stErrors.length);
    }
    if (warning == null) {
      assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(aggregateWarnings),0,aggregateWarningCount);
    }
 else {
      assertEquals(""String_Node_Str"" + numRepetitions + ""String_Node_Str"",numRepetitions,aggregateWarningCount);
      for (int i=0; i < numRepetitions; ++i) {
        JSError[] warnings=errorManagers[i].getWarnings();
        JSError actual=warnings[0];
        assertEquals(warning,actual.getType());
        if (!allowSourcelessWarnings) {
          assertTrue(""String_Node_Str"",actual.sourceName != null && !actual.sourceName.isEmpty());
          assertTrue(""String_Node_Str"",-1 != actual.lineNumber);
          assertTrue(""String_Node_Str"",-1 != actual.getCharno());
        }
        if (description != null) {
          assertEquals(description,actual.description);
        }
      }
    }
    if (normalizeEnabled) {
      normalizeActualCode(compiler,externsRootClone,mainRootClone);
    }
    boolean codeChange=!mainRootClone.isEquivalentTo(mainRoot);
    boolean externsChange=!externsRootClone.isEquivalentTo(externsRoot);
    if (externsChange && !allowExternsChanges) {
      String explanation=externsRootClone.checkTreeEquals(externsRoot);
      fail(""String_Node_Str"" + ""String_Node_Str"" + compiler.toSource(externsRootClone) + ""String_Node_Str""+ compiler.toSource(externsRoot)+ ""String_Node_Str""+ explanation);
    }
    if (!codeChange && !externsChange) {
      assertFalse(""String_Node_Str"" + ""String_Node_Str"",hasCodeChanged);
    }
 else {
      assertTrue(""String_Node_Str"",hasCodeChanged);
    }
    if (expected != null) {
      if (compareAsTree) {
        String explanation=expectedRoot.checkTreeEquals(mainRoot);
        assertNull(""String_Node_Str"" + compiler.toSource(expectedRoot) + ""String_Node_Str""+ compiler.toSource(mainRoot)+ ""String_Node_Str""+ explanation,explanation);
      }
 else       if (expected != null) {
        assertEquals(Joiner.on(""String_Node_Str"").join(expected),compiler.toSource(mainRoot));
      }
    }
    Node normalizeCheckRootClone=root.cloneTree();
    Node normalizeCheckExternsRootClone=normalizeCheckRootClone.getFirstChild();
    Node normalizeCheckMainRootClone=normalizeCheckRootClone.getLastChild();
    new PrepareAst(compiler).process(normalizeCheckExternsRootClone,normalizeCheckMainRootClone);
    String explanation=normalizeCheckMainRootClone.checkTreeEquals(mainRoot);
    assertNull(""String_Node_Str"" + compiler.toSource(normalizeCheckMainRootClone) + ""String_Node_Str""+ compiler.toSource(mainRoot)+ ""String_Node_Str""+ explanation,explanation);
    if (normalizeEnabled) {
      new Normalize(compiler,true).process(normalizeCheckExternsRootClone,normalizeCheckMainRootClone);
      explanation=normalizeCheckMainRootClone.checkTreeEquals(mainRoot);
      assertNull(""String_Node_Str"" + compiler.toSource(normalizeCheckMainRootClone) + ""String_Node_Str""+ compiler.toSource(mainRoot)+ ""String_Node_Str""+ explanation,explanation);
    }
  }
 else {
    String errors=""String_Node_Str"";
    for (    JSError actualError : compiler.getErrors()) {
      errors+=actualError.description + ""String_Node_Str"";
    }
    assertEquals(""String_Node_Str"" + errors,1,compiler.getErrorCount());
    assertEquals(errors,error,compiler.getErrors()[0].getType());
    if (warning != null) {
      String warnings=""String_Node_Str"";
      for (      JSError actualError : compiler.getWarnings()) {
        warnings+=actualError.description + ""String_Node_Str"";
      }
      assertEquals(""String_Node_Str"" + warnings,1,compiler.getWarningCount());
      assertEquals(warnings,warning,compiler.getWarnings()[0].getType());
    }
  }
}",0.9963865096359744
27951,"@Override protected void setUp() throws Exception {
  super.setUp();
  previouslyUsedMap=new VariableMap(ImmutableMap.<String,String>of());
  prefix=DEFAULT_PREFIX;
  withClosurePass=false;
  localRenamingOnly=false;
  preserveFunctionExpressionNames=false;
  generatePseudoNames=false;
  shouldShadow=false;
}","@Override protected void setUp() throws Exception {
  super.setUp();
  previouslyUsedMap=new VariableMap(ImmutableMap.<String,String>of());
  prefix=DEFAULT_PREFIX;
  withClosurePass=false;
  withNormalize=false;
  localRenamingOnly=false;
  preserveFunctionExpressionNames=false;
  generatePseudoNames=false;
  shouldShadow=false;
}",0.9642301710730948
27952,"public void testDollarSignSuperExport2(){
  boolean normalizedExpectedJs=false;
  super.enableNormalize(false);
  useGoogleCodingConvention=false;
  test(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
  localRenamingOnly=false;
  test(""String_Node_Str"",""String_Node_Str"");
  useGoogleCodingConvention=true;
  test(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
  super.disableNormalize();
}","public void testDollarSignSuperExport2(){
  withNormalize=true;
  useGoogleCodingConvention=false;
  test(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
  localRenamingOnly=false;
  test(""String_Node_Str"",""String_Node_Str"");
  useGoogleCodingConvention=true;
  test(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
}",0.8864734299516909
27953,"@Override public void process(Node externs,Node root){
  ProcessClosurePrimitives closurePass=new ProcessClosurePrimitives(compiler,null,CheckLevel.WARNING);
  closurePass.process(externs,root);
  renameVars=new RenameVars(compiler,prefix,false,false,false,false,previouslyUsedMap,null,closurePass.getExportedVariableNames());
  renameVars.process(externs,root);
}","@Override public void process(Node externs,Node root){
  Normalize normalize=new Normalize(compiler,false);
  normalize.process(externs,root);
  wrappedPass.process(externs,root);
}",0.4293577981651376
27954,"@Override protected CompilerPass getProcessor(Compiler compiler){
  if (withClosurePass) {
    return new ClosurePassAndRenameVars(compiler);
  }
 else {
    return renameVars=new RenameVars(compiler,prefix,localRenamingOnly,preserveFunctionExpressionNames,generatePseudoNames,shouldShadow,previouslyUsedMap,null,null);
  }
}","@Override protected CompilerPass getProcessor(Compiler compiler){
  CompilerPass pass;
  if (withClosurePass) {
    pass=new ClosurePassAndRenameVars(compiler);
  }
 else {
    pass=renameVars=new RenameVars(compiler,prefix,localRenamingOnly,preserveFunctionExpressionNames,generatePseudoNames,shouldShadow,previouslyUsedMap,null,null);
  }
  if (withNormalize) {
    pass=new NormalizePassWrapper(compiler,pass);
  }
  return pass;
}",0.8194993412384717
27955,"/** 
 * Check whether there's any property conflict for for a particular super interface
 * @param t The node traversal object that supplies context
 * @param n The node being visited
 * @param functionName The function name being checked
 * @param properties The property names in the super interfaces that havebeen visited
 * @param currentProperties The property names in the super interfacethat have been visited
 * @param interfaceType The super interface that is being visited
 */
private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
  Set<String> currentPropertyNames=interfaceType.getImplicitPrototype().getOwnPropertyNames();
  for (  String name : currentPropertyNames) {
    ObjectType oType=properties.get(name);
    if (oType != null) {
      if (!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))) {
        compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
      }
    }
    currentProperties.put(name,interfaceType);
  }
  for (  ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {
    checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
  }
}","/** 
 * Check whether there's any property conflict for for a particular super interface
 * @param t The node traversal object that supplies context
 * @param n The node being visited
 * @param functionName The function name being checked
 * @param properties The property names in the super interfaces that havebeen visited
 * @param currentProperties The property names in the super interfacethat have been visited
 * @param interfaceType The super interface that is being visited
 */
private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
  ObjectType implicitProto=interfaceType.getImplicitPrototype();
  Set<String> currentPropertyNames;
  if (implicitProto == null) {
    currentPropertyNames=ImmutableSet.of();
  }
 else {
    currentPropertyNames=implicitProto.getOwnPropertyNames();
  }
  for (  String name : currentPropertyNames) {
    ObjectType oType=properties.get(name);
    if (oType != null) {
      if (!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))) {
        compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
      }
    }
    currentProperties.put(name,interfaceType);
  }
  for (  ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {
    checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
  }
}",0.9198195071155848
27956,"boolean isParameterizeSubtypeOf(JSType thatType){
  if (thatType.isParameterizedType()) {
    JSType thisParameter=this.parameterType;
    JSType thatParameter=thatType.toMaybeParameterizedType().parameterType;
    return this.wrapsSameRawType(thatType) && (thisParameter.isSubtype(thatParameter) || thatParameter.isSubtype(thisParameter));
  }
 else {
    return this.getReferencedTypeInternal().isSubtype(thatType);
  }
}","boolean isParameterizeSubtypeOf(JSType thatType){
  if (thatType.isParameterizedType()) {
    JSType thisParameter=this.parameterType;
    JSType thatParameter=thatType.toMaybeParameterizedType().parameterType;
    if (this.wrapsSameRawType(thatType)) {
      return (thisParameter.isSubtype(thatParameter) || thatParameter.isSubtype(thisParameter));
    }
  }
  return this.getReferencedTypeInternal().isSubtype(thatType);
}",0.8537735849056604
27957,"/** 
 * TypeExpression := BasicTypeExpression | '?' BasicTypeExpression | '!' BasicTypeExpression | BasicTypeExpression '?' | BasicTypeExpression '!' | '?'
 */
private Node parseTypeExpression(JsDocToken token){
  if (token == JsDocToken.QMARK) {
    token=next();
    if (token == JsDocToken.COMMA || token == JsDocToken.EQUALS || token == JsDocToken.RB || token == JsDocToken.RC || token == JsDocToken.RP || token == JsDocToken.PIPE) {
      restoreLookAhead(token);
      return newNode(Token.QMARK);
    }
    return wrapNode(Token.QMARK,parseBasicTypeExpression(token));
  }
 else   if (token == JsDocToken.BANG) {
    return wrapNode(Token.BANG,parseBasicTypeExpression(next()));
  }
 else {
    Node basicTypeExpr=parseBasicTypeExpression(token);
    if (basicTypeExpr != null) {
      if (match(JsDocToken.QMARK)) {
        next();
        return wrapNode(Token.QMARK,basicTypeExpr);
      }
 else       if (match(JsDocToken.BANG)) {
        next();
        return wrapNode(Token.BANG,basicTypeExpr);
      }
    }
    return basicTypeExpr;
  }
}","/** 
 * TypeExpression := BasicTypeExpression | '?' BasicTypeExpression | '!' BasicTypeExpression | BasicTypeExpression '?' | BasicTypeExpression '!' | '?'
 */
private Node parseTypeExpression(JsDocToken token){
  if (token == JsDocToken.QMARK) {
    token=next();
    if (token == JsDocToken.COMMA || token == JsDocToken.EQUALS || token == JsDocToken.RB || token == JsDocToken.RC || token == JsDocToken.RP || token == JsDocToken.PIPE || token == JsDocToken.GT) {
      restoreLookAhead(token);
      return newNode(Token.QMARK);
    }
    return wrapNode(Token.QMARK,parseBasicTypeExpression(token));
  }
 else   if (token == JsDocToken.BANG) {
    return wrapNode(Token.BANG,parseBasicTypeExpression(next()));
  }
 else {
    Node basicTypeExpr=parseBasicTypeExpression(token);
    if (basicTypeExpr != null) {
      if (match(JsDocToken.QMARK)) {
        next();
        return wrapNode(Token.QMARK,basicTypeExpr);
      }
 else       if (match(JsDocToken.BANG)) {
        next();
        return wrapNode(Token.BANG,basicTypeExpr);
      }
    }
    return basicTypeExpr;
  }
}",0.9878163074039362
27958,"/** 
 * TypeName := NameExpression | NameExpression TypeApplication TypeApplication := '.<' TypeExpressionList '>' TypeExpressionList := TypeExpression // a white lie
 */
private Node parseTypeName(JsDocToken token){
  if (token != JsDocToken.STRING) {
    return reportGenericTypeSyntaxWarning();
  }
  String typeName=stream.getString();
  int lineno=stream.getLineno();
  int charno=stream.getCharno();
  while (match(JsDocToken.EOL) && typeName.charAt(typeName.length() - 1) == '.') {
    skipEOLs();
    if (match(JsDocToken.STRING)) {
      next();
      typeName+=stream.getString();
    }
  }
  Node typeNameNode=newStringNode(typeName,lineno,charno);
  if (match(JsDocToken.LT)) {
    next();
    skipEOLs();
    Node memberType=parseTypeExpressionList(next());
    if (memberType != null) {
      typeNameNode.addChildToFront(memberType);
      skipEOLs();
      if (!match(JsDocToken.GT)) {
        return reportTypeSyntaxWarning(""String_Node_Str"");
      }
      next();
    }
  }
  return typeNameNode;
}","/** 
 * TypeName := NameExpression | NameExpression TypeApplication TypeApplication := '.<' TypeExpressionList '>'
 */
private Node parseTypeName(JsDocToken token){
  if (token != JsDocToken.STRING) {
    return reportGenericTypeSyntaxWarning();
  }
  String typeName=stream.getString();
  int lineno=stream.getLineno();
  int charno=stream.getCharno();
  while (match(JsDocToken.EOL) && typeName.charAt(typeName.length() - 1) == '.') {
    skipEOLs();
    if (match(JsDocToken.STRING)) {
      next();
      typeName+=stream.getString();
    }
  }
  Node typeNameNode=newStringNode(typeName,lineno,charno);
  if (match(JsDocToken.LT)) {
    next();
    skipEOLs();
    Node memberType=parseTypeExpressionList(next());
    if (memberType != null) {
      typeNameNode.addChildToFront(memberType);
      skipEOLs();
      if (!match(JsDocToken.GT)) {
        return reportTypeSyntaxWarning(""String_Node_Str"");
      }
      next();
    }
  }
  return typeNameNode;
}",0.9737638748738648
27959,"/** 
 * Visits an object literal field definition <code>key : value</code>. If the <code>lvalue</code> is a prototype modification, we change the schema of the object type it is referring to.
 * @param t the traversal
 * @param key the assign node
 */
private void visitObjLitKey(NodeTraversal t,Node key,Node objlit){
  if (objlit.isFromExterns()) {
    ensureTyped(t,key);
    return;
  }
  Node rvalue=key.getFirstChild();
  JSType rightType=NodeUtil.getObjectLitKeyTypeFromValueType(key,getJSType(rvalue));
  if (rightType == null) {
    rightType=getNativeType(UNKNOWN_TYPE);
  }
  Node owner=objlit;
  JSType keyType=getJSType(key);
  JSType allowedValueType=keyType;
  if (allowedValueType.isEnumElementType()) {
    allowedValueType=allowedValueType.toMaybeEnumElementType().getPrimitiveType();
  }
  boolean valid=validator.expectCanAssignToPropertyOf(t,key,rightType,allowedValueType,owner,NodeUtil.getObjectLitKeyName(key));
  if (valid) {
    ensureTyped(t,key,rightType);
  }
 else {
    ensureTyped(t,key);
  }
  JSType objlitType=getJSType(objlit);
  ObjectType type=ObjectType.cast(objlitType.restrictByNotNullOrUndefined());
  if (type != null) {
    String property=NodeUtil.getObjectLitKeyName(key);
    if (type.hasProperty(property) && !type.isPropertyTypeInferred(property) && !propertyIsImplicitCast(type,property)) {
      validator.expectCanAssignToPropertyOf(t,key,keyType,type.getPropertyType(property),owner,property);
    }
    return;
  }
}","/** 
 * Visits an object literal field definition <code>key : value</code>. If the <code>lvalue</code> is a prototype modification, we change the schema of the object type it is referring to.
 * @param t the traversal
 * @param key the assign node
 */
private void visitObjLitKey(NodeTraversal t,Node key,Node objlit,JSType litType){
  if (objlit.isFromExterns()) {
    ensureTyped(t,key);
    return;
  }
  if (litType.isStruct() && key.isQuotedString()) {
    report(t,key,ILLEGAL_OBJLIT_KEY,""String_Node_Str"");
  }
 else   if (litType.isDict() && !key.isQuotedString()) {
    report(t,key,ILLEGAL_OBJLIT_KEY,""String_Node_Str"");
  }
  Node rvalue=key.getFirstChild();
  JSType rightType=NodeUtil.getObjectLitKeyTypeFromValueType(key,getJSType(rvalue));
  if (rightType == null) {
    rightType=getNativeType(UNKNOWN_TYPE);
  }
  Node owner=objlit;
  JSType keyType=getJSType(key);
  JSType allowedValueType=keyType;
  if (allowedValueType.isEnumElementType()) {
    allowedValueType=allowedValueType.toMaybeEnumElementType().getPrimitiveType();
  }
  boolean valid=validator.expectCanAssignToPropertyOf(t,key,rightType,allowedValueType,owner,NodeUtil.getObjectLitKeyName(key));
  if (valid) {
    ensureTyped(t,key,rightType);
  }
 else {
    ensureTyped(t,key);
  }
  JSType objlitType=getJSType(objlit);
  ObjectType type=ObjectType.cast(objlitType.restrictByNotNullOrUndefined());
  if (type != null) {
    String property=NodeUtil.getObjectLitKeyName(key);
    if (type.hasProperty(property) && !type.isPropertyTypeInferred(property) && !propertyIsImplicitCast(type,property)) {
      validator.expectCanAssignToPropertyOf(t,key,keyType,type.getPropertyType(property),owner,property);
    }
    return;
  }
}",0.9233668341708544
27960,"/** 
 * This is the meat of the type checking.  It is basically one big switch, with each case representing one type of parse tree node.  The individual cases are usually pretty straightforward.
 * @param t The node traversal object that supplies context, such as thescope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */
@Override public void visit(NodeTraversal t,Node n,Node parent){
  JSType childType;
  JSType leftType, rightType;
  Node left, right;
  boolean typeable=true;
switch (n.getType()) {
case Token.CAST:
    Node expr=n.getFirstChild();
  ensureTyped(t,n,getJSType(expr));
JSType castType=getJSType(n);
JSType exprType=getJSType(expr);
if (castType.isSubtype(exprType)) {
expr.setJSType(castType);
}
break;
case Token.NAME:
typeable=visitName(t,n,parent);
break;
case Token.PARAM_LIST:
typeable=false;
break;
case Token.COMMA:
ensureTyped(t,n,getJSType(n.getLastChild()));
break;
case Token.TRUE:
case Token.FALSE:
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.THIS:
ensureTyped(t,n,t.getScope().getTypeOfThis());
break;
case Token.NULL:
ensureTyped(t,n,NULL_TYPE);
break;
case Token.NUMBER:
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.STRING:
ensureTyped(t,n,STRING_TYPE);
break;
case Token.STRING_KEY:
typeable=false;
break;
case Token.GETTER_DEF:
case Token.SETTER_DEF:
break;
case Token.ARRAYLIT:
ensureTyped(t,n,ARRAY_TYPE);
break;
case Token.REGEXP:
ensureTyped(t,n,REGEXP_TYPE);
break;
case Token.GETPROP:
visitGetProp(t,n,parent);
typeable=!(parent.isAssign() && parent.getFirstChild() == n);
break;
case Token.GETELEM:
visitGetElem(t,n);
typeable=false;
break;
case Token.VAR:
visitVar(t,n);
typeable=false;
break;
case Token.NEW:
visitNew(t,n);
break;
case Token.CALL:
visitCall(t,n);
typeable=!parent.isExprResult();
break;
case Token.RETURN:
visitReturn(t,n);
typeable=false;
break;
case Token.DEC:
case Token.INC:
left=n.getFirstChild();
checkPropCreation(t,left);
validator.expectNumber(t,left,getJSType(left),""String_Node_Str"");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.NOT:
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.VOID:
ensureTyped(t,n,VOID_TYPE);
break;
case Token.TYPEOF:
ensureTyped(t,n,STRING_TYPE);
break;
case Token.BITNOT:
childType=getJSType(n.getFirstChild());
if (!childType.matchesInt32Context()) {
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.POS:
case Token.NEG:
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),""String_Node_Str"");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.EQ:
case Token.NE:
case Token.SHEQ:
case Token.SHNE:
{
left=n.getFirstChild();
right=n.getLastChild();
if (left.isTypeOf()) {
if (right.isString()) {
checkTypeofString(t,right,right.getString());
}
}
 else if (right.isTypeOf() && left.isString()) {
checkTypeofString(t,left,left.getString());
}
leftType=getJSType(left);
rightType=getJSType(right);
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=TernaryValue.UNKNOWN;
if (n.getType() == Token.EQ || n.getType() == Token.NE) {
result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if (n.isNE()) {
result=result.not();
}
}
 else {
if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
result=n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
}
}
if (result != TernaryValue.UNKNOWN) {
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.LT:
case Token.LE:
case Token.GT:
case Token.GE:
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
if (rightType.isNumber()) {
validator.expectNumber(t,n,leftType,""String_Node_Str"");
}
 else if (leftType.isNumber()) {
validator.expectNumber(t,n,rightType,""String_Node_Str"");
}
 else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
}
 else {
String message=""String_Node_Str"";
validator.expectString(t,n,leftType,message);
validator.expectNotNullOrUndefined(t,n,leftType,message,getNativeType(STRING_TYPE));
message=""String_Node_Str"";
validator.expectString(t,n,rightType,message);
validator.expectNotNullOrUndefined(t,n,rightType,message,getNativeType(STRING_TYPE));
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.IN:
left=n.getFirstChild();
right=n.getLastChild();
rightType=getJSType(right);
validator.expectString(t,left,getJSType(left),""String_Node_Str"");
validator.expectObject(t,n,rightType,""String_Node_Str"");
if (rightType.isStruct()) {
report(t,right,IN_USED_WITH_STRUCT);
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.INSTANCEOF:
left=n.getFirstChild();
right=n.getLastChild();
rightType=getJSType(right).restrictByNotNullOrUndefined();
validator.expectAnyObject(t,left,getJSType(left),""String_Node_Str"");
validator.expectActualObject(t,right,rightType,""String_Node_Str"");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.ASSIGN:
visitAssign(t,n);
typeable=false;
break;
case Token.ASSIGN_LSH:
case Token.ASSIGN_RSH:
case Token.ASSIGN_URSH:
case Token.ASSIGN_DIV:
case Token.ASSIGN_MOD:
case Token.ASSIGN_BITOR:
case Token.ASSIGN_BITXOR:
case Token.ASSIGN_BITAND:
case Token.ASSIGN_SUB:
case Token.ASSIGN_ADD:
case Token.ASSIGN_MUL:
checkPropCreation(t,n.getFirstChild());
case Token.LSH:
case Token.RSH:
case Token.URSH:
case Token.DIV:
case Token.MOD:
case Token.BITOR:
case Token.BITXOR:
case Token.BITAND:
case Token.SUB:
case Token.ADD:
case Token.MUL:
visitBinaryOperator(n.getType(),t,n);
break;
case Token.DELPROP:
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.CASE:
JSType switchType=getJSType(parent.getFirstChild());
JSType caseType=getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t,n,switchType,caseType);
typeable=false;
break;
case Token.WITH:
{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,""String_Node_Str"");
typeable=false;
break;
}
case Token.FUNCTION:
visitFunction(t,n);
break;
case Token.LABEL:
case Token.LABEL_NAME:
case Token.SWITCH:
case Token.BREAK:
case Token.CATCH:
case Token.TRY:
case Token.SCRIPT:
case Token.EXPR_RESULT:
case Token.BLOCK:
case Token.EMPTY:
case Token.DEFAULT_CASE:
case Token.CONTINUE:
case Token.DEBUGGER:
case Token.THROW:
typeable=false;
break;
case Token.DO:
case Token.IF:
case Token.WHILE:
typeable=false;
break;
case Token.FOR:
if (NodeUtil.isForIn(n)) {
Node obj=n.getChildAtIndex(1);
if (getJSType(obj).isStruct()) {
report(t,obj,IN_USED_WITH_STRUCT);
}
}
typeable=false;
break;
case Token.AND:
case Token.HOOK:
case Token.OBJECTLIT:
case Token.OR:
if (n.getJSType() != null) {
ensureTyped(t,n);
}
 else {
if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
ensureTyped(t,n,parent.getJSType());
}
 else {
ensureTyped(t,n);
}
}
if (n.isObjectLit()) {
for (Node key : n.children()) {
visitObjLitKey(t,key,n);
}
}
break;
default :
report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));
ensureTyped(t,n);
break;
}
typeable=typeable && !inExterns;
if (typeable) {
doPercentTypedAccounting(t,n);
}
checkNoTypeCheckSection(n,false);
}","/** 
 * This is the meat of the type checking.  It is basically one big switch, with each case representing one type of parse tree node.  The individual cases are usually pretty straightforward.
 * @param t The node traversal object that supplies context, such as thescope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */
@Override public void visit(NodeTraversal t,Node n,Node parent){
  JSType childType;
  JSType leftType, rightType;
  Node left, right;
  boolean typeable=true;
switch (n.getType()) {
case Token.CAST:
    Node expr=n.getFirstChild();
  ensureTyped(t,n,getJSType(expr));
JSType castType=getJSType(n);
JSType exprType=getJSType(expr);
if (castType.isSubtype(exprType)) {
expr.setJSType(castType);
}
break;
case Token.NAME:
typeable=visitName(t,n,parent);
break;
case Token.PARAM_LIST:
typeable=false;
break;
case Token.COMMA:
ensureTyped(t,n,getJSType(n.getLastChild()));
break;
case Token.TRUE:
case Token.FALSE:
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.THIS:
ensureTyped(t,n,t.getScope().getTypeOfThis());
break;
case Token.NULL:
ensureTyped(t,n,NULL_TYPE);
break;
case Token.NUMBER:
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.STRING:
ensureTyped(t,n,STRING_TYPE);
break;
case Token.STRING_KEY:
typeable=false;
break;
case Token.GETTER_DEF:
case Token.SETTER_DEF:
break;
case Token.ARRAYLIT:
ensureTyped(t,n,ARRAY_TYPE);
break;
case Token.REGEXP:
ensureTyped(t,n,REGEXP_TYPE);
break;
case Token.GETPROP:
visitGetProp(t,n,parent);
typeable=!(parent.isAssign() && parent.getFirstChild() == n);
break;
case Token.GETELEM:
visitGetElem(t,n);
typeable=false;
break;
case Token.VAR:
visitVar(t,n);
typeable=false;
break;
case Token.NEW:
visitNew(t,n);
break;
case Token.CALL:
visitCall(t,n);
typeable=!parent.isExprResult();
break;
case Token.RETURN:
visitReturn(t,n);
typeable=false;
break;
case Token.DEC:
case Token.INC:
left=n.getFirstChild();
checkPropCreation(t,left);
validator.expectNumber(t,left,getJSType(left),""String_Node_Str"");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.NOT:
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.VOID:
ensureTyped(t,n,VOID_TYPE);
break;
case Token.TYPEOF:
ensureTyped(t,n,STRING_TYPE);
break;
case Token.BITNOT:
childType=getJSType(n.getFirstChild());
if (!childType.matchesInt32Context()) {
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.POS:
case Token.NEG:
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),""String_Node_Str"");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.EQ:
case Token.NE:
case Token.SHEQ:
case Token.SHNE:
{
left=n.getFirstChild();
right=n.getLastChild();
if (left.isTypeOf()) {
if (right.isString()) {
checkTypeofString(t,right,right.getString());
}
}
 else if (right.isTypeOf() && left.isString()) {
checkTypeofString(t,left,left.getString());
}
leftType=getJSType(left);
rightType=getJSType(right);
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=TernaryValue.UNKNOWN;
if (n.getType() == Token.EQ || n.getType() == Token.NE) {
result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if (n.isNE()) {
result=result.not();
}
}
 else {
if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
result=n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
}
}
if (result != TernaryValue.UNKNOWN) {
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.LT:
case Token.LE:
case Token.GT:
case Token.GE:
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
if (rightType.isNumber()) {
validator.expectNumber(t,n,leftType,""String_Node_Str"");
}
 else if (leftType.isNumber()) {
validator.expectNumber(t,n,rightType,""String_Node_Str"");
}
 else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
}
 else {
String message=""String_Node_Str"";
validator.expectString(t,n,leftType,message);
validator.expectNotNullOrUndefined(t,n,leftType,message,getNativeType(STRING_TYPE));
message=""String_Node_Str"";
validator.expectString(t,n,rightType,message);
validator.expectNotNullOrUndefined(t,n,rightType,message,getNativeType(STRING_TYPE));
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.IN:
left=n.getFirstChild();
right=n.getLastChild();
rightType=getJSType(right);
validator.expectString(t,left,getJSType(left),""String_Node_Str"");
validator.expectObject(t,n,rightType,""String_Node_Str"");
if (rightType.isStruct()) {
report(t,right,IN_USED_WITH_STRUCT);
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.INSTANCEOF:
left=n.getFirstChild();
right=n.getLastChild();
rightType=getJSType(right).restrictByNotNullOrUndefined();
validator.expectAnyObject(t,left,getJSType(left),""String_Node_Str"");
validator.expectActualObject(t,right,rightType,""String_Node_Str"");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.ASSIGN:
visitAssign(t,n);
typeable=false;
break;
case Token.ASSIGN_LSH:
case Token.ASSIGN_RSH:
case Token.ASSIGN_URSH:
case Token.ASSIGN_DIV:
case Token.ASSIGN_MOD:
case Token.ASSIGN_BITOR:
case Token.ASSIGN_BITXOR:
case Token.ASSIGN_BITAND:
case Token.ASSIGN_SUB:
case Token.ASSIGN_ADD:
case Token.ASSIGN_MUL:
checkPropCreation(t,n.getFirstChild());
case Token.LSH:
case Token.RSH:
case Token.URSH:
case Token.DIV:
case Token.MOD:
case Token.BITOR:
case Token.BITXOR:
case Token.BITAND:
case Token.SUB:
case Token.ADD:
case Token.MUL:
visitBinaryOperator(n.getType(),t,n);
break;
case Token.DELPROP:
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.CASE:
JSType switchType=getJSType(parent.getFirstChild());
JSType caseType=getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t,n,switchType,caseType);
typeable=false;
break;
case Token.WITH:
{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,""String_Node_Str"");
typeable=false;
break;
}
case Token.FUNCTION:
visitFunction(t,n);
break;
case Token.LABEL:
case Token.LABEL_NAME:
case Token.SWITCH:
case Token.BREAK:
case Token.CATCH:
case Token.TRY:
case Token.SCRIPT:
case Token.EXPR_RESULT:
case Token.BLOCK:
case Token.EMPTY:
case Token.DEFAULT_CASE:
case Token.CONTINUE:
case Token.DEBUGGER:
case Token.THROW:
typeable=false;
break;
case Token.DO:
case Token.IF:
case Token.WHILE:
typeable=false;
break;
case Token.FOR:
if (NodeUtil.isForIn(n)) {
Node obj=n.getChildAtIndex(1);
if (getJSType(obj).isStruct()) {
report(t,obj,IN_USED_WITH_STRUCT);
}
}
typeable=false;
break;
case Token.AND:
case Token.HOOK:
case Token.OBJECTLIT:
case Token.OR:
if (n.getJSType() != null) {
ensureTyped(t,n);
}
 else {
if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
ensureTyped(t,n,parent.getJSType());
}
 else {
ensureTyped(t,n);
}
}
if (n.isObjectLit()) {
JSType typ=getJSType(n);
for (Node key : n.children()) {
visitObjLitKey(t,key,n,typ);
}
}
break;
default :
report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));
ensureTyped(t,n);
break;
}
typeable=typeable && !inExterns;
if (typeable) {
doPercentTypedAccounting(t,n);
}
checkNoTypeCheckSection(n,false);
}",0.9979982052874992
27961,"/** 
 * When computing infima, we may get a situation like inf(Type1, Type2) where both types are unresolved, so they're technically subtypes of one another. If this happens, filter them down to NoResolvedType.
 */
static JSType filterNoResolvedType(JSType type){
  if (type.isNoResolvedType()) {
    return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);
  }
 else   if (type.isUnionType()) {
    UnionType unionType=type.toMaybeUnionType();
    boolean needsFiltering=false;
    for (    JSType alt : unionType.getAlternates()) {
      if (alt.isNoResolvedType()) {
        needsFiltering=true;
        break;
      }
    }
    if (needsFiltering) {
      UnionTypeBuilder builder=new UnionTypeBuilder(type.registry);
      for (      JSType alt : unionType.getAlternates()) {
        if (!alt.isNoResolvedType()) {
          builder.addAlternate(alt);
        }
      }
      return builder.build();
    }
  }
  return type;
}","/** 
 * When computing infima, we may get a situation like inf(Type1, Type2) where both types are unresolved, so they're technically subtypes of one another. If this happens, filter them down to NoResolvedType.
 */
static JSType filterNoResolvedType(JSType type){
  if (type.isNoResolvedType()) {
    return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);
  }
 else   if (type.isUnionType()) {
    UnionType unionType=type.toMaybeUnionType();
    boolean needsFiltering=false;
    for (    JSType alt : unionType.getAlternates()) {
      if (alt.isNoResolvedType()) {
        needsFiltering=true;
        break;
      }
    }
    if (needsFiltering) {
      UnionTypeBuilder builder=new UnionTypeBuilder(type.registry);
      builder.addAlternate(type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE));
      for (      JSType alt : unionType.getAlternates()) {
        if (!alt.isNoResolvedType()) {
          builder.addAlternate(alt);
        }
      }
      return builder.build();
    }
  }
  return type;
}",0.948018528049408
27962,"/** 
 * A generic implementation meant to be used as a helper for common getGreatestSubtype implementations.
 */
static JSType getGreatestSubtype(JSType thisType,JSType thatType){
  if (thisType.isFunctionType() && thatType.isFunctionType()) {
    return thisType.toMaybeFunctionType().supAndInfHelper(thatType.toMaybeFunctionType(),false);
  }
 else   if (thisType.isEquivalentTo(thatType)) {
    return thisType;
  }
 else   if (thisType.isUnknownType() || thatType.isUnknownType()) {
    return thisType.isEquivalentTo(thatType) ? thisType : thisType.getNativeType(JSTypeNative.UNKNOWN_TYPE);
  }
 else   if (thisType.isSubtype(thatType)) {
    return filterNoResolvedType(thisType);
  }
 else   if (thatType.isSubtype(thisType)) {
    return filterNoResolvedType(thatType);
  }
 else   if (thisType.isUnionType()) {
    return thisType.toMaybeUnionType().meet(thatType);
  }
 else   if (thatType.isUnionType()) {
    return thatType.toMaybeUnionType().meet(thisType);
  }
 else   if (thisType.isRecordType()) {
    return thisType.toMaybeRecordType().getGreatestSubtypeHelper(thatType);
  }
 else   if (thatType.isRecordType()) {
    return thatType.toMaybeRecordType().getGreatestSubtypeHelper(thisType);
  }
  if (thisType.isEnumElementType()) {
    JSType inf=thisType.toMaybeEnumElementType().meet(thatType);
    if (inf != null) {
      return inf;
    }
  }
 else   if (thatType.isEnumElementType()) {
    JSType inf=thatType.toMaybeEnumElementType().meet(thisType);
    if (inf != null) {
      return inf;
    }
  }
  if (thisType.isObject() && thatType.isObject()) {
    return thisType.getNativeType(JSTypeNative.NO_OBJECT_TYPE);
  }
  return thisType.getNativeType(JSTypeNative.NO_TYPE);
}","/** 
 * A generic implementation meant to be used as a helper for common getGreatestSubtype implementations.
 */
static JSType getGreatestSubtype(JSType thisType,JSType thatType){
  if (thisType.isFunctionType() && thatType.isFunctionType()) {
    return thisType.toMaybeFunctionType().supAndInfHelper(thatType.toMaybeFunctionType(),false);
  }
 else   if (thisType.isEquivalentTo(thatType)) {
    return thisType;
  }
 else   if (thisType.isUnknownType() || thatType.isUnknownType()) {
    return thisType.isEquivalentTo(thatType) ? thisType : thisType.getNativeType(JSTypeNative.UNKNOWN_TYPE);
  }
 else   if (thisType.isUnionType()) {
    return thisType.toMaybeUnionType().meet(thatType);
  }
 else   if (thatType.isUnionType()) {
    return thatType.toMaybeUnionType().meet(thisType);
  }
 else   if (thisType.isSubtype(thatType)) {
    return filterNoResolvedType(thisType);
  }
 else   if (thatType.isSubtype(thisType)) {
    return filterNoResolvedType(thatType);
  }
 else   if (thisType.isRecordType()) {
    return thisType.toMaybeRecordType().getGreatestSubtypeHelper(thatType);
  }
 else   if (thatType.isRecordType()) {
    return thatType.toMaybeRecordType().getGreatestSubtypeHelper(thisType);
  }
  if (thisType.isEnumElementType()) {
    JSType inf=thisType.toMaybeEnumElementType().meet(thatType);
    if (inf != null) {
      return inf;
    }
  }
 else   if (thatType.isEnumElementType()) {
    JSType inf=thatType.toMaybeEnumElementType().meet(thisType);
    if (inf != null) {
      return inf;
    }
  }
  if (thisType.isObject() && thatType.isObject()) {
    return thisType.getNativeType(JSTypeNative.NO_OBJECT_TYPE);
  }
  return thisType.getNativeType(JSTypeNative.NO_TYPE);
}",0.886150234741784
27963,"JSType meet(JSType that){
  UnionTypeBuilder builder=new UnionTypeBuilder(registry);
  for (  JSType alternate : alternates) {
    if (alternate.isSubtype(that)) {
      builder.addAlternate(alternate);
    }
  }
  if (that.isUnionType()) {
    for (    JSType otherAlternate : that.toMaybeUnionType().alternates) {
      if (otherAlternate.isSubtype(this)) {
        builder.addAlternate(otherAlternate);
      }
    }
  }
 else   if (that.isSubtype(this)) {
    builder.addAlternate(that);
  }
  JSType result=builder.build();
  if (!result.isNoType()) {
    return result;
  }
 else   if (this.isObject() && that.isObject()) {
    return getNativeType(JSTypeNative.NO_OBJECT_TYPE);
  }
 else {
    return getNativeType(JSTypeNative.NO_TYPE);
  }
}","JSType meet(JSType that){
  UnionTypeBuilder builder=new UnionTypeBuilder(registry);
  for (  JSType alternate : alternates) {
    if (alternate.isSubtype(that)) {
      builder.addAlternate(alternate);
    }
  }
  if (that.isUnionType()) {
    for (    JSType otherAlternate : that.toMaybeUnionType().alternates) {
      if (otherAlternate.isSubtype(this)) {
        builder.addAlternate(otherAlternate);
      }
    }
  }
 else   if (that.isSubtype(this)) {
    builder.addAlternate(that);
  }
  JSType result=builder.build();
  if (!result.isNoType()) {
    return result;
  }
 else   if (this.isObject() && (that.isObject() && !that.isNoType())) {
    return getNativeType(JSTypeNative.NO_OBJECT_TYPE);
  }
 else {
    return getNativeType(JSTypeNative.NO_TYPE);
  }
}",0.985545335085414
27964,"/** 
 * Returns a more restricted union type than   {@code this} one, in which allsubtypes of  {@code type} have been removed.<p>Examples: <ul> <li> {@code (number,string)} restricted by {@code number} is{@code string}</li> <li>  {@code (null, EvalError, URIError)} restricted by{@code Error} is {@code null}</li> </ul>
 * @param type the supertype of the types to remove from this union type
 */
public JSType getRestrictedUnion(JSType type){
  UnionTypeBuilder restricted=new UnionTypeBuilder(registry);
  for (  JSType t : alternates) {
    if (t.isUnknownType() || !t.isSubtype(type)) {
      restricted.addAlternate(t);
    }
  }
  return restricted.build();
}","/** 
 * Returns a more restricted union type than   {@code this} one, in which allsubtypes of  {@code type} have been removed.<p>Examples: <ul> <li> {@code (number,string)} restricted by {@code number} is{@code string}</li> <li>  {@code (null, EvalError, URIError)} restricted by{@code Error} is {@code null}</li> </ul>
 * @param type the supertype of the types to remove from this union type
 */
public JSType getRestrictedUnion(JSType type){
  UnionTypeBuilder restricted=new UnionTypeBuilder(registry);
  for (  JSType t : alternates) {
    if (t.isUnknownType() || t.isNoResolvedType() || !t.isSubtype(type)) {
      restricted.addAlternate(t);
    }
  }
  return restricted.build();
}",0.982274741506647
27965,"public void testNamedSubtypeChain() throws Exception {
  List<JSType> typeChain=Lists.newArrayList(registry.getNativeType(JSTypeNative.ALL_TYPE),registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE),registry.getNativeType(JSTypeNative.OBJECT_TYPE),googBar.getPrototype(),googBar.getInstanceType(),googSubBar.getPrototype(),googSubBar.getInstanceType(),googSubSubBar.getPrototype(),googSubSubBar.getInstanceType(),registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),registry.getNativeType(JSTypeNative.NO_RESOLVED_TYPE),registry.getNativeType(JSTypeNative.NO_TYPE));
  verifySubtypeChain(typeChain);
}","public void testNamedSubtypeChain() throws Exception {
  List<JSType> typeChain=Lists.newArrayList(registry.getNativeType(JSTypeNative.ALL_TYPE),registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE),registry.getNativeType(JSTypeNative.OBJECT_TYPE),googBar.getPrototype(),googBar.getInstanceType(),googSubBar.getPrototype(),googSubBar.getInstanceType(),googSubSubBar.getPrototype(),googSubSubBar.getInstanceType(),registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),registry.getNativeType(JSTypeNative.NO_TYPE));
  verifySubtypeChain(typeChain);
}",0.9528795811518324
27966,"/** 
 * Tests the behavior of the unresolved Bottom type.
 */
public void testNoResolvedType() throws Exception {
  assertFalse(NO_RESOLVED_TYPE.isNoObjectType());
  assertFalse(NO_RESOLVED_TYPE.isNoType());
  assertTrue(NO_RESOLVED_TYPE.isNoResolvedType());
  assertFalse(NO_RESOLVED_TYPE.isArrayType());
  assertFalse(NO_RESOLVED_TYPE.isBooleanValueType());
  assertFalse(NO_RESOLVED_TYPE.isDateType());
  assertFalse(NO_RESOLVED_TYPE.isEnumElementType());
  assertFalse(NO_RESOLVED_TYPE.isNullType());
  assertFalse(NO_RESOLVED_TYPE.isNamedType());
  assertTrue(NO_RESOLVED_TYPE.isNumber());
  assertFalse(NO_RESOLVED_TYPE.isNumberObjectType());
  assertFalse(NO_RESOLVED_TYPE.isNumberValueType());
  assertTrue(NO_RESOLVED_TYPE.isObject());
  assertFalse(NO_RESOLVED_TYPE.isFunctionPrototypeType());
  assertFalse(NO_RESOLVED_TYPE.isRegexpType());
  assertTrue(NO_RESOLVED_TYPE.isString());
  assertFalse(NO_RESOLVED_TYPE.isStringObjectType());
  assertFalse(NO_RESOLVED_TYPE.isStringValueType());
  assertFalse(NO_RESOLVED_TYPE.isEnumType());
  assertFalse(NO_RESOLVED_TYPE.isUnionType());
  assertFalse(NO_RESOLVED_TYPE.isStruct());
  assertFalse(NO_RESOLVED_TYPE.isDict());
  assertFalse(NO_RESOLVED_TYPE.isAllType());
  assertFalse(NO_RESOLVED_TYPE.isVoidType());
  assertTrue(NO_RESOLVED_TYPE.isConstructor());
  assertFalse(NO_RESOLVED_TYPE.isInstanceType());
  assertTrue(NO_RESOLVED_TYPE.isSubtype(NO_RESOLVED_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(NO_OBJECT_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(ARRAY_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(BOOLEAN_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(BOOLEAN_OBJECT_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(DATE_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(EVAL_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(functionType));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(NULL_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(NUMBER_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(NUMBER_OBJECT_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(OBJECT_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(URI_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(RANGE_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(REFERENCE_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(REGEXP_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(STRING_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(STRING_OBJECT_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(SYNTAX_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(TYPE_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(ALL_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(VOID_TYPE));
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,NO_RESOLVED_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,NO_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,NO_OBJECT_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,ARRAY_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,BOOLEAN_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,BOOLEAN_OBJECT_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,DATE_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,ERROR_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,EVAL_ERROR_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,functionType);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,NULL_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,NUMBER_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,NUMBER_OBJECT_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,OBJECT_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,URI_ERROR_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,RANGE_ERROR_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,REFERENCE_ERROR_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,REGEXP_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,STRING_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,STRING_OBJECT_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,SYNTAX_ERROR_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,TYPE_ERROR_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,ALL_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,VOID_TYPE);
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(NO_RESOLVED_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(DATE_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(functionType));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(NULL_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(STRING_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(ALL_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(VOID_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isNullable());
  assertTrue(NO_RESOLVED_TYPE.isObject());
  assertTrue(NO_RESOLVED_TYPE.matchesInt32Context());
  assertTrue(NO_RESOLVED_TYPE.matchesNumberContext());
  assertTrue(NO_RESOLVED_TYPE.matchesObjectContext());
  assertTrue(NO_RESOLVED_TYPE.matchesStringContext());
  assertTrue(NO_RESOLVED_TYPE.matchesUint32Context());
  assertEquals(""String_Node_Str"",NO_RESOLVED_TYPE.toString());
  assertEquals(null,NO_RESOLVED_TYPE.getDisplayName());
  assertFalse(NO_RESOLVED_TYPE.hasDisplayName());
  assertTypeEquals(CHECKED_UNKNOWN_TYPE,NO_RESOLVED_TYPE.getPropertyType(""String_Node_Str""));
  Asserts.assertResolvesToSame(NO_RESOLVED_TYPE);
  assertTrue(forwardDeclaredNamedType.isEmptyType());
  assertTrue(forwardDeclaredNamedType.isNoResolvedType());
}","/** 
 * Tests the behavior of the unresolved Bottom type.
 */
public void testNoResolvedType() throws Exception {
  assertFalse(NO_RESOLVED_TYPE.isNoObjectType());
  assertFalse(NO_RESOLVED_TYPE.isNoType());
  assertTrue(NO_RESOLVED_TYPE.isNoResolvedType());
  assertFalse(NO_RESOLVED_TYPE.isArrayType());
  assertFalse(NO_RESOLVED_TYPE.isBooleanValueType());
  assertFalse(NO_RESOLVED_TYPE.isDateType());
  assertFalse(NO_RESOLVED_TYPE.isEnumElementType());
  assertFalse(NO_RESOLVED_TYPE.isNullType());
  assertFalse(NO_RESOLVED_TYPE.isNamedType());
  assertTrue(NO_RESOLVED_TYPE.isNumber());
  assertFalse(NO_RESOLVED_TYPE.isNumberObjectType());
  assertFalse(NO_RESOLVED_TYPE.isNumberValueType());
  assertTrue(NO_RESOLVED_TYPE.isObject());
  assertFalse(NO_RESOLVED_TYPE.isFunctionPrototypeType());
  assertFalse(NO_RESOLVED_TYPE.isRegexpType());
  assertTrue(NO_RESOLVED_TYPE.isString());
  assertFalse(NO_RESOLVED_TYPE.isStringObjectType());
  assertFalse(NO_RESOLVED_TYPE.isStringValueType());
  assertFalse(NO_RESOLVED_TYPE.isEnumType());
  assertFalse(NO_RESOLVED_TYPE.isUnionType());
  assertFalse(NO_RESOLVED_TYPE.isStruct());
  assertFalse(NO_RESOLVED_TYPE.isDict());
  assertFalse(NO_RESOLVED_TYPE.isAllType());
  assertFalse(NO_RESOLVED_TYPE.isVoidType());
  assertTrue(NO_RESOLVED_TYPE.isConstructor());
  assertFalse(NO_RESOLVED_TYPE.isInstanceType());
  assertTrue(NO_RESOLVED_TYPE.isSubtype(NO_RESOLVED_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(NO_OBJECT_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(ARRAY_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(BOOLEAN_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(BOOLEAN_OBJECT_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(DATE_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(EVAL_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(functionType));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(NULL_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(NUMBER_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(NUMBER_OBJECT_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(OBJECT_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(URI_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(RANGE_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(REFERENCE_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(REGEXP_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(STRING_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(STRING_OBJECT_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(SYNTAX_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(TYPE_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(ALL_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(VOID_TYPE));
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,NO_RESOLVED_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,NO_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,NO_OBJECT_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,ARRAY_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,BOOLEAN_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,BOOLEAN_OBJECT_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,DATE_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,ERROR_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,EVAL_ERROR_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,functionType);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,NULL_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,NUMBER_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,NUMBER_OBJECT_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,OBJECT_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,URI_ERROR_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,RANGE_ERROR_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,REFERENCE_ERROR_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,REGEXP_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,STRING_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,STRING_OBJECT_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,SYNTAX_ERROR_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,TYPE_ERROR_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,ALL_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,VOID_TYPE);
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(NO_RESOLVED_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(DATE_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(functionType));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(NULL_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(STRING_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(ALL_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(VOID_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isNullable());
  assertTrue(NO_RESOLVED_TYPE.isObject());
  assertTrue(NO_RESOLVED_TYPE.matchesInt32Context());
  assertTrue(NO_RESOLVED_TYPE.matchesNumberContext());
  assertTrue(NO_RESOLVED_TYPE.matchesObjectContext());
  assertTrue(NO_RESOLVED_TYPE.matchesStringContext());
  assertTrue(NO_RESOLVED_TYPE.matchesUint32Context());
  assertEquals(""String_Node_Str"",NO_RESOLVED_TYPE.toString());
  assertEquals(null,NO_RESOLVED_TYPE.getDisplayName());
  assertFalse(NO_RESOLVED_TYPE.hasDisplayName());
  assertTypeEquals(CHECKED_UNKNOWN_TYPE,NO_RESOLVED_TYPE.getPropertyType(""String_Node_Str""));
  Asserts.assertResolvesToSame(NO_RESOLVED_TYPE);
  assertTrue(forwardDeclaredNamedType.isEmptyType());
  assertTrue(forwardDeclaredNamedType.isNoResolvedType());
  UnionType nullable=(UnionType)registry.createNullableType(NO_RESOLVED_TYPE);
  assertTypeEquals(nullable,nullable.getGreatestSubtype(NULL_TYPE));
  assertTypeEquals(NO_RESOLVED_TYPE,nullable.getRestrictedUnion(NULL_TYPE));
}",0.9836991958269942
27967,"/** 
 * Tests the behavior of the null type.
 */
public void testNullType() throws Exception {
  assertFalse(NULL_TYPE.isArrayType());
  assertFalse(NULL_TYPE.isBooleanValueType());
  assertFalse(NULL_TYPE.isDateType());
  assertFalse(NULL_TYPE.isEnumElementType());
  assertFalse(NULL_TYPE.isNamedType());
  assertTrue(NULL_TYPE.isNullType());
  assertFalse(NULL_TYPE.isNumber());
  assertFalse(NULL_TYPE.isNumberObjectType());
  assertFalse(NULL_TYPE.isNumberValueType());
  assertFalse(NULL_TYPE.isFunctionPrototypeType());
  assertFalse(NULL_TYPE.isRegexpType());
  assertFalse(NULL_TYPE.isString());
  assertFalse(NULL_TYPE.isStringObjectType());
  assertFalse(NULL_TYPE.isStringValueType());
  assertFalse(NULL_TYPE.isEnumType());
  assertFalse(NULL_TYPE.isUnionType());
  assertFalse(NULL_TYPE.isStruct());
  assertFalse(NULL_TYPE.isDict());
  assertFalse(NULL_TYPE.isAllType());
  assertFalse(NULL_TYPE.isVoidType());
  assertFalse(NULL_TYPE.isConstructor());
  assertFalse(NULL_TYPE.isInstanceType());
  assertNull(NULL_TYPE.autoboxesTo());
  assertFalse(NULL_TYPE.isSubtype(NO_OBJECT_TYPE));
  assertFalse(NULL_TYPE.isSubtype(NO_TYPE));
  assertTrue(NULL_TYPE.isSubtype(NULL_TYPE));
  assertTrue(NULL_TYPE.isSubtype(ALL_TYPE));
  assertFalse(NULL_TYPE.isSubtype(STRING_OBJECT_TYPE));
  assertFalse(NULL_TYPE.isSubtype(NUMBER_TYPE));
  assertFalse(NULL_TYPE.isSubtype(functionType));
  assertFalse(NULL_TYPE.isSubtype(OBJECT_TYPE));
  assertFalse(NULL_TYPE.isSubtype(DATE_TYPE));
  assertFalse(NULL_TYPE.isSubtype(REGEXP_TYPE));
  assertFalse(NULL_TYPE.isSubtype(ARRAY_TYPE));
  assertTrue(NULL_TYPE.isSubtype(UNKNOWN_TYPE));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(NO_OBJECT_TYPE)));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(NO_TYPE)));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(NULL_TYPE)));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(ALL_TYPE)));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(STRING_OBJECT_TYPE)));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(NUMBER_TYPE)));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(functionType)));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(OBJECT_TYPE)));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(DATE_TYPE)));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(REGEXP_TYPE)));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(ARRAY_TYPE)));
  assertFalse(NULL_TYPE.canBeCalled());
  assertCanTestForEqualityWith(NULL_TYPE,NO_TYPE);
  assertCanTestForEqualityWith(NULL_TYPE,NO_OBJECT_TYPE);
  assertCanTestForEqualityWith(NULL_TYPE,ALL_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,ARRAY_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,BOOLEAN_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,BOOLEAN_OBJECT_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,DATE_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,ERROR_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,EVAL_ERROR_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,functionType);
  assertCannotTestForEqualityWith(NULL_TYPE,NULL_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,NUMBER_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,NUMBER_OBJECT_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,OBJECT_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,URI_ERROR_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,RANGE_ERROR_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,REFERENCE_ERROR_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,REGEXP_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,STRING_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,STRING_OBJECT_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,SYNTAX_ERROR_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,TYPE_ERROR_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,VOID_TYPE);
  assertTrue(NULL_TYPE.canTestForShallowEqualityWith(NO_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(DATE_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(ERROR_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(functionType));
  assertTrue(NULL_TYPE.canTestForShallowEqualityWith(NULL_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(STRING_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE));
  assertTrue(NULL_TYPE.canTestForShallowEqualityWith(ALL_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(VOID_TYPE));
  assertTrue(NULL_TYPE.canTestForShallowEqualityWith(createNullableType(STRING_OBJECT_TYPE)));
  assertTypeEquals(NULL_TYPE,NULL_TYPE.getLeastSupertype(NULL_TYPE));
  assertTypeEquals(ALL_TYPE,NULL_TYPE.getLeastSupertype(ALL_TYPE));
  assertTypeEquals(createNullableType(STRING_OBJECT_TYPE),NULL_TYPE.getLeastSupertype(STRING_OBJECT_TYPE));
  assertTypeEquals(createNullableType(NUMBER_TYPE),NULL_TYPE.getLeastSupertype(NUMBER_TYPE));
  assertTypeEquals(createNullableType(functionType),NULL_TYPE.getLeastSupertype(functionType));
  assertTypeEquals(createNullableType(OBJECT_TYPE),NULL_TYPE.getLeastSupertype(OBJECT_TYPE));
  assertTypeEquals(createNullableType(DATE_TYPE),NULL_TYPE.getLeastSupertype(DATE_TYPE));
  assertTypeEquals(createNullableType(REGEXP_TYPE),NULL_TYPE.getLeastSupertype(REGEXP_TYPE));
  assertTrue(NULL_TYPE.matchesInt32Context());
  assertTrue(NULL_TYPE.matchesNumberContext());
  assertFalse(NULL_TYPE.matchesObjectContext());
  assertTrue(NULL_TYPE.matchesStringContext());
  assertTrue(NULL_TYPE.matchesUint32Context());
  assertFalse(NULL_TYPE.matchesObjectContext());
  assertEquals(""String_Node_Str"",NULL_TYPE.toString());
  assertTrue(NULL_TYPE.hasDisplayName());
  assertEquals(""String_Node_Str"",NULL_TYPE.getDisplayName());
  Asserts.assertResolvesToSame(NULL_TYPE);
  assertTrue(NULL_TYPE.isSubtype(createUnionType(forwardDeclaredNamedType,NULL_TYPE)));
  assertTypeEquals(NULL_TYPE,NULL_TYPE.getGreatestSubtype(createUnionType(forwardDeclaredNamedType,NULL_TYPE)));
  assertFalse(NULL_TYPE.isNominalConstructor());
  assertTrue(NULL_TYPE.differsFrom(UNKNOWN_TYPE));
}","/** 
 * Tests the behavior of the null type.
 */
public void testNullType() throws Exception {
  assertFalse(NULL_TYPE.isArrayType());
  assertFalse(NULL_TYPE.isBooleanValueType());
  assertFalse(NULL_TYPE.isDateType());
  assertFalse(NULL_TYPE.isEnumElementType());
  assertFalse(NULL_TYPE.isNamedType());
  assertTrue(NULL_TYPE.isNullType());
  assertFalse(NULL_TYPE.isNumber());
  assertFalse(NULL_TYPE.isNumberObjectType());
  assertFalse(NULL_TYPE.isNumberValueType());
  assertFalse(NULL_TYPE.isFunctionPrototypeType());
  assertFalse(NULL_TYPE.isRegexpType());
  assertFalse(NULL_TYPE.isString());
  assertFalse(NULL_TYPE.isStringObjectType());
  assertFalse(NULL_TYPE.isStringValueType());
  assertFalse(NULL_TYPE.isEnumType());
  assertFalse(NULL_TYPE.isUnionType());
  assertFalse(NULL_TYPE.isStruct());
  assertFalse(NULL_TYPE.isDict());
  assertFalse(NULL_TYPE.isAllType());
  assertFalse(NULL_TYPE.isVoidType());
  assertFalse(NULL_TYPE.isConstructor());
  assertFalse(NULL_TYPE.isInstanceType());
  assertNull(NULL_TYPE.autoboxesTo());
  assertFalse(NULL_TYPE.isSubtype(NO_OBJECT_TYPE));
  assertFalse(NULL_TYPE.isSubtype(NO_TYPE));
  assertTrue(NULL_TYPE.isSubtype(NULL_TYPE));
  assertTrue(NULL_TYPE.isSubtype(ALL_TYPE));
  assertFalse(NULL_TYPE.isSubtype(STRING_OBJECT_TYPE));
  assertFalse(NULL_TYPE.isSubtype(NUMBER_TYPE));
  assertFalse(NULL_TYPE.isSubtype(functionType));
  assertFalse(NULL_TYPE.isSubtype(OBJECT_TYPE));
  assertFalse(NULL_TYPE.isSubtype(DATE_TYPE));
  assertFalse(NULL_TYPE.isSubtype(REGEXP_TYPE));
  assertFalse(NULL_TYPE.isSubtype(ARRAY_TYPE));
  assertTrue(NULL_TYPE.isSubtype(UNKNOWN_TYPE));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(NO_OBJECT_TYPE)));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(NO_TYPE)));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(NULL_TYPE)));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(ALL_TYPE)));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(STRING_OBJECT_TYPE)));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(NUMBER_TYPE)));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(functionType)));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(OBJECT_TYPE)));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(DATE_TYPE)));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(REGEXP_TYPE)));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(ARRAY_TYPE)));
  assertFalse(NULL_TYPE.canBeCalled());
  assertCanTestForEqualityWith(NULL_TYPE,NO_TYPE);
  assertCanTestForEqualityWith(NULL_TYPE,NO_OBJECT_TYPE);
  assertCanTestForEqualityWith(NULL_TYPE,ALL_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,ARRAY_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,BOOLEAN_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,BOOLEAN_OBJECT_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,DATE_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,ERROR_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,EVAL_ERROR_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,functionType);
  assertCannotTestForEqualityWith(NULL_TYPE,NULL_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,NUMBER_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,NUMBER_OBJECT_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,OBJECT_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,URI_ERROR_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,RANGE_ERROR_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,REFERENCE_ERROR_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,REGEXP_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,STRING_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,STRING_OBJECT_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,SYNTAX_ERROR_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,TYPE_ERROR_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,VOID_TYPE);
  assertTrue(NULL_TYPE.canTestForShallowEqualityWith(NO_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(DATE_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(ERROR_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(functionType));
  assertTrue(NULL_TYPE.canTestForShallowEqualityWith(NULL_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(STRING_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE));
  assertTrue(NULL_TYPE.canTestForShallowEqualityWith(ALL_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(VOID_TYPE));
  assertTrue(NULL_TYPE.canTestForShallowEqualityWith(createNullableType(STRING_OBJECT_TYPE)));
  assertTypeEquals(NULL_TYPE,NULL_TYPE.getLeastSupertype(NULL_TYPE));
  assertTypeEquals(ALL_TYPE,NULL_TYPE.getLeastSupertype(ALL_TYPE));
  assertTypeEquals(createNullableType(STRING_OBJECT_TYPE),NULL_TYPE.getLeastSupertype(STRING_OBJECT_TYPE));
  assertTypeEquals(createNullableType(NUMBER_TYPE),NULL_TYPE.getLeastSupertype(NUMBER_TYPE));
  assertTypeEquals(createNullableType(functionType),NULL_TYPE.getLeastSupertype(functionType));
  assertTypeEquals(createNullableType(OBJECT_TYPE),NULL_TYPE.getLeastSupertype(OBJECT_TYPE));
  assertTypeEquals(createNullableType(DATE_TYPE),NULL_TYPE.getLeastSupertype(DATE_TYPE));
  assertTypeEquals(createNullableType(REGEXP_TYPE),NULL_TYPE.getLeastSupertype(REGEXP_TYPE));
  assertTrue(NULL_TYPE.matchesInt32Context());
  assertTrue(NULL_TYPE.matchesNumberContext());
  assertFalse(NULL_TYPE.matchesObjectContext());
  assertTrue(NULL_TYPE.matchesStringContext());
  assertTrue(NULL_TYPE.matchesUint32Context());
  assertFalse(NULL_TYPE.matchesObjectContext());
  assertEquals(""String_Node_Str"",NULL_TYPE.toString());
  assertTrue(NULL_TYPE.hasDisplayName());
  assertEquals(""String_Node_Str"",NULL_TYPE.getDisplayName());
  Asserts.assertResolvesToSame(NULL_TYPE);
  assertTrue(NULL_TYPE.isSubtype(createUnionType(forwardDeclaredNamedType,NULL_TYPE)));
  assertTypeEquals(createUnionType(forwardDeclaredNamedType,NULL_TYPE),NULL_TYPE.getGreatestSubtype(createUnionType(forwardDeclaredNamedType,NULL_TYPE)));
  assertFalse(NULL_TYPE.isNominalConstructor());
  assertTrue(NULL_TYPE.differsFrom(UNKNOWN_TYPE));
}",0.9914784831700044
27968,"/** 
 * Resolve the referenced type within the enclosing scope.
 */
@Override JSType resolveInternal(ErrorReporter t,StaticScope<JSType> enclosing){
  boolean resolved=resolveViaRegistry(t,enclosing);
  if (detectImplicitPrototypeCycle()) {
    handleTypeCycle(t);
  }
  if (resolved) {
    super.resolveInternal(t,enclosing);
    finishPropertyContinuations();
    return registry.isLastGeneration() ? getReferencedType() : this;
  }
  resolveViaProperties(t,enclosing);
  if (detectImplicitPrototypeCycle()) {
    handleTypeCycle(t);
  }
  super.resolveInternal(t,enclosing);
  if (isResolved()) {
    finishPropertyContinuations();
  }
  return registry.isLastGeneration() ? getReferencedType() : this;
}","/** 
 * Resolve the referenced type within the enclosing scope.
 */
@Override JSType resolveInternal(ErrorReporter t,StaticScope<JSType> enclosing){
  boolean resolved=resolveViaRegistry(t,enclosing);
  if (detectInheritanceCycle()) {
    handleTypeCycle(t);
  }
  if (resolved) {
    super.resolveInternal(t,enclosing);
    finishPropertyContinuations();
    return registry.isLastGeneration() ? getReferencedType() : this;
  }
  resolveViaProperties(t,enclosing);
  if (detectInheritanceCycle()) {
    handleTypeCycle(t);
  }
  super.resolveInternal(t,enclosing);
  if (isResolved()) {
    finishPropertyContinuations();
  }
  return registry.isLastGeneration() ? getReferencedType() : this;
}",0.4536376604850214
27969,"/** 
 * Detects a cycle in the implicit prototype chain. This method accesses the   {@link #getImplicitPrototype()} method and must therefore beinvoked only after the object is sufficiently initialized to respond to calls to this method.<p> The method is not thread safe.<p>
 * @return True iff an implicit prototype cycle was detected.
 */
final boolean detectImplicitPrototypeCycle(){
  this.visited=true;
  ObjectType p=getImplicitPrototype();
  while (p != null) {
    if (p.visited) {
      return true;
    }
 else {
      p.visited=true;
    }
    p=p.getImplicitPrototype();
  }
  p=this;
  do {
    p.visited=false;
    p=p.getImplicitPrototype();
  }
 while (p != null);
  return false;
}","/** 
 * Detects a cycle in the implicit prototype chain. This method accesses the   {@link #getImplicitPrototype()} method and must therefore beinvoked only after the object is sufficiently initialized to respond to calls to this method.<p>
 * @return True iff an implicit prototype cycle was detected.
 */
final boolean detectImplicitPrototypeCycle(){
  this.visited=true;
  ObjectType p=getImplicitPrototype();
  while (p != null) {
    if (p.visited) {
      return true;
    }
 else {
      p.visited=true;
    }
    p=p.getImplicitPrototype();
  }
  p=this;
  do {
    p.visited=false;
    p=p.getImplicitPrototype();
  }
 while (p != null);
  return false;
}",0.97503671071953
27970,"/** 
 * Remove useless switches and cases.
 */
private Node tryOptimizeSwitch(Node n){
  Preconditions.checkState(n.isSwitch());
  Node defaultCase=tryOptimizeDefaultCase(n);
  if (defaultCase == null) {
    Node next=null;
    Node prev=null;
    for (Node c=n.getFirstChild().getNext(); c != null; c=next) {
      next=c.getNext();
      if (!mayHaveSideEffects(c.getFirstChild()) && isUselessCase(c,prev)) {
        removeCase(n,c);
      }
 else {
        prev=c;
      }
    }
  }
  if (n.hasOneChild()) {
    Node condition=n.removeFirstChild();
    Node parent=n.getParent();
    Node replacement=IR.exprResult(condition).srcref(n);
    parent.replaceChild(n,replacement);
    reportCodeChange();
    return replacement;
  }
  return null;
}","/** 
 * Remove useless switches and cases.
 */
private Node tryOptimizeSwitch(Node n){
  Preconditions.checkState(n.isSwitch());
  Node defaultCase=tryOptimizeDefaultCase(n);
  if (defaultCase == null) {
    Node cond=n.getFirstChild(), prev=null, next=null, cur;
    for (cur=cond.getNext(); cur != null; cur=next) {
      next=cur.getNext();
      if (!mayHaveSideEffects(cur.getFirstChild()) && isUselessCase(cur,prev)) {
        removeCase(n,cur);
      }
 else {
        prev=cur;
      }
    }
    if (NodeUtil.isLiteralValue(cond,false)) {
      Node caseLabel;
      TernaryValue caseMatches=TernaryValue.TRUE;
      for (cur=cond.getNext(); cur != null; cur=next) {
        next=cur.getNext();
        caseLabel=cur.getFirstChild();
        caseMatches=PeepholeFoldConstants.evaluateComparison(Token.SHEQ,cond,caseLabel);
        if (caseMatches == TernaryValue.TRUE) {
          break;
        }
 else         if (caseMatches == TernaryValue.UNKNOWN) {
          break;
        }
 else {
          n.removeChild(cur);
          reportCodeChange();
        }
      }
      if (caseMatches != TernaryValue.UNKNOWN) {
        Node block, lastStm;
        while (cur != null) {
          block=cur.getLastChild();
          lastStm=block.getLastChild();
          cur=cur.getNext();
          if (lastStm.isBreak()) {
            block.removeChild(lastStm);
            reportCodeChange();
            break;
          }
        }
        for (; cur != null; cur=next) {
          next=cur.getNext();
          n.removeChild(cur);
          reportCodeChange();
        }
        cur=cond.getNext();
        if (cur != null && cur.getNext() == null) {
          block=cur.getLastChild();
          if (!(NodeUtil.containsType(block,Token.BREAK,NodeUtil.MATCH_NOT_FUNCTION))) {
            cur.removeChild(block);
            n.getParent().replaceChild(n,block);
            reportCodeChange();
            return block;
          }
        }
      }
    }
  }
  if (n.hasOneChild()) {
    Node condition=n.removeFirstChild();
    Node replacement=IR.exprResult(condition).srcref(n);
    n.getParent().replaceChild(n,replacement);
    reportCodeChange();
    return replacement;
  }
  return null;
}",0.3896984073195527
27971,"public void testOptimizeSwitch(){
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
}","public void testOptimizeSwitch(){
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  fold(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"");
  foldSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  foldSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  foldSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  fold(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  fold(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"");
  foldSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  foldSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
}",0.4275899972519923
27972,"/** 
 * Remove useless switches and cases.
 */
private Node tryOptimizeSwitch(Node n){
  Preconditions.checkState(n.isSwitch());
  Node defaultCase=tryOptimizeDefaultCase(n);
  if (defaultCase == null) {
    Node cond=n.getFirstChild(), prev=null, next=null, cur;
    for (cur=cond.getNext(); cur != null; cur=next) {
      next=cur.getNext();
      if (!mayHaveSideEffects(cur.getFirstChild()) && isUselessCase(cur,prev)) {
        removeCase(n,cur);
      }
 else {
        prev=cur;
      }
    }
    if (NodeUtil.isLiteralValue(cond,false)) {
      Node caseLabel;
      TernaryValue caseMatches=TernaryValue.TRUE;
      for (cur=cond.getNext(); cur != null; cur=next) {
        next=cur.getNext();
        caseLabel=cur.getFirstChild();
        caseMatches=PeepholeFoldConstants.evaluateComparison(Token.SHEQ,cond,caseLabel);
        if (caseMatches == TernaryValue.TRUE) {
          break;
        }
 else         if (caseMatches == TernaryValue.UNKNOWN) {
          break;
        }
 else {
          n.removeChild(cur);
          reportCodeChange();
        }
      }
      if (caseMatches != TernaryValue.UNKNOWN) {
        Node block, lastStm;
        while (cur != null) {
          block=cur.getLastChild();
          lastStm=block.getLastChild();
          cur=cur.getNext();
          if (lastStm.isBreak()) {
            block.removeChild(lastStm);
            reportCodeChange();
            break;
          }
        }
        for (; cur != null; cur=next) {
          next=cur.getNext();
          n.removeChild(cur);
          reportCodeChange();
        }
        cur=cond.getNext();
        if (cur != null && cur.getNext() == null) {
          block=cur.getLastChild();
          if (!(NodeUtil.containsType(block,Token.BREAK,NodeUtil.MATCH_NOT_FUNCTION))) {
            cur.removeChild(block);
            n.getParent().replaceChild(n,block);
            reportCodeChange();
            return block;
          }
        }
      }
    }
  }
  if (n.hasOneChild()) {
    Node condition=n.removeFirstChild();
    Node replacement=IR.exprResult(condition).srcref(n);
    n.getParent().replaceChild(n,replacement);
    reportCodeChange();
    return replacement;
  }
  return null;
}","/** 
 * Remove useless switches and cases.
 */
private Node tryOptimizeSwitch(Node n){
  Preconditions.checkState(n.isSwitch());
  Node defaultCase=tryOptimizeDefaultCase(n);
  if (defaultCase == null) {
    Node cond=n.getFirstChild(), prev=null, next=null, cur;
    for (cur=cond.getNext(); cur != null; cur=next) {
      next=cur.getNext();
      if (!mayHaveSideEffects(cur.getFirstChild()) && isUselessCase(cur,prev)) {
        removeCase(n,cur);
      }
 else {
        prev=cur;
      }
    }
    if (NodeUtil.isLiteralValue(cond,false)) {
      Node caseLabel;
      TernaryValue caseMatches=TernaryValue.TRUE;
      for (cur=cond.getNext(); cur != null; cur=next) {
        next=cur.getNext();
        caseLabel=cur.getFirstChild();
        caseMatches=PeepholeFoldConstants.evaluateComparison(Token.SHEQ,cond,caseLabel);
        if (caseMatches == TernaryValue.TRUE) {
          break;
        }
 else         if (caseMatches == TernaryValue.UNKNOWN) {
          break;
        }
 else {
          n.removeChild(cur);
          reportCodeChange();
        }
      }
      if (caseMatches != TernaryValue.UNKNOWN) {
        Node block, lastStm;
        while (cur != null) {
          block=cur.getLastChild();
          lastStm=block.getLastChild();
          cur=cur.getNext();
          if (lastStm != null && lastStm.isBreak()) {
            block.removeChild(lastStm);
            reportCodeChange();
            break;
          }
        }
        for (; cur != null; cur=next) {
          next=cur.getNext();
          n.removeChild(cur);
          reportCodeChange();
        }
        cur=cond.getNext();
        if (cur != null && cur.getNext() == null) {
          block=cur.getLastChild();
          if (!(NodeUtil.containsType(block,Token.BREAK,NodeUtil.MATCH_NOT_FUNCTION))) {
            cur.removeChild(block);
            n.getParent().replaceChild(n,block);
            reportCodeChange();
            return block;
          }
        }
      }
    }
  }
  if (n.hasOneChild()) {
    Node condition=n.removeFirstChild();
    Node replacement=IR.exprResult(condition).srcref(n);
    n.getParent().replaceChild(n,replacement);
    reportCodeChange();
    return replacement;
  }
  return null;
}",0.9957062146892656
27973,"public void testOptimizeSwitch(){
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  fold(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"");
  foldSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  foldSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  foldSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  fold(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  fold(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"");
  foldSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  foldSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
}","public void testOptimizeSwitch(){
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  fold(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"");
  foldSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  foldSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  foldSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  fold(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  fold(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"");
  foldSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  foldSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  foldSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9813068084376608
27974,"/** 
 * Expect that the first type can be assigned to a symbol of the second type.
 * @param t The node traversal.
 * @param n The node to issue warnings on.
 * @param rightType The type on the RHS of the assign.
 * @param leftType The type of the symbol on the LHS of the assign.
 * @param msg An extra message for the mismatch warning, if necessary.
 * @return True if the types matched, false otherwise.
 */
boolean expectCanAssignTo(NodeTraversal t,Node n,JSType rightType,JSType leftType,String msg){
  if (!rightType.canAssignTo(leftType)) {
    if (bothIntrinsics(rightType,leftType)) {
      registerMismatch(rightType,leftType,null);
    }
 else {
      mismatch(t,n,msg,rightType,leftType);
    }
    return false;
  }
  return true;
}","/** 
 * Expect that the first type can be assigned to a symbol of the second type.
 * @param t The node traversal.
 * @param n The node to issue warnings on.
 * @param rightType The type on the RHS of the assign.
 * @param leftType The type of the symbol on the LHS of the assign.
 * @param msg An extra message for the mismatch warning, if necessary.
 * @return True if the types matched, false otherwise.
 */
boolean expectCanAssignTo(NodeTraversal t,Node n,JSType rightType,JSType leftType,String msg){
  if (!rightType.canAssignTo(leftType)) {
    mismatch(t,n,msg,rightType,leftType);
    return false;
  }
  return true;
}",0.8244719592134013
27975,"/** 
 * Expect that the first type can be assigned to a symbol of the second type.
 * @param t The node traversal.
 * @param n The node to issue warnings on.
 * @param rightType The type on the RHS of the assign.
 * @param leftType The type of the symbol on the LHS of the assign.
 * @param owner The owner of the property being assigned to.
 * @param propName The name of the property being assigned to.
 * @return True if the types matched, false otherwise.
 */
boolean expectCanAssignToPropertyOf(NodeTraversal t,Node n,JSType rightType,JSType leftType,Node owner,String propName){
  if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {
    if (bothIntrinsics(rightType,leftType)) {
      registerMismatch(rightType,leftType,null);
    }
 else {
      JSType ownerType=getJSType(owner);
      if (ownerType.isFunctionPrototypeType()) {
        FunctionType ownerFn=ownerType.toObjectType().getOwnerFunction();
        if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {
          return true;
        }
      }
      mismatch(t,n,""String_Node_Str"" + propName + ""String_Node_Str""+ getReadableJSTypeName(owner,true),rightType,leftType);
    }
    return false;
  }
  return true;
}","/** 
 * Expect that the first type can be assigned to a symbol of the second type.
 * @param t The node traversal.
 * @param n The node to issue warnings on.
 * @param rightType The type on the RHS of the assign.
 * @param leftType The type of the symbol on the LHS of the assign.
 * @param owner The owner of the property being assigned to.
 * @param propName The name of the property being assigned to.
 * @return True if the types matched, false otherwise.
 */
boolean expectCanAssignToPropertyOf(NodeTraversal t,Node n,JSType rightType,JSType leftType,Node owner,String propName){
  if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {
    JSType ownerType=getJSType(owner);
    if (ownerType.isFunctionPrototypeType()) {
      FunctionType ownerFn=ownerType.toObjectType().getOwnerFunction();
      if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {
        return true;
      }
    }
    mismatch(t,n,""String_Node_Str"" + propName + ""String_Node_Str""+ getReadableJSTypeName(owner,true),rightType,leftType);
    return false;
  }
  return true;
}",0.8551783412118608
27976,"/** 
 * A function is a subtype of another if their call methods are related via subtyping and   {@code this} is a subtype of {@code that} with regard tothe prototype chain.
 */
@Override public boolean isSubtype(JSType that){
  if (JSType.isSubtypeHelper(this,that)) {
    return true;
  }
  if (that.isFunctionType()) {
    FunctionType other=that.toMaybeFunctionType();
    if (other.isInterface()) {
      return true;
    }
    if (isInterface()) {
      return false;
    }
    boolean treatThisTypesAsCovariant=isConstructor() || other.isConstructor() || (other.typeOfThis.toObjectType() != null && other.typeOfThis.toObjectType().getConstructor() != null && other.typeOfThis.toObjectType().getConstructor().isInterface())|| other.typeOfThis.isSubtype(this.typeOfThis)|| this.typeOfThis.isSubtype(other.typeOfThis);
    return treatThisTypesAsCovariant && this.call.isSubtype(other.call);
  }
  return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that);
}","/** 
 * A function is a subtype of another if their call methods are related via subtyping and   {@code this} is a subtype of {@code that} with regard tothe prototype chain.
 */
@Override public boolean isSubtype(JSType that){
  if (JSType.isSubtypeHelper(this,that)) {
    return true;
  }
  if (that.isFunctionType()) {
    FunctionType other=that.toMaybeFunctionType();
    if (other.isInterface()) {
      return true;
    }
    if (isInterface()) {
      return false;
    }
    boolean treatThisTypesAsCovariant=(other.typeOfThis.toObjectType() != null && other.typeOfThis.toObjectType().getConstructor() != null && other.typeOfThis.toObjectType().getConstructor().isInterface()) || other.typeOfThis.isSubtype(this.typeOfThis) || this.typeOfThis.isSubtype(other.typeOfThis);
    return treatThisTypesAsCovariant && this.call.isSubtype(other.call);
  }
  return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that);
}",0.8153200419727177
27977,"public void testTypeRedefinition() throws Exception {
  testTypes(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
}","public void testTypeRedefinition() throws Exception {
  testClosureTypesMultipleWarnings(""String_Node_Str"" + ""String_Node_Str"",Lists.newArrayList(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""));
}",0.5524296675191815
27978,"private void testClosureTypesMultipleWarnings(String js,List<String> descriptions) throws Exception {
  Node n=compiler.parseTestCode(js);
  Node externs=new Node(Token.BLOCK);
  Node externAndJsRoot=new Node(Token.BLOCK,externs,n);
  externAndJsRoot.setIsSyntheticBlock(true);
  assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(compiler.getErrors()),0,compiler.getErrorCount());
  new ProcessClosurePrimitives(compiler,null,CheckLevel.ERROR).process(null,n);
  CodingConvention convention=compiler.getCodingConvention();
  new TypeCheck(compiler,new ClosureReverseAbstractInterpreter(convention,registry).append(new SemanticReverseAbstractInterpreter(convention,registry)).getFirst(),registry).processForTesting(null,n);
  assertEquals(0,compiler.getErrorCount());
  if (descriptions == null) {
    assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(compiler.getWarnings()),0,compiler.getWarningCount());
  }
 else {
    assertEquals(descriptions.size(),compiler.getWarningCount());
    for (int i=0; i < descriptions.size(); i++) {
      assertEquals(descriptions.get(i),compiler.getWarnings()[i].description);
    }
  }
}","private void testClosureTypesMultipleWarnings(String js,List<String> descriptions) throws Exception {
  Node n=compiler.parseTestCode(js);
  Node externs=new Node(Token.BLOCK);
  Node externAndJsRoot=new Node(Token.BLOCK,externs,n);
  externAndJsRoot.setIsSyntheticBlock(true);
  assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(compiler.getErrors()),0,compiler.getErrorCount());
  new ProcessClosurePrimitives(compiler,null,CheckLevel.ERROR).process(null,n);
  CodingConvention convention=compiler.getCodingConvention();
  new TypeCheck(compiler,new ClosureReverseAbstractInterpreter(convention,registry).append(new SemanticReverseAbstractInterpreter(convention,registry)).getFirst(),registry).processForTesting(null,n);
  assertEquals(0,compiler.getErrorCount());
  if (descriptions == null) {
    assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(compiler.getWarnings()),0,compiler.getWarningCount());
  }
 else {
    assertEquals(descriptions.size(),compiler.getWarningCount());
    Set<String> actualWarningDescriptions=Sets.newHashSet();
    for (int i=0; i < descriptions.size(); i++) {
      actualWarningDescriptions.add(compiler.getWarnings()[i].description);
    }
    assertEquals(Sets.newHashSet(descriptions),actualWarningDescriptions);
  }
}",0.8975091874234381
27979,"public void testTypeRedefinition() throws Exception {
  testTypes(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
}","public void testTypeRedefinition() throws Exception {
  testClosureTypesMultipleWarnings(""String_Node_Str"" + ""String_Node_Str"",Lists.newArrayList(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""));
}",0.5524296675191815
27980,"private void testClosureTypesMultipleWarnings(String js,List<String> descriptions) throws Exception {
  Node n=compiler.parseTestCode(js);
  Node externs=new Node(Token.BLOCK);
  Node externAndJsRoot=new Node(Token.BLOCK,externs,n);
  externAndJsRoot.setIsSyntheticBlock(true);
  assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(compiler.getErrors()),0,compiler.getErrorCount());
  new ProcessClosurePrimitives(compiler,null,CheckLevel.ERROR).process(null,n);
  CodingConvention convention=compiler.getCodingConvention();
  new TypeCheck(compiler,new ClosureReverseAbstractInterpreter(convention,registry).append(new SemanticReverseAbstractInterpreter(convention,registry)).getFirst(),registry).processForTesting(null,n);
  assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(compiler.getErrors()),0,compiler.getErrorCount());
  if (descriptions == null) {
    assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(compiler.getWarnings()),0,compiler.getWarningCount());
  }
 else {
    assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(compiler.getWarnings()),descriptions.size(),compiler.getWarningCount());
    for (int i=0; i < descriptions.size(); i++) {
      assertEquals(descriptions.get(i),compiler.getWarnings()[i].description);
    }
  }
}","private void testClosureTypesMultipleWarnings(String js,List<String> descriptions) throws Exception {
  Node n=compiler.parseTestCode(js);
  Node externs=new Node(Token.BLOCK);
  Node externAndJsRoot=new Node(Token.BLOCK,externs,n);
  externAndJsRoot.setIsSyntheticBlock(true);
  assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(compiler.getErrors()),0,compiler.getErrorCount());
  new ProcessClosurePrimitives(compiler,null,CheckLevel.ERROR).process(null,n);
  CodingConvention convention=compiler.getCodingConvention();
  new TypeCheck(compiler,new ClosureReverseAbstractInterpreter(convention,registry).append(new SemanticReverseAbstractInterpreter(convention,registry)).getFirst(),registry).processForTesting(null,n);
  assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(compiler.getErrors()),0,compiler.getErrorCount());
  if (descriptions == null) {
    assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(compiler.getWarnings()),0,compiler.getWarningCount());
  }
 else {
    assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(compiler.getWarnings()),descriptions.size(),compiler.getWarningCount());
    Set<String> actualWarningDescriptions=Sets.newHashSet();
    for (int i=0; i < descriptions.size(); i++) {
      actualWarningDescriptions.add(compiler.getWarnings()[i].description);
    }
    assertEquals(Sets.newHashSet(descriptions),actualWarningDescriptions);
  }
}",0.9089590134203844
27981,"/** 
 * @return True if our parameter spec is equal to {@code that}'s parameter spec.
 */
boolean hasEqualParameters(ArrowType that,EquivalenceMethod eqMethod){
  Node thisParam=parameters.getFirstChild();
  Node otherParam=that.parameters.getFirstChild();
  while (thisParam != null && otherParam != null) {
    JSType thisParamType=thisParam.getJSType();
    JSType otherParamType=otherParam.getJSType();
    if (thisParamType != null) {
      if (otherParamType != null && !thisParamType.checkEquivalenceHelper(otherParamType,eqMethod)) {
        return false;
      }
    }
 else {
      if (otherParamType != null) {
        return false;
      }
    }
    thisParam=thisParam.getNext();
    otherParam=otherParam.getNext();
  }
  return thisParam == otherParam;
}","/** 
 * @return True if our parameter spec is equal to {@code that}'s parameter spec.
 */
boolean hasEqualParameters(ArrowType that,EquivalenceMethod eqMethod){
  Node thisParam=parameters.getFirstChild();
  Node otherParam=that.parameters.getFirstChild();
  while (thisParam != null && otherParam != null) {
    JSType thisParamType=thisParam.getJSType();
    JSType otherParamType=otherParam.getJSType();
    if (thisParamType != null) {
      if (otherParamType != null && !thisParamType.checkEquivalenceHelper(otherParamType,eqMethod)) {
        return false;
      }
    }
 else {
      if (otherParamType != null) {
        return false;
      }
    }
    if (thisParam.isOptionalArg() != otherParam.isOptionalArg()) {
      return false;
    }
    if (thisParam.isVarArgs() != otherParam.isVarArgs()) {
      return false;
    }
    thisParam=thisParam.getNext();
    otherParam=otherParam.getNext();
  }
  return thisParam == otherParam;
}",0.872960372960373
27982,"private void initializeBuiltInTypes(){
  BooleanType BOOLEAN_TYPE=new BooleanType(this);
  registerNativeType(JSTypeNative.BOOLEAN_TYPE,BOOLEAN_TYPE);
  NullType NULL_TYPE=new NullType(this);
  registerNativeType(JSTypeNative.NULL_TYPE,NULL_TYPE);
  NumberType NUMBER_TYPE=new NumberType(this);
  registerNativeType(JSTypeNative.NUMBER_TYPE,NUMBER_TYPE);
  StringType STRING_TYPE=new StringType(this);
  registerNativeType(JSTypeNative.STRING_TYPE,STRING_TYPE);
  UnknownType UNKNOWN_TYPE=new UnknownType(this,false);
  registerNativeType(JSTypeNative.UNKNOWN_TYPE,UNKNOWN_TYPE);
  UnknownType checkedUnknownType=new UnknownType(this,true);
  registerNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE,checkedUnknownType);
  VoidType VOID_TYPE=new VoidType(this);
  registerNativeType(JSTypeNative.VOID_TYPE,VOID_TYPE);
  AllType ALL_TYPE=new AllType(this);
  registerNativeType(JSTypeNative.ALL_TYPE,ALL_TYPE);
  PrototypeObjectType TOP_LEVEL_PROTOTYPE=new PrototypeObjectType(this,null,null,true,null,null);
  registerNativeType(JSTypeNative.TOP_LEVEL_PROTOTYPE,TOP_LEVEL_PROTOTYPE);
  FunctionType OBJECT_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createOptionalParameters(ALL_TYPE),UNKNOWN_TYPE),null,null,true,true);
  OBJECT_FUNCTION_TYPE.setPrototype(TOP_LEVEL_PROTOTYPE,null);
  registerNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE,OBJECT_FUNCTION_TYPE);
  ObjectType OBJECT_TYPE=OBJECT_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.OBJECT_TYPE,OBJECT_TYPE);
  ObjectType OBJECT_PROTOTYPE=OBJECT_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.OBJECT_PROTOTYPE,OBJECT_PROTOTYPE);
  FunctionType FUNCTION_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createParametersWithVarArgs(ALL_TYPE),UNKNOWN_TYPE),null,null,true,true);
  FUNCTION_FUNCTION_TYPE.setPrototypeBasedOn(OBJECT_TYPE);
  registerNativeType(JSTypeNative.FUNCTION_FUNCTION_TYPE,FUNCTION_FUNCTION_TYPE);
  ObjectType FUNCTION_PROTOTYPE=FUNCTION_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.FUNCTION_PROTOTYPE,FUNCTION_PROTOTYPE);
  NoType NO_TYPE=new NoType(this);
  registerNativeType(JSTypeNative.NO_TYPE,NO_TYPE);
  NoObjectType NO_OBJECT_TYPE=new NoObjectType(this);
  registerNativeType(JSTypeNative.NO_OBJECT_TYPE,NO_OBJECT_TYPE);
  NoObjectType NO_RESOLVED_TYPE=new NoResolvedType(this);
  registerNativeType(JSTypeNative.NO_RESOLVED_TYPE,NO_RESOLVED_TYPE);
  FunctionType ARRAY_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createParametersWithVarArgs(ALL_TYPE),null),null,null,true,true);
  ARRAY_FUNCTION_TYPE.getInternalArrowType().returnType=ARRAY_FUNCTION_TYPE.getInstanceType();
  ObjectType arrayPrototype=ARRAY_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.ARRAY_FUNCTION_TYPE,ARRAY_FUNCTION_TYPE);
  ObjectType ARRAY_TYPE=ARRAY_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.ARRAY_TYPE,ARRAY_TYPE);
  FunctionType BOOLEAN_OBJECT_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createParameters(false,ALL_TYPE),BOOLEAN_TYPE),null,null,true,true);
  ObjectType booleanPrototype=BOOLEAN_OBJECT_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE,BOOLEAN_OBJECT_FUNCTION_TYPE);
  ObjectType BOOLEAN_OBJECT_TYPE=BOOLEAN_OBJECT_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.BOOLEAN_OBJECT_TYPE,BOOLEAN_OBJECT_TYPE);
  FunctionType DATE_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createOptionalParameters(UNKNOWN_TYPE,UNKNOWN_TYPE,UNKNOWN_TYPE,UNKNOWN_TYPE,UNKNOWN_TYPE,UNKNOWN_TYPE,UNKNOWN_TYPE),STRING_TYPE),null,null,true,true);
  ObjectType datePrototype=DATE_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.DATE_FUNCTION_TYPE,DATE_FUNCTION_TYPE);
  ObjectType DATE_TYPE=DATE_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.DATE_TYPE,DATE_TYPE);
  FunctionType ERROR_FUNCTION_TYPE=new ErrorFunctionType(this,""String_Node_Str"");
  registerNativeType(JSTypeNative.ERROR_FUNCTION_TYPE,ERROR_FUNCTION_TYPE);
  ObjectType ERROR_TYPE=ERROR_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.ERROR_TYPE,ERROR_TYPE);
  FunctionType EVAL_ERROR_FUNCTION_TYPE=new ErrorFunctionType(this,""String_Node_Str"");
  EVAL_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);
  registerNativeType(JSTypeNative.EVAL_ERROR_FUNCTION_TYPE,EVAL_ERROR_FUNCTION_TYPE);
  ObjectType EVAL_ERROR_TYPE=EVAL_ERROR_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.EVAL_ERROR_TYPE,EVAL_ERROR_TYPE);
  FunctionType RANGE_ERROR_FUNCTION_TYPE=new ErrorFunctionType(this,""String_Node_Str"");
  RANGE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);
  registerNativeType(JSTypeNative.RANGE_ERROR_FUNCTION_TYPE,RANGE_ERROR_FUNCTION_TYPE);
  ObjectType RANGE_ERROR_TYPE=RANGE_ERROR_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.RANGE_ERROR_TYPE,RANGE_ERROR_TYPE);
  FunctionType REFERENCE_ERROR_FUNCTION_TYPE=new ErrorFunctionType(this,""String_Node_Str"");
  REFERENCE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);
  registerNativeType(JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE,REFERENCE_ERROR_FUNCTION_TYPE);
  ObjectType REFERENCE_ERROR_TYPE=REFERENCE_ERROR_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.REFERENCE_ERROR_TYPE,REFERENCE_ERROR_TYPE);
  FunctionType SYNTAX_ERROR_FUNCTION_TYPE=new ErrorFunctionType(this,""String_Node_Str"");
  SYNTAX_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);
  registerNativeType(JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE,SYNTAX_ERROR_FUNCTION_TYPE);
  ObjectType SYNTAX_ERROR_TYPE=SYNTAX_ERROR_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.SYNTAX_ERROR_TYPE,SYNTAX_ERROR_TYPE);
  FunctionType TYPE_ERROR_FUNCTION_TYPE=new ErrorFunctionType(this,""String_Node_Str"");
  TYPE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);
  registerNativeType(JSTypeNative.TYPE_ERROR_FUNCTION_TYPE,TYPE_ERROR_FUNCTION_TYPE);
  ObjectType TYPE_ERROR_TYPE=TYPE_ERROR_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.TYPE_ERROR_TYPE,TYPE_ERROR_TYPE);
  FunctionType URI_ERROR_FUNCTION_TYPE=new ErrorFunctionType(this,""String_Node_Str"");
  URI_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);
  registerNativeType(JSTypeNative.URI_ERROR_FUNCTION_TYPE,URI_ERROR_FUNCTION_TYPE);
  ObjectType URI_ERROR_TYPE=URI_ERROR_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.URI_ERROR_TYPE,URI_ERROR_TYPE);
  FunctionType NUMBER_OBJECT_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createParameters(false,ALL_TYPE),NUMBER_TYPE),null,null,true,true);
  ObjectType numberPrototype=NUMBER_OBJECT_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE,NUMBER_OBJECT_FUNCTION_TYPE);
  ObjectType NUMBER_OBJECT_TYPE=NUMBER_OBJECT_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.NUMBER_OBJECT_TYPE,NUMBER_OBJECT_TYPE);
  FunctionType REGEXP_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createOptionalParameters(ALL_TYPE,ALL_TYPE)),null,null,true,true);
  REGEXP_FUNCTION_TYPE.getInternalArrowType().returnType=REGEXP_FUNCTION_TYPE.getInstanceType();
  ObjectType regexpPrototype=REGEXP_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.REGEXP_FUNCTION_TYPE,REGEXP_FUNCTION_TYPE);
  ObjectType REGEXP_TYPE=REGEXP_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.REGEXP_TYPE,REGEXP_TYPE);
  FunctionType STRING_OBJECT_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createParameters(false,ALL_TYPE),STRING_TYPE),null,null,true,true);
  ObjectType stringPrototype=STRING_OBJECT_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.STRING_OBJECT_FUNCTION_TYPE,STRING_OBJECT_FUNCTION_TYPE);
  ObjectType STRING_OBJECT_TYPE=STRING_OBJECT_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.STRING_OBJECT_TYPE,STRING_OBJECT_TYPE);
  JSType NULL_VOID=createUnionType(NULL_TYPE,VOID_TYPE);
  registerNativeType(JSTypeNative.NULL_VOID,NULL_VOID);
  JSType OBJECT_NUMBER_STRING=createUnionType(OBJECT_TYPE,NUMBER_TYPE,STRING_TYPE);
  registerNativeType(JSTypeNative.OBJECT_NUMBER_STRING,OBJECT_NUMBER_STRING);
  JSType OBJECT_NUMBER_STRING_BOOLEAN=createUnionType(OBJECT_TYPE,NUMBER_TYPE,STRING_TYPE,BOOLEAN_TYPE);
  registerNativeType(JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN,OBJECT_NUMBER_STRING_BOOLEAN);
  JSType NUMBER_STRING_BOOLEAN=createUnionType(NUMBER_TYPE,STRING_TYPE,BOOLEAN_TYPE);
  registerNativeType(JSTypeNative.NUMBER_STRING_BOOLEAN,NUMBER_STRING_BOOLEAN);
  JSType NUMBER_STRING=createUnionType(NUMBER_TYPE,STRING_TYPE);
  registerNativeType(JSTypeNative.NUMBER_STRING,NUMBER_STRING);
  JSType STRING_VALUE_OR_OBJECT_TYPE=createUnionType(STRING_OBJECT_TYPE,STRING_TYPE);
  registerNativeType(JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE,STRING_VALUE_OR_OBJECT_TYPE);
  JSType NUMBER_VALUE_OR_OBJECT_TYPE=createUnionType(NUMBER_OBJECT_TYPE,NUMBER_TYPE);
  registerNativeType(JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE,NUMBER_VALUE_OR_OBJECT_TYPE);
  FunctionType U2U_FUNCTION_TYPE=createFunctionType(UNKNOWN_TYPE,true,UNKNOWN_TYPE);
  registerNativeType(JSTypeNative.U2U_FUNCTION_TYPE,U2U_FUNCTION_TYPE);
  FunctionType U2U_CONSTRUCTOR_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createParametersWithVarArgs(UNKNOWN_TYPE),UNKNOWN_TYPE),UNKNOWN_TYPE,null,true,true){
    private static final long serialVersionUID=1L;
    @Override public FunctionType getConstructor(){
      return registry.getNativeFunctionType(JSTypeNative.FUNCTION_FUNCTION_TYPE);
    }
  }
;
  registerNativeType(JSTypeNative.U2U_CONSTRUCTOR_TYPE,U2U_CONSTRUCTOR_TYPE);
  registerNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE,U2U_CONSTRUCTOR_TYPE);
  FUNCTION_FUNCTION_TYPE.setInstanceType(U2U_CONSTRUCTOR_TYPE);
  U2U_CONSTRUCTOR_TYPE.setImplicitPrototype(FUNCTION_PROTOTYPE);
  FunctionType LEAST_FUNCTION_TYPE=createNativeFunctionTypeWithVarArgs(NO_TYPE,ALL_TYPE);
  registerNativeType(JSTypeNative.LEAST_FUNCTION_TYPE,LEAST_FUNCTION_TYPE);
  FunctionType GLOBAL_THIS_CTOR=new FunctionType(this,""String_Node_Str"",null,createArrowType(createParameters(false,ALL_TYPE),NUMBER_TYPE),null,null,true,true);
  ObjectType GLOBAL_THIS=GLOBAL_THIS_CTOR.getInstanceType();
  registerNativeType(JSTypeNative.GLOBAL_THIS,GLOBAL_THIS);
  FunctionType GREATEST_FUNCTION_TYPE=createNativeFunctionTypeWithVarArgs(ALL_TYPE,NO_TYPE);
  registerNativeType(JSTypeNative.GREATEST_FUNCTION_TYPE,GREATEST_FUNCTION_TYPE);
  registerPropertyOnType(""String_Node_Str"",OBJECT_FUNCTION_TYPE);
}","private void initializeBuiltInTypes(){
  BooleanType BOOLEAN_TYPE=new BooleanType(this);
  registerNativeType(JSTypeNative.BOOLEAN_TYPE,BOOLEAN_TYPE);
  NullType NULL_TYPE=new NullType(this);
  registerNativeType(JSTypeNative.NULL_TYPE,NULL_TYPE);
  NumberType NUMBER_TYPE=new NumberType(this);
  registerNativeType(JSTypeNative.NUMBER_TYPE,NUMBER_TYPE);
  StringType STRING_TYPE=new StringType(this);
  registerNativeType(JSTypeNative.STRING_TYPE,STRING_TYPE);
  UnknownType UNKNOWN_TYPE=new UnknownType(this,false);
  registerNativeType(JSTypeNative.UNKNOWN_TYPE,UNKNOWN_TYPE);
  UnknownType checkedUnknownType=new UnknownType(this,true);
  registerNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE,checkedUnknownType);
  VoidType VOID_TYPE=new VoidType(this);
  registerNativeType(JSTypeNative.VOID_TYPE,VOID_TYPE);
  AllType ALL_TYPE=new AllType(this);
  registerNativeType(JSTypeNative.ALL_TYPE,ALL_TYPE);
  PrototypeObjectType TOP_LEVEL_PROTOTYPE=new PrototypeObjectType(this,null,null,true,null,null);
  registerNativeType(JSTypeNative.TOP_LEVEL_PROTOTYPE,TOP_LEVEL_PROTOTYPE);
  FunctionType OBJECT_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createOptionalParameters(ALL_TYPE),UNKNOWN_TYPE),null,null,true,true);
  OBJECT_FUNCTION_TYPE.setPrototype(TOP_LEVEL_PROTOTYPE,null);
  registerNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE,OBJECT_FUNCTION_TYPE);
  ObjectType OBJECT_TYPE=OBJECT_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.OBJECT_TYPE,OBJECT_TYPE);
  ObjectType OBJECT_PROTOTYPE=OBJECT_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.OBJECT_PROTOTYPE,OBJECT_PROTOTYPE);
  FunctionType FUNCTION_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createParametersWithVarArgs(ALL_TYPE),UNKNOWN_TYPE),null,null,true,true);
  FUNCTION_FUNCTION_TYPE.setPrototypeBasedOn(OBJECT_TYPE);
  registerNativeType(JSTypeNative.FUNCTION_FUNCTION_TYPE,FUNCTION_FUNCTION_TYPE);
  ObjectType FUNCTION_PROTOTYPE=FUNCTION_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.FUNCTION_PROTOTYPE,FUNCTION_PROTOTYPE);
  NoType NO_TYPE=new NoType(this);
  registerNativeType(JSTypeNative.NO_TYPE,NO_TYPE);
  NoObjectType NO_OBJECT_TYPE=new NoObjectType(this);
  registerNativeType(JSTypeNative.NO_OBJECT_TYPE,NO_OBJECT_TYPE);
  NoObjectType NO_RESOLVED_TYPE=new NoResolvedType(this);
  registerNativeType(JSTypeNative.NO_RESOLVED_TYPE,NO_RESOLVED_TYPE);
  FunctionType ARRAY_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createParametersWithVarArgs(ALL_TYPE),null),null,null,true,true);
  ARRAY_FUNCTION_TYPE.getInternalArrowType().returnType=ARRAY_FUNCTION_TYPE.getInstanceType();
  ObjectType arrayPrototype=ARRAY_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.ARRAY_FUNCTION_TYPE,ARRAY_FUNCTION_TYPE);
  ObjectType ARRAY_TYPE=ARRAY_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.ARRAY_TYPE,ARRAY_TYPE);
  FunctionType BOOLEAN_OBJECT_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createOptionalParameters(ALL_TYPE),BOOLEAN_TYPE),null,null,true,true);
  ObjectType booleanPrototype=BOOLEAN_OBJECT_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE,BOOLEAN_OBJECT_FUNCTION_TYPE);
  ObjectType BOOLEAN_OBJECT_TYPE=BOOLEAN_OBJECT_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.BOOLEAN_OBJECT_TYPE,BOOLEAN_OBJECT_TYPE);
  FunctionType DATE_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createOptionalParameters(UNKNOWN_TYPE,UNKNOWN_TYPE,UNKNOWN_TYPE,UNKNOWN_TYPE,UNKNOWN_TYPE,UNKNOWN_TYPE,UNKNOWN_TYPE),STRING_TYPE),null,null,true,true);
  ObjectType datePrototype=DATE_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.DATE_FUNCTION_TYPE,DATE_FUNCTION_TYPE);
  ObjectType DATE_TYPE=DATE_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.DATE_TYPE,DATE_TYPE);
  FunctionType ERROR_FUNCTION_TYPE=new ErrorFunctionType(this,""String_Node_Str"");
  registerNativeType(JSTypeNative.ERROR_FUNCTION_TYPE,ERROR_FUNCTION_TYPE);
  ObjectType ERROR_TYPE=ERROR_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.ERROR_TYPE,ERROR_TYPE);
  FunctionType EVAL_ERROR_FUNCTION_TYPE=new ErrorFunctionType(this,""String_Node_Str"");
  EVAL_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);
  registerNativeType(JSTypeNative.EVAL_ERROR_FUNCTION_TYPE,EVAL_ERROR_FUNCTION_TYPE);
  ObjectType EVAL_ERROR_TYPE=EVAL_ERROR_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.EVAL_ERROR_TYPE,EVAL_ERROR_TYPE);
  FunctionType RANGE_ERROR_FUNCTION_TYPE=new ErrorFunctionType(this,""String_Node_Str"");
  RANGE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);
  registerNativeType(JSTypeNative.RANGE_ERROR_FUNCTION_TYPE,RANGE_ERROR_FUNCTION_TYPE);
  ObjectType RANGE_ERROR_TYPE=RANGE_ERROR_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.RANGE_ERROR_TYPE,RANGE_ERROR_TYPE);
  FunctionType REFERENCE_ERROR_FUNCTION_TYPE=new ErrorFunctionType(this,""String_Node_Str"");
  REFERENCE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);
  registerNativeType(JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE,REFERENCE_ERROR_FUNCTION_TYPE);
  ObjectType REFERENCE_ERROR_TYPE=REFERENCE_ERROR_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.REFERENCE_ERROR_TYPE,REFERENCE_ERROR_TYPE);
  FunctionType SYNTAX_ERROR_FUNCTION_TYPE=new ErrorFunctionType(this,""String_Node_Str"");
  SYNTAX_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);
  registerNativeType(JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE,SYNTAX_ERROR_FUNCTION_TYPE);
  ObjectType SYNTAX_ERROR_TYPE=SYNTAX_ERROR_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.SYNTAX_ERROR_TYPE,SYNTAX_ERROR_TYPE);
  FunctionType TYPE_ERROR_FUNCTION_TYPE=new ErrorFunctionType(this,""String_Node_Str"");
  TYPE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);
  registerNativeType(JSTypeNative.TYPE_ERROR_FUNCTION_TYPE,TYPE_ERROR_FUNCTION_TYPE);
  ObjectType TYPE_ERROR_TYPE=TYPE_ERROR_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.TYPE_ERROR_TYPE,TYPE_ERROR_TYPE);
  FunctionType URI_ERROR_FUNCTION_TYPE=new ErrorFunctionType(this,""String_Node_Str"");
  URI_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);
  registerNativeType(JSTypeNative.URI_ERROR_FUNCTION_TYPE,URI_ERROR_FUNCTION_TYPE);
  ObjectType URI_ERROR_TYPE=URI_ERROR_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.URI_ERROR_TYPE,URI_ERROR_TYPE);
  FunctionType NUMBER_OBJECT_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createOptionalParameters(ALL_TYPE),NUMBER_TYPE),null,null,true,true);
  ObjectType numberPrototype=NUMBER_OBJECT_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE,NUMBER_OBJECT_FUNCTION_TYPE);
  ObjectType NUMBER_OBJECT_TYPE=NUMBER_OBJECT_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.NUMBER_OBJECT_TYPE,NUMBER_OBJECT_TYPE);
  FunctionType REGEXP_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createOptionalParameters(ALL_TYPE,ALL_TYPE)),null,null,true,true);
  REGEXP_FUNCTION_TYPE.getInternalArrowType().returnType=REGEXP_FUNCTION_TYPE.getInstanceType();
  ObjectType regexpPrototype=REGEXP_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.REGEXP_FUNCTION_TYPE,REGEXP_FUNCTION_TYPE);
  ObjectType REGEXP_TYPE=REGEXP_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.REGEXP_TYPE,REGEXP_TYPE);
  FunctionType STRING_OBJECT_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createOptionalParameters(ALL_TYPE),STRING_TYPE),null,null,true,true);
  ObjectType stringPrototype=STRING_OBJECT_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.STRING_OBJECT_FUNCTION_TYPE,STRING_OBJECT_FUNCTION_TYPE);
  ObjectType STRING_OBJECT_TYPE=STRING_OBJECT_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.STRING_OBJECT_TYPE,STRING_OBJECT_TYPE);
  JSType NULL_VOID=createUnionType(NULL_TYPE,VOID_TYPE);
  registerNativeType(JSTypeNative.NULL_VOID,NULL_VOID);
  JSType OBJECT_NUMBER_STRING=createUnionType(OBJECT_TYPE,NUMBER_TYPE,STRING_TYPE);
  registerNativeType(JSTypeNative.OBJECT_NUMBER_STRING,OBJECT_NUMBER_STRING);
  JSType OBJECT_NUMBER_STRING_BOOLEAN=createUnionType(OBJECT_TYPE,NUMBER_TYPE,STRING_TYPE,BOOLEAN_TYPE);
  registerNativeType(JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN,OBJECT_NUMBER_STRING_BOOLEAN);
  JSType NUMBER_STRING_BOOLEAN=createUnionType(NUMBER_TYPE,STRING_TYPE,BOOLEAN_TYPE);
  registerNativeType(JSTypeNative.NUMBER_STRING_BOOLEAN,NUMBER_STRING_BOOLEAN);
  JSType NUMBER_STRING=createUnionType(NUMBER_TYPE,STRING_TYPE);
  registerNativeType(JSTypeNative.NUMBER_STRING,NUMBER_STRING);
  JSType STRING_VALUE_OR_OBJECT_TYPE=createUnionType(STRING_OBJECT_TYPE,STRING_TYPE);
  registerNativeType(JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE,STRING_VALUE_OR_OBJECT_TYPE);
  JSType NUMBER_VALUE_OR_OBJECT_TYPE=createUnionType(NUMBER_OBJECT_TYPE,NUMBER_TYPE);
  registerNativeType(JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE,NUMBER_VALUE_OR_OBJECT_TYPE);
  FunctionType U2U_FUNCTION_TYPE=createFunctionType(UNKNOWN_TYPE,true,UNKNOWN_TYPE);
  registerNativeType(JSTypeNative.U2U_FUNCTION_TYPE,U2U_FUNCTION_TYPE);
  FunctionType U2U_CONSTRUCTOR_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createParametersWithVarArgs(UNKNOWN_TYPE),UNKNOWN_TYPE),UNKNOWN_TYPE,null,true,true){
    private static final long serialVersionUID=1L;
    @Override public FunctionType getConstructor(){
      return registry.getNativeFunctionType(JSTypeNative.FUNCTION_FUNCTION_TYPE);
    }
  }
;
  registerNativeType(JSTypeNative.U2U_CONSTRUCTOR_TYPE,U2U_CONSTRUCTOR_TYPE);
  registerNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE,U2U_CONSTRUCTOR_TYPE);
  FUNCTION_FUNCTION_TYPE.setInstanceType(U2U_CONSTRUCTOR_TYPE);
  U2U_CONSTRUCTOR_TYPE.setImplicitPrototype(FUNCTION_PROTOTYPE);
  FunctionType LEAST_FUNCTION_TYPE=createNativeFunctionTypeWithVarArgs(NO_TYPE,ALL_TYPE);
  registerNativeType(JSTypeNative.LEAST_FUNCTION_TYPE,LEAST_FUNCTION_TYPE);
  FunctionType GLOBAL_THIS_CTOR=new FunctionType(this,""String_Node_Str"",null,createArrowType(createParameters(false,ALL_TYPE),NUMBER_TYPE),null,null,true,true);
  ObjectType GLOBAL_THIS=GLOBAL_THIS_CTOR.getInstanceType();
  registerNativeType(JSTypeNative.GLOBAL_THIS,GLOBAL_THIS);
  FunctionType GREATEST_FUNCTION_TYPE=createNativeFunctionTypeWithVarArgs(ALL_TYPE,NO_TYPE);
  registerNativeType(JSTypeNative.GREATEST_FUNCTION_TYPE,GREATEST_FUNCTION_TYPE);
  registerPropertyOnType(""String_Node_Str"",OBJECT_FUNCTION_TYPE);
}",0.998036282027305
27983,"public void testGetElem(){
  testSame(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",null);
  assertType(""String_Node_Str"",getType(""String_Node_Str""));
  assertType(""String_Node_Str"",getType(""String_Node_Str""));
  assertType(""String_Node_Str"",getType(""String_Node_Str""));
  testSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  assertType(""String_Node_Str"",getType(""String_Node_Str""));
}","public void testGetElem(){
  testSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",null);
  assertType(""String_Node_Str"",getType(""String_Node_Str""));
  assertType(""String_Node_Str"",getType(""String_Node_Str""));
  assertType(""String_Node_Str"",getType(""String_Node_Str""));
  testSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  assertType(""String_Node_Str"",getType(""String_Node_Str""));
}",0.9305354558610708
27984,"public void testParseOptionalModifier() throws Exception {
  JSDocInfo info=parse(""String_Node_Str"");
  assertTypeEquals(registry.createFunctionType(UNKNOWN_TYPE,createUnionType(VOID_TYPE,NUMBER_TYPE)),info.getType());
}","public void testParseOptionalModifier() throws Exception {
  JSDocInfo info=parse(""String_Node_Str"");
  assertTypeEquals(registry.createFunctionType(UNKNOWN_TYPE,registry.createOptionalParameters(NUMBER_TYPE)),info.getType());
}",0.8705357142857143
27985,"/** 
 * Computes the subset of   {@code this} and {@code that} types if equalityis observed. If a value  {@code v1} of type {@code null} is equal to a value{@code v2} of type {@code (undefined,number)}, we can infer that the type of   {@code v1} is {@code null} and the type of {@code v2} is{@code undefined}.
 * @return a pair containing the restricted type of {@code this} as the firstcomponent and the restricted type of  {@code that} as the secondelement. The returned pair is never  {@code null} even though itscomponents may be  {@code null}
 */
public TypePair getTypesUnderEquality(JSType that){
  if (that.isUnionType()) {
    TypePair p=that.toMaybeUnionType().getTypesUnderEquality(this);
    return new TypePair(p.typeB,p.typeA);
  }
switch (this.testForEquality(that)) {
case FALSE:
    return new TypePair(null,null);
case TRUE:
case UNKNOWN:
  return new TypePair(this,that);
}
throw new IllegalStateException();
}","/** 
 * Computes the subset of   {@code this} and {@code that} types if equalityis observed. If a value  {@code v1} of type {@code null} is equal to a value{@code v2} of type {@code (undefined,number)}, we can infer that the type of   {@code v1} is {@code null} and the type of {@code v2} is{@code undefined}.
 * @return a pair containing the restricted type of {@code this} as the firstcomponent and the restricted type of  {@code that} as the secondelement. The returned pair is never  {@code null} even though itscomponents may be  {@code null}
 */
public TypePair getTypesUnderEquality(JSType that){
  if (that.isUnionType()) {
    TypePair p=that.toMaybeUnionType().getTypesUnderEquality(this);
    return new TypePair(p.typeB,p.typeA);
  }
switch (testForEquality(that)) {
case FALSE:
    return new TypePair(null,null);
case TRUE:
case UNKNOWN:
  return new TypePair(this,that);
}
throw new IllegalStateException();
}",0.9973016729627632
27986,"/** 
 * A hash code function for diagnosing complicated issues around type-identity.
 */
public String toDebugHashCodeString(){
  return ""String_Node_Str"" + this.hashCode() + ""String_Node_Str"";
}","/** 
 * A hash code function for diagnosing complicated issues around type-identity.
 */
public String toDebugHashCodeString(){
  return ""String_Node_Str"" + hashCode() + ""String_Node_Str"";
}",0.987012987012987
27987,"/** 
 * Tests whether   {@code this} and {@code that} are meaningfullycomparable. By meaningfully, we mean compatible types that do not lead to step 22 of the definition of the Abstract Equality Comparison Algorithm (11.9.3, page 55&ndash;56) of the ECMA-262 specification.<p>
 */
public final boolean canTestForEqualityWith(JSType that){
  return this.testForEquality(that).equals(UNKNOWN);
}","/** 
 * Tests whether   {@code this} and {@code that} are meaningfullycomparable. By meaningfully, we mean compatible types that do not lead to step 22 of the definition of the Abstract Equality Comparison Algorithm (11.9.3, page 55&ndash;56) of the ECMA-262 specification.<p>
 */
public final boolean canTestForEqualityWith(JSType that){
  return testForEquality(that).equals(UNKNOWN);
}",0.9935979513444302
27988,"/** 
 * Tests whether the type is a number (value or Object).
 * @return {@code this &lt;: (Number, number)}
 */
public final boolean isNumber(){
  return this.isSubtype(getNativeType(JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE));
}","/** 
 * Tests whether the type is a number (value or Object).
 * @return {@code this &lt;: (Number, number)}
 */
public final boolean isNumber(){
  return isSubtype(getNativeType(JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE));
}",0.9889624724061812
27989,"/** 
 * Returns true iff   {@code this} can be a {@code struct}. UnionType overrides the method, assume   {@code this} is not a union here.
 */
public boolean isStruct(){
  if (isObject()) {
    ObjectType objType=toObjectType();
    FunctionType ctor=objType.getConstructor();
    if (ctor == null) {
      JSDocInfo info=objType.getJSDocInfo();
      return info != null && info.makesStructs();
    }
 else {
      return ctor.makesStructs();
    }
  }
  return false;
}","/** 
 * Returns true iff   {@code this} can be a {@code struct}. UnionType overrides the method, assume   {@code this} is not a union here.
 */
public boolean isStruct(){
  if (isObject()) {
    ObjectType objType=toObjectType();
    ObjectType iproto=objType.getImplicitPrototype();
    if (iproto != null && iproto.isStruct()) {
      return true;
    }
    FunctionType ctor=objType.getConstructor();
    if (ctor == null) {
      JSDocInfo info=objType.getJSDocInfo();
      return info != null && info.makesStructs();
    }
 else {
      return ctor.makesStructs();
    }
  }
  return false;
}",0.8822429906542056
27990,"/** 
 * Computes the subset of   {@code this} and {@code that} types if inequalityis observed. If a value  {@code v1} of type {@code number} is not equal to avalue  {@code v2} of type {@code (undefined,number)}, we can infer that the type of   {@code v1} is {@code number} and the type of {@code v2} is{@code number} as well.
 * @return a pair containing the restricted type of {@code this} as the firstcomponent and the restricted type of  {@code that} as the secondelement. The returned pair is never  {@code null} even though itscomponents may be  {@code null}
 */
public TypePair getTypesUnderInequality(JSType that){
  if (that.isUnionType()) {
    TypePair p=that.toMaybeUnionType().getTypesUnderInequality(this);
    return new TypePair(p.typeB,p.typeA);
  }
switch (this.testForEquality(that)) {
case TRUE:
    JSType noType=getNativeType(JSTypeNative.NO_TYPE);
  return new TypePair(noType,noType);
case FALSE:
case UNKNOWN:
return new TypePair(this,that);
}
throw new IllegalStateException();
}","/** 
 * Computes the subset of   {@code this} and {@code that} types if inequalityis observed. If a value  {@code v1} of type {@code number} is not equal to avalue  {@code v2} of type {@code (undefined,number)}, we can infer that the type of   {@code v1} is {@code number} and the type of {@code v2} is{@code number} as well.
 * @return a pair containing the restricted type of {@code this} as the firstcomponent and the restricted type of  {@code that} as the secondelement. The returned pair is never  {@code null} even though itscomponents may be  {@code null}
 */
public TypePair getTypesUnderInequality(JSType that){
  if (that.isUnionType()) {
    TypePair p=that.toMaybeUnionType().getTypesUnderInequality(this);
    return new TypePair(p.typeB,p.typeA);
  }
switch (testForEquality(that)) {
case TRUE:
    JSType noType=getNativeType(JSTypeNative.NO_TYPE);
  return new TypePair(noType,noType);
case FALSE:
case UNKNOWN:
return new TypePair(this,that);
}
throw new IllegalStateException();
}",0.9975037443834248
27991,"/** 
 * Returns true iff   {@code this} can be a {@code dict}. UnionType overrides the method, assume   {@code this} is not a union here.
 */
public boolean isDict(){
  if (isObject()) {
    FunctionType ctor=toObjectType().getConstructor();
    return ctor != null && ctor.makesDicts();
  }
  return false;
}","/** 
 * Returns true iff   {@code this} can be a {@code dict}. UnionType overrides the method, assume   {@code this} is not a union here.
 */
public boolean isDict(){
  if (isObject()) {
    ObjectType objType=toObjectType();
    ObjectType iproto=objType.getImplicitPrototype();
    if (iproto != null && iproto.isDict()) {
      return true;
    }
    FunctionType ctor=objType.getConstructor();
    return ctor != null && ctor.makesDicts();
  }
  return false;
}",0.6770025839793282
27992,"/** 
 * Tests whether this type is nullable.
 */
public boolean isNullable(){
  return this.isSubtype(getNativeType(JSTypeNative.NULL_TYPE));
}","/** 
 * Tests whether this type is nullable.
 */
public boolean isNullable(){
  return isSubtype(getNativeType(JSTypeNative.NULL_TYPE));
}",0.98220640569395
27993,"/** 
 * Tests whether values of   {@code this} type can be safely assignedto values of  {@code that} type.<p>The default implementation verifies that  {@code this} is a subtypeof  {@code that}.<p>
 */
public boolean canAssignTo(JSType that){
  if (this.isSubtype(that)) {
    return true;
  }
  return false;
}","/** 
 * Tests whether values of   {@code this} type can be safely assignedto values of  {@code that} type.<p>The default implementation verifies that  {@code this} is a subtypeof  {@code that}.<p>
 */
public boolean canAssignTo(JSType that){
  return isSubtype(that);
}",0.8704663212435233
27994,"/** 
 * Computes the subset of   {@code this} and {@code that} types undershallow inequality.
 * @return A pair containing the restricted type of {@code this} as the firstcomponent and the restricted type of  {@code that} as the secondelement. The returned pair is never  {@code null} even though itscomponents may be  {@code null}
 */
public TypePair getTypesUnderShallowInequality(JSType that){
  if (that.isUnionType()) {
    TypePair p=that.toMaybeUnionType().getTypesUnderShallowInequality(this);
    return new TypePair(p.typeB,p.typeA);
  }
  if (this.isNullType() && that.isNullType() || this.isVoidType() && that.isVoidType()) {
    return new TypePair(null,null);
  }
 else {
    return new TypePair(this,that);
  }
}","/** 
 * Computes the subset of   {@code this} and {@code that} types undershallow inequality.
 * @return A pair containing the restricted type of {@code this} as the firstcomponent and the restricted type of  {@code that} as the secondelement. The returned pair is never  {@code null} even though itscomponents may be  {@code null}
 */
public TypePair getTypesUnderShallowInequality(JSType that){
  if (that.isUnionType()) {
    TypePair p=that.toMaybeUnionType().getTypesUnderShallowInequality(this);
    return new TypePair(p.typeB,p.typeA);
  }
  if (isNullType() && that.isNullType() || isVoidType() && that.isVoidType()) {
    return new TypePair(null,null);
  }
 else {
    return new TypePair(this,that);
  }
}",0.9930747922437672
27995,"/** 
 * An equivalence visitor.
 */
boolean checkEquivalenceHelper(JSType that,EquivalenceMethod eqMethod){
  if (this == that) {
    return true;
  }
  boolean thisUnknown=isUnknownType();
  boolean thatUnknown=that.isUnknownType();
  if (thisUnknown || thatUnknown) {
    if (eqMethod == EquivalenceMethod.INVARIANT) {
      return true;
    }
 else     if (eqMethod == EquivalenceMethod.DATA_FLOW) {
      return thisUnknown && thatUnknown;
    }
 else     if (thisUnknown && thatUnknown && (isNominalType() ^ that.isNominalType())) {
      return false;
    }
  }
  if (isUnionType() && that.isUnionType()) {
    return this.toMaybeUnionType().checkUnionEquivalenceHelper(that.toMaybeUnionType(),eqMethod);
  }
  if (isFunctionType() && that.isFunctionType()) {
    return this.toMaybeFunctionType().checkFunctionEquivalenceHelper(that.toMaybeFunctionType(),eqMethod);
  }
  if (isRecordType() && that.isRecordType()) {
    return this.toMaybeRecordType().checkRecordEquivalenceHelper(that.toMaybeRecordType(),eqMethod);
  }
  ParameterizedType thisParamType=toMaybeParameterizedType();
  ParameterizedType thatParamType=that.toMaybeParameterizedType();
  if (thisParamType != null || thatParamType != null) {
    boolean paramsMatch=false;
    if (thisParamType != null && thatParamType != null) {
      paramsMatch=thisParamType.getParameterType().checkEquivalenceHelper(thatParamType.getParameterType(),eqMethod);
    }
 else     if (eqMethod == EquivalenceMethod.IDENTITY) {
      paramsMatch=false;
    }
 else {
      paramsMatch=true;
    }
    JSType thisRootType=thisParamType == null ? this : thisParamType.getReferencedTypeInternal();
    JSType thatRootType=thatParamType == null ? that : thatParamType.getReferencedTypeInternal();
    return paramsMatch && thisRootType.checkEquivalenceHelper(thatRootType,eqMethod);
  }
  if (isNominalType() && that.isNominalType()) {
    return toObjectType().getReferenceName().equals(that.toObjectType().getReferenceName());
  }
  if (this instanceof ProxyObjectType) {
    return ((ProxyObjectType)this).getReferencedTypeInternal().checkEquivalenceHelper(that,eqMethod);
  }
  if (that instanceof ProxyObjectType) {
    return checkEquivalenceHelper(((ProxyObjectType)that).getReferencedTypeInternal(),eqMethod);
  }
  return this == that;
}","/** 
 * An equivalence visitor.
 */
boolean checkEquivalenceHelper(JSType that,EquivalenceMethod eqMethod){
  if (this == that) {
    return true;
  }
  boolean thisUnknown=isUnknownType();
  boolean thatUnknown=that.isUnknownType();
  if (thisUnknown || thatUnknown) {
    if (eqMethod == EquivalenceMethod.INVARIANT) {
      return true;
    }
 else     if (eqMethod == EquivalenceMethod.DATA_FLOW) {
      return thisUnknown && thatUnknown;
    }
 else     if (thisUnknown && thatUnknown && (isNominalType() ^ that.isNominalType())) {
      return false;
    }
  }
  if (isUnionType() && that.isUnionType()) {
    return toMaybeUnionType().checkUnionEquivalenceHelper(that.toMaybeUnionType(),eqMethod);
  }
  if (isFunctionType() && that.isFunctionType()) {
    return toMaybeFunctionType().checkFunctionEquivalenceHelper(that.toMaybeFunctionType(),eqMethod);
  }
  if (isRecordType() && that.isRecordType()) {
    return toMaybeRecordType().checkRecordEquivalenceHelper(that.toMaybeRecordType(),eqMethod);
  }
  ParameterizedType thisParamType=toMaybeParameterizedType();
  ParameterizedType thatParamType=that.toMaybeParameterizedType();
  if (thisParamType != null || thatParamType != null) {
    boolean paramsMatch=false;
    if (thisParamType != null && thatParamType != null) {
      paramsMatch=thisParamType.getParameterType().checkEquivalenceHelper(thatParamType.getParameterType(),eqMethod);
    }
 else     if (eqMethod == EquivalenceMethod.IDENTITY) {
      paramsMatch=false;
    }
 else {
      paramsMatch=true;
    }
    JSType thisRootType=thisParamType == null ? this : thisParamType.getReferencedTypeInternal();
    JSType thatRootType=thatParamType == null ? that : thatParamType.getReferencedTypeInternal();
    return paramsMatch && thisRootType.checkEquivalenceHelper(thatRootType,eqMethod);
  }
  if (isNominalType() && that.isNominalType()) {
    return toObjectType().getReferenceName().equals(that.toObjectType().getReferenceName());
  }
  if (this instanceof ProxyObjectType) {
    return ((ProxyObjectType)this).getReferencedTypeInternal().checkEquivalenceHelper(that,eqMethod);
  }
  if (that instanceof ProxyObjectType) {
    return checkEquivalenceHelper(((ProxyObjectType)that).getReferencedTypeInternal(),eqMethod);
  }
  return this == that;
}",0.9967241755841888
27996,"/** 
 * Tests whether the type is a string (value or Object).
 * @return {@code this &lt;: (String, string)}
 */
public final boolean isString(){
  return this.isSubtype(getNativeType(JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE));
}","/** 
 * Tests whether the type is a string (value or Object).
 * @return {@code this &lt;: (String, string)}
 */
public final boolean isString(){
  return isSubtype(getNativeType(JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE));
}",0.9889624724061812
27997,"/** 
 * Given the name of a native object property, checks whether the property is present on the object and different from the native one.
 */
private boolean hasOverridenNativeProperty(String propertyName){
  if (isNativeObjectType()) {
    return false;
  }
  JSType propertyType=getPropertyType(propertyName);
  ObjectType nativeType=this.isFunctionType() ? registry.getNativeObjectType(JSTypeNative.FUNCTION_PROTOTYPE) : registry.getNativeObjectType(JSTypeNative.OBJECT_PROTOTYPE);
  JSType nativePropertyType=nativeType.getPropertyType(propertyName);
  return propertyType != nativePropertyType;
}","/** 
 * Given the name of a native object property, checks whether the property is present on the object and different from the native one.
 */
private boolean hasOverridenNativeProperty(String propertyName){
  if (isNativeObjectType()) {
    return false;
  }
  JSType propertyType=getPropertyType(propertyName);
  ObjectType nativeType=isFunctionType() ? registry.getNativeObjectType(JSTypeNative.FUNCTION_PROTOTYPE) : registry.getNativeObjectType(JSTypeNative.OBJECT_PROTOTYPE);
  JSType nativePropertyType=nativeType.getPropertyType(propertyName);
  return propertyType != nativePropertyType;
}",0.9958368026644464
27998,"@Override public boolean isSubtype(JSType that){
  if (JSType.isSubtypeHelper(this,that)) {
    return true;
  }
  if (that.isUnionType()) {
    return false;
  }
  if (that.isRecordType()) {
    return RecordType.isSubtype(this,that.toMaybeRecordType());
  }
  ObjectType thatObj=that.toObjectType();
  FunctionType thatCtor=thatObj == null ? null : thatObj.getConstructor();
  if (getConstructor() != null && getConstructor().isInterface()) {
    for (    ObjectType thisInterface : getCtorExtendedInterfaces()) {
      if (thisInterface.isSubtype(that)) {
        return true;
      }
    }
  }
 else   if (thatCtor != null && thatCtor.isInterface()) {
    Iterable<ObjectType> thisInterfaces=getCtorImplementedInterfaces();
    for (    ObjectType thisInterface : thisInterfaces) {
      if (thisInterface.isSubtype(that)) {
        return true;
      }
    }
  }
  if (isUnknownType() || implicitPrototypeChainIsUnknown()) {
    return true;
  }
  return thatObj != null && this.isImplicitPrototype(thatObj);
}","@Override public boolean isSubtype(JSType that){
  if (JSType.isSubtypeHelper(this,that)) {
    return true;
  }
  if (that.isUnionType()) {
    return false;
  }
  if (that.isRecordType()) {
    return RecordType.isSubtype(this,that.toMaybeRecordType());
  }
  ObjectType thatObj=that.toObjectType();
  FunctionType thatCtor=thatObj == null ? null : thatObj.getConstructor();
  if (getConstructor() != null && getConstructor().isInterface()) {
    for (    ObjectType thisInterface : getCtorExtendedInterfaces()) {
      if (thisInterface.isSubtype(that)) {
        return true;
      }
    }
  }
 else   if (thatCtor != null && thatCtor.isInterface()) {
    Iterable<ObjectType> thisInterfaces=getCtorImplementedInterfaces();
    for (    ObjectType thisInterface : thisInterfaces) {
      if (thisInterface.isSubtype(that)) {
        return true;
      }
    }
  }
  if (isUnknownType() || implicitPrototypeChainIsUnknown()) {
    return true;
  }
  return thatObj != null && isImplicitPrototype(thatObj);
}",0.9975308641975308
27999,"/** 
 * Infer the role of the function (whether it's a constructor or interface) and what it inherits from in JSDocInfo.
 */
FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info){
  if (info != null) {
    isConstructor=info.isConstructor();
    makesStructs=info.makesStructs();
    makesDicts=info.makesDicts();
    isInterface=info.isInterface();
    if (makesStructs && !isConstructor) {
      reportWarning(CONSTRUCTOR_REQUIRED,""String_Node_Str"",fnName);
    }
 else     if (makesDicts && !isConstructor) {
      reportWarning(CONSTRUCTOR_REQUIRED,""String_Node_Str"",fnName);
    }
    if (info.hasBaseType()) {
      if (isConstructor) {
        JSType maybeBaseType=info.getBaseType().evaluate(scope,typeRegistry);
        if (maybeBaseType != null && maybeBaseType.setValidator(new ExtendedTypeValidator())) {
          baseType=(ObjectType)maybeBaseType;
        }
      }
 else {
        reportWarning(EXTENDS_WITHOUT_TYPEDEF,fnName);
      }
    }
    if (isConstructor || isInterface) {
      implementedInterfaces=Lists.newArrayList();
      for (      JSTypeExpression t : info.getImplementedInterfaces()) {
        JSType maybeInterType=t.evaluate(scope,typeRegistry);
        if (maybeInterType != null && maybeInterType.setValidator(new ImplementedTypeValidator())) {
          implementedInterfaces.add((ObjectType)maybeInterType);
        }
      }
    }
 else     if (info.getImplementedInterfaceCount() > 0) {
      reportWarning(CONSTRUCTOR_REQUIRED,""String_Node_Str"",fnName);
    }
    if (isInterface) {
      extendedInterfaces=Lists.newArrayList();
      for (      JSTypeExpression t : info.getExtendedInterfaces()) {
        JSType maybeInterfaceType=t.evaluate(scope,typeRegistry);
        if (maybeInterfaceType != null && maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {
          extendedInterfaces.add((ObjectType)maybeInterfaceType);
        }
      }
    }
  }
  return this;
}","/** 
 * Infer the role of the function (whether it's a constructor or interface) and what it inherits from in JSDocInfo.
 */
FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info){
  if (info != null) {
    isConstructor=info.isConstructor();
    makesStructs=info.makesStructs();
    makesDicts=info.makesDicts();
    isInterface=info.isInterface();
    if (makesStructs && !isConstructor) {
      reportWarning(CONSTRUCTOR_REQUIRED,""String_Node_Str"",fnName);
    }
 else     if (makesDicts && !isConstructor) {
      reportWarning(CONSTRUCTOR_REQUIRED,""String_Node_Str"",fnName);
    }
    if (info.hasBaseType()) {
      if (isConstructor) {
        JSType maybeBaseType=info.getBaseType().evaluate(scope,typeRegistry);
        if (maybeBaseType != null && maybeBaseType.setValidator(new ExtendedTypeValidator())) {
          baseType=(ObjectType)maybeBaseType;
        }
      }
 else {
        reportWarning(EXTENDS_WITHOUT_TYPEDEF,fnName);
      }
    }
    if (info.getImplementedInterfaceCount() > 0) {
      if (isConstructor) {
        implementedInterfaces=Lists.newArrayList();
        for (        JSTypeExpression t : info.getImplementedInterfaces()) {
          JSType maybeInterType=t.evaluate(scope,typeRegistry);
          if (maybeInterType != null && maybeInterType.setValidator(new ImplementedTypeValidator())) {
            implementedInterfaces.add((ObjectType)maybeInterType);
          }
        }
      }
 else       if (isInterface) {
        reportWarning(TypeCheck.CONFLICTING_IMPLEMENTED_TYPE,fnName);
      }
 else {
        reportWarning(CONSTRUCTOR_REQUIRED,""String_Node_Str"",fnName);
      }
    }
    if (isInterface) {
      extendedInterfaces=Lists.newArrayList();
      for (      JSTypeExpression t : info.getExtendedInterfaces()) {
        JSType maybeInterfaceType=t.evaluate(scope,typeRegistry);
        if (maybeInterfaceType != null && maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {
          extendedInterfaces.add((ObjectType)maybeInterfaceType);
        }
      }
    }
  }
  return this;
}",0.9324324324324323
28000,"/** 
 * Visits a   {@link Token#FUNCTION} node.
 * @param t The node traversal object that supplies context, such as thescope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 */
private void visitFunction(NodeTraversal t,Node n){
  FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
  String functionPrivateName=n.getFirstChild().getString();
  if (functionType.isConstructor()) {
    FunctionType baseConstructor=functionType.getSuperClassConstructor();
    if (baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE) && baseConstructor != null && baseConstructor.isInterface() && functionType.isConstructor()) {
      compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,""String_Node_Str"",functionPrivateName));
    }
 else {
      if (baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE) && baseConstructor != null) {
        if (functionType.makesStructs() && !baseConstructor.makesStructs()) {
          compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,""String_Node_Str"",functionPrivateName));
        }
 else         if (functionType.makesDicts() && !baseConstructor.makesDicts()) {
          compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,""String_Node_Str"",functionPrivateName));
        }
      }
      for (      JSType baseInterface : functionType.getImplementedInterfaces()) {
        boolean badImplementedType=false;
        ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
        if (baseInterfaceObj != null) {
          FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
          if (interfaceConstructor != null && !interfaceConstructor.isInterface()) {
            badImplementedType=true;
          }
        }
 else {
          badImplementedType=true;
        }
        if (badImplementedType) {
          report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
        }
      }
      validator.expectAllInterfaceProperties(t,n,functionType);
    }
  }
 else   if (functionType.isInterface()) {
    for (    ObjectType extInterface : functionType.getExtendedInterfaces()) {
      if (extInterface.getConstructor() != null && !extInterface.getConstructor().isInterface()) {
        compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,""String_Node_Str"",functionPrivateName));
      }
    }
    if (functionType.hasImplementedInterfaces()) {
      compiler.report(t.makeError(n,CONFLICTING_IMPLEMENTED_TYPE,functionPrivateName));
    }
    if (functionType.getExtendedInterfacesCount() > 1) {
      HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
      HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
      for (      ObjectType interfaceType : functionType.getExtendedInterfaces()) {
        currentProperties.clear();
        checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
        properties.putAll(currentProperties);
      }
    }
  }
}","/** 
 * Visits a   {@link Token#FUNCTION} node.
 * @param t The node traversal object that supplies context, such as thescope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 */
private void visitFunction(NodeTraversal t,Node n){
  FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
  String functionPrivateName=n.getFirstChild().getString();
  if (functionType.isConstructor()) {
    FunctionType baseConstructor=functionType.getSuperClassConstructor();
    if (baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE) && baseConstructor != null && baseConstructor.isInterface() && functionType.isConstructor()) {
      compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,""String_Node_Str"",functionPrivateName));
    }
 else {
      if (baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE) && baseConstructor != null) {
        if (functionType.makesStructs() && !baseConstructor.makesStructs()) {
          compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,""String_Node_Str"",functionPrivateName));
        }
 else         if (functionType.makesDicts() && !baseConstructor.makesDicts()) {
          compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,""String_Node_Str"",functionPrivateName));
        }
      }
      for (      JSType baseInterface : functionType.getImplementedInterfaces()) {
        boolean badImplementedType=false;
        ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
        if (baseInterfaceObj != null) {
          FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
          if (interfaceConstructor != null && !interfaceConstructor.isInterface()) {
            badImplementedType=true;
          }
        }
 else {
          badImplementedType=true;
        }
        if (badImplementedType) {
          report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
        }
      }
      validator.expectAllInterfaceProperties(t,n,functionType);
    }
  }
 else   if (functionType.isInterface()) {
    for (    ObjectType extInterface : functionType.getExtendedInterfaces()) {
      if (extInterface.getConstructor() != null && !extInterface.getConstructor().isInterface()) {
        compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,""String_Node_Str"",functionPrivateName));
      }
    }
    if (functionType.getExtendedInterfacesCount() > 1) {
      HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
      HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
      for (      ObjectType interfaceType : functionType.getExtendedInterfaces()) {
        currentProperties.clear();
        checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
        properties.putAll(currentProperties);
      }
    }
  }
}",0.975107296137339
