record_number,buggy_code,fixed_code,code_similarity
104001,"/** 
 * Sends a <tt>WhiteboardObject</tt> to delete and delete the local <tt>WhiteboardObject</tt>
 * @param obj the <tt>WhiteboardObject</tt> to send and delete
 * @throws OperationFailedException if sendingthe WhiteboardObject fails for some reason.
 */
public void deleteWhiteboardObject(WhiteboardObject obj) throws OperationFailedException {
  Iterator participants=getWhiteboardParticipants();
  if (!participants.hasNext())   return;
  WhiteboardParticipantJabberImpl participant=(WhiteboardParticipantJabberImpl)participants.next();
  Contact contact=participant.getContact();
  try {
    assertConnected();
    org.jivesoftware.smack.packet.Message msg=new org.jivesoftware.smack.packet.Message();
    WhiteboardObjectPacketExtension messageJI=new WhiteboardObjectPacketExtension(obj.getID(),WhiteboardObjectPacketExtension.ACTION_DELETE);
    msg.addExtension(messageJI);
    msg.addExtension(new Version());
    MessageEventManager.addNotificationsRequests(msg,true,false,false,true);
    smackChat.sendMessage(msg);
    WhiteboardObjectDeliveredEvent msgDeliveredEvt=new WhiteboardObjectDeliveredEvent(this,obj,contact,new Date());
    fireMessageEvent(msgDeliveredEvt);
    int i=0;
    while (i < whiteboardObjects.size()) {
      WhiteboardObjectJabberImpl wbObj=(WhiteboardObjectJabberImpl)whiteboardObjects.get(i);
      if (wbObj.getID().equals(obj.getID()))       whiteboardObjects.remove(i);
 else       i++;
    }
  }
 catch (  XMPPException ex) {
    ex.printStackTrace();
    logger.error(""String_Node_Str"",ex);
  }
}","/** 
 * Sends a <tt>WhiteboardObject</tt> to delete and delete the local <tt>WhiteboardObject</tt>
 * @param obj the <tt>WhiteboardObject</tt> to send and delete
 * @throws OperationFailedException if sendingthe WhiteboardObject fails for some reason.
 */
public void deleteWhiteboardObject(WhiteboardObject obj) throws OperationFailedException {
  Iterator participants=getWhiteboardParticipants();
  if (!participants.hasNext())   return;
  WhiteboardParticipantJabberImpl participant=(WhiteboardParticipantJabberImpl)participants.next();
  Contact contact=participant.getContact();
  try {
    assertConnected();
    org.jivesoftware.smack.packet.Message msg=new org.jivesoftware.smack.packet.Message();
    WhiteboardObjectPacketExtension messageJI=new WhiteboardObjectPacketExtension(obj.getID(),WhiteboardObjectPacketExtension.ACTION_DELETE);
    msg.addExtension(messageJI);
    msg.addExtension(new Version());
    MessageEventManager.addNotificationsRequests(msg,true,false,false,true);
    smackChat.sendMessage(msg);
    WhiteboardObjectDeliveredEvent msgDeliveredEvt=new WhiteboardObjectDeliveredEvent(this,obj,contact,new Date());
    fireMessageEvent(msgDeliveredEvt);
    int i=0;
    while (i < whiteboardObjects.size()) {
      WhiteboardObjectJabberImpl wbObj=whiteboardObjects.get(i);
      if (wbObj.getID().equals(obj.getID()))       whiteboardObjects.remove(i);
 else       i++;
    }
  }
 catch (  XMPPException ex) {
    ex.printStackTrace();
    logger.error(""String_Node_Str"",ex);
  }
}",0.9908256880733946
104002,"private WhiteboardObject updateWhiteboardObjects(WhiteboardObject ws){
  WhiteboardObjectJabberImpl wbObj=null;
  int i=0;
  while (i < whiteboardObjects.size()) {
    WhiteboardObjectJabberImpl wbObjTmp=(WhiteboardObjectJabberImpl)whiteboardObjects.get(i);
    if (wbObjTmp.getID().equals(ws.getID())) {
      wbObj=wbObjTmp;
      break;
    }
 else     i++;
  }
  if (wbObj == null)   return null;
  if (ws instanceof WhiteboardObjectPath) {
    WhiteboardObjectPathJabberImpl obj=(WhiteboardObjectPathJabberImpl)wbObj;
    obj.setPoints(((WhiteboardObjectPath)ws).getPoints());
    obj.setColor(ws.getColor());
    obj.setThickness(ws.getThickness());
  }
 else   if (ws instanceof WhiteboardObjectPolyLine) {
    WhiteboardObjectPolyLineJabberImpl obj=(WhiteboardObjectPolyLineJabberImpl)wbObj;
    obj.setPoints(((WhiteboardObjectPolyLine)ws).getPoints());
    obj.setColor(ws.getColor());
    obj.setThickness(ws.getThickness());
  }
 else   if (ws instanceof WhiteboardObjectPolygon) {
    WhiteboardObjectPolygonJabberImpl obj=(WhiteboardObjectPolygonJabberImpl)wbObj;
    obj.setPoints(((WhiteboardObjectPolygon)ws).getPoints());
    obj.setBackgroundColor(((WhiteboardObjectPolygon)ws).getBackgroundColor());
    obj.setFill(((WhiteboardObjectPolygon)ws).isFill());
    obj.setColor(ws.getColor());
    obj.setThickness(ws.getThickness());
  }
 else   if (ws instanceof WhiteboardObjectLine) {
    WhiteboardObjectLineJabberImpl obj=(WhiteboardObjectLineJabberImpl)wbObj;
    obj.setWhiteboardPointStart(((WhiteboardObjectLine)ws).getWhiteboardPointStart());
    obj.setWhiteboardPointEnd(((WhiteboardObjectLine)ws).getWhiteboardPointEnd());
    obj.setColor(ws.getColor());
    obj.setThickness(ws.getThickness());
  }
 else   if (ws instanceof WhiteboardObjectRect) {
    WhiteboardObjectRectJabberImpl obj=(WhiteboardObjectRectJabberImpl)wbObj;
    obj.setFill(((WhiteboardObjectRect)ws).isFill());
    obj.setHeight(((WhiteboardObjectRect)ws).getHeight());
    obj.setWhiteboardPoint(((WhiteboardObjectRect)ws).getWhiteboardPoint());
    obj.setWidth((((WhiteboardObjectRect)ws)).getWidth());
    obj.setColor(ws.getColor());
    obj.setThickness(ws.getThickness());
  }
 else   if (ws instanceof WhiteboardObjectCircle) {
    WhiteboardObjectCircleJabberImpl obj=(WhiteboardObjectCircleJabberImpl)wbObj;
    obj.setFill(((WhiteboardObjectCircle)ws).isFill());
    obj.setRadius(((WhiteboardObjectCircle)ws).getRadius());
    obj.setWhiteboardPoint(((WhiteboardObjectCircle)ws).getWhiteboardPoint());
    obj.setBackgroundColor((((WhiteboardObjectCircle)ws)).getBackgroundColor());
    obj.setColor(ws.getColor());
    obj.setThickness(ws.getThickness());
  }
 else   if (ws instanceof WhiteboardObjectText) {
    WhiteboardObjectTextJabberImpl obj=(WhiteboardObjectTextJabberImpl)wbObj;
    obj.setFontName(((WhiteboardObjectText)ws).getFontName());
    obj.setFontSize(((WhiteboardObjectText)ws).getFontSize());
    obj.setText(((WhiteboardObjectText)ws).getText());
    obj.setWhiteboardPoint(((WhiteboardObjectText)ws).getWhiteboardPoint());
    obj.setColor(ws.getColor());
    obj.setThickness(ws.getThickness());
  }
 else   if (ws instanceof WhiteboardObjectImage) {
    WhiteboardObjectImageJabberImpl obj=(WhiteboardObjectImageJabberImpl)wbObj;
    obj.setBackgroundImage(((WhiteboardObjectImage)ws).getBackgroundImage());
    obj.setHeight(((WhiteboardObjectImage)ws).getHeight());
    obj.setWhiteboardPoint(((WhiteboardObjectImage)ws).getWhiteboardPoint());
    obj.setWidth(((WhiteboardObjectImage)ws).getWidth());
    obj.setColor(ws.getColor());
    obj.setThickness(ws.getThickness());
  }
  whiteboardObjects.set(i,wbObj);
  return wbObj;
}","private WhiteboardObject updateWhiteboardObjects(WhiteboardObject ws){
  WhiteboardObjectJabberImpl wbObj=null;
  int i=0;
  while (i < whiteboardObjects.size()) {
    WhiteboardObjectJabberImpl wbObjTmp=whiteboardObjects.get(i);
    if (wbObjTmp.getID().equals(ws.getID())) {
      wbObj=wbObjTmp;
      break;
    }
 else     i++;
  }
  if (wbObj == null)   return null;
  if (ws instanceof WhiteboardObjectPath) {
    WhiteboardObjectPathJabberImpl obj=(WhiteboardObjectPathJabberImpl)wbObj;
    obj.setPoints(((WhiteboardObjectPath)ws).getPoints());
    obj.setColor(ws.getColor());
    obj.setThickness(ws.getThickness());
  }
 else   if (ws instanceof WhiteboardObjectPolyLine) {
    WhiteboardObjectPolyLineJabberImpl obj=(WhiteboardObjectPolyLineJabberImpl)wbObj;
    obj.setPoints(((WhiteboardObjectPolyLine)ws).getPoints());
    obj.setColor(ws.getColor());
    obj.setThickness(ws.getThickness());
  }
 else   if (ws instanceof WhiteboardObjectPolygon) {
    WhiteboardObjectPolygonJabberImpl obj=(WhiteboardObjectPolygonJabberImpl)wbObj;
    obj.setPoints(((WhiteboardObjectPolygon)ws).getPoints());
    obj.setBackgroundColor(((WhiteboardObjectPolygon)ws).getBackgroundColor());
    obj.setFill(((WhiteboardObjectPolygon)ws).isFill());
    obj.setColor(ws.getColor());
    obj.setThickness(ws.getThickness());
  }
 else   if (ws instanceof WhiteboardObjectLine) {
    WhiteboardObjectLineJabberImpl obj=(WhiteboardObjectLineJabberImpl)wbObj;
    obj.setWhiteboardPointStart(((WhiteboardObjectLine)ws).getWhiteboardPointStart());
    obj.setWhiteboardPointEnd(((WhiteboardObjectLine)ws).getWhiteboardPointEnd());
    obj.setColor(ws.getColor());
    obj.setThickness(ws.getThickness());
  }
 else   if (ws instanceof WhiteboardObjectRect) {
    WhiteboardObjectRectJabberImpl obj=(WhiteboardObjectRectJabberImpl)wbObj;
    obj.setFill(((WhiteboardObjectRect)ws).isFill());
    obj.setHeight(((WhiteboardObjectRect)ws).getHeight());
    obj.setWhiteboardPoint(((WhiteboardObjectRect)ws).getWhiteboardPoint());
    obj.setWidth((((WhiteboardObjectRect)ws)).getWidth());
    obj.setColor(ws.getColor());
    obj.setThickness(ws.getThickness());
  }
 else   if (ws instanceof WhiteboardObjectCircle) {
    WhiteboardObjectCircleJabberImpl obj=(WhiteboardObjectCircleJabberImpl)wbObj;
    obj.setFill(((WhiteboardObjectCircle)ws).isFill());
    obj.setRadius(((WhiteboardObjectCircle)ws).getRadius());
    obj.setWhiteboardPoint(((WhiteboardObjectCircle)ws).getWhiteboardPoint());
    obj.setBackgroundColor((((WhiteboardObjectCircle)ws)).getBackgroundColor());
    obj.setColor(ws.getColor());
    obj.setThickness(ws.getThickness());
  }
 else   if (ws instanceof WhiteboardObjectText) {
    WhiteboardObjectTextJabberImpl obj=(WhiteboardObjectTextJabberImpl)wbObj;
    obj.setFontName(((WhiteboardObjectText)ws).getFontName());
    obj.setFontSize(((WhiteboardObjectText)ws).getFontSize());
    obj.setText(((WhiteboardObjectText)ws).getText());
    obj.setWhiteboardPoint(((WhiteboardObjectText)ws).getWhiteboardPoint());
    obj.setColor(ws.getColor());
    obj.setThickness(ws.getThickness());
  }
 else   if (ws instanceof WhiteboardObjectImage) {
    WhiteboardObjectImageJabberImpl obj=(WhiteboardObjectImageJabberImpl)wbObj;
    obj.setBackgroundImage(((WhiteboardObjectImage)ws).getBackgroundImage());
    obj.setHeight(((WhiteboardObjectImage)ws).getHeight());
    obj.setWhiteboardPoint(((WhiteboardObjectImage)ws).getWhiteboardPoint());
    obj.setWidth(((WhiteboardObjectImage)ws).getWidth());
    obj.setColor(ws.getColor());
    obj.setThickness(ws.getThickness());
  }
  whiteboardObjects.set(i,wbObj);
  return wbObj;
}",0.243235856791473
104003,"/** 
 * Delivers the specified event to all registered message listeners.
 * @param evt the <tt>EventObject</tt> that we'd like delivered to allregistered message listeners.
 */
public void fireMessageEvent(EventObject evt){
  logger.debug(""String_Node_Str"" + messageListeners.size() + ""String_Node_Str""+ evt.toString());
  Iterator listeners=null;
synchronized (messageListeners) {
    listeners=new ArrayList(messageListeners).iterator();
  }
  while (listeners.hasNext()) {
    WhiteboardObjectListener listener=(WhiteboardObjectListener)listeners.next();
    if (evt instanceof WhiteboardObjectDeliveredEvent) {
      listener.whiteboardObjectDelivered((WhiteboardObjectDeliveredEvent)evt);
    }
 else     if (evt instanceof WhiteboardObjectReceivedEvent) {
      WhiteboardObjectJabberImpl wbObj=(WhiteboardObjectJabberImpl)((WhiteboardObjectReceivedEvent)evt).getSourceWhiteboardObject();
      listener.whiteboardObjectReceived((WhiteboardObjectReceivedEvent)evt);
      whiteboardObjects.add(wbObj);
    }
 else     if (evt instanceof WhiteboardObjectDeletedEvent) {
      String wbObjID=((WhiteboardObjectDeletedEvent)evt).getId();
      listener.whiteboardObjectDeleted((WhiteboardObjectDeletedEvent)evt);
      int i=0;
      while (i < whiteboardObjects.size()) {
        WhiteboardObjectJabberImpl wbObj=(WhiteboardObjectJabberImpl)whiteboardObjects.get(i);
        if (wbObj.getID().equals(wbObjID))         whiteboardObjects.remove(i);
 else         i++;
      }
    }
 else     if (evt instanceof WhiteboardObjectModifiedEvent) {
      WhiteboardObjectJabberImpl wbObj=(WhiteboardObjectJabberImpl)((WhiteboardObjectReceivedEvent)evt).getSourceWhiteboardObject();
      listener.whiteboardObjecModified((WhiteboardObjectModifiedEvent)evt);
      whiteboardObjects.remove(wbObj);
      whiteboardObjects.add(wbObj);
    }
 else     if (evt instanceof WhiteboardObjectDeliveryFailedEvent) {
      listener.whiteboardObjectDeliveryFailed((WhiteboardObjectDeliveryFailedEvent)evt);
    }
  }
}","/** 
 * Delivers the specified event to all registered message listeners.
 * @param evt the <tt>EventObject</tt> that we'd like delivered to allregistered message listeners.
 */
public void fireMessageEvent(EventObject evt){
  logger.debug(""String_Node_Str"" + messageListeners.size() + ""String_Node_Str""+ evt.toString());
  Iterator listeners=null;
synchronized (messageListeners) {
    listeners=new ArrayList(messageListeners).iterator();
  }
  while (listeners.hasNext()) {
    WhiteboardObjectListener listener=(WhiteboardObjectListener)listeners.next();
    if (evt instanceof WhiteboardObjectDeliveredEvent) {
      listener.whiteboardObjectDelivered((WhiteboardObjectDeliveredEvent)evt);
    }
 else     if (evt instanceof WhiteboardObjectReceivedEvent) {
      WhiteboardObjectJabberImpl wbObj=(WhiteboardObjectJabberImpl)((WhiteboardObjectReceivedEvent)evt).getSourceWhiteboardObject();
      listener.whiteboardObjectReceived((WhiteboardObjectReceivedEvent)evt);
      whiteboardObjects.add(wbObj);
    }
 else     if (evt instanceof WhiteboardObjectDeletedEvent) {
      String wbObjID=((WhiteboardObjectDeletedEvent)evt).getId();
      listener.whiteboardObjectDeleted((WhiteboardObjectDeletedEvent)evt);
      int i=0;
      while (i < whiteboardObjects.size()) {
        WhiteboardObjectJabberImpl wbObj=whiteboardObjects.get(i);
        if (wbObj.getID().equals(wbObjID))         whiteboardObjects.remove(i);
 else         i++;
      }
    }
 else     if (evt instanceof WhiteboardObjectModifiedEvent) {
      WhiteboardObjectModifiedEvent womevt=(WhiteboardObjectModifiedEvent)evt;
      WhiteboardObjectJabberImpl wbObj=(WhiteboardObjectJabberImpl)womevt.getSourceWhiteboardObject();
      listener.whiteboardObjecModified(womevt);
      whiteboardObjects.remove(wbObj);
      whiteboardObjects.add(wbObj);
    }
 else     if (evt instanceof WhiteboardObjectDeliveryFailedEvent) {
      listener.whiteboardObjectDeliveryFailed((WhiteboardObjectDeliveryFailedEvent)evt);
    }
  }
}",0.8468648513614789
104004,"public SipStackProperties(){
  super();
  String logDir=SipActivator.getConfigurationService().getScHomeDirLocation() + System.getProperty(""String_Node_Str"") + SipActivator.getConfigurationService().getScHomeDirName()+ System.getProperty(""String_Node_Str"");
  if (!NSPVALUE_DEBUG_LOG.startsWith(logDir))   NSPVALUE_DEBUG_LOG=logDir + NSPVALUE_DEBUG_LOG;
  if (!NSPVALUE_SERVER_LOG.startsWith(logDir))   NSPVALUE_SERVER_LOG=logDir + NSPVALUE_SERVER_LOG;
  this.setProperty(JSPNAME_STACK_NAME,""String_Node_Str"");
  this.setProperty(NSPNAME_DEBUG_LOG,NSPVALUE_DEBUG_LOG);
  this.setProperty(NSPNAME_DEBUG_LOG_OVERWRITE,NSPVALUE_DEBUG_LOG_OVERWRITE);
  this.setProperty(NSPNAME_SERVER_LOG_OVERWRITE,NSPVALUE_SERVER_LOG_OVERWRITE);
  this.setProperty(NSPNAME_CACHE_CLIENT_CONNECTIONS,NSPVALUE_CACHE_CLIENT_CONNECTIONS);
  this.setProperty(NSPNAME_DELIVER_UNSOLICITED_NOTIFY,NSPVALUE_DELIVER_UNSOLICITED_NOTIFY);
  this.setProperty(NSPNAME_USE_ROUTER_FOR_ALL_URIS,NSPVALUE_USE_ROUTER_FOR_ALL_URIS);
  this.setProperty(NSPNAME_ROUTER_PATH,NSPVALUE_ROUTER_PATH);
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  String logLevel=LogManager.getLogManager().getProperty(""String_Node_Str"");
  String jainSipTraceLevel=null;
  if (logLevel == null) {
    jainSipTraceLevel=NSPVALUE_DEFAULT_TRACE_LEVEL;
  }
 else   if (logLevel.equals(Level.FINEST.getName())) {
    jainSipTraceLevel=""String_Node_Str"";
  }
 else   if (logLevel.equals(Level.FINER.getName())) {
    jainSipTraceLevel=""String_Node_Str"";
  }
 else   if (logLevel.equals(Level.FINE.getName())) {
    jainSipTraceLevel=""String_Node_Str"";
  }
 else   if (logLevel.equals(Level.WARNING.getName()) || logLevel.equals(Level.SEVERE.getName())) {
    jainSipTraceLevel=""String_Node_Str"";
  }
 else   if (logLevel.equals(Level.OFF)) {
    jainSipTraceLevel=""String_Node_Str"";
  }
 else {
    jainSipTraceLevel=logLevel;
  }
  this.setProperty(NSPNAME_TRACE_LEVEL,jainSipTraceLevel);
}","public SipStackProperties(){
  super();
  String logDir=SipActivator.getConfigurationService().getScHomeDirLocation() + System.getProperty(""String_Node_Str"") + SipActivator.getConfigurationService().getScHomeDirName()+ System.getProperty(""String_Node_Str"");
  if (!NSPVALUE_DEBUG_LOG.startsWith(logDir))   NSPVALUE_DEBUG_LOG=logDir + NSPVALUE_DEBUG_LOG;
  if (!NSPVALUE_SERVER_LOG.startsWith(logDir))   NSPVALUE_SERVER_LOG=logDir + NSPVALUE_SERVER_LOG;
  this.setProperty(JSPNAME_STACK_NAME,""String_Node_Str"");
  this.setProperty(NSPNAME_DEBUG_LOG,NSPVALUE_DEBUG_LOG);
  this.setProperty(NSPNAME_DEBUG_LOG_OVERWRITE,NSPVALUE_DEBUG_LOG_OVERWRITE);
  this.setProperty(NSPNAME_SERVER_LOG_OVERWRITE,NSPVALUE_SERVER_LOG_OVERWRITE);
  this.setProperty(NSPNAME_CACHE_CLIENT_CONNECTIONS,NSPVALUE_CACHE_CLIENT_CONNECTIONS);
  this.setProperty(NSPNAME_DELIVER_UNSOLICITED_NOTIFY,NSPVALUE_DELIVER_UNSOLICITED_NOTIFY);
  this.setProperty(NSPNAME_USE_ROUTER_FOR_ALL_URIS,NSPVALUE_USE_ROUTER_FOR_ALL_URIS);
  this.setProperty(NSPNAME_ROUTER_PATH,NSPVALUE_ROUTER_PATH);
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  String logLevel=LogManager.getLogManager().getProperty(""String_Node_Str"");
  String jainSipTraceLevel=null;
  if (logLevel == null) {
    jainSipTraceLevel=NSPVALUE_DEFAULT_TRACE_LEVEL;
  }
 else   if (logLevel.equals(Level.FINEST.getName())) {
    jainSipTraceLevel=""String_Node_Str"";
  }
 else   if (logLevel.equals(Level.FINER.getName())) {
    jainSipTraceLevel=""String_Node_Str"";
  }
 else   if (logLevel.equals(Level.FINE.getName())) {
    jainSipTraceLevel=""String_Node_Str"";
  }
 else   if (logLevel.equals(Level.WARNING.getName()) || logLevel.equals(Level.SEVERE.getName())) {
    jainSipTraceLevel=""String_Node_Str"";
  }
 else   if (logLevel.equals(Level.OFF.getName())) {
    jainSipTraceLevel=""String_Node_Str"";
  }
 else {
    jainSipTraceLevel=logLevel;
  }
  this.setProperty(NSPNAME_TRACE_LEVEL,jainSipTraceLevel);
}",0.997426659804426
104005,"/** 
 * Indicates whether some other object is ""equal to"" this account id. <p>
 * @param obj   the reference object with which to compare.
 * @return  <tt>true</tt> if this object is the same as the objargument; <tt>false</tt> otherwise.
 * @see #hashCode()
 * @see java.util.Hashtable
 */
@Override public boolean equals(Object obj){
  if (this == obj)   return true;
  if (obj == null || !(getClass().isInstance(obj)) || !(userID.equals(((AccountID)obj).userID)))   return false;
  return true;
}","/** 
 * Indicates whether some other object is ""equal to"" this account id. <p>
 * @param obj   the reference object with which to compare.
 * @return  <tt>true</tt> if this object is the same as the objargument; <tt>false</tt> otherwise.
 * @see #hashCode()
 * @see java.util.Hashtable
 */
@Override public boolean equals(Object obj){
  if (this == obj)   return true;
  return (obj != null) && getClass().isInstance(obj) && userID.equals(((AccountID)obj).userID);
}",0.9107883817427386
104006,"/** 
 * Returns an empty iterator. Subgroups may only be present in the root group.
 * @return an empty iterator
 */
public Iterator subgroups(){
  return dummyGroupsList.iterator();
}","/** 
 * Returns an empty iterator. Subgroups may only be present in the root group.
 * @return an empty iterator
 */
public Iterator<ContactGroup> subgroups(){
  return dummyGroupsList.iterator();
}",0.9633507853403142
104007,"/** 
 * Returns the icq contact encapsulating with the spcieified screen name or null if no such contact was found.
 * @param screenName the screenName (or icq UIN) for the contact we'relooking for.
 * @return the <tt>ContactIcqImpl</tt> corresponding to the specifiedscrenname or null if no such contact existed.
 */
ContactIcqImpl findContact(String screenName){
  if (screenName == null)   return null;
  String lcScreenName=screenName.toLowerCase();
  return buddies.get(lcScreenName);
}","/** 
 * Returns the icq contact encapsulating with the spcieified screen name or null if no such contact was found.
 * @param screenName the screenName (or icq UIN) for the contact we'relooking for.
 * @return the <tt>ContactIcqImpl</tt> corresponding to the specifiedscrenname or null if no such contact existed.
 */
ContactIcqImpl findContact(String screenName){
  if (screenName == null)   return null;
  String lcScreenName=screenName.toLowerCase();
  return (ContactIcqImpl)buddies.get(lcScreenName);
}",0.9839679358717436
104008,"/** 
 * Returns a string representation of this group, in the form IcqGroup.GroupName[size]{ buddy1.toString(), buddy2.toString(), ...}.
 * @return  a String representation of the object.
 */
public String toString(){
  StringBuffer buff=new StringBuffer(""String_Node_Str"");
  buff.append(getGroupName());
  buff.append(""String_Node_Str"" + countContacts() + ""String_Node_Str"");
  Iterator contacts=contacts();
  while (contacts.hasNext()) {
    ContactIcqImpl contact=(ContactIcqImpl)contacts.next();
    buff.append(contact.toString());
    if (contacts.hasNext())     buff.append(""String_Node_Str"");
  }
  return buff.append(""String_Node_Str"").toString();
}","/** 
 * Returns a string representation of this group, in the form IcqGroup.GroupName[size]{ buddy1.toString(), buddy2.toString(), ...}.
 * @return  a String representation of the object.
 */
public String toString(){
  StringBuffer buff=new StringBuffer(""String_Node_Str"");
  buff.append(getGroupName());
  buff.append(""String_Node_Str"" + countContacts() + ""String_Node_Str"");
  Iterator<Contact> contacts=contacts();
  while (contacts.hasNext()) {
    Contact contact=contacts.next();
    buff.append(contact.toString());
    if (contacts.hasNext())     buff.append(""String_Node_Str"");
  }
  return buff.append(""String_Node_Str"").toString();
}",0.9754601226993864
104009,"/** 
 * Returns the index of contact in this group -1 if no such contact was found.
 * @param contact the contact whose index we're looking for.
 * @return the index of contact in this group.
 */
int findContactIndex(Contact contact){
  Iterator contacts=contacts();
  int i=0;
  while (contacts.hasNext()) {
    ContactIcqImpl item=(ContactIcqImpl)contacts.next();
    if (item == contact)     return i;
    i++;
  }
  return -1;
}","/** 
 * Returns the index of contact in this group -1 if no such contact was found.
 * @param contact the contact whose index we're looking for.
 * @return the index of contact in this group.
 */
int findContactIndex(Contact contact){
  Iterator<Contact> contacts=contacts();
  int i=0;
  while (contacts.hasNext()) {
    ContactIcqImpl item=(ContactIcqImpl)contacts.next();
    if (item == contact)     return i;
    i++;
  }
  return -1;
}",0.9896907216494846
104010,"/** 
 * Returns an Iterator over all contacts, member of this <tt>ContactGroup</tt>.
 * @return a java.util.Iterator over all contacts inside this<tt>ContactGroup</tt>. In case the group doesn't contain any memebers it will return an empty iterator.
 */
public Iterator contacts(){
  return buddies.values().iterator();
}","/** 
 * Returns an Iterator over all contacts, member of this <tt>ContactGroup</tt>.
 * @return a java.util.Iterator over all contacts inside this<tt>ContactGroup</tt>. In case the group doesn't contain any memebers it will return an empty iterator.
 */
public Iterator<Contact> contacts(){
  return buddies.values().iterator();
}",0.9861751152073732
104011,"/** 
 * Returns an iterator over the sub groups that this <tt>ContactGroup</tt> contains.
 * @return a java.util.Iterator over the <tt>ContactGroup</tt>children of this group (i.e. subgroups).
 */
public Iterator subgroups(){
  return subGroups.iterator();
}","/** 
 * Returns an iterator over the sub groups that this <tt>ContactGroup</tt> contains.
 * @return a java.util.Iterator over the <tt>ContactGroup</tt>children of this group (i.e. subgroups).
 */
public Iterator<ContactGroup> subgroups(){
  return subGroups.iterator();
}",0.9735849056603774
104012,"/** 
 * Returns the subgroup with the specified name.
 * @param groupName the name of the <tt>ContactGroup</tt> to retrieve.
 * @return the <tt>ContactGroup</tt> with the specified index.
 */
public ContactGroup getGroup(String groupName){
  Iterator<ContactGroupIcqImpl> subgroups=subgroups();
  while (subgroups.hasNext()) {
    ContactGroupIcqImpl grp=subgroups.next();
    if (grp.getGroupName().equals(groupName))     return grp;
  }
  return null;
}","/** 
 * Returns the subgroup with the specified name.
 * @param groupName the name of the <tt>ContactGroup</tt> to retrieve.
 * @return the <tt>ContactGroup</tt> with the specified index.
 */
public ContactGroup getGroup(String groupName){
  Iterator<ContactGroup> subgroups=subgroups();
  while (subgroups.hasNext()) {
    ContactGroup grp=subgroups.next();
    if (grp.getGroupName().equals(groupName))     return grp;
  }
  return null;
}",0.9174107142857144
104013,"/** 
 * Returns a string representation of the root contact group that contains all subgroups and subcontacts of this group.
 * @return  a string representation of this root contact group.
 */
public String toString(){
  StringBuffer buff=new StringBuffer(getGroupName());
  buff.append(""String_Node_Str"" + countSubgroups() + ""String_Node_Str"");
  Iterator<ContactGroupIcqImpl> subGroups=subgroups();
  while (subGroups.hasNext()) {
    ContactGroup group=(ContactGroup)subGroups.next();
    buff.append(group.toString());
    if (subGroups.hasNext())     buff.append(""String_Node_Str"");
  }
  return buff.toString();
}","/** 
 * Returns a string representation of the root contact group that contains all subgroups and subcontacts of this group.
 * @return  a string representation of this root contact group.
 */
public String toString(){
  StringBuffer buff=new StringBuffer(getGroupName());
  buff.append(""String_Node_Str"" + countSubgroups() + ""String_Node_Str"");
  Iterator<ContactGroup> subGroups=subgroups();
  while (subGroups.hasNext()) {
    ContactGroup group=subGroups.next();
    buff.append(group.toString());
    if (subGroups.hasNext())     buff.append(""String_Node_Str"");
  }
  return buff.toString();
}",0.8545603944124898
104014,"/** 
 * Returns an Iterator over all contacts, member of this <tt>ContactGroup</tt>.
 * @return a java.util.Iterator over all contacts inside this<tt>ContactGroup</tt>
 */
public Iterator contacts(){
  return dummyContacts.iterator();
}","/** 
 * Returns an Iterator over all contacts, member of this <tt>ContactGroup</tt>.
 * @return a java.util.Iterator over all contacts inside this<tt>ContactGroup</tt>
 */
public Iterator<Contact> contacts(){
  return dummyContacts.iterator();
}",0.9812889812889812
104015,"/** 
 * Returns the Contact with the specified screenname (or icq UIN) or null if no such screenname was found.
 * @param screenName the screen name (or ICQ UIN) of the contact to find.
 * @return the <tt>Contact</tt> carrying the specified<tt>screenName</tt> or <tt>null</tt> if no such contact exits.
 */
public ContactIcqImpl findContactByScreenName(String screenName){
  Iterator<ContactGroupIcqImpl> contactGroups=rootGroup.subgroups();
  ContactIcqImpl result=null;
  while (contactGroups.hasNext()) {
    ContactGroupIcqImpl contactGroup=contactGroups.next();
    result=contactGroup.findContact(screenName);
    if (result != null)     return result;
  }
  return null;
}","/** 
 * Returns the Contact with the specified screenname (or icq UIN) or null if no such screenname was found.
 * @param screenName the screen name (or ICQ UIN) of the contact to find.
 * @return the <tt>Contact</tt> carrying the specified<tt>screenName</tt> or <tt>null</tt> if no such contact exits.
 */
public ContactIcqImpl findContactByScreenName(String screenName){
  Iterator<ContactGroup> contactGroups=rootGroup.subgroups();
  ContactIcqImpl result=null;
  while (contactGroups.hasNext()) {
    ContactGroupIcqImpl contactGroup=(ContactGroupIcqImpl)contactGroups.next();
    result=contactGroup.findContact(screenName);
    if (result != null)     return result;
  }
  return null;
}",0.979591836734694
104016,"/** 
 * Called by joustsim as a notification of the fact that the server has sent the specified group and that it is actually a member from our contact list. We copy the group locally and generate the corresponding sip-communicator events
 * @param list the BuddyList where this is happening.
 * @param oldItems we don't use it
 * @param newItems we don't use it
 * @param group the new Group that has been added
 * @param buddies the members of the new group.
 */
public void groupAdded(BuddyList list,List oldItems,List newItems,Group group,List buddies){
  logger.trace(""String_Node_Str"" + group.getName());
  logger.trace(""String_Node_Str"" + buddies);
  ContactGroupIcqImpl newGroup=findContactGroup(group.getName());
  if (newGroup == null) {
    newGroup=new ContactGroupIcqImpl((MutableGroup)group,buddies,ServerStoredContactListIcqImpl.this,true);
    rootGroup.addSubGroup(newGroup);
    fireGroupEvent(newGroup,ServerStoredGroupEvent.GROUP_CREATED_EVENT);
  }
 else {
    List newContacts=new ArrayList();
    List<ContactIcqImpl> deletedContacts=new ArrayList<ContactIcqImpl>();
    newGroup.updateGroup((MutableGroup)group,buddies,newContacts,deletedContacts);
    fireGroupEvent(newGroup,ServerStoredGroupEvent.GROUP_RESOLVED_EVENT);
    Iterator<ContactIcqImpl> deletedContactsIter=deletedContacts.iterator();
    while (deletedContactsIter.hasNext()) {
      ContactIcqImpl contact=(ContactIcqImpl)deletedContactsIter.next();
      fireContactRemoved(newGroup,contact);
    }
    Iterator<ContactIcqImpl> contactsIter=newGroup.contacts();
    while (contactsIter.hasNext()) {
      ContactIcqImpl contact=(ContactIcqImpl)contactsIter.next();
      if (newContacts.contains(contact))       fireContactAdded(newGroup,contact);
 else       fireContactResolved(newGroup,contact);
    }
  }
  for (int i=0; i < buddies.size(); i++)   ((Buddy)buddies.get(i)).addBuddyListener(jsimBuddyListener);
  group.addGroupListener(jsimGroupChangeListener);
}","/** 
 * Called by joustsim as a notification of the fact that the server has sent the specified group and that it is actually a member from our contact list. We copy the group locally and generate the corresponding sip-communicator events
 * @param list the BuddyList where this is happening.
 * @param oldItems we don't use it
 * @param newItems we don't use it
 * @param group the new Group that has been added
 * @param buddies the members of the new group.
 */
public void groupAdded(BuddyList list,List oldItems,List newItems,Group group,List buddies){
  logger.trace(""String_Node_Str"" + group.getName());
  logger.trace(""String_Node_Str"" + buddies);
  ContactGroupIcqImpl newGroup=findContactGroup(group.getName());
  if (newGroup == null) {
    newGroup=new ContactGroupIcqImpl((MutableGroup)group,buddies,ServerStoredContactListIcqImpl.this,true);
    rootGroup.addSubGroup(newGroup);
    fireGroupEvent(newGroup,ServerStoredGroupEvent.GROUP_CREATED_EVENT);
  }
 else {
    List<Contact> newContacts=new ArrayList<Contact>();
    List<ContactIcqImpl> deletedContacts=new ArrayList<ContactIcqImpl>();
    newGroup.updateGroup((MutableGroup)group,buddies,newContacts,deletedContacts);
    fireGroupEvent(newGroup,ServerStoredGroupEvent.GROUP_RESOLVED_EVENT);
    Iterator<ContactIcqImpl> deletedContactsIter=deletedContacts.iterator();
    while (deletedContactsIter.hasNext()) {
      ContactIcqImpl contact=(ContactIcqImpl)deletedContactsIter.next();
      fireContactRemoved(newGroup,contact);
    }
    Iterator<Contact> contactsIter=newGroup.contacts();
    while (contactsIter.hasNext()) {
      ContactIcqImpl contact=(ContactIcqImpl)contactsIter.next();
      if (newContacts.contains(contact))       fireContactAdded(newGroup,contact);
 else       fireContactResolved(newGroup,contact);
    }
  }
  for (int i=0; i < buddies.size(); i++)   ((Buddy)buddies.get(i)).addBuddyListener(jsimBuddyListener);
  group.addGroupListener(jsimGroupChangeListener);
}",0.9936305732484076
104017,"ContactGroupIcqImpl findGroup(Buddy buddy){
  Iterator<ContactGroupIcqImpl> iter=rootGroup.subgroups();
  while (iter.hasNext()) {
    ContactGroupIcqImpl elem=iter.next();
    if (!elem.isPersistent() || !elem.isResolved())     continue;
    Iterator bs=elem.getJoustSimSourceGroup().getBuddiesCopy().iterator();
    while (bs.hasNext()) {
      Buddy b=(Buddy)bs.next();
      if (b == buddy)       return elem;
    }
  }
  return null;
}","ContactGroupIcqImpl findGroup(Buddy buddy){
  Iterator<ContactGroup> iter=rootGroup.subgroups();
  while (iter.hasNext()) {
    ContactGroupIcqImpl elem=(ContactGroupIcqImpl)iter.next();
    if (!elem.isPersistent() || !elem.isResolved())     continue;
    Iterator bs=elem.getJoustSimSourceGroup().getBuddiesCopy().iterator();
    while (bs.hasNext()) {
      Buddy b=(Buddy)bs.next();
      if (b == buddy)       return elem;
    }
  }
  return null;
}",0.9686800894854586
104018,"/** 
 * Returns the index of the ContactGroup containing the specified joust sim group.
 * @param joustSimGroup the joust sim group we're looking for.
 * @return the index of the ContactGroup containing the specifiedjoustSimGroup or -1 if no containing ContactGroup exists.
 */
public int findContactGroupIndex(Group joustSimGroup){
  Iterator<Group> contactGroups=rootGroup.subgroups();
  int index=0;
  for (; contactGroups.hasNext(); index++) {
    ContactGroupIcqImpl contactGroup=(ContactGroupIcqImpl)contactGroups.next();
    if (joustSimGroup == contactGroup.getJoustSimSourceGroup())     return index;
  }
  return -1;
}","/** 
 * Returns the index of the ContactGroup containing the specified joust sim group.
 * @param joustSimGroup the joust sim group we're looking for.
 * @return the index of the ContactGroup containing the specifiedjoustSimGroup or -1 if no containing ContactGroup exists.
 */
public int findContactGroupIndex(Group joustSimGroup){
  Iterator<ContactGroup> contactGroups=rootGroup.subgroups();
  int index=0;
  for (; contactGroups.hasNext(); index++) {
    ContactGroupIcqImpl contactGroup=(ContactGroupIcqImpl)contactGroups.next();
    if (joustSimGroup == contactGroup.getJoustSimSourceGroup())     return index;
  }
  return -1;
}",0.9944576405384006
104019,"/** 
 * Returns the ContactGroup containing the specified contact or null if no such group or contact exist.
 * @param child the contact whose parent group we're looking for.
 * @return the <tt>ContactGroup</tt> containing the specified<tt>contact</tt> or <tt>null</tt> if no such groupo or contact exist.
 */
public ContactGroupIcqImpl findContactGroup(ContactIcqImpl child){
  Iterator<ContactGroupIcqImpl> contactGroups=rootGroup.subgroups();
  while (contactGroups.hasNext()) {
    ContactGroupIcqImpl contactGroup=contactGroups.next();
    if (contactGroup.findContact(child.getJoustSimBuddy()) != null)     return contactGroup;
  }
  return null;
}","/** 
 * Returns the ContactGroup containing the specified contact or null if no such group or contact exist.
 * @param child the contact whose parent group we're looking for.
 * @return the <tt>ContactGroup</tt> containing the specified<tt>contact</tt> or <tt>null</tt> if no such groupo or contact exist.
 */
public ContactGroupIcqImpl findContactGroup(ContactIcqImpl child){
  Iterator<ContactGroup> contactGroups=rootGroup.subgroups();
  while (contactGroups.hasNext()) {
    ContactGroupIcqImpl contactGroup=(ContactGroupIcqImpl)contactGroups.next();
    if (contactGroup.findContact(child.getJoustSimBuddy()) != null)     return contactGroup;
  }
  return null;
}",0.8502269288956127
104020,"/** 
 * Returns the Contact with the specified screenname (or icq UIN) or null if no such screenname was found.
 * @param screenName the screen name (or ICQ UIN) of the contact to find.
 * @return the <tt>Contact</tt> carrying the specified<tt>screenName</tt> or <tt>null</tt> if no such contact exits.
 */
public ContactIcqImpl findContactByJoustSimBuddy(Buddy buddy){
  Iterator<ContactGroupIcqImpl> contactGroups=rootGroup.subgroups();
  String screenName=buddy.getScreenname().getFormatted();
  ContactIcqImpl result=null;
  while (contactGroups.hasNext()) {
    ContactGroupIcqImpl contactGroup=contactGroups.next();
    result=contactGroup.findContact(screenName);
    if (result != null)     return result;
  }
  return null;
}","/** 
 * Returns the Contact with the specified screenname (or icq UIN) or null if no such screenname was found.
 * @param screenName the screen name (or ICQ UIN) of the contact to find.
 * @return the <tt>Contact</tt> carrying the specified<tt>screenName</tt> or <tt>null</tt> if no such contact exits.
 */
public ContactIcqImpl findContactByJoustSimBuddy(Buddy buddy){
  Iterator<ContactGroup> contactGroups=rootGroup.subgroups();
  String screenName=buddy.getScreenname().getFormatted();
  ContactIcqImpl result=null;
  while (contactGroups.hasNext()) {
    ContactGroupIcqImpl contactGroup=(ContactGroupIcqImpl)contactGroups.next();
    result=contactGroup.findContact(screenName);
    if (result != null)     return result;
  }
  return null;
}",0.98110661268556
104021,"/** 
 * Returns the contact encapsulating with the spcieified name or null if no such contact was found.
 * @param id the id for the contact we're looking for.
 * @return the <tt>ContactMsnImpl</tt> corresponding to the specifiedscrenname or null if no such contact existed.
 */
ContactMsnImpl findContact(String id){
  Iterator contacts=contacts();
  while (contacts.hasNext()) {
    ContactMsnImpl item=(ContactMsnImpl)contacts.next();
    if (item.getAddress().equals(id))     return item;
  }
  return null;
}","/** 
 * Returns the contact encapsulating with the spcieified name or null if no such contact was found.
 * @param id the id for the contact we're looking for.
 * @return the <tt>ContactMsnImpl</tt> corresponding to the specifiedscrenname or null if no such contact existed.
 */
ContactMsnImpl findContact(String id){
  if (id == null)   return null;
  return (ContactMsnImpl)buddies.get(id.toLowerCase());
}",0.7144408251900108
104022,"/** 
 * Returns an empty iterator. Subgroups may only be present in the root group.
 * @return an empty iterator
 */
public Iterator subgroups(){
  return dummyGroupsList.iterator();
}","/** 
 * Returns an empty iterator. Subgroups may only be present in the root group.
 * @return an empty iterator
 */
public Iterator<ContactGroup> subgroups(){
  return dummyGroupsList.iterator();
}",0.9633507853403142
104023,"/** 
 * Returns a string representation of this group, in the form MsnGroup.GroupName[size]{ buddy1.toString(), buddy2.toString(), ...}.
 * @return  a String representation of the object.
 */
public String toString(){
  StringBuffer buff=new StringBuffer(""String_Node_Str"");
  buff.append(getGroupName());
  buff.append(""String_Node_Str"" + countContacts() + ""String_Node_Str"");
  Iterator contacts=contacts();
  while (contacts.hasNext()) {
    ContactMsnImpl contact=(ContactMsnImpl)contacts.next();
    buff.append(contact.toString());
    if (contacts.hasNext())     buff.append(""String_Node_Str"");
  }
  return buff.append(""String_Node_Str"").toString();
}","/** 
 * Returns a string representation of this group, in the form MsnGroup.GroupName[size]{ buddy1.toString(), buddy2.toString(), ...}.
 * @return  a String representation of the object.
 */
public String toString(){
  StringBuffer buff=new StringBuffer(""String_Node_Str"");
  buff.append(getGroupName());
  buff.append(""String_Node_Str"" + countContacts() + ""String_Node_Str"");
  Iterator<Contact> contacts=contacts();
  while (contacts.hasNext()) {
    Contact contact=contacts.next();
    buff.append(contact.toString());
    if (contacts.hasNext())     buff.append(""String_Node_Str"");
  }
  return buff.append(""String_Node_Str"").toString();
}",0.9754601226993864
104024,"/** 
 * Returns an Iterator over all contacts, member of this <tt>ContactGroup</tt>.
 * @return a java.util.Iterator over all contacts inside this<tt>ContactGroup</tt>. In case the group doesn't contain any memebers it will return an empty iterator.
 */
public Iterator contacts(){
  return buddies.values().iterator();
}","/** 
 * Returns an Iterator over all contacts, member of this <tt>ContactGroup</tt>.
 * @return a java.util.Iterator over all contacts inside this<tt>ContactGroup</tt>. In case the group doesn't contain any memebers it will return an empty iterator.
 */
public Iterator<Contact> contacts(){
  return buddies.values().iterator();
}",0.9861751152073732
104025,"/** 
 * Initializes the RTP manager so that it would start listening on the <tt>address</tt> session address. The method also initializes the RTP manager buffer control.
 * @param rtpManager the <tt>RTPManager</tt> to initialize.
 * @param bindAddress the <tt>SessionAddress</tt> to use when initializingthe RTPManager.
 * @throws MediaException if we fail to initialize the RTP manager.
 */
private void initializeRtpManager(RTPManager rtpManager,SessionAddress bindAddress) throws MediaException {
  selectedKeyProviderAlgorithm=selectKeyProviderAlgorithm(0);
  try {
    if (selectedKeyProviderAlgorithm != null && selectedKeyProviderAlgorithm.getProviderType() == KeyProviderAlgorithm.ProviderType.ZRTP_PROVIDER) {
      TransformConnector transConnector=TransformManager.createZRTPConnector(bindAddress,this);
      rtpManager.initialize(transConnector);
      this.transConnectors.put(rtpManager,transConnector);
      SecurityEventManager securityEventManager=new SecurityEventManager(this);
      boolean zrtpAutoStart=false;
      if (rtpManager.equals(audioRtpManager)) {
        if (zrtpDHSession == null) {
          zrtpDHSession=transConnector;
          zrtpAutoStart=true;
          securityEventManager.setDHSession(true);
        }
        securityEventManager.setSessionType(AUDIO_SESSION);
      }
 else       if (rtpManager.equals(videoRtpManager)) {
        securityEventManager.setSessionType(VIDEO_SESSION);
      }
      ZRTPTransformEngine engine=(ZRTPTransformEngine)transConnector.getEngine();
      engine.setUserCallback(securityEventManager);
      if (this.getCall().isDefaultEncrypted()) {
        if (engine.initialize(""String_Node_Str"",zrtpAutoStart)) {
          usingZRTP=true;
          engine.sendInfo(ZrtpCodes.MessageSeverity.Info,EnumSet.of(ZRTPCustomInfoCodes.ZRTPEnabledByDefault));
        }
 else {
          engine.sendInfo(ZrtpCodes.MessageSeverity.Info,EnumSet.of(ZRTPCustomInfoCodes.ZRTPEngineInitFailure));
        }
      }
 else {
        engine.sendInfo(ZrtpCodes.MessageSeverity.Info,EnumSet.of(ZRTPCustomInfoCodes.ZRTPNotEnabledByUser));
      }
      logger.trace(""String_Node_Str"" + (rtpManager.equals(audioRtpManager) ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
    }
 else {
      rtpManager.initialize(bindAddress);
      logger.trace(""String_Node_Str"" + (rtpManager.equals(audioRtpManager) ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
    }
  }
 catch (  Exception exc) {
    exc.printStackTrace();
    logger.error(""String_Node_Str"",exc);
    throw new MediaException(""String_Node_Str"",MediaException.IO_ERROR,exc);
  }
  BufferControl bc=(BufferControl)rtpManager.getControl(BufferControl.class.getName());
  if (bc != null) {
    long buff=100;
    String buffStr=MediaActivator.getConfigurationService().getString(PROPERTY_NAME_RECEIVE_BUFFER_LENGTH);
    try {
      if (buffStr != null && buffStr.length() > 0)       buff=Long.parseLong(buffStr);
    }
 catch (    NumberFormatException exc) {
      logger.warn(buffStr + ""String_Node_Str"",exc);
    }
    buff=bc.setBufferLength(buff);
    logger.trace(""String_Node_Str"" + buff);
    bc.setEnabledThreshold(true);
    bc.setMinimumThreshold(100);
  }
  rtpManager.addReceiveStreamListener(this);
  rtpManager.addSendStreamListener(this);
  rtpManager.addSessionListener(this);
}","/** 
 * Initializes the RTP manager so that it would start listening on the <tt>address</tt> session address. The method also initializes the RTP manager buffer control.
 * @param rtpManager the <tt>RTPManager</tt> to initialize.
 * @param bindAddress the <tt>SessionAddress</tt> to use when initializingthe RTPManager.
 * @throws MediaException if we fail to initialize the RTP manager.
 */
private void initializeRtpManager(RTPManager rtpManager,SessionAddress bindAddress) throws MediaException {
  selectedKeyProviderAlgorithm=selectKeyProviderAlgorithm(0);
  try {
    if (selectedKeyProviderAlgorithm != null && selectedKeyProviderAlgorithm.getProviderType() == KeyProviderAlgorithm.ProviderType.ZRTP_PROVIDER) {
      TransformConnector transConnector=TransformManager.createZRTPConnector(bindAddress);
      rtpManager.initialize(transConnector);
      this.transConnectors.put(rtpManager,transConnector);
      SecurityEventManager securityEventManager=new SecurityEventManager(this);
      boolean zrtpAutoStart=false;
      if (rtpManager.equals(audioRtpManager)) {
        if (zrtpDHSession == null) {
          zrtpDHSession=transConnector;
          zrtpAutoStart=true;
          securityEventManager.setDHSession(true);
        }
        securityEventManager.setSessionType(AUDIO_SESSION);
      }
 else       if (rtpManager.equals(videoRtpManager)) {
        securityEventManager.setSessionType(VIDEO_SESSION);
      }
      ZRTPTransformEngine engine=(ZRTPTransformEngine)transConnector.getEngine();
      engine.setUserCallback(securityEventManager);
      if (this.getCall().isDefaultEncrypted()) {
        if (engine.initialize(""String_Node_Str"",zrtpAutoStart)) {
          usingZRTP=true;
          engine.sendInfo(ZrtpCodes.MessageSeverity.Info,EnumSet.of(ZRTPCustomInfoCodes.ZRTPEnabledByDefault));
        }
 else {
          engine.sendInfo(ZrtpCodes.MessageSeverity.Info,EnumSet.of(ZRTPCustomInfoCodes.ZRTPEngineInitFailure));
        }
      }
 else {
        engine.sendInfo(ZrtpCodes.MessageSeverity.Info,EnumSet.of(ZRTPCustomInfoCodes.ZRTPNotEnabledByUser));
      }
      logger.trace(""String_Node_Str"" + (rtpManager.equals(audioRtpManager) ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
    }
 else {
      rtpManager.initialize(bindAddress);
      logger.trace(""String_Node_Str"" + (rtpManager.equals(audioRtpManager) ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
    }
  }
 catch (  Exception exc) {
    exc.printStackTrace();
    logger.error(""String_Node_Str"",exc);
    throw new MediaException(""String_Node_Str"",MediaException.IO_ERROR,exc);
  }
  BufferControl bc=(BufferControl)rtpManager.getControl(BufferControl.class.getName());
  if (bc != null) {
    long buff=100;
    String buffStr=MediaActivator.getConfigurationService().getString(PROPERTY_NAME_RECEIVE_BUFFER_LENGTH);
    try {
      if (buffStr != null && buffStr.length() > 0)       buff=Long.parseLong(buffStr);
    }
 catch (    NumberFormatException exc) {
      logger.warn(buffStr + ""String_Node_Str"",exc);
    }
    buff=bc.setBufferLength(buff);
    logger.trace(""String_Node_Str"" + buff);
    bc.setEnabledThreshold(true);
    bc.setMinimumThreshold(100);
  }
  rtpManager.addReceiveStreamListener(this);
  rtpManager.addSendStreamListener(this);
  rtpManager.addSessionListener(this);
}",0.9992495872730002
104026,"/** 
 * Return required control from the Control[] array if exists, that is
 */
public Object getControl(String controlType){
  try {
    Class cls=Class.forName(controlType);
    Object cs[]=getControls();
    for (int i=0; i < cs.length; i++) {
      if (cls.isInstance(cs[i]))       return cs[i];
    }
    return null;
  }
 catch (  Exception e) {
    return null;
  }
}","/** 
 * Return required control from the Control[] array if exists, that is
 */
public Object getControl(String controlType){
  try {
    Class<?> cls=Class.forName(controlType);
    Object cs[]=getControls();
    for (int i=0; i < cs.length; i++) {
      if (cls.isInstance(cs[i]))       return cs[i];
    }
    return null;
  }
 catch (  Exception e) {
    return null;
  }
}",0.996005326231691
104027,"/** 
 * Creates a connector specific for use in case of ZRTP key management
 * @param addr local RTP session listen address
 * @param cryptoProvider the cryptography services provider selection stringshould be obtained from a resource file or by querying 
 * @return the TransformConnector used for ZRTP processing
 * @throws InvalidSessionAddressException
 */
public static TransformConnector createZRTPConnector(SessionAddress addr,CallSession callSession) throws InvalidSessionAddressException {
  ZRTPTransformEngine engine=new ZRTPTransformEngine();
  TransformConnector connector=new ZrtpTransformConnector(addr,engine);
  engine.setConnector(connector);
  return connector;
}","/** 
 * Creates a connector specific for use in case of ZRTP key management
 * @param addr local RTP session listen address
 * @param cryptoProvider the cryptography services provider selection stringshould be obtained from a resource file or by querying 
 * @return the TransformConnector used for ZRTP processing
 * @throws InvalidSessionAddressException
 */
public static TransformConnector createZRTPConnector(SessionAddress addr) throws InvalidSessionAddressException {
  ZRTPTransformEngine engine=new ZRTPTransformEngine();
  TransformConnector connector=new ZrtpTransformConnector(addr,engine);
  engine.setConnector(connector);
  return connector;
}",0.982089552238806
104028,"public int write(byte[] buffer,int offset,int length){
  RawPacket pkt=this.transformer.transform(new RawPacket(buffer,offset,length));
  for (int i=0; i < this.remoteAddrs.size(); ++i) {
    InetAddress remoteAddr=(InetAddress)this.remoteAddrs.elementAt(i);
    int remotePort=((Integer)this.remotePorts.elementAt(i)).intValue();
    try {
      this.socket.send(new DatagramPacket(pkt.getBuffer(),pkt.getOffset(),pkt.getLength(),remoteAddr,remotePort));
    }
 catch (    Exception e) {
      return -1;
    }
  }
  return length;
}","public int write(byte[] buffer,int offset,int length){
  RawPacket pkt=this.transformer.transform(new RawPacket(buffer,offset,length));
  for (int i=0; i < this.remoteAddrs.size(); ++i) {
    InetAddress remoteAddr=this.remoteAddrs.elementAt(i);
    int remotePort=(this.remotePorts.elementAt(i)).intValue();
    try {
      this.socket.send(new DatagramPacket(pkt.getBuffer(),pkt.getOffset(),pkt.getLength(),remoteAddr,remotePort));
    }
 catch (    Exception e) {
      return -1;
    }
  }
  return length;
}",0.9789674952198852
104029,"/** 
 * Get RTP header length from a RTP packet
 * @param pkt the source RTP packet
 * @return RTP header length from source RTP packet
 */
public static int GetRTPHeaderLength(RawPacket pkt){
  boolean hasExtension=((pkt.readByte(0) & (0x01 << 2)) != 0);
  if (hasExtension) {
    return -1;
  }
  int csrcNum=(int)(pkt.readByte(0) & 0xF);
  return 12 + 4 * csrcNum;
}","/** 
 * Get RTP header length from a RTP packet
 * @param pkt the source RTP packet
 * @return RTP header length from source RTP packet
 */
public static int GetRTPHeaderLength(RawPacket pkt){
  boolean hasExtension=((pkt.readByte(0) & (0x01 << 2)) != 0);
  if (hasExtension) {
    return -1;
  }
  int csrcNum=pkt.readByte(0) & 0xF;
  return 12 + 4 * csrcNum;
}",0.9904240766073872
104030,"/** 
 * Get RTP padding size from a RTP packet
 * @param pkt the source RTP packet
 * @return RTP padding size from source RTP packet
 */
public static int GetRTPPaddingSize(RawPacket pkt){
  if ((pkt.readByte(0) & (0x01 << 2)) == 0) {
    return 0;
  }
 else {
    return (int)pkt.readByte(pkt.getLength() - 1);
  }
}","/** 
 * Get RTP padding size from a RTP packet
 * @param pkt the source RTP packet
 * @return RTP padding size from source RTP packet
 */
public static int GetRTPPaddingSize(RawPacket pkt){
  if ((pkt.readByte(0) & (0x01 << 2)) == 0) {
    return 0;
  }
 else {
    return pkt.readByte(pkt.getLength() - 1);
  }
}",0.9920760697305864
104031,"/** 
 * Constructs a SRTCPTransformer object
 * @param engine The associated SRTPTransformEngine object
 */
public SRTCPTransformer(SRTPTransformEngine engine){
  this.engine=engine;
}","/** 
 * Constructs a SRTCPTransformer object
 * @param engine The associated SRTPTransformEngine object
 */
public SRTCPTransformer(SRTPTransformEngine engine){
}",0.9364161849710982
104032,"/** 
 * Checks if a packet is a replayed on based on its sequence number. This method supports a 64 packet history relative the the given sequence number. Sequence Number is guaranteed to be real (not faked) through  authentication.
 * @param seqNum sequence number of the packet
 * @return true if this sequence number indicates the packet is not areplayed one, false if not
 */
boolean checkReplay(int seqNo,long guessedIndex){
  long localIndex=(((long)this.roc) << 16) | this.seqNum;
  long delta=guessedIndex - localIndex;
  if (delta > 0) {
    return true;
  }
 else {
    if (-delta > REPLAY_WINDOW_SIZE) {
      return false;
    }
 else {
      if (((this.replayWindow >> (-delta)) & 0x1) != 0) {
        return false;
      }
 else {
        return true;
      }
    }
  }
}","/** 
 * Checks if a packet is a replayed on based on its sequence number. This method supports a 64 packet history relative the the given sequence number. Sequence Number is guaranteed to be real (not faked) through  authentication.
 * @param seqNo sequence number of the packet
 * @return true if this sequence number indicates the packet is not areplayed one, false if not
 */
boolean checkReplay(int seqNo,long guessedIndex){
  long localIndex=(((long)this.roc) << 16) | this.seqNum;
  long delta=guessedIndex - localIndex;
  if (delta > 0) {
    return true;
  }
 else {
    if (-delta > REPLAY_WINDOW_SIZE) {
      return false;
    }
 else {
      if (((this.replayWindow >> (-delta)) & 0x1) != 0) {
        return false;
      }
 else {
        return true;
      }
    }
  }
}",0.9980879541108988
104033,"/** 
 * Perform Counter Mode AES encryption / decryption 
 * @param pkt the RTP packet to be encrypted / decrypted
 */
public void processPacketAESCM(RawPacket pkt){
  long ssrc=PacketManipulator.GetRTPSSRC(pkt);
  int seqNum=PacketManipulator.GetRTPSequenceNumber(pkt);
  long index=((long)this.roc << 16) | (long)seqNum;
  ivStore[0]=saltKey[0];
  ivStore[1]=saltKey[1];
  ivStore[2]=saltKey[2];
  ivStore[3]=saltKey[3];
  int i;
  for (i=4; i < 8; i++) {
    ivStore[i]=(byte)((0xFF & (ssrc >> ((7 - i) * 8))) ^ this.saltKey[i]);
  }
  for (i=8; i < 14; i++) {
    ivStore[i]=(byte)((0xFF & (byte)(index >> ((13 - i) * 8))) ^ this.saltKey[i]);
  }
  ivStore[14]=ivStore[15]=0;
  final int payloadOffset=PacketManipulator.GetRTPHeaderLength(pkt);
  final int payloadLength=PacketManipulator.GetRTPPayloadLength(pkt);
  cipherCtr.process(AEScipher,pkt.getBuffer(),pkt.getOffset() + payloadOffset,payloadLength,ivStore);
}","/** 
 * Perform Counter Mode AES encryption / decryption 
 * @param pkt the RTP packet to be encrypted / decrypted
 */
public void processPacketAESCM(RawPacket pkt){
  long ssrc=PacketManipulator.GetRTPSSRC(pkt);
  int seqNo=PacketManipulator.GetRTPSequenceNumber(pkt);
  long index=((long)this.roc << 16) | seqNo;
  ivStore[0]=saltKey[0];
  ivStore[1]=saltKey[1];
  ivStore[2]=saltKey[2];
  ivStore[3]=saltKey[3];
  int i;
  for (i=4; i < 8; i++) {
    ivStore[i]=(byte)((0xFF & (ssrc >> ((7 - i) * 8))) ^ this.saltKey[i]);
  }
  for (i=8; i < 14; i++) {
    ivStore[i]=(byte)((0xFF & (byte)(index >> ((13 - i) * 8))) ^ this.saltKey[i]);
  }
  ivStore[14]=ivStore[15]=0;
  final int payloadOffset=PacketManipulator.GetRTPHeaderLength(pkt);
  final int payloadLength=PacketManipulator.GetRTPPayloadLength(pkt);
  cipherCtr.process(AEScipher,pkt.getBuffer(),pkt.getOffset() + payloadOffset,payloadLength,ivStore);
}",0.9934640522875816
104034,"public RawPacket transform(RawPacket pkt){
  long ssrc=PacketManipulator.GetRTPSSRC(pkt);
  SRTPCryptoContext context=(SRTPCryptoContext)this.contexts.get(ssrc);
  if (context == null) {
    context=this.engine.getDefaultContext().deriveContext(ssrc,0,0);
    if (context != null) {
      context.deriveSrtpKeys(0);
      this.contexts.put(ssrc,context);
    }
  }
  if (context != null) {
    context.transformPacket(pkt);
  }
  return pkt;
}","public RawPacket transform(RawPacket pkt){
  long ssrc=PacketManipulator.GetRTPSSRC(pkt);
  SRTPCryptoContext context=this.contexts.get(ssrc);
  if (context == null) {
    context=this.engine.getDefaultContext().deriveContext(ssrc,0,0);
    if (context != null) {
      context.deriveSrtpKeys(0);
      this.contexts.put(ssrc,context);
    }
  }
  if (context != null) {
    context.transformPacket(pkt);
  }
  return pkt;
}",0.978085351787774
104035,"public RawPacket reverseTransform(RawPacket pkt){
  long ssrc=PacketManipulator.GetRTPSSRC(pkt);
  int seqNum=PacketManipulator.GetRTPSequenceNumber(pkt);
  SRTPCryptoContext context=(SRTPCryptoContext)this.contexts.get(ssrc);
  if (context == null) {
    context=this.engine.getDefaultContext().deriveContext(ssrc,0,0);
    if (context != null) {
      context.deriveSrtpKeys(seqNum);
      this.contexts.put(ssrc,context);
    }
  }
  if (context != null) {
    boolean validPacket=context.reverseTransformPacket(pkt);
    if (!validPacket) {
      return null;
    }
  }
  return pkt;
}","public RawPacket reverseTransform(RawPacket pkt){
  long ssrc=PacketManipulator.GetRTPSSRC(pkt);
  int seqNum=PacketManipulator.GetRTPSequenceNumber(pkt);
  SRTPCryptoContext context=this.contexts.get(ssrc);
  if (context == null) {
    context=this.engine.getDefaultContext().deriveContext(ssrc,0,0);
    if (context != null) {
      context.deriveSrtpKeys(seqNum);
      this.contexts.put(ssrc,context);
    }
  }
  if (context != null) {
    boolean validPacket=context.reverseTransformPacket(pkt);
    if (!validPacket) {
      return null;
    }
  }
  return pkt;
}",0.9836065573770492
104036,"/** 
 * The diagnostics code itself.
 */
public void run(){
  logger.debug(""String_Node_Str"" + addressEntry);
  setDiagnosticsStatus(this.DIAGNOSTICS_STATUS_DISOVERING_CONFIG);
  InetAddress address=addressEntry.getInetAddress();
  if (addressEntry.isIPv6()) {
    if (addressEntry.isLinkLocal()) {
      addressEntry.setAddressPreference(ADDR_PREF_LOCAL_IPV6);
      setDiagnosticsStatus(DIAGNOSTICS_STATUS_TERMINATED);
      return;
    }
    if (addressEntry.is6to4()) {
      addressEntry.setAddressPreference(AddressPreference.MIN);
      setDiagnosticsStatus(DIAGNOSTICS_STATUS_TERMINATED);
      return;
    }
    addressEntry.setAddressPreference(ADDR_PREF_GLOBAL_IPV6);
    setDiagnosticsStatus(DIAGNOSTICS_STATUS_COMPLETED);
    return;
  }
  if (addressEntry.isIPv4LinkLocalAutoconf()) {
    addressEntry.setAddressPreference(AddressPreference.MIN);
    setDiagnosticsStatus(DIAGNOSTICS_STATUS_TERMINATED);
    return;
  }
  if (addressEntry.isLinkLocalIPv4Address()) {
    addressEntry.setAddressPreference(ADDR_PREF_PRIVATE_IPV4);
  }
 else {
    addressEntry.setAddressPreference(ADDR_PREF_GLOBAL_IPV4);
  }
  if (!useStun) {
    setDiagnosticsStatus(DIAGNOSTICS_STATUS_TERMINATED);
    return;
  }
  for (int i=0; i < bindRetries; i++) {
    StunAddress localStunAddress=new StunAddress(address,1024 + (int)(Math.random() * 64512));
    try {
      stunClient=new StunClient(localStunAddress);
      stunClient.start();
      logger.debug(""String_Node_Str"" + localStunAddress + ""String_Node_Str"");
      break;
    }
 catch (    StunException ex) {
      if (ex.getCause() instanceof SocketException && i < bindRetries) {
        logger.debug(""String_Node_Str"" + localStunAddress + ""String_Node_Str"");
        logger.debug(""String_Node_Str"",ex);
        continue;
      }
      logger.error(""String_Node_Str"" + addressEntry.toString() + ""String_Node_Str""+ localStunAddress.getPort()+ ""String_Node_Str"",ex);
      setDiagnosticsStatus(DIAGNOSTICS_STATUS_TERMINATED);
      return;
    }
  }
  StunMessageEvent event=null;
  try {
    event=stunClient.doStunTestI(primaryStunServerAddress);
  }
 catch (  StunException ex) {
    logger.error(""String_Node_Str"" + addressEntry.toString(),ex);
    setDiagnosticsStatus(DIAGNOSTICS_STATUS_TERMINATED);
    stunClient.shutDown();
    return;
  }
  if (event == null) {
    logger.debug(""String_Node_Str"" + addressEntry);
    setDiagnosticsStatus(DIAGNOSTICS_STATUS_TERMINATED);
    stunClient.shutDown();
    logger.debug(""String_Node_Str"");
    return;
  }
  boolean isPublic;
  Message stunResponse=event.getMessage();
  Attribute mappedAttr=stunResponse.getAttribute(Attribute.MAPPED_ADDRESS);
  StunAddress mappedAddrFromTestI=((MappedAddressAttribute)mappedAttr).getAddress();
  Attribute changedAddressAttributeFromTestI=stunResponse.getAttribute(Attribute.CHANGED_ADDRESS);
  StunAddress secondaryStunServerAddress=((ChangedAddressAttribute)changedAddressAttributeFromTestI).getAddress();
  if (mappedAddrFromTestI == null) {
    logger.error(""String_Node_Str"" + addressEntry.toString());
    setDiagnosticsStatus(DIAGNOSTICS_STATUS_TERMINATED);
    return;
  }
  if (mappedAddrFromTestI.equals(event.getSourceAccessPoint().getAddress())) {
    isPublic=true;
  }
 else {
    isPublic=false;
  }
  try {
    event=stunClient.doStunTestII(primaryStunServerAddress);
  }
 catch (  StunException ex) {
    logger.error(""String_Node_Str"" + addressEntry.toString(),ex);
    setDiagnosticsStatus(DIAGNOSTICS_STATUS_TERMINATED);
    stunClient.shutDown();
    logger.debug(""String_Node_Str"");
    return;
  }
  if (event != null) {
    logger.error(""String_Node_Str"" + addressEntry.toString());
    setDiagnosticsStatus(DIAGNOSTICS_STATUS_TERMINATED);
    stunClient.shutDown();
    return;
  }
  try {
    event=stunClient.doStunTestI(secondaryStunServerAddress);
    logger.debug(""String_Node_Str"");
  }
 catch (  StunException ex) {
    logger.error(""String_Node_Str"" + addressEntry.toString(),ex);
    setDiagnosticsStatus(DIAGNOSTICS_STATUS_TERMINATED);
    stunClient.shutDown();
    return;
  }
  if (event == null) {
    logger.error(""String_Node_Str"" + addressEntry.toString());
    setDiagnosticsStatus(DIAGNOSTICS_STATUS_TERMINATED);
    stunClient.shutDown();
    return;
  }
  stunResponse=event.getMessage();
  mappedAttr=stunResponse.getAttribute(Attribute.MAPPED_ADDRESS);
  StunAddress mappedAddrFromSecServer=((MappedAddressAttribute)mappedAttr).getAddress();
  if (!mappedAddrFromTestI.equals(mappedAddrFromSecServer)) {
    logger.debug(""String_Node_Str"" + addressEntry.toString());
    setDiagnosticsStatus(DIAGNOSTICS_STATUS_TERMINATED);
    stunClient.shutDown();
    return;
  }
  try {
    event=stunClient.doStunTestIII(primaryStunServerAddress);
    logger.debug(""String_Node_Str"");
  }
 catch (  StunException ex) {
    logger.error(""String_Node_Str"" + addressEntry.toString(),ex);
    setDiagnosticsStatus(DIAGNOSTICS_STATUS_TERMINATED);
    stunClient.shutDown();
    return;
  }
  if (event == null) {
    logger.debug(""String_Node_Str"" + addressEntry.toString());
    setDiagnosticsStatus(DIAGNOSTICS_STATUS_TERMINATED);
    stunClient.shutDown();
    return;
  }
  logger.debug(""String_Node_Str"" + addressEntry.toString());
  setDiagnosticsStatus(DIAGNOSTICS_STATUS_TERMINATED);
  stunClient.shutDown();
}","/** 
 * The diagnostics code itself.
 */
public void run(){
  logger.debug(""String_Node_Str"" + addressEntry);
  setDiagnosticsStatus(DIAGNOSTICS_STATUS_DISOVERING_CONFIG);
  InetAddress address=addressEntry.getInetAddress();
  if (addressEntry.isIPv6()) {
    if (addressEntry.isLinkLocal()) {
      addressEntry.setAddressPreference(ADDR_PREF_LOCAL_IPV6);
      setDiagnosticsStatus(DIAGNOSTICS_STATUS_TERMINATED);
      return;
    }
    if (addressEntry.is6to4()) {
      addressEntry.setAddressPreference(AddressPreference.MIN);
      setDiagnosticsStatus(DIAGNOSTICS_STATUS_TERMINATED);
      return;
    }
    addressEntry.setAddressPreference(ADDR_PREF_GLOBAL_IPV6);
    setDiagnosticsStatus(DIAGNOSTICS_STATUS_COMPLETED);
    return;
  }
  if (addressEntry.isIPv4LinkLocalAutoconf()) {
    addressEntry.setAddressPreference(AddressPreference.MIN);
    setDiagnosticsStatus(DIAGNOSTICS_STATUS_TERMINATED);
    return;
  }
  if (addressEntry.isLinkLocalIPv4Address()) {
    addressEntry.setAddressPreference(ADDR_PREF_PRIVATE_IPV4);
  }
 else {
    addressEntry.setAddressPreference(ADDR_PREF_GLOBAL_IPV4);
  }
  if (!useStun) {
    setDiagnosticsStatus(DIAGNOSTICS_STATUS_TERMINATED);
    return;
  }
  for (int i=0; i < bindRetries; i++) {
    StunAddress localStunAddress=new StunAddress(address,1024 + (int)(Math.random() * 64512));
    try {
      stunClient=new StunClient(localStunAddress);
      stunClient.start();
      logger.debug(""String_Node_Str"" + localStunAddress + ""String_Node_Str"");
      break;
    }
 catch (    StunException ex) {
      if (ex.getCause() instanceof SocketException && i < bindRetries) {
        logger.debug(""String_Node_Str"" + localStunAddress + ""String_Node_Str"");
        logger.debug(""String_Node_Str"",ex);
        continue;
      }
      logger.error(""String_Node_Str"" + addressEntry.toString() + ""String_Node_Str""+ localStunAddress.getPort()+ ""String_Node_Str"",ex);
      setDiagnosticsStatus(DIAGNOSTICS_STATUS_TERMINATED);
      return;
    }
  }
  StunMessageEvent event=null;
  try {
    event=stunClient.doStunTestI(primaryStunServerAddress);
  }
 catch (  StunException ex) {
    logger.error(""String_Node_Str"" + addressEntry.toString(),ex);
    setDiagnosticsStatus(DIAGNOSTICS_STATUS_TERMINATED);
    stunClient.shutDown();
    return;
  }
  if (event == null) {
    logger.debug(""String_Node_Str"" + addressEntry);
    setDiagnosticsStatus(DIAGNOSTICS_STATUS_TERMINATED);
    stunClient.shutDown();
    logger.debug(""String_Node_Str"");
    return;
  }
  boolean isPublic;
  Message stunResponse=event.getMessage();
  Attribute mappedAttr=stunResponse.getAttribute(Attribute.MAPPED_ADDRESS);
  StunAddress mappedAddrFromTestI=((MappedAddressAttribute)mappedAttr).getAddress();
  Attribute changedAddressAttributeFromTestI=stunResponse.getAttribute(Attribute.CHANGED_ADDRESS);
  StunAddress secondaryStunServerAddress=((ChangedAddressAttribute)changedAddressAttributeFromTestI).getAddress();
  if (mappedAddrFromTestI == null) {
    logger.error(""String_Node_Str"" + addressEntry.toString());
    setDiagnosticsStatus(DIAGNOSTICS_STATUS_TERMINATED);
    return;
  }
  if (mappedAddrFromTestI.equals(event.getSourceAccessPoint().getAddress())) {
    isPublic=true;
  }
 else {
    isPublic=false;
  }
  try {
    event=stunClient.doStunTestII(primaryStunServerAddress);
  }
 catch (  StunException ex) {
    logger.error(""String_Node_Str"" + addressEntry.toString(),ex);
    setDiagnosticsStatus(DIAGNOSTICS_STATUS_TERMINATED);
    stunClient.shutDown();
    logger.debug(""String_Node_Str"");
    return;
  }
  if (event != null) {
    logger.error(""String_Node_Str"" + addressEntry.toString());
    setDiagnosticsStatus(DIAGNOSTICS_STATUS_TERMINATED);
    stunClient.shutDown();
    return;
  }
  try {
    event=stunClient.doStunTestI(secondaryStunServerAddress);
    logger.debug(""String_Node_Str"");
  }
 catch (  StunException ex) {
    logger.error(""String_Node_Str"" + addressEntry.toString(),ex);
    setDiagnosticsStatus(DIAGNOSTICS_STATUS_TERMINATED);
    stunClient.shutDown();
    return;
  }
  if (event == null) {
    logger.error(""String_Node_Str"" + addressEntry.toString());
    setDiagnosticsStatus(DIAGNOSTICS_STATUS_TERMINATED);
    stunClient.shutDown();
    return;
  }
  stunResponse=event.getMessage();
  mappedAttr=stunResponse.getAttribute(Attribute.MAPPED_ADDRESS);
  StunAddress mappedAddrFromSecServer=((MappedAddressAttribute)mappedAttr).getAddress();
  if (!mappedAddrFromTestI.equals(mappedAddrFromSecServer)) {
    logger.debug(""String_Node_Str"" + addressEntry.toString());
    setDiagnosticsStatus(DIAGNOSTICS_STATUS_TERMINATED);
    stunClient.shutDown();
    return;
  }
  try {
    event=stunClient.doStunTestIII(primaryStunServerAddress);
    logger.debug(""String_Node_Str"");
  }
 catch (  StunException ex) {
    logger.error(""String_Node_Str"" + addressEntry.toString(),ex);
    setDiagnosticsStatus(DIAGNOSTICS_STATUS_TERMINATED);
    stunClient.shutDown();
    return;
  }
  if (event == null) {
    logger.debug(""String_Node_Str"" + addressEntry.toString());
    setDiagnosticsStatus(DIAGNOSTICS_STATUS_TERMINATED);
    stunClient.shutDown();
    return;
  }
  logger.debug(""String_Node_Str"" + addressEntry.toString());
  setDiagnosticsStatus(DIAGNOSTICS_STATUS_TERMINATED);
  stunClient.shutDown();
}",0.999527722678757
104037,"/** 
 * Returns true if <tt>obj</tt> is the same object as this AddressPreference or is at least an instance of AddressPreference and has the same numerical value. In all other cases the method returns false.
 * @param obj the object to compare with
 * @return true if both objects represent the same preference value andfalse otherwise.
 */
public boolean equals(Object obj){
  if (!(obj instanceof AddressPreference) || obj == null)   return false;
  if (obj == this || ((AddressPreference)obj).preference == preference)   return true;
  return false;
}","/** 
 * Returns true if <tt>obj</tt> is the same object as this AddressPreference or is at least an instance of AddressPreference and has the same numerical value. In all other cases the method returns false.
 * @param obj the object to compare with
 * @return true if both objects represent the same preference value andfalse otherwise.
 */
public boolean equals(Object obj){
  if (!(obj instanceof AddressPreference))   return false;
  if (obj == this || ((AddressPreference)obj).preference == preference)   return true;
  return false;
}",0.9863013698630136
104038,"/** 
 * Compares this address preference with the specified object for order. Returns a negative integer, zero, or a positive integer as this AddressPreference is less than, equal to, or greater than the specified object.<p>
 * @param o the Object to be compared.
 * @return  a negative integer, zero, or a positive integer as this objectis less than, equal to, or greater than the specified object.
 * @throws ClassCastException if the specified object's type is not aninstance or a descendant of AddressPreference.
 */
public int compareTo(Object o){
  AddressPreference other=(AddressPreference)o;
  return this.preference - other.preference;
}","/** 
 * Compares this address preference with the specified object for order. Returns a negative integer, zero, or a positive integer as this AddressPreference is less than, equal to, or greater than the specified object.<p>
 * @param o the Object to be compared.
 * @return  a negative integer, zero, or a positive integer as this objectis less than, equal to, or greater than the specified object.
 * @throws ClassCastException if the specified object's type is not aninstance or a descendant of AddressPreference.
 */
public int compareTo(AddressPreference o){
  return this.preference - o.preference;
}",0.8810853950518756
104039,"/** 
 * Creates a NetworkAddressManager, starts it, and registers it as a NetworkAddressManagerService.
 * @param bundleContext  OSGI bundle context
 * @throws Exception if starting the NetworkAddressManagerFails.
 */
public void start(BundleContext bundleContext) throws Exception {
  try {
    logger.logEntry();
    this.bundleContext=bundleContext;
    networkAMS=new NetworkAddressManagerServiceImpl();
    networkAMS.start();
    logger.info(""String_Node_Str"");
    bundleContext.registerService(NetworkAddressManagerService.class.getName(),networkAMS,null);
    logger.info(""String_Node_Str"");
  }
  finally {
    logger.logExit();
  }
}","/** 
 * Creates a NetworkAddressManager, starts it, and registers it as a NetworkAddressManagerService.
 * @param bundleContext  OSGI bundle context
 * @throws Exception if starting the NetworkAddressManagerFails.
 */
public void start(BundleContext bundleContext) throws Exception {
  try {
    logger.logEntry();
    NetaddrActivator.bundleContext=bundleContext;
    networkAMS=new NetworkAddressManagerServiceImpl();
    networkAMS.start();
    logger.info(""String_Node_Str"");
    bundleContext.registerService(NetworkAddressManagerService.class.getName(),networkAMS,null);
    logger.info(""String_Node_Str"");
  }
  finally {
    logger.logExit();
  }
}",0.9846153846153848
104040,"/** 
 * Returns the set of actions registered for this event notification.
 * @return the set of actions registered for this event notification
 */
public Map getActions(){
  return actionsTable;
}","/** 
 * Returns the set of actions registered for this event notification.
 * @return the set of actions registered for this event notification
 */
public Map<String,Action> getActions(){
  return actionsTable;
}",0.9633251833740832
104041,"/** 
 * Returns the <tt>Action</tt> corresponding to the given <tt>actionType</tt>.
 * @param actionType one of NotificationService.ACTION_XXX constants
 * @return the <tt>Action</tt> corresponding to the given<tt>actionType</tt>
 */
public Action getAction(String actionType){
  return (Action)actionsTable.get(actionType);
}","/** 
 * Returns the <tt>Action</tt> corresponding to the given <tt>actionType</tt>.
 * @param actionType one of NotificationService.ACTION_XXX constants
 * @return the <tt>Action</tt> corresponding to the given<tt>actionType</tt>
 */
public Action getAction(String actionType){
  return actionsTable.get(actionType);
}",0.9875776397515528
104042,"/** 
 * Loads all previously saved event notifications.
 */
private void loadNotifications(){
  List<String> eventTypes=configService.getPropertyNamesByPrefix(NOTIFICATIONS_PREFIX,true);
  for (  String eventTypeRootPropName : eventTypes) {
    boolean isEventActive=isEnabled(eventTypeRootPropName + ""String_Node_Str"");
    String eventType=configService.getString(eventTypeRootPropName);
    List<String> actions=configService.getPropertyNamesByPrefix(eventTypeRootPropName + ""String_Node_Str"",true);
    for (    String actionPropName : actions) {
      String actionType=configService.getString(actionPropName);
      NotificationActionHandler handler=null;
      if (actionType.equals(ACTION_SOUND)) {
        String soundFileDescriptor=configService.getString(actionPropName + ""String_Node_Str"");
        String loopInterval=configService.getString(actionPropName + ""String_Node_Str"");
        handler=new SoundNotificationHandlerImpl(soundFileDescriptor,Integer.parseInt(loopInterval));
        handler.setEnabled(isEnabled(actionPropName + ""String_Node_Str""));
      }
 else       if (actionType.equals(ACTION_POPUP_MESSAGE)) {
        String defaultMessage=configService.getString(actionPropName + ""String_Node_Str"");
        handler=new PopupMessageNotificationHandlerImpl(defaultMessage);
        handler.setEnabled(isEnabled(actionPropName + ""String_Node_Str""));
      }
 else       if (actionType.equals(ACTION_LOG_MESSAGE)) {
        String logType=configService.getString(actionPropName + ""String_Node_Str"");
        handler=new LogMessageNotificationHandlerImpl(logType);
        handler.setEnabled(isEnabled(actionPropName + ""String_Node_Str""));
      }
 else       if (actionType.equals(ACTION_COMMAND)) {
        String commandDescriptor=configService.getString(actionPropName + ""String_Node_Str"");
        handler=new CommandNotificationHandlerImpl(commandDescriptor);
        handler.setEnabled(isEnabled(actionPropName + ""String_Node_Str""));
      }
      EventNotification notification=(EventNotification)notificationsTable.get(eventType);
      if (notification == null) {
        notification=new EventNotification(eventType);
        notificationsTable.put(eventType,notification);
      }
      notification.setActive(isEventActive);
      notification.addAction(actionType,handler);
    }
  }
}","/** 
 * Loads all previously saved event notifications.
 */
private void loadNotifications(){
  List<String> eventTypes=configService.getPropertyNamesByPrefix(NOTIFICATIONS_PREFIX,true);
  for (  String eventTypeRootPropName : eventTypes) {
    boolean isEventActive=isEnabled(eventTypeRootPropName + ""String_Node_Str"");
    String eventType=configService.getString(eventTypeRootPropName);
    List<String> actions=configService.getPropertyNamesByPrefix(eventTypeRootPropName + ""String_Node_Str"",true);
    for (    String actionPropName : actions) {
      String actionType=configService.getString(actionPropName);
      NotificationActionHandler handler=null;
      if (actionType.equals(ACTION_SOUND)) {
        String soundFileDescriptor=configService.getString(actionPropName + ""String_Node_Str"");
        String loopInterval=configService.getString(actionPropName + ""String_Node_Str"");
        handler=new SoundNotificationHandlerImpl(soundFileDescriptor,Integer.parseInt(loopInterval));
        handler.setEnabled(isEnabled(actionPropName + ""String_Node_Str""));
      }
 else       if (actionType.equals(ACTION_POPUP_MESSAGE)) {
        String defaultMessage=configService.getString(actionPropName + ""String_Node_Str"");
        handler=new PopupMessageNotificationHandlerImpl(defaultMessage);
        handler.setEnabled(isEnabled(actionPropName + ""String_Node_Str""));
      }
 else       if (actionType.equals(ACTION_LOG_MESSAGE)) {
        String logType=configService.getString(actionPropName + ""String_Node_Str"");
        handler=new LogMessageNotificationHandlerImpl(logType);
        handler.setEnabled(isEnabled(actionPropName + ""String_Node_Str""));
      }
 else       if (actionType.equals(ACTION_COMMAND)) {
        String commandDescriptor=configService.getString(actionPropName + ""String_Node_Str"");
        handler=new CommandNotificationHandlerImpl(commandDescriptor);
        handler.setEnabled(isEnabled(actionPropName + ""String_Node_Str""));
      }
      EventNotification notification=notificationsTable.get(eventType);
      if (notification == null) {
        notification=new EventNotification(eventType);
        notificationsTable.put(eventType,notification);
      }
      notification.setActive(isEventActive);
      notification.addAction(actionType,handler);
    }
  }
}",0.995891891891892
104043,"/** 
 * Notifies all registered <tt>NotificationChangeListener</tt>s that a <tt>NotificationActionTypeEvent</tt> has occurred.
 * @param eventType the type of the event, which is one of ACTION_XXXconstants declared in the <tt>NotificationActionTypeEvent</tt> class.
 * @param sourceEventType the <tt>eventType</tt>, which is the parent of theaction
 * @param sourceActionType the <tt>actionType</tt>, for which the event isabout
 * @param actionHandler the notification action handler
 */
private void fireNotificationActionTypeEvent(String eventType,String sourceEventType,String sourceActionType,NotificationActionHandler actionHandler){
  NotificationActionTypeEvent event=new NotificationActionTypeEvent(this,eventType,sourceEventType,sourceActionType,actionHandler);
  NotificationChangeListener listener;
  for (int i=0; i < changeListeners.size(); i++) {
    listener=(NotificationChangeListener)changeListeners.get(i);
    if (eventType.equals(NotificationActionTypeEvent.ACTION_ADDED)) {
      listener.actionAdded(event);
    }
 else     if (eventType.equals(NotificationActionTypeEvent.ACTION_REMOVED)) {
      listener.actionRemoved(event);
    }
 else     if (eventType.equals(NotificationActionTypeEvent.ACTION_CHANGED)) {
      listener.actionChanged(event);
    }
  }
}","/** 
 * Notifies all registered <tt>NotificationChangeListener</tt>s that a <tt>NotificationActionTypeEvent</tt> has occurred.
 * @param eventType the type of the event, which is one of ACTION_XXXconstants declared in the <tt>NotificationActionTypeEvent</tt> class.
 * @param sourceEventType the <tt>eventType</tt>, which is the parent of theaction
 * @param sourceActionType the <tt>actionType</tt>, for which the event isabout
 * @param actionHandler the notification action handler
 */
private void fireNotificationActionTypeEvent(String eventType,String sourceEventType,String sourceActionType,NotificationActionHandler actionHandler){
  NotificationActionTypeEvent event=new NotificationActionTypeEvent(this,eventType,sourceEventType,sourceActionType,actionHandler);
  NotificationChangeListener listener;
  for (int i=0; i < changeListeners.size(); i++) {
    listener=changeListeners.get(i);
    if (eventType.equals(NotificationActionTypeEvent.ACTION_ADDED)) {
      listener.actionAdded(event);
    }
 else     if (eventType.equals(NotificationActionTypeEvent.ACTION_REMOVED)) {
      listener.actionRemoved(event);
    }
 else     if (eventType.equals(NotificationActionTypeEvent.ACTION_CHANGED)) {
      listener.actionChanged(event);
    }
  }
}",0.988985051140834
104044,"/** 
 * Returns the notification handler corresponding to the given <tt>eventType</tt> and <tt>actionType</tt>.
 * @param eventType the type of the event that we'd like to retrieve.
 * @param actionType the type of the action that we'd like to retrieve adescriptor for.
 * @return the notification handler of the action to be executedwhen an event of the specified type has occurred.
 */
public NotificationActionHandler getEventNotificationActionHandler(String eventType,String actionType){
  EventNotification notification=(EventNotification)notificationsTable.get(eventType);
  if (notification == null)   return null;
  EventNotification.Action action=notification.getAction(actionType);
  if (action == null)   return null;
  return action.getActionHandler();
}","/** 
 * Returns the notification handler corresponding to the given <tt>eventType</tt> and <tt>actionType</tt>.
 * @param eventType the type of the event that we'd like to retrieve.
 * @param actionType the type of the action that we'd like to retrieve adescriptor for.
 * @return the notification handler of the action to be executedwhen an event of the specified type has occurred.
 */
public NotificationActionHandler getEventNotificationActionHandler(String eventType,String actionType){
  EventNotification notification=notificationsTable.get(eventType);
  if (notification == null)   return null;
  EventNotification.Action action=notification.getAction(actionType);
  if (action == null)   return null;
  return action.getActionHandler();
}",0.9874421678783872
104045,"/** 
 * Finds the <tt>EventNotification</tt> corresponding to the given <tt>eventType</tt> and returns its isActive status.
 * @param eventType the name of the event (as defined by the plugin that'sregistered it) that we are checking.
 * @return <code>true</code> if actions for the specified <tt>eventType</tt>are activated, <code>false</code> - otherwise. If the given <tt>eventType</tt> is not contained in the list of registered event types - returns <code>false</code>.
 */
public boolean isActive(String eventType){
  EventNotification eventNotification=(EventNotification)notificationsTable.get(eventType);
  if (eventNotification == null)   return false;
  return eventNotification.isActive();
}","/** 
 * Finds the <tt>EventNotification</tt> corresponding to the given <tt>eventType</tt> and returns its isActive status.
 * @param eventType the name of the event (as defined by the plugin that'sregistered it) that we are checking.
 * @return <code>true</code> if actions for the specified <tt>eventType</tt>are activated, <code>false</code> - otherwise. If the given <tt>eventType</tt> is not contained in the list of registered event types - returns <code>false</code>.
 */
public boolean isActive(String eventType){
  EventNotification eventNotification=notificationsTable.get(eventType);
  if (eventNotification == null)   return false;
  return eventNotification.isActive();
}",0.9863013698630136
104046,"/** 
 * Deletes all registered events and actions  and registers and saves the default events as current.
 */
public void restoreDefaults(){
  Set<String> eventTypes=((Hashtable<String,EventNotification>)notificationsTable.clone()).keySet();
  for (  String eventType : eventTypes) {
    EventNotification notification=notificationsTable.get(eventType);
    Vector actionsToRemove=new Vector(notification.getActions().keySet());
    Iterator actionIter=actionsToRemove.iterator();
    while (actionIter.hasNext()) {
      String actionType=(String)actionIter.next();
      removeEventNotificationAction(eventType,actionType);
    }
    removeEventNotification(eventType);
  }
  for (  Map.Entry<String,EventNotification> entry : defaultNotificationsTable.entrySet()) {
    String eventType=entry.getKey();
    EventNotification notification=entry.getValue();
    Iterator actionIter=notification.getActions().keySet().iterator();
    while (actionIter.hasNext()) {
      String actionType=(String)actionIter.next();
      registerNotificationForEvent(eventType,actionType,notification.getAction(actionType).getActionHandler());
    }
  }
}","/** 
 * Deletes all registered events and actions  and registers and saves the default events as current.
 */
public void restoreDefaults(){
  Set<String> eventTypes=((Hashtable<String,EventNotification>)notificationsTable.clone()).keySet();
  for (  String eventType : eventTypes) {
    EventNotification notification=notificationsTable.get(eventType);
    Vector<String> actionsToRemove=new Vector<String>(notification.getActions().keySet());
    Iterator<String> actionIter=actionsToRemove.iterator();
    while (actionIter.hasNext()) {
      String actionType=actionIter.next();
      removeEventNotificationAction(eventType,actionType);
    }
    removeEventNotification(eventType);
  }
  for (  Map.Entry<String,EventNotification> entry : defaultNotificationsTable.entrySet()) {
    String eventType=entry.getKey();
    EventNotification notification=entry.getValue();
    Iterator<String> actionIter=notification.getActions().keySet().iterator();
    while (actionIter.hasNext()) {
      String actionType=actionIter.next();
      registerNotificationForEvent(eventType,actionType,notification.getAction(actionType).getActionHandler());
    }
  }
}",0.979075850043592
104047,"/** 
 * Creates a new default <tt>EventNotification</tt> or obtains the corresponding existing one and registers a new action in it.
 * @param eventType the name of the event (as defined by the plugin that'sregistering it) that we are setting an action for.
 * @param actionType the type of the action that is to be executed when thespecified event occurs (could be one of the ACTION_XXX fields).
 * @param actionDescriptor a String containing a description of the action(a URI to the sound file for audio notifications or a command line for exec action types) that should be executed when the action occurs.
 * @param defaultMessage the default message to use if no specific messagehas been provided when firing the notification.
 */
public void registerDefaultNotificationForEvent(String eventType,String actionType,String actionDescriptor,String defaultMessage){
  logger.debug(""String_Node_Str"" + eventType + ""String_Node_Str""+ actionType+ ""String_Node_Str""+ actionDescriptor+ ""String_Node_Str""+ defaultMessage);
  if (isDefault(eventType,actionType)) {
    NotificationActionHandler handler=getEventNotificationActionHandler(eventType,actionType);
    boolean isNew=false;
    if (handler == null) {
      isNew=true;
      if (actionType.equals(NotificationService.ACTION_SOUND)) {
        handler=new SoundNotificationHandlerImpl(actionDescriptor,-1);
      }
 else       if (actionType.equals(NotificationService.ACTION_LOG_MESSAGE)) {
        handler=new LogMessageNotificationHandlerImpl(LogMessageNotificationHandler.INFO_LOG_TYPE);
      }
 else       if (actionType.equals(NotificationService.ACTION_POPUP_MESSAGE)) {
        handler=new PopupMessageNotificationHandlerImpl(defaultMessage);
      }
 else       if (actionType.equals(NotificationService.ACTION_COMMAND)) {
        handler=new CommandNotificationHandlerImpl(actionDescriptor);
      }
    }
    this.saveNotification(eventType,actionType,handler,handler.isEnabled(),true);
    EventNotification notification=null;
    if (notificationsTable.containsKey(eventType))     notification=(EventNotification)notificationsTable.get(eventType);
 else {
      notification=new EventNotification(eventType);
      notificationsTable.put(eventType,notification);
    }
    notification.addAction(actionType,handler);
    fireNotificationActionTypeEvent(isNew ? NotificationActionTypeEvent.ACTION_ADDED : NotificationActionTypeEvent.ACTION_CHANGED,eventType,actionType,handler);
  }
  EventNotification notification=null;
  if (defaultNotificationsTable.containsKey(eventType))   notification=defaultNotificationsTable.get(eventType);
 else {
    notification=new EventNotification(eventType);
    defaultNotificationsTable.put(eventType,notification);
  }
  NotificationActionHandler handler=null;
  if (actionType.equals(NotificationService.ACTION_SOUND)) {
    handler=new SoundNotificationHandlerImpl(actionDescriptor,-1);
  }
 else   if (actionType.equals(NotificationService.ACTION_LOG_MESSAGE)) {
    handler=new LogMessageNotificationHandlerImpl(LogMessageNotificationHandler.INFO_LOG_TYPE);
  }
 else   if (actionType.equals(NotificationService.ACTION_POPUP_MESSAGE)) {
    handler=new PopupMessageNotificationHandlerImpl(defaultMessage);
  }
 else   if (actionType.equals(NotificationService.ACTION_COMMAND)) {
    handler=new CommandNotificationHandlerImpl(actionDescriptor);
  }
  notification.addAction(actionType,handler);
}","/** 
 * Creates a new default <tt>EventNotification</tt> or obtains the corresponding existing one and registers a new action in it.
 * @param eventType the name of the event (as defined by the plugin that'sregistering it) that we are setting an action for.
 * @param actionType the type of the action that is to be executed when thespecified event occurs (could be one of the ACTION_XXX fields).
 * @param actionDescriptor a String containing a description of the action(a URI to the sound file for audio notifications or a command line for exec action types) that should be executed when the action occurs.
 * @param defaultMessage the default message to use if no specific messagehas been provided when firing the notification.
 */
public void registerDefaultNotificationForEvent(String eventType,String actionType,String actionDescriptor,String defaultMessage){
  logger.debug(""String_Node_Str"" + eventType + ""String_Node_Str""+ actionType+ ""String_Node_Str""+ actionDescriptor+ ""String_Node_Str""+ defaultMessage);
  if (isDefault(eventType,actionType)) {
    NotificationActionHandler handler=getEventNotificationActionHandler(eventType,actionType);
    boolean isNew=false;
    if (handler == null) {
      isNew=true;
      if (actionType.equals(NotificationService.ACTION_SOUND)) {
        handler=new SoundNotificationHandlerImpl(actionDescriptor,-1);
      }
 else       if (actionType.equals(NotificationService.ACTION_LOG_MESSAGE)) {
        handler=new LogMessageNotificationHandlerImpl(LogMessageNotificationHandler.INFO_LOG_TYPE);
      }
 else       if (actionType.equals(NotificationService.ACTION_POPUP_MESSAGE)) {
        handler=new PopupMessageNotificationHandlerImpl(defaultMessage);
      }
 else       if (actionType.equals(NotificationService.ACTION_COMMAND)) {
        handler=new CommandNotificationHandlerImpl(actionDescriptor);
      }
    }
    this.saveNotification(eventType,actionType,handler,handler.isEnabled(),true);
    EventNotification notification=null;
    if (notificationsTable.containsKey(eventType))     notification=notificationsTable.get(eventType);
 else {
      notification=new EventNotification(eventType);
      notificationsTable.put(eventType,notification);
    }
    notification.addAction(actionType,handler);
    fireNotificationActionTypeEvent(isNew ? NotificationActionTypeEvent.ACTION_ADDED : NotificationActionTypeEvent.ACTION_CHANGED,eventType,actionType,handler);
  }
  EventNotification notification=null;
  if (defaultNotificationsTable.containsKey(eventType))   notification=defaultNotificationsTable.get(eventType);
 else {
    notification=new EventNotification(eventType);
    defaultNotificationsTable.put(eventType,notification);
  }
  NotificationActionHandler handler=null;
  if (actionType.equals(NotificationService.ACTION_SOUND)) {
    handler=new SoundNotificationHandlerImpl(actionDescriptor,-1);
  }
 else   if (actionType.equals(NotificationService.ACTION_LOG_MESSAGE)) {
    handler=new LogMessageNotificationHandlerImpl(LogMessageNotificationHandler.INFO_LOG_TYPE);
  }
 else   if (actionType.equals(NotificationService.ACTION_POPUP_MESSAGE)) {
    handler=new PopupMessageNotificationHandlerImpl(defaultMessage);
  }
 else   if (actionType.equals(NotificationService.ACTION_COMMAND)) {
    handler=new CommandNotificationHandlerImpl(actionDescriptor);
  }
  notification.addAction(actionType,handler);
}",0.997200530425814
104048,"/** 
 * Returns an iterator over a list of all events registered in this notification service. Each line in the returned list consists of a String, representing the name of the event (as defined by the plugin that registered it).
 * @return an iterator over a list of all events registered in thisnotifications service
 */
public Iterator getRegisteredEvents(){
  return Collections.unmodifiableSet(notificationsTable.keySet()).iterator();
}","/** 
 * Returns an iterator over a list of all events registered in this notification service. Each line in the returned list consists of a String, representing the name of the event (as defined by the plugin that registered it).
 * @return an iterator over a list of all events registered in thisnotifications service
 */
public Iterator<String> getRegisteredEvents(){
  return Collections.unmodifiableSet(notificationsTable.keySet()).iterator();
}",0.991011235955056
104049,"/** 
 * Removes the given actionType from the list of actions registered for the given <tt>eventType</tt>.
 * @param eventType the name of the event (as defined by the plugin that'sregistering it) for which we'll remove the notification.
 * @param actionType the type of the action that is to be executed when thespecified event occurs (could be one of the ACTION_XXX fields).
 */
public void removeEventNotificationAction(String eventType,String actionType){
  EventNotification notification=(EventNotification)notificationsTable.get(eventType);
  if (notification == null)   return;
  Action action=notification.getAction(actionType);
  if (action == null)   return;
  notification.removeAction(actionType);
  saveNotification(eventType,actionType,action.getActionHandler(),false,false);
  fireNotificationActionTypeEvent(NotificationActionTypeEvent.ACTION_REMOVED,eventType,action.getActionType(),action.getActionHandler());
}","/** 
 * Removes the given actionType from the list of actions registered for the given <tt>eventType</tt>.
 * @param eventType the name of the event (as defined by the plugin that'sregistering it) for which we'll remove the notification.
 * @param actionType the type of the action that is to be executed when thespecified event occurs (could be one of the ACTION_XXX fields).
 */
public void removeEventNotificationAction(String eventType,String actionType){
  EventNotification notification=notificationsTable.get(eventType);
  if (notification == null)   return;
  Action action=notification.getAction(actionType);
  if (action == null)   return;
  notification.removeAction(actionType);
  saveNotification(eventType,actionType,action.getActionHandler(),false,false);
  fireNotificationActionTypeEvent(NotificationActionTypeEvent.ACTION_REMOVED,eventType,action.getActionType(),action.getActionHandler());
}",0.989668297988037
104050,"/** 
 * Stores an account represented in the form of an <code>AccountID</code> created by a specific <code>ProtocolProviderFactory</code>.
 * @param factory the <code>ProtocolProviderFactory</code> which created theaccount to be stored
 * @param accountID the account in the form of <code>AccountID</code> to bestored
 */
public void storeAccount(ProtocolProviderFactory factory,AccountID accountID){
  ConfigurationService configurationService=getConfigurationService();
  String factoryPackage=getFactoryImplPackageName(factory);
  List<String> storedAccounts=configurationService.getPropertyNamesByPrefix(factoryPackage,true);
  String accountUID=accountID.getAccountUniqueID();
  String accountNodeName=null;
  for (Iterator<String> storedAccountIter=storedAccounts.iterator(); storedAccountIter.hasNext(); ) {
    String storedAccount=storedAccountIter.next();
    String storedAccountUID=configurationService.getString(storedAccount + ""String_Node_Str"");
    if (storedAccountUID.equals(accountUID)) {
      accountNodeName=configurationService.getString(storedAccount);
    }
  }
  if (accountNodeName == null) {
    accountNodeName=""String_Node_Str"" + Long.toString(System.currentTimeMillis());
    configurationService.setProperty(factoryPackage + ""String_Node_Str"" + accountNodeName,accountNodeName);
    configurationService.setProperty(factoryPackage + ""String_Node_Str"" + accountNodeName+ ""String_Node_Str""+ ProtocolProviderFactory.ACCOUNT_UID,accountID.getAccountUniqueID());
  }
  Map<?,?> accountProperties=accountID.getAccountProperties();
  for (  Map.Entry entry : accountProperties.entrySet()) {
    String property=(String)entry.getKey();
    String value=(String)entry.getValue();
    if (property.equals(ProtocolProviderFactory.PASSWORD))     value=new String(Base64.encode(value.getBytes()));
    configurationService.setProperty(factoryPackage + ""String_Node_Str"" + accountNodeName+ ""String_Node_Str""+ property,value);
  }
  logger.debug(""String_Node_Str"" + accountID.getAccountUniqueID() + ""String_Node_Str""+ factoryPackage);
}","/** 
 * Stores an account represented in the form of an <code>AccountID</code> created by a specific <code>ProtocolProviderFactory</code>.
 * @param factory the <code>ProtocolProviderFactory</code> which created theaccount to be stored
 * @param accountID the account in the form of <code>AccountID</code> to bestored
 */
public void storeAccount(ProtocolProviderFactory factory,AccountID accountID){
  ConfigurationService configurationService=getConfigurationService();
  String factoryPackage=getFactoryImplPackageName(factory);
  List<String> storedAccounts=configurationService.getPropertyNamesByPrefix(factoryPackage,true);
  String accountUID=accountID.getAccountUniqueID();
  String accountNodeName=null;
  for (Iterator<String> storedAccountIter=storedAccounts.iterator(); storedAccountIter.hasNext(); ) {
    String storedAccount=storedAccountIter.next();
    String storedAccountUID=configurationService.getString(storedAccount + ""String_Node_Str"");
    if (storedAccountUID.equals(accountUID)) {
      accountNodeName=configurationService.getString(storedAccount);
    }
  }
  if (accountNodeName == null) {
    accountNodeName=""String_Node_Str"" + Long.toString(System.currentTimeMillis());
    configurationService.setProperty(factoryPackage + ""String_Node_Str"" + accountNodeName,accountNodeName);
    configurationService.setProperty(factoryPackage + ""String_Node_Str"" + accountNodeName+ ""String_Node_Str""+ ProtocolProviderFactory.ACCOUNT_UID,accountID.getAccountUniqueID());
  }
  Map<String,String> accountProperties=accountID.getAccountProperties();
  for (  Map.Entry<String,String> entry : accountProperties.entrySet()) {
    String property=entry.getKey();
    String value=entry.getValue();
    if (property.equals(ProtocolProviderFactory.PASSWORD))     value=new String(Base64.encode(value.getBytes()));
    configurationService.setProperty(factoryPackage + ""String_Node_Str"" + accountNodeName+ ""String_Node_Str""+ property,value);
  }
  logger.debug(""String_Node_Str"" + accountID.getAccountUniqueID() + ""String_Node_Str""+ factoryPackage);
}",0.98906439854192
104051,"/** 
 * Custom engine initialization method. This allows to explicit specify if the engine starts with auto-sensing or not.
 * @param zidFilename The ZID file name
 * @param autoEnable Set this true to start with auto-sensing and false todisable it.
 * @return true if initialization fails, false if succeeds
 */
public synchronized boolean initialize(String zidFilename,boolean autoEnable){
  BundleContext bc=MediaActivator.getBundleContext();
  ServiceReference faServiceReference=bc.getServiceReference(FileAccessService.class.getName());
  FileAccessService faService=(FileAccessService)bc.getService(faServiceReference);
  File file=null;
  try {
    file=faService.getPrivatePersistentFile(zidFilename);
  }
 catch (  Exception e) {
    logger.warn(""String_Node_Str"");
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"",e);
  }
  String zidFilePath=null;
  try {
    zidFilePath=file.getAbsolutePath();
  }
 catch (  SecurityException e) {
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"",e);
  }
  ZidFile zf=ZidFile.getInstance();
  if (!zf.isOpen()) {
    String fname;
    if (zidFilePath == null) {
      String home=System.getenv(""String_Node_Str"");
      String baseDir=(home != null) ? ((home) + (""String_Node_Str"")) : ""String_Node_Str"";
      fname=baseDir + ""String_Node_Str"";
      zidFilename=fname;
    }
 else {
      zidFilename=zidFilePath;
    }
    if (zf.open(zidFilename) < 0) {
      return false;
    }
  }
  zrtpEngine=new ZRtp(zf.getZid(),this,clientIdString);
  if (timeoutProvider == null) {
    timeoutProvider=new TimeoutProvider(""String_Node_Str"");
    timeoutProvider.setDaemon(true);
    timeoutProvider.start();
  }
  enableZrtp=autoEnable;
  return true;
}","/** 
 * Custom engine initialization method. This allows to explicit specify if the engine starts with auto-sensing or not.
 * @param zidFilename The ZID file name
 * @param autoEnable Set this true to start with auto-sensing and false todisable it.
 * @return true if initialization fails, false if succeeds
 */
public synchronized boolean initialize(String zidFilename,boolean autoEnable){
  BundleContext bc=MediaActivator.getBundleContext();
  ServiceReference faServiceReference=bc.getServiceReference(FileAccessService.class.getName());
  FileAccessService faService=(FileAccessService)bc.getService(faServiceReference);
  File file=null;
  try {
    file=faService.getPrivatePersistentFile(zidFilename);
  }
 catch (  Exception e) {
    logger.warn(""String_Node_Str"");
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"",e);
  }
  String zidFilePath=null;
  try {
    if (file != null)     zidFilePath=file.getAbsolutePath();
  }
 catch (  SecurityException e) {
    if (logger.isDebugEnabled())     logger.debug(""String_Node_Str"",e);
  }
  ZidFile zf=ZidFile.getInstance();
  if (!zf.isOpen()) {
    String fname;
    if (zidFilePath == null) {
      String home=System.getenv(""String_Node_Str"");
      String baseDir=(home != null) ? ((home) + (""String_Node_Str"")) : ""String_Node_Str"";
      fname=baseDir + ""String_Node_Str"";
      zidFilename=fname;
    }
 else {
      zidFilename=zidFilePath;
    }
    if (zf.open(zidFilename) < 0) {
      return false;
    }
  }
  zrtpEngine=new ZRtp(zf.getZid(),this,clientIdString);
  if (timeoutProvider == null) {
    timeoutProvider=new TimeoutProvider(""String_Node_Str"");
    timeoutProvider.setDaemon(true);
    timeoutProvider.start();
  }
  enableZrtp=autoEnable;
  return true;
}",0.993689041881813
104052,"/** 
 * Encodes the input buffer passing it to the output one
 * @param inputBuffer Buffer
 * @param outputBuffer Buffer
 * @return int
 */
public int process(Buffer inputBuffer,Buffer outputBuffer){
  if (!checkInputBuffer(inputBuffer)) {
    return BUFFER_PROCESSED_FAILED;
  }
  if (isEOM(inputBuffer)) {
    propagateEOM(outputBuffer);
    return BUFFER_PROCESSED_OK;
  }
  Format newFormat=inputBuffer.getFormat();
  if (lastFormat != newFormat) {
    initConverter((AudioFormat)newFormat);
  }
  int inpLength=inputBuffer.getLength();
  int outLength=calculateOutputSize(inputBuffer.getLength());
  byte[] inpData=(byte[])inputBuffer.getData();
  byte[] outData=validateByteArraySize(outputBuffer,outLength);
  pcm162alaw(inpData,inputBuffer.getOffset(),outData,0,outData.length,bigEndian);
  updateOutput(outputBuffer,outputFormat,outLength,0);
  return BUFFER_PROCESSED_OK;
}","/** 
 * Encodes the input buffer passing it to the output one
 * @param inputBuffer Buffer
 * @param outputBuffer Buffer
 * @return int
 */
public int process(Buffer inputBuffer,Buffer outputBuffer){
  if (!checkInputBuffer(inputBuffer)) {
    return BUFFER_PROCESSED_FAILED;
  }
  if (isEOM(inputBuffer)) {
    propagateEOM(outputBuffer);
    return BUFFER_PROCESSED_OK;
  }
  Format newFormat=inputBuffer.getFormat();
  if (lastFormat != newFormat) {
    initConverter((AudioFormat)newFormat);
  }
  int outLength=calculateOutputSize(inputBuffer.getLength());
  byte[] inpData=(byte[])inputBuffer.getData();
  byte[] outData=validateByteArraySize(outputBuffer,outLength);
  pcm162alaw(inpData,inputBuffer.getOffset(),outData,0,outData.length,bigEndian);
  updateOutput(outputBuffer,outputFormat,outLength,0);
  return BUFFER_PROCESSED_OK;
}",0.976231884057971
104053,"protected Format[] getMatchingOutputFormats(Format in){
  AudioFormat inFormat=(AudioFormat)in;
  int channels=inFormat.getChannels();
  int sampleRate=(int)(inFormat.getSampleRate());
  supportedOutputFormats=new AudioFormat[]{new AudioFormat(AudioFormat.ALAW,sampleRate,8,1,Format.NOT_SPECIFIED,Format.NOT_SPECIFIED)};
  return supportedOutputFormats;
}","protected Format[] getMatchingOutputFormats(Format in){
  AudioFormat inFormat=(AudioFormat)in;
  int sampleRate=(int)(inFormat.getSampleRate());
  supportedOutputFormats=new AudioFormat[]{new AudioFormat(AudioFormat.ALAW,sampleRate,8,1,Format.NOT_SPECIFIED,Format.NOT_SPECIFIED)};
  return supportedOutputFormats;
}",0.9418777943368108
104054,"public java.lang.Object[] getControls(){
  if (controls == null) {
    controls=new Control[1];
    controls[0]=new PacketSizeAdapter(this,packetSize,true);
  }
  return (Object[])controls;
}","public java.lang.Object[] getControls(){
  if (controls == null) {
    controls=new Control[1];
    controls[0]=new PacketSizeAdapter(this,packetSize,true);
  }
  return controls;
}",0.9731182795698924
104055,"public java.lang.Object[] getControls(){
  if (controls == null) {
    controls=new Control[1];
    controls[0]=new com.sun.media.controls.SilenceSuppressionAdapter(this,false,false);
  }
  return (Object[])controls;
}","public java.lang.Object[] getControls(){
  if (controls == null) {
    controls=new Control[1];
    controls[0]=new com.sun.media.controls.SilenceSuppressionAdapter(this,false,false);
  }
  return controls;
}",0.976525821596244
104056,"public java.lang.Object[] getControls(){
  if (controls == null) {
    controls=new Control[1];
    controls[0]=new com.sun.media.controls.SilenceSuppressionAdapter(this,false,false);
  }
  return (Object[])controls;
}","public java.lang.Object[] getControls(){
  if (controls == null) {
    controls=new Control[1];
    controls[0]=new com.sun.media.controls.SilenceSuppressionAdapter(this,false,false);
  }
  return controls;
}",0.976525821596244
104057,"protected Format[] getMatchingOutputFormats(Format in){
  AudioFormat af=(AudioFormat)in;
  supportedOutputFormats=new AudioFormat[]{new AudioFormat(Constants.ILBC_RTP,8000.0,16,1,AudioFormat.LITTLE_ENDIAN,AudioFormat.SIGNED)};
  return supportedOutputFormats;
}","protected Format[] getMatchingOutputFormats(Format in){
  supportedOutputFormats=new AudioFormat[]{new AudioFormat(Constants.ILBC_RTP,8000.0,16,1,AudioFormat.LITTLE_ENDIAN,AudioFormat.SIGNED)};
  return supportedOutputFormats;
}",0.9306122448979592
104058,"public static float gaindequant(int index,float maxIn,int cblen){
  float scale;
  scale=(float)(float)Math.abs(maxIn);
  if (scale < 0.1) {
    scale=(float)0.1;
  }
  if (cblen == 8) {
    return scale * ilbc_constants.gain_sq3Tbl[index];
  }
 else   if (cblen == 16) {
    return scale * ilbc_constants.gain_sq4Tbl[index];
  }
 else   if (cblen == 32) {
    return scale * ilbc_constants.gain_sq5Tbl[index];
  }
  return 0.0f;
}","public static float gaindequant(int index,float maxIn,int cblen){
  float scale;
  scale=Math.abs(maxIn);
  if (scale < 0.1) {
    scale=(float)0.1;
  }
  if (cblen == 8) {
    return scale * ilbc_constants.gain_sq3Tbl[index];
  }
 else   if (cblen == 16) {
    return scale * ilbc_constants.gain_sq4Tbl[index];
  }
 else   if (cblen == 32) {
    return scale * ilbc_constants.gain_sq5Tbl[index];
  }
  return 0.0f;
}",0.983490566037736
104059,"public static void interpolate(float out[],float in1[],float in2[],int in2_idx,float coef,int length){
  int i;
  float invcoef;
  invcoef=(float)1.0f - coef;
  for (i=0; i < length; i++) {
    out[i]=coef * in1[i] + invcoef * in2[i + in2_idx];
  }
}","public static void interpolate(float out[],float in1[],float in2[],int in2_idx,float coef,int length){
  int i;
  float invcoef;
  invcoef=1.0f - coef;
  for (i=0; i < length; i++) {
    out[i]=coef * in1[i] + invcoef * in2[i + in2_idx];
  }
}",0.9858012170385396
104060,"public static void iCBConstruct(float decvector[],int decvector_idx,int index[],int index_idx,int gain_index[],int gain_index_idx,float mem[],int mem_idx,int lMem,int veclen,int nStages){
  int j, k;
  float[] gain=new float[ilbc_constants.CB_NSTAGES];
  float[] cbvec=new float[ilbc_constants.SUBL];
  gain[0]=gaindequant(gain_index[gain_index_idx + 0],1.0f,32);
  if (nStages > 1) {
    gain[1]=gaindequant(gain_index[gain_index_idx + 1],(float)(float)Math.abs(gain[0]),16);
  }
  if (nStages > 2) {
    gain[2]=gaindequant(gain_index[gain_index_idx + 2],(float)(float)Math.abs(gain[1]),8);
  }
  getCBvec(cbvec,mem,mem_idx,index[index_idx + 0],lMem,veclen);
  for (j=0; j < veclen; j++) {
    decvector[decvector_idx + j]=gain[0] * cbvec[j];
  }
  if (nStages > 1) {
    for (k=1; k < nStages; k++) {
      getCBvec(cbvec,mem,mem_idx,index[index_idx + k],lMem,veclen);
      for (j=0; j < veclen; j++) {
        decvector[decvector_idx + j]+=gain[k] * cbvec[j];
      }
    }
  }
}","public static void iCBConstruct(float decvector[],int decvector_idx,int index[],int index_idx,int gain_index[],int gain_index_idx,float mem[],int mem_idx,int lMem,int veclen,int nStages){
  int j, k;
  float[] gain=new float[ilbc_constants.CB_NSTAGES];
  float[] cbvec=new float[ilbc_constants.SUBL];
  gain[0]=gaindequant(gain_index[gain_index_idx + 0],1.0f,32);
  if (nStages > 1) {
    gain[1]=gaindequant(gain_index[gain_index_idx + 1],Math.abs(gain[0]),16);
  }
  if (nStages > 2) {
    gain[2]=gaindequant(gain_index[gain_index_idx + 2],Math.abs(gain[1]),8);
  }
  getCBvec(cbvec,mem,mem_idx,index[index_idx + 0],lMem,veclen);
  for (j=0; j < veclen; j++) {
    decvector[decvector_idx + j]=gain[0] * cbvec[j];
  }
  if (nStages > 1) {
    for (k=1; k < nStages; k++) {
      getCBvec(cbvec,mem,mem_idx,index[index_idx + k],lMem,veclen);
      for (j=0; j < veclen; j++) {
        decvector[decvector_idx + j]+=gain[k] * cbvec[j];
      }
    }
  }
}",0.9855670103092784
104061,"public static void getCBvec(float cbvec[],float mem[],int mem_idx,int index,int lMem,int cbveclen){
  int j, k, n, memInd, sFilt;
  float[] tmpbuf=new float[ilbc_constants.CB_MEML];
  int base_size;
  int ilow, ihigh;
  float alfa, alfa1;
  base_size=lMem - cbveclen + 1;
  if (cbveclen == ilbc_constants.SUBL) {
    base_size+=cbveclen / 2;
  }
  if (index < lMem - cbveclen + 1) {
    k=index + cbveclen;
    System.arraycopy(mem,mem_idx + lMem - k,cbvec,0,cbveclen);
  }
 else   if (index < base_size) {
    k=2 * (index - (lMem - cbveclen + 1)) + cbveclen;
    ihigh=k / 2;
    ilow=ihigh - 5;
    System.arraycopy(mem,mem_idx + lMem - k / 2,cbvec,0,ilow);
    alfa1=(float)0.2;
    alfa=0.0f;
    for (j=ilow; j < ihigh; j++) {
      cbvec[j]=((float)1.0f - alfa) * mem[mem_idx + lMem - k / 2 + j] + alfa * mem[mem_idx + lMem - k + j];
      alfa+=alfa1;
    }
    System.arraycopy(mem,mem_idx + lMem - k + ihigh,cbvec,ihigh,(cbveclen - ihigh));
  }
 else {
    if (index - base_size < lMem - cbveclen + 1) {
      float[] tempbuff2=new float[ilbc_constants.CB_MEML + ilbc_constants.CB_FILTERLEN + 1];
      int pos, pp, pp1;
      for (int li=0; li < ilbc_constants.CB_HALFFILTERLEN; li++)       tempbuff2[li]=0.0f;
      System.arraycopy(mem,mem_idx,tempbuff2,ilbc_constants.CB_HALFFILTERLEN,lMem);
      for (int li=0; li < ilbc_constants.CB_HALFFILTERLEN + 1; li++)       tempbuff2[lMem + ilbc_constants.CB_HALFFILTERLEN + li]=0.0f;
      k=index - base_size + cbveclen;
      sFilt=lMem - k;
      memInd=sFilt + 1 - ilbc_constants.CB_HALFFILTERLEN;
      pos=0;
      for (int li=0; li < cbveclen; li++)       cbvec[li]=0;
      for (n=0; n < cbveclen; n++) {
        pp=memInd + n + ilbc_constants.CB_HALFFILTERLEN;
        pp1=ilbc_constants.CB_FILTERLEN - 1;
        for (j=0; j < ilbc_constants.CB_FILTERLEN; j++) {
          cbvec[pos]+=tempbuff2[pp] * ilbc_constants.cbfiltersTbl[pp1];
          pp++;
          pp1--;
        }
        pos++;
      }
    }
 else {
      float[] tempbuff2=new float[ilbc_constants.CB_MEML + ilbc_constants.CB_FILTERLEN + 1];
      int pos, pp, pp1;
      int i;
      for (int li=0; li < ilbc_constants.CB_HALFFILTERLEN; li++)       tempbuff2[li]=0.0f;
      System.arraycopy(mem,mem_idx,tempbuff2,ilbc_constants.CB_HALFFILTERLEN,lMem);
      for (int li=0; li < ilbc_constants.CB_HALFFILTERLEN; li++)       tempbuff2[lMem + ilbc_constants.CB_HALFFILTERLEN + li]=0.0f;
      k=2 * (index - base_size - (lMem - cbveclen + 1)) + cbveclen;
      sFilt=lMem - k;
      memInd=sFilt + 1 - ilbc_constants.CB_HALFFILTERLEN;
      pos=sFilt;
      for (int li=0; li < k; li++)       tmpbuf[pos + li]=0.0f;
      for (i=0; i < k; i++) {
        pp=memInd + i + ilbc_constants.CB_HALFFILTERLEN;
        pp1=ilbc_constants.CB_FILTERLEN - 1;
        for (j=0; j < ilbc_constants.CB_FILTERLEN; j++) {
          tmpbuf[pos]+=tempbuff2[pp] * ilbc_constants.cbfiltersTbl[pp1];
          pp++;
          pp1--;
        }
        pos++;
      }
      ihigh=k / 2;
      ilow=ihigh - 5;
      System.arraycopy(tmpbuf,lMem - k / 2,cbvec,0,ilow);
      alfa1=(float)0.2;
      alfa=0.0f;
      for (j=ilow; j < ihigh; j++) {
        cbvec[j]=((float)1.0f - alfa) * tmpbuf[lMem - k / 2 + j] + alfa * tmpbuf[lMem - k + j];
        alfa+=alfa1;
      }
      System.arraycopy(tmpbuf,lMem - k + ihigh,cbvec,ihigh,cbveclen - ihigh);
    }
  }
}","public static void getCBvec(float cbvec[],float mem[],int mem_idx,int index,int lMem,int cbveclen){
  int j, k, n, memInd, sFilt;
  float[] tmpbuf=new float[ilbc_constants.CB_MEML];
  int base_size;
  int ilow, ihigh;
  float alfa, alfa1;
  base_size=lMem - cbveclen + 1;
  if (cbveclen == ilbc_constants.SUBL) {
    base_size+=cbveclen / 2;
  }
  if (index < lMem - cbveclen + 1) {
    k=index + cbveclen;
    System.arraycopy(mem,mem_idx + lMem - k,cbvec,0,cbveclen);
  }
 else   if (index < base_size) {
    k=2 * (index - (lMem - cbveclen + 1)) + cbveclen;
    ihigh=k / 2;
    ilow=ihigh - 5;
    System.arraycopy(mem,mem_idx + lMem - k / 2,cbvec,0,ilow);
    alfa1=(float)0.2;
    alfa=0.0f;
    for (j=ilow; j < ihigh; j++) {
      cbvec[j]=(1.0f - alfa) * mem[mem_idx + lMem - k / 2 + j] + alfa * mem[mem_idx + lMem - k + j];
      alfa+=alfa1;
    }
    System.arraycopy(mem,mem_idx + lMem - k + ihigh,cbvec,ihigh,(cbveclen - ihigh));
  }
 else {
    if (index - base_size < lMem - cbveclen + 1) {
      float[] tempbuff2=new float[ilbc_constants.CB_MEML + ilbc_constants.CB_FILTERLEN + 1];
      int pos, pp, pp1;
      for (int li=0; li < ilbc_constants.CB_HALFFILTERLEN; li++)       tempbuff2[li]=0.0f;
      System.arraycopy(mem,mem_idx,tempbuff2,ilbc_constants.CB_HALFFILTERLEN,lMem);
      for (int li=0; li < ilbc_constants.CB_HALFFILTERLEN + 1; li++)       tempbuff2[lMem + ilbc_constants.CB_HALFFILTERLEN + li]=0.0f;
      k=index - base_size + cbveclen;
      sFilt=lMem - k;
      memInd=sFilt + 1 - ilbc_constants.CB_HALFFILTERLEN;
      pos=0;
      for (int li=0; li < cbveclen; li++)       cbvec[li]=0;
      for (n=0; n < cbveclen; n++) {
        pp=memInd + n + ilbc_constants.CB_HALFFILTERLEN;
        pp1=ilbc_constants.CB_FILTERLEN - 1;
        for (j=0; j < ilbc_constants.CB_FILTERLEN; j++) {
          cbvec[pos]+=tempbuff2[pp] * ilbc_constants.cbfiltersTbl[pp1];
          pp++;
          pp1--;
        }
        pos++;
      }
    }
 else {
      float[] tempbuff2=new float[ilbc_constants.CB_MEML + ilbc_constants.CB_FILTERLEN + 1];
      int pos, pp, pp1;
      int i;
      for (int li=0; li < ilbc_constants.CB_HALFFILTERLEN; li++)       tempbuff2[li]=0.0f;
      System.arraycopy(mem,mem_idx,tempbuff2,ilbc_constants.CB_HALFFILTERLEN,lMem);
      for (int li=0; li < ilbc_constants.CB_HALFFILTERLEN; li++)       tempbuff2[lMem + ilbc_constants.CB_HALFFILTERLEN + li]=0.0f;
      k=2 * (index - base_size - (lMem - cbveclen + 1)) + cbveclen;
      sFilt=lMem - k;
      memInd=sFilt + 1 - ilbc_constants.CB_HALFFILTERLEN;
      pos=sFilt;
      for (int li=0; li < k; li++)       tmpbuf[pos + li]=0.0f;
      for (i=0; i < k; i++) {
        pp=memInd + i + ilbc_constants.CB_HALFFILTERLEN;
        pp1=ilbc_constants.CB_FILTERLEN - 1;
        for (j=0; j < ilbc_constants.CB_FILTERLEN; j++) {
          tmpbuf[pos]+=tempbuff2[pp] * ilbc_constants.cbfiltersTbl[pp1];
          pp++;
          pp1--;
        }
        pos++;
      }
      ihigh=k / 2;
      ilow=ihigh - 5;
      System.arraycopy(tmpbuf,lMem - k / 2,cbvec,0,ilow);
      alfa1=(float)0.2;
      alfa=0.0f;
      for (j=ilow; j < ihigh; j++) {
        cbvec[j]=(1.0f - alfa) * tmpbuf[lMem - k / 2 + j] + alfa * tmpbuf[lMem - k + j];
        alfa+=alfa1;
      }
      System.arraycopy(tmpbuf,lMem - k + ihigh,cbvec,ihigh,cbveclen - ihigh);
    }
  }
}",0.9979179060083284
104062,"/** 
 * Creates a chatroom, by specifying the chat room name and the parent protocol provider.
 * @param chatRoomName the name of the chat room to create.
 * @param protocolProvider the parent protocol provider.
 */
public ChatRoomWrapper createChatRoom(String chatRoomName,ProtocolProviderService protocolProvider){
  ChatRoomWrapper chatRoomWrapper=null;
  OperationSetMultiUserChat groupChatOpSet=(OperationSetMultiUserChat)protocolProvider.getOperationSet(OperationSetMultiUserChat.class);
  if (groupChatOpSet == null)   return null;
  ChatRoom chatRoom=null;
  try {
    chatRoom=groupChatOpSet.createChatRoom(chatRoomName,new Hashtable());
  }
 catch (  OperationFailedException ex) {
    logger.error(""String_Node_Str"",ex);
    new ErrorDialog(GuiActivator.getUIService().getMainFrame(),GuiActivator.getResources().getI18NString(""String_Node_Str""),GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{chatRoomName}),ex).showDialog();
  }
catch (  OperationNotSupportedException ex) {
    logger.error(""String_Node_Str"",ex);
    new ErrorDialog(GuiActivator.getUIService().getMainFrame(),GuiActivator.getResources().getI18NString(""String_Node_Str""),GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{chatRoomName}),ex).showDialog();
  }
  if (chatRoom != null) {
    ChatRoomProviderWrapper parentProvider=chatRoomList.findServerWrapperFromProvider(protocolProvider);
    chatRoomWrapper=new ChatRoomWrapper(parentProvider,chatRoom);
    chatRoomList.addChatRoom(chatRoomWrapper);
    fireChatRoomListChangedEvent(chatRoomWrapper,ChatRoomListChangeEvent.CHAT_ROOM_ADDED);
  }
  return chatRoomWrapper;
}","/** 
 * Creates a chatroom, by specifying the chat room name and the parent protocol provider.
 * @param chatRoomName the name of the chat room to create.
 * @param protocolProvider the parent protocol provider.
 */
public ChatRoomWrapper createChatRoom(String chatRoomName,ProtocolProviderService protocolProvider){
  ChatRoomWrapper chatRoomWrapper=null;
  OperationSetMultiUserChat groupChatOpSet=(OperationSetMultiUserChat)protocolProvider.getOperationSet(OperationSetMultiUserChat.class);
  if (groupChatOpSet == null)   return null;
  ChatRoom chatRoom=null;
  try {
    chatRoom=groupChatOpSet.createChatRoom(chatRoomName,null);
  }
 catch (  OperationFailedException ex) {
    logger.error(""String_Node_Str"",ex);
    new ErrorDialog(GuiActivator.getUIService().getMainFrame(),GuiActivator.getResources().getI18NString(""String_Node_Str""),GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{chatRoomName}),ex).showDialog();
  }
catch (  OperationNotSupportedException ex) {
    logger.error(""String_Node_Str"",ex);
    new ErrorDialog(GuiActivator.getUIService().getMainFrame(),GuiActivator.getResources().getI18NString(""String_Node_Str""),GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{chatRoomName}),ex).showDialog();
  }
  if (chatRoom != null) {
    ChatRoomProviderWrapper parentProvider=chatRoomList.findServerWrapperFromProvider(protocolProvider);
    chatRoomWrapper=new ChatRoomWrapper(parentProvider,chatRoom);
    chatRoomList.addChatRoom(chatRoomWrapper);
    fireChatRoomListChangedEvent(chatRoomWrapper,ChatRoomListChangeEvent.CHAT_ROOM_ADDED);
  }
  return chatRoomWrapper;
}",0.9948375341633768
104063,"/** 
 * Implements the <tt>ChatRoomMessageListener.messageReceived</tt> method. <br> Obtains the corresponding <tt>ChatPanel</tt> and proccess the message there.
 */
public void messageReceived(ChatRoomMessageReceivedEvent evt){
  ChatRoom sourceChatRoom=(ChatRoom)evt.getSource();
  ChatRoomMember sourceMember=evt.getSourceChatRoomMember();
  String messageType=null;
  if (evt.getEventType() == ChatRoomMessageReceivedEvent.CONVERSATION_MESSAGE_RECEIVED) {
    messageType=Constants.INCOMING_MESSAGE;
  }
 else   if (evt.getEventType() == ChatRoomMessageReceivedEvent.SYSTEM_MESSAGE_RECEIVED) {
    messageType=Constants.SYSTEM_MESSAGE;
  }
 else   if (evt.getEventType() == ChatRoomMessageReceivedEvent.ACTION_MESSAGE_RECEIVED) {
    messageType=Constants.ACTION_MESSAGE;
  }
  logger.trace(""String_Node_Str"" + sourceMember.getContactAddress());
  Message message=evt.getMessage();
  ChatPanel chatPanel=null;
  ChatWindowManager chatWindowManager=GuiActivator.getUIService().getChatWindowManager();
  if (sourceChatRoom.isSystem()) {
    ChatRoomProviderWrapper serverWrapper=chatRoomList.findServerWrapperFromProvider(sourceChatRoom.getParentProvider());
    chatPanel=chatWindowManager.getMultiChat(serverWrapper.getSystemRoomWrapper());
  }
 else {
    chatPanel=chatWindowManager.getMultiChat(sourceChatRoom,message.getMessageUID());
  }
  chatPanel.processMessage(sourceMember.getName(),evt.getTimestamp(),messageType,message.getContent(),message.getContentType());
  chatWindowManager.openChat(chatPanel,false);
  String title=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{sourceMember.getName()});
  NotificationManager.fireChatNotification(sourceChatRoom,NotificationManager.INCOMING_MESSAGE,title,message.getContent());
}","/** 
 * Implements the <tt>ChatRoomMessageListener.messageReceived</tt> method. <br> Obtains the corresponding <tt>ChatPanel</tt> and process the message there.
 */
public void messageReceived(ChatRoomMessageReceivedEvent evt){
  ChatRoom sourceChatRoom=(ChatRoom)evt.getSource();
  ChatRoomMember sourceMember=evt.getSourceChatRoomMember();
  String messageType=null;
switch (evt.getEventType()) {
case ChatRoomMessageReceivedEvent.CONVERSATION_MESSAGE_RECEIVED:
    messageType=Constants.INCOMING_MESSAGE;
  break;
case ChatRoomMessageReceivedEvent.SYSTEM_MESSAGE_RECEIVED:
messageType=Constants.SYSTEM_MESSAGE;
break;
case ChatRoomMessageReceivedEvent.ACTION_MESSAGE_RECEIVED:
messageType=Constants.ACTION_MESSAGE;
break;
}
logger.trace(""String_Node_Str"" + sourceMember.getContactAddress());
Message message=evt.getMessage();
ChatPanel chatPanel=null;
ChatWindowManager chatWindowManager=GuiActivator.getUIService().getChatWindowManager();
if (sourceChatRoom.isSystem()) {
ChatRoomProviderWrapper serverWrapper=chatRoomList.findServerWrapperFromProvider(sourceChatRoom.getParentProvider());
chatPanel=chatWindowManager.getMultiChat(serverWrapper.getSystemRoomWrapper());
}
 else {
chatPanel=chatWindowManager.getMultiChat(sourceChatRoom,message.getMessageUID());
}
String messageContent=message.getContent();
chatPanel.processMessage(sourceMember.getName(),evt.getTimestamp(),messageType,messageContent,message.getContentType());
chatWindowManager.openChat(chatPanel,false);
boolean fireChatNotification;
if (sourceChatRoom.isSystem() || isPrivate(sourceChatRoom) || (messageContent == null)) fireChatNotification=true;
 else {
String nickname=sourceChatRoom.getUserNickname();
fireChatNotification=(nickname == null) || messageContent.toLowerCase().contains(nickname.toLowerCase());
}
if (fireChatNotification) {
String title=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{sourceMember.getName()});
NotificationManager.fireChatNotification(sourceChatRoom,NotificationManager.INCOMING_MESSAGE,title,messageContent);
}
}",0.8031496062992126
104064,"public boolean isContactListSupported(){
  return !chatRoomWrapper.getChatRoom().isSystem();
}","public boolean isContactListSupported(){
  ChatRoom chatRoom=chatRoomWrapper.getChatRoom();
  return !chatRoom.isSystem() && !ConferenceChatManager.isPrivate(chatRoom);
}",0.6666666666666666
104065,"/** 
 * Creates a room with the named <tt>roomName</tt> and according to the specified <tt>roomProperties</tt> on the server that this protocol provider is currently connected to.
 * @param roomName the name of the <tt>ChatRoom</tt> to create.
 * @param roomProperties properties specifying how the room should becreated. Contains list of invitees and the invitation message.
 * @throws OperationFailedException if the room couldn't be created forsome reason (e.g. room already exists; user already joined to an existent room or user has no permissions to create a chat room).
 * @throws OperationNotSupportedException if chat room creation is notsupported by this server
 * @return ChatRoom the chat room that we've just created.
 */
public ChatRoom createChatRoom(String roomName,Hashtable roomProperties) throws OperationFailedException, OperationNotSupportedException {
  ChatRoom chatRoom=null;
  ChatRoomManager chatRoomManager=icqProvider.getAimConnection().getChatRoomManager();
  ChatRoomSession chatRoomSession=chatRoomManager.joinRoom(roomName);
  if (chatRoomSession != null) {
    chatRoom=new ChatRoomIcqImpl(roomName,chatRoomSession,icqProvider);
  }
  return chatRoom;
}","/** 
 * Creates a room with the named <tt>roomName</tt> and according to the specified <tt>roomProperties</tt> on the server that this protocol provider is currently connected to.
 * @param roomName the name of the <tt>ChatRoom</tt> to create.
 * @param roomProperties properties specifying how the room should becreated. Contains list of invitees and the invitation message.
 * @throws OperationFailedException if the room couldn't be created forsome reason (e.g. room already exists; user already joined to an existent room or user has no permissions to create a chat room).
 * @throws OperationNotSupportedException if chat room creation is notsupported by this server
 * @return ChatRoom the chat room that we've just created.
 */
public ChatRoom createChatRoom(String roomName,Map<String,Object> roomProperties) throws OperationFailedException, OperationNotSupportedException {
  ChatRoom chatRoom=null;
  ChatRoomManager chatRoomManager=icqProvider.getAimConnection().getChatRoomManager();
  ChatRoomSession chatRoomSession=chatRoomManager.joinRoom(roomName);
  if (chatRoomSession != null) {
    chatRoom=new ChatRoomIcqImpl(roomName,chatRoomSession,icqProvider);
  }
  return chatRoom;
}",0.9895002099958
104066,"/** 
 * Determines whether this chat room should be stored in the configuration file or not. If the chat room is persistent it still will be shown after a restart in the chat room list. A non-persistent chat room will be only in the chat room list until the the program is running.
 * @return true if this chat room is persistent, false otherwise
 */
public boolean isPersistent(){
  return true;
}","/** 
 * Determines whether this chat room should be stored in the configuration file or not. If the chat room is persistent it still will be shown after a restart in the chat room list. A non-persistent chat room will be only in the chat room list until the the program is running.
 * @return true if this chat room is persistent, false otherwise
 */
public boolean isPersistent(){
  return !isPrivate();
}",0.9800995024875622
104067,"/** 
 * Tests if this chat room is joined
 * @param chatRoom the chat room we want to test
 * @return true if the chat room is joined, false otherwise
 */
protected boolean isJoined(ChatRoomIrcImpl chatRoom){
  if (ircMUCOpSet.findSystemRoom().equals(chatRoom))   return isConnected();
  if (chatRoom.isPrivate())   return true;
  if (this.isConnected()) {
    String[] channels=this.getChannels();
    for (int i=0; i < channels.length; i++) {
      if (chatRoom.getName().equals(channels[i])) {
        return true;
      }
    }
    return false;
  }
 else {
    return false;
  }
}","/** 
 * Tests if this chat room is joined
 * @param chatRoom the chat room we want to test
 * @return true if the chat room is joined, false otherwise
 */
protected boolean isJoined(ChatRoomIrcImpl chatRoom){
  if (ircMUCOpSet.findSystemRoom().equals(chatRoom))   return isConnected();
  if (chatRoom.isPrivate())   return true;
  if (this.isConnected()) {
    String[] channels=this.getChannels();
    for (    String channel : channels) {
      if (chatRoom.getName().equals(channel))       return true;
    }
    return false;
  }
 else {
    return false;
  }
}",0.7391304347826086
104068,"/** 
 * This method is called whenever someone (possibly us) leaves a channel which we are on.
 * @param channel The channel which somebody parted from.
 * @param sender The nick of the user who parted from the channel.
 * @param login The login of the user who parted from the channel.
 * @param hostname The host name of the user who parted from the channel.
 */
protected void onPart(String channel,String sender,String login,String hostname){
  if (logger.isDebugEnabled())   logger.debug(""String_Node_Str"" + channel + ""String_Node_Str""+ sender+ ""String_Node_Str""+ login+ ""String_Node_Str""+ hostname);
  ChatRoomIrcImpl chatRoom=(ChatRoomIrcImpl)ircMUCOpSet.findRoom(channel);
  if (chatRoom.getUserNickname().equals(sender)) {
    ircMUCOpSet.fireLocalUserPresenceEvent(chatRoom,LocalUserChatRoomPresenceChangeEvent.LOCAL_USER_LEFT,""String_Node_Str"");
    Iterator members=chatRoom.getMembers().iterator();
    while (members.hasNext()) {
      ChatRoomMember member=(ChatRoomMember)members.next();
      chatRoom.fireMemberPresenceEvent(member,null,ChatRoomMemberPresenceChangeEvent.MEMBER_LEFT,""String_Node_Str"");
    }
    chatRoom.clearChatRoomMemberList();
  }
 else {
    ChatRoomMember member=chatRoom.getChatRoomMember(sender);
    if (member == null)     return;
    chatRoom.removeChatRoomMember(sender);
    chatRoom.fireMemberPresenceEvent(member,null,ChatRoomMemberPresenceChangeEvent.MEMBER_LEFT,null);
  }
}","/** 
 * This method is called whenever someone (possibly us) leaves a channel which we are on.
 * @param channel The channel which somebody parted from.
 * @param sender The nick of the user who parted from the channel.
 * @param login The login of the user who parted from the channel.
 * @param hostname The host name of the user who parted from the channel.
 */
protected void onPart(String channel,String sender,String login,String hostname){
  if (logger.isDebugEnabled())   logger.debug(""String_Node_Str"" + channel + ""String_Node_Str""+ sender+ ""String_Node_Str""+ login+ ""String_Node_Str""+ hostname);
  ChatRoomIrcImpl chatRoom=(ChatRoomIrcImpl)ircMUCOpSet.findRoom(channel);
  if (chatRoom.getUserNickname().equals(sender)) {
    ircMUCOpSet.fireLocalUserPresenceEvent(chatRoom,LocalUserChatRoomPresenceChangeEvent.LOCAL_USER_LEFT,""String_Node_Str"");
    for (    ChatRoomMember member : chatRoom.getMembers())     chatRoom.fireMemberPresenceEvent(member,null,ChatRoomMemberPresenceChangeEvent.MEMBER_LEFT,""String_Node_Str"");
    chatRoom.clearChatRoomMemberList();
  }
 else {
    ChatRoomMember member=chatRoom.getChatRoomMember(sender);
    if (member == null)     return;
    chatRoom.removeChatRoomMember(sender);
    chatRoom.fireMemberPresenceEvent(member,null,ChatRoomMemberPresenceChangeEvent.MEMBER_LEFT,null);
  }
}",0.9256977165639724
104069,"/** 
 * Creates a room with the named <tt>roomName</tt> and according to the specified <tt>roomProperties</tt> on the server that this protocol provider is currently connected to. When the method returns the room the local user will not have joined it and thus will not receive messages on it until the <tt>ChatRoom.join()</tt> method is called. <p>
 * @param roomName the name of the <tt>ChatRoom</tt> to create.
 * @param roomProperties properties specifying how the room should becreated.
 * @throws OperationFailedException if the room couldn't be created for somereason (e.g. room already exists; user already joined to an existent room or user has no permissions to create a chat room).
 * @throws OperationNotSupportedException if chat room creation is notsupported by this server
 * @return the newly created <tt>ChatRoom</tt> named <tt>roomName</tt>.
 */
public ChatRoom createChatRoom(String roomName,Hashtable roomProperties) throws OperationFailedException, OperationNotSupportedException {
  return findRoom(roomName);
}","/** 
 * Creates a room with the named <tt>roomName</tt> and according to the specified <tt>roomProperties</tt> on the server that this protocol provider is currently connected to. When the method returns the room the local user will not have joined it and thus will not receive messages on it until the <tt>ChatRoom.join()</tt> method is called. <p>
 * @param roomName the name of the <tt>ChatRoom</tt> to create.
 * @param roomProperties properties specifying how the room should becreated.
 * @throws OperationFailedException if the room couldn't be created for somereason (e.g. room already exists; user already joined to an existent room or user has no permissions to create a chat room).
 * @throws OperationNotSupportedException if chat room creation is notsupported by this server
 * @return the newly created <tt>ChatRoom</tt> named <tt>roomName</tt>.
 */
public ChatRoom createChatRoom(String roomName,Map<String,Object> roomProperties) throws OperationFailedException, OperationNotSupportedException {
  return findRoom(roomName);
}",0.9879518072289156
104070,"/** 
 * Returns the private room corresponding to the given nick name.
 * @param nickIdentifier the nickName of the person for which the privateroom is.
 * @return the private room corresponding to the given nick name
 */
protected ChatRoomIrcImpl findPrivateChatRoom(String nickIdentifier){
synchronized (privateRoomCache) {
    if (privateRoomCache.containsKey(nickIdentifier))     return privateRoomCache.get(nickIdentifier);
    ChatRoomIrcImpl chatRoom=new ChatRoomIrcImpl(nickIdentifier,ircProvider,true,false);
    privateRoomCache.put(nickIdentifier,chatRoom);
    fireLocalUserPresenceEvent(chatRoom,LocalUserChatRoomPresenceChangeEvent.LOCAL_USER_JOINED,""String_Node_Str"");
    return chatRoom;
  }
}","/** 
 * Returns the private room corresponding to the given nick name.
 * @param nickIdentifier the nickName of the person for which the privateroom is.
 * @return the private room corresponding to the given nick name
 */
protected ChatRoomIrcImpl findPrivateChatRoom(String nickIdentifier){
  ChatRoomIrcImpl chatRoom;
synchronized (privateRoomCache) {
    if (privateRoomCache.containsKey(nickIdentifier))     return privateRoomCache.get(nickIdentifier);
    chatRoom=new ChatRoomIrcImpl(nickIdentifier,ircProvider,true,false);
    privateRoomCache.put(nickIdentifier,chatRoom);
  }
  fireLocalUserPresenceEvent(chatRoom,LocalUserChatRoomPresenceChangeEvent.LOCAL_USER_JOINED,""String_Node_Str"");
  return chatRoom;
}",0.9635854341736696
104071,"/** 
 * Creates a room with the named <tt>roomName</tt> and according to the specified <tt>roomProperties</tt> on the server that this protocol provider is currently connected to.
 * @param roomName the name of the <tt>ChatRoom</tt> to create.
 * @param roomProperties properties specifying how the room should becreated.
 * @throws OperationFailedException if the room couldn't be created forsome reason (e.g. room already exists; user already joined to an existent room or user has no permissions to create a chat room).
 * @throws OperationNotSupportedException if chat room creation is notsupported by this server
 * @return ChatRoom the chat room that we've just created.
 */
public ChatRoom createChatRoom(String roomName,Hashtable roomProperties) throws OperationFailedException, OperationNotSupportedException {
  assertSupportedAndConnected();
  ChatRoom room=findRoom(roomName);
  if (room == null) {
    MultiUserChat muc=new MultiUserChat(getXmppConnection(),getCanonicalRoomName(roomName));
    try {
      muc.create(getXmppConnection().getUser());
      muc.sendConfigurationForm(new Form(Form.TYPE_SUBMIT));
    }
 catch (    XMPPException ex) {
      logger.error(""String_Node_Str"",ex);
      throw new OperationFailedException(""String_Node_Str"",ex.getXMPPError().getCode(),ex.getCause());
    }
    room=createLocalChatRoomInstance(muc);
  }
  return room;
}","/** 
 * Creates a room with the named <tt>roomName</tt> and according to the specified <tt>roomProperties</tt> on the server that this protocol provider is currently connected to.
 * @param roomName the name of the <tt>ChatRoom</tt> to create.
 * @param roomProperties properties specifying how the room should becreated.
 * @throws OperationFailedException if the room couldn't be created forsome reason (e.g. room already exists; user already joined to an existent room or user has no permissions to create a chat room).
 * @throws OperationNotSupportedException if chat room creation is notsupported by this server
 * @return ChatRoom the chat room that we've just created.
 */
public ChatRoom createChatRoom(String roomName,Map<String,Object> roomProperties) throws OperationFailedException, OperationNotSupportedException {
  assertSupportedAndConnected();
  ChatRoom room=findRoom(roomName);
  if (room == null) {
    MultiUserChat muc=new MultiUserChat(getXmppConnection(),getCanonicalRoomName(roomName));
    try {
      muc.create(getXmppConnection().getUser());
      muc.sendConfigurationForm(new Form(Form.TYPE_SUBMIT));
    }
 catch (    XMPPException ex) {
      logger.error(""String_Node_Str"",ex);
      throw new OperationFailedException(""String_Node_Str"",ex.getXMPPError().getCode(),ex.getCause());
    }
    room=createLocalChatRoomInstance(muc);
  }
  return room;
}",0.9909453096704092
104072,"/** 
 * Creates a room with the named <tt>roomName</tt> and according to the specified <tt>roomProperties</tt> on the server that this protocol provider is currently connected to. When the method returns the room the local user will not have joined it and thus will not receive messages on it until the <tt>ChatRoom.join()</tt> method is called. <p>
 * @param roomName the name of the <tt>ChatRoom</tt> to create.
 * @param roomProperties properties specifying how the room should becreated.
 * @throws OperationFailedException if the room couldn't be created for somereason (e.g. room already exists; user already joined to an existant room or user has no permissions to create a chat room).
 * @throws OperationNotSupportedException if chat room creation is notsupported by this server
 * @return the newly created <tt>ChatRoom</tt> named <tt>roomName</tt>.
 */
public ChatRoom createChatRoom(String roomName,Hashtable roomProperties) throws OperationFailedException, OperationNotSupportedException {
  MockChatRoom room=new MockChatRoom(provider,this,roomName);
  existingChatRooms.add(room);
  return room;
}","/** 
 * Creates a room with the named <tt>roomName</tt> and according to the specified <tt>roomProperties</tt> on the server that this protocol provider is currently connected to. When the method returns the room the local user will not have joined it and thus will not receive messages on it until the <tt>ChatRoom.join()</tt> method is called. <p>
 * @param roomName the name of the <tt>ChatRoom</tt> to create.
 * @param roomProperties properties specifying how the room should becreated.
 * @throws OperationFailedException if the room couldn't be created for somereason (e.g. room already exists; user already joined to an existing room or user has no permissions to create a chat room).
 * @throws OperationNotSupportedException if chat room creation is notsupported by this server
 * @return the newly created <tt>ChatRoom</tt> named <tt>roomName</tt>.
 */
public ChatRoom createChatRoom(String roomName,Map<String,Object> roomProperties) throws OperationFailedException, OperationNotSupportedException {
  MockChatRoom room=new MockChatRoom(provider,this,roomName);
  existingChatRooms.add(room);
  return room;
}",0.9861173309449172
104073,"/** 
 * Creates a room with the named <tt>roomName</tt> and according to the specified <tt>roomProperties</tt> on the server that this protocol provider is currently connected to. Note the roomProperties also contain users that we like to invite to the chatRoom, this is required in the yahoo protocol.
 * @param roomName the name of the <tt>ChatRoom</tt> to create.
 * @param roomProperties properties specifying how the room should be created.
 * @throws OperationFailedException if the room couldn't be created for some reason (e.g. room already exists; user already joined to an existent room or user has no permissions to create a chat room).
 * @throws OperationNotSupportedException if chat room creation is not supported by this server
 * @return ChatRoom the chat room that we've just created.
 */
public ChatRoom createChatRoom(String roomName,Hashtable<String,Object> roomProperties) throws OperationFailedException, OperationNotSupportedException {
  ChatRoom chatRoom=null;
  try {
    YahooConference conference=yahooProvider.getYahooSession().createConference(new String[]{},""String_Node_Str"",yahooProvider.getYahooSession().getLoginIdentity());
    chatRoom=findRoom(conference);
  }
 catch (  Exception e) {
    logger.debug(""String_Node_Str"" + e);
  }
  return chatRoom;
}","/** 
 * Creates a room with the named <tt>roomName</tt> and according to the specified <tt>roomProperties</tt> on the server that this protocol provider is currently connected to. Note the roomProperties also contain users that we like to invite to the chatRoom, this is required in the yahoo protocol.
 * @param roomName the name of the <tt>ChatRoom</tt> to create.
 * @param roomProperties properties specifying how the room should be created.
 * @throws OperationFailedException if the room couldn't be created for some reason (e.g. room already exists; user already joined to an existent room or user has no permissions to create a chat room).
 * @throws OperationNotSupportedException if chat room creation is not supported by this server
 * @return ChatRoom the chat room that we've just created.
 */
public ChatRoom createChatRoom(String roomName,Map<String,Object> roomProperties) throws OperationFailedException, OperationNotSupportedException {
  ChatRoom chatRoom=null;
  try {
    YahooConference conference=yahooProvider.getYahooSession().createConference(new String[]{},""String_Node_Str"",yahooProvider.getYahooSession().getLoginIdentity());
    chatRoom=findRoom(conference);
  }
 catch (  Exception e) {
    logger.debug(""String_Node_Str"" + e);
  }
  return chatRoom;
}",0.9953379953379954
104074,"/** 
 * Returns an empty iterator. Subgroups may only be present in the root group.
 * @return an empty iterator
 */
public Iterator subgroups(){
  return dummyGroupsList.iterator();
}","/** 
 * Returns an empty iterator. Subgroups may only be present in the root group.
 * @return an empty iterator
 */
public Iterator<ContactGroup> subgroups(){
  return dummyGroupsList.iterator();
}",0.9633507853403142
104075,"/** 
 * Returns the contact encapsulating with the spcieified name or null if no such contact was found.
 * @param id the id for the contact we're looking for.
 * @return the <tt>ContactJabberImpl</tt> corresponding to the specifiedscrenname or null if no such contact existed.
 */
ContactJabberImpl findContact(String id){
  if (id == null)   return null;
  return buddies.get(id.toLowerCase());
}","/** 
 * Returns the contact encapsulating with the spcieified name or null if no such contact was found.
 * @param id the id for the contact we're looking for.
 * @return the <tt>ContactJabberImpl</tt> corresponding to the specifiedscrenname or null if no such contact existed.
 */
ContactJabberImpl findContact(String id){
  if (id == null)   return null;
  return (ContactJabberImpl)buddies.get(id.toLowerCase());
}",0.9766871165644172
104076,"/** 
 * Returns a string representation of this group, in the form JabberGroup.GroupName[size]{ buddy1.toString(), buddy2.toString(), ...}.
 * @return  a String representation of the object.
 */
public String toString(){
  StringBuffer buff=new StringBuffer(""String_Node_Str"");
  buff.append(getGroupName());
  buff.append(""String_Node_Str"" + countContacts() + ""String_Node_Str"");
  Iterator contacts=contacts();
  while (contacts.hasNext()) {
    ContactJabberImpl contact=(ContactJabberImpl)contacts.next();
    buff.append(contact.toString());
    if (contacts.hasNext())     buff.append(""String_Node_Str"");
  }
  return buff.append(""String_Node_Str"").toString();
}","/** 
 * Returns a string representation of this group, in the form JabberGroup.GroupName[size]{ buddy1.toString(), buddy2.toString(), ...}.
 * @return  a String representation of the object.
 */
public String toString(){
  StringBuffer buff=new StringBuffer(""String_Node_Str"");
  buff.append(getGroupName());
  buff.append(""String_Node_Str"" + countContacts() + ""String_Node_Str"");
  Iterator<Contact> contacts=contacts();
  while (contacts.hasNext()) {
    ContactJabberImpl contact=(ContactJabberImpl)contacts.next();
    buff.append(contact.toString());
    if (contacts.hasNext())     buff.append(""String_Node_Str"");
  }
  return buff.append(""String_Node_Str"").toString();
}",0.9933085501858736
104077,"/** 
 * Returns an Iterator over all contacts, member of this <tt>ContactGroup</tt>.
 * @return a java.util.Iterator over all contacts inside this<tt>ContactGroup</tt>. In case the group doesn't contain any memebers it will return an empty iterator.
 */
public Iterator contacts(){
  return buddies.values().iterator();
}","/** 
 * Returns an Iterator over all contacts, member of this <tt>ContactGroup</tt>.
 * @return a java.util.Iterator over all contacts inside this<tt>ContactGroup</tt>. In case the group doesn't contain any memebers it will return an empty iterator.
 */
public Iterator<Contact> contacts(){
  return buddies.values().iterator();
}",0.9861751152073732
104078,"/** 
 * Requests the provider to enter into a status corresponding to the specified paramters.
 * @param status the PresenceStatus as returned bygetRequestableStatusSet
 * @param statusMessage the message that should be set as the reason toenter that status
 * @throws IllegalArgumentException if the status requested is not avalid PresenceStatus supported by this provider.
 * @throws IllegalStateException if the provider is not currentlyregistered.
 * @throws OperationFailedException with code NETWORK_FAILURE ifpublishing the status fails due to a network error.
 */
public void publishPresenceStatus(PresenceStatus status,String statusMessage) throws IllegalArgumentException, IllegalStateException, OperationFailedException {
  assertConnected();
  JabberStatusEnum jabberStatusEnum=parentProvider.getJabberStatusEnum();
  boolean isValidStatus=false;
  for (Iterator supportedStatusIter=jabberStatusEnum.getSupportedStatusSet(); supportedStatusIter.hasNext(); ) {
    if (supportedStatusIter.next().equals(status)) {
      isValidStatus=true;
      break;
    }
  }
  if (!isValidStatus)   throw new IllegalArgumentException(status + ""String_Node_Str"");
  Presence presence=null;
  if (status.equals(jabberStatusEnum.getStatus(JabberStatusEnum.OFFLINE))) {
    presence=new Presence(Presence.Type.unavailable);
    parentProvider.unregister();
  }
 else {
    presence=new Presence(Presence.Type.available);
    presence.setMode(presenceStatusToJabberMode(status));
    presence.setPriority(resourcePriority);
    presence.setStatus(statusMessage);
    presence.addExtension(new Version());
    parentProvider.getConnection().sendPacket(presence);
  }
  fireProviderPresenceStatusChangeEvent(currentStatus,status);
  if (!getCurrentStatusMessage().equals(statusMessage)) {
    String oldStatusMessage=getCurrentStatusMessage();
    currentStatusMessage=statusMessage;
    fireProviderStatusMessageChangeEvent(oldStatusMessage,getCurrentStatusMessage());
  }
}","/** 
 * Requests the provider to enter into a status corresponding to the specified paramters.
 * @param status the PresenceStatus as returned bygetRequestableStatusSet
 * @param statusMessage the message that should be set as the reason toenter that status
 * @throws IllegalArgumentException if the status requested is not avalid PresenceStatus supported by this provider.
 * @throws IllegalStateException if the provider is not currentlyregistered.
 * @throws OperationFailedException with code NETWORK_FAILURE ifpublishing the status fails due to a network error.
 */
public void publishPresenceStatus(PresenceStatus status,String statusMessage) throws IllegalArgumentException, IllegalStateException, OperationFailedException {
  assertConnected();
  JabberStatusEnum jabberStatusEnum=parentProvider.getJabberStatusEnum();
  boolean isValidStatus=false;
  for (Iterator<PresenceStatus> supportedStatusIter=jabberStatusEnum.getSupportedStatusSet(); supportedStatusIter.hasNext(); ) {
    if (supportedStatusIter.next().equals(status)) {
      isValidStatus=true;
      break;
    }
  }
  if (!isValidStatus)   throw new IllegalArgumentException(status + ""String_Node_Str"");
  Presence presence=null;
  if (status.equals(jabberStatusEnum.getStatus(JabberStatusEnum.OFFLINE))) {
    presence=new Presence(Presence.Type.unavailable);
    parentProvider.unregister();
  }
 else {
    presence=new Presence(Presence.Type.available);
    presence.setMode(presenceStatusToJabberMode(status));
    presence.setPriority(resourcePriority);
    presence.setStatus(statusMessage);
    presence.addExtension(new Version());
    parentProvider.getConnection().sendPacket(presence);
  }
  fireProviderPresenceStatusChangeEvent(currentStatus,status);
  if (!getCurrentStatusMessage().equals(statusMessage)) {
    String oldStatusMessage=getCurrentStatusMessage();
    currentStatusMessage=statusMessage;
    fireProviderStatusMessageChangeEvent(oldStatusMessage,getCurrentStatusMessage());
  }
}",0.9959493670886076
104079,"/** 
 * Notify all provider presence listeners of the corresponding event change
 * @param oldStatus the status our stack had so far
 * @param newStatus the status we have from now on
 */
void fireProviderPresenceStatusChangeEvent(PresenceStatus oldStatus,PresenceStatus newStatus){
  if (oldStatus.equals(newStatus)) {
    logger.debug(""String_Node_Str"" + oldStatus);
    return;
  }
  ProviderPresenceStatusChangeEvent evt=new ProviderPresenceStatusChangeEvent(parentProvider,oldStatus,newStatus);
  currentStatus=newStatus;
  logger.debug(""String_Node_Str"" + providerPresenceStatusListeners.size() + ""String_Node_Str""+ evt);
  Iterator listeners=null;
synchronized (providerPresenceStatusListeners) {
    listeners=new ArrayList(providerPresenceStatusListeners).iterator();
  }
  while (listeners.hasNext()) {
    ProviderPresenceStatusListener listener=(ProviderPresenceStatusListener)listeners.next();
    listener.providerStatusChanged(evt);
  }
}","/** 
 * Notify all provider presence listeners of the corresponding event change
 * @param oldStatus the status our stack had so far
 * @param newStatus the status we have from now on
 */
void fireProviderPresenceStatusChangeEvent(PresenceStatus oldStatus,PresenceStatus newStatus){
  if (oldStatus.equals(newStatus)) {
    logger.debug(""String_Node_Str"" + oldStatus);
    return;
  }
  ProviderPresenceStatusChangeEvent evt=new ProviderPresenceStatusChangeEvent(parentProvider,oldStatus,newStatus);
  currentStatus=newStatus;
  logger.debug(""String_Node_Str"" + providerPresenceStatusListeners.size() + ""String_Node_Str""+ evt);
  Iterator<ProviderPresenceStatusListener> listeners=null;
synchronized (providerPresenceStatusListeners) {
    listeners=new ArrayList<ProviderPresenceStatusListener>(providerPresenceStatusListeners).iterator();
  }
  while (listeners.hasNext()) {
    ProviderPresenceStatusListener listener=listeners.next();
    listener.providerStatusChanged(evt);
  }
}",0.9504643962848296
104080,"/** 
 * Notify all provider presence listeners that a new status message has been set.
 * @param oldStatusMessage the status message our stack had so far
 * @param newStatusMessage the status message we have from now on
 */
private void fireProviderStatusMessageChangeEvent(String oldStatusMessage,String newStatusMessage){
  PropertyChangeEvent evt=new PropertyChangeEvent(parentProvider,ProviderPresenceStatusListener.STATUS_MESSAGE,oldStatusMessage,newStatusMessage);
  logger.debug(""String_Node_Str"" + providerPresenceStatusListeners.size() + ""String_Node_Str""+ evt);
  Iterator listeners=null;
synchronized (providerPresenceStatusListeners) {
    listeners=new ArrayList(providerPresenceStatusListeners).iterator();
  }
  while (listeners.hasNext()) {
    ProviderPresenceStatusListener listener=(ProviderPresenceStatusListener)listeners.next();
    listener.providerStatusMessageChanged(evt);
  }
}","/** 
 * Notify all provider presence listeners that a new status message has been set.
 * @param oldStatusMessage the status message our stack had so far
 * @param newStatusMessage the status message we have from now on
 */
private void fireProviderStatusMessageChangeEvent(String oldStatusMessage,String newStatusMessage){
  PropertyChangeEvent evt=new PropertyChangeEvent(parentProvider,ProviderPresenceStatusListener.STATUS_MESSAGE,oldStatusMessage,newStatusMessage);
  logger.debug(""String_Node_Str"" + providerPresenceStatusListeners.size() + ""String_Node_Str""+ evt);
  Iterator<ProviderPresenceStatusListener> listeners=null;
synchronized (providerPresenceStatusListeners) {
    listeners=new ArrayList<ProviderPresenceStatusListener>(providerPresenceStatusListeners).iterator();
  }
  while (listeners.hasNext()) {
    ProviderPresenceStatusListener listener=(ProviderPresenceStatusListener)listeners.next();
    listener.providerStatusMessageChanged(evt);
  }
}",0.9636752136752136
104081,"/** 
 * The method is called by a ProtocolProvider implementation whenver a change in the registration state of the corresponding provider had occurred.
 * @param evt ProviderStatusChangeEvent the event describing the statuschange.
 */
public void registrationStateChanged(RegistrationStateChangeEvent evt){
  logger.debug(""String_Node_Str"" + evt.getOldState() + ""String_Node_Str""+ evt.getNewState());
  if (evt.getNewState() == RegistrationState.REGISTERED) {
    parentProvider.getConnection().getRoster().addRosterListener(new ContactChangesListener());
    fireProviderPresenceStatusChangeEvent(currentStatus,parentProvider.getJabberStatusEnum().getStatus(JabberStatusEnum.AVAILABLE));
    ssContactList.init();
  }
 else   if (evt.getNewState() == RegistrationState.UNREGISTERED || evt.getNewState() == RegistrationState.AUTHENTICATION_FAILED || evt.getNewState() == RegistrationState.CONNECTION_FAILED) {
    PresenceStatus oldStatus=currentStatus;
    PresenceStatus offlineStatus=parentProvider.getJabberStatusEnum().getStatus(JabberStatusEnum.OFFLINE);
    currentStatus=offlineStatus;
    fireProviderPresenceStatusChangeEvent(oldStatus,currentStatus);
    Iterator groupsIter=getServerStoredContactListRoot().subgroups();
    while (groupsIter.hasNext()) {
      ContactGroupJabberImpl group=(ContactGroupJabberImpl)groupsIter.next();
      Iterator contactsIter=group.contacts();
      while (contactsIter.hasNext()) {
        ContactJabberImpl contact=(ContactJabberImpl)contactsIter.next();
        PresenceStatus oldContactStatus=contact.getPresenceStatus();
        if (!oldContactStatus.isOnline())         continue;
        contact.updatePresenceStatus(offlineStatus);
        fireContactPresenceStatusChangeEvent(contact,contact.getParentContactGroup(),oldContactStatus,offlineStatus);
      }
    }
    Iterator contactsIter=getServerStoredContactListRoot().contacts();
    while (contactsIter.hasNext()) {
      ContactJabberImpl contact=(ContactJabberImpl)contactsIter.next();
      PresenceStatus oldContactStatus=contact.getPresenceStatus();
      if (!oldContactStatus.isOnline())       continue;
      contact.updatePresenceStatus(offlineStatus);
      fireContactPresenceStatusChangeEvent(contact,contact.getParentContactGroup(),oldContactStatus,offlineStatus);
    }
  }
}","/** 
 * The method is called by a ProtocolProvider implementation whenver a change in the registration state of the corresponding provider had occurred.
 * @param evt ProviderStatusChangeEvent the event describing the statuschange.
 */
public void registrationStateChanged(RegistrationStateChangeEvent evt){
  logger.debug(""String_Node_Str"" + evt.getOldState() + ""String_Node_Str""+ evt.getNewState());
  if (evt.getNewState() == RegistrationState.REGISTERED) {
    parentProvider.getConnection().getRoster().addRosterListener(new ContactChangesListener());
    fireProviderPresenceStatusChangeEvent(currentStatus,parentProvider.getJabberStatusEnum().getStatus(JabberStatusEnum.AVAILABLE));
    ssContactList.init();
  }
 else   if (evt.getNewState() == RegistrationState.UNREGISTERED || evt.getNewState() == RegistrationState.AUTHENTICATION_FAILED || evt.getNewState() == RegistrationState.CONNECTION_FAILED) {
    PresenceStatus oldStatus=currentStatus;
    PresenceStatus offlineStatus=parentProvider.getJabberStatusEnum().getStatus(JabberStatusEnum.OFFLINE);
    currentStatus=offlineStatus;
    fireProviderPresenceStatusChangeEvent(oldStatus,currentStatus);
    Iterator<ContactGroup> groupsIter=getServerStoredContactListRoot().subgroups();
    while (groupsIter.hasNext()) {
      ContactGroup group=groupsIter.next();
      Iterator<Contact> contactsIter=group.contacts();
      while (contactsIter.hasNext()) {
        ContactJabberImpl contact=(ContactJabberImpl)contactsIter.next();
        PresenceStatus oldContactStatus=contact.getPresenceStatus();
        if (!oldContactStatus.isOnline())         continue;
        contact.updatePresenceStatus(offlineStatus);
        fireContactPresenceStatusChangeEvent(contact,contact.getParentContactGroup(),oldContactStatus,offlineStatus);
      }
    }
    Iterator<Contact> contactsIter=getServerStoredContactListRoot().contacts();
    while (contactsIter.hasNext()) {
      ContactJabberImpl contact=(ContactJabberImpl)contactsIter.next();
      PresenceStatus oldContactStatus=contact.getPresenceStatus();
      if (!oldContactStatus.isOnline())       continue;
      contact.updatePresenceStatus(offlineStatus);
      fireContactPresenceStatusChangeEvent(contact,contact.getParentContactGroup(),oldContactStatus,offlineStatus);
    }
  }
}",0.763375380600261
104082,"/** 
 * Connects and logins to the server
 * @param authority SecurityAuthority
 * @param reasonCode the authentication reason code. Indicates the reason ofthis authentication.
 * @throws XMPPException if we cannot connect to the server - network problem
 * @throws OperationFailedException if login parametersas server port are not correct
 */
private void connectAndLogin(SecurityAuthority authority,int reasonCode) throws XMPPException, OperationFailedException {
synchronized (initializationLock) {
    String password=JabberActivator.getProtocolProviderFactory().loadPassword(getAccountID());
    if (password == null) {
      UserCredentials credentials=new UserCredentials();
      credentials.setUserName(getAccountID().getUserID());
      credentials=authority.obtainCredentials(ProtocolNames.JABBER,credentials,reasonCode);
      if (credentials == null) {
        fireRegistrationStateChanged(getRegistrationState(),RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_USER_REQUEST,""String_Node_Str"");
        return;
      }
      char[] pass=credentials.getPassword();
      if (pass == null) {
        fireRegistrationStateChanged(getRegistrationState(),RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_USER_REQUEST,""String_Node_Str"");
        return;
      }
      password=new String(pass);
      if (credentials.isPasswordPersistent()) {
        JabberActivator.getProtocolProviderFactory().storePassword(getAccountID(),password);
      }
    }
    try {
      String userID=StringUtils.parseName(getAccountID().getUserID());
      String serviceName=StringUtils.parseServer(getAccountID().getUserID());
      String serverAddress=getAccountID().getAccountPropertyString(ProtocolProviderFactory.SERVER_ADDRESS);
      String serverPort=getAccountID().getAccountPropertyString(ProtocolProviderFactory.SERVER_PORT);
      String accountResource=getAccountID().getAccountPropertyString(ProtocolProviderFactory.RESOURCE);
      try {
        InetSocketAddress srvAddress=NetworkUtils.getSRVRecord(""String_Node_Str"",""String_Node_Str"",serviceName);
        if (srvAddress != null)         serverAddress=srvAddress.getHostName();
      }
 catch (      ParseException ex1) {
        logger.error(""String_Node_Str"" + ex1.getMessage());
      }
      Roster.setDefaultSubscriptionMode(Roster.SubscriptionMode.manual);
      try {
        ConnectionConfiguration confConn=new ConnectionConfiguration(serverAddress,Integer.parseInt(serverPort),serviceName);
        confConn.setReconnectionAllowed(false);
        connection=new XMPPConnection(confConn);
        connection.connect();
      }
 catch (      XMPPException exc) {
        logger.error(""String_Node_Str"" + getAccountID().getAccountUniqueID(),exc);
        throw new OperationFailedException(""String_Node_Str"" + getAccountID().getAccountUniqueID(),OperationFailedException.NETWORK_FAILURE,exc);
      }
      connection.addConnectionListener(new JabberConnectionListener());
      fireRegistrationStateChanged(getRegistrationState(),RegistrationState.REGISTERING,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
      if (accountResource == null || accountResource.equals(""String_Node_Str""))       accountResource=""String_Node_Str"";
      SASLAuthentication.supportSASLMechanism(""String_Node_Str"",0);
      try {
        connection.login(userID,password,accountResource);
      }
 catch (      XMPPException e1) {
        try {
          try {
            connection.disconnect();
          }
 catch (          Exception e) {
          }
          connection.connect();
          connection.login(userID + ""String_Node_Str"" + serviceName,password,accountResource);
        }
 catch (        XMPPException e2) {
          throw e1;
        }
      }
      if (connection.isAuthenticated()) {
        this.reconnecting=false;
        connection.getRoster().setSubscriptionMode(Roster.SubscriptionMode.manual);
        fireRegistrationStateChanged(getRegistrationState(),RegistrationState.REGISTERED,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
      }
 else {
        fireRegistrationStateChanged(getRegistrationState(),RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
      }
    }
 catch (    NumberFormatException ex) {
      throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INVALID_ACCOUNT_PROPERTIES,ex);
    }
  }
  if (getRegistrationState() == RegistrationState.REGISTERED) {
    discoveryManager=ServiceDiscoveryManager.getInstanceFor(connection);
    ServiceDiscoveryManager.setIdentityName(""String_Node_Str"");
    ServiceDiscoveryManager.setIdentityType(""String_Node_Str"");
    Iterator<String> it=supportedFeatures.iterator();
    while (it.hasNext())     discoveryManager.addFeature(it.next());
  }
}","/** 
 * Connects and logins to the server
 * @param authority SecurityAuthority
 * @param reasonCode the authentication reason code. Indicates the reason ofthis authentication.
 * @throws XMPPException if we cannot connect to the server - network problem
 * @throws OperationFailedException if login parametersas server port are not correct
 */
private synchronized void connectAndLogin(SecurityAuthority authority,int reasonCode) throws XMPPException, OperationFailedException {
synchronized (initializationLock) {
    String password=JabberActivator.getProtocolProviderFactory().loadPassword(getAccountID());
    if (password == null) {
      UserCredentials credentials=new UserCredentials();
      credentials.setUserName(getAccountID().getUserID());
      credentials=authority.obtainCredentials(ProtocolNames.JABBER,credentials,reasonCode);
      if (credentials == null) {
        fireRegistrationStateChanged(getRegistrationState(),RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_USER_REQUEST,""String_Node_Str"");
        return;
      }
      char[] pass=credentials.getPassword();
      if (pass == null) {
        fireRegistrationStateChanged(getRegistrationState(),RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_USER_REQUEST,""String_Node_Str"");
        return;
      }
      password=new String(pass);
      if (credentials.isPasswordPersistent()) {
        JabberActivator.getProtocolProviderFactory().storePassword(getAccountID(),password);
      }
    }
    try {
      String userID=StringUtils.parseName(getAccountID().getUserID());
      String serviceName=StringUtils.parseServer(getAccountID().getUserID());
      String serverAddress=getAccountID().getAccountPropertyString(ProtocolProviderFactory.SERVER_ADDRESS);
      String serverPort=getAccountID().getAccountPropertyString(ProtocolProviderFactory.SERVER_PORT);
      String accountResource=getAccountID().getAccountPropertyString(ProtocolProviderFactory.RESOURCE);
      try {
        InetSocketAddress srvAddress=NetworkUtils.getSRVRecord(""String_Node_Str"",""String_Node_Str"",serviceName);
        if (srvAddress != null)         serverAddress=srvAddress.getHostName();
      }
 catch (      ParseException ex1) {
        logger.error(""String_Node_Str"" + ex1.getMessage());
      }
      Roster.setDefaultSubscriptionMode(Roster.SubscriptionMode.manual);
      try {
        ConnectionConfiguration confConn=new ConnectionConfiguration(serverAddress,Integer.parseInt(serverPort),serviceName);
        confConn.setReconnectionAllowed(false);
        connection=new XMPPConnection(confConn);
        connection.connect();
      }
 catch (      XMPPException exc) {
        logger.error(""String_Node_Str"" + getAccountID().getAccountUniqueID(),exc);
        throw new OperationFailedException(""String_Node_Str"" + getAccountID().getAccountUniqueID(),OperationFailedException.NETWORK_FAILURE,exc);
      }
      connection.addConnectionListener(new JabberConnectionListener());
      fireRegistrationStateChanged(getRegistrationState(),RegistrationState.REGISTERING,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
      if (accountResource == null || accountResource.equals(""String_Node_Str""))       accountResource=""String_Node_Str"";
      SASLAuthentication.supportSASLMechanism(""String_Node_Str"",0);
      try {
        connection.login(userID,password,accountResource);
      }
 catch (      XMPPException e1) {
        try {
          try {
            connection.disconnect();
          }
 catch (          Exception e) {
          }
          connection.connect();
          connection.login(userID + ""String_Node_Str"" + serviceName,password,accountResource);
        }
 catch (        XMPPException e2) {
          throw e1;
        }
      }
      if (connection.isAuthenticated()) {
        this.reconnecting=false;
        connection.getRoster().setSubscriptionMode(Roster.SubscriptionMode.manual);
        fireRegistrationStateChanged(getRegistrationState(),RegistrationState.REGISTERED,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
      }
 else {
        fireRegistrationStateChanged(getRegistrationState(),RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
      }
    }
 catch (    NumberFormatException ex) {
      throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INVALID_ACCOUNT_PROPERTIES,ex);
    }
  }
  if (getRegistrationState() == RegistrationState.REGISTERED) {
    discoveryManager=ServiceDiscoveryManager.getInstanceFor(connection);
    ServiceDiscoveryManager.setIdentityName(""String_Node_Str"");
    ServiceDiscoveryManager.setIdentityType(""String_Node_Str"");
    Iterator<String> it=supportedFeatures.iterator();
    while (it.hasNext())     discoveryManager.addFeature(it.next());
  }
}",0.9986471016755124
104083,"public void run(){
  OperationSetServerStoredAccountInfo accountInfoOpSet=(OperationSetServerStoredAccountInfo)protocolProvider.getOperationSet(OperationSetServerStoredAccountInfo.class);
  if (accountInfoOpSet != null) {
    byte[] accountImage=AccountInfoUtils.getImage(accountInfoOpSet);
    if (accountImage != null) {
      accountImageLabel.setImageIcon(new ImageIcon(accountImage));
    }
    String firstName=AccountInfoUtils.getFirstName(accountInfoOpSet);
    String lastName=AccountInfoUtils.getLastName(accountInfoOpSet);
    String accountName=""String_Node_Str"";
    if (firstName != null) {
      accountName+=firstName;
    }
    if (lastName != null) {
      accountName+=""String_Node_Str"" + lastName;
    }
    if (accountName.length() == 0) {
      String displayName=AccountInfoUtils.getDisplayName(accountInfoOpSet);
      if (displayName != null)       accountName=displayName;
    }
    if (accountName.length() > 0) {
      accountNameLabel.setText(accountName);
    }
    revalidate();
    repaint();
  }
}","public void run(){
  OperationSetServerStoredAccountInfo accountInfoOpSet=(OperationSetServerStoredAccountInfo)protocolProvider.getOperationSet(OperationSetServerStoredAccountInfo.class);
  if (accountInfoOpSet != null) {
    byte[] accountImage=AccountInfoUtils.getImage(accountInfoOpSet);
    if (accountImage != null) {
      if (accountImage.length > 0)       accountImageLabel.setImageIcon(new ImageIcon(accountImage));
    }
    String firstName=AccountInfoUtils.getFirstName(accountInfoOpSet);
    String lastName=AccountInfoUtils.getLastName(accountInfoOpSet);
    String accountName=""String_Node_Str"";
    if (firstName != null) {
      accountName+=firstName;
    }
    if (lastName != null) {
      accountName+=""String_Node_Str"" + lastName;
    }
    if (accountName.length() == 0) {
      String displayName=AccountInfoUtils.getDisplayName(accountInfoOpSet);
      if (displayName != null)       accountName=displayName;
    }
    if (accountName.length() > 0) {
      accountNameLabel.setText(accountName);
    }
    revalidate();
    repaint();
  }
}",0.9832935560859188
104084,"public void registrationStateChanged(RegistrationStateChangeEvent evt){
  final ProtocolProviderService protocolProvider=evt.getProvider();
  this.updateStatus(protocolProvider);
  if (evt.getNewState().equals(RegistrationState.REGISTERED)) {
    new Thread(new Runnable(){
      public void run(){
        OperationSetServerStoredAccountInfo accountInfoOpSet=(OperationSetServerStoredAccountInfo)protocolProvider.getOperationSet(OperationSetServerStoredAccountInfo.class);
        if (accountInfoOpSet != null) {
          byte[] accountImage=AccountInfoUtils.getImage(accountInfoOpSet);
          if (accountImage != null) {
            accountImageLabel.setImageIcon(new ImageIcon(accountImage));
          }
          String firstName=AccountInfoUtils.getFirstName(accountInfoOpSet);
          String lastName=AccountInfoUtils.getLastName(accountInfoOpSet);
          String accountName=""String_Node_Str"";
          if (firstName != null) {
            accountName+=firstName;
          }
          if (lastName != null) {
            accountName+=""String_Node_Str"" + lastName;
          }
          if (accountName.length() == 0) {
            String displayName=AccountInfoUtils.getDisplayName(accountInfoOpSet);
            if (displayName != null)             accountName=displayName;
          }
          if (accountName.length() > 0) {
            accountNameLabel.setText(accountName);
          }
          revalidate();
          repaint();
        }
      }
    }
).start();
  }
}","public void registrationStateChanged(RegistrationStateChangeEvent evt){
  final ProtocolProviderService protocolProvider=evt.getProvider();
  this.updateStatus(protocolProvider);
  if (evt.getNewState().equals(RegistrationState.REGISTERED)) {
    new Thread(new Runnable(){
      public void run(){
        OperationSetServerStoredAccountInfo accountInfoOpSet=(OperationSetServerStoredAccountInfo)protocolProvider.getOperationSet(OperationSetServerStoredAccountInfo.class);
        if (accountInfoOpSet != null) {
          byte[] accountImage=AccountInfoUtils.getImage(accountInfoOpSet);
          if (accountImage != null) {
            if (accountImage.length > 0)             accountImageLabel.setImageIcon(new ImageIcon(accountImage));
          }
          String firstName=AccountInfoUtils.getFirstName(accountInfoOpSet);
          String lastName=AccountInfoUtils.getLastName(accountInfoOpSet);
          String accountName=""String_Node_Str"";
          if (firstName != null) {
            accountName+=firstName;
          }
          if (lastName != null) {
            accountName+=""String_Node_Str"" + lastName;
          }
          if (accountName.length() == 0) {
            String displayName=AccountInfoUtils.getDisplayName(accountInfoOpSet);
            if (displayName != null)             accountName=displayName;
          }
          if (accountName.length() > 0) {
            accountNameLabel.setText(accountName);
          }
          revalidate();
          repaint();
        }
      }
    }
).start();
  }
}",0.9864731111844276
104085,"public void buddyIconUpdated(IconService iconService,Screenname screenname,ExtraInfoData extraInfoData,ByteBlock byteBlock){
  if (byteBlock != null) {
    if (screenname.getFormatted().equals(uin)) {
synchronized (this) {
        accountImage=new ImageDetail(""String_Node_Str"",byteBlock.toByteArray());
        this.notifyAll();
      }
    }
  }
}","public void buddyIconUpdated(IconService iconService,Screenname screenname,ExtraInfoData extraInfoData,ByteBlock byteBlock){
  if (byteBlock != null) {
    if (screenname.getFormatted().equals(uin)) {
synchronized (this) {
        byte[] img=byteBlock.toByteArray();
        if (img != null && img.length > 0)         accountImage=new ImageDetail(""String_Node_Str"",img);
        this.notifyAll();
      }
    }
  }
}",0.7895424836601307
104086,"public void run(){
  try {
    Collection copyContactsForUpdate=null;
    while (true) {
synchronized (contactsForUpdate) {
        if (contactsForUpdate.isEmpty())         contactsForUpdate.wait();
        copyContactsForUpdate=new Vector(contactsForUpdate);
        contactsForUpdate.clear();
      }
      Iterator iter=copyContactsForUpdate.iterator();
      while (iter.hasNext()) {
        ContactIcqImpl contact=(ContactIcqImpl)iter.next();
        String oldNickname=contact.getDisplayName();
        String nickName=getParentProvider().getInfoRetreiver().getNickName(contact.getUIN());
        if (nickName != null) {
          contact.setNickname(nickName);
          parentOperationSet.fireContactPropertyChangeEvent(ContactPropertyChangeEvent.PROPERTY_DISPLAY_NAME,contact,oldNickname,nickName);
        }
 else         contact.setNickname(oldNickname);
      }
    }
  }
 catch (  InterruptedException ex) {
    logger.error(""String_Node_Str"",ex);
  }
}","public void run(){
  try {
    Collection copyContactsForUpdate=null;
    while (true) {
synchronized (contactsForUpdate) {
        if (contactsForUpdate.isEmpty())         contactsForUpdate.wait();
        copyContactsForUpdate=new Vector(contactsForUpdate);
        contactsForUpdate.clear();
      }
      Iterator iter=copyContactsForUpdate.iterator();
      while (iter.hasNext()) {
        ContactIcqImpl contact=(ContactIcqImpl)iter.next();
        String oldNickname=contact.getDisplayName();
        String nickName=null;
        try {
          nickName=getParentProvider().getInfoRetreiver().getNickName(contact.getUIN());
        }
 catch (        Exception e) {
          continue;
        }
        if (nickName != null) {
          contact.setNickname(nickName);
          parentOperationSet.fireContactPropertyChangeEvent(ContactPropertyChangeEvent.PROPERTY_DISPLAY_NAME,contact,oldNickname,nickName);
        }
 else         contact.setNickname(oldNickname);
      }
    }
  }
 catch (  InterruptedException ex) {
    logger.error(""String_Node_Str"",ex);
  }
}",0.9461312438785504
104087,"/** 
 * Persistently adds a subscription for the presence status of the contact corresponding to the specified contactIdentifier and indicates that it should be added to the specified group of the server stored contact list.
 * @param parentGroup the parent group of the server stored contact listwhere the contact should be added. <p>
 * @param contactIdentifier the contact whose status updates we aresubscribing for.
 * @throws IllegalArgumentException if <tt>contact</tt> or<tt>parent</tt> are not a contact known to the underlying protocol provider.
 * @throws IllegalStateException if the underlying protocol provider isnot registered/signed on a public service.
 * @throws OperationFailedException with code NETWORK_FAILURE ifsubscribing fails due to errors experienced during network communication
 */
public void subscribe(ContactGroup parentGroup,String contactIdentifier) throws IllegalArgumentException, IllegalStateException, OperationFailedException {
  logger.debug(""String_Node_Str"" + contactIdentifier);
  ContactSipImpl contact=(ContactSipImpl)resolveContactID(contactIdentifier);
  if (contact != null && contact.isPersistent()) {
    throw new OperationFailedException(""String_Node_Str"" + contactIdentifier + ""String_Node_Str"",OperationFailedException.SUBSCRIPTION_ALREADY_EXISTS);
  }
 else   if (!contact.isPersistent()) {
    ContactGroupSipImpl oldParentGroup=(ContactGroupSipImpl)contact.getParentContactGroup();
    oldParentGroup.removeContact(contact);
    fireSubscriptionEvent(contact,oldParentGroup,SubscriptionEvent.SUBSCRIPTION_REMOVED);
  }
  Address contactAddress;
  try {
    contactAddress=parentProvider.parseAddressString(contactIdentifier);
  }
 catch (  ParseException exc) {
    throw new IllegalArgumentException(contactIdentifier + ""String_Node_Str"",exc);
  }
  contact=new ContactSipImpl(contactAddress,this.parentProvider);
  ((ContactGroupSipImpl)parentGroup).addContact(contact);
  fireSubscriptionEvent(contact,parentGroup,SubscriptionEvent.SUBSCRIPTION_CREATED);
  if (this.presenceEnabled == false)   return;
  assertConnected();
  Request subscription;
  try {
    subscription=createSubscription(contact,this.subscriptionDuration);
  }
 catch (  OperationFailedException ex) {
    logger.error(""String_Node_Str"",ex);
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INTERNAL_ERROR);
  }
  ClientTransaction subscribeTransaction;
  SipProvider jainSipProvider=this.parentProvider.getDefaultJainSipProvider();
  try {
    subscribeTransaction=jainSipProvider.getNewClientTransaction(subscription);
  }
 catch (  TransactionUnavailableException ex) {
    logger.error(""String_Node_Str"" + ""String_Node_Str"",ex);
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.NETWORK_FAILURE);
  }
  CallIdHeader idheader=(CallIdHeader)subscription.getHeader(CallIdHeader.NAME);
  this.subscribedContacts.put(idheader.getCallId(),contact);
  try {
    subscribeTransaction.sendRequest();
  }
 catch (  SipException ex) {
    logger.error(""String_Node_Str"",ex);
    this.subscribedContacts.remove(idheader.getCallId());
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.NETWORK_FAILURE);
  }
}","/** 
 * Persistently adds a subscription for the presence status of the contact corresponding to the specified contactIdentifier and indicates that it should be added to the specified group of the server stored contact list.
 * @param parentGroup the parent group of the server stored contact listwhere the contact should be added. <p>
 * @param contactIdentifier the contact whose status updates we aresubscribing for.
 * @throws IllegalArgumentException if <tt>contact</tt> or<tt>parent</tt> are not a contact known to the underlying protocol provider.
 * @throws IllegalStateException if the underlying protocol provider isnot registered/signed on a public service.
 * @throws OperationFailedException with code NETWORK_FAILURE ifsubscribing fails due to errors experienced during network communication
 */
public void subscribe(ContactGroup parentGroup,String contactIdentifier) throws IllegalArgumentException, IllegalStateException, OperationFailedException {
  logger.debug(""String_Node_Str"" + contactIdentifier);
  ContactSipImpl contact=(ContactSipImpl)resolveContactID(contactIdentifier);
  if (contact != null) {
    if (contact.isPersistent()) {
      throw new OperationFailedException(""String_Node_Str"" + contactIdentifier + ""String_Node_Str"",OperationFailedException.SUBSCRIPTION_ALREADY_EXISTS);
    }
 else {
      ContactGroupSipImpl oldParentGroup=(ContactGroupSipImpl)contact.getParentContactGroup();
      oldParentGroup.removeContact(contact);
      fireSubscriptionEvent(contact,oldParentGroup,SubscriptionEvent.SUBSCRIPTION_REMOVED);
    }
  }
  Address contactAddress;
  try {
    contactAddress=parentProvider.parseAddressString(contactIdentifier);
  }
 catch (  ParseException exc) {
    throw new IllegalArgumentException(contactIdentifier + ""String_Node_Str"",exc);
  }
  contact=new ContactSipImpl(contactAddress,this.parentProvider);
  ((ContactGroupSipImpl)parentGroup).addContact(contact);
  fireSubscriptionEvent(contact,parentGroup,SubscriptionEvent.SUBSCRIPTION_CREATED);
  if (this.presenceEnabled == false)   return;
  assertConnected();
  Request subscription;
  try {
    subscription=createSubscription(contact,this.subscriptionDuration);
  }
 catch (  OperationFailedException ex) {
    logger.error(""String_Node_Str"",ex);
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INTERNAL_ERROR);
  }
  ClientTransaction subscribeTransaction;
  SipProvider jainSipProvider=this.parentProvider.getDefaultJainSipProvider();
  try {
    subscribeTransaction=jainSipProvider.getNewClientTransaction(subscription);
  }
 catch (  TransactionUnavailableException ex) {
    logger.error(""String_Node_Str"" + ""String_Node_Str"",ex);
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.NETWORK_FAILURE);
  }
  CallIdHeader idheader=(CallIdHeader)subscription.getHeader(CallIdHeader.NAME);
  this.subscribedContacts.put(idheader.getCallId(),contact);
  try {
    subscribeTransaction.sendRequest();
  }
 catch (  SipException ex) {
    logger.error(""String_Node_Str"",ex);
    this.subscribedContacts.remove(idheader.getCallId());
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.NETWORK_FAILURE);
  }
}",0.9607325779916188
104088,"/** 
 * Moves the corresponding node from its old parent to the node corresponding to the new parent meta group.
 * @param evt the MetaContactListEvent containing the corresponding contact
 */
public void metaContactMoved(MetaContactMovedEvent evt){
  Element metaContactNode=findMetaContactNode(evt.getSourceMetaContact().getMetaUID());
  Element newParentNode=findMetaContactGroupNode(evt.getNewParent().getMetaUID());
  if (metaContactNode == null) {
    logger.error(""String_Node_Str"" + evt.getSourceMetaContact());
    return;
  }
  if (newParentNode == null) {
    logger.error(""String_Node_Str"" + evt.getNewParent());
    return;
  }
  metaContactNode.getParentNode().removeChild(metaContactNode);
  updateParentsForMetaContactNode(metaContactNode,evt.getNewParent());
  Element childContacts=XMLUtils.findChild(newParentNode,CHILD_CONTACTS_NODE_NAME);
  childContacts.appendChild(metaContactNode);
  try {
    scheduleContactListStorage();
  }
 catch (  IOException ex) {
    logger.error(""String_Node_Str"" + evt.getSourceMetaContact(),ex);
  }
}","/** 
 * Moves the corresponding node from its old parent to the node corresponding to the new parent meta group.
 * @param evt the MetaContactListEvent containing the corresponding contact
 */
public void metaContactMoved(MetaContactMovedEvent evt){
  Element metaContactNode=findMetaContactNode(evt.getSourceMetaContact().getMetaUID());
  Element newParentNode=findMetaContactGroupNode(evt.getNewParent().getMetaUID());
  if (newParentNode == null) {
    logger.error(""String_Node_Str"" + evt.getNewParent());
    return;
  }
  if (metaContactNode == null) {
    metaContactNode=createMetaContactNode(evt.getSourceMetaContact());
  }
 else {
    metaContactNode.getParentNode().removeChild(metaContactNode);
  }
  updateParentsForMetaContactNode(metaContactNode,evt.getNewParent());
  Element childContacts=XMLUtils.findChild(newParentNode,CHILD_CONTACTS_NODE_NAME);
  childContacts.appendChild(metaContactNode);
  try {
    scheduleContactListStorage();
  }
 catch (  IOException ex) {
    logger.error(""String_Node_Str"" + evt.getSourceMetaContact(),ex);
  }
}",0.8312056737588652
104089,"/** 
 * Receives options requests and replies with an OK response containing methods that we support.
 * @param requestEvent the incoming options request.
 */
public boolean processRequest(RequestEvent requestEvent){
  Response optionsOK=null;
  try {
    optionsOK=provider.getMessageFactory().createResponse(Response.OK,requestEvent.getRequest());
    Iterator<String> supportedMethods=provider.getSupportedMethods().iterator();
    while (supportedMethods.hasNext()) {
      String method=(String)supportedMethods.next();
      if (method.equals(Request.REGISTER))       continue;
      optionsOK.addHeader(provider.getHeaderFactory().createAllowHeader(method));
    }
    Iterator<String> events=provider.getKnownEventsList().iterator();
synchronized (provider.getKnownEventsList()) {
      while (events.hasNext()) {
        String event=events.next();
        optionsOK.addHeader(provider.getHeaderFactory().createAllowEventsHeader(event));
      }
    }
    optionsOK.setHeader(provider.getSipCommUserAgentHeader());
  }
 catch (  ParseException ex) {
    logger.warn(""String_Node_Str"",ex);
    return false;
  }
  try {
    ServerTransaction sTran=requestEvent.getServerTransaction();
    if (sTran == null) {
      SipProvider sipProvider=(SipProvider)requestEvent.getSource();
      sTran=sipProvider.getNewServerTransaction(requestEvent.getRequest());
    }
    sTran.sendResponse(optionsOK);
  }
 catch (  TransactionUnavailableException ex) {
    logger.info(""String_Node_Str"" + ""String_Node_Str"");
    logger.trace(""String_Node_Str"",ex);
    return false;
  }
catch (  InvalidArgumentException ex) {
    logger.warn(""String_Node_Str"",ex);
    return false;
  }
catch (  SipException ex) {
    logger.warn(""String_Node_Str"",ex);
    return false;
  }
  return true;
}","/** 
 * Receives options requests and replies with an OK response containing methods that we support.
 * @param requestEvent the incoming options request.
 */
public boolean processRequest(RequestEvent requestEvent){
  Response optionsOK=null;
  try {
    optionsOK=provider.getMessageFactory().createResponse(Response.OK,requestEvent.getRequest());
    Iterator<String> supportedMethods=provider.getSupportedMethods().iterator();
    while (supportedMethods.hasNext()) {
      String method=(String)supportedMethods.next();
      if (method.equals(Request.REGISTER))       continue;
      optionsOK.addHeader(provider.getHeaderFactory().createAllowHeader(method));
    }
    Iterator<String> events=provider.getKnownEventsList().iterator();
synchronized (provider.getKnownEventsList()) {
      while (events.hasNext()) {
        String event=events.next();
        optionsOK.addHeader(provider.getHeaderFactory().createAllowEventsHeader(event));
      }
    }
    optionsOK.setHeader(provider.getSipCommUserAgentHeader());
  }
 catch (  ParseException ex) {
    logger.warn(""String_Node_Str"",ex);
    return false;
  }
  try {
    SipStackSharing.getOrCreateServerTransaction(requestEvent).sendResponse(optionsOK);
  }
 catch (  TransactionUnavailableException ex) {
    logger.info(""String_Node_Str"" + ""String_Node_Str"");
    logger.trace(""String_Node_Str"",ex);
    return false;
  }
catch (  InvalidArgumentException ex) {
    logger.warn(""String_Node_Str"",ex);
    return false;
  }
catch (  SipException ex) {
    logger.warn(""String_Node_Str"",ex);
    return false;
  }
  return true;
}",0.9270462633451956
104090,"/** 
 * Process a request from a distant contact
 * @param requestEvent the <tt>RequestEvent</tt> containing the newlyreceived request.
 * @return <tt>true</tt> if the specified event has been handled by thisprocessor and shouldn't be offered to other processors registered for the same method; <tt>false</tt>, otherwise
 */
public boolean processRequest(RequestEvent requestEvent){
synchronized (messageProcessors) {
    Iterator iter=messageProcessors.iterator();
    while (iter.hasNext()) {
      SipMessageProcessor listener=(SipMessageProcessor)iter.next();
      if (!listener.processMessage(requestEvent))       return true;
    }
  }
  String content=null;
  Request req=requestEvent.getRequest();
  try {
    content=new String(req.getRawContent(),getCharset(req));
  }
 catch (  UnsupportedEncodingException ex) {
    logger.debug(""String_Node_Str"");
    content=new String(requestEvent.getRequest().getRawContent());
  }
  FromHeader fromHeader=(FromHeader)requestEvent.getRequest().getHeader(FromHeader.NAME);
  if (fromHeader == null) {
    logger.error(""String_Node_Str"");
    return false;
  }
  Contact from=opSetPersPresence.resolveContactID(fromHeader.getAddress().getURI().toString());
  ContentTypeHeader ctheader=(ContentTypeHeader)req.getHeader(ContentTypeHeader.NAME);
  String ctype=null;
  String cencoding=null;
  if (ctheader == null) {
    ctype=DEFAULT_MIME_TYPE;
  }
 else {
    ctype=ctheader.getContentType() + ""String_Node_Str"" + ctheader.getContentSubType();
    cencoding=ctheader.getParameter(""String_Node_Str"");
  }
  if (cencoding == null)   cencoding=DEFAULT_MIME_ENCODING;
  Message newMessage=createMessage(content,ctype,cencoding,null);
  if (from == null) {
    logger.debug(""String_Node_Str"" + fromHeader.getAddress().getURI().toString());
    from=opSetPersPresence.createVolatileContact(fromHeader.getAddress());
  }
  try {
    Response ok=sipProvider.getMessageFactory().createResponse(Response.OK,requestEvent.getRequest());
    SipProvider jainSipProvider=(SipProvider)requestEvent.getSource();
    jainSipProvider.getNewServerTransaction(requestEvent.getRequest()).sendResponse(ok);
  }
 catch (  ParseException exc) {
    logger.error(""String_Node_Str"",exc);
  }
catch (  SipException exc) {
    logger.error(""String_Node_Str"" + exc.getMessage(),exc);
  }
catch (  InvalidArgumentException exc) {
    logger.debug(""String_Node_Str"" + exc.getMessage(),exc);
  }
  MessageReceivedEvent msgReceivedEvt=new MessageReceivedEvent(newMessage,from,System.currentTimeMillis());
  fireMessageEvent(msgReceivedEvt);
  return true;
}","/** 
 * Process a request from a distant contact
 * @param requestEvent the <tt>RequestEvent</tt> containing the newlyreceived request.
 * @return <tt>true</tt> if the specified event has been handled by thisprocessor and shouldn't be offered to other processors registered for the same method; <tt>false</tt>, otherwise
 */
public boolean processRequest(RequestEvent requestEvent){
synchronized (messageProcessors) {
    Iterator iter=messageProcessors.iterator();
    while (iter.hasNext()) {
      SipMessageProcessor listener=(SipMessageProcessor)iter.next();
      if (!listener.processMessage(requestEvent))       return true;
    }
  }
  String content=null;
  Request req=requestEvent.getRequest();
  try {
    content=new String(req.getRawContent(),getCharset(req));
  }
 catch (  UnsupportedEncodingException ex) {
    logger.debug(""String_Node_Str"");
    content=new String(requestEvent.getRequest().getRawContent());
  }
  FromHeader fromHeader=(FromHeader)requestEvent.getRequest().getHeader(FromHeader.NAME);
  if (fromHeader == null) {
    logger.error(""String_Node_Str"");
    return false;
  }
  Contact from=opSetPersPresence.resolveContactID(fromHeader.getAddress().getURI().toString());
  ContentTypeHeader ctheader=(ContentTypeHeader)req.getHeader(ContentTypeHeader.NAME);
  String ctype=null;
  String cencoding=null;
  if (ctheader == null) {
    ctype=DEFAULT_MIME_TYPE;
  }
 else {
    ctype=ctheader.getContentType() + ""String_Node_Str"" + ctheader.getContentSubType();
    cencoding=ctheader.getParameter(""String_Node_Str"");
  }
  if (cencoding == null)   cencoding=DEFAULT_MIME_ENCODING;
  Message newMessage=createMessage(content,ctype,cencoding,null);
  if (from == null) {
    logger.debug(""String_Node_Str"" + fromHeader.getAddress().getURI().toString());
    from=opSetPersPresence.createVolatileContact(fromHeader.getAddress());
  }
  try {
    Response ok=sipProvider.getMessageFactory().createResponse(Response.OK,requestEvent.getRequest());
    SipStackSharing.getOrCreateServerTransaction(requestEvent).sendResponse(ok);
  }
 catch (  ParseException exc) {
    logger.error(""String_Node_Str"",exc);
  }
catch (  SipException exc) {
    logger.error(""String_Node_Str"" + exc.getMessage(),exc);
  }
catch (  InvalidArgumentException exc) {
    logger.debug(""String_Node_Str"" + exc.getMessage(),exc);
  }
  MessageReceivedEvent msgReceivedEvt=new MessageReceivedEvent(newMessage,from,System.currentTimeMillis());
  fireMessageEvent(msgReceivedEvt);
  return true;
}",0.9638982047741173
104091,"/** 
 * Processes a Request received on a SipProvider upon which this SipListener is registered. <p>
 * @param requestEvent requestEvent fired from the SipProvider to the<tt>SipListener</tt> representing a Request received from the network.
 * @return <tt>true</tt> if the specified event has been handled by thisprocessor and shouldn't be offered to other processors registered for the same method; <tt>false</tt>, otherwise
 */
public boolean processRequest(RequestEvent requestEvent){
  ServerTransaction serverTransaction=requestEvent.getServerTransaction();
  SipProvider jainSipProvider=(SipProvider)requestEvent.getSource();
  Request request=requestEvent.getRequest();
  String requestMethod=request.getMethod();
  if (serverTransaction == null) {
    try {
      serverTransaction=jainSipProvider.getNewServerTransaction(request);
    }
 catch (    TransactionAlreadyExistsException ex) {
      logger.error(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",ex);
      return false;
    }
catch (    TransactionUnavailableException ex) {
      logger.error(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",ex);
      return false;
    }
  }
  boolean processed=false;
  if (requestMethod.equals(Request.INVITE)) {
    logger.debug(""String_Node_Str"");
    DialogState dialogState=serverTransaction.getDialog().getState();
    if ((dialogState == null) || dialogState.equals(DialogState.CONFIRMED)) {
      if (logger.isDebugEnabled())       logger.debug(""String_Node_Str"" + dialogState);
      processInvite(jainSipProvider,serverTransaction,request);
      processed=true;
    }
 else {
      logger.error(""String_Node_Str"" + ""String_Node_Str"");
    }
  }
 else   if (requestMethod.equals(Request.ACK)) {
    processAck(serverTransaction,request);
    processed=true;
  }
 else   if (requestMethod.equals(Request.BYE)) {
    processBye(serverTransaction,request);
    processed=true;
  }
 else   if (requestMethod.equals(Request.CANCEL)) {
    processCancel(serverTransaction,request);
    processed=true;
  }
 else   if (requestMethod.equals(Request.REFER)) {
    logger.debug(""String_Node_Str"");
    processRefer(serverTransaction,request,jainSipProvider);
    processed=true;
  }
 else   if (requestMethod.equals(Request.NOTIFY)) {
    logger.debug(""String_Node_Str"");
    processed=processNotify(serverTransaction,request);
  }
  return processed;
}","/** 
 * Processes a Request received on a SipProvider upon which this SipListener is registered. <p>
 * @param requestEvent requestEvent fired from the SipProvider to the<tt>SipListener</tt> representing a Request received from the network.
 * @return <tt>true</tt> if the specified event has been handled by thisprocessor and shouldn't be offered to other processors registered for the same method; <tt>false</tt>, otherwise
 */
public boolean processRequest(RequestEvent requestEvent){
  ServerTransaction serverTransaction=requestEvent.getServerTransaction();
  SipProvider jainSipProvider=(SipProvider)requestEvent.getSource();
  Request request=requestEvent.getRequest();
  String requestMethod=request.getMethod();
  if (serverTransaction == null) {
    try {
      serverTransaction=SipStackSharing.getOrCreateServerTransaction(requestEvent);
    }
 catch (    TransactionAlreadyExistsException ex) {
      logger.error(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",ex);
      return false;
    }
catch (    TransactionUnavailableException ex) {
      logger.error(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",ex);
      return false;
    }
  }
  boolean processed=false;
  if (requestMethod.equals(Request.INVITE)) {
    logger.debug(""String_Node_Str"");
    DialogState dialogState=serverTransaction.getDialog().getState();
    if ((dialogState == null) || dialogState.equals(DialogState.CONFIRMED)) {
      if (logger.isDebugEnabled())       logger.debug(""String_Node_Str"" + dialogState);
      processInvite(jainSipProvider,serverTransaction,request);
      processed=true;
    }
 else {
      logger.error(""String_Node_Str"" + ""String_Node_Str"");
    }
  }
 else   if (requestMethod.equals(Request.ACK)) {
    processAck(serverTransaction,request);
    processed=true;
  }
 else   if (requestMethod.equals(Request.BYE)) {
    processBye(serverTransaction,request);
    processed=true;
  }
 else   if (requestMethod.equals(Request.CANCEL)) {
    processCancel(serverTransaction,request);
    processed=true;
  }
 else   if (requestMethod.equals(Request.REFER)) {
    logger.debug(""String_Node_Str"");
    processRefer(serverTransaction,request,jainSipProvider);
    processed=true;
  }
 else   if (requestMethod.equals(Request.NOTIFY)) {
    logger.debug(""String_Node_Str"");
    processed=processNotify(serverTransaction,request);
  }
  return processed;
}",0.9886744966442952
104092,"/** 
 * Try to find a contact registered using a string to identify him.
 * @param contactID A string with which the contact may havebeen registered
 * @return A valid contact if it has been found, null otherwise
 */
Contact resolveContactID(String contactID){
  Contact res=this.findContactByID(contactID);
  if (res == null) {
    if (contactID.startsWith(""String_Node_Str"")) {
      res=this.findContactByID(contactID.substring(4));
    }
    if (res == null) {
      if (contactID.indexOf('@') > -1) {
        res=this.findContactByID(contactID.substring(0,contactID.indexOf('@')));
        if (res == null) {
          if (contactID.startsWith(""String_Node_Str"")) {
            res=this.findContactByID(contactID.substring(4,contactID.indexOf('@')));
          }
        }
      }
    }
  }
  return res;
}","/** 
 * Try to find a contact registered using a string to identify him.
 * @param contactID A string with which the contact may havebeen registered
 * @return A valid contact if it has been found, null otherwise
 */
Contact resolveContactID(String contactID){
  Contact res=this.findContactByID(contactID);
  if (res == null) {
    if (contactID.startsWith(""String_Node_Str"")) {
      res=this.findContactByID(contactID.substring(4));
    }
    if (res == null) {
      if (contactID.indexOf('@') > -1) {
        res=this.findContactByID(contactID.substring(0,contactID.indexOf('@')));
        if (res == null) {
          if (contactID.startsWith(""String_Node_Str"")) {
            res=this.findContactByID(contactID.substring(4,contactID.indexOf('@')));
          }
        }
      }
    }
    if (res == null) {
      int ix=contactID.indexOf(""String_Node_Str"",4);
      if (ix == -1)       ix=contactID.indexOf(""String_Node_Str"",4);
      if (ix > 0)       res=this.findContactByID(contactID.substring(4,contactID.indexOf(""String_Node_Str"",4)));
    }
  }
  return res;
}",0.8600212089077413
104093,"/** 
 * Process a request from a distant contact
 * @param requestEvent the <tt>RequestEvent</tt> containing the newlyreceived request.
 * @return <tt>true</tt> if the specified event has been handled by thisprocessor and shouldn't be offered to other processors registered for the same method; <tt>false</tt>, otherwise
 */
public boolean processRequest(RequestEvent requestEvent){
  if (this.presenceEnabled == false)   return false;
  ServerTransaction serverTransaction=requestEvent.getServerTransaction();
  SipProvider jainSipProvider=(SipProvider)requestEvent.getSource();
  Request request=requestEvent.getRequest();
  if (serverTransaction == null) {
    try {
      serverTransaction=jainSipProvider.getNewServerTransaction(request);
    }
 catch (    TransactionAlreadyExistsException ex) {
      logger.error(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",ex);
      return false;
    }
catch (    TransactionUnavailableException ex) {
      logger.error(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",ex);
      return false;
    }
  }
  EventHeader eventHeader=(EventHeader)request.getHeader(EventHeader.NAME);
  if (eventHeader == null || !eventHeader.getEventType().equalsIgnoreCase(""String_Node_Str"")) {
    return false;
  }
  boolean processed=false;
  if (request.getMethod().equals(Request.NOTIFY)) {
    Response response=null;
    logger.debug(""String_Node_Str"");
    SubscriptionStateHeader sstateHeader=(SubscriptionStateHeader)request.getHeader(SubscriptionStateHeader.NAME);
    if (sstateHeader == null) {
      logger.error(""String_Node_Str"");
      return false;
    }
    CallIdHeader idheader=(CallIdHeader)request.getHeader(CallIdHeader.NAME);
    ContactSipImpl contact=(ContactSipImpl)this.subscribedContacts.get(idheader.getCallId());
    if (contact != null && !sstateHeader.getState().equalsIgnoreCase(SubscriptionStateHeader.TERMINATED) && !contact.isResolved()) {
      logger.debug(""String_Node_Str"");
    }
    if (contact == null && !sstateHeader.getState().equalsIgnoreCase(SubscriptionStateHeader.TERMINATED)) {
      logger.debug(""String_Node_Str"" + idheader.getCallId());
synchronized (this.waitedCallIds) {
        this.waitedCallIds.remove(idheader.getCallId());
      }
      try {
        response=this.parentProvider.getMessageFactory().createResponse(Response.CALL_OR_TRANSACTION_DOES_NOT_EXIST,request);
      }
 catch (      ParseException e) {
        logger.error(""String_Node_Str"",e);
        return false;
      }
      try {
        serverTransaction.sendResponse(response);
      }
 catch (      SipException e) {
        logger.error(""String_Node_Str"",e);
      }
catch (      InvalidArgumentException e) {
        logger.error(""String_Node_Str"" + ""String_Node_Str"",e);
      }
      return true;
    }
    ContentTypeHeader ctheader=(ContentTypeHeader)request.getHeader(ContentTypeHeader.NAME);
    if (ctheader != null && !ctheader.getContentSubType().equalsIgnoreCase(PIDF_XML)) {
      try {
        response=this.parentProvider.getMessageFactory().createResponse(Response.UNSUPPORTED_MEDIA_TYPE,request);
      }
 catch (      ParseException e) {
        logger.error(""String_Node_Str"",e);
        return false;
      }
      AcceptHeader acceptHeader=null;
      try {
        acceptHeader=this.parentProvider.getHeaderFactory().createAcceptHeader(""String_Node_Str"",PIDF_XML);
      }
 catch (      ParseException e) {
        logger.error(""String_Node_Str"",e);
        return false;
      }
      response.setHeader(acceptHeader);
      try {
        serverTransaction.sendResponse(response);
      }
 catch (      SipException e) {
        logger.error(""String_Node_Str"",e);
      }
catch (      InvalidArgumentException e) {
        logger.error(""String_Node_Str"" + ""String_Node_Str"",e);
      }
    }
    if (sstateHeader.getState().equalsIgnoreCase(SubscriptionStateHeader.TERMINATED)) {
      if (contact != null) {
        terminateSubscription(contact);
        this.subscribedContacts.remove(serverTransaction.getDialog().getCallId().getCallId());
        if (sstateHeader.getReasonCode().equals(SubscriptionStateHeader.DEACTIVATED)) {
          forcePollContact(contact);
        }
      }
synchronized (this.waitedCallIds) {
        this.waitedCallIds.remove(idheader.getCallId());
      }
    }
    try {
      response=this.parentProvider.getMessageFactory().createResponse(Response.OK,request);
    }
 catch (    ParseException e) {
      logger.error(""String_Node_Str"",e);
      return false;
    }
    try {
      serverTransaction.sendResponse(response);
    }
 catch (    SipException e) {
      logger.error(""String_Node_Str"",e);
    }
catch (    InvalidArgumentException e) {
      logger.error(""String_Node_Str"" + ""String_Node_Str"",e);
    }
    if (request.getRawContent() != null && !sstateHeader.getState().equalsIgnoreCase(SubscriptionStateHeader.TERMINATED)) {
      setPidfPresenceStatus(new String(request.getRawContent()));
    }
    processed=true;
  }
 else   if (request.getMethod().equals(Request.SUBSCRIBE)) {
    FromHeader from=(FromHeader)request.getHeader(FromHeader.NAME);
    if (this.useDistantPA) {
      this.useDistantPA=false;
      if (this.republishTask != null) {
        this.republishTask.cancel();
        this.republishTask=null;
      }
    }
    ContactSipImpl contact=(ContactSipImpl)resolveContactID(from.getAddress().getURI().toString());
    if (contact == null) {
      contact=new ContactSipImpl(from.getAddress(),this.parentProvider);
      contact.setResolved(true);
      contact.setResolvable(false);
    }
    logger.debug(contact.toString() + ""String_Node_Str"" + ""String_Node_Str"");
    ExpiresHeader expHeader=request.getExpires();
    int expires;
    if (expHeader == null) {
      expires=PRESENCE_DEFAULT_EXPIRE;
    }
 else {
      expires=expHeader.getExpires();
    }
    if (expires < SUBSCRIBE_MIN_EXPIRE && expires > 0 && expires < 3600) {
      Response response=null;
      try {
        response=this.parentProvider.getMessageFactory().createResponse(Response.INTERVAL_TOO_BRIEF,request);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        return false;
      }
      MinExpiresHeader min=null;
      try {
        min=this.parentProvider.getHeaderFactory().createMinExpiresHeader(SUBSCRIBE_MIN_EXPIRE);
      }
 catch (      InvalidArgumentException e) {
        logger.error(""String_Node_Str"",e);
        return false;
      }
      response.setHeader(min);
      try {
        serverTransaction.sendResponse(response);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        return false;
      }
      return true;
    }
    if (this.ourWatchers.contains(contact) && expires != 0 && contact.getServerDialog().equals(serverTransaction.getDialog())) {
      contact.getTimeoutTask().cancel();
      WatcherTimeoutTask timeout=new WatcherTimeoutTask(contact);
      contact.setTimeoutTask(timeout);
      getTimer().schedule(timeout,expires * 1000);
      Response response=null;
      try {
        response=this.parentProvider.getMessageFactory().createResponse(Response.OK,request);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        return false;
      }
      try {
        expHeader=this.parentProvider.getHeaderFactory().createExpiresHeader(expires);
      }
 catch (      InvalidArgumentException e) {
        logger.error(""String_Node_Str"");
        return false;
      }
      response.setHeader(expHeader);
      try {
        serverTransaction.sendResponse(response);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        return false;
      }
      return true;
    }
    Dialog dialog=contact.getServerDialog();
    if (expires == 0) {
      logger.debug(""String_Node_Str"" + contact + ""String_Node_Str"");
synchronized (this.ourWatchers) {
        this.ourWatchers.remove(contact);
      }
      contact.getTimeoutTask().cancel();
      contact.setServerDialog(null);
      Response response=null;
      try {
        response=this.parentProvider.getMessageFactory().createResponse(Response.OK,request);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        return false;
      }
      try {
        expHeader=this.parentProvider.getHeaderFactory().createExpiresHeader(0);
      }
 catch (      InvalidArgumentException e) {
        logger.error(""String_Node_Str"",e);
        return false;
      }
      response.setHeader(expHeader);
      try {
        serverTransaction.sendResponse(response);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        return false;
      }
      ClientTransaction transac=null;
      try {
        transac=createNotify(contact,getPidfPresenceStatus((ContactSipImpl)getLocalContactForDst(contact)),SubscriptionStateHeader.TERMINATED,SubscriptionStateHeader.TIMEOUT);
      }
 catch (      OperationFailedException e) {
        logger.error(""String_Node_Str"",e);
        return false;
      }
      try {
        dialog.sendRequest(transac);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        return false;
      }
      return true;
    }
    if (this.ourWatchers.contains(contact) && !contact.getServerDialog().equals(serverTransaction.getDialog())) {
      logger.debug(""String_Node_Str"" + contact + ""String_Node_Str""+ ""String_Node_Str"");
      ClientTransaction transac=null;
      try {
        transac=createNotify(contact,getPidfPresenceStatus((ContactSipImpl)getLocalContactForDst(contact)),SubscriptionStateHeader.TERMINATED,SubscriptionStateHeader.REJECTED);
      }
 catch (      OperationFailedException e) {
        logger.error(""String_Node_Str"",e);
        return false;
      }
      contact.setServerDialog(null);
synchronized (this.ourWatchers) {
        this.ourWatchers.remove(contact);
      }
      if (contact.getTimeoutTask() != null) {
        contact.getTimeoutTask().cancel();
      }
      try {
        dialog.sendRequest(transac);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        return false;
      }
    }
synchronized (contact) {
      contact.setServerDialog(serverTransaction.getDialog());
    }
    dialog=contact.getServerDialog();
    Response response=null;
    try {
      response=this.parentProvider.getMessageFactory().createResponse(Response.OK,request);
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
      return false;
    }
    try {
      expHeader=this.parentProvider.getHeaderFactory().createExpiresHeader(expires);
    }
 catch (    InvalidArgumentException e) {
      logger.error(""String_Node_Str"",e);
      return false;
    }
    response.setHeader(expHeader);
    try {
      serverTransaction.sendResponse(response);
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
      return false;
    }
    ClientTransaction transac=null;
    try {
      transac=createNotify(contact,getPidfPresenceStatus((ContactSipImpl)getLocalContactForDst(contact)),SubscriptionStateHeader.ACTIVE,null);
    }
 catch (    OperationFailedException e) {
      logger.error(""String_Node_Str"",e);
      return false;
    }
    try {
      dialog.sendRequest(transac);
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
      return false;
    }
synchronized (this.ourWatchers) {
      this.ourWatchers.add(contact);
    }
    WatcherTimeoutTask timeout=new WatcherTimeoutTask(contact);
    contact.setTimeoutTask(timeout);
    getTimer().schedule(timeout,expires * 1000);
    processed=true;
  }
 else   if (request.getMethod().equals(Request.PUBLISH)) {
    Response response=null;
    try {
      response=this.parentProvider.getMessageFactory().createResponse(Response.NOT_IMPLEMENTED,request);
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
      return false;
    }
    try {
      serverTransaction.sendResponse(response);
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
      return false;
    }
    processed=true;
  }
  return processed;
}","/** 
 * Process a request from a distant contact
 * @param requestEvent the <tt>RequestEvent</tt> containing the newlyreceived request.
 * @return <tt>true</tt> if the specified event has been handled by thisprocessor and shouldn't be offered to other processors registered for the same method; <tt>false</tt>, otherwise
 */
public boolean processRequest(RequestEvent requestEvent){
  if (this.presenceEnabled == false)   return false;
  ServerTransaction serverTransaction=requestEvent.getServerTransaction();
  SipProvider jainSipProvider=(SipProvider)requestEvent.getSource();
  Request request=requestEvent.getRequest();
  if (serverTransaction == null) {
    try {
      serverTransaction=SipStackSharing.getOrCreateServerTransaction(requestEvent);
    }
 catch (    TransactionAlreadyExistsException ex) {
      logger.error(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",ex);
      return false;
    }
catch (    TransactionUnavailableException ex) {
      logger.error(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",ex);
      return false;
    }
  }
  EventHeader eventHeader=(EventHeader)request.getHeader(EventHeader.NAME);
  if (eventHeader == null || !eventHeader.getEventType().equalsIgnoreCase(""String_Node_Str"")) {
    return false;
  }
  boolean processed=false;
  if (request.getMethod().equals(Request.NOTIFY)) {
    Response response=null;
    logger.debug(""String_Node_Str"");
    SubscriptionStateHeader sstateHeader=(SubscriptionStateHeader)request.getHeader(SubscriptionStateHeader.NAME);
    if (sstateHeader == null) {
      logger.error(""String_Node_Str"");
      return false;
    }
    CallIdHeader idheader=(CallIdHeader)request.getHeader(CallIdHeader.NAME);
    ContactSipImpl contact=(ContactSipImpl)this.subscribedContacts.get(idheader.getCallId());
    if (contact != null && !sstateHeader.getState().equalsIgnoreCase(SubscriptionStateHeader.TERMINATED) && !contact.isResolved()) {
      logger.debug(""String_Node_Str"");
    }
    if (contact == null && !sstateHeader.getState().equalsIgnoreCase(SubscriptionStateHeader.TERMINATED)) {
      logger.debug(""String_Node_Str"" + idheader.getCallId());
synchronized (this.waitedCallIds) {
        this.waitedCallIds.remove(idheader.getCallId());
      }
      try {
        response=this.parentProvider.getMessageFactory().createResponse(Response.CALL_OR_TRANSACTION_DOES_NOT_EXIST,request);
      }
 catch (      ParseException e) {
        logger.error(""String_Node_Str"",e);
        return false;
      }
      try {
        serverTransaction.sendResponse(response);
      }
 catch (      SipException e) {
        logger.error(""String_Node_Str"",e);
      }
catch (      InvalidArgumentException e) {
        logger.error(""String_Node_Str"" + ""String_Node_Str"",e);
      }
      return true;
    }
    ContentTypeHeader ctheader=(ContentTypeHeader)request.getHeader(ContentTypeHeader.NAME);
    if (ctheader != null && !ctheader.getContentSubType().equalsIgnoreCase(PIDF_XML)) {
      try {
        response=this.parentProvider.getMessageFactory().createResponse(Response.UNSUPPORTED_MEDIA_TYPE,request);
      }
 catch (      ParseException e) {
        logger.error(""String_Node_Str"",e);
        return false;
      }
      AcceptHeader acceptHeader=null;
      try {
        acceptHeader=this.parentProvider.getHeaderFactory().createAcceptHeader(""String_Node_Str"",PIDF_XML);
      }
 catch (      ParseException e) {
        logger.error(""String_Node_Str"",e);
        return false;
      }
      response.setHeader(acceptHeader);
      try {
        serverTransaction.sendResponse(response);
      }
 catch (      SipException e) {
        logger.error(""String_Node_Str"",e);
      }
catch (      InvalidArgumentException e) {
        logger.error(""String_Node_Str"" + ""String_Node_Str"",e);
      }
    }
    if (sstateHeader.getState().equalsIgnoreCase(SubscriptionStateHeader.TERMINATED)) {
      if (contact != null) {
        terminateSubscription(contact);
        this.subscribedContacts.remove(serverTransaction.getDialog().getCallId().getCallId());
        if (sstateHeader.getReasonCode().equals(SubscriptionStateHeader.DEACTIVATED)) {
          forcePollContact(contact);
        }
      }
synchronized (this.waitedCallIds) {
        this.waitedCallIds.remove(idheader.getCallId());
      }
    }
    try {
      response=this.parentProvider.getMessageFactory().createResponse(Response.OK,request);
    }
 catch (    ParseException e) {
      logger.error(""String_Node_Str"",e);
      return false;
    }
    try {
      serverTransaction.sendResponse(response);
    }
 catch (    SipException e) {
      logger.error(""String_Node_Str"",e);
    }
catch (    InvalidArgumentException e) {
      logger.error(""String_Node_Str"" + ""String_Node_Str"",e);
    }
    if (request.getRawContent() != null && !sstateHeader.getState().equalsIgnoreCase(SubscriptionStateHeader.TERMINATED)) {
      setPidfPresenceStatus(new String(request.getRawContent()));
    }
    processed=true;
  }
 else   if (request.getMethod().equals(Request.SUBSCRIBE)) {
    FromHeader from=(FromHeader)request.getHeader(FromHeader.NAME);
    if (this.useDistantPA) {
      this.useDistantPA=false;
      if (this.republishTask != null) {
        this.republishTask.cancel();
        this.republishTask=null;
      }
    }
    ContactSipImpl contact=(ContactSipImpl)resolveContactID(from.getAddress().getURI().toString());
    if (contact == null) {
      contact=new ContactSipImpl(from.getAddress(),this.parentProvider);
      contact.setResolved(true);
      contact.setResolvable(false);
    }
    logger.debug(contact.toString() + ""String_Node_Str"" + ""String_Node_Str"");
    ExpiresHeader expHeader=request.getExpires();
    int expires;
    if (expHeader == null) {
      expires=PRESENCE_DEFAULT_EXPIRE;
    }
 else {
      expires=expHeader.getExpires();
    }
    if (expires < SUBSCRIBE_MIN_EXPIRE && expires > 0 && expires < 3600) {
      Response response=null;
      try {
        response=this.parentProvider.getMessageFactory().createResponse(Response.INTERVAL_TOO_BRIEF,request);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        return false;
      }
      MinExpiresHeader min=null;
      try {
        min=this.parentProvider.getHeaderFactory().createMinExpiresHeader(SUBSCRIBE_MIN_EXPIRE);
      }
 catch (      InvalidArgumentException e) {
        logger.error(""String_Node_Str"",e);
        return false;
      }
      response.setHeader(min);
      try {
        serverTransaction.sendResponse(response);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        return false;
      }
      return true;
    }
    if (this.ourWatchers.contains(contact) && expires != 0 && contact.getServerDialog().equals(serverTransaction.getDialog())) {
      contact.getTimeoutTask().cancel();
      WatcherTimeoutTask timeout=new WatcherTimeoutTask(contact);
      contact.setTimeoutTask(timeout);
      getTimer().schedule(timeout,expires * 1000);
      Response response=null;
      try {
        response=this.parentProvider.getMessageFactory().createResponse(Response.OK,request);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        return false;
      }
      try {
        expHeader=this.parentProvider.getHeaderFactory().createExpiresHeader(expires);
      }
 catch (      InvalidArgumentException e) {
        logger.error(""String_Node_Str"");
        return false;
      }
      response.setHeader(expHeader);
      try {
        serverTransaction.sendResponse(response);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        return false;
      }
      return true;
    }
    Dialog dialog=contact.getServerDialog();
    if (expires == 0) {
      logger.debug(""String_Node_Str"" + contact + ""String_Node_Str"");
synchronized (this.ourWatchers) {
        this.ourWatchers.remove(contact);
      }
      contact.getTimeoutTask().cancel();
      contact.setServerDialog(null);
      Response response=null;
      try {
        response=this.parentProvider.getMessageFactory().createResponse(Response.OK,request);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        return false;
      }
      try {
        expHeader=this.parentProvider.getHeaderFactory().createExpiresHeader(0);
      }
 catch (      InvalidArgumentException e) {
        logger.error(""String_Node_Str"",e);
        return false;
      }
      response.setHeader(expHeader);
      try {
        serverTransaction.sendResponse(response);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        return false;
      }
      ClientTransaction transac=null;
      try {
        transac=createNotify(contact,getPidfPresenceStatus((ContactSipImpl)getLocalContactForDst(contact)),SubscriptionStateHeader.TERMINATED,SubscriptionStateHeader.TIMEOUT);
      }
 catch (      OperationFailedException e) {
        logger.error(""String_Node_Str"",e);
        return false;
      }
      try {
        dialog.sendRequest(transac);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        return false;
      }
      return true;
    }
    if (this.ourWatchers.contains(contact) && !contact.getServerDialog().equals(serverTransaction.getDialog())) {
      logger.debug(""String_Node_Str"" + contact + ""String_Node_Str""+ ""String_Node_Str"");
      ClientTransaction transac=null;
      try {
        transac=createNotify(contact,getPidfPresenceStatus((ContactSipImpl)getLocalContactForDst(contact)),SubscriptionStateHeader.TERMINATED,SubscriptionStateHeader.REJECTED);
      }
 catch (      OperationFailedException e) {
        logger.error(""String_Node_Str"",e);
        return false;
      }
      contact.setServerDialog(null);
synchronized (this.ourWatchers) {
        this.ourWatchers.remove(contact);
      }
      if (contact.getTimeoutTask() != null) {
        contact.getTimeoutTask().cancel();
      }
      try {
        dialog.sendRequest(transac);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        return false;
      }
    }
synchronized (contact) {
      contact.setServerDialog(serverTransaction.getDialog());
    }
    dialog=contact.getServerDialog();
    Response response=null;
    try {
      response=this.parentProvider.getMessageFactory().createResponse(Response.OK,request);
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
      return false;
    }
    try {
      expHeader=this.parentProvider.getHeaderFactory().createExpiresHeader(expires);
    }
 catch (    InvalidArgumentException e) {
      logger.error(""String_Node_Str"",e);
      return false;
    }
    response.setHeader(expHeader);
    try {
      serverTransaction.sendResponse(response);
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
      return false;
    }
    ClientTransaction transac=null;
    try {
      transac=createNotify(contact,getPidfPresenceStatus((ContactSipImpl)getLocalContactForDst(contact)),SubscriptionStateHeader.ACTIVE,null);
    }
 catch (    OperationFailedException e) {
      logger.error(""String_Node_Str"",e);
      return false;
    }
    try {
      dialog.sendRequest(transac);
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
      return false;
    }
synchronized (this.ourWatchers) {
      this.ourWatchers.add(contact);
    }
    WatcherTimeoutTask timeout=new WatcherTimeoutTask(contact);
    contact.setTimeoutTask(timeout);
    getTimer().schedule(timeout,expires * 1000);
    processed=true;
  }
 else   if (request.getMethod().equals(Request.PUBLISH)) {
    Response response=null;
    try {
      response=this.parentProvider.getMessageFactory().createResponse(Response.NOT_IMPLEMENTED,request);
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
      return false;
    }
    try {
      serverTransaction.sendResponse(response);
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
      return false;
    }
    processed=true;
  }
  return processed;
}",0.9960366608867972
104094,"/** 
 * Persistently adds a subscription for the presence status of the contact corresponding to the specified contactIdentifier and indicates that it should be added to the specified group of the server stored contact list.
 * @param parentGroup the parent group of the server stored contact listwhere the contact should be added. <p>
 * @param contactIdentifier the contact whose status updates we aresubscribing for.
 * @throws IllegalArgumentException if <tt>contact</tt> or<tt>parent</tt> are not a contact known to the underlying protocol provider.
 * @throws IllegalStateException if the underlying protocol provider isnot registered/signed on a public service.
 * @throws OperationFailedException with code NETWORK_FAILURE ifsubscribing fails due to errors experienced during network communication
 */
public void subscribe(ContactGroup parentGroup,String contactIdentifier) throws IllegalArgumentException, IllegalStateException, OperationFailedException {
  logger.debug(""String_Node_Str"" + contactIdentifier);
  ContactSipImpl contact=(ContactSipImpl)resolveContactID(contactIdentifier);
  if (contact != null) {
    throw new OperationFailedException(""String_Node_Str"" + contactIdentifier + ""String_Node_Str"",OperationFailedException.SUBSCRIPTION_ALREADY_EXISTS);
  }
  Address contactAddress;
  try {
    contactAddress=parentProvider.parseAddressString(contactIdentifier);
  }
 catch (  ParseException exc) {
    throw new IllegalArgumentException(contactIdentifier + ""String_Node_Str"",exc);
  }
  contact=new ContactSipImpl(contactAddress,this.parentProvider);
  ((ContactGroupSipImpl)parentGroup).addContact(contact);
  fireSubscriptionEvent(contact,parentGroup,SubscriptionEvent.SUBSCRIPTION_CREATED);
  if (this.presenceEnabled == false)   return;
  assertConnected();
  Request subscription;
  try {
    subscription=createSubscription(contact,this.subscriptionDuration);
  }
 catch (  OperationFailedException ex) {
    logger.error(""String_Node_Str"",ex);
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INTERNAL_ERROR);
  }
  ClientTransaction subscribeTransaction;
  SipProvider jainSipProvider=this.parentProvider.getDefaultJainSipProvider();
  try {
    subscribeTransaction=jainSipProvider.getNewClientTransaction(subscription);
  }
 catch (  TransactionUnavailableException ex) {
    logger.error(""String_Node_Str"" + ""String_Node_Str"",ex);
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.NETWORK_FAILURE);
  }
  CallIdHeader idheader=(CallIdHeader)subscription.getHeader(CallIdHeader.NAME);
  this.subscribedContacts.put(idheader.getCallId(),contact);
  try {
    subscribeTransaction.sendRequest();
  }
 catch (  SipException ex) {
    logger.error(""String_Node_Str"",ex);
    this.subscribedContacts.remove(idheader.getCallId());
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.NETWORK_FAILURE);
  }
}","/** 
 * Persistently adds a subscription for the presence status of the contact corresponding to the specified contactIdentifier and indicates that it should be added to the specified group of the server stored contact list.
 * @param parentGroup the parent group of the server stored contact listwhere the contact should be added. <p>
 * @param contactIdentifier the contact whose status updates we aresubscribing for.
 * @throws IllegalArgumentException if <tt>contact</tt> or<tt>parent</tt> are not a contact known to the underlying protocol provider.
 * @throws IllegalStateException if the underlying protocol provider isnot registered/signed on a public service.
 * @throws OperationFailedException with code NETWORK_FAILURE ifsubscribing fails due to errors experienced during network communication
 */
public void subscribe(ContactGroup parentGroup,String contactIdentifier) throws IllegalArgumentException, IllegalStateException, OperationFailedException {
  logger.debug(""String_Node_Str"" + contactIdentifier);
  ContactSipImpl contact=(ContactSipImpl)resolveContactID(contactIdentifier);
  if (contact != null && contact.isPersistent()) {
    throw new OperationFailedException(""String_Node_Str"" + contactIdentifier + ""String_Node_Str"",OperationFailedException.SUBSCRIPTION_ALREADY_EXISTS);
  }
 else   if (!contact.isPersistent()) {
    ContactGroupSipImpl oldParentGroup=(ContactGroupSipImpl)contact.getParentContactGroup();
    oldParentGroup.removeContact(contact);
    fireSubscriptionEvent(contact,oldParentGroup,SubscriptionEvent.SUBSCRIPTION_REMOVED);
  }
  Address contactAddress;
  try {
    contactAddress=parentProvider.parseAddressString(contactIdentifier);
  }
 catch (  ParseException exc) {
    throw new IllegalArgumentException(contactIdentifier + ""String_Node_Str"",exc);
  }
  contact=new ContactSipImpl(contactAddress,this.parentProvider);
  ((ContactGroupSipImpl)parentGroup).addContact(contact);
  fireSubscriptionEvent(contact,parentGroup,SubscriptionEvent.SUBSCRIPTION_CREATED);
  if (this.presenceEnabled == false)   return;
  assertConnected();
  Request subscription;
  try {
    subscription=createSubscription(contact,this.subscriptionDuration);
  }
 catch (  OperationFailedException ex) {
    logger.error(""String_Node_Str"",ex);
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INTERNAL_ERROR);
  }
  ClientTransaction subscribeTransaction;
  SipProvider jainSipProvider=this.parentProvider.getDefaultJainSipProvider();
  try {
    subscribeTransaction=jainSipProvider.getNewClientTransaction(subscription);
  }
 catch (  TransactionUnavailableException ex) {
    logger.error(""String_Node_Str"" + ""String_Node_Str"",ex);
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.NETWORK_FAILURE);
  }
  CallIdHeader idheader=(CallIdHeader)subscription.getHeader(CallIdHeader.NAME);
  this.subscribedContacts.put(idheader.getCallId(),contact);
  try {
    subscribeTransaction.sendRequest();
  }
 catch (  SipException ex) {
    logger.error(""String_Node_Str"",ex);
    this.subscribedContacts.remove(idheader.getCallId());
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.NETWORK_FAILURE);
  }
}",0.9520714865962632
104095,"private void initPluginComponents(){
  ServiceReference[] serRefs=null;
  String osgiFilter=""String_Node_Str"" + Container.CONTAINER_ID + ""String_Node_Str""+ Container.CONTAINER_CHAT_TOOL_BAR.getID()+ ""String_Node_Str"";
  try {
    serRefs=GuiActivator.bundleContext.getServiceReferences(PluginComponent.class.getName(),osgiFilter);
  }
 catch (  InvalidSyntaxException exc) {
    logger.error(""String_Node_Str"",exc);
  }
  if (serRefs != null) {
    for (int i=0; i < serRefs.length; i++) {
      PluginComponent component=(PluginComponent)GuiActivator.bundleContext.getService(serRefs[i]);
      ;
      this.add((Component)component.getComponent());
      this.revalidate();
      this.repaint();
    }
  }
  GuiActivator.getUIService().addPluginComponentListener(this);
}","private void initPluginComponents(){
  ServiceReference[] serRefs=null;
  String osgiFilter=""String_Node_Str"" + Container.CONTAINER_ID + ""String_Node_Str""+ Container.CONTAINER_CHAT_TOOL_BAR.getID()+ ""String_Node_Str"";
  try {
    serRefs=GuiActivator.bundleContext.getServiceReferences(PluginComponent.class.getName(),osgiFilter);
  }
 catch (  InvalidSyntaxException exc) {
    logger.error(""String_Node_Str"",exc);
  }
  if (serRefs != null) {
    for (int i=0; i < serRefs.length; i++) {
      PluginComponent component=(PluginComponent)GuiActivator.bundleContext.getService(serRefs[i]);
      this.add((Component)component.getComponent());
      this.revalidate();
      this.repaint();
    }
  }
  GuiActivator.getUIService().addPluginComponentListener(this);
}",0.9947984395318596
104096,"/** 
 * Creates an instance and constructs the <tt>MainToolBar</tt>.
 * @param messageWindow The parent <tt>ChatWindow</tt>.
 */
public MainToolBar(ChatWindow messageWindow){
  this.messageWindow=messageWindow;
  this.setOpaque(false);
  this.setLayout(new FlowLayout(FlowLayout.LEFT,3,0));
  this.add(inviteButton);
  this.add(historyButton);
  this.add(optionsButton);
  this.sendFileButton.setName(""String_Node_Str"");
  this.sendFileButton.setToolTipText(GuiActivator.getResources().getI18NString(""String_Node_Str""));
  this.historyButton.setName(""String_Node_Str"");
  this.historyButton.setToolTipText(GuiActivator.getResources().getI18NString(""String_Node_Str"") + ""String_Node_Str"");
  this.inviteButton.setName(""String_Node_Str"");
  this.inviteButton.setToolTipText(GuiActivator.getResources().getI18NString(""String_Node_Str""));
  this.optionsButton.setName(""String_Node_Str"");
  this.optionsButton.setToolTipText(GuiActivator.getResources().getI18NString(""String_Node_Str""));
  this.sendFileButton.addActionListener(this);
  this.historyButton.addActionListener(this);
  this.inviteButton.addActionListener(this);
  this.optionsButton.addActionListener(this);
  this.initPluginComponents();
}","/** 
 * Creates an instance and constructs the <tt>MainToolBar</tt>.
 * @param messageWindow The parent <tt>ChatWindow</tt>.
 */
public MainToolBar(ChatWindow messageWindow){
  this.messageWindow=messageWindow;
  this.setOpaque(false);
  this.setLayout(new FlowLayout(FlowLayout.LEFT,3,0));
  this.add(inviteButton);
  this.add(historyButton);
  this.add(optionsButton);
  this.add(previousButton);
  this.add(nextButton);
  this.previousButton.setName(""String_Node_Str"");
  this.previousButton.setToolTipText(GuiActivator.getResources().getI18NString(""String_Node_Str""));
  this.nextButton.setName(""String_Node_Str"");
  this.nextButton.setToolTipText(GuiActivator.getResources().getI18NString(""String_Node_Str""));
  this.sendFileButton.setName(""String_Node_Str"");
  this.sendFileButton.setToolTipText(GuiActivator.getResources().getI18NString(""String_Node_Str""));
  this.historyButton.setName(""String_Node_Str"");
  this.historyButton.setToolTipText(GuiActivator.getResources().getI18NString(""String_Node_Str"") + ""String_Node_Str"");
  this.inviteButton.setName(""String_Node_Str"");
  this.inviteButton.setToolTipText(GuiActivator.getResources().getI18NString(""String_Node_Str""));
  this.optionsButton.setName(""String_Node_Str"");
  this.optionsButton.setToolTipText(GuiActivator.getResources().getI18NString(""String_Node_Str""));
  this.previousButton.addActionListener(this);
  this.nextButton.addActionListener(this);
  this.sendFileButton.addActionListener(this);
  this.historyButton.addActionListener(this);
  this.inviteButton.addActionListener(this);
  this.optionsButton.addActionListener(this);
  this.initPluginComponents();
}",0.7874293785310734
104097,"/** 
 * Disables/Enables history arrow buttons depending on whether the current page is the first, the last page or a middle page.
 */
public void changeHistoryButtonsState(ChatPanel chatPanel){
}","/** 
 * Disables/Enables history arrow buttons depending on whether the current page is the first, the last page or a middle page.
 */
public void changeHistoryButtonsState(ChatPanel chatPanel){
  ChatConversationPanel convPanel=chatPanel.getChatConversationPanel();
  long firstMsgInHistory=chatPanel.getFirstHistoryMsgTimestamp();
  long lastMsgInHistory=chatPanel.getLastHistoryMsgTimestamp();
  Date firstMsgInPage=convPanel.getPageFirstMsgTimestamp();
  Date lastMsgInPage=convPanel.getPageLastMsgTimestamp();
  if (firstMsgInHistory == 0 || lastMsgInHistory == 0) {
    previousButton.setEnabled(false);
    nextButton.setEnabled(false);
    return;
  }
  if (firstMsgInHistory < firstMsgInPage.getTime())   previousButton.setEnabled(true);
 else   previousButton.setEnabled(false);
  if (lastMsgInPage.getTime() > 0 && (lastMsgInHistory > lastMsgInPage.getTime())) {
    nextButton.setEnabled(true);
  }
 else {
    nextButton.setEnabled(false);
  }
}",0.3396880415944541
104098,"/** 
 * Passes the message to the contained <code>ChatConversationPanel</code> for processing and appends it at the end of the conversationPanel document.
 * @param contactName The name of the contact sending the message.
 * @param date The time at which the message is sent or received.
 * @param messageType The type of the message. One of OUTGOING_MESSAGEor INCOMING_MESSAGE.
 * @param message The message text.
 */
public void processMessage(String contactName,long date,String messageType,String message,String contentType){
  String processedMessage=this.conversationPanel.processMessage(contactName,date,messageType,message,contentType);
  this.conversationPanel.appendMessageToEnd(processedMessage);
}","/** 
 * Passes the message to the contained <code>ChatConversationPanel</code> for processing and appends it at the end of the conversationPanel document.
 * @param contactName The name of the contact sending the message.
 * @param date The time at which the message is sent or received.
 * @param messageType The type of the message. One of OUTGOING_MESSAGEor INCOMING_MESSAGE.
 * @param message The message text.
 */
public void processMessage(String contactName,long date,String messageType,String message,String contentType){
  String processedMessage=this.conversationPanel.processMessage(contactName,date,messageType,message,contentType);
  this.conversationPanel.appendMessageToEnd(processedMessage);
  this.lastHistoryMsgTimestamp=date;
}",0.9745704467353952
104099,"/** 
 * Invoked when <tt>ChatRoomMemberPresenceChangeEvent</tt> are received. When a new <tt>ChatRoomMember</tt> has joined the chat adds it to the list of chat participants on the right of the chat window. When a <tt>ChatRoomMember</tt> has left or quit, or has being kicked it's removed from the chat window.
 */
public void memberPresenceChanged(ChatRoomMemberPresenceChangeEvent evt){
  ChatRoom sourceChatRoom=(ChatRoom)evt.getSource();
  if (!sourceChatRoom.equals(chatRoomWrapper.getChatRoom()))   return;
  String eventType=evt.getEventType();
  ChatRoomMember chatRoomMember=evt.getChatRoomMember();
  String statusMessage=null;
  if (eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_JOINED)) {
    ConferenceChatContact chatContact=new ConferenceChatContact(chatRoomMember);
    chatParticipants.add(chatContact);
    sessionRenderer.addChatContact(chatContact);
    statusMessage=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{sourceChatRoom.getName()});
    sessionRenderer.updateChatContactStatus(chatContact,statusMessage);
  }
 else   if (eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_LEFT) || eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_KICKED) || eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_QUIT)) {
    if (eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_LEFT)) {
      statusMessage=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{sourceChatRoom.getName()});
    }
 else     if (eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_KICKED)) {
      statusMessage=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{sourceChatRoom.getName()});
    }
 else     if (eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_QUIT)) {
      statusMessage=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{sourceChatRoom.getName()});
    }
    for (    ChatContact chatContact : chatParticipants) {
      if (chatContact.getDescriptor().equals(chatRoomMember)) {
        sessionRenderer.updateChatContactStatus(chatContact,statusMessage);
        sessionRenderer.removeChatContact(chatContact);
        break;
      }
    }
  }
}","/** 
 * Invoked when <tt>ChatRoomMemberPresenceChangeEvent</tt> are received. When a new <tt>ChatRoomMember</tt> has joined the chat adds it to the list of chat participants on the right of the chat window. When a <tt>ChatRoomMember</tt> has left or quit, or has being kicked it's removed from the chat window.
 */
public void memberPresenceChanged(ChatRoomMemberPresenceChangeEvent evt){
  ChatRoom sourceChatRoom=(ChatRoom)evt.getSource();
  if (!sourceChatRoom.equals(chatRoomWrapper.getChatRoom()))   return;
  String eventType=evt.getEventType();
  ChatRoomMember chatRoomMember=evt.getChatRoomMember();
  String statusMessage=null;
  if (eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_JOINED)) {
    ConferenceChatContact chatContact=new ConferenceChatContact(chatRoomMember);
    chatParticipants.add(chatContact);
    sessionRenderer.addChatContact(chatContact);
    if (!evt.isReasonUserList()) {
      statusMessage=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{sourceChatRoom.getName()});
      sessionRenderer.updateChatContactStatus(chatContact,statusMessage);
    }
  }
 else   if (eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_LEFT) || eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_KICKED) || eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_QUIT)) {
    if (eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_LEFT)) {
      statusMessage=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{sourceChatRoom.getName()});
    }
 else     if (eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_KICKED)) {
      statusMessage=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{sourceChatRoom.getName()});
    }
 else     if (eventType.equals(ChatRoomMemberPresenceChangeEvent.MEMBER_QUIT)) {
      statusMessage=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{sourceChatRoom.getName()});
    }
    for (    ChatContact chatContact : chatParticipants) {
      if (chatContact.getDescriptor().equals(chatRoomMember)) {
        sessionRenderer.updateChatContactStatus(chatContact,statusMessage);
        sessionRenderer.removeChatContact(chatContact);
        break;
      }
    }
  }
}",0.9898808185293456
104100,"/** 
 * Creates the corresponding ChatRoomMemberPresenceChangeEvent and notifies all <tt>ChatRoomMemberPresenceListener</tt>s that a ChatRoomMember has joined or left this <tt>ChatRoom</tt>.
 * @param member the <tt>ChatRoomMember</tt> that this event is about 
 * @param actorMember a member that act in the event (for example the kickerin a member kicked event)
 * @param eventID the identifier of the event
 * @param eventReason the reason of the event
 */
public void fireMemberPresenceEvent(ChatRoomMember member,ChatRoomMember actorMember,String eventID,String eventReason){
  ChatRoomMemberPresenceChangeEvent evt=null;
  if (actorMember != null)   evt=new ChatRoomMemberPresenceChangeEvent(this,member,actorMember,eventID,eventReason);
 else   evt=new ChatRoomMemberPresenceChangeEvent(this,member,eventID,eventReason);
  logger.trace(""String_Node_Str"" + evt);
  Iterator<ChatRoomMemberPresenceListener> listeners=null;
synchronized (memberListeners) {
    listeners=new ArrayList<ChatRoomMemberPresenceListener>(memberListeners).iterator();
  }
  while (listeners.hasNext()) {
    ChatRoomMemberPresenceListener listener=(ChatRoomMemberPresenceListener)listeners.next();
    listener.memberPresenceChanged(evt);
  }
}","/** 
 * Creates the corresponding ChatRoomMemberPresenceChangeEvent and notifies all <tt>ChatRoomMemberPresenceListener</tt>s that a ChatRoomMember has joined or left this <tt>ChatRoom</tt>.
 * @param member the <tt>ChatRoomMember</tt> that this event is about 
 * @param actorMember a member that act in the event (for example the kickerin a member kicked event)
 * @param eventID the identifier of the event
 * @param eventReason the reason of the event
 */
public void fireMemberPresenceEvent(ChatRoomMember member,ChatRoomMember actorMember,String eventID,String eventReason){
  ChatRoomMemberPresenceChangeEvent evt;
  if (actorMember != null)   evt=new ChatRoomMemberPresenceChangeEvent(this,member,actorMember,eventID,eventReason);
 else   evt=new ChatRoomMemberPresenceChangeEvent(this,member,eventID,eventReason);
  logger.trace(""String_Node_Str"" + evt);
  List<ChatRoomMemberPresenceListener> listeners;
synchronized (memberListeners) {
    listeners=new ArrayList<ChatRoomMemberPresenceListener>(memberListeners);
  }
  for (  ChatRoomMemberPresenceListener listener : listeners)   listener.memberPresenceChanged(evt);
}",0.8697496817988969
104101,"/** 
 * This method is called when we receive a user list from the server after joining a channel.
 * @param channel The name of the channel.
 * @param users An array of User objects belonging to this channel.
 * @see User
 */
protected void onUserList(String channel,User[] users){
  if (logger.isDebugEnabled())   logger.debug(""String_Node_Str"" + channel);
  ChatRoomIrcImpl chatRoom=ircMUCOpSet.getChatRoom(channel);
  chatRoom.clearChatRoomMemberList();
  for (int i=0; i < users.length; i++) {
    User user=users[i];
    ChatRoomMemberRole newMemberRole;
    if (user.getPrefix().equalsIgnoreCase(""String_Node_Str"")) {
      newMemberRole=ChatRoomMemberRole.ADMINISTRATOR;
    }
 else     if (user.getPrefix().equalsIgnoreCase(""String_Node_Str"")) {
      newMemberRole=ChatRoomMemberRole.MODERATOR;
    }
 else     if (user.getPrefix().equalsIgnoreCase(""String_Node_Str"")) {
      newMemberRole=ChatRoomMemberRole.MEMBER;
    }
 else {
      newMemberRole=ChatRoomMemberRole.GUEST;
    }
    ChatRoomMemberIrcImpl newMember=new ChatRoomMemberIrcImpl(parentProvider,chatRoom,user.getNick(),null,null,newMemberRole);
    chatRoom.addChatRoomMember(user.getNick(),newMember);
    chatRoom.fireMemberPresenceEvent(newMember,null,ChatRoomMemberPresenceChangeEvent.MEMBER_JOINED,null);
  }
}","/** 
 * This method is called when we receive a user list from the server after joining a channel.
 * @param channel The name of the channel.
 * @param users An array of User objects belonging to this channel.
 * @see User
 */
protected void onUserList(String channel,User[] users){
  if (logger.isDebugEnabled())   logger.debug(""String_Node_Str"" + channel);
  ChatRoomIrcImpl chatRoom=ircMUCOpSet.getChatRoom(channel);
  chatRoom.clearChatRoomMemberList();
  for (  User user : users) {
    String userPrefix=user.getPrefix();
    ChatRoomMemberRole newMemberRole;
    if (""String_Node_Str"".equalsIgnoreCase(userPrefix))     newMemberRole=ChatRoomMemberRole.ADMINISTRATOR;
 else     if (""String_Node_Str"".equalsIgnoreCase(userPrefix))     newMemberRole=ChatRoomMemberRole.MODERATOR;
 else     if (""String_Node_Str"".equalsIgnoreCase(userPrefix))     newMemberRole=ChatRoomMemberRole.MEMBER;
 else     newMemberRole=ChatRoomMemberRole.GUEST;
    ChatRoomMemberIrcImpl newMember=new ChatRoomMemberIrcImpl(parentProvider,chatRoom,user.getNick(),null,null,newMemberRole);
    chatRoom.addChatRoomMember(user.getNick(),newMember);
    chatRoom.fireMemberPresenceEvent(newMember,null,ChatRoomMemberPresenceChangeEvent.MEMBER_JOINED,ChatRoomMemberPresenceChangeEvent.REASON_USER_LIST);
  }
}",0.785242718446602
104102,"/** 
 * Returns the list of chat rooms on this server.
 * @return the list of chat rooms on this server
 */
public List getServerChatRoomList(){
  return serverChatRoomList;
}","/** 
 * Returns the list of chat rooms on this server.
 * @return the list of chat rooms on this server
 */
public List<String> getServerChatRoomList(){
  return serverChatRoomList;
}",0.9776536312849162
104103,"/** 
 * Returns the <tt>List</tt> of <tt>ChatRoom</tt>s currently available on the server that this protocol provider is connected to.
 * @return a <tt>java.util.List</tt> of <tt>ChatRoom</tt>s that arecurrently available on the server that this protocol provider is connected to.
 * @throws OperationFailedException if we failed retrieving this list fromthe server.
 */
public List getExistingChatRooms() throws OperationFailedException {
  return ircProvider.getIrcStack().getServerChatRoomList();
}","/** 
 * Returns the <tt>List</tt> of <tt>ChatRoom</tt>s currently available on the server that this protocol provider is connected to.
 * @return a <tt>java.util.List</tt> of <tt>ChatRoom</tt>s that arecurrently available on the server that this protocol provider is connected to.
 * @throws OperationFailedException if we failed retrieving this list fromthe server.
 */
public List<String> getExistingChatRooms() throws OperationFailedException {
  return ircProvider.getIrcStack().getServerChatRoomList();
}",0.992079207920792
104104,"/** 
 * Delivers a <tt>LocalUserChatRoomPresenceChangeEvent</tt> to all registered <tt>LocalUserChatRoomPresenceListener</tt>s.
 * @param chatRoom the <tt>ChatRoom</tt> which has been joined, left, etc.
 * @param eventType the type of this event; one of LOCAL_USER_JOINED,LOCAL_USER_LEFT, etc.
 * @param reason the reason
 */
protected void fireLocalUserPresenceEvent(ChatRoom chatRoom,String eventType,String reason){
  LocalUserChatRoomPresenceChangeEvent evt=new LocalUserChatRoomPresenceChangeEvent(this,chatRoom,eventType,reason);
  Iterator listeners=null;
synchronized (localUserPresenceListeners) {
    listeners=new ArrayList(localUserPresenceListeners).iterator();
  }
  while (listeners.hasNext()) {
    LocalUserChatRoomPresenceListener listener=(LocalUserChatRoomPresenceListener)listeners.next();
    listener.localUserPresenceChanged(evt);
  }
}","/** 
 * Delivers a <tt>LocalUserChatRoomPresenceChangeEvent</tt> to all registered <tt>LocalUserChatRoomPresenceListener</tt>s.
 * @param chatRoom the <tt>ChatRoom</tt> which has been joined, left, etc.
 * @param eventType the type of this event; one of LOCAL_USER_JOINED,LOCAL_USER_LEFT, etc.
 * @param reason the reason
 */
protected void fireLocalUserPresenceEvent(ChatRoom chatRoom,String eventType,String reason){
  LocalUserChatRoomPresenceChangeEvent evt=new LocalUserChatRoomPresenceChangeEvent(this,chatRoom,eventType,reason);
  logger.trace(""String_Node_Str"" + evt);
  List<LocalUserChatRoomPresenceListener> listeners;
synchronized (localUserPresenceListeners) {
    listeners=new ArrayList<LocalUserChatRoomPresenceListener>(localUserPresenceListeners);
  }
  for (  LocalUserChatRoomPresenceListener listener : listeners)   listener.localUserPresenceChanged(evt);
}",0.6846950517836594
104105,"/** 
 * Returns a reference to a chatRoom named <tt>roomName</tt>. The room is created if it doesn't exists <p>
 * @param roomName the name of the <tt>ChatRoom</tt> that we're looking for.
 * @return the <tt>ChatRoom</tt> named <tt>roomName</tt>.
 */
public ChatRoom findRoom(String roomName){
  ChatRoom room=(ChatRoom)chatRoomCache.get(roomName);
  if (room != null) {
    return room;
  }
 else {
    return createLocalChatRoomInstance(roomName);
  }
}","/** 
 * Returns a reference to a chatRoom named <tt>roomName</tt>. The room is created if it doesn't exists <p>
 * @param roomName the name of the <tt>ChatRoom</tt> that we're looking for.
 * @return the <tt>ChatRoom</tt> named <tt>roomName</tt>.
 */
public ChatRoom findRoom(String roomName){
  ChatRoom room=chatRoomCache.get(roomName);
  return (room != null) ? room : createLocalChatRoomInstance(roomName);
}",0.9181084198385236
104106,"/** 
 * Manages a mouse click over the contact list. When the left mouse button is clicked on a contact cell different things may happen depending on the contained component under the mouse. If the mouse is double clicked on the ""contact name"" the chat window is opened, configured to use the default protocol contact for the selected MetaContact. If the mouse is clicked on one of the protocol icons, the chat window is opened, configured to use the protocol contact corresponding to the given icon. When the right mouse button is clicked on a contact cell, the cell is selected and the <tt>ContactRightButtonMenu</tt> is opened. When the right mouse button is clicked on a group cell, the cell is selected and the <tt>GroupRightButtonMenu</tt> is opened. When the middle mouse button is clicked on a cell, the cell is selected.
 */
public void mouseClicked(MouseEvent e){
  int selectedIndex=this.getSelectedIndex();
  Object selectedValue=this.getSelectedValue();
  if (selectedIndex < 0)   return;
  ContactListCellRenderer renderer=(ContactListCellRenderer)this.getCellRenderer().getListCellRendererComponent(this,selectedValue,selectedIndex,true,true);
  Point selectedCellPoint=this.indexToLocation(selectedIndex);
  int translatedX=e.getX() - selectedCellPoint.x;
  if (selectedValue instanceof MetaContactGroup) {
    MetaContactGroup group=(MetaContactGroup)selectedValue;
    if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0 || (e.isControlDown() && !e.isMetaDown())) {
      groupRightButtonMenu=new GroupRightButtonMenu(mainFrame,group);
      SwingUtilities.convertPointToScreen(selectedCellPoint,this);
      groupRightButtonMenu.setInvoker(this);
      groupRightButtonMenu.setLocation(selectedCellPoint.x,selectedCellPoint.y + renderer.getHeight());
      groupRightButtonMenu.setVisible(true);
    }
 else     if ((e.getModifiers() & InputEvent.BUTTON1_MASK) != 0) {
      if (listModel.isGroupClosed(group))       listModel.openGroup(group);
 else       listModel.closeGroup(group);
      fireContactListEvent(group,ContactListEvent.GROUP_SELECTED,e.getClickCount());
      Component component=this.getHorizontalComponent(renderer,translatedX);
      if (component instanceof JPanel) {
        if (component.getName() != null && component.getName().equals(""String_Node_Str"")) {
          JPanel panel=(JPanel)component;
          int internalX=translatedX - (renderer.getWidth() - panel.getWidth() - 2);
          Component c=getHorizontalComponent(panel,internalX);
          if (c instanceof JLabel) {
            if (listModel.isGroupClosed(group)) {
              listModel.openGroup(group);
            }
 else {
              listModel.closeGroup(group);
            }
          }
        }
      }
    }
  }
  if (selectedValue instanceof MetaContact) {
    MetaContact contact=(MetaContact)selectedValue;
    Component component=this.getHorizontalComponent(renderer,translatedX);
    if (component instanceof JLabel) {
      if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0 || (e.isControlDown() && !e.isMetaDown())) {
        contactRightButtonMenu=new ContactRightButtonMenu(this,contact);
        SwingUtilities.convertPointToScreen(selectedCellPoint,this);
        contactRightButtonMenu.setInvoker(this);
        contactRightButtonMenu.setLocation(selectedCellPoint.x,selectedCellPoint.y + renderer.getHeight());
        contactRightButtonMenu.setVisible(true);
      }
 else       if ((e.getModifiers() & InputEvent.BUTTON1_MASK) != 0 && e.getClickCount() > 1) {
        fireContactListEvent(contact,ContactListEvent.CONTACT_SELECTED,e.getClickCount());
      }
    }
 else     if (component instanceof JButton) {
      SwingUtilities.invokeLater(new RunInfoWindow(selectedCellPoint,contact));
    }
 else     if (component instanceof JPanel) {
      if (component.getName() != null && component.getName().equals(""String_Node_Str"")) {
        JPanel panel=(JPanel)component;
        int internalX=translatedX - (renderer.getWidth() - panel.getWidth() - 2);
        Component c=getHorizontalComponent(panel,internalX);
        if (c instanceof ContactProtocolButton) {
          fireContactListEvent(contact,((ContactProtocolButton)c).getProtocolContact(),ContactListEvent.PROTOCOL_CONTACT_SELECTED);
        }
      }
    }
  }
}","/** 
 * Manages a mouse click over the contact list. When the left mouse button is clicked on a contact cell different things may happen depending on the contained component under the mouse. If the mouse is double clicked on the ""contact name"" the chat window is opened, configured to use the default protocol contact for the selected MetaContact. If the mouse is clicked on one of the protocol icons, the chat window is opened, configured to use the protocol contact corresponding to the given icon. When the right mouse button is clicked on a contact cell, the cell is selected and the <tt>ContactRightButtonMenu</tt> is opened. When the right mouse button is clicked on a group cell, the cell is selected and the <tt>GroupRightButtonMenu</tt> is opened. When the middle mouse button is clicked on a cell, the cell is selected.
 */
public void mouseClicked(MouseEvent e){
  int selectedIndex=this.getSelectedIndex();
  Object selectedValue=this.getSelectedValue();
  if (selectedIndex < 0)   return;
  ContactListCellRenderer renderer=(ContactListCellRenderer)this.getCellRenderer().getListCellRendererComponent(this,selectedValue,selectedIndex,true,true);
  Point selectedCellPoint=this.indexToLocation(selectedIndex);
  int translatedX=e.getX() - selectedCellPoint.x;
  if (selectedValue instanceof MetaContactGroup) {
    MetaContactGroup group=(MetaContactGroup)selectedValue;
    if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0 || (e.isControlDown() && !e.isMetaDown())) {
      groupRightButtonMenu=new GroupRightButtonMenu(mainFrame,group);
      SwingUtilities.convertPointToScreen(selectedCellPoint,this);
      groupRightButtonMenu.setInvoker(this);
      groupRightButtonMenu.setLocation(selectedCellPoint.x,selectedCellPoint.y + renderer.getHeight());
      groupRightButtonMenu.setVisible(true);
    }
 else     if ((e.getModifiers() & InputEvent.BUTTON1_MASK) != 0) {
      if (!disableOpenClose) {
        if (listModel.isGroupClosed(group))         listModel.openGroup(group);
 else         listModel.closeGroup(group);
      }
      fireContactListEvent(group,ContactListEvent.GROUP_SELECTED,e.getClickCount());
      if (!disableOpenClose) {
        Component component=this.getHorizontalComponent(renderer,translatedX);
        if (component instanceof JPanel) {
          if (component.getName() != null && component.getName().equals(""String_Node_Str"")) {
            JPanel panel=(JPanel)component;
            int internalX=translatedX - (renderer.getWidth() - panel.getWidth() - 2);
            Component c=getHorizontalComponent(panel,internalX);
            if (c instanceof JLabel) {
              if (listModel.isGroupClosed(group)) {
                listModel.openGroup(group);
              }
 else {
                listModel.closeGroup(group);
              }
            }
          }
        }
      }
    }
  }
  if (selectedValue instanceof MetaContact) {
    MetaContact contact=(MetaContact)selectedValue;
    Component component=this.getHorizontalComponent(renderer,translatedX);
    if (component instanceof JLabel) {
      if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0 || (e.isControlDown() && !e.isMetaDown())) {
        contactRightButtonMenu=new ContactRightButtonMenu(this,contact);
        SwingUtilities.convertPointToScreen(selectedCellPoint,this);
        contactRightButtonMenu.setInvoker(this);
        contactRightButtonMenu.setLocation(selectedCellPoint.x,selectedCellPoint.y + renderer.getHeight());
        contactRightButtonMenu.setVisible(true);
      }
 else       if ((e.getModifiers() & InputEvent.BUTTON1_MASK) != 0 && e.getClickCount() > 1) {
        fireContactListEvent(contact,ContactListEvent.CONTACT_SELECTED,e.getClickCount());
      }
    }
 else     if (component instanceof JButton) {
      SwingUtilities.invokeLater(new RunInfoWindow(selectedCellPoint,contact));
    }
 else     if (component instanceof JPanel) {
      if (component.getName() != null && component.getName().equals(""String_Node_Str"")) {
        JPanel panel=(JPanel)component;
        int internalX=translatedX - (renderer.getWidth() - panel.getWidth() - 2);
        Component c=getHorizontalComponent(panel,internalX);
        if (c instanceof ContactProtocolButton) {
          fireContactListEvent(contact,((ContactProtocolButton)c).getProtocolContact(),ContactListEvent.PROTOCOL_CONTACT_SELECTED);
        }
      }
    }
  }
}",0.9868329868329868
104107,"public void groupSelected(ContactListEvent evt){
  this.moveDialog.dispose();
  MetaContactGroup sourceGroup=evt.getSourceGroup();
  guiContactList.removeExcContactListListener(this);
  if (moveAllContacts) {
    mainFrame.getContactList().moveMetaContact(contactItem,sourceGroup);
  }
 else   if (contactToMove != null) {
    new MoveSubcontactThread(sourceGroup).start();
  }
}","public void groupSelected(ContactListEvent evt){
  this.moveDialog.dispose();
  MetaContactGroup sourceGroup=evt.getSourceGroup();
  guiContactList.removeExcContactListListener(this);
  if (moveAllContacts) {
    mainFrame.getContactList().moveMetaContact(contactItem,sourceGroup);
  }
 else   if (contactToMove != null) {
    new MoveSubcontactThread(sourceGroup).start();
  }
  guiContactList.setDisableOpenClose(false);
}",0.9439601494396016
104108,"/** 
 * Handles the <tt>ActionEvent</tt>. Determines which menu item was selected and performs the appropriate operations.
 */
public void actionPerformed(ActionEvent e){
  JMenuItem menuItem=(JMenuItem)e.getSource();
  String itemName=menuItem.getName();
  Contact cont=null;
  if (itemName.startsWith(addSubcontactPrefix)) {
    ProtocolProviderService pps=((ProviderAwareMenuItem)menuItem).getProvider();
    if (pps != null) {
      AddContactDialog dialog=new AddContactDialog(mainFrame,contactItem,pps);
      dialog.setLocation(Toolkit.getDefaultToolkit().getScreenSize().width / 2 - 250,Toolkit.getDefaultToolkit().getScreenSize().height / 2 - 100);
      dialog.showDialog();
    }
  }
 else   if (itemName.equalsIgnoreCase(""String_Node_Str"")) {
    ContactListPane clistPanel=mainFrame.getContactListPanel();
    SwingUtilities.invokeLater(clistPanel.new RunMessageWindow(contactItem));
  }
 else   if (itemName.equalsIgnoreCase(""String_Node_Str"")) {
    Contact defaultSmsContact=contactItem.getDefaultContact(OperationSetSmsMessaging.class);
    ContactListPane clistPanel=mainFrame.getContactListPanel();
    SwingUtilities.invokeLater(clistPanel.new RunMessageWindow(contactItem,defaultSmsContact,true));
  }
 else   if (itemName.equalsIgnoreCase(""String_Node_Str"")) {
    cont=contactItem.getDefaultContact(OperationSetBasicTelephony.class);
    callContact(cont);
  }
 else   if (itemName.equalsIgnoreCase(""String_Node_Str"")) {
  }
 else   if (itemName.equalsIgnoreCase(""String_Node_Str"")) {
    RenameContactDialog dialog=new RenameContactDialog(mainFrame,contactItem);
    dialog.setLocation(Toolkit.getDefaultToolkit().getScreenSize().width / 2 - 200,Toolkit.getDefaultToolkit().getScreenSize().height / 2 - 50);
    dialog.setVisible(true);
    dialog.requestFocusInFiled();
  }
 else   if (itemName.equalsIgnoreCase(""String_Node_Str"")) {
    HistoryWindow history;
    HistoryWindowManager historyWindowManager=GuiActivator.getUIService().getHistoryWindowManager();
    if (historyWindowManager.containsHistoryWindowForContact(contactItem)) {
      history=historyWindowManager.getHistoryWindowForContact(contactItem);
      if (history.getState() == JFrame.ICONIFIED)       history.setState(JFrame.NORMAL);
      history.toFront();
    }
 else {
      history=new HistoryWindow(this.contactItem);
      historyWindowManager.addHistoryWindowForContact(contactItem,history);
      history.setVisible(true);
    }
  }
 else   if (itemName.startsWith(moveToPrefix)) {
    MetaContactGroup group=mainFrame.getGroupByID(itemName.substring(moveToPrefix.length()));
    try {
      if (group != null) {
        mainFrame.getContactList().moveMetaContact(contactItem,group);
      }
    }
 catch (    Exception ex) {
      new ErrorDialog(mainFrame,GuiActivator.getResources().getI18NString(""String_Node_Str""),GuiActivator.getResources().getI18NString(""String_Node_Str""),ex).showDialog();
    }
  }
 else   if (itemName.startsWith(removeContactPrefix)) {
    Contact contact=getContactFromMetaContact(itemName.substring(removeContactPrefix.length()));
    if (contact != null) {
      new RemoveContactThread(contact).start();
    }
 else {
      new RemoveAllContactsThread().start();
    }
  }
 else   if (itemName.startsWith(moveSubcontactPrefix)) {
    Contact contact=getContactFromMetaContact(itemName.substring(moveSubcontactPrefix.length()));
    guiContactList.addExcContactListListener(this);
    this.moveDialog=new MoveSubcontactMessageDialog(mainFrame,this);
    this.moveDialog.setVisible(true);
    if (contact != null) {
      this.contactToMove=contact;
    }
 else {
      this.moveAllContacts=true;
    }
  }
 else   if (itemName.startsWith(callContactPrefix)) {
    cont=getContactFromMetaContact(itemName.substring(callContactPrefix.length()));
    callContact(cont);
  }
}","/** 
 * Handles the <tt>ActionEvent</tt>. Determines which menu item was selected and performs the appropriate operations.
 */
public void actionPerformed(ActionEvent e){
  JMenuItem menuItem=(JMenuItem)e.getSource();
  String itemName=menuItem.getName();
  Contact cont=null;
  if (itemName.startsWith(addSubcontactPrefix)) {
    ProtocolProviderService pps=((ProviderAwareMenuItem)menuItem).getProvider();
    if (pps != null) {
      AddContactDialog dialog=new AddContactDialog(mainFrame,contactItem,pps);
      dialog.setLocation(Toolkit.getDefaultToolkit().getScreenSize().width / 2 - 250,Toolkit.getDefaultToolkit().getScreenSize().height / 2 - 100);
      dialog.showDialog();
    }
  }
 else   if (itemName.equalsIgnoreCase(""String_Node_Str"")) {
    ContactListPane clistPanel=mainFrame.getContactListPanel();
    SwingUtilities.invokeLater(clistPanel.new RunMessageWindow(contactItem));
  }
 else   if (itemName.equalsIgnoreCase(""String_Node_Str"")) {
    Contact defaultSmsContact=contactItem.getDefaultContact(OperationSetSmsMessaging.class);
    ContactListPane clistPanel=mainFrame.getContactListPanel();
    SwingUtilities.invokeLater(clistPanel.new RunMessageWindow(contactItem,defaultSmsContact,true));
  }
 else   if (itemName.equalsIgnoreCase(""String_Node_Str"")) {
    cont=contactItem.getDefaultContact(OperationSetBasicTelephony.class);
    callContact(cont);
  }
 else   if (itemName.equalsIgnoreCase(""String_Node_Str"")) {
  }
 else   if (itemName.equalsIgnoreCase(""String_Node_Str"")) {
    RenameContactDialog dialog=new RenameContactDialog(mainFrame,contactItem);
    dialog.setLocation(Toolkit.getDefaultToolkit().getScreenSize().width / 2 - 200,Toolkit.getDefaultToolkit().getScreenSize().height / 2 - 50);
    dialog.setVisible(true);
    dialog.requestFocusInFiled();
  }
 else   if (itemName.equalsIgnoreCase(""String_Node_Str"")) {
    HistoryWindow history;
    HistoryWindowManager historyWindowManager=GuiActivator.getUIService().getHistoryWindowManager();
    if (historyWindowManager.containsHistoryWindowForContact(contactItem)) {
      history=historyWindowManager.getHistoryWindowForContact(contactItem);
      if (history.getState() == JFrame.ICONIFIED)       history.setState(JFrame.NORMAL);
      history.toFront();
    }
 else {
      history=new HistoryWindow(this.contactItem);
      historyWindowManager.addHistoryWindowForContact(contactItem,history);
      history.setVisible(true);
    }
  }
 else   if (itemName.startsWith(moveToPrefix)) {
    MetaContactGroup group=mainFrame.getGroupByID(itemName.substring(moveToPrefix.length()));
    try {
      if (group != null) {
        mainFrame.getContactList().moveMetaContact(contactItem,group);
      }
    }
 catch (    Exception ex) {
      new ErrorDialog(mainFrame,GuiActivator.getResources().getI18NString(""String_Node_Str""),GuiActivator.getResources().getI18NString(""String_Node_Str""),ex).showDialog();
    }
  }
 else   if (itemName.startsWith(removeContactPrefix)) {
    Contact contact=getContactFromMetaContact(itemName.substring(removeContactPrefix.length()));
    if (contact != null) {
      new RemoveContactThread(contact).start();
    }
 else {
      new RemoveAllContactsThread().start();
    }
  }
 else   if (itemName.startsWith(moveSubcontactPrefix)) {
    Contact contact=getContactFromMetaContact(itemName.substring(moveSubcontactPrefix.length()));
    guiContactList.addExcContactListListener(this);
    guiContactList.setDisableOpenClose(true);
    this.moveDialog=new MoveSubcontactMessageDialog(mainFrame,this);
    this.moveDialog.addWindowListener(new WindowAdapter(){
      public void windowClosed(      WindowEvent e){
        guiContactList.setDisableOpenClose(false);
      }
    }
);
    this.moveDialog.setVisible(true);
    if (contact != null) {
      this.contactToMove=contact;
    }
 else {
      this.moveAllContacts=true;
    }
  }
 else   if (itemName.startsWith(callContactPrefix)) {
    cont=getContactFromMetaContact(itemName.substring(callContactPrefix.length()));
    callContact(cont);
  }
}",0.9711734693877552
104109,"public ManageButtonsPanel(JTable pluginTable){
  this.pluginTable=pluginTable;
  this.setLayout(new BorderLayout());
  this.setBorder(BorderFactory.createEmptyBorder(8,8,8,8));
  String showSystemBundlesProp=PluginManagerActivator.getConfigurationService().getString(""String_Node_Str"");
  if (showSystemBundlesProp != null) {
    boolean isShowSystemBundles=new Boolean(showSystemBundlesProp).booleanValue();
    this.showSysBundlesCheckBox.setSelected(isShowSystemBundles);
    ((PluginTableModel)pluginTable.getModel()).setShowSystemBundles(isShowSystemBundles);
  }
  this.showSysBundlesCheckBox.addChangeListener(new ShowSystemBundlesChangeListener());
  this.buttonsPanel.add(newButton);
  this.buttonsPanel.add(activateButton);
  this.buttonsPanel.add(deactivateButton);
  this.buttonsPanel.add(uninstallButton);
  this.buttonsPanel.add(updateButton);
  this.buttonsPanel.add(showSysBundlesCheckBox);
  this.add(buttonsPanel,BorderLayout.NORTH);
  this.newButton.addActionListener(this);
  this.activateButton.addActionListener(this);
  this.deactivateButton.addActionListener(this);
  this.uninstallButton.addActionListener(this);
  this.updateButton.addActionListener(this);
}","public ManageButtonsPanel(JTable pluginTable){
  this.pluginTable=pluginTable;
  this.setLayout(new BorderLayout());
  this.setBorder(BorderFactory.createEmptyBorder(8,8,8,8));
  String showSystemBundlesProp=PluginManagerActivator.getConfigurationService().getString(""String_Node_Str"");
  if (showSystemBundlesProp != null) {
    boolean isShowSystemBundles=new Boolean(showSystemBundlesProp).booleanValue();
    this.showSysBundlesCheckBox.setSelected(isShowSystemBundles);
    ((PluginTableModel)pluginTable.getModel()).setShowSystemBundles(isShowSystemBundles);
  }
  this.showSysBundlesCheckBox.addChangeListener(new ShowSystemBundlesChangeListener());
  this.buttonsPanel.add(newButton);
  this.buttonsPanel.add(activateButton);
  this.buttonsPanel.add(deactivateButton);
  this.buttonsPanel.add(uninstallButton);
  this.buttonsPanel.add(updateButton);
  this.buttonsPanel.add(showSysBundlesCheckBox);
  this.add(buttonsPanel,BorderLayout.NORTH);
  this.newButton.addActionListener(this);
  this.activateButton.addActionListener(this);
  this.deactivateButton.addActionListener(this);
  this.uninstallButton.addActionListener(this);
  this.updateButton.addActionListener(this);
  enableActivateButton(false);
  enableDeactivateButton(false);
  enableUninstallButton(false);
}",0.961038961038961
104110,"public void stateChanged(ChangeEvent e){
  if (currentValue == showSysBundlesCheckBox.isSelected()) {
    return;
  }
  currentValue=showSysBundlesCheckBox.isSelected();
  PluginManagerActivator.getConfigurationService().setProperty(""String_Node_Str"",new Boolean(showSysBundlesCheckBox.isSelected()));
  PluginTableModel tableModel=(PluginTableModel)pluginTable.getModel();
  tableModel.setShowSystemBundles(showSysBundlesCheckBox.isSelected());
  tableModel.update();
}","public void stateChanged(ChangeEvent e){
  if (currentValue == showSysBundlesCheckBox.isSelected()) {
    return;
  }
  currentValue=showSysBundlesCheckBox.isSelected();
  PluginManagerActivator.getConfigurationService().setProperty(""String_Node_Str"",new Boolean(showSysBundlesCheckBox.isSelected()));
  PluginTableModel tableModel=(PluginTableModel)pluginTable.getModel();
  tableModel.setShowSystemBundles(showSysBundlesCheckBox.isSelected());
  tableModel.update();
  enableActivateButton(false);
  enableDeactivateButton(false);
  enableUninstallButton(false);
}",0.9073359073359072
104111,"public void keyPressed(KeyEvent e){
}","public void keyPressed(KeyEvent e){
  if (contactList.getModel().getSize() <= 0)   return;
  int keyCode=e.getKeyCode();
  if (keyCode == KeyEvent.VK_LEFT) {
    closeGroup();
  }
 else   if (keyCode == KeyEvent.VK_RIGHT) {
    openGroup();
  }
 else   if (keyCode == KeyEvent.VK_ENTER) {
    openOrCloseGroup();
  }
}",0.2084507042253521
104112,"/** 
 * Searches the contact list when any key, different from ""space"", ""+"" or ""-"" is typed. Selects the Contact name closest to the typed string. The time between two button presses is checked to determine whether the user makes a new search or a continuous search. When user types the same letter consecutively the search mechanism selects the next Contact name starting with the same letter.
 */
public void keyTyped(KeyEvent e){
  if (contactList.getModel().getSize() <= 0)   return;
  long eventTimestamp=e.getWhen();
  char keyChar=e.getKeyChar();
  if (keyChar == ' ') {
    closeGroup();
  }
 else   if (keyChar == '+') {
    openGroup();
  }
 else   if (keyChar == '-') {
    closeGroup();
  }
 else {
    if ((lastTypedTimestamp - eventTimestamp) > 1000) {
      keyBuffer.delete(0,keyBuffer.length() - 1);
    }
    this.lastTypedTimestamp=eventTimestamp;
    this.keyBuffer.append(keyChar);
    boolean selectedSameLetterContact=false;
    int selectedIndex=this.contactList.getSelectedIndex();
    if (selectedIndex != -1) {
      Object selectedObject=this.contactList.getSelectedValue();
      if (selectedObject instanceof MetaContact) {
        String selectedContactName=((MetaContact)selectedObject).getDisplayName();
        if (selectedContactName != null) {
          selectedSameLetterContact=selectedContactName.substring(0,1).equalsIgnoreCase(keyBuffer.toString());
        }
      }
    }
    int contactIndex=contactList.getNextMatch(keyBuffer.toString(),(lastTypedKey != keyChar || !selectedSameLetterContact) ? 0 : selectedIndex + 1,Position.Bias.Forward);
    int currentlySelectedIndex=this.contactList.getSelectedIndex();
    if (currentlySelectedIndex != contactIndex && contactIndex != -1) {
      this.contactList.setSelectedIndex(contactIndex);
      currentlySelectedIndex=contactList.getSelectedIndex();
    }
    this.contactList.ensureIndexIsVisible(currentlySelectedIndex);
    this.lastTypedKey=keyChar;
  }
}","/** 
 * Searches the contact list when any key, different from ""space"", ""+"" or ""-"" is typed. Selects the Contact name closest to the typed string. The time between two button presses is checked to determine whether the user makes a new search or a continuous search. When user types the same letter consecutively the search mechanism selects the next Contact name starting with the same letter.
 */
public void keyTyped(KeyEvent e){
  if (contactList.getModel().getSize() <= 0)   return;
  long eventTimestamp=e.getWhen();
  char keyChar=e.getKeyChar();
  if (keyChar == ' ') {
    openOrCloseGroup();
  }
 else   if (keyChar == '+') {
    openGroup();
  }
 else   if (keyChar == '-') {
    closeGroup();
  }
 else {
    if ((lastTypedTimestamp - eventTimestamp) > 1000) {
      keyBuffer.delete(0,keyBuffer.length() - 1);
    }
    this.lastTypedTimestamp=eventTimestamp;
    this.keyBuffer.append(keyChar);
    boolean selectedSameLetterContact=false;
    int selectedIndex=this.contactList.getSelectedIndex();
    if (selectedIndex != -1) {
      Object selectedObject=this.contactList.getSelectedValue();
      if (selectedObject instanceof MetaContact) {
        String selectedContactName=((MetaContact)selectedObject).getDisplayName();
        if (selectedContactName != null) {
          selectedSameLetterContact=selectedContactName.substring(0,1).equalsIgnoreCase(keyBuffer.toString());
        }
      }
    }
    int contactIndex=contactList.getNextMatch(keyBuffer.toString(),(lastTypedKey != keyChar || !selectedSameLetterContact) ? 0 : selectedIndex + 1,Position.Bias.Forward);
    int currentlySelectedIndex=this.contactList.getSelectedIndex();
    if (currentlySelectedIndex != contactIndex && contactIndex != -1) {
      this.contactList.setSelectedIndex(contactIndex);
      currentlySelectedIndex=contactList.getSelectedIndex();
    }
    this.contactList.ensureIndexIsVisible(currentlySelectedIndex);
    this.lastTypedKey=keyChar;
  }
}",0.9979529170931424
104113,"public void actionPerformed(ActionEvent e){
  Object selectedValue=contactList.getSelectedValue();
  if (selectedValue instanceof MetaContact) {
    MetaContact contact=(MetaContact)selectedValue;
    SwingUtilities.invokeLater(new RunMessageWindow(contact));
  }
 else   if (selectedValue instanceof MetaContactGroup) {
    MetaContactGroup group=(MetaContactGroup)selectedValue;
    ContactListModel model=(ContactListModel)contactList.getModel();
    if (model.isGroupClosed(group)) {
      model.openGroup(group);
    }
  }
}","public void actionPerformed(ActionEvent e){
  Object selectedValue=contactList.getSelectedValue();
  if (selectedValue instanceof MetaContact) {
    MetaContact contact=(MetaContact)selectedValue;
    SwingUtilities.invokeLater(new RunMessageWindow(contact));
  }
}",0.6675062972292192
104114,"/** 
 * Put the JAIN-SIP stack in a state where it cannot receive any data and frees the network ports used. That is to say remove JAIN-SIP <tt>ListeningPoint</tt>s and <tt>SipProvider</tt>s.
 */
private void stopListening(){
  try {
    this.secureJainSipProvider.removeSipListener(this);
    this.stack.deleteSipProvider(this.secureJainSipProvider);
    this.secureJainSipProvider=null;
    this.clearJainSipProvider.removeSipListener(this);
    this.stack.deleteSipProvider(this.clearJainSipProvider);
    this.clearJainSipProvider=null;
    Iterator<ListeningPoint> it=this.stack.getListeningPoints();
    while (it.hasNext()) {
      this.stack.deleteListeningPoint(it.next());
      it=this.stack.getListeningPoints();
    }
    this.stack.stop();
    logger.trace(""String_Node_Str"");
  }
 catch (  ObjectInUseException ex) {
    logger.fatal(""String_Node_Str"",ex);
  }
}","/** 
 * Put the JAIN-SIP stack in a state where it cannot receive any data and frees the network ports used. That is to say remove JAIN-SIP <tt>ListeningPoint</tt>s and <tt>SipProvider</tt>s.
 */
private void stopListening(){
  try {
    this.secureJainSipProvider.removeSipListener(this);
    this.stack.deleteSipProvider(this.secureJainSipProvider);
    this.secureJainSipProvider=null;
    this.clearJainSipProvider.removeSipListener(this);
    this.stack.deleteSipProvider(this.clearJainSipProvider);
    this.clearJainSipProvider=null;
    Iterator<ListeningPoint> it=this.stack.getListeningPoints();
    Vector<ListeningPoint> lpointsToRemove=new Vector<ListeningPoint>();
    while (it.hasNext()) {
      lpointsToRemove.add(it.next());
    }
    it=lpointsToRemove.iterator();
    while (it.hasNext()) {
      this.stack.deleteListeningPoint(it.next());
    }
    this.stack.stop();
    logger.trace(""String_Node_Str"");
  }
 catch (  ObjectInUseException ex) {
    logger.fatal(""String_Node_Str"",ex);
  }
}",0.8831306187202538
104115,"/** 
 * Creates a rounded corner scaled image.
 * @param imageBytes The bytes of the image to be scaled.
 * @param width The maximum width of the scaled image.
 * @param height The maximum height of the scaled image.
 * @return The rounded corner scaled image.
 */
public static ImageIcon getScaledRoundedIcon(byte[] imageBytes,int width,int height){
  if (imageBytes == null || !(imageBytes.length > 0))   return null;
  ImageIcon imageIcon=null;
  try {
    InputStream in=new ByteArrayInputStream(imageBytes);
    BufferedImage image=ImageIO.read(in);
    if (image != null)     imageIcon=getScaledRoundedIcon(image,width,height);
 else     logger.trace(""String_Node_Str"");
  }
 catch (  Exception e) {
    logger.debug(""String_Node_Str"",e);
  }
  return imageIcon;
}","/** 
 * Creates a rounded corner scaled image.
 * @param imageBytes The bytes of the image to be scaled.
 * @param width The maximum width of the scaled image.
 * @param height The maximum height of the scaled image.
 * @return The rounded corner scaled image.
 */
public static ImageIcon getScaledRoundedIcon(byte[] imageBytes,int width,int height){
  if (imageBytes == null || !(imageBytes.length > 0))   return null;
  ImageIcon imageIcon=null;
  try {
    Image image=null;
    try {
      image=ImageIO.read(new ByteArrayInputStream(imageBytes));
    }
 catch (    Exception e) {
      try {
        image=Toolkit.getDefaultToolkit().createImage(imageBytes);
      }
 catch (      Exception e1) {
        throw e;
      }
    }
    if (image != null)     imageIcon=getScaledRoundedIcon(image,width,height);
 else     logger.trace(""String_Node_Str"");
  }
 catch (  Exception e) {
    logger.debug(""String_Node_Str"",e);
  }
  return imageIcon;
}",0.810244470314319
104116,"/** 
 * When CTRL+Z is pressed invokes the <code>ChatWritePanel.undo()</code> method, when CTRL+R is pressed invokes the <code>ChatWritePanel.redo()</code> method. <p> Sends typing notifications when user types.
 */
public void keyPressed(KeyEvent e){
  if ((e.getModifiers() & KeyEvent.CTRL_MASK) == KeyEvent.CTRL_MASK && (e.getKeyCode() == KeyEvent.VK_Z)) {
    if (undo.canUndo())     undo();
  }
 else   if ((e.getModifiers() & KeyEvent.CTRL_MASK) == KeyEvent.CTRL_MASK && (e.getKeyCode() == KeyEvent.VK_R)) {
    if (undo.canRedo())     redo();
  }
 else   if (ConfigurationManager.isSendTypingNotifications() && e.getKeyCode() != KeyEvent.VK_ESCAPE) {
    if (typingState != OperationSetTypingNotifications.STATE_TYPING) {
      stoppedTypingTimer.setDelay(2 * 1000);
      typingState=OperationSetTypingNotifications.STATE_TYPING;
      int result=chatPanel.getChatSession().getCurrentChatTransport().sendTypingNotification(typingState);
      if (result == ChatPanel.TYPING_NOTIFICATION_SUCCESSFULLY_SENT)       typingTimer.start();
    }
    if (!stoppedTypingTimer.isRunning())     stoppedTypingTimer.start();
 else     stoppedTypingTimer.restart();
  }
}","/** 
 * When CTRL+Z is pressed invokes the <code>ChatWritePanel.undo()</code> method, when CTRL+R is pressed invokes the <code>ChatWritePanel.redo()</code> method. <p> Sends typing notifications when user types.
 */
public void keyPressed(KeyEvent e){
  if ((e.getModifiers() & KeyEvent.CTRL_MASK) == KeyEvent.CTRL_MASK && (e.getKeyCode() == KeyEvent.VK_Z)) {
    if (undo.canUndo())     undo();
  }
 else   if ((e.getModifiers() & KeyEvent.CTRL_MASK) == KeyEvent.CTRL_MASK && (e.getKeyCode() == KeyEvent.VK_R)) {
    if (undo.canRedo())     redo();
  }
 else   if (ConfigurationManager.isSendTypingNotifications() && e.getKeyCode() != KeyEvent.VK_ESCAPE && !e.isAltDown() && !e.isControlDown() && !e.isActionKey()) {
    if (typingState != OperationSetTypingNotifications.STATE_TYPING) {
      stoppedTypingTimer.setDelay(2 * 1000);
      typingState=OperationSetTypingNotifications.STATE_TYPING;
      int result=chatPanel.getChatSession().getCurrentChatTransport().sendTypingNotification(typingState);
      if (result == ChatPanel.TYPING_NOTIFICATION_SUCCESSFULLY_SENT)       typingTimer.start();
    }
    if (!stoppedTypingTimer.isRunning())     stoppedTypingTimer.start();
 else     stoppedTypingTimer.restart();
  }
}",0.9748953974895398
104117,"/** 
 * Handles the <tt>ActionEvent</tt>. The choosen menu item should correspond to an account, where the new contact will be added. We obtain here the protocol provider corresponding to the choosen account and show the dialog, where the user could add the contact.
 */
public void actionPerformed(ActionEvent e){
  JMenuItem item=(JMenuItem)e.getSource();
  String itemText=item.getText();
  String itemName=item.getName();
  if (itemName.equals(""String_Node_Str"")) {
    if (group != null)     new RemoveGroupThread(group).start();
  }
 else   if (itemName.equals(""String_Node_Str"")) {
    RenameGroupDialog dialog=new RenameGroupDialog(mainFrame,group);
    dialog.setLocation(Toolkit.getDefaultToolkit().getScreenSize().width / 2 - 200,Toolkit.getDefaultToolkit().getScreenSize().height / 2 - 50);
    dialog.setVisible(true);
    dialog.requestFocusInFiled();
  }
 else   if (item instanceof AccountMenuItem) {
    ProtocolProviderService pps=((AccountMenuItem)item).getProtocolProvider();
    AddContactDialog dialog=new AddContactDialog(mainFrame,group,pps);
    dialog.setLocation(Toolkit.getDefaultToolkit().getScreenSize().width / 2 - 250,Toolkit.getDefaultToolkit().getScreenSize().height / 2 - 100);
    dialog.showDialog();
  }
}","/** 
 * Handles the <tt>ActionEvent</tt>. The choosen menu item should correspond to an account, where the new contact will be added. We obtain here the protocol provider corresponding to the choosen account and show the dialog, where the user could add the contact.
 */
public void actionPerformed(ActionEvent e){
  JMenuItem item=(JMenuItem)e.getSource();
  String itemName=item.getName();
  if (itemName.equals(""String_Node_Str"")) {
    if (group != null)     new RemoveGroupThread(group).start();
  }
 else   if (itemName.equals(""String_Node_Str"")) {
    RenameGroupDialog dialog=new RenameGroupDialog(mainFrame,group);
    dialog.setLocation(Toolkit.getDefaultToolkit().getScreenSize().width / 2 - 200,Toolkit.getDefaultToolkit().getScreenSize().height / 2 - 50);
    dialog.setVisible(true);
    dialog.requestFocusInFiled();
  }
 else   if (item instanceof AccountMenuItem) {
    ProtocolProviderService pps=((AccountMenuItem)item).getProtocolProvider();
    AddContactDialog dialog=new AddContactDialog(mainFrame,group,pps);
    dialog.setLocation(Toolkit.getDefaultToolkit().getScreenSize().width / 2 - 250,Toolkit.getDefaultToolkit().getScreenSize().height / 2 - 100);
    dialog.showDialog();
  }
}",0.9861337683523654
104118,"/** 
 * Creates an instance of <tt>ChatContactListPanel</tt>.
 */
public ChatRoomMemberListPanel(ChatPanel chat){
  super(new BorderLayout());
  this.memberList=new DefaultContactList();
  this.memberList.setModel(memberListModel);
  this.memberList.setCellRenderer(new ChatContactCellRenderer());
  JScrollPane contactsScrollPane=new SCScrollPane();
  contactsScrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  contactsScrollPane.getViewport().add(memberList);
  contactsScrollPane.getViewport().setOpaque(false);
  contactsScrollPane.setOpaque(false);
  this.add(contactsScrollPane);
}","/** 
 * Creates an instance of <tt>ChatContactListPanel</tt>.
 */
public ChatRoomMemberListPanel(ChatPanel chat){
  super(new BorderLayout());
  this.memberList.setModel(memberListModel);
  this.memberList.setCellRenderer(new ChatContactCellRenderer());
  JScrollPane contactsScrollPane=new SCScrollPane();
  contactsScrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  contactsScrollPane.setOpaque(false);
  JViewport viewport=contactsScrollPane.getViewport();
  viewport.setOpaque(false);
  viewport.add(memberList);
  this.add(contactsScrollPane);
}",0.8176519567027477
104119,"/** 
 * Method used to listen for property change events from the model and update the dialog's graphical components as necessary.
 * @param evt PropertyChangeEvent passed from the model to signal that oneof its properties has changed value.
 */
public void propertyChange(PropertyChangeEvent evt){
  if (evt.getPropertyName().equals(WizardModel.CURRENT_PAGE_PROPERTY)) {
    wizardController.resetButtonsToPanelRules();
  }
 else   if (evt.getPropertyName().equals(WizardModel.NEXT_FINISH_BUTTON_TEXT_PROPERTY)) {
    nextButton.setText(evt.getNewValue().toString());
  }
 else   if (evt.getPropertyName().equals(WizardModel.BACK_BUTTON_TEXT_PROPERTY)) {
    backButton.setText(evt.getNewValue().toString());
  }
 else   if (evt.getPropertyName().equals(WizardModel.CANCEL_BUTTON_TEXT_PROPERTY)) {
    cancelButton.setText(evt.getNewValue().toString());
  }
 else   if (evt.getPropertyName().equals(WizardModel.NEXT_FINISH_BUTTON_ENABLED_PROPERTY)) {
    nextButton.setEnabled((Boolean)evt.getNewValue());
  }
 else   if (evt.getPropertyName().equals(WizardModel.BACK_BUTTON_ENABLED_PROPERTY)) {
    backButton.setEnabled((Boolean)evt.getNewValue());
  }
 else   if (evt.getPropertyName().equals(WizardModel.CANCEL_BUTTON_ENABLED_PROPERTY)) {
    cancelButton.setEnabled((Boolean)evt.getNewValue());
  }
 else   if (evt.getPropertyName().equals(WizardModel.NEXT_FINISH_BUTTON_ICON_PROPERTY)) {
    nextButton.setIcon((Icon)evt.getNewValue());
  }
 else   if (evt.getPropertyName().equals(WizardModel.BACK_BUTTON_ICON_PROPERTY)) {
    backButton.setIcon((Icon)evt.getNewValue());
  }
 else   if (evt.getPropertyName().equals(WizardModel.CANCEL_BUTTON_ICON_PROPERTY)) {
    cancelButton.setIcon((Icon)evt.getNewValue());
  }
}","/** 
 * Method used to listen for property change events from the model and update the dialog's graphical components as necessary.
 * @param evt PropertyChangeEvent passed from the model to signal that oneof its properties has changed value.
 */
public void propertyChange(PropertyChangeEvent evt){
  String name=evt.getPropertyName();
  if (WizardModel.CURRENT_PAGE_PROPERTY.equals(name)) {
    wizardController.resetButtonsToPanelRules();
  }
 else   if (WizardModel.NEXT_FINISH_BUTTON_TEXT_PROPERTY.equals(name)) {
    nextButton.setText(evt.getNewValue().toString());
  }
 else   if (WizardModel.BACK_BUTTON_TEXT_PROPERTY.equals(name)) {
    backButton.setText(evt.getNewValue().toString());
  }
 else   if (WizardModel.CANCEL_BUTTON_TEXT_PROPERTY.equals(name)) {
    cancelButton.setText(evt.getNewValue().toString());
  }
 else   if (WizardModel.NEXT_FINISH_BUTTON_ENABLED_PROPERTY.equals(name)) {
    nextButton.setEnabled((Boolean)evt.getNewValue());
  }
 else   if (WizardModel.BACK_BUTTON_ENABLED_PROPERTY.equals(name)) {
    backButton.setEnabled((Boolean)evt.getNewValue());
  }
 else   if (WizardModel.CANCEL_BUTTON_ENABLED_PROPERTY.equals(name)) {
    cancelButton.setEnabled((Boolean)evt.getNewValue());
  }
 else   if (WizardModel.NEXT_FINISH_BUTTON_ICON_PROPERTY.equals(name)) {
    nextButton.setIcon((Icon)evt.getNewValue());
  }
 else   if (WizardModel.BACK_BUTTON_ICON_PROPERTY.equals(name)) {
    backButton.setIcon((Icon)evt.getNewValue());
  }
 else   if (WizardModel.CANCEL_BUTTON_ICON_PROPERTY.equals(name)) {
    cancelButton.setIcon((Icon)evt.getNewValue());
  }
}",0.7530901416943021
104120,"/** 
 * Removes from the wizard the <tt>WizardPage</tt> corresponding to the given identifier.
 * @param id The identifer of the wizard page.
 */
public void unregisterWizardPage(Object id){
  WizardPage wizardPage=wizardModel.getWizardPage(id);
  if (wizardPage != null) {
    cardPanel.remove((Component)wizardModel.getWizardPage(id).getWizardForm());
    wizardModel.unregisterPage(id);
  }
}","/** 
 * Removes from the wizard the <tt>WizardPage</tt> corresponding to the given identifier.
 * @param id The identifier of the wizard page.
 */
public void unregisterWizardPage(Object id){
  WizardPage wizardPage=wizardModel.getWizardPage(id);
  if (wizardPage != null) {
    cardPanel.remove((Component)wizardModel.getWizardPage(id).getWizardForm());
    wizardModel.unregisterPage(id);
  }
}",0.9987357774968394
104121,"/** 
 * This method accepts a java.awt.Frame object as the javax.swing.JDialog's parent.
 * @param owner The java.awt.Frame object that is the owner of thejavax.swing.JDialog.
 */
public Wizard(Frame owner){
  super(owner,false);
  wizardModel=new WizardModel();
  initComponents();
}","/** 
 * This method accepts a java.awt.Frame object as the javax.swing.JDialog's parent.
 * @param owner The java.awt.Frame object that is the owner of thejavax.swing.JDialog.
 */
public Wizard(Frame owner){
  super(owner,false);
  initComponents();
}",0.8859813084112149
104122,"/** 
 * Resets the buttons to support the original panel rules, including whether the next or back buttons are enabled or disabled, or if the panel is finishable. If the panel in question has another panel behind it, enables the back button. Otherwise, disables it. If the panel in question has one or more panels in front of it, enables the next button. Otherwise, disables it.
 */
void resetButtonsToPanelRules(){
  WizardModel model=wizard.getModel();
  WizardPage page=model.getCurrentWizardPage();
  model.setCancelButtonText(Wizard.CANCEL_TEXT);
  model.setBackButtonText(Wizard.BACK_TEXT);
  if (page.getBackPageIdentifier() != null) {
    model.setBackButtonEnabled(Boolean.TRUE);
  }
 else {
    model.setBackButtonEnabled(Boolean.FALSE);
  }
  if (page.getNextPageIdentifier() != null) {
    model.setNextFinishButtonEnabled(Boolean.TRUE);
  }
 else {
    model.setNextFinishButtonEnabled(Boolean.FALSE);
  }
  if (page.getNextPageIdentifier().equals(WizardPage.FINISH_PAGE_IDENTIFIER)) {
    model.setNextFinishButtonText(Wizard.FINISH_TEXT);
  }
 else {
    model.setNextFinishButtonText(Wizard.NEXT_TEXT);
  }
}","/** 
 * Resets the buttons to support the original panel rules, including whether the next or back buttons are enabled or disabled, or if the panel is finishable. If the panel in question has another panel behind it, enables the back button. Otherwise, disables it. If the panel in question has one or more panels in front of it, enables the next button. Otherwise, disables it.
 */
void resetButtonsToPanelRules(){
  WizardModel model=wizard.getModel();
  WizardPage page=model.getCurrentWizardPage();
  model.setCancelButtonText(Wizard.CANCEL_TEXT);
  Object backPageIdentifier=page.getBackPageIdentifier();
  model.setBackButtonEnabled((backPageIdentifier != null) && !WizardPage.DEFAULT_PAGE_IDENTIFIER.equals(backPageIdentifier));
  model.setBackButtonText(Wizard.BACK_TEXT);
  model.setNextFinishButtonEnabled(page.getNextPageIdentifier() != null);
  if (page.getNextPageIdentifier().equals(WizardPage.FINISH_PAGE_IDENTIFIER)) {
    model.setNextFinishButtonText(Wizard.FINISH_TEXT);
  }
 else {
    model.setNextFinishButtonText(Wizard.NEXT_TEXT);
  }
}",0.7619047619047619
104123,"/** 
 * Saves the (protocol provider, wizard) pair in through the <tt>ConfigurationService</tt>.
 * @param protocolProvider the protocol provider to save
 * @param wizard the wizard to save
 */
public void saveAccountWizard(ProtocolProviderService protocolProvider,AccountRegistrationWizard wizard){
  String prefix=""String_Node_Str"";
  List<String> accounts=configService.getPropertyNamesByPrefix(prefix,true);
  boolean savedAccount=false;
  for (  String accountRootPropName : accounts) {
    String accountUID=configService.getString(accountRootPropName);
    if (accountUID.equals(protocolProvider.getAccountID().getAccountUniqueID())) {
      configService.setProperty(accountRootPropName + ""String_Node_Str"",wizard.getClass().getName().replace('.','_'));
      savedAccount=true;
    }
  }
  if (!savedAccount) {
    String accNodeName=""String_Node_Str"" + Long.toString(System.currentTimeMillis());
    String accountPackage=""String_Node_Str"" + accNodeName;
    configService.setProperty(accountPackage,protocolProvider.getAccountID().getAccountUniqueID());
    configService.setProperty(accountPackage + ""String_Node_Str"",wizard);
  }
}","/** 
 * Saves the (protocol provider, wizard) pair in through the <tt>ConfigurationService</tt>.
 * @param protocolProvider the protocol provider to save
 * @param wizard the wizard to save
 */
public void saveAccountWizard(ProtocolProviderService protocolProvider,AccountRegistrationWizard wizard){
  String prefix=""String_Node_Str"";
  List<String> accounts=configService.getPropertyNamesByPrefix(prefix,true);
  boolean savedAccount=false;
  for (  String accountRootPropName : accounts) {
    String accountUID=configService.getString(accountRootPropName);
    if (accountUID.equals(protocolProvider.getAccountID().getAccountUniqueID())) {
      configService.setProperty(accountRootPropName + ""String_Node_Str"",wizard.getClass().getName().replace('.','_'));
      savedAccount=true;
    }
  }
  if (!savedAccount) {
    String accountPackage=prefix + ""String_Node_Str"" + Long.toString(System.currentTimeMillis());
    configService.setProperty(accountPackage,protocolProvider.getAccountID().getAccountUniqueID());
    configService.setProperty(accountPackage + ""String_Node_Str"",wizard);
  }
}",0.962070504239179
104124,"public AccountRegWizardContainerImpl(MainFrame mainFrame){
  super(mainFrame);
  this.setTitle(GuiActivator.getResources().getI18NString(""String_Node_Str""));
  this.summaryPage=new AccountRegSummaryPage(this);
  this.registerWizardPage(summaryPage.getIdentifier(),summaryPage);
  ServiceReference[] accountWizardRefs=null;
  try {
    accountWizardRefs=GuiActivator.bundleContext.getServiceReferences(AccountRegistrationWizard.class.getName(),null);
  }
 catch (  InvalidSyntaxException ex) {
    logger.error(""String_Node_Str"",ex);
    return;
  }
  if (accountWizardRefs != null) {
    logger.debug(""String_Node_Str"" + accountWizardRefs.length + ""String_Node_Str"");
    for (int i=0; i < accountWizardRefs.length; i++) {
      ServiceReference serRef=accountWizardRefs[i];
      String protocolName=(String)serRef.getProperty(ProtocolProviderFactory.PROTOCOL);
      AccountRegistrationWizard wizard=(AccountRegistrationWizard)GuiActivator.bundleContext.getService(serRef);
      this.addAccountRegistrationWizard(protocolName,wizard);
    }
  }
  GuiActivator.bundleContext.addServiceListener(this);
}","public AccountRegWizardContainerImpl(MainFrame mainFrame){
  super(mainFrame);
  this.setTitle(GuiActivator.getResources().getI18NString(""String_Node_Str""));
  this.summaryPage=new AccountRegSummaryPage(this);
  this.registerWizardPage(summaryPage.getIdentifier(),summaryPage);
  ServiceReference[] accountWizardRefs=null;
  try {
    accountWizardRefs=GuiActivator.bundleContext.getServiceReferences(AccountRegistrationWizard.class.getName(),null);
  }
 catch (  InvalidSyntaxException ex) {
    logger.error(""String_Node_Str"",ex);
    return;
  }
  if (accountWizardRefs != null) {
    logger.debug(""String_Node_Str"" + accountWizardRefs.length + ""String_Node_Str"");
    for (    ServiceReference serRef : accountWizardRefs) {
      String protocolName=(String)serRef.getProperty(ProtocolProviderFactory.PROTOCOL);
      AccountRegistrationWizard wizard=(AccountRegistrationWizard)GuiActivator.bundleContext.getService(serRef);
      this.addAccountRegistrationWizard(protocolName,wizard);
    }
  }
  GuiActivator.bundleContext.addServiceListener(this);
}",0.951411383618695
104125,"/** 
 * Handles registration of a new account wizard.
 */
public void serviceChanged(ServiceEvent event){
  if (!GuiActivator.isStarted)   return;
  ServiceReference serRef=event.getServiceReference();
  String protocolName=(String)serRef.getProperty(ProtocolProviderFactory.PROTOCOL);
  Object sService=GuiActivator.bundleContext.getService(event.getServiceReference());
  if (!(sService instanceof AccountRegistrationWizard)) {
    return;
  }
  AccountRegistrationWizard wizard=(AccountRegistrationWizard)sService;
switch (event.getType()) {
case ServiceEvent.REGISTERED:
    logger.info(""String_Node_Str"");
  this.addAccountRegistrationWizard(protocolName,wizard);
break;
case ServiceEvent.UNREGISTERING:
this.removeAccountRegistrationWizard(protocolName,wizard);
break;
}
}","/** 
 * Handles registration of a new account wizard.
 */
public void serviceChanged(ServiceEvent event){
  if (!GuiActivator.isStarted)   return;
  ServiceReference serRef=event.getServiceReference();
  Object sService=GuiActivator.bundleContext.getService(serRef);
  if (!(sService instanceof AccountRegistrationWizard))   return;
  String protocolName=(String)serRef.getProperty(ProtocolProviderFactory.PROTOCOL);
  AccountRegistrationWizard wizard=(AccountRegistrationWizard)sService;
switch (event.getType()) {
case ServiceEvent.REGISTERED:
    logger.info(""String_Node_Str"");
  this.addAccountRegistrationWizard(protocolName,wizard);
break;
case ServiceEvent.UNREGISTERING:
this.removeAccountRegistrationWizard(protocolName,wizard);
break;
}
}",0.8094302554027505
104126,"/** 
 * Opens the corresponding wizard to modify an existing account given by the <tt>protocolProvider</tt> parameter.
 * @param protocolProvider The <tt>ProtocolProviderService</tt> for theaccount to modify.
 */
public void modifyAccount(ProtocolProviderService protocolProvider){
  AccountRegistrationWizard wizard=registeredWizards.get(protocolProvider.getProtocolDisplayName());
  this.setCurrentWizard(wizard);
  wizard.setModification(true);
  Iterator<WizardPage> i=wizard.getPages();
  boolean firstPage=true;
  while (i.hasNext()) {
    WizardPage page=i.next();
    Object identifier=page.getIdentifier();
    this.registerWizardPage(identifier,page);
    if (firstPage) {
      this.setCurrentPage(identifier);
      firstPage=false;
    }
  }
  wizard.loadAccount(protocolProvider);
  try {
    this.setWizzardIcon(ImageIO.read(new ByteArrayInputStream(wizard.getPageImage())));
  }
 catch (  IOException e1) {
    e1.printStackTrace();
  }
}","/** 
 * Opens the corresponding wizard to modify an existing account given by the <tt>protocolProvider</tt> parameter.
 * @param protocolProvider The <tt>ProtocolProviderService</tt> for theaccount to modify.
 */
public void modifyAccount(ProtocolProviderService protocolProvider){
  AccountRegistrationWizard wizard=registeredWizards.get(protocolProvider.getProtocolDisplayName());
  this.setCurrentWizard(wizard);
  wizard.setModification(true);
  wizard.loadAccount(protocolProvider);
}",0.638946638946639
104127,"/** 
 * Sets the currently used <tt>AccountRegistrationWizard</tt>.
 * @param wizard the <tt>AccountRegistrationWizard</tt> to set ascurrent one
 */
public void setCurrentWizard(AccountRegistrationWizard wizard){
  this.currentWizard=wizard;
  Dimension wizardSize=this.currentWizard.getSize();
  summaryPage.setPreferredSize(wizardSize);
  Iterator<WizardPage> i=wizard.getPages();
  while (i.hasNext()) {
    WizardPage page=i.next();
    this.registerWizardPage(page.getIdentifier(),page);
  }
  this.setCurrentPage(wizard.getFirstPageIdentifier());
  try {
    this.setWizzardIcon(ImageIO.read(new ByteArrayInputStream(wizard.getPageImage())));
  }
 catch (  IOException e1) {
    e1.printStackTrace();
  }
}","/** 
 * Sets the currently used <tt>AccountRegistrationWizard</tt>.
 * @param wizard the <tt>AccountRegistrationWizard</tt> to set ascurrent one
 */
public void setCurrentWizard(AccountRegistrationWizard wizard){
  this.currentWizard=wizard;
  summaryPage.setPreferredSize(this.currentWizard.getSize());
  Iterator<WizardPage> i=wizard.getPages();
  while (i.hasNext()) {
    WizardPage page=i.next();
    this.registerWizardPage(page.getIdentifier(),page);
  }
  this.setCurrentPage(wizard.getFirstPageIdentifier());
  try {
    this.setWizzardIcon(ImageIO.read(new ByteArrayInputStream(wizard.getPageImage())));
  }
 catch (  IOException e1) {
    e1.printStackTrace();
  }
}",0.9402447804175668
104128,"/** 
 * Initialized the service implementation, and puts it in a sate where it could interoperate with other services. It is strongly recommended that properties in this Map be mapped to property names as specified by <tt>AccountProperties</tt>.
 * @param screenname the account id/uin/screenname of the account thatwe're about to create
 * @param accountID the identifier of the account that this protocolprovider represents.
 * @see net.java.sip.communicator.service.protocol.AccountID
 */
protected void initialize(String screenname,AccountID accountID){
synchronized (initializationLock) {
    this.accountID=accountID;
    String protocolIconPath=accountID.getAccountPropertyString(ProtocolProviderFactory.PROTOCOL_ICON_PATH);
    if (protocolIconPath == null) {
      protocolIconPath=""String_Node_Str"";
    }
    jabberIcon=new ProtocolIconJabberImpl(protocolIconPath);
    jabberStatusEnum=JabberStatusEnum.getJabberStatusEnum(protocolIconPath);
    supportedFeatures.add(""String_Node_Str"");
    String keepAliveStrValue=accountID.getAccountPropertyString(""String_Node_Str"");
    String resourcePriority=accountID.getAccountPropertyString(ProtocolProviderFactory.RESOURCE_PRIORITY);
    OperationSetPersistentPresenceJabberImpl persistentPresence=new OperationSetPersistentPresenceJabberImpl(this);
    if (resourcePriority != null) {
      persistentPresence.setResourcePriority(Integer.parseInt(resourcePriority));
      supportedFeatures.add(""String_Node_Str"");
    }
    supportedOperationSets.put(OperationSetPersistentPresence.class.getName(),persistentPresence);
    supportedOperationSets.put(OperationSetPresence.class.getName(),persistentPresence);
    OperationSetBasicInstantMessagingJabberImpl basicInstantMessaging=new OperationSetBasicInstantMessagingJabberImpl(this);
    if (keepAliveStrValue != null)     basicInstantMessaging.setKeepAliveEnabled(Boolean.parseBoolean(keepAliveStrValue));
    supportedOperationSets.put(OperationSetBasicInstantMessaging.class.getName(),basicInstantMessaging);
    supportedFeatures.add(""String_Node_Str"");
    OperationSetWhiteboardingJabberImpl whiteboard=new OperationSetWhiteboardingJabberImpl(this);
    supportedOperationSets.put(OperationSetWhiteboarding.class.getName(),whiteboard);
    OperationSetTypingNotifications typingNotifications=new OperationSetTypingNotificationsJabberImpl(this);
    supportedOperationSets.put(OperationSetTypingNotifications.class.getName(),typingNotifications);
    supportedFeatures.add(""String_Node_Str"");
    OperationSetMultiUserChat multiUserChat=new OperationSetMultiUserChatJabberImpl(this);
    supportedOperationSets.put(OperationSetMultiUserChat.class.getName(),multiUserChat);
    InfoRetreiver infoRetreiver=new InfoRetreiver(this,screenname);
    OperationSetServerStoredContactInfo contactInfo=new OperationSetServerStoredContactInfoJabberImpl(infoRetreiver);
    supportedOperationSets.put(OperationSetServerStoredContactInfo.class.getName(),contactInfo);
    OperationSetServerStoredAccountInfo accountInfo=new OperationSetServerStoredAccountInfoJabberImpl(this,infoRetreiver,screenname);
    supportedOperationSets.put(OperationSetServerStoredAccountInfo.class.getName(),accountInfo);
    supportedFeatures.add(""String_Node_Str"");
    supportedFeatures.add(""String_Node_Str"");
    supportedFeatures.add(""String_Node_Str"");
    if (JabberActivator.getMediaService() != null) {
      OperationSetBasicTelephony opSetBasicTelephony=new OperationSetBasicTelephonyJabberImpl(this);
      supportedOperationSets.put(OperationSetBasicTelephony.class.getName(),opSetBasicTelephony);
      supportedFeatures.add(""String_Node_Str"");
      supportedFeatures.add(""String_Node_Str"");
    }
    isInitialized=true;
  }
}","/** 
 * Initialized the service implementation, and puts it in a sate where it could interoperate with other services. It is strongly recommended that properties in this Map be mapped to property names as specified by <tt>AccountProperties</tt>.
 * @param screenname the account id/uin/screenname of the account thatwe're about to create
 * @param accountID the identifier of the account that this protocolprovider represents.
 * @see net.java.sip.communicator.service.protocol.AccountID
 */
protected void initialize(String screenname,AccountID accountID){
synchronized (initializationLock) {
    this.accountID=accountID;
    String protocolIconPath=accountID.getAccountPropertyString(ProtocolProviderFactory.PROTOCOL_ICON_PATH);
    if (protocolIconPath == null) {
      protocolIconPath=""String_Node_Str"";
    }
    jabberIcon=new ProtocolIconJabberImpl(protocolIconPath);
    jabberStatusEnum=JabberStatusEnum.getJabberStatusEnum(protocolIconPath);
    supportedFeatures.add(""String_Node_Str"");
    String keepAliveStrValue=accountID.getAccountPropertyString(""String_Node_Str"");
    String resourcePriority=accountID.getAccountPropertyString(ProtocolProviderFactory.RESOURCE_PRIORITY);
    OperationSetPersistentPresenceJabberImpl persistentPresence=new OperationSetPersistentPresenceJabberImpl(this);
    if (resourcePriority != null) {
      persistentPresence.setResourcePriority(Integer.parseInt(resourcePriority));
      supportedFeatures.add(""String_Node_Str"");
    }
    supportedOperationSets.put(OperationSetPersistentPresence.class.getName(),persistentPresence);
    supportedOperationSets.put(OperationSetPresence.class.getName(),persistentPresence);
    OperationSetBasicInstantMessagingJabberImpl basicInstantMessaging=new OperationSetBasicInstantMessagingJabberImpl(this);
    if (keepAliveStrValue != null)     basicInstantMessaging.setKeepAliveEnabled(Boolean.parseBoolean(keepAliveStrValue));
    supportedOperationSets.put(OperationSetBasicInstantMessaging.class.getName(),basicInstantMessaging);
    supportedFeatures.add(""String_Node_Str"");
    OperationSetWhiteboardingJabberImpl whiteboard=new OperationSetWhiteboardingJabberImpl(this);
    supportedOperationSets.put(OperationSetWhiteboarding.class.getName(),whiteboard);
    OperationSetTypingNotifications typingNotifications=new OperationSetTypingNotificationsJabberImpl(this);
    supportedOperationSets.put(OperationSetTypingNotifications.class.getName(),typingNotifications);
    supportedFeatures.add(""String_Node_Str"");
    OperationSetMultiUserChat multiUserChat=new OperationSetMultiUserChatJabberImpl(this);
    supportedOperationSets.put(OperationSetMultiUserChat.class.getName(),multiUserChat);
    InfoRetreiver infoRetreiver=new InfoRetreiver(this,screenname);
    OperationSetServerStoredContactInfo contactInfo=new OperationSetServerStoredContactInfoJabberImpl(infoRetreiver);
    supportedOperationSets.put(OperationSetServerStoredContactInfo.class.getName(),contactInfo);
    OperationSetServerStoredAccountInfo accountInfo=new OperationSetServerStoredAccountInfoJabberImpl(this,infoRetreiver,screenname);
    supportedOperationSets.put(OperationSetServerStoredAccountInfo.class.getName(),accountInfo);
    supportedFeatures.add(""String_Node_Str"");
    supportedFeatures.add(""String_Node_Str"");
    supportedFeatures.add(""String_Node_Str"");
    String enableJingle=(String)JabberActivator.getConfigurationService().getProperty(PNAME_ENABLE_JINGLE);
    if (Boolean.getBoolean(enableJingle) && JabberActivator.getMediaService() != null) {
      OperationSetBasicTelephony opSetBasicTelephony=new OperationSetBasicTelephonyJabberImpl(this);
      supportedOperationSets.put(OperationSetBasicTelephony.class.getName(),opSetBasicTelephony);
      supportedFeatures.add(""String_Node_Str"");
      supportedFeatures.add(""String_Node_Str"");
    }
    isInitialized=true;
  }
}",0.980226733456367
104129,"/** 
 * Returns an InetAddress instance that represents the localhost, and that a socket can bind upon or distribute to peers as a contact address.
 * @param intendedDestination the destination that we'd like to use thelocalhost address with.
 * @return an InetAddress instance representing the local host, and thata socket can bind upon or distribute to peers as a contact address.
 */
public synchronized InetAddress getLocalHost(InetAddress intendedDestination){
  if (logger.isTraceEnabled()) {
    logger.trace(""String_Node_Str"" + intendedDestination);
  }
  InetAddress localHost=null;
  localHostFinderSocket.connect(intendedDestination,RANDOM_ADDR_DISC_PORT);
  localHost=localHostFinderSocket.getLocalAddress();
  localHostFinderSocket.disconnect();
  if (localHost.isAnyLocalAddress()) {
    logger.trace(""String_Node_Str"" + ""String_Node_Str"");
    try {
      if (intendedDestination instanceof Inet6Address) {
        Enumeration<NetworkInterface> interfaces=NetworkInterface.getNetworkInterfaces();
        while (interfaces.hasMoreElements()) {
          NetworkInterface iface=interfaces.nextElement();
          Enumeration<InetAddress> addresses=iface.getInetAddresses();
          while (addresses.hasMoreElements()) {
            InetAddress address=addresses.nextElement();
            if (address instanceof Inet6Address) {
              if (!address.isAnyLocalAddress() && !address.isLinkLocalAddress() && !address.isSiteLocalAddress()&& !address.isLoopbackAddress()) {
                if (logger.isTraceEnabled()) {
                  logger.trace(""String_Node_Str"" + address);
                }
                return address;
              }
            }
          }
        }
      }
 else       localHost=InetAddress.getLocalHost();
    }
 catch (    Exception ex) {
      logger.warn(""String_Node_Str"",ex);
    }
  }
  if (logger.isTraceEnabled()) {
    logger.trace(""String_Node_Str"" + localHost);
  }
  return localHost;
}","/** 
 * Returns an InetAddress instance that represents the localhost, and that a socket can bind upon or distribute to peers as a contact address.
 * @param intendedDestination the destination that we'd like to use thelocalhost address with.
 * @return an InetAddress instance representing the local host, and thata socket can bind upon or distribute to peers as a contact address.
 */
public synchronized InetAddress getLocalHost(InetAddress intendedDestination){
  if (logger.isTraceEnabled()) {
    logger.trace(""String_Node_Str"" + intendedDestination);
  }
  InetAddress localHost=null;
  localHostFinderSocket.connect(intendedDestination,RANDOM_ADDR_DISC_PORT);
  localHost=localHostFinderSocket.getLocalAddress();
  localHostFinderSocket.disconnect();
  if (localHost.isAnyLocalAddress()) {
    logger.trace(""String_Node_Str"" + ""String_Node_Str"");
    try {
      if (intendedDestination instanceof Inet6Address) {
        Enumeration<NetworkInterface> interfaces=NetworkInterface.getNetworkInterfaces();
        while (interfaces.hasMoreElements()) {
          NetworkInterface iface=interfaces.nextElement();
          Enumeration<InetAddress> addresses=iface.getInetAddresses();
          while (addresses.hasMoreElements()) {
            InetAddress address=addresses.nextElement();
            if (address instanceof Inet6Address) {
              if (!address.isAnyLocalAddress() && !address.isLinkLocalAddress() && !address.isSiteLocalAddress()&& !address.isLoopbackAddress()) {
                if (logger.isTraceEnabled()) {
                  logger.trace(""String_Node_Str"" + address);
                }
                return address;
              }
            }
          }
        }
      }
 else {
        localHost=InetAddress.getLocalHost();
        if (!(localHost instanceof Inet4Address)) {
          Enumeration<NetworkInterface> interfaces=NetworkInterface.getNetworkInterfaces();
          while (interfaces.hasMoreElements()) {
            NetworkInterface iface=interfaces.nextElement();
            Enumeration<InetAddress> addresses=iface.getInetAddresses();
            while (addresses.hasMoreElements()) {
              InetAddress address=addresses.nextElement();
              if (address instanceof Inet4Address) {
                if (!address.isLoopbackAddress()) {
                  if (logger.isTraceEnabled()) {
                    logger.trace(""String_Node_Str"" + address);
                  }
                  return address;
                }
              }
            }
          }
        }
      }
    }
 catch (    Exception ex) {
      logger.warn(""String_Node_Str"",ex);
    }
  }
  if (logger.isTraceEnabled()) {
    logger.trace(""String_Node_Str"" + localHost);
  }
  return localHost;
}",0.831877264010228
104130,"/** 
 * Handles the <tt>ActionEvent</tt> when one of the menu items is selected.
 */
public void actionPerformed(ActionEvent e){
  JMenuItem menuItem=(JMenuItem)e.getSource();
  String itemText=menuItem.getName();
  if (itemText.equalsIgnoreCase(""String_Node_Str"")) {
    ChatRoomListDialog chatRoomsDialog=new ChatRoomListDialog(GuiActivator.getUIService().getMainFrame());
    chatRoomsDialog.setPreferredSize(new Dimension(500,400));
    chatRoomsDialog.setVisible(true);
  }
 else   if (itemText.equalsIgnoreCase(""String_Node_Str"")) {
    this.parentWindow.setVisible(false);
    this.parentWindow.dispose();
  }
}","/** 
 * Handles the <tt>ActionEvent</tt> when one of the menu items is selected.
 */
public void actionPerformed(ActionEvent e){
  JMenuItem menuItem=(JMenuItem)e.getSource();
  String itemText=menuItem.getName();
  if (itemText.equalsIgnoreCase(""String_Node_Str"")) {
    ChatRoomListDialog.showChatRoomListDialog();
  }
 else   if (itemText.equalsIgnoreCase(""String_Node_Str"")) {
    this.parentWindow.setVisible(false);
    this.parentWindow.dispose();
  }
}",0.8330241187384044
104131,"/** 
 * Handles the <tt>ActionEvent</tt> when one of the menu items is selected.
 */
public void actionPerformed(ActionEvent e){
  JMenuItem menuItem=(JMenuItem)e.getSource();
  String itemName=menuItem.getName();
  if (itemName.equals(""String_Node_Str"")) {
    NewAccountDialog.showNewAccountDialog();
  }
 else   if (itemName.equals(""String_Node_Str"")) {
    AddContactWizard wizard=new AddContactWizard(parentWindow);
    wizard.showDialog(false);
  }
 else   if (itemName.equals(""String_Node_Str"")) {
    CreateGroupDialog dialog=new CreateGroupDialog(parentWindow);
    dialog.setVisible(true);
  }
 else   if (itemName.equals(""String_Node_Str"")) {
    closeActionPerformed();
  }
 else   if (itemName.equals(""String_Node_Str"")) {
    ChatRoomListDialog chatRoomsDialog=new ChatRoomListDialog(parentWindow);
    chatRoomsDialog.setPreferredSize(new Dimension(500,400));
    chatRoomsDialog.setVisible(true);
  }
}","/** 
 * Handles the <tt>ActionEvent</tt> when one of the menu items is selected.
 */
public void actionPerformed(ActionEvent e){
  JMenuItem menuItem=(JMenuItem)e.getSource();
  String itemName=menuItem.getName();
  if (itemName.equals(""String_Node_Str"")) {
    NewAccountDialog.showNewAccountDialog();
  }
 else   if (itemName.equals(""String_Node_Str"")) {
    AddContactWizard wizard=new AddContactWizard(parentWindow);
    wizard.showDialog(false);
  }
 else   if (itemName.equals(""String_Node_Str"")) {
    CreateGroupDialog dialog=new CreateGroupDialog(parentWindow);
    dialog.setVisible(true);
  }
 else   if (itemName.equals(""String_Node_Str"")) {
    closeActionPerformed();
  }
 else   if (itemName.equals(""String_Node_Str"")) {
    ChatRoomListDialog.showChatRoomListDialog();
  }
}",0.9203747072599532
104132,"/** 
 * Creates an SCAudioClip from the given URI and adds it to the list of available audio-s.
 * @param uri the path where the audio file could be found
 */
public SCAudioClip createAudio(String uri){
  SCAudioClipImpl audioClip;
synchronized (audioClips) {
    if (audioClips.containsKey(uri)) {
      audioClip=audioClips.get(uri);
    }
 else {
      URL url=AudioNotifierActivator.getResources().getSoundURLForPath(uri);
      if (url == null) {
        try {
          url=new URL(uri);
        }
 catch (        MalformedURLException e) {
        }
      }
      audioClip=new SCAudioClipImpl(url,this);
      audioClips.put(uri,audioClip);
    }
  }
  return audioClip;
}","/** 
 * Creates an SCAudioClip from the given URI and adds it to the list of available audio-s.
 * @param uri the path where the audio file could be found
 */
public SCAudioClip createAudio(String uri){
  SCAudioClipImpl audioClip;
synchronized (audioClips) {
    if (audioClips.containsKey(uri)) {
      audioClip=audioClips.get(uri);
    }
 else {
      URL url=AudioNotifierActivator.getResources().getSoundURLForPath(uri);
      if (url == null) {
        try {
          url=new URL(uri);
        }
 catch (        MalformedURLException e) {
          return null;
        }
      }
      try {
        audioClip=new SCAudioClipImpl(url,this);
        if (audioClip == null)         return null;
      }
 catch (      Throwable e) {
        return null;
      }
      audioClips.put(uri,audioClip);
    }
  }
  return audioClip;
}",0.8976897689768977
104133,"/** 
 * Creates the audio clip and initialize the listener used from the loop timer.
 * @param url the url pointing to the audio file
 */
public SCAudioClipImpl(URL url,AudioNotifierService audioNotifier){
  InputStream inputstream;
  try {
    inputstream=url.openStream();
    this.createAppletAudioClip(inputstream);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  this.audioListener=new PlayAudioListener(audioClip);
  this.playAudioTimer.addActionListener(audioListener);
  this.audioNotifier=audioNotifier;
}","/** 
 * Creates the audio clip and initialize the listener used from the loop timer.
 * @param url the url pointing to the audio file
 */
public SCAudioClipImpl(URL url,AudioNotifierService audioNotifier) throws IOException {
  InputStream inputstream;
  inputstream=url.openStream();
  this.createAppletAudioClip(inputstream);
  this.audioListener=new PlayAudioListener(audioClip);
  this.playAudioTimer.addActionListener(audioListener);
  this.audioNotifier=audioNotifier;
}",0.4601593625498008
104134,"/** 
 * Creates a vector containing SDP descriptions of media types and formats that we support. If the offerVector is non null
 * @param offerMediaDescs the media descriptions sent by the offerer (couldbe null).
 * @param publicAudioAddress the <tt>InetSocketAddress</tt> that we shouldbe using for sending audio.
 * @param publicVideoAddress the <tt>InetSocketAddress</tt> that we shouldbe using for sending video.
 * @return a <tt>Vector</tt> containing media descriptions that we supportand (if this is an answer to an offer) that the offering <tt>CallParticipant</tt> supports as well.
 * @throws SdpException we fail creating the media descriptions
 * @throws MediaException with code UNSUPPORTED_FORMAT_SET_ERROR if we don'tsupport any of the offered media formats.
 */
private Vector<MediaDescription> createMediaDescriptions(Vector<MediaDescription> offerMediaDescs,InetSocketAddress publicAudioAddress,InetSocketAddress publicVideoAddress) throws SdpException, MediaException {
  MediaControl mediaControl=mediaServCallback.getMediaControl(getCall());
  String[] supportedAudioEncodings=mediaControl.getSupportedAudioEncodings();
  String[] supportedVideoEncodings=mediaControl.getSupportedVideoEncodings();
  if (offerMediaDescs != null && offerMediaDescs.size() > 0) {
    Vector<String> offeredVideoEncodings=new Vector<String>();
    Vector<String> offeredAudioEncodings=new Vector<String>();
    for (    MediaDescription desc : offerMediaDescs) {
      Media media=desc.getMedia();
      String mediaType=media.getMediaType();
      if (mediaType.equalsIgnoreCase(""String_Node_Str"")) {
        offeredVideoEncodings=media.getMediaFormats(true);
      }
 else       if (mediaType.equalsIgnoreCase(""String_Node_Str"")) {
        offeredAudioEncodings=media.getMediaFormats(true);
      }
    }
    Hashtable<String,List<String>> encodings=new Hashtable<String,List<String>>(2);
    encodings.put(""String_Node_Str"",offeredAudioEncodings);
    encodings.put(""String_Node_Str"",offeredVideoEncodings);
    encodings=intersectMediaEncodings(encodings);
    List<String> intersectedAudioEncsList=encodings.get(""String_Node_Str"");
    List<String> intersectedVideoEncsList=encodings.get(""String_Node_Str"");
    supportedAudioEncodings=intersectedAudioEncsList.toArray(new String[0]);
    supportedVideoEncodings=intersectedVideoEncsList.toArray(new String[0]);
  }
  Vector<MediaDescription> mediaDescs=new Vector<MediaDescription>();
  if (supportedAudioEncodings.length > 0) {
    MediaDescription am=mediaServCallback.getSdpFactory().createMediaDescription(""String_Node_Str"",publicAudioAddress.getPort(),1,""String_Node_Str"",supportedAudioEncodings);
    String g723Str=String.valueOf(SdpConstants.G723);
    for (    String supportedAudioEncoding : supportedAudioEncodings) {
      if (supportedAudioEncoding.equals(g723Str)) {
        am.setAttribute(""String_Node_Str"",""String_Node_Str"");
        am.setAttribute(""String_Node_Str"",""String_Node_Str"");
      }
    }
    byte onHold=this.onHold;
    if (!mediaServCallback.getDeviceConfiguration().isAudioCaptureSupported()) {
      onHold|=ON_HOLD_REMOTELY;
    }
    setAttributeOnHold(am,onHold);
    TransformConnector transConnector=this.transConnectors.get(audioRtpManager);
    if (transConnector != null) {
      TransformEngine engine=transConnector.getEngine();
      if (engine instanceof ZRTPTransformEngine) {
        ZRTPTransformEngine ze=(ZRTPTransformEngine)engine;
        String helloHash=ze.getHelloHash();
        if (helloHash != null && helloHash.length() > 0)         am.setAttribute(""String_Node_Str"",ze.getHelloHash());
      }
    }
    mediaDescs.add(am);
  }
  if (supportedVideoEncodings.length > 0) {
    MediaDescription vm=mediaServCallback.getSdpFactory().createMediaDescription(""String_Node_Str"",publicVideoAddress.getPort(),1,""String_Node_Str"",supportedVideoEncodings);
    String h264Str=String.valueOf(Constants.H264_RTP_SDP);
    for (    String supportedVideoEncoding : supportedVideoEncodings) {
      if (supportedVideoEncoding.equals(h264Str)) {
        vm.setAttribute(""String_Node_Str"",Constants.H264_RTP_SDP + ""String_Node_Str"");
        vm.setAttribute(""String_Node_Str"",Constants.H264_RTP_SDP + ""String_Node_Str"");
      }
    }
    byte onHold=this.onHold;
    if (!mediaServCallback.getDeviceConfiguration().isVideoCaptureSupported() || !mediaControl.isLocalVideoAllowed()) {
      onHold|=ON_HOLD_REMOTELY;
    }
    setAttributeOnHold(vm,onHold);
    TransformConnector transConnector=this.transConnectors.get(videoRtpManager);
    if (transConnector != null) {
      TransformEngine engine=transConnector.getEngine();
      if (engine instanceof ZRTPTransformEngine) {
        ZRTPTransformEngine ze=(ZRTPTransformEngine)engine;
        String helloHash=ze.getHelloHash();
        if (helloHash != null && helloHash.length() > 0)         vm.setAttribute(""String_Node_Str"",ze.getHelloHash());
      }
    }
    mediaDescs.add(vm);
  }
  return mediaDescs;
}","/** 
 * Creates a vector containing SDP descriptions of media types and formats that we support. If the offerVector is non null
 * @param offerMediaDescs the media descriptions sent by the offerer (couldbe null).
 * @param publicAudioAddress the <tt>InetSocketAddress</tt> that we shouldbe using for sending audio.
 * @param publicVideoAddress the <tt>InetSocketAddress</tt> that we shouldbe using for sending video.
 * @return a <tt>Vector</tt> containing media descriptions that we supportand (if this is an answer to an offer) that the offering <tt>CallParticipant</tt> supports as well.
 * @throws SdpException we fail creating the media descriptions
 * @throws MediaException with code UNSUPPORTED_FORMAT_SET_ERROR if we don'tsupport any of the offered media formats.
 */
private Vector<MediaDescription> createMediaDescriptions(Vector<MediaDescription> offerMediaDescs,InetSocketAddress publicAudioAddress,InetSocketAddress publicVideoAddress) throws SdpException, MediaException {
  MediaControl mediaControl=mediaServCallback.getMediaControl(getCall());
  String[] supportedAudioEncodings=mediaControl.getSupportedAudioEncodings();
  String[] supportedVideoEncodings=mediaControl.getSupportedVideoEncodings();
  if (offerMediaDescs != null && offerMediaDescs.size() > 0) {
    Vector<String> offeredVideoEncodings=new Vector<String>();
    Vector<String> offeredAudioEncodings=new Vector<String>();
    for (    MediaDescription desc : offerMediaDescs) {
      Media media=desc.getMedia();
      String mediaType=media.getMediaType();
      if (mediaType.equalsIgnoreCase(""String_Node_Str"")) {
        offeredVideoEncodings=media.getMediaFormats(true);
      }
 else       if (mediaType.equalsIgnoreCase(""String_Node_Str"")) {
        offeredAudioEncodings=media.getMediaFormats(true);
      }
    }
    Hashtable<String,List<String>> encodings=new Hashtable<String,List<String>>(2);
    encodings.put(""String_Node_Str"",offeredAudioEncodings);
    encodings.put(""String_Node_Str"",offeredVideoEncodings);
    encodings=intersectMediaEncodings(encodings);
    List<String> intersectedAudioEncsList=encodings.get(""String_Node_Str"");
    List<String> intersectedVideoEncsList=encodings.get(""String_Node_Str"");
    supportedAudioEncodings=intersectedAudioEncsList.toArray(new String[0]);
    supportedVideoEncodings=intersectedVideoEncsList.toArray(new String[0]);
  }
  Vector<MediaDescription> mediaDescs=new Vector<MediaDescription>();
  if (supportedAudioEncodings.length > 0) {
    MediaDescription am=mediaServCallback.getSdpFactory().createMediaDescription(""String_Node_Str"",publicAudioAddress.getPort(),1,""String_Node_Str"",supportedAudioEncodings);
    String g723Str=String.valueOf(SdpConstants.G723);
    for (    String supportedAudioEncoding : supportedAudioEncodings) {
      if (supportedAudioEncoding.equals(g723Str)) {
        am.setAttribute(""String_Node_Str"",""String_Node_Str"");
        am.setAttribute(""String_Node_Str"",""String_Node_Str"");
      }
    }
    byte onHold=this.onHold;
    if (mediaServCallback.getDeviceConfiguration().isAudioCaptureSupported()) {
      setAttributeOnHold(am,onHold);
      TransformConnector transConnector=this.transConnectors.get(audioRtpManager);
      if (transConnector != null) {
        TransformEngine engine=transConnector.getEngine();
        if (engine instanceof ZRTPTransformEngine) {
          ZRTPTransformEngine ze=(ZRTPTransformEngine)engine;
          String helloHash=ze.getHelloHash();
          if (helloHash != null && helloHash.length() > 0)           am.setAttribute(""String_Node_Str"",ze.getHelloHash());
        }
      }
      mediaDescs.add(am);
    }
  }
  if (supportedVideoEncodings.length > 0) {
    MediaDescription vm=mediaServCallback.getSdpFactory().createMediaDescription(""String_Node_Str"",publicVideoAddress.getPort(),1,""String_Node_Str"",supportedVideoEncodings);
    String h264Str=String.valueOf(Constants.H264_RTP_SDP);
    for (    String supportedVideoEncoding : supportedVideoEncodings) {
      if (supportedVideoEncoding.equals(h264Str)) {
        vm.setAttribute(""String_Node_Str"",Constants.H264_RTP_SDP + ""String_Node_Str"");
        vm.setAttribute(""String_Node_Str"",Constants.H264_RTP_SDP + ""String_Node_Str"");
      }
    }
    byte onHold=this.onHold;
    if (!mediaServCallback.getDeviceConfiguration().isVideoCaptureSupported() || !mediaControl.isLocalVideoAllowed()) {
      onHold|=ON_HOLD_REMOTELY;
    }
    setAttributeOnHold(vm,onHold);
    TransformConnector transConnector=this.transConnectors.get(videoRtpManager);
    if (transConnector != null) {
      TransformEngine engine=transConnector.getEngine();
      if (engine instanceof ZRTPTransformEngine) {
        ZRTPTransformEngine ze=(ZRTPTransformEngine)engine;
        String helloHash=ze.getHelloHash();
        if (helloHash != null && helloHash.length() > 0)         vm.setAttribute(""String_Node_Str"",ze.getHelloHash());
      }
    }
    mediaDescs.add(vm);
  }
  return mediaDescs;
}",0.7357178841309824
104135,"/** 
 * Plays the sound given by the containing <tt>soundFileDescriptor</tt>. The sound is played in loop if the loopInterval is defined.
 */
public void start(){
  AudioNotifierService audioNotifService=NotificationActivator.getAudioNotifier();
  if (audioNotifService == null)   return;
  audio=audioNotifService.createAudio(soundFileDescriptor);
  if (loopInterval > -1)   audio.playInLoop(loopInterval);
 else   audio.play();
}","/** 
 * Plays the sound given by the containing <tt>soundFileDescriptor</tt>. The sound is played in loop if the loopInterval is defined.
 */
public void start(){
  AudioNotifierService audioNotifService=NotificationActivator.getAudioNotifier();
  if (audioNotifService == null)   return;
  audio=audioNotifService.createAudio(soundFileDescriptor);
  if (audio == null)   return;
  if (loopInterval > -1)   audio.playInLoop(loopInterval);
 else   audio.play();
}",0.9652855543113102
104136,"/** 
 * Called when we're connected to the IRC server.
 */
protected void onConnect(){
  RegistrationState oldState=parentProvider.getCurrentRegistrationState();
  parentProvider.setCurrentRegistrationState(RegistrationState.REGISTERED);
  parentProvider.fireRegistrationStateChanged(oldState,RegistrationState.REGISTERED,RegistrationStateChangeEvent.REASON_USER_REQUEST,null);
}","/** 
 * Called when we're connected to the IRC server.
 */
protected void onConnect(){
synchronized (this) {
    onConnectInvoked=true;
  }
}",0.3807692307692307
104137,"/** 
 * Connects to the server.
 * @param serverAddress the address of the server
 * @param serverPort the port to connect to
 * @param serverPassword the password to use for connect
 * @param autoNickChange indicates if the nick name should be changed in case there exist already a participant with the same nick name
 * @throws OperationFailedException
 */
public void connect(String serverAddress,int serverPort,String serverPassword,boolean autoNickChange) throws OperationFailedException {
  this.setVerbose(false);
  this.setAutoNickChange(autoNickChange);
  try {
    if (serverPassword == null) {
      this.connect(serverAddress,serverPort);
    }
 else     this.connect(serverAddress,serverPort,serverPassword);
  }
 catch (  IOException e) {
    throw new OperationFailedException(e.getMessage(),OperationFailedException.INTERNAL_SERVER_ERROR);
  }
catch (  NickAlreadyInUseException e) {
    throw new OperationFailedException(e.getMessage(),OperationFailedException.SUBSCRIPTION_ALREADY_EXISTS);
  }
catch (  IrcException e) {
    throw new OperationFailedException(e.getMessage(),OperationFailedException.GENERAL_ERROR);
  }
}","/** 
 * Connects to the server.
 * @param serverAddress the address of the server
 * @param serverPort the port to connect to
 * @param serverPassword the password to use for connect
 * @param autoNickChange indicates if the nick name should be changed in case there exist already a participant with the same nick name
 * @throws OperationFailedException
 */
public void connect(String serverAddress,int serverPort,String serverPassword,boolean autoNickChange) throws OperationFailedException {
  this.setVerbose(false);
  this.setAutoNickChange(autoNickChange);
  try {
synchronized (this) {
      onConnectInvoked=false;
      if (serverPassword == null) {
        this.connect(serverAddress,serverPort);
      }
 else       this.connect(serverAddress,serverPort,serverPassword);
    }
  }
 catch (  IOException e) {
    throw new OperationFailedException(e.getMessage(),OperationFailedException.INTERNAL_SERVER_ERROR);
  }
catch (  NickAlreadyInUseException e) {
    throw new OperationFailedException(e.getMessage(),OperationFailedException.SUBSCRIPTION_ALREADY_EXISTS);
  }
catch (  IrcException e) {
    throw new OperationFailedException(e.getMessage(),OperationFailedException.GENERAL_ERROR);
  }
  if (onConnectInvoked) {
    RegistrationState oldState=parentProvider.getCurrentRegistrationState();
    parentProvider.setCurrentRegistrationState(RegistrationState.REGISTERED);
    parentProvider.fireRegistrationStateChanged(oldState,RegistrationState.REGISTERED,RegistrationStateChangeEvent.REASON_USER_REQUEST,null);
  }
}",0.8529741863075196
104138,"/** 
 * Returns a set of all protocol providers.
 * @return a set of all protocol providers.
 */
public Iterator<ProtocolProviderService> getProtocolProviders(){
  return ((Map<ProtocolProviderService,Integer>)protocolProviders.clone()).keySet().iterator();
}","/** 
 * Returns a set of all protocol providers.
 * @return a set of all protocol providers.
 */
public Iterator<ProtocolProviderService> getProtocolProviders(){
  return new LinkedList<ProtocolProviderService>(protocolProviders.keySet()).iterator();
}",0.8571428571428571
104139,"/** 
 * Initializes the menu, by adding all containing menu items.
 */
private void init(){
  this.moveToMenu.setIcon(new ImageIcon(ImageLoader.getImage(ImageLoader.GROUPS_16x16_ICON)));
  this.addSubcontactMenu.setIcon(new ImageIcon(ImageLoader.getImage(ImageLoader.ADD_CONTACT_16x16_ICON)));
  this.removeContactMenu.setIcon(new ImageIcon(ImageLoader.getImage(ImageLoader.DELETE_16x16_ICON)));
  this.moveSubcontactMenu.setIcon(new ImageIcon(ImageLoader.getImage(ImageLoader.MOVE_CONTACT_ICON)));
  this.callContactMenu.setIcon(new ImageIcon(ImageLoader.getImage(ImageLoader.CALL_16x16_ICON)));
  Iterator providers=mainFrame.getProtocolProviders();
  if (providers.hasNext()) {
    JLabel infoLabel=new JLabel(GuiActivator.getResources().getI18NString(""String_Node_Str""));
    infoLabel.setBorder(BorderFactory.createEmptyBorder(0,5,0,0));
    infoLabel.setFont(infoLabel.getFont().deriveFont(Font.BOLD));
    this.addSubcontactMenu.add(infoLabel);
    this.addSubcontactMenu.addSeparator();
  }
  while (providers.hasNext()) {
    ProtocolProviderService pps=(ProtocolProviderService)providers.next();
    String protocolName=pps.getProtocolName();
    JMenuItem menuItem=new JMenuItem(pps.getAccountID().getDisplayName(),new ImageIcon(ImageLoader.getAccountStatusImage(pps)));
    menuItem.setName(addSubcontactPrefix + protocolName);
    menuItem.addActionListener(this);
    this.addSubcontactMenu.add(menuItem);
  }
  Iterator<MetaContactGroup> groups=this.mainFrame.getAllGroups();
  if (groups.hasNext()) {
    JLabel infoLabel=new JLabel(GuiActivator.getResources().getI18NString(""String_Node_Str""));
    infoLabel.setBorder(BorderFactory.createEmptyBorder(0,5,0,0));
    infoLabel.setFont(infoLabel.getFont().deriveFont(Font.BOLD));
    this.moveToMenu.add(infoLabel);
    this.moveToMenu.addSeparator();
  }
  while (groups.hasNext()) {
    MetaContactGroup group=groups.next();
    JMenuItem menuItem=new JMenuItem(group.getGroupName());
    menuItem.setName(moveToPrefix + group.getMetaUID());
    menuItem.addActionListener(this);
    this.moveToMenu.add(menuItem);
  }
  Iterator<Contact> contacts=contactItem.getContacts();
  if (contactItem.getContactCount() > 1) {
    JMenuItem allItem=new JMenuItem(allContactsString);
    JMenuItem allItem1=new JMenuItem(allContactsString);
    allItem.addActionListener(this);
    allItem1.addActionListener(this);
    allItem.setName(removeContactPrefix + ""String_Node_Str"");
    allItem1.setName(moveSubcontactPrefix + ""String_Node_Str"");
    this.removeContactMenu.add(allItem);
    this.moveSubcontactMenu.add(allItem1);
    this.removeContactMenu.addSeparator();
    this.moveSubcontactMenu.addSeparator();
  }
  while (contacts.hasNext()) {
    Contact contact=contacts.next();
    ProtocolProviderService protocolProvider=contact.getProtocolProvider();
    String contactDisplayName=contact.getDisplayName();
    JMenuItem contactItem=new JMenuItem(contactDisplayName);
    JMenuItem contactItem1=new JMenuItem(contactDisplayName);
    Icon protocolIcon=new ImageIcon(createContactStatusImage(contact));
    contactItem.setIcon(protocolIcon);
    contactItem1.setIcon(protocolIcon);
    contactItem.setName(removeContactPrefix + contact.getAddress() + protocolProvider.getProtocolName());
    contactItem1.setName(moveSubcontactPrefix + contact.getAddress() + protocolProvider.getProtocolName());
    contactItem.addActionListener(this);
    contactItem1.addActionListener(this);
    this.removeContactMenu.add(contactItem);
    this.moveSubcontactMenu.add(contactItem1);
    if (contact.getProtocolProvider().getOperationSet(OperationSetBasicTelephony.class) != null) {
      JMenuItem callContactItem=new JMenuItem(contactDisplayName);
      callContactItem.setIcon(protocolIcon);
      callContactItem.setName(callContactPrefix + contact.getAddress() + protocolProvider.getProtocolName());
      callContactItem.addActionListener(this);
      this.callContactMenu.add(callContactItem);
    }
    protocolProvider.getOperationSet(OperationSetWebContactInfo.class);
  }
  this.add(sendMessageItem);
  this.add(sendSmsItem);
  if (callContactMenu.getItemCount() > 1) {
    this.add(callContactMenu);
  }
 else {
    this.add(callItem);
  }
  this.add(sendFileItem);
  this.addSeparator();
  this.add(moveToMenu);
  this.add(moveSubcontactMenu);
  this.addSeparator();
  this.add(addSubcontactMenu);
  this.addSeparator();
  this.add(removeContactMenu);
  this.add(renameContactItem);
  this.addSeparator();
  this.add(viewHistoryItem);
  this.initPluginComponents();
  this.sendMessageItem.setName(""String_Node_Str"");
  this.callItem.setName(""String_Node_Str"");
  this.sendSmsItem.setName(""String_Node_Str"");
  this.sendFileItem.setName(""String_Node_Str"");
  this.moveToMenu.setName(""String_Node_Str"");
  this.addSubcontactMenu.setName(""String_Node_Str"");
  this.renameContactItem.setName(""String_Node_Str"");
  this.viewHistoryItem.setName(""String_Node_Str"");
  this.sendMessageItem.addActionListener(this);
  this.callItem.addActionListener(this);
  this.sendSmsItem.addActionListener(this);
  this.sendFileItem.addActionListener(this);
  this.renameContactItem.addActionListener(this);
  this.viewHistoryItem.addActionListener(this);
  if (contactItem.getDefaultContact(OperationSetFileTransfer.class) == null)   this.sendFileItem.setEnabled(false);
  if (contactItem.getDefaultContact(OperationSetBasicTelephony.class) == null)   this.callItem.setEnabled(false);
  if (contactItem.getDefaultContact(OperationSetBasicInstantMessaging.class) == null)   this.sendMessageItem.setEnabled(false);
  if (contactItem.getDefaultContact(OperationSetSmsMessaging.class) == null)   this.sendSmsItem.setEnabled(false);
}","/** 
 * Initializes the menu, by adding all containing menu items.
 */
private void init(){
  this.moveToMenu.setIcon(new ImageIcon(ImageLoader.getImage(ImageLoader.GROUPS_16x16_ICON)));
  this.addSubcontactMenu.setIcon(new ImageIcon(ImageLoader.getImage(ImageLoader.ADD_CONTACT_16x16_ICON)));
  this.removeContactMenu.setIcon(new ImageIcon(ImageLoader.getImage(ImageLoader.DELETE_16x16_ICON)));
  this.moveSubcontactMenu.setIcon(new ImageIcon(ImageLoader.getImage(ImageLoader.MOVE_CONTACT_ICON)));
  this.callContactMenu.setIcon(new ImageIcon(ImageLoader.getImage(ImageLoader.CALL_16x16_ICON)));
  Iterator<ProtocolProviderService> providers=mainFrame.getProtocolProviders();
  if (providers.hasNext()) {
    JLabel infoLabel=new JLabel(GuiActivator.getResources().getI18NString(""String_Node_Str""));
    infoLabel.setBorder(BorderFactory.createEmptyBorder(0,5,0,0));
    infoLabel.setFont(infoLabel.getFont().deriveFont(Font.BOLD));
    this.addSubcontactMenu.add(infoLabel);
    this.addSubcontactMenu.addSeparator();
  }
  while (providers.hasNext()) {
    ProtocolProviderService pps=(ProtocolProviderService)providers.next();
    String protocolName=pps.getProtocolName();
    ProviderAwareMenuItem menuItem=new ProviderAwareMenuItem(pps,pps.getAccountID().getDisplayName(),new ImageIcon(ImageLoader.getAccountStatusImage(pps)));
    menuItem.setName(addSubcontactPrefix + protocolName);
    menuItem.addActionListener(this);
    this.addSubcontactMenu.add(menuItem);
  }
  Iterator<MetaContactGroup> groups=this.mainFrame.getAllGroups();
  if (groups.hasNext()) {
    JLabel infoLabel=new JLabel(GuiActivator.getResources().getI18NString(""String_Node_Str""));
    infoLabel.setBorder(BorderFactory.createEmptyBorder(0,5,0,0));
    infoLabel.setFont(infoLabel.getFont().deriveFont(Font.BOLD));
    this.moveToMenu.add(infoLabel);
    this.moveToMenu.addSeparator();
  }
  while (groups.hasNext()) {
    MetaContactGroup group=groups.next();
    JMenuItem menuItem=new JMenuItem(group.getGroupName());
    menuItem.setName(moveToPrefix + group.getMetaUID());
    menuItem.addActionListener(this);
    this.moveToMenu.add(menuItem);
  }
  Iterator<Contact> contacts=contactItem.getContacts();
  if (contactItem.getContactCount() > 1) {
    JMenuItem allItem=new JMenuItem(allContactsString);
    JMenuItem allItem1=new JMenuItem(allContactsString);
    allItem.addActionListener(this);
    allItem1.addActionListener(this);
    allItem.setName(removeContactPrefix + ""String_Node_Str"");
    allItem1.setName(moveSubcontactPrefix + ""String_Node_Str"");
    this.removeContactMenu.add(allItem);
    this.moveSubcontactMenu.add(allItem1);
    this.removeContactMenu.addSeparator();
    this.moveSubcontactMenu.addSeparator();
  }
  while (contacts.hasNext()) {
    Contact contact=contacts.next();
    ProtocolProviderService protocolProvider=contact.getProtocolProvider();
    String contactDisplayName=contact.getDisplayName();
    JMenuItem contactItem=new JMenuItem(contactDisplayName);
    JMenuItem contactItem1=new JMenuItem(contactDisplayName);
    Icon protocolIcon=new ImageIcon(createContactStatusImage(contact));
    contactItem.setIcon(protocolIcon);
    contactItem1.setIcon(protocolIcon);
    contactItem.setName(removeContactPrefix + contact.getAddress() + protocolProvider.getProtocolName());
    contactItem1.setName(moveSubcontactPrefix + contact.getAddress() + protocolProvider.getProtocolName());
    contactItem.addActionListener(this);
    contactItem1.addActionListener(this);
    this.removeContactMenu.add(contactItem);
    this.moveSubcontactMenu.add(contactItem1);
    if (contact.getProtocolProvider().getOperationSet(OperationSetBasicTelephony.class) != null) {
      JMenuItem callContactItem=new JMenuItem(contactDisplayName);
      callContactItem.setIcon(protocolIcon);
      callContactItem.setName(callContactPrefix + contact.getAddress() + protocolProvider.getProtocolName());
      callContactItem.addActionListener(this);
      this.callContactMenu.add(callContactItem);
    }
    protocolProvider.getOperationSet(OperationSetWebContactInfo.class);
  }
  this.add(sendMessageItem);
  this.add(sendSmsItem);
  if (callContactMenu.getItemCount() > 1) {
    this.add(callContactMenu);
  }
 else {
    this.add(callItem);
  }
  this.add(sendFileItem);
  this.addSeparator();
  this.add(moveToMenu);
  this.add(moveSubcontactMenu);
  this.addSeparator();
  this.add(addSubcontactMenu);
  this.addSeparator();
  this.add(removeContactMenu);
  this.add(renameContactItem);
  this.addSeparator();
  this.add(viewHistoryItem);
  this.initPluginComponents();
  this.sendMessageItem.setName(""String_Node_Str"");
  this.callItem.setName(""String_Node_Str"");
  this.sendSmsItem.setName(""String_Node_Str"");
  this.sendFileItem.setName(""String_Node_Str"");
  this.moveToMenu.setName(""String_Node_Str"");
  this.addSubcontactMenu.setName(""String_Node_Str"");
  this.renameContactItem.setName(""String_Node_Str"");
  this.viewHistoryItem.setName(""String_Node_Str"");
  this.sendMessageItem.addActionListener(this);
  this.callItem.addActionListener(this);
  this.sendSmsItem.addActionListener(this);
  this.sendFileItem.addActionListener(this);
  this.renameContactItem.addActionListener(this);
  this.viewHistoryItem.addActionListener(this);
  if (contactItem.getDefaultContact(OperationSetFileTransfer.class) == null)   this.sendFileItem.setEnabled(false);
  if (contactItem.getDefaultContact(OperationSetBasicTelephony.class) == null)   this.callItem.setEnabled(false);
  if (contactItem.getDefaultContact(OperationSetBasicInstantMessaging.class) == null)   this.sendMessageItem.setEnabled(false);
  if (contactItem.getDefaultContact(OperationSetSmsMessaging.class) == null)   this.sendSmsItem.setEnabled(false);
}",0.9950013154433044
104140,"public void run(){
  Iterator i=contactItem.getContacts();
  while (i.hasNext()) {
    Contact contact=(Contact)i.next();
    mainFrame.getContactList().moveContact(contact,metaContact);
  }
}","public void run(){
  Iterator<Contact> i=contactItem.getContacts();
  while (i.hasNext()) {
    Contact contact=i.next();
    mainFrame.getContactList().moveContact(contact,metaContact);
  }
}",0.953125
104141,"/** 
 * Handles the <tt>ActionEvent</tt>. Determines which menu item was selected and performs the appropriate operations.
 */
public void actionPerformed(ActionEvent e){
  JMenuItem menuItem=(JMenuItem)e.getSource();
  String itemName=menuItem.getName();
  String itemText=menuItem.getText();
  Contact cont=null;
  if (itemName.startsWith(addSubcontactPrefix)) {
    ProtocolProviderService pps=mainFrame.getProtocolProviderForAccount(itemText);
    if (pps != null) {
      AddContactDialog dialog=new AddContactDialog(mainFrame,contactItem,pps);
      dialog.setLocation(Toolkit.getDefaultToolkit().getScreenSize().width / 2 - 250,Toolkit.getDefaultToolkit().getScreenSize().height / 2 - 100);
      dialog.showDialog();
    }
  }
 else   if (itemName.equalsIgnoreCase(""String_Node_Str"")) {
    ContactListPane clistPanel=mainFrame.getContactListPanel();
    SwingUtilities.invokeLater(clistPanel.new RunMessageWindow(contactItem));
  }
 else   if (itemName.equalsIgnoreCase(""String_Node_Str"")) {
    Contact defaultSmsContact=contactItem.getDefaultContact(OperationSetSmsMessaging.class);
    ContactListPane clistPanel=mainFrame.getContactListPanel();
    SwingUtilities.invokeLater(clistPanel.new RunMessageWindow(contactItem,defaultSmsContact,true));
  }
 else   if (itemName.equalsIgnoreCase(""String_Node_Str"")) {
    cont=contactItem.getDefaultContact(OperationSetBasicTelephony.class);
    callContact(cont);
  }
 else   if (itemName.equalsIgnoreCase(""String_Node_Str"")) {
  }
 else   if (itemName.equalsIgnoreCase(""String_Node_Str"")) {
    RenameContactDialog dialog=new RenameContactDialog(mainFrame,contactItem);
    dialog.setLocation(Toolkit.getDefaultToolkit().getScreenSize().width / 2 - 200,Toolkit.getDefaultToolkit().getScreenSize().height / 2 - 50);
    dialog.setVisible(true);
    dialog.requestFocusInFiled();
  }
 else   if (itemName.equalsIgnoreCase(""String_Node_Str"")) {
    HistoryWindow history;
    HistoryWindowManager historyWindowManager=GuiActivator.getUIService().getHistoryWindowManager();
    if (historyWindowManager.containsHistoryWindowForContact(contactItem)) {
      history=historyWindowManager.getHistoryWindowForContact(contactItem);
      if (history.getState() == JFrame.ICONIFIED)       history.setState(JFrame.NORMAL);
      history.toFront();
    }
 else {
      history=new HistoryWindow(this.contactItem);
      historyWindowManager.addHistoryWindowForContact(contactItem,history);
      history.setVisible(true);
    }
  }
 else   if (itemName.startsWith(moveToPrefix)) {
    MetaContactGroup group=mainFrame.getGroupByID(itemName.substring(moveToPrefix.length()));
    try {
      if (group != null) {
        mainFrame.getContactList().moveMetaContact(contactItem,group);
      }
    }
 catch (    Exception ex) {
      new ErrorDialog(mainFrame,GuiActivator.getResources().getI18NString(""String_Node_Str""),GuiActivator.getResources().getI18NString(""String_Node_Str""),ex).showDialog();
    }
  }
 else   if (itemName.startsWith(removeContactPrefix)) {
    Contact contact=getContactFromMetaContact(itemName.substring(removeContactPrefix.length()));
    if (contact != null) {
      new RemoveContactThread(contact).start();
    }
 else {
      new RemoveAllContactsThread().start();
    }
  }
 else   if (itemName.startsWith(moveSubcontactPrefix)) {
    Contact contact=getContactFromMetaContact(itemName.substring(moveSubcontactPrefix.length()));
    guiContactList.addExcContactListListener(this);
    this.moveDialog=new MoveSubcontactMessageDialog(mainFrame,this);
    this.moveDialog.setVisible(true);
    if (contact != null) {
      this.contactToMove=contact;
    }
 else {
      this.moveAllContacts=true;
    }
  }
 else   if (itemName.startsWith(callContactPrefix)) {
    cont=getContactFromMetaContact(itemName.substring(callContactPrefix.length()));
    callContact(cont);
  }
}","/** 
 * Handles the <tt>ActionEvent</tt>. Determines which menu item was selected and performs the appropriate operations.
 */
public void actionPerformed(ActionEvent e){
  JMenuItem menuItem=(JMenuItem)e.getSource();
  String itemName=menuItem.getName();
  Contact cont=null;
  if (itemName.startsWith(addSubcontactPrefix)) {
    ProtocolProviderService pps=((ProviderAwareMenuItem)menuItem).getProvider();
    if (pps != null) {
      AddContactDialog dialog=new AddContactDialog(mainFrame,contactItem,pps);
      dialog.setLocation(Toolkit.getDefaultToolkit().getScreenSize().width / 2 - 250,Toolkit.getDefaultToolkit().getScreenSize().height / 2 - 100);
      dialog.showDialog();
    }
  }
 else   if (itemName.equalsIgnoreCase(""String_Node_Str"")) {
    ContactListPane clistPanel=mainFrame.getContactListPanel();
    SwingUtilities.invokeLater(clistPanel.new RunMessageWindow(contactItem));
  }
 else   if (itemName.equalsIgnoreCase(""String_Node_Str"")) {
    Contact defaultSmsContact=contactItem.getDefaultContact(OperationSetSmsMessaging.class);
    ContactListPane clistPanel=mainFrame.getContactListPanel();
    SwingUtilities.invokeLater(clistPanel.new RunMessageWindow(contactItem,defaultSmsContact,true));
  }
 else   if (itemName.equalsIgnoreCase(""String_Node_Str"")) {
    cont=contactItem.getDefaultContact(OperationSetBasicTelephony.class);
    callContact(cont);
  }
 else   if (itemName.equalsIgnoreCase(""String_Node_Str"")) {
  }
 else   if (itemName.equalsIgnoreCase(""String_Node_Str"")) {
    RenameContactDialog dialog=new RenameContactDialog(mainFrame,contactItem);
    dialog.setLocation(Toolkit.getDefaultToolkit().getScreenSize().width / 2 - 200,Toolkit.getDefaultToolkit().getScreenSize().height / 2 - 50);
    dialog.setVisible(true);
    dialog.requestFocusInFiled();
  }
 else   if (itemName.equalsIgnoreCase(""String_Node_Str"")) {
    HistoryWindow history;
    HistoryWindowManager historyWindowManager=GuiActivator.getUIService().getHistoryWindowManager();
    if (historyWindowManager.containsHistoryWindowForContact(contactItem)) {
      history=historyWindowManager.getHistoryWindowForContact(contactItem);
      if (history.getState() == JFrame.ICONIFIED)       history.setState(JFrame.NORMAL);
      history.toFront();
    }
 else {
      history=new HistoryWindow(this.contactItem);
      historyWindowManager.addHistoryWindowForContact(contactItem,history);
      history.setVisible(true);
    }
  }
 else   if (itemName.startsWith(moveToPrefix)) {
    MetaContactGroup group=mainFrame.getGroupByID(itemName.substring(moveToPrefix.length()));
    try {
      if (group != null) {
        mainFrame.getContactList().moveMetaContact(contactItem,group);
      }
    }
 catch (    Exception ex) {
      new ErrorDialog(mainFrame,GuiActivator.getResources().getI18NString(""String_Node_Str""),GuiActivator.getResources().getI18NString(""String_Node_Str""),ex).showDialog();
    }
  }
 else   if (itemName.startsWith(removeContactPrefix)) {
    Contact contact=getContactFromMetaContact(itemName.substring(removeContactPrefix.length()));
    if (contact != null) {
      new RemoveContactThread(contact).start();
    }
 else {
      new RemoveAllContactsThread().start();
    }
  }
 else   if (itemName.startsWith(moveSubcontactPrefix)) {
    Contact contact=getContactFromMetaContact(itemName.substring(moveSubcontactPrefix.length()));
    guiContactList.addExcContactListListener(this);
    this.moveDialog=new MoveSubcontactMessageDialog(mainFrame,this);
    this.moveDialog.setVisible(true);
    if (contact != null) {
      this.contactToMove=contact;
    }
 else {
      this.moveAllContacts=true;
    }
  }
 else   if (itemName.startsWith(callContactPrefix)) {
    cont=getContactFromMetaContact(itemName.substring(callContactPrefix.length()));
    callContact(cont);
  }
}",0.985628429579305
104142,"/** 
 * The reason we need to override this method here comes from the fact that the user id that is standardly returned by the parent method is not sufficient for the user to distinguish this account from other sip accounts with the same user name. Besides we also need to handle the case of registrar-less accounts.
 * @return A String that can be showed to users when referring to thisaccount.
 */
public String getDisplayName(){
  String returnValue=getUserID();
  String protocolName=getAccountPropertyString(ProtocolProviderFactory.PROTOCOL);
  String service=getService();
  if (service == null || service.trim().length() == 0) {
    protocolName=""String_Node_Str"" + protocolName;
  }
 else {
    returnValue+=""String_Node_Str"" + service;
  }
  if (protocolName != null && protocolName.trim().length() > 0)   returnValue+=""String_Node_Str"" + protocolName + ""String_Node_Str"";
  return returnValue;
}","/** 
 * The reason we need to override this method here comes from the fact that the user id that is standardly returned by the parent method is not sufficient for the user to distinguish this account from other sip accounts with the same user name. Besides we also need to handle the case of registrar-less accounts.
 * @return A String that can be showed to users when referring to thisaccount.
 */
public String getDisplayName(){
  String returnValue=super.getAccountPropertyString(ProtocolProviderFactory.USER_ID);
  String protocolName=getAccountPropertyString(ProtocolProviderFactory.PROTOCOL);
  String service=getService();
  if (service == null || service.trim().length() == 0) {
    protocolName=""String_Node_Str"" + protocolName;
  }
  if (protocolName != null && protocolName.trim().length() > 0)   returnValue+=""String_Node_Str"" + protocolName + ""String_Node_Str"";
  return returnValue;
}",0.8615725359911407
104143,"/** 
 * Creates a SIP account id from the specified ide and account properties.
 * @param userID the user id part of the SIP uri identifying this contact.
 * @param accountProperties any other properties necessary for the account.
 * @param serverName the name of the server that the user belongs to.
 */
protected SipAccountID(String userID,Map accountProperties,String serverName){
  super(getUserIDWithoutServerName(userID),accountProperties,(String)accountProperties.get(ProtocolProviderFactory.PROTOCOL),serverName);
}","/** 
 * Creates a SIP account id from the specified ide and account properties.
 * @param userID the user id part of the SIP uri identifying this contact.
 * @param accountProperties any other properties necessary for the account.
 * @param serverName the name of the server that the user belongs to.
 */
protected SipAccountID(String userID,Map accountProperties,String serverName){
  super(stripServerNameFromUserID(userID),accountProperties,(String)accountProperties.get(ProtocolProviderFactory.PROTOCOL),serverName);
}",0.9626794258373206
104144,"/** 
 * Sends the <tt>message</tt> to the destination indicated by the <tt>to</tt> contact.
 * @param to the <tt>Contact</tt> to send <tt>message</tt> to
 * @param message the <tt>Message</tt> to send.
 * @throws IllegalStateException if the underlying ICQ stack is notregistered and initialized.
 * @throws IllegalArgumentException if <tt>to</tt> is not an instancebelonging to the underlying implementation.
 */
public void sendInstantMessage(Contact to,Message message) throws IllegalStateException, IllegalArgumentException {
  if (!(to instanceof ContactDictImpl)) {
    throw new IllegalArgumentException(""String_Node_Str"" + to);
  }
  fireMessageDelivered(message,to);
  this.submitDictQuery((ContactDictImpl)to,message);
}","/** 
 * Sends the <tt>message</tt> to the destination indicated by the <tt>to</tt> contact.
 * @param to the <tt>Contact</tt> to send <tt>message</tt> to
 * @param message the <tt>Message</tt> to send.
 * @throws IllegalStateException if the underlying ICQ stack is notregistered and initialized.
 * @throws IllegalArgumentException if <tt>to</tt> is not an instancebelonging to the underlying implementation.
 */
public void sendInstantMessage(Contact to,Message message) throws IllegalStateException, IllegalArgumentException {
  if (!(to instanceof ContactDictImpl)) {
    throw new IllegalArgumentException(""String_Node_Str"" + to);
  }
  message=createMessage(Html2Text.extractText(message.getContent()));
  fireMessageDelivered(message,to);
  this.submitDictQuery((ContactDictImpl)to,message);
}",0.954248366013072
104145,"/** 
 * Handles transfers to the chat panel write area from the clip board or a DND drop operation. The <tt>Transferable</tt> parameter contains the data that needs to be imported. <p>
 * @param comp  the component to receive the transfer;
 * @param transferable     the data to import
 * @return  true if the data was inserted into the component and falseotherwise
 * @see #importData(TransferHandler.TransferSupport)
 */
public boolean importData(JComponent comp,Transferable transferable){
  if (comp instanceof JTextComponent) {
    DataFlavor flavor=getFlavor(transferable.getTransferDataFlavors());
    if (flavor != null) {
      InputContext inputContext=comp.getInputContext();
      if (inputContext != null) {
        inputContext.endComposition();
      }
      try {
        BufferedReader reader=new BufferedReader(flavor.getReaderForText(transferable));
        StringBuffer buffToPaste=new StringBuffer();
        String line=null;
        while ((line=reader.readLine()) != null) {
          buffToPaste.append(line).append(""String_Node_Str"");
        }
        ((JTextComponent)comp).replaceSelection(buffToPaste.toString());
        return true;
      }
 catch (      UnsupportedFlavorException ufe) {
      }
catch (      IOException ioe) {
      }
    }
  }
  return false;
}","/** 
 * Handles transfers to the chat panel write area from the clip board or a DND drop operation. The <tt>Transferable</tt> parameter contains the data that needs to be imported. <p>
 * @param comp  the component to receive the transfer;
 * @param transferable     the data to import
 * @return  true if the data was inserted into the component and falseotherwise
 * @see #importData(TransferHandler.TransferSupport)
 */
public boolean importData(JComponent comp,Transferable transferable){
  if (comp instanceof JTextComponent) {
    DataFlavor flavor=getFlavor(transferable.getTransferDataFlavors());
    if (flavor != null) {
      InputContext inputContext=comp.getInputContext();
      if (inputContext != null) {
        inputContext.endComposition();
      }
      try {
        BufferedReader reader=new BufferedReader(flavor.getReaderForText(transferable));
        StringBuffer buffToPaste=new StringBuffer();
        String line=reader.readLine();
        while (line != null) {
          buffToPaste.append(line);
          line=reader.readLine();
          if (line != null)           buffToPaste.append(""String_Node_Str"");
        }
        ((JTextComponent)comp).replaceSelection(buffToPaste.toString());
        return true;
      }
 catch (      UnsupportedFlavorException ufe) {
      }
catch (      IOException ioe) {
      }
    }
  }
  return false;
}",0.949812734082397
104146,"protected Iterator getFileList(){
  return this.historyDocuments.keySet().iterator();
}","protected Iterator<String> getFileList(){
  return this.historyDocuments.keySet().iterator();
}",0.956043956043956
104147,"public int compare(Object o1,Object o2){
  if (o1 instanceof HistoryRecord && o2 instanceof HistoryRecord) {
    return ((HistoryRecord)o1).getTimestamp().compareTo(((HistoryRecord)o2).getTimestamp());
  }
 else   return 0;
}","public int compare(HistoryRecord h1,HistoryRecord h2){
  return h1.getTimestamp().compareTo(h2.getTimestamp());
}",0.621301775147929
104148,"/** 
 * If there is keyword restriction and doesn't match the conditions return null. Otherwise return the HistoryRecord corresponding the given nodes.
 * @param propertyNodes NodeList
 * @param timestamp Date
 * @param keywords String[]
 * @param field String
 * @param caseSensitive boolean
 * @return HistoryRecord
 */
private HistoryRecord filterByKeyword(NodeList propertyNodes,Date timestamp,String[] keywords,String field,boolean caseSensitive){
  ArrayList nameVals=new ArrayList();
  int len=propertyNodes.getLength();
  for (int j=0; j < len; j++) {
    Node propertyNode=propertyNodes.item(j);
    if (propertyNode.getNodeType() == Node.ELEMENT_NODE) {
      String nodeName=propertyNode.getNodeName();
      Node nestedNode=propertyNode.getFirstChild();
      if (nestedNode == null)       continue;
      String nodeValue=nestedNode.getNodeValue();
      if (field != null && field.equals(nodeName) && !matchKeyword(nodeValue,keywords,caseSensitive)) {
        return null;
      }
      nameVals.add(nodeName);
      nameVals.add(propertyNode.getFirstChild().getNodeValue());
    }
  }
  String[] propertyNames=new String[nameVals.size() / 2];
  String[] propertyValues=new String[propertyNames.length];
  for (int j=0; j < propertyNames.length; j++) {
    propertyNames[j]=(String)nameVals.get(j * 2);
    propertyValues[j]=(String)nameVals.get(j * 2 + 1);
  }
  return new HistoryRecord(propertyNames,propertyValues,timestamp);
}","/** 
 * If there is keyword restriction and doesn't match the conditions return null. Otherwise return the HistoryRecord corresponding the given nodes.
 * @param propertyNodes NodeList
 * @param timestamp Date
 * @param keywords String[]
 * @param field String
 * @param caseSensitive boolean
 * @return HistoryRecord
 */
private HistoryRecord filterByKeyword(NodeList propertyNodes,Date timestamp,String[] keywords,String field,boolean caseSensitive){
  ArrayList<String> nameVals=new ArrayList<String>();
  int len=propertyNodes.getLength();
  for (int j=0; j < len; j++) {
    Node propertyNode=propertyNodes.item(j);
    if (propertyNode.getNodeType() == Node.ELEMENT_NODE) {
      String nodeName=propertyNode.getNodeName();
      Node nestedNode=propertyNode.getFirstChild();
      if (nestedNode == null)       continue;
      String nodeValue=nestedNode.getNodeValue();
      if (field != null && field.equals(nodeName) && !matchKeyword(nodeValue,keywords,caseSensitive)) {
        return null;
      }
      nameVals.add(nodeName);
      nameVals.add(propertyNode.getFirstChild().getNodeValue());
    }
  }
  String[] propertyNames=new String[nameVals.size() / 2];
  String[] propertyValues=new String[propertyNames.length];
  for (int j=0; j < propertyNames.length; j++) {
    propertyNames[j]=(String)nameVals.get(j * 2);
    propertyValues[j]=(String)nameVals.get(j * 2 + 1);
  }
  return new HistoryRecord(propertyNames,propertyValues,timestamp);
}",0.9944941500344116
104149,"/** 
 * Returns the supplied number of recent messages before the given date
 * @param date messages before date
 * @param count messages count
 * @return QueryResultSet the found records
 * @throws RuntimeException
 */
public QueryResultSet findLastRecordsBefore(Date date,int count) throws RuntimeException {
  Vector filelist=filterFilesByDate(this.historyImpl.getFileList(),null,date);
  TreeSet result=new TreeSet(new HistoryRecordComparator());
  int leftCount=count;
  int currentFile=filelist.size() - 1;
  while (leftCount > 0 && currentFile >= 0) {
    Document doc=this.historyImpl.getDocumentForFile((String)filelist.get(currentFile));
    if (doc == null) {
      currentFile--;
      continue;
    }
    NodeList nodes=doc.getElementsByTagName(""String_Node_Str"");
    Node node;
    for (int i=nodes.getLength() - 1; i >= 0 && leftCount > 0; i--) {
      node=nodes.item(i);
      NodeList propertyNodes=node.getChildNodes();
      String ts=node.getAttributes().getNamedItem(""String_Node_Str"").getNodeValue();
      Date timestamp=new Date(Long.parseLong(ts));
      if (!isInPeriod(timestamp,null,date))       continue;
      ArrayList nameVals=new ArrayList();
      boolean isRecordOK=true;
      int len=propertyNodes.getLength();
      for (int j=0; j < len; j++) {
        Node propertyNode=propertyNodes.item(j);
        if (propertyNode.getNodeType() == Node.ELEMENT_NODE) {
          Node nodeValue=propertyNode.getFirstChild();
          if (nodeValue != null) {
            nameVals.add(propertyNode.getNodeName());
            nameVals.add(nodeValue.getNodeValue());
          }
 else           isRecordOK=false;
        }
      }
      if (!isRecordOK)       continue;
      String[] propertyNames=new String[nameVals.size() / 2];
      String[] propertyValues=new String[propertyNames.length];
      for (int j=0; j < propertyNames.length; j++) {
        propertyNames[j]=(String)nameVals.get(j * 2);
        propertyValues[j]=(String)nameVals.get(j * 2 + 1);
      }
      HistoryRecord record=new HistoryRecord(propertyNames,propertyValues,timestamp);
      result.add(record);
      leftCount--;
    }
    currentFile--;
  }
  return new OrderedQueryResultSet(result);
}","/** 
 * Returns the supplied number of recent messages before the given date
 * @param date messages before date
 * @param count messages count
 * @return QueryResultSet the found records
 * @throws RuntimeException
 */
public QueryResultSet findLastRecordsBefore(Date date,int count) throws RuntimeException {
  Vector<String> filelist=filterFilesByDate(this.historyImpl.getFileList(),null,date);
  TreeSet<HistoryRecord> result=new TreeSet<HistoryRecord>(new HistoryRecordComparator());
  int leftCount=count;
  int currentFile=filelist.size() - 1;
  while (leftCount > 0 && currentFile >= 0) {
    Document doc=this.historyImpl.getDocumentForFile((String)filelist.get(currentFile));
    if (doc == null) {
      currentFile--;
      continue;
    }
    NodeList nodes=doc.getElementsByTagName(""String_Node_Str"");
    Node node;
    for (int i=nodes.getLength() - 1; i >= 0 && leftCount > 0; i--) {
      node=nodes.item(i);
      NodeList propertyNodes=node.getChildNodes();
      String ts=node.getAttributes().getNamedItem(""String_Node_Str"").getNodeValue();
      Date timestamp=new Date(Long.parseLong(ts));
      if (!isInPeriod(timestamp,null,date))       continue;
      ArrayList<String> nameVals=new ArrayList<String>();
      boolean isRecordOK=true;
      int len=propertyNodes.getLength();
      for (int j=0; j < len; j++) {
        Node propertyNode=propertyNodes.item(j);
        if (propertyNode.getNodeType() == Node.ELEMENT_NODE) {
          Node nodeValue=propertyNode.getFirstChild();
          if (nodeValue != null) {
            nameVals.add(propertyNode.getNodeName());
            nameVals.add(nodeValue.getNodeValue());
          }
 else           isRecordOK=false;
        }
      }
      if (!isRecordOK)       continue;
      String[] propertyNames=new String[nameVals.size() / 2];
      String[] propertyValues=new String[propertyNames.length];
      for (int j=0; j < propertyNames.length; j++) {
        propertyNames[j]=(String)nameVals.get(j * 2);
        propertyValues[j]=(String)nameVals.get(j * 2 + 1);
      }
      HistoryRecord record=new HistoryRecord(propertyNames,propertyValues,timestamp);
      result.add(record);
      leftCount--;
    }
    currentFile--;
  }
  return new OrderedQueryResultSet(result);
}",0.9878869448183042
104150,"/** 
 * Returns the last <tt>count</tt> messages. No progress firing as this method is supposed to be used in message windows and is supposed to be as quick as it can.
 * @param count int
 * @return QueryResultSet
 * @throws RuntimeException
 */
public synchronized QueryResultSet findLast(int count) throws RuntimeException {
  Vector filelist=filterFilesByDate(this.historyImpl.getFileList(),null,null);
  TreeSet result=new TreeSet(new HistoryRecordComparator());
  int leftCount=count;
  int currentFile=filelist.size() - 1;
  while (leftCount > 0 && currentFile >= 0) {
    Document doc=this.historyImpl.getDocumentForFile((String)filelist.get(currentFile));
    if (doc == null) {
      currentFile--;
      continue;
    }
    List nodes=new ArrayList();
    NodeList nodesList=doc.getElementsByTagName(""String_Node_Str"");
    for (int i=0; i < nodesList.getLength(); i++) {
      nodes.add(nodesList.item(i));
    }
    List lNodes=null;
    if (nodes.size() > leftCount) {
      lNodes=nodes.subList(nodes.size() - leftCount,nodes.size());
      leftCount=0;
    }
 else {
      lNodes=nodes;
      leftCount-=nodes.size();
    }
    Iterator i=lNodes.iterator();
    while (i.hasNext()) {
      Node node=(Node)i.next();
      NodeList propertyNodes=node.getChildNodes();
      String ts=node.getAttributes().getNamedItem(""String_Node_Str"").getNodeValue();
      Date timestamp=new Date(Long.parseLong(ts));
      ArrayList nameVals=new ArrayList();
      boolean isRecordOK=true;
      int len=propertyNodes.getLength();
      for (int j=0; j < len; j++) {
        Node propertyNode=propertyNodes.item(j);
        if (propertyNode.getNodeType() == Node.ELEMENT_NODE) {
          Node nodeValue=propertyNode.getFirstChild();
          if (nodeValue != null) {
            nameVals.add(propertyNode.getNodeName());
            nameVals.add(nodeValue.getNodeValue());
          }
 else           isRecordOK=false;
        }
      }
      if (!isRecordOK)       continue;
      String[] propertyNames=new String[nameVals.size() / 2];
      String[] propertyValues=new String[propertyNames.length];
      for (int j=0; j < propertyNames.length; j++) {
        propertyNames[j]=(String)nameVals.get(j * 2);
        propertyValues[j]=(String)nameVals.get(j * 2 + 1);
      }
      HistoryRecord record=new HistoryRecord(propertyNames,propertyValues,timestamp);
      result.add(record);
    }
    currentFile--;
  }
  return new OrderedQueryResultSet(result);
}","/** 
 * Returns the last <tt>count</tt> messages. No progress firing as this method is supposed to be used in message windows and is supposed to be as quick as it can.
 * @param count int
 * @return QueryResultSet
 * @throws RuntimeException
 */
public synchronized QueryResultSet findLast(int count) throws RuntimeException {
  Vector<String> filelist=filterFilesByDate(this.historyImpl.getFileList(),null,null);
  TreeSet<HistoryRecord> result=new TreeSet<HistoryRecord>(new HistoryRecordComparator());
  int leftCount=count;
  int currentFile=filelist.size() - 1;
  while (leftCount > 0 && currentFile >= 0) {
    Document doc=this.historyImpl.getDocumentForFile((String)filelist.get(currentFile));
    if (doc == null) {
      currentFile--;
      continue;
    }
    List<Node> nodes=new ArrayList<Node>();
    NodeList nodesList=doc.getElementsByTagName(""String_Node_Str"");
    for (int i=0; i < nodesList.getLength(); i++) {
      nodes.add(nodesList.item(i));
    }
    List<Node> lNodes=null;
    if (nodes.size() > leftCount) {
      lNodes=nodes.subList(nodes.size() - leftCount,nodes.size());
      leftCount=0;
    }
 else {
      lNodes=nodes;
      leftCount-=nodes.size();
    }
    Iterator<Node> i=lNodes.iterator();
    while (i.hasNext()) {
      Node node=(Node)i.next();
      NodeList propertyNodes=node.getChildNodes();
      String ts=node.getAttributes().getNamedItem(""String_Node_Str"").getNodeValue();
      Date timestamp=new Date(Long.parseLong(ts));
      ArrayList<String> nameVals=new ArrayList<String>();
      boolean isRecordOK=true;
      int len=propertyNodes.getLength();
      for (int j=0; j < len; j++) {
        Node propertyNode=propertyNodes.item(j);
        if (propertyNode.getNodeType() == Node.ELEMENT_NODE) {
          Node nodeValue=propertyNode.getFirstChild();
          if (nodeValue != null) {
            nameVals.add(propertyNode.getNodeName());
            nameVals.add(nodeValue.getNodeValue());
          }
 else           isRecordOK=false;
        }
      }
      if (!isRecordOK)       continue;
      String[] propertyNames=new String[nameVals.size() / 2];
      String[] propertyValues=new String[propertyNames.length];
      for (int j=0; j < propertyNames.length; j++) {
        propertyNames[j]=(String)nameVals.get(j * 2);
        propertyValues[j]=(String)nameVals.get(j * 2 + 1);
      }
      HistoryRecord record=new HistoryRecord(propertyNames,propertyValues,timestamp);
      result.add(record);
    }
    currentFile--;
  }
  return new OrderedQueryResultSet(result);
}",0.9844249201277956
104151,"/** 
 * Count the number of messages that a search will return Actually only the last file is parsed and its nodes are counted. We accept that the other files are full with max records,  this way we escape parsing all files which will significantly  slow the process and for one search will parse the files twice.
 * @return the number of searched messages
 * @throws UnsupportedOperationException Thrown if an exception occurs during the execution of the query, such as internal IO error.
 */
public int countRecords() throws UnsupportedOperationException {
  int result=0;
  String lastFile=null;
  Iterator filelistIter=this.historyImpl.getFileList();
  while (filelistIter.hasNext()) {
    lastFile=(String)filelistIter.next();
    result+=HistoryWriterImpl.MAX_RECORDS_PER_FILE;
  }
  if (lastFile == null)   return result;
  Document doc=this.historyImpl.getDocumentForFile(lastFile);
  if (doc == null)   return result;
  NodeList nodes=doc.getElementsByTagName(""String_Node_Str"");
  result+=nodes.getLength();
  return result;
}","/** 
 * Count the number of messages that a search will return Actually only the last file is parsed and its nodes are counted. We accept that the other files are full with max records, this way we escape parsing all files which will significantly slow the process and for one search will parse the files twice.
 * @return the number of searched messages
 * @throws UnsupportedOperationException Thrown if an exception occurs during the execution of the query, such as internal IO error.
 */
public int countRecords() throws UnsupportedOperationException {
  int result=0;
  String lastFile=null;
  Iterator<String> filelistIter=this.historyImpl.getFileList();
  while (filelistIter.hasNext()) {
    lastFile=(String)filelistIter.next();
    result+=HistoryWriterImpl.MAX_RECORDS_PER_FILE;
  }
  if (lastFile == null)   return result;
  Document doc=this.historyImpl.getDocumentForFile(lastFile);
  if (doc == null)   return result;
  NodeList nodes=doc.getElementsByTagName(""String_Node_Str"");
  result+=nodes.getLength();
  return result;
}",0.9951876804619828
104152,"private void fireProgressStateChanged(Date startDate,Date endDate,String[] keywords,int progress){
  ProgressEvent event=new ProgressEvent(this,startDate,endDate,keywords,progress);
synchronized (progressListeners) {
    Iterator iter=progressListeners.iterator();
    while (iter.hasNext()) {
      HistorySearchProgressListener item=(HistorySearchProgressListener)iter.next();
      item.progressChanged(event);
    }
  }
}","private void fireProgressStateChanged(Date startDate,Date endDate,String[] keywords,int progress){
  ProgressEvent event=new ProgressEvent(this,startDate,endDate,keywords,progress);
synchronized (progressListeners) {
    Iterator<HistorySearchProgressListener> iter=progressListeners.iterator();
    while (iter.hasNext()) {
      HistorySearchProgressListener item=(HistorySearchProgressListener)iter.next();
      item.progressChanged(event);
    }
  }
}",0.9648127128263336
104153,"private QueryResultSet find(Date startDate,Date endDate,String[] keywords,String field,boolean caseSensitive){
  TreeSet result=new TreeSet(new HistoryRecordComparator());
  Vector filelist=filterFilesByDate(this.historyImpl.getFileList(),startDate,endDate);
  double currentProgress=HistorySearchProgressListener.PROGRESS_MINIMUM_VALUE;
  double fileProgressStep=HistorySearchProgressListener.PROGRESS_MAXIMUM_VALUE;
  if (filelist.size() != 0)   fileProgressStep=HistorySearchProgressListener.PROGRESS_MAXIMUM_VALUE / filelist.size();
  fireProgressStateChanged(startDate,endDate,keywords,HistorySearchProgressListener.PROGRESS_MINIMUM_VALUE);
  Iterator fileIterator=filelist.iterator();
  while (fileIterator.hasNext()) {
    String filename=(String)fileIterator.next();
    Document doc=this.historyImpl.getDocumentForFile(filename);
    if (doc == null)     continue;
    NodeList nodes=doc.getElementsByTagName(""String_Node_Str"");
    double nodesProgressStep=fileProgressStep;
    if (nodes.getLength() != 0)     nodesProgressStep=fileProgressStep / nodes.getLength();
    Node node;
    for (int i=0; i < nodes.getLength(); i++) {
      node=nodes.item(i);
      String ts=node.getAttributes().getNamedItem(""String_Node_Str"").getNodeValue();
      Date timestamp=new Date(Long.parseLong(ts));
      if (isInPeriod(timestamp,startDate,endDate)) {
        NodeList propertyNodes=node.getChildNodes();
        HistoryRecord record=filterByKeyword(propertyNodes,timestamp,keywords,field,caseSensitive);
        if (record != null) {
          result.add(record);
        }
      }
      currentProgress+=nodesProgressStep;
      fireProgressStateChanged(startDate,endDate,keywords,(int)currentProgress);
    }
  }
  if ((int)currentProgress < HistorySearchProgressListener.PROGRESS_MAXIMUM_VALUE) {
    fireProgressStateChanged(startDate,endDate,keywords,HistorySearchProgressListener.PROGRESS_MAXIMUM_VALUE);
  }
  return new OrderedQueryResultSet(result);
}","private QueryResultSet find(Date startDate,Date endDate,String[] keywords,String field,boolean caseSensitive){
  TreeSet<HistoryRecord> result=new TreeSet<HistoryRecord>(new HistoryRecordComparator());
  Vector<String> filelist=filterFilesByDate(this.historyImpl.getFileList(),startDate,endDate);
  double currentProgress=HistorySearchProgressListener.PROGRESS_MINIMUM_VALUE;
  double fileProgressStep=HistorySearchProgressListener.PROGRESS_MAXIMUM_VALUE;
  if (filelist.size() != 0)   fileProgressStep=HistorySearchProgressListener.PROGRESS_MAXIMUM_VALUE / filelist.size();
  fireProgressStateChanged(startDate,endDate,keywords,HistorySearchProgressListener.PROGRESS_MINIMUM_VALUE);
  Iterator<String> fileIterator=filelist.iterator();
  while (fileIterator.hasNext()) {
    String filename=fileIterator.next();
    Document doc=this.historyImpl.getDocumentForFile(filename);
    if (doc == null)     continue;
    NodeList nodes=doc.getElementsByTagName(""String_Node_Str"");
    double nodesProgressStep=fileProgressStep;
    if (nodes.getLength() != 0)     nodesProgressStep=fileProgressStep / nodes.getLength();
    Node node;
    for (int i=0; i < nodes.getLength(); i++) {
      node=nodes.item(i);
      String ts=node.getAttributes().getNamedItem(""String_Node_Str"").getNodeValue();
      Date timestamp=new Date(Long.parseLong(ts));
      if (isInPeriod(timestamp,startDate,endDate)) {
        NodeList propertyNodes=node.getChildNodes();
        HistoryRecord record=filterByKeyword(propertyNodes,timestamp,keywords,field,caseSensitive);
        if (record != null) {
          result.add(record);
        }
      }
      currentProgress+=nodesProgressStep;
      fireProgressStateChanged(startDate,endDate,keywords,(int)currentProgress);
    }
  }
  if ((int)currentProgress < HistorySearchProgressListener.PROGRESS_MAXIMUM_VALUE) {
    fireProgressStateChanged(startDate,endDate,keywords,HistorySearchProgressListener.PROGRESS_MAXIMUM_VALUE);
  }
  return new OrderedQueryResultSet(result);
}",0.9863842662632376
104154,"/** 
 * Used to limit the files if any starting or ending date exist So only few files to be searched.
 * @param filelist Iterator
 * @param startDate Date
 * @param endDate Date
 * @return Iterator
 */
private Vector filterFilesByDate(Iterator filelist,Date startDate,Date endDate){
  if (startDate == null && endDate == null) {
    Vector result=new Vector();
    while (filelist.hasNext()) {
      result.add(filelist.next());
    }
    return result;
  }
  TreeSet files=new TreeSet();
  while (filelist.hasNext()) {
    String filename=(String)filelist.next();
    files.add(Long.parseLong(filename.substring(0,filename.length() - 4)));
  }
  TreeSet resultAsLong=new TreeSet();
  if (files.size() == 0) {
    Vector result=new Vector();
    Iterator iter=resultAsLong.iterator();
    while (iter.hasNext()) {
      Long item=(Long)iter.next();
      result.add(item.toString() + ""String_Node_Str"");
    }
    return result;
  }
  if (startDate == null) {
    Long endLong=Long.valueOf(endDate.getTime());
    files.add(endLong);
    resultAsLong.addAll(files.subSet(files.first(),endLong));
    resultAsLong.remove(endLong);
  }
 else   if (endDate == null) {
    Long startLong=Long.valueOf(startDate.getTime());
    if (files.size() > 0 && (startLong.longValue() < ((Long)files.first()).longValue())) {
      resultAsLong=files;
    }
 else {
      files.add(startLong);
      resultAsLong.addAll(files.subSet(startLong,files.last()));
      resultAsLong.add(files.last());
      resultAsLong.add(files.subSet(files.first(),startLong).last());
      resultAsLong.remove(startLong);
    }
  }
 else {
    Long startLong=Long.valueOf(startDate.getTime());
    Long endLong=Long.valueOf(endDate.getTime());
    files.add(startLong);
    files.add(endLong);
    resultAsLong.addAll(files.subSet(startLong,endLong));
    SortedSet theFirstToStart=files.subSet(files.first(),startLong);
    if (!theFirstToStart.isEmpty())     resultAsLong.add(theFirstToStart.last());
    resultAsLong.remove(startLong);
    resultAsLong.remove(endLong);
  }
  Vector result=new Vector();
  Iterator iter=resultAsLong.iterator();
  while (iter.hasNext()) {
    Long item=(Long)iter.next();
    result.add(item.toString() + ""String_Node_Str"");
  }
  return result;
}","/** 
 * Used to limit the files if any starting or ending date exist So only few files to be searched.
 * @param filelist Iterator
 * @param startDate Date
 * @param endDate Date
 * @return Iterator
 */
private Vector<String> filterFilesByDate(Iterator<String> filelist,Date startDate,Date endDate){
  if (startDate == null && endDate == null) {
    Vector<String> result=new Vector<String>();
    while (filelist.hasNext()) {
      result.add(filelist.next());
    }
    return result;
  }
  TreeSet<Long> files=new TreeSet<Long>();
  while (filelist.hasNext()) {
    String filename=(String)filelist.next();
    files.add(Long.parseLong(filename.substring(0,filename.length() - 4)));
  }
  TreeSet<Long> resultAsLong=new TreeSet<Long>();
  if (files.size() == 0) {
    Vector<String> result=new Vector<String>();
    Iterator<Long> iter=resultAsLong.iterator();
    while (iter.hasNext()) {
      Long item=(Long)iter.next();
      result.add(item.toString() + ""String_Node_Str"");
    }
    return result;
  }
  if (startDate == null) {
    Long endLong=Long.valueOf(endDate.getTime());
    files.add(endLong);
    resultAsLong.addAll(files.subSet(files.first(),endLong));
    resultAsLong.remove(endLong);
  }
 else   if (endDate == null) {
    Long startLong=Long.valueOf(startDate.getTime());
    if (files.size() > 0 && (startLong.longValue() < ((Long)files.first()).longValue())) {
      resultAsLong=files;
    }
 else {
      files.add(startLong);
      resultAsLong.addAll(files.subSet(startLong,files.last()));
      resultAsLong.add(files.last());
      resultAsLong.add(files.subSet(files.first(),startLong).last());
      resultAsLong.remove(startLong);
    }
  }
 else {
    Long startLong=Long.valueOf(startDate.getTime());
    Long endLong=Long.valueOf(endDate.getTime());
    files.add(startLong);
    files.add(endLong);
    resultAsLong.addAll(files.subSet(startLong,endLong));
    SortedSet<Long> theFirstToStart=files.subSet(files.first(),startLong);
    if (!theFirstToStart.isEmpty())     resultAsLong.add(theFirstToStart.last());
    resultAsLong.remove(startLong);
    resultAsLong.remove(endLong);
  }
  Vector<String> result=new Vector<String>();
  Iterator<Long> iter=resultAsLong.iterator();
  while (iter.hasNext()) {
    Long item=iter.next();
    result.add(item.toString() + ""String_Node_Str"");
  }
  return result;
}",0.9756627553237722
104155,"/** 
 * Returns the supplied number of recent messages after the given date
 * @param date messages after date
 * @param count messages count
 * @return QueryResultSet the found records
 * @throws RuntimeException
 */
public QueryResultSet findFirstRecordsAfter(Date date,int count) throws RuntimeException {
  TreeSet result=new TreeSet(new HistoryRecordComparator());
  Vector filelist=filterFilesByDate(this.historyImpl.getFileList(),date,null);
  int leftCount=count;
  int currentFile=0;
  while (leftCount > 0 && currentFile < filelist.size()) {
    Document doc=this.historyImpl.getDocumentForFile((String)filelist.get(currentFile));
    if (doc == null) {
      currentFile++;
      continue;
    }
    NodeList nodes=doc.getElementsByTagName(""String_Node_Str"");
    Node node;
    for (int i=0; i < nodes.getLength() && leftCount > 0; i++) {
      node=nodes.item(i);
      NodeList propertyNodes=node.getChildNodes();
      String ts=node.getAttributes().getNamedItem(""String_Node_Str"").getNodeValue();
      Date timestamp=new Date(Long.parseLong(ts));
      if (!isInPeriod(timestamp,date,null))       continue;
      ArrayList nameVals=new ArrayList();
      boolean isRecordOK=true;
      int len=propertyNodes.getLength();
      for (int j=0; j < len; j++) {
        Node propertyNode=propertyNodes.item(j);
        if (propertyNode.getNodeType() == Node.ELEMENT_NODE) {
          Node nodeValue=propertyNode.getFirstChild();
          if (nodeValue != null) {
            nameVals.add(propertyNode.getNodeName());
            nameVals.add(nodeValue.getNodeValue());
          }
 else           isRecordOK=false;
        }
      }
      if (!isRecordOK)       continue;
      String[] propertyNames=new String[nameVals.size() / 2];
      String[] propertyValues=new String[propertyNames.length];
      for (int j=0; j < propertyNames.length; j++) {
        propertyNames[j]=(String)nameVals.get(j * 2);
        propertyValues[j]=(String)nameVals.get(j * 2 + 1);
      }
      HistoryRecord record=new HistoryRecord(propertyNames,propertyValues,timestamp);
      result.add(record);
      leftCount--;
    }
    currentFile++;
  }
  return new OrderedQueryResultSet(result);
}","/** 
 * Returns the supplied number of recent messages after the given date
 * @param date messages after date
 * @param count messages count
 * @return QueryResultSet the found records
 * @throws RuntimeException
 */
public QueryResultSet findFirstRecordsAfter(Date date,int count) throws RuntimeException {
  TreeSet<HistoryRecord> result=new TreeSet<HistoryRecord>(new HistoryRecordComparator());
  Vector<String> filelist=filterFilesByDate(this.historyImpl.getFileList(),date,null);
  int leftCount=count;
  int currentFile=0;
  while (leftCount > 0 && currentFile < filelist.size()) {
    Document doc=this.historyImpl.getDocumentForFile((String)filelist.get(currentFile));
    if (doc == null) {
      currentFile++;
      continue;
    }
    NodeList nodes=doc.getElementsByTagName(""String_Node_Str"");
    Node node;
    for (int i=0; i < nodes.getLength() && leftCount > 0; i++) {
      node=nodes.item(i);
      NodeList propertyNodes=node.getChildNodes();
      String ts=node.getAttributes().getNamedItem(""String_Node_Str"").getNodeValue();
      Date timestamp=new Date(Long.parseLong(ts));
      if (!isInPeriod(timestamp,date,null))       continue;
      ArrayList<String> nameVals=new ArrayList<String>();
      boolean isRecordOK=true;
      int len=propertyNodes.getLength();
      for (int j=0; j < len; j++) {
        Node propertyNode=propertyNodes.item(j);
        if (propertyNode.getNodeType() == Node.ELEMENT_NODE) {
          Node nodeValue=propertyNode.getFirstChild();
          if (nodeValue != null) {
            nameVals.add(propertyNode.getNodeName());
            nameVals.add(nodeValue.getNodeValue());
          }
 else           isRecordOK=false;
        }
      }
      if (!isRecordOK)       continue;
      String[] propertyNames=new String[nameVals.size() / 2];
      String[] propertyValues=new String[propertyNames.length];
      for (int j=0; j < propertyNames.length; j++) {
        propertyNames[j]=(String)nameVals.get(j * 2);
        propertyValues[j]=(String)nameVals.get(j * 2 + 1);
      }
      HistoryRecord record=new HistoryRecord(propertyNames,propertyValues,timestamp);
      result.add(record);
      leftCount--;
    }
    currentFile++;
  }
  return new OrderedQueryResultSet(result);
}",0.9878213802435724
104156,"/** 
 * Initializes this chat room dialog.
 */
private void init(){
  ChatRoomListUI chatRoomsListUI=new ChatRoomListUI(this);
  JButton createChatRoomButton=new JButton(GuiActivator.getResources().getI18NString(CREATE_CHAT_ROOM));
  JButton joinChatRoomButton=new JButton(GuiActivator.getResources().getI18NString(JOIN_CHAT_ROOM));
  JButton cancelButton=new JButton(GuiActivator.getResources().getI18NString(CLOSE_CHAT_ROOM_DIALOG));
  TransparentPanel buttonPanel=new TransparentPanel();
  this.setTitle(GuiActivator.getResources().getI18NString(MY_CHAT_ROOMS));
  this.getContentPane().add(buttonPanel,BorderLayout.SOUTH);
  this.getContentPane().add(chatRoomsListUI,BorderLayout.CENTER);
  buttonPanel.add(joinChatRoomButton);
  buttonPanel.add(createChatRoomButton);
  buttonPanel.add(cancelButton);
  createChatRoomButton.addActionListener(this);
  joinChatRoomButton.addActionListener(this);
  cancelButton.addActionListener(this);
  createChatRoomButton.setName(CREATE_CHAT_ROOM);
  joinChatRoomButton.setName(JOIN_CHAT_ROOM);
  cancelButton.setName(CLOSE_CHAT_ROOM_DIALOG);
  createChatRoomButton.setMnemonic(GuiActivator.getResources().getI18nMnemonic(CREATE_CHAT_ROOM));
  joinChatRoomButton.setMnemonic(GuiActivator.getResources().getI18nMnemonic(JOIN_CHAT_ROOM));
  cancelButton.setMnemonic(GuiActivator.getResources().getI18nMnemonic(CLOSE_CHAT_ROOM_DIALOG));
}","/** 
 * Initializes this chat room dialog.
 */
private void init(){
  ChatRoomListUI chatRoomsListUI=new ChatRoomListUI(this);
  JButton createChatRoomButton=new JButton(GuiActivator.getResources().getI18NString(CREATE_CHAT_ROOM));
  JButton joinChatRoomButton=new JButton(GuiActivator.getResources().getI18NString(JOIN_CHAT_ROOM));
  TransparentPanel buttonPanel=new TransparentPanel();
  this.setTitle(GuiActivator.getResources().getI18NString(MY_CHAT_ROOMS));
  this.getContentPane().add(buttonPanel,BorderLayout.SOUTH);
  this.getContentPane().add(chatRoomsListUI,BorderLayout.CENTER);
  buttonPanel.add(joinChatRoomButton);
  buttonPanel.add(createChatRoomButton);
  createChatRoomButton.addActionListener(this);
  joinChatRoomButton.addActionListener(this);
  createChatRoomButton.setName(CREATE_CHAT_ROOM);
  joinChatRoomButton.setName(JOIN_CHAT_ROOM);
  createChatRoomButton.setMnemonic(GuiActivator.getResources().getI18nMnemonic(CREATE_CHAT_ROOM));
  joinChatRoomButton.setMnemonic(GuiActivator.getResources().getI18nMnemonic(JOIN_CHAT_ROOM));
}",0.4385026737967914
104157,"/** 
 * Handles <tt>ActionEvent</tt>s triggered by a button click.
 */
public void actionPerformed(ActionEvent e){
  JButton sourceButton=(JButton)e.getSource();
  String buttonName=sourceButton.getName();
  if (buttonName.equals(CREATE_CHAT_ROOM)) {
    CreateChatRoomWizard createChatRoomWizard=new CreateChatRoomWizard(mainFrame);
    createChatRoomWizard.showDialog(false);
  }
 else   if (buttonName.equals(JOIN_CHAT_ROOM)) {
    JoinChatRoomWizard joinChatRoomWizard=new JoinChatRoomWizard(mainFrame);
    joinChatRoomWizard.showDialog(false);
  }
 else   if (buttonName.equals(CLOSE_CHAT_ROOM_DIALOG)) {
    this.dispose();
  }
}","/** 
 * Handles <tt>ActionEvent</tt>s triggered by a button click.
 */
public void actionPerformed(ActionEvent e){
  JButton sourceButton=(JButton)e.getSource();
  String buttonName=sourceButton.getName();
  if (buttonName.equals(CREATE_CHAT_ROOM)) {
    CreateChatRoomWizard createChatRoomWizard=new CreateChatRoomWizard(mainFrame);
    createChatRoomWizard.showDialog(false);
  }
 else   if (buttonName.equals(JOIN_CHAT_ROOM)) {
    JoinChatRoomWizard joinChatRoomWizard=new JoinChatRoomWizard(mainFrame);
    joinChatRoomWizard.showDialog(false);
  }
}",0.9319899244332494
104158,"/** 
 * Creates a vector containing SDP descriptions of media types and formats that we support. If the offerVector is non null
 * @param offerMediaDescs the media descriptions sent by the offerer (couldbe null).
 * @param publicAudioAddress the <tt>InetSocketAddress</tt> that we shouldbe using for sending audio.
 * @param publicVideoAddress the <tt>InetSocketAddress</tt> that we shouldbe using for sending video.
 * @return a <tt>Vector</tt> containing media descriptions that we supportand (if this is an answer to an offer) that the offering <tt>CallParticipant</tt> supports as well.
 * @throws SdpException we fail creating the media descriptions
 * @throws MediaException with code UNSUPPORTED_FORMAT_SET_ERROR if we don'tsupport any of the offered media formats.
 */
private Vector<MediaDescription> createMediaDescriptions(Vector<MediaDescription> offerMediaDescs,InetSocketAddress publicAudioAddress,InetSocketAddress publicVideoAddress) throws SdpException, MediaException {
  MediaControl mediaControl=mediaServCallback.getMediaControl(getCall());
  String[] supportedAudioEncodings=mediaControl.getSupportedAudioEncodings();
  String[] supportedVideoEncodings=mediaControl.getSupportedVideoEncodings();
  if (offerMediaDescs != null && offerMediaDescs.size() > 0) {
    Vector<String> offeredVideoEncodings=new Vector<String>();
    Vector<String> offeredAudioEncodings=new Vector<String>();
    for (    MediaDescription desc : offerMediaDescs) {
      Media media=desc.getMedia();
      String mediaType=media.getMediaType();
      if (mediaType.equalsIgnoreCase(""String_Node_Str"")) {
        offeredVideoEncodings=media.getMediaFormats(true);
      }
 else       if (mediaType.equalsIgnoreCase(""String_Node_Str"")) {
        offeredAudioEncodings=media.getMediaFormats(true);
      }
    }
    Hashtable<String,List<String>> encodings=new Hashtable<String,List<String>>(2);
    encodings.put(""String_Node_Str"",offeredAudioEncodings);
    encodings.put(""String_Node_Str"",offeredVideoEncodings);
    encodings=intersectMediaEncodings(encodings);
    List<String> intersectedAudioEncsList=encodings.get(""String_Node_Str"");
    List<String> intersectedVideoEncsList=encodings.get(""String_Node_Str"");
    supportedAudioEncodings=intersectedAudioEncsList.toArray(new String[0]);
    supportedVideoEncodings=intersectedVideoEncsList.toArray(new String[0]);
  }
  Vector<MediaDescription> mediaDescs=new Vector<MediaDescription>();
  if (supportedAudioEncodings.length > 0) {
    MediaDescription am=mediaServCallback.getSdpFactory().createMediaDescription(""String_Node_Str"",publicAudioAddress.getPort(),1,""String_Node_Str"",supportedAudioEncodings);
    String g723Str=String.valueOf(SdpConstants.G723);
    for (    String supportedAudioEncoding : supportedAudioEncodings) {
      if (supportedAudioEncoding.equals(g723Str)) {
        am.setAttribute(""String_Node_Str"",""String_Node_Str"");
        am.setAttribute(""String_Node_Str"",""String_Node_Str"");
      }
    }
    byte onHold=this.onHold;
    if (!mediaServCallback.getDeviceConfiguration().isAudioCaptureSupported()) {
      onHold|=ON_HOLD_REMOTELY;
    }
    setAttributeOnHold(am,onHold);
    TransformConnector transConnector=this.transConnectors.get(audioRtpManager);
    if (transConnector != null) {
      TransformEngine engine=transConnector.getEngine();
      if (engine instanceof ZRTPTransformEngine) {
        ZRTPTransformEngine ze=(ZRTPTransformEngine)engine;
        String helloHash=ze.getHelloHash();
        if (helloHash != null && helloHash.length() > 0)         am.setAttribute(""String_Node_Str"",ze.getHelloHash());
      }
    }
    mediaDescs.add(am);
  }
  if (mediaServCallback.getDeviceConfiguration().isVideoCaptureSupported() && supportedVideoEncodings.length > 0) {
    MediaDescription vm=mediaServCallback.getSdpFactory().createMediaDescription(""String_Node_Str"",publicVideoAddress.getPort(),1,""String_Node_Str"",supportedVideoEncodings);
    String h264Str=String.valueOf(Constants.H264_RTP_SDP);
    for (    String supportedVideoEncoding : supportedVideoEncodings) {
      if (supportedVideoEncoding.equals(h264Str)) {
        vm.setAttribute(""String_Node_Str"",Constants.H264_RTP_SDP + ""String_Node_Str"");
        vm.setAttribute(""String_Node_Str"",Constants.H264_RTP_SDP + ""String_Node_Str"");
      }
    }
    byte onHold=this.onHold;
    if (!mediaControl.isLocalVideoAllowed()) {
      onHold|=ON_HOLD_REMOTELY;
    }
    setAttributeOnHold(vm,onHold);
    TransformConnector transConnector=this.transConnectors.get(videoRtpManager);
    if (transConnector != null) {
      TransformEngine engine=transConnector.getEngine();
      if (engine instanceof ZRTPTransformEngine) {
        ZRTPTransformEngine ze=(ZRTPTransformEngine)engine;
        String helloHash=ze.getHelloHash();
        if (helloHash != null && helloHash.length() > 0)         vm.setAttribute(""String_Node_Str"",ze.getHelloHash());
      }
    }
    mediaDescs.add(vm);
  }
  return mediaDescs;
}","/** 
 * Creates a vector containing SDP descriptions of media types and formats that we support. If the offerVector is non null
 * @param offerMediaDescs the media descriptions sent by the offerer (couldbe null).
 * @param publicAudioAddress the <tt>InetSocketAddress</tt> that we shouldbe using for sending audio.
 * @param publicVideoAddress the <tt>InetSocketAddress</tt> that we shouldbe using for sending video.
 * @return a <tt>Vector</tt> containing media descriptions that we supportand (if this is an answer to an offer) that the offering <tt>CallParticipant</tt> supports as well.
 * @throws SdpException we fail creating the media descriptions
 * @throws MediaException with code UNSUPPORTED_FORMAT_SET_ERROR if we don'tsupport any of the offered media formats.
 */
private Vector<MediaDescription> createMediaDescriptions(Vector<MediaDescription> offerMediaDescs,InetSocketAddress publicAudioAddress,InetSocketAddress publicVideoAddress) throws SdpException, MediaException {
  MediaControl mediaControl=mediaServCallback.getMediaControl(getCall());
  String[] supportedAudioEncodings=mediaControl.getSupportedAudioEncodings();
  String[] supportedVideoEncodings=mediaControl.getSupportedVideoEncodings();
  if (offerMediaDescs != null && offerMediaDescs.size() > 0) {
    Vector<String> offeredVideoEncodings=new Vector<String>();
    Vector<String> offeredAudioEncodings=new Vector<String>();
    for (    MediaDescription desc : offerMediaDescs) {
      Media media=desc.getMedia();
      String mediaType=media.getMediaType();
      if (mediaType.equalsIgnoreCase(""String_Node_Str"")) {
        offeredVideoEncodings=media.getMediaFormats(true);
      }
 else       if (mediaType.equalsIgnoreCase(""String_Node_Str"")) {
        offeredAudioEncodings=media.getMediaFormats(true);
      }
    }
    Hashtable<String,List<String>> encodings=new Hashtable<String,List<String>>(2);
    encodings.put(""String_Node_Str"",offeredAudioEncodings);
    encodings.put(""String_Node_Str"",offeredVideoEncodings);
    encodings=intersectMediaEncodings(encodings);
    List<String> intersectedAudioEncsList=encodings.get(""String_Node_Str"");
    List<String> intersectedVideoEncsList=encodings.get(""String_Node_Str"");
    supportedAudioEncodings=intersectedAudioEncsList.toArray(new String[0]);
    supportedVideoEncodings=intersectedVideoEncsList.toArray(new String[0]);
  }
  Vector<MediaDescription> mediaDescs=new Vector<MediaDescription>();
  if (supportedAudioEncodings.length > 0) {
    MediaDescription am=mediaServCallback.getSdpFactory().createMediaDescription(""String_Node_Str"",publicAudioAddress.getPort(),1,""String_Node_Str"",supportedAudioEncodings);
    String g723Str=String.valueOf(SdpConstants.G723);
    for (    String supportedAudioEncoding : supportedAudioEncodings) {
      if (supportedAudioEncoding.equals(g723Str)) {
        am.setAttribute(""String_Node_Str"",""String_Node_Str"");
        am.setAttribute(""String_Node_Str"",""String_Node_Str"");
      }
    }
    byte onHold=this.onHold;
    if (!mediaServCallback.getDeviceConfiguration().isAudioCaptureSupported()) {
      onHold|=ON_HOLD_REMOTELY;
    }
    setAttributeOnHold(am,onHold);
    TransformConnector transConnector=this.transConnectors.get(audioRtpManager);
    if (transConnector != null) {
      TransformEngine engine=transConnector.getEngine();
      if (engine instanceof ZRTPTransformEngine) {
        ZRTPTransformEngine ze=(ZRTPTransformEngine)engine;
        String helloHash=ze.getHelloHash();
        if (helloHash != null && helloHash.length() > 0)         am.setAttribute(""String_Node_Str"",ze.getHelloHash());
      }
    }
    mediaDescs.add(am);
  }
  if (supportedVideoEncodings.length > 0) {
    MediaDescription vm=mediaServCallback.getSdpFactory().createMediaDescription(""String_Node_Str"",publicVideoAddress.getPort(),1,""String_Node_Str"",supportedVideoEncodings);
    String h264Str=String.valueOf(Constants.H264_RTP_SDP);
    for (    String supportedVideoEncoding : supportedVideoEncodings) {
      if (supportedVideoEncoding.equals(h264Str)) {
        vm.setAttribute(""String_Node_Str"",Constants.H264_RTP_SDP + ""String_Node_Str"");
        vm.setAttribute(""String_Node_Str"",Constants.H264_RTP_SDP + ""String_Node_Str"");
      }
    }
    byte onHold=this.onHold;
    if (!mediaServCallback.getDeviceConfiguration().isVideoCaptureSupported() || !mediaControl.isLocalVideoAllowed()) {
      onHold|=ON_HOLD_REMOTELY;
    }
    setAttributeOnHold(vm,onHold);
    TransformConnector transConnector=this.transConnectors.get(videoRtpManager);
    if (transConnector != null) {
      TransformEngine engine=transConnector.getEngine();
      if (engine instanceof ZRTPTransformEngine) {
        ZRTPTransformEngine ze=(ZRTPTransformEngine)engine;
        String helloHash=ze.getHelloHash();
        if (helloHash != null && helloHash.length() > 0)         vm.setAttribute(""String_Node_Str"",ze.getHelloHash());
      }
    }
    mediaDescs.add(vm);
  }
  return mediaDescs;
}",0.9854021947045204
104159,"/** 
 * Handle incoming message by creating an appropriate Sip Communicator <tt>Message</tt> and firing a <tt>MessageReceivedEvent</tt> to interested listeners.
 * @param ev The original <tt>SessionEvent</tt> which noticed usof an incoming message.
 */
private void handleNewMessage(SessionEvent ev){
  logger.debug(""String_Node_Str"" + ev);
  String formattedMessage=ev.getMessage();
  logger.debug(""String_Node_Str"" + formattedMessage);
  if (formattedMessage.startsWith(""String_Node_Str"")) {
    formattedMessage=processLinks(messageDecoder.decodeToHTML(formattedMessage));
  }
 else {
    formattedMessage=processLinks(formattedMessage);
  }
  formattedMessage=formattedMessage.replaceAll(""String_Node_Str"",""String_Node_Str"");
  formattedMessage=formattedMessage.replaceAll(""String_Node_Str"",""String_Node_Str"");
  logger.debug(""String_Node_Str"" + formattedMessage);
  Message newMessage=createMessage(formattedMessage,HTML_MIME_TYPE,DEFAULT_MIME_ENCODING,null);
  Contact sourceContact=opSetPersPresence.findContactByID(ev.getFrom());
  if (sourceContact == null) {
    logger.debug(""String_Node_Str"" + ev.getFrom());
    sourceContact=opSetPersPresence.createVolatileContact(ev.getFrom());
  }
  MessageReceivedEvent msgReceivedEvt=new MessageReceivedEvent(newMessage,sourceContact,new Date());
  fireMessageEvent(msgReceivedEvt);
}","/** 
 * Handle incoming message by creating an appropriate Sip Communicator <tt>Message</tt> and firing a <tt>MessageReceivedEvent</tt> to interested listeners.
 * @param ev The original <tt>SessionEvent</tt> which noticed usof an incoming message.
 */
private void handleNewMessage(SessionEvent ev){
  logger.debug(""String_Node_Str"" + ev);
  String formattedMessage=ev.getMessage();
  logger.debug(""String_Node_Str"" + formattedMessage);
  formattedMessage=processLinks(messageDecoder.decodeToHTML(formattedMessage));
  formattedMessage=formattedMessage.replaceAll(""String_Node_Str"",""String_Node_Str"");
  formattedMessage=formattedMessage.replaceAll(""String_Node_Str"",""String_Node_Str"");
  logger.debug(""String_Node_Str"" + formattedMessage);
  Message newMessage=createMessage(formattedMessage,HTML_MIME_TYPE,DEFAULT_MIME_ENCODING,null);
  Contact sourceContact=opSetPersPresence.findContactByID(ev.getFrom());
  if (sourceContact == null) {
    logger.debug(""String_Node_Str"" + ev.getFrom());
    sourceContact=opSetPersPresence.createVolatileContact(ev.getFrom());
  }
  MessageReceivedEvent msgReceivedEvt=new MessageReceivedEvent(newMessage,sourceContact,new Date());
  fireMessageEvent(msgReceivedEvt);
}",0.950098231827112
104160,"/** 
 * Sends the <tt>message</tt> to the destination indicated by the <tt>to</tt> contact.
 * @param to the <tt>Contact</tt> to send <tt>message</tt> to
 * @param message the <tt>Message</tt> to send.
 * @throws java.lang.IllegalStateException if the underlying stack isnot registered and initialized.
 * @throws java.lang.IllegalArgumentException if <tt>to</tt> is not aninstance of ContactImpl.
 */
public void sendInstantMessage(Contact to,Message message) throws IllegalStateException, IllegalArgumentException {
  assertConnected();
  if (!(to instanceof ContactYahooImpl))   throw new IllegalArgumentException(""String_Node_Str"" + to);
  try {
    String toUserID=((ContactYahooImpl)to).getID();
    byte[] msgBytesToBeSent=message.getContent().getBytes();
    do {
      if (msgBytesToBeSent.length > MAX_MESSAGE_LENGTH) {
        byte[] tmp1=new byte[MAX_MESSAGE_LENGTH];
        System.arraycopy(msgBytesToBeSent,0,tmp1,0,MAX_MESSAGE_LENGTH);
        byte[] tmp2=new byte[msgBytesToBeSent.length - MAX_MESSAGE_LENGTH];
        System.arraycopy(msgBytesToBeSent,MAX_MESSAGE_LENGTH,tmp2,0,tmp2.length);
        msgBytesToBeSent=tmp2;
        yahooProvider.getYahooSession().sendMessage(toUserID,new String(tmp1));
      }
 else {
        yahooProvider.getYahooSession().sendMessage(toUserID,new String(msgBytesToBeSent));
      }
      MessageDeliveredEvent msgDeliveredEvt=new MessageDeliveredEvent(message,to,new Date());
      fireMessageEvent(msgDeliveredEvt);
    }
 while (msgBytesToBeSent.length > MAX_MESSAGE_LENGTH);
  }
 catch (  IOException ex) {
    logger.fatal(""String_Node_Str"" + ex.getMessage());
    MessageDeliveryFailedEvent evt=new MessageDeliveryFailedEvent(message,to,MessageDeliveryFailedEvent.NETWORK_FAILURE,new Date());
    fireMessageEvent(evt);
    return;
  }
}","/** 
 * Sends the <tt>message</tt> to the destination indicated by the <tt>to</tt> contact.
 * @param to the <tt>Contact</tt> to send <tt>message</tt> to
 * @param message the <tt>Message</tt> to send.
 * @throws java.lang.IllegalStateException if the underlying stack isnot registered and initialized.
 * @throws java.lang.IllegalArgumentException if <tt>to</tt> is not aninstance of ContactImpl.
 */
public void sendInstantMessage(Contact to,Message message) throws IllegalStateException, IllegalArgumentException {
  assertConnected();
  if (!(to instanceof ContactYahooImpl))   throw new IllegalArgumentException(""String_Node_Str"" + to);
  try {
    String toUserID=((ContactYahooImpl)to).getID();
    byte[] msgBytesToBeSent=message.getContent().trim().getBytes();
    do {
      if (msgBytesToBeSent.length > MAX_MESSAGE_LENGTH) {
        byte[] tmp1=new byte[MAX_MESSAGE_LENGTH];
        System.arraycopy(msgBytesToBeSent,0,tmp1,0,MAX_MESSAGE_LENGTH);
        byte[] tmp2=new byte[msgBytesToBeSent.length - MAX_MESSAGE_LENGTH];
        System.arraycopy(msgBytesToBeSent,MAX_MESSAGE_LENGTH,tmp2,0,tmp2.length);
        msgBytesToBeSent=tmp2;
        yahooProvider.getYahooSession().sendMessage(toUserID,new String(tmp1));
      }
 else {
        yahooProvider.getYahooSession().sendMessage(toUserID,new String(msgBytesToBeSent));
      }
      MessageDeliveredEvent msgDeliveredEvt=new MessageDeliveredEvent(message,to,new Date());
      fireMessageEvent(msgDeliveredEvt);
    }
 while (msgBytesToBeSent.length > MAX_MESSAGE_LENGTH);
  }
 catch (  IOException ex) {
    logger.fatal(""String_Node_Str"" + ex.getMessage());
    MessageDeliveryFailedEvent evt=new MessageDeliveryFailedEvent(message,to,MessageDeliveryFailedEvent.NETWORK_FAILURE,new Date());
    fireMessageEvent(evt);
    return;
  }
}",0.9980560955290196
104161,"/** 
 * Handler for incoming authorization requests.
 * @param handler an instance of an AuthorizationHandler forauthorization requests coming from other users requesting permission add us to their contact list.
 */
public void setAuthorizationHandler(AuthorizationHandler handler){
  ssContactList.setAuthorizationHandler(handler);
}","/** 
 * Handler for incoming authorization requests.
 * @param handler an instance of an AuthorizationHandler forauthorization requests coming from other users requesting permission add us to their contact list.
 */
public void setAuthorizationHandler(AuthorizationHandler handler){
  ssContactList.setAuthorizationHandler(handler);
  if (earlyEventListener != null) {
    earlyEventListener.processEarlyAuthorizations();
    earlyEventListener=null;
  }
}",0.8455696202531645
104162,"/** 
 * The method is called by a ProtocolProvider implementation whenver a change in the registration state of the corresponding provider had occurred.
 * @param evt ProviderStatusChangeEvent the event describing the statuschange.
 */
public void registrationStateChanged(RegistrationStateChangeEvent evt){
  logger.debug(""String_Node_Str"" + evt.getOldState() + ""String_Node_Str""+ evt.getNewState());
  if (evt.getNewState() == RegistrationState.REGISTERED) {
    parentProvider.getYahooSession().addSessionListener(new StatusChangedListener());
    ssContactList.setYahooSession(parentProvider.getYahooSession());
    initContactStatuses();
    addSubscriptionListener(statusUpdater);
  }
 else   if (evt.getNewState() == RegistrationState.UNREGISTERED || evt.getNewState() == RegistrationState.AUTHENTICATION_FAILED || evt.getNewState() == RegistrationState.CONNECTION_FAILED) {
    PresenceStatus oldStatus=currentStatus;
    currentStatus=YahooStatusEnum.OFFLINE;
    fireProviderPresenceStatusChangeEvent(oldStatus,currentStatus);
    removeSubscriptionListener(statusUpdater);
    Iterator groupsIter=getServerStoredContactListRoot().subgroups();
    while (groupsIter.hasNext()) {
      ContactGroupYahooImpl group=(ContactGroupYahooImpl)groupsIter.next();
      Iterator contactsIter=group.contacts();
      while (contactsIter.hasNext()) {
        ContactYahooImpl contact=(ContactYahooImpl)contactsIter.next();
        PresenceStatus oldContactStatus=contact.getPresenceStatus();
        if (!oldContactStatus.isOnline())         continue;
        contact.updatePresenceStatus(YahooStatusEnum.OFFLINE);
        fireContactPresenceStatusChangeEvent(contact,contact.getParentContactGroup(),oldContactStatus,YahooStatusEnum.OFFLINE);
      }
    }
  }
}","/** 
 * The method is called by a ProtocolProvider implementation whenver a change in the registration state of the corresponding provider had occurred.
 * @param evt ProviderStatusChangeEvent the event describing the statuschange.
 */
public void registrationStateChanged(RegistrationStateChangeEvent evt){
  logger.debug(""String_Node_Str"" + evt.getOldState() + ""String_Node_Str""+ evt.getNewState());
  if (evt.getNewState() == RegistrationState.REGISTERING) {
    earlyEventListener=new EarlyEventListener();
    parentProvider.getYahooSession().addSessionListener(earlyEventListener);
  }
 else   if (evt.getNewState() == RegistrationState.REGISTERED) {
    parentProvider.getYahooSession().addSessionListener(new StatusChangedListener());
    ssContactList.setYahooSession(parentProvider.getYahooSession());
    initContactStatuses();
    addSubscriptionListener(statusUpdater);
    if (earlyEventListener != null) {
      parentProvider.getYahooSession().removeSessionListener(earlyEventListener);
    }
  }
 else   if (evt.getNewState() == RegistrationState.UNREGISTERED || evt.getNewState() == RegistrationState.AUTHENTICATION_FAILED || evt.getNewState() == RegistrationState.CONNECTION_FAILED) {
    PresenceStatus oldStatus=currentStatus;
    currentStatus=YahooStatusEnum.OFFLINE;
    fireProviderPresenceStatusChangeEvent(oldStatus,currentStatus);
    removeSubscriptionListener(statusUpdater);
    Iterator groupsIter=getServerStoredContactListRoot().subgroups();
    while (groupsIter.hasNext()) {
      ContactGroupYahooImpl group=(ContactGroupYahooImpl)groupsIter.next();
      Iterator contactsIter=group.contacts();
      while (contactsIter.hasNext()) {
        ContactYahooImpl contact=(ContactYahooImpl)contactsIter.next();
        PresenceStatus oldContactStatus=contact.getPresenceStatus();
        if (!oldContactStatus.isOnline())         continue;
        contact.updatePresenceStatus(YahooStatusEnum.OFFLINE);
        fireContactPresenceStatusChangeEvent(contact,contact.getParentContactGroup(),oldContactStatus,YahooStatusEnum.OFFLINE);
      }
    }
    parentProvider.getYahooSession().removeSessionListener(earlyEventListener);
    earlyEventListener=null;
  }
}",0.8909688843916013
104163,"/** 
 * Creates a <tt>ChatPanel</tt> which is added to the given chat window.
 * @param chatWindow The parent window of this chat panel.
 */
public ChatPanel(ChatWindow chatWindow){
  super(new BorderLayout());
  this.chatWindow=chatWindow;
  this.conversationPanel=new ChatConversationPanel(this);
  this.sendPanel=new ChatSendPanel(this);
  this.writeMessagePanel=new ChatWritePanel(this);
  this.messagePane.setBorder(null);
  this.messagePane.setOpaque(false);
  this.messagePane.setResizeWeight(1.0D);
  this.writeMessagePanel.setPreferredSize(new Dimension(500,100));
  this.writeMessagePanel.setMinimumSize(new Dimension(500,100));
  this.conversationPanel.setPreferredSize(new Dimension(400,200));
  this.messagePane.setBottomComponent(writeMessagePanel);
  this.add(messagePane,BorderLayout.CENTER);
  this.add(sendPanel,BorderLayout.SOUTH);
  this.addComponentListener(new TabSelectionComponentListener());
}","/** 
 * Creates a <tt>ChatPanel</tt> which is added to the given chat window.
 * @param chatWindow The parent window of this chat panel.
 */
public ChatPanel(ChatWindow chatWindow){
  super(new BorderLayout());
  this.chatWindow=chatWindow;
  this.conversationPanel=new ChatConversationPanel(this);
  this.conversationPanel.setPreferredSize(new Dimension(400,200));
  this.sendPanel=new ChatSendPanel(this);
  this.writeMessagePanel=new ChatWritePanel(this);
  Dimension writeMessagePanelSize=new Dimension(500,100);
  this.writeMessagePanel.setMinimumSize(writeMessagePanelSize);
  this.writeMessagePanel.setPreferredSize(writeMessagePanelSize);
  this.messagePane.setBorder(null);
  this.messagePane.setOpaque(false);
  this.messagePane.setResizeWeight(1.0D);
  this.messagePane.setBottomComponent(writeMessagePanel);
  this.add(messagePane,BorderLayout.CENTER);
  this.add(sendPanel,BorderLayout.SOUTH);
  this.addComponentListener(new TabSelectionComponentListener());
}",0.7156448202959831
104164,"public void actionPerformed(ActionEvent e){
  SIPCommMenu contactSelector=transportSelectorBox.getMenu();
  contactSelector.doClick();
}","public void actionPerformed(ActionEvent e){
  transportSelectorBox.getMenu().doClick();
}",0.7911111111111111
104165,"public void setChatSession(ChatSession chatSession){
  this.chatSession=chatSession;
  if (chatSession instanceof MetaContactChatSession) {
    if (subjectPanel != null) {
      this.remove(subjectPanel);
      this.revalidate();
      this.repaint();
    }
    if (topSplitPane != null) {
      if (chatContactListPanel != null)       topSplitPane.remove(chatContactListPanel);
      this.messagePane.remove(topSplitPane);
    }
    this.messagePane.setTopComponent(conversationPanel);
    initChatTransportSelectorBox();
    if (!transportSelectorBox.getMenu().isEnabled()) {
      getChatConversationPanel().appendMessageToEnd(""String_Node_Str"" + GuiActivator.getResources().getI18NString(""String_Node_Str"") + ""String_Node_Str"");
    }
    ActionMap amap=this.getActionMap();
    amap.put(""String_Node_Str"",new ChangeTransportAction());
    InputMap imap=this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW);
    imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_P,KeyEvent.CTRL_DOWN_MASK),""String_Node_Str"");
  }
 else   if (chatSession instanceof ConferenceChatSession) {
    removeChatTransportSelectorBox();
    messagePane.remove(conversationPanel);
    this.chatContactListPanel=new ChatRoomMemberListPanel(this);
    this.chatContactListPanel.setPreferredSize(new Dimension(150,100));
    this.chatContactListPanel.setMinimumSize(new Dimension(150,100));
    this.chatContactListPanel.setOpaque(false);
    this.topSplitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT);
    this.topSplitPane.setBorder(null);
    this.topSplitPane.setResizeWeight(1.0D);
    this.topSplitPane.setOneTouchExpandable(true);
    topSplitPane.setLeftComponent(conversationPanel);
    this.messagePane.setTopComponent(topSplitPane);
    topSplitPane.setRightComponent(chatContactListPanel);
    topSplitPane.setOpaque(false);
    Iterator<ChatContact> chatParticipants=chatSession.getParticipants();
    while (chatParticipants.hasNext()) {
      ChatContact chatContact=chatParticipants.next();
      chatContactListPanel.addContact(chatContact);
    }
  }
  if (!chatSession.getCurrentChatTransport().allowsSmsMessage())   sendSmsCheckBox.setEnabled(false);
}","public void setChatSession(ChatSession chatSession){
  this.chatSession=chatSession;
  if ((this.chatSession != null) && this.chatSession.isContactListSupported()) {
    messagePane.remove(conversationPanel);
    this.chatContactListPanel=new ChatRoomMemberListPanel(this);
    Dimension chatContactPanelSize=new Dimension(150,100);
    this.chatContactListPanel.setMinimumSize(chatContactPanelSize);
    this.chatContactListPanel.setPreferredSize(chatContactPanelSize);
    this.chatContactListPanel.setOpaque(false);
    topSplitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT);
    topSplitPane.setBorder(null);
    topSplitPane.setOneTouchExpandable(true);
    topSplitPane.setOpaque(false);
    topSplitPane.setResizeWeight(1.0D);
    topSplitPane.setLeftComponent(conversationPanel);
    topSplitPane.setRightComponent(chatContactListPanel);
    messagePane.setTopComponent(topSplitPane);
  }
 else {
    if (topSplitPane != null) {
      if (chatContactListPanel != null) {
        topSplitPane.remove(chatContactListPanel);
        chatContactListPanel=null;
      }
      this.messagePane.remove(topSplitPane);
      topSplitPane=null;
    }
    this.messagePane.setTopComponent(conversationPanel);
  }
  if (chatSession instanceof MetaContactChatSession) {
    if (subjectPanel != null) {
      this.remove(subjectPanel);
      subjectPanel=null;
      this.revalidate();
      this.repaint();
    }
    initChatTransportSelectorBox();
    if (!transportSelectorBox.getMenu().isEnabled()) {
      getChatConversationPanel().appendMessageToEnd(""String_Node_Str"" + GuiActivator.getResources().getI18NString(""String_Node_Str"") + ""String_Node_Str"");
    }
    ActionMap amap=this.getActionMap();
    amap.put(""String_Node_Str"",new ChangeTransportAction());
    InputMap imap=this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW);
    imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_P,KeyEvent.CTRL_DOWN_MASK),""String_Node_Str"");
  }
 else   if (chatSession instanceof ConferenceChatSession) {
    removeChatTransportSelectorBox();
  }
  if (chatContactListPanel != null) {
    Iterator<ChatContact> chatParticipants=chatSession.getParticipants();
    while (chatParticipants.hasNext()) {
      chatContactListPanel.addContact(chatParticipants.next());
    }
  }
  if (!chatSession.getCurrentChatTransport().allowsSmsMessage())   sendSmsCheckBox.setEnabled(false);
}",0.4663856223652097
104166,"/** 
 * Returns the <tt>ChatContact</tt> corresponding to the given <tt>MetaContact</tt>.
 * @param metaContact the <tt>MetaContact</tt> to search for
 * @return the <tt>ChatContact</tt> corresponding to the given<tt>MetaContact</tt>.
 */
private ChatContact findChatContactByMetaContact(MetaContact metaContact){
  Iterator chatContactsIter=chatParticipants.iterator();
  while (chatContactsIter.hasNext()) {
    ChatContact chatContact=(ChatContact)chatContactsIter.next();
    Object chatSourceContact=chatContact.getDescriptor();
    MetaContact parentMetaContact=GuiActivator.getMetaContactListService().findMetaContactByContact((Contact)chatSourceContact);
    if (parentMetaContact != null && parentMetaContact.equals(metaContact))     return chatContact;
  }
  return null;
}","/** 
 * Returns the <tt>ChatContact</tt> corresponding to the given <tt>MetaContact</tt>.
 * @param metaContact the <tt>MetaContact</tt> to search for
 * @return the <tt>ChatContact</tt> corresponding to the given<tt>MetaContact</tt>.
 */
private ChatContact findChatContactByMetaContact(MetaContact metaContact){
  for (  ChatContact chatContact : chatParticipants) {
    Object chatSourceContact=chatContact.getDescriptor();
    MetaContact parentMetaContact=GuiActivator.getMetaContactListService().findMetaContactByContact((Contact)chatSourceContact);
    if (parentMetaContact != null && parentMetaContact.equals(metaContact))     return chatContact;
  }
  return null;
}",0.8814256339958876
104167,"/** 
 * Implements <tt>MetaContactListListener.protoContactMoved</tt> method. When a proto contact is moved, updates the ""send via"" selector box.
 */
public void protoContactMoved(ProtoContactEvent evt){
  MetaContactChatTransport chatTransport=null;
  if (evt.getOldParent().equals(metaContact)) {
    Iterator chatTransportsIter=chatTransports.iterator();
    while (chatTransportsIter.hasNext()) {
      chatTransport=(MetaContactChatTransport)chatTransportsIter.next();
      if (chatTransport.getContact().equals(evt.getProtoContact())) {
        sessionRenderer.removeChatTransport(chatTransport);
        break;
      }
    }
  }
 else   if (evt.getNewParent().equals(metaContact)) {
    chatTransport=new MetaContactChatTransport(this,evt.getProtoContact());
    sessionRenderer.addChatTransport(chatTransport);
  }
}","/** 
 * Implements <tt>MetaContactListListener.protoContactMoved</tt> method. When a proto contact is moved, updates the ""send via"" selector box.
 */
public void protoContactMoved(ProtoContactEvent evt){
  MetaContactChatTransport chatTransport=null;
  if (evt.getOldParent().equals(metaContact)) {
    protoContactRemoved(evt);
  }
 else   if (evt.getNewParent().equals(metaContact)) {
    chatTransport=new MetaContactChatTransport(this,evt.getProtoContact());
    sessionRenderer.addChatTransport(chatTransport);
  }
}",0.5898959881129272
104168,"/** 
 * Returns the ChatTransport corresponding to the given descriptor.
 * @param descriptor The descriptor of the chat transport we're looking for.
 * @return The ChatTransport corresponding to the given descriptor.
 */
public ChatTransport findChatTransportForDescriptor(Object descriptor){
  Iterator<ChatTransport> chatTransportsIter=chatTransports.iterator();
  while (chatTransportsIter.hasNext()) {
    ChatTransport chatTransport=chatTransportsIter.next();
    if (chatTransport.getDescriptor().equals(descriptor))     return chatTransport;
  }
  return null;
}","public static ChatTransport findChatTransportForDescriptor(Iterable<ChatTransport> chatTransports,Object descriptor){
  for (  ChatTransport chatTransport : chatTransports) {
    if (chatTransport.getDescriptor().equals(descriptor))     return chatTransport;
  }
  return null;
}",0.3156654888103651
104169,"/** 
 * Returns an iterator to the list of all participants contained in this  chat session.
 * @return an iterator to the list of all participants contained in this chat session.
 */
public Iterator getParticipants(){
  return chatParticipants.iterator();
}","/** 
 * Returns an iterator to the list of all participants contained in this  chat session.
 * @return an iterator to the list of all participants contained in this chat session.
 */
public Iterator<ChatContact> getParticipants(){
  return chatParticipants.iterator();
}",0.9754253308128544
104170,"/** 
 * Returns all available chat transports for this chat session. Each chat transport is corresponding to a protocol provider.
 * @return all available chat transports for this chat session.
 */
public Iterator getChatTransports(){
  return chatTransports.iterator();
}","/** 
 * Returns all available chat transports for this chat session. Each chat transport is corresponding to a protocol provider.
 * @return all available chat transports for this chat session.
 */
public Iterator<ChatTransport> getChatTransports(){
  return chatTransports.iterator();
}",0.9731663685152058
104171,"/** 
 * Disposes this chat session.
 */
public void dispose(){
  if (metaContactListService != null)   metaContactListService.removeMetaContactListListener(this);
  Iterator<ChatTransport> chatTransportsIter=chatTransports.iterator();
  while (chatTransportsIter.hasNext()) {
    ChatTransport chatTransport=chatTransportsIter.next();
    chatTransport.dispose();
  }
}","/** 
 * Disposes this chat session.
 */
public void dispose(){
  if (metaContactListService != null)   metaContactListService.removeMetaContactListListener(this);
  for (  ChatTransport chatTransport : chatTransports)   chatTransport.dispose();
}",0.6308943089430894
104172,"/** 
 * Implements <tt>MetaContactListListener.protoContactRemoved</tt> method. When a proto contact is removed, updates the ""send via"" selector box.
 */
public void protoContactRemoved(ProtoContactEvent evt){
  if (evt.getOldParent().equals(metaContact)) {
    Iterator chatTransportsIter=chatTransports.iterator();
    MetaContactChatTransport chatTransport=null;
    while (chatTransportsIter.hasNext()) {
      chatTransport=(MetaContactChatTransport)chatTransportsIter.next();
      if (chatTransport.getContact().equals(evt.getProtoContact())) {
        sessionRenderer.removeChatTransport(chatTransport);
        break;
      }
    }
  }
}","/** 
 * Implements <tt>MetaContactListListener.protoContactRemoved</tt> method. When a proto contact is removed, updates the ""send via"" selector box.
 */
public void protoContactRemoved(ProtoContactEvent evt){
  if (evt.getOldParent().equals(metaContact)) {
    Contact protoContact=evt.getProtoContact();
    for (    ChatTransport chatTransport : chatTransports) {
      if (((MetaContactChatTransport)chatTransport).getContact().equals(protoContact)) {
        sessionRenderer.removeChatTransport(chatTransport);
        break;
      }
    }
  }
}",0.6939799331103679
104173,"/** 
 * Returns a reference to a chatRoom named <tt>roomName</tt> or null if that room does not exist.
 * @param roomName the name of the <tt>ChatRoom</tt> that we're lookingfor.
 * @return the <tt>ChatRoom</tt> named <tt>roomName</tt> if it exists, nullotherwise.
 * @throws OperationFailedException if an error occurs while trying todiscover the room on the server.
 * @throws OperationNotSupportedException if the server does not supportmulti user chat
 */
public ChatRoom findRoom(String roomName) throws OperationFailedException, OperationNotSupportedException {
  assertSupportedAndConnected();
  String canonicalRoomName=getCanonicalRoomName(roomName);
  ChatRoom room=chatRoomCache.get(canonicalRoomName);
  if (room == null) {
    try {
      Collection<HostedRoom> co=MultiUserChat.getHostedRooms(getXmppConnection(),canonicalRoomName);
      for (      HostedRoom ho : co) {
        if (ho.getJid().equals(canonicalRoomName)) {
          MultiUserChat muc=new MultiUserChat(getXmppConnection(),canonicalRoomName);
          room=new ChatRoomJabberImpl(muc,jabberProvider);
          chatRoomCache.put(canonicalRoomName,room);
          break;
        }
      }
    }
 catch (    XMPPException ex) {
      if (!ex.getXMPPError().getCondition().equals(XMPPError.Condition.item_not_found.toString())) {
        MultiUserChat muc=new MultiUserChat(getXmppConnection(),canonicalRoomName);
        room=new ChatRoomJabberImpl(muc,jabberProvider);
        chatRoomCache.put(canonicalRoomName,room);
      }
      logger.debug(""String_Node_Str"" + canonicalRoomName + ""String_Node_Str"",ex);
    }
  }
  return room;
}","/** 
 * Returns a reference to a chatRoom named <tt>roomName</tt> or null if that room does not exist.
 * @param roomName the name of the <tt>ChatRoom</tt> that we're lookingfor.
 * @return the <tt>ChatRoom</tt> named <tt>roomName</tt> if it exists, nullotherwise.
 * @throws OperationFailedException if an error occurs while trying todiscover the room on the server.
 * @throws OperationNotSupportedException if the server does not supportmulti user chat
 */
public ChatRoom findRoom(String roomName) throws OperationFailedException, OperationNotSupportedException {
  assertSupportedAndConnected();
  String canonicalRoomName=getCanonicalRoomName(roomName);
  ChatRoom room=chatRoomCache.get(canonicalRoomName);
  if (room != null)   return room;
  try {
    RoomInfo infos=MultiUserChat.getRoomInfo(getXmppConnection(),canonicalRoomName);
    if (infos.getRoom().equals(canonicalRoomName)) {
      MultiUserChat muc=new MultiUserChat(getXmppConnection(),canonicalRoomName);
      room=new ChatRoomJabberImpl(muc,jabberProvider);
      chatRoomCache.put(canonicalRoomName,room);
      return room;
    }
  }
 catch (  XMPPException xe) {
    return null;
  }
catch (  NullPointerException ne) {
  }
  try {
    Collection<HostedRoom> co=MultiUserChat.getHostedRooms(getXmppConnection(),canonicalRoomName);
  }
 catch (  XMPPException xe) {
    if (xe.getXMPPError().getCondition().equals(XMPPError.Condition.item_not_found.toString())) {
      return null;
    }
 else {
      MultiUserChat muc=new MultiUserChat(getXmppConnection(),canonicalRoomName);
      room=new ChatRoomJabberImpl(muc,jabberProvider);
      chatRoomCache.put(canonicalRoomName,room);
      return room;
    }
  }
  return null;
}",0.799879626843214
104174,"/** 
 * Initializes this network address manager service implementation and starts all processes/threads associated with this address manager, such as a stun firewall/nat detector, keep alive threads, binding lifetime discovery threads and etc. The method may also be used after a call to stop() as a reinitialization technique.
 */
public void start(){
  String stunAddressStr=null;
  int port=-1;
  stunAddressStr=NetaddrActivator.getConfigurationService().getString(PROP_STUN_SERVER_ADDRESS);
  String portStr=NetaddrActivator.getConfigurationService().getString(PROP_STUN_SERVER_PORT);
  this.localHostFinderSocket=initRandomPortSocket();
  if (stunAddressStr == null || portStr == null) {
    useStun=false;
    stunServerAddress=new StunAddress(DEFAULT_STUN_SERVER_ADDRESS,DEFAULT_STUN_SERVER_PORT);
    logger.info(""String_Node_Str"" + stunAddressStr + ""String_Node_Str""+ portStr+ ""String_Node_Str"");
  }
 else {
    try {
      port=Integer.valueOf(portStr).intValue();
    }
 catch (    NumberFormatException ex) {
      logger.error(portStr + ""String_Node_Str"" + ""String_Node_Str"",ex);
      port=3478;
    }
    stunServerAddress=new StunAddress(stunAddressStr,port);
    detector=new SimpleAddressDetector(stunServerAddress);
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"" + ""String_Node_Str"" + stunAddressStr + ""String_Node_Str""+ port);
    }
    detector.start();
    logger.debug(""String_Node_Str"");
    NetaddrActivator.getConfigurationService().addVetoableChangeListener(PROP_STUN_SERVER_ADDRESS,this);
    NetaddrActivator.getConfigurationService().addVetoableChangeListener(PROP_STUN_SERVER_PORT,this);
    launchStunServerTest();
  }
}","/** 
 * Initializes this network address manager service implementation and starts all processes/threads associated with this address manager, such as a stun firewall/nat detector, keep alive threads, binding lifetime discovery threads and etc. The method may also be used after a call to stop() as a reinitialization technique.
 */
public void start(){
  String stunAddressStr=null;
  int port=-1;
  stunAddressStr=NetaddrActivator.getConfigurationService().getString(PROP_STUN_SERVER_ADDRESS);
  String portStr=NetaddrActivator.getConfigurationService().getString(PROP_STUN_SERVER_PORT);
  this.localHostFinderSocket=initRandomPortSocket();
  if (stunAddressStr == null || portStr == null) {
    useStun=false;
    logger.info(""String_Node_Str"" + stunAddressStr + ""String_Node_Str""+ portStr+ ""String_Node_Str"");
  }
 else {
    try {
      port=Integer.valueOf(portStr).intValue();
    }
 catch (    NumberFormatException ex) {
      logger.info(portStr + ""String_Node_Str"" + ""String_Node_Str"",ex);
      port=DEFAULT_STUN_SERVER_PORT;
    }
    stunServerAddress=new StunAddress(stunAddressStr,port);
    detector=new SimpleAddressDetector(stunServerAddress);
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"" + ""String_Node_Str"" + stunAddressStr + ""String_Node_Str""+ port);
    }
    detector.start();
    logger.debug(""String_Node_Str"");
    NetaddrActivator.getConfigurationService().addVetoableChangeListener(PROP_STUN_SERVER_ADDRESS,this);
    NetaddrActivator.getConfigurationService().addVetoableChangeListener(PROP_STUN_SERVER_PORT,this);
    launchStunServerTest();
  }
}",0.4713763702801462
104175,"/** 
 * Tries to obtain a mapped/public address for the specified port (possibly by executing a STUN query).
 * @param port the port whose mapping we are interested in.
 * @return a public address corresponding to the specified port or nullif all attempts to retrieve such an address have failed.
 * @throws IOException if an error occurs while stun4j is using sockets.
 * @throws BindException if the port is already in use.
 */
public InetSocketAddress getPublicAddressFor(int port) throws IOException, BindException {
  return getPublicAddressFor(this.stunServerAddress.getSocketAddress().getAddress(),port);
}","/** 
 * Tries to obtain a mapped/public address for the specified port (possibly by executing a STUN query).
 * @param dst the destination that we'd like to use this address with.
 * @param port the port whose mapping we are interested in.
 * @return a public address corresponding to the specified port or nullif all attempts to retrieve such an address have failed.
 * @throws IOException if an error occurs while stun4j is using sockets.
 * @throws BindException if the port is already in use.
 */
public InetSocketAddress getPublicAddressFor(InetAddress dst,int port) throws IOException, BindException {
  if (!useStun || (dst instanceof Inet6Address)) {
    logger.debug(""String_Node_Str"" + dst + ""String_Node_Str""+ useStun+ ""String_Node_Str""+ (dst instanceof Inet6Address)+ ""String_Node_Str"");
    DatagramSocket bindTestSocket=new DatagramSocket(port);
    bindTestSocket.close();
    return new InetSocketAddress(getLocalHost(dst),port);
  }
  StunAddress mappedAddress=queryStunServer(port);
  InetSocketAddress result=null;
  if (mappedAddress != null)   result=mappedAddress.getSocketAddress();
 else {
    InetAddress localHost=getLocalHost(dst);
    result=new InetSocketAddress(localHost,port);
  }
  if (logger.isDebugEnabled())   logger.debug(""String_Node_Str"" + port + ""String_Node_Str""+ result);
  return result;
}",0.5892030848329048
104176,"/** 
 * Tries to obtain a mapped/public address for the specified port (possibly by executing a STUN query).
 * @param port the port whose mapping we are interested in.
 * @return a public address corresponding to the specified port or nullif all attempts to retrieve such an address have failed.
 * @throws IOException if an error occurs while stun4j is using sockets.
 * @throws BindException if the port is already in use.
 */
public InetSocketAddress getPublicAddressFor(int port) throws IOException, BindException ;","/** 
 * Tries to obtain a mapped/public address for the specified port. If the STUN lib fails, tries to retrieve localhost, if that fails too, returns null.
 * @param intendedDestination the destination that we'd like to use thisaddress with.
 * @param port the port whose mapping we are interested in.
 * @return a public address corresponding to the specified port or null ifall attempts to retrieve such an address have failed.
 * @throws IOException if an error occurs while the underlying resolve libis using sockets.
 * @throws BindException if the port is already in use.
 */
public InetSocketAddress getPublicAddressFor(InetAddress intendedDestination,int port) throws IOException, BindException ;",0.7118367346938775
104177,"public Component getListCellRendererComponent(JList list,Object value,int index,boolean isSelected,boolean cellHasFocus){
  this.index=index;
  this.photoLabel.setIcon(null);
  ContactList contactList=(ContactList)list;
  ChatContact chatContact=(ChatContact)value;
  this.setPreferredSize(new Dimension(20,30));
  String displayName=chatContact.getName();
  if (displayName == null || displayName.length() < 1) {
    displayName=GuiActivator.getResources().getI18NString(""String_Node_Str"");
  }
  this.nameLabel.setFont(this.getFont().deriveFont(Font.PLAIN));
  this.nameLabel.setText(displayName);
  if (contactForegroundColor != null)   this.nameLabel.setForeground(contactForegroundColor);
  this.setBorder(BorderFactory.createEmptyBorder(1,5,1,1));
  ImageIcon avatar=chatContact.getAvatar();
  if (avatar != null)   this.photoLabel.setIcon(avatar);
  this.setBounds(0,0,list.getWidth() - 2,30);
  this.nameLabel.setBounds(0,0,list.getWidth() - 28,17);
  this.photoLabel.setBounds(list.getWidth() - 28,0,25,30);
  this.isLeaf=true;
  this.isSelected=isSelected;
  return this;
}","public Component getListCellRendererComponent(JList list,Object value,int index,boolean isSelected,boolean cellHasFocus){
  this.index=index;
  this.photoLabel.setIcon(null);
  DefaultContactList contactList=(DefaultContactList)list;
  ChatContact chatContact=(ChatContact)value;
  this.setPreferredSize(new Dimension(20,30));
  String displayName=chatContact.getName();
  if (displayName == null || displayName.length() < 1) {
    displayName=GuiActivator.getResources().getI18NString(""String_Node_Str"");
  }
  this.nameLabel.setFont(this.getFont().deriveFont(Font.PLAIN));
  this.nameLabel.setText(displayName);
  if (contactForegroundColor != null)   this.nameLabel.setForeground(contactForegroundColor);
  this.setBorder(BorderFactory.createEmptyBorder(1,5,1,1));
  ImageIcon avatar=chatContact.getAvatar();
  if (avatar != null)   this.photoLabel.setIcon(avatar);
  this.setBounds(0,0,list.getWidth() - 2,30);
  this.nameLabel.setBounds(0,0,list.getWidth() - 28,17);
  this.photoLabel.setBounds(list.getWidth() - 28,0,25,30);
  this.isLeaf=true;
  this.isSelected=isSelected;
  return this;
}",0.9706422018348624
104178,"/** 
 * Constructs the <tt>ChatInviteDialog</tt>.
 * @param chatPanel the <tt>ChatPanel</tt> corresponding to the<tt>ChatRoom</tt>, where the contact is invited. 
 */
public ChatInviteDialog(ChatPanel chatPanel){
  this.chatPanel=chatPanel;
  this.setModal(false);
  String title=GuiActivator.getResources().getI18NString(""String_Node_Str"");
  this.setTitle(title);
  TransparentPanel mainPanel=new TransparentPanel(new BorderLayout(5,5));
  TransparentPanel northPanel=new TransparentPanel(new BorderLayout(10,10));
  mainPanel.setPreferredSize(new Dimension(450,350));
  mainPanel.setBorder(BorderFactory.createEmptyBorder(15,15,15,15));
  this.reasonArea.setBorder(BorderFactory.createTitledBorder(GuiActivator.getResources().getI18NString(""String_Node_Str"")));
  JTextArea infoTextArea=new JTextArea();
  infoTextArea.setText(GuiActivator.getResources().getI18NString(""String_Node_Str""));
  infoTextArea.setFont(Constants.FONT.deriveFont(Font.BOLD,12f));
  infoTextArea.setLineWrap(true);
  infoTextArea.setOpaque(false);
  infoTextArea.setWrapStyleWord(true);
  infoTextArea.setEditable(false);
  JLabel iconLabel=new JLabel(new ImageIcon(ImageLoader.getImage(ImageLoader.INVITE_DIALOG_ICON)));
  northPanel.add(iconLabel,BorderLayout.WEST);
  northPanel.add(infoTextArea,BorderLayout.CENTER);
  TransparentPanel buttonsPanel=new TransparentPanel(new FlowLayout(FlowLayout.RIGHT));
  inviteButton.addActionListener(this);
  cancelButton.addActionListener(this);
  buttonsPanel.add(inviteButton);
  buttonsPanel.add(cancelButton);
  this.getRootPane().setDefaultButton(inviteButton);
  inviteButton.setMnemonic(GuiActivator.getResources().getI18nMnemonic(""String_Node_Str""));
  cancelButton.setMnemonic(GuiActivator.getResources().getI18nMnemonic(""String_Node_Str""));
  MainFrame mainFrame=GuiActivator.getUIService().getMainFrame();
  final ContactList contactList=new ContactList(mainFrame);
  final ContactList selectedContactList=new ContactList(mainFrame);
  contactList.setModel(contactListModel);
  selectedContactList.setModel(selectedContactListModel);
  contactList.setMouseMotionListener(null);
  contactList.setMouseListener(new MouseAdapter(){
    public void mouseClicked(    MouseEvent e){
      if (e.getClickCount() > 1) {
        MetaContact metaContact=(MetaContact)contactList.getSelectedValue();
        moveContactFromLeftToRight(metaContact);
      }
    }
  }
);
  selectedContactList.setMouseMotionListener(null);
  selectedContactList.setMouseListener(new MouseAdapter(){
    public void mouseClicked(    MouseEvent e){
      if (e.getClickCount() > 1) {
        MetaContact metaContact=(MetaContact)selectedContactList.getSelectedValue();
        moveContactFromRightToLeft(metaContact);
      }
    }
  }
);
  JScrollPane contactListScrollPane=new JScrollPane();
  contactListScrollPane.setOpaque(false);
  contactListScrollPane.getViewport().setOpaque(false);
  contactListScrollPane.getViewport().add(contactList);
  contactListScrollPane.getViewport().setBorder(null);
  contactListScrollPane.setViewportBorder(null);
  contactListScrollPane.setBorder(SIPCommBorders.getRoundBorder());
  JScrollPane selectedListScrollPane=new JScrollPane();
  selectedListScrollPane.setOpaque(false);
  selectedListScrollPane.getViewport().setOpaque(false);
  selectedListScrollPane.getViewport().add(selectedContactList);
  selectedListScrollPane.getViewport().setBorder(null);
  selectedListScrollPane.setViewportBorder(null);
  selectedListScrollPane.setBorder(SIPCommBorders.getRoundBorder());
  JPanel listPanel=new JPanel(new GridLayout(0,2,5,5));
  listPanel.setPreferredSize(new Dimension(400,200));
  listPanel.add(contactListScrollPane);
  listPanel.add(selectedListScrollPane);
  listPanel.setOpaque(false);
  this.initContactListData();
  JPanel addRemoveButtonsPanel=new JPanel(new GridLayout(0,2,5,5));
  addRemoveButtonsPanel.setOpaque(false);
  JButton addContactButton=new JButton(GuiActivator.getResources().getI18NString(""String_Node_Str""));
  JButton removeContactButton=new JButton(GuiActivator.getResources().getI18NString(""String_Node_Str""));
  addRemoveButtonsPanel.add(addContactButton);
  addRemoveButtonsPanel.add(removeContactButton);
  addContactButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      MetaContact metaContact=(MetaContact)contactList.getSelectedValue();
      if (metaContact != null)       moveContactFromLeftToRight(metaContact);
    }
  }
);
  removeContactButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      MetaContact metaContact=(MetaContact)selectedContactList.getSelectedValue();
      if (metaContact != null)       moveContactFromRightToLeft(metaContact);
    }
  }
);
  TransparentPanel centerPanel=new TransparentPanel(new BorderLayout());
  centerPanel.add(listPanel,BorderLayout.CENTER);
  centerPanel.add(addRemoveButtonsPanel,BorderLayout.SOUTH);
  TransparentPanel southPanel=new TransparentPanel(new BorderLayout());
  southPanel.add(reasonArea,BorderLayout.CENTER);
  southPanel.add(buttonsPanel,BorderLayout.SOUTH);
  mainPanel.add(northPanel,BorderLayout.NORTH);
  mainPanel.add(centerPanel,BorderLayout.CENTER);
  mainPanel.add(southPanel,BorderLayout.SOUTH);
  this.getContentPane().add(mainPanel);
}","/** 
 * Constructs the <tt>ChatInviteDialog</tt>.
 * @param chatPanel the <tt>ChatPanel</tt> corresponding to the<tt>ChatRoom</tt>, where the contact is invited.
 */
public ChatInviteDialog(ChatPanel chatPanel){
  this.chatPanel=chatPanel;
  this.setModal(false);
  String title=GuiActivator.getResources().getI18NString(""String_Node_Str"");
  this.setTitle(title);
  TransparentPanel mainPanel=new TransparentPanel(new BorderLayout(5,5));
  TransparentPanel northPanel=new TransparentPanel(new BorderLayout(10,10));
  mainPanel.setPreferredSize(new Dimension(450,350));
  mainPanel.setBorder(BorderFactory.createEmptyBorder(15,15,15,15));
  this.reasonArea.setBorder(BorderFactory.createTitledBorder(GuiActivator.getResources().getI18NString(""String_Node_Str"")));
  JTextArea infoTextArea=new JTextArea();
  infoTextArea.setText(GuiActivator.getResources().getI18NString(""String_Node_Str""));
  infoTextArea.setFont(Constants.FONT.deriveFont(Font.BOLD,12f));
  infoTextArea.setLineWrap(true);
  infoTextArea.setOpaque(false);
  infoTextArea.setWrapStyleWord(true);
  infoTextArea.setEditable(false);
  JLabel iconLabel=new JLabel(new ImageIcon(ImageLoader.getImage(ImageLoader.INVITE_DIALOG_ICON)));
  northPanel.add(iconLabel,BorderLayout.WEST);
  northPanel.add(infoTextArea,BorderLayout.CENTER);
  TransparentPanel buttonsPanel=new TransparentPanel(new FlowLayout(FlowLayout.RIGHT));
  inviteButton.addActionListener(this);
  cancelButton.addActionListener(this);
  buttonsPanel.add(inviteButton);
  buttonsPanel.add(cancelButton);
  this.getRootPane().setDefaultButton(inviteButton);
  inviteButton.setMnemonic(GuiActivator.getResources().getI18nMnemonic(""String_Node_Str""));
  cancelButton.setMnemonic(GuiActivator.getResources().getI18nMnemonic(""String_Node_Str""));
  final DefaultContactList contactList=new DefaultContactList();
  final DefaultContactList selectedContactList=new DefaultContactList();
  contactList.setModel(contactListModel);
  selectedContactList.setModel(selectedContactListModel);
  contactList.addMouseListener(new MouseAdapter(){
    public void mouseClicked(    MouseEvent e){
      if (e.getClickCount() > 1) {
        MetaContact metaContact=(MetaContact)contactList.getSelectedValue();
        moveContactFromLeftToRight(metaContact);
      }
    }
  }
);
  selectedContactList.addMouseListener(new MouseAdapter(){
    public void mouseClicked(    MouseEvent e){
      if (e.getClickCount() > 1) {
        MetaContact metaContact=(MetaContact)selectedContactList.getSelectedValue();
        moveContactFromRightToLeft(metaContact);
      }
    }
  }
);
  JScrollPane contactListScrollPane=new JScrollPane();
  contactListScrollPane.setOpaque(false);
  contactListScrollPane.getViewport().setOpaque(false);
  contactListScrollPane.getViewport().add(contactList);
  contactListScrollPane.getViewport().setBorder(null);
  contactListScrollPane.setViewportBorder(null);
  contactListScrollPane.setBorder(SIPCommBorders.getRoundBorder());
  JScrollPane selectedListScrollPane=new JScrollPane();
  selectedListScrollPane.setOpaque(false);
  selectedListScrollPane.getViewport().setOpaque(false);
  selectedListScrollPane.getViewport().add(selectedContactList);
  selectedListScrollPane.getViewport().setBorder(null);
  selectedListScrollPane.setViewportBorder(null);
  selectedListScrollPane.setBorder(SIPCommBorders.getRoundBorder());
  JPanel listPanel=new JPanel(new GridLayout(0,2,5,5));
  listPanel.setPreferredSize(new Dimension(400,200));
  listPanel.add(contactListScrollPane);
  listPanel.add(selectedListScrollPane);
  listPanel.setOpaque(false);
  this.initContactListData();
  JPanel addRemoveButtonsPanel=new JPanel(new GridLayout(0,2,5,5));
  addRemoveButtonsPanel.setOpaque(false);
  JButton addContactButton=new JButton(GuiActivator.getResources().getI18NString(""String_Node_Str""));
  JButton removeContactButton=new JButton(GuiActivator.getResources().getI18NString(""String_Node_Str""));
  addRemoveButtonsPanel.add(addContactButton);
  addRemoveButtonsPanel.add(removeContactButton);
  addContactButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      MetaContact metaContact=(MetaContact)contactList.getSelectedValue();
      if (metaContact != null)       moveContactFromLeftToRight(metaContact);
    }
  }
);
  removeContactButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      MetaContact metaContact=(MetaContact)selectedContactList.getSelectedValue();
      if (metaContact != null)       moveContactFromRightToLeft(metaContact);
    }
  }
);
  TransparentPanel centerPanel=new TransparentPanel(new BorderLayout());
  centerPanel.add(listPanel,BorderLayout.CENTER);
  centerPanel.add(addRemoveButtonsPanel,BorderLayout.SOUTH);
  TransparentPanel southPanel=new TransparentPanel(new BorderLayout());
  southPanel.add(reasonArea,BorderLayout.CENTER);
  southPanel.add(buttonsPanel,BorderLayout.SOUTH);
  mainPanel.add(northPanel,BorderLayout.NORTH);
  mainPanel.add(centerPanel,BorderLayout.CENTER);
  mainPanel.add(southPanel,BorderLayout.SOUTH);
  this.getContentPane().add(mainPanel);
}",0.9444817336273852
104179,"/** 
 * Creates an instance of <tt>ChatContactListPanel</tt>.
 */
public ChatRoomMemberListPanel(ChatPanel chat){
  super(new BorderLayout());
  this.memberList=new ContactList(GuiActivator.getUIService().getMainFrame());
  this.memberList.setModel(memberListModel);
  this.memberList.setCellRenderer(new ChatContactCellRenderer());
  this.memberList.setSelectionMode(ListSelectionModel.SINGLE_INTERVAL_SELECTION);
  this.memberList.setMouseMotionListener(null);
  this.memberList.setMouseListener(null);
  JScrollPane contactsScrollPane=new JScrollPane();
  contactsScrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  contactsScrollPane.getViewport().add(memberList);
  contactsScrollPane.getViewport().setOpaque(false);
  contactsScrollPane.setOpaque(false);
  this.add(contactsScrollPane);
}","/** 
 * Creates an instance of <tt>ChatContactListPanel</tt>.
 */
public ChatRoomMemberListPanel(ChatPanel chat){
  super(new BorderLayout());
  this.memberList=new DefaultContactList();
  this.memberList.setModel(memberListModel);
  this.memberList.setCellRenderer(new ChatContactCellRenderer());
  JScrollPane contactsScrollPane=new JScrollPane();
  contactsScrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  contactsScrollPane.getViewport().add(memberList);
  contactsScrollPane.getViewport().setOpaque(false);
  contactsScrollPane.setOpaque(false);
  this.add(contactsScrollPane);
}",0.7803187803187803
104180,"BanParticipantThread(ChatRoom chatRoom,String reason){
  this.chatRoom=chatRoom;
}","BanParticipantThread(ChatRoom chatRoom,String reason){
  this.chatRoom=chatRoom;
  this.reason=reason;
}",0.8817204301075269
104181,"public void run(){
  try {
    chatRoom.banParticipant((ChatRoomMember)chatContact.getDescriptor(),reason);
  }
 catch (  OperationFailedException e) {
    logger.error(""String_Node_Str"",e);
    String errorTitle=GuiActivator.getResources().getI18NString(""String_Node_Str"");
    if (e.getErrorCode() == OperationFailedException.NOT_ENOUGH_PRIVILEGES) {
      new ErrorDialog(chatPanel.getChatWindow(),errorTitle,GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{chatContact.getName()}),e).showDialog();
    }
 else     if (e.getErrorCode() == OperationFailedException.FORBIDDEN) {
      new ErrorDialog(chatPanel.getChatWindow(),errorTitle,GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{chatContact.getName()}),e).showDialog();
    }
 else {
      new ErrorDialog(chatPanel.getChatWindow(),errorTitle,GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{chatContact.getName()}),e).showDialog();
    }
  }
}","public void run(){
  try {
    chatRoom.banParticipant((ChatRoomMember)chatContact.getDescriptor(),reason);
  }
 catch (  OperationFailedException e) {
    logger.error(""String_Node_Str"",e);
    String errorTitle=GuiActivator.getResources().getI18NString(""String_Node_Str"");
    String errorMessageKey;
switch (e.getErrorCode()) {
case OperationFailedException.NOT_ENOUGH_PRIVILEGES:
      errorMessageKey=""String_Node_Str"";
    break;
case OperationFailedException.FORBIDDEN:
  errorMessageKey=""String_Node_Str"";
break;
default :
errorMessageKey=""String_Node_Str"";
break;
}
new ErrorDialog(chatPanel.getChatWindow(),errorTitle,GuiActivator.getResources().getI18NString(errorMessageKey,new String[]{chatContact.getName()}),e).showDialog();
}
}",0.6204889406286379
104182,"/** 
 * @override {@link SwingWorker}{@link #done()} to perform UI changesafter the chat room join task has finished.
 */
protected void done(){
  String returnCode=null;
  try {
    returnCode=get();
  }
 catch (  InterruptedException ignore) {
  }
catch (  ExecutionException ignore) {
  }
  ConfigurationManager.updateChatRoomStatus(chatRoomWrapper.getParentProvider().getProtocolProvider(),chatRoomWrapper.getChatRoomID(),Constants.ONLINE_STATUS);
  String errorMessage=null;
  if (returnCode.equals(AUTHENTICATION_FAILED)) {
    ChatRoomAuthenticationWindow authWindow=new ChatRoomAuthenticationWindow(chatRoomWrapper);
    authWindow.setVisible(true);
  }
 else   if (returnCode.equals(REGISTRATION_REQUIRED)) {
    errorMessage=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{chatRoomWrapper.getChatRoomName()});
  }
 else   if (returnCode.equals(PROVIDER_NOT_REGISTERED)) {
    errorMessage=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{chatRoomWrapper.getChatRoomName()});
  }
 else   if (returnCode.equals(SUBSCRIPTION_ALREADY_EXISTS)) {
    errorMessage=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{chatRoomWrapper.getChatRoomName()});
  }
 else {
    errorMessage=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{chatRoomWrapper.getChatRoomName()});
  }
  if (!returnCode.equals(SUCCESS) && !returnCode.equals(AUTHENTICATION_FAILED)) {
    new ErrorDialog(GuiActivator.getUIService().getMainFrame(),GuiActivator.getResources().getI18NString(""String_Node_Str""),errorMessage).showDialog();
  }
}","/** 
 * @override {@link SwingWorker}{@link #done()} to perform UI changesafter the chat room join task has finished.
 */
protected void done(){
  String returnCode=null;
  try {
    returnCode=get();
  }
 catch (  InterruptedException ignore) {
  }
catch (  ExecutionException ignore) {
  }
  ConfigurationManager.updateChatRoomStatus(chatRoomWrapper.getParentProvider().getProtocolProvider(),chatRoomWrapper.getChatRoomID(),Constants.ONLINE_STATUS);
  String errorMessage=null;
  if (AUTHENTICATION_FAILED.equals(returnCode)) {
    ChatRoomAuthenticationWindow authWindow=new ChatRoomAuthenticationWindow(chatRoomWrapper);
    authWindow.setVisible(true);
  }
 else   if (REGISTRATION_REQUIRED.equals(returnCode)) {
    errorMessage=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{chatRoomWrapper.getChatRoomName()});
  }
 else   if (PROVIDER_NOT_REGISTERED.equals(returnCode)) {
    errorMessage=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{chatRoomWrapper.getChatRoomName()});
  }
 else   if (SUBSCRIPTION_ALREADY_EXISTS.equals(returnCode)) {
    errorMessage=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{chatRoomWrapper.getChatRoomName()});
  }
 else {
    errorMessage=GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{chatRoomWrapper.getChatRoomName()});
  }
  if (!SUCCESS.equals(returnCode) && !AUTHENTICATION_FAILED.equals(returnCode)) {
    new ErrorDialog(GuiActivator.getUIService().getMainFrame(),GuiActivator.getResources().getI18NString(""String_Node_Str""),errorMessage).showDialog();
  }
}",0.9334990677439404
104183,"/** 
 * Adds the specified detail to the list of details registered on-line for this account. If such a detail already exists its max instance number is consulted and if it allows it - a second instance is added or otherwise and illegal argument exception is thrown. An IllegalArgumentException is also thrown in case the class of the specified detail is not supported by the underlying implementation, i.e. its class name was not returned by the getSupportedDetailTypes() method. <p>
 * @param detail the detail that we'd like registered on the server.<p>
 * @throws IllegalArgumentException if such a detail already exists and itsmax instances number has been atteined or if the underlying implementation does not support setting details of the corresponding class.
 * @throws OperationFailedException with code Network Failure if putting thenew value online has failed
 * @throws java.lang.ArrayIndexOutOfBoundsException if the number ofinstances currently registered by the application is already equal to the maximum number of supported instances (@see getMaxDetailInstances())
 */
public void addDetail(GenericDetail detail) throws IllegalArgumentException, OperationFailedException, ArrayIndexOutOfBoundsException {
  assertConnected();
  if (!isDetailClassSupported(detail.getClass()))   throw new IllegalArgumentException(""String_Node_Str"" + detail.getClass());
  Vector alreadySetDetails=new Vector();
  Iterator iter=getDetails(detail.getClass());
  while (iter.hasNext()) {
    alreadySetDetails.add(iter.next());
  }
  if (alreadySetDetails.size() >= getMaxDetailInstances(detail.getClass()))   throw new ArrayIndexOutOfBoundsException(""String_Node_Str"");
  alreadySetDetails.add(detail);
  SuccessResponseListener responseListener=new SuccessResponseListener();
  MetaFullInfoSetCmd cmd=new MetaFullInfoSetCmd(Integer.parseInt(uin),reqID++);
  int typeOfDetail=((int[])supportedTypes.get(detail.getClass()))[1];
  try {
switch (typeOfDetail) {
case 0x01A4:
      cmd.setCountry(getCountryCode(((CountryDetail)detail).getLocale()));
    break;
case 0x0154:
  cmd.setNickName(((StringDetail)detail).getString());
break;
case 0x0140:
cmd.setFirstName(((StringDetail)detail).getString());
break;
case 0x014A:
cmd.setLastName(((StringDetail)detail).getString());
break;
case 0x015E:
cmd.setEmail(((StringDetail)detail).getString(),false);
break;
case 0x0190:
cmd.setHomeCity(((StringDetail)detail).getString());
break;
case 0x019A:
cmd.setHomeState(((StringDetail)detail).getString());
break;
case 0x0276:
cmd.setHomePhone(((StringDetail)detail).getString());
break;
case 0x0280:
cmd.setHomeFax(((StringDetail)detail).getString());
break;
case 0x0262:
cmd.setAddress(((StringDetail)detail).getString());
break;
case 0x028A:
cmd.setCellPhone(((StringDetail)detail).getString());
break;
case 0x026C:
cmd.setHomeZip(((StringDetail)detail).getString());
break;
case 0x017C:
if (detail.equals(ServerStoredDetails.GenderDetail.FEMALE)) cmd.setGender(1);
 else if (detail.equals(ServerStoredDetails.GenderDetail.MALE)) cmd.setGender(2);
 else cmd.setGender(0);
break;
case 0x0213:
cmd.setHomePage(((StringDetail)detail).getString());
break;
case 0x023A:
cmd.setBirthDay(((BirthDateDetail)detail).getCalendar().getTime());
break;
case 0x0186:
int[] langs=new int[3];
Arrays.fill(langs,-1);
int count=0;
Iterator i=getDetails(SpokenLanguageDetail.class);
while (i.hasNext()) {
Object item=(Object)i.next();
langs[count++]=getLanguageCode(((SpokenLanguageDetail)item).getLocale());
}
langs[count]=getLanguageCode(((SpokenLanguageDetail)detail).getLocale());
cmd.setLanguages(langs[0],langs[1],langs[2]);
break;
case 0x0320:
cmd.setOriginCity(((StringDetail)detail).getString());
break;
case 0x032A:
cmd.setOriginState(((StringDetail)detail).getString());
break;
case 0x0334:
cmd.setOriginCountry(getCountryCode(((CountryDetail)detail).getLocale()));
break;
case 0x029E:
cmd.setWorkCity(((StringDetail)detail).getString());
break;
case 0x02A8:
cmd.setWorkState(((StringDetail)detail).getString());
break;
case 0x02C6:
cmd.setWorkPhone(((StringDetail)detail).getString());
break;
case 0x02D0:
cmd.setWorkFax(((StringDetail)detail).getString());
break;
case 0x0294:
cmd.setWorkAddress(((StringDetail)detail).getString());
break;
case 0x02BC:
cmd.setWorkZip(((StringDetail)detail).getString());
break;
case 0x02B2:
cmd.setWorkCountry(getCountryCode(((CountryDetail)detail).getLocale()));
break;
case 0x01AE:
cmd.setWorkCompany(((StringDetail)detail).getString());
break;
case 0x01B8:
cmd.setWorkDepartment(((StringDetail)detail).getString());
break;
case 0x01C2:
cmd.setWorkPosition(((StringDetail)detail).getString());
break;
case 0x01CC:
cmd.setWorkOccupationCode(getOccupationCode(((StringDetail)detail).getString()));
break;
case 0x02DA:
cmd.setWorkWebPage(((StringDetail)detail).getString());
break;
case 0x0258:
cmd.setNotes(((StringDetail)detail).getString());
break;
case 0x01EA:
ArrayList interests=new ArrayList();
Iterator intIter=getDetails(InterestDetail.class);
while (intIter.hasNext()) {
InterestDetail item=(InterestDetail)intIter.next();
interests.add(item);
}
InterestDetail[] interestsArr=(InterestDetail[])interests.toArray();
int[] interestsCategories=new int[interestsArr.length];
String[] interestsStr=new String[interestsArr.length];
for (int k=0; k < interestsArr.length; k++) {
interestsStr[k]=interestsArr[k].getInterest();
interestsCategories[k]=getInterestCode(interestsStr[k]);
}
cmd.setInterests(interestsCategories,interestsStr);
break;
case 0x0316:
int offset=((ServerStoredDetails.TimeZoneDetail)detail).getTimeZone().getRawOffset() / (60 * 60 * 1000);
cmd.setTimeZone(offset);
break;
}
}
 catch (IOException ex) {
throw new OperationFailedException(""String_Node_Str"",OperationFailedException.NETWORK_FAILURE);
}
icqProvider.getAimConnection().getInfoService().getOscarConnection().sendSnacRequest(cmd,responseListener);
responseListener.waitForEvent(5000);
if (!responseListener.success) if (responseListener.timeout) throw new OperationFailedException(""String_Node_Str"",OperationFailedException.NETWORK_FAILURE);
 else throw new OperationFailedException(""String_Node_Str"",OperationFailedException.GENERAL_ERROR);
infoRetreiver.detailsChanged(uin);
}","/** 
 * Adds the specified detail to the list of details registered on-line for this account. If such a detail already exists its max instance number is consulted and if it allows it - a second instance is added or otherwise and illegal argument exception is thrown. An IllegalArgumentException is also thrown in case the class of the specified detail is not supported by the underlying implementation, i.e. its class name was not returned by the getSupportedDetailTypes() method. <p>
 * @param detail the detail that we'd like registered on the server.<p>
 * @throws IllegalArgumentException if such a detail already exists and itsmax instances number has been atteined or if the underlying implementation does not support setting details of the corresponding class.
 * @throws OperationFailedException with code Network Failure if putting thenew value online has failed
 * @throws java.lang.ArrayIndexOutOfBoundsException if the number ofinstances currently registered by the application is already equal to the maximum number of supported instances (@see getMaxDetailInstances())
 */
public void addDetail(GenericDetail detail) throws IllegalArgumentException, OperationFailedException, ArrayIndexOutOfBoundsException {
  assertConnected();
  if (!isDetailClassSupported(detail.getClass()))   throw new IllegalArgumentException(""String_Node_Str"" + detail.getClass());
  Vector alreadySetDetails=new Vector();
  Iterator iter=getDetails(detail.getClass());
  while (iter.hasNext()) {
    alreadySetDetails.add(iter.next());
  }
  if (alreadySetDetails.size() >= getMaxDetailInstances(detail.getClass()))   throw new ArrayIndexOutOfBoundsException(""String_Node_Str"");
  alreadySetDetails.add(detail);
  SuccessResponseListener responseListener=new SuccessResponseListener();
  MetaFullInfoSetCmd cmd=new MetaFullInfoSetCmd(Integer.parseInt(uin),reqID++);
  int typeOfDetail=((int[])supportedTypes.get(detail.getClass()))[1];
  try {
switch (typeOfDetail) {
case 0x01A4:
      cmd.setCountry(getCountryCode(((CountryDetail)detail).getLocale()));
    break;
case 0x0154:
  cmd.setNickName(((StringDetail)detail).getString());
break;
case 0x0140:
cmd.setFirstName(((StringDetail)detail).getString());
break;
case 0x014A:
cmd.setLastName(((StringDetail)detail).getString());
break;
case 0x015E:
cmd.setEmail(((StringDetail)detail).getString(),false);
break;
case 0x0190:
cmd.setHomeCity(((StringDetail)detail).getString());
break;
case 0x019A:
cmd.setHomeState(((StringDetail)detail).getString());
break;
case 0x0276:
cmd.setHomePhone(((StringDetail)detail).getString());
break;
case 0x0280:
cmd.setHomeFax(((StringDetail)detail).getString());
break;
case 0x0262:
cmd.setAddress(((StringDetail)detail).getString());
break;
case 0x028A:
cmd.setCellPhone(((StringDetail)detail).getString());
break;
case 0x026C:
cmd.setHomeZip(((StringDetail)detail).getString());
break;
case 0x017C:
if (detail.equals(ServerStoredDetails.GenderDetail.FEMALE)) cmd.setGender(1);
 else if (detail.equals(ServerStoredDetails.GenderDetail.MALE)) cmd.setGender(2);
 else cmd.setGender(0);
break;
case 0x0213:
cmd.setHomePage(((StringDetail)detail).getString());
break;
case 0x023A:
cmd.setBirthDay(((BirthDateDetail)detail).getCalendar().getTime());
break;
case 0x0186:
int[] langs=new int[3];
Arrays.fill(langs,-1);
int count=0;
Iterator i=getDetails(SpokenLanguageDetail.class);
while (i.hasNext()) {
Object item=(Object)i.next();
langs[count++]=getLanguageCode(((SpokenLanguageDetail)item).getLocale());
}
langs[count]=getLanguageCode(((SpokenLanguageDetail)detail).getLocale());
cmd.setLanguages(langs[0],langs[1],langs[2]);
break;
case 0x0320:
cmd.setOriginCity(((StringDetail)detail).getString());
break;
case 0x032A:
cmd.setOriginState(((StringDetail)detail).getString());
break;
case 0x0334:
cmd.setOriginCountry(getCountryCode(((CountryDetail)detail).getLocale()));
break;
case 0x029E:
cmd.setWorkCity(((StringDetail)detail).getString());
break;
case 0x02A8:
cmd.setWorkState(((StringDetail)detail).getString());
break;
case 0x02C6:
cmd.setWorkPhone(((StringDetail)detail).getString());
break;
case 0x02D0:
cmd.setWorkFax(((StringDetail)detail).getString());
break;
case 0x0294:
cmd.setWorkAddress(((StringDetail)detail).getString());
break;
case 0x02BC:
cmd.setWorkZip(((StringDetail)detail).getString());
break;
case 0x02B2:
cmd.setWorkCountry(getCountryCode(((CountryDetail)detail).getLocale()));
break;
case 0x01AE:
cmd.setWorkCompany(((StringDetail)detail).getString());
break;
case 0x01B8:
cmd.setWorkDepartment(((StringDetail)detail).getString());
break;
case 0x01C2:
cmd.setWorkPosition(((StringDetail)detail).getString());
break;
case 0x01CC:
cmd.setWorkOccupationCode(getOccupationCode(((StringDetail)detail).getString()));
break;
case 0x02DA:
cmd.setWorkWebPage(((StringDetail)detail).getString());
break;
case 0x0258:
cmd.setNotes(((StringDetail)detail).getString());
break;
case 0x01EA:
List<InterestDetail> interests=new ArrayList<InterestDetail>();
Iterator intIter=getDetails(InterestDetail.class);
while (intIter.hasNext()) {
InterestDetail item=(InterestDetail)intIter.next();
interests.add(item);
}
setInterests(cmd,interests);
break;
case 0x0316:
int offset=((ServerStoredDetails.TimeZoneDetail)detail).getTimeZone().getRawOffset() / (60 * 60 * 1000);
cmd.setTimeZone(offset);
break;
}
}
 catch (IOException ex) {
throw new OperationFailedException(""String_Node_Str"",OperationFailedException.NETWORK_FAILURE);
}
icqProvider.getAimConnection().getInfoService().getOscarConnection().sendSnacRequest(cmd,responseListener);
responseListener.waitForEvent(5000);
if (!responseListener.success) if (responseListener.timeout) throw new OperationFailedException(""String_Node_Str"",OperationFailedException.NETWORK_FAILURE);
 else throw new OperationFailedException(""String_Node_Str"",OperationFailedException.GENERAL_ERROR);
infoRetreiver.detailsChanged(uin);
}",0.9629383413661292
104184,"/** 
 * Replaces the currentDetailValue detail with newDetailValue and returns true if the operation was a success or false if currentDetailValue did not previously exist (in this case an additional call to addDetail is required).
 * @param currentDetailValue the detail value we'd like to replace.
 * @param newDetailValue the value of the detail that we'd like toreplace currentDetailValue with.
 * @throws ClassCastException if newDetailValue is not an instance ofthe same class as currentDetailValue.
 * @throws OperationFailedException with code Network Failure if puttingthe new value back online has failed
 * @return boolean
 */
public boolean replaceDetail(GenericDetail currentDetailValue,GenericDetail newDetailValue) throws ClassCastException, OperationFailedException {
  assertConnected();
  if (!newDetailValue.getClass().equals(currentDetailValue.getClass()))   throw new ClassCastException(""String_Node_Str"");
  if (currentDetailValue.equals(newDetailValue))   return true;
  boolean isFound=false;
  Vector alreadySetDetails=new Vector();
  Iterator iter=infoRetreiver.getDetails(uin,currentDetailValue.getClass());
  while (iter.hasNext()) {
    GenericDetail item=(GenericDetail)iter.next();
    if (item.equals(currentDetailValue)) {
      isFound=true;
      alreadySetDetails.add(newDetailValue);
    }
 else     alreadySetDetails.add(item);
  }
  if (!isFound)   return false;
  SuccessResponseListener responseListener=new SuccessResponseListener();
  MetaFullInfoSetCmd cmd=new MetaFullInfoSetCmd(Integer.parseInt(uin),reqID++);
  int typeOfDetail=((int[])supportedTypes.get(newDetailValue.getClass()))[1];
  try {
switch (typeOfDetail) {
case 0x01A4:
      cmd.setCountry(getCountryCode(((CountryDetail)newDetailValue).getLocale()));
    break;
case 0x0154:
  cmd.setNickName(((StringDetail)newDetailValue).getString());
break;
case 0x0140:
cmd.setFirstName(((StringDetail)newDetailValue).getString());
break;
case 0x014A:
cmd.setLastName(((StringDetail)newDetailValue).getString());
break;
case 0x015E:
cmd.setEmail(((StringDetail)newDetailValue).getString(),false);
break;
case 0x0190:
cmd.setHomeCity(((StringDetail)newDetailValue).getString());
break;
case 0x019A:
cmd.setHomeState(((StringDetail)newDetailValue).getString());
break;
case 0x0276:
cmd.setHomePhone(((StringDetail)newDetailValue).getString());
break;
case 0x0280:
cmd.setHomeFax(((StringDetail)newDetailValue).getString());
break;
case 0x0262:
cmd.setAddress(((StringDetail)newDetailValue).getString());
break;
case 0x028A:
cmd.setCellPhone(((StringDetail)newDetailValue).getString());
break;
case 0x026C:
cmd.setHomeZip(((StringDetail)newDetailValue).getString());
break;
case 0x017C:
if (newDetailValue.equals(ServerStoredDetails.GenderDetail.FEMALE)) cmd.setGender(1);
 else if (newDetailValue.equals(ServerStoredDetails.GenderDetail.MALE)) cmd.setGender(2);
 else cmd.setGender(0);
break;
case 0x0213:
cmd.setHomePage(((StringDetail)newDetailValue).getString());
break;
case 0x023A:
cmd.setBirthDay(((BirthDateDetail)newDetailValue).getCalendar().getTime());
break;
case 0x0186:
int[] langs=new int[3];
Arrays.fill(langs,-1);
int count=0;
Iterator i=getDetails(SpokenLanguageDetail.class);
while (i.hasNext()) {
Object item=(Object)i.next();
if (item.equals(currentDetailValue)) langs[count++]=getLanguageCode(((SpokenLanguageDetail)newDetailValue).getLocale());
 else langs[count++]=getLanguageCode(((SpokenLanguageDetail)item).getLocale());
}
cmd.setLanguages(langs[0],langs[1],langs[2]);
break;
case 0x0320:
cmd.setOriginCity(((StringDetail)newDetailValue).getString());
break;
case 0x032A:
cmd.setOriginState(((StringDetail)newDetailValue).getString());
break;
case 0x0334:
cmd.setOriginCountry(getCountryCode(((CountryDetail)newDetailValue).getLocale()));
break;
case 0x029E:
cmd.setWorkCity(((StringDetail)newDetailValue).getString());
break;
case 0x02A8:
cmd.setWorkState(((StringDetail)newDetailValue).getString());
break;
case 0x02C6:
cmd.setWorkPhone(((StringDetail)newDetailValue).getString());
break;
case 0x02D0:
cmd.setWorkFax(((StringDetail)newDetailValue).getString());
break;
case 0x0294:
cmd.setWorkAddress(((StringDetail)newDetailValue).getString());
break;
case 0x02BC:
cmd.setWorkZip(((StringDetail)newDetailValue).getString());
break;
case 0x02B2:
cmd.setWorkCountry(getCountryCode(((CountryDetail)newDetailValue).getLocale()));
break;
case 0x01AE:
cmd.setWorkCompany(((StringDetail)newDetailValue).getString());
break;
case 0x01B8:
cmd.setWorkDepartment(((StringDetail)newDetailValue).getString());
break;
case 0x01C2:
cmd.setWorkPosition(((StringDetail)newDetailValue).getString());
break;
case 0x01CC:
cmd.setWorkOccupationCode(getOccupationCode(((StringDetail)newDetailValue).getString()));
break;
case 0x02DA:
cmd.setWorkWebPage(((StringDetail)newDetailValue).getString());
break;
case 0x0258:
cmd.setNotes(((StringDetail)newDetailValue).getString());
break;
case 0x01EA:
ArrayList interests=new ArrayList();
Iterator intIter=getDetails(InterestDetail.class);
while (intIter.hasNext()) {
InterestDetail item=(InterestDetail)intIter.next();
if (item.equals(currentDetailValue)) interests.add(newDetailValue);
 else interests.add(item);
}
InterestDetail[] interestsArr=(InterestDetail[])interests.toArray();
int[] interestsCategories=new int[interestsArr.length];
String[] interestsStr=new String[interestsArr.length];
for (int k=0; k < interestsArr.length; k++) {
interestsStr[k]=interestsArr[k].getInterest();
interestsCategories[k]=getInterestCode(interestsStr[k]);
}
cmd.setInterests(interestsCategories,interestsStr);
break;
case 0x0316:
int offset=((ServerStoredDetails.TimeZoneDetail)newDetailValue).getTimeZone().getRawOffset() / (60 * 60 * 1000);
cmd.setTimeZone(offset);
break;
}
}
 catch (IOException ex) {
throw new OperationFailedException(""String_Node_Str"",OperationFailedException.NETWORK_FAILURE);
}
icqProvider.getAimConnection().getInfoService().getOscarConnection().sendSnacRequest(cmd,responseListener);
responseListener.waitForEvent(5000);
if (!responseListener.success && responseListener.timeout) throw new OperationFailedException(""String_Node_Str"",OperationFailedException.NETWORK_FAILURE);
if (responseListener.success) {
infoRetreiver.detailsChanged(uin);
return true;
}
 else return false;
}","/** 
 * Replaces the currentDetailValue detail with newDetailValue and returns true if the operation was a success or false if currentDetailValue did not previously exist (in this case an additional call to addDetail is required).
 * @param currentDetailValue the detail value we'd like to replace.
 * @param newDetailValue the value of the detail that we'd like toreplace currentDetailValue with.
 * @throws ClassCastException if newDetailValue is not an instance ofthe same class as currentDetailValue.
 * @throws OperationFailedException with code Network Failure if puttingthe new value back online has failed
 * @return boolean
 */
public boolean replaceDetail(GenericDetail currentDetailValue,GenericDetail newDetailValue) throws ClassCastException, OperationFailedException {
  assertConnected();
  if (!newDetailValue.getClass().equals(currentDetailValue.getClass()))   throw new ClassCastException(""String_Node_Str"");
  if (currentDetailValue.equals(newDetailValue))   return true;
  boolean isFound=false;
  Vector alreadySetDetails=new Vector();
  Iterator iter=infoRetreiver.getDetails(uin,currentDetailValue.getClass());
  while (iter.hasNext()) {
    GenericDetail item=(GenericDetail)iter.next();
    if (item.equals(currentDetailValue)) {
      isFound=true;
      alreadySetDetails.add(newDetailValue);
    }
 else     alreadySetDetails.add(item);
  }
  if (!isFound)   return false;
  SuccessResponseListener responseListener=new SuccessResponseListener();
  MetaFullInfoSetCmd cmd=new MetaFullInfoSetCmd(Integer.parseInt(uin),reqID++);
  int typeOfDetail=((int[])supportedTypes.get(newDetailValue.getClass()))[1];
  try {
switch (typeOfDetail) {
case 0x01A4:
      cmd.setCountry(getCountryCode(((CountryDetail)newDetailValue).getLocale()));
    break;
case 0x0154:
  cmd.setNickName(((StringDetail)newDetailValue).getString());
break;
case 0x0140:
cmd.setFirstName(((StringDetail)newDetailValue).getString());
break;
case 0x014A:
cmd.setLastName(((StringDetail)newDetailValue).getString());
break;
case 0x015E:
cmd.setEmail(((StringDetail)newDetailValue).getString(),false);
break;
case 0x0190:
cmd.setHomeCity(((StringDetail)newDetailValue).getString());
break;
case 0x019A:
cmd.setHomeState(((StringDetail)newDetailValue).getString());
break;
case 0x0276:
cmd.setHomePhone(((StringDetail)newDetailValue).getString());
break;
case 0x0280:
cmd.setHomeFax(((StringDetail)newDetailValue).getString());
break;
case 0x0262:
cmd.setAddress(((StringDetail)newDetailValue).getString());
break;
case 0x028A:
cmd.setCellPhone(((StringDetail)newDetailValue).getString());
break;
case 0x026C:
cmd.setHomeZip(((StringDetail)newDetailValue).getString());
break;
case 0x017C:
if (newDetailValue.equals(ServerStoredDetails.GenderDetail.FEMALE)) cmd.setGender(1);
 else if (newDetailValue.equals(ServerStoredDetails.GenderDetail.MALE)) cmd.setGender(2);
 else cmd.setGender(0);
break;
case 0x0213:
cmd.setHomePage(((StringDetail)newDetailValue).getString());
break;
case 0x023A:
cmd.setBirthDay(((BirthDateDetail)newDetailValue).getCalendar().getTime());
break;
case 0x0186:
int[] langs=new int[3];
Arrays.fill(langs,-1);
int count=0;
Iterator i=getDetails(SpokenLanguageDetail.class);
while (i.hasNext()) {
Object item=(Object)i.next();
if (item.equals(currentDetailValue)) langs[count++]=getLanguageCode(((SpokenLanguageDetail)newDetailValue).getLocale());
 else langs[count++]=getLanguageCode(((SpokenLanguageDetail)item).getLocale());
}
cmd.setLanguages(langs[0],langs[1],langs[2]);
break;
case 0x0320:
cmd.setOriginCity(((StringDetail)newDetailValue).getString());
break;
case 0x032A:
cmd.setOriginState(((StringDetail)newDetailValue).getString());
break;
case 0x0334:
cmd.setOriginCountry(getCountryCode(((CountryDetail)newDetailValue).getLocale()));
break;
case 0x029E:
cmd.setWorkCity(((StringDetail)newDetailValue).getString());
break;
case 0x02A8:
cmd.setWorkState(((StringDetail)newDetailValue).getString());
break;
case 0x02C6:
cmd.setWorkPhone(((StringDetail)newDetailValue).getString());
break;
case 0x02D0:
cmd.setWorkFax(((StringDetail)newDetailValue).getString());
break;
case 0x0294:
cmd.setWorkAddress(((StringDetail)newDetailValue).getString());
break;
case 0x02BC:
cmd.setWorkZip(((StringDetail)newDetailValue).getString());
break;
case 0x02B2:
cmd.setWorkCountry(getCountryCode(((CountryDetail)newDetailValue).getLocale()));
break;
case 0x01AE:
cmd.setWorkCompany(((StringDetail)newDetailValue).getString());
break;
case 0x01B8:
cmd.setWorkDepartment(((StringDetail)newDetailValue).getString());
break;
case 0x01C2:
cmd.setWorkPosition(((StringDetail)newDetailValue).getString());
break;
case 0x01CC:
cmd.setWorkOccupationCode(getOccupationCode(((StringDetail)newDetailValue).getString()));
break;
case 0x02DA:
cmd.setWorkWebPage(((StringDetail)newDetailValue).getString());
break;
case 0x0258:
cmd.setNotes(((StringDetail)newDetailValue).getString());
break;
case 0x01EA:
List<InterestDetail> interests=new ArrayList<InterestDetail>();
Iterator intIter=getDetails(InterestDetail.class);
while (intIter.hasNext()) {
InterestDetail item=(InterestDetail)intIter.next();
if (item.equals(currentDetailValue)) interests.add((InterestDetail)newDetailValue);
 else interests.add(item);
}
setInterests(cmd,interests);
break;
case 0x0316:
int offset=((ServerStoredDetails.TimeZoneDetail)newDetailValue).getTimeZone().getRawOffset() / (60 * 60 * 1000);
cmd.setTimeZone(offset);
break;
}
}
 catch (IOException ex) {
throw new OperationFailedException(""String_Node_Str"",OperationFailedException.NETWORK_FAILURE);
}
icqProvider.getAimConnection().getInfoService().getOscarConnection().sendSnacRequest(cmd,responseListener);
responseListener.waitForEvent(5000);
if (!responseListener.success && responseListener.timeout) throw new OperationFailedException(""String_Node_Str"",OperationFailedException.NETWORK_FAILURE);
if (responseListener.success) {
infoRetreiver.detailsChanged(uin);
return true;
}
 else return false;
}",0.9324901445466492
104185,"/** 
 * Enables or disables the ""Next"" wizard button according to whether the User ID field is empty.
 */
private void setNextButtonAccordingToUserID(){
  if (nickField.getText() == null || nickField.getText().equals(""String_Node_Str"") || serverField.getText() == null || serverField.getText().equals(""String_Node_Str"") || (!passwordNotRequired.isSelected() && passField.equals(""String_Node_Str""))) {
    wizard.getWizardContainer().setNextFinishButtonEnabled(false);
  }
 else {
    wizard.getWizardContainer().setNextFinishButtonEnabled(true);
  }
}","/** 
 * Enables or disables the ""Next"" wizard button according to whether the User ID field is empty.
 */
private void setNextButtonAccordingToUserID(){
  if (nickField.getText() == null || nickField.getText().equals(""String_Node_Str"") || serverField.getText() == null || serverField.getText().equals(""String_Node_Str"") || (!passwordNotRequired.isSelected() && passField.getText().equals(""String_Node_Str""))) {
    wizard.getWizardContainer().setNextFinishButtonEnabled(false);
  }
 else {
    wizard.getWizardContainer().setNextFinishButtonEnabled(true);
  }
}",0.9910071942446044
104186,"/** 
 * Replacing the characters that we must escape used for the created filename.
 * @param ids Ids - folder names as we are using FileSystem for storing files.
 */
private void escapeCharacters(String[] ids){
  for (int i=0; i < ids.length; i++) {
    String currId=ids[i];
    for (int j=0; j < ESCAPE_SEQUENCES.length; j++) {
      currId=currId.replaceAll(ESCAPE_SEQUENCES[j][0],ESCAPE_SEQUENCES[j][1]);
    }
    ids[i]=currId;
  }
}","/** 
 * Replacing the characters that we must escape used for the created filename.
 * @param ids Ids - folder names as we are usingFileSystem for storing files.
 */
private void escapeCharacters(String[] ids){
  for (int i=0; i < ids.length; i++) {
    String currId=ids[i];
    for (int j=0; j < ESCAPE_SEQUENCES.length; j++) {
      currId=currId.replaceAll(ESCAPE_SEQUENCES[j][0],ESCAPE_SEQUENCES[j][1]);
    }
    ids[i]=currId;
  }
}",0.9988623435722412
104187,"/** 
 * Returns the history by specified local and remote contact if one of them is null the default is used
 * @param localContact Contact
 * @param remoteContact Contact
 * @return History
 * @throws IOException
 */
private History getHistory(Contact localContact,Contact remoteContact) throws IOException {
  History retVal=null;
  String localId=localContact == null ? ""String_Node_Str"" : localContact.getAddress();
  String remoteId=remoteContact == null ? ""String_Node_Str"" : remoteContact.getAddress();
  HistoryID historyId=HistoryID.createFromRawID(new String[]{""String_Node_Str"",localId,remoteId});
  if (this.historyService.isHistoryExisting(historyId)) {
    retVal=this.historyService.getHistory(historyId);
  }
 else {
    retVal=this.historyService.createHistory(historyId,recordStructure);
  }
  return retVal;
}","/** 
 * Returns the history by specified local and remote contact if one of them is null the default is used
 * @param localContact Contact
 * @param remoteContact Contact
 * @return History
 * @throws IOException
 */
private History getHistory(Contact localContact,Contact remoteContact) throws IOException {
  History retVal=null;
  String localId=localContact == null ? ""String_Node_Str"" : localContact.getAddress();
  String remoteId=remoteContact == null ? ""String_Node_Str"" : remoteContact.getAddress();
  String account=remoteContact.getProtocolProvider().getAccountID().getAccountUniqueID();
  HistoryID historyId=HistoryID.createFromRawID(new String[]{""String_Node_Str"",localId,account,remoteId});
  if (!this.historyService.isHistoryCreated(historyId)) {
    HistoryID historyId_old=HistoryID.createFromRawID(new String[]{""String_Node_Str"",localId,remoteId});
    if (this.historyService.isHistoryCreated(historyId_old)) {
      try {
        this.historyService.moveHistory(historyId_old,historyId);
      }
 catch (      IOException iOException) {
        historyId=historyId_old;
      }
    }
  }
  if (this.historyService.isHistoryExisting(historyId)) {
    retVal=this.historyService.getHistory(historyId);
  }
 else {
    retVal=this.historyService.createHistory(historyId,recordStructure);
  }
  return retVal;
}",0.7516218721037998
104188,"/** 
 * Returns the IDs of all existing histories.
 * @return An iterator to a list of IDs.
 */
Iterator<HistoryID> getExistingIDs();","/** 
 * Returns the IDs of all existing histories.
 * @return An iterator to a list of IDs.
 */
public Iterator<HistoryID> getExistingIDs();",0.9743589743589745
104189,"/** 
 * Returns the history associated with this ID.
 * @param id The ID of the history.
 * @return Returns the history with this ID.
 * @throws IllegalArgumentException Thrown if there is no such history.
 */
History getHistory(HistoryID id) throws IllegalArgumentException ;","/** 
 * Returns the history associated with this ID.
 * @param id The ID of the history.
 * @return Returns the history with this ID.
 * @throws IllegalArgumentException Thrown if there is no such history.
 */
public History getHistory(HistoryID id) throws IllegalArgumentException ;",0.9874776386404294
104190,"/** 
 * Tests if a history with the given ID exists.
 * @param id The ID to test.
 * @return True if a history with this ID exists. False otherwise.
 */
boolean isHistoryExisting(HistoryID id);","/** 
 * Tests if a history with the given ID exists and is loaded.
 * @param id The ID to test.
 * @return True if a history with this ID exists. False otherwise.
 */
public boolean isHistoryExisting(HistoryID id);",0.9484029484029484
104191,"/** 
 * Creates a new history for this ID.
 * @param id The ID of the history to be created.
 * @param recordStructure The structure of the data.
 * @return Returns the history with this ID.
 * @throws IllegalArgumentException Thrown if such history already exists.
 * @throws IOException Thrown if the history could not be created due to a IO error.
 */
History createHistory(HistoryID id,HistoryRecordStructure recordStructure) throws IllegalArgumentException, IOException ;","/** 
 * Creates a new history for this ID.
 * @param id The ID of the history to be created.
 * @param recordStructure The structure of the data.
 * @return Returns the history with this ID.
 * @throws IllegalArgumentException Thrown if such history already exists.
 * @throws IOException Thrown if the history could not be created due to a IO error.
 */
public History createHistory(HistoryID id,HistoryRecordStructure recordStructure) throws IllegalArgumentException, IOException ;",0.9927007299270072
104192,"/** 
 * Process history messages.
 * @param historyList The collection of messages coming from history.
 * @param escapedMessageID The incoming message needed to be ignored ifcontained in history.
 */
public void processHistory(Collection<EventObject> historyList,String escapedMessageID){
  Iterator<EventObject> iterator=historyList.iterator();
  String historyString=""String_Node_Str"";
  String messageType;
  while (iterator.hasNext()) {
    Object o=iterator.next();
    if (o instanceof MessageDeliveredEvent) {
      MessageDeliveredEvent evt=(MessageDeliveredEvent)o;
      ProtocolProviderService protocolProvider=evt.getDestinationContact().getProtocolProvider();
      if (isGreyHistoryStyleDisabled(protocolProvider))       messageType=Constants.OUTGOING_MESSAGE;
 else       messageType=Constants.HISTORY_OUTGOING_MESSAGE;
      historyString+=processHistoryMessage(GuiActivator.getUIService().getMainFrame().getAccount(protocolProvider),evt.getTimestamp(),messageType,evt.getSourceMessage().getContent(),evt.getSourceMessage().getContentType());
    }
 else     if (o instanceof MessageReceivedEvent) {
      MessageReceivedEvent evt=(MessageReceivedEvent)o;
      ProtocolProviderService protocolProvider=evt.getSourceContact().getProtocolProvider();
      if (!evt.getSourceMessage().getMessageUID().equals(escapedMessageID)) {
        if (isGreyHistoryStyleDisabled(protocolProvider))         messageType=Constants.INCOMING_MESSAGE;
 else         messageType=Constants.HISTORY_INCOMING_MESSAGE;
        historyString+=processHistoryMessage(evt.getSourceContact().getDisplayName(),evt.getTimestamp(),messageType,evt.getSourceMessage().getContent(),evt.getSourceMessage().getContentType());
      }
    }
 else     if (o instanceof ChatRoomMessageDeliveredEvent) {
      ChatRoomMessageDeliveredEvent evt=(ChatRoomMessageDeliveredEvent)o;
      ProtocolProviderService protocolProvider=evt.getSourceChatRoom().getParentProvider();
      historyString+=processHistoryMessage(GuiActivator.getUIService().getMainFrame().getAccount(protocolProvider),evt.getTimestamp(),Constants.HISTORY_OUTGOING_MESSAGE,evt.getMessage().getContent(),evt.getMessage().getContentType());
    }
 else     if (o instanceof ChatRoomMessageReceivedEvent) {
      ChatRoomMessageReceivedEvent evt=(ChatRoomMessageReceivedEvent)o;
      if (!evt.getMessage().getMessageUID().equals(escapedMessageID)) {
        historyString+=processHistoryMessage(evt.getSourceChatRoomMember().getName(),evt.getTimestamp(),Constants.HISTORY_INCOMING_MESSAGE,evt.getMessage().getContent(),evt.getMessage().getContentType());
      }
    }
  }
  conversationPanel.insertMessageAfterStart(historyString);
  getChatWindow().getMainToolBar().changeHistoryButtonsState(this);
}","/** 
 * Process history messages.
 * @param historyList The collection of messages coming from history.
 * @param escapedMessageID The incoming message needed to be ignored ifcontained in history.
 */
public void processHistory(Collection<EventObject> historyList,String escapedMessageID){
  Iterator<EventObject> iterator=historyList.iterator();
  String messageType;
  while (iterator.hasNext()) {
    Object o=iterator.next();
    String historyString=""String_Node_Str"";
    if (o instanceof MessageDeliveredEvent) {
      MessageDeliveredEvent evt=(MessageDeliveredEvent)o;
      ProtocolProviderService protocolProvider=evt.getDestinationContact().getProtocolProvider();
      if (isGreyHistoryStyleDisabled(protocolProvider))       messageType=Constants.OUTGOING_MESSAGE;
 else       messageType=Constants.HISTORY_OUTGOING_MESSAGE;
      historyString=processHistoryMessage(GuiActivator.getUIService().getMainFrame().getAccount(protocolProvider),evt.getTimestamp(),messageType,evt.getSourceMessage().getContent(),evt.getSourceMessage().getContentType());
    }
 else     if (o instanceof MessageReceivedEvent) {
      MessageReceivedEvent evt=(MessageReceivedEvent)o;
      ProtocolProviderService protocolProvider=evt.getSourceContact().getProtocolProvider();
      if (!evt.getSourceMessage().getMessageUID().equals(escapedMessageID)) {
        if (isGreyHistoryStyleDisabled(protocolProvider))         messageType=Constants.INCOMING_MESSAGE;
 else         messageType=Constants.HISTORY_INCOMING_MESSAGE;
        historyString=processHistoryMessage(evt.getSourceContact().getDisplayName(),evt.getTimestamp(),messageType,evt.getSourceMessage().getContent(),evt.getSourceMessage().getContentType());
      }
    }
 else     if (o instanceof ChatRoomMessageDeliveredEvent) {
      ChatRoomMessageDeliveredEvent evt=(ChatRoomMessageDeliveredEvent)o;
      ProtocolProviderService protocolProvider=evt.getSourceChatRoom().getParentProvider();
      historyString=processHistoryMessage(GuiActivator.getUIService().getMainFrame().getAccount(protocolProvider),evt.getTimestamp(),Constants.HISTORY_OUTGOING_MESSAGE,evt.getMessage().getContent(),evt.getMessage().getContentType());
    }
 else     if (o instanceof ChatRoomMessageReceivedEvent) {
      ChatRoomMessageReceivedEvent evt=(ChatRoomMessageReceivedEvent)o;
      if (!evt.getMessage().getMessageUID().equals(escapedMessageID)) {
        historyString=processHistoryMessage(evt.getSourceChatRoomMember().getName(),evt.getTimestamp(),Constants.HISTORY_INCOMING_MESSAGE,evt.getMessage().getContent(),evt.getMessage().getContentType());
      }
    }
    conversationPanel.appendMessageToEnd(historyString);
  }
  getChatWindow().getMainToolBar().changeHistoryButtonsState(this);
}",0.9622193830991056
104193,"/** 
 * Creates a rounded corner scaled image.
 * @param imageBytes The bytes of the image to be scaled.
 * @param width The maximum width of the scaled image.
 * @param height The maximum height of the scaled image.
 * @return The rounded corner scaled image.
 */
public static ImageIcon getScaledRoundedImage(byte[] imageBytes,int width,int height){
  if (imageBytes == null || !(imageBytes.length > 0))   return null;
  ImageIcon imageIcon=null;
  try {
    InputStream in=new ByteArrayInputStream(imageBytes);
    BufferedImage image=ImageIO.read(in);
    imageIcon=getScaledRoundedIcon(image,width,height);
  }
 catch (  Exception e) {
    logger.debug(""String_Node_Str"",e);
  }
  return imageIcon;
}","/** 
 * Creates a rounded corner scaled image.
 * @param imageBytes The bytes of the image to be scaled.
 * @param width The maximum width of the scaled image.
 * @param height The maximum height of the scaled image.
 * @return The rounded corner scaled image.
 */
public static ImageIcon getScaledRoundedImage(byte[] imageBytes,int width,int height){
  if (imageBytes == null || !(imageBytes.length > 0))   return null;
  ImageIcon imageIcon=null;
  try {
    InputStream in=new ByteArrayInputStream(imageBytes);
    BufferedImage image=ImageIO.read(in);
    if (image != null)     imageIcon=getScaledRoundedIcon(image,width,height);
 else     logger.trace(""String_Node_Str"");
  }
 catch (  Exception e) {
    logger.debug(""String_Node_Str"",e);
  }
  return imageIcon;
}",0.9552845528455284
104194,"private void showPreview(final Container previewContainer,final Component preview,final Player player){
  if (!SwingUtilities.isEventDispatchThread()) {
    SwingUtilities.invokeLater(new Runnable(){
      public void run(){
        showPreview(previewContainer,preview,player);
      }
    }
);
    return;
  }
  previewContainer.removeAll();
  if (preview != null) {
    HierarchyListener hierarchyListener=new HierarchyListener(){
      private Window window;
      private WindowListener windowListener;
      public void dispose(){
        if (windowListener != null) {
          if (window != null) {
            window.removeWindowListener(windowListener);
            window=null;
          }
          windowListener=null;
        }
        preview.removeHierarchyListener(this);
        disposePlayer(player);
      }
      public void hierarchyChanged(      HierarchyEvent event){
        if ((event.getChangeFlags() & HierarchyEvent.DISPLAYABILITY_CHANGED) != 0) {
          if (preview.isDisplayable()) {
            if (windowListener == null) {
              window=SwingUtilities.windowForComponent(preview);
              if (window != null) {
                windowListener=new WindowAdapter(){
                  public void windowClosing(                  WindowEvent event){
                    dispose();
                  }
                }
;
                window.addWindowListener(windowListener);
              }
            }
          }
 else {
            dispose();
          }
        }
      }
    }
;
    preview.addHierarchyListener(hierarchyListener);
    previewContainer.add(preview);
  }
 else   disposePlayer(player);
}","private void showPreview(final Container previewContainer,final Component preview,final Player player){
  if (!SwingUtilities.isEventDispatchThread()) {
    SwingUtilities.invokeLater(new Runnable(){
      public void run(){
        showPreview(previewContainer,preview,player);
      }
    }
);
    return;
  }
  previewContainer.removeAll();
  if (preview != null) {
    HierarchyListener hierarchyListener=new HierarchyListener(){
      private Window window;
      private WindowListener windowListener;
      public void dispose(){
        if (windowListener != null) {
          if (window != null) {
            window.removeWindowListener(windowListener);
            window=null;
          }
          windowListener=null;
        }
        preview.removeHierarchyListener(this);
        disposePlayer(player);
        videoDeviceInPreview=null;
      }
      public void hierarchyChanged(      HierarchyEvent event){
        if ((event.getChangeFlags() & HierarchyEvent.DISPLAYABILITY_CHANGED) != 0) {
          if (preview.isDisplayable()) {
            if (windowListener == null) {
              window=SwingUtilities.windowForComponent(preview);
              if (window != null) {
                windowListener=new WindowAdapter(){
                  public void windowClosing(                  WindowEvent event){
                    dispose();
                  }
                }
;
                window.addWindowListener(windowListener);
              }
            }
          }
 else {
            dispose();
          }
        }
      }
    }
;
    preview.addHierarchyListener(hierarchyListener);
    previewContainer.add(preview);
  }
 else   disposePlayer(player);
}",0.9895615866388308
104195,"public void actionPerformed(ActionEvent event){
  Object selection=comboBox.getSelectedItem();
  CaptureDeviceInfo device=null;
  if (selection instanceof DeviceConfigurationComboBoxModel.CaptureDevice) {
    device=((DeviceConfigurationComboBoxModel.CaptureDevice)selection).info;
  }
  createPreview(device,preview);
}","public void actionPerformed(ActionEvent event){
  Object selection=comboBox.getSelectedItem();
  CaptureDeviceInfo device=null;
  if (selection instanceof DeviceConfigurationComboBoxModel.CaptureDevice)   device=((DeviceConfigurationComboBoxModel.CaptureDevice)selection).info;
  if ((device != null) && device.equals(videoDeviceInPreview))   return;
  Exception exception;
  try {
    createPreview(device,preview);
    exception=null;
  }
 catch (  IOException ex) {
    exception=ex;
  }
catch (  MediaException ex) {
    exception=ex;
  }
  if (exception != null) {
    logger.error(""String_Node_Str"" + device,exception);
    device=null;
  }
  videoDeviceInPreview=device;
}",0.5865865865865866
104196,"private void disposePlayer(Player player){
  player.stop();
  player.deallocate();
  player.close();
}","private void disposePlayer(Player player){
  player.stop();
  player.deallocate();
  player.close();
  if ((videoPlayerInPreview != null) && videoPlayerInPreview.equals(player))   videoPlayerInPreview=null;
}",0.6580645161290323
104197,"public void dispose(){
  if (windowListener != null) {
    if (window != null) {
      window.removeWindowListener(windowListener);
      window=null;
    }
    windowListener=null;
  }
  preview.removeHierarchyListener(this);
  disposePlayer(player);
}","public void dispose(){
  if (windowListener != null) {
    if (window != null) {
      window.removeWindowListener(windowListener);
      window=null;
    }
    windowListener=null;
  }
  preview.removeHierarchyListener(this);
  disposePlayer(player);
  videoDeviceInPreview=null;
}",0.9457943925233644
104198,"private Component createPreview(int type,final JComboBox comboBox){
  final Container preview;
  if (type == DeviceConfigurationComboBoxModel.VIDEO) {
    JLabel noPreview=new JLabel(MediaActivator.getResources().getI18NString(""String_Node_Str""));
    noPreview.setHorizontalAlignment(SwingConstants.CENTER);
    noPreview.setVerticalAlignment(SwingConstants.CENTER);
    preview=createVideoContainer(noPreview);
    ActionListener comboBoxListener=new ActionListener(){
      public void actionPerformed(      ActionEvent event){
        Object selection=comboBox.getSelectedItem();
        CaptureDeviceInfo device=null;
        if (selection instanceof DeviceConfigurationComboBoxModel.CaptureDevice) {
          device=((DeviceConfigurationComboBoxModel.CaptureDevice)selection).info;
        }
        createPreview(device,preview);
      }
    }
;
    comboBox.addActionListener(comboBoxListener);
    comboBoxListener.actionPerformed(null);
  }
 else   preview=new TransparentPanel();
  return preview;
}","private Component createPreview(int type,final JComboBox comboBox){
  final Container preview;
  if (type == DeviceConfigurationComboBoxModel.VIDEO) {
    JLabel noPreview=new JLabel(MediaActivator.getResources().getI18NString(""String_Node_Str""));
    noPreview.setHorizontalAlignment(SwingConstants.CENTER);
    noPreview.setVerticalAlignment(SwingConstants.CENTER);
    preview=createVideoContainer(noPreview);
    final ActionListener comboBoxListener=new ActionListener(){
      public void actionPerformed(      ActionEvent event){
        Object selection=comboBox.getSelectedItem();
        CaptureDeviceInfo device=null;
        if (selection instanceof DeviceConfigurationComboBoxModel.CaptureDevice)         device=((DeviceConfigurationComboBoxModel.CaptureDevice)selection).info;
        if ((device != null) && device.equals(videoDeviceInPreview))         return;
        Exception exception;
        try {
          createPreview(device,preview);
          exception=null;
        }
 catch (        IOException ex) {
          exception=ex;
        }
catch (        MediaException ex) {
          exception=ex;
        }
        if (exception != null) {
          logger.error(""String_Node_Str"" + device,exception);
          device=null;
        }
        videoDeviceInPreview=device;
      }
    }
;
    comboBox.addActionListener(comboBoxListener);
    comboBox.addHierarchyListener(new HierarchyListener(){
      public void hierarchyChanged(      HierarchyEvent event){
        if (((event.getChangeFlags() & HierarchyEvent.DISPLAYABILITY_CHANGED) != 0) && comboBox.isDisplayable())         comboBoxListener.actionPerformed(null);
      }
    }
);
  }
 else   preview=new TransparentPanel();
  return preview;
}",0.7087591240875912
104199,"/** 
 * Removes <tt>listener</tt> from the list of listeneres current registered for chat room modification events.
 * @param listener the <tt>ChatRoomChangeListener</tt> to remove.
 */
public void removePropertyChangeListener(PropertyChangeListener listener){
synchronized (propertyChangeListeners) {
    propertyChangeListeners.remove(listener);
  }
}","public void removePropertyChangeListener(PropertyChangeListener listener){
synchronized (propertyChangeListeners) {
    propertyChangeListeners.remove(listener);
  }
}",0.6423076923076924
104200,"/** 
 * Adds <tt>listener</tt> to the list of listeners registered to receive events upon modification of chat room properties such as its subject for example.
 * @param listener the <tt>ChatRoomChangeListener</tt> that is to beregistered for <tt>ChatRoomChangeEvent</tt>-s.
 */
public void addPropertyChangeListener(PropertyChangeListener listener){
synchronized (propertyChangeListeners) {
    if (!propertyChangeListeners.contains(listener))     propertyChangeListeners.add(listener);
  }
}","public void addPropertyChangeListener(PropertyChangeListener listener){
synchronized (propertyChangeListeners) {
    if (!propertyChangeListeners.contains(listener))     propertyChangeListeners.add(listener);
  }
}",0.6025459688826026
104201,"@Override protected void close(boolean isEscaped){
}","/** 
 * Reinitialize the newAccountDialog, when the window is closed.
 */
protected void close(boolean isEscaped){
  newAccountDialog=null;
}",0.4766839378238341
104202,"public void actionPerformed(ActionEvent arg0){
  NewAccountDialog newAccountDialog=new NewAccountDialog();
  newAccountDialog.pack();
  newAccountDialog.setVisible(true);
}","public void actionPerformed(ActionEvent arg0){
  NewAccountDialog.showNewAccountDialog();
}",0.6615969581749049
104203,"/** 
 * Creates and initializes the <tt>SelectAccountPanel</tt>.
 * @param newContact An object that collects all user choices through thewizard.
 * @param protocolProvidersList The list of available<tt>ProtocolProviderServices</tt>, from which the user could select.
 */
public SelectAccountPanel(NewContact newContact,Iterator<ProtocolProviderService> protocolProvidersList){
  super(new BorderLayout());
  this.newContact=newContact;
  this.setBorder(BorderFactory.createEmptyBorder(10,10,10,10));
  this.setPreferredSize(new Dimension(500,200));
  this.iconLabel.setBorder(BorderFactory.createEmptyBorder(0,10,10,10));
  this.infoLabel.setEditable(false);
  this.infoTitleLabel.setFont(Constants.FONT.deriveFont(Font.BOLD,18));
  this.labelsPanel.add(infoTitleLabel);
  this.labelsPanel.add(infoLabel);
  this.rightPanel.add(labelsPanel,BorderLayout.NORTH);
  this.rightPanel.add(tablePane,BorderLayout.CENTER);
  this.rightPanel.add(buttonPanel,BorderLayout.SOUTH);
  this.buttonPanel.add(addAccountButton);
  this.addAccountButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      NewAccountDialog newAccountDialog=new NewAccountDialog();
      newAccountDialog.pack();
      newAccountDialog.setVisible(true);
    }
  }
);
  this.add(iconLabel,BorderLayout.WEST);
  this.rightPanel.setBorder(BorderFactory.createEmptyBorder(0,10,10,10));
  this.add(rightPanel,BorderLayout.CENTER);
  this.tableInit(protocolProvidersList);
  GuiActivator.bundleContext.addServiceListener(this);
}","/** 
 * Creates and initializes the <tt>SelectAccountPanel</tt>.
 * @param newContact An object that collects all user choices through thewizard.
 * @param protocolProvidersList The list of available<tt>ProtocolProviderServices</tt>, from which the user could select.
 */
public SelectAccountPanel(NewContact newContact,Iterator<ProtocolProviderService> protocolProvidersList){
  super(new BorderLayout());
  this.newContact=newContact;
  this.setBorder(BorderFactory.createEmptyBorder(10,10,10,10));
  this.setPreferredSize(new Dimension(500,200));
  this.iconLabel.setBorder(BorderFactory.createEmptyBorder(0,10,10,10));
  this.infoLabel.setEditable(false);
  this.infoTitleLabel.setFont(Constants.FONT.deriveFont(Font.BOLD,18));
  this.labelsPanel.add(infoTitleLabel);
  this.labelsPanel.add(infoLabel);
  this.rightPanel.add(labelsPanel,BorderLayout.NORTH);
  this.rightPanel.add(tablePane,BorderLayout.CENTER);
  this.rightPanel.add(buttonPanel,BorderLayout.SOUTH);
  this.buttonPanel.add(addAccountButton);
  this.addAccountButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      NewAccountDialog.showNewAccountDialog();
    }
  }
);
  this.add(iconLabel,BorderLayout.WEST);
  this.rightPanel.setBorder(BorderFactory.createEmptyBorder(0,10,10,10));
  this.add(rightPanel,BorderLayout.CENTER);
  this.tableInit(protocolProvidersList);
  GuiActivator.bundleContext.addServiceListener(this);
}",0.9654941373534338
104204,"/** 
 * Handles the <tt>ActionEvent</tt> when one of the menu items is selected.
 */
public void actionPerformed(ActionEvent e){
  JMenuItem menuItem=(JMenuItem)e.getSource();
  String itemName=menuItem.getName();
  if (itemName.equals(""String_Node_Str"")) {
    NewAccountDialog dialog=new NewAccountDialog();
    dialog.setVisible(true);
  }
 else   if (itemName.equals(""String_Node_Str"")) {
    AddContactWizard wizard=new AddContactWizard(parentWindow);
    wizard.showDialog(false);
  }
 else   if (itemName.equals(""String_Node_Str"")) {
    CreateGroupDialog dialog=new CreateGroupDialog(parentWindow);
    dialog.setVisible(true);
  }
 else   if (itemName.equals(""String_Node_Str"")) {
    closeActionPerformed();
  }
 else   if (itemName.equals(""String_Node_Str"")) {
    ChatRoomListDialog chatRoomsDialog=new ChatRoomListDialog(parentWindow);
    chatRoomsDialog.setPreferredSize(new Dimension(500,400));
    chatRoomsDialog.setVisible(true);
  }
}","/** 
 * Handles the <tt>ActionEvent</tt> when one of the menu items is selected.
 */
public void actionPerformed(ActionEvent e){
  JMenuItem menuItem=(JMenuItem)e.getSource();
  String itemName=menuItem.getName();
  if (itemName.equals(""String_Node_Str"")) {
    NewAccountDialog.showNewAccountDialog();
  }
 else   if (itemName.equals(""String_Node_Str"")) {
    AddContactWizard wizard=new AddContactWizard(parentWindow);
    wizard.showDialog(false);
  }
 else   if (itemName.equals(""String_Node_Str"")) {
    CreateGroupDialog dialog=new CreateGroupDialog(parentWindow);
    dialog.setVisible(true);
  }
 else   if (itemName.equals(""String_Node_Str"")) {
    closeActionPerformed();
  }
 else   if (itemName.equals(""String_Node_Str"")) {
    ChatRoomListDialog chatRoomsDialog=new ChatRoomListDialog(parentWindow);
    chatRoomsDialog.setPreferredSize(new Dimension(500,400));
    chatRoomsDialog.setVisible(true);
  }
}",0.9754273504273504
104205,"public int compare(String encoding0,String encoding1){
  if (encodingConfiguration.getPriority(encoding0) > encodingConfiguration.getPriority(encoding1))   return -1;
  return encoding0.compareTo(encoding1);
}","public int compare(String encoding0,String encoding1){
  return encodingConfiguration.getPriority(encoding1) - encodingConfiguration.getPriority(encoding0);
}",0.7247956403269755
104206,"private String[] getEncodings(){
  if (encodings != null)   return encodings;
  String[] availableEncodings;
switch (type) {
case AUDIO:
    availableEncodings=encodingConfiguration.getAvailableAudioEncodings();
  break;
case VIDEO:
availableEncodings=encodingConfiguration.getAvailableVideoEncodings();
break;
default :
throw new IllegalStateException(""String_Node_Str"");
}
final int encodingCount=availableEncodings.length;
if (encodingCount < 1) encodings=NO_ENCODINGS;
 else {
encodings=new String[encodingCount];
System.arraycopy(availableEncodings,0,encodings,0,encodingCount);
Arrays.sort(encodings,0,encodingCount,new Comparator<String>(){
public int compare(String encoding0,String encoding1){
if (encodingConfiguration.getPriority(encoding0) > encodingConfiguration.getPriority(encoding1)) return -1;
return encoding0.compareTo(encoding1);
}
}
);
}
return encodings;
}","private String[] getEncodings(){
  if (encodings != null)   return encodings;
  String[] availableEncodings;
switch (type) {
case AUDIO:
    availableEncodings=encodingConfiguration.getAvailableAudioEncodings();
  break;
case VIDEO:
availableEncodings=encodingConfiguration.getAvailableVideoEncodings();
break;
default :
throw new IllegalStateException(""String_Node_Str"");
}
final int encodingCount=availableEncodings.length;
if (encodingCount < 1) encodings=NO_ENCODINGS;
 else {
encodings=new String[encodingCount];
System.arraycopy(availableEncodings,0,encodings,0,encodingCount);
Arrays.sort(encodings,0,encodingCount,new Comparator<String>(){
public int compare(String encoding0,String encoding1){
return encodingConfiguration.getPriority(encoding1) - encodingConfiguration.getPriority(encoding0);
}
}
);
}
return encodings;
}",0.9104739613809244
104207,"/** 
 * Informs all <tt>ChatFocusListener</tt>s that a <tt>ChatFocusEvent</tt> has been triggered.
 * @param eventID the type of the <tt>ChatFocusEvent</tt>
 */
private void fireChatFocusEvent(int eventID){
  ChatFocusEvent evt=new ChatFocusEvent(this,eventID);
  logger.trace(""String_Node_Str"" + evt);
  Iterable<ChatFocusListener> listeners;
synchronized (focusListeners) {
    listeners=new ArrayList<ChatFocusListener>(focusListeners);
  }
  for (  ChatFocusListener listener : listeners) {
switch (evt.getEventID()) {
case ChatFocusEvent.FOCUS_GAINED:
      listener.chatFocusGained(evt);
    break;
case ChatFocusEvent.FOCUS_LOST:
  listener.chatFocusLost(evt);
break;
default :
logger.error(""String_Node_Str"" + evt.getEventID());
}
}
}","/** 
 * Informs all <tt>ChatFocusListener</tt>s that a <tt>ChatFocusEvent</tt> has been triggered.
 * @param eventID the type of the <tt>ChatFocusEvent</tt>
 */
public void fireChatFocusEvent(int eventID){
  ChatFocusEvent evt=new ChatFocusEvent(this,eventID);
  logger.trace(""String_Node_Str"" + evt);
  Iterable<ChatFocusListener> listeners;
synchronized (focusListeners) {
    listeners=new ArrayList<ChatFocusListener>(focusListeners);
  }
  for (  ChatFocusListener listener : listeners) {
switch (evt.getEventID()) {
case ChatFocusEvent.FOCUS_GAINED:
      listener.chatFocusGained(evt);
    break;
case ChatFocusEvent.FOCUS_LOST:
  listener.chatFocusLost(evt);
break;
default :
logger.error(""String_Node_Str"" + evt.getEventID());
}
}
}",0.9925826028320972
104208,"public void dispose(){
  keyboardFocusManager.removePropertyChangeListener(propertyName,this);
}","/** 
 * Runs clean-up for associated resources which need explicit disposal (e.g. listeners keeping this instance alive because they were added to the model which operationally outlives this instance).
 */
public void dispose(){
  writeMessagePanel.dispose();
  chatSession.dispose();
}",0.1465968586387434
104209,"/** 
 * Creates an instance of <tt>ChatWindow</tt> by passing to it an instance of the main application window.
 * @param mainFrame the main application window
 */
public ChatWindow(){
  if (!ConfigurationManager.isWindowDecorated()) {
    this.setUndecorated(true);
  }
  this.setHierarchicallyOpaque(false);
  this.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
  if (ConfigurationManager.isMultiChatWindowEnabled()) {
    chatTabbedPane=new SIPCommTabbedPane(true,false);
    chatTabbedPane.addCloseListener(new CloseListener(){
      public void closeOperation(      MouseEvent e){
        int tabIndex=chatTabbedPane.getOverTabIndex();
        ChatPanel chatPanel=(ChatPanel)chatTabbedPane.getComponentAt(tabIndex);
        GuiActivator.getUIService().getChatWindowManager().closeChat(chatPanel);
      }
    }
);
  }
  menuBar=new MessageWindowMenuBar(this);
  this.setJMenuBar(menuBar);
  boolean isToolBarExtended=new Boolean(GuiActivator.getResources().getSettingsString(""String_Node_Str"")).booleanValue();
  if (isToolBarExtended)   mainToolBar=new ExtendedMainToolBar(this);
 else   mainToolBar=new MainToolBar(this);
  northPanel.add(new LogoBar(),BorderLayout.NORTH);
  northPanel.add(mainToolBar,BorderLayout.CENTER);
  northPanel.add(contactPhotoPanel,BorderLayout.EAST);
  this.mainPanel.add(northPanel,BorderLayout.NORTH);
  this.getContentPane().add(mainPanel,BorderLayout.CENTER);
  this.getContentPane().add(statusBarPanel,BorderLayout.SOUTH);
  this.initPluginComponents();
  this.setKeybindingInput(KeybindingSet.Category.CHAT);
  this.addKeybindingAction(""String_Node_Str"",new ForwordTabAction());
  this.addKeybindingAction(""String_Node_Str"",new BackwordTabAction());
  this.addKeybindingAction(""String_Node_Str"",new CopyAction());
  this.addKeybindingAction(""String_Node_Str"",new PasteAction());
  this.addKeybindingAction(""String_Node_Str"",new OpenSmileyAction());
  this.addKeybindingAction(""String_Node_Str"",new OpenHistoryAction());
  this.addKeybindingAction(""String_Node_Str"",new CloseAction());
  this.addWindowListener(new ChatWindowAdapter());
  int width=GuiActivator.getResources().getSettingsInt(""String_Node_Str"");
  int height=GuiActivator.getResources().getSettingsInt(""String_Node_Str"");
  this.setSize(width,height);
}","/** 
 * Creates an instance of <tt>ChatWindow</tt> by passing to it an instance of the main application window.
 * @param mainFrame the main application window
 */
public ChatWindow(){
  if (!ConfigurationManager.isWindowDecorated()) {
    this.setUndecorated(true);
  }
  this.addWindowFocusListener(this);
  this.setHierarchicallyOpaque(false);
  this.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
  if (ConfigurationManager.isMultiChatWindowEnabled()) {
    chatTabbedPane=new SIPCommTabbedPane(true,false);
    chatTabbedPane.addCloseListener(new CloseListener(){
      public void closeOperation(      MouseEvent e){
        int tabIndex=chatTabbedPane.getOverTabIndex();
        ChatPanel chatPanel=(ChatPanel)chatTabbedPane.getComponentAt(tabIndex);
        GuiActivator.getUIService().getChatWindowManager().closeChat(chatPanel);
      }
    }
);
    chatTabbedPane.addChangeListener(new ChangeListener(){
      public void stateChanged(      ChangeEvent evt){
        removeNonReadChatState();
      }
    }
);
  }
  menuBar=new MessageWindowMenuBar(this);
  this.setJMenuBar(menuBar);
  boolean isToolBarExtended=new Boolean(GuiActivator.getResources().getSettingsString(""String_Node_Str"")).booleanValue();
  if (isToolBarExtended)   mainToolBar=new ExtendedMainToolBar(this);
 else   mainToolBar=new MainToolBar(this);
  northPanel.add(new LogoBar(),BorderLayout.NORTH);
  northPanel.add(mainToolBar,BorderLayout.CENTER);
  northPanel.add(contactPhotoPanel,BorderLayout.EAST);
  this.mainPanel.add(northPanel,BorderLayout.NORTH);
  this.getContentPane().add(mainPanel,BorderLayout.CENTER);
  this.getContentPane().add(statusBarPanel,BorderLayout.SOUTH);
  this.initPluginComponents();
  this.setKeybindingInput(KeybindingSet.Category.CHAT);
  this.addKeybindingAction(""String_Node_Str"",new ForwordTabAction());
  this.addKeybindingAction(""String_Node_Str"",new BackwordTabAction());
  this.addKeybindingAction(""String_Node_Str"",new CopyAction());
  this.addKeybindingAction(""String_Node_Str"",new PasteAction());
  this.addKeybindingAction(""String_Node_Str"",new OpenSmileyAction());
  this.addKeybindingAction(""String_Node_Str"",new OpenHistoryAction());
  this.addKeybindingAction(""String_Node_Str"",new CloseAction());
  this.addWindowListener(new ChatWindowAdapter());
  int width=GuiActivator.getResources().getSettingsInt(""String_Node_Str"");
  int height=GuiActivator.getResources().getSettingsInt(""String_Node_Str"");
  this.setSize(width,height);
}",0.957347972972973
104210,"/** 
 * Disposes the chat window.
 */
private void disposeChatWindow(ChatWindow chatWindow){
  for (  ChatPanel chatPanel : chatPanels)   chatPanel.dispose();
synchronized (chatPanels) {
    chatPanels.clear();
  }
  if (chatWindow.getChatCount() > 0)   chatWindow.removeAllChats();
  GuiActivator.getUIService().unregisterExportedWindow(chatWindow);
  chatWindow.dispose();
  ContactList clist=GuiActivator.getUIService().getMainFrame().getContactListPanel().getContactList();
  clist.removeAllActiveContacts();
  clist.refreshAll();
}","/** 
 * Disposes the chat window.
 */
private void disposeChatWindow(ChatWindow chatWindow){
  for (  ChatPanel chatPanel : chatPanels)   chatPanel.dispose();
synchronized (chatPanels) {
    chatPanels.clear();
  }
  if (chatWindow.getChatCount() > 0)   chatWindow.removeAllChats();
  GuiActivator.getUIService().unregisterExportedWindow(chatWindow);
  chatWindow.dispose();
  ContactList clist=GuiActivator.getUIService().getMainFrame().getContactListPanel().getContactList();
  clist.removeAllActiveContacts();
}",0.979047619047619
104211,"/** 
 * Removes all contacts from the list of active contacts.
 */
public void removeAllActiveContacts(){
synchronized (activeContacts) {
    if (activeContacts.size() > 0) {
      this.activeContacts.removeAllElements();
      GuiActivator.getSystrayService().setSystrayIcon(SystrayService.SC_IMG_TYPE);
    }
  }
}","/** 
 * Removes all contacts from the list of active contacts.
 */
public void removeAllActiveContacts(){
synchronized (activeContacts) {
    if (activeContacts.size() > 0) {
      this.activeContacts.removeAllElements();
      GuiActivator.getSystrayService().setSystrayIcon(SystrayService.SC_IMG_TYPE);
    }
  }
  this.refreshAll();
}",0.9678407350689128
104212,"/** 
 * Analyzes the incoming <tt>responseEvent</tt> and then forwards it to the proper event handler.
 * @param responseEvent the responseEvent that we receivedProtocolProviderService.
 * @return <tt>true</tt> if the specified event has been handled by thisprocessor and shouldn't be offered to other processors registered for the same method; <tt>false</tt>, otherwise
 */
public boolean processResponse(ResponseEvent responseEvent){
  ClientTransaction clientTransaction=responseEvent.getClientTransaction();
  Response response=responseEvent.getResponse();
  CSeqHeader cseq=((CSeqHeader)response.getHeader(CSeqHeader.NAME));
  if (cseq == null) {
    logger.error(""String_Node_Str"");
  }
  String method=cseq.getMethod();
  SipProvider sourceProvider=(SipProvider)responseEvent.getSource();
  int responseStatusCode=response.getStatusCode();
  boolean processed=false;
switch (responseStatusCode) {
case Response.OK:
    if (method.equals(Request.INVITE)) {
      processInviteOK(clientTransaction,response);
      processed=true;
    }
 else     if (method.equals(Request.BYE)) {
    }
  break;
case Response.RINGING:
processRinging(clientTransaction,response);
processed=true;
break;
case Response.SESSION_PROGRESS:
processSessionProgress(clientTransaction,response);
processed=true;
break;
case Response.TRYING:
processTrying(clientTransaction,response);
processed=true;
break;
case Response.BUSY_HERE:
processBusyHere(clientTransaction,response);
processed=true;
break;
case Response.ACCEPTED:
if (Request.REFER.equals(method)) {
processReferAccepted(clientTransaction,response);
processed=true;
}
break;
case Response.UNAUTHORIZED:
case Response.PROXY_AUTHENTICATION_REQUIRED:
processAuthenticationChallenge(clientTransaction,response,sourceProvider);
processed=true;
break;
default :
if ((responseStatusCode / 100 == 4) || (responseStatusCode / 100 == 5)) {
CallParticipantSipImpl callParticipant=activeCallsRepository.findCallParticipant(clientTransaction.getDialog());
logger.error(""String_Node_Str"" + response.getStatusCode() + ""String_Node_Str""+ response.getReasonPhrase());
if (callParticipant != null) callParticipant.setState(CallParticipantState.FAILED);
processed=true;
}
break;
}
return processed;
}","/** 
 * Analyzes the incoming <tt>responseEvent</tt> and then forwards it to the proper event handler.
 * @param responseEvent the responseEvent that we receivedProtocolProviderService.
 * @return <tt>true</tt> if the specified event has been handled by thisprocessor and shouldn't be offered to other processors registered for the same method; <tt>false</tt>, otherwise
 */
public boolean processResponse(ResponseEvent responseEvent){
  ClientTransaction clientTransaction=responseEvent.getClientTransaction();
  Response response=responseEvent.getResponse();
  CSeqHeader cseq=((CSeqHeader)response.getHeader(CSeqHeader.NAME));
  if (cseq == null) {
    logger.error(""String_Node_Str"");
  }
  String method=cseq.getMethod();
  SipProvider sourceProvider=(SipProvider)responseEvent.getSource();
  int responseStatusCode=response.getStatusCode();
  boolean processed=false;
switch (responseStatusCode) {
case Response.OK:
    if (method.equals(Request.INVITE)) {
      processInviteOK(clientTransaction,response);
      processed=true;
    }
 else     if (method.equals(Request.BYE)) {
    }
  break;
case Response.RINGING:
processRinging(clientTransaction,response);
processed=true;
break;
case Response.SESSION_PROGRESS:
processSessionProgress(clientTransaction,response);
processed=true;
break;
case Response.TRYING:
processTrying(clientTransaction,response);
processed=true;
break;
case Response.BUSY_HERE:
case Response.BUSY_EVERYWHERE:
case Response.DECLINE:
processBusyHere(clientTransaction,response);
processed=true;
break;
case Response.ACCEPTED:
if (Request.REFER.equals(method)) {
processReferAccepted(clientTransaction,response);
processed=true;
}
break;
case Response.UNAUTHORIZED:
case Response.PROXY_AUTHENTICATION_REQUIRED:
processAuthenticationChallenge(clientTransaction,response,sourceProvider);
processed=true;
break;
default :
if ((responseStatusCode / 100 == 4) || (responseStatusCode / 100 == 5) || (responseStatusCode / 100 == 6)) {
CallParticipantSipImpl callParticipant=activeCallsRepository.findCallParticipant(clientTransaction.getDialog());
logger.error(""String_Node_Str"" + response.getStatusCode() + ""String_Node_Str""+ response.getReasonPhrase());
if (callParticipant != null) callParticipant.setState(CallParticipantState.FAILED);
processed=true;
}
break;
}
return processed;
}",0.9803488628836388
104213,"public void refreshStates(CallParticipantSecurityOnEvent event){
  String securityString=event.getSecurityString();
  if (securityString != null) {
    securityStringLabel.setText(securityString);
    if (event.isSecurityVerified()) {
      sasVerificationButton.setImage(iconEncrVerified);
    }
  }
  sasVerificationButton.setImage(iconEncr);
  notificationService.fireNotification(ZRTP_SECURE_NOTIFICATION);
  revalidate();
  repaint();
}","public void refreshStates(CallParticipantSecurityOnEvent event){
  String securityString=event.getSecurityString();
  if (securityString != null) {
    securityStringLabel.setText(securityString);
  }
  if (event.isSecurityVerified()) {
    sasVerificationButton.setImage(iconEncrVerified);
  }
 else {
    sasVerificationButton.setImage(iconEncr);
  }
  notificationService.fireNotification(ZRTP_SECURE_NOTIFICATION);
  revalidate();
  repaint();
}",0.9752808988764043
104214,"protected void updateFilteredItems(){
  fireIntervalRemoved(this,0,filteredItems.size());
  filteredItems.clear();
  if (filter == null)   filteredItems.addAll(items);
 else {
    for (Iterator iterator=items.iterator(); iterator.hasNext(); ) {
      Object item=iterator.next();
      if (filter.accept(item))       filteredItems.add(item);
    }
  }
  fireIntervalAdded(this,0,filteredItems.size());
}","protected void updateFilteredItems(){
  fireIntervalRemoved(this,0,filteredItems.size());
  filteredItems.clear();
  if (filter == null) {
    filteredItems.addAll(items);
  }
 else {
    for (Iterator iterator=items.iterator(); iterator.hasNext(); ) {
      Object item=iterator.next();
      if (filter.accept(item))       filteredItems.add(item);
    }
  }
  fireIntervalAdded(this,0,filteredItems.size());
}",0.9901719901719902
104215,"/** 
 * Changes the ""Send as SMS"" check box state.
 * @param isSmsSelected <code>true</code> to set the ""Send as SMS"" check boxselected, <code>false</code> - otherwise. 
 */
public void setSmsSelected(boolean isSmsSelected){
  sendSmsCheckBox.setSelected(isSmsSelected);
}","/** 
 * Changes the ""Send as SMS"" check box state.
 * @param isSmsSelected <code>true</code> to set the ""Send as SMS"" check boxselected, <code>false</code> - otherwise.
 */
public void setSmsSelected(boolean isSmsSelected){
  sendSmsCheckBox.setSelected(isSmsSelected);
}",0.998158379373849
104216,"/** 
 * Process history messages.
 * @param historyList The collection of messages coming from history.
 * @param escapedMessageID The incoming message needed to be ignored ifcontained in history.
 */
public void processHistory(Collection historyList,String escapedMessageID){
  Iterator iterator=historyList.iterator();
  String historyString=""String_Node_Str"";
  String messageType;
  while (iterator.hasNext()) {
    Object o=iterator.next();
    if (o instanceof MessageDeliveredEvent) {
      MessageDeliveredEvent evt=(MessageDeliveredEvent)o;
      ProtocolProviderService protocolProvider=evt.getDestinationContact().getProtocolProvider();
      if (isGreyHistoryStyleDisabled(protocolProvider))       messageType=Constants.OUTGOING_MESSAGE;
 else       messageType=Constants.HISTORY_OUTGOING_MESSAGE;
      historyString+=processHistoryMessage(GuiActivator.getUIService().getMainFrame().getAccount(protocolProvider),evt.getTimestamp(),messageType,evt.getSourceMessage().getContent(),evt.getSourceMessage().getContentType());
    }
 else     if (o instanceof MessageReceivedEvent) {
      MessageReceivedEvent evt=(MessageReceivedEvent)o;
      ProtocolProviderService protocolProvider=evt.getSourceContact().getProtocolProvider();
      if (!evt.getSourceMessage().getMessageUID().equals(escapedMessageID)) {
        if (isGreyHistoryStyleDisabled(protocolProvider))         messageType=Constants.INCOMING_MESSAGE;
 else         messageType=Constants.HISTORY_INCOMING_MESSAGE;
        historyString+=processHistoryMessage(evt.getSourceContact().getDisplayName(),evt.getTimestamp(),messageType,evt.getSourceMessage().getContent(),evt.getSourceMessage().getContentType());
      }
    }
 else     if (o instanceof ChatRoomMessageDeliveredEvent) {
      ChatRoomMessageDeliveredEvent evt=(ChatRoomMessageDeliveredEvent)o;
      ProtocolProviderService protocolProvider=evt.getSourceChatRoom().getParentProvider();
      historyString+=processHistoryMessage(GuiActivator.getUIService().getMainFrame().getAccount(protocolProvider),evt.getTimestamp(),Constants.HISTORY_OUTGOING_MESSAGE,evt.getMessage().getContent(),evt.getMessage().getContentType());
    }
 else     if (o instanceof ChatRoomMessageReceivedEvent) {
      ChatRoomMessageReceivedEvent evt=(ChatRoomMessageReceivedEvent)o;
      if (!evt.getMessage().getMessageUID().equals(escapedMessageID)) {
        historyString+=processHistoryMessage(evt.getSourceChatRoomMember().getName(),evt.getTimestamp(),Constants.HISTORY_INCOMING_MESSAGE,evt.getMessage().getContent(),evt.getMessage().getContentType());
      }
    }
  }
  conversationPanel.insertMessageAfterStart(historyString);
  getChatWindow().getMainToolBar().changeHistoryButtonsState(this);
}","/** 
 * Process history messages.
 * @param historyList The collection of messages coming from history.
 * @param escapedMessageID The incoming message needed to be ignored ifcontained in history.
 */
public void processHistory(Collection<EventObject> historyList,String escapedMessageID){
  Iterator<EventObject> iterator=historyList.iterator();
  String historyString=""String_Node_Str"";
  String messageType;
  while (iterator.hasNext()) {
    Object o=iterator.next();
    if (o instanceof MessageDeliveredEvent) {
      MessageDeliveredEvent evt=(MessageDeliveredEvent)o;
      ProtocolProviderService protocolProvider=evt.getDestinationContact().getProtocolProvider();
      if (isGreyHistoryStyleDisabled(protocolProvider))       messageType=Constants.OUTGOING_MESSAGE;
 else       messageType=Constants.HISTORY_OUTGOING_MESSAGE;
      historyString+=processHistoryMessage(GuiActivator.getUIService().getMainFrame().getAccount(protocolProvider),evt.getTimestamp(),messageType,evt.getSourceMessage().getContent(),evt.getSourceMessage().getContentType());
    }
 else     if (o instanceof MessageReceivedEvent) {
      MessageReceivedEvent evt=(MessageReceivedEvent)o;
      ProtocolProviderService protocolProvider=evt.getSourceContact().getProtocolProvider();
      if (!evt.getSourceMessage().getMessageUID().equals(escapedMessageID)) {
        if (isGreyHistoryStyleDisabled(protocolProvider))         messageType=Constants.INCOMING_MESSAGE;
 else         messageType=Constants.HISTORY_INCOMING_MESSAGE;
        historyString+=processHistoryMessage(evt.getSourceContact().getDisplayName(),evt.getTimestamp(),messageType,evt.getSourceMessage().getContent(),evt.getSourceMessage().getContentType());
      }
    }
 else     if (o instanceof ChatRoomMessageDeliveredEvent) {
      ChatRoomMessageDeliveredEvent evt=(ChatRoomMessageDeliveredEvent)o;
      ProtocolProviderService protocolProvider=evt.getSourceChatRoom().getParentProvider();
      historyString+=processHistoryMessage(GuiActivator.getUIService().getMainFrame().getAccount(protocolProvider),evt.getTimestamp(),Constants.HISTORY_OUTGOING_MESSAGE,evt.getMessage().getContent(),evt.getMessage().getContentType());
    }
 else     if (o instanceof ChatRoomMessageReceivedEvent) {
      ChatRoomMessageReceivedEvent evt=(ChatRoomMessageReceivedEvent)o;
      if (!evt.getMessage().getMessageUID().equals(escapedMessageID)) {
        historyString+=processHistoryMessage(evt.getSourceChatRoomMember().getName(),evt.getTimestamp(),Constants.HISTORY_INCOMING_MESSAGE,evt.getMessage().getContent(),evt.getMessage().getContentType());
      }
    }
  }
  conversationPanel.insertMessageAfterStart(historyString);
  getChatWindow().getMainToolBar().changeHistoryButtonsState(this);
}",0.9952363503114694
104217,"public Format setInputFormat(Format in){
  if (!(in instanceof VideoFormat) || null == NativeDecoder.matches(in,inputFormats))   return null;
  VideoFormat videoIn=(VideoFormat)in;
  Dimension inSize=videoIn.getSize();
  if (inSize == null)   inSize=new Dimension(DEF_WIDTH,DEF_HEIGHT);
  YUVFormat yuv=(YUVFormat)videoIn;
  if (yuv.getOffsetU() > yuv.getOffsetV())   return null;
  int strideY=inSize.width;
  int strideUV=strideY / 2;
  int offsetU=strideY * inSize.height;
  int offsetV=offsetU + strideUV * inSize.height / 2;
  int inputYuvLength=(strideY + strideUV) * inSize.height;
  float sourceFrameRate=videoIn.getFrameRate();
  inputFormat=new YUVFormat(inSize,inputYuvLength + INPUT_BUFFER_PADDING_SIZE,Format.byteArray,sourceFrameRate,YUVFormat.YUV_420,strideY,strideUV,0,offsetU,offsetV);
  return inputFormat;
}","public Format setInputFormat(Format in){
  if (!(in instanceof VideoFormat) || null == JNIDecoder.matches(in,inputFormats))   return null;
  VideoFormat videoIn=(VideoFormat)in;
  Dimension inSize=videoIn.getSize();
  if (inSize == null)   inSize=new Dimension(DEF_WIDTH,DEF_HEIGHT);
  YUVFormat yuv=(YUVFormat)videoIn;
  if (yuv.getOffsetU() > yuv.getOffsetV())   return null;
  int strideY=inSize.width;
  int strideUV=strideY / 2;
  int offsetU=strideY * inSize.height;
  int offsetV=offsetU + strideUV * inSize.height / 2;
  int inputYuvLength=(strideY + strideUV) * inSize.height;
  float sourceFrameRate=videoIn.getFrameRate();
  inputFormat=new YUVFormat(inSize,inputYuvLength + INPUT_BUFFER_PADDING_SIZE,Format.byteArray,sourceFrameRate,YUVFormat.YUV_420,strideY,strideUV,0,offsetU,offsetV);
  return inputFormat;
}",0.9957550030321408
104218,"public Format setOutputFormat(Format out){
  if (!(out instanceof VideoFormat) || null == NativeDecoder.matches(out,getMatchingOutputFormats(inputFormat)))   return null;
  VideoFormat videoOut=(VideoFormat)out;
  Dimension outSize=videoOut.getSize();
  if (outSize == null) {
    Dimension inSize=((VideoFormat)inputFormat).getSize();
    if (inSize == null)     outSize=new Dimension(DEF_WIDTH,DEF_HEIGHT);
 else     outSize=inSize;
  }
  outputFormat=new VideoFormat(videoOut.getEncoding(),outSize,outSize.width * outSize.height,Format.byteArray,videoOut.getFrameRate());
  return outputFormat;
}","public Format setOutputFormat(Format out){
  if (!(out instanceof VideoFormat) || null == JNIDecoder.matches(out,getMatchingOutputFormats(inputFormat)))   return null;
  VideoFormat videoOut=(VideoFormat)out;
  Dimension outSize=videoOut.getSize();
  if (outSize == null) {
    Dimension inSize=((VideoFormat)inputFormat).getSize();
    if (inSize == null)     outSize=new Dimension(DEF_WIDTH,DEF_HEIGHT);
 else     outSize=inSize;
  }
  outputFormat=new VideoFormat(videoOut.getEncoding(),outSize,outSize.width * outSize.height,Format.byteArray,videoOut.getFrameRate());
  return outputFormat;
}",0.994142259414226
104219,"/** 
 * Return the list of formats supported at the output.
 */
public Format[] getSupportedOutputFormats(Format in){
  if (in == null)   return defOutputFormats;
  if (!(in instanceof VideoFormat) || null == NativeDecoder.matches(in,inputFormats))   return new Format[0];
  return getMatchingOutputFormats(in);
}","/** 
 * Return the list of formats supported at the output.
 */
public Format[] getSupportedOutputFormats(Format in){
  if (in == null)   return defOutputFormats;
  if (!(in instanceof VideoFormat) || null == JNIDecoder.matches(in,inputFormats))   return new Format[0];
  return getMatchingOutputFormats(in);
}",0.9887640449438202
104220,"/** 
 * Shows the dialog.
 * @return The return code that should indicate what was the choice ofthe user. If the user chooses cancel, the return code is the  CANCEL_RETURN_CODE.
 */
public int showDialog(){
  if (!SwingUtilities.isEventDispatchThread()) {
    final int[] returnCodes=new int[1];
    Exception exception=null;
    try {
      SwingUtilities.invokeAndWait(new Runnable(){
        public void run(){
          returnCodes[0]=showDialog();
        }
      }
);
    }
 catch (    InterruptedException ex) {
      exception=ex;
    }
catch (    InvocationTargetException ex) {
      exception=ex;
    }
    if (exception != null)     throw new UndeclaredThrowableException(exception);
    return returnCodes[0];
  }
  pack();
  setModal(true);
  setVisible(true);
  return returnCode;
}","/** 
 * Shows the dialog.
 * @return The return code that should indicate what was the choice ofthe user. If the user chooses cancel, the return code is the CANCEL_RETURN_CODE.
 */
public int showDialog(){
  if (!SwingUtilities.isEventDispatchThread()) {
    final int[] returnCodes=new int[1];
    Exception exception=null;
    try {
      SwingUtilities.invokeAndWait(new Runnable(){
        public void run(){
          returnCodes[0]=showDialog();
        }
      }
);
    }
 catch (    InterruptedException ex) {
      exception=ex;
    }
catch (    InvocationTargetException ex) {
      exception=ex;
    }
    if (exception != null)     throw new UndeclaredThrowableException(exception);
    return returnCodes[0];
  }
  pack();
  setModal(true);
  setVisible(true);
  return returnCode;
}",0.9993722536095416
104221,"/** 
 * Sets the message to be displayed.
 * @param message The message to be displayed.
 */
public void setMessage(String message){
  this.messageArea.setText(message);
}","/** 
 * Sets the message to be displayed.
 * @param message The message to be displayed.
 */
public void setMessage(String message){
  this.messageArea.setText(message);
  this.messageArea.setSize(new Dimension(MAX_MSG_PANE_WIDTH,MAX_MSG_PANE_HEIGHT));
  int height=this.messageArea.getPreferredSize().height;
  this.messageArea.setPreferredSize(new Dimension(600,height));
}",0.6263736263736264
104222,"/** 
 * Creates an instance of <tt>ChatWritePanel</tt>.
 * @param panel The parent <tt>ChatPanel</tt>.
 */
public ChatWritePanel(ChatPanel panel){
  super(new BorderLayout());
  SCScrollPane scrollPane=new SCScrollPane();
  this.chatPanel=panel;
  this.editorPane.setContentType(""String_Node_Str"");
  this.editorPane.setFont(Constants.FONT);
  this.editorPane.setCaretPosition(0);
  this.editorPane.setEditorKit(new SIPCommHTMLEditorKit());
  this.editorPane.getDocument().addUndoableEditListener(this);
  this.editorPane.addKeyListener(this);
  this.editorPane.addMouseListener(this);
  this.editorPane.setTransferHandler(new ChatPanelTransferHandler());
  this.editTextToolBar=new EditTextToolBar(this);
  this.add(editTextToolBar,BorderLayout.NORTH);
  this.add(scrollPane,BorderLayout.CENTER);
  this.rightButtonMenu=new WritePanelRightButtonMenu(chatPanel.getChatWindow());
  scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  scrollPane.setViewportView(editorPane);
  this.typingTimer.setRepeats(true);
  ConfigurationService configService=GuiActivator.getConfigurationService();
  String messageCommandProperty=""String_Node_Str"";
  String messageCommand=configService.getString(messageCommandProperty);
  if (messageCommand == null)   messageCommand=GuiActivator.getResources().getSettingsString(messageCommandProperty);
  this.changeSendCommand((messageCommand == null || messageCommand.equalsIgnoreCase(""String_Node_Str"")));
}","/** 
 * Creates an instance of <tt>ChatWritePanel</tt>.
 * @param panel The parent <tt>ChatPanel</tt>.
 */
public ChatWritePanel(ChatPanel panel){
  super(new BorderLayout());
  SCScrollPane scrollPane=new SCScrollPane();
  this.chatPanel=panel;
  this.editorPane.setContentType(""String_Node_Str"");
  this.editorPane.setFont(Constants.FONT);
  this.editorPane.setCaretPosition(0);
  this.editorPane.setEditorKit(new SIPCommHTMLEditorKit());
  this.editorPane.getDocument().addUndoableEditListener(this);
  this.editorPane.addKeyListener(this);
  this.editorPane.addMouseListener(this);
  this.editorPane.setTransferHandler(new ChatWritePanelTransferHandler());
  this.editTextToolBar=new EditTextToolBar(this);
  this.add(editTextToolBar,BorderLayout.NORTH);
  this.add(scrollPane,BorderLayout.CENTER);
  this.rightButtonMenu=new WritePanelRightButtonMenu(chatPanel.getChatWindow());
  scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  scrollPane.setViewportView(editorPane);
  this.typingTimer.setRepeats(true);
  ConfigurationService configService=GuiActivator.getConfigurationService();
  String messageCommandProperty=""String_Node_Str"";
  String messageCommand=configService.getString(messageCommandProperty);
  if (messageCommand == null)   messageCommand=GuiActivator.getResources().getSettingsString(messageCommandProperty);
  this.changeSendCommand((messageCommand == null || messageCommand.equalsIgnoreCase(""String_Node_Str"")));
}",0.9982987410683906
104223,"/** 
 * Creates a <tt>CallComboBox</tt> by specifying the parent panel, where this combo box will be placed.
 * @param parentCallPanel The parent panel.
 */
public CallComboBox(MainCallPanel parentCallPanel){
  this.parentCallPanel=parentCallPanel;
  this.setUI(new SIPCommCallComboBoxUI());
  this.addActionListener(this);
  JTextField textField=(JTextField)this.getEditor().getEditorComponent();
  textField.getDocument().addDocumentListener(this);
  textField.getActionMap().put(""String_Node_Str"",new CreateCallAction());
  textField.getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER,0),""String_Node_Str"");
  textField.addFocusListener(this);
}","/** 
 * Creates a <tt>CallComboBox</tt> by specifying the parent panel, where this combo box will be placed.
 * @param parentCallPanel The parent panel.
 */
public CallComboBox(MainCallPanel parentCallPanel){
  this.parentCallPanel=parentCallPanel;
  this.setUI(new SIPCommCallComboBoxUI());
  this.addActionListener(this);
  JTextField textField=(JTextField)this.getEditor().getEditorComponent();
  textField.getDocument().addDocumentListener(this);
  textField.getActionMap().put(""String_Node_Str"",new CreateCallAction());
  textField.getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER,0),""String_Node_Str"");
  textField.addFocusListener(this);
  callHistoryLoadThread=new LoadLastCallsFromHistory();
  SwingUtilities.invokeLater(callHistoryLoadThread);
}",0.9232934553131598
104224,"public void focusGained(FocusEvent e){
  this.handleChange();
}","public void focusGained(FocusEvent e){
  SwingUtilities.invokeLater(callHistoryLoadThread);
  this.handleChange();
}",0.7039106145251397
104225,"/** 
 * Enables or disabled the call button according to the content in the combo box editor field.
 */
protected void handleChange(){
  String item=((CallComboEditor)this.getEditor()).getItem().toString();
  if (item.length() > 0) {
    parentCallPanel.setCallMetaContact(false);
    ContactList clist=parentCallPanel.getMainFrame().getContactListPanel().getContactList();
    int selectedIndex=clist.getSelectedIndex();
    clist.removeSelectionInterval(selectedIndex,selectedIndex);
    parentCallPanel.setCallButtonEnabled(true);
  }
 else {
    Object o=parentCallPanel.getMainFrame().getContactListPanel().getContactList().getSelectedValue();
    boolean enabled=(o instanceof MetaContact);
    parentCallPanel.setCallButtonEnabled(enabled);
  }
}","/** 
 * Enables or disables the call button according to the content in the combo box editor field.
 */
protected void handleChange(){
  String item=((CallComboEditor)this.getEditor()).getItem().toString();
  if (item.length() > 0) {
    parentCallPanel.setCallMetaContact(false);
    ContactList clist=parentCallPanel.getMainFrame().getContactListPanel().getContactList();
    int selectedIndex=clist.getSelectedIndex();
    clist.removeSelectionInterval(selectedIndex,selectedIndex);
    parentCallPanel.setCallButtonEnabled(true);
  }
 else {
    Object o=parentCallPanel.getMainFrame().getContactListPanel().getContactList().getSelectedValue();
    boolean enabled=(o instanceof MetaContact);
    parentCallPanel.setCallButtonEnabled(enabled);
  }
}",0.99867197875166
104226,"/** 
 * Authenticate a packet using HMC SHA1 method. Calculated authentication tag is returned.
 * @param pkt the RTP packet to be authenticated
 * @return authentication tag of pkt
 */
private byte[] authenticatePacketHMCSHA1(RawPacket pkt){
  hmacSha1.update(pkt.getBuffer(),0,pkt.getLength());
  byte[] rb=new byte[4];
  rb[0]=(byte)(this.roc >> 24);
  rb[1]=(byte)(this.roc >> 16);
  rb[2]=(byte)(this.roc >> 8);
  rb[3]=(byte)this.roc;
  hmacSha1.update(rb);
  return hmacSha1.doFinal();
}","/** 
 * Authenticate a packet using HMC SHA1 method. Calculated authentication tag is returned.
 * @param pkt the RTP packet to be authenticated
 * @return authentication tag of pkt
 */
private byte[] authenticatePacketHMCSHA1(RawPacket pkt,int rocIn){
  hmacSha1.update(pkt.getBuffer(),0,pkt.getLength());
  byte[] rb=new byte[4];
  rb[0]=(byte)(rocIn >> 24);
  rb[1]=(byte)(rocIn >> 16);
  rb[2]=(byte)(rocIn >> 8);
  rb[3]=(byte)rocIn;
  hmacSha1.update(rb);
  return hmacSha1.doFinal();
}",0.9371196754563894
104227,"/** 
 * Transform a RTP packet into a SRTP packet.  This method is called when a normal RTP packet ready to be sent. Operations done by the transformation may include: encryption, using either Counter Mode encryption, or F8 Mode encryption, adding authentication tag, currently HMC SHA1 method. Both encryption and authentication functionality can be turned off as long as the SRTPPolicy used in this SRTPCryptoContext is requires no encryption and no authentication. Then the packet will be sent out untouched. However this is not encouraged. If no SRTP feature is enabled, then we shall not use SRTP TransformConnector. We should use the original method (RTPManager managed transportation) instead.  
 * @param pkt the RTP packet that is going to be sent out
 */
public void transformPacket(RawPacket pkt){
  if (this.policy.getEncType() == SRTPPolicy.AESCM_ENCRYPTION) {
    processPacketAESCM(pkt);
  }
 else   if (this.policy.getEncType() == SRTPPolicy.AESF8_ENCRYPTION) {
    processPacketAESF8(pkt);
  }
  if (this.policy.getAuthType() == SRTPPolicy.HMACSHA1_AUTHENTICATION) {
    byte[] tag=authenticatePacketHMCSHA1(pkt);
    pkt.append(tag,policy.getAuthTagLength());
  }
  int seqNum=PacketManipulator.GetRTPSequenceNumber(pkt);
  if (seqNum == 0xFFFF) {
    this.roc++;
  }
}","/** 
 * Transform a RTP packet into a SRTP packet.  This method is called when a normal RTP packet ready to be sent. Operations done by the transformation may include: encryption, using either Counter Mode encryption, or F8 Mode encryption, adding authentication tag, currently HMC SHA1 method. Both encryption and authentication functionality can be turned off as long as the SRTPPolicy used in this SRTPCryptoContext is requires no encryption and no authentication. Then the packet will be sent out untouched. However this is not encouraged. If no SRTP feature is enabled, then we shall not use SRTP TransformConnector. We should use the original method (RTPManager managed transportation) instead.  
 * @param pkt the RTP packet that is going to be sent out
 */
public void transformPacket(RawPacket pkt){
  if (this.policy.getEncType() == SRTPPolicy.AESCM_ENCRYPTION) {
    processPacketAESCM(pkt);
  }
 else   if (this.policy.getEncType() == SRTPPolicy.AESF8_ENCRYPTION) {
    processPacketAESF8(pkt);
  }
  if (this.policy.getAuthType() == SRTPPolicy.HMACSHA1_AUTHENTICATION) {
    byte[] tag=authenticatePacketHMCSHA1(pkt,this.roc);
    pkt.append(tag,policy.getAuthTagLength());
  }
  int seqNum=PacketManipulator.GetRTPSequenceNumber(pkt);
  if (seqNum == 0xFFFF) {
    this.roc++;
  }
}",0.9965156794425089
104228,"/** 
 * Transform a SRTP packet into a RTP packet. This method is called when a SRTP packet is received. Operations done by the this operation include: Authentication check, Packet replay check and decryption. Both encryption and authentication functionality can be turned off as long as the SRTPPolicy used in this SRTPCryptoContext is requires no encryption and no authentication. Then the packet will be sent out untouched. However this is not encouraged. If no SRTP feature is enabled, then we shall not use SRTP TransformConnector. We should use the original method (RTPManager managed transportation) instead.  
 * @param pkt the RTP packet that is just received
 * @return true if the packet can be acceptedfalse if the packet failed authentication or failed replay check 
 */
public boolean reverseTransformPacket(RawPacket pkt){
  if (this.policy.getAuthType() == SRTPPolicy.HMACSHA1_AUTHENTICATION) {
    int tagLength=this.policy.getAuthTagLength();
    byte[] originalTag=pkt.readRegion(pkt.getLength() - tagLength,tagLength);
    pkt.shrink(tagLength);
    byte[] calculatedTag=authenticatePacketHMCSHA1(pkt);
    for (int i=0; i < tagLength; i++) {
      if ((originalTag[i] & 0xff) == (calculatedTag[i] & 0xff))       continue;
 else       return false;
    }
  }
  int seqNum=PacketManipulator.GetRTPSequenceNumber(pkt);
  if (!checkReplay(seqNum)) {
    return false;
  }
  if (this.policy.getEncType() == SRTPPolicy.AESCM_ENCRYPTION) {
    processPacketAESCM(pkt);
  }
 else   if (this.policy.getEncType() == SRTPPolicy.AESF8_ENCRYPTION) {
    processPacketAESF8(pkt);
  }
  update(seqNum);
  return true;
}","/** 
 * Transform a SRTP packet into a RTP packet. This method is called when a SRTP packet is received. Operations done by the this operation include: Authentication check, Packet replay check and decryption. Both encryption and authentication functionality can be turned off as long as the SRTPPolicy used in this SRTPCryptoContext is requires no encryption and no authentication. Then the packet will be sent out untouched. However this is not encouraged. If no SRTP feature is enabled, then we shall not use SRTP TransformConnector. We should use the original method (RTPManager managed transportation) instead.  
 * @param pkt the RTP packet that is just received
 * @return true if the packet can be acceptedfalse if the packet failed authentication or failed replay check 
 */
public boolean reverseTransformPacket(RawPacket pkt){
  int seqNum=PacketManipulator.GetRTPSequenceNumber(pkt);
  if (!checkReplay(seqNum)) {
    return false;
  }
  if (this.policy.getAuthType() == SRTPPolicy.HMACSHA1_AUTHENTICATION) {
    int tagLength=this.policy.getAuthTagLength();
    byte[] originalTag=pkt.readRegion(pkt.getLength() - tagLength,tagLength);
    pkt.shrink(tagLength);
    long guessedIndex=guessIndex(seqNum);
    int guessedRoc=(int)(guessedIndex >> 16);
    byte[] calculatedTag=authenticatePacketHMCSHA1(pkt,guessedRoc);
    for (int i=0; i < tagLength; i++) {
      if ((originalTag[i] & 0xff) == (calculatedTag[i] & 0xff))       continue;
 else       return false;
    }
  }
  if (this.policy.getEncType() == SRTPPolicy.AESCM_ENCRYPTION) {
    processPacketAESCM(pkt);
  }
 else   if (this.policy.getEncType() == SRTPPolicy.AESF8_ENCRYPTION) {
    processPacketAESF8(pkt);
  }
  update(seqNum);
  return true;
}",0.904747685876381
104229,"/** 
 * Sets the look&feel and the theme.
 */
private void setDefaultThemePack(){
  ToolTipManager toolTipManager=ToolTipManager.sharedInstance();
  UIManager.put(""String_Node_Str"",new Color(GuiActivator.getResources().getColor(""String_Node_Str"")));
  toolTipManager.setInitialDelay(500);
  toolTipManager.setDismissDelay(60000);
  toolTipManager.setEnabled(true);
  UIManager.put(""String_Node_Str"",getClass().getClassLoader());
  String osName=System.getProperty(""String_Node_Str"");
  String laf=UIManager.getSystemLookAndFeelClassName();
  boolean lafIsSet=false;
  if ((laf != null) && !laf.equals(UIManager.getCrossPlatformLookAndFeelClassName())) {
    try {
      UIManager.setLookAndFeel(laf);
      lafIsSet=true;
      UIDefaults uiDefaults=UIManager.getDefaults();
      if (osName.startsWith(""String_Node_Str"")) {
        uiDefaults.put(""String_Node_Str"",uiDefaults.get(""String_Node_Str""));
      }
    }
 catch (    ClassNotFoundException ex) {
    }
catch (    InstantiationException ex) {
    }
catch (    IllegalAccessException ex) {
    }
catch (    UnsupportedLookAndFeelException ex) {
    }
  }
  if (!lafIsSet) {
    try {
      SIPCommLookAndFeel lf=new SIPCommLookAndFeel();
      SIPCommLookAndFeel.setCurrentTheme(new SIPCommDefaultTheme());
      boolean isDecorated=new Boolean(GuiActivator.getResources().getSettingsString(""String_Node_Str"")).booleanValue();
      if (isDecorated) {
        JFrame.setDefaultLookAndFeelDecorated(true);
        JDialog.setDefaultLookAndFeelDecorated(true);
      }
      UIManager.setLookAndFeel(lf);
    }
 catch (    UnsupportedLookAndFeelException e) {
      logger.error(""String_Node_Str"",e);
    }
  }
}","/** 
 * Sets the look&feel and the theme.
 */
private void setDefaultThemePack(){
  ToolTipManager toolTipManager=ToolTipManager.sharedInstance();
  UIManager.put(""String_Node_Str"",new Color(GuiActivator.getResources().getColor(""String_Node_Str"")));
  toolTipManager.setInitialDelay(500);
  toolTipManager.setDismissDelay(60000);
  toolTipManager.setEnabled(true);
  UIManager.put(""String_Node_Str"",getClass().getClassLoader());
  String osName=System.getProperty(""String_Node_Str"");
  String laf=UIManager.getSystemLookAndFeelClassName();
  boolean lafIsSet=false;
  if ((laf != null) && !laf.equals(UIManager.getCrossPlatformLookAndFeelClassName())) {
    try {
      UIManager.setLookAndFeel(laf);
      lafIsSet=true;
      UIDefaults uiDefaults=UIManager.getDefaults();
      if (osName.startsWith(""String_Node_Str"")) {
        uiDefaults.put(""String_Node_Str"",uiDefaults.get(""String_Node_Str""));
      }
      if (laf.equals(""String_Node_Str"") || laf.equals(""String_Node_Str"")) {
        UIDefaults metalDefaults=(new javax.swing.plaf.metal.MetalLookAndFeel()).getDefaults();
        uiDefaults.put(""String_Node_Str"",metalDefaults.get(""String_Node_Str""));
      }
    }
 catch (    ClassNotFoundException ex) {
    }
catch (    InstantiationException ex) {
    }
catch (    IllegalAccessException ex) {
    }
catch (    UnsupportedLookAndFeelException ex) {
    }
  }
  if (!lafIsSet) {
    try {
      SIPCommLookAndFeel lf=new SIPCommLookAndFeel();
      SIPCommLookAndFeel.setCurrentTheme(new SIPCommDefaultTheme());
      boolean isDecorated=new Boolean(GuiActivator.getResources().getSettingsString(""String_Node_Str"")).booleanValue();
      if (isDecorated) {
        JFrame.setDefaultLookAndFeelDecorated(true);
        JDialog.setDefaultLookAndFeelDecorated(true);
      }
      UIManager.setLookAndFeel(lf);
    }
 catch (    UnsupportedLookAndFeelException e) {
      logger.error(""String_Node_Str"",e);
    }
  }
}",0.9277376320177876
104230,"/** 
 * Initializes the accounts table.
 */
private void accountsInit(){
  this.accountsPanel.setLayout(new BoxLayout(accountsPanel,BoxLayout.Y_AXIS));
  for (  ProtocolProviderFactory providerFactory : GuiActivator.getProtocolProviderFactories().values()) {
    ServiceReference serRef;
    ProtocolProviderService protocolProvider;
    for (    AccountID accountID : providerFactory.getRegisteredAccounts()) {
      boolean isHidden=(accountID.getAccountProperty(ProtocolProviderFactory.IS_PROTOCOL_HIDDEN) != null);
      if (isHidden)       continue;
      serRef=providerFactory.getProviderForAccount(accountID);
      protocolProvider=(ProtocolProviderService)GuiActivator.bundleContext.getService(serRef);
      AccountPanel accountPanel=new AccountPanel(protocolProvider);
      accountsPanel.add(accountPanel);
      accounts.put(protocolProvider,accountPanel);
    }
  }
}","/** 
 * Initializes the accounts table.
 */
private void accountsInit(){
  this.accountsPanel.setLayout(new BoxLayout(accountsPanel,BoxLayout.Y_AXIS));
  for (  ProtocolProviderFactory providerFactory : GuiActivator.getProtocolProviderFactories().values()) {
    ServiceReference serRef;
    ProtocolProviderService protocolProvider;
    for (    AccountID accountID : providerFactory.getRegisteredAccounts()) {
      boolean isHidden=(accountID.getAccountProperty(ProtocolProviderFactory.IS_PROTOCOL_HIDDEN) != null);
      if (isHidden)       continue;
      serRef=providerFactory.getProviderForAccount(accountID);
      protocolProvider=(ProtocolProviderService)GuiActivator.bundleContext.getService(serRef);
      OperationSetPresence presence=(OperationSetPresence)protocolProvider.getOperationSet(OperationSetPresence.class);
      if (presence != null) {
        presence.addProviderPresenceStatusListener(this);
      }
      AccountPanel accountPanel=new AccountPanel(protocolProvider);
      accountsPanel.add(accountPanel);
      accounts.put(protocolProvider,accountPanel);
    }
  }
}",0.8909090909090909
104231,"public AccountPanel(ProtocolProviderService protocolProvider){
  super(new GridBagLayout());
  this.protocolProvider=protocolProvider;
  this.setPreferredSize(new Dimension(400,80));
  this.setBorder(BorderFactory.createMatteBorder(0,0,1,0,Color.GRAY));
  try {
    protocolImage=ImageIO.read(new ByteArrayInputStream(protocolProvider.getProtocolIcon().getIcon(ProtocolIcon.ICON_SIZE_16x16)));
  }
 catch (  IOException e) {
    logger.error(""String_Node_Str"",e);
  }
  protocolLabel.setIcon(new ImageIcon(protocolImage));
  constraints.insets=new Insets(0,5,0,5);
  constraints.weightx=0;
  constraints.gridx=0;
  constraints.gridy=0;
  constraints.anchor=GridBagConstraints.FIRST_LINE_START;
  this.add(protocolLabel,constraints);
  this.accountLabel.setText(protocolProvider.getAccountID().getDisplayName());
  constraints.insets=new Insets(0,0,0,0);
  constraints.gridx=1;
  constraints.gridy=0;
  constraints.fill=GridBagConstraints.HORIZONTAL;
  constraints.anchor=GridBagConstraints.FIRST_LINE_START;
  constraints.weightx=1.0;
  this.add(accountLabel,constraints);
  String passwordRequiredProperty=protocolProvider.getAccountID().getAccountPropertyString(ProtocolProviderFactory.NO_PASSWORD_REQUIRED);
  boolean isPasswordRequired=true;
  if (passwordRequiredProperty != null && passwordRequiredProperty != ""String_Node_Str"") {
    isPasswordRequired=!(new Boolean(passwordRequiredProperty).booleanValue());
  }
  if (isPasswordRequired) {
    String password=protocolProvider.getAccountID().getAccountPropertyString(ProtocolProviderFactory.PASSWORD);
    passwordField.setText(password);
    constraints.gridx=1;
    constraints.gridy=1;
    constraints.anchor=GridBagConstraints.FIRST_LINE_START;
    this.add(passwordField,constraints);
  }
  constraints.gridx=2;
  constraints.gridy=0;
  constraints.weightx=0;
  this.add(modifyButton,constraints);
  this.modifyButton.addActionListener(this);
  constraints.gridx=2;
  constraints.gridy=1;
  constraints.weightx=0;
  this.add(removeButton,constraints);
  this.removeButton.addActionListener(this);
}","public AccountPanel(ProtocolProviderService protocolProvider){
  super(new GridBagLayout());
  this.protocolProvider=protocolProvider;
  this.setPreferredSize(new Dimension(400,80));
  this.setBorder(BorderFactory.createMatteBorder(0,0,1,0,Color.GRAY));
  Image protocolImage=ImageLoader.getAccountStatusImage(protocolProvider);
  protocolLabel.setIcon(new ImageIcon(protocolImage));
  constraints.insets=new Insets(0,5,0,5);
  constraints.weightx=0;
  constraints.gridx=0;
  constraints.gridy=0;
  constraints.anchor=GridBagConstraints.FIRST_LINE_START;
  this.add(protocolLabel,constraints);
  this.accountLabel.setText(protocolProvider.getAccountID().getDisplayName());
  constraints.insets=new Insets(0,0,0,0);
  constraints.gridx=1;
  constraints.gridy=0;
  constraints.fill=GridBagConstraints.HORIZONTAL;
  constraints.anchor=GridBagConstraints.FIRST_LINE_START;
  constraints.weightx=1.0;
  this.add(accountLabel,constraints);
  String passwordRequiredProperty=protocolProvider.getAccountID().getAccountPropertyString(ProtocolProviderFactory.NO_PASSWORD_REQUIRED);
  boolean isPasswordRequired=true;
  if (passwordRequiredProperty != null && passwordRequiredProperty != ""String_Node_Str"") {
    isPasswordRequired=!(new Boolean(passwordRequiredProperty).booleanValue());
  }
  if (isPasswordRequired) {
    String password=protocolProvider.getAccountID().getAccountPropertyString(ProtocolProviderFactory.PASSWORD);
    passwordField.setText(password);
    constraints.gridx=1;
    constraints.gridy=1;
    constraints.anchor=GridBagConstraints.FIRST_LINE_START;
    this.add(passwordField,constraints);
  }
  constraints.gridx=2;
  constraints.gridy=0;
  constraints.weightx=0;
  this.add(modifyButton,constraints);
  this.modifyButton.addActionListener(this);
  constraints.gridx=2;
  constraints.gridy=1;
  constraints.weightx=0;
  this.add(removeButton,constraints);
  this.removeButton.addActionListener(this);
}",0.9450439146800502
104232,"/** 
 * Sets the selected contact to the given proto contact.
 * @param pps the protocol provider to select
 */
public void setSelected(ProtocolProviderService pps){
  this.setSelected(pps,new ImageIcon(createAccountStatusImage(pps)));
}","/** 
 * Sets the selected contact to the given proto contact.
 * @param pps the protocol provider to select
 */
public void setSelected(ProtocolProviderService pps){
  this.setSelected(pps,new ImageIcon(ImageLoader.getAccountStatusImage(pps)));
}",0.9565217391304348
104233,"/** 
 * Updates the protocol account status.
 * @param pps the protocol provider service to update
 */
public void updateAccountStatus(ProtocolProviderService pps){
  JMenuItem menuItem=accountsTable.get(pps);
  Icon icon=new ImageIcon(createAccountStatusImage(pps));
  ProtocolProviderService selectedPPS=(ProtocolProviderService)menu.getSelectedObject();
  if (selectedPPS.equals(pps) && !pps.isRegistered()) {
    ProtocolProviderService newPPS=findFirstRegisteredProvider();
    if (newPPS != null)     this.setSelected(newPPS);
  }
  if (!selectedPPS.equals(pps) && !selectedPPS.isRegistered() && pps.isRegistered()) {
    this.setSelected(pps);
  }
  menuItem.setIcon(icon);
  if (menu.getSelectedObject().equals(pps)) {
    this.menu.setIcon(icon);
  }
  menuItem.repaint();
  this.menu.repaint();
}","/** 
 * Updates the protocol account status.
 * @param pps the protocol provider service to update
 */
public void updateAccountStatus(ProtocolProviderService pps){
  JMenuItem menuItem=accountsTable.get(pps);
  Icon icon=new ImageIcon(ImageLoader.getAccountStatusImage(pps));
  ProtocolProviderService selectedPPS=(ProtocolProviderService)menu.getSelectedObject();
  if (selectedPPS.equals(pps) && !pps.isRegistered()) {
    ProtocolProviderService newPPS=findFirstRegisteredProvider();
    if (newPPS != null)     this.setSelected(newPPS);
  }
  if (!selectedPPS.equals(pps) && !selectedPPS.isRegistered() && pps.isRegistered()) {
    this.setSelected(pps);
  }
  menuItem.setIcon(icon);
  if (menu.getSelectedObject().equals(pps)) {
    this.menu.setIcon(icon);
  }
  menuItem.repaint();
  this.menu.repaint();
}",0.987045033929673
104234,"/** 
 * Adds an account to this account selector box. The account is represented by its protocol provider.
 * @param pps the protocol provider for the added account
 */
public void addAccount(ProtocolProviderService pps){
  Image img=createAccountStatusImage(pps);
  JMenuItem menuItem=new JMenuItem(pps.getAccountID().getDisplayName(),new ImageIcon(img));
  menuItem.addActionListener(this);
  this.accountsTable.put(pps,menuItem);
  this.menu.add(menuItem);
  if (accountsTable.size() < 2) {
    this.setSelected(pps);
  }
 else {
    OperationSetPresence presence=(OperationSetPresence)pps.getOperationSet(OperationSetPresence.class);
    OperationSetPresence selectedPresence=(OperationSetPresence)selectedProvider.getOperationSet(OperationSetPresence.class);
    if (presence != null && selectedPresence != null && (selectedPresence.getPresenceStatus().getStatus() < presence.getPresenceStatus().getStatus())) {
      setSelected(pps);
    }
 else     if (pps.isRegistered() && !selectedProvider.isRegistered()) {
      setSelected(pps);
    }
  }
}","/** 
 * Adds an account to this account selector box. The account is represented by its protocol provider.
 * @param pps the protocol provider for the added account
 */
public void addAccount(ProtocolProviderService pps){
  Image img=ImageLoader.getAccountStatusImage(pps);
  JMenuItem menuItem=new JMenuItem(pps.getAccountID().getDisplayName(),new ImageIcon(img));
  menuItem.addActionListener(this);
  this.accountsTable.put(pps,menuItem);
  this.menu.add(menuItem);
  if (accountsTable.size() < 2) {
    this.setSelected(pps);
  }
 else {
    OperationSetPresence presence=(OperationSetPresence)pps.getOperationSet(OperationSetPresence.class);
    OperationSetPresence selectedPresence=(OperationSetPresence)selectedProvider.getOperationSet(OperationSetPresence.class);
    if (presence != null && selectedPresence != null && (selectedPresence.getPresenceStatus().getStatus() < presence.getPresenceStatus().getStatus())) {
      setSelected(pps);
    }
 else     if (pps.isRegistered() && !selectedProvider.isRegistered()) {
      setSelected(pps);
    }
  }
}",0.990080302314596
104235,"/** 
 * Initializes the menu, by adding all containing menu items.
 */
private void init(){
  this.moveToMenu.setIcon(new ImageIcon(ImageLoader.getImage(ImageLoader.GROUPS_16x16_ICON)));
  this.addSubcontactMenu.setIcon(new ImageIcon(ImageLoader.getImage(ImageLoader.ADD_CONTACT_16x16_ICON)));
  this.removeContactMenu.setIcon(new ImageIcon(ImageLoader.getImage(ImageLoader.DELETE_16x16_ICON)));
  this.moveSubcontactMenu.setIcon(new ImageIcon(ImageLoader.getImage(ImageLoader.MOVE_CONTACT_ICON)));
  this.callContactMenu.setIcon(new ImageIcon(ImageLoader.getImage(ImageLoader.CALL_16x16_ICON)));
  Iterator providers=mainFrame.getProtocolProviders();
  if (providers.hasNext()) {
    JLabel infoLabel=new JLabel(GuiActivator.getResources().getI18NString(""String_Node_Str""));
    infoLabel.setBorder(BorderFactory.createEmptyBorder(0,5,0,0));
    infoLabel.setFont(Constants.FONT.deriveFont(Font.BOLD));
    this.addSubcontactMenu.add(infoLabel);
    this.addSubcontactMenu.addSeparator();
  }
  while (providers.hasNext()) {
    ProtocolProviderService pps=(ProtocolProviderService)providers.next();
    String protocolName=pps.getProtocolName();
    JMenuItem menuItem=new JMenuItem(pps.getAccountID().getDisplayName(),new ImageIcon(createAccountStatusImage(pps)));
    menuItem.setName(addSubcontactPrefix + protocolName);
    menuItem.addActionListener(this);
    this.addSubcontactMenu.add(menuItem);
  }
  Iterator groups=this.mainFrame.getAllGroups();
  if (groups.hasNext()) {
    JLabel infoLabel=new JLabel(GuiActivator.getResources().getI18NString(""String_Node_Str""));
    infoLabel.setBorder(BorderFactory.createEmptyBorder(0,5,0,0));
    infoLabel.setFont(Constants.FONT.deriveFont(Font.BOLD));
    this.moveToMenu.add(infoLabel);
    this.moveToMenu.addSeparator();
  }
  while (groups.hasNext()) {
    MetaContactGroup group=(MetaContactGroup)groups.next();
    JMenuItem menuItem=new JMenuItem(group.getGroupName());
    menuItem.setName(moveToPrefix + group.getMetaUID());
    menuItem.addActionListener(this);
    this.moveToMenu.add(menuItem);
  }
  Iterator contacts=contactItem.getContacts();
  if (contactItem.getContactCount() > 1) {
    JMenuItem allItem=new JMenuItem(allContactsString);
    JMenuItem allItem1=new JMenuItem(allContactsString);
    allItem.addActionListener(this);
    allItem1.addActionListener(this);
    allItem.setName(removeContactPrefix + ""String_Node_Str"");
    allItem1.setName(moveSubcontactPrefix + ""String_Node_Str"");
    this.removeContactMenu.add(allItem);
    this.moveSubcontactMenu.add(allItem1);
    this.removeContactMenu.addSeparator();
    this.moveSubcontactMenu.addSeparator();
  }
  while (contacts.hasNext()) {
    Contact contact=(Contact)contacts.next();
    ProtocolProviderService protocolProvider=contact.getProtocolProvider();
    String contactDisplayName=contact.getDisplayName();
    JMenuItem contactItem=new JMenuItem(contactDisplayName);
    JMenuItem contactItem1=new JMenuItem(contactDisplayName);
    Icon protocolIcon=new ImageIcon(createContactStatusImage(contact));
    contactItem.setIcon(protocolIcon);
    contactItem1.setIcon(protocolIcon);
    contactItem.setName(removeContactPrefix + contact.getAddress() + protocolProvider.getProtocolName());
    contactItem1.setName(moveSubcontactPrefix + contact.getAddress() + protocolProvider.getProtocolName());
    contactItem.addActionListener(this);
    contactItem1.addActionListener(this);
    this.removeContactMenu.add(contactItem);
    this.moveSubcontactMenu.add(contactItem1);
    if (contact.getProtocolProvider().getOperationSet(OperationSetBasicTelephony.class) != null) {
      JMenuItem callContactItem=new JMenuItem(contactDisplayName);
      callContactItem.setIcon(protocolIcon);
      callContactItem.setName(callContactPrefix + contact.getAddress() + protocolProvider.getProtocolName());
      callContactItem.addActionListener(this);
      this.callContactMenu.add(callContactItem);
    }
    protocolProvider.getOperationSet(OperationSetWebContactInfo.class);
  }
  this.add(sendMessageItem);
  this.add(sendSmsItem);
  if (callContactMenu.getItemCount() > 1) {
    this.add(callContactMenu);
  }
 else {
    this.add(callItem);
  }
  this.add(sendFileItem);
  this.addSeparator();
  this.add(moveToMenu);
  this.add(moveSubcontactMenu);
  this.addSeparator();
  this.add(addSubcontactMenu);
  this.addSeparator();
  this.add(removeContactMenu);
  this.add(renameContactItem);
  this.addSeparator();
  this.add(viewHistoryItem);
  this.initPluginComponents();
  this.sendMessageItem.setName(""String_Node_Str"");
  this.callItem.setName(""String_Node_Str"");
  this.sendSmsItem.setName(""String_Node_Str"");
  this.sendFileItem.setName(""String_Node_Str"");
  this.moveToMenu.setName(""String_Node_Str"");
  this.addSubcontactMenu.setName(""String_Node_Str"");
  this.renameContactItem.setName(""String_Node_Str"");
  this.viewHistoryItem.setName(""String_Node_Str"");
  this.sendMessageItem.addActionListener(this);
  this.callItem.addActionListener(this);
  this.sendSmsItem.addActionListener(this);
  this.sendFileItem.addActionListener(this);
  this.renameContactItem.addActionListener(this);
  this.viewHistoryItem.addActionListener(this);
  if (contactItem.getDefaultContact(OperationSetFileTransfer.class) == null)   this.sendFileItem.setEnabled(false);
  if (contactItem.getDefaultContact(OperationSetBasicTelephony.class) == null)   this.callItem.setEnabled(false);
  if (contactItem.getDefaultContact(OperationSetBasicInstantMessaging.class) == null)   this.sendMessageItem.setEnabled(false);
  if (contactItem.getDefaultContact(OperationSetSmsMessaging.class) == null)   this.sendSmsItem.setEnabled(false);
}","/** 
 * Initializes the menu, by adding all containing menu items.
 */
private void init(){
  this.moveToMenu.setIcon(new ImageIcon(ImageLoader.getImage(ImageLoader.GROUPS_16x16_ICON)));
  this.addSubcontactMenu.setIcon(new ImageIcon(ImageLoader.getImage(ImageLoader.ADD_CONTACT_16x16_ICON)));
  this.removeContactMenu.setIcon(new ImageIcon(ImageLoader.getImage(ImageLoader.DELETE_16x16_ICON)));
  this.moveSubcontactMenu.setIcon(new ImageIcon(ImageLoader.getImage(ImageLoader.MOVE_CONTACT_ICON)));
  this.callContactMenu.setIcon(new ImageIcon(ImageLoader.getImage(ImageLoader.CALL_16x16_ICON)));
  Iterator providers=mainFrame.getProtocolProviders();
  if (providers.hasNext()) {
    JLabel infoLabel=new JLabel(GuiActivator.getResources().getI18NString(""String_Node_Str""));
    infoLabel.setBorder(BorderFactory.createEmptyBorder(0,5,0,0));
    infoLabel.setFont(Constants.FONT.deriveFont(Font.BOLD));
    this.addSubcontactMenu.add(infoLabel);
    this.addSubcontactMenu.addSeparator();
  }
  while (providers.hasNext()) {
    ProtocolProviderService pps=(ProtocolProviderService)providers.next();
    String protocolName=pps.getProtocolName();
    JMenuItem menuItem=new JMenuItem(pps.getAccountID().getDisplayName(),new ImageIcon(ImageLoader.getAccountStatusImage(pps)));
    menuItem.setName(addSubcontactPrefix + protocolName);
    menuItem.addActionListener(this);
    this.addSubcontactMenu.add(menuItem);
  }
  Iterator groups=this.mainFrame.getAllGroups();
  if (groups.hasNext()) {
    JLabel infoLabel=new JLabel(GuiActivator.getResources().getI18NString(""String_Node_Str""));
    infoLabel.setBorder(BorderFactory.createEmptyBorder(0,5,0,0));
    infoLabel.setFont(Constants.FONT.deriveFont(Font.BOLD));
    this.moveToMenu.add(infoLabel);
    this.moveToMenu.addSeparator();
  }
  while (groups.hasNext()) {
    MetaContactGroup group=(MetaContactGroup)groups.next();
    JMenuItem menuItem=new JMenuItem(group.getGroupName());
    menuItem.setName(moveToPrefix + group.getMetaUID());
    menuItem.addActionListener(this);
    this.moveToMenu.add(menuItem);
  }
  Iterator contacts=contactItem.getContacts();
  if (contactItem.getContactCount() > 1) {
    JMenuItem allItem=new JMenuItem(allContactsString);
    JMenuItem allItem1=new JMenuItem(allContactsString);
    allItem.addActionListener(this);
    allItem1.addActionListener(this);
    allItem.setName(removeContactPrefix + ""String_Node_Str"");
    allItem1.setName(moveSubcontactPrefix + ""String_Node_Str"");
    this.removeContactMenu.add(allItem);
    this.moveSubcontactMenu.add(allItem1);
    this.removeContactMenu.addSeparator();
    this.moveSubcontactMenu.addSeparator();
  }
  while (contacts.hasNext()) {
    Contact contact=(Contact)contacts.next();
    ProtocolProviderService protocolProvider=contact.getProtocolProvider();
    String contactDisplayName=contact.getDisplayName();
    JMenuItem contactItem=new JMenuItem(contactDisplayName);
    JMenuItem contactItem1=new JMenuItem(contactDisplayName);
    Icon protocolIcon=new ImageIcon(createContactStatusImage(contact));
    contactItem.setIcon(protocolIcon);
    contactItem1.setIcon(protocolIcon);
    contactItem.setName(removeContactPrefix + contact.getAddress() + protocolProvider.getProtocolName());
    contactItem1.setName(moveSubcontactPrefix + contact.getAddress() + protocolProvider.getProtocolName());
    contactItem.addActionListener(this);
    contactItem1.addActionListener(this);
    this.removeContactMenu.add(contactItem);
    this.moveSubcontactMenu.add(contactItem1);
    if (contact.getProtocolProvider().getOperationSet(OperationSetBasicTelephony.class) != null) {
      JMenuItem callContactItem=new JMenuItem(contactDisplayName);
      callContactItem.setIcon(protocolIcon);
      callContactItem.setName(callContactPrefix + contact.getAddress() + protocolProvider.getProtocolName());
      callContactItem.addActionListener(this);
      this.callContactMenu.add(callContactItem);
    }
    protocolProvider.getOperationSet(OperationSetWebContactInfo.class);
  }
  this.add(sendMessageItem);
  this.add(sendSmsItem);
  if (callContactMenu.getItemCount() > 1) {
    this.add(callContactMenu);
  }
 else {
    this.add(callItem);
  }
  this.add(sendFileItem);
  this.addSeparator();
  this.add(moveToMenu);
  this.add(moveSubcontactMenu);
  this.addSeparator();
  this.add(addSubcontactMenu);
  this.addSeparator();
  this.add(removeContactMenu);
  this.add(renameContactItem);
  this.addSeparator();
  this.add(viewHistoryItem);
  this.initPluginComponents();
  this.sendMessageItem.setName(""String_Node_Str"");
  this.callItem.setName(""String_Node_Str"");
  this.sendSmsItem.setName(""String_Node_Str"");
  this.sendFileItem.setName(""String_Node_Str"");
  this.moveToMenu.setName(""String_Node_Str"");
  this.addSubcontactMenu.setName(""String_Node_Str"");
  this.renameContactItem.setName(""String_Node_Str"");
  this.viewHistoryItem.setName(""String_Node_Str"");
  this.sendMessageItem.addActionListener(this);
  this.callItem.addActionListener(this);
  this.sendSmsItem.addActionListener(this);
  this.sendFileItem.addActionListener(this);
  this.renameContactItem.addActionListener(this);
  this.viewHistoryItem.addActionListener(this);
  if (contactItem.getDefaultContact(OperationSetFileTransfer.class) == null)   this.sendFileItem.setEnabled(false);
  if (contactItem.getDefaultContact(OperationSetBasicTelephony.class) == null)   this.callItem.setEnabled(false);
  if (contactItem.getDefaultContact(OperationSetBasicInstantMessaging.class) == null)   this.sendMessageItem.setEnabled(false);
  if (contactItem.getDefaultContact(OperationSetSmsMessaging.class) == null)   this.sendSmsItem.setEnabled(false);
}",0.998145040190796
104236,"/** 
 * Creates an instance of GroupRightButtonMenu.
 * @param mainFrame The parent <tt>MainFrame</tt> window.
 * @param group The <tt>MetaContactGroup</tt> for which the menu is opened.
 */
public GroupRightButtonMenu(MainFrame mainFrame,MetaContactGroup group){
  this.group=group;
  this.mainFrame=mainFrame;
  this.addContactMenu.setIcon(new ImageIcon(ImageLoader.getImage(ImageLoader.ADD_CONTACT_16x16_ICON)));
  this.add(addContactMenu);
  Iterator providers=mainFrame.getProtocolProviders();
  while (providers.hasNext()) {
    ProtocolProviderService pps=(ProtocolProviderService)providers.next();
    boolean isHidden=pps.getAccountID().getAccountProperty(ProtocolProviderFactory.IS_PROTOCOL_HIDDEN) != null;
    if (isHidden)     continue;
    String protocolName=pps.getProtocolName();
    AccountMenuItem menuItem=new AccountMenuItem(pps,new ImageIcon(createAccountStatusImage(pps)));
    menuItem.setName(protocolName);
    menuItem.addActionListener(this);
    this.addContactMenu.add(menuItem);
  }
  this.addSeparator();
  this.add(renameGroupItem);
  this.add(removeGroupItem);
  this.renameGroupItem.setName(""String_Node_Str"");
  this.removeGroupItem.setName(""String_Node_Str"");
  this.addContactMenu.setMnemonic(GuiActivator.getResources().getI18nMnemonic(""String_Node_Str""));
  this.renameGroupItem.setMnemonic(GuiActivator.getResources().getI18nMnemonic(""String_Node_Str""));
  this.removeGroupItem.setMnemonic(GuiActivator.getResources().getI18nMnemonic(""String_Node_Str""));
  this.renameGroupItem.addActionListener(this);
  this.removeGroupItem.addActionListener(this);
  this.initPluginComponents();
}","/** 
 * Creates an instance of GroupRightButtonMenu.
 * @param mainFrame The parent <tt>MainFrame</tt> window.
 * @param group The <tt>MetaContactGroup</tt> for which the menu is opened.
 */
public GroupRightButtonMenu(MainFrame mainFrame,MetaContactGroup group){
  this.group=group;
  this.mainFrame=mainFrame;
  this.addContactMenu.setIcon(new ImageIcon(ImageLoader.getImage(ImageLoader.ADD_CONTACT_16x16_ICON)));
  this.add(addContactMenu);
  Iterator providers=mainFrame.getProtocolProviders();
  while (providers.hasNext()) {
    ProtocolProviderService pps=(ProtocolProviderService)providers.next();
    boolean isHidden=pps.getAccountID().getAccountProperty(ProtocolProviderFactory.IS_PROTOCOL_HIDDEN) != null;
    if (isHidden)     continue;
    String protocolName=pps.getProtocolName();
    AccountMenuItem menuItem=new AccountMenuItem(pps,new ImageIcon(ImageLoader.getAccountStatusImage(pps)));
    menuItem.setName(protocolName);
    menuItem.addActionListener(this);
    this.addContactMenu.add(menuItem);
  }
  this.addSeparator();
  this.add(renameGroupItem);
  this.add(removeGroupItem);
  this.renameGroupItem.setName(""String_Node_Str"");
  this.removeGroupItem.setName(""String_Node_Str"");
  this.addContactMenu.setMnemonic(GuiActivator.getResources().getI18nMnemonic(""String_Node_Str""));
  this.renameGroupItem.setMnemonic(GuiActivator.getResources().getI18nMnemonic(""String_Node_Str""));
  this.removeGroupItem.setMnemonic(GuiActivator.getResources().getI18nMnemonic(""String_Node_Str""));
  this.renameGroupItem.addActionListener(this);
  this.removeGroupItem.addActionListener(this);
  this.initPluginComponents();
}",0.9935523487872276
104237,"AEGetURLEventHandler(LaunchArgHandler launchArgHandler){
  this.launchArgHandler=launchArgHandler;
  setAEGetURLListener(new IAEGetURLListener(){
    public void handleAEGetURLEvent(    final String url){
      new Thread(){
        public void run(){
          AEGetURLEventHandler.this.launchArgHandler.handleArgs(new String[]{url});
        }
      }
.start();
    }
  }
);
}","AEGetURLEventHandler(LaunchArgHandler launchArgHandler){
  this.launchArgHandler=launchArgHandler;
  try {
    setAEGetURLListener(new IAEGetURLListener(){
      public void handleAEGetURLEvent(      final String url){
        new Thread(){
          public void run(){
            AEGetURLEventHandler.this.launchArgHandler.handleArgs(new String[]{url});
          }
        }
.start();
      }
    }
);
  }
 catch (  Throwable err) {
    System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"");
    err.printStackTrace();
  }
}",0.7381974248927039
104238,"public ActionMenuPanel(){
  super(new FlowLayout(FlowLayout.LEFT,15,15));
  this.setOpaque(false);
  this.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));
  this.initListeners();
  SIPCommButton addContactButton=new SIPCommButton(ImageLoader.getImage(ImageLoader.QUICK_MENU_ADD_ICON));
  SIPCommButton optionsButton=new SIPCommButton(ImageLoader.getImage(ImageLoader.QUICK_MENU_CONFIGURE_ICON));
  SIPCommButton showOfflineButton;
  boolean isShowOffline=ConfigurationManager.isShowOffline();
  if (isShowOffline)   showOfflineButton=new SIPCommButton(ImageLoader.getImage(ImageLoader.QUICK_MENU_HIDE_OFFLINE_ICON));
 else   showOfflineButton=new SIPCommButton(ImageLoader.getImage(ImageLoader.QUICK_MENU_SHOW_OFFLINE_ICON));
  SIPCommButton soundButton;
  boolean isMute=GuiActivator.getAudioNotifier().isMute();
  if (isMute)   soundButton=new SIPCommButton(ImageLoader.getImage(ImageLoader.QUICK_MENU_SOUND_ON_ICON));
 else   soundButton=new SIPCommButton(ImageLoader.getImage(ImageLoader.QUICK_MENU_SOUND_OFF_ICON));
  SIPCommButton myChatRoomsButton=new SIPCommButton(ImageLoader.getImage(ImageLoader.QUICK_MENU_MY_CHAT_ROOMS_ICON));
  addContactButton.addActionListener(this);
  optionsButton.addActionListener(this);
  showOfflineButton.addActionListener(this);
  soundButton.addActionListener(this);
  myChatRoomsButton.addActionListener(this);
  addContactButton.setName(""String_Node_Str"");
  optionsButton.setName(""String_Node_Str"");
  showOfflineButton.setName(""String_Node_Str"");
  soundButton.setName(""String_Node_Str"");
  myChatRoomsButton.setName(""String_Node_Str"");
  JPanel addContactPanel=createMoreActionsButtonPanel(addContactButton,""String_Node_Str"");
  JPanel configPanel=createMoreActionsButtonPanel(optionsButton,""String_Node_Str"");
  JPanel showOfflinePanel=createMoreActionsButtonPanel(showOfflineButton,""String_Node_Str"");
  JPanel soundPanel=createMoreActionsButtonPanel(soundButton,""String_Node_Str"");
  JPanel myChatRoomsPanel=createMoreActionsButtonPanel(myChatRoomsButton,""String_Node_Str"");
  this.add(addContactPanel);
  this.add(configPanel);
  this.add(showOfflinePanel);
  this.add(soundPanel);
  this.add(myChatRoomsPanel);
  this.initPluginComponents();
}","public ActionMenuPanel(){
  super(new FlowLayout(FlowLayout.CENTER,15,15));
  this.setOpaque(false);
  this.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));
  this.initListeners();
  SIPCommButton addContactButton=new SIPCommButton(ImageLoader.getImage(ImageLoader.QUICK_MENU_ADD_ICON));
  SIPCommButton optionsButton=new SIPCommButton(ImageLoader.getImage(ImageLoader.QUICK_MENU_CONFIGURE_ICON));
  SIPCommButton showOfflineButton;
  boolean isShowOffline=ConfigurationManager.isShowOffline();
  if (isShowOffline)   showOfflineButton=new SIPCommButton(ImageLoader.getImage(ImageLoader.QUICK_MENU_HIDE_OFFLINE_ICON));
 else   showOfflineButton=new SIPCommButton(ImageLoader.getImage(ImageLoader.QUICK_MENU_SHOW_OFFLINE_ICON));
  SIPCommButton soundButton;
  boolean isMute=GuiActivator.getAudioNotifier().isMute();
  if (isMute)   soundButton=new SIPCommButton(ImageLoader.getImage(ImageLoader.QUICK_MENU_SOUND_ON_ICON));
 else   soundButton=new SIPCommButton(ImageLoader.getImage(ImageLoader.QUICK_MENU_SOUND_OFF_ICON));
  SIPCommButton myChatRoomsButton=new SIPCommButton(ImageLoader.getImage(ImageLoader.QUICK_MENU_MY_CHAT_ROOMS_ICON));
  addContactButton.addActionListener(this);
  optionsButton.addActionListener(this);
  showOfflineButton.addActionListener(this);
  soundButton.addActionListener(this);
  myChatRoomsButton.addActionListener(this);
  addContactButton.setName(""String_Node_Str"");
  optionsButton.setName(""String_Node_Str"");
  showOfflineButton.setName(""String_Node_Str"");
  soundButton.setName(""String_Node_Str"");
  myChatRoomsButton.setName(""String_Node_Str"");
  JPanel addContactPanel=createMoreActionsButtonPanel(addContactButton,""String_Node_Str"");
  JPanel configPanel=createMoreActionsButtonPanel(optionsButton,""String_Node_Str"");
  JPanel showOfflinePanel=createMoreActionsButtonPanel(showOfflineButton,""String_Node_Str"");
  JPanel soundPanel=createMoreActionsButtonPanel(soundButton,""String_Node_Str"");
  JPanel myChatRoomsPanel=createMoreActionsButtonPanel(myChatRoomsButton,""String_Node_Str"");
  this.add(addContactPanel);
  this.add(configPanel);
  this.add(showOfflinePanel);
  this.add(soundPanel);
  this.add(myChatRoomsPanel);
  this.initPluginComponents();
}",0.9986357435197816
104239,"/** 
 * Draws the background of the menu item.
 * @param g the paint graphics
 * @param menuItem menu item to be painted
 * @param bgColor selection background color
 * @since 1.4
 */
protected void paintBackground(Graphics g,JMenuItem menuItem,Color bgColor){
  AntialiasingManager.activateAntialiasing(g);
  super.paintBackground(g,menuItem,bgColor);
  boolean isToolBarExtended=new Boolean(GuiActivator.getResources().getSettingsString(""String_Node_Str"")).booleanValue();
  if (!isToolBarExtended) {
    int menuWidth=menuItem.getWidth();
    int menuHeight=menuItem.getHeight();
    g.drawImage(menuBgImage,0,0,menuWidth,menuHeight,null);
  }
}","/** 
 * Draws the background of the menu item.
 * @param g the paint graphics
 * @param menuItem menu item to be painted
 * @param bgColor selection background color
 * @since 1.4
 */
protected void paintBackground(Graphics g,JMenuItem menuItem,Color bgColor){
  super.paintBackground(g,menuItem,bgColor);
  boolean isToolBarExtended=new Boolean(GuiActivator.getResources().getSettingsString(""String_Node_Str"")).booleanValue();
  if (!isToolBarExtended) {
    g=g.create();
    try {
      AntialiasingManager.activateAntialiasing(g);
      int menuWidth=menuItem.getWidth();
      int menuHeight=menuItem.getHeight();
      g.drawImage(menuBgImage,0,0,menuWidth,menuHeight,null);
    }
  finally {
      g.dispose();
    }
  }
}",0.8729121278140886
104240,"/** 
 * Draws the background of the menu item.
 * @param g the paint graphics
 * @param menuItem menu item to be painted
 * @param bgColor selection background color
 * @since 1.4
 */
protected void paintBackground(Graphics g,JMenuItem menuItem,Color bgColor){
  AntialiasingManager.activateAntialiasing(g);
  super.paintBackground(g,menuItem,bgColor);
  ButtonModel model=menuItem.getModel();
  Color oldColor=g.getColor();
  int menuWidth=menuItem.getWidth();
  int menuHeight=menuItem.getHeight();
  if (menuItem.isOpaque()) {
    if (model.isArmed() || (menuItem instanceof JMenu && model.isSelected())) {
      g.setColor(bgColor);
      g.fillRoundRect(0,0,menuWidth,menuHeight,5,5);
      g.setColor(SIPCommLookAndFeel.getControlDarkShadow());
      g.drawRoundRect(0,0,menuWidth - 1,menuHeight - 1,5,5);
    }
 else {
      g.setColor(menuItem.getBackground());
      g.fillRoundRect(0,0,menuWidth,menuHeight,5,5);
    }
    g.setColor(oldColor);
  }
}","/** 
 * Draws the background of the menu item.
 * @param g the paint graphics
 * @param menuItem menu item to be painted
 * @param bgColor selection background color
 * @since 1.4
 */
protected void paintBackground(Graphics g,JMenuItem menuItem,Color bgColor){
  super.paintBackground(g,menuItem,bgColor);
  g=g.create();
  try {
    internalPaintBackground(g,menuItem,bgColor);
  }
  finally {
    g.dispose();
  }
}",0.429920116194626
104241,"/** 
 * Draws the background of the menu item.
 * @param g the paint graphics
 * @param menuItem menu item to be painted
 * @param bgColor selection background color
 * @since 1.4
 */
protected void paintBackground(Graphics g,JMenuItem menuItem,Color bgColor){
  AntialiasingManager.activateAntialiasing(g);
  super.paintBackground(g,menuItem,bgColor);
  ButtonModel model=menuItem.getModel();
  Color oldColor=g.getColor();
  int menuWidth=menuItem.getWidth();
  int menuHeight=menuItem.getHeight();
  if (menuItem.isOpaque()) {
    if (model.isArmed() || (menuItem instanceof JMenu && model.isSelected())) {
      g.setColor(bgColor);
      g.fillRoundRect(0,0,menuWidth,menuHeight,5,5);
      g.setColor(SIPCommLookAndFeel.getControlDarkShadow());
      g.drawRoundRect(0,0,menuWidth - 1,menuHeight - 1,5,5);
    }
 else {
      g.setColor(menuItem.getBackground());
      g.fillRoundRect(0,0,menuWidth,menuHeight,5,5);
    }
    g.setColor(oldColor);
  }
}","/** 
 * Draws the background of the menu item.
 * @param g the paint graphics
 * @param menuItem menu item to be painted
 * @param bgColor selection background color
 * @since 1.4
 */
protected void paintBackground(Graphics g,JMenuItem menuItem,Color bgColor){
  super.paintBackground(g,menuItem,bgColor);
  g=g.create();
  try {
    internalPaintBackground(g,menuItem,bgColor);
  }
  finally {
    g.dispose();
  }
}",0.429920116194626
104242,"/** 
 * Draws the background of the menu.
 * @param g the paint graphics
 * @param menuItem menu item to be painted
 * @param bgColor selection background color
 * @since 1.4
 */
protected void paintBackground(Graphics g,JMenuItem menuItem,Color bgColor){
  AntialiasingManager.activateAntialiasing(g);
  super.paintBackground(g,menuItem,bgColor);
  ButtonModel model=menuItem.getModel();
  Color oldColor=g.getColor();
  int menuWidth=menuItem.getWidth();
  int menuHeight=menuItem.getHeight();
  if (menuItem.isOpaque()) {
    if (model.isArmed() || (menuItem instanceof JMenu && model.isSelected())) {
      g.setColor(bgColor);
      g.fillRoundRect(0,0,menuWidth,menuHeight,5,5);
      g.setColor(SIPCommLookAndFeel.getControlDarkShadow());
      g.drawRoundRect(0,0,menuWidth - 1,menuHeight - 1,5,5);
    }
 else {
      g.setColor(menuItem.getBackground());
      g.fillRoundRect(0,0,menuWidth,menuHeight,5,5);
    }
    g.setColor(oldColor);
  }
}","/** 
 * Draws the background of the menu.
 * @param g the paint graphics
 * @param menuItem menu item to be painted
 * @param bgColor selection background color
 * @since 1.4
 */
protected void paintBackground(Graphics g,JMenuItem menuItem,Color bgColor){
  super.paintBackground(g,menuItem,bgColor);
  g=g.create();
  try {
    internalPaintBackground(g,menuItem,bgColor);
  }
  finally {
    g.dispose();
  }
}",0.4257498171177761
104243,"/** 
 * Draws the background of the menu item.
 * @param g the paint graphics
 * @param menuItem menu item to be painted
 * @param bgColor selection background color
 * @since 1.4
 */
protected void paintBackground(Graphics g,JMenuItem menuItem,Color bgColor){
  AntialiasingManager.activateAntialiasing(g);
  int menuWidth=menuItem.getWidth();
  int menuHeight=menuItem.getHeight();
  g.drawImage(menuBgImage,0,0,menuWidth,menuHeight,null);
}","/** 
 * Draws the background of the menu item.
 * @param g the paint graphics
 * @param menuItem menu item to be painted
 * @param bgColor selection background color
 * @since 1.4
 */
protected void paintBackground(Graphics g,JMenuItem menuItem,Color bgColor){
  g=g.create();
  try {
    AntialiasingManager.activateAntialiasing(g);
    int menuWidth=menuItem.getWidth();
    int menuHeight=menuItem.getHeight();
    g.drawImage(menuBgImage,0,0,menuWidth,menuHeight,null);
  }
  finally {
    g.dispose();
  }
}",0.9277486910994764
104244,"/** 
 * Draws the background of the menu.
 * @param g the paint graphics
 * @param menuItem menu item to be painted
 * @param bgColor selection background color
 * @since 1.4
 */
protected void paintBackground(Graphics g,JMenuItem menuItem,Color bgColor){
  AntialiasingManager.activateAntialiasing(g);
  super.paintBackground(g,menuItem,bgColor);
  Color oldColor=g.getColor();
  int menuWidth=menuItem.getWidth();
  int menuHeight=menuItem.getHeight();
  if (menuItem.isSelected()) {
    g.setColor(Color.LIGHT_GRAY);
    g.fillRoundRect(0,0,menuWidth,menuHeight,8,8);
  }
  g.setColor(oldColor);
}","/** 
 * Draws the background of the menu.
 * @param g the paint graphics
 * @param menuItem menu item to be painted
 * @param bgColor selection background color
 * @since 1.4
 */
protected void paintBackground(Graphics g,JMenuItem menuItem,Color bgColor){
  super.paintBackground(g,menuItem,bgColor);
  g=g.create();
  try {
    internalPaintBackground(g,menuItem,bgColor);
  }
  finally {
    g.dispose();
  }
}",0.5790513833992095
104245,"protected void paintTabBackground(Graphics g,int tabPlacement,int tabIndex,int x,int y,int w,int h,boolean isSelected){
  BufferedImage leftImg=null;
  BufferedImage middleImg=null;
  BufferedImage rightImg=null;
  Graphics2D g2=(Graphics2D)g;
  AntialiasingManager.activateAntialiasing(g2);
  int tabOverlap=0;
  if (isSelected) {
    if (tabPane.isEnabledAt(tabIndex)) {
      leftImg=UtilActivator.getImage(SELECTED_TAB_LEFT_BG);
      middleImg=UtilActivator.getImage(SELECTED_TAB_MIDDLE_BG);
      rightImg=UtilActivator.getImage(SELECTED_TAB_RIGHT_BG);
      tabOverlap=TAB_OVERLAP;
    }
 else {
      leftImg=UtilActivator.getImage(TAB_LEFT_BG);
      middleImg=UtilActivator.getImage(TAB_MIDDLE_BG);
      rightImg=UtilActivator.getImage(TAB_RIGHT_BG);
    }
  }
 else {
    leftImg=UtilActivator.getImage(TAB_LEFT_BG);
    middleImg=UtilActivator.getImage(TAB_MIDDLE_BG);
    rightImg=UtilActivator.getImage(TAB_RIGHT_BG);
  }
  g2.drawImage(leftImg,x,y,null);
  g2.drawImage(middleImg,x + leftImg.getWidth(),y,w - leftImg.getWidth() - rightImg.getWidth() + tabOverlap,leftImg.getHeight(),null);
  g2.drawImage(rightImg,x + w - rightImg.getWidth() + tabOverlap,y,null);
}","protected void paintTabBackground(Graphics g,int tabPlacement,int tabIndex,int x,int y,int w,int h,boolean isSelected){
  g=g.create();
  try {
    internalPaintTabBackground(g,tabPlacement,tabIndex,x,y,w,h,isSelected);
  }
  finally {
    g.dispose();
  }
}",0.1834607366226546
104246,"private void internalPaintComponent(Graphics g){
  AntialiasingManager.activateAntialiasing(g);
  if (isOpaque()) {
    g.setColor(getBackground());
    g.fillRect(0,0,getWidth(),getHeight());
  }
  if (this.bgImage != null) {
    Image paintBgImage;
    if (this.iconImage == null && !isEnabled()) {
      paintBgImage=new ImageIcon(LightGrayFilter.createDisabledImage(bgImage)).getImage();
    }
 else     paintBgImage=bgImage;
    g.drawImage(paintBgImage,this.getWidth() / 2 - this.bgImage.getWidth(null) / 2,this.getHeight() / 2 - this.bgImage.getHeight(null) / 2,this);
  }
  if (this.iconImage != null) {
    Image paintIconImage;
    if (!isEnabled()) {
      paintIconImage=new ImageIcon(LightGrayFilter.createDisabledImage(iconImage)).getImage();
    }
 else     paintIconImage=iconImage;
    g.drawImage(paintIconImage,this.getWidth() / 2 - this.iconImage.getWidth(null) / 2,this.getHeight() / 2 - this.iconImage.getHeight(null) / 2,this);
  }
  FadeTracker fadeTracker=FadeTracker.getInstance();
  float visibility=this.getModel().isRollover() ? 1.0f : 0.0f;
  if (fadeTracker.isTracked(this,FadeKind.ROLLOVER)) {
    visibility=fadeTracker.getFade(this,FadeKind.ROLLOVER);
  }
  g.setColor(new Color(1.0f,1.0f,1.0f,visibility / 2));
  if (this.bgImage != null) {
    g.fillRoundRect(this.getWidth() / 2 - this.bgImage.getWidth(null) / 2,this.getHeight() / 2 - this.bgImage.getHeight(null) / 2,bgImage.getWidth(null),bgImage.getHeight(null),10,10);
  }
 else {
    g.fillRoundRect(0,0,this.getWidth(),this.getHeight(),10,10);
  }
  if (this.getModel().isPressed()) {
    if (this.pressedImage != null) {
      g.drawImage(this.pressedImage,0,0,this);
    }
 else     if (this.iconImage != null) {
      g.drawImage(this.iconImage,this.getWidth() / 2 - this.iconImage.getWidth(null) / 2 + 1,this.getHeight() / 2 - this.iconImage.getHeight(null) / 2 + 1,this);
    }
  }
}","private void internalPaintComponent(Graphics g){
  AntialiasingManager.activateAntialiasing(g);
  if (isOpaque()) {
    g.setColor(getBackground());
    g.fillRect(0,0,getWidth(),getHeight());
  }
  if (this.bgImage != null) {
    Image paintBgImage;
    if (this.iconImage == null && !isEnabled()) {
      paintBgImage=new ImageIcon(LightGrayFilter.createDisabledImage(bgImage)).getImage();
    }
 else     paintBgImage=bgImage;
    g.drawImage(paintBgImage,this.getWidth() / 2 - this.bgImage.getWidth(null) / 2,this.getHeight() / 2 - this.bgImage.getHeight(null) / 2,this);
  }
  if (this.iconImage != null) {
    Image paintIconImage;
    if (!isEnabled()) {
      paintIconImage=new ImageIcon(LightGrayFilter.createDisabledImage(iconImage)).getImage();
    }
 else     paintIconImage=iconImage;
    g.drawImage(paintIconImage,this.getWidth() / 2 - this.iconImage.getWidth(null) / 2,this.getHeight() / 2 - this.iconImage.getHeight(null) / 2,this);
  }
  FadeTracker fadeTracker=FadeTracker.getInstance();
  float visibility=this.getModel().isRollover() ? 1.0f : 0.0f;
  if (fadeTracker.isTracked(this,FadeKind.ROLLOVER)) {
    visibility=fadeTracker.getFade(this,FadeKind.ROLLOVER);
  }
  visibility/=2;
  g.setColor(new Color(1.0f,1.0f,1.0f,visibility));
  if (this.bgImage != null) {
    g.fillRoundRect(this.getWidth() / 2 - this.bgImage.getWidth(null) / 2,this.getHeight() / 2 - this.bgImage.getHeight(null) / 2,bgImage.getWidth(null),bgImage.getHeight(null),10,10);
  }
 else   if (isContentAreaFilled() || (visibility != 0.0f)) {
    g.fillRoundRect(0,0,this.getWidth(),this.getHeight(),10,10);
  }
  if (this.getModel().isPressed()) {
    if (this.pressedImage != null) {
      g.drawImage(this.pressedImage,0,0,this);
    }
 else     if (this.iconImage != null) {
      g.drawImage(this.iconImage,this.getWidth() / 2 - this.iconImage.getWidth(null) / 2 + 1,this.getHeight() / 2 - this.iconImage.getHeight(null) / 2 + 1,this);
    }
  }
}",0.9806788511749348
104247,"/** 
 * Draws the background of the menu.
 * @param g the paint graphics
 * @param menuItem menu item to be painted
 * @param bgColor selection background color
 * @since 1.4
 */
protected void paintBackground(Graphics g,JMenuItem menuItem,Color bgColor){
  super.paintBackground(g,menuItem,bgColor);
  g=g.create();
  try {
    internalPaintBackground(g,menuItem,bgColor);
  }
  finally {
    g.dispose();
  }
}","/** 
 * Draws the background of the menu.
 * @param g the paint graphics
 * @param menuItem menu item to be painted
 * @param bgColor selection background color
 * @since 1.4
 */
protected void paintBackground(Graphics g,JMenuItem menuItem,Color bgColor){
  if (menuItem.isSelected()) {
    g=g.create();
    try {
      AntialiasingManager.activateAntialiasing(g);
      int menuWidth=menuItem.getWidth();
      int menuHeight=menuItem.getHeight();
      g.setColor(Color.LIGHT_GRAY);
      g.fillRoundRect(0,0,menuWidth,menuHeight,8,8);
    }
  finally {
      g.dispose();
    }
  }
 else {
    super.paintBackground(g,menuItem,bgColor);
  }
}",0.5784499054820416
104248,"/** 
 * Handles the <tt>ActionEvent</tt> generated when user presses one of the buttons in this panel.
 */
public void actionPerformed(ActionEvent evt){
  JButton button=(JButton)evt.getSource();
  String buttonName=button.getName();
  if (buttonName.equals(CALL_BUTTON)) {
    if (isCallMetaContact) {
      Object[] selectedContacts=mainFrame.getContactListPanel().getContactList().getSelectedValues();
      java.util.List<Contact> telephonyContacts=new Vector<Contact>();
      for (int i=0; i < selectedContacts.length; i++) {
        Object o=selectedContacts[i];
        if (o instanceof MetaContact) {
          Contact contact=((MetaContact)o).getDefaultContact(OperationSetBasicTelephony.class);
          if (contact != null)           telephonyContacts.add(contact);
 else {
            new ErrorDialog(this.mainFrame,GuiActivator.getResources().getI18NString(""String_Node_Str""),GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{((MetaContact)o).getDisplayName()})).showDialog();
          }
        }
      }
      if (telephonyContacts.size() > 0)       CallManager.createCall(protocolProvider,telephonyContacts);
    }
 else     if (!phoneNumberCombo.isComboFieldEmpty()) {
      String stringContact=phoneNumberCombo.getEditor().getItem().toString();
      CallManager.createCall(protocolProvider,stringContact);
    }
  }
 else   if (buttonName.equals(DIAL_BUTTON)) {
    if (!dialpadDialog.isVisible()) {
      dialpadDialog.setSize(mainFrame.getWidth() - 20,dialpadDialog.getHeight());
      dialpadDialog.setLocation(mainFrame.getX() + 10,dialButton.getLocationOnScreen().y - dialpadDialog.getHeight());
      dialpadDialog.setVisible(true);
    }
 else {
      dialpadDialog.setVisible(false);
    }
  }
}","/** 
 * Handles the <tt>ActionEvent</tt> generated when user presses one of the buttons in this panel.
 */
public void actionPerformed(ActionEvent evt){
  JButton button=(JButton)evt.getSource();
  String buttonName=button.getName();
  if (buttonName.equals(CALL_BUTTON)) {
    if (isCallMetaContact) {
      Object[] selectedContacts=mainFrame.getContactListPanel().getContactList().getSelectedValues();
      java.util.List<Contact> telephonyContacts=new Vector<Contact>();
      for (int i=0; i < selectedContacts.length; i++) {
        Object o=selectedContacts[i];
        if (o instanceof MetaContact) {
          Contact contact=((MetaContact)o).getDefaultContact(OperationSetBasicTelephony.class);
          if (contact != null)           telephonyContacts.add(contact);
 else {
            new ErrorDialog(this.mainFrame,GuiActivator.getResources().getI18NString(""String_Node_Str""),GuiActivator.getResources().getI18NString(""String_Node_Str"",new String[]{((MetaContact)o).getDisplayName()})).showDialog();
          }
        }
      }
      if (telephonyContacts.size() > 0)       CallManager.createCall(protocolProvider,telephonyContacts);
    }
 else     if (!phoneNumberCombo.isComboFieldEmpty()) {
      String stringContact=phoneNumberCombo.getEditor().getItem().toString();
      CallManager.createCall(protocolProvider,stringContact);
    }
  }
 else   if (buttonName.equals(DIAL_BUTTON)) {
    if (!dialpadDialog.isVisible()) {
      dialpadDialog.setSize(mainFrame.getWidth() - 20,dialpadDialog.getHeight());
      dialpadDialog.setLocation(mainFrame.getX() + 10,button.getLocationOnScreen().y - dialpadDialog.getHeight());
      dialpadDialog.setVisible(true);
    }
 else {
      dialpadDialog.setVisible(false);
    }
  }
}",0.998282770463652
104249,"/** 
 * Initializes and constructs this panel.
 */
public MainCallPanel(MainFrame mainFrame){
  super(new BorderLayout());
  this.mainFrame=mainFrame;
  this.setBorder(BorderFactory.createEmptyBorder(10,0,0,0));
  this.dialpadDialog=new DialpadDialog(this);
  phoneNumberCombo.setEditable(true);
  callButton.setEnabled(false);
  this.add(comboPanel,BorderLayout.NORTH);
  callViaPanel.add(callViaLabel);
  callViaPanel.add(accountSelectorBox);
  buttonsPanel.add(callButton);
  phoneNumberCombo.setOpaque(false);
  comboPanel.add(dialButton,BorderLayout.WEST);
  comboPanel.add(phoneNumberCombo,BorderLayout.CENTER);
  comboPanel.add(buttonsPanel,BorderLayout.EAST);
  callButton.setName(CALL_BUTTON);
  dialButton.setName(DIAL_BUTTON);
  callButton.setToolTipText(GuiActivator.getResources().getI18NString(""String_Node_Str""));
  callButton.addActionListener(this);
  dialButton.addActionListener(this);
  this.initPluginComponents();
}","/** 
 * Initializes and constructs this panel.
 */
public MainCallPanel(MainFrame mainFrame){
  super(new BorderLayout());
  this.mainFrame=mainFrame;
  this.setBorder(BorderFactory.createEmptyBorder(10,0,0,0));
  this.dialpadDialog=new DialpadDialog(this);
  phoneNumberCombo.setEditable(true);
  callButton.setEnabled(false);
  this.add(comboPanel,BorderLayout.NORTH);
  callViaPanel.add(callViaLabel);
  callViaPanel.add(accountSelectorBox);
  buttonsPanel.add(callButton);
  phoneNumberCombo.setOpaque(false);
  comboPanel.add(createDialButton(),BorderLayout.WEST);
  comboPanel.add(phoneNumberCombo,BorderLayout.CENTER);
  comboPanel.add(buttonsPanel,BorderLayout.EAST);
  callButton.setName(CALL_BUTTON);
  callButton.setToolTipText(GuiActivator.getResources().getI18NString(""String_Node_Str""));
  callButton.addActionListener(this);
  this.initPluginComponents();
}",0.9441680486456606
104250,"/** 
 * Removes the account corresponding to the given protocol provider from this menu.
 * @param protocolProvider the protocol provider corresponding to theaccount to remove.
 */
private void removeAccount(ProtocolProviderService protocolProvider){
  Object selector=this.accountSelectors.get(protocolProvider.getAccountID());
  if (menu instanceof Container)   ((Container)menu).remove((Component)selector);
 else   ((MenuContainer)menu).remove((MenuComponent)selector);
}","/** 
 * Removes the account corresponding to the given protocol provider from this menu.
 * @param protocolProvider the protocol provider corresponding to theaccount to remove.
 */
private void removeAccount(ProtocolProviderService protocolProvider){
  Object selector=this.accountSelectors.get(protocolProvider.getAccountID());
  Object selectorMenu;
  if (selector instanceof StatusSimpleSelector)   selectorMenu=((StatusSimpleSelector)selector).getMenu();
 else   selectorMenu=((StatusSelector)selector).getMenu();
  if (menu instanceof Container)   ((Container)menu).remove((Component)selectorMenu);
 else   ((MenuContainer)menu).remove((MenuComponent)selectorMenu);
}",0.8212728857890148
104251,"/** 
 * Puts a the <tt>SendSteam</tt>s of a specific <tt>RTPManager</tt> on/off hold i.e. stops/starts them.
 * @param rtpManager the <tt>RTPManager</tt> to have its<tt>SendStream</tt>s on/off hold i.e. stopped/started
 * @param on <tt>true</tt> to have the <tt>SendStream</tt>s of<tt>rtpManager</tt> put on hold i.e. stopped; <tt>false</tt>, otherwise
 */
private void putOnHold(RTPManager rtpManager,boolean on){
  for (Iterator sendStreamIter=rtpManager.getSendStreams().iterator(); sendStreamIter.hasNext(); ) {
    SendStream sendStream=(SendStream)sendStreamIter.next();
    if (on) {
      try {
        sendStream.getDataSource().stop();
        sendStream.stop();
      }
 catch (      IOException ex) {
        logger.warn(""String_Node_Str"",ex);
      }
    }
 else {
      try {
        sendStream.getDataSource().start();
        sendStream.start();
      }
 catch (      IOException ex) {
        logger.warn(""String_Node_Str"",ex);
      }
    }
  }
}","/** 
 * Puts a the <tt>SendSteam</tt>s of a specific <tt>RTPManager</tt> on/off hold i.e. stops/starts them.
 * @param rtpManager the <tt>RTPManager</tt> to have its<tt>SendStream</tt>s on/off hold i.e. stopped/started
 * @param on <tt>true</tt> to have the <tt>SendStream</tt>s of<tt>rtpManager</tt> put on hold i.e. stopped; <tt>false</tt>, otherwise
 */
private void putOnHold(RTPManager rtpManager,boolean on){
  for (Iterator<SendStream> sendStreamIter=rtpManager.getSendStreams().iterator(); sendStreamIter.hasNext(); ) {
    SendStream sendStream=sendStreamIter.next();
    if (on) {
      try {
        sendStream.getDataSource().stop();
        sendStream.stop();
      }
 catch (      IOException ex) {
        logger.warn(""String_Node_Str"",ex);
      }
    }
 else {
      try {
        sendStream.getDataSource().start();
        sendStream.start();
      }
 catch (      IOException ex) {
        logger.warn(""String_Node_Str"",ex);
      }
    }
  }
}",0.9875518672199172
104252,"/** 
 * Returns a <tt>Hashtable</tt> mapping media types (e.g. audio or video) to lists of JMF encoding strings corresponding to the SDP formats specified in the <tt>mediaDescriptions</tt> vector.
 * @param mediaDescriptions a <tt>Vector</tt> containing<tt>MediaDescription</tt> instances extracted from an SDP offer or answer.
 * @return a <tt>Hashtable</tt> mapping media types (e.g. audio or video) tolists of JMF encoding strings corresponding to the SDP formats specified in the <tt>mediaDescriptions</tt> vector.
 */
private Hashtable<String,List<String>> extractMediaEncodings(Vector mediaDescriptions){
  Hashtable<String,List<String>> mediaEncodings=new Hashtable<String,List<String>>(2);
  Iterator descriptionsIter=mediaDescriptions.iterator();
  while (descriptionsIter.hasNext()) {
    MediaDescription mediaDescription=(MediaDescription)descriptionsIter.next();
    Media media=mediaDescription.getMedia();
    Vector mediaFormats=null;
    String mediaType=null;
    try {
      mediaFormats=media.getMediaFormats(true);
      mediaType=media.getMediaType();
    }
 catch (    SdpParseException ex) {
      logger.warn(""String_Node_Str"",ex);
      continue;
    }
    if (mediaFormats.size() > 0) {
      List<String> jmfEncodings=MediaUtils.sdpToJmfEncodings(mediaFormats);
      if (jmfEncodings.size() > 0)       mediaEncodings.put(mediaType,jmfEncodings);
    }
  }
  logger.trace(""String_Node_Str"" + mediaEncodings);
  return mediaEncodings;
}","/** 
 * Returns a <tt>Hashtable</tt> mapping media types (e.g. audio or video) to lists of JMF encoding strings corresponding to the SDP formats specified in the <tt>mediaDescriptions</tt> vector.
 * @param mediaDescriptions a <tt>Vector</tt> containing<tt>MediaDescription</tt> instances extracted from an SDP offer or answer.
 * @return a <tt>Hashtable</tt> mapping media types (e.g. audio or video) tolists of JMF encoding strings corresponding to the SDP formats specified in the <tt>mediaDescriptions</tt> vector.
 */
private Hashtable<String,List<String>> extractMediaEncodings(Vector<MediaDescription> mediaDescriptions){
  Hashtable<String,List<String>> mediaEncodings=new Hashtable<String,List<String>>(2);
  Iterator<MediaDescription> descriptionsIter=mediaDescriptions.iterator();
  while (descriptionsIter.hasNext()) {
    MediaDescription mediaDescription=descriptionsIter.next();
    Media media=mediaDescription.getMedia();
    Vector<String> mediaFormats=null;
    String mediaType=null;
    try {
      mediaFormats=media.getMediaFormats(true);
      mediaType=media.getMediaType();
    }
 catch (    SdpParseException ex) {
      logger.warn(""String_Node_Str"",ex);
      continue;
    }
    if (mediaFormats.size() > 0) {
      List<String> jmfEncodings=MediaUtils.sdpToJmfEncodings(mediaFormats);
      if (jmfEncodings.size() > 0)       mediaEncodings.put(mediaType,jmfEncodings);
    }
  }
  logger.trace(""String_Node_Str"" + mediaEncodings);
  return mediaEncodings;
}",0.945121951219512
104253,"/** 
 * Creates a DataSource for all encodings in the mediaDescriptions vector and initializes send streams in our rtp managers for every stream in the data source.
 * @param mediaDescriptions a <tt>Vector</tt> containing<tt>MediaDescription</tt> instances as sent by the remote side with their SDP description.
 * @throws MediaException if we fail to create our data source with theproper encodings and/or fail to initialize the RTP managers with the necessary streams and/or don't find encodings supported by both the remote participant and the local controller.
 */
private void createSendStreams(Vector mediaDescriptions) throws MediaException {
  Hashtable<String,List<String>> mediaEncodings=extractMediaEncodings(mediaDescriptions);
  DataSource dataSource=mediaServCallback.getMediaControl(getCall()).createDataSourceForEncodings(mediaEncodings);
  PushBufferStream[] streams=((PushBufferDataSource)dataSource).getStreams();
  for (int i=0; i < streams.length; i++) {
    RTPManager rtpManager=null;
    if (streams[i].getFormat() instanceof VideoFormat) {
      rtpManager=getVideoRtpManager();
    }
 else     if (streams[i].getFormat() instanceof AudioFormat) {
      rtpManager=getAudioRtpManager();
    }
 else {
      logger.warn(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ streams[i].getFormat());
      continue;
    }
    try {
      SendStream stream=rtpManager.createSendStream(dataSource,i);
      logger.trace(""String_Node_Str"" + streams[i].getFormat());
    }
 catch (    Exception exc) {
      throw new MediaException(""String_Node_Str"" + streams[i].getFormat(),MediaException.IO_ERROR,exc);
    }
  }
}","/** 
 * Creates a DataSource for all encodings in the mediaDescriptions vector and initializes send streams in our rtp managers for every stream in the data source.
 * @param mediaDescriptions a <tt>Vector</tt> containing<tt>MediaDescription</tt> instances as sent by the remote side with their SDP description.
 * @throws MediaException if we fail to create our data source with theproper encodings and/or fail to initialize the RTP managers with the necessary streams and/or don't find encodings supported by both the remote participant and the local controller.
 */
private void createSendStreams(Vector<MediaDescription> mediaDescriptions) throws MediaException {
  Hashtable<String,List<String>> mediaEncodings=extractMediaEncodings(mediaDescriptions);
  DataSource dataSource=mediaServCallback.getMediaControl(getCall()).createDataSourceForEncodings(mediaEncodings);
  PushBufferStream[] streams=((PushBufferDataSource)dataSource).getStreams();
  for (int i=0; i < streams.length; i++) {
    RTPManager rtpManager=null;
    if (streams[i].getFormat() instanceof VideoFormat) {
      rtpManager=getVideoRtpManager();
    }
 else     if (streams[i].getFormat() instanceof AudioFormat) {
      rtpManager=getAudioRtpManager();
    }
 else {
      logger.warn(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ streams[i].getFormat());
      continue;
    }
    try {
      SendStream stream=rtpManager.createSendStream(dataSource,i);
      logger.trace(""String_Node_Str"" + streams[i].getFormat());
    }
 catch (    Exception exc) {
      throw new MediaException(""String_Node_Str"" + streams[i].getFormat(),MediaException.IO_ERROR,exc);
    }
  }
}",0.9945454545454544
104254,"/** 
 * Initializes the RTP manager so that it would start listening on the <tt>address</tt> session address. The method also initializes the RTP manager buffer control.
 * @param rtpManager the <tt>RTPManager</tt> to initialize.
 * @param bindAddress the <tt>SessionAddress</tt> to use when initializingthe RTPManager.
 * @throws MediaException if we fail to initialize the RTP manager.
 */
private void initializeRtpManager(RTPManager rtpManager,SessionAddress bindAddress) throws MediaException {
  selectedKeyProviderAlgorithm=selectKeyProviderAlgorithm(0);
  try {
    if (selectedKeyProviderAlgorithm != null && selectedKeyProviderAlgorithm.getProviderType() == KeyProviderAlgorithm.ProviderType.ZRTP_PROVIDER) {
      TransformManager.initializeProviders();
      TransformConnector transConnector=TransformManager.createZRTPConnector(bindAddress,""String_Node_Str"",this);
      rtpManager.initialize(transConnector);
      this.transConnectors.put(rtpManager,transConnector);
      SCCallback callback=new SCCallback(this);
      boolean zrtpAutoStart=false;
      if (rtpManager.equals(audioRtpManager)) {
        if (zrtpDHSession == null) {
          zrtpDHSession=transConnector;
          zrtpAutoStart=true;
          callback.setDHSession(true);
        }
        callback.setType(SecurityGUIEventZrtp.AUDIO);
      }
 else       if (rtpManager.equals(videoRtpManager)) {
        callback.setType(SecurityGUIEventZrtp.VIDEO);
      }
      ZRTPTransformEngine engine=(ZRTPTransformEngine)transConnector.getEngine();
      engine.setUserCallback(callback);
      if (this.getCall().isDefaultEncrypted()) {
        if (engine.initialize(""String_Node_Str"")) {
          usingSRTP=true;
          engine.sendInfo(ZrtpCodes.MessageSeverity.Info,EnumSet.of(ZRTPCustomInfoCodes.ZRTPEnabledByDefault));
        }
 else {
          engine.sendInfo(ZrtpCodes.MessageSeverity.Info,EnumSet.of(ZRTPCustomInfoCodes.ZRTPEngineInitFailure));
        }
      }
 else {
        engine.sendInfo(ZrtpCodes.MessageSeverity.Info,EnumSet.of(ZRTPCustomInfoCodes.ZRTPNotEnabledByUser));
      }
      logger.trace(""String_Node_Str"" + (rtpManager.equals(audioRtpManager) ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
    }
 else     if (selectedKeyProviderAlgorithm != null && selectedKeyProviderAlgorithm.getProviderType() == KeyProviderAlgorithm.ProviderType.DUMMY_PROVIDER && rtpManager.equals(audioRtpManager)) {
      SRTPPolicy srtpPolicy=new SRTPPolicy(SRTPPolicy.AESF8_ENCRYPTION,16,SRTPPolicy.HMACSHA1_AUTHENTICATION,20,10,14);
      byte[] masterKey={0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f};
      byte[] masterSalt={0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d};
      TransformConnector transConnector=null;
      TransformManager.initializeProviders();
      transConnector=TransformManager.createSRTPConnector(bindAddress,masterKey,masterSalt,srtpPolicy,srtpPolicy,""String_Node_Str"");
      rtpManager.initialize(transConnector);
      this.transConnectors.put(rtpManager,transConnector);
      logger.trace(""String_Node_Str"" + (rtpManager.equals(audioRtpManager) ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
    }
 else {
      rtpManager.initialize(bindAddress);
      logger.trace(""String_Node_Str"" + (rtpManager.equals(audioRtpManager) ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
    }
  }
 catch (  Exception exc) {
    exc.printStackTrace();
    logger.error(""String_Node_Str"",exc);
    throw new MediaException(""String_Node_Str"",MediaException.IO_ERROR,exc);
  }
  BufferControl bc=(BufferControl)rtpManager.getControl(BufferControl.class.getName());
  if (bc != null) {
    long buff=100;
    String buffStr=MediaActivator.getConfigurationService().getString(PROPERTY_NAME_RECEIVE_BUFFER_LENGTH);
    try {
      if (buffStr != null && buffStr.length() > 0)       buff=Long.parseLong(buffStr);
    }
 catch (    NumberFormatException exc) {
      logger.warn(buffStr + ""String_Node_Str"",exc);
    }
    buff=bc.setBufferLength(buff);
    logger.trace(""String_Node_Str"" + buff);
    bc.setEnabledThreshold(true);
    bc.setMinimumThreshold(100);
  }
  rtpManager.addReceiveStreamListener(this);
  rtpManager.addSendStreamListener(this);
  rtpManager.addSessionListener(this);
}","/** 
 * Initializes the RTP manager so that it would start listening on the <tt>address</tt> session address. The method also initializes the RTP manager buffer control.
 * @param rtpManager the <tt>RTPManager</tt> to initialize.
 * @param bindAddress the <tt>SessionAddress</tt> to use when initializingthe RTPManager.
 * @throws MediaException if we fail to initialize the RTP manager.
 */
private void initializeRtpManager(RTPManager rtpManager,SessionAddress bindAddress) throws MediaException {
  selectedKeyProviderAlgorithm=selectKeyProviderAlgorithm(0);
  try {
    if (selectedKeyProviderAlgorithm != null && selectedKeyProviderAlgorithm.getProviderType() == KeyProviderAlgorithm.ProviderType.ZRTP_PROVIDER) {
      TransformManager.initializeProviders();
      TransformConnector transConnector=TransformManager.createZRTPConnector(bindAddress,""String_Node_Str"",this);
      rtpManager.initialize(transConnector);
      this.transConnectors.put(rtpManager,transConnector);
      SCCallback callback=new SCCallback(this);
      boolean zrtpAutoStart=false;
      if (rtpManager.equals(audioRtpManager)) {
        if (zrtpDHSession == null) {
          zrtpDHSession=transConnector;
          zrtpAutoStart=true;
          callback.setDHSession(true);
        }
        callback.setType(SecurityGUIEventZrtp.AUDIO);
      }
 else       if (rtpManager.equals(videoRtpManager)) {
        callback.setType(SecurityGUIEventZrtp.VIDEO);
      }
      ZRTPTransformEngine engine=(ZRTPTransformEngine)transConnector.getEngine();
      engine.setUserCallback(callback);
      if (this.getCall().isDefaultEncrypted()) {
        if (engine.initialize(""String_Node_Str"",zrtpAutoStart)) {
          usingZRTP=true;
          engine.sendInfo(ZrtpCodes.MessageSeverity.Info,EnumSet.of(ZRTPCustomInfoCodes.ZRTPEnabledByDefault));
        }
 else {
          engine.sendInfo(ZrtpCodes.MessageSeverity.Info,EnumSet.of(ZRTPCustomInfoCodes.ZRTPEngineInitFailure));
        }
      }
 else {
        engine.sendInfo(ZrtpCodes.MessageSeverity.Info,EnumSet.of(ZRTPCustomInfoCodes.ZRTPNotEnabledByUser));
      }
      logger.trace(""String_Node_Str"" + (rtpManager.equals(audioRtpManager) ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
    }
 else {
      rtpManager.initialize(bindAddress);
      logger.trace(""String_Node_Str"" + (rtpManager.equals(audioRtpManager) ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
    }
  }
 catch (  Exception exc) {
    exc.printStackTrace();
    logger.error(""String_Node_Str"",exc);
    throw new MediaException(""String_Node_Str"",MediaException.IO_ERROR,exc);
  }
  BufferControl bc=(BufferControl)rtpManager.getControl(BufferControl.class.getName());
  if (bc != null) {
    long buff=100;
    String buffStr=MediaActivator.getConfigurationService().getString(PROPERTY_NAME_RECEIVE_BUFFER_LENGTH);
    try {
      if (buffStr != null && buffStr.length() > 0)       buff=Long.parseLong(buffStr);
    }
 catch (    NumberFormatException exc) {
      logger.warn(buffStr + ""String_Node_Str"",exc);
    }
    buff=bc.setBufferLength(buff);
    logger.trace(""String_Node_Str"" + buff);
    bc.setEnabledThreshold(true);
    bc.setMinimumThreshold(100);
  }
  rtpManager.addReceiveStreamListener(this);
  rtpManager.addSendStreamListener(this);
  rtpManager.addSessionListener(this);
}",0.8682556312205343
104255,"/** 
 * Method for getting the default secure status value for communication
 * @return the default enabled/disabled status value for securecommunication
 */
public boolean getSecureCommunicationStatus(){
  return usingSRTP;
}","/** 
 * Method for getting the default secure status value for communication
 * @return the default enabled/disabled status value for securecommunication
 */
public boolean getSecureCommunicationStatus(){
  return usingZRTP;
}",0.995575221238938
104256,"/** 
 * The method is meant for use by protocol service implementations upon reception of an SDP answer in response to an offer sent by us earlier.
 * @param sdpAnswerStr the SDP answer that we'd like to handle.
 * @param responder the participant that has sent the answer.
 * @throws MediaException code SERVICE_NOT_STARTED if this method is calledbefore the service was started.
 * @throws ParseException if sdpAnswerStr does not contain a valid sdpString.
 */
public void processSdpAnswer(CallParticipant responder,String sdpAnswerStr) throws MediaException, ParseException {
  logger.trace(""String_Node_Str"" + sdpAnswerStr);
  SessionDescription sdpAnswer=null;
  try {
    sdpAnswer=mediaServCallback.getSdpFactory().createSessionDescription(sdpAnswerStr);
  }
 catch (  SdpParseException ex) {
    throw new ParseException(""String_Node_Str"" + ex.getMessage(),ex.getCharOffset());
  }
  setCallURL(sdpAnswer.getURI());
  Vector mediaDescriptions=null;
  try {
    mediaDescriptions=sdpAnswer.getMediaDescriptions(true);
  }
 catch (  SdpException exc) {
    logger.error(""String_Node_Str"",exc);
    throw new MediaException(""String_Node_Str"",MediaException.INTERNAL_ERROR,exc);
  }
  this.initStreamTargets(sdpAnswer.getConnection(),mediaDescriptions);
  createSendStreams(mediaDescriptions);
}","/** 
 * The method is meant for use by protocol service implementations upon reception of an SDP answer in response to an offer sent by us earlier.
 * @param sdpAnswerStr the SDP answer that we'd like to handle.
 * @param responder the participant that has sent the answer.
 * @throws MediaException code SERVICE_NOT_STARTED if this method is calledbefore the service was started.
 * @throws ParseException if sdpAnswerStr does not contain a valid sdpString.
 */
public void processSdpAnswer(CallParticipant responder,String sdpAnswerStr) throws MediaException, ParseException {
  logger.trace(""String_Node_Str"" + sdpAnswerStr);
  SessionDescription sdpAnswer=null;
  try {
    sdpAnswer=mediaServCallback.getSdpFactory().createSessionDescription(sdpAnswerStr);
  }
 catch (  SdpParseException ex) {
    throw new ParseException(""String_Node_Str"" + ex.getMessage(),ex.getCharOffset());
  }
  setCallURL(sdpAnswer.getURI());
  Vector<MediaDescription> mediaDescriptions=null;
  try {
    mediaDescriptions=sdpAnswer.getMediaDescriptions(true);
  }
 catch (  SdpException exc) {
    logger.error(""String_Node_Str"",exc);
    throw new MediaException(""String_Node_Str"",MediaException.INTERNAL_ERROR,exc);
  }
  this.initStreamTargets(sdpAnswer.getConnection(),mediaDescriptions);
  createSendStreams(mediaDescriptions);
}",0.993119266055046
104257,"/** 
 * Creates a vector containing SDP descriptions of media types and formats that we support. If the offerVector is non null
 * @param offerMediaDescs the media descriptions sent by the offerer (couldbe null).
 * @param publicAudioAddress the <tt>InetSocketAddress</tt> that we shouldbe using for sending audio.
 * @param publicVideoAddress the <tt>InetSocketAddress</tt> that we shouldbe using for sending video.
 * @return a <tt>Vector</tt> containing media descriptions that we supportand (if this is an answer to an offer) that the offering <tt>CallParticipant</tt> supports as well.
 * @throws SdpException we fail creating the media descriptions
 * @throws MediaException with code UNSUPPORTED_FORMAT_SET_ERROR if we don'tsupport any of the offered media formats.
 */
private Vector createMediaDescriptions(Vector<MediaDescription> offerMediaDescs,InetSocketAddress publicAudioAddress,InetSocketAddress publicVideoAddress) throws SdpException, MediaException {
  MediaControl mediaControl=mediaServCallback.getMediaControl(getCall());
  String[] supportedAudioEncodings=mediaControl.getSupportedAudioEncodings();
  String[] supportedVideoEncodings=mediaControl.getSupportedVideoEncodings();
  if (offerMediaDescs != null && offerMediaDescs.size() > 0) {
    Vector<String> offeredVideoEncodings=new Vector<String>();
    Vector<String> offeredAudioEncodings=new Vector<String>();
    Iterator<MediaDescription> offerDescsIter=offerMediaDescs.iterator();
    while (offerDescsIter.hasNext()) {
      MediaDescription desc=offerDescsIter.next();
      Media media=desc.getMedia();
      String mediaType=media.getMediaType();
      if (mediaType.equalsIgnoreCase(""String_Node_Str"")) {
        offeredVideoEncodings=media.getMediaFormats(true);
        continue;
      }
      if (mediaType.equalsIgnoreCase(""String_Node_Str"")) {
        offeredAudioEncodings=media.getMediaFormats(true);
        continue;
      }
    }
    Hashtable<String,List<String>> encodings=new Hashtable<String,List<String>>(2);
    encodings.put(""String_Node_Str"",offeredAudioEncodings);
    encodings.put(""String_Node_Str"",offeredVideoEncodings);
    encodings=intersectMediaEncodings(encodings);
    List<String> intersectedAudioEncsList=(List<String>)encodings.get(""String_Node_Str"");
    List<String> intersectedVideoEncsList=(List<String>)encodings.get(""String_Node_Str"");
    supportedAudioEncodings=intersectedAudioEncsList.toArray(new String[0]);
    supportedVideoEncodings=intersectedVideoEncsList.toArray(new String[0]);
  }
  Vector mediaDescs=new Vector();
  if (supportedAudioEncodings.length > 0) {
    MediaDescription am=mediaServCallback.getSdpFactory().createMediaDescription(""String_Node_Str"",publicAudioAddress.getPort(),1,""String_Node_Str"",supportedAudioEncodings);
    String g723Str=String.valueOf(SdpConstants.G723);
    for (int i=0; i < supportedAudioEncodings.length; i++) {
      if (supportedAudioEncodings[i].equals(g723Str)) {
        am.setAttribute(""String_Node_Str"",""String_Node_Str"");
        am.setAttribute(""String_Node_Str"",""String_Node_Str"");
      }
    }
    byte onHold=this.onHold;
    if (!mediaServCallback.getDeviceConfiguration().isAudioCaptureSupported()) {
      onHold|=ON_HOLD_REMOTELY;
    }
    setAttributeOnHold(am,onHold);
    mediaDescs.add(am);
  }
  if (supportedVideoEncodings.length > 0) {
    MediaDescription vm=mediaServCallback.getSdpFactory().createMediaDescription(""String_Node_Str"",publicVideoAddress.getPort(),1,""String_Node_Str"",supportedVideoEncodings);
    String h264Str=String.valueOf(Constants.H264_RTP_SDP);
    for (int i=0; i < supportedVideoEncodings.length; i++) {
      if (supportedVideoEncodings[i].equals(h264Str)) {
        vm.setAttribute(""String_Node_Str"",Constants.H264_RTP_SDP + ""String_Node_Str"");
        vm.setAttribute(""String_Node_Str"",Constants.H264_RTP_SDP + ""String_Node_Str"");
      }
    }
    byte onHold=this.onHold;
    if (!mediaServCallback.getDeviceConfiguration().isVideoCaptureSupported()) {
      onHold|=ON_HOLD_REMOTELY;
    }
    setAttributeOnHold(vm,onHold);
    mediaDescs.add(vm);
  }
  return mediaDescs;
}","/** 
 * Creates a vector containing SDP descriptions of media types and formats that we support. If the offerVector is non null
 * @param offerMediaDescs the media descriptions sent by the offerer (couldbe null).
 * @param publicAudioAddress the <tt>InetSocketAddress</tt> that we shouldbe using for sending audio.
 * @param publicVideoAddress the <tt>InetSocketAddress</tt> that we shouldbe using for sending video.
 * @return a <tt>Vector</tt> containing media descriptions that we supportand (if this is an answer to an offer) that the offering <tt>CallParticipant</tt> supports as well.
 * @throws SdpException we fail creating the media descriptions
 * @throws MediaException with code UNSUPPORTED_FORMAT_SET_ERROR if we don'tsupport any of the offered media formats.
 */
private Vector<MediaDescription> createMediaDescriptions(Vector<MediaDescription> offerMediaDescs,InetSocketAddress publicAudioAddress,InetSocketAddress publicVideoAddress) throws SdpException, MediaException {
  MediaControl mediaControl=mediaServCallback.getMediaControl(getCall());
  String[] supportedAudioEncodings=mediaControl.getSupportedAudioEncodings();
  String[] supportedVideoEncodings=mediaControl.getSupportedVideoEncodings();
  if (offerMediaDescs != null && offerMediaDescs.size() > 0) {
    Vector<String> offeredVideoEncodings=new Vector<String>();
    Vector<String> offeredAudioEncodings=new Vector<String>();
    Iterator<MediaDescription> offerDescsIter=offerMediaDescs.iterator();
    while (offerDescsIter.hasNext()) {
      MediaDescription desc=offerDescsIter.next();
      Media media=desc.getMedia();
      String mediaType=media.getMediaType();
      if (mediaType.equalsIgnoreCase(""String_Node_Str"")) {
        offeredVideoEncodings=media.getMediaFormats(true);
        continue;
      }
      if (mediaType.equalsIgnoreCase(""String_Node_Str"")) {
        offeredAudioEncodings=media.getMediaFormats(true);
        continue;
      }
    }
    Hashtable<String,List<String>> encodings=new Hashtable<String,List<String>>(2);
    encodings.put(""String_Node_Str"",offeredAudioEncodings);
    encodings.put(""String_Node_Str"",offeredVideoEncodings);
    encodings=intersectMediaEncodings(encodings);
    List<String> intersectedAudioEncsList=(List<String>)encodings.get(""String_Node_Str"");
    List<String> intersectedVideoEncsList=(List<String>)encodings.get(""String_Node_Str"");
    supportedAudioEncodings=intersectedAudioEncsList.toArray(new String[0]);
    supportedVideoEncodings=intersectedVideoEncsList.toArray(new String[0]);
  }
  Vector<MediaDescription> mediaDescs=new Vector<MediaDescription>();
  if (supportedAudioEncodings.length > 0) {
    MediaDescription am=mediaServCallback.getSdpFactory().createMediaDescription(""String_Node_Str"",publicAudioAddress.getPort(),1,""String_Node_Str"",supportedAudioEncodings);
    String g723Str=String.valueOf(SdpConstants.G723);
    for (int i=0; i < supportedAudioEncodings.length; i++) {
      if (supportedAudioEncodings[i].equals(g723Str)) {
        am.setAttribute(""String_Node_Str"",""String_Node_Str"");
        am.setAttribute(""String_Node_Str"",""String_Node_Str"");
      }
    }
    byte onHold=this.onHold;
    if (!mediaServCallback.getDeviceConfiguration().isAudioCaptureSupported()) {
      onHold|=ON_HOLD_REMOTELY;
    }
    setAttributeOnHold(am,onHold);
    mediaDescs.add(am);
  }
  if (supportedVideoEncodings.length > 0) {
    MediaDescription vm=mediaServCallback.getSdpFactory().createMediaDescription(""String_Node_Str"",publicVideoAddress.getPort(),1,""String_Node_Str"",supportedVideoEncodings);
    String h264Str=String.valueOf(Constants.H264_RTP_SDP);
    for (int i=0; i < supportedVideoEncodings.length; i++) {
      if (supportedVideoEncodings[i].equals(h264Str)) {
        vm.setAttribute(""String_Node_Str"",Constants.H264_RTP_SDP + ""String_Node_Str"");
        vm.setAttribute(""String_Node_Str"",Constants.H264_RTP_SDP + ""String_Node_Str"");
      }
    }
    byte onHold=this.onHold;
    if (!mediaServCallback.getDeviceConfiguration().isVideoCaptureSupported()) {
      onHold|=ON_HOLD_REMOTELY;
    }
    setAttributeOnHold(vm,onHold);
    mediaDescs.add(vm);
  }
  return mediaDescs;
}",0.9934672150979916
104258,"/** 
 * Creates an SDP description of this session using the offer descirption (if not null) for limiting. The intendedDestination parameter, which may contain the address that the offer is to be sent to, will only be used if the <tt>offer</tt> or its connection parameter are <tt>null</tt>. In the oposite case we are using the address provided in the connection param as an intended destination.
 * @param offer the call participant meant to receive the offer or null ifwe are to construct our own offer.
 * @param intendedDestination the address of the call participant that thedescriptions is to be sent to.
 * @return a SessionDescription of this CallSession.
 * @throws MediaException code INTERNAL_ERROR if we get an SDP exceptionwhile creating and/or parsing the sdp description.
 */
private SessionDescription createSessionDescription(SessionDescription offer,InetAddress intendedDestination) throws MediaException {
  SdpFactory sdpFactory=mediaServCallback.getSdpFactory();
  try {
    SessionDescription sessDescr=sdpFactory.createSessionDescription();
    Version v=sdpFactory.createVersion(0);
    sessDescr.setVersion(v);
    NetworkAddressManagerService netAddressManager=MediaActivator.getNetworkAddressManagerService();
    if (offer != null) {
      Connection c=offer.getConnection();
      if (c != null) {
        try {
          intendedDestination=NetworkUtils.getInetAddress(c.getAddress());
        }
 catch (        SdpParseException ex) {
          logger.warn(""String_Node_Str"" + c.toString() + ""String_Node_Str"",ex);
        }
catch (        UnknownHostException ex) {
          logger.warn(""String_Node_Str"" + c.toString() + ""String_Node_Str"",ex);
        }
      }
      Iterator<MediaDescription> mediaDescriptions=offer.getMediaDescriptions(true).iterator();
      while (mediaDescriptions.hasNext()) {
        Connection conn=mediaDescriptions.next().getConnection();
        if (conn != null) {
          try {
            intendedDestination=NetworkUtils.getInetAddress(conn.getAddress());
            break;
          }
 catch (          UnknownHostException e) {
            logger.debug(""String_Node_Str"" + ""String_Node_Str"" + conn.getAddress(),e);
          }
        }
      }
    }
    boolean allocateMediaPorts=false;
    boolean startStreaming=false;
    if ((audioSessionAddress == null) || (videoSessionAddress == null)) {
      allocateMediaPorts=true;
    }
 else {
      if (((lastIntendedDestination == null) && (intendedDestination != null)) || ((lastIntendedDestination != null) && !lastIntendedDestination.equals(intendedDestination))) {
        startStreaming=stopStreaming();
        audioRtpManager=RTPManager.newInstance();
        videoRtpManager=RTPManager.newInstance();
        allocateMediaPorts=true;
      }
    }
    if (allocateMediaPorts) {
      allocateMediaPorts(intendedDestination);
      lastIntendedDestination=intendedDestination;
      if (startStreaming) {
        startStreaming();
        applyOnHold();
      }
    }
    InetAddress publicIpAddress=audioPublicAddress.getAddress();
    String addrType=publicIpAddress instanceof Inet6Address ? Connection.IP6 : Connection.IP4;
    Origin o=sdpFactory.createOrigin(call.getProtocolProvider().getAccountID().getUserID(),0,0,""String_Node_Str"",addrType,publicIpAddress.getHostAddress());
    sessDescr.setOrigin(o);
    Connection c=sdpFactory.createConnection(""String_Node_Str"",addrType,publicIpAddress.getHostAddress());
    sessDescr.setConnection(c);
    sessDescr.setSessionName(sdpFactory.createSessionName(""String_Node_Str""));
    TimeDescription t=sdpFactory.createTimeDescription();
    Vector<TimeDescription> timeDescs=new Vector<TimeDescription>();
    timeDescs.add(t);
    sessDescr.setTimeDescriptions(timeDescs);
    Vector offeredMediaDescriptions=null;
    if (offer != null)     offeredMediaDescriptions=offer.getMediaDescriptions(false);
    logger.debug(""String_Node_Str"" + audioPublicAddress + ""String_Node_Str""+ videoPublicAddress);
    Vector mediaDescs=createMediaDescriptions(offeredMediaDescriptions,audioPublicAddress,videoPublicAddress);
    sessDescr.setMediaDescriptions(mediaDescs);
    if (logger.isTraceEnabled()) {
      logger.trace(""String_Node_Str"" + sessDescr.toString());
    }
    return sessDescr;
  }
 catch (  SdpException exc) {
    throw new MediaException(""String_Node_Str"" + ""String_Node_Str"",MediaException.INTERNAL_ERROR,exc);
  }
}","/** 
 * Creates an SDP description of this session using the offer descirption (if not null) for limiting. The intendedDestination parameter, which may contain the address that the offer is to be sent to, will only be used if the <tt>offer</tt> or its connection parameter are <tt>null</tt>. In the oposite case we are using the address provided in the connection param as an intended destination.
 * @param offer the call participant meant to receive the offer or null ifwe are to construct our own offer.
 * @param intendedDestination the address of the call participant that thedescriptions is to be sent to.
 * @return a SessionDescription of this CallSession.
 * @throws MediaException code INTERNAL_ERROR if we get an SDP exceptionwhile creating and/or parsing the sdp description.
 */
private SessionDescription createSessionDescription(SessionDescription offer,InetAddress intendedDestination) throws MediaException {
  SdpFactory sdpFactory=mediaServCallback.getSdpFactory();
  try {
    SessionDescription sessDescr=sdpFactory.createSessionDescription();
    Version v=sdpFactory.createVersion(0);
    sessDescr.setVersion(v);
    NetworkAddressManagerService netAddressManager=MediaActivator.getNetworkAddressManagerService();
    if (offer != null) {
      Connection c=offer.getConnection();
      if (c != null) {
        try {
          intendedDestination=NetworkUtils.getInetAddress(c.getAddress());
        }
 catch (        SdpParseException ex) {
          logger.warn(""String_Node_Str"" + c.toString() + ""String_Node_Str"",ex);
        }
catch (        UnknownHostException ex) {
          logger.warn(""String_Node_Str"" + c.toString() + ""String_Node_Str"",ex);
        }
      }
      Iterator<MediaDescription> mediaDescriptions=offer.getMediaDescriptions(true).iterator();
      while (mediaDescriptions.hasNext()) {
        Connection conn=mediaDescriptions.next().getConnection();
        if (conn != null) {
          try {
            intendedDestination=NetworkUtils.getInetAddress(conn.getAddress());
            break;
          }
 catch (          UnknownHostException e) {
            logger.debug(""String_Node_Str"" + ""String_Node_Str"" + conn.getAddress(),e);
          }
        }
      }
    }
    boolean allocateMediaPorts=false;
    boolean startStreaming=false;
    if ((audioSessionAddress == null) || (videoSessionAddress == null)) {
      allocateMediaPorts=true;
    }
 else {
      if (((lastIntendedDestination == null) && (intendedDestination != null)) || ((lastIntendedDestination != null) && !lastIntendedDestination.equals(intendedDestination))) {
        startStreaming=stopStreaming();
        audioRtpManager=RTPManager.newInstance();
        videoRtpManager=RTPManager.newInstance();
        allocateMediaPorts=true;
      }
    }
    if (allocateMediaPorts) {
      allocateMediaPorts(intendedDestination);
      lastIntendedDestination=intendedDestination;
      if (startStreaming) {
        startStreaming();
        applyOnHold();
      }
    }
    InetAddress publicIpAddress=audioPublicAddress.getAddress();
    String addrType=publicIpAddress instanceof Inet6Address ? Connection.IP6 : Connection.IP4;
    Origin o=sdpFactory.createOrigin(call.getProtocolProvider().getAccountID().getUserID(),0,0,""String_Node_Str"",addrType,publicIpAddress.getHostAddress());
    sessDescr.setOrigin(o);
    Connection c=sdpFactory.createConnection(""String_Node_Str"",addrType,publicIpAddress.getHostAddress());
    sessDescr.setConnection(c);
    sessDescr.setSessionName(sdpFactory.createSessionName(""String_Node_Str""));
    TimeDescription t=sdpFactory.createTimeDescription();
    Vector<TimeDescription> timeDescs=new Vector<TimeDescription>();
    timeDescs.add(t);
    sessDescr.setTimeDescriptions(timeDescs);
    Vector<MediaDescription> offeredMediaDescriptions=null;
    if (offer != null)     offeredMediaDescriptions=offer.getMediaDescriptions(false);
    logger.debug(""String_Node_Str"" + audioPublicAddress + ""String_Node_Str""+ videoPublicAddress);
    Vector<MediaDescription> mediaDescs=createMediaDescriptions(offeredMediaDescriptions,audioPublicAddress,videoPublicAddress);
    sessDescr.setMediaDescriptions(mediaDescs);
    if (logger.isTraceEnabled()) {
      logger.trace(""String_Node_Str"" + sessDescr.toString());
    }
    return sessDescr;
  }
 catch (  SdpException exc) {
    throw new MediaException(""String_Node_Str"" + ""String_Node_Str"",MediaException.INTERNAL_ERROR,exc);
  }
}",0.9959349593495936
104259,"/** 
 * Stops and closes all streams currently handled by <tt>rtpManager</tt>.
 * @param rtpManager the rtpManager whose streams we'll be stopping.
 * @return <tt>true</tt> if there was an actual change in the streaming i.e.the streaming wasn't already stopped before this request; <tt>false</tt>, otherwise
 */
private boolean stopStreaming(RTPManager rtpManager){
  boolean stoppedAtLeastOneStream=false;
  Vector<SendStream> sendStreams=rtpManager.getSendStreams();
  Iterator<SendStream> ssIter=sendStreams.iterator();
  while (ssIter.hasNext()) {
    SendStream stream=(SendStream)ssIter.next();
    try {
      stream.getDataSource().stop();
      stream.stop();
      stream.close();
    }
 catch (    IOException ex) {
      logger.warn(""String_Node_Str"",ex);
    }
    stoppedAtLeastOneStream=true;
  }
  Vector<ReceiveStream> receiveStreams=rtpManager.getReceiveStreams();
  Iterator<ReceiveStream> rsIter=receiveStreams.iterator();
  while (rsIter.hasNext()) {
    ReceiveStream stream=rsIter.next();
    try {
      stream.getDataSource().stop();
    }
 catch (    IOException ex) {
      logger.warn(""String_Node_Str"",ex);
    }
    stoppedAtLeastOneStream=true;
  }
  if (selectedKeyProviderAlgorithm != null && selectedKeyProviderAlgorithm.getProviderType() == KeyProviderAlgorithm.ProviderType.ZRTP_PROVIDER) {
    TransformConnector transConnector=this.transConnectors.get(rtpManager);
    if (transConnector != null) {
      if (usingSRTP) {
        ZRTPTransformEngine engine=(ZRTPTransformEngine)transConnector.getEngine();
        engine.stopZrtp();
        engine.cleanup();
      }
      transConnector.removeTargets();
    }
  }
 else {
    rtpManager.removeTargets(""String_Node_Str"");
  }
  printFlowStatistics(rtpManager);
  rtpManager.removeReceiveStreamListener(this);
  rtpManager.removeSendStreamListener(this);
  rtpManager.removeSessionListener(this);
  rtpManager.dispose();
  return stoppedAtLeastOneStream;
}","/** 
 * Stops and closes all streams currently handled by <tt>rtpManager</tt>.
 * @param rtpManager the rtpManager whose streams we'll be stopping.
 * @return <tt>true</tt> if there was an actual change in the streaming i.e.the streaming wasn't already stopped before this request; <tt>false</tt>, otherwise
 */
private boolean stopStreaming(RTPManager rtpManager){
  boolean stoppedAtLeastOneStream=false;
  Vector<SendStream> sendStreams=rtpManager.getSendStreams();
  Iterator<SendStream> ssIter=sendStreams.iterator();
  while (ssIter.hasNext()) {
    SendStream stream=(SendStream)ssIter.next();
    try {
      stream.getDataSource().stop();
      stream.stop();
      stream.close();
    }
 catch (    IOException ex) {
      logger.warn(""String_Node_Str"",ex);
    }
    stoppedAtLeastOneStream=true;
  }
  Vector<ReceiveStream> receiveStreams=rtpManager.getReceiveStreams();
  Iterator<ReceiveStream> rsIter=receiveStreams.iterator();
  while (rsIter.hasNext()) {
    ReceiveStream stream=rsIter.next();
    try {
      stream.getDataSource().stop();
    }
 catch (    IOException ex) {
      logger.warn(""String_Node_Str"",ex);
    }
    stoppedAtLeastOneStream=true;
  }
  if (selectedKeyProviderAlgorithm != null && selectedKeyProviderAlgorithm.getProviderType() == KeyProviderAlgorithm.ProviderType.ZRTP_PROVIDER) {
    TransformConnector transConnector=this.transConnectors.get(rtpManager);
    if (transConnector != null) {
      if (usingZRTP) {
        ZRTPTransformEngine engine=(ZRTPTransformEngine)transConnector.getEngine();
        engine.stopZrtp();
        engine.cleanup();
      }
      transConnector.removeTargets();
    }
  }
 else {
    rtpManager.removeTargets(""String_Node_Str"");
  }
  printFlowStatistics(rtpManager);
  rtpManager.removeReceiveStreamListener(this);
  rtpManager.removeSendStreamListener(this);
  rtpManager.removeSessionListener(this);
  rtpManager.dispose();
  return stoppedAtLeastOneStream;
}",0.9994853319608852
104260,"/** 
 * Method for setting the default secure status value for communication Also has the role to trigger going secure from not secure or viceversa Notifies any present CallSession of change in the status value for this purpose
 * @param activator setting for default communication securing
 * @param source the source of changing the secure status (local or remote)
 */
public void setSecureCommunicationStatus(boolean activator,OperationSetSecureTelephony.SecureStatusChangeSource source){
  logger.trace(""String_Node_Str"");
  usingSRTP=activator;
  if (source != OperationSetSecureTelephony.SecureStatusChangeSource.SECURE_STATUS_REVERTED) {
    SecureEvent secureEvent=null;
    if (activator) {
      secureEvent=new SecureEvent(this,SecureEvent.SECURE_COMMUNICATION,source);
    }
 else {
      secureEvent=new SecureEvent(this,SecureEvent.UNSECURE_COMMUNICATION,source);
    }
    if (selectedKeyProviderAlgorithm.getProviderType() == KeyProviderAlgorithm.ProviderType.ZRTP_PROVIDER) {
      zrtpChangeStatus(this.audioRtpManager,secureEvent);
    }
  }
}","/** 
 * Method for setting the default secure status value for communication Also has the role to trigger going secure from not secure or viceversa Notifies any present CallSession of change in the status value for this purpose
 * @param activator setting for default communication securing
 * @param source the source of changing the secure status (local or remote)
 */
public void setSecureCommunicationStatus(boolean activator,OperationSetSecureTelephony.SecureStatusChangeSource source){
  logger.trace(""String_Node_Str"");
  usingZRTP=activator;
  if (source != OperationSetSecureTelephony.SecureStatusChangeSource.SECURE_STATUS_REVERTED) {
    SecureEvent secureEvent=null;
    if (activator) {
      secureEvent=new SecureEvent(this,SecureEvent.SECURE_COMMUNICATION,source);
    }
 else {
      secureEvent=new SecureEvent(this,SecureEvent.UNSECURE_COMMUNICATION,source);
    }
    if (selectedKeyProviderAlgorithm.getProviderType() == KeyProviderAlgorithm.ProviderType.ZRTP_PROVIDER) {
      zrtpChangeStatus(this.audioRtpManager,secureEvent);
    }
  }
}",0.9990583804143126
104261,"public void run(){
  while (!stop) {
synchronized (sync) {
      while (!newTask && !stop) {
        try {
          sync.wait();
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
    }
    long endTime=System.currentTimeMillis() + nextDelay;
    long currentTime=System.currentTimeMillis();
synchronized (sync) {
      while ((currentTime <= endTime) && newTask && !stop) {
        try {
          sync.wait(endTime - currentTime);
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
        currentTime=System.currentTimeMillis();
      }
    }
    if (newTask && !stop) {
      newTask=false;
      executor.handleTimeout();
    }
  }
}","public void run(){
  while (!stop) {
synchronized (sync) {
      while (!newTask && !stop) {
        try {
          sync.wait();
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
    }
    long endTime=System.currentTimeMillis() + nextDelay;
    long currentTime=System.currentTimeMillis();
synchronized (sync) {
      while ((currentTime < endTime) && newTask && !stop) {
        try {
          sync.wait(endTime - currentTime);
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
        currentTime=System.currentTimeMillis();
      }
    }
    if (newTask && !stop) {
      newTask=false;
      executor.handleTimeout();
    }
  }
}",0.999315537303217
104262,"protected void initClassDefaults(UIDefaults table){
  super.initClassDefaults(table);
  String lfPackageName=""String_Node_Str"";
  Object[] uiDefaults={""String_Node_Str"",lfPackageName + ""String_Node_Str"",""String_Node_Str"",lfPackageName + ""String_Node_Str"",""String_Node_Str"",lfPackageName + ""String_Node_Str"",""String_Node_Str"",lfPackageName + ""String_Node_Str"",""String_Node_Str"",lfPackageName + ""String_Node_Str"",""String_Node_Str"",lfPackageName + ""String_Node_Str"",""String_Node_Str"",lfPackageName + ""String_Node_Str"",""String_Node_Str"",lfPackageName + ""String_Node_Str"",""String_Node_Str"",lfPackageName + ""String_Node_Str"",""String_Node_Str"",lfPackageName + ""String_Node_Str"",""String_Node_Str"",lfPackageName + ""String_Node_Str"",""String_Node_Str"",lfPackageName + ""String_Node_Str"",""String_Node_Str"",lfPackageName + ""String_Node_Str"",""String_Node_Str"",lfPackageName + ""String_Node_Str"",""String_Node_Str"",lfPackageName + ""String_Node_Str"",""String_Node_Str"",lfPackageName + ""String_Node_Str"",""String_Node_Str"",lfPackageName + ""String_Node_Str"",""String_Node_Str"",lfPackageName + ""String_Node_Str"",""String_Node_Str"",lfPackageName + ""String_Node_Str"",""String_Node_Str"",lfPackageName + ""String_Node_Str"",""String_Node_Str"",lfPackageName + ""String_Node_Str"",""String_Node_Str"",lfPackageName + ""String_Node_Str""};
  table.putDefaults(uiDefaults);
}","protected void initClassDefaults(UIDefaults table){
  super.initClassDefaults(table);
  String lfPackageName=""String_Node_Str"";
  Object[] uiDefaults={""String_Node_Str"",lfPackageName + ""String_Node_Str"",""String_Node_Str"",lfPackageName + ""String_Node_Str"",""String_Node_Str"",lfPackageName + ""String_Node_Str"",""String_Node_Str"",lfPackageName + ""String_Node_Str"",""String_Node_Str"",lfPackageName + ""String_Node_Str"",""String_Node_Str"",lfPackageName + ""String_Node_Str"",""String_Node_Str"",lfPackageName + ""String_Node_Str"",""String_Node_Str"",lfPackageName + ""String_Node_Str"",""String_Node_Str"",lfPackageName + ""String_Node_Str"",""String_Node_Str"",lfPackageName + ""String_Node_Str"",""String_Node_Str"",lfPackageName + ""String_Node_Str"",""String_Node_Str"",lfPackageName + ""String_Node_Str"",""String_Node_Str"",lfPackageName + ""String_Node_Str"",""String_Node_Str"",lfPackageName + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",lfPackageName + ""String_Node_Str"",""String_Node_Str"",lfPackageName + ""String_Node_Str"",""String_Node_Str"",lfPackageName + ""String_Node_Str"",""String_Node_Str"",lfPackageName + ""String_Node_Str"",""String_Node_Str"",lfPackageName + ""String_Node_Str"",""String_Node_Str"",lfPackageName + ""String_Node_Str"",""String_Node_Str"",lfPackageName + ""String_Node_Str""};
  table.putDefaults(uiDefaults);
}",0.9939531368102796
104263,"private void closeActionPerformed(){
  try {
    GuiActivator.bundleContext.getBundle(0).stop();
  }
 catch (  BundleException ex) {
    logger.error(""String_Node_Str"",ex);
    System.exit(0);
  }
  parentWindow.dispose();
}","void closeActionPerformed(){
  try {
    GuiActivator.bundleContext.getBundle(0).stop();
  }
 catch (  BundleException ex) {
    logger.error(""String_Node_Str"",ex);
    System.exit(0);
  }
  parentWindow.dispose();
}",0.7681818181818182
104264,"private boolean registerCloseMenuItemMacOSX(){
  return false;
}","private boolean registerCloseMenuItemMacOSX(){
  return registerMenuItemMacOSX(""String_Node_Str"",this);
}",0.7218934911242604
104265,"private void configActionPerformed(){
  ExportedWindow configDialog=GuiActivator.getUIService().getExportedWindow(ExportedWindow.CONFIGURATION_WINDOW);
  configDialog.setVisible(true);
}","void configActionPerformed(){
  ExportedWindow configDialog=GuiActivator.getUIService().getExportedWindow(ExportedWindow.CONFIGURATION_WINDOW);
  configDialog.setVisible(true);
}",0.978021978021978
104266,"private boolean registerConfigMenuItemMacOSX(){
  return false;
}","private boolean registerConfigMenuItemMacOSX(){
  return FileMenu.registerMenuItemMacOSX(""String_Node_Str"",this);
}",0.6888888888888889
104267,"private boolean registerMenuEntryMacOSX(UIService uiService){
  return false;
}","private boolean registerMenuEntryMacOSX(UIService uiService){
  Exception exception=null;
  try {
    Class<?> clazz=Class.forName(""String_Node_Str"");
    Method method=clazz.getMethod(""String_Node_Str"",(Class<?>[])null);
    Object result=method.invoke(null,(Object[])null);
    if (result instanceof Boolean)     return ((Boolean)result).booleanValue();
  }
 catch (  ClassNotFoundException ex) {
    exception=ex;
  }
catch (  IllegalAccessException ex) {
    exception=ex;
  }
catch (  InvocationTargetException ex) {
    exception=ex;
  }
catch (  NoSuchMethodException ex) {
    exception=ex;
  }
  if (exception != null)   logger.error(""String_Node_Str"",exception);
  return false;
}",0.1716514954486346
104268,"private boolean registerCloseMenuItemMacOSX(){
  Application application=Application.getApplication();
  if (application != null) {
    application.addApplicationListener(new ApplicationAdapter(){
      public void handleQuit(      ApplicationEvent event){
        closeActionPerformed();
        event.setHandled(true);
      }
    }
);
    return true;
  }
  return false;
}","private boolean registerCloseMenuItemMacOSX(){
  return false;
}",0.2909090909090909
104269,"private boolean registerConfigMenuItemMacOSX(){
  Application application=Application.getApplication();
  if (application != null) {
    application.addPreferencesMenuItem();
    if (application.isPreferencesMenuItemPresent()) {
      application.setEnabledPreferencesMenu(true);
      application.addApplicationListener(new ApplicationAdapter(){
        public void handlePreferences(        ApplicationEvent event){
          configActionPerformed();
          event.setHandled(true);
        }
      }
);
      return true;
    }
  }
  return false;
}","private boolean registerConfigMenuItemMacOSX(){
  return false;
}",0.210016155088853
104270,"private boolean registerMenuEntryMacOSX(UIService uiService){
  Application application=Application.getApplication();
  if (application != null) {
    application.addAboutMenuItem();
    if (application.isAboutMenuItemPresent()) {
      application.setEnabledAboutMenu(true);
      application.addApplicationListener(new ApplicationAdapter(){
        public void handleAbout(        ApplicationEvent event){
          AboutWindowPluginComponent.actionPerformed();
          event.setHandled(true);
        }
      }
);
      return true;
    }
  }
  return false;
}","private boolean registerMenuEntryMacOSX(UIService uiService){
  return false;
}",0.2453416149068323
104271,"public void actionPerformed(ActionEvent evt){
  JButton button=(JButton)evt.getSource();
  String buttonName=button.getName();
  if (buttonName.equals(HANGUP_BUTTON)) {
    Call call=callPanel.getCall();
    CallManager.hangupCall(call);
    this.dispose();
  }
 else   if (buttonName.equals(DIAL_BUTTON)) {
    if (dialpadDialog == null) {
      Call call=callPanel.getCall();
      Iterator<CallParticipant> callParticipants=(call == null) ? new Vector<CallParticipant>().iterator() : callPanel.getCall().getCallParticipants();
      dialpadDialog=new DialpadDialog(callParticipants);
    }
    if (!dialpadDialog.isVisible()) {
      dialpadDialog.setSize(this.getWidth() - 20,dialpadDialog.getHeight());
      dialpadDialog.setLocation(this.getX() + 10,getLocationOnScreen().y + getHeight());
      dialpadDialog.setVisible(true);
      dialpadDialog.requestFocus();
    }
 else {
      dialpadDialog.setVisible(false);
    }
  }
}","public void actionPerformed(ActionEvent evt){
  JButton button=(JButton)evt.getSource();
  String buttonName=button.getName();
  if (buttonName.equals(HANGUP_BUTTON)) {
    actionPerformedOnHangupButton();
  }
 else   if (buttonName.equals(DIAL_BUTTON)) {
    if (dialpadDialog == null) {
      Call call=callPanel.getCall();
      Iterator<CallParticipant> callParticipants=(call == null) ? new Vector<CallParticipant>().iterator() : callPanel.getCall().getCallParticipants();
      dialpadDialog=new DialpadDialog(callParticipants);
    }
    if (!dialpadDialog.isVisible()) {
      dialpadDialog.setSize(this.getWidth() - 20,dialpadDialog.getHeight());
      dialpadDialog.setLocation(this.getX() + 10,getLocationOnScreen().y + getHeight());
      dialpadDialog.setVisible(true);
      dialpadDialog.requestFocus();
    }
 else {
      dialpadDialog.setVisible(false);
    }
  }
}",0.9394939493949396
104272,"/** 
 * Returns the <tt>Call</tt> corresponding to this CallDialog.
 * @return the <tt>Call</tt> corresponding to this CallDialog.
 */
public Call getCall(){
  if (callPanel != null) {
    return callPanel.getCall();
  }
 else   return null;
}","/** 
 * Returns the <tt>Call</tt> corresponding to this CallDialog.
 * @return the <tt>Call</tt> corresponding to this CallDialog.
 */
public Call getCall(){
  return (callPanel != null) ? callPanel.getCall() : null;
}",0.8850325379609545
104273,"@Override protected void close(boolean isEscaped){
}","@Override protected void close(boolean isEscaped){
  if (!isEscaped) {
    actionPerformedOnHangupButton();
  }
}",0.6303030303030303
104274,"/** 
 * Initializes all components in this panel.
 */
private void initComponents(){
  JPanel mainPanel=new JPanel(new BorderLayout());
  JLabel callLabel=new JLabel();
  JPanel buttonsPanel=new JPanel(new FlowLayout(FlowLayout.CENTER));
  SIPCommButton callButton=new SIPCommButton(ImageLoader.getImage(ImageLoader.CALL_BUTTON_BG));
  SIPCommButton hangupButton=new SIPCommButton(ImageLoader.getImage(ImageLoader.HANGUP_BUTTON_BG));
  mainPanel.setPreferredSize(new Dimension(400,90));
  mainPanel.setOpaque(false);
  mainPanel.setBorder(BorderFactory.createCompoundBorder(SIPCommBorders.getRoundBorder(),BorderFactory.createEmptyBorder(20,20,20,20)));
  callButton.setName(CALL_BUTTON);
  hangupButton.setName(HANGUP_BUTTON);
  callButton.addActionListener(this);
  hangupButton.addActionListener(this);
  this.initCallLabel(callLabel);
  this.getContentPane().add(mainPanel);
  mainPanel.add(callLabel,BorderLayout.CENTER);
  mainPanel.add(buttonsPanel,BorderLayout.EAST);
  buttonsPanel.add(callButton);
  buttonsPanel.add(hangupButton);
}","/** 
 * Initializes all components in this panel.
 */
private void initComponents(){
  JPanel mainPanel=new JPanel(new GridBagLayout());
  JLabel callLabel=new JLabel();
  JPanel buttonsPanel=new TransparentPanel(new GridBagLayout());
  SIPCommButton callButton=new SIPCommButton(ImageLoader.getImage(ImageLoader.CALL_BUTTON_BG));
  SIPCommButton hangupButton=new SIPCommButton(ImageLoader.getImage(ImageLoader.HANGUP_BUTTON_BG));
  mainPanel.setPreferredSize(new Dimension(400,90));
  mainPanel.setOpaque(false);
  mainPanel.setBorder(BorderFactory.createEmptyBorder(20,20,20,20));
  callButton.setName(CALL_BUTTON);
  hangupButton.setName(HANGUP_BUTTON);
  callButton.addActionListener(this);
  hangupButton.addActionListener(this);
  this.initCallLabel(callLabel);
  this.getContentPane().add(mainPanel);
  GridBagConstraints mainConstraints=new GridBagConstraints();
  mainConstraints.anchor=GridBagConstraints.WEST;
  mainConstraints.gridx=0;
  mainConstraints.gridy=0;
  mainConstraints.weightx=1;
  mainPanel.add(callLabel,mainConstraints);
  mainConstraints.anchor=GridBagConstraints.CENTER;
  mainConstraints.gridx=1;
  mainConstraints.weightx=0;
  mainPanel.add(Box.createHorizontalStrut(HGAP),mainConstraints);
  mainConstraints.anchor=GridBagConstraints.CENTER;
  mainConstraints.gridx=2;
  mainConstraints.weightx=0;
  mainPanel.add(buttonsPanel,mainConstraints);
  GridBagConstraints buttonConstraints=new GridBagConstraints();
  buttonConstraints.gridx=0;
  buttonConstraints.gridy=0;
  buttonsPanel.add(callButton,buttonConstraints);
  buttonConstraints.gridx=1;
  buttonsPanel.add(Box.createHorizontalStrut(HGAP));
  buttonConstraints.gridx=2;
  buttonsPanel.add(hangupButton,buttonConstraints);
}",0.6405513239027929
104275,"private void enterFullScreen(){
  final JFrame frame=new JFrame();
  frame.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
  frame.setTitle(getParticipantName());
  frame.setUndecorated(true);
  Component center=createCenter();
  final Component buttonBar=createFullScreenButtonBar();
  final Container contentPane=frame.getContentPane();
  contentPane.setLayout(new FullScreenLayout(false));
  if (buttonBar != null)   contentPane.add(buttonBar,FullScreenLayout.SOUTH);
  if (center != null)   contentPane.add(center,FullScreenLayout.CENTER);
  Color background=Color.black;
  contentPane.setBackground(background);
  setBackground(center,background);
class FullScreenListener implements ContainerListener, KeyListener, MouseMotionListener, WindowStateListener {
    public void componentAdded(    ContainerEvent event){
      Component child=event.getChild();
      child.addKeyListener(this);
      child.addMouseMotionListener(this);
    }
    public void componentRemoved(    ContainerEvent event){
      Component child=event.getChild();
      child.removeMouseMotionListener(this);
      child.removeKeyListener(this);
    }
    public void keyPressed(    KeyEvent event){
      if (!event.isConsumed() && (event.getKeyCode() == KeyEvent.VK_ESCAPE)) {
        event.consume();
        exitFullScreen(frame);
      }
    }
    public void keyReleased(    KeyEvent event){
    }
    public void keyTyped(    KeyEvent event){
    }
    public void mouseDragged(    MouseEvent event){
    }
    public void mouseMoved(    MouseEvent event){
      Component component=event.getComponent();
      if ((buttonBar != null) && (component != null) && !component.equals(buttonBar)) {
        Point pointInContentPane=SwingUtilities.convertPoint(component,event.getPoint(),contentPane);
        Rectangle hotSpotBounds=buttonBar.getBounds();
        hotSpotBounds.x=0;
        hotSpotBounds.width=contentPane.getWidth();
        boolean visible=hotSpotBounds.contains(pointInContentPane);
        buttonBar.setVisible(visible);
      }
    }
    public void windowStateChanged(    WindowEvent event){
switch (event.getID()) {
case WindowEvent.WINDOW_CLOSED:
case WindowEvent.WINDOW_DEACTIVATED:
case WindowEvent.WINDOW_ICONIFIED:
case WindowEvent.WINDOW_LOST_FOCUS:
        exitFullScreen(frame);
      break;
  }
}
}
FullScreenListener listener=new FullScreenListener();
if (buttonBar != null) {
buttonBar.setVisible(false);
addMouseMotionListener(contentPane,listener);
}
addKeyListener(frame,listener);
if (center instanceof Container) ((Container)center).addContainerListener(listener);
frame.addWindowStateListener(listener);
getGraphicsConfiguration().getDevice().setFullScreenWindow(frame);
}","private void enterFullScreen(){
  final JFrame frame=new JFrame();
  frame.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
  frame.setTitle(getParticipantName());
  frame.setUndecorated(true);
  Component center=createCenter();
  final Component buttonBar=createFullScreenButtonBar();
  final Container contentPane=frame.getContentPane();
  contentPane.setLayout(new FullScreenLayout(false));
  if (buttonBar != null)   contentPane.add(buttonBar,FullScreenLayout.SOUTH);
  if (center != null)   contentPane.add(center,FullScreenLayout.CENTER);
  Color background=Color.black;
  contentPane.setBackground(background);
  setBackground(center,background);
class FullScreenListener implements ContainerListener, KeyListener, WindowStateListener {
    public void componentAdded(    ContainerEvent event){
      Component child=event.getChild();
      child.addKeyListener(this);
    }
    public void componentRemoved(    ContainerEvent event){
      Component child=event.getChild();
      child.removeKeyListener(this);
    }
    public void keyPressed(    KeyEvent event){
      if (!event.isConsumed() && (event.getKeyCode() == KeyEvent.VK_ESCAPE)) {
        event.consume();
        exitFullScreen(frame);
      }
    }
    public void keyReleased(    KeyEvent event){
    }
    public void keyTyped(    KeyEvent event){
    }
    public void windowStateChanged(    WindowEvent event){
switch (event.getID()) {
case WindowEvent.WINDOW_CLOSED:
case WindowEvent.WINDOW_DEACTIVATED:
case WindowEvent.WINDOW_ICONIFIED:
case WindowEvent.WINDOW_LOST_FOCUS:
        exitFullScreen(frame);
      break;
  }
}
}
FullScreenListener listener=new FullScreenListener();
addKeyListener(frame,listener);
if (center instanceof Container) ((Container)center).addContainerListener(listener);
frame.addWindowStateListener(listener);
getGraphicsConfiguration().getDevice().setFullScreenWindow(frame);
}",0.7841773527494023
104276,"public void componentRemoved(ContainerEvent event){
  Component child=event.getChild();
  child.removeMouseMotionListener(this);
  child.removeKeyListener(this);
}","public void componentRemoved(ContainerEvent event){
  Component child=event.getChild();
  child.removeKeyListener(this);
}",0.856140350877193
104277,"public void componentAdded(ContainerEvent event){
  Component child=event.getChild();
  child.addKeyListener(this);
  child.addMouseMotionListener(this);
}","public void componentAdded(ContainerEvent event){
  Component child=event.getChild();
  child.addKeyListener(this);
}",0.8602941176470589
104278,"/** 
 * Paint a round background for all selected cells.
 */
public void paintComponent(Graphics g){
  super.paintComponent(g);
  Graphics2D g2=(Graphics2D)g;
  AntialiasingManager.activateAntialiasing(g2);
  if (this.isSelected) {
    g2.setColor(Constants.SELECTED_COLOR);
    g2.fillRoundRect(0,0,this.getWidth(),this.getHeight(),7,7);
    g2.setColor(Constants.LIST_SELECTION_BORDER_COLOR);
    g2.setStroke(new BasicStroke(1.5f));
    g2.drawRoundRect(0,0,this.getWidth() - 1,this.getHeight() - 1,7,7);
  }
}","/** 
 * Paint a round background for all selected cells.
 */
public void paintComponent(Graphics g){
  super.paintComponent(g);
  g=g.create();
  try {
    AntialiasingManager.activateAntialiasing(g);
    if (this.isSelected) {
      Graphics2D g2=(Graphics2D)g;
      int width=getWidth();
      int height=getHeight();
      g2.setColor(Constants.SELECTED_COLOR);
      g2.fillRoundRect(0,0,width,height,7,7);
      g2.setColor(Constants.LIST_SELECTION_BORDER_COLOR);
      g2.setStroke(new BasicStroke(1.5f));
      g2.drawRoundRect(0,0,width - 1,height - 1,7,7);
    }
  }
  finally {
    g.dispose();
  }
}",0.6743772241992882
104279,"public void paintComponent(Graphics g){
  super.paintComponent(g);
  Graphics2D g2=(Graphics2D)g;
  AntialiasingManager.activateAntialiasing(g2);
  g2.setColor(Color.WHITE);
  g2.fillRoundRect(0,0,this.getWidth() - 1,this.getHeight() - 1,15,15);
  g2.setColor(Color.GRAY);
  g2.drawRoundRect(0,0,this.getWidth() - 1,this.getHeight() - 1,15,15);
  if (isWindowImageBgEnabled && bgImage != null) {
    if (isTextureBackground) {
      g2.setPaint(texture);
      g2.fillRect(0,0,this.getWidth(),this.getHeight());
    }
 else {
      g.setColor(new Color(GuiActivator.getResources().getColor(""String_Node_Str"")));
      g.fillRect(0,0,getWidth(),getHeight());
      g2.drawImage(bgImage,this.getWidth() - bgImage.getWidth(),this.getHeight() - bgImage.getHeight(),this);
    }
  }
}","public void paintComponent(Graphics g){
  super.paintComponent(g);
  g=g.create();
  try {
    AntialiasingManager.activateAntialiasing(g);
    Graphics2D g2=(Graphics2D)g;
    int width=getWidth();
    int height=getHeight();
    g2.setColor(Color.WHITE);
    g2.fillRoundRect(0,0,width - 1,height - 1,15,15);
    g2.setColor(Color.GRAY);
    g2.drawRoundRect(0,0,width - 1,height - 1,15,15);
    if (isWindowImageBgEnabled && bgImage != null) {
      if (isTextureBackground) {
        g2.setPaint(texture);
        g2.fillRect(0,0,width,height);
      }
 else {
        g.setColor(new Color(GuiActivator.getResources().getColor(""String_Node_Str"")));
        g.fillRect(0,0,width,height);
        g2.drawImage(bgImage,width - bgImage.getWidth(),height - bgImage.getHeight(),this);
      }
    }
  }
  finally {
    g.dispose();
  }
}",0.7187112763320942
104280,"/** 
 * Overrides the <code>paintComponent</code> method of <tt>JButton</tt> to paint the button background and icon, and all additional effects of this configururable button.
 * @param g The Graphics object.
 */
public void paintComponent(Graphics g){
  AntialiasingManager.activateAntialiasing(g);
  if (isOpaque()) {
    g.setColor(getBackground());
    g.fillRect(0,0,getWidth(),getHeight());
  }
  if (this.bgImage != null) {
    Image paintBgImage;
    if (this.iconImage == null && !isEnabled()) {
      paintBgImage=new ImageIcon(LightGrayFilter.createDisabledImage(bgImage)).getImage();
    }
 else     paintBgImage=bgImage;
    g.drawImage(paintBgImage,this.getWidth() / 2 - this.bgImage.getWidth(null) / 2,this.getHeight() / 2 - this.bgImage.getHeight(null) / 2,this);
  }
  if (this.iconImage != null) {
    Image paintIconImage;
    if (!isEnabled()) {
      paintIconImage=new ImageIcon(LightGrayFilter.createDisabledImage(iconImage)).getImage();
    }
 else     paintIconImage=iconImage;
    g.drawImage(paintIconImage,this.getWidth() / 2 - this.iconImage.getWidth(null) / 2,this.getHeight() / 2 - this.iconImage.getHeight(null) / 2,this);
  }
  FadeTracker fadeTracker=FadeTracker.getInstance();
  float visibility=this.getModel().isRollover() ? 1.0f : 0.0f;
  if (fadeTracker.isTracked(this,FadeKind.ROLLOVER)) {
    visibility=fadeTracker.getFade(this,FadeKind.ROLLOVER);
  }
  g.setColor(new Color(1.0f,1.0f,1.0f,visibility / 2));
  if (this.bgImage != null) {
    g.fillRoundRect(this.getWidth() / 2 - this.bgImage.getWidth(null) / 2,this.getHeight() / 2 - this.bgImage.getHeight(null) / 2,bgImage.getWidth(null),bgImage.getHeight(null),10,10);
  }
 else {
    g.fillRoundRect(0,0,this.getWidth(),this.getHeight(),10,10);
  }
  if (this.getModel().isPressed()) {
    if (this.pressedImage != null) {
      g.drawImage(this.pressedImage,0,0,this);
    }
 else     if (this.iconImage != null) {
      g.drawImage(this.iconImage,this.getWidth() / 2 - this.iconImage.getWidth(null) / 2 + 1,this.getHeight() / 2 - this.iconImage.getHeight(null) / 2 + 1,this);
    }
  }
}","/** 
 * Overrides the <code>paintComponent</code> method of <tt>JButton</tt> to paint the button background and icon, and all additional effects of this configurable button.
 * @param g The Graphics object.
 */
protected void paintComponent(Graphics g){
  g=g.create();
  try {
    internalPaintComponent(g);
  }
  finally {
    g.dispose();
  }
}",0.2277024249897246
104281,"public void paintComponent(Graphics g){
  super.paintComponent(g);
  if (!isColorBgEnabled)   return;
  Graphics2D g2=(Graphics2D)g;
  AntialiasingManager.activateAntialiasing(g2);
  GradientPaint bgGradientColor=new GradientPaint(this.getWidth() / 2,0,bgStartColor,this.getWidth() / 2,80,bgEndColor);
  g2.setPaint(bgGradientColor);
  g2.fillRect(0,0,this.getWidth(),80);
  g2.setColor(bgEndColor);
  g2.fillRect(0,78,this.getWidth(),this.getHeight());
  GradientPaint curveShadow=new GradientPaint(0,0,new Color(255,255,255,150),this.getWidth(),this.getHeight(),new Color(255,255,255,50));
  g2.setPaint(curveShadow);
  g2.setStroke(new BasicStroke(1f));
  CubicCurve2D curve1=new CubicCurve2D.Float(50,-1,250,30,50,150,0,300);
  g2.draw(curve1);
  CubicCurve2D curve2=new CubicCurve2D.Float(this.getWidth() - 20,0,this.getWidth(),100,this.getWidth() / 2,100,0,150);
  g2.draw(curve2);
  CubicCurve2D curve3=new CubicCurve2D.Float(0,90,this.getWidth() / 3,60,2 * this.getWidth() / 3,60,this.getWidth(),90);
  g2.draw(curve3);
}","protected void paintComponent(Graphics g){
  super.paintComponent(g);
  g=g.create();
  try {
    internalPaintComponent(g);
  }
  finally {
    g.dispose();
  }
}",0.1812080536912751
104282,"public void paintComponent(Graphics g){
  super.paintComponent(g);
  if (!isColorBgEnabled)   return;
  Graphics2D g2=(Graphics2D)g;
  AntialiasingManager.activateAntialiasing(g2);
  GradientPaint bgGradientColor=new GradientPaint(this.getWidth() / 2,0,bgStartColor,this.getWidth() / 2,80,bgEndColor);
  g2.setPaint(bgGradientColor);
  g2.fillRect(0,0,this.getWidth(),80);
  g2.setColor(bgEndColor);
  g2.fillRect(0,78,this.getWidth(),this.getHeight());
  GradientPaint curveShadow=new GradientPaint(0,0,new Color(255,255,255,150),this.getWidth(),this.getHeight(),new Color(255,255,255,50));
  g2.setPaint(curveShadow);
  g2.setStroke(new BasicStroke(1f));
  CubicCurve2D curve1=new CubicCurve2D.Float(50,-1,250,30,50,150,0,300);
  g2.draw(curve1);
  CubicCurve2D curve2=new CubicCurve2D.Float(this.getWidth() - 20,0,this.getWidth(),100,this.getWidth() / 2,100,0,150);
  g2.draw(curve2);
  CubicCurve2D curve3=new CubicCurve2D.Float(0,90,this.getWidth() / 3,60,2 * this.getWidth() / 3,60,this.getWidth(),90);
  g2.draw(curve3);
}","public void paintComponent(Graphics g){
  super.paintComponent(g);
  g=g.create();
  try {
    internalPaintComponent(g);
  }
  finally {
    g.dispose();
  }
}",0.1883936080740118
104283,"/** 
 * Overwrites the <tt>paintComponent(Graphics g)</tt> method in order to provide a new look and the mouse moves over this component.
 */
public void paintComponent(Graphics g){
  Graphics2D g2=(Graphics2D)g;
  AntialiasingManager.activateAntialiasing(g2);
  super.paintComponent(g2);
}","/** 
 * Overwrites the <tt>paintComponent(Graphics g)</tt> method in order to provide a new look and the mouse moves over this component.
 */
public void paintComponent(Graphics g){
  super.paintComponent(g);
}",0.772
104284,"/** 
 * Overrides the <code>paintComponent</code> method of <tt>JButton</tt> to paint the button background and icon, and all additional effects of this configururable button.
 * @param g The Graphics object.
 */
public void paintComponent(Graphics g){
  AntialiasingManager.activateAntialiasing(g);
  if (this.bgImage != null) {
    if (this.iconImage == null && !isEnabled()) {
      Image disabledImage=new ImageIcon(LightGrayFilter.createDisabledImage(bgImage)).getImage();
      g.drawImage(disabledImage,0,0,this);
    }
 else {
      g.drawImage(this.bgImage,0,0,this);
    }
  }
  if (this.getModel().isRollover() && this.bgRolloverImage != null) {
    g.drawImage(this.bgRolloverImage,0,0,this);
  }
  if (this.getModel().isSelected() && this.pressedImage != null) {
    g.drawImage(this.pressedImage,0,0,this);
  }
  if (this.iconImage != null) {
    if (!isEnabled()) {
      Image disabledImage=new ImageIcon(LightGrayFilter.createDisabledImage(iconImage)).getImage();
      g.drawImage(disabledImage,(this.bgImage.getWidth(null) - disabledImage.getWidth(null)) / 2,(this.bgImage.getHeight(null) - disabledImage.getHeight(null)) / 2,this);
    }
 else {
      g.drawImage(this.iconImage,(this.bgImage.getWidth(null) - this.iconImage.getWidth(null)) / 2,(this.bgImage.getHeight(null) - this.iconImage.getHeight(null)) / 2,this);
    }
  }
}","/** 
 * Overrides the <code>paintComponent</code> method of <tt>JButton</tt> to paint the button background and icon, and all additional effects of this configururable button.
 * @param g The Graphics object.
 */
public void paintComponent(Graphics g){
  g=g.create();
  try {
    internalPaintComponent(g);
  }
  finally {
    g.dispose();
  }
}",0.3441367118444313
104285,"/** 
 * Overrides the <code>paintComponent</code> method in <tt>JComponent</tt> to paint the screen capture image as a background of this component.
 */
protected void paintComponent(Graphics g){
  AntialiasingManager.activateAntialiasing(g);
  Graphics2D g2=(Graphics2D)g;
  g2.drawImage(this.background,0,0,null);
  g2.setColor(new Color(255,255,255,180));
  g2.fillRoundRect(0,0,getWidth(),getHeight(),10,10);
  g2.setColor(Constants.BORDER_COLOR);
  g2.drawRoundRect(0,0,getWidth() - 1,getHeight() - 1,10,10);
}","/** 
 * Overrides the <code>paintComponent</code> method in <tt>JComponent</tt> to paint the screen capture image as a background of this component.
 */
protected void paintComponent(Graphics g){
  g=g.create();
  try {
    AntialiasingManager.activateAntialiasing(g);
    Graphics2D g2=(Graphics2D)g;
    int width=getWidth();
    int height=getHeight();
    g2.drawImage(this.background,0,0,null);
    g2.setColor(new Color(255,255,255,180));
    g2.fillRoundRect(0,0,width,height,10,10);
    g2.setColor(Constants.BORDER_COLOR);
    g2.drawRoundRect(0,0,width - 1,height - 1,10,10);
  }
  finally {
    g.dispose();
  }
}",0.8287971905179983
104286,"/** 
 * Initializes and creates an account corresponding to the specified accountProperties and registers the resulting ProtocolProvider in the <tt>context</tt> BundleContext parameter.
 * @param userIDStr the user identifier uniquely representing the newlycreated account within the protocol namespace.
 * @param accountProperties a set of protocol (or implementation)specific properties defining the new account.
 * @return the AccountID of the newly created account.
 * @throws IllegalArgumentException if userID does not correspond to anidentifier in the context of the underlying protocol or if accountProperties does not contain a complete set of account installation properties.
 * @throws IllegalStateException if the account has already beeninstalled.
 * @throws NullPointerException if any of the arguments is null.
 */
public AccountID installAccount(String userIDStr,Map accountProperties){
  BundleContext context=SipActivator.getBundleContext();
  if (context == null)   throw new NullPointerException(""String_Node_Str"");
  if (userIDStr == null)   throw new NullPointerException(""String_Node_Str"");
  accountProperties.put(USER_ID,userIDStr);
  if (accountProperties == null)   throw new NullPointerException(""String_Node_Str"");
  String serverAddress=(String)accountProperties.get(SERVER_ADDRESS);
  if (serverAddress == null)   throw new NullPointerException(""String_Node_Str"");
  if (!accountProperties.containsKey(PROTOCOL))   accountProperties.put(PROTOCOL,ProtocolNames.SIP);
  AccountID accountID=new SipAccountID(userIDStr,accountProperties,serverAddress);
  if (registeredAccounts.containsKey(accountID))   throw new IllegalStateException(""String_Node_Str"" + userIDStr + ""String_Node_Str"");
  this.storeAccount(accountID);
  try {
    accountID=loadAccount(accountProperties);
  }
 catch (  RuntimeException exc) {
    this.removeStoredAccount(SipActivator.getBundleContext(),accountID);
    throw exc;
  }
  return accountID;
}","/** 
 * Initializes and creates an account corresponding to the specified accountProperties and registers the resulting ProtocolProvider in the <tt>context</tt> BundleContext parameter.
 * @param userIDStr the user identifier uniquely representing the newlycreated account within the protocol namespace.
 * @param accountProperties a set of protocol (or implementation)specific properties defining the new account.
 * @return the AccountID of the newly created account.
 * @throws IllegalArgumentException if userID does not correspond to anidentifier in the context of the underlying protocol or if accountProperties does not contain a complete set of account installation properties.
 * @throws IllegalStateException if the account has already beeninstalled.
 * @throws NullPointerException if any of the arguments is null.
 */
public AccountID installAccount(String userIDStr,Map accountProperties){
  BundleContext context=SipActivator.getBundleContext();
  if (context == null)   throw new NullPointerException(""String_Node_Str"");
  if (userIDStr == null)   throw new NullPointerException(""String_Node_Str"");
  accountProperties.put(USER_ID,userIDStr);
  if (accountProperties == null)   throw new NullPointerException(""String_Node_Str"");
  String serverAddress=(String)accountProperties.get(SERVER_ADDRESS);
  if (!accountProperties.containsKey(PROTOCOL))   accountProperties.put(PROTOCOL,ProtocolNames.SIP);
  AccountID accountID=new SipAccountID(userIDStr,accountProperties,serverAddress);
  if (registeredAccounts.containsKey(accountID))   throw new IllegalStateException(""String_Node_Str"" + userIDStr + ""String_Node_Str"");
  this.storeAccount(accountID);
  try {
    accountID=loadAccount(accountProperties);
  }
 catch (  RuntimeException exc) {
    this.removeStoredAccount(SipActivator.getBundleContext(),accountID);
    throw exc;
  }
  return accountID;
}",0.97854526425955
104287,"/** 
 * Modifies the account corresponding to the specified accountID. This method is meant to be used to change properties of already existing accounts. Note that if the given accountID doesn't correspond to any registered account this method would do nothing.
 * @param protocolProvider the protocol provider service corresponding tothe modified account.
 * @param accountProperties a set of protocol (or implementation) specificproperties defining the new account.
 * @throws java.lang.NullPointerException if any of the arguments is null.
 */
public void modifyAccount(ProtocolProviderService protocolProvider,Map accountProperties){
  BundleContext context=SipActivator.getBundleContext();
  if (context == null)   throw new NullPointerException(""String_Node_Str"");
  if (protocolProvider == null)   throw new NullPointerException(""String_Node_Str"");
  SipAccountID accountID=(SipAccountID)protocolProvider.getAccountID();
  if (!registeredAccounts.containsKey(accountID))   return;
  ServiceRegistration registration=(ServiceRegistration)registeredAccounts.get(accountID);
  if (registration != null)   registration.unregister();
  if (accountProperties == null)   throw new NullPointerException(""String_Node_Str"");
  String serverAddress=(String)accountProperties.get(SERVER_ADDRESS);
  if (serverAddress == null)   throw new NullPointerException(""String_Node_Str"");
  if (!accountProperties.containsKey(PROTOCOL))   accountProperties.put(PROTOCOL,ProtocolNames.SIP);
  accountID.setAccountProperties(accountProperties);
  this.storeAccount(accountID);
  String userIDStr=(String)accountProperties.get(USER_ID);
  Hashtable properties=new Hashtable();
  properties.put(PROTOCOL,ProtocolNames.SIP);
  properties.put(USER_ID,userIDStr);
  try {
    ((ProtocolProviderServiceSipImpl)protocolProvider).initialize(userIDStr,accountID);
    this.storeAccount(accountID);
    registration=context.registerService(ProtocolProviderService.class.getName(),protocolProvider,properties);
    registeredAccounts.put(accountID,registration);
  }
 catch (  OperationFailedException ex) {
    logger.error(""String_Node_Str"",ex);
    throw new IllegalArgumentException(""String_Node_Str"" + ex.getMessage());
  }
}","/** 
 * Modifies the account corresponding to the specified accountID. This method is meant to be used to change properties of already existing accounts. Note that if the given accountID doesn't correspond to any registered account this method would do nothing.
 * @param protocolProvider the protocol provider service corresponding tothe modified account.
 * @param accountProperties a set of protocol (or implementation) specificproperties defining the new account.
 * @throws java.lang.NullPointerException if any of the arguments is null.
 */
public void modifyAccount(ProtocolProviderService protocolProvider,Map accountProperties){
  BundleContext context=SipActivator.getBundleContext();
  if (context == null)   throw new NullPointerException(""String_Node_Str"");
  if (protocolProvider == null)   throw new NullPointerException(""String_Node_Str"");
  SipAccountID accountID=(SipAccountID)protocolProvider.getAccountID();
  if (!registeredAccounts.containsKey(accountID))   return;
  ServiceRegistration registration=(ServiceRegistration)registeredAccounts.get(accountID);
  if (registration != null)   registration.unregister();
  if (accountProperties == null)   throw new NullPointerException(""String_Node_Str"");
  if (!accountProperties.containsKey(PROTOCOL))   accountProperties.put(PROTOCOL,ProtocolNames.SIP);
  accountID.setAccountProperties(accountProperties);
  this.storeAccount(accountID);
  String userIDStr=(String)accountProperties.get(USER_ID);
  Hashtable properties=new Hashtable();
  properties.put(PROTOCOL,ProtocolNames.SIP);
  properties.put(USER_ID,userIDStr);
  try {
    ((ProtocolProviderServiceSipImpl)protocolProvider).initialize(userIDStr,accountID);
    this.storeAccount(accountID);
    registration=context.registerService(ProtocolProviderService.class.getName(),protocolProvider,properties);
    registeredAccounts.put(accountID,registration);
  }
 catch (  OperationFailedException ex) {
    logger.error(""String_Node_Str"",ex);
    throw new IllegalArgumentException(""String_Node_Str"" + ex.getMessage());
  }
}",0.9642521166509878
104288,"/** 
 * Initializes the SipRegistrarConnection that this class will be using.
 * @param accountID the ID of the account that this registrar is associatedwith.
 * @throws java.lang.IllegalArgumentException if one or more accountproperties have invalid values.
 */
private void initRegistrarConnection(SipAccountID accountID) throws IllegalArgumentException {
  String registrarAddressStr=(String)accountID.getAccountProperties().get(ProtocolProviderFactory.SERVER_ADDRESS);
  if (registrarAddressStr == null) {
    String userID=(String)accountID.getAccountProperties().get(ProtocolProviderFactory.USER_ID);
    if (userID.indexOf(""String_Node_Str"") > -1)     registrarAddressStr=userID.substring(userID.indexOf(""String_Node_Str"") + 1);
  }
  if (registrarAddressStr == null || registrarAddressStr.trim().length() == 0) {
    initRegistrarlessConnection(accountID);
    return;
  }
  InetAddress registrarAddress=null;
  int registrarPort=ListeningPoint.PORT_5060;
  try {
    String registrarTransport=(String)accountID.getAccountProperties().get(ProtocolProviderFactory.PREFERRED_TRANSPORT);
    if (registrarTransport == null)     registrarTransport=getDefaultTransport();
    InetSocketAddress registrarSocketAddress=resolveSipAddress(registrarAddressStr,registrarTransport);
    registrarAddress=registrarSocketAddress.getAddress();
    registrarPort=registrarSocketAddress.getPort();
    accountID.putProperty(ProtocolProviderFactory.SERVER_ADDRESS_VALIDATED,Boolean.toString(true));
  }
 catch (  UnknownHostException ex) {
    logger.debug(registrarAddressStr + ""String_Node_Str"",ex);
    String serverValidatedString=(String)accountID.getAccountProperties().get(ProtocolProviderFactory.SERVER_ADDRESS_VALIDATED);
    boolean isServerValidated=false;
    if (serverValidatedString != null)     isServerValidated=new Boolean(serverValidatedString).booleanValue();
    if (serverValidatedString == null || !isServerValidated) {
      throw new IllegalArgumentException(registrarAddressStr + ""String_Node_Str"" + ex.getMessage());
    }
  }
  if (registrarAddress == null) {
    fireRegistrationStateChanged(RegistrationState.UNREGISTERED,RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_SERVER_NOT_FOUND,""String_Node_Str"");
    return;
  }
  String registrarPortStr=(String)accountID.getAccountProperties().get(ProtocolProviderFactory.SERVER_PORT);
  if (registrarPortStr != null && registrarPortStr.length() > 0) {
    try {
      registrarPort=Integer.parseInt(registrarPortStr);
    }
 catch (    NumberFormatException ex) {
      logger.error(registrarPortStr + ""String_Node_Str"",ex);
    }
    if (registrarPort > NetworkUtils.MAX_PORT_NUMBER) {
      throw new IllegalArgumentException(registrarPort + ""String_Node_Str"" + NetworkUtils.MAX_PORT_NUMBER+ ""String_Node_Str"");
    }
  }
  String registrarTransport=(String)accountID.getAccountProperties().get(ProtocolProviderFactory.PREFERRED_TRANSPORT);
  if (registrarTransport != null && registrarTransport.length() > 0) {
    if (!registrarTransport.equals(ListeningPoint.UDP) && !registrarTransport.equals(ListeningPoint.TCP) && !registrarTransport.equals(ListeningPoint.TLS)) {
      throw new IllegalArgumentException(registrarTransport + ""String_Node_Str"" + ""String_Node_Str"");
    }
  }
 else {
    registrarTransport=ListeningPoint.UDP;
  }
  int expires=SipRegistrarConnection.DEFAULT_REGISTRATION_EXPIRATION;
  String expiresStr=SipActivator.getConfigurationService().getString(REGISTRATION_EXPIRATION);
  if (expiresStr != null && expiresStr.length() > 0) {
    try {
      expires=Integer.parseInt(expiresStr);
    }
 catch (    NumberFormatException ex) {
      logger.error(expiresStr + ""String_Node_Str"",ex);
    }
  }
  try {
    this.sipRegistrarConnection=new SipRegistrarConnection(registrarAddress,registrarPort,registrarTransport,expires,this);
    String useRouteString=(String)accountID.getAccountProperties().get(REGISTERS_USE_ROUTE);
    boolean useRoute=false;
    if (useRouteString != null)     useRoute=new Boolean(useRouteString).booleanValue();
    this.sipRegistrarConnection.setRouteHeaderEnabled(useRoute);
  }
 catch (  ParseException ex) {
    logger.error(""String_Node_Str"" + registrarAddress.getHostAddress(),ex);
    throw new IllegalArgumentException(""String_Node_Str"" + registrarAddress.getHostAddress() + ""String_Node_Str""+ ex.getMessage());
  }
}","/** 
 * Initializes the SipRegistrarConnection that this class will be using.
 * @param accountID the ID of the account that this registrar is associatedwith.
 * @throws java.lang.IllegalArgumentException if one or more accountproperties have invalid values.
 */
private void initRegistrarConnection(SipAccountID accountID) throws IllegalArgumentException {
  String registrarAddressStr=(String)accountID.getAccountProperties().get(ProtocolProviderFactory.SERVER_ADDRESS);
  if (registrarAddressStr == null) {
    String userID=(String)accountID.getAccountProperties().get(ProtocolProviderFactory.USER_ID);
    int index=userID.indexOf(""String_Node_Str"");
    if (index > -1)     registrarAddressStr=userID.substring(index + 1);
  }
  if (registrarAddressStr == null || registrarAddressStr.trim().length() == 0) {
    initRegistrarlessConnection(accountID);
    return;
  }
  InetAddress registrarAddress=null;
  int registrarPort=ListeningPoint.PORT_5060;
  try {
    String registrarTransport=(String)accountID.getAccountProperties().get(ProtocolProviderFactory.PREFERRED_TRANSPORT);
    if (registrarTransport == null)     registrarTransport=getDefaultTransport();
    InetSocketAddress registrarSocketAddress=resolveSipAddress(registrarAddressStr,registrarTransport);
    registrarAddress=registrarSocketAddress.getAddress();
    registrarPort=registrarSocketAddress.getPort();
    accountID.putProperty(ProtocolProviderFactory.SERVER_ADDRESS_VALIDATED,Boolean.toString(true));
  }
 catch (  UnknownHostException ex) {
    logger.debug(registrarAddressStr + ""String_Node_Str"",ex);
    String serverValidatedString=(String)accountID.getAccountProperties().get(ProtocolProviderFactory.SERVER_ADDRESS_VALIDATED);
    boolean isServerValidated=false;
    if (serverValidatedString != null)     isServerValidated=new Boolean(serverValidatedString).booleanValue();
    if (serverValidatedString == null || !isServerValidated) {
      throw new IllegalArgumentException(registrarAddressStr + ""String_Node_Str"" + ex.getMessage());
    }
  }
  if (registrarAddress == null) {
    fireRegistrationStateChanged(RegistrationState.UNREGISTERED,RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_SERVER_NOT_FOUND,""String_Node_Str"");
    return;
  }
  String registrarPortStr=(String)accountID.getAccountProperties().get(ProtocolProviderFactory.SERVER_PORT);
  if (registrarPortStr != null && registrarPortStr.length() > 0) {
    try {
      registrarPort=Integer.parseInt(registrarPortStr);
    }
 catch (    NumberFormatException ex) {
      logger.error(registrarPortStr + ""String_Node_Str"",ex);
    }
    if (registrarPort > NetworkUtils.MAX_PORT_NUMBER) {
      throw new IllegalArgumentException(registrarPort + ""String_Node_Str"" + NetworkUtils.MAX_PORT_NUMBER+ ""String_Node_Str"");
    }
  }
  String registrarTransport=(String)accountID.getAccountProperties().get(ProtocolProviderFactory.PREFERRED_TRANSPORT);
  if (registrarTransport != null && registrarTransport.length() > 0) {
    if (!registrarTransport.equals(ListeningPoint.UDP) && !registrarTransport.equals(ListeningPoint.TCP) && !registrarTransport.equals(ListeningPoint.TLS)) {
      throw new IllegalArgumentException(registrarTransport + ""String_Node_Str"" + ""String_Node_Str"");
    }
  }
 else {
    registrarTransport=ListeningPoint.UDP;
  }
  int expires=SipRegistrarConnection.DEFAULT_REGISTRATION_EXPIRATION;
  String expiresStr=SipActivator.getConfigurationService().getString(REGISTRATION_EXPIRATION);
  if (expiresStr != null && expiresStr.length() > 0) {
    try {
      expires=Integer.parseInt(expiresStr);
    }
 catch (    NumberFormatException ex) {
      logger.error(expiresStr + ""String_Node_Str"",ex);
    }
  }
  try {
    this.sipRegistrarConnection=new SipRegistrarConnection(registrarAddress,registrarPort,registrarTransport,expires,this);
    String useRouteString=(String)accountID.getAccountProperties().get(REGISTERS_USE_ROUTE);
    boolean useRoute=false;
    if (useRouteString != null)     useRoute=new Boolean(useRouteString).booleanValue();
    this.sipRegistrarConnection.setRouteHeaderEnabled(useRoute);
  }
 catch (  ParseException ex) {
    logger.error(""String_Node_Str"" + registrarAddress.getHostAddress(),ex);
    throw new IllegalArgumentException(""String_Node_Str"" + registrarAddress.getHostAddress() + ""String_Node_Str""+ ex.getMessage());
  }
}",0.9937020496965532
104289,"/** 
 * Returns a string that could be directly used (or easily converted to) an address that other users of the procotol can use to communicate with us. By default this string is set to userid@servicename. Protocol implementors should override it if they'd need it to respect a different syntax.
 * @return a String in the form of userid@service that other protocol usersshould be able to parse into a meaningful address and use it to communicate with us.
 */
public String getAccountAddress(){
  return ""String_Node_Str"" + getUserID() + ""String_Node_Str""+ getService();
}","/** 
 * Returns a string that could be directly used (or easily converted to) an address that other users of the procotol can use to communicate with us. By default this string is set to userid@servicename. Protocol implementors should override it if they'd need it to respect a different syntax.
 * @return a String in the form of userid@service that other protocol usersshould be able to parse into a meaningful address and use it to communicate with us.
 */
public String getAccountAddress(){
  StringBuffer accountAddress=new StringBuffer();
  accountAddress.append(""String_Node_Str"");
  accountAddress.append(getUserID());
  String service=getService();
  if (service != null) {
    accountAddress.append('@');
    accountAddress.append(service);
  }
  return accountAddress.toString();
}",0.7862371888726208
104290,"/** 
 * Creates a SIP account id from the specified ide and account properties.
 * @param userID the user id part of the SIP uri identifying this contact.
 * @param accountProperties any other properties necessary for the account.
 * @param serverName the name of the server that the user belongs to.
 */
protected SipAccountID(String userID,Map accountProperties,String serverName){
  super((userID.indexOf(""String_Node_Str"") > -1) ? userID.substring(0,userID.indexOf(""String_Node_Str"")) : userID,accountProperties,(String)accountProperties.get(ProtocolProviderFactory.PROTOCOL),serverName);
}","/** 
 * Creates a SIP account id from the specified ide and account properties.
 * @param userID the user id part of the SIP uri identifying this contact.
 * @param accountProperties any other properties necessary for the account.
 * @param serverName the name of the server that the user belongs to.
 */
protected SipAccountID(String userID,Map accountProperties,String serverName){
  super(getUserIDWithoutServerName(userID),accountProperties,(String)accountProperties.get(ProtocolProviderFactory.PROTOCOL),serverName);
}",0.8898836168307968
104291,"/** 
 * Fills the UIN and Password fields in this panel with the data coming from the given protocolProvider.
 * @param protocolProvider The <tt>ProtocolProviderService</tt> to loadthe data from.
 */
public void loadAccount(ProtocolProviderService protocolProvider){
  AccountID accountID=protocolProvider.getAccountID();
  String password=(String)accountID.getAccountProperties().get(ProtocolProviderFactory.PASSWORD);
  String serverAddress=(String)accountID.getAccountProperties().get(ProtocolProviderFactory.SERVER_ADDRESS);
  String serverPort=(String)accountID.getAccountProperties().get(ProtocolProviderFactory.SERVER_PORT);
  String proxyAddress=(String)accountID.getAccountProperties().get(ProtocolProviderFactory.PROXY_ADDRESS);
  String proxyPort=(String)accountID.getAccountProperties().get(ProtocolProviderFactory.PROXY_PORT);
  String preferredTransport=(String)accountID.getAccountProperties().get(ProtocolProviderFactory.PREFERRED_TRANSPORT);
  boolean enablePresence=new Boolean((String)accountID.getAccountProperties().get(ProtocolProviderFactory.IS_PRESENCE_ENABLED)).booleanValue();
  boolean forceP2P=new Boolean((String)accountID.getAccountProperties().get(ProtocolProviderFactory.FORCE_P2P_MODE)).booleanValue();
  String pollingPeriod=(String)accountID.getAccountProperties().get(ProtocolProviderFactory.POLLING_PERIOD);
  String subscriptionPeriod=(String)accountID.getAccountProperties().get(ProtocolProviderFactory.SUBSCRIPTION_EXPIRATION);
  String keepAliveMethod=(String)accountID.getAccountProperties().get(""String_Node_Str"");
  String keepAliveInterval=(String)accountID.getAccountProperties().get(""String_Node_Str"");
  uinField.setEnabled(false);
  this.uinField.setText(accountID.getUserID() + ""String_Node_Str"" + serverAddress);
  if (password != null) {
    this.passField.setText(password);
    this.rememberPassBox.setSelected(true);
  }
  serverField.setText(serverAddress);
  serverField.setEnabled(false);
  serverPortField.setText(serverPort);
  proxyField.setText(proxyAddress);
  transportCombo.setSelectedItem(preferredTransport);
  proxyPortField.setText(proxyPort);
  if (!(SIPAccountRegistration.DEFAULT_PORT.equals(serverPort) || SIPAccountRegistration.DEFAULT_TLS_PORT.equals(serverPort)) || !(SIPAccountRegistration.DEFAULT_PORT.equals(proxyPort) || SIPAccountRegistration.DEFAULT_TLS_PORT.equals(proxyPort)) || !transportCombo.getSelectedItem().equals(SIPAccountRegistration.DEFAULT_TRANSPORT)) {
    enableAdvOpButton.setSelected(true);
    serverField.setEnabled(false);
    serverPortField.setEnabled(true);
    proxyField.setEnabled(true);
    proxyPortField.setEnabled(true);
    transportCombo.setEnabled(true);
  }
  enablePresOpButton.setSelected(enablePresence);
  forceP2PPresOpButton.setSelected(forceP2P);
  pollPeriodField.setText(pollingPeriod);
  subscribeExpiresField.setText(subscriptionPeriod);
  if (!enablePresence) {
    pollPeriodField.setEnabled(false);
    subscribeExpiresField.setEnabled(false);
  }
  keepAliveMethodBox.setSelectedItem(keepAliveMethod);
  keepAliveIntervalValue.setText(keepAliveInterval);
}","/** 
 * Fills the UIN and Password fields in this panel with the data coming from the given protocolProvider.
 * @param protocolProvider The <tt>ProtocolProviderService</tt> to loadthe data from.
 */
public void loadAccount(ProtocolProviderService protocolProvider){
  AccountID accountID=protocolProvider.getAccountID();
  String password=(String)accountID.getAccountProperties().get(ProtocolProviderFactory.PASSWORD);
  String serverAddress=(String)accountID.getAccountProperties().get(ProtocolProviderFactory.SERVER_ADDRESS);
  String serverPort=(String)accountID.getAccountProperties().get(ProtocolProviderFactory.SERVER_PORT);
  String proxyAddress=(String)accountID.getAccountProperties().get(ProtocolProviderFactory.PROXY_ADDRESS);
  String proxyPort=(String)accountID.getAccountProperties().get(ProtocolProviderFactory.PROXY_PORT);
  String preferredTransport=(String)accountID.getAccountProperties().get(ProtocolProviderFactory.PREFERRED_TRANSPORT);
  boolean enablePresence=new Boolean((String)accountID.getAccountProperties().get(ProtocolProviderFactory.IS_PRESENCE_ENABLED)).booleanValue();
  boolean forceP2P=new Boolean((String)accountID.getAccountProperties().get(ProtocolProviderFactory.FORCE_P2P_MODE)).booleanValue();
  String pollingPeriod=(String)accountID.getAccountProperties().get(ProtocolProviderFactory.POLLING_PERIOD);
  String subscriptionPeriod=(String)accountID.getAccountProperties().get(ProtocolProviderFactory.SUBSCRIPTION_EXPIRATION);
  String keepAliveMethod=(String)accountID.getAccountProperties().get(""String_Node_Str"");
  String keepAliveInterval=(String)accountID.getAccountProperties().get(""String_Node_Str"");
  uinField.setEnabled(false);
  this.uinField.setText((serverAddress == null) ? accountID.getUserID() : (accountID.getUserID() + ""String_Node_Str"" + serverAddress));
  if (password != null) {
    this.passField.setText(password);
    this.rememberPassBox.setSelected(true);
  }
  serverField.setText(serverAddress);
  serverField.setEnabled(false);
  serverPortField.setText(serverPort);
  proxyField.setText(proxyAddress);
  transportCombo.setSelectedItem(preferredTransport);
  proxyPortField.setText(proxyPort);
  if (!(SIPAccountRegistration.DEFAULT_PORT.equals(serverPort) || SIPAccountRegistration.DEFAULT_TLS_PORT.equals(serverPort)) || !(SIPAccountRegistration.DEFAULT_PORT.equals(proxyPort) || SIPAccountRegistration.DEFAULT_TLS_PORT.equals(proxyPort)) || !transportCombo.getSelectedItem().equals(SIPAccountRegistration.DEFAULT_TRANSPORT)) {
    enableAdvOpButton.setSelected(true);
    serverField.setEnabled(false);
    serverPortField.setEnabled(true);
    proxyField.setEnabled(true);
    proxyPortField.setEnabled(true);
    transportCombo.setEnabled(true);
  }
  enablePresOpButton.setSelected(enablePresence);
  forceP2PPresOpButton.setSelected(forceP2P);
  pollPeriodField.setText(pollingPeriod);
  subscribeExpiresField.setText(subscriptionPeriod);
  if (!enablePresence) {
    pollPeriodField.setEnabled(false);
    subscribeExpiresField.setEnabled(false);
  }
  keepAliveMethodBox.setSelectedItem(keepAliveMethod);
  keepAliveIntervalValue.setText(keepAliveInterval);
}",0.9916479280436876
104292,"/** 
 * Creates an account for the given user and password.
 * @param providerFactory the ProtocolProviderFactory which will createthe account
 * @param userName the user identifier
 * @param passwd the password
 * @return the <tt>ProtocolProviderService</tt> for the new account.
 */
private ProtocolProviderService installAccount(ProtocolProviderFactory providerFactory,String userName,String passwd){
  Hashtable accountProperties=new Hashtable();
  if (registration.isRememberPassword()) {
    accountProperties.put(ProtocolProviderFactory.PASSWORD,passwd);
  }
  String serverAddress=null;
  if (registration.getServerAddress() != null)   serverAddress=registration.getServerAddress();
 else   serverAddress=getServerFromUserName(userName);
  accountProperties.put(ProtocolProviderFactory.SERVER_ADDRESS,serverAddress);
  accountProperties.put(ProtocolProviderFactory.SERVER_PORT,registration.getServerPort());
  String proxyAddress=null;
  if (registration.getProxy() != null)   proxyAddress=registration.getProxy();
 else   proxyAddress=getServerFromUserName(userName);
  accountProperties.put(ProtocolProviderFactory.PROXY_ADDRESS,proxyAddress);
  accountProperties.put(ProtocolProviderFactory.PROXY_PORT,registration.getProxyPort());
  accountProperties.put(ProtocolProviderFactory.PREFERRED_TRANSPORT,registration.getPreferredTransport());
  accountProperties.put(ProtocolProviderFactory.IS_PRESENCE_ENABLED,Boolean.toString(registration.isEnablePresence()));
  accountProperties.put(ProtocolProviderFactory.FORCE_P2P_MODE,Boolean.toString(registration.isForceP2PMode()));
  accountProperties.put(ProtocolProviderFactory.POLLING_PERIOD,registration.getPollingPeriod());
  accountProperties.put(ProtocolProviderFactory.SUBSCRIPTION_EXPIRATION,registration.getSubscriptionExpiration());
  accountProperties.put(""String_Node_Str"",registration.getKeepAliveMethod());
  accountProperties.put(""String_Node_Str"",registration.getKeepAliveInterval());
  if (isModification) {
    providerFactory.modifyAccount(protocolProvider,accountProperties);
    this.isModification=false;
    return protocolProvider;
  }
  try {
    AccountID accountID=providerFactory.installAccount(userName,accountProperties);
    ServiceReference serRef=providerFactory.getProviderForAccount(accountID);
    protocolProvider=(ProtocolProviderService)SIPAccRegWizzActivator.bundleContext.getService(serRef);
  }
 catch (  IllegalArgumentException exc) {
    SIPAccRegWizzActivator.getUIService().getPopupDialog().showMessagePopupDialog(exc.getMessage(),Resources.getString(""String_Node_Str""),PopupDialog.ERROR_MESSAGE);
  }
catch (  IllegalStateException exc) {
    SIPAccRegWizzActivator.getUIService().getPopupDialog().showMessagePopupDialog(exc.getMessage(),Resources.getString(""String_Node_Str""),PopupDialog.ERROR_MESSAGE);
  }
  return protocolProvider;
}","/** 
 * Creates an account for the given user and password.
 * @param providerFactory the ProtocolProviderFactory which will createthe account
 * @param userName the user identifier
 * @param passwd the password
 * @return the <tt>ProtocolProviderService</tt> for the new account.
 */
private ProtocolProviderService installAccount(ProtocolProviderFactory providerFactory,String userName,String passwd){
  Hashtable accountProperties=new Hashtable();
  if (registration.isRememberPassword()) {
    accountProperties.put(ProtocolProviderFactory.PASSWORD,passwd);
  }
  String serverAddress=null;
  if (registration.getServerAddress() != null)   serverAddress=registration.getServerAddress();
 else   serverAddress=getServerFromUserName(userName);
  if (serverAddress != null)   accountProperties.put(ProtocolProviderFactory.SERVER_ADDRESS,serverAddress);
  accountProperties.put(ProtocolProviderFactory.SERVER_PORT,registration.getServerPort());
  String proxyAddress=null;
  if (registration.getProxy() != null)   proxyAddress=registration.getProxy();
 else   proxyAddress=getServerFromUserName(userName);
  if (proxyAddress != null)   accountProperties.put(ProtocolProviderFactory.PROXY_ADDRESS,proxyAddress);
  accountProperties.put(ProtocolProviderFactory.PROXY_PORT,registration.getProxyPort());
  accountProperties.put(ProtocolProviderFactory.PREFERRED_TRANSPORT,registration.getPreferredTransport());
  accountProperties.put(ProtocolProviderFactory.IS_PRESENCE_ENABLED,Boolean.toString(registration.isEnablePresence()));
  accountProperties.put(ProtocolProviderFactory.FORCE_P2P_MODE,Boolean.toString(registration.isForceP2PMode()));
  accountProperties.put(ProtocolProviderFactory.POLLING_PERIOD,registration.getPollingPeriod());
  accountProperties.put(ProtocolProviderFactory.SUBSCRIPTION_EXPIRATION,registration.getSubscriptionExpiration());
  accountProperties.put(""String_Node_Str"",registration.getKeepAliveMethod());
  accountProperties.put(""String_Node_Str"",registration.getKeepAliveInterval());
  if (isModification) {
    providerFactory.modifyAccount(protocolProvider,accountProperties);
    this.isModification=false;
    return protocolProvider;
  }
  try {
    AccountID accountID=providerFactory.installAccount(userName,accountProperties);
    ServiceReference serRef=providerFactory.getProviderForAccount(accountID);
    protocolProvider=(ProtocolProviderService)SIPAccRegWizzActivator.bundleContext.getService(serRef);
  }
 catch (  IllegalArgumentException exc) {
    SIPAccRegWizzActivator.getUIService().getPopupDialog().showMessagePopupDialog(exc.getMessage(),Resources.getString(""String_Node_Str""),PopupDialog.ERROR_MESSAGE);
  }
catch (  IllegalStateException exc) {
    SIPAccRegWizzActivator.getUIService().getPopupDialog().showMessagePopupDialog(exc.getMessage(),Resources.getString(""String_Node_Str""),PopupDialog.ERROR_MESSAGE);
  }
  return protocolProvider;
}",0.990054091781539
104293,"/** 
 * Called when this bundle is started.
 * @param bundleContext The execution context of the bundle being started.
 */
public void start(BundleContext bundleContext) throws Exception {
  isStarted=true;
  GuiActivator.bundleContext=bundleContext;
  NotificationManager.registerGuiNotifications();
  notificationServiceListener=new NotificationServiceListener();
  bundleContext.addServiceListener(notificationServiceListener);
  ConfigurationManager.loadGuiConfigurations();
  try {
    this.uiService=new UIServiceImpl();
    logger.info(""String_Node_Str"");
    bundleContext.registerService(UIService.class.getName(),this.uiService,null);
    logger.info(""String_Node_Str"");
    uiService.loadApplicationGui();
    logger.logEntry();
  }
  finally {
    logger.logExit();
  }
  GuiActivator.getConfigurationService().addPropertyChangeListener(uiService);
  bundleContext.addServiceListener(uiService);
}","/** 
 * Called when this bundle is started.
 * @param bundleContext The execution context of the bundle being started.
 */
public void start(BundleContext bundleContext) throws Exception {
  isStarted=true;
  GuiActivator.bundleContext=bundleContext;
  NotificationManager.registerGuiNotifications();
  notificationServiceListener=new NotificationServiceListener();
  bundleContext.addServiceListener(notificationServiceListener);
  ConfigurationManager.loadGuiConfigurations();
  try {
    uiService=new UIServiceImpl();
    logger.info(""String_Node_Str"");
    bundleContext.registerService(UIService.class.getName(),uiService,null);
    logger.info(""String_Node_Str"");
    uiService.loadApplicationGui();
    logger.logEntry();
  }
  finally {
    logger.logExit();
  }
  GuiActivator.getConfigurationService().addPropertyChangeListener(uiService);
  bundleContext.addServiceListener(uiService);
}",0.9944690265486724
104294,"/** 
 * Returns all <tt>ProtocolProviderFactory</tt>s obtained from the bundle context.
 * @return all <tt>ProtocolProviderFactory</tt>s obtained from the bundlecontext
 */
public static Map getProtocolProviderFactories(){
  ServiceReference[] serRefs=null;
  try {
    serRefs=bundleContext.getServiceReferences(ProtocolProviderFactory.class.getName(),null);
  }
 catch (  InvalidSyntaxException e) {
    logger.error(""String_Node_Str"" + e);
  }
  for (int i=0; i < serRefs.length; i++) {
    ProtocolProviderFactory providerFactory=(ProtocolProviderFactory)bundleContext.getService(serRefs[i]);
    providerFactoriesMap.put(serRefs[i].getProperty(ProtocolProviderFactory.PROTOCOL),providerFactory);
  }
  return providerFactoriesMap;
}","/** 
 * Returns all <tt>ProtocolProviderFactory</tt>s obtained from the bundle context.
 * @return all <tt>ProtocolProviderFactory</tt>s obtained from the bundlecontext
 */
public static Map<Object,ProtocolProviderFactory> getProtocolProviderFactories(){
  ServiceReference[] serRefs=null;
  try {
    serRefs=bundleContext.getServiceReferences(ProtocolProviderFactory.class.getName(),null);
  }
 catch (  InvalidSyntaxException e) {
    logger.error(""String_Node_Str"" + e);
  }
  for (int i=0; i < serRefs.length; i++) {
    ProtocolProviderFactory providerFactory=(ProtocolProviderFactory)bundleContext.getService(serRefs[i]);
    providerFactoriesMap.put(serRefs[i].getProperty(ProtocolProviderFactory.PROTOCOL),providerFactory);
  }
  return providerFactoriesMap;
}",0.9787516600265604
104295,"/** 
 * Handles the <tt>ActionEvent</tt>. Depending on the user choice sets the return code to the appropriate value.
 */
public void actionPerformed(ActionEvent e){
  JButton button=(JButton)e.getSource();
  if (button.equals(okButton)) {
    if (doNotAskAgain.isSelected()) {
      this.returnCode=OK_DONT_ASK_CODE;
    }
 else {
      this.returnCode=OK_RETURN_CODE;
    }
  }
 else {
    this.returnCode=CANCEL_RETURN_CODE;
  }
synchronized (lock) {
    lock.notify();
  }
  this.dispose();
}","/** 
 * Handles the <tt>ActionEvent</tt>. Depending on the user choice sets the return code to the appropriate value.
 */
public void actionPerformed(ActionEvent e){
  JButton button=(JButton)e.getSource();
  if (button.equals(okButton)) {
    if (doNotAskAgain.isSelected()) {
      this.returnCode=OK_DONT_ASK_CODE;
    }
 else {
      this.returnCode=OK_RETURN_CODE;
    }
  }
 else {
    this.returnCode=CANCEL_RETURN_CODE;
  }
  this.dispose();
}",0.9229144667370645
104296,"/** 
 * Shows the dialog.
 * @return The return code that should indicate what was the choice ofthe user. If the user chooses cancel, the return code is the  CANCEL_RETURN_CODE.
 */
public int showDialog(){
  this.pack();
  this.setVisible(true);
synchronized (lock) {
    try {
      lock.wait();
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
  }
  return returnCode;
}","/** 
 * Shows the dialog.
 * @return The return code that should indicate what was the choice ofthe user. If the user chooses cancel, the return code is the  CANCEL_RETURN_CODE.
 */
public int showDialog(){
  if (!SwingUtilities.isEventDispatchThread()) {
    final int[] returnCodes=new int[1];
    Exception exception=null;
    try {
      SwingUtilities.invokeAndWait(new Runnable(){
        public void run(){
          returnCodes[0]=showDialog();
        }
      }
);
    }
 catch (    InterruptedException ex) {
      exception=ex;
    }
catch (    InvocationTargetException ex) {
      exception=ex;
    }
    if (exception != null)     throw new UndeclaredThrowableException(exception);
    return returnCodes[0];
  }
  pack();
  setModal(true);
  setVisible(true);
  return returnCode;
}",0.3856427378964941
104297,"/** 
 * Removes the associated with this <tt>PluginComponentEvent</tt> component from this container.
 */
public void pluginComponentRemoved(PluginComponentEvent event){
  final PluginComponent pluginComponent=event.getPluginComponent();
  Container containerID=pluginComponent.getContainer();
  if (containerID.equals(Container.CONTAINER_MAIN_WINDOW)) {
    Object constraints=UIServiceImpl.getBorderLayoutConstraintsFromContainer(pluginComponent.getConstraints());
    if (constraints == null)     constraints=BorderLayout.SOUTH;
    if (pluginComponent.isNativeComponent()) {
      if (nativePluginsTable.containsKey(pluginComponent)) {
        final Component c=(Component)nativePluginsTable.get(pluginComponent);
        final Object finalConstraints=constraints;
        SwingUtilities.invokeLater(new Runnable(){
          public void run(){
            removePluginComponent(c,pluginComponent.getContainer(),finalConstraints);
            getContentPane().repaint();
          }
        }
);
      }
    }
 else {
      this.removePluginComponent((Component)pluginComponent.getComponent(),pluginComponent.getContainer(),constraints);
    }
    nativePluginsTable.remove(pluginComponent);
  }
}","/** 
 * Removes the associated with this <tt>PluginComponentEvent</tt> component from this container.
 */
public void pluginComponentRemoved(PluginComponentEvent event){
  final PluginComponent pluginComponent=event.getPluginComponent();
  Container containerID=pluginComponent.getContainer();
  if (containerID.equals(Container.CONTAINER_MAIN_WINDOW)) {
    Object constraints=UIServiceImpl.getBorderLayoutConstraintsFromContainer(pluginComponent.getConstraints());
    if (constraints == null)     constraints=BorderLayout.SOUTH;
    if (pluginComponent.isNativeComponent()) {
      if (nativePluginsTable.containsKey(pluginComponent)) {
        final Component c=nativePluginsTable.get(pluginComponent);
        final Object finalConstraints=constraints;
        SwingUtilities.invokeLater(new Runnable(){
          public void run(){
            removePluginComponent(c,pluginComponent.getContainer(),finalConstraints);
            getContentPane().repaint();
          }
        }
);
      }
    }
 else {
      this.removePluginComponent((Component)pluginComponent.getComponent(),pluginComponent.getContainer(),constraints);
    }
    nativePluginsTable.remove(pluginComponent);
  }
}",0.9953994144709328
104298,"/** 
 * Removes all native plugins from this container.
 */
private void removeNativePlugins(){
  Iterator pluginIterator=nativePluginsTable.entrySet().iterator();
  Object constraints;
  while (pluginIterator.hasNext()) {
    Map.Entry<PluginComponent,Component> entry=(Map.Entry<PluginComponent,Component>)pluginIterator.next();
    PluginComponent pluginComponent=(PluginComponent)entry.getKey();
    Component c=(Component)entry.getValue();
    constraints=UIServiceImpl.getBorderLayoutConstraintsFromContainer(pluginComponent.getConstraints());
    if (constraints == null)     constraints=BorderLayout.SOUTH;
    this.removePluginComponent(c,pluginComponent.getContainer(),constraints);
    this.getContentPane().repaint();
  }
}","/** 
 * Removes all native plugins from this container.
 */
private void removeNativePlugins(){
  Object constraints;
  for (  Map.Entry<PluginComponent,Component> entry : nativePluginsTable.entrySet()) {
    PluginComponent pluginComponent=entry.getKey();
    Component c=entry.getValue();
    constraints=UIServiceImpl.getBorderLayoutConstraintsFromContainer(pluginComponent.getConstraints());
    if (constraints == null)     constraints=BorderLayout.SOUTH;
    this.removePluginComponent(c,pluginComponent.getContainer(),constraints);
    this.getContentPane().repaint();
  }
}",0.7203647416413373
104299,"public void run(){
  if (isVisible) {
    MainFrame.this.addNativePlugins();
    MainFrame.super.setVisible(isVisible);
    MainFrame.super.setExtendedState(MainFrame.NORMAL);
    MainFrame.super.toFront();
  }
 else {
    MainFrame.super.setVisible(isVisible);
  }
}","public void run(){
  if (ConfigurationManager.isQuitWarningShown()) {
    MessageDialog dialog=new MessageDialog(null,Messages.getI18NString(""String_Node_Str"").getText(),Messages.getI18NString(""String_Node_Str"").getText(),false);
    if (dialog.showDialog() == MessageDialog.OK_DONT_ASK_CODE)     ConfigurationManager.setQuitWarningShown(false);
  }
}",0.1391585760517799
104300,"/** 
 * Creates an instance of <tt>MainFrame</tt>.
 */
public MainFrame(){
  if (!ConfigurationManager.isWindowDecorated()) {
    this.setUndecorated(true);
  }
  this.mainCallPanel=new MainCallPanel(this);
  this.contactListPanel=new ContactListPane(this);
  this.accountStatusPanel=new AccountStatusPanel(this);
  menu=new MainMenu(this);
  this.addWindowListener(new MainFrameWindowAdapter());
  this.initTitleFont();
  String applicationName=GuiActivator.getResources().getSettingsString(""String_Node_Str"");
  this.setTitle(applicationName);
  this.mainPanel.setBackground(new Color(GuiActivator.getResources().getColor(""String_Node_Str"")));
  this.init();
  this.initPluginComponents();
}","/** 
 * Creates an instance of <tt>MainFrame</tt>.
 */
public MainFrame(){
  if (!ConfigurationManager.isWindowDecorated()) {
    this.setUndecorated(true);
  }
  this.mainCallPanel=new MainCallPanel(this);
  this.contactListPanel=new ContactListPane(this);
  this.accountStatusPanel=new AccountStatusPanel(this);
  menu=new MainMenu(this);
  this.addWindowListener(new WindowAdapter(){
    public void windowClosed(    WindowEvent event){
      MainFrame.this.windowClosed(event);
    }
    public void windowClosing(    WindowEvent event){
      MainFrame.this.windowClosing(event);
    }
  }
);
  this.initTitleFont();
  String applicationName=GuiActivator.getResources().getSettingsString(""String_Node_Str"");
  this.setTitle(applicationName);
  this.mainPanel.setBackground(new Color(GuiActivator.getResources().getColor(""String_Node_Str"")));
  this.init();
  this.initPluginComponents();
}",0.8620037807183365
104301,"public void windowClosed(WindowEvent e){
  if (GuiActivator.getUIService().getExitOnMainWindowClose()) {
    try {
      GuiActivator.bundleContext.getBundle(0).stop();
    }
 catch (    BundleException ex) {
      logger.error(""String_Node_Str"",ex);
      System.exit(0);
    }
  }
}","protected void windowClosed(WindowEvent event){
  if (GuiActivator.getUIService().getExitOnMainWindowClose()) {
    try {
      GuiActivator.bundleContext.getBundle(0).stop();
    }
 catch (    BundleException ex) {
      logger.error(""String_Node_Str"",ex);
      System.exit(0);
    }
  }
}",0.9704347826086956
104302,"public void windowClosing(WindowEvent e){
  if (!GuiActivator.getUIService().getExitOnMainWindowClose()) {
    new Thread(){
      public void run(){
        if (ConfigurationManager.isQuitWarningShown()) {
          MessageDialog dialog=new MessageDialog(MainFrame.this,Messages.getI18NString(""String_Node_Str"").getText(),Messages.getI18NString(""String_Node_Str"").getText(),false);
          int returnCode=dialog.showDialog();
          if (returnCode == MessageDialog.OK_DONT_ASK_CODE) {
            ConfigurationManager.setQuitWarningShown(false);
          }
        }
      }
    }
.start();
    ConfigurationManager.setApplicationVisible(false);
  }
}","protected void windowClosing(WindowEvent event){
  if (!GuiActivator.getUIService().getExitOnMainWindowClose()) {
    SwingUtilities.invokeLater(new Runnable(){
      public void run(){
        if (ConfigurationManager.isQuitWarningShown()) {
          MessageDialog dialog=new MessageDialog(null,Messages.getI18NString(""String_Node_Str"").getText(),Messages.getI18NString(""String_Node_Str"").getText(),false);
          if (dialog.showDialog() == MessageDialog.OK_DONT_ASK_CODE)           ConfigurationManager.setQuitWarningShown(false);
        }
      }
    }
);
    ConfigurationManager.setApplicationVisible(false);
  }
}",0.7550702028081123
104303,"/** 
 * Writes the symbol corresponding to a choosen smiley icon to the write message area at the end of the current text.
 */
public void actionPerformed(ActionEvent e){
  JMenuItem smileyItem=(JMenuItem)e.getSource();
  String buttonText=smileyItem.getToolTipText();
  for (int i=0; i < this.imageList.size(); i++) {
    Smiley smiley=(Smiley)this.imageList.get(i);
    String smileyString=smiley.getSmileyStrings()[0];
    if (buttonText.equals(smileyString)) {
      chatWritePanel.appendText(smileyString);
      chatWritePanel.getEditorPane().requestFocus();
    }
  }
}","/** 
 * Writes the symbol corresponding to a choosen smiley icon to the write message area at the end of the current text.
 */
public void actionPerformed(ActionEvent e){
  JMenuItem smileyItem=(JMenuItem)e.getSource();
  String buttonText=smileyItem.getToolTipText();
  for (  Smiley smiley : imageList) {
    String smileyString=smiley.getSmileyStrings()[0];
    if (buttonText.equals(smileyString)) {
      chatWritePanel.appendText(smileyString);
      chatWritePanel.getEditorPane().requestFocus();
    }
  }
}",0.9110907424381302
104304,"/** 
 * In order to have a popup which is at the form closest to sqware.
 * @param itemsCount the count of items that will be laied out.
 */
private void calculateGridDimensions(int itemsCount){
  this.gridRowCount=(int)Math.round(Math.sqrt(itemsCount));
  this.gridColCount=(int)Math.round(itemsCount / gridRowCount);
}","/** 
 * In order to have a popup which is at the form closest to sqware.
 * @param itemsCount the count of items that will be laied out.
 */
private void calculateGridDimensions(int itemsCount){
  this.gridRowCount=(int)Math.round(Math.sqrt(itemsCount));
  this.gridColCount=(int)Math.ceil(itemsCount / gridRowCount);
}",0.9859154929577464
104305,"/** 
 * Creates an instance of this <tt>SmiliesSelectorBox</tt> and initializes the panel with the smiley icons given by the incoming imageList.
 * @param imageList The pack of smiley icons.
 */
public SmiliesSelectorBox(ArrayList imageList,ChatWritePanel writePanel){
  this.imageList=imageList;
  this.chatWritePanel=writePanel;
  this.selectorBox.setUI(new SIPCommChatSelectorMenuUI());
  this.setOpaque(false);
  this.selectorBox.setOpaque(false);
  this.setPreferredSize(new Dimension(BUTTON_WIDTH,BUTTON_HEIGHT));
  this.selectorBox.setBorder(BorderFactory.createEmptyBorder(0,0,0,0));
  this.selectorBox.setIcon(new ImageIcon(ImageLoader.getImage(ImageLoader.SMILIES_ICON)));
  this.calculateGridDimensions(imageList.size());
  this.selectorBox.getPopupMenu().setLayout(new GridLayout(this.gridRowCount,this.gridColCount,5,5));
  for (int i=0; i < imageList.size(); i++) {
    Smiley smiley=(Smiley)this.imageList.get(i);
    ImageIcon imageIcon=new ImageIcon(ImageLoader.getImage(smiley.getImageID()));
    JMenuItem smileyItem=new JMenuItem(imageIcon);
    smileyItem.setToolTipText(smiley.getSmileyStrings()[0]);
    smileyItem.addActionListener(this);
    this.selectorBox.add(smileyItem);
  }
  this.add(selectorBox);
}","/** 
 * Creates an instance of this <tt>SmiliesSelectorBox</tt> and initializes the panel with the smiley icons given by the incoming imageList.
 * @param imageList The pack of smiley icons.
 */
public SmiliesSelectorBox(ArrayList<Smiley> imageList,ChatWritePanel writePanel){
  this.imageList=imageList;
  this.chatWritePanel=writePanel;
  this.selectorBox.setUI(new SIPCommChatSelectorMenuUI());
  this.setOpaque(false);
  this.selectorBox.setOpaque(false);
  this.setPreferredSize(new Dimension(BUTTON_WIDTH,BUTTON_HEIGHT));
  this.selectorBox.setBorder(BorderFactory.createEmptyBorder(0,0,0,0));
  this.selectorBox.setIcon(new ImageIcon(ImageLoader.getImage(ImageLoader.SMILIES_ICON)));
  this.calculateGridDimensions(imageList.size());
  this.selectorBox.getPopupMenu().setLayout(new GridLayout(this.gridRowCount,this.gridColCount,5,5));
  for (  Smiley smiley : imageList) {
    ImageIcon imageIcon=new ImageIcon(ImageLoader.getImage(smiley.getImageID()));
    JMenuItem smileyItem=new JMenuItem(imageIcon);
    smileyItem.setToolTipText(smiley.getSmileyStrings()[0]);
    smileyItem.addActionListener(this);
    this.selectorBox.add(smileyItem);
  }
  this.add(selectorBox);
}",0.9511184755592378
104306,"/** 
 * Overrides the <code>paintComponent</code> method of <tt>JButton</tt> to paint the button background and icon, and all additional effects of this configururable button.
 * @param g The Graphics object.
 */
public void paintComponent(Graphics g){
  AntialiasingManager.activateAntialiasing(g);
  if (this.bgImage != null) {
    if (this.iconImage == null && !isEnabled()) {
      Image disabledImage=new ImageIcon(LightGrayFilter.createDisabledImage(bgImage)).getImage();
      g.drawImage(disabledImage,0,0,this);
    }
 else {
      g.drawImage(this.bgImage,0,0,this);
    }
  }
  if (this.iconImage != null) {
    if (!isEnabled()) {
      Image disabledImage=new ImageIcon(LightGrayFilter.createDisabledImage(iconImage)).getImage();
      if (this.iconLayout.equals(SIPCommButton.CENTER_ICON_LAYOUT)) {
        g.drawImage(disabledImage,(this.bgImage.getWidth(null) - disabledImage.getWidth(null)) / 2,(this.bgImage.getHeight(null) - disabledImage.getHeight(null)) / 2,this);
      }
 else       if (this.iconLayout.equals(SIPCommButton.LEFT_ICON_LAYOUT)) {
        g.drawImage(disabledImage,7,(this.bgImage.getHeight(null) - disabledImage.getHeight(null)) / 2,this);
      }
 else       if (this.iconLayout.equals(SIPCommButton.LEFT_ICON_LAYOUT)) {
        g.drawImage(disabledImage,this.bgImage.getWidth(null) - 3,(this.bgImage.getHeight(null) - disabledImage.getHeight(null)) / 2,this);
      }
    }
 else {
      if (this.iconLayout.equals(SIPCommButton.CENTER_ICON_LAYOUT)) {
        g.drawImage(this.iconImage,(this.bgImage.getWidth(null) - this.iconImage.getWidth(null)) / 2,(this.bgImage.getHeight(null) - this.iconImage.getHeight(null)) / 2,this);
      }
 else       if (this.iconLayout.equals(SIPCommButton.LEFT_ICON_LAYOUT)) {
        g.drawImage(this.iconImage,7,(this.bgImage.getHeight(null) - this.iconImage.getHeight(null)) / 2,this);
      }
 else       if (this.iconLayout.equals(SIPCommButton.LEFT_ICON_LAYOUT)) {
        g.drawImage(this.iconImage,this.bgImage.getWidth(null) - 3,(this.bgImage.getHeight(null) - this.iconImage.getHeight(null)) / 2,this);
      }
    }
  }
  if (this.bgRolloverImage != null && this.getModel().isRollover()) {
    g.drawImage(this.bgRolloverImage,0,0,this);
    if (this.iconImage != null) {
      if (this.iconLayout.equals(SIPCommButton.CENTER_ICON_LAYOUT)) {
        g.drawImage(this.iconImage,(this.bgImage.getWidth(null) - this.iconImage.getWidth(null)) / 2,(this.bgImage.getHeight(null) - this.iconImage.getHeight(null)) / 2,this);
      }
 else       if (this.iconLayout.equals(SIPCommButton.LEFT_ICON_LAYOUT)) {
        g.drawImage(this.iconImage,7,(this.bgImage.getHeight(null) - this.iconImage.getHeight(null)) / 2,this);
      }
 else       if (this.iconLayout.equals(SIPCommButton.LEFT_ICON_LAYOUT)) {
        g.drawImage(this.iconImage,this.bgImage.getWidth(null) - 3,(this.bgImage.getHeight(null) - this.iconImage.getHeight(null)) / 2,this);
      }
    }
  }
  if (this.getModel().isPressed()) {
    if (this.pressedImage != null) {
      g.drawImage(this.pressedImage,0,0,this);
    }
 else {
      g.drawImage(this.bgRolloverImage,0,0,this);
      if (this.iconImage != null) {
        if (this.iconLayout.equals(SIPCommButton.CENTER_ICON_LAYOUT)) {
          g.drawImage(this.iconImage,(this.bgImage.getWidth(null) - this.iconImage.getWidth(null)) / 2 + 1,(this.bgImage.getHeight(null) - this.iconImage.getHeight(null)) / 2 + 1,this);
        }
 else         if (this.iconLayout.equals(SIPCommButton.LEFT_ICON_LAYOUT)) {
          g.drawImage(this.iconImage,7 + 1,(this.bgImage.getHeight(null) - this.iconImage.getHeight(null)) / 2 + 1,this);
        }
 else         if (this.iconLayout.equals(SIPCommButton.LEFT_ICON_LAYOUT)) {
          g.drawImage(this.iconImage,this.bgImage.getWidth(null) - 3 + 1,(this.bgImage.getHeight(null) - this.iconImage.getHeight(null)) / 2 + 1,this);
        }
      }
    }
  }
}","/** 
 * Overrides the <code>paintComponent</code> method of <tt>JButton</tt> to paint the button background and icon, and all additional effects of this configururable button.
 * @param g The Graphics object.
 */
public void paintComponent(Graphics g){
  AntialiasingManager.activateAntialiasing(g);
  if (isOpaque()) {
    g.setColor(getBackground());
    g.fillRect(0,0,getWidth(),getHeight());
  }
  if (this.bgImage != null) {
    if (this.iconImage == null && !isEnabled()) {
      Image disabledImage=new ImageIcon(LightGrayFilter.createDisabledImage(bgImage)).getImage();
      g.drawImage(disabledImage,0,0,this);
    }
 else {
      g.drawImage(this.bgImage,0,0,this);
    }
  }
  if (this.iconImage != null) {
    if (!isEnabled()) {
      Image disabledImage=new ImageIcon(LightGrayFilter.createDisabledImage(iconImage)).getImage();
      if (this.iconLayout.equals(SIPCommButton.CENTER_ICON_LAYOUT)) {
        g.drawImage(disabledImage,(this.bgImage.getWidth(null) - disabledImage.getWidth(null)) / 2,(this.bgImage.getHeight(null) - disabledImage.getHeight(null)) / 2,this);
      }
 else       if (this.iconLayout.equals(SIPCommButton.LEFT_ICON_LAYOUT)) {
        g.drawImage(disabledImage,7,(this.bgImage.getHeight(null) - disabledImage.getHeight(null)) / 2,this);
      }
 else       if (this.iconLayout.equals(SIPCommButton.LEFT_ICON_LAYOUT)) {
        g.drawImage(disabledImage,this.bgImage.getWidth(null) - 3,(this.bgImage.getHeight(null) - disabledImage.getHeight(null)) / 2,this);
      }
    }
 else {
      if (this.iconLayout.equals(SIPCommButton.CENTER_ICON_LAYOUT)) {
        g.drawImage(this.iconImage,(this.bgImage.getWidth(null) - this.iconImage.getWidth(null)) / 2,(this.bgImage.getHeight(null) - this.iconImage.getHeight(null)) / 2,this);
      }
 else       if (this.iconLayout.equals(SIPCommButton.LEFT_ICON_LAYOUT)) {
        g.drawImage(this.iconImage,7,(this.bgImage.getHeight(null) - this.iconImage.getHeight(null)) / 2,this);
      }
 else       if (this.iconLayout.equals(SIPCommButton.LEFT_ICON_LAYOUT)) {
        g.drawImage(this.iconImage,this.bgImage.getWidth(null) - 3,(this.bgImage.getHeight(null) - this.iconImage.getHeight(null)) / 2,this);
      }
    }
  }
  if (this.bgRolloverImage != null && this.getModel().isRollover()) {
    g.drawImage(this.bgRolloverImage,0,0,this);
    if (this.iconImage != null) {
      if (this.iconLayout.equals(SIPCommButton.CENTER_ICON_LAYOUT)) {
        g.drawImage(this.iconImage,(this.bgImage.getWidth(null) - this.iconImage.getWidth(null)) / 2,(this.bgImage.getHeight(null) - this.iconImage.getHeight(null)) / 2,this);
      }
 else       if (this.iconLayout.equals(SIPCommButton.LEFT_ICON_LAYOUT)) {
        g.drawImage(this.iconImage,7,(this.bgImage.getHeight(null) - this.iconImage.getHeight(null)) / 2,this);
      }
 else       if (this.iconLayout.equals(SIPCommButton.LEFT_ICON_LAYOUT)) {
        g.drawImage(this.iconImage,this.bgImage.getWidth(null) - 3,(this.bgImage.getHeight(null) - this.iconImage.getHeight(null)) / 2,this);
      }
    }
  }
  if (this.getModel().isPressed()) {
    if (this.pressedImage != null) {
      g.drawImage(this.pressedImage,0,0,this);
    }
 else {
      g.drawImage(this.bgRolloverImage,0,0,this);
      if (this.iconImage != null) {
        if (this.iconLayout.equals(SIPCommButton.CENTER_ICON_LAYOUT)) {
          g.drawImage(this.iconImage,(this.bgImage.getWidth(null) - this.iconImage.getWidth(null)) / 2 + 1,(this.bgImage.getHeight(null) - this.iconImage.getHeight(null)) / 2 + 1,this);
        }
 else         if (this.iconLayout.equals(SIPCommButton.LEFT_ICON_LAYOUT)) {
          g.drawImage(this.iconImage,7 + 1,(this.bgImage.getHeight(null) - this.iconImage.getHeight(null)) / 2 + 1,this);
        }
 else         if (this.iconLayout.equals(SIPCommButton.LEFT_ICON_LAYOUT)) {
          g.drawImage(this.iconImage,this.bgImage.getWidth(null) - 3 + 1,(this.bgImage.getHeight(null) - this.iconImage.getHeight(null)) / 2 + 1,this);
        }
      }
    }
  }
}",0.9871908687381103
104307,"/** 
 * Initializes the RTP manager so that it would start listening on the <tt>address</tt> session address. The method also initializes the RTP manager buffer control.
 * @param rtpManager the <tt>RTPManager</tt> to initialize.
 * @param bindAddress the <tt>SessionAddress</tt> to use when initializing theRTPManager.
 * @throws MediaException if we fail to initialize the RTP manager.
 */
private void initializeRtpManager(RTPManager rtpManager,SessionAddress bindAddress) throws MediaException {
  selectedKeyProviderAlgorithm=selectKeyProviderAlgorithm(0);
  try {
    if (selectedKeyProviderAlgorithm != null && selectedKeyProviderAlgorithm.getProviderType() == KeyProviderAlgorithm.ProviderType.ZRTP_PROVIDER && rtpManager.equals(audioRtpManager)) {
      TransformConnector transConnector=null;
      TransformManager.initializeProviders();
      transConnector=TransformManager.createZRTPConnector(bindAddress,""String_Node_Str"",this);
      rtpManager.initialize(transConnector);
      this.transConnectors.put(rtpManager,transConnector);
      ZRTPTransformEngine engine=(ZRTPTransformEngine)transConnector.getEngine();
      if (usingSRTP) {
        if (!engine.initialize(""String_Node_Str""))         engine.sendInfo(ZrtpCodes.MessageSeverity.Info,EnumSet.of(ZRTPCustomInfoCodes.ZRTPEngineInitFailure));
      }
 else {
        engine.sendInfo(ZrtpCodes.MessageSeverity.Info,EnumSet.of(ZRTPCustomInfoCodes.ZRTPNotEnabledByUser));
      }
      logger.trace(""String_Node_Str"" + (rtpManager.equals(audioRtpManager) ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
    }
 else     if (selectedKeyProviderAlgorithm != null && selectedKeyProviderAlgorithm.getProviderType() == KeyProviderAlgorithm.ProviderType.DUMMY_PROVIDER && rtpManager.equals(audioRtpManager)) {
      SRTPPolicy srtpPolicy=new SRTPPolicy(SRTPPolicy.AESF8_ENCRYPTION,16,SRTPPolicy.HMACSHA1_AUTHENTICATION,20,10,14);
      byte[] masterKey={0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f};
      byte[] masterSalt={0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d};
      TransformConnector transConnector=null;
      TransformManager.initializeProviders();
      transConnector=TransformManager.createSRTPConnector(bindAddress,masterKey,masterSalt,srtpPolicy,srtpPolicy,""String_Node_Str"");
      rtpManager.initialize(transConnector);
      this.transConnectors.put(rtpManager,transConnector);
      logger.trace(""String_Node_Str"" + (rtpManager.equals(audioRtpManager) ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
    }
 else {
      rtpManager.initialize(bindAddress);
      logger.trace(""String_Node_Str"" + (rtpManager.equals(audioRtpManager) ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
    }
  }
 catch (  Exception exc) {
    logger.error(""String_Node_Str"",exc);
    throw new MediaException(""String_Node_Str"",MediaException.IO_ERROR,exc);
  }
  BufferControl bc=(BufferControl)rtpManager.getControl(BufferControl.class.getName());
  if (bc != null) {
    long buff=100;
    String buffStr=MediaActivator.getConfigurationService().getString(PROPERTY_NAME_RECEIVE_BUFFER_LENGTH);
    try {
      if (buffStr != null && buffStr.length() > 0)       buff=Long.parseLong(buffStr);
    }
 catch (    NumberFormatException exc) {
      logger.warn(buffStr + ""String_Node_Str"",exc);
    }
    buff=bc.setBufferLength(buff);
    logger.trace(""String_Node_Str"" + buff);
    bc.setEnabledThreshold(true);
    bc.setMinimumThreshold(100);
  }
  rtpManager.addReceiveStreamListener(this);
  rtpManager.addSendStreamListener(this);
  rtpManager.addSessionListener(this);
}","/** 
 * Initializes the RTP manager so that it would start listening on the <tt>address</tt> session address. The method also initializes the RTP manager buffer control.
 * @param rtpManager the <tt>RTPManager</tt> to initialize.
 * @param bindAddress the <tt>SessionAddress</tt> to use when initializing theRTPManager.
 * @throws MediaException if we fail to initialize the RTP manager.
 */
private void initializeRtpManager(RTPManager rtpManager,SessionAddress bindAddress) throws MediaException {
  selectedKeyProviderAlgorithm=selectKeyProviderAlgorithm(0);
  try {
    if (selectedKeyProviderAlgorithm != null && selectedKeyProviderAlgorithm.getProviderType() == KeyProviderAlgorithm.ProviderType.ZRTP_PROVIDER && rtpManager.equals(audioRtpManager)) {
      TransformConnector transConnector=null;
      TransformManager.initializeProviders();
      transConnector=TransformManager.createZRTPConnector(bindAddress,""String_Node_Str"");
      rtpManager.initialize(transConnector);
      this.transConnectors.put(rtpManager,transConnector);
      ZRTPTransformEngine engine=(ZRTPTransformEngine)transConnector.getEngine();
      if (usingSRTP) {
        if (!engine.initialize(""String_Node_Str""))         engine.sendInfo(ZrtpCodes.MessageSeverity.Info,EnumSet.of(ZRTPCustomInfoCodes.ZRTPEngineInitFailure));
      }
 else {
        engine.sendInfo(ZrtpCodes.MessageSeverity.Info,EnumSet.of(ZRTPCustomInfoCodes.ZRTPNotEnabledByUser));
      }
      logger.trace(""String_Node_Str"" + (rtpManager.equals(audioRtpManager) ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
    }
 else     if (selectedKeyProviderAlgorithm != null && selectedKeyProviderAlgorithm.getProviderType() == KeyProviderAlgorithm.ProviderType.DUMMY_PROVIDER && rtpManager.equals(audioRtpManager)) {
      SRTPPolicy srtpPolicy=new SRTPPolicy(SRTPPolicy.AESF8_ENCRYPTION,16,SRTPPolicy.HMACSHA1_AUTHENTICATION,20,10,14);
      byte[] masterKey={0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f};
      byte[] masterSalt={0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d};
      TransformConnector transConnector=null;
      TransformManager.initializeProviders();
      transConnector=TransformManager.createSRTPConnector(bindAddress,masterKey,masterSalt,srtpPolicy,srtpPolicy,""String_Node_Str"");
      rtpManager.initialize(transConnector);
      this.transConnectors.put(rtpManager,transConnector);
      logger.trace(""String_Node_Str"" + (rtpManager.equals(audioRtpManager) ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
    }
 else {
      rtpManager.initialize(bindAddress);
      logger.trace(""String_Node_Str"" + (rtpManager.equals(audioRtpManager) ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
    }
  }
 catch (  Exception exc) {
    logger.error(""String_Node_Str"",exc);
    throw new MediaException(""String_Node_Str"",MediaException.IO_ERROR,exc);
  }
  BufferControl bc=(BufferControl)rtpManager.getControl(BufferControl.class.getName());
  if (bc != null) {
    long buff=100;
    String buffStr=MediaActivator.getConfigurationService().getString(PROPERTY_NAME_RECEIVE_BUFFER_LENGTH);
    try {
      if (buffStr != null && buffStr.length() > 0)       buff=Long.parseLong(buffStr);
    }
 catch (    NumberFormatException exc) {
      logger.warn(buffStr + ""String_Node_Str"",exc);
    }
    buff=bc.setBufferLength(buff);
    logger.trace(""String_Node_Str"" + buff);
    bc.setEnabledThreshold(true);
    bc.setMinimumThreshold(100);
  }
  rtpManager.addReceiveStreamListener(this);
  rtpManager.addSendStreamListener(this);
  rtpManager.addSessionListener(this);
}",0.9993134697240148
104308,"/** 
 * The class constructor. Gets a reference to the ZRTP GUI plugin and initializes the  ZRTP GUI component members.
 */
public SCCallback(CallSession callSession){
  BundleContext bc=MediaActivator.getBundleContext();
  ServiceReference uiServiceRef=bc.getServiceReference(UIService.class.getName());
  uiService=(UIService)bc.getService(uiServiceRef);
  popupDialog=uiService.getPopupDialog();
  ServiceReference[] serRefs=null;
  this.callSession=callSession;
  String osgiFilter=""String_Node_Str"" + Container.CONTAINER_ID + ""String_Node_Str""+ Container.CONTAINER_MAIN_TOOL_BAR.getID()+ ""String_Node_Str"";
  zrtpButton=(JButton)callSession.getCall().getSecureGUIComponent(""String_Node_Str"");
  zrtpLabel=(JLabel)callSession.getCall().getSecureGUIComponent(""String_Node_Str"");
}","/** 
 * The class constructor. Gets a reference to the ZRTP GUI plugin and initializes the  ZRTP GUI component members.
 */
public SCCallback(){
  BundleContext bc=MediaActivator.getBundleContext();
  ServiceReference uiServiceRef=bc.getServiceReference(UIService.class.getName());
  uiService=(UIService)bc.getService(uiServiceRef);
  popupDialog=uiService.getPopupDialog();
  ServiceReference[] serRefs=null;
  String osgiFilter=""String_Node_Str"" + Container.CONTAINER_ID + ""String_Node_Str""+ Container.CONTAINER_MAIN_TOOL_BAR.getID()+ ""String_Node_Str"";
  try {
    serRefs=bc.getServiceReferences(PluginComponent.class.getName(),osgiFilter);
  }
 catch (  InvalidSyntaxException exc) {
    exc.printStackTrace();
  }
  if (serRefs != null) {
    for (int i=0; i < serRefs.length; i++) {
      PluginComponent component=(PluginComponent)bc.getService(serRefs[i]);
      if (component.getName().equals(""String_Node_Str"")) {
        zrtpPanel=(JPanel)component.getComponent();
        for (int j=0; j < zrtpPanel.getComponentCount(); j++) {
          Component subComponent=zrtpPanel.getComponent(j);
          if (subComponent.getName().equals(""String_Node_Str"")) {
            zrtpButton=(JButton)subComponent;
          }
 else           if (subComponent.getName().equals(""String_Node_Str"")) {
            zrtpLabel=(JLabel)subComponent;
          }
        }
      }
    }
  }
}",0.5715604801477377
104309,"public void actionPerformed(ActionEvent evt){
  Call call=callParticipant.getCall();
  if (call != null) {
    String command=evt.getActionCommand();
    if (command.equals(""String_Node_Str"")) {
      OperationSetBasicTelephony telephony=(OperationSetBasicTelephony)call.getProtocolProvider().getOperationSet(OperationSetBasicTelephony.class);
      if (telephony.getSecured(callParticipant)) {
        updateSecureButton(false);
        telephony.setSecured(callParticipant,false,OperationSetBasicTelephony.SecureStatusChangeSource.SECURE_STATUS_CHANGE_BY_LOCAL);
      }
 else {
        updateSecureButton(true);
        telephony.setSecured(callParticipant,true,OperationSetBasicTelephony.SecureStatusChangeSource.SECURE_STATUS_CHANGE_BY_LOCAL);
      }
    }
  }
}","public void actionPerformed(ActionEvent evt){
  Call call=callParticipant.getCall();
  if (call != null) {
    String command=evt.getActionCommand();
    if (command.equals(""String_Node_Str"")) {
      OperationSetBasicTelephony telephony=(OperationSetBasicTelephony)call.getProtocolProvider().getOperationSet(OperationSetBasicTelephony.class);
      if (telephony.isSecured(callParticipant)) {
        updateSecureButton(false);
        telephony.setSecured(callParticipant,false,OperationSetBasicTelephony.SecureStatusChangeSource.SECURE_STATUS_CHANGE_BY_LOCAL);
      }
 else {
        updateSecureButton(true);
        telephony.setSecured(callParticipant,true,OperationSetBasicTelephony.SecureStatusChangeSource.SECURE_STATUS_CHANGE_BY_LOCAL);
      }
    }
  }
}",0.996742671009772
104310,"public void setSecured(CallParticipant participant,boolean secured,OperationSetBasicTelephony.SecureStatusChangeSource source){
}","@Override public void setSecured(CallParticipant participant,boolean secured,OperationSetBasicTelephony.SecureStatusChangeSource source){
}",0.9626865671641792
104311,"public void actionPerformed(ActionEvent evt){
  JButton button=(JButton)evt.getSource();
  String buttonName=button.getName();
  if (buttonName.equals(HANGUP_BUTTON)) {
    Call call=callPanel.getCall();
    CallManager.hangupCall(call);
    this.dispose();
  }
 else   if (buttonName.equals(DIAL_BUTTON)) {
    if (dialpadDialog == null) {
      Call call=callPanel.getCall();
      if (call != null) {
        dialpadDialog=new DialpadDialog(callPanel.getCall().getCallParticipants());
      }
 else {
        dialpadDialog=new DialpadDialog(new Vector().iterator());
      }
    }
    if (!dialpadDialog.isVisible()) {
      dialpadDialog.setSize(this.getWidth() - 20,dialpadDialog.getHeight());
      dialpadDialog.setLocation(this.getX() + 10,getLocationOnScreen().y + getHeight());
      dialpadDialog.setVisible(true);
    }
 else {
      dialpadDialog.setVisible(false);
    }
  }
}","public void actionPerformed(ActionEvent evt){
  JButton button=(JButton)evt.getSource();
  String buttonName=button.getName();
  if (buttonName.equals(HANGUP_BUTTON)) {
    Call call=callPanel.getCall();
    CallManager.hangupCall(call);
    this.dispose();
  }
 else   if (buttonName.equals(DIAL_BUTTON)) {
    if (dialpadDialog == null) {
      Call call=callPanel.getCall();
      if (call != null) {
        dialpadDialog=new DialpadDialog(callPanel.getCall().getCallParticipants());
      }
 else {
        dialpadDialog=new DialpadDialog(new Vector().iterator());
      }
    }
    if (!dialpadDialog.isVisible()) {
      dialpadDialog.setSize(this.getWidth() - 20,dialpadDialog.getHeight());
      dialpadDialog.setLocation(this.getX() + 10,getLocationOnScreen().y + getHeight());
      dialpadDialog.setVisible(true);
      dialpadDialog.requestFocus();
    }
 else {
      dialpadDialog.setVisible(false);
    }
  }
}",0.9801762114537445
104312,"public void focusLost(FocusEvent e){
  this.dispose();
}","public void focusLost(FocusEvent e){
  this.setVisible(false);
}",0.8666666666666667
104313,"/** 
 * Handles the <tt>ActionEvent</tt> generated when user presses one of the buttons in this panel.
 */
public void actionPerformed(ActionEvent evt){
  JButton button=(JButton)evt.getSource();
  String buttonName=button.getName();
  if (buttonName.equals(CALL_BUTTON)) {
    if (isCallMetaContact) {
      Object[] selectedContacts=mainFrame.getContactListPanel().getContactList().getSelectedValues();
      Vector telephonyContacts=new Vector();
      for (int i=0; i < selectedContacts.length; i++) {
        Object o=selectedContacts[i];
        if (o instanceof MetaContact) {
          Contact contact=((MetaContact)o).getDefaultContact(OperationSetBasicTelephony.class);
          if (contact != null)           telephonyContacts.add(contact);
 else {
            new ErrorDialog(this.mainFrame,Messages.getI18NString(""String_Node_Str"").getText(),Messages.getI18NString(""String_Node_Str"",new String[]{((MetaContact)o).getDisplayName()}).getText()).showDialog();
          }
        }
      }
      if (telephonyContacts.size() > 0)       CallManager.createCall(protocolProvider,telephonyContacts);
    }
 else     if (!phoneNumberCombo.isComboFieldEmpty()) {
      String stringContact=phoneNumberCombo.getEditor().getItem().toString();
      CallManager.createCall(protocolProvider,stringContact);
    }
  }
 else   if (buttonName.equals(DIAL_BUTTON)) {
    if (!dialpadDialog.isVisible()) {
      dialpadDialog.setSize(mainFrame.getWidth() - 20,dialpadDialog.getHeight());
      dialpadDialog.setLocation(mainFrame.getX() + 10,dialButton.getLocationOnScreen().y - dialpadDialog.getHeight());
      dialpadDialog.setVisible(true);
    }
 else {
      dialpadDialog.setVisible(false);
    }
  }
}","/** 
 * Handles the <tt>ActionEvent</tt> generated when user presses one of the buttons in this panel.
 */
public void actionPerformed(ActionEvent evt){
  JButton button=(JButton)evt.getSource();
  String buttonName=button.getName();
  if (buttonName.equals(CALL_BUTTON)) {
    if (isCallMetaContact) {
      Object[] selectedContacts=mainFrame.getContactListPanel().getContactList().getSelectedValues();
      Vector telephonyContacts=new Vector();
      for (int i=0; i < selectedContacts.length; i++) {
        Object o=selectedContacts[i];
        if (o instanceof MetaContact) {
          Contact contact=((MetaContact)o).getDefaultContact(OperationSetBasicTelephony.class);
          if (contact != null)           telephonyContacts.add(contact);
 else {
            new ErrorDialog(this.mainFrame,Messages.getI18NString(""String_Node_Str"").getText(),Messages.getI18NString(""String_Node_Str"",new String[]{((MetaContact)o).getDisplayName()}).getText()).showDialog();
          }
        }
      }
      if (telephonyContacts.size() > 0)       CallManager.createCall(protocolProvider,telephonyContacts);
    }
 else     if (!phoneNumberCombo.isComboFieldEmpty()) {
      String stringContact=phoneNumberCombo.getEditor().getItem().toString();
      CallManager.createCall(protocolProvider,stringContact);
    }
  }
 else   if (buttonName.equals(DIAL_BUTTON)) {
    if (!dialpadDialog.isVisible()) {
      dialpadDialog.setSize(mainFrame.getWidth() - 20,dialpadDialog.getHeight());
      dialpadDialog.setLocation(mainFrame.getX() + 10,dialButton.getLocationOnScreen().y - dialpadDialog.getHeight());
      dialpadDialog.setVisible(true);
      dialpadDialog.requestFocus();
    }
 else {
      dialpadDialog.setVisible(false);
    }
  }
}",0.9895531050493326
104314,"public void handleStateChange(StateEvent event){
  State newState=event.getNewState();
  State oldState=event.getOldState();
  AimConnection conn=event.getAimConnection();
  logger.debug(""String_Node_Str"" + getProtocolName() + ""String_Node_Str""+ oldState+ ""String_Node_Str""+ newState);
  int reasonCode=RegistrationStateChangeEvent.REASON_NOT_SPECIFIED;
  String reasonStr=null;
  if (newState == State.ONLINE) {
    icbmService=conn.getIcbmService();
    icbmService.addIcbmListener(aimIcbmListener);
    conn.getInfoService().getOscarConnection().getSnacProcessor().getFlapProcessor().addPacketListener(new ConnectionClosedListener(conn));
  }
 else   if (newState == State.DISCONNECTED) {
    Service service=aimConnection.getBosService();
    if (service != null) {
      int discconectCode=service.getOscarConnection().getLastCloseCode();
      reasonCode=ConnectionClosedListener.convertCodeToRegistrationStateChangeEvent(discconectCode);
      reasonStr=ConnectionClosedListener.convertCodeToStringReason(discconectCode);
      logger.debug(""String_Node_Str"" + reasonStr);
    }
 else     logger.debug(""String_Node_Str"");
  }
 else   if (newState == State.FAILED) {
    logger.debug(""String_Node_Str"" + event.getNewStateInfo());
  }
  if (event.getNewStateInfo() instanceof LoginFailureStateInfo) {
    LoginFailureInfo loginFailure=((LoginFailureStateInfo)event.getNewStateInfo()).getLoginFailureInfo();
    if (loginFailure instanceof AuthFailureInfo) {
      AuthFailureInfo afi=(AuthFailureInfo)loginFailure;
      logger.debug(""String_Node_Str"" + afi.getErrorCode());
      int code=ConnectionClosedListener.convertAuthCodeToReasonCode(afi);
      reasonCode=ConnectionClosedListener.convertCodeToRegistrationStateChangeEvent(code);
      reasonStr=ConnectionClosedListener.convertCodeToStringReason(code);
    }
  }
  if (reasonCode == RegistrationStateChangeEvent.REASON_AUTHENTICATION_FAILED) {
    if (USING_ICQ)     IcqActivator.getIcqProtocolProviderFactory().storePassword(getAccountID(),null);
 else     IcqActivator.getAimProtocolProviderFactory().storePassword(getAccountID(),null);
    reconnect(SecurityAuthority.WRONG_PASSWORD);
  }
  fireRegistrationStateChanged(oldState,event.getOldStateInfo(),newState,event.getNewStateInfo(),reasonCode,reasonStr);
}","public void handleStateChange(StateEvent event){
  State newState=event.getNewState();
  State oldState=event.getOldState();
  AimConnection conn=event.getAimConnection();
  logger.debug(""String_Node_Str"" + getProtocolName() + ""String_Node_Str""+ oldState+ ""String_Node_Str""+ newState);
  int reasonCode=RegistrationStateChangeEvent.REASON_NOT_SPECIFIED;
  String reasonStr=null;
  if (newState == State.ONLINE) {
    icbmService=conn.getIcbmService();
    icbmService.addIcbmListener(aimIcbmListener);
    conn.getInfoService().getOscarConnection().getSnacProcessor().getFlapProcessor().addPacketListener(new ConnectionClosedListener(conn));
  }
 else   if (newState == State.DISCONNECTED) {
    Service service=aimConnection.getBosService();
    if (service != null) {
      int discconectCode=service.getOscarConnection().getLastCloseCode();
      reasonCode=ConnectionClosedListener.convertCodeToRegistrationStateChangeEvent(discconectCode);
      reasonStr=ConnectionClosedListener.convertCodeToStringReason(discconectCode);
      logger.debug(""String_Node_Str"" + reasonStr);
    }
 else     logger.debug(""String_Node_Str"");
  }
 else   if (newState == State.FAILED) {
    logger.debug(""String_Node_Str"" + event.getNewStateInfo());
  }
  if (event.getNewStateInfo() instanceof LoginFailureStateInfo) {
    LoginFailureInfo loginFailure=((LoginFailureStateInfo)event.getNewStateInfo()).getLoginFailureInfo();
    if (loginFailure instanceof AuthFailureInfo) {
      AuthFailureInfo afi=(AuthFailureInfo)loginFailure;
      logger.debug(""String_Node_Str"" + afi.getErrorCode());
      int code=ConnectionClosedListener.convertAuthCodeToReasonCode(afi);
      reasonCode=ConnectionClosedListener.convertCodeToRegistrationStateChangeEvent(code);
      reasonStr=ConnectionClosedListener.convertCodeToStringReason(code);
    }
  }
  if (reasonCode == RegistrationStateChangeEvent.REASON_AUTHENTICATION_FAILED) {
    if (USING_ICQ)     IcqActivator.getIcqProtocolProviderFactory().storePassword(getAccountID(),null);
 else     IcqActivator.getAimProtocolProviderFactory().storePassword(getAccountID(),null);
    reconnect(SecurityAuthority.WRONG_PASSWORD);
  }
  if (newState == State.ONLINE) {
    new RegisteredEventThread().start();
  }
 else {
    fireRegistrationStateChanged(oldState,event.getOldStateInfo(),newState,event.getNewStateInfo(),reasonCode,reasonStr);
  }
}",0.973124059342077
104315,"/** 
 * Adds the specified protocol specific contact to the list of contacts merged in this meta contact. The method also keeps up to date the contactsOnline field which is used in the compareTo() method.
 * @param contact the protocol specific Contact to add.
 */
void addProtoContact(Contact contact){
synchronized (parentGroupModLock) {
    if (parentGroup != null) {
      parentGroup.lightRemoveMetaContact(this);
    }
    contactsOnline+=contact.getPresenceStatus().isOnline() ? 1 : 0;
    this.protoContacts.add(contact);
    if (this.protoContacts.size() == 1 && (this.displayName == null || this.displayName.trim().length() == 0)) {
      this.displayName=new String(contact.getDisplayName().getBytes());
    }
    if (parentGroup != null) {
      parentGroup.lightAddMetaContact(this);
    }
  }
}","/** 
 * Adds the specified protocol specific contact to the list of contacts merged in this meta contact. The method also keeps up to date the contactsOnline field which is used in the compareTo() method.
 * @param contact the protocol specific Contact to add.
 */
void addProtoContact(Contact contact){
synchronized (parentGroupModLock) {
    if (parentGroup != null) {
      parentGroup.lightRemoveMetaContact(this);
    }
    contactsOnline+=contact.getPresenceStatus().isOnline() ? 1 : 0;
    this.protoContacts.add(contact);
    if (this.protoContacts.size() == 1 && (this.displayName == null || this.displayName.trim().length() == 0)) {
      this.displayName=contact.getDisplayName();
    }
    if (parentGroup != null) {
      parentGroup.lightAddMetaContact(this);
    }
  }
}",0.8851224105461394
104316,"private void sendInstantMessage(){
  Contact contact=(Contact)contactSelectorBox.getMenu().getSelectedObject();
  OperationSetBasicInstantMessaging im=(OperationSetBasicInstantMessaging)contact.getProtocolProvider().getOperationSet(OperationSetBasicInstantMessaging.class);
  OperationSetTypingNotifications tn=(OperationSetTypingNotifications)contact.getProtocolProvider().getOperationSet(OperationSetTypingNotifications.class);
  String htmlText=getTextFromWriteArea(""String_Node_Str"");
  String plainText=getTextFromWriteArea(OperationSetBasicInstantMessaging.DEFAULT_MIME_TYPE);
  Message msg;
  if (im.isContentTypeSupported(""String_Node_Str"") && (htmlText.indexOf(""String_Node_Str"") > -1 || htmlText.indexOf(""String_Node_Str"") > -1 || htmlText.indexOf(""String_Node_Str"") > -1 || htmlText.indexOf(""String_Node_Str"") > -1)) {
    msg=im.createMessage(htmlText.getBytes(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
 else {
    msg=im.createMessage(plainText);
  }
  this.refreshWriteArea();
  if (tn != null) {
    getChatWritePanel().stopTypingTimer();
  }
  try {
    im.sendInstantMessage(contact,msg);
  }
 catch (  IllegalStateException ex) {
    logger.error(""String_Node_Str"",ex);
    this.refreshWriteArea();
    this.processMessage(contact.getDisplayName(),new Date(System.currentTimeMillis()),Constants.OUTGOING_MESSAGE,msg.getContent(),msg.getContentType());
    this.processMessage(contact.getDisplayName(),new Date(System.currentTimeMillis()),Constants.ERROR_MESSAGE,Messages.getI18NString(""String_Node_Str"").getText(),""String_Node_Str"");
  }
catch (  Exception ex) {
    logger.error(""String_Node_Str"",ex);
    this.refreshWriteArea();
    this.processMessage(contact.getDisplayName(),new Date(System.currentTimeMillis()),Constants.OUTGOING_MESSAGE,msg.getContent(),msg.getContentType());
    this.processMessage(contact.getDisplayName(),new Date(System.currentTimeMillis()),Constants.ERROR_MESSAGE,Messages.getI18NString(""String_Node_Str"",new String[]{ex.getMessage()}).getText(),""String_Node_Str"");
  }
}","private void sendInstantMessage(){
  Contact contact=(Contact)contactSelectorBox.getMenu().getSelectedObject();
  OperationSetBasicInstantMessaging im=(OperationSetBasicInstantMessaging)contact.getProtocolProvider().getOperationSet(OperationSetBasicInstantMessaging.class);
  OperationSetTypingNotifications tn=(OperationSetTypingNotifications)contact.getProtocolProvider().getOperationSet(OperationSetTypingNotifications.class);
  String htmlText=getTextFromWriteArea(""String_Node_Str"");
  String plainText=getTextFromWriteArea(OperationSetBasicInstantMessaging.DEFAULT_MIME_TYPE);
  Message msg;
  if (im.isContentTypeSupported(""String_Node_Str"") && (htmlText.indexOf(""String_Node_Str"") > -1 || htmlText.indexOf(""String_Node_Str"") > -1 || htmlText.indexOf(""String_Node_Str"") > -1 || htmlText.indexOf(""String_Node_Str"") > -1)) {
    msg=im.createMessage(htmlText,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
 else {
    msg=im.createMessage(plainText);
  }
  this.refreshWriteArea();
  if (tn != null) {
    getChatWritePanel().stopTypingTimer();
  }
  try {
    im.sendInstantMessage(contact,msg);
  }
 catch (  IllegalStateException ex) {
    logger.error(""String_Node_Str"",ex);
    this.refreshWriteArea();
    this.processMessage(contact.getDisplayName(),new Date(System.currentTimeMillis()),Constants.OUTGOING_MESSAGE,msg.getContent(),msg.getContentType());
    this.processMessage(contact.getDisplayName(),new Date(System.currentTimeMillis()),Constants.ERROR_MESSAGE,Messages.getI18NString(""String_Node_Str"").getText(),""String_Node_Str"");
  }
catch (  Exception ex) {
    logger.error(""String_Node_Str"",ex);
    this.refreshWriteArea();
    this.processMessage(contact.getDisplayName(),new Date(System.currentTimeMillis()),Constants.OUTGOING_MESSAGE,msg.getContent(),msg.getContentType());
    this.processMessage(contact.getDisplayName(),new Date(System.currentTimeMillis()),Constants.ERROR_MESSAGE,Messages.getI18NString(""String_Node_Str"",new String[]{ex.getMessage()}).getText(),""String_Node_Str"");
  }
}",0.9972966330793808
104317,"/** 
 * Used to convert HistoryRecord in ChatRoomMessageDeliveredEvent or  ChatRoomMessageReceivedEvent which are returned by the finder methods
 * @param hr HistoryRecord
 * @param contact Contact
 * @return Object
 */
private Object convertHistoryRecordToMessageEvent(HistoryRecord hr,ChatRoom room){
  MessageImpl msg=new MessageImpl(hr);
  Date timestamp=null;
  if (msg.getMessageReceivedDate() != null) {
    if (msg.getMessageReceivedDate().after(hr.getTimestamp()) && (msg.getMessageReceivedDate().getTime() - hr.getTimestamp().getTime()) > 86400000)     timestamp=hr.getTimestamp();
 else     timestamp=msg.getMessageReceivedDate();
  }
 else   timestamp=hr.getTimestamp();
  String fromStr=hr.getPropertyValues()[5];
  ChatRoomMember from=new ChatRoomMemberImpl(fromStr,room,null);
  if (msg.isOutgoing) {
    return new ChatRoomMessageDeliveredEvent(room,timestamp,msg,ChatRoomMessageDeliveredEvent.CONVERSATION_MESSAGE_DELIVERED);
  }
 else   return new ChatRoomMessageReceivedEvent(room,from,timestamp,msg,ChatRoomMessageReceivedEvent.CONVERSATION_MESSAGE_RECEIVED);
}","/** 
 * Used to convert HistoryRecord in ChatRoomMessageDeliveredEvent or  ChatRoomMessageReceivedEvent which are returned by the finder methods
 * @param hr HistoryRecord
 * @param contact Contact
 * @return Object
 */
private Object convertHistoryRecordToMessageEvent(HistoryRecord hr,ChatRoom room){
  MessageImpl msg=createMessageFromHistoryRecord(hr);
  Date timestamp=null;
  if (msg.getMessageReceivedDate() != null) {
    if (msg.getMessageReceivedDate().after(hr.getTimestamp()) && (msg.getMessageReceivedDate().getTime() - hr.getTimestamp().getTime()) > 86400000)     timestamp=hr.getTimestamp();
 else     timestamp=msg.getMessageReceivedDate();
  }
 else   timestamp=hr.getTimestamp();
  String fromStr=hr.getPropertyValues()[5];
  ChatRoomMember from=new ChatRoomMemberImpl(fromStr,room,null);
  if (msg.isOutgoing) {
    return new ChatRoomMessageDeliveredEvent(room,timestamp,msg,ChatRoomMessageDeliveredEvent.CONVERSATION_MESSAGE_DELIVERED);
  }
 else   return new ChatRoomMessageReceivedEvent(room,from,timestamp,msg,ChatRoomMessageReceivedEvent.CONVERSATION_MESSAGE_RECEIVED);
}",0.979329352319706
104318,"MessageImpl(HistoryRecord hr){
  for (int i=0; i < hr.getPropertyNames().length; i++) {
    String propName=hr.getPropertyNames()[i];
    if (propName.equals(""String_Node_Str"") || propName.equals(STRUCTURE_NAMES[1]))     textContent=hr.getPropertyValues()[i];
 else     if (propName.equals(STRUCTURE_NAMES[2]))     contentType=hr.getPropertyValues()[i];
 else     if (propName.equals(STRUCTURE_NAMES[3]))     contentEncoding=hr.getPropertyValues()[i];
 else     if (propName.equals(STRUCTURE_NAMES[4]))     messageUID=hr.getPropertyValues()[i];
 else     if (propName.equals(STRUCTURE_NAMES[5]))     subject=hr.getPropertyValues()[i];
 else     if (propName.equals(STRUCTURE_NAMES[0])) {
      if (hr.getPropertyValues()[i].equals(""String_Node_Str""))       isOutgoing=false;
 else       if (hr.getPropertyValues()[i].equals(""String_Node_Str""))       isOutgoing=true;
    }
 else     if (propName.equals(STRUCTURE_NAMES[6])) {
      messageReceivedDate=new Date(Long.parseLong(hr.getPropertyValues()[i]));
    }
  }
}","MessageImpl(String content,String contentType,String encoding,String subject,String messageUID,boolean isOutgoing,Date messageReceivedDate){
  super(content,contentType,encoding,subject,messageUID);
  this.isOutgoing=isOutgoing;
  this.messageReceivedDate=messageReceivedDate;
}",0.0757341576506955
104319,"/** 
 * Creates a message instance according to the specified parameters.
 * @param content the message body
 * @param contentType message content type or null for text/plain
 * @param contentEncoding message encoding or null for UTF8
 * @param subject the subject of the message or null for no subject.
 */
public MessageDictImpl(String content,String contentType,String contentEncoding,String subject){
  this.textContent=content;
  this.contentType=contentType;
  this.contentEncoding=contentEncoding;
  this.subject=subject;
  this.messageUID=String.valueOf(System.currentTimeMillis()) + String.valueOf(hashCode());
}","/** 
 * Creates a message instance according to the specified parameters.
 * @param content the message body
 * @param contentType message content type or null for text/plain
 * @param contentEncoding message encoding or null for UTF8
 * @param subject the subject of the message or null for no subject.
 */
public MessageDictImpl(String content,String contentType,String contentEncoding,String subject){
  super(content,contentType,contentEncoding,subject);
}",0.8214616096207216
104320,"/** 
 * Prepares the meta contact list service for shutdown.
 * @param bc the currently active bundle context.
 */
public void stop(BundleContext bc){
  storageManager.storeContactListAndStopStorageManager();
  bc.removeServiceListener(this);
  Iterator providers=this.currentlyInstalledProviders.values().iterator();
  while (providers.hasNext()) {
    ProtocolProviderService pp=(ProtocolProviderService)providers.next();
    OperationSetPersistentPresence opSetPersPresence=(OperationSetPersistentPresence)pp.getOperationSet(OperationSetPersistentPresence.class);
    if (opSetPersPresence != null) {
      opSetPersPresence.removeSubscriptionListener(clSubscriptionEventHandler);
      opSetPersPresence.removeServerStoredGroupChangeListener(clGroupEventHandler);
    }
 else {
      OperationSetPresence opSetPresence=(OperationSetPresence)pp.getOperationSet(OperationSetPresence.class);
      if (opSetPresence != null) {
        opSetPersPresence.removeSubscriptionListener(clSubscriptionEventHandler);
      }
    }
  }
  currentlyInstalledProviders.clear();
  if (storageManager != null) {
    storageManager.stop();
  }
}","/** 
 * Prepares the meta contact list service for shutdown.
 * @param bc the currently active bundle context.
 */
public void stop(BundleContext bc){
  storageManager.storeContactListAndStopStorageManager();
  bc.removeServiceListener(this);
  Iterator providers=this.currentlyInstalledProviders.values().iterator();
  while (providers.hasNext()) {
    ProtocolProviderService pp=(ProtocolProviderService)providers.next();
    OperationSetPersistentPresence opSetPersPresence=(OperationSetPersistentPresence)pp.getOperationSet(OperationSetPersistentPresence.class);
    if (opSetPersPresence != null) {
      opSetPersPresence.removeSubscriptionListener(clSubscriptionEventHandler);
      opSetPersPresence.removeServerStoredGroupChangeListener(clGroupEventHandler);
    }
 else {
      OperationSetPresence opSetPresence=(OperationSetPresence)pp.getOperationSet(OperationSetPresence.class);
      if (opSetPresence != null) {
        opSetPresence.removeSubscriptionListener(clSubscriptionEventHandler);
      }
    }
  }
  currentlyInstalledProviders.clear();
  if (storageManager != null) {
    storageManager.stop();
  }
}",0.9982285208148804
104321,"/** 
 * This method returns a file specific to the current user. It may not exist, but it is guaranteed that you will have the sufficient rights to create it. This file should not be considered secure because the implementor may return a file accesible to everyone. Generaly it will reside in current user's homedir, but it may as well reside in a shared directory. Note: DO NOT store unencrypted sensitive information in this file
 * @param fileName The name of the private file you wish to access
 * @return The file
 * @throws Exception if we faile to create the file.
 */
public File getPrivatePersistentFile(String fileName) throws Exception {
  File file=null;
  try {
    logger.logEntry();
    String fullPath=getFullPath(fileName);
    file=this.accessibleFile(fullPath,fileName);
    if (file == null) {
      throw new SecurityException(""String_Node_Str"" + ""String_Node_Str"" + file.getAbsolutePath());
    }
  }
  finally {
    logger.logExit();
  }
  return file;
}","/** 
 * This method returns a file specific to the current user. It may not exist, but it is guaranteed that you will have the sufficient rights to create it. This file should not be considered secure because the implementor may return a file accesible to everyone. Generaly it will reside in current user's homedir, but it may as well reside in a shared directory. Note: DO NOT store unencrypted sensitive information in this file
 * @param fileName The name of the private file you wish to access
 * @return The file
 * @throws Exception if we faile to create the file.
 */
public File getPrivatePersistentFile(String fileName) throws Exception {
  File file=null;
  try {
    logger.logEntry();
    String fullPath=getFullPath(fileName);
    file=this.accessibleFile(fullPath,fileName);
    if (file == null) {
      throw new SecurityException(""String_Node_Str"" + ""String_Node_Str"" + new File(fullPath,fileName).getPath());
    }
  }
  finally {
    logger.logExit();
  }
  return file;
}",0.9801929913661758
104322,"/** 
 * Creates an IcqContactImpl
 * @param buddy the JoustSIM object that we will be encapsulating.
 * @param ssclCallback a reference to the ServerStoredContactListIcqImplinstance that created us.
 * @param isPersistent determines whether this contact is persistent or not.
 * @param isResolved specifies whether the contact has been resolved againstthe server contact list
 */
ContactIcqImpl(Buddy buddy,ServerStoredContactListIcqImpl ssclCallback,boolean isPersistent,boolean isResolved){
  this.joustSimBuddy=buddy;
  this.isLocal=isLocal;
  this.ssclCallback=ssclCallback;
  this.isPersistent=isPersistent;
  this.isResolved=isResolved;
}","/** 
 * Creates an IcqContactImpl
 * @param buddy the JoustSIM object that we will be encapsulating.
 * @param ssclCallback a reference to the ServerStoredContactListIcqImplinstance that created us.
 * @param isPersistent determines whether this contact is persistent or not.
 * @param isResolved specifies whether the contact has been resolved againstthe server contact list
 */
ContactIcqImpl(Buddy buddy,ServerStoredContactListIcqImpl ssclCallback,boolean isPersistent,boolean isResolved){
  this.joustSimBuddy=buddy;
  this.ssclCallback=ssclCallback;
  this.isPersistent=isPersistent;
  this.isResolved=isResolved;
}",0.981012658227848
104323,"ContactJabberImpl(String id,ServerStoredContactListJabberImpl ssclCallback,boolean isPersistent){
  this.tempId=id;
  this.isLocal=isLocal;
  this.ssclCallback=ssclCallback;
  this.isPersistent=isPersistent;
  this.isResolved=false;
  this.status=((ProtocolProviderServiceJabberImpl)getProtocolProvider()).getJabberStatusEnum().getStatus(JabberStatusEnum.OFFLINE);
}","ContactJabberImpl(String id,ServerStoredContactListJabberImpl ssclCallback,boolean isPersistent){
  this.tempId=id;
  this.ssclCallback=ssclCallback;
  this.isPersistent=isPersistent;
  this.isResolved=false;
  this.status=((ProtocolProviderServiceJabberImpl)getProtocolProvider()).getJabberStatusEnum().getStatus(JabberStatusEnum.OFFLINE);
}",0.9661016949152542
104324,"/** 
 * Initializes protocol provider references and whatever else there is to initialize.
 * @throws java.lang.Exception in case we meet problems while retrivingprotocol providers through OSGI
 */
public void setUp() throws Exception {
  ServiceReference[] serRefs=null;
  String osgiFilter=""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str"";
  try {
    serRefs=bc.getServiceReferences(ProtocolProviderFactory.class.getName(),osgiFilter);
  }
 catch (  InvalidSyntaxException ex) {
    fail(osgiFilter + ""String_Node_Str"");
  }
  assertTrue(""String_Node_Str"",serRefs != null || serRefs.length > 0);
  providerFactory=(ProtocolProviderFactory)bc.getService(serRefs[0]);
  userID1=System.getProperty(GibberishProtocolProviderServiceLick.ACCOUNT_1_PREFIX + ProtocolProviderFactory.USER_ID);
  userID2=System.getProperty(GibberishProtocolProviderServiceLick.ACCOUNT_2_PREFIX + ProtocolProviderFactory.USER_ID);
  ServiceReference[] gibberishProvider1Refs=bc.getServiceReferences(ProtocolProviderService.class.getName(),""String_Node_Str"" + ""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ""String_Node_Str""+ ProtocolProviderFactory.USER_ID+ ""String_Node_Str""+ userID1+ ""String_Node_Str""+ ""String_Node_Str"");
  assertNotNull(""String_Node_Str"" + userID1,gibberishProvider1Refs);
  assertTrue(""String_Node_Str"" + userID1,gibberishProvider1Refs.length > 0);
  ServiceReference[] gibberishProvider2Refs=bc.getServiceReferences(ProtocolProviderService.class.getName(),""String_Node_Str"" + ""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ""String_Node_Str""+ ProtocolProviderFactory.USER_ID+ ""String_Node_Str""+ userID2+ ""String_Node_Str""+ ""String_Node_Str"");
  assertNotNull(""String_Node_Str"" + userID2,gibberishProvider2Refs);
  assertTrue(""String_Node_Str"" + userID2,gibberishProvider2Refs.length > 0);
  provider1ServiceRef=gibberishProvider1Refs[0];
  provider1=(ProtocolProviderService)bc.getService(provider1ServiceRef);
  provider2ServiceRef=gibberishProvider2Refs[0];
  provider2=(ProtocolProviderService)bc.getService(provider2ServiceRef);
}","/** 
 * Initializes protocol provider references and whatever else there is to initialize.
 * @throws java.lang.Exception in case we meet problems while retrivingprotocol providers through OSGI
 */
public void setUp() throws Exception {
  ServiceReference[] serRefs=null;
  String osgiFilter=""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str"";
  try {
    serRefs=bc.getServiceReferences(ProtocolProviderFactory.class.getName(),osgiFilter);
  }
 catch (  InvalidSyntaxException ex) {
    fail(osgiFilter + ""String_Node_Str"");
  }
  assertTrue(""String_Node_Str"",(serRefs != null) && (serRefs.length > 0));
  providerFactory=(ProtocolProviderFactory)bc.getService(serRefs[0]);
  userID1=System.getProperty(GibberishProtocolProviderServiceLick.ACCOUNT_1_PREFIX + ProtocolProviderFactory.USER_ID);
  userID2=System.getProperty(GibberishProtocolProviderServiceLick.ACCOUNT_2_PREFIX + ProtocolProviderFactory.USER_ID);
  ServiceReference[] gibberishProvider1Refs=bc.getServiceReferences(ProtocolProviderService.class.getName(),""String_Node_Str"" + ""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ""String_Node_Str""+ ProtocolProviderFactory.USER_ID+ ""String_Node_Str""+ userID1+ ""String_Node_Str""+ ""String_Node_Str"");
  assertNotNull(""String_Node_Str"" + userID1,gibberishProvider1Refs);
  assertTrue(""String_Node_Str"" + userID1,gibberishProvider1Refs.length > 0);
  ServiceReference[] gibberishProvider2Refs=bc.getServiceReferences(ProtocolProviderService.class.getName(),""String_Node_Str"" + ""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ""String_Node_Str""+ ProtocolProviderFactory.USER_ID+ ""String_Node_Str""+ userID2+ ""String_Node_Str""+ ""String_Node_Str"");
  assertNotNull(""String_Node_Str"" + userID2,gibberishProvider2Refs);
  assertTrue(""String_Node_Str"" + userID2,gibberishProvider2Refs.length > 0);
  provider1ServiceRef=gibberishProvider1Refs[0];
  provider1=(ProtocolProviderService)bc.getService(provider1ServiceRef);
  provider2ServiceRef=gibberishProvider2Refs[0];
  provider2=(ProtocolProviderService)bc.getService(provider2ServiceRef);
}",0.9971590909090908
104325,"public void setUp() throws Exception {
  ServiceReference[] serRefs=null;
  String osgiFilter=""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ProtocolNames.ICQ+ ""String_Node_Str"";
  try {
    serRefs=IcqSlickFixture.bc.getServiceReferences(ProtocolProviderFactory.class.getName(),osgiFilter);
  }
 catch (  InvalidSyntaxException ex) {
    fail(osgiFilter + ""String_Node_Str"");
  }
  assertTrue(""String_Node_Str"",serRefs != null || serRefs.length > 0);
  providerFactory=(ProtocolProviderFactory)IcqSlickFixture.bc.getService(serRefs[0]);
  ourUserID=System.getProperty(IcqProtocolProviderSlick.TESTED_IMPL_USER_ID_PROP_NAME);
  ServiceReference[] icqProviderRefs=bc.getServiceReferences(ProtocolProviderService.class.getName(),""String_Node_Str"" + ""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ProtocolNames.ICQ+ ""String_Node_Str""+ ""String_Node_Str""+ ProtocolProviderFactory.USER_ID+ ""String_Node_Str""+ ourUserID+ ""String_Node_Str""+ ""String_Node_Str"");
  assertNotNull(""String_Node_Str"" + ourUserID,icqProviderRefs);
  assertTrue(""String_Node_Str"" + ourUserID,icqProviderRefs.length > 0);
  icqServiceRef=icqProviderRefs[0];
  provider=(ProtocolProviderService)bc.getService(icqServiceRef);
}","public void setUp() throws Exception {
  ServiceReference[] serRefs=null;
  String osgiFilter=""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ProtocolNames.ICQ+ ""String_Node_Str"";
  try {
    serRefs=IcqSlickFixture.bc.getServiceReferences(ProtocolProviderFactory.class.getName(),osgiFilter);
  }
 catch (  InvalidSyntaxException ex) {
    fail(osgiFilter + ""String_Node_Str"");
  }
  assertTrue(""String_Node_Str"",(serRefs != null) && (serRefs.length > 0));
  providerFactory=(ProtocolProviderFactory)IcqSlickFixture.bc.getService(serRefs[0]);
  ourUserID=System.getProperty(IcqProtocolProviderSlick.TESTED_IMPL_USER_ID_PROP_NAME);
  ServiceReference[] icqProviderRefs=bc.getServiceReferences(ProtocolProviderService.class.getName(),""String_Node_Str"" + ""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ProtocolNames.ICQ+ ""String_Node_Str""+ ""String_Node_Str""+ ProtocolProviderFactory.USER_ID+ ""String_Node_Str""+ ourUserID+ ""String_Node_Str""+ ""String_Node_Str"");
  assertNotNull(""String_Node_Str"" + ourUserID,icqProviderRefs);
  assertTrue(""String_Node_Str"" + ourUserID,icqProviderRefs.length > 0);
  icqServiceRef=icqProviderRefs[0];
  provider=(ProtocolProviderService)bc.getService(icqServiceRef);
}",0.9951923076923076
104326,"/** 
 * We try to register with wrong uin which must fire event with status AUTHENTICATION_FAILED. As the uin is new (not existing and not registered) we first install this account, then try to register and wait for the supposed event. After all we unregister this account
 * @throws OperationFailedException if register () fails for a provider.
 */
public void testRegisterWrongUsername() throws OperationFailedException {
  ServiceReference[] serRefs=null;
  String osgiFilter=""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ProtocolNames.ICQ+ ""String_Node_Str"";
  try {
    serRefs=IcqSlickFixture.bc.getServiceReferences(ProtocolProviderFactory.class.getName(),osgiFilter);
  }
 catch (  InvalidSyntaxException ex) {
    fail(osgiFilter + ""String_Node_Str"");
  }
  assertTrue(""String_Node_Str"",serRefs != null || serRefs.length > 0);
  ProtocolProviderFactory icqProviderFactory=(ProtocolProviderFactory)IcqSlickFixture.bc.getService(serRefs[0]);
  String passwd=System.getProperty(IcqProtocolProviderSlick.TESTED_IMPL_PWD_PROP_NAME,null);
  String uin=System.getProperty(IcqProtocolProviderSlick.TESTED_IMPL_USER_ID_PROP_NAME,null);
  uin=uin + ""String_Node_Str"";
  Hashtable icqAccountProperties=new Hashtable();
  icqAccountProperties.put(ProtocolProviderFactory.PASSWORD,passwd);
  AccountID icqAccountID=icqProviderFactory.installAccount(uin,icqAccountProperties);
  ServiceReference[] icqProviderRefs=null;
  try {
    icqProviderRefs=IcqSlickFixture.bc.getServiceReferences(ProtocolProviderService.class.getName(),""String_Node_Str"" + ""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ProtocolNames.ICQ+ ""String_Node_Str""+ ""String_Node_Str""+ ProtocolProviderFactory.USER_ID+ ""String_Node_Str""+ uin+ ""String_Node_Str""+ ""String_Node_Str"");
  }
 catch (  InvalidSyntaxException ex) {
    logger.debug(""String_Node_Str"",ex);
  }
  assertNotNull(""String_Node_Str"" + icqAccountID,icqProviderRefs);
  assertTrue(""String_Node_Str"" + icqAccountID,icqProviderRefs.length > 0);
  ServiceReference icqServiceRef=icqProviderRefs[0];
  ProtocolProviderService provider=(ProtocolProviderService)IcqSlickFixture.bc.getService(icqServiceRef);
  RegistrationFailedEventCollector regFailedEvtCollector=new RegistrationFailedEventCollector();
  logger.debug(""String_Node_Str"" + regFailedEvtCollector);
  provider.addRegistrationStateChangeListener(regFailedEvtCollector);
  provider.register(new SecurityAuthorityImpl(passwd.toCharArray()));
  try {
synchronized (registrationLock) {
      logger.debug(""String_Node_Str"");
      registrationLock.wait(40000);
      logger.debug(""String_Node_Str"");
    }
  }
 catch (  InterruptedException ex) {
    logger.debug(""String_Node_Str"",ex);
  }
catch (  Throwable t) {
    logger.debug(""String_Node_Str"",t);
  }
  assertTrue(""String_Node_Str"" + ""String_Node_Str"" + regFailedEvtCollector.collectedNewStates,regFailedEvtCollector.collectedNewStates.contains(RegistrationState.AUTHENTICATION_FAILED));
  assertEquals(""String_Node_Str"" + ""String_Node_Str"",regFailedEvtCollector.failedCode,RegistrationStateChangeEvent.REASON_NON_EXISTING_USER_ID);
  assertNotNull(""String_Node_Str"",regFailedEvtCollector.failedReason);
  provider.removeRegistrationStateChangeListener(regFailedEvtCollector);
  icqProviderFactory.uninstallAccount(icqAccountID);
}","/** 
 * We try to register with wrong uin which must fire event with status AUTHENTICATION_FAILED. As the uin is new (not existing and not registered) we first install this account, then try to register and wait for the supposed event. After all we unregister this account
 * @throws OperationFailedException if register () fails for a provider.
 */
public void testRegisterWrongUsername() throws OperationFailedException {
  ServiceReference[] serRefs=null;
  String osgiFilter=""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ProtocolNames.ICQ+ ""String_Node_Str"";
  try {
    serRefs=IcqSlickFixture.bc.getServiceReferences(ProtocolProviderFactory.class.getName(),osgiFilter);
  }
 catch (  InvalidSyntaxException ex) {
    fail(osgiFilter + ""String_Node_Str"");
  }
  assertTrue(""String_Node_Str"",(serRefs != null) && (serRefs.length > 0));
  ProtocolProviderFactory icqProviderFactory=(ProtocolProviderFactory)IcqSlickFixture.bc.getService(serRefs[0]);
  String passwd=System.getProperty(IcqProtocolProviderSlick.TESTED_IMPL_PWD_PROP_NAME,null);
  String uin=System.getProperty(IcqProtocolProviderSlick.TESTED_IMPL_USER_ID_PROP_NAME,null);
  uin=uin + ""String_Node_Str"";
  Hashtable icqAccountProperties=new Hashtable();
  icqAccountProperties.put(ProtocolProviderFactory.PASSWORD,passwd);
  AccountID icqAccountID=icqProviderFactory.installAccount(uin,icqAccountProperties);
  ServiceReference[] icqProviderRefs=null;
  try {
    icqProviderRefs=IcqSlickFixture.bc.getServiceReferences(ProtocolProviderService.class.getName(),""String_Node_Str"" + ""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ProtocolNames.ICQ+ ""String_Node_Str""+ ""String_Node_Str""+ ProtocolProviderFactory.USER_ID+ ""String_Node_Str""+ uin+ ""String_Node_Str""+ ""String_Node_Str"");
  }
 catch (  InvalidSyntaxException ex) {
    logger.debug(""String_Node_Str"",ex);
  }
  assertNotNull(""String_Node_Str"" + icqAccountID,icqProviderRefs);
  assertTrue(""String_Node_Str"" + icqAccountID,icqProviderRefs.length > 0);
  ServiceReference icqServiceRef=icqProviderRefs[0];
  ProtocolProviderService provider=(ProtocolProviderService)IcqSlickFixture.bc.getService(icqServiceRef);
  RegistrationFailedEventCollector regFailedEvtCollector=new RegistrationFailedEventCollector();
  logger.debug(""String_Node_Str"" + regFailedEvtCollector);
  provider.addRegistrationStateChangeListener(regFailedEvtCollector);
  provider.register(new SecurityAuthorityImpl(passwd.toCharArray()));
  try {
synchronized (registrationLock) {
      logger.debug(""String_Node_Str"");
      registrationLock.wait(40000);
      logger.debug(""String_Node_Str"");
    }
  }
 catch (  InterruptedException ex) {
    logger.debug(""String_Node_Str"",ex);
  }
catch (  Throwable t) {
    logger.debug(""String_Node_Str"",t);
  }
  assertTrue(""String_Node_Str"" + ""String_Node_Str"" + regFailedEvtCollector.collectedNewStates,regFailedEvtCollector.collectedNewStates.contains(RegistrationState.AUTHENTICATION_FAILED));
  assertEquals(""String_Node_Str"" + ""String_Node_Str"",regFailedEvtCollector.failedCode,RegistrationStateChangeEvent.REASON_NON_EXISTING_USER_ID);
  assertNotNull(""String_Node_Str"",regFailedEvtCollector.failedReason);
  provider.removeRegistrationStateChangeListener(regFailedEvtCollector);
  icqProviderFactory.uninstallAccount(icqAccountID);
}",0.9981971153846154
104327,"/** 
 * Will try to register with wrong password and wait for triggered event with status AUTHENTICATION_FAILED. We get the already installed account. Change the password and try to register. After all tests we must return the original password so we don't break the other tests
 * @throws OperationFailedException if register fails for a provider.
 */
public void testRegisterWrongPassword() throws OperationFailedException {
  ServiceReference[] serRefs=null;
  String osgiFilter=""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ProtocolNames.ICQ+ ""String_Node_Str"";
  try {
    serRefs=IcqSlickFixture.bc.getServiceReferences(ProtocolProviderFactory.class.getName(),osgiFilter);
  }
 catch (  InvalidSyntaxException ex) {
    fail(osgiFilter + ""String_Node_Str"");
  }
  assertTrue(""String_Node_Str"",serRefs != null || serRefs.length > 0);
  ProtocolProviderFactory icqProviderFactory=(ProtocolProviderFactory)IcqSlickFixture.bc.getService(serRefs[0]);
  String passwd=System.getProperty(IcqProtocolProviderSlick.TESTED_IMPL_PWD_PROP_NAME,null);
  String uin=System.getProperty(IcqProtocolProviderSlick.TESTED_IMPL_USER_ID_PROP_NAME,null);
  passwd=""String_Node_Str"";
  Hashtable icqAccountProperties=new Hashtable();
  icqAccountProperties.put(ProtocolProviderFactory.PASSWORD,passwd);
  AccountID icqAccountID=icqProviderFactory.installAccount(uin,icqAccountProperties);
  ServiceReference[] icqProviderRefs=null;
  try {
    icqProviderRefs=IcqSlickFixture.bc.getServiceReferences(ProtocolProviderService.class.getName(),""String_Node_Str"" + ""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ProtocolNames.ICQ+ ""String_Node_Str""+ ""String_Node_Str""+ ProtocolProviderFactory.USER_ID+ ""String_Node_Str""+ icqAccountID.getUserID()+ ""String_Node_Str""+ ""String_Node_Str"");
  }
 catch (  InvalidSyntaxException ex1) {
    logger.error(""String_Node_Str"",ex1);
  }
  assertNotNull(""String_Node_Str"" + icqAccountID,icqProviderRefs);
  assertTrue(""String_Node_Str"" + icqAccountID,icqProviderRefs.length > 0);
  ServiceReference icqServiceRef=icqProviderRefs[0];
  ProtocolProviderService provider=(ProtocolProviderService)IcqSlickFixture.bc.getService(icqServiceRef);
  RegistrationFailedEventCollector regFailedEvtCollector=new RegistrationFailedEventCollector();
  logger.debug(""String_Node_Str"" + regFailedEvtCollector);
  provider.addRegistrationStateChangeListener(regFailedEvtCollector);
  provider.register(new SecurityAuthorityImpl(passwd.toCharArray()));
  try {
synchronized (registrationLock) {
      logger.debug(""String_Node_Str"");
      registrationLock.wait(40000);
      logger.debug(""String_Node_Str"");
    }
  }
 catch (  InterruptedException ex) {
    logger.debug(""String_Node_Str"",ex);
  }
catch (  Throwable t) {
    logger.debug(""String_Node_Str"",t);
  }
  assertTrue(""String_Node_Str"" + ""String_Node_Str"" + regFailedEvtCollector.collectedNewStates,regFailedEvtCollector.collectedNewStates.contains(RegistrationState.AUTHENTICATION_FAILED));
  assertEquals(""String_Node_Str"",regFailedEvtCollector.failedCode,RegistrationStateChangeEvent.REASON_AUTHENTICATION_FAILED);
  assertNotNull(""String_Node_Str"",regFailedEvtCollector.failedReason);
  provider.removeRegistrationStateChangeListener(regFailedEvtCollector);
  icqProviderFactory.uninstallAccount(icqAccountID);
}","/** 
 * Will try to register with wrong password and wait for triggered event with status AUTHENTICATION_FAILED. We get the already installed account. Change the password and try to register. After all tests we must return the original password so we don't break the other tests
 * @throws OperationFailedException if register fails for a provider.
 */
public void testRegisterWrongPassword() throws OperationFailedException {
  ServiceReference[] serRefs=null;
  String osgiFilter=""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ProtocolNames.ICQ+ ""String_Node_Str"";
  try {
    serRefs=IcqSlickFixture.bc.getServiceReferences(ProtocolProviderFactory.class.getName(),osgiFilter);
  }
 catch (  InvalidSyntaxException ex) {
    fail(osgiFilter + ""String_Node_Str"");
  }
  assertTrue(""String_Node_Str"",(serRefs != null) && (serRefs.length > 0));
  ProtocolProviderFactory icqProviderFactory=(ProtocolProviderFactory)IcqSlickFixture.bc.getService(serRefs[0]);
  String passwd=System.getProperty(IcqProtocolProviderSlick.TESTED_IMPL_PWD_PROP_NAME,null);
  String uin=System.getProperty(IcqProtocolProviderSlick.TESTED_IMPL_USER_ID_PROP_NAME,null);
  passwd=""String_Node_Str"";
  Hashtable icqAccountProperties=new Hashtable();
  icqAccountProperties.put(ProtocolProviderFactory.PASSWORD,passwd);
  AccountID icqAccountID=icqProviderFactory.installAccount(uin,icqAccountProperties);
  ServiceReference[] icqProviderRefs=null;
  try {
    icqProviderRefs=IcqSlickFixture.bc.getServiceReferences(ProtocolProviderService.class.getName(),""String_Node_Str"" + ""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ProtocolNames.ICQ+ ""String_Node_Str""+ ""String_Node_Str""+ ProtocolProviderFactory.USER_ID+ ""String_Node_Str""+ icqAccountID.getUserID()+ ""String_Node_Str""+ ""String_Node_Str"");
  }
 catch (  InvalidSyntaxException ex1) {
    logger.error(""String_Node_Str"",ex1);
  }
  assertNotNull(""String_Node_Str"" + icqAccountID,icqProviderRefs);
  assertTrue(""String_Node_Str"" + icqAccountID,icqProviderRefs.length > 0);
  ServiceReference icqServiceRef=icqProviderRefs[0];
  ProtocolProviderService provider=(ProtocolProviderService)IcqSlickFixture.bc.getService(icqServiceRef);
  RegistrationFailedEventCollector regFailedEvtCollector=new RegistrationFailedEventCollector();
  logger.debug(""String_Node_Str"" + regFailedEvtCollector);
  provider.addRegistrationStateChangeListener(regFailedEvtCollector);
  provider.register(new SecurityAuthorityImpl(passwd.toCharArray()));
  try {
synchronized (registrationLock) {
      logger.debug(""String_Node_Str"");
      registrationLock.wait(40000);
      logger.debug(""String_Node_Str"");
    }
  }
 catch (  InterruptedException ex) {
    logger.debug(""String_Node_Str"",ex);
  }
catch (  Throwable t) {
    logger.debug(""String_Node_Str"",t);
  }
  assertTrue(""String_Node_Str"" + ""String_Node_Str"" + regFailedEvtCollector.collectedNewStates,regFailedEvtCollector.collectedNewStates.contains(RegistrationState.AUTHENTICATION_FAILED));
  assertEquals(""String_Node_Str"",regFailedEvtCollector.failedCode,RegistrationStateChangeEvent.REASON_AUTHENTICATION_FAILED);
  assertNotNull(""String_Node_Str"",regFailedEvtCollector.failedReason);
  provider.removeRegistrationStateChangeListener(regFailedEvtCollector);
  icqProviderFactory.uninstallAccount(icqAccountID);
}",0.9981992797118848
104328,"/** 
 * Installs an account and verifies whether the installation has gone well.
 */
public void testInstallAccount(){
  ServiceReference[] serRefs=null;
  String osgiFilter=""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ProtocolNames.ICQ+ ""String_Node_Str"";
  try {
    serRefs=IcqSlickFixture.bc.getServiceReferences(ProtocolProviderFactory.class.getName(),osgiFilter);
  }
 catch (  InvalidSyntaxException ex) {
    fail(osgiFilter + ""String_Node_Str"");
  }
  assertTrue(""String_Node_Str"",serRefs != null || serRefs.length > 0);
  icqProviderFactory=(ProtocolProviderFactory)IcqSlickFixture.bc.getService(serRefs[0]);
  assertTrue(""String_Node_Str"" + ""String_Node_Str"",icqProviderFactory.getRegisteredAccounts().size() == 0);
  String passwd=System.getProperty(IcqProtocolProviderSlick.TESTED_IMPL_PWD_PROP_NAME,null);
  String uin=System.getProperty(IcqProtocolProviderSlick.TESTED_IMPL_USER_ID_PROP_NAME,null);
  assertNotNull(""String_Node_Str"" + IcqProtocolProviderSlick.TESTED_IMPL_USER_ID_PROP_NAME + ""String_Node_Str""+ ""String_Node_Str""+ IcqProtocolProviderSlick.TESTED_IMPL_PWD_PROP_NAME,uin);
  assertNotNull(""String_Node_Str"" + IcqProtocolProviderSlick.TESTED_IMPL_PWD_PROP_NAME + ""String_Node_Str""+ uin+ ""String_Node_Str"",passwd);
  Hashtable icqAccountProperties=new Hashtable();
  icqAccountProperties.put(ProtocolProviderFactory.PASSWORD,passwd);
  try {
    icqProviderFactory.installAccount(null,icqAccountProperties);
    fail(""String_Node_Str"" + ""String_Node_Str"");
  }
 catch (  NullPointerException exc) {
  }
  IcqSlickFixture.icqAccountID=icqProviderFactory.installAccount(uin,icqAccountProperties);
  try {
    IcqSlickFixture.icqAccountID=icqProviderFactory.installAccount(uin,icqAccountProperties);
    fail(""String_Node_Str"" + ""String_Node_Str"");
  }
 catch (  IllegalStateException exc) {
  }
  assertTrue(""String_Node_Str"" + ""String_Node_Str"",icqProviderFactory.getRegisteredAccounts().size() == 1);
  osgiFilter=""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ProtocolNames.ICQ+ ""String_Node_Str""+ ""String_Node_Str""+ ProtocolProviderFactory.USER_ID+ ""String_Node_Str""+ IcqSlickFixture.icqAccountID.getUserID()+ ""String_Node_Str"";
  try {
    serRefs=IcqSlickFixture.bc.getServiceReferences(ProtocolProviderService.class.getName(),osgiFilter);
  }
 catch (  InvalidSyntaxException ex) {
    fail(osgiFilter + ""String_Node_Str"");
  }
  assertTrue(""String_Node_Str"" + ""String_Node_Str"",serRefs != null && serRefs.length > 0);
  Object icqProtocolProvider=IcqSlickFixture.bc.getService(serRefs[0]);
  assertTrue(""String_Node_Str"" + ""String_Node_Str"",icqProtocolProvider instanceof ProtocolProviderService);
}","/** 
 * Installs an account and verifies whether the installation has gone well.
 */
public void testInstallAccount(){
  ServiceReference[] serRefs=null;
  String osgiFilter=""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ProtocolNames.ICQ+ ""String_Node_Str"";
  try {
    serRefs=IcqSlickFixture.bc.getServiceReferences(ProtocolProviderFactory.class.getName(),osgiFilter);
  }
 catch (  InvalidSyntaxException ex) {
    fail(osgiFilter + ""String_Node_Str"");
  }
  assertTrue(""String_Node_Str"",(serRefs != null) && (serRefs.length > 0));
  icqProviderFactory=(ProtocolProviderFactory)IcqSlickFixture.bc.getService(serRefs[0]);
  assertTrue(""String_Node_Str"" + ""String_Node_Str"",icqProviderFactory.getRegisteredAccounts().size() == 0);
  String passwd=System.getProperty(IcqProtocolProviderSlick.TESTED_IMPL_PWD_PROP_NAME,null);
  String uin=System.getProperty(IcqProtocolProviderSlick.TESTED_IMPL_USER_ID_PROP_NAME,null);
  assertNotNull(""String_Node_Str"" + IcqProtocolProviderSlick.TESTED_IMPL_USER_ID_PROP_NAME + ""String_Node_Str""+ ""String_Node_Str""+ IcqProtocolProviderSlick.TESTED_IMPL_PWD_PROP_NAME,uin);
  assertNotNull(""String_Node_Str"" + IcqProtocolProviderSlick.TESTED_IMPL_PWD_PROP_NAME + ""String_Node_Str""+ uin+ ""String_Node_Str"",passwd);
  Hashtable icqAccountProperties=new Hashtable();
  icqAccountProperties.put(ProtocolProviderFactory.PASSWORD,passwd);
  try {
    icqProviderFactory.installAccount(null,icqAccountProperties);
    fail(""String_Node_Str"" + ""String_Node_Str"");
  }
 catch (  NullPointerException exc) {
  }
  IcqSlickFixture.icqAccountID=icqProviderFactory.installAccount(uin,icqAccountProperties);
  try {
    IcqSlickFixture.icqAccountID=icqProviderFactory.installAccount(uin,icqAccountProperties);
    fail(""String_Node_Str"" + ""String_Node_Str"");
  }
 catch (  IllegalStateException exc) {
  }
  assertTrue(""String_Node_Str"" + ""String_Node_Str"",icqProviderFactory.getRegisteredAccounts().size() == 1);
  osgiFilter=""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ProtocolNames.ICQ+ ""String_Node_Str""+ ""String_Node_Str""+ ProtocolProviderFactory.USER_ID+ ""String_Node_Str""+ IcqSlickFixture.icqAccountID.getUserID()+ ""String_Node_Str"";
  try {
    serRefs=IcqSlickFixture.bc.getServiceReferences(ProtocolProviderService.class.getName(),osgiFilter);
  }
 catch (  InvalidSyntaxException ex) {
    fail(osgiFilter + ""String_Node_Str"");
  }
  assertTrue(""String_Node_Str"" + ""String_Node_Str"",serRefs != null && serRefs.length > 0);
  Object icqProtocolProvider=IcqSlickFixture.bc.getService(serRefs[0]);
  assertTrue(""String_Node_Str"" + ""String_Node_Str"",icqProtocolProvider instanceof ProtocolProviderService);
}",0.9977695167286246
104329,"/** 
 * Initializes protocol provider references and whatever else there is to initialize.
 * @throws java.lang.Exception in case we meet problems while retrivingprotocol providers through OSGI
 */
public void setUp() throws Exception {
  ServiceReference[] serRefs=null;
  String osgiFilter=""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ProtocolNames.JABBER+ ""String_Node_Str"";
  try {
    serRefs=bc.getServiceReferences(ProtocolProviderFactory.class.getName(),osgiFilter);
  }
 catch (  InvalidSyntaxException ex) {
    fail(osgiFilter + ""String_Node_Str"");
  }
  assertTrue(""String_Node_Str"",serRefs != null || serRefs.length > 0);
  providerFactory=(ProtocolProviderFactory)bc.getService(serRefs[0]);
  userID1=System.getProperty(JabberProtocolProviderServiceLick.ACCOUNT_1_PREFIX + ProtocolProviderFactory.USER_ID);
  userID2=System.getProperty(JabberProtocolProviderServiceLick.ACCOUNT_2_PREFIX + ProtocolProviderFactory.USER_ID);
  chatRoomName=System.getProperty(JabberProtocolProviderServiceLick.CHAT_ROOM_NAME);
  ServiceReference[] jabberProvider1Refs=bc.getServiceReferences(ProtocolProviderService.class.getName(),""String_Node_Str"" + ""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ProtocolNames.JABBER+ ""String_Node_Str""+ ""String_Node_Str""+ ProtocolProviderFactory.USER_ID+ ""String_Node_Str""+ userID1+ ""String_Node_Str""+ ""String_Node_Str"");
  assertNotNull(""String_Node_Str"" + userID1,jabberProvider1Refs);
  assertTrue(""String_Node_Str"" + userID1,jabberProvider1Refs.length > 0);
  ServiceReference[] jabberProvider2Refs=bc.getServiceReferences(ProtocolProviderService.class.getName(),""String_Node_Str"" + ""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ProtocolNames.JABBER+ ""String_Node_Str""+ ""String_Node_Str""+ ProtocolProviderFactory.USER_ID+ ""String_Node_Str""+ userID2+ ""String_Node_Str""+ ""String_Node_Str"");
  assertNotNull(""String_Node_Str"" + userID2,jabberProvider2Refs);
  assertTrue(""String_Node_Str"" + userID2,jabberProvider2Refs.length > 0);
  provider1ServiceRef=jabberProvider1Refs[0];
  provider1=(ProtocolProviderService)bc.getService(provider1ServiceRef);
  provider2ServiceRef=jabberProvider2Refs[0];
  provider2=(ProtocolProviderService)bc.getService(provider2ServiceRef);
}","/** 
 * Initializes protocol provider references and whatever else there is to initialize.
 * @throws java.lang.Exception in case we meet problems while retrivingprotocol providers through OSGI
 */
public void setUp() throws Exception {
  ServiceReference[] serRefs=null;
  String osgiFilter=""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ProtocolNames.JABBER+ ""String_Node_Str"";
  try {
    serRefs=bc.getServiceReferences(ProtocolProviderFactory.class.getName(),osgiFilter);
  }
 catch (  InvalidSyntaxException ex) {
    fail(osgiFilter + ""String_Node_Str"");
  }
  assertTrue(""String_Node_Str"",(serRefs != null) && (serRefs.length > 0));
  providerFactory=(ProtocolProviderFactory)bc.getService(serRefs[0]);
  userID1=System.getProperty(JabberProtocolProviderServiceLick.ACCOUNT_1_PREFIX + ProtocolProviderFactory.USER_ID);
  userID2=System.getProperty(JabberProtocolProviderServiceLick.ACCOUNT_2_PREFIX + ProtocolProviderFactory.USER_ID);
  chatRoomName=System.getProperty(JabberProtocolProviderServiceLick.CHAT_ROOM_NAME);
  ServiceReference[] jabberProvider1Refs=bc.getServiceReferences(ProtocolProviderService.class.getName(),""String_Node_Str"" + ""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ProtocolNames.JABBER+ ""String_Node_Str""+ ""String_Node_Str""+ ProtocolProviderFactory.USER_ID+ ""String_Node_Str""+ userID1+ ""String_Node_Str""+ ""String_Node_Str"");
  assertNotNull(""String_Node_Str"" + userID1,jabberProvider1Refs);
  assertTrue(""String_Node_Str"" + userID1,jabberProvider1Refs.length > 0);
  ServiceReference[] jabberProvider2Refs=bc.getServiceReferences(ProtocolProviderService.class.getName(),""String_Node_Str"" + ""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ProtocolNames.JABBER+ ""String_Node_Str""+ ""String_Node_Str""+ ProtocolProviderFactory.USER_ID+ ""String_Node_Str""+ userID2+ ""String_Node_Str""+ ""String_Node_Str"");
  assertNotNull(""String_Node_Str"" + userID2,jabberProvider2Refs);
  assertTrue(""String_Node_Str"" + userID2,jabberProvider2Refs.length > 0);
  provider1ServiceRef=jabberProvider1Refs[0];
  provider1=(ProtocolProviderService)bc.getService(provider1ServiceRef);
  provider2ServiceRef=jabberProvider2Refs[0];
  provider2=(ProtocolProviderService)bc.getService(provider2ServiceRef);
}",0.9973799126637556
104330,"/** 
 * Initializes protocol provider references and whatever else there is to initialize.
 * @throws java.lang.Exception in case we meet problems while retrivingprotocol providers through OSGI
 */
public void setUp() throws Exception {
  ServiceReference[] serRefs=null;
  String osgiFilter=""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ProtocolNames.MSN+ ""String_Node_Str"";
  try {
    serRefs=bc.getServiceReferences(ProtocolProviderFactory.class.getName(),osgiFilter);
  }
 catch (  InvalidSyntaxException ex) {
    fail(osgiFilter + ""String_Node_Str"");
  }
  assertTrue(""String_Node_Str"",serRefs != null || serRefs.length > 0);
  providerFactory=(ProtocolProviderFactory)bc.getService(serRefs[0]);
  userID1=System.getProperty(MsnProtocolProviderServiceLick.ACCOUNT_1_PREFIX + ProtocolProviderFactory.USER_ID);
  userID2=System.getProperty(MsnProtocolProviderServiceLick.ACCOUNT_2_PREFIX + ProtocolProviderFactory.USER_ID);
  ServiceReference[] msnProvider1Refs=bc.getServiceReferences(ProtocolProviderService.class.getName(),""String_Node_Str"" + ""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ProtocolNames.MSN+ ""String_Node_Str""+ ""String_Node_Str""+ ProtocolProviderFactory.USER_ID+ ""String_Node_Str""+ userID1+ ""String_Node_Str""+ ""String_Node_Str"");
  assertNotNull(""String_Node_Str"" + userID1,msnProvider1Refs);
  assertTrue(""String_Node_Str"" + userID1,msnProvider1Refs.length > 0);
  ServiceReference[] msnProvider2Refs=bc.getServiceReferences(ProtocolProviderService.class.getName(),""String_Node_Str"" + ""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ProtocolNames.MSN+ ""String_Node_Str""+ ""String_Node_Str""+ ProtocolProviderFactory.USER_ID+ ""String_Node_Str""+ userID2+ ""String_Node_Str""+ ""String_Node_Str"");
  assertNotNull(""String_Node_Str"" + userID2,msnProvider2Refs);
  assertTrue(""String_Node_Str"" + userID2,msnProvider2Refs.length > 0);
  provider1ServiceRef=msnProvider1Refs[0];
  provider1=(ProtocolProviderService)bc.getService(provider1ServiceRef);
  provider2ServiceRef=msnProvider2Refs[0];
  provider2=(ProtocolProviderService)bc.getService(provider2ServiceRef);
}","/** 
 * Initializes protocol provider references and whatever else there is to initialize.
 * @throws java.lang.Exception in case we meet problems while retrivingprotocol providers through OSGI
 */
public void setUp() throws Exception {
  ServiceReference[] serRefs=null;
  String osgiFilter=""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ProtocolNames.MSN+ ""String_Node_Str"";
  try {
    serRefs=bc.getServiceReferences(ProtocolProviderFactory.class.getName(),osgiFilter);
  }
 catch (  InvalidSyntaxException ex) {
    fail(osgiFilter + ""String_Node_Str"");
  }
  assertTrue(""String_Node_Str"",(serRefs != null) && (serRefs.length > 0));
  providerFactory=(ProtocolProviderFactory)bc.getService(serRefs[0]);
  userID1=System.getProperty(MsnProtocolProviderServiceLick.ACCOUNT_1_PREFIX + ProtocolProviderFactory.USER_ID);
  userID2=System.getProperty(MsnProtocolProviderServiceLick.ACCOUNT_2_PREFIX + ProtocolProviderFactory.USER_ID);
  ServiceReference[] msnProvider1Refs=bc.getServiceReferences(ProtocolProviderService.class.getName(),""String_Node_Str"" + ""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ProtocolNames.MSN+ ""String_Node_Str""+ ""String_Node_Str""+ ProtocolProviderFactory.USER_ID+ ""String_Node_Str""+ userID1+ ""String_Node_Str""+ ""String_Node_Str"");
  assertNotNull(""String_Node_Str"" + userID1,msnProvider1Refs);
  assertTrue(""String_Node_Str"" + userID1,msnProvider1Refs.length > 0);
  ServiceReference[] msnProvider2Refs=bc.getServiceReferences(ProtocolProviderService.class.getName(),""String_Node_Str"" + ""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ProtocolNames.MSN+ ""String_Node_Str""+ ""String_Node_Str""+ ProtocolProviderFactory.USER_ID+ ""String_Node_Str""+ userID2+ ""String_Node_Str""+ ""String_Node_Str"");
  assertNotNull(""String_Node_Str"" + userID2,msnProvider2Refs);
  assertTrue(""String_Node_Str"" + userID2,msnProvider2Refs.length > 0);
  provider1ServiceRef=msnProvider1Refs[0];
  provider1=(ProtocolProviderService)bc.getService(provider1ServiceRef);
  provider2ServiceRef=msnProvider2Refs[0];
  provider2=(ProtocolProviderService)bc.getService(provider2ServiceRef);
}",0.997229916897507
104331,"/** 
 * Initializes protocol provider references and whatever else there is to initialize.
 * @throws java.lang.Exception in case we meet problems while retrivingprotocol providers through OSGI
 */
public void setUp() throws Exception {
  ServiceReference[] serRefs=null;
  String osgiFilter=""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ProtocolNames.SIP+ ""String_Node_Str"";
  try {
    serRefs=bc.getServiceReferences(ProtocolProviderFactory.class.getName(),osgiFilter);
  }
 catch (  InvalidSyntaxException ex) {
    fail(osgiFilter + ""String_Node_Str"");
  }
  assertTrue(""String_Node_Str"",serRefs != null || serRefs.length > 0);
  providerFactory=(ProtocolProviderFactory)bc.getService(serRefs[0]);
  userID1=System.getProperty(SipProtocolProviderServiceLick.ACCOUNT_1_PREFIX + ProtocolProviderFactory.USER_ID);
  userID2=System.getProperty(SipProtocolProviderServiceLick.ACCOUNT_2_PREFIX + ProtocolProviderFactory.USER_ID);
  ServiceReference[] sipProvider1Refs=bc.getServiceReferences(ProtocolProviderService.class.getName(),""String_Node_Str"" + ""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ProtocolNames.SIP+ ""String_Node_Str""+ ""String_Node_Str""+ ProtocolProviderFactory.USER_ID+ ""String_Node_Str""+ userID1+ ""String_Node_Str""+ ""String_Node_Str"");
  assertNotNull(""String_Node_Str"" + userID1,sipProvider1Refs);
  assertTrue(""String_Node_Str"" + userID1,sipProvider1Refs.length > 0);
  ServiceReference[] sipProvider2Refs=bc.getServiceReferences(ProtocolProviderService.class.getName(),""String_Node_Str"" + ""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ProtocolNames.SIP+ ""String_Node_Str""+ ""String_Node_Str""+ ProtocolProviderFactory.USER_ID+ ""String_Node_Str""+ userID2+ ""String_Node_Str""+ ""String_Node_Str"");
  assertNotNull(""String_Node_Str"" + userID2,sipProvider2Refs);
  assertTrue(""String_Node_Str"" + userID2,sipProvider2Refs.length > 0);
  provider1ServiceRef=sipProvider1Refs[0];
  provider1=(ProtocolProviderService)bc.getService(provider1ServiceRef);
  provider2ServiceRef=sipProvider2Refs[0];
  provider2=(ProtocolProviderService)bc.getService(provider2ServiceRef);
}","/** 
 * Initializes protocol provider references and whatever else there is to initialize.
 * @throws java.lang.Exception in case we meet problems while retrivingprotocol providers through OSGI
 */
public void setUp() throws Exception {
  ServiceReference[] serRefs=null;
  String osgiFilter=""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ProtocolNames.SIP+ ""String_Node_Str"";
  try {
    serRefs=bc.getServiceReferences(ProtocolProviderFactory.class.getName(),osgiFilter);
  }
 catch (  InvalidSyntaxException ex) {
    fail(osgiFilter + ""String_Node_Str"");
  }
  assertTrue(""String_Node_Str"",(serRefs != null) && (serRefs.length > 0));
  providerFactory=(ProtocolProviderFactory)bc.getService(serRefs[0]);
  userID1=System.getProperty(SipProtocolProviderServiceLick.ACCOUNT_1_PREFIX + ProtocolProviderFactory.USER_ID);
  userID2=System.getProperty(SipProtocolProviderServiceLick.ACCOUNT_2_PREFIX + ProtocolProviderFactory.USER_ID);
  ServiceReference[] sipProvider1Refs=bc.getServiceReferences(ProtocolProviderService.class.getName(),""String_Node_Str"" + ""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ProtocolNames.SIP+ ""String_Node_Str""+ ""String_Node_Str""+ ProtocolProviderFactory.USER_ID+ ""String_Node_Str""+ userID1+ ""String_Node_Str""+ ""String_Node_Str"");
  assertNotNull(""String_Node_Str"" + userID1,sipProvider1Refs);
  assertTrue(""String_Node_Str"" + userID1,sipProvider1Refs.length > 0);
  ServiceReference[] sipProvider2Refs=bc.getServiceReferences(ProtocolProviderService.class.getName(),""String_Node_Str"" + ""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ProtocolNames.SIP+ ""String_Node_Str""+ ""String_Node_Str""+ ProtocolProviderFactory.USER_ID+ ""String_Node_Str""+ userID2+ ""String_Node_Str""+ ""String_Node_Str"");
  assertNotNull(""String_Node_Str"" + userID2,sipProvider2Refs);
  assertTrue(""String_Node_Str"" + userID2,sipProvider2Refs.length > 0);
  provider1ServiceRef=sipProvider1Refs[0];
  provider1=(ProtocolProviderService)bc.getService(provider1ServiceRef);
  provider2ServiceRef=sipProvider2Refs[0];
  provider2=(ProtocolProviderService)bc.getService(provider2ServiceRef);
}",0.997229916897507
104332,"/** 
 * Initializes protocol provider references and whatever else there is to initialize.
 * @throws java.lang.Exception in case we meet problems while retrivingprotocol providers through OSGI
 */
public void setUp() throws Exception {
  ServiceReference[] serRefs=null;
  String osgiFilter=""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ProtocolNames.YAHOO+ ""String_Node_Str"";
  try {
    serRefs=bc.getServiceReferences(ProtocolProviderFactory.class.getName(),osgiFilter);
  }
 catch (  InvalidSyntaxException ex) {
    fail(osgiFilter + ""String_Node_Str"");
  }
  assertTrue(""String_Node_Str"",serRefs != null || serRefs.length > 0);
  providerFactory=(ProtocolProviderFactory)bc.getService(serRefs[0]);
  userID1=System.getProperty(YahooProtocolProviderServiceLick.ACCOUNT_1_PREFIX + ProtocolProviderFactory.USER_ID);
  userID2=System.getProperty(YahooProtocolProviderServiceLick.ACCOUNT_2_PREFIX + ProtocolProviderFactory.USER_ID);
  ServiceReference[] yahooProvider1Refs=bc.getServiceReferences(ProtocolProviderService.class.getName(),""String_Node_Str"" + ""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ProtocolNames.YAHOO+ ""String_Node_Str""+ ""String_Node_Str""+ ProtocolProviderFactory.USER_ID+ ""String_Node_Str""+ userID1+ ""String_Node_Str""+ ""String_Node_Str"");
  assertNotNull(""String_Node_Str"" + userID1,yahooProvider1Refs);
  assertTrue(""String_Node_Str"" + userID1,yahooProvider1Refs.length > 0);
  ServiceReference[] yahooProvider2Refs=bc.getServiceReferences(ProtocolProviderService.class.getName(),""String_Node_Str"" + ""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ProtocolNames.YAHOO+ ""String_Node_Str""+ ""String_Node_Str""+ ProtocolProviderFactory.USER_ID+ ""String_Node_Str""+ userID2+ ""String_Node_Str""+ ""String_Node_Str"");
  assertNotNull(""String_Node_Str"" + userID2,yahooProvider2Refs);
  assertTrue(""String_Node_Str"" + userID2,yahooProvider2Refs.length > 0);
  provider1ServiceRef=yahooProvider1Refs[0];
  provider1=(ProtocolProviderService)bc.getService(provider1ServiceRef);
  provider2ServiceRef=yahooProvider2Refs[0];
  provider2=(ProtocolProviderService)bc.getService(provider2ServiceRef);
}","/** 
 * Initializes protocol provider references and whatever else there is to initialize.
 * @throws java.lang.Exception in case we meet problems while retrivingprotocol providers through OSGI
 */
public void setUp() throws Exception {
  ServiceReference[] serRefs=null;
  String osgiFilter=""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ProtocolNames.YAHOO+ ""String_Node_Str"";
  try {
    serRefs=bc.getServiceReferences(ProtocolProviderFactory.class.getName(),osgiFilter);
  }
 catch (  InvalidSyntaxException ex) {
    fail(osgiFilter + ""String_Node_Str"");
  }
  assertTrue(""String_Node_Str"",(serRefs != null) && (serRefs.length > 0));
  providerFactory=(ProtocolProviderFactory)bc.getService(serRefs[0]);
  userID1=System.getProperty(YahooProtocolProviderServiceLick.ACCOUNT_1_PREFIX + ProtocolProviderFactory.USER_ID);
  userID2=System.getProperty(YahooProtocolProviderServiceLick.ACCOUNT_2_PREFIX + ProtocolProviderFactory.USER_ID);
  ServiceReference[] yahooProvider1Refs=bc.getServiceReferences(ProtocolProviderService.class.getName(),""String_Node_Str"" + ""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ProtocolNames.YAHOO+ ""String_Node_Str""+ ""String_Node_Str""+ ProtocolProviderFactory.USER_ID+ ""String_Node_Str""+ userID1+ ""String_Node_Str""+ ""String_Node_Str"");
  assertNotNull(""String_Node_Str"" + userID1,yahooProvider1Refs);
  assertTrue(""String_Node_Str"" + userID1,yahooProvider1Refs.length > 0);
  ServiceReference[] yahooProvider2Refs=bc.getServiceReferences(ProtocolProviderService.class.getName(),""String_Node_Str"" + ""String_Node_Str"" + ProtocolProviderFactory.PROTOCOL + ""String_Node_Str""+ ProtocolNames.YAHOO+ ""String_Node_Str""+ ""String_Node_Str""+ ProtocolProviderFactory.USER_ID+ ""String_Node_Str""+ userID2+ ""String_Node_Str""+ ""String_Node_Str"");
  assertNotNull(""String_Node_Str"" + userID2,yahooProvider2Refs);
  assertTrue(""String_Node_Str"" + userID2,yahooProvider2Refs.length > 0);
  provider1ServiceRef=yahooProvider1Refs[0];
  provider1=(ProtocolProviderService)bc.getService(provider1ServiceRef);
  provider2ServiceRef=yahooProvider2Refs[0];
  provider2=(ProtocolProviderService)bc.getService(provider2ServiceRef);
}",0.9972627737226276
104333,"/** 
 * Sets the call-hold related attribute of a specific <tt>MediaDescription</tt> to a specific value depending on the type of hold this <tt>CallSession</tt> is currently in.
 * @param mediaDescription the <tt>MediaDescription</tt> to set thecall-hold related attribute of
 * @param onHold the call-hold state of this <tt>CallSession</tt> which isa combination of  {@link #ON_HOLD_LOCALLY} and{@link #ON_HOLD_REMOTELY}
 * @throws SdpException
 */
private void setAttributeOnHold(MediaDescription mediaDescription,byte onHold) throws SdpException {
  String attribute;
  if (ON_HOLD_LOCALLY == (onHold | ON_HOLD_LOCALLY))   attribute=(ON_HOLD_REMOTELY == (onHold | ON_HOLD_REMOTELY)) ? ""String_Node_Str"" : ""String_Node_Str"";
 else   attribute=(ON_HOLD_REMOTELY == (onHold | ON_HOLD_REMOTELY)) ? ""String_Node_Str"" : null;
  if (attribute != null)   mediaDescription.setAttribute(attribute,null);
}","/** 
 * Sets the call-hold related attribute of a specific <tt>MediaDescription</tt> to a specific value depending on the type of hold this <tt>CallSession</tt> is currently in.
 * @param mediaDescription the <tt>MediaDescription</tt> to set thecall-hold related attribute of
 * @param onHold the call-hold state of this <tt>CallSession</tt> which isa combination of  {@link #ON_HOLD_LOCALLY} and{@link #ON_HOLD_REMOTELY}
 * @throws SdpException
 */
private void setAttributeOnHold(MediaDescription mediaDescription,byte onHold) throws SdpException {
  String attribute;
  if (ON_HOLD_LOCALLY == (onHold & ON_HOLD_LOCALLY))   attribute=(ON_HOLD_REMOTELY == (onHold & ON_HOLD_REMOTELY)) ? ""String_Node_Str"" : ""String_Node_Str"";
 else   attribute=(ON_HOLD_REMOTELY == (onHold & ON_HOLD_REMOTELY)) ? ""String_Node_Str"" : null;
  if (attribute != null)   mediaDescription.setAttribute(attribute,null);
}",0.9966592427616926
104334,"/** 
 * Checks whether the current component will  exceeds the screen size and if it do will set a default size 
 */
private void ensureOnScreenLocationAndSize(){
  int x=this.getX();
  int y=this.getY();
  int width=this.getWidth();
  int height=this.getHeight();
  int screenWidth=Toolkit.getDefaultToolkit().getScreenSize().width;
  int screenHeight=Toolkit.getDefaultToolkit().getScreenSize().height;
  if (x < 0 || y < 0) {
    this.setLocation(Toolkit.getDefaultToolkit().getScreenSize().width / 2 - this.getWidth() / 2,50);
    x=this.getX();
    y=this.getY();
  }
  if (x + width > screenWidth || y + height > screenHeight - 50) {
    double aspect=(double)width / height;
    int newHeight=screenHeight - 100;
    int newWidth=(int)(newHeight * aspect);
    this.setPreferredSize(new Dimension(newWidth,newHeight));
    this.setSize(newWidth,newHeight);
  }
}","/** 
 * Checks whether the current component will  exceeds the screen size and if it do will set a default size 
 */
private void ensureOnScreenLocationAndSize(){
  int x=this.getX();
  int y=this.getY();
  int width=this.getWidth();
  int height=this.getHeight();
  int screenWidth=Toolkit.getDefaultToolkit().getScreenSize().width;
  int screenHeight=Toolkit.getDefaultToolkit().getScreenSize().height;
  if (x < 0 || y < 0) {
    this.setLocation(Toolkit.getDefaultToolkit().getScreenSize().width / 2 - this.getWidth() / 2,50);
    x=this.getX();
    y=this.getY();
  }
  Rectangle virtualBounds=new Rectangle();
  GraphicsEnvironment ge=GraphicsEnvironment.getLocalGraphicsEnvironment();
  GraphicsDevice[] gs=ge.getScreenDevices();
  for (int j=0; j < gs.length; j++) {
    GraphicsDevice gd=gs[j];
    GraphicsConfiguration[] gc=gd.getConfigurations();
    for (int i=0; i < gc.length; i++) {
      virtualBounds=virtualBounds.union(gc[i].getBounds());
    }
  }
  if (!(virtualBounds.contains(x,y) && virtualBounds.contains(x + width,y + height))) {
    if (x + width > virtualBounds.width) {
      x=virtualBounds.width - width;
      if (x < 20) {
        x=20;
        width=virtualBounds.width - 40;
      }
    }
    if (y + height > virtualBounds.height) {
      y=virtualBounds.height - height;
      if (y < 20) {
        y=20;
        height=virtualBounds.height - 40;
      }
    }
    this.setPreferredSize(new Dimension(width,height));
    this.setSize(width,height);
    this.setLocation(x,y);
  }
}",0.5971524288107203
104335,"/** 
 * Checks whether the current component will  exceeds the screen size and if it do will set a default size 
 */
private void ensureOnScreenLocationAndSize(){
  int x=this.getX();
  int y=this.getY();
  int width=this.getWidth();
  int height=this.getHeight();
  int screenWidth=Toolkit.getDefaultToolkit().getScreenSize().width;
  int screenHeight=Toolkit.getDefaultToolkit().getScreenSize().height;
  if (x < 0 || y < 0) {
    this.setLocation(Toolkit.getDefaultToolkit().getScreenSize().width / 2 - this.getWidth() / 2,50);
    x=this.getX();
    y=this.getY();
  }
  if (x + width > screenWidth || y + height > screenHeight - 50) {
    double aspect=(double)width / height;
    int newHeight=screenHeight - 100;
    int newWidth=(int)(newHeight * aspect);
    this.setPreferredSize(new Dimension(newWidth,newHeight));
    this.setSize(newWidth,newHeight);
  }
}","/** 
 * Checks whether the current component will  exceeds the screen size and if it do will set a default size 
 */
private void ensureOnScreenLocationAndSize(){
  int x=this.getX();
  int y=this.getY();
  int width=this.getWidth();
  int height=this.getHeight();
  int screenWidth=Toolkit.getDefaultToolkit().getScreenSize().width;
  int screenHeight=Toolkit.getDefaultToolkit().getScreenSize().height;
  if (x < 0 || y < 0) {
    this.setLocation(Toolkit.getDefaultToolkit().getScreenSize().width / 2 - this.getWidth() / 2,50);
    x=this.getX();
    y=this.getY();
  }
  Rectangle virtualBounds=new Rectangle();
  GraphicsEnvironment ge=GraphicsEnvironment.getLocalGraphicsEnvironment();
  GraphicsDevice[] gs=ge.getScreenDevices();
  for (int j=0; j < gs.length; j++) {
    GraphicsDevice gd=gs[j];
    GraphicsConfiguration[] gc=gd.getConfigurations();
    for (int i=0; i < gc.length; i++) {
      virtualBounds=virtualBounds.union(gc[i].getBounds());
    }
  }
  if (!(virtualBounds.contains(x,y) && virtualBounds.contains(x + width,y + height))) {
    if (x + width > virtualBounds.width) {
      x=virtualBounds.width - width;
      if (x < 20) {
        x=20;
        width=virtualBounds.width - 40;
      }
    }
    if (y + height > virtualBounds.height) {
      y=virtualBounds.height - height;
      if (y < 20) {
        y=20;
        height=virtualBounds.height - 40;
      }
    }
    this.setPreferredSize(new Dimension(width,height));
    this.setSize(width,height);
    this.setLocation(x,y);
  }
}",0.5971524288107203
104336,"public void run(){
  run=true;
  int timer=0;
  do {
    try {
      if (MouseInfo.getPointerInfo() != null) {
        Point currentPosition=MouseInfo.getPointerInfo().getLocation();
        if (!isNear(lastPosition,currentPosition)) {
          ProtocolProviderService[] pps=StatusUpdateActivator.getProtocolProviders();
          for (          ProtocolProviderService protocolProviderService : pps) {
            if (lastStates.get(protocolProviderService) != null) {
              PresenceStatus lastState=lastStates.get(protocolProviderService);
              OperationSetPresence presence=(OperationSetPresence)protocolProviderService.getOperationSet(OperationSetPresence.class);
              try {
                presence.publishPresenceStatus(lastState,""String_Node_Str"");
              }
 catch (              IllegalArgumentException e) {
              }
catch (              IllegalStateException e) {
              }
catch (              OperationFailedException e) {
              }
              lastStates.remove(protocolProviderService);
            }
          }
          timer=getTimer() * 1000 * 60;
        }
 else {
          ProtocolProviderService[] pps=StatusUpdateActivator.getProtocolProviders();
          for (          ProtocolProviderService protocolProviderService : pps) {
            OperationSetPresence presence=(OperationSetPresence)protocolProviderService.getOperationSet(OperationSetPresence.class);
            PresenceStatus status=presence.getPresenceStatus();
            if (status.getStatus() < PresenceStatus.AVAILABLE_THRESHOLD) {
              break;
            }
            lastStates.put(protocolProviderService,presence.getPresenceStatus());
            PresenceStatus newStatus=findAwayStatus(presence);
            try {
              presence.publishPresenceStatus(newStatus,newStatus.getStatusName());
            }
 catch (            IllegalArgumentException e) {
            }
catch (            IllegalStateException e) {
            }
catch (            OperationFailedException e) {
            }
          }
          timer=IDLE_TIMER;
        }
        lastPosition=currentPosition;
      }
      Thread.sleep(timer);
    }
 catch (    InterruptedException e) {
    }
  }
 while (run && timer > 0);
}","public void run(){
  run=true;
  int timer=0;
  do {
    try {
      if (MouseInfo.getPointerInfo() != null) {
        Point currentPosition=MouseInfo.getPointerInfo().getLocation();
        if (!isNear(lastPosition,currentPosition)) {
          ProtocolProviderService[] pps=StatusUpdateActivator.getProtocolProviders();
          for (          ProtocolProviderService protocolProviderService : pps) {
            if (lastStates.get(protocolProviderService) != null) {
              PresenceStatus lastState=lastStates.get(protocolProviderService);
              OperationSetPresence presence=(OperationSetPresence)protocolProviderService.getOperationSet(OperationSetPresence.class);
              try {
                presence.publishPresenceStatus(lastState,""String_Node_Str"");
              }
 catch (              IllegalArgumentException e) {
              }
catch (              IllegalStateException e) {
              }
catch (              OperationFailedException e) {
              }
              lastStates.remove(protocolProviderService);
            }
          }
          timer=getTimer() * 1000 * 60;
        }
 else {
          ProtocolProviderService[] pps=StatusUpdateActivator.getProtocolProviders();
          for (          ProtocolProviderService protocolProviderService : pps) {
            OperationSetPresence presence=(OperationSetPresence)protocolProviderService.getOperationSet(OperationSetPresence.class);
            PresenceStatus status=presence.getPresenceStatus();
            if (status.getStatus() < PresenceStatus.AVAILABLE_THRESHOLD) {
              continue;
            }
            lastStates.put(protocolProviderService,presence.getPresenceStatus());
            PresenceStatus newStatus=findAwayStatus(presence);
            try {
              if (newStatus != null) {
                presence.publishPresenceStatus(newStatus,newStatus.getStatusName());
              }
            }
 catch (            IllegalArgumentException e) {
            }
catch (            IllegalStateException e) {
            }
catch (            OperationFailedException e) {
            }
          }
          timer=IDLE_TIMER;
        }
        lastPosition=currentPosition;
      }
      Thread.sleep(timer);
    }
 catch (    InterruptedException e) {
    }
  }
 while (run && timer > 0);
}",0.9847627340008708
104337,"/** 
 * Process the incoming sip messages
 * @param requestEvent the incoming event holding the message
 * @return whether this message needs further processing(true) or no(false)
 */
public boolean processMessage(RequestEvent requestEvent){
  String content=null;
  Request req=requestEvent.getRequest();
  ContentTypeHeader ctheader=(ContentTypeHeader)req.getHeader(ContentTypeHeader.NAME);
  if (ctheader == null && !ctheader.getContentSubType().equalsIgnoreCase(CONTENT_SUBTYPE))   return true;
  content=new String(req.getRawContent());
  if (content == null || content.length() == 0) {
    sendResponse(requestEvent,Response.BAD_REQUEST);
    return false;
  }
  FromHeader fromHeader=(FromHeader)requestEvent.getRequest().getHeader(FromHeader.NAME);
  if (fromHeader == null) {
    logger.error(""String_Node_Str"");
    return true;
  }
  Contact from=opSetPersPresence.resolveContactID(fromHeader.getAddress().getURI().toString());
  Document doc=null;
  try {
    doc=opSetPersPresence.convertDocument(content);
  }
 catch (  Exception e) {
  }
  if (doc == null) {
    sendResponse(requestEvent,Response.BAD_REQUEST);
    return false;
  }
  logger.debug(""String_Node_Str"" + content);
  NodeList stateList=doc.getElementsByTagNameNS(NS_VALUE,STATE_ELEMENT);
  if (stateList.getLength() == 0) {
    logger.error(""String_Node_Str"");
    sendResponse(requestEvent,Response.BAD_REQUEST);
    return false;
  }
  Node stateNode=stateList.item(0);
  if (stateNode.getNodeType() != Node.ELEMENT_NODE) {
    logger.error(""String_Node_Str"");
    sendResponse(requestEvent,Response.BAD_REQUEST);
    return false;
  }
  String state=XMLUtils.getText((Element)stateNode);
  if (state == null || state.length() == 0) {
    logger.error(""String_Node_Str"");
    sendResponse(requestEvent,Response.BAD_REQUEST);
    return false;
  }
  NodeList refreshList=doc.getElementsByTagNameNS(NS_VALUE,REFRESH_ELEMENT);
  int refresh=REFRESH_DEFAULT_TIME;
  if (refreshList.getLength() != 0) {
    Node refreshNode=refreshList.item(0);
    if (refreshNode.getNodeType() == Node.ELEMENT_NODE) {
      String refreshStr=XMLUtils.getText((Element)refreshNode);
      try {
        refresh=Integer.parseInt(refreshStr);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
      }
    }
  }
  if (state.equals(COMPOSING_STATE_ACTIVE)) {
    TypingTask task=findTypigTask(from);
    if (task == null) {
      task=new TypingTask(from);
      typingTasks.add(task);
    }
 else     task.cancel();
    timer.schedule(task,refresh * 1000);
    fireTypingNotificationsEvent(from,STATE_TYPING);
  }
 else   if (state.equals(COMPOSING_STATE_IDLE)) {
    fireTypingNotificationsEvent(from,STATE_PAUSED);
  }
  sendResponse(requestEvent,Response.OK);
  return false;
}","/** 
 * Process the incoming sip messages
 * @param requestEvent the incoming event holding the message
 * @return whether this message needs further processing(true) or no(false)
 */
public boolean processMessage(RequestEvent requestEvent){
  String content=null;
  Request req=requestEvent.getRequest();
  ContentTypeHeader ctheader=(ContentTypeHeader)req.getHeader(ContentTypeHeader.NAME);
  if (ctheader == null || !ctheader.getContentSubType().equalsIgnoreCase(CONTENT_SUBTYPE))   return true;
  content=new String(req.getRawContent());
  if (content == null || content.length() == 0) {
    sendResponse(requestEvent,Response.BAD_REQUEST);
    return false;
  }
  FromHeader fromHeader=(FromHeader)requestEvent.getRequest().getHeader(FromHeader.NAME);
  if (fromHeader == null) {
    logger.error(""String_Node_Str"");
    return true;
  }
  Contact from=opSetPersPresence.resolveContactID(fromHeader.getAddress().getURI().toString());
  Document doc=null;
  try {
    doc=opSetPersPresence.convertDocument(content);
  }
 catch (  Exception e) {
  }
  if (doc == null) {
    sendResponse(requestEvent,Response.BAD_REQUEST);
    return false;
  }
  logger.debug(""String_Node_Str"" + content);
  NodeList stateList=doc.getElementsByTagNameNS(NS_VALUE,STATE_ELEMENT);
  if (stateList.getLength() == 0) {
    logger.error(""String_Node_Str"");
    sendResponse(requestEvent,Response.BAD_REQUEST);
    return false;
  }
  Node stateNode=stateList.item(0);
  if (stateNode.getNodeType() != Node.ELEMENT_NODE) {
    logger.error(""String_Node_Str"");
    sendResponse(requestEvent,Response.BAD_REQUEST);
    return false;
  }
  String state=XMLUtils.getText((Element)stateNode);
  if (state == null || state.length() == 0) {
    logger.error(""String_Node_Str"");
    sendResponse(requestEvent,Response.BAD_REQUEST);
    return false;
  }
  NodeList refreshList=doc.getElementsByTagNameNS(NS_VALUE,REFRESH_ELEMENT);
  int refresh=REFRESH_DEFAULT_TIME;
  if (refreshList.getLength() != 0) {
    Node refreshNode=refreshList.item(0);
    if (refreshNode.getNodeType() == Node.ELEMENT_NODE) {
      String refreshStr=XMLUtils.getText((Element)refreshNode);
      try {
        refresh=Integer.parseInt(refreshStr);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
      }
    }
  }
  if (state.equals(COMPOSING_STATE_ACTIVE)) {
    TypingTask task=findTypigTask(from);
    if (task == null) {
      task=new TypingTask(from);
      typingTasks.add(task);
    }
 else     task.cancel();
    timer.schedule(task,refresh * 1000);
    fireTypingNotificationsEvent(from,STATE_TYPING);
  }
 else   if (state.equals(COMPOSING_STATE_IDLE)) {
    fireTypingNotificationsEvent(from,STATE_PAUSED);
  }
  sendResponse(requestEvent,Response.OK);
  return false;
}",0.9992771955186122
104338,"/** 
 * Process the responses of sent messages
 * @param responseEvent the incoming event holding the response
 * @return whether this message needs further processing(true) or no(false)
 */
public boolean processResponse(ResponseEvent responseEvent,Map sentMsg){
  String content=null;
  Request req=responseEvent.getClientTransaction().getRequest();
  ContentTypeHeader ctheader=(ContentTypeHeader)req.getHeader(ContentTypeHeader.NAME);
  if (ctheader == null && !ctheader.getContentSubType().equalsIgnoreCase(CONTENT_SUBTYPE))   return true;
  int status=responseEvent.getResponse().getStatusCode();
  if (status >= 200 && status < 300) {
    logger.debug(""String_Node_Str"" + responseEvent.getResponse().getReasonPhrase());
    String key=((CallIdHeader)req.getHeader(CallIdHeader.NAME)).getCallId();
    sentMsg.remove(key);
    return false;
  }
  return true;
}","/** 
 * Process the responses of sent messages
 * @param responseEvent the incoming event holding the response
 * @return whether this message needs further processing(true) or no(false)
 */
public boolean processResponse(ResponseEvent responseEvent,Map sentMsg){
  String content=null;
  Request req=responseEvent.getClientTransaction().getRequest();
  ContentTypeHeader ctheader=(ContentTypeHeader)req.getHeader(ContentTypeHeader.NAME);
  if (ctheader == null || !ctheader.getContentSubType().equalsIgnoreCase(CONTENT_SUBTYPE))   return true;
  int status=responseEvent.getResponse().getStatusCode();
  String key=((CallIdHeader)req.getHeader(CallIdHeader.NAME)).getCallId();
  if (status >= 200 && status < 300) {
    logger.debug(""String_Node_Str"" + responseEvent.getResponse().getReasonPhrase());
    sentMsg.remove(key);
    return false;
  }
 else   if (status >= 400 && status != 401 && status != 407) {
    logger.warn(""String_Node_Str"" + responseEvent.getResponse().getReasonPhrase());
    sentMsg.remove(key);
    return false;
  }
  return true;
}",0.7528556593977155
104339,"/** 
 * Adds all protocol supported operation sets.
 * @param protocolProvider The protocol provider.
 */
public void addProtocolSupportedOperationSets(ProtocolProviderService protocolProvider){
  Map supportedOperationSets=protocolProvider.getSupportedOperationSets();
  String ppOpSetClassName=OperationSetPersistentPresence.class.getName();
  String pOpSetClassName=OperationSetPresence.class.getName();
  if (supportedOperationSets.containsKey(ppOpSetClassName) || supportedOperationSets.containsKey(pOpSetClassName)) {
    OperationSetPresence presence=(OperationSetPresence)supportedOperationSets.get(ppOpSetClassName);
    if (presence == null) {
      presence=(OperationSetPresence)supportedOperationSets.get(pOpSetClassName);
    }
    presence.addProviderPresenceStatusListener(new GUIProviderPresenceStatusListener());
    presence.addContactPresenceStatusListener(new GUIContactPresenceStatusListener());
  }
  String imOpSetClassName=OperationSetBasicInstantMessaging.class.getName();
  if (supportedOperationSets.containsKey(imOpSetClassName)) {
    OperationSetBasicInstantMessaging im=(OperationSetBasicInstantMessaging)supportedOperationSets.get(imOpSetClassName);
    im.addMessageListener(getContactListPanel());
  }
  String tnOpSetClassName=OperationSetTypingNotifications.class.getName();
  if (supportedOperationSets.containsKey(tnOpSetClassName)) {
    OperationSetTypingNotifications tn=(OperationSetTypingNotifications)supportedOperationSets.get(tnOpSetClassName);
    tn.addTypingNotificationsListener(this.getContactListPanel());
  }
  String telOpSetClassName=OperationSetBasicTelephony.class.getName();
  if (supportedOperationSets.containsKey(telOpSetClassName)) {
    OperationSetBasicTelephony telephony=(OperationSetBasicTelephony)supportedOperationSets.get(telOpSetClassName);
    telephony.addCallListener(callManager);
    this.getContactListPanel().getContactList().addListSelectionListener(callManager);
    this.tabbedPane.addChangeListener(callManager);
  }
  String multiChatClassName=OperationSetMultiUserChat.class.getName();
  if (supportedOperationSets.containsKey(multiChatClassName)) {
    OperationSetMultiUserChat multiUserChat=(OperationSetMultiUserChat)supportedOperationSets.get(multiChatClassName);
    multiUserChat.addInvitationListener(multiUserChatManager);
    multiUserChat.addInvitationRejectionListener(multiUserChatManager);
    multiUserChat.addPresenceListener(multiUserChatManager);
    this.getChatRoomsListPanel().getChatRoomsList().addChatServer(protocolProvider,multiUserChat);
  }
  String smsOpSetClassName=OperationSetSmsMessaging.class.getName();
  if (supportedOperationSets.containsKey(smsOpSetClassName)) {
    OperationSetSmsMessaging smsOpSet=(OperationSetSmsMessaging)supportedOperationSets.get(smsOpSetClassName);
    smsOpSet.addMessageListener(getContactListPanel());
  }
}","/** 
 * Adds all protocol supported operation sets.
 * @param protocolProvider The protocol provider.
 */
public void addProtocolSupportedOperationSets(ProtocolProviderService protocolProvider){
  Map supportedOperationSets=protocolProvider.getSupportedOperationSets();
  String ppOpSetClassName=OperationSetPersistentPresence.class.getName();
  String pOpSetClassName=OperationSetPresence.class.getName();
  if (supportedOperationSets.containsKey(ppOpSetClassName) || supportedOperationSets.containsKey(pOpSetClassName)) {
    OperationSetPresence presence=(OperationSetPresence)supportedOperationSets.get(ppOpSetClassName);
    if (presence == null) {
      presence=(OperationSetPresence)supportedOperationSets.get(pOpSetClassName);
    }
    presence.addProviderPresenceStatusListener(new GUIProviderPresenceStatusListener());
    presence.addContactPresenceStatusListener(new GUIContactPresenceStatusListener());
  }
  String imOpSetClassName=OperationSetBasicInstantMessaging.class.getName();
  if (supportedOperationSets.containsKey(imOpSetClassName)) {
    OperationSetBasicInstantMessaging im=(OperationSetBasicInstantMessaging)supportedOperationSets.get(imOpSetClassName);
    im.addMessageListener(getContactListPanel());
  }
  String tnOpSetClassName=OperationSetTypingNotifications.class.getName();
  if (supportedOperationSets.containsKey(tnOpSetClassName)) {
    OperationSetTypingNotifications tn=(OperationSetTypingNotifications)supportedOperationSets.get(tnOpSetClassName);
    tn.addTypingNotificationsListener(this.getContactListPanel());
  }
  String telOpSetClassName=OperationSetBasicTelephony.class.getName();
  if (supportedOperationSets.containsKey(telOpSetClassName)) {
    OperationSetBasicTelephony telephony=(OperationSetBasicTelephony)supportedOperationSets.get(telOpSetClassName);
    telephony.addCallListener(callManager);
    this.getContactListPanel().getContactList().addListSelectionListener(callManager);
    this.tabbedPane.addChangeListener(callManager);
  }
  String multiChatClassName=OperationSetMultiUserChat.class.getName();
  if (supportedOperationSets.containsKey(multiChatClassName)) {
    OperationSetMultiUserChat multiUserChat=(OperationSetMultiUserChat)supportedOperationSets.get(multiChatClassName);
    multiUserChat.addInvitationListener(multiUserChatManager);
    multiUserChat.addInvitationRejectionListener(multiUserChatManager);
    multiUserChat.addPresenceListener(multiUserChatManager);
    this.getChatRoomsListPanel().getChatRoomsList().addChatServer(protocolProvider,multiUserChat);
  }
}",0.9440029569395676
104340,"public void messageDelivered(MessageDeliveredEvent evt){
  Message msg=evt.getSourceMessage();
  Contact contact=evt.getDestinationContact();
  processMessage(contact.getDisplayName(),new Date(System.currentTimeMillis()),Constants.OUTGOING_MESSAGE,msg.getContent(),msg.getContentType());
  processMessage(contact.getDisplayName(),new Date(System.currentTimeMillis()),Constants.ACTION_MESSAGE,Messages.getI18NString(""String_Node_Str"").getText(),""String_Node_Str"");
  smsOpSet.removeMessageListener(this);
}","public void messageDelivered(MessageDeliveredEvent evt){
  Message msg=evt.getSourceMessage();
  if (sentSmsMessage == null || !sentSmsMessage.equals(msg))   return;
  sentSmsMessage=null;
  Contact contact=evt.getDestinationContact();
  processMessage(contact.getDisplayName(),new Date(System.currentTimeMillis()),Constants.OUTGOING_MESSAGE,msg.getContent(),msg.getContentType());
  processMessage(contact.getDisplayName(),new Date(System.currentTimeMillis()),Constants.ACTION_MESSAGE,Messages.getI18NString(""String_Node_Str"").getText(),""String_Node_Str"");
}",0.8740601503759399
104341,"public void messageDeliveryFailed(MessageDeliveryFailedEvent evt){
  logger.error(evt.getReason());
  String errorMsg=null;
  Message sourceMessage=(Message)evt.getSource();
  Contact sourceContact=evt.getDestinationContact();
  MetaContact metaContact=chatWindow.getMainFrame().getContactList().findMetaContactByContact(sourceContact);
  if (evt.getErrorCode() == MessageDeliveryFailedEvent.OFFLINE_MESSAGES_NOT_SUPPORTED) {
    errorMsg=Messages.getI18NString(""String_Node_Str"").getText();
  }
 else   if (evt.getErrorCode() == MessageDeliveryFailedEvent.NETWORK_FAILURE) {
    errorMsg=Messages.getI18NString(""String_Node_Str"").getText();
  }
 else   if (evt.getErrorCode() == MessageDeliveryFailedEvent.PROVIDER_NOT_REGISTERED) {
    errorMsg=Messages.getI18NString(""String_Node_Str"").getText();
  }
 else   if (evt.getErrorCode() == MessageDeliveryFailedEvent.INTERNAL_ERROR) {
    errorMsg=Messages.getI18NString(""String_Node_Str"").getText();
  }
 else {
    errorMsg=Messages.getI18NString(""String_Node_Str"").getText();
  }
  processMessage(metaContact.getDisplayName(),new Date(System.currentTimeMillis()),Constants.OUTGOING_MESSAGE,sourceMessage.getContent(),sourceMessage.getContentType());
  processMessage(metaContact.getDisplayName(),new Date(System.currentTimeMillis()),Constants.ERROR_MESSAGE,errorMsg,""String_Node_Str"");
  smsOpSet.removeMessageListener(this);
}","public void messageDeliveryFailed(MessageDeliveryFailedEvent evt){
  logger.error(evt.getReason());
  String errorMsg=null;
  Message sourceMessage=(Message)evt.getSource();
  if (sentSmsMessage == null || !sentSmsMessage.equals(sourceMessage))   return;
  sentSmsMessage=null;
  Contact sourceContact=evt.getDestinationContact();
  MetaContact metaContact=chatWindow.getMainFrame().getContactList().findMetaContactByContact(sourceContact);
  if (evt.getErrorCode() == MessageDeliveryFailedEvent.OFFLINE_MESSAGES_NOT_SUPPORTED) {
    errorMsg=Messages.getI18NString(""String_Node_Str"").getText();
  }
 else   if (evt.getErrorCode() == MessageDeliveryFailedEvent.NETWORK_FAILURE) {
    errorMsg=Messages.getI18NString(""String_Node_Str"").getText();
  }
 else   if (evt.getErrorCode() == MessageDeliveryFailedEvent.PROVIDER_NOT_REGISTERED) {
    errorMsg=Messages.getI18NString(""String_Node_Str"").getText();
  }
 else   if (evt.getErrorCode() == MessageDeliveryFailedEvent.INTERNAL_ERROR) {
    errorMsg=Messages.getI18NString(""String_Node_Str"").getText();
  }
 else {
    errorMsg=Messages.getI18NString(""String_Node_Str"").getText();
  }
  processMessage(metaContact.getDisplayName(),new Date(System.currentTimeMillis()),Constants.OUTGOING_MESSAGE,sourceMessage.getContent(),sourceMessage.getContentType());
  processMessage(metaContact.getDisplayName(),new Date(System.currentTimeMillis()),Constants.ERROR_MESSAGE,errorMsg,""String_Node_Str"");
}",0.948936170212766
104342,"private void sendSmsMessage(String text){
  OperationSetSmsMessaging smsOpSet=null;
  Iterator protocolProviders=chatWindow.getMainFrame().getProtocolProviders();
  while (protocolProviders.hasNext()) {
    ProtocolProviderService protocolProvider=(ProtocolProviderService)protocolProviders.next();
    smsOpSet=(OperationSetSmsMessaging)protocolProvider.getOperationSet(OperationSetSmsMessaging.class);
    if (smsOpSet != null)     break;
  }
  if (smsOpSet == null) {
    logger.error(""String_Node_Str"");
    this.refreshWriteArea();
    this.processMessage(metaContact.getDisplayName(),new Date(System.currentTimeMillis()),Constants.OUTGOING_MESSAGE,text,""String_Node_Str"");
    this.processMessage(metaContact.getDisplayName(),new Date(System.currentTimeMillis()),Constants.ERROR_MESSAGE,Messages.getI18NString(""String_Node_Str"").getText(),""String_Node_Str"");
    return;
  }
  smsOpSet.addMessageListener(new SmsMessageListener(smsOpSet));
  Message message=smsOpSet.createMessage(text);
  SendSmsDialog smsDialog=new SendSmsDialog(this,message,smsOpSet);
  smsDialog.setPreferredSize(new Dimension(400,200));
  smsDialog.setVisible(true);
}","private void sendSmsMessage(String text){
  OperationSetSmsMessaging smsOpSet=null;
  Iterator protocolProviders=chatWindow.getMainFrame().getProtocolProviders();
  while (protocolProviders.hasNext()) {
    ProtocolProviderService protocolProvider=(ProtocolProviderService)protocolProviders.next();
    smsOpSet=(OperationSetSmsMessaging)protocolProvider.getOperationSet(OperationSetSmsMessaging.class);
    if (smsOpSet != null)     break;
  }
  if (smsOpSet == null) {
    logger.error(""String_Node_Str"");
    this.refreshWriteArea();
    this.processMessage(metaContact.getDisplayName(),new Date(System.currentTimeMillis()),Constants.OUTGOING_MESSAGE,text,""String_Node_Str"");
    this.processMessage(metaContact.getDisplayName(),new Date(System.currentTimeMillis()),Constants.ERROR_MESSAGE,Messages.getI18NString(""String_Node_Str"").getText(),""String_Node_Str"");
    return;
  }
  smsOpSet.addMessageListener(new SmsMessageListener(smsOpSet));
  sentSmsMessage=smsOpSet.createMessage(text);
  SendSmsDialog smsDialog=new SendSmsDialog(this,sentSmsMessage,smsOpSet);
  smsDialog.setPreferredSize(new Dimension(400,200));
  smsDialog.setVisible(true);
}",0.9886956521739132
104343,"/** 
 * Sends the <tt>message</tt> to the destination indicated by the <tt>to</tt> contact.
 * @param to the <tt>Contact</tt> to send <tt>message</tt> to
 * @param message the <tt>Message</tt> to send.
 * @throws java.lang.IllegalStateException if the underlying stack isnot registered and initialized.
 * @throws java.lang.IllegalArgumentException if <tt>to</tt> is not aninstance of ContactImpl.
 */
public void sendInstantMessage(Contact to,Message message) throws IllegalStateException, IllegalArgumentException {
  if (!(to instanceof ContactSipImpl))   throw new IllegalArgumentException(""String_Node_Str"" + to);
  assertConnected();
  if (to.getPresenceStatus().equals(sipStatusEnum.getStatus(SipStatusEnum.OFFLINE)) && !offlineMessageSupported) {
    logger.debug(""String_Node_Str"");
    MessageDeliveryFailedEvent evt=new MessageDeliveryFailedEvent(message,to,MessageDeliveryFailedEvent.OFFLINE_MESSAGES_NOT_SUPPORTED,new Date());
    fireMessageEvent(evt);
    return;
  }
  Request mes;
  try {
    mes=createMessage(to,message);
  }
 catch (  OperationFailedException ex) {
    logger.error(""String_Node_Str"",ex);
    MessageDeliveryFailedEvent evt=new MessageDeliveryFailedEvent(message,to,MessageDeliveryFailedEvent.INTERNAL_ERROR,new Date());
    fireMessageEvent(evt);
    return;
  }
  sendRequestMessage(mes,to,message);
}","/** 
 * Sends the <tt>message</tt> to the destination indicated by the <tt>to</tt> contact.
 * @param to the <tt>Contact</tt> to send <tt>message</tt> to
 * @param message the <tt>Message</tt> to send.
 * @throws java.lang.IllegalStateException if the underlying stack isnot registered and initialized.
 * @throws java.lang.IllegalArgumentException if <tt>to</tt> is not aninstance of ContactImpl.
 */
public void sendInstantMessage(Contact to,Message message) throws IllegalStateException, IllegalArgumentException {
  if (!(to instanceof ContactSipImpl))   throw new IllegalArgumentException(""String_Node_Str"" + to);
  assertConnected();
  if (to.getPresenceStatus().equals(sipStatusEnum.getStatus(SipStatusEnum.OFFLINE)) && !offlineMessageSupported) {
    logger.debug(""String_Node_Str"");
    MessageDeliveryFailedEvent evt=new MessageDeliveryFailedEvent(message,to,MessageDeliveryFailedEvent.OFFLINE_MESSAGES_NOT_SUPPORTED,new Date());
    fireMessageEvent(evt);
    return;
  }
  Request mes;
  try {
    mes=createMessage(to,message);
  }
 catch (  OperationFailedException ex) {
    logger.error(""String_Node_Str"",ex);
    MessageDeliveryFailedEvent evt=new MessageDeliveryFailedEvent(message,to,MessageDeliveryFailedEvent.INTERNAL_ERROR,new Date());
    fireMessageEvent(evt);
    return;
  }
  try {
    sendRequestMessage(mes,to,message);
  }
 catch (  TransactionUnavailableException ex) {
    logger.error(""String_Node_Str"" + ""String_Node_Str"",ex);
    MessageDeliveryFailedEvent evt=new MessageDeliveryFailedEvent(message,to,MessageDeliveryFailedEvent.NETWORK_FAILURE,new Date());
    fireMessageEvent(evt);
    return;
  }
catch (  SipException ex) {
    logger.error(""String_Node_Str"",ex);
    MessageDeliveryFailedEvent evt=new MessageDeliveryFailedEvent(message,to,MessageDeliveryFailedEvent.INTERNAL_ERROR,new Date());
    fireMessageEvent(evt);
    return;
  }
}",0.832039739211425
104344,"void sendRequestMessage(Request mes,Contact to,Message message){
  CallIdHeader call=(CallIdHeader)mes.getHeader(CallIdHeader.NAME);
  String callid=call.getCallId();
  AuthorizationHeader authorization=sipProvider.getSipSecurityManager().getCachedAuthorizationHeader(callid);
  if (authorization != null)   mes.addHeader(authorization);
  ClientTransaction messageTransaction;
  SipProvider jainSipProvider=this.sipProvider.getDefaultJainSipProvider();
  try {
    messageTransaction=jainSipProvider.getNewClientTransaction(mes);
  }
 catch (  TransactionUnavailableException ex) {
    logger.error(""String_Node_Str"" + ""String_Node_Str"",ex);
    MessageDeliveryFailedEvent evt=new MessageDeliveryFailedEvent(message,to,MessageDeliveryFailedEvent.NETWORK_FAILURE,new Date());
    fireMessageEvent(evt);
    return;
  }
  try {
    messageTransaction.sendRequest();
  }
 catch (  SipException ex) {
    logger.error(""String_Node_Str"",ex);
    MessageDeliveryFailedEvent evt=new MessageDeliveryFailedEvent(message,to,MessageDeliveryFailedEvent.INTERNAL_ERROR,new Date());
    fireMessageEvent(evt);
    return;
  }
  String key=((CallIdHeader)mes.getHeader(CallIdHeader.NAME)).getCallId();
  this.sentMsg.put(key,message);
}","void sendRequestMessage(Request mes,Contact to,Message message) throws TransactionUnavailableException, SipException {
  CallIdHeader call=(CallIdHeader)mes.getHeader(CallIdHeader.NAME);
  String callid=call.getCallId();
  AuthorizationHeader authorization=sipProvider.getSipSecurityManager().getCachedAuthorizationHeader(callid);
  if (authorization != null)   mes.addHeader(authorization);
  ClientTransaction messageTransaction;
  SipProvider jainSipProvider=this.sipProvider.getDefaultJainSipProvider();
  messageTransaction=jainSipProvider.getNewClientTransaction(mes);
  messageTransaction.sendRequest();
  String key=((CallIdHeader)mes.getHeader(CallIdHeader.NAME)).getCallId();
  this.sentMsg.put(key,message);
}",0.6735324407826982
104345,"public void sendTypingNotification(Contact to,int typingState) throws IllegalStateException, IllegalArgumentException {
  assertConnected();
  if (!(to instanceof ContactSipImpl))   throw new IllegalArgumentException(""String_Node_Str"" + to);
  Document doc=opSetPersPresence.createDocument();
  Element rootEl=doc.createElementNS(NS_VALUE,""String_Node_Str"");
  rootEl.setAttribute(""String_Node_Str"",""String_Node_Str"");
  doc.appendChild(rootEl);
  if (typingState == STATE_TYPING) {
    Element state=doc.createElement(""String_Node_Str"");
    Node stateValue=doc.createTextNode(COMPOSING_STATE_ACTIVE);
    state.appendChild(stateValue);
    rootEl.appendChild(state);
    Element refresh=doc.createElement(""String_Node_Str"");
    Node refreshValue=doc.createTextNode(""String_Node_Str"");
    refresh.appendChild(refreshValue);
    rootEl.appendChild(refresh);
  }
 else   if (typingState == STATE_STOPPED) {
    Element state=doc.createElement(""String_Node_Str"");
    Node stateValue=doc.createTextNode(COMPOSING_STATE_IDLE);
    state.appendChild(stateValue);
    rootEl.appendChild(state);
  }
 else   return;
  Message message=opSetBasicIm.createMessage(new String(opSetPersPresence.convertDocument(doc)).getBytes(),CONTENT_TYPE,OperationSetBasicInstantMessaging.DEFAULT_MIME_ENCODING,null);
  Request mes;
  try {
    mes=opSetBasicIm.createMessage(to,message);
  }
 catch (  OperationFailedException ex) {
    logger.error(""String_Node_Str"",ex);
    return;
  }
  opSetBasicIm.sendRequestMessage(mes,to,message);
}","public void sendTypingNotification(Contact to,int typingState) throws IllegalStateException, IllegalArgumentException {
  assertConnected();
  if (!(to instanceof ContactSipImpl))   throw new IllegalArgumentException(""String_Node_Str"" + to);
  Document doc=opSetPersPresence.createDocument();
  Element rootEl=doc.createElementNS(NS_VALUE,""String_Node_Str"");
  rootEl.setAttribute(""String_Node_Str"",""String_Node_Str"");
  doc.appendChild(rootEl);
  if (typingState == STATE_TYPING) {
    Element state=doc.createElement(""String_Node_Str"");
    Node stateValue=doc.createTextNode(COMPOSING_STATE_ACTIVE);
    state.appendChild(stateValue);
    rootEl.appendChild(state);
    Element refresh=doc.createElement(""String_Node_Str"");
    Node refreshValue=doc.createTextNode(""String_Node_Str"");
    refresh.appendChild(refreshValue);
    rootEl.appendChild(refresh);
  }
 else   if (typingState == STATE_STOPPED) {
    Element state=doc.createElement(""String_Node_Str"");
    Node stateValue=doc.createTextNode(COMPOSING_STATE_IDLE);
    state.appendChild(stateValue);
    rootEl.appendChild(state);
  }
 else   return;
  Message message=opSetBasicIm.createMessage(new String(opSetPersPresence.convertDocument(doc)).getBytes(),CONTENT_TYPE,OperationSetBasicInstantMessaging.DEFAULT_MIME_ENCODING,null);
  Request mes;
  try {
    mes=opSetBasicIm.createMessage(to,message);
  }
 catch (  OperationFailedException ex) {
    logger.error(""String_Node_Str"",ex);
    return;
  }
  try {
    opSetBasicIm.sendRequestMessage(mes,to,message);
  }
 catch (  TransactionUnavailableException ex) {
    logger.error(""String_Node_Str"" + ""String_Node_Str"",ex);
    return;
  }
catch (  SipException ex) {
    logger.error(""String_Node_Str"",ex);
    return;
  }
}",0.9319018404907976
104346,"/** 
 * Indicates whether some other object is ""equal to"" this one. <p>
 * @param obj   the reference object with which to compare.
 * @return  <tt>true</tt> if this object is the same as the objargument; <tt>false</tt> otherwise.
 */
public boolean equals(Object obj){
  if (obj == null || !(obj instanceof ContactJabberImpl) || !(((ContactJabberImpl)obj).getAddress().equals(getAddress()) && ((ContactJabberImpl)obj).getProtocolProvider() == getProtocolProvider()))   return false;
  return true;
}","/** 
 * Indicates whether some other object is ""equal to"" this one. <p>
 * @param obj   the reference object with which to compare.
 * @return  <tt>true</tt> if this object is the same as the objargument; <tt>false</tt> otherwise.
 */
public boolean equals(Object obj){
  if (obj == null || !(obj instanceof ContactJabberImpl) || !(((ContactJabberImpl)obj).getAddress().equalsIgnoreCase(getAddress()) && ((ContactJabberImpl)obj).getProtocolProvider() == getProtocolProvider()))   return false;
  return true;
}",0.99009900990099
104347,"/** 
 * Returns the Contact with the specified id or null if no such id was found.
 * @param id the id of the contact to find.
 * @return the <tt>Contact</tt> carrying the specified<tt>screenName</tt> or <tt>null</tt> if no such contact exits.
 */
public ContactJabberImpl findContactById(String id){
  Iterator contactGroups=rootGroup.subgroups();
  ContactJabberImpl result=null;
  while (contactGroups.hasNext()) {
    ContactGroupJabberImpl contactGroup=(ContactGroupJabberImpl)contactGroups.next();
    result=contactGroup.findContact(id);
    if (result != null)     return result;
  }
  Iterator rootContacts=rootGroup.contacts();
  while (rootContacts.hasNext()) {
    ContactJabberImpl item=(ContactJabberImpl)rootContacts.next();
    if (item.getAddress().equals(id))     return item;
  }
  return null;
}","/** 
 * Returns the Contact with the specified id or null if no such id was found.
 * @param id the id of the contact to find.
 * @return the <tt>Contact</tt> carrying the specified<tt>screenName</tt> or <tt>null</tt> if no such contact exits.
 */
public ContactJabberImpl findContactById(String id){
  Iterator contactGroups=rootGroup.subgroups();
  ContactJabberImpl result=null;
  while (contactGroups.hasNext()) {
    ContactGroupJabberImpl contactGroup=(ContactGroupJabberImpl)contactGroups.next();
    result=contactGroup.findContact(id);
    if (result != null)     return result;
  }
  Iterator rootContacts=rootGroup.contacts();
  while (rootContacts.hasNext()) {
    ContactJabberImpl item=(ContactJabberImpl)rootContacts.next();
    if (item.getAddress().equalsIgnoreCase(id))     return item;
  }
  return null;
}",0.9939024390243902
104348,"public DialButton(CallManager manager,ImageIcon iconImage){
  super(iconImage);
  this.callManager=manager;
  this.setOpaque(false);
  this.setToolTipText(Messages.getI18NString(""String_Node_Str"").getText());
  dialpadDialog=new CallParticipantDialpadDialog(callManager,callParticipant);
  this.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (!dialpadDialog.isVisible()) {
        dialpadDialog.setLocation(callManager.getMainFrame().getX() + (callManager.getMainFrame().getWidth() - dialpadDialog.getWidth()) / 2,getLocationOnScreen().y + getHeight());
        dialpadDialog.setVisible(true);
      }
 else {
        dialpadDialog.setVisible(false);
      }
    }
  }
);
}","public DialButton(CallManager manager,ImageIcon iconImage){
  super(iconImage);
  this.callManager=manager;
  this.setOpaque(false);
  this.setToolTipText(Messages.getI18NString(""String_Node_Str"").getText());
  dialpadDialog=new CallParticipantDialpadDialog(callManager,callParticipant);
  this.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (!dialpadDialog.isVisible()) {
        dialpadDialog.setSize(callManager.getMainFrame().getWidth() - 20,dialpadDialog.getHeight());
        dialpadDialog.setLocation(callManager.getMainFrame().getX() + 10,getLocationOnScreen().y + getHeight());
        dialpadDialog.setVisible(true);
      }
 else {
        dialpadDialog.setVisible(false);
      }
    }
  }
);
}",0.8379287155346334
104349,"public void actionPerformed(ActionEvent e){
  if (!dialpadDialog.isVisible()) {
    dialpadDialog.setLocation(callManager.getMainFrame().getX() + (callManager.getMainFrame().getWidth() - dialpadDialog.getWidth()) / 2,getLocationOnScreen().y + getHeight());
    dialpadDialog.setVisible(true);
  }
 else {
    dialpadDialog.setVisible(false);
  }
}","public void actionPerformed(ActionEvent e){
  if (!dialpadDialog.isVisible()) {
    dialpadDialog.setSize(callManager.getMainFrame().getWidth() - 20,dialpadDialog.getHeight());
    dialpadDialog.setLocation(callManager.getMainFrame().getX() + 10,getLocationOnScreen().y + getHeight());
    dialpadDialog.setVisible(true);
  }
 else {
    dialpadDialog.setVisible(false);
  }
}",0.6721991701244814
104350,"/** 
 * Creates the selector box, containing all protocol statuses, adds it to the StatusPanel and refreshes the panel.
 * @param protocolProvider The protocol provider.
 */
public void addAccount(ProtocolProviderService protocolProvider){
  StatusSelectorBox protocolStatusCombo;
  int providerIndex=this.mainFrame.getProviderIndex(protocolProvider);
  if (mainFrame.getProtocolPresenceOpSet(protocolProvider) != null) {
    protocolStatusCombo=new PresenceStatusSelectorBox(this.mainFrame,protocolProvider,providerIndex);
  }
 else {
    protocolStatusCombo=new SimpleStatusSelectorBox(this.mainFrame,protocolProvider,providerIndex);
  }
  protocolStatusCombo.addComponentListener(this);
  boolean isHidden=protocolProvider.getAccountID().getAccountProperties().get(""String_Node_Str"") != null;
  if (isHidden)   hiddenProviders++;
  if (protocolStatusCombos.size() - hiddenProviders == 1) {
    this.globalStatusBox=new GlobalStatusSelectorBox(mainFrame);
    Icon statusSeparatorIcon=new ImageIcon(ImageLoader.getImage(ImageLoader.STATUS_SEPARATOR_ICON));
    this.add(new JLabel(statusSeparatorIcon),FlowLayout.LEFT);
    this.add(globalStatusBox,FlowLayout.LEFT);
  }
  this.protocolStatusCombos.put(protocolProvider,protocolStatusCombo);
  if (!isHidden) {
    this.add(protocolStatusCombo);
    this.getParent().validate();
  }
}","/** 
 * Creates the selector box, containing all protocol statuses, adds it to the StatusPanel and refreshes the panel.
 * @param protocolProvider The protocol provider.
 */
public void addAccount(ProtocolProviderService protocolProvider){
  StatusSelectorBox protocolStatusCombo;
  int providerIndex=this.mainFrame.getProviderIndex(protocolProvider);
  if (mainFrame.getProtocolPresenceOpSet(protocolProvider) != null) {
    protocolStatusCombo=new PresenceStatusSelectorBox(this.mainFrame,protocolProvider,providerIndex);
  }
 else {
    protocolStatusCombo=new SimpleStatusSelectorBox(this.mainFrame,protocolProvider,providerIndex);
  }
  protocolStatusCombo.addComponentListener(this);
  boolean isHidden=protocolProvider.getAccountID().getAccountProperties().get(""String_Node_Str"") != null;
  if (isHidden)   hiddenProviders++;
  if (protocolStatusCombos.size() - hiddenProviders == 1 && !isHidden) {
    this.globalStatusBox=new GlobalStatusSelectorBox(mainFrame);
    Icon statusSeparatorIcon=new ImageIcon(ImageLoader.getImage(ImageLoader.STATUS_SEPARATOR_ICON));
    this.add(new JLabel(statusSeparatorIcon),FlowLayout.LEFT);
    this.add(globalStatusBox,FlowLayout.LEFT);
  }
  this.protocolStatusCombos.put(protocolProvider,protocolStatusCombo);
  if (!isHidden) {
    this.add(protocolStatusCombo);
    this.getParent().validate();
  }
}",0.9951582867783983
104351,"/** 
 * Enables or disabled the call button according to the content in the combo box editor field.
 */
protected void handleChange(){
  String item=((CallComboEditor)this.getEditor()).getItem().toString();
  if (item.length() > 0) {
    callManager.setCallMetaContact(false);
    ContactList clist=this.callManager.getMainFrame().getContactListPanel().getContactList();
    clist.removeSelectionInterval(clist.getSelectedIndex(),clist.getSelectedIndex());
    callManager.getCallButton().setEnabled(true);
  }
 else {
    Object o=callManager.getMainFrame().getContactListPanel().getContactList().getSelectedValue();
    if (o == null || !(o instanceof MetaContact)) {
      callManager.getCallButton().setEnabled(false);
    }
  }
}","/** 
 * Enables or disabled the call button according to the content in the combo box editor field.
 */
protected void handleChange(){
  String item=((CallComboEditor)this.getEditor()).getItem().toString();
  if (item.length() > 0) {
    callManager.setCallMetaContact(false);
    ContactList clist=this.callManager.getMainFrame().getContactListPanel().getContactList();
    clist.removeSelectionInterval(clist.getSelectedIndex(),clist.getSelectedIndex());
    callManager.getCallButton().setEnabled(true);
  }
 else {
    Object o=callManager.getMainFrame().getContactListPanel().getContactList().getSelectedValue();
    boolean enabled=true;
    if (o == null || !(o instanceof MetaContact)) {
      enabled=false;
    }
    Component selectedPanel=callManager.getMainFrame().getSelectedTab();
    if (selectedPanel != null && selectedPanel instanceof CallPanel) {
      CallState state=((CallPanel)selectedPanel).getCall().getCallState();
      if (state == CallState.CALL_INITIALIZATION) {
        enabled=true;
      }
    }
    callManager.getCallButton().setEnabled(enabled);
  }
}",0.7903402854006586
104352,"public void stateChanged(ChangeEvent e){
  PluginManagerActivator.getConfigurationService().setProperty(""String_Node_Str"",new Boolean(showSysBundlesCheckBox.isSelected()));
  PluginTableModel tableModel=(PluginTableModel)pluginTable.getModel();
  tableModel.setShowSystemBundles(showSysBundlesCheckBox.isSelected());
  tableModel.update();
}","public void stateChanged(ChangeEvent e){
  if (currentValue == showSysBundlesCheckBox.isSelected()) {
    return;
  }
  currentValue=showSysBundlesCheckBox.isSelected();
  PluginManagerActivator.getConfigurationService().setProperty(""String_Node_Str"",new Boolean(showSysBundlesCheckBox.isSelected()));
  PluginTableModel tableModel=(PluginTableModel)pluginTable.getModel();
  tableModel.setShowSystemBundles(showSysBundlesCheckBox.isSelected());
  tableModel.update();
}",0.840937114673243
104353,"/** 
 * Creates an instance of <tt>CallListPanel</tt>.
 */
public CallListPanel(MainFrame mainFrame){
  super(new BorderLayout());
  this.mainFrame=mainFrame;
  this.callHistory=GuiActivator.getCallHistoryService();
  this.searchComboBox.addActionListener(this);
  new LoadLastCallsFromHistory().start();
  this.initPanels();
  this.initPluginComponents();
}","/** 
 * Creates an instance of <tt>CallListPanel</tt>.
 */
public CallListPanel(MainFrame mainFrame){
  super(new BorderLayout());
  this.mainFrame=mainFrame;
  this.callHistory=GuiActivator.getCallHistoryService();
  this.searchComboBox.addActionListener(this);
  new LoadLastCallsFromHistory().start();
  this.initPanels();
  this.initPluginComponents();
  this.setPreferredSize(new Dimension(200,450));
  this.setMinimumSize(new Dimension(80,200));
}",0.8828606658446363
104354,"/** 
 * Creates the scroll panel containing the chat rooms list.
 * @param frame the main application frame
 */
public ChatRoomsListPanel(MainFrame frame){
  this.mainFrame=frame;
  this.chatRoomsList=new ChatRoomsList(mainFrame);
  this.treePanel.add(chatRoomsList,BorderLayout.NORTH);
  this.treePanel.setOpaque(false);
  this.setViewport(new ScrollPaneBackground());
  this.getViewport().setView(treePanel);
  this.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  this.getVerticalScrollBar().setUnitIncrement(30);
  this.getActionMap().put(""String_Node_Str"",new ChatRoomsListPanelEnterAction());
  InputMap imap=this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW);
  imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER,0),""String_Node_Str"");
}","/** 
 * Creates the scroll panel containing the chat rooms list.
 * @param frame the main application frame
 */
public ChatRoomsListPanel(MainFrame frame){
  this.mainFrame=frame;
  this.chatRoomsList=new ChatRoomsList(mainFrame);
  this.treePanel.add(chatRoomsList,BorderLayout.NORTH);
  this.treePanel.setOpaque(false);
  this.setViewport(new ScrollPaneBackground());
  this.getViewport().setView(treePanel);
  this.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  this.getVerticalScrollBar().setUnitIncrement(30);
  this.getActionMap().put(""String_Node_Str"",new ChatRoomsListPanelEnterAction());
  InputMap imap=this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW);
  imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER,0),""String_Node_Str"");
  this.setPreferredSize(new Dimension(200,450));
  this.setMinimumSize(new Dimension(80,200));
}",0.941682013505218
104355,"/** 
 * Creates the contactlist scroll panel defining the parent frame.
 * @param mainFrame The parent frame.
 */
public ContactListPanel(MainFrame mainFrame){
  this.mainFrame=mainFrame;
  this.chatWindowManager=mainFrame.getChatWindowManager();
  this.treePanel.setOpaque(false);
  this.setViewport(new ScrollPaneBackground());
  this.getViewport().setView(treePanel);
  this.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  this.getVerticalScrollBar().setUnitIncrement(30);
  this.setPreferredSize(new Dimension(300,600));
  this.setMinimumSize(new Dimension(80,200));
}","/** 
 * Creates the contactlist scroll panel defining the parent frame.
 * @param mainFrame The parent frame.
 */
public ContactListPanel(MainFrame mainFrame){
  this.mainFrame=mainFrame;
  this.chatWindowManager=mainFrame.getChatWindowManager();
  this.treePanel.setOpaque(false);
  this.setViewport(new ScrollPaneBackground());
  this.getViewport().setView(treePanel);
  this.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  this.getVerticalScrollBar().setUnitIncrement(30);
  this.setPreferredSize(new Dimension(200,450));
  this.setMinimumSize(new Dimension(80,200));
}",0.9949664429530202
104356,"/** 
 * Creates an Message through the advance createMessage() method and inspects its parameters.
 */
public void testCreateMessage2(){
  String body=""String_Node_Str"" + ""String_Node_Str"" + new Date().toString();
  String contentType=""String_Node_Str"";
  String encoding=""String_Node_Str"";
  String subject=""String_Node_Str"";
  net.java.sip.communicator.service.protocol.Message msg=opSetBasicIM1.createMessage(body.getBytes(),contentType,encoding,subject);
  assertEquals(""String_Node_Str"",body,msg.getContent());
  assertTrue(""String_Node_Str"",Arrays.equals(body.getBytes(),msg.getRawData()));
  assertEquals(""String_Node_Str"",body.length(),msg.getSize());
  assertEquals(""String_Node_Str"",contentType,msg.getContentType());
  assertEquals(""String_Node_Str"",encoding,msg.getEncoding());
  assertNotNull(""String_Node_Str"",msg.getMessageUID());
  net.java.sip.communicator.service.protocol.Message msg2=opSetBasicIM1.createMessage(body);
  assertFalse(""String_Node_Str"",msg.getMessageUID().equals(msg2.getMessageUID()));
}","/** 
 * Creates an Message through the advance createMessage() method and inspects its parameters.
 */
public void testCreateMessage2(){
  String body=""String_Node_Str"" + ""String_Node_Str"" + new Date().toString();
  String contentType=""String_Node_Str"";
  String encoding=""String_Node_Str"";
  String subject=""String_Node_Str"";
  net.java.sip.communicator.service.protocol.Message msg=opSetBasicIM1.createMessage(body.getBytes(),contentType,encoding,subject);
  assertEquals(""String_Node_Str"",body,msg.getContent());
  assertEquals(""String_Node_Str"",encoding,msg.getEncoding());
  try {
    assertTrue(""String_Node_Str"",Arrays.equals(body.getBytes(encoding),msg.getRawData()));
    assertEquals(""String_Node_Str"",body.getBytes(encoding).length,msg.getSize());
  }
 catch (  UnsupportedEncodingException e) {
    logger.warn(""String_Node_Str"",e);
    assertTrue(""String_Node_Str"",Arrays.equals(body.getBytes(),msg.getRawData()));
    assertEquals(""String_Node_Str"",body.getBytes().length,msg.getSize());
  }
  assertEquals(""String_Node_Str"",contentType,msg.getContentType());
  assertNotNull(""String_Node_Str"",msg.getMessageUID());
  net.java.sip.communicator.service.protocol.Message msg2=opSetBasicIM1.createMessage(body);
  assertFalse(""String_Node_Str"",msg.getMessageUID().equals(msg2.getMessageUID()));
}",0.8266094420600858
104357,"public Packetizer(){
  packetSize=480;
  supportedInputFormats=new AudioFormat[]{new AudioFormat(AudioFormat.ALAW,Format.NOT_SPECIFIED,8,1,Format.NOT_SPECIFIED,Format.NOT_SPECIFIED,8,Format.NOT_SPECIFIED,Format.byteArray)};
  defaultOutputFormats=new AudioFormat[]{new AudioFormat(AudioFormat.ALAW,Format.NOT_SPECIFIED,8,1,Format.NOT_SPECIFIED,Format.NOT_SPECIFIED,8,Format.NOT_SPECIFIED,Format.byteArray)};
  PLUGIN_NAME=""String_Node_Str"";
}","public Packetizer(){
  packetSize=160;
  supportedInputFormats=new AudioFormat[]{new AudioFormat(AudioFormat.ALAW,Format.NOT_SPECIFIED,8,1,Format.NOT_SPECIFIED,Format.NOT_SPECIFIED,8,Format.NOT_SPECIFIED,Format.byteArray)};
  defaultOutputFormats=new AudioFormat[]{new AudioFormat(AudioFormat.ALAW,Format.NOT_SPECIFIED,8,1,Format.NOT_SPECIFIED,Format.NOT_SPECIFIED,8,Format.NOT_SPECIFIED,Format.byteArray)};
  PLUGIN_NAME=""String_Node_Str"";
}",0.995475113122172
104358,"/** 
 * Create an instance of the <tt>QuickMenu</tt>.
 * @param mainFrame The parent <tt>MainFrame</tt> window.
 */
public QuickMenu(MainFrame mainFrame){
  this.mainFrame=mainFrame;
  this.setRollover(true);
  this.setLayout(new FlowLayout(FlowLayout.LEFT,2,0));
  this.setBorder(BorderFactory.createEmptyBorder(0,5,5,5));
  this.setFloatable(true);
  this.infoButton.setPreferredSize(new Dimension(28,28));
  this.configureButton.setPreferredSize(new Dimension(28,28));
  this.searchButton.setPreferredSize(new Dimension(28,28));
  this.addButton.setPreferredSize(new Dimension(28,28));
  this.soundButton.setPreferredSize(new Dimension(28,28));
  this.infoButton.setToolTipText(Messages.getI18NString(""String_Node_Str"").getText());
  this.configureButton.setToolTipText(Messages.getI18NString(""String_Node_Str"").getText());
  this.searchButton.setToolTipText(Messages.getI18NString(""String_Node_Str"").getText());
  this.addButton.setToolTipText(Messages.getI18NString(""String_Node_Str"").getText());
  this.soundButton.setToolTipText(Messages.getI18NString(""String_Node_Str"").getText());
  this.updateMuteButton(GuiActivator.getAudioNotifier().isMute());
  this.init();
}","/** 
 * Create an instance of the <tt>QuickMenu</tt>.
 * @param mainFrame The parent <tt>MainFrame</tt> window.
 */
public QuickMenu(MainFrame mainFrame){
  this.mainFrame=mainFrame;
  this.setRollover(true);
  this.setLayout(new FlowLayout(FlowLayout.LEFT,2,0));
  this.setBorder(BorderFactory.createEmptyBorder(0,5,5,5));
  this.setFloatable(true);
  this.infoButton.setPreferredSize(new Dimension(BUTTON_SIZE,BUTTON_SIZE));
  this.configureButton.setPreferredSize(new Dimension(BUTTON_SIZE,BUTTON_SIZE));
  this.searchButton.setPreferredSize(new Dimension(BUTTON_SIZE,BUTTON_SIZE));
  this.addButton.setPreferredSize(new Dimension(BUTTON_SIZE,BUTTON_SIZE));
  this.soundButton.setPreferredSize(new Dimension(BUTTON_SIZE,BUTTON_SIZE));
  this.infoButton.setToolTipText(Messages.getI18NString(""String_Node_Str"").getText());
  this.configureButton.setToolTipText(Messages.getI18NString(""String_Node_Str"").getText());
  this.searchButton.setToolTipText(Messages.getI18NString(""String_Node_Str"").getText());
  this.addButton.setToolTipText(Messages.getI18NString(""String_Node_Str"").getText());
  this.soundButton.setToolTipText(Messages.getI18NString(""String_Node_Str"").getText());
  this.updateMuteButton(GuiActivator.getAudioNotifier().isMute());
  this.init();
}",0.9466338259441708
104359,"/** 
 * Implements ComponentListener.componentMoved method in order to resize the toolbar when buttons are aligned on more than one row.
 */
public void componentMoved(ComponentEvent e){
  int compCount=this.getComponentCount();
  int buttonHeight=this.infoButton.getHeight();
  int biggestY=0;
  for (int i=0; i < compCount; i++) {
    Component c=this.getComponent(i);
    if (c instanceof JButton) {
      if (c.getY() > biggestY)       biggestY=c.getY();
    }
  }
  this.setPreferredSize(new Dimension(this.getWidth(),biggestY + buttonHeight));
  ((JPanel)this.getParent()).revalidate();
  ((JPanel)this.getParent()).repaint();
}","/** 
 * Implements ComponentListener.componentMoved method in order to resize the toolbar when buttons are aligned on more than one row.
 */
public void componentMoved(ComponentEvent e){
  int compCount=this.getComponentCount();
  int biggestY=0;
  for (int i=0; i < compCount; i++) {
    Component c=this.getComponent(i);
    if (c instanceof JButton) {
      if (c.getY() > biggestY)       biggestY=c.getY();
    }
  }
  this.setPreferredSize(new Dimension(this.getWidth(),biggestY + BUTTON_SIZE));
  ((JPanel)this.getParent()).revalidate();
  ((JPanel)this.getParent()).repaint();
}",0.9417555373256769
104360,"/** 
 * Returns all <tt>OperationSetWhiteboarding</tt>s obtained from the bundle context.
 * @return all <tt>OperationSetWhiteboarding</tt>s obtained from the bundlecontext
 */
public static List getWhiteboardOperationSets(){
  List whiteboardOpSets=new ArrayList();
  ServiceReference[] serRefs=null;
  try {
    serRefs=bundleContext.getServiceReferences(ProtocolProviderService.class.getName(),null);
  }
 catch (  InvalidSyntaxException e) {
    logger.error(""String_Node_Str"" + e);
  }
  for (int i=0; i < serRefs.length; i++) {
    ProtocolProviderService protocolProvider=(ProtocolProviderService)bundleContext.getService(serRefs[i]);
    OperationSet opSet=protocolProvider.getOperationSet(OperationSetWhiteboarding.class);
    if (opSet != null)     whiteboardOpSets.add(opSet);
  }
  return whiteboardOpSets;
}","/** 
 * Returns all <tt>OperationSetWhiteboarding</tt>s obtained from the bundle context.
 * @return all <tt>OperationSetWhiteboarding</tt>s obtained from the bundlecontext
 */
public static List getWhiteboardOperationSets(){
  List whiteboardOpSets=new ArrayList();
  ServiceReference[] serRefs=null;
  try {
    serRefs=bundleContext.getServiceReferences(ProtocolProviderService.class.getName(),null);
  }
 catch (  InvalidSyntaxException e) {
    logger.error(""String_Node_Str"" + e);
  }
  if (serRefs == null)   return null;
  for (int i=0; i < serRefs.length; i++) {
    ProtocolProviderService protocolProvider=(ProtocolProviderService)bundleContext.getService(serRefs[i]);
    OperationSet opSet=protocolProvider.getOperationSet(OperationSetWhiteboarding.class);
    if (opSet != null)     whiteboardOpSets.add(opSet);
  }
  return whiteboardOpSets;
}",0.9773539928486292
104361,"/** 
 * Implements the <tt>WhiteboardSessionPresenceListener .whiteboardSessionPresenceChanged</tt> method.
 */
public void whiteboardSessionPresenceChanged(WhiteboardSessionPresenceChangeEvent evt){
  WhiteboardSession whiteboardSession=evt.getWhiteboardSession();
  if (evt.getEventType().equals(WhiteboardSessionPresenceChangeEvent.LOCAL_USER_JOINED)) {
    whiteboardSession.addWhiteboardObjectListener(WhiteboardSessionManager.this);
    WhiteboardFrame frame=getWhiteboardFrame(evt.getWhiteboardSession());
    if (frame == null) {
      frame=new WhiteboardFrame(WhiteboardSessionManager.this,whiteboardSession);
      frame.setVisible(true);
      wbFrames.add(frame);
    }
  }
 else   if (evt.getEventType().equals(WhiteboardSessionPresenceChangeEvent.LOCAL_USER_JOIN_FAILED)) {
    WhiteboardActivator.getUiService().getPopupDialog().showMessagePopupDialog(Resources.getString(""String_Node_Str"",new String[]{whiteboardSession.getWhiteboardID()}) + evt.getReason(),Resources.getString(""String_Node_Str""),PopupDialog.ERROR_MESSAGE);
  }
 else   if (evt.getEventType().equals(WhiteboardSessionPresenceChangeEvent.LOCAL_USER_LEFT)) {
    WhiteboardFrame frame=getWhiteboardFrame(whiteboardSession);
    if (frame == null)     return;
    frame.dispose();
    whiteboardSession.removeWhiteboardObjectListener(WhiteboardSessionManager.this);
  }
 else   if (evt.getEventType().equals(WhiteboardSessionPresenceChangeEvent.LOCAL_USER_KICKED)) {
  }
 else   if (evt.getEventType().equals(WhiteboardSessionPresenceChangeEvent.LOCAL_USER_DROPPED)) {
  }
}","/** 
 * Implements the <tt>WhiteboardSessionPresenceListener .whiteboardSessionPresenceChanged</tt> method.
 */
public void whiteboardSessionPresenceChanged(WhiteboardSessionPresenceChangeEvent evt){
  WhiteboardSession whiteboardSession=evt.getWhiteboardSession();
  if (evt.getEventType().equals(WhiteboardSessionPresenceChangeEvent.LOCAL_USER_JOINED)) {
    whiteboardSession.addWhiteboardObjectListener(WhiteboardSessionManager.this);
    WhiteboardFrame frame=getWhiteboardFrame(evt.getWhiteboardSession());
    if (frame == null) {
      frame=new WhiteboardFrame(WhiteboardSessionManager.this,whiteboardSession);
      frame.setVisible(true);
      wbFrames.add(frame);
    }
  }
 else   if (evt.getEventType().equals(WhiteboardSessionPresenceChangeEvent.LOCAL_USER_JOIN_FAILED)) {
    WhiteboardActivator.getUiService().getPopupDialog().showMessagePopupDialog(Resources.getString(""String_Node_Str"",new String[]{whiteboardSession.getWhiteboardID()}) + evt.getReason(),Resources.getString(""String_Node_Str""),PopupDialog.ERROR_MESSAGE);
  }
 else   if (evt.getEventType().equals(WhiteboardSessionPresenceChangeEvent.LOCAL_USER_LEFT)) {
    WhiteboardFrame frame=getWhiteboardFrame(whiteboardSession);
    if (frame == null)     return;
    wbFrames.remove(frame);
    frame.dispose();
    whiteboardSession.removeWhiteboardObjectListener(WhiteboardSessionManager.this);
  }
 else   if (evt.getEventType().equals(WhiteboardSessionPresenceChangeEvent.LOCAL_USER_KICKED)) {
  }
 else   if (evt.getEventType().equals(WhiteboardSessionPresenceChangeEvent.LOCAL_USER_DROPPED)) {
  }
}",0.9910771191841936
104362,"public WhiteboardSessionManager(){
  Iterator opSets=WhiteboardActivator.getWhiteboardOperationSets().iterator();
  while (opSets.hasNext()) {
    OperationSetWhiteboarding whiteboardOpSet=(OperationSetWhiteboarding)opSets.next();
    whiteboardOpSet.addInvitationListener(new InvitationListener());
    whiteboardOpSet.addPresenceListener(new PresenceListener());
  }
}","public WhiteboardSessionManager(){
  if (WhiteboardActivator.getWhiteboardOperationSets() == null)   return;
  Iterator opSets=WhiteboardActivator.getWhiteboardOperationSets().iterator();
  while (opSets.hasNext()) {
    OperationSetWhiteboarding whiteboardOpSet=(OperationSetWhiteboarding)opSets.next();
    whiteboardOpSet.addInvitationListener(new InvitationListener());
    whiteboardOpSet.addPresenceListener(new PresenceListener());
  }
}",0.8427518427518428
104363,"/** 
 * Creates an instance of this Message with the specified parameters.
 * @param content the text content of the message.
 * @param contentType a MIME string indicating the content type of the<tt>content</tt> String.
 * @param contentEncoding a MIME String indicating the content encoding ofthe <tt>content</tt> String.
 * @param subject the subject of the message or null for empty.
 */
public MessageSipImpl(String content,String contentType,String contentEncoding,String subject){
  this.textContent=content;
  this.contentType=contentType;
  this.contentEncoding=contentEncoding;
  this.subject=subject;
  this.messageUID=String.valueOf(System.currentTimeMillis()) + String.valueOf(hashCode());
}","/** 
 * Creates an instance of this Message with the specified parameters.
 * @param content the text content of the message.
 * @param contentType a MIME string indicating the content type of the<tt>content</tt> String.
 * @param contentEncoding a MIME String indicating the content encoding ofthe <tt>content</tt> String.
 * @param subject the subject of the message or null for empty.
 */
public MessageSipImpl(String content,String contentType,String contentEncoding,String subject){
  this.textContent=content;
  this.contentType=contentType;
  this.contentEncoding=contentEncoding;
  this.subject=subject;
  try {
    this.rawContent=content.getBytes(contentEncoding);
  }
 catch (  UnsupportedEncodingException ex) {
    logger.warn(""String_Node_Str"",ex);
    this.contentEncoding=Charset.defaultCharset().name();
    this.rawContent=content.getBytes();
  }
  this.messageUID=String.valueOf(System.currentTimeMillis()) + String.valueOf(hashCode());
}",0.847682119205298
104364,"/** 
 * Returns the size of the content stored in this message.
 * @return an int indicating the number of bytes that this messagecontains.
 */
public int getSize(){
  return getContent().length();
}","/** 
 * Returns the size of the content stored in this message.
 * @return an int indicating the number of bytes that this messagecontains.
 */
public int getSize(){
  return rawContent.length;
}",0.9746192893401016
104365,"/** 
 * Get the raw/binary content of an instant message.
 * @return a byte[] array containing message bytes.
 */
public byte[] getRawData(){
  return getContent().getBytes();
}","/** 
 * Get the raw/binary content of an instant message.
 * @return a byte[] array containing message bytes.
 */
public byte[] getRawData(){
  return rawContent;
}",0.9442815249266864
104366,"/** 
 * Construct a Request which represent a new message
 * @param to the <tt>Contact</tt> to send <tt>message</tt> to
 * @param message the <tt>Message</tt> to send.
 * @return a Message Request destinated to the contact
 * @throws OperationFailedException if an error occured duringthe creation of the request
 */
private Request createMessage(Contact to,Message message) throws OperationFailedException {
  InetAddress destinationInetAddress=null;
  Address toAddress=null;
  try {
    toAddress=parseAddressStr(to.getAddress());
    destinationInetAddress=InetAddress.getByName(((SipURI)toAddress.getURI()).getHost());
  }
 catch (  UnknownHostException ex) {
    throw new IllegalArgumentException(((SipURI)toAddress.getURI()).getHost() + ""String_Node_Str"" + ex.getMessage());
  }
catch (  ParseException exc) {
    logger.error(""String_Node_Str"" + ""String_Node_Str"",exc);
    throw new OperationFailedException(""String_Node_Str"" + ""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,exc);
  }
  CallIdHeader callIdHeader=this.sipProvider.getDefaultJainSipProvider().getNewCallId();
  CSeqHeader cSeqHeader=null;
  try {
    cSeqHeader=this.sipProvider.getHeaderFactory().createCSeqHeader(seqN++,Request.MESSAGE);
  }
 catch (  InvalidArgumentException ex) {
    logger.error(""String_Node_Str"" + ""String_Node_Str"",ex);
    throw new OperationFailedException(""String_Node_Str"" + ""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,ex);
  }
catch (  ParseException exc) {
    logger.error(""String_Node_Str"" + ""String_Node_Str"",exc);
    throw new OperationFailedException(""String_Node_Str"" + ""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,exc);
  }
  String localTag=ProtocolProviderServiceSipImpl.generateLocalTag();
  FromHeader fromHeader=null;
  ToHeader toHeader=null;
  try {
    fromHeader=this.sipProvider.getHeaderFactory().createFromHeader(this.sipProvider.getOurSipAddress(),localTag);
    toHeader=this.sipProvider.getHeaderFactory().createToHeader(toAddress,null);
  }
 catch (  ParseException ex) {
    logger.error(""String_Node_Str"" + ""String_Node_Str"",ex);
    throw new OperationFailedException(""String_Node_Str"" + ""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,ex);
  }
  ArrayList viaHeaders=this.sipProvider.getLocalViaHeaders(destinationInetAddress,this.sipProvider.getDefaultListeningPoint());
  MaxForwardsHeader maxForwards=this.sipProvider.getMaxForwardsHeader();
  ContentTypeHeader contTypeHeader;
  ContentLengthHeader contLengthHeader;
  try {
    contTypeHeader=this.sipProvider.getHeaderFactory().createContentTypeHeader(getType(message),getSubType(message));
    if (!DEFAULT_MIME_ENCODING.equalsIgnoreCase(message.getEncoding()))     contTypeHeader.setParameter(""String_Node_Str"",message.getEncoding());
    contLengthHeader=this.sipProvider.getHeaderFactory().createContentLengthHeader(message.getSize());
  }
 catch (  ParseException ex) {
    logger.error(""String_Node_Str"" + ""String_Node_Str"",ex);
    throw new OperationFailedException(""String_Node_Str"" + ""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,ex);
  }
catch (  InvalidArgumentException exc) {
    logger.error(""String_Node_Str"" + ""String_Node_Str"",exc);
    throw new OperationFailedException(""String_Node_Str"" + ""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,exc);
  }
  Request req;
  try {
    req=this.sipProvider.getMessageFactory().createRequest(toHeader.getAddress().getURI(),Request.MESSAGE,callIdHeader,cSeqHeader,fromHeader,toHeader,viaHeaders,maxForwards,contTypeHeader,message.getContent().getBytes());
  }
 catch (  ParseException ex) {
    logger.error(""String_Node_Str"",ex);
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,ex);
  }
  req.addHeader(contLengthHeader);
  return req;
}","/** 
 * Construct a Request which represent a new message
 * @param to the <tt>Contact</tt> to send <tt>message</tt> to
 * @param message the <tt>Message</tt> to send.
 * @return a Message Request destinated to the contact
 * @throws OperationFailedException if an error occured duringthe creation of the request
 */
private Request createMessage(Contact to,Message message) throws OperationFailedException {
  InetAddress destinationInetAddress=null;
  Address toAddress=null;
  try {
    toAddress=parseAddressStr(to.getAddress());
    destinationInetAddress=InetAddress.getByName(((SipURI)toAddress.getURI()).getHost());
  }
 catch (  UnknownHostException ex) {
    throw new IllegalArgumentException(((SipURI)toAddress.getURI()).getHost() + ""String_Node_Str"" + ex.getMessage());
  }
catch (  ParseException exc) {
    logger.error(""String_Node_Str"" + ""String_Node_Str"",exc);
    throw new OperationFailedException(""String_Node_Str"" + ""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,exc);
  }
  CallIdHeader callIdHeader=this.sipProvider.getDefaultJainSipProvider().getNewCallId();
  CSeqHeader cSeqHeader=null;
  try {
    cSeqHeader=this.sipProvider.getHeaderFactory().createCSeqHeader(seqN++,Request.MESSAGE);
  }
 catch (  InvalidArgumentException ex) {
    logger.error(""String_Node_Str"" + ""String_Node_Str"",ex);
    throw new OperationFailedException(""String_Node_Str"" + ""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,ex);
  }
catch (  ParseException exc) {
    logger.error(""String_Node_Str"" + ""String_Node_Str"",exc);
    throw new OperationFailedException(""String_Node_Str"" + ""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,exc);
  }
  String localTag=ProtocolProviderServiceSipImpl.generateLocalTag();
  FromHeader fromHeader=null;
  ToHeader toHeader=null;
  try {
    fromHeader=this.sipProvider.getHeaderFactory().createFromHeader(this.sipProvider.getOurSipAddress(),localTag);
    toHeader=this.sipProvider.getHeaderFactory().createToHeader(toAddress,null);
  }
 catch (  ParseException ex) {
    logger.error(""String_Node_Str"" + ""String_Node_Str"",ex);
    throw new OperationFailedException(""String_Node_Str"" + ""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,ex);
  }
  ArrayList viaHeaders=this.sipProvider.getLocalViaHeaders(destinationInetAddress,this.sipProvider.getDefaultListeningPoint());
  MaxForwardsHeader maxForwards=this.sipProvider.getMaxForwardsHeader();
  ContentTypeHeader contTypeHeader;
  ContentLengthHeader contLengthHeader;
  try {
    contTypeHeader=this.sipProvider.getHeaderFactory().createContentTypeHeader(getType(message),getSubType(message));
    if (!DEFAULT_MIME_ENCODING.equalsIgnoreCase(message.getEncoding()))     contTypeHeader.setParameter(""String_Node_Str"",message.getEncoding());
    contLengthHeader=this.sipProvider.getHeaderFactory().createContentLengthHeader(message.getSize());
  }
 catch (  ParseException ex) {
    logger.error(""String_Node_Str"" + ""String_Node_Str"",ex);
    throw new OperationFailedException(""String_Node_Str"" + ""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,ex);
  }
catch (  InvalidArgumentException exc) {
    logger.error(""String_Node_Str"" + ""String_Node_Str"",exc);
    throw new OperationFailedException(""String_Node_Str"" + ""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,exc);
  }
  Request req;
  try {
    req=this.sipProvider.getMessageFactory().createRequest(toHeader.getAddress().getURI(),Request.MESSAGE,callIdHeader,cSeqHeader,fromHeader,toHeader,viaHeaders,maxForwards,contTypeHeader,message.getRawData());
  }
 catch (  ParseException ex) {
    logger.error(""String_Node_Str"",ex);
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,ex);
  }
  req.addHeader(contLengthHeader);
  return req;
}",0.9967092273265764
104367,"/** 
 * Indicates whether the user is Online, available and eager to communicatie (can be reached and is likely to become annoyngly talkative if contacted).
 * @return true if the the status coefficient is higher than theEAGER_TO_COMMUNICATE_THRESHOLD and false otherwise
 */
public boolean isEagerToCommunicate(){
  return getStatus() >= EAGER_TO_COMMUNICATE_THRESHOLD;
}","/** 
 * Indicates whether the user is Online, available and eager to communicatie (can be reached and is likely to become annoyngly talkative if contacted).
 * @return true if the the status coefficient is higher than theEAGER_TO_COMMUNICATE_THRESHOLD and false otherwise
 */
public boolean isEagerToCommunicate(){
  return getStatus() >= EAGER_TO_COMMUNICATE_THRESSHOLD;
}",0.9986577181208054
104368,"public void run(){
  if (Constants.REMOVE_CONTACT_ASK) {
    String message=""String_Node_Str"" + this.group.getGroupName() + ""String_Node_Str"";
    MessageDialog dialog=new MessageDialog(mainFrame,message,Messages.getI18NString(""String_Node_Str"").getText());
    dialog.setTitle(Messages.getI18NString(""String_Node_Str"").getText());
    int returnCode=dialog.showDialog();
    if (returnCode == MessageDialog.OK_RETURN_CODE) {
      mainFrame.getContactList().removeMetaContactGroup(group);
    }
 else     if (returnCode == MessageDialog.OK_DONT_ASK_CODE) {
      mainFrame.getContactList().removeMetaContactGroup(group);
      Constants.REMOVE_CONTACT_ASK=false;
    }
  }
 else {
    mainFrame.getContactList().removeMetaContactGroup(group);
  }
}","public void run(){
  if (Constants.REMOVE_CONTACT_ASK) {
    String message=""String_Node_Str"" + this.group.getGroupName() + ""String_Node_Str"";
    MessageDialog dialog=new MessageDialog(mainFrame,Messages.getI18NString(""String_Node_Str"").getText(),message,Messages.getI18NString(""String_Node_Str"").getText());
    int returnCode=dialog.showDialog();
    if (returnCode == MessageDialog.OK_RETURN_CODE) {
      mainFrame.getContactList().removeMetaContactGroup(group);
    }
 else     if (returnCode == MessageDialog.OK_DONT_ASK_CODE) {
      mainFrame.getContactList().removeMetaContactGroup(group);
      Constants.REMOVE_CONTACT_ASK=false;
    }
  }
 else {
    mainFrame.getContactList().removeMetaContactGroup(group);
  }
}",0.97289972899729
104369,"/** 
 * Unregisters the contained protocol provider and process all possible errors that may occur during the un-registration process.
 */
public void run(){
  try {
    protocolProvider.unregister();
  }
 catch (  OperationFailedException ex) {
    int errorCode=ex.getErrorCode();
    if (errorCode == OperationFailedException.GENERAL_ERROR) {
      logger.error(""String_Node_Str"" + ""String_Node_Str"" + ex);
    }
 else     if (errorCode == OperationFailedException.INTERNAL_ERROR) {
      logger.error(""String_Node_Str"" + ""String_Node_Str"" + ex);
    }
 else     if (errorCode == OperationFailedException.NETWORK_FAILURE) {
      logger.error(""String_Node_Str"" + ""String_Node_Str"" + ex);
    }
    new ErrorDialog(mainFrame,Messages.getI18NString(""String_Node_Str"",new String[]{protocolProvider.getAccountID().getUserID(),protocolProvider.getAccountID().getService()}).getText(),Messages.getI18NString(""String_Node_Str"").getText()).showDialog();
  }
}","/** 
 * Unregisters the contained protocol provider and process all possible errors that may occur during the un-registration process.
 */
public void run(){
  try {
    protocolProvider.unregister();
  }
 catch (  OperationFailedException ex) {
    int errorCode=ex.getErrorCode();
    if (errorCode == OperationFailedException.GENERAL_ERROR) {
      logger.error(""String_Node_Str"" + ""String_Node_Str"" + ex);
    }
 else     if (errorCode == OperationFailedException.INTERNAL_ERROR) {
      logger.error(""String_Node_Str"" + ""String_Node_Str"" + ex);
    }
 else     if (errorCode == OperationFailedException.NETWORK_FAILURE) {
      logger.error(""String_Node_Str"" + ""String_Node_Str"" + ex);
    }
    new ErrorDialog(mainFrame,Messages.getI18NString(""String_Node_Str"").getText(),Messages.getI18NString(""String_Node_Str"",new String[]{protocolProvider.getAccountID().getUserID(),protocolProvider.getAccountID().getService()}).getText()).showDialog();
  }
}",0.9454926624737946
104370,"/** 
 * The method is called by a ProtocolProvider implementation whenever a change in the registration state of the corresponding provider had occurred.
 * @param evt ProviderStatusChangeEvent the event describing the statuschange.
 */
public void registrationStateChanged(RegistrationStateChangeEvent evt){
  ProtocolProviderService protocolProvider=evt.getProvider();
  AccountID accountID=protocolProvider.getAccountID();
  logger.trace(""String_Node_Str"" + protocolProvider + ""String_Node_Str""+ evt.getNewState().getStateName());
  OperationSetPresence presence=mainFrame.getProtocolPresenceOpSet(protocolProvider);
  OperationSetMultiUserChat multiUserChat=mainFrame.getMultiUserChatOpSet(protocolProvider);
  if (evt.getNewState().equals(RegistrationState.REGISTERED)) {
    this.mainFrame.getStatusPanel().updateStatus(protocolProvider);
    if (mainFrame.getCallManager().containsCallAccount(protocolProvider)) {
      this.mainFrame.getCallManager().updateCallAccountStatus(protocolProvider);
    }
    if (presence != null) {
      presence.setAuthorizationHandler(new AuthorizationHandlerImpl(mainFrame));
    }
    if (multiUserChat != null) {
      mainFrame.getChatRoomsListPanel().getChatRoomsList().synchronizeOpSetWithLocalContactList(protocolProvider,multiUserChat);
    }
  }
 else   if (evt.getNewState().equals(RegistrationState.AUTHENTICATION_FAILED)) {
    this.mainFrame.getStatusPanel().updateStatus(evt.getProvider());
    if (evt.getReasonCode() == RegistrationStateChangeEvent.REASON_RECONNECTION_RATE_LIMIT_EXCEEDED) {
      String msgText=Messages.getI18NString(""String_Node_Str"",new String[]{accountID.getUserID(),accountID.getService()}).getText();
      new ErrorDialog(null,msgText,Messages.getI18NString(""String_Node_Str"").getText()).showDialog();
    }
 else     if (evt.getReasonCode() == RegistrationStateChangeEvent.REASON_NON_EXISTING_USER_ID) {
      String msgText=Messages.getI18NString(""String_Node_Str"",new String[]{protocolProvider.getProtocolName()}).getText();
      new ErrorDialog(null,msgText,Messages.getI18NString(""String_Node_Str"").getText()).showDialog();
    }
 else     if (evt.getReasonCode() == RegistrationStateChangeEvent.REASON_AUTHENTICATION_FAILED) {
      String msgText=Messages.getI18NString(""String_Node_Str"",new String[]{accountID.getUserID(),accountID.getService()}).getText();
      new ErrorDialog(null,msgText,Messages.getI18NString(""String_Node_Str"").getText()).showDialog();
    }
    logger.error(evt.getReason());
  }
 else   if (evt.getNewState().equals(RegistrationState.CONNECTION_FAILED)) {
    this.mainFrame.getStatusPanel().updateStatus(evt.getProvider());
    String msgText=Messages.getI18NString(""String_Node_Str"",new String[]{accountID.getUserID(),accountID.getService()}).getText();
    new ErrorDialog(null,msgText,Messages.getI18NString(""String_Node_Str"").getText()).showDialog();
    logger.error(evt.getReason());
  }
 else   if (evt.getNewState().equals(RegistrationState.EXPIRED)) {
    this.mainFrame.getStatusPanel().updateStatus(evt.getProvider());
    String msgText=Messages.getI18NString(""String_Node_Str"",new String[]{protocolProvider.getProtocolName()}).getText();
    new ErrorDialog(null,msgText,Messages.getI18NString(""String_Node_Str"").getText()).showDialog();
    logger.error(evt.getReason());
  }
 else   if (evt.getNewState().equals(RegistrationState.UNREGISTERED)) {
    this.mainFrame.getStatusPanel().updateStatus(evt.getProvider());
    if (mainFrame.getCallManager().containsCallAccount(protocolProvider)) {
      this.mainFrame.getCallManager().updateCallAccountStatus(protocolProvider);
    }
    if (!manuallyDisconnected) {
      if (evt.getReasonCode() == RegistrationStateChangeEvent.REASON_MULTIPLE_LOGINS) {
        String msgText=Messages.getI18NString(""String_Node_Str"",new String[]{accountID.getUserID(),accountID.getService()}).getText();
        new ErrorDialog(null,msgText,Messages.getI18NString(""String_Node_Str"").getText()).showDialog();
      }
 else       if (evt.getReasonCode() == RegistrationStateChangeEvent.REASON_CLIENT_LIMIT_REACHED_FOR_IP) {
        String msgText=Messages.getI18NString(""String_Node_Str"",new String[]{protocolProvider.getProtocolName()}).getText();
        new ErrorDialog(null,msgText,Messages.getI18NString(""String_Node_Str"").getText()).showDialog();
      }
 else       if (evt.getReasonCode() == RegistrationStateChangeEvent.REASON_USER_REQUEST) {
      }
 else {
        String msgText=Messages.getI18NString(""String_Node_Str"",new String[]{accountID.getUserID(),accountID.getService()}).getText();
        new ErrorDialog(null,msgText,Messages.getI18NString(""String_Node_Str"").getText()).showDialog();
      }
      logger.error(evt.getReason());
    }
  }
}","/** 
 * The method is called by a ProtocolProvider implementation whenever a change in the registration state of the corresponding provider had occurred.
 * @param evt ProviderStatusChangeEvent the event describing the statuschange.
 */
public void registrationStateChanged(RegistrationStateChangeEvent evt){
  ProtocolProviderService protocolProvider=evt.getProvider();
  AccountID accountID=protocolProvider.getAccountID();
  logger.trace(""String_Node_Str"" + protocolProvider + ""String_Node_Str""+ evt.getNewState().getStateName());
  OperationSetPresence presence=mainFrame.getProtocolPresenceOpSet(protocolProvider);
  OperationSetMultiUserChat multiUserChat=mainFrame.getMultiUserChatOpSet(protocolProvider);
  if (evt.getNewState().equals(RegistrationState.REGISTERED)) {
    this.mainFrame.getStatusPanel().updateStatus(protocolProvider);
    if (mainFrame.getCallManager().containsCallAccount(protocolProvider)) {
      this.mainFrame.getCallManager().updateCallAccountStatus(protocolProvider);
    }
    if (presence != null) {
      presence.setAuthorizationHandler(new AuthorizationHandlerImpl(mainFrame));
    }
    if (multiUserChat != null) {
      mainFrame.getChatRoomsListPanel().getChatRoomsList().synchronizeOpSetWithLocalContactList(protocolProvider,multiUserChat);
    }
  }
 else   if (evt.getNewState().equals(RegistrationState.AUTHENTICATION_FAILED)) {
    this.mainFrame.getStatusPanel().updateStatus(evt.getProvider());
    if (evt.getReasonCode() == RegistrationStateChangeEvent.REASON_RECONNECTION_RATE_LIMIT_EXCEEDED) {
      String msgText=Messages.getI18NString(""String_Node_Str"",new String[]{accountID.getUserID(),accountID.getService()}).getText();
      new ErrorDialog(null,Messages.getI18NString(""String_Node_Str"").getText(),msgText).showDialog();
    }
 else     if (evt.getReasonCode() == RegistrationStateChangeEvent.REASON_NON_EXISTING_USER_ID) {
      String msgText=Messages.getI18NString(""String_Node_Str"",new String[]{protocolProvider.getProtocolName()}).getText();
      new ErrorDialog(null,Messages.getI18NString(""String_Node_Str"").getText(),msgText).showDialog();
    }
 else     if (evt.getReasonCode() == RegistrationStateChangeEvent.REASON_AUTHENTICATION_FAILED) {
      String msgText=Messages.getI18NString(""String_Node_Str"",new String[]{accountID.getUserID(),accountID.getService()}).getText();
      new ErrorDialog(null,Messages.getI18NString(""String_Node_Str"").getText(),msgText).showDialog();
    }
    logger.error(evt.getReason());
  }
 else   if (evt.getNewState().equals(RegistrationState.CONNECTION_FAILED)) {
    this.mainFrame.getStatusPanel().updateStatus(evt.getProvider());
    String msgText=Messages.getI18NString(""String_Node_Str"",new String[]{accountID.getUserID(),accountID.getService()}).getText();
    new ErrorDialog(null,Messages.getI18NString(""String_Node_Str"").getText(),msgText).showDialog();
    logger.error(evt.getReason());
  }
 else   if (evt.getNewState().equals(RegistrationState.EXPIRED)) {
    this.mainFrame.getStatusPanel().updateStatus(evt.getProvider());
    String msgText=Messages.getI18NString(""String_Node_Str"",new String[]{protocolProvider.getProtocolName()}).getText();
    new ErrorDialog(null,Messages.getI18NString(""String_Node_Str"").getText(),msgText).showDialog();
    logger.error(evt.getReason());
  }
 else   if (evt.getNewState().equals(RegistrationState.UNREGISTERED)) {
    this.mainFrame.getStatusPanel().updateStatus(evt.getProvider());
    if (mainFrame.getCallManager().containsCallAccount(protocolProvider)) {
      this.mainFrame.getCallManager().updateCallAccountStatus(protocolProvider);
    }
    if (!manuallyDisconnected) {
      if (evt.getReasonCode() == RegistrationStateChangeEvent.REASON_MULTIPLE_LOGINS) {
        String msgText=Messages.getI18NString(""String_Node_Str"",new String[]{accountID.getUserID(),accountID.getService()}).getText();
        new ErrorDialog(null,Messages.getI18NString(""String_Node_Str"").getText(),msgText).showDialog();
      }
 else       if (evt.getReasonCode() == RegistrationStateChangeEvent.REASON_CLIENT_LIMIT_REACHED_FOR_IP) {
        String msgText=Messages.getI18NString(""String_Node_Str"",new String[]{protocolProvider.getProtocolName()}).getText();
        new ErrorDialog(null,Messages.getI18NString(""String_Node_Str"").getText(),msgText).showDialog();
      }
 else       if (evt.getReasonCode() == RegistrationStateChangeEvent.REASON_USER_REQUEST) {
      }
 else {
        String msgText=Messages.getI18NString(""String_Node_Str"",new String[]{accountID.getUserID(),accountID.getService()}).getText();
        new ErrorDialog(null,Messages.getI18NString(""String_Node_Str"").getText(),msgText).showDialog();
      }
      logger.error(evt.getReason());
    }
  }
}",0.9864521591871296
104371,"/** 
 * Indicates whether the user is Online, available and eager to communicatie (can be reached and is likely to become annoyngly talkative if contacted).
 * @return true if the the status coefficient is higher than theEAGER_TO_COMMUNICATE_THRESHOLD and false otherwise
 */
public boolean isEagerToCommunicate(){
  return getStatus() >= EAGER_TO_COMMUNICATE_THRESSHOLD;
}","/** 
 * Indicates whether the user is Online, available and eager to communicatie (can be reached and is likely to become annoyngly talkative if contacted).
 * @return true if the the status coefficient is higher than theEAGER_TO_COMMUNICATE_THRESHOLD and false otherwise
 */
public boolean isEagerToCommunicate(){
  return getStatus() >= EAGER_TO_COMMUNICATE_THRESHOLD;
}",0.9986577181208054
104372,"public void run(){
  try {
    chatRoom.banParticipant((ChatRoomMember)chatContact.getSourceContact(),reason);
  }
 catch (  OperationFailedException e) {
    logger.error(""String_Node_Str"",e);
    if (e.getErrorCode() == OperationFailedException.NOT_ENOUGH_PRIVILEGES) {
      new ErrorDialog(chatPanel.getChatWindow(),Messages.getI18NString(""String_Node_Str"",new String[]{chatContact.getName()}).getText(),e,Messages.getI18NString(""String_Node_Str"").getText()).showDialog();
    }
 else     if (e.getErrorCode() == OperationFailedException.FORBIDDEN) {
      new ErrorDialog(chatPanel.getChatWindow(),Messages.getI18NString(""String_Node_Str"",new String[]{chatContact.getName()}).getText(),e,Messages.getI18NString(""String_Node_Str"").getText()).showDialog();
    }
 else {
      new ErrorDialog(chatPanel.getChatWindow(),Messages.getI18NString(""String_Node_Str"",new String[]{chatContact.getName()}).getText(),e,Messages.getI18NString(""String_Node_Str"").getText()).showDialog();
    }
  }
}","public void run(){
  try {
    chatRoom.banParticipant((ChatRoomMember)chatContact.getSourceContact(),reason);
  }
 catch (  OperationFailedException e) {
    logger.error(""String_Node_Str"",e);
    if (e.getErrorCode() == OperationFailedException.NOT_ENOUGH_PRIVILEGES) {
      new ErrorDialog(chatPanel.getChatWindow(),Messages.getI18NString(""String_Node_Str"").getText(),Messages.getI18NString(""String_Node_Str"",new String[]{chatContact.getName()}).getText(),e).showDialog();
    }
 else     if (e.getErrorCode() == OperationFailedException.FORBIDDEN) {
      new ErrorDialog(chatPanel.getChatWindow(),Messages.getI18NString(""String_Node_Str"").getText(),Messages.getI18NString(""String_Node_Str"",new String[]{chatContact.getName()}).getText(),e).showDialog();
    }
 else {
      new ErrorDialog(chatPanel.getChatWindow(),Messages.getI18NString(""String_Node_Str"").getText(),Messages.getI18NString(""String_Node_Str"",new String[]{chatContact.getName()}).getText(),e).showDialog();
    }
  }
}",0.8171717171717172
104373,"/** 
 */
public void actionPerformed(ActionEvent e){
  JButton button=(JButton)e.getSource();
  if (button.equals(saveButton)) {
    Iterator configurationSet=configForm.getConfigurationSet();
    while (configurationSet.hasNext()) {
      ChatRoomConfigurationFormField formField=(ChatRoomConfigurationFormField)configurationSet.next();
      if (formField.getType().equals(ChatRoomConfigurationFormField.TYPE_TEXT_FIXED))       continue;
      JComponent c=(JComponent)uiFieldsTable.get(formField.getName());
      if (c instanceof JTextComponent) {
        String newValue=((JTextComponent)c).getText();
        formField.addValue(newValue);
      }
 else       if (c instanceof AbstractButton) {
        boolean isSelected=((AbstractButton)c).isSelected();
        formField.addValue(new Boolean(isSelected));
      }
 else       if (c instanceof JComboBox) {
        Object selectedObject=((JComboBox)c).getSelectedItem();
        formField.addValue(selectedObject);
      }
 else       if (c instanceof JPanel) {
        Component[] components=c.getComponents();
        for (int i=0; i < components.length; i++) {
          if (!(components[i] instanceof JCheckBox))           continue;
          JCheckBox checkBox=(JCheckBox)components[i];
          formField.addValue(checkBox.getText());
        }
      }
    }
    new Thread(){
      public void run(){
        try {
          configForm.submit();
        }
 catch (        Exception e) {
          new ErrorDialog(ChatRoomConfigurationWindow.this,Messages.getI18NString(""String_Node_Str"").getText(),e,Messages.getI18NString(""String_Node_Str"").getText()).showDialog();
        }
      }
    }
.start();
  }
  this.dispose();
}","/** 
 */
public void actionPerformed(ActionEvent e){
  JButton button=(JButton)e.getSource();
  if (button.equals(saveButton)) {
    Iterator configurationSet=configForm.getConfigurationSet();
    while (configurationSet.hasNext()) {
      ChatRoomConfigurationFormField formField=(ChatRoomConfigurationFormField)configurationSet.next();
      if (formField.getType().equals(ChatRoomConfigurationFormField.TYPE_TEXT_FIXED))       continue;
      JComponent c=(JComponent)uiFieldsTable.get(formField.getName());
      if (c instanceof JTextComponent) {
        String newValue=((JTextComponent)c).getText();
        formField.addValue(newValue);
      }
 else       if (c instanceof AbstractButton) {
        boolean isSelected=((AbstractButton)c).isSelected();
        formField.addValue(new Boolean(isSelected));
      }
 else       if (c instanceof JComboBox) {
        Object selectedObject=((JComboBox)c).getSelectedItem();
        formField.addValue(selectedObject);
      }
 else       if (c instanceof JPanel) {
        Component[] components=c.getComponents();
        for (int i=0; i < components.length; i++) {
          if (!(components[i] instanceof JCheckBox))           continue;
          JCheckBox checkBox=(JCheckBox)components[i];
          formField.addValue(checkBox.getText());
        }
      }
    }
    new Thread(){
      public void run(){
        try {
          configForm.submit();
        }
 catch (        Exception e) {
          new ErrorDialog(ChatRoomConfigurationWindow.this,Messages.getI18NString(""String_Node_Str"").getText(),Messages.getI18NString(""String_Node_Str"").getText(),e).showDialog();
        }
      }
    }
.start();
  }
  this.dispose();
}",0.9988158673771462
104374,"public void run(){
  try {
    configForm.submit();
  }
 catch (  Exception e) {
    new ErrorDialog(ChatRoomConfigurationWindow.this,Messages.getI18NString(""String_Node_Str"").getText(),e,Messages.getI18NString(""String_Node_Str"").getText()).showDialog();
  }
}","public void run(){
  try {
    configForm.submit();
  }
 catch (  Exception e) {
    new ErrorDialog(ChatRoomConfigurationWindow.this,Messages.getI18NString(""String_Node_Str"").getText(),Messages.getI18NString(""String_Node_Str"").getText(),e).showDialog();
  }
}",0.9923076923076924
104375,"/** 
 * Obtains and opens the configuration form of the corresponding chat room when user clicks on the configuration button.
 */
public void actionPerformed(ActionEvent evt){
  if (chatRoomWrapper.getChatRoom() == null)   return;
  try {
    ChatRoomConfigurationForm configForm=chatRoomWrapper.getChatRoom().getConfigurationForm();
    ChatRoomConfigurationWindow configWindow=new ChatRoomConfigurationWindow(chatRoomWrapper.getChatRoomName(),configForm);
    configWindow.setVisible(true);
  }
 catch (  OperationFailedException e) {
    logger.error(""String_Node_Str"",e);
    if (e.getErrorCode() == OperationFailedException.NOT_ENOUGH_PRIVILEGES) {
      new ErrorDialog(chatWindow,Messages.getI18NString(""String_Node_Str"",new String[]{chatRoomWrapper.getChatRoomName()}).getText(),Messages.getI18NString(""String_Node_Str"").getText(),ErrorDialog.WARNING).showDialog();
    }
 else {
      new ErrorDialog(chatWindow,Messages.getI18NString(""String_Node_Str"",new String[]{chatRoomWrapper.getChatRoomName()}).getText(),e,Messages.getI18NString(""String_Node_Str"").getText()).showDialog();
    }
  }
}","/** 
 * Obtains and opens the configuration form of the corresponding chat room when user clicks on the configuration button.
 */
public void actionPerformed(ActionEvent evt){
  if (chatRoomWrapper.getChatRoom() == null)   return;
  try {
    ChatRoomConfigurationForm configForm=chatRoomWrapper.getChatRoom().getConfigurationForm();
    ChatRoomConfigurationWindow configWindow=new ChatRoomConfigurationWindow(chatRoomWrapper.getChatRoomName(),configForm);
    configWindow.setVisible(true);
  }
 catch (  OperationFailedException e) {
    logger.error(""String_Node_Str"",e);
    if (e.getErrorCode() == OperationFailedException.NOT_ENOUGH_PRIVILEGES) {
      new ErrorDialog(chatWindow,Messages.getI18NString(""String_Node_Str"").getText(),Messages.getI18NString(""String_Node_Str"",new String[]{chatRoomWrapper.getChatRoomName()}).getText(),ErrorDialog.WARNING).showDialog();
    }
 else {
      new ErrorDialog(chatWindow,Messages.getI18NString(""String_Node_Str"").getText(),Messages.getI18NString(""String_Node_Str"",new String[]{chatRoomWrapper.getChatRoomName()}).getText(),e).showDialog();
    }
  }
}",0.8782924613987284
104376,"/** 
 * Called to accept an incoming invitation. Adds the invitation chat room to the list of chat rooms and joins it.
 * @param invitation the invitation to accept.
 */
public void acceptInvitation(ChatRoomInvitation invitation){
  ChatRoom chatRoom=invitation.getTargetChatRoom();
  byte[] password=invitation.getChatRoomPassword();
  ChatRoomsList chatRoomsList=mainFrame.getChatRoomsListPanel().getChatRoomsList();
  chatRoomsList.addChatRoom(new ChatRoomWrapper(chatRoom));
  try {
    if (password == null)     chatRoom.join();
 else     chatRoom.join(password);
  }
 catch (  OperationFailedException e) {
    new ErrorDialog(mainFrame,Messages.getI18NString(""String_Node_Str"",new String[]{chatRoom.getName()}).getText(),Messages.getI18NString(""String_Node_Str"").getText()).showDialog();
    logger.error(""String_Node_Str"" + chatRoom.getName(),e);
  }
}","/** 
 * Called to accept an incoming invitation. Adds the invitation chat room to the list of chat rooms and joins it.
 * @param invitation the invitation to accept.
 */
public void acceptInvitation(ChatRoomInvitation invitation){
  ChatRoom chatRoom=invitation.getTargetChatRoom();
  byte[] password=invitation.getChatRoomPassword();
  ChatRoomsList chatRoomsList=mainFrame.getChatRoomsListPanel().getChatRoomsList();
  chatRoomsList.addChatRoom(new ChatRoomWrapper(chatRoom));
  try {
    if (password == null)     chatRoom.join();
 else     chatRoom.join(password);
  }
 catch (  OperationFailedException e) {
    new ErrorDialog(mainFrame,Messages.getI18NString(""String_Node_Str"").getText(),Messages.getI18NString(""String_Node_Str"",new String[]{chatRoom.getName()}).getText()).showDialog();
    logger.error(""String_Node_Str"" + chatRoom.getName(),e);
  }
}",0.9616279069767442
104377,"/** 
 * Joins the given chat room and manages all the exceptions that could occur during the join process.
 * @param chatRoom the chat room to join
 */
public void joinChatRoom(ChatRoom chatRoom){
  try {
    chatRoom.join();
    ChatRoomsList chatRoomList=mainFrame.getChatRoomsListPanel().getChatRoomsList();
    ChatRoomWrapper chatRoomWrapper=chatRoomList.findChatRoomWrapperFromChatRoom(chatRoom);
    if (chatRoomWrapper == null) {
      chatRoomWrapper=new ChatRoomWrapper(chatRoom);
      chatRoomList.addChatRoom(chatRoomWrapper);
    }
    ConfigurationManager.updateChatRoomStatus(chatRoomWrapper.getParentProvider(),chatRoomWrapper.getChatRoomID(),Constants.ONLINE_STATUS);
  }
 catch (  OperationFailedException e) {
    if (e.getErrorCode() == OperationFailedException.AUTHENTICATION_FAILED) {
      ChatRoomAuthenticationWindow authWindow=new ChatRoomAuthenticationWindow(mainFrame,chatRoom);
      authWindow.setVisible(true);
    }
 else     if (e.getErrorCode() == OperationFailedException.REGISTRATION_REQUIRED) {
      new ErrorDialog(mainFrame,Messages.getI18NString(""String_Node_Str"",new String[]{chatRoom.getName()}).getText(),e,Messages.getI18NString(""String_Node_Str"").getText()).showDialog();
    }
 else     if (e.getErrorCode() == OperationFailedException.PROVIDER_NOT_REGISTERED) {
      new ErrorDialog(mainFrame,Messages.getI18NString(""String_Node_Str"",new String[]{chatRoom.getName()}).getText(),e,Messages.getI18NString(""String_Node_Str"").getText()).showDialog();
    }
 else     if (e.getErrorCode() == OperationFailedException.SUBSCRIPTION_ALREADY_EXISTS) {
      new ErrorDialog(mainFrame,Messages.getI18NString(""String_Node_Str"",new String[]{chatRoom.getName()}).getText(),e,Messages.getI18NString(""String_Node_Str"").getText()).showDialog();
    }
 else {
      new ErrorDialog(mainFrame,Messages.getI18NString(""String_Node_Str"",new String[]{chatRoom.getName()}).getText(),e,Messages.getI18NString(""String_Node_Str"").getText()).showDialog();
    }
    logger.error(""String_Node_Str"" + chatRoom.getName(),e);
  }
}","/** 
 * Joins the given chat room and manages all the exceptions that could occur during the join process.
 * @param chatRoom the chat room to join
 */
public void joinChatRoom(ChatRoom chatRoom){
  try {
    chatRoom.join();
    ChatRoomsList chatRoomList=mainFrame.getChatRoomsListPanel().getChatRoomsList();
    ChatRoomWrapper chatRoomWrapper=chatRoomList.findChatRoomWrapperFromChatRoom(chatRoom);
    if (chatRoomWrapper == null) {
      chatRoomWrapper=new ChatRoomWrapper(chatRoom);
      chatRoomList.addChatRoom(chatRoomWrapper);
    }
    ConfigurationManager.updateChatRoomStatus(chatRoomWrapper.getParentProvider(),chatRoomWrapper.getChatRoomID(),Constants.ONLINE_STATUS);
  }
 catch (  OperationFailedException e) {
    if (e.getErrorCode() == OperationFailedException.AUTHENTICATION_FAILED) {
      ChatRoomAuthenticationWindow authWindow=new ChatRoomAuthenticationWindow(mainFrame,chatRoom);
      authWindow.setVisible(true);
    }
 else     if (e.getErrorCode() == OperationFailedException.REGISTRATION_REQUIRED) {
      new ErrorDialog(mainFrame,Messages.getI18NString(""String_Node_Str"").getText(),Messages.getI18NString(""String_Node_Str"",new String[]{chatRoom.getName()}).getText(),e).showDialog();
    }
 else     if (e.getErrorCode() == OperationFailedException.PROVIDER_NOT_REGISTERED) {
      new ErrorDialog(mainFrame,Messages.getI18NString(""String_Node_Str"").getText(),Messages.getI18NString(""String_Node_Str"",new String[]{chatRoom.getName()}).getText(),e).showDialog();
    }
 else     if (e.getErrorCode() == OperationFailedException.SUBSCRIPTION_ALREADY_EXISTS) {
      new ErrorDialog(mainFrame,Messages.getI18NString(""String_Node_Str"").getText(),Messages.getI18NString(""String_Node_Str"",new String[]{chatRoom.getName()}).getText(),e).showDialog();
    }
 else {
      new ErrorDialog(mainFrame,Messages.getI18NString(""String_Node_Str"").getText(),Messages.getI18NString(""String_Node_Str"",new String[]{chatRoom.getName()}).getText(),e).showDialog();
    }
    logger.error(""String_Node_Str"" + chatRoom.getName(),e);
  }
}",0.8941463414634147
104378,"/** 
 * Implements the <tt>LocalUserChatRoomPresenceListener.localUserPresenceChanged</tt> method.
 */
public void localUserPresenceChanged(LocalUserChatRoomPresenceChangeEvent evt){
  ChatRoom sourceChatRoom=evt.getChatRoom();
  ChatRoomsList chatRoomsList=mainFrame.getChatRoomsListPanel().getChatRoomsList();
  ChatRoomWrapper chatRoomWrapper=chatRoomsList.findChatRoomWrapperFromChatRoom(sourceChatRoom);
  if (evt.getEventType().equals(LocalUserChatRoomPresenceChangeEvent.LOCAL_USER_JOINED)) {
    if (chatRoomWrapper != null) {
      chatRoomsList.refresh();
      ConferenceChatPanel chatPanel=(ConferenceChatPanel)chatWindowManager.getMultiChat(chatRoomWrapper);
      if (chatWindowManager.isChatOpenedForChatRoom(chatRoomWrapper)) {
        chatPanel.loadChatRoom(sourceChatRoom);
      }
 else {
        chatWindowManager.openChat(chatPanel,true);
      }
      chatPanel.updateChatRoomStatus(Constants.ONLINE_STATUS);
    }
    if (sourceChatRoom.isSystem()) {
      MultiUserChatServerWrapper serverWrapper=chatRoomsList.findServerWrapperFromProvider(sourceChatRoom.getParentProvider());
      serverWrapper.setSystemRoom(sourceChatRoom);
    }
    sourceChatRoom.addMessageListener(this);
  }
 else   if (evt.getEventType().equals(LocalUserChatRoomPresenceChangeEvent.LOCAL_USER_JOIN_FAILED)) {
    new ErrorDialog(mainFrame,Messages.getI18NString(""String_Node_Str"",new String[]{sourceChatRoom.getName()}).getText() + evt.getReason(),Messages.getI18NString(""String_Node_Str"").getText()).showDialog();
  }
 else   if (evt.getEventType().equals(LocalUserChatRoomPresenceChangeEvent.LOCAL_USER_LEFT)) {
    this.closeChatRoom(chatRoomWrapper);
    mainFrame.getChatRoomsListPanel().getChatRoomsList().refresh();
    sourceChatRoom.removeMessageListener(this);
  }
 else   if (evt.getEventType().equals(LocalUserChatRoomPresenceChangeEvent.LOCAL_USER_KICKED)) {
    this.closeChatRoom(chatRoomWrapper);
    mainFrame.getChatRoomsListPanel().getChatRoomsList().refresh();
    sourceChatRoom.removeMessageListener(this);
  }
 else   if (evt.getEventType().equals(LocalUserChatRoomPresenceChangeEvent.LOCAL_USER_DROPPED)) {
    this.closeChatRoom(chatRoomWrapper);
    mainFrame.getChatRoomsListPanel().getChatRoomsList().refresh();
    sourceChatRoom.removeMessageListener(this);
  }
}","/** 
 * Implements the <tt>LocalUserChatRoomPresenceListener.localUserPresenceChanged</tt> method.
 */
public void localUserPresenceChanged(LocalUserChatRoomPresenceChangeEvent evt){
  ChatRoom sourceChatRoom=evt.getChatRoom();
  ChatRoomsList chatRoomsList=mainFrame.getChatRoomsListPanel().getChatRoomsList();
  ChatRoomWrapper chatRoomWrapper=chatRoomsList.findChatRoomWrapperFromChatRoom(sourceChatRoom);
  if (evt.getEventType().equals(LocalUserChatRoomPresenceChangeEvent.LOCAL_USER_JOINED)) {
    if (chatRoomWrapper != null) {
      chatRoomsList.refresh();
      ConferenceChatPanel chatPanel=(ConferenceChatPanel)chatWindowManager.getMultiChat(chatRoomWrapper);
      if (chatWindowManager.isChatOpenedForChatRoom(chatRoomWrapper)) {
        chatPanel.loadChatRoom(sourceChatRoom);
      }
 else {
        chatWindowManager.openChat(chatPanel,true);
      }
      chatPanel.updateChatRoomStatus(Constants.ONLINE_STATUS);
    }
    if (sourceChatRoom.isSystem()) {
      MultiUserChatServerWrapper serverWrapper=chatRoomsList.findServerWrapperFromProvider(sourceChatRoom.getParentProvider());
      serverWrapper.setSystemRoom(sourceChatRoom);
    }
    sourceChatRoom.addMessageListener(this);
  }
 else   if (evt.getEventType().equals(LocalUserChatRoomPresenceChangeEvent.LOCAL_USER_JOIN_FAILED)) {
    new ErrorDialog(mainFrame,Messages.getI18NString(""String_Node_Str"").getText(),Messages.getI18NString(""String_Node_Str"",new String[]{sourceChatRoom.getName()}).getText() + evt.getReason()).showDialog();
  }
 else   if (evt.getEventType().equals(LocalUserChatRoomPresenceChangeEvent.LOCAL_USER_LEFT)) {
    this.closeChatRoom(chatRoomWrapper);
    mainFrame.getChatRoomsListPanel().getChatRoomsList().refresh();
    sourceChatRoom.removeMessageListener(this);
  }
 else   if (evt.getEventType().equals(LocalUserChatRoomPresenceChangeEvent.LOCAL_USER_KICKED)) {
    this.closeChatRoom(chatRoomWrapper);
    mainFrame.getChatRoomsListPanel().getChatRoomsList().refresh();
    sourceChatRoom.removeMessageListener(this);
  }
 else   if (evt.getEventType().equals(LocalUserChatRoomPresenceChangeEvent.LOCAL_USER_DROPPED)) {
    this.closeChatRoom(chatRoomWrapper);
    mainFrame.getChatRoomsListPanel().getChatRoomsList().refresh();
    sourceChatRoom.removeMessageListener(this);
  }
}",0.9751525719267656
104379,"public void run(){
  String chatRoomName=chatRoomPanel.getChatRoomName();
  ChatRoom chatRoom=null;
  try {
    chatRoom=mainFrame.getMultiUserChatOpSet(pps).createChatRoom(chatRoomName,null);
  }
 catch (  OperationFailedException ex) {
    logger.error(""String_Node_Str"",ex);
    new ErrorDialog(mainFrame,Messages.getI18NString(""String_Node_Str"",new String[]{chatRoomName}).getText(),ex,Messages.getI18NString(""String_Node_Str"").getText()).showDialog();
  }
catch (  OperationNotSupportedException ex) {
    logger.error(""String_Node_Str"",ex);
    new ErrorDialog(mainFrame,Messages.getI18NString(""String_Node_Str"",new String[]{chatRoomName}).getText(),ex,Messages.getI18NString(""String_Node_Str"").getText()).showDialog();
  }
  if (chatRoom != null)   mainFrame.getChatRoomsListPanel().getChatRoomsList().addChatRoom(new ChatRoomWrapper(chatRoom));
}","public void run(){
  String chatRoomName=chatRoomPanel.getChatRoomName();
  ChatRoom chatRoom=null;
  try {
    chatRoom=mainFrame.getMultiUserChatOpSet(pps).createChatRoom(chatRoomName,null);
  }
 catch (  OperationFailedException ex) {
    logger.error(""String_Node_Str"",ex);
    new ErrorDialog(mainFrame,Messages.getI18NString(""String_Node_Str"").getText(),Messages.getI18NString(""String_Node_Str"",new String[]{chatRoomName}).getText(),ex).showDialog();
  }
catch (  OperationNotSupportedException ex) {
    logger.error(""String_Node_Str"",ex);
    new ErrorDialog(mainFrame,Messages.getI18NString(""String_Node_Str"").getText(),Messages.getI18NString(""String_Node_Str"",new String[]{chatRoomName}).getText(),ex).showDialog();
  }
  if (chatRoom != null)   mainFrame.getChatRoomsListPanel().getChatRoomsList().addChatRoom(new ChatRoomWrapper(chatRoom));
}",0.7810304449648712
104380,"/** 
 * Indicates whether the user is Online, available and eager to communicatie (can be reached and is likely to become annoyngly talkative if contacted).
 * @return true if the the status coefficient is higher than theEAGER_TO_COMMUNICATE_THRESHOLD and false otherwise
 */
public boolean isEagerToCommunicate(){
  return getStatus() >= EAGER_TO_COMMUNICATE_THRESSHOLD;
}","/** 
 * Indicates whether the user is Online, available and eager to communicatie (can be reached and is likely to become annoyngly talkative if contacted).
 * @return true if the the status coefficient is higher than theEAGER_TO_COMMUNICATE_THRESHOLD and false otherwise
 */
public boolean isEagerToCommunicate(){
  return getStatus() >= EAGER_TO_COMMUNICATE_THRESHOLD;
}",0.9986577181208054
104381,"/** 
 * Sets to CONNECTED that state of the corresponding call participant and sends an ACK.
 * @param clientTransaction the <tt>ClientTransaction</tt> that the responsearrived in.
 * @param ok the OK <tt>Response</tt> to process
 */
private void processInviteOK(ClientTransaction clientTransaction,Response ok){
  Dialog dialog=clientTransaction.getDialog();
  CallParticipantSipImpl callParticipant=activeCallsRepository.findCallParticipant(dialog);
  if (callParticipant == null) {
    logger.debug(""String_Node_Str"");
    return;
  }
  if (callParticipant.getState() == CallParticipantState.CONNECTED) {
    logger.debug(""String_Node_Str"" + ""String_Node_Str"");
    return;
  }
  Request ack=null;
  ContentTypeHeader contentTypeHeader=null;
  try {
    ack=clientTransaction.getDialog().createRequest(Request.ACK);
    contentTypeHeader=protocolProvider.getHeaderFactory().createContentTypeHeader(""String_Node_Str"",""String_Node_Str"");
  }
 catch (  ParseException ex) {
    callParticipant.setState(CallParticipantState.FAILED,""String_Node_Str"");
    logger.error(""String_Node_Str"",ex);
  }
catch (  SipException ex) {
    logger.error(""String_Node_Str"",ex);
    callParticipant.setState(CallParticipantState.FAILED);
    return;
  }
  callParticipant.setSdpDescription(new String(ok.getRawContent()));
  CallSession callSession=((CallSipImpl)callParticipant.getCall()).getMediaCallSession();
  try {
    if (callSession == null) {
      callSession=SipActivator.getMediaService().createCallSession(callParticipant.getCall());
      String sdp=callSession.processSdpOffer(callParticipant,callParticipant.getSdpDescription());
      ack.setContent(sdp,contentTypeHeader);
    }
    callSession.processSdpAnswer(callParticipant,callParticipant.getSdpDescription());
  }
 catch (  ParseException exc) {
    logger.error(""String_Node_Str"" + callParticipant.getDisplayName() + ""String_Node_Str""+ callParticipant.getAddress()+ ""String_Node_Str"",exc);
    callParticipant.setState(CallParticipantState.FAILED,""String_Node_Str"" + callParticipant.getDisplayName() + ""String_Node_Str""+ callParticipant.getAddress()+ ""String_Node_Str"");
  }
catch (  MediaException exc) {
    logger.error(""String_Node_Str"" + callParticipant.getDisplayName() + ""String_Node_Str""+ callParticipant.getAddress()+ ""String_Node_Str""+ ""String_Node_Str""+ exc.getMessage(),exc);
    callParticipant.setState(CallParticipantState.FAILED,""String_Node_Str"" + callParticipant.getDisplayName() + ""String_Node_Str""+ callParticipant.getAddress()+ ""String_Node_Str""+ ""String_Node_Str""+ exc.getMessage());
  }
  try {
    clientTransaction.getDialog().sendAck(ack);
  }
 catch (  SipException ex) {
    logger.error(""String_Node_Str"",ex);
    callParticipant.setState(CallParticipantState.FAILED);
    return;
  }
  callParticipant.setState(CallParticipantState.CONNECTED);
}","/** 
 * Sets to CONNECTED that state of the corresponding call participant and sends an ACK.
 * @param clientTransaction the <tt>ClientTransaction</tt> that the responsearrived in.
 * @param ok the OK <tt>Response</tt> to process
 */
private void processInviteOK(ClientTransaction clientTransaction,Response ok){
  Dialog dialog=clientTransaction.getDialog();
  CallParticipantSipImpl callParticipant=activeCallsRepository.findCallParticipant(dialog);
  if (callParticipant == null) {
    logger.debug(""String_Node_Str"");
    return;
  }
  if (callParticipant.getState() == CallParticipantState.CONNECTED) {
    logger.debug(""String_Node_Str"" + ""String_Node_Str"");
    return;
  }
  Request ack=null;
  ContentTypeHeader contentTypeHeader=null;
  try {
    ack=clientTransaction.getDialog().createRequest(Request.ACK);
    contentTypeHeader=protocolProvider.getHeaderFactory().createContentTypeHeader(""String_Node_Str"",""String_Node_Str"");
  }
 catch (  ParseException ex) {
    callParticipant.setState(CallParticipantState.FAILED,""String_Node_Str"");
    logger.error(""String_Node_Str"",ex);
  }
catch (  SipException ex) {
    logger.error(""String_Node_Str"",ex);
    callParticipant.setState(CallParticipantState.FAILED);
    return;
  }
  callParticipant.setSdpDescription(new String(ok.getRawContent()));
  CallSession callSession=((CallSipImpl)callParticipant.getCall()).getMediaCallSession();
  try {
    try {
      if (callSession == null) {
        callSession=SipActivator.getMediaService().createCallSession(callParticipant.getCall());
        String sdp=callSession.processSdpOffer(callParticipant,callParticipant.getSdpDescription());
        ack.setContent(sdp,contentTypeHeader);
      }
    }
  finally {
      try {
        clientTransaction.getDialog().sendAck(ack);
      }
 catch (      SipException ex) {
        logger.error(""String_Node_Str"",ex);
        callParticipant.setState(CallParticipantState.FAILED);
        return;
      }
    }
    callSession.processSdpAnswer(callParticipant,callParticipant.getSdpDescription());
  }
 catch (  ParseException exc) {
    logger.error(""String_Node_Str"" + callParticipant.getDisplayName() + ""String_Node_Str""+ callParticipant.getAddress()+ ""String_Node_Str"",exc);
    callParticipant.setState(CallParticipantState.FAILED,""String_Node_Str"" + callParticipant.getDisplayName() + ""String_Node_Str""+ callParticipant.getAddress()+ ""String_Node_Str"");
  }
catch (  MediaException exc) {
    logger.error(""String_Node_Str"" + callParticipant.getDisplayName() + ""String_Node_Str""+ callParticipant.getAddress()+ ""String_Node_Str""+ ""String_Node_Str""+ exc.getMessage(),exc);
    callParticipant.setState(CallParticipantState.FAILED,""String_Node_Str"" + callParticipant.getDisplayName() + ""String_Node_Str""+ callParticipant.getAddress()+ ""String_Node_Str""+ ""String_Node_Str""+ exc.getMessage());
  }
  callParticipant.setState(CallParticipantState.CONNECTED);
}",0.9157381615598886
104382,"/** 
 * Removes the specified provider from the list of currently known providers and ignores all the contacts that it has registered locally.
 * @param provider the ProtocolProviderService that has been unregistered.
 */
private void handleProviderRemoved(ProtocolProviderService provider){
  logger.debug(""String_Node_Str"" + provider.getProtocolName());
  this.currentlyInstalledProviders.remove(provider.getAccountID().getAccountUniqueID());
  OperationSetPersistentPresence persPresOpSet=(OperationSetPersistentPresence)provider.getOperationSet(OperationSetPersistentPresence.class);
  if (persPresOpSet == null)   return;
  ContactGroup rootGroup=persPresOpSet.getServerStoredContactListRoot();
  Iterator subgroups=rootGroup.subgroups();
  while (subgroups.hasNext()) {
    ContactGroup group=(ContactGroup)subgroups.next();
    this.removeContactGroupFromMetaContactGroup(this.rootMetaGroup,group,provider);
  }
  this.removeContactGroupFromMetaContactGroup(this.rootMetaGroup,rootGroup,provider);
}","/** 
 * Removes the specified provider from the list of currently known providers and ignores all the contacts that it has registered locally.
 * @param provider the ProtocolProviderService that has been unregistered.
 */
private void handleProviderRemoved(ProtocolProviderService provider){
  logger.debug(""String_Node_Str"" + provider.getProtocolName());
  this.currentlyInstalledProviders.remove(provider.getAccountID().getAccountUniqueID());
  OperationSetPersistentPresence persPresOpSet=(OperationSetPersistentPresence)provider.getOperationSet(OperationSetPersistentPresence.class);
  if (persPresOpSet == null)   return;
  ContactGroup rootGroup=persPresOpSet.getServerStoredContactListRoot();
  Iterator subgroups=rootGroup.subgroups();
  while (subgroups.hasNext()) {
    ContactGroup group=(ContactGroup)subgroups.next();
    this.removeContactGroupFromMetaContactGroup((MetaContactGroupImpl)findMetaContactGroupByContactGroup(group),group,provider);
  }
  this.removeContactGroupFromMetaContactGroup(this.rootMetaGroup,rootGroup,provider);
}",0.9645114244044726
104383,"/** 
 * Derive a new SRTPCryptoContext for use with a new SSRC This method returns a new SRTPCryptoContext initialized with the data of this SRTPCryptoContext. Replacing the SSRC, Roll-over-Counter, and the key derivation rate the application cab use this SRTPCryptoContext to encrypt / decrypt a new stream (Synchronization source) inside one RTP session. Before the application can use this SRTPCryptoContext it must call the deriveSrtpKeys method.
 * @param ssrc The SSRC for this context
 * @param roc The Roll-Over-Counter for this context
 * @param keyDerivRate The key derivation rate for this context
 * @return a new SRTPCryptoContext with all relevant data set.
 */
public SRTPCryptoContext deriveContext(long ssrc,int roc,long deriveRate){
  SRTPCryptoContext pcc=new SRTPCryptoContext(ssrc,roc,deriveRate,this.masterKey,this.masterSalt,this.policy);
  return pcc;
}","/** 
 * Derive a new SRTPCryptoContext for use with a new SSRC This method returns a new SRTPCryptoContext initialized with the data of this SRTPCryptoContext. Replacing the SSRC, Roll-over-Counter, and the key derivation rate the application cab use this SRTPCryptoContext to encrypt / decrypt a new stream (Synchronization source) inside one RTP session. Before the application can use this SRTPCryptoContext it must call the deriveSrtpKeys method.
 * @param ssrc The SSRC for this context
 * @param roc The Roll-Over-Counter for this context
 * @param deriveRate The key derivation rate for this context
 * @return a new SRTPCryptoContext with all relevant data set.
 */
public SRTPCryptoContext deriveContext(long ssrc,int roc,long deriveRate){
  SRTPCryptoContext pcc=new SRTPCryptoContext(ssrc,roc,deriveRate,this.masterKey,this.masterSalt,this.policy);
  return pcc;
}",0.9920091324200914
104384,"/** 
 * Construct a normal SRTPCryptoContext based on the given parameters.
 * @param ssrc the RTP SSRC that this SRTP cryptographic context protects.
 * @param roc the initial Roll-Over-Counter according to RFC 3711.These are the upper 32 bit of the overall 48 bit SRTP packet index. Refer to chapter 3.2.1 of the RFC.
 * @param keyDerivRate the key derivation rate defines when to recomputethe SRTP session keys. Refer to chapter 4.3.1 in the RFC.
 * @param masterKey byte array holding the master key for this SRTPcryptographic context. Refer to chapter 3.2.1 of the RFC about the role of the master key.
 * @param masterSalt byte array holding the master salt for this SRTP cryptographic context. It is used to computer the initialization vector that in turn is input to compute the session key, session authentication key and the session salt.
 * @param policy SRTP policy for this SRTP cryptographic context, defined the encryption algorithm, the authentication algorithm, etc 
 */
public SRTPCryptoContext(long ssrc,int roc,long keyDerivationRate,byte[] masterKey,byte[] masterSalt,SRTPPolicy policy){
  this.ssrc=ssrc;
  this.mki=null;
  this.roc=roc;
  this.guessedROC=0;
  this.seqNum=0;
  this.keyDerivationRate=keyDerivationRate;
  this.seqNumSet=false;
  this.policy=policy;
  this.masterKey=new byte[masterKey.length];
  System.arraycopy(masterKey,0,this.masterKey,0,this.masterKey.length);
  this.masterSalt=new byte[masterSalt.length];
  System.arraycopy(masterSalt,0,this.masterSalt,0,this.masterSalt.length);
switch (policy.getEncType()) {
case SRTPPolicy.NULL_ENCRYPTION:
    this.encKey=null;
  this.saltKey=null;
break;
case SRTPPolicy.AESCM_ENCRYPTION:
case SRTPPolicy.AESF8_ENCRYPTION:
this.encKey=new byte[this.policy.getEncKeyLength()];
this.saltKey=new byte[this.policy.getSaltKeyLength()];
break;
}
switch (policy.getAuthType()) {
case SRTPPolicy.NULL_AUTHENTICATION:
this.authKey=null;
break;
case SRTPPolicy.HMACSHA1_AUTHENTICATION:
this.authKey=new byte[policy.getAuthKeyLength()];
break;
}
}","/** 
 * Construct a normal SRTPCryptoContext based on the given parameters.
 * @param ssrc the RTP SSRC that this SRTP cryptographic context protects.
 * @param roc the initial Roll-Over-Counter according to RFC 3711.These are the upper 32 bit of the overall 48 bit SRTP packet index. Refer to chapter 3.2.1 of the RFC.
 * @param keyDerivationRate the key derivation rate defines when to recomputethe SRTP session keys. Refer to chapter 4.3.1 in the RFC.
 * @param masterKey byte array holding the master key for this SRTPcryptographic context. Refer to chapter 3.2.1 of the RFC about the role of the master key.
 * @param masterSalt byte array holding the master salt for this SRTP cryptographic context. It is used to computer the initialization vector that in turn is input to compute the session key, session authentication key and the session salt.
 * @param policy SRTP policy for this SRTP cryptographic context, defined the encryption algorithm, the authentication algorithm, etc 
 */
public SRTPCryptoContext(long ssrc,int roc,long keyDerivationRate,byte[] masterKey,byte[] masterSalt,SRTPPolicy policy){
  this.ssrc=ssrc;
  this.mki=null;
  this.roc=roc;
  this.guessedROC=0;
  this.seqNum=0;
  this.keyDerivationRate=keyDerivationRate;
  this.seqNumSet=false;
  this.policy=policy;
  this.masterKey=new byte[masterKey.length];
  System.arraycopy(masterKey,0,this.masterKey,0,this.masterKey.length);
  this.masterSalt=new byte[masterSalt.length];
  System.arraycopy(masterSalt,0,this.masterSalt,0,this.masterSalt.length);
switch (policy.getEncType()) {
case SRTPPolicy.NULL_ENCRYPTION:
    this.encKey=null;
  this.saltKey=null;
break;
case SRTPPolicy.AESCM_ENCRYPTION:
case SRTPPolicy.AESF8_ENCRYPTION:
this.encKey=new byte[this.policy.getEncKeyLength()];
this.saltKey=new byte[this.policy.getSaltKeyLength()];
break;
}
switch (policy.getAuthType()) {
case SRTPPolicy.NULL_AUTHENTICATION:
this.authKey=null;
break;
case SRTPPolicy.HMACSHA1_AUTHENTICATION:
this.authKey=new byte[policy.getAuthKeyLength()];
break;
}
}",0.9987651271918992
104385,"/** 
 * Sets the contact's presence status using the PIDF document provided. In case of conflict (more than one status per contact) the last valid status in the document is used. This implementation is very tolerant to be more compatible with bad implementations of SIMPLE. The limit of the tolerance is defined by the CPU cost: as far as the tolerance costs nothing more in well structured documents, we do it.
 * @param presenceDoc the pidf document to use
 */
public void setPidfPresenceStatus(String presenceDoc){
  Document doc=convertDocument(presenceDoc);
  if (doc == null) {
    return;
  }
  logger.debug(""String_Node_Str"" + presenceDoc);
  NodeList presList=doc.getElementsByTagName(PRESENCE_ELEMENT);
  if (presList.getLength() == 0) {
    logger.error(""String_Node_Str"");
    return;
  }
  if (presList.getLength() > 1) {
    logger.warn(""String_Node_Str"");
  }
  Node presNode=presList.item(0);
  if (presNode.getNodeType() != Node.ELEMENT_NODE) {
    logger.error(""String_Node_Str"");
    return;
  }
  Element presence=(Element)presNode;
  SipStatusEnum personStatus=null;
  NodeList personList=presence.getElementsByTagName(PERSON_ELEMENT);
  if (personList.getLength() > 1) {
    logger.error(""String_Node_Str"");
    return;
  }
  if (personList.getLength() > 0) {
    Node personNode=personList.item(0);
    if (personNode.getNodeType() != Node.ELEMENT_NODE) {
      logger.error(""String_Node_Str"");
      return;
    }
    Element person=(Element)personNode;
    NodeList activityList=person.getElementsByTagName(ACTIVITY_ELEMENT);
    if (activityList.getLength() > 0) {
      Element activity=null;
      for (int i=0; i < activityList.getLength(); i++) {
        Node activityNode=activityList.item(i);
        if (activityNode.getNodeType() != Node.ELEMENT_NODE) {
          continue;
        }
        activity=(Element)activityNode;
        if (activity.getNodeName().equals(AWAY_ELEMENT)) {
          personStatus=SipStatusEnum.AWAY;
          break;
        }
 else         if (activity.getNodeName().equals(BUSY_ELEMENT)) {
          personStatus=SipStatusEnum.BUSY;
          break;
        }
 else         if (activity.getNodeName().equals(OTP_ELEMENT)) {
          personStatus=SipStatusEnum.ON_THE_PHONE;
          break;
        }
      }
    }
  }
  NodeList tupleList=presence.getElementsByTagName(TUPLE_ELEMENT);
  for (int i=0; i < tupleList.getLength(); i++) {
    Node tupleNode=tupleList.item(i);
    if (tupleNode.getNodeType() != Node.ELEMENT_NODE) {
      continue;
    }
    Element tuple=(Element)tupleNode;
    NodeList contactList=tuple.getElementsByTagName(CONTACT_ELEMENT);
    for (int j=0; j < contactList.getLength(); j++) {
      Node contactNode=contactList.item(j);
      if (contactNode.getNodeType() != Node.ELEMENT_NODE) {
        continue;
      }
      Element contact=(Element)contactNode;
      ContactSipImpl sipcontact=(ContactSipImpl)resolveContactID(getTextContent(contact));
      if (sipcontact == null) {
        logger.debug(""String_Node_Str"" + getTextContent(contact));
        continue;
      }
      if (personStatus != null) {
        changePresenceStatusForContact(sipcontact,personStatus);
        continue;
      }
      NodeList statusList=tuple.getElementsByTagName(STATUS_ELEMENT);
      if (statusList.getLength() == 0) {
        logger.debug(""String_Node_Str"");
        continue;
      }
      int index=statusList.getLength() - 1;
      Node statusNode=null;
      do {
        Node temp=statusList.item(index);
        if (temp.getNodeType() == Node.ELEMENT_NODE) {
          statusNode=temp;
          break;
        }
        index--;
      }
 while (index >= 0);
      if (statusNode == null) {
        logger.debug(""String_Node_Str"");
        break;
      }
      Element status=(Element)statusNode;
      NodeList basicList=status.getElementsByTagName(BASIC_ELEMENT);
      if (basicList.getLength() == 0) {
        logger.debug(""String_Node_Str"");
        continue;
      }
      index=basicList.getLength() - 1;
      Node basicNode=null;
      do {
        Node temp=basicList.item(index);
        if (temp.getNodeType() == Node.ELEMENT_NODE) {
          basicNode=temp;
          break;
        }
        index--;
      }
 while (index >= 0);
      if (basicNode == null) {
        logger.debug(""String_Node_Str"");
        break;
      }
      Element basic=(Element)basicNode;
      NodeList noteList=tuple.getElementsByTagName(NOTE_ELEMENT);
      boolean changed=false;
      for (int k=0; k < noteList.getLength() && !changed; k++) {
        Node noteNode=noteList.item(k);
        if (noteNode.getNodeType() != Node.ELEMENT_NODE) {
          continue;
        }
        Element note=(Element)noteNode;
        String state=getTextContent(note);
        Iterator states=SipStatusEnum.supportedStatusSet();
        while (states.hasNext()) {
          SipStatusEnum current=(SipStatusEnum)states.next();
          if (current.getStatusName().equalsIgnoreCase(state)) {
            changed=true;
            changePresenceStatusForContact(sipcontact,current);
            break;
          }
        }
      }
      if (changed == false) {
        if (getTextContent(basic).equalsIgnoreCase(ONLINE_STATUS)) {
          changePresenceStatusForContact(sipcontact,SipStatusEnum.ONLINE);
        }
 else         if (getTextContent(basic).equalsIgnoreCase(OFFLINE_STATUS)) {
          changePresenceStatusForContact(sipcontact,SipStatusEnum.OFFLINE);
        }
      }
    }
  }
}","/** 
 * Sets the contact's presence status using the PIDF document provided. In case of conflict (more than one status per contact) the last valid status in the document is used. This implementation is very tolerant to be more compatible with bad implementations of SIMPLE. The limit of the tolerance is defined by the CPU cost: as far as the tolerance costs nothing more in well structured documents, we do it.
 * @param presenceDoc the pidf document to use
 */
public void setPidfPresenceStatus(String presenceDoc){
  Document doc=convertDocument(presenceDoc);
  if (doc == null) {
    return;
  }
  logger.debug(""String_Node_Str"" + presenceDoc);
  NodeList presList=doc.getElementsByTagNameNS(NS_VALUE,PRESENCE_ELEMENT);
  if (presList.getLength() == 0) {
    logger.error(""String_Node_Str"");
    return;
  }
  if (presList.getLength() > 1) {
    logger.warn(""String_Node_Str"");
  }
  Node presNode=presList.item(0);
  if (presNode.getNodeType() != Node.ELEMENT_NODE) {
    logger.error(""String_Node_Str"");
    return;
  }
  Element presence=(Element)presNode;
  SipStatusEnum personStatus=null;
  NodeList personList=presence.getElementsByTagNameNS(ANY_NS,PERSON_ELEMENT);
  if (personList.getLength() > 1) {
    logger.error(""String_Node_Str"");
    return;
  }
  if (personList.getLength() > 0) {
    Node personNode=personList.item(0);
    if (personNode.getNodeType() != Node.ELEMENT_NODE) {
      logger.error(""String_Node_Str"");
      return;
    }
    Element person=(Element)personNode;
    NodeList activityList=person.getElementsByTagNameNS(ANY_NS,ACTIVITY_ELEMENT);
    if (activityList.getLength() > 0) {
      Element activity=null;
      for (int i=0; i < activityList.getLength(); i++) {
        Node activityNode=activityList.item(i);
        if (activityNode.getNodeType() != Node.ELEMENT_NODE) {
          continue;
        }
        activity=(Element)activityNode;
        NodeList statusList=activity.getChildNodes();
        for (int j=0; j < statusList.getLength(); j++) {
          Node statusNode=statusList.item(j);
          if (statusNode.getNodeType() == Node.ELEMENT_NODE) {
            String statusname=statusNode.getLocalName();
            if (statusname.equals(AWAY_ELEMENT)) {
              personStatus=SipStatusEnum.AWAY;
              break;
            }
 else             if (statusname.equals(BUSY_ELEMENT)) {
              personStatus=SipStatusEnum.BUSY;
              break;
            }
 else             if (statusname.equals(OTP_ELEMENT)) {
              personStatus=SipStatusEnum.ON_THE_PHONE;
              break;
            }
          }
        }
        if (personStatus != null)         break;
      }
    }
  }
  NodeList tupleList=presence.getElementsByTagNameNS(NS_VALUE,TUPLE_ELEMENT);
  for (int i=0; i < tupleList.getLength(); i++) {
    Node tupleNode=tupleList.item(i);
    if (tupleNode.getNodeType() != Node.ELEMENT_NODE) {
      continue;
    }
    Element tuple=(Element)tupleNode;
    NodeList contactList=tuple.getElementsByTagNameNS(NS_VALUE,CONTACT_ELEMENT);
    Vector sipcontact=new Vector(1,3);
    String contactID=null;
    if (contactList.getLength() == 0) {
      contactID=XMLUtils.getAttribute(presNode,ENTITY_ATTRIBUTE);
      if (contactID.startsWith(""String_Node_Str""))       contactID=contactID.substring(""String_Node_Str"".length());
      Contact tmpContact=resolveContactID(contactID);
      if (tmpContact != null) {
        sipcontact.add(tmpContact);
      }
    }
 else {
      for (int j=0; j < contactList.getLength(); j++) {
        Node contactNode=contactList.item(j);
        if (contactNode.getNodeType() != Node.ELEMENT_NODE) {
          continue;
        }
        Element contact=(Element)contactNode;
        contactID=getTextContent(contact);
        Contact tmpContact=resolveContactID(contactID);
        if (tmpContact != null) {
          sipcontact.add(tmpContact);
        }
      }
    }
    if (sipcontact.isEmpty()) {
      logger.debug(""String_Node_Str"" + contactID);
      continue;
    }
    if (personStatus != null) {
      for (int j=0; j < sipcontact.size(); j++) {
        changePresenceStatusForContact((ContactSipImpl)sipcontact.get(j),personStatus);
      }
      continue;
    }
    NodeList statusList=tuple.getElementsByTagNameNS(NS_VALUE,STATUS_ELEMENT);
    int index=statusList.getLength() - 1;
    Node statusNode=null;
    do {
      Node temp=statusList.item(index);
      if (temp.getNodeType() == Node.ELEMENT_NODE) {
        statusNode=temp;
        break;
      }
      index--;
    }
 while (index >= 0);
    Element basic=null;
    if (statusNode == null) {
      logger.debug(""String_Node_Str"");
    }
 else {
      Element status=(Element)statusNode;
      NodeList basicList=status.getElementsByTagNameNS(NS_VALUE,BASIC_ELEMENT);
      index=basicList.getLength() - 1;
      Node basicNode=null;
      do {
        Node temp=basicList.item(index);
        if (temp.getNodeType() == Node.ELEMENT_NODE) {
          basicNode=temp;
          break;
        }
        index--;
      }
 while (index >= 0);
      if (basicNode == null) {
        logger.debug(""String_Node_Str"");
      }
 else {
        basic=(Element)basicNode;
      }
    }
    NodeList noteList=tuple.getElementsByTagNameNS(NS_VALUE,NOTE_ELEMENT);
    boolean changed=false;
    for (int k=0; k < noteList.getLength() && !changed; k++) {
      Node noteNode=noteList.item(k);
      if (noteNode.getNodeType() != Node.ELEMENT_NODE) {
        continue;
      }
      Element note=(Element)noteNode;
      String state=getTextContent(note);
      Iterator states=SipStatusEnum.supportedStatusSet();
      while (states.hasNext()) {
        SipStatusEnum current=(SipStatusEnum)states.next();
        if (current.getStatusName().equalsIgnoreCase(state)) {
          changed=true;
          for (int j=0; j < sipcontact.size(); j++) {
            changePresenceStatusForContact((ContactSipImpl)sipcontact.get(j),current);
          }
          break;
        }
      }
    }
    if (changed == false && basic != null) {
      if (getTextContent(basic).equalsIgnoreCase(ONLINE_STATUS)) {
        for (int j=0; j < sipcontact.size(); j++) {
          changePresenceStatusForContact((ContactSipImpl)sipcontact.get(j),SipStatusEnum.ONLINE);
        }
      }
 else       if (getTextContent(basic).equalsIgnoreCase(OFFLINE_STATUS)) {
        for (int j=0; j < sipcontact.size(); j++) {
          changePresenceStatusForContact((ContactSipImpl)sipcontact.get(j),SipStatusEnum.OFFLINE);
        }
      }
    }
 else {
      if (changed == false) {
        logger.debug(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
}",0.7634559735427863
104386,"/** 
 * Refreshes all the registered feeds.
 */
public void refreshAllRssFeeds(){
  Vector rssContactList=new Vector();
  rssContactList=opSetPersPresence.getContactListRoot().getRssURLList(rssContactList);
  Iterator rssContact=rssContactList.iterator();
  while (rssContact.hasNext()) {
    submitRssQuery((ContactRssImpl)rssContact.next(),false);
  }
}","/** 
 * Refreshes all the registered feeds.
 */
public void refreshAllRssFeeds(){
  Vector rssContactList=new Vector();
  rssContactList=opSetPersPresence.getContactListRoot().getRssURLList(rssContactList);
  Iterator rssContact=rssContactList.iterator();
  while (rssContact.hasNext()) {
    ContactRssImpl contact=(ContactRssImpl)rssContact.next();
    try {
      submitRssQuery(contact,false);
    }
 catch (    Exception ex) {
      logger.error(""String_Node_Str"" + contact,ex);
    }
  }
}",0.7576470588235295
104387,"/** 
 * Used for restoring the key information from a textual representation.
 * @param settings textual representation of the stored data
 */
public static RssItemKey deserialize(String settings){
  StringTokenizer reader=new StringTokenizer(settings,""String_Node_Str"");
  RssItemKey result=new RssItemKey();
  while (reader.hasMoreTokens()) {
    String data[]=reader.nextToken().split(""String_Node_Str"");
    if (data[0].equals(""String_Node_Str"")) {
      if (data.length == 2) {
        try {
          result.itemDate=formatter.parse(data[1]);
        }
 catch (        ParseException e) {
          result.itemDate=null;
        }
      }
 else       result.itemDate=null;
    }
    if (data[0].equals(""String_Node_Str"")) {
      if (data.length == 2)       result.itemUri=data[1];
 else       result.itemUri=null;
    }
    if (data[0].equals(""String_Node_Str"")) {
      if (data.length == 2)       result.usesDate=Boolean.valueOf(data[1]).booleanValue();
 else       result.usesDate=result.itemDate == null;
    }
  }
  if (result.itemDate == null && result.itemUri == null)   return null;
 else   return result;
}","/** 
 * Used for restoring the key information from a textual representation.
 * @param settings textual representation of the stored data
 * @return the result rss item
 */
public static RssItemKey deserialize(String settings){
  StringTokenizer reader=new StringTokenizer(settings,""String_Node_Str"");
  RssItemKey result=new RssItemKey();
  while (reader.hasMoreTokens()) {
    String data[]=reader.nextToken().split(""String_Node_Str"",2);
    if (data[0].equals(""String_Node_Str"")) {
      if (data.length == 2) {
        try {
          result.itemDate=formatter.parse(data[1]);
        }
 catch (        ParseException e) {
          result.itemDate=null;
        }
      }
 else       result.itemDate=null;
    }
    if (data[0].equals(""String_Node_Str"")) {
      if (data.length == 2)       result.itemUri=data[1];
 else       result.itemUri=null;
    }
    if (data[0].equals(""String_Node_Str"")) {
      if (data.length == 2)       result.usesDate=Boolean.valueOf(data[1]).booleanValue();
 else       result.usesDate=result.itemDate == null;
    }
  }
  if (result.itemDate == null && result.itemUri == null)   return null;
 else   return result;
}",0.9855072463768116
104388,"/** 
 * Tests if an ID is valid.
 */
private static boolean isIDValid(String id){
  boolean isValid=true;
  int pos=id.indexOf('%');
  if (pos < 0) {
    isValid=!hasSpecialChar(id);
  }
 else {
    if (pos + 1 < id.length()) {
      String start=id.substring(0,pos);
      String end=id.substring(pos + 1);
      isValid=!hasSpecialChar(start);
      if (isValid) {
        try {
          Integer.parseInt(end,16);
          isValid=true;
        }
 catch (        Exception e) {
          isValid=false;
        }
      }
    }
 else {
      isValid=false;
    }
  }
  return isValid;
}","/** 
 * Tests if an ID is valid.
 */
private static boolean isIDValid(String id){
  boolean isValid=true;
  int pos=id.indexOf('$');
  if (pos < 0) {
    isValid=!hasSpecialChar(id);
  }
 else {
    if (pos + 1 < id.length()) {
      String start=id.substring(0,pos);
      String end=id.substring(pos + 1);
      isValid=!hasSpecialChar(start);
      if (isValid) {
        try {
          Integer.parseInt(end,16);
          isValid=true;
        }
 catch (        Exception e) {
          isValid=false;
        }
      }
    }
 else {
      isValid=false;
    }
  }
  return isValid;
}",0.99830220713073
104389,"/** 
 * An one-way function returning a ""human readable"" containing no special characters. All characters _, a-z, A-Z, 0-9 are kept unchainged. All other are replaced with _ and the word is postfixed with %HASHCODE, where HASHCODE is the hexadecimal hash value of the original string. If there are no special characters the word is not postfixed. Note: This method does not use URLEncoder, because in url-encoding the  sign is considered as ""safe"".
 * @param rawString The string to be hashed.
 * @return The human-readable hash.
 */
public static String readableHash(String rawString){
  StringBuffer encodedString=new StringBuffer(rawString);
  boolean addHash=false;
  for (int i=0; i < encodedString.length(); i++) {
    if (HistoryID.isSpecialChar(encodedString.charAt(i))) {
      addHash=true;
      encodedString.setCharAt(i,'_');
    }
  }
  if (addHash) {
    encodedString.append('%');
    encodedString.append(Integer.toHexString(rawString.hashCode()));
  }
  return encodedString.toString();
}","/** 
 * An one-way function returning a ""human readable"" containing no special characters. All characters _, a-z, A-Z, 0-9 are kept unchainged. All other are replaced with _ and the word is postfixed with $HASHCODE, where HASHCODE is the hexadecimal hash value of the original string. If there are no special characters the word is not postfixed. Note: This method does not use URLEncoder, because in url-encoding the  sign is considered as ""safe"".
 * @param rawString The string to be hashed.
 * @return The human-readable hash.
 */
public static String readableHash(String rawString){
  StringBuffer encodedString=new StringBuffer(rawString);
  boolean addHash=false;
  for (int i=0; i < encodedString.length(); i++) {
    if (HistoryID.isSpecialChar(encodedString.charAt(i))) {
      addHash=true;
      encodedString.setCharAt(i,'_');
    }
  }
  if (addHash) {
    encodedString.append('$');
    encodedString.append(Integer.toHexString(rawString.hashCode()));
  }
  return encodedString.toString();
}",0.9980119284294234
104390,"/** 
 * Tests if a character is a special one. A character is special if it is not in the range _, a-z, A-Z, 0-9.
 * @param c The character to test.
 * @return Returns true if the character is special. False otherwise.
 */
private static boolean isSpecialChar(char c){
  return (c != '_') && (c < 'A' || c > 'Z') && (c < 'a' || c > 'z')&& (c < '0' || c > '9');
}","/** 
 * Tests if a character is a special one. A character is special if it is not in the range _, a-z, A-Z, 0-9.
 * @param c The character to test.
 * @return Returns true if the character is special. False otherwise.
 */
private static boolean isSpecialChar(char c){
  return (c != '_') && (c != '@') && (c != '.')&& (c != '-')&& (c != '+')&& (c < 'A' || c > 'Z')&& (c < 'a' || c > 'z')&& (c < '0' || c > '9');
}",0.9304123711340206
104391,"/** 
 * Tests there is a special character in a string.
 */
private static boolean hasSpecialChar(String str){
  boolean hasSpecialChar=false;
  for (int i=0; i < str.length(); i++) {
    if (isSpecialChar(str.charAt(i))) {
      hasSpecialChar=false;
      break;
    }
  }
  return hasSpecialChar;
}","/** 
 * Tests there is a special character in a string.
 */
private static boolean hasSpecialChar(String str){
  boolean hasSpecialChar=false;
  for (int i=0; i < str.length(); i++) {
    if (isSpecialChar(str.charAt(i))) {
      hasSpecialChar=true;
      break;
    }
  }
  return hasSpecialChar;
}",0.9883527454242927
104392,"/** 
 * Creates a room with the named <tt>roomName</tt> and according to the specified <tt>roomProperties</tt> on the server that this protocol provider is currently connected to. When the method returns the room the local user will not have joined it and thus will not receive messages on it until the <tt>ChatRoom.join()</tt> method is called. <p>
 * @param roomName the name of the <tt>ChatRoom</tt> to create.
 * @param roomProperties properties specifying how the room should becreated.
 * @throws OperationFailedException if the room couldn't be created for somereason (e.g. room already exists; user already joined to an existant room or user has no permissions to create a chat room).
 * @throws OperationNotSupportedException if chat room creation is notsupported by this server
 * @return the newly created <tt>ChatRoom</tt> named <tt>roomName</tt>.
 */
public ChatRoom createChatRoom(String roomName,Hashtable roomProperties) throws OperationFailedException, OperationNotSupportedException ;","/** 
 * Creates a room with the named <tt>roomName</tt> and according to the specified <tt>roomProperties</tt> on the server that this protocol provider is currently connected to. When the method returns the room the local user will not have joined it and thus will not receive messages on it until the <tt>ChatRoom.join()</tt> method is called. <p>
 * @param roomName the name of the <tt>ChatRoom</tt> to create.
 * @param roomProperties properties specifying how the room should becreated.
 * @throws OperationFailedException if the room couldn't be created for somereason (e.g. room already exists; user already joined to an existent room or user has no permissions to create a chat room).
 * @throws OperationNotSupportedException if chat room creation is notsupported by this server
 * @return the newly created <tt>ChatRoom</tt> named <tt>roomName</tt>.
 */
public ChatRoom createChatRoom(String roomName,Hashtable roomProperties) throws OperationFailedException, OperationNotSupportedException ;",0.999001996007984
104393,"/** 
 * Formats message smilies.
 * @param message The source message string.
 * @return The message string with properly formated smilies.
 */
private String processSmilies(String message,String contentType){
  String startPlainTextTag;
  String endPlainTextTag;
  if (contentType == null || contentType.equals(TEXT_CONTENT_TYPE) || ""String_Node_Str"".equals(contentType)) {
    startPlainTextTag=""String_Node_Str"";
    endPlainTextTag=""String_Node_Str"";
  }
 else {
    if (HTML_CONTENT_TYPE.equals(contentType)) {
      message=removeAltFromHTMLSmilies(message);
    }
    startPlainTextTag=""String_Node_Str"";
    endPlainTextTag=""String_Node_Str"";
  }
  ArrayList smiliesList=ImageLoader.getDefaultSmiliesPack();
  StringBuffer regexp=new StringBuffer();
  for (int i=0; i < smiliesList.size(); i++) {
    Smiley smiley=(Smiley)smiliesList.get(i);
    String[] smileyStrings=smiley.getSmileyStrings();
    for (int j=0; j < smileyStrings.length; j++) {
      regexp.append(GuiUtils.replaceSpecialRegExpChars(smileyStrings[j])).append(""String_Node_Str"");
    }
  }
  regexp=regexp.deleteCharAt(regexp.length() - 1);
  Pattern p=Pattern.compile(regexp.toString());
  Matcher m=p.matcher(message);
  StringBuffer msgBuffer=new StringBuffer();
  boolean matchSuccessfull=false;
  while (m.find()) {
    if (!matchSuccessfull)     matchSuccessfull=true;
    String matchGroup=m.group().trim();
    String replacement=endPlainTextTag + ""String_Node_Str"" + ImageLoader.getSmiley(matchGroup).getImagePath()+ ""String_Node_Str""+ matchGroup+ ""String_Node_Str""+ startPlainTextTag;
    m.appendReplacement(msgBuffer,GuiUtils.replaceSpecialRegExpChars(replacement));
  }
  m.appendTail(msgBuffer);
  return msgBuffer.toString();
}","/** 
 * Formats message smilies.
 * @param message The source message string.
 * @return The message string with properly formated smilies.
 */
private String processSmilies(String message,String contentType){
  String startPlainTextTag;
  String endPlainTextTag;
  if (contentType == null || contentType.equals(TEXT_CONTENT_TYPE) || ""String_Node_Str"".equals(contentType)) {
    startPlainTextTag=""String_Node_Str"";
    endPlainTextTag=""String_Node_Str"";
  }
 else {
    startPlainTextTag=""String_Node_Str"";
    endPlainTextTag=""String_Node_Str"";
  }
  ArrayList smiliesList=ImageLoader.getDefaultSmiliesPack();
  StringBuffer regexp=new StringBuffer();
  regexp.append(""String_Node_Str"");
  for (int i=0; i < smiliesList.size(); i++) {
    Smiley smiley=(Smiley)smiliesList.get(i);
    String[] smileyStrings=smiley.getSmileyStrings();
    for (int j=0; j < smileyStrings.length; j++) {
      regexp.append(GuiUtils.replaceSpecialRegExpChars(smileyStrings[j])).append(""String_Node_Str"");
    }
  }
  regexp=regexp.deleteCharAt(regexp.length() - 1);
  regexp.append(')');
  Pattern p=Pattern.compile(regexp.toString());
  Matcher m=p.matcher(message);
  StringBuffer msgBuffer=new StringBuffer();
  boolean matchSuccessfull=false;
  while (m.find()) {
    if (!matchSuccessfull)     matchSuccessfull=true;
    String matchGroup=m.group().trim();
    String replacement=endPlainTextTag + ""String_Node_Str"" + ImageLoader.getSmiley(matchGroup).getImagePath()+ ""String_Node_Str""+ matchGroup+ ""String_Node_Str""+ startPlainTextTag;
    m.appendReplacement(msgBuffer,GuiUtils.replaceSpecialRegExpChars(replacement));
  }
  m.appendTail(msgBuffer);
  return msgBuffer.toString();
}",0.952240566037736
104394,"/** 
 * Creates a number of dummy contacts and fills the specified provider with them.
 * @param provider the <tt>MockProvider</tt> to fill in.
 */
private void fillMockContactList(MockProvider provider){
  MockPersistentPresenceOperationSet mockOpSet=(MockPersistentPresenceOperationSet)provider.getSupportedOperationSets().get(OperationSetPersistentPresence.class.getName());
  MockContactGroup root=(MockContactGroup)mockOpSet.getServerStoredContactListRoot();
  root.addContact(new MockContact(""String_Node_Str"",provider));
  root.addContact(new MockContact(""String_Node_Str"",provider));
  root.addContact(new MockContact(""String_Node_Str"",provider));
  mockContactToRename=new MockContact(""String_Node_Str"",provider);
  root.addContact(mockContactToRename);
  mockContactToReorder=new MockContact(""String_Node_Str"",provider);
  root.addContact(mockContactToReorder);
  topLevelMockGroup=new MockContactGroup(topLevelGroupName,provider);
  subLevelContact=new MockContact(subLevelContactName,provider);
  topLevelMockGroup.addContact(subLevelContact);
  topLevelMockGroup.addContact(new MockContact(""String_Node_Str"",provider));
  topLevelMockGroup.addContact(new MockContact(""String_Node_Str"",provider));
  subLevelGroup=new MockContactGroup(""String_Node_Str"",provider);
  subsubContact=new MockContact(""String_Node_Str"",provider);
  subLevelGroup.addContact(subsubContact);
  subLevelGroup.addContact(new MockContact(""String_Node_Str"",provider));
  subLevelGroup.addContact(new MockContact(""String_Node_Str"",provider));
  subLevelGroup.addContact(new MockContact(""String_Node_Str"",provider));
  topLevelMockGroup.addSubgroup(subLevelGroup);
  root.addSubgroup(topLevelMockGroup);
}","/** 
 * Creates a number of dummy contacts and fills the specified provider with them.
 * @param provider the <tt>MockProvider</tt> to fill in.
 */
private void fillMockContactList(MockProvider provider){
  MockPersistentPresenceOperationSet mockOpSet=(MockPersistentPresenceOperationSet)provider.getSupportedOperationSets().get(OperationSetPersistentPresence.class.getName());
  MockContactGroup root=(MockContactGroup)mockOpSet.getServerStoredContactListRoot();
  root.addContact(new MockContact(""String_Node_Str"",provider));
  root.addContact(new MockContact(""String_Node_Str"",provider));
  root.addContact(new MockContact(""String_Node_Str"",provider));
  MockContact someOfflineContact=new MockContact(""String_Node_Str"",provider);
  someOfflineContact.setPresenceStatus(MockStatusEnum.MOCK_STATUS_00);
  root.addContact(someOfflineContact);
  mockContactToRename=new MockContact(""String_Node_Str"",provider);
  root.addContact(mockContactToRename);
  mockContactToReorder=new MockContact(""String_Node_Str"",provider);
  mockContactToReorder.setPresenceStatus(MockStatusEnum.MOCK_STATUS_00);
  root.addContact(mockContactToReorder);
  topLevelMockGroup=new MockContactGroup(topLevelGroupName,provider);
  subLevelContact=new MockContact(subLevelContactName,provider);
  topLevelMockGroup.addContact(subLevelContact);
  topLevelMockGroup.addContact(new MockContact(""String_Node_Str"",provider));
  topLevelMockGroup.addContact(new MockContact(""String_Node_Str"",provider));
  subLevelGroup=new MockContactGroup(""String_Node_Str"",provider);
  subsubContact=new MockContact(""String_Node_Str"",provider);
  subLevelGroup.addContact(subsubContact);
  subLevelGroup.addContact(new MockContact(""String_Node_Str"",provider));
  subLevelGroup.addContact(new MockContact(""String_Node_Str"",provider));
  subLevelGroup.addContact(new MockContact(""String_Node_Str"",provider));
  topLevelMockGroup.addSubgroup(subLevelGroup);
  root.addSubgroup(topLevelMockGroup);
}",0.9221458046767538
104395,"/** 
 * Verifies whether contacts are properly ordered according to their current status and name Checks whether reordered events are issued once a contact inside this group changes its status or is added removed a contact.
 */
public void testContactsOrder(){
  assertContactsOrder(fixture.metaClService.getRoot());
  MclEventCollector evtCollector=new MclEventCollector();
  fixture.metaClService.addMetaContactListListener(evtCollector);
  ((MockPersistentPresenceOperationSet)fixture.mockPresOpSet).changePresenceStatusForContact(MetaContactListServiceLick.mockContactToReorder,MockStatusEnum.MOCK_STATUS_100);
  fixture.metaClService.removeMetaContactListListener(evtCollector);
  assertEquals(""String_Node_Str"",1,evtCollector.collectedMetaContactGroupEvents.size());
  MetaContactGroupEvent evt=(MetaContactGroupEvent)evtCollector.collectedMetaContactGroupEvents.remove(0);
  assertEquals(""String_Node_Str"",MetaContactGroupEvent.CHILD_CONTACTS_REORDERED,evt.getEventID());
  assertEquals(""String_Node_Str"",fixture.metaClService.getRoot(),evt.getSourceMetaContactGroup());
  MetaContact theReorderedContact=fixture.metaClService.getRoot().getMetaContact(0);
  assertEquals(MetaContactListServiceLick.mockContactToReorder + ""String_Node_Str"" + ""String_Node_Str"",MetaContactListServiceLick.mockContactToReorder.getDisplayName(),theReorderedContact.getDisplayName());
  assertContactsOrder(fixture.metaClService.getRoot());
  ((MockPersistentPresenceOperationSet)fixture.mockPresOpSet).changePresenceStatusForContact(MetaContactListServiceLick.mockContactToReorder,MockStatusEnum.MOCK_STATUS_00);
  fixture.metaClService.addMetaContactListListener(evtCollector);
  fixture.metaClService.renameMetaContact(theReorderedContact,""String_Node_Str"");
  fixture.metaClService.removeMetaContactListListener(evtCollector);
  assertEquals(""String_Node_Str"" + ""String_Node_Str"",1,evtCollector.collectedMetaContactGroupEvents.size());
  evt=(MetaContactGroupEvent)evtCollector.collectedMetaContactGroupEvents.remove(0);
  assertEquals(""String_Node_Str"",MetaContactGroupEvent.CHILD_CONTACTS_REORDERED,evt.getEventID());
  assertEquals(""String_Node_Str"",fixture.metaClService.getRoot(),evt.getSourceMetaContactGroup());
  assertSame(MetaContactListServiceLick.mockContactToReorder + ""String_Node_Str"" + ""String_Node_Str"",theReorderedContact,fixture.metaClService.getRoot().getMetaContact(fixture.metaClService.getRoot().countChildContacts() - 1));
}","/** 
 * Verifies whether contacts are properly ordered according to their current status and name Checks whether reordered events are issued once a contact inside this group changes its status or is added removed a contact.
 */
public void testContactsOrder(){
  assertContactsOrder(fixture.metaClService.getRoot());
  MclEventCollector evtCollector=new MclEventCollector();
  fixture.metaClService.addMetaContactListListener(evtCollector);
  ((MockPersistentPresenceOperationSet)fixture.mockPresOpSet).changePresenceStatusForContact(MetaContactListServiceLick.mockContactToReorder,MockStatusEnum.MOCK_STATUS_100);
  fixture.metaClService.removeMetaContactListListener(evtCollector);
  assertEquals(""String_Node_Str"",1,evtCollector.collectedMetaContactGroupEvents.size());
  MetaContactGroupEvent evt=(MetaContactGroupEvent)evtCollector.collectedMetaContactGroupEvents.remove(0);
  assertEquals(""String_Node_Str"",MetaContactGroupEvent.CHILD_CONTACTS_REORDERED,evt.getEventID());
  assertEquals(""String_Node_Str"",fixture.metaClService.getRoot(),evt.getSourceMetaContactGroup());
  assertContactsOrder(fixture.metaClService.getRoot());
  ((MockPersistentPresenceOperationSet)fixture.mockPresOpSet).changePresenceStatusForContact(MetaContactListServiceLick.mockContactToReorder,MockStatusEnum.MOCK_STATUS_00);
  fixture.metaClService.addMetaContactListListener(evtCollector);
  MetaContact theReorderedContact=fixture.metaClService.findMetaContactByContact(MetaContactListServiceLick.mockContactToReorder);
  fixture.metaClService.renameMetaContact(theReorderedContact,""String_Node_Str"");
  fixture.metaClService.removeMetaContactListListener(evtCollector);
  assertEquals(""String_Node_Str"" + ""String_Node_Str"",1,evtCollector.collectedMetaContactGroupEvents.size());
  evt=(MetaContactGroupEvent)evtCollector.collectedMetaContactGroupEvents.remove(0);
  assertEquals(""String_Node_Str"",MetaContactGroupEvent.CHILD_CONTACTS_REORDERED,evt.getEventID());
  assertEquals(""String_Node_Str"",fixture.metaClService.getRoot(),evt.getSourceMetaContactGroup());
  assertSame(MetaContactListServiceLick.mockContactToReorder + ""String_Node_Str"" + ""String_Node_Str"",theReorderedContact,fixture.metaClService.getRoot().getMetaContact(fixture.metaClService.getRoot().countChildContacts() - 1));
}",0.9102482495225972
104396,"/** 
 * Restores all accounts stored for the package corresponding to sourceFactory and and installs everyone of them through the install account method. <p>
 * @param bundleContext a currently valid bundle context.
 */
protected void loadStoredAccounts(BundleContext bundleContext){
  String sourcePackageName=getFactoryImplPackageName();
  ServiceReference confReference=bundleContext.getServiceReference(ConfigurationService.class.getName());
  ConfigurationService configurationService=(ConfigurationService)bundleContext.getService(confReference);
  List storedAccounts=configurationService.getPropertyNamesByPrefix(sourcePackageName,true);
  logger.debug(""String_Node_Str"" + storedAccounts.size() + ""String_Node_Str"");
  Iterator storedAccountsIter=storedAccounts.iterator();
  while (storedAccountsIter.hasNext()) {
    String accountRootPropName=(String)storedAccountsIter.next();
    logger.debug(""String_Node_Str"" + accountRootPropName);
    List storedAccPropNames=configurationService.getPropertyNamesByPrefix(accountRootPropName,true);
    Iterator propNamesIter=storedAccPropNames.iterator();
    Map accountProperties=new Hashtable();
    while (propNamesIter.hasNext()) {
      String fullPropertyName=(String)propNamesIter.next();
      String storedPropertyValue=configurationService.getString(fullPropertyName);
      String propertyName=fullPropertyName.substring(fullPropertyName.lastIndexOf('.') + 1);
      if (propertyName.equals(PASSWORD)) {
        if (storedPropertyValue == null || storedPropertyValue.length() == 0) {
          storedPropertyValue=""String_Node_Str"";
        }
 else {
          storedPropertyValue=new String(Base64.decode(storedPropertyValue));
        }
      }
      accountProperties.put(propertyName,storedPropertyValue);
    }
    loadAccount(accountProperties);
  }
}","/** 
 * Restores all accounts stored for the package corresponding to sourceFactory and and installs everyone of them through the install account method. <p>
 * @param bundleContext a currently valid bundle context.
 */
protected void loadStoredAccounts(BundleContext bundleContext){
  String sourcePackageName=getFactoryImplPackageName();
  ServiceReference confReference=bundleContext.getServiceReference(ConfigurationService.class.getName());
  ConfigurationService configurationService=(ConfigurationService)bundleContext.getService(confReference);
  List storedAccounts=configurationService.getPropertyNamesByPrefix(sourcePackageName,true);
  logger.debug(""String_Node_Str"" + storedAccounts.size() + ""String_Node_Str"");
  Iterator storedAccountsIter=storedAccounts.iterator();
  while (storedAccountsIter.hasNext()) {
    String accountRootPropName=(String)storedAccountsIter.next();
    logger.debug(""String_Node_Str"" + accountRootPropName);
    List storedAccPropNames=configurationService.getPropertyNamesByPrefix(accountRootPropName,true);
    Iterator propNamesIter=storedAccPropNames.iterator();
    Map accountProperties=new Hashtable();
    while (propNamesIter.hasNext()) {
      String fullPropertyName=(String)propNamesIter.next();
      String storedPropertyValue=configurationService.getString(fullPropertyName);
      String propertyName=fullPropertyName.substring(fullPropertyName.lastIndexOf('.') + 1);
      if (propertyName.equals(PASSWORD)) {
        if (storedPropertyValue == null || storedPropertyValue.length() == 0) {
          storedPropertyValue=""String_Node_Str"";
        }
 else {
          storedPropertyValue=new String(Base64.decode(storedPropertyValue));
        }
      }
      accountProperties.put(propertyName,storedPropertyValue);
    }
    try {
      loadAccount(accountProperties);
    }
 catch (    Exception exc) {
      logger.error(""String_Node_Str"" + accountProperties,exc);
    }
  }
}",0.9691160809371672
104397,"private void ensureDocumentSize(){
  if (document.getLength() > Constants.CHAT_BUFFER_SIZE && document.getDefaultRootElement().getElementCount() > 2) {
    Element firstElement=this.document.getDefaultRootElement().getElement(0);
    try {
      if (firstElement != null)       this.document.remove(firstElement.getStartOffset(),firstElement.getEndOffset() - firstElement.getStartOffset());
      String idAttr=(String)firstElement.getAttributes().getAttribute(""String_Node_Str"");
      if (idAttr != null && idAttr.equals(""String_Node_Str"")) {
        Element secondElement=this.document.getDefaultRootElement().getElement(0);
        this.document.remove(secondElement.getStartOffset(),secondElement.getEndOffset() - secondElement.getStartOffset());
      }
    }
 catch (    BadLocationException e) {
      LOGGER.error(""String_Node_Str"",e);
    }
  }
}","/** 
 * Ensures that the document won't become too big. When the document reaches a certain size the first message in the page is removed.
 */
private void ensureDocumentSize(){
  if (document.getLength() > Constants.CHAT_BUFFER_SIZE) {
    int msgElementCount=0;
    Element firstMsgElement=null;
    int firstMsgIndex=0;
    Element rootElement=this.document.getDefaultRootElement();
    for (int i=0; i < rootElement.getElementCount(); i++) {
      String idAttr=(String)rootElement.getElement(i).getAttributes().getAttribute(""String_Node_Str"");
      if (idAttr != null && (idAttr.equals(""String_Node_Str"") || idAttr.equals(""String_Node_Str"") || idAttr.equals(""String_Node_Str""))) {
        if (firstMsgElement == null) {
          firstMsgElement=rootElement.getElement(i);
          firstMsgIndex=i;
        }
        msgElementCount++;
      }
    }
    if (firstMsgElement == null || msgElementCount < 2)     return;
    try {
      Element headerElement=null;
      if (firstMsgIndex > 1) {
        headerElement=rootElement.getElement(firstMsgIndex - 1);
        String idAttr=(String)headerElement.getAttributes().getAttribute(""String_Node_Str"");
        if (idAttr != null && idAttr.equals(""String_Node_Str"")) {
          this.document.remove(headerElement.getStartOffset(),headerElement.getEndOffset() - headerElement.getStartOffset());
        }
      }
      this.document.remove(firstMsgElement.getStartOffset(),firstMsgElement.getEndOffset() - firstMsgElement.getStartOffset());
    }
 catch (    BadLocationException e) {
      LOGGER.error(""String_Node_Str"",e);
    }
  }
}",0.315359477124183
104398,"private void ensureDocumentSize(){
  if (document.getLength() > Constants.CHAT_BUFFER_SIZE) {
    Element firstElement=this.document.getDefaultRootElement().getElement(0);
    try {
      if (firstElement != null)       this.document.remove(firstElement.getStartOffset(),firstElement.getEndOffset() - firstElement.getStartOffset());
      String idAttr=(String)firstElement.getAttributes().getAttribute(""String_Node_Str"");
      if (idAttr != null && idAttr.equals(""String_Node_Str"")) {
        Element secondElement=this.document.getDefaultRootElement().getElement(0);
        this.document.remove(secondElement.getStartOffset(),secondElement.getEndOffset() - secondElement.getStartOffset());
      }
    }
 catch (    BadLocationException e) {
      LOGGER.error(""String_Node_Str"",e);
    }
  }
}","private void ensureDocumentSize(){
  if (document.getLength() > Constants.CHAT_BUFFER_SIZE && document.getDefaultRootElement().getElementCount() > 2) {
    Element firstElement=this.document.getDefaultRootElement().getElement(0);
    try {
      if (firstElement != null)       this.document.remove(firstElement.getStartOffset(),firstElement.getEndOffset() - firstElement.getStartOffset());
      String idAttr=(String)firstElement.getAttributes().getAttribute(""String_Node_Str"");
      if (idAttr != null && idAttr.equals(""String_Node_Str"")) {
        Element secondElement=this.document.getDefaultRootElement().getElement(0);
        this.document.remove(secondElement.getStartOffset(),secondElement.getEndOffset() - secondElement.getStartOffset());
      }
    }
 catch (    BadLocationException e) {
      LOGGER.error(""String_Node_Str"",e);
    }
  }
}",0.9649334945586456
104399,"/** 
 * Formats message smilies.
 * @param message The source message string.
 * @return The message string with properly formated smilies.
 */
private String processSmilies(String message,String contentType){
  String startPlainTextTag;
  String endPlainTextTag;
  if (contentType == null || contentType.equals(TEXT_CONTENT_TYPE) || ""String_Node_Str"".equals(contentType)) {
    startPlainTextTag=""String_Node_Str"";
    endPlainTextTag=""String_Node_Str"";
  }
 else {
    startPlainTextTag=""String_Node_Str"";
    endPlainTextTag=""String_Node_Str"";
  }
  ArrayList smiliesList=ImageLoader.getDefaultSmiliesPack();
  StringBuffer regexp=new StringBuffer();
  for (int i=0; i < smiliesList.size(); i++) {
    Smiley smiley=(Smiley)smiliesList.get(i);
    String[] smileyStrings=smiley.getSmileyStrings();
    for (int j=0; j < smileyStrings.length; j++) {
      regexp.append(GuiUtils.replaceSpecialRegExpChars(smileyStrings[j])).append(""String_Node_Str"");
    }
  }
  regexp=regexp.deleteCharAt(regexp.length() - 1);
  Pattern p=Pattern.compile(regexp.toString());
  Matcher m=p.matcher(message);
  StringBuffer msgBuffer=new StringBuffer();
  boolean matchSuccessfull=false;
  while (m.find()) {
    if (!matchSuccessfull)     matchSuccessfull=true;
    String matchGroup=m.group().trim();
    String replacement=endPlainTextTag + ""String_Node_Str"" + ImageLoader.getSmiley(matchGroup).getImagePath()+ ""String_Node_Str""+ matchGroup+ ""String_Node_Str""+ startPlainTextTag;
    m.appendReplacement(msgBuffer,GuiUtils.replaceSpecialRegExpChars(replacement));
  }
  m.appendTail(msgBuffer);
  return msgBuffer.toString();
}","/** 
 * Formats message smilies.
 * @param message The source message string.
 * @return The message string with properly formated smilies.
 */
private String processSmilies(String message,String contentType){
  String startPlainTextTag;
  String endPlainTextTag;
  if (contentType == null || contentType.equals(TEXT_CONTENT_TYPE) || ""String_Node_Str"".equals(contentType)) {
    startPlainTextTag=""String_Node_Str"";
    endPlainTextTag=""String_Node_Str"";
  }
 else {
    if (HTML_CONTENT_TYPE.equals(contentType)) {
      message=removeAltFromHTMLSmilies(message);
    }
    startPlainTextTag=""String_Node_Str"";
    endPlainTextTag=""String_Node_Str"";
  }
  ArrayList smiliesList=ImageLoader.getDefaultSmiliesPack();
  StringBuffer regexp=new StringBuffer();
  for (int i=0; i < smiliesList.size(); i++) {
    Smiley smiley=(Smiley)smiliesList.get(i);
    String[] smileyStrings=smiley.getSmileyStrings();
    for (int j=0; j < smileyStrings.length; j++) {
      regexp.append(GuiUtils.replaceSpecialRegExpChars(smileyStrings[j])).append(""String_Node_Str"");
    }
  }
  regexp=regexp.deleteCharAt(regexp.length() - 1);
  Pattern p=Pattern.compile(regexp.toString());
  Matcher m=p.matcher(message);
  StringBuffer msgBuffer=new StringBuffer();
  boolean matchSuccessfull=false;
  while (m.find()) {
    if (!matchSuccessfull)     matchSuccessfull=true;
    String matchGroup=m.group().trim();
    String replacement=endPlainTextTag + ""String_Node_Str"" + ImageLoader.getSmiley(matchGroup).getImagePath()+ ""String_Node_Str""+ matchGroup+ ""String_Node_Str""+ startPlainTextTag;
    m.appendReplacement(msgBuffer,GuiUtils.replaceSpecialRegExpChars(replacement));
  }
  m.appendTail(msgBuffer);
  return msgBuffer.toString();
}",0.9688062387522496
104400,"/** 
 * Get the PresenceStatus for a particular contact.
 * @param contactIdentifier the identifier of the contact whose statuswe're interested in.
 * @return PresenceStatus the <tt>PresenceStatus</tt> of the specified<tt>contact</tt>
 * @throws IllegalArgumentException if <tt>contact</tt> is not a contactknown to the underlying protocol provider
 * @throws IllegalStateException if the underlying protocol provider isnot registered/signed on a public service.
 * @throws OperationFailedException with code NETWORK_FAILURE ifretrieving the status fails due to errors experienced during network communication
 */
public PresenceStatus queryContactStatus(String contactIdentifier) throws IllegalArgumentException, IllegalStateException, OperationFailedException {
  return resolveContactID(contactIdentifier).getPresenceStatus();
}","/** 
 * Get the PresenceStatus for a particular contact.
 * @param contactIdentifier the identifier of the contact whose statuswe're interested in.
 * @return PresenceStatus the <tt>PresenceStatus</tt> of the specified<tt>contact</tt>
 * @throws IllegalArgumentException if <tt>contact</tt> is not a contactknown to the underlying protocol provider
 * @throws IllegalStateException if the underlying protocol provider isnot registered/signed on a public service.
 * @throws OperationFailedException with code NETWORK_FAILURE ifretrieving the status fails due to errors experienced during network communication
 */
public PresenceStatus queryContactStatus(String contactIdentifier) throws IllegalArgumentException, IllegalStateException, OperationFailedException {
  Contact contact=resolveContactID(contactIdentifier);
  if (contact == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + contactIdentifier + ""String_Node_Str"");
  }
  return contact.getPresenceStatus();
}",0.906989543203082
104401,"/** 
 * Requests the provider to enter into a status corresponding to the specified paramters.
 * @param status the PresenceStatus as returned bygetRequestableStatusSet
 * @param statusMessage the message that should be set as the reason toenter that status
 * @throws IllegalArgumentException if the status requested is not avalid PresenceStatus supported by this provider.
 * @throws IllegalStateException if the provider is not currentlyregistered.
 * @throws OperationFailedException with code NETWORK_FAILURE ifpublishing the status fails due to a network error.
 */
public void publishPresenceStatus(PresenceStatus status,String statusMsg) throws IllegalArgumentException, IllegalStateException, OperationFailedException {
  PresenceStatus oldStatus=this.presenceStatus;
  this.presenceStatus=status;
  String oldMessage=this.statusMessage;
  this.statusMessage=statusMsg;
  this.fireProviderStatusChangeEvent(oldStatus);
  this.fireProviderMsgStatusChangeEvent(oldMessage);
  if (!status.equals(SipStatusEnum.OFFLINE)) {
    assertConnected();
  }
  if (status.equals(SipStatusEnum.OFFLINE)) {
    unsubscribeToAllContact();
  }
  if (this.useDistantPA) {
    Request req=createPublish(PUBLISH_DEFAULT_EXPIRE,true);
    if (status.equals(SipStatusEnum.OFFLINE)) {
synchronized (this.waitedCallIds) {
        this.waitedCallIds.add(((CallIdHeader)req.getHeader(CallIdHeader.NAME)).getCallId());
      }
    }
    ClientTransaction transac=null;
    try {
      transac=this.parentProvider.getDefaultJainSipProvider().getNewClientTransaction(req);
    }
 catch (    TransactionUnavailableException e) {
      logger.debug(""String_Node_Str"",e);
      throw new OperationFailedException(""String_Node_Str"",OperationFailedException.NETWORK_FAILURE);
    }
    try {
      transac.sendRequest();
    }
 catch (    SipException e) {
      logger.debug(""String_Node_Str"");
      throw new OperationFailedException(""String_Node_Str"",OperationFailedException.NETWORK_FAILURE);
    }
  }
 else {
synchronized (this.ourWatchers) {
      Iterator iter=this.ourWatchers.iterator();
      ContactSipImpl me=(ContactSipImpl)getLocalContact();
      while (iter.hasNext()) {
        ContactSipImpl contact=(ContactSipImpl)iter.next();
        if (!contact.isResolved()) {
          continue;
        }
        ClientTransaction transac=null;
        try {
          if (status.equals(SipStatusEnum.OFFLINE)) {
            transac=createNotify(contact,getPidfPresenceStatus(me),SubscriptionStateHeader.TERMINATED,SubscriptionStateHeader.PROBATION);
synchronized (this.waitedCallIds) {
              this.waitedCallIds.add(transac.getDialog().getCallId().getCallId());
            }
          }
 else {
            transac=createNotify(contact,getPidfPresenceStatus(me),SubscriptionStateHeader.ACTIVE,null);
          }
        }
 catch (        OperationFailedException e) {
          logger.debug(""String_Node_Str"",e);
          return;
        }
        try {
          contact.getServerDialog().sendRequest(transac);
        }
 catch (        Exception e) {
          logger.debug(""String_Node_Str"");
          return;
        }
      }
      if (status.equals(SipStatusEnum.OFFLINE)) {
synchronized (this.ourWatchers) {
          this.ourWatchers.removeAllElements();
        }
      }
    }
  }
}","/** 
 * Requests the provider to enter into a status corresponding to the specified paramters.
 * @param status the PresenceStatus as returned bygetRequestableStatusSet
 * @param statusMessage the message that should be set as the reason toenter that status
 * @throws IllegalArgumentException if the status requested is not avalid PresenceStatus supported by this provider.
 * @throws IllegalStateException if the provider is not currentlyregistered.
 * @throws OperationFailedException with code NETWORK_FAILURE ifpublishing the status fails due to a network error.
 */
public void publishPresenceStatus(PresenceStatus status,String statusMsg) throws IllegalArgumentException, IllegalStateException, OperationFailedException {
  PresenceStatus oldStatus=this.presenceStatus;
  this.presenceStatus=status;
  String oldMessage=this.statusMessage;
  this.statusMessage=statusMsg;
  this.fireProviderStatusChangeEvent(oldStatus);
  this.fireProviderMsgStatusChangeEvent(oldMessage);
  if (!status.equals(SipStatusEnum.OFFLINE)) {
    assertConnected();
  }
  if (status.equals(SipStatusEnum.OFFLINE)) {
    unsubscribeToAllContact();
  }
  if (this.useDistantPA) {
    Request req=createPublish(PUBLISH_DEFAULT_EXPIRE,true);
    if (status.equals(SipStatusEnum.OFFLINE)) {
synchronized (this.waitedCallIds) {
        this.waitedCallIds.add(((CallIdHeader)req.getHeader(CallIdHeader.NAME)).getCallId());
      }
    }
    ClientTransaction transac=null;
    try {
      transac=this.parentProvider.getDefaultJainSipProvider().getNewClientTransaction(req);
    }
 catch (    TransactionUnavailableException e) {
      logger.error(""String_Node_Str"",e);
      throw new OperationFailedException(""String_Node_Str"",OperationFailedException.NETWORK_FAILURE);
    }
    try {
      transac.sendRequest();
    }
 catch (    SipException e) {
      logger.error(""String_Node_Str"");
      throw new OperationFailedException(""String_Node_Str"",OperationFailedException.NETWORK_FAILURE);
    }
  }
 else {
synchronized (this.ourWatchers) {
      Iterator iter=this.ourWatchers.iterator();
      ContactSipImpl me=(ContactSipImpl)getLocalContact();
      while (iter.hasNext()) {
        ContactSipImpl contact=(ContactSipImpl)iter.next();
        if (!contact.isResolved()) {
          continue;
        }
        ClientTransaction transac=null;
        try {
          if (status.equals(SipStatusEnum.OFFLINE)) {
            transac=createNotify(contact,getPidfPresenceStatus(me),SubscriptionStateHeader.TERMINATED,SubscriptionStateHeader.PROBATION);
synchronized (this.waitedCallIds) {
              this.waitedCallIds.add(transac.getDialog().getCallId().getCallId());
            }
          }
 else {
            transac=createNotify(contact,getPidfPresenceStatus(me),SubscriptionStateHeader.ACTIVE,null);
          }
        }
 catch (        OperationFailedException e) {
          logger.error(""String_Node_Str"",e);
          return;
        }
        try {
          contact.getServerDialog().sendRequest(transac);
        }
 catch (        Exception e) {
          logger.error(""String_Node_Str"",e);
          return;
        }
      }
      if (status.equals(SipStatusEnum.OFFLINE)) {
synchronized (this.ourWatchers) {
          this.ourWatchers.removeAllElements();
        }
      }
    }
  }
}",0.9936170212765958
104402,"/** 
 * Converts the <tt>PresenceStatus</tt> of <tt>contact</tt> into a PIDF document.
 * @param contact The contact which interest us
 * @return a PIDF document representing the current presence status ofthis contact or null if an error occurs.
 */
public byte[] getPidfPresenceStatus(ContactSipImpl contact){
  Document doc=this.createDocument();
  if (doc == null) {
    return null;
  }
  String contactUri=null;
  try {
    contactUri=this.parseAddressStr(contact.getAddress()).getURI().toString();
  }
 catch (  ParseException e) {
    logger.debug(""String_Node_Str"",e);
    return null;
  }
  Element presence=doc.createElement(PRESENCE_ELEMENT);
  presence.setAttribute(NS_ELEMENT,NS_VALUE);
  presence.setAttribute(RPID_NS_ELEMENT,RPID_NS_VALUE);
  presence.setAttribute(DM_NS_ELEMENT,DM_NS_VALUE);
  presence.setAttribute(ENTITY_ATTRIBUTE,contactUri);
  doc.appendChild(presence);
  Element person=doc.createElement(NS_PERSON_ELT);
  person.setAttribute(ID_ATTRIBUTE,""String_Node_Str"" + String.valueOf(tupleid++));
  presence.appendChild(person);
  Element activities=doc.createElement(NS_ACTIVITY_ELT);
  person.appendChild(activities);
  if (getPresenceStatus().equals(SipStatusEnum.AWAY)) {
    Element away=doc.createElement(NS_AWAY_ELT);
    activities.appendChild(away);
  }
 else   if (getPresenceStatus().equals(SipStatusEnum.DO_NOT_DISTURB)) {
    Element busy=doc.createElement(NS_BUSY_ELT);
    activities.appendChild(busy);
  }
  Element tuple=doc.createElement(TUPLE_ELEMENT);
  tuple.setAttribute(ID_ATTRIBUTE,String.valueOf(tupleid++));
  presence.appendChild(tuple);
  Element status=doc.createElement(STATUS_ELEMENT);
  tuple.appendChild(status);
  Element basic=doc.createElement(BASIC_ELEMENT);
  if (this.getPresenceStatus().equals(SipStatusEnum.OFFLINE)) {
    basic.appendChild(doc.createTextNode(OFFLINE_STATUS));
  }
 else {
    basic.appendChild(doc.createTextNode(ONLINE_STATUS));
  }
  status.appendChild(basic);
  Element contactUriEl=doc.createElement(CONTACT_ELEMENT);
  Node cValue=doc.createTextNode(contactUri);
  contactUriEl.appendChild(cValue);
  tuple.appendChild(contactUriEl);
  Element noteNodeEl=doc.createElement(NOTE_ELEMENT);
  noteNodeEl.appendChild(doc.createTextNode(this.getPresenceStatus().getStatusName()));
  tuple.appendChild(noteNodeEl);
  String res=convertDocument(doc);
  if (res == null) {
    return null;
  }
  return res.getBytes();
}","/** 
 * Converts the <tt>PresenceStatus</tt> of <tt>contact</tt> into a PIDF document.
 * @param contact The contact which interest us
 * @return a PIDF document representing the current presence status ofthis contact or null if an error occurs.
 */
public byte[] getPidfPresenceStatus(ContactSipImpl contact){
  Document doc=this.createDocument();
  if (doc == null) {
    return null;
  }
  String contactUri=null;
  try {
    contactUri=this.parseAddressStr(contact.getAddress()).getURI().toString();
  }
 catch (  ParseException e) {
    logger.debug(""String_Node_Str"",e);
    return null;
  }
  Element presence=doc.createElement(PRESENCE_ELEMENT);
  presence.setAttribute(NS_ELEMENT,NS_VALUE);
  presence.setAttribute(RPID_NS_ELEMENT,RPID_NS_VALUE);
  presence.setAttribute(DM_NS_ELEMENT,DM_NS_VALUE);
  presence.setAttribute(ENTITY_ATTRIBUTE,contactUri);
  doc.appendChild(presence);
  Element person=doc.createElement(NS_PERSON_ELT);
  person.setAttribute(ID_ATTRIBUTE,""String_Node_Str"" + String.valueOf(tupleid++));
  presence.appendChild(person);
  Element activities=doc.createElement(NS_ACTIVITY_ELT);
  person.appendChild(activities);
  if (contact.getPresenceStatus().equals(SipStatusEnum.AWAY)) {
    Element away=doc.createElement(NS_AWAY_ELT);
    activities.appendChild(away);
  }
 else   if (contact.getPresenceStatus().equals(SipStatusEnum.DO_NOT_DISTURB)) {
    Element busy=doc.createElement(NS_BUSY_ELT);
    activities.appendChild(busy);
  }
  Element tuple=doc.createElement(TUPLE_ELEMENT);
  tuple.setAttribute(ID_ATTRIBUTE,String.valueOf(tupleid++));
  presence.appendChild(tuple);
  Element status=doc.createElement(STATUS_ELEMENT);
  tuple.appendChild(status);
  Element basic=doc.createElement(BASIC_ELEMENT);
  if (contact.getPresenceStatus().equals(SipStatusEnum.OFFLINE)) {
    basic.appendChild(doc.createTextNode(OFFLINE_STATUS));
  }
 else {
    basic.appendChild(doc.createTextNode(ONLINE_STATUS));
  }
  status.appendChild(basic);
  Element contactUriEl=doc.createElement(CONTACT_ELEMENT);
  Node cValue=doc.createTextNode(contactUri);
  contactUriEl.appendChild(cValue);
  tuple.appendChild(contactUriEl);
  Element noteNodeEl=doc.createElement(NOTE_ELEMENT);
  noteNodeEl.appendChild(doc.createTextNode(contact.getPresenceStatus().getStatusName()));
  tuple.appendChild(noteNodeEl);
  String res=convertDocument(doc);
  if (res == null) {
    return null;
  }
  return res.getBytes();
}",0.9921325051759834
104403,"/** 
 * The method would add a subscription for a contact, wait for a subscription event confirming the subscription, then change the status of the newly added contact (which is actually the testerAgent) and make sure that the corresponding notification events have been generated.
 * @throws java.lang.Exception if an exception occurs during testing.
 */
public void postTestSubscribe() throws Exception {
  logger.debug(""String_Node_Str"");
  SubscriptionEventCollector subEvtCollector=new SubscriptionEventCollector();
  this.operationSetPresence1.addSubsciptionListener(subEvtCollector);
synchronized (subEvtCollector) {
    this.operationSetPresence1.subscribe(this.fixture.userID2);
    subEvtCollector.waitForEvent(10000);
  }
  assertEquals(""String_Node_Str"",1,subEvtCollector.collectedEvents.size());
  SubscriptionEvent subEvt=(SubscriptionEvent)subEvtCollector.collectedEvents.get(0);
  assertEquals(""String_Node_Str"",this.fixture.userID2,((Contact)subEvt.getSource()).getAddress());
  assertEquals(""String_Node_Str"",this.fixture.userID2,subEvt.getSourceContact().getAddress());
  assertSame(""String_Node_Str"",this.fixture.provider1,subEvt.getSourceProvider());
  subEvtCollector.collectedEvents.clear();
synchronized (subEvtCollector) {
    subEvtCollector.waitForEvent(10000);
    this.operationSetPresence1.removeSubscriptionListener(subEvtCollector);
  }
  subEvtCollector.collectedEvents.clear();
  logger.debug(""String_Node_Str"");
  PresenceStatus oldStatus=this.operationSetPresence2.getPresenceStatus();
  PresenceStatus newStatus=getSampleStatus1();
  if (oldStatus.equals(newStatus)) {
    newStatus=getSampleStatus2();
  }
  ContactPresenceEventCollector contactPresEvtCollector=new ContactPresenceEventCollector(this.fixture.userID2,newStatus);
  this.operationSetPresence1.addContactPresenceStatusListener(contactPresEvtCollector);
synchronized (contactPresEvtCollector) {
    this.operationSetPresence2.publishPresenceStatus(newStatus,""String_Node_Str"");
    contactPresEvtCollector.waitForEvent(10000);
    this.operationSetPresence1.removeContactPresenceStatusListener(contactPresEvtCollector);
  }
  assertEquals(""String_Node_Str"",1,contactPresEvtCollector.collectedEvents.size());
  ContactPresenceStatusChangeEvent presEvt=(ContactPresenceStatusChangeEvent)contactPresEvtCollector.collectedEvents.get(0);
  assertEquals(""String_Node_Str"",this.fixture.userID2,((Contact)presEvt.getSource()).getAddress());
  assertEquals(""String_Node_Str"",this.fixture.userID2,presEvt.getSourceContact().getAddress());
  assertSame(""String_Node_Str"",this.fixture.provider1,presEvt.getSourceProvider());
  PresenceStatus reportedNewStatus=presEvt.getNewStatus();
  PresenceStatus reportedOldStatus=presEvt.getOldStatus();
  assertEquals(""String_Node_Str"",newStatus,reportedNewStatus);
  assertNotNull(""String_Node_Str"",reportedOldStatus);
  try {
    subEvtCollector.collectedEvents.clear();
    this.operationSetPresence2.addSubsciptionListener(subEvtCollector);
synchronized (subEvtCollector) {
      this.operationSetPresence2.subscribe(this.fixture.userID1);
      subEvtCollector.waitForEvent(10000);
      subEvtCollector.collectedEvents.clear();
      subEvtCollector.waitForEvent(10000);
      this.operationSetPresence2.removeSubscriptionListener(subEvtCollector);
    }
  }
 catch (  OperationFailedException ex) {
  }
  Object lock=new Object();
synchronized (lock) {
    logger.info(""String_Node_Str"" + ""String_Node_Str"");
    lock.wait(3000);
    logger.info(""String_Node_Str"");
  }
}","/** 
 * The method would add a subscription for a contact, wait for a subscription event confirming the subscription, then change the status of the newly added contact (which is actually the testerAgent) and make sure that the corresponding notification events have been generated.
 * @throws java.lang.Exception if an exception occurs during testing.
 */
public void postTestSubscribe() throws Exception {
  logger.debug(""String_Node_Str"");
  SubscriptionEventCollector subEvtCollector=new SubscriptionEventCollector();
  this.operationSetPresence1.addSubsciptionListener(subEvtCollector);
synchronized (subEvtCollector) {
    this.operationSetPresence1.subscribe(this.fixture.userID2);
    subEvtCollector.waitForEvent(10000);
  }
  assertEquals(""String_Node_Str"",1,subEvtCollector.collectedEvents.size());
  SubscriptionEvent subEvt=(SubscriptionEvent)subEvtCollector.collectedEvents.get(0);
  assertEquals(""String_Node_Str"",this.fixture.userID2,((Contact)subEvt.getSource()).getAddress());
  assertEquals(""String_Node_Str"",this.fixture.userID2,subEvt.getSourceContact().getAddress());
  assertSame(""String_Node_Str"",this.fixture.provider1,subEvt.getSourceProvider());
  subEvtCollector.collectedEvents.clear();
synchronized (subEvtCollector) {
    subEvtCollector.waitForEvent(10000);
    this.operationSetPresence1.removeSubscriptionListener(subEvtCollector);
  }
  subEvtCollector.collectedEvents.clear();
  logger.debug(""String_Node_Str"");
  PresenceStatus oldStatus=this.operationSetPresence2.getPresenceStatus();
  PresenceStatus newStatus=getSampleStatus1();
  if (oldStatus.equals(newStatus)) {
    newStatus=getSampleStatus2();
  }
  logger.debug(""String_Node_Str"" + newStatus + ""String_Node_Str"");
  ContactPresenceEventCollector contactPresEvtCollector=new ContactPresenceEventCollector(this.fixture.userID2,newStatus);
  this.operationSetPresence1.addContactPresenceStatusListener(contactPresEvtCollector);
synchronized (contactPresEvtCollector) {
    this.operationSetPresence2.publishPresenceStatus(newStatus,""String_Node_Str"");
    contactPresEvtCollector.waitForEvent(10000);
    this.operationSetPresence1.removeContactPresenceStatusListener(contactPresEvtCollector);
  }
  assertEquals(""String_Node_Str"",1,contactPresEvtCollector.collectedEvents.size());
  ContactPresenceStatusChangeEvent presEvt=(ContactPresenceStatusChangeEvent)contactPresEvtCollector.collectedEvents.get(0);
  assertEquals(""String_Node_Str"",this.fixture.userID2,((Contact)presEvt.getSource()).getAddress());
  assertEquals(""String_Node_Str"",this.fixture.userID2,presEvt.getSourceContact().getAddress());
  assertSame(""String_Node_Str"",this.fixture.provider1,presEvt.getSourceProvider());
  PresenceStatus reportedNewStatus=presEvt.getNewStatus();
  PresenceStatus reportedOldStatus=presEvt.getOldStatus();
  assertEquals(""String_Node_Str"",newStatus,reportedNewStatus);
  assertNotNull(""String_Node_Str"",reportedOldStatus);
  try {
    subEvtCollector.collectedEvents.clear();
    this.operationSetPresence2.addSubsciptionListener(subEvtCollector);
synchronized (subEvtCollector) {
      this.operationSetPresence2.subscribe(this.fixture.userID1);
      subEvtCollector.waitForEvent(10000);
      subEvtCollector.collectedEvents.clear();
      subEvtCollector.waitForEvent(10000);
      this.operationSetPresence2.removeSubscriptionListener(subEvtCollector);
    }
  }
 catch (  OperationFailedException ex) {
  }
  Object lock=new Object();
synchronized (lock) {
    logger.info(""String_Node_Str"" + ""String_Node_Str"");
    lock.wait(3000);
    logger.info(""String_Node_Str"");
  }
}",0.9905380595961022
104404,"public void run(){
  for (byte i=0; i < 10; i++) {
synchronized (waitedCallIds) {
      if (waitedCallIds.size() == 0) {
        break;
      }
    }
synchronized (this) {
      try {
        wait(500);
      }
 catch (      InterruptedException e) {
        logger.debug(""String_Node_Str"" + ""String_Node_Str"",e);
      }
    }
  }
}","/** 
 * Check if we can't subscribe to this contact now
 */
public void run(){
  Iterator groupsIter=getServerStoredContactListRoot().subgroups();
  while (groupsIter.hasNext()) {
    ContactGroupSipImpl group=(ContactGroupSipImpl)groupsIter.next();
    Iterator contactsIter=group.contacts();
    while (contactsIter.hasNext()) {
      ContactSipImpl contact=(ContactSipImpl)contactsIter.next();
      forcePollContact(contact);
    }
  }
}",0.0904392764857881
104405,"/** 
 * Process a request from a distant contact
 * @param requestEvent the <tt>RequestEvent</tt> containing the newlyreceived request.
 */
public void processRequest(RequestEvent requestEvent){
  ServerTransaction serverTransaction=requestEvent.getServerTransaction();
  SipProvider jainSipProvider=(SipProvider)requestEvent.getSource();
  Request request=requestEvent.getRequest();
  if (serverTransaction == null) {
    try {
      serverTransaction=jainSipProvider.getNewServerTransaction(request);
    }
 catch (    TransactionAlreadyExistsException ex) {
      logger.error(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",ex);
      return;
    }
catch (    TransactionUnavailableException ex) {
      logger.error(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",ex);
      return;
    }
  }
  EventHeader eventHeader=(EventHeader)request.getHeader(EventHeader.NAME);
  if (eventHeader == null || !eventHeader.getEventType().equalsIgnoreCase(""String_Node_Str"")) {
    return;
  }
  if (request.getMethod().equals(Request.NOTIFY)) {
    Response response=null;
    logger.debug(""String_Node_Str"");
    SubscriptionStateHeader sstateHeader=(SubscriptionStateHeader)request.getHeader(SubscriptionStateHeader.NAME);
    if (sstateHeader == null) {
      logger.error(""String_Node_Str"");
      return;
    }
    CallIdHeader idheader=(CallIdHeader)request.getHeader(CallIdHeader.NAME);
    ContactSipImpl contact=(ContactSipImpl)this.subscribedContacts.get(idheader.getCallId());
    if (contact != null && !sstateHeader.getState().equalsIgnoreCase(SubscriptionStateHeader.TERMINATED) && !contact.isResolved()) {
      logger.debug(""String_Node_Str"");
      return;
    }
    if (contact == null && !sstateHeader.getState().equalsIgnoreCase(SubscriptionStateHeader.TERMINATED)) {
      logger.debug(""String_Node_Str"" + idheader.getCallId());
synchronized (this.waitedCallIds) {
        this.waitedCallIds.remove(idheader.getCallId());
      }
      try {
        response=this.parentProvider.getMessageFactory().createResponse(Response.CALL_OR_TRANSACTION_DOES_NOT_EXIST,request);
      }
 catch (      ParseException e) {
        logger.error(""String_Node_Str"",e);
        return;
      }
      try {
        serverTransaction.sendResponse(response);
      }
 catch (      SipException e) {
        logger.error(""String_Node_Str"",e);
      }
catch (      InvalidArgumentException e) {
        logger.error(""String_Node_Str"" + ""String_Node_Str"",e);
      }
      return;
    }
    ContentTypeHeader ctheader=(ContentTypeHeader)request.getHeader(ContentTypeHeader.NAME);
    if (ctheader != null && !ctheader.getContentSubType().equalsIgnoreCase(PIDF_XML)) {
      try {
        response=this.parentProvider.getMessageFactory().createResponse(Response.UNSUPPORTED_MEDIA_TYPE,request);
      }
 catch (      ParseException e) {
        logger.error(""String_Node_Str"",e);
        return;
      }
      AcceptHeader acceptHeader=null;
      try {
        acceptHeader=this.parentProvider.getHeaderFactory().createAcceptHeader(""String_Node_Str"",PIDF_XML);
      }
 catch (      ParseException e) {
        logger.error(""String_Node_Str"",e);
        return;
      }
      response.setHeader(acceptHeader);
      try {
        serverTransaction.sendResponse(response);
      }
 catch (      SipException e) {
        logger.error(""String_Node_Str"",e);
      }
catch (      InvalidArgumentException e) {
        logger.error(""String_Node_Str"" + ""String_Node_Str"",e);
      }
    }
    if (sstateHeader.getState().equalsIgnoreCase(SubscriptionStateHeader.TERMINATED)) {
      if (contact != null) {
        terminateSubscription(contact);
        this.subscribedContacts.remove(serverTransaction.getDialog().getCallId().getCallId());
      }
synchronized (this.waitedCallIds) {
        this.waitedCallIds.remove(idheader.getCallId());
      }
    }
    try {
      response=this.parentProvider.getMessageFactory().createResponse(Response.OK,request);
    }
 catch (    ParseException e) {
      logger.error(""String_Node_Str"",e);
      return;
    }
    try {
      serverTransaction.sendResponse(response);
    }
 catch (    SipException e) {
      logger.error(""String_Node_Str"",e);
    }
catch (    InvalidArgumentException e) {
      logger.error(""String_Node_Str"" + ""String_Node_Str"",e);
    }
    if (request.getRawContent() != null && !sstateHeader.getState().equalsIgnoreCase(SubscriptionStateHeader.TERMINATED)) {
      setPidfPresenceStatus(new String(request.getRawContent()));
    }
  }
 else   if (request.getMethod().equals(Request.SUBSCRIBE)) {
    FromHeader from=(FromHeader)request.getHeader(FromHeader.NAME);
    if (this.useDistantPA) {
      this.useDistantPA=false;
      if (this.republishTask != null) {
        this.republishTask.cancel();
      }
    }
    ContactSipImpl contact=(ContactSipImpl)resolveContactID(from.getAddress().getURI().toString());
    if (contact == null) {
      contact=new ContactSipImpl(from.getAddress().getURI().toString(),this.parentProvider);
      contact.setResolved(true);
      contact.setResolvable(false);
    }
    logger.debug(contact.toString() + ""String_Node_Str"" + ""String_Node_Str"");
    ExpiresHeader expHeader=request.getExpires();
    int expires;
    if (expHeader == null) {
      expires=SUBSCRIBE_DEFAULT_EXPIRE;
    }
 else {
      expires=expHeader.getExpires();
    }
    if (expires < SUBSCRIBE_MIN_EXPIRE && expires > 0 && expires < 3600) {
      Response response=null;
      try {
        response=this.parentProvider.getMessageFactory().createResponse(Response.INTERVAL_TOO_BRIEF,request);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        return;
      }
      MinExpiresHeader min=null;
      try {
        min=this.parentProvider.getHeaderFactory().createMinExpiresHeader(SUBSCRIBE_MIN_EXPIRE);
      }
 catch (      InvalidArgumentException e) {
        logger.error(""String_Node_Str"",e);
        return;
      }
      response.setHeader(min);
      try {
        serverTransaction.sendResponse(response);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        return;
      }
      return;
    }
    if (this.ourWatchers.contains(contact)) {
      contact.getTimeoutTask().cancel();
      watcherTimeoutTask timeout=new watcherTimeoutTask(contact);
      contact.setTimeoutTask(timeout);
      this.timer.schedule(timeout,expires * 1000);
      Response response=null;
      try {
        response=this.parentProvider.getMessageFactory().createResponse(Response.OK,request);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        return;
      }
      try {
        expHeader=this.parentProvider.getHeaderFactory().createExpiresHeader(expires);
      }
 catch (      InvalidArgumentException e) {
        logger.error(""String_Node_Str"");
        return;
      }
      response.setHeader(expHeader);
      try {
        serverTransaction.sendResponse(response);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        return;
      }
      return;
    }
    Dialog dialog=contact.getServerDialog();
    if (expires == 0) {
      logger.debug(""String_Node_Str"" + contact + ""String_Node_Str"");
synchronized (this.ourWatchers) {
        this.ourWatchers.remove(contact);
      }
      contact.getTimeoutTask().cancel();
      contact.setServerDialog(null);
      Response response=null;
      try {
        response=this.parentProvider.getMessageFactory().createResponse(Response.OK,request);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        return;
      }
      try {
        expHeader=this.parentProvider.getHeaderFactory().createExpiresHeader(0);
      }
 catch (      InvalidArgumentException e) {
        logger.error(""String_Node_Str"",e);
        return;
      }
      response.setHeader(expHeader);
      try {
        serverTransaction.sendResponse(response);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        return;
      }
      ClientTransaction transac=null;
      try {
        transac=createNotify(contact,getPidfPresenceStatus((ContactSipImpl)getLocalContact()),SubscriptionStateHeader.TERMINATED,SubscriptionStateHeader.TIMEOUT);
      }
 catch (      OperationFailedException e) {
        logger.error(""String_Node_Str"",e);
        return;
      }
      try {
        dialog.sendRequest(transac);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        return;
      }
      return;
    }
    contact.setServerDialog(serverTransaction.getDialog());
    dialog=contact.getServerDialog();
    Response response=null;
    try {
      response=this.parentProvider.getMessageFactory().createResponse(Response.OK,request);
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
      return;
    }
    try {
      expHeader=this.parentProvider.getHeaderFactory().createExpiresHeader(expires);
    }
 catch (    InvalidArgumentException e) {
      logger.error(""String_Node_Str"",e);
      return;
    }
    response.setHeader(expHeader);
    try {
      serverTransaction.sendResponse(response);
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
      return;
    }
    ClientTransaction transac=null;
    try {
      transac=createNotify(contact,getPidfPresenceStatus((ContactSipImpl)getLocalContact()),SubscriptionStateHeader.ACTIVE,null);
    }
 catch (    OperationFailedException e) {
      logger.error(""String_Node_Str"",e);
      return;
    }
    try {
      dialog.sendRequest(transac);
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
      return;
    }
synchronized (this.ourWatchers) {
      this.ourWatchers.add(contact);
    }
    watcherTimeoutTask timeout=new watcherTimeoutTask(contact);
    contact.setTimeoutTask(timeout);
    this.timer.schedule(timeout,expires * 1000);
  }
 else   if (request.getMethod().equals(Request.PUBLISH)) {
    Response response=null;
    try {
      response=this.parentProvider.getMessageFactory().createResponse(Response.NOT_IMPLEMENTED,request);
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
      return;
    }
    try {
      serverTransaction.sendResponse(response);
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
      return;
    }
  }
}","/** 
 * Process a request from a distant contact
 * @param requestEvent the <tt>RequestEvent</tt> containing the newlyreceived request.
 */
public void processRequest(RequestEvent requestEvent){
  ServerTransaction serverTransaction=requestEvent.getServerTransaction();
  SipProvider jainSipProvider=(SipProvider)requestEvent.getSource();
  Request request=requestEvent.getRequest();
  if (serverTransaction == null) {
    try {
      serverTransaction=jainSipProvider.getNewServerTransaction(request);
    }
 catch (    TransactionAlreadyExistsException ex) {
      logger.error(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",ex);
      return;
    }
catch (    TransactionUnavailableException ex) {
      logger.error(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",ex);
      return;
    }
  }
  EventHeader eventHeader=(EventHeader)request.getHeader(EventHeader.NAME);
  if (eventHeader == null || !eventHeader.getEventType().equalsIgnoreCase(""String_Node_Str"")) {
    return;
  }
  if (request.getMethod().equals(Request.NOTIFY)) {
    Response response=null;
    logger.debug(""String_Node_Str"");
    SubscriptionStateHeader sstateHeader=(SubscriptionStateHeader)request.getHeader(SubscriptionStateHeader.NAME);
    if (sstateHeader == null) {
      logger.error(""String_Node_Str"");
      return;
    }
    CallIdHeader idheader=(CallIdHeader)request.getHeader(CallIdHeader.NAME);
    ContactSipImpl contact=(ContactSipImpl)this.subscribedContacts.get(idheader.getCallId());
    if (contact != null && !sstateHeader.getState().equalsIgnoreCase(SubscriptionStateHeader.TERMINATED) && !contact.isResolved()) {
      logger.debug(""String_Node_Str"");
    }
    if (contact == null && !sstateHeader.getState().equalsIgnoreCase(SubscriptionStateHeader.TERMINATED)) {
      logger.debug(""String_Node_Str"" + idheader.getCallId());
synchronized (this.waitedCallIds) {
        this.waitedCallIds.remove(idheader.getCallId());
      }
      try {
        response=this.parentProvider.getMessageFactory().createResponse(Response.CALL_OR_TRANSACTION_DOES_NOT_EXIST,request);
      }
 catch (      ParseException e) {
        logger.error(""String_Node_Str"",e);
        return;
      }
      try {
        serverTransaction.sendResponse(response);
      }
 catch (      SipException e) {
        logger.error(""String_Node_Str"",e);
      }
catch (      InvalidArgumentException e) {
        logger.error(""String_Node_Str"" + ""String_Node_Str"",e);
      }
      return;
    }
    ContentTypeHeader ctheader=(ContentTypeHeader)request.getHeader(ContentTypeHeader.NAME);
    if (ctheader != null && !ctheader.getContentSubType().equalsIgnoreCase(PIDF_XML)) {
      try {
        response=this.parentProvider.getMessageFactory().createResponse(Response.UNSUPPORTED_MEDIA_TYPE,request);
      }
 catch (      ParseException e) {
        logger.error(""String_Node_Str"",e);
        return;
      }
      AcceptHeader acceptHeader=null;
      try {
        acceptHeader=this.parentProvider.getHeaderFactory().createAcceptHeader(""String_Node_Str"",PIDF_XML);
      }
 catch (      ParseException e) {
        logger.error(""String_Node_Str"",e);
        return;
      }
      response.setHeader(acceptHeader);
      try {
        serverTransaction.sendResponse(response);
      }
 catch (      SipException e) {
        logger.error(""String_Node_Str"",e);
      }
catch (      InvalidArgumentException e) {
        logger.error(""String_Node_Str"" + ""String_Node_Str"",e);
      }
    }
    if (sstateHeader.getState().equalsIgnoreCase(SubscriptionStateHeader.TERMINATED)) {
      if (contact != null) {
        terminateSubscription(contact);
        this.subscribedContacts.remove(serverTransaction.getDialog().getCallId().getCallId());
        if (sstateHeader.getReasonCode().equals(SubscriptionStateHeader.DEACTIVATED)) {
          forcePollContact(contact);
        }
      }
synchronized (this.waitedCallIds) {
        this.waitedCallIds.remove(idheader.getCallId());
      }
    }
    try {
      response=this.parentProvider.getMessageFactory().createResponse(Response.OK,request);
    }
 catch (    ParseException e) {
      logger.error(""String_Node_Str"",e);
      return;
    }
    try {
      serverTransaction.sendResponse(response);
    }
 catch (    SipException e) {
      logger.error(""String_Node_Str"",e);
    }
catch (    InvalidArgumentException e) {
      logger.error(""String_Node_Str"" + ""String_Node_Str"",e);
    }
    if (request.getRawContent() != null && !sstateHeader.getState().equalsIgnoreCase(SubscriptionStateHeader.TERMINATED)) {
      setPidfPresenceStatus(new String(request.getRawContent()));
    }
  }
 else   if (request.getMethod().equals(Request.SUBSCRIBE)) {
    FromHeader from=(FromHeader)request.getHeader(FromHeader.NAME);
    if (this.useDistantPA) {
      this.useDistantPA=false;
      if (this.republishTask != null) {
        this.republishTask.cancel();
      }
    }
    ContactSipImpl contact=(ContactSipImpl)resolveContactID(from.getAddress().getURI().toString());
    if (contact == null) {
      contact=new ContactSipImpl(from.getAddress().getURI().toString(),this.parentProvider);
      contact.setResolved(true);
      contact.setResolvable(false);
    }
    logger.debug(contact.toString() + ""String_Node_Str"" + ""String_Node_Str"");
    ExpiresHeader expHeader=request.getExpires();
    int expires;
    if (expHeader == null) {
      expires=SUBSCRIBE_DEFAULT_EXPIRE;
    }
 else {
      expires=expHeader.getExpires();
    }
    if (expires < SUBSCRIBE_MIN_EXPIRE && expires > 0 && expires < 3600) {
      Response response=null;
      try {
        response=this.parentProvider.getMessageFactory().createResponse(Response.INTERVAL_TOO_BRIEF,request);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        return;
      }
      MinExpiresHeader min=null;
      try {
        min=this.parentProvider.getHeaderFactory().createMinExpiresHeader(SUBSCRIBE_MIN_EXPIRE);
      }
 catch (      InvalidArgumentException e) {
        logger.error(""String_Node_Str"",e);
        return;
      }
      response.setHeader(min);
      try {
        serverTransaction.sendResponse(response);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        return;
      }
      return;
    }
    if (this.ourWatchers.contains(contact)) {
      contact.getTimeoutTask().cancel();
      watcherTimeoutTask timeout=new watcherTimeoutTask(contact);
      contact.setTimeoutTask(timeout);
      this.timer.schedule(timeout,expires * 1000);
      Response response=null;
      try {
        response=this.parentProvider.getMessageFactory().createResponse(Response.OK,request);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        return;
      }
      try {
        expHeader=this.parentProvider.getHeaderFactory().createExpiresHeader(expires);
      }
 catch (      InvalidArgumentException e) {
        logger.error(""String_Node_Str"");
        return;
      }
      response.setHeader(expHeader);
      try {
        serverTransaction.sendResponse(response);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        return;
      }
      return;
    }
    Dialog dialog=contact.getServerDialog();
    if (expires == 0) {
      logger.debug(""String_Node_Str"" + contact + ""String_Node_Str"");
synchronized (this.ourWatchers) {
        this.ourWatchers.remove(contact);
      }
      contact.getTimeoutTask().cancel();
      contact.setServerDialog(null);
      Response response=null;
      try {
        response=this.parentProvider.getMessageFactory().createResponse(Response.OK,request);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        return;
      }
      try {
        expHeader=this.parentProvider.getHeaderFactory().createExpiresHeader(0);
      }
 catch (      InvalidArgumentException e) {
        logger.error(""String_Node_Str"",e);
        return;
      }
      response.setHeader(expHeader);
      try {
        serverTransaction.sendResponse(response);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        return;
      }
      ClientTransaction transac=null;
      try {
        transac=createNotify(contact,getPidfPresenceStatus((ContactSipImpl)getLocalContact()),SubscriptionStateHeader.TERMINATED,SubscriptionStateHeader.TIMEOUT);
      }
 catch (      OperationFailedException e) {
        logger.error(""String_Node_Str"",e);
        return;
      }
      try {
        dialog.sendRequest(transac);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        return;
      }
      return;
    }
    contact.setServerDialog(serverTransaction.getDialog());
    dialog=contact.getServerDialog();
    Response response=null;
    try {
      response=this.parentProvider.getMessageFactory().createResponse(Response.OK,request);
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
      return;
    }
    try {
      expHeader=this.parentProvider.getHeaderFactory().createExpiresHeader(expires);
    }
 catch (    InvalidArgumentException e) {
      logger.error(""String_Node_Str"",e);
      return;
    }
    response.setHeader(expHeader);
    try {
      serverTransaction.sendResponse(response);
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
      return;
    }
    ClientTransaction transac=null;
    try {
      transac=createNotify(contact,getPidfPresenceStatus((ContactSipImpl)getLocalContact()),SubscriptionStateHeader.ACTIVE,null);
    }
 catch (    OperationFailedException e) {
      logger.error(""String_Node_Str"",e);
      return;
    }
    try {
      dialog.sendRequest(transac);
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
      return;
    }
synchronized (this.ourWatchers) {
      this.ourWatchers.add(contact);
    }
    watcherTimeoutTask timeout=new watcherTimeoutTask(contact);
    contact.setTimeoutTask(timeout);
    this.timer.schedule(timeout,expires * 1000);
  }
 else   if (request.getMethod().equals(Request.PUBLISH)) {
    Response response=null;
    try {
      response=this.parentProvider.getMessageFactory().createResponse(Response.NOT_IMPLEMENTED,request);
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
      return;
    }
    try {
      serverTransaction.sendResponse(response);
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
      return;
    }
  }
}",0.9928574852595752
104406,"/** 
 * The method is called by a ProtocolProvider implementation whenver a change in the registration state of the corresponding provider had occurred. The method is particularly interested in events stating that the SIP provider has unregistered so that it would fire status change events for all contacts in our buddy list.
 * @param evt ProviderStatusChangeEvent the event describing the statuschange.
 */
public void registrationStateChanged(RegistrationStateChangeEvent evt){
  if (evt.getNewState() == RegistrationState.UNREGISTERING) {
    timer.cancel();
    try {
      publishPresenceStatus(SipStatusEnum.OFFLINE,""String_Node_Str"");
    }
 catch (    OperationFailedException e) {
      logger.error(""String_Node_Str"",e);
    }
    Thread t=new Thread(new unregisteringThread());
    t.setDaemon(false);
    t.start();
    PresenceStatus oldStatus=presenceStatus;
    presenceStatus=SipStatusEnum.OFFLINE;
    fireProviderStatusChangeEvent(oldStatus);
  }
 else   if (evt.getNewState().equals(RegistrationState.REGISTERED)) {
    logger.debug(""String_Node_Str"");
    Iterator groupsIter=getServerStoredContactListRoot().subgroups();
    while (groupsIter.hasNext()) {
      ContactGroupSipImpl group=(ContactGroupSipImpl)groupsIter.next();
      Iterator contactsIter=group.contacts();
      while (contactsIter.hasNext()) {
        ContactSipImpl contact=(ContactSipImpl)contactsIter.next();
        if (contact.isResolved()) {
          logger.debug(""String_Node_Str"" + contact + ""String_Node_Str"");
          continue;
        }
        Request subscription;
        try {
          subscription=createSubscription(contact,SUBSCRIBE_DEFAULT_EXPIRE);
        }
 catch (        OperationFailedException ex) {
          logger.error(""String_Node_Str"",ex);
          return;
        }
        ClientTransaction subscribeTransaction;
        SipProvider jainSipProvider=parentProvider.getDefaultJainSipProvider();
        try {
          subscribeTransaction=jainSipProvider.getNewClientTransaction(subscription);
        }
 catch (        TransactionUnavailableException ex) {
          logger.error(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",ex);
          return;
        }
        CallIdHeader idheader=(CallIdHeader)subscription.getHeader(CallIdHeader.NAME);
        subscribedContacts.put(idheader.getCallId(),contact);
        logger.debug(""String_Node_Str"" + idheader.getCallId());
        try {
          subscribeTransaction.sendRequest();
        }
 catch (        SipException ex) {
          logger.error(""String_Node_Str"",ex);
          subscribedContacts.remove(idheader.getCallId());
          return;
        }
      }
    }
    timer=new Timer(true);
    pollingTask=new PollOfflineContactsTask();
    timer.schedule(pollingTask,POLLING_TASK_PERIOD,POLLING_TASK_PERIOD);
  }
}","/** 
 * The method is called by a ProtocolProvider implementation whenver a change in the registration state of the corresponding provider had occurred. The method is particularly interested in events stating that the SIP provider has unregistered so that it would fire status change events for all contacts in our buddy list.
 * @param evt ProviderStatusChangeEvent the event describing the statuschange.
 */
public void registrationStateChanged(RegistrationStateChangeEvent evt){
  if (evt.getNewState() == RegistrationState.UNREGISTERING) {
    timer.cancel();
    try {
      publishPresenceStatus(SipStatusEnum.OFFLINE,""String_Node_Str"");
    }
 catch (    OperationFailedException e) {
      logger.error(""String_Node_Str"",e);
    }
    for (byte i=0; i < 10; i++) {
synchronized (waitedCallIds) {
        if (waitedCallIds.size() == 0) {
          break;
        }
      }
synchronized (this) {
        try {
          wait(500);
        }
 catch (        InterruptedException e) {
          logger.debug(""String_Node_Str"" + ""String_Node_Str"",e);
        }
      }
    }
    PresenceStatus oldStatus=presenceStatus;
    presenceStatus=SipStatusEnum.OFFLINE;
    fireProviderStatusChangeEvent(oldStatus);
  }
 else   if (evt.getNewState().equals(RegistrationState.REGISTERED)) {
    logger.debug(""String_Node_Str"");
    Iterator groupsIter=getServerStoredContactListRoot().subgroups();
    while (groupsIter.hasNext()) {
      ContactGroupSipImpl group=(ContactGroupSipImpl)groupsIter.next();
      Iterator contactsIter=group.contacts();
      while (contactsIter.hasNext()) {
        ContactSipImpl contact=(ContactSipImpl)contactsIter.next();
        if (contact.isResolved()) {
          logger.debug(""String_Node_Str"" + contact + ""String_Node_Str"");
          continue;
        }
        forcePollContact(contact);
      }
    }
    timer=new Timer(true);
    pollingTask=new PollOfflineContactsTask();
    timer.schedule(pollingTask,POLLING_TASK_PERIOD,POLLING_TASK_PERIOD);
  }
}",0.6802494802494803
104407,"/** 
 * Creates an instance of this operation set keeping a reference to the specified parent <tt>provider</tt>.
 * @param provider the ProtocolProviderServiceSipImpl instance thatcreated us.
 * @param isPresenceEnabled if we are activated or if we don't have tohandle the presence informations for contacts
 * @param forceP2PMode if we should start in the p2p mode directly
 * @param pollingPeriod the period between two poll for offline contacts
 * @param subscriptionExpiration the default subscription expiration valueto use
 */
public OperationSetPresenceSipImpl(ProtocolProviderServiceSipImpl provider,boolean isPresenceEnabled,boolean forceP2PMode,int pollingPeriod,int subscriptionExpiration){
  this.parentProvider=provider;
  this.contactListRoot=new ContactGroupSipImpl(""String_Node_Str"",provider);
  this.parentProvider.addRegistrationStateChangeListener(new RegistrationListener());
  this.parentProvider.registerMethodProcessor(Request.SUBSCRIBE,this);
  this.parentProvider.registerMethodProcessor(Request.NOTIFY,this);
  this.parentProvider.registerMethodProcessor(Request.PUBLISH,this);
  this.parentProvider.registerEvent(""String_Node_Str"");
  logger.debug(""String_Node_Str"" + isPresenceEnabled + ""String_Node_Str""+ forceP2PMode+ ""String_Node_Str""+ pollingPeriod+ ""String_Node_Str""+ subscriptionExpiration+ ""String_Node_Str""+ provider.getOurDisplayName());
  if (pollingPeriod > 0) {
    this.pollingTaskPeriod=pollingPeriod * 1000;
  }
  this.useDistantPA=!forceP2PMode;
  this.subscriptionDuration=subscriptionExpiration;
  this.presenceEnabled=isPresenceEnabled;
}","/** 
 * Creates an instance of this operation set keeping a reference to the specified parent <tt>provider</tt>.
 * @param provider the ProtocolProviderServiceSipImpl instance thatcreated us.
 * @param isPresenceEnabled if we are activated or if we don't have tohandle the presence informations for contacts
 * @param forceP2PMode if we should start in the p2p mode directly
 * @param pollingPeriod the period between two poll for offline contacts
 * @param subscriptionExpiration the default subscription expiration valueto use
 */
public OperationSetPresenceSipImpl(ProtocolProviderServiceSipImpl provider,boolean isPresenceEnabled,boolean forceP2PMode,int pollingPeriod,int subscriptionExpiration){
  this.parentProvider=provider;
  this.contactListRoot=new ContactGroupSipImpl(""String_Node_Str"",provider);
  this.parentProvider.addRegistrationStateChangeListener(new RegistrationListener());
  this.parentProvider.registerMethodProcessor(Request.SUBSCRIBE,this);
  this.parentProvider.registerMethodProcessor(Request.NOTIFY,this);
  this.parentProvider.registerMethodProcessor(Request.PUBLISH,this);
  this.parentProvider.registerEvent(""String_Node_Str"");
  logger.debug(""String_Node_Str"" + isPresenceEnabled + ""String_Node_Str""+ forceP2PMode+ ""String_Node_Str""+ pollingPeriod+ ""String_Node_Str""+ subscriptionExpiration+ ""String_Node_Str""+ provider.getOurDisplayName());
  if (pollingPeriod > 0) {
    this.pollingTaskPeriod=pollingPeriod * 1000;
  }
  this.useDistantPA=!forceP2PMode;
  if (subscriptionDuration > 0) {
    this.subscriptionDuration=subscriptionExpiration;
  }
  this.presenceEnabled=isPresenceEnabled;
}",0.9875389408099688
104408,"/** 
 * Notifies all registered listeners of the new event.
 * @param oldValue the presence status we were in before the change.
 */
public void fireProviderMsgStatusChangeEvent(String oldValue){
  PropertyChangeEvent evt=new PropertyChangeEvent(this.parentProvider,ProviderPresenceStatusListener.STATUS_MESSAGE,oldValue,this.statusMessage);
  logger.debug(""String_Node_Str"" + this.providerPresenceStatusListeners.size() + ""String_Node_Str""+ evt);
  Iterator listeners=null;
synchronized (this.providerPresenceStatusListeners) {
    listeners=new ArrayList(this.providerPresenceStatusListeners).iterator();
  }
  while (listeners.hasNext()) {
    ProviderPresenceStatusListener listener=(ProviderPresenceStatusListener)listeners.next();
    listener.providerStatusMessageChanged(evt);
  }
}","/** 
 * Notifies all registered listeners of the new event.
 * @param oldValue the presence status we were in before the change.
 */
public void fireProviderMsgStatusChangeEvent(String oldValue){
  PropertyChangeEvent evt=new PropertyChangeEvent(this.parentProvider,ProviderPresenceStatusListener.STATUS_MESSAGE,oldValue,this.statusMessage);
  logger.debug(""String_Node_Str"" + this.providerPresenceStatusListeners.size() + ""String_Node_Str""+ evt);
  Iterator listeners=null;
synchronized (this.providerPresenceStatusListeners) {
    listeners=new ArrayList(this.providerPresenceStatusListeners).iterator();
  }
  while (listeners.hasNext()) {
    ProviderPresenceStatusListener listener=(ProviderPresenceStatusListener)listeners.next();
    listener.providerStatusMessageChanged(evt);
  }
  logger.debug(""String_Node_Str"");
}",0.978328173374613
104409,"/** 
 * The method would add a subscription for a contact, wait for a subscription event confirming the subscription, then change the status of the newly added contact (which is actually the testerAgent) and make sure that the corresponding notification events have been generated.
 * @throws java.lang.Exception if an exception occurs during testing.
 */
public void postTestSubscribe() throws Exception {
  logger.debug(""String_Node_Str"");
  SubscriptionEventCollector subEvtCollector=new SubscriptionEventCollector();
  this.operationSetPresence1.addSubsciptionListener(subEvtCollector);
synchronized (subEvtCollector) {
    this.operationSetPresence1.subscribe(this.fixture.userID2);
    subEvtCollector.waitForEvent(10000);
  }
  assertEquals(""String_Node_Str"",1,subEvtCollector.collectedEvents.size());
  SubscriptionEvent subEvt=(SubscriptionEvent)subEvtCollector.collectedEvents.get(0);
  assertEquals(""String_Node_Str"",this.fixture.userID2,((Contact)subEvt.getSource()).getAddress());
  assertEquals(""String_Node_Str"",this.fixture.userID2,subEvt.getSourceContact().getAddress());
  assertSame(""String_Node_Str"",this.fixture.provider1,subEvt.getSourceProvider());
  subEvtCollector.collectedEvents.clear();
synchronized (subEvtCollector) {
    subEvtCollector.waitForEvent(10000);
    this.operationSetPresence1.removeSubscriptionListener(subEvtCollector);
  }
  subEvtCollector.collectedEvents.clear();
  logger.debug(""String_Node_Str"");
  PresenceStatus oldStatus=this.operationSetPresence2.getPresenceStatus();
  PresenceStatus newStatus=getSampleStatus1();
  if (oldStatus.equals(newStatus)) {
    newStatus=getSampleStatus2();
  }
  logger.debug(""String_Node_Str"" + newStatus + ""String_Node_Str"");
  ContactPresenceEventCollector contactPresEvtCollector=new ContactPresenceEventCollector(this.fixture.userID2,newStatus);
  this.operationSetPresence1.addContactPresenceStatusListener(contactPresEvtCollector);
synchronized (contactPresEvtCollector) {
    this.operationSetPresence2.publishPresenceStatus(newStatus,""String_Node_Str"");
    contactPresEvtCollector.waitForEvent(10000);
    this.operationSetPresence1.removeContactPresenceStatusListener(contactPresEvtCollector);
  }
  assertEquals(""String_Node_Str"",1,contactPresEvtCollector.collectedEvents.size());
  ContactPresenceStatusChangeEvent presEvt=(ContactPresenceStatusChangeEvent)contactPresEvtCollector.collectedEvents.get(0);
  assertEquals(""String_Node_Str"",this.fixture.userID2,((Contact)presEvt.getSource()).getAddress());
  assertEquals(""String_Node_Str"",this.fixture.userID2,presEvt.getSourceContact().getAddress());
  assertSame(""String_Node_Str"",this.fixture.provider1,presEvt.getSourceProvider());
  PresenceStatus reportedNewStatus=presEvt.getNewStatus();
  PresenceStatus reportedOldStatus=presEvt.getOldStatus();
  assertEquals(""String_Node_Str"",newStatus,reportedNewStatus);
  assertNotNull(""String_Node_Str"",reportedOldStatus);
  try {
    subEvtCollector.collectedEvents.clear();
    this.operationSetPresence2.addSubsciptionListener(subEvtCollector);
synchronized (subEvtCollector) {
      this.operationSetPresence2.subscribe(this.fixture.userID1);
      subEvtCollector.waitForEvent(10000);
      subEvtCollector.collectedEvents.clear();
      subEvtCollector.waitForEvent(10000);
      this.operationSetPresence2.removeSubscriptionListener(subEvtCollector);
    }
  }
 catch (  OperationFailedException ex) {
  }
  Object lock=new Object();
synchronized (lock) {
    logger.info(""String_Node_Str"" + ""String_Node_Str"");
    lock.wait(3000);
    logger.info(""String_Node_Str"");
  }
}","/** 
 * The method would add a subscription for a contact, wait for a subscription event confirming the subscription, then change the status of the newly added contact (which is actually the testerAgent) and make sure that the corresponding notification events have been generated.
 * @throws java.lang.Exception if an exception occurs during testing.
 */
public void postTestSubscribe() throws Exception {
  logger.debug(""String_Node_Str"");
  SubscriptionEventCollector subEvtCollector=new SubscriptionEventCollector();
  this.operationSetPresence1.addSubsciptionListener(subEvtCollector);
synchronized (subEvtCollector) {
    this.operationSetPresence1.subscribe(this.fixture.userID2);
    subEvtCollector.waitForEvent(10000);
  }
  assertEquals(""String_Node_Str"",1,subEvtCollector.collectedEvents.size());
  SubscriptionEvent subEvt=(SubscriptionEvent)subEvtCollector.collectedEvents.get(0);
  assertEquals(""String_Node_Str"",this.fixture.userID2,((Contact)subEvt.getSource()).getAddress());
  assertEquals(""String_Node_Str"",this.fixture.userID2,subEvt.getSourceContact().getAddress());
  assertSame(""String_Node_Str"",this.fixture.provider1,subEvt.getSourceProvider());
  subEvtCollector.collectedEvents.clear();
synchronized (subEvtCollector) {
    subEvtCollector.waitForEvent(10000);
    this.operationSetPresence1.removeSubscriptionListener(subEvtCollector);
  }
  subEvtCollector.collectedEvents.clear();
  Object lock=new Object();
synchronized (lock) {
    logger.info(""String_Node_Str"");
    lock.wait(3000);
  }
  logger.debug(""String_Node_Str"");
  PresenceStatus oldStatus=this.operationSetPresence2.getPresenceStatus();
  PresenceStatus newStatus=getSampleStatus1();
  if (oldStatus.equals(newStatus)) {
    newStatus=getSampleStatus2();
  }
  logger.debug(""String_Node_Str"" + newStatus + ""String_Node_Str"");
  ContactPresenceEventCollector contactPresEvtCollector=new ContactPresenceEventCollector(this.fixture.userID2,newStatus);
  this.operationSetPresence1.addContactPresenceStatusListener(contactPresEvtCollector);
synchronized (contactPresEvtCollector) {
    this.operationSetPresence2.publishPresenceStatus(newStatus,""String_Node_Str"");
    contactPresEvtCollector.waitForEvent(10000);
    this.operationSetPresence1.removeContactPresenceStatusListener(contactPresEvtCollector);
  }
  assertEquals(""String_Node_Str"",1,contactPresEvtCollector.collectedEvents.size());
  ContactPresenceStatusChangeEvent presEvt=(ContactPresenceStatusChangeEvent)contactPresEvtCollector.collectedEvents.get(0);
  assertEquals(""String_Node_Str"",this.fixture.userID2,((Contact)presEvt.getSource()).getAddress());
  assertEquals(""String_Node_Str"",this.fixture.userID2,presEvt.getSourceContact().getAddress());
  assertSame(""String_Node_Str"",this.fixture.provider1,presEvt.getSourceProvider());
  PresenceStatus reportedNewStatus=presEvt.getNewStatus();
  PresenceStatus reportedOldStatus=presEvt.getOldStatus();
  assertEquals(""String_Node_Str"",newStatus,reportedNewStatus);
  assertNotNull(""String_Node_Str"",reportedOldStatus);
  try {
    subEvtCollector.collectedEvents.clear();
    this.operationSetPresence2.addSubsciptionListener(subEvtCollector);
synchronized (subEvtCollector) {
      this.operationSetPresence2.subscribe(this.fixture.userID1);
      subEvtCollector.waitForEvent(10000);
      subEvtCollector.collectedEvents.clear();
      subEvtCollector.waitForEvent(10000);
      this.operationSetPresence2.removeSubscriptionListener(subEvtCollector);
    }
  }
 catch (  OperationFailedException ex) {
  }
synchronized (lock) {
    logger.info(""String_Node_Str"" + ""String_Node_Str"");
    lock.wait(3000);
    logger.info(""String_Node_Str"");
  }
}",0.980777209238003
104410,"/** 
 * Check if we can't subscribe to this contact now
 */
public void run(){
  Iterator groupsIter=getServerStoredContactListRoot().subgroups();
  while (groupsIter.hasNext()) {
    ContactGroupSipImpl group=(ContactGroupSipImpl)groupsIter.next();
    Iterator contactsIter=group.contacts();
    while (contactsIter.hasNext()) {
      ContactSipImpl contact=(ContactSipImpl)contactsIter.next();
      if (!contact.isResolvable() || (!contact.getPresenceStatus().equals(SipStatusEnum.UNKNOWN) && !contact.getPresenceStatus().equals(SipStatusEnum.OFFLINE))) {
        continue;
      }
      Request subscription=null;
      try {
        subscription=createSubscription(contact,SUBSCRIBE_DEFAULT_EXPIRE);
      }
 catch (      OperationFailedException e) {
        logger.debug(""String_Node_Str"",e);
        return;
      }
      ClientTransaction subscribeTransaction;
      SipProvider jainSipProvider=parentProvider.getDefaultJainSipProvider();
      try {
        subscribeTransaction=jainSipProvider.getNewClientTransaction(subscription);
      }
 catch (      TransactionUnavailableException ex) {
        logger.error(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",ex);
        return;
      }
      CallIdHeader idheader=(CallIdHeader)subscription.getHeader(CallIdHeader.NAME);
      subscribedContacts.put(idheader.getCallId(),contact);
      logger.debug(""String_Node_Str"" + contact);
      try {
        subscribeTransaction.sendRequest();
      }
 catch (      SipException ex) {
        logger.error(""String_Node_Str"",ex);
        subscribedContacts.remove(idheader.getCallId());
        return;
      }
    }
  }
}","/** 
 * Check if we can't subscribe to this contact now
 */
public void run(){
  Iterator groupsIter=getServerStoredContactListRoot().subgroups();
  while (groupsIter.hasNext()) {
    ContactGroupSipImpl group=(ContactGroupSipImpl)groupsIter.next();
    Iterator contactsIter=group.contacts();
    while (contactsIter.hasNext()) {
      ContactSipImpl contact=(ContactSipImpl)contactsIter.next();
      if (!contact.isResolvable() || contact.getClientDialog() != null) {
        continue;
      }
      Request subscription=null;
      try {
        subscription=createSubscription(contact,SUBSCRIBE_DEFAULT_EXPIRE);
      }
 catch (      OperationFailedException e) {
        logger.debug(""String_Node_Str"",e);
        return;
      }
      ClientTransaction subscribeTransaction;
      SipProvider jainSipProvider=parentProvider.getDefaultJainSipProvider();
      try {
        subscribeTransaction=jainSipProvider.getNewClientTransaction(subscription);
      }
 catch (      TransactionUnavailableException ex) {
        logger.error(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",ex);
        return;
      }
      CallIdHeader idheader=(CallIdHeader)subscription.getHeader(CallIdHeader.NAME);
      subscribedContacts.put(idheader.getCallId(),contact);
      logger.debug(""String_Node_Str"" + contact);
      try {
        subscribeTransaction.sendRequest();
      }
 catch (      SipException ex) {
        logger.error(""String_Node_Str"",ex);
        subscribedContacts.remove(idheader.getCallId());
        return;
      }
    }
  }
}",0.9520526480727044
104411,"/** 
 * Sets the contact's presence status using the PIDF document provided. In case of conflict (more than one status per contact) the last valid status in the document is used. This implementation is very tolerant to be more compatible with bad implementations of SIMPLE. The limit of the tolerance is defined by the CPU cost: as far as the tolerance costs nothing more in well structured documents, we do it.
 * @param presenceDoc the pidf document to use
 */
public void setPidfPresenceStatus(String presenceDoc){
  Document doc=convertDocument(presenceDoc);
  if (doc == null) {
    return;
  }
  logger.debug(""String_Node_Str"" + presenceDoc);
  NodeList presList=doc.getElementsByTagName(PRESENCE_ELEMENT);
  if (presList.getLength() == 0) {
    logger.error(""String_Node_Str"");
    return;
  }
  if (presList.getLength() > 1) {
    logger.warn(""String_Node_Str"");
  }
  Node presNode=presList.item(0);
  if (presNode.getNodeType() != Node.ELEMENT_NODE) {
    logger.error(""String_Node_Str"");
    return;
  }
  Element presence=(Element)presNode;
  NodeList tupleList=presence.getElementsByTagName(TUPLE_ELEMENT);
  for (int i=0; i < tupleList.getLength(); i++) {
    Node tupleNode=tupleList.item(i);
    if (tupleNode.getNodeType() != Node.ELEMENT_NODE) {
      continue;
    }
    Element tuple=(Element)tupleNode;
    NodeList contactList=tuple.getElementsByTagName(CONTACT_ELEMENT);
    for (int j=0; j < contactList.getLength(); j++) {
      Node contactNode=contactList.item(j);
      if (contactNode.getNodeType() != Node.ELEMENT_NODE) {
        continue;
      }
      Element contact=(Element)contactNode;
      ContactSipImpl sipcontact=(ContactSipImpl)resolveContactID(getTextContent(contact));
      if (sipcontact == null) {
        logger.debug(""String_Node_Str"" + getTextContent(contact));
        continue;
      }
      NodeList statusList=tuple.getElementsByTagName(STATUS_ELEMENT);
      if (statusList.getLength() == 0) {
        logger.debug(""String_Node_Str"");
        continue;
      }
      int index=statusList.getLength() - 1;
      Node statusNode=null;
      do {
        Node temp=statusList.item(index);
        if (temp.getNodeType() == Node.ELEMENT_NODE) {
          statusNode=temp;
          break;
        }
        index--;
      }
 while (index >= 0);
      if (statusNode == null) {
        logger.debug(""String_Node_Str"");
        break;
      }
      Element status=(Element)statusNode;
      NodeList basicList=status.getElementsByTagName(BASIC_ELEMENT);
      if (basicList.getLength() == 0) {
        logger.debug(""String_Node_Str"");
        continue;
      }
      index=basicList.getLength() - 1;
      Node basicNode=null;
      do {
        Node temp=basicList.item(index);
        if (temp.getNodeType() == Node.ELEMENT_NODE) {
          basicNode=temp;
          break;
        }
        index--;
      }
 while (index >= 0);
      if (basicNode == null) {
        logger.debug(""String_Node_Str"");
        break;
      }
      Element basic=(Element)basicNode;
      if (getTextContent(basic).equalsIgnoreCase(ONLINE_STATUS)) {
        NodeList noteList=tuple.getElementsByTagName(NOTE_ELEMENT);
        boolean changed=false;
        for (int k=0; k < noteList.getLength(); k++) {
          Node noteNode=noteList.item(k);
          if (noteNode.getNodeType() != Node.ELEMENT_NODE) {
            continue;
          }
          Element note=(Element)noteNode;
          String state=getTextContent(note);
          if (state.equalsIgnoreCase(SipStatusEnum.AWAY.getStatusName())) {
            changed=true;
            changePresenceStatusForContact(sipcontact,SipStatusEnum.AWAY);
          }
        }
        if (changed == false) {
          changePresenceStatusForContact(sipcontact,SipStatusEnum.ONLINE);
        }
      }
 else       if (getTextContent(basic).equalsIgnoreCase(OFFLINE_STATUS)) {
        changePresenceStatusForContact(sipcontact,SipStatusEnum.OFFLINE);
      }
    }
  }
}","/** 
 * Sets the contact's presence status using the PIDF document provided. In case of conflict (more than one status per contact) the last valid status in the document is used. This implementation is very tolerant to be more compatible with bad implementations of SIMPLE. The limit of the tolerance is defined by the CPU cost: as far as the tolerance costs nothing more in well structured documents, we do it.
 * @param presenceDoc the pidf document to use
 */
public void setPidfPresenceStatus(String presenceDoc){
  Document doc=convertDocument(presenceDoc);
  if (doc == null) {
    return;
  }
  logger.debug(""String_Node_Str"" + presenceDoc);
  NodeList presList=doc.getElementsByTagName(PRESENCE_ELEMENT);
  if (presList.getLength() == 0) {
    logger.error(""String_Node_Str"");
    return;
  }
  if (presList.getLength() > 1) {
    logger.warn(""String_Node_Str"");
  }
  Node presNode=presList.item(0);
  if (presNode.getNodeType() != Node.ELEMENT_NODE) {
    logger.error(""String_Node_Str"");
    return;
  }
  Element presence=(Element)presNode;
  SipStatusEnum personStatus=null;
  NodeList personList=presence.getElementsByTagName(PERSON_ELEMENT);
  if (personList.getLength() > 1) {
    logger.error(""String_Node_Str"");
    return;
  }
  if (personList.getLength() > 0) {
    Node personNode=personList.item(0);
    if (personNode.getNodeType() != Node.ELEMENT_NODE) {
      logger.error(""String_Node_Str"");
      return;
    }
    Element person=(Element)personNode;
    NodeList activityList=person.getElementsByTagName(ACTIVITY_ELEMENT);
    if (activityList.getLength() > 0) {
      Element activity=null;
      for (int i=0; i < activityList.getLength(); i++) {
        Node activityNode=activityList.item(i);
        if (activityNode.getNodeType() != Node.ELEMENT_NODE) {
          continue;
        }
        if (activityNode.getNodeName().equals(AWAY_ELEMENT) || activityNode.getNodeName().equals(BUSY_ELEMENT)) {
          activity=(Element)activityNode;
          break;
        }
      }
      if (activity != null) {
        if (activity.getNodeName().equals(AWAY_ELEMENT)) {
          personStatus=SipStatusEnum.AWAY;
        }
 else         if (activity.getNodeName().equals(BUSY_ELEMENT)) {
          personStatus=SipStatusEnum.DO_NOT_DISTURB;
        }
      }
    }
  }
  NodeList tupleList=presence.getElementsByTagName(TUPLE_ELEMENT);
  for (int i=0; i < tupleList.getLength(); i++) {
    Node tupleNode=tupleList.item(i);
    if (tupleNode.getNodeType() != Node.ELEMENT_NODE) {
      continue;
    }
    Element tuple=(Element)tupleNode;
    NodeList contactList=tuple.getElementsByTagName(CONTACT_ELEMENT);
    for (int j=0; j < contactList.getLength(); j++) {
      Node contactNode=contactList.item(j);
      if (contactNode.getNodeType() != Node.ELEMENT_NODE) {
        continue;
      }
      Element contact=(Element)contactNode;
      ContactSipImpl sipcontact=(ContactSipImpl)resolveContactID(getTextContent(contact));
      if (sipcontact == null) {
        logger.debug(""String_Node_Str"" + getTextContent(contact));
        continue;
      }
      if (personStatus != null) {
        changePresenceStatusForContact(sipcontact,personStatus);
        continue;
      }
      NodeList statusList=tuple.getElementsByTagName(STATUS_ELEMENT);
      if (statusList.getLength() == 0) {
        logger.debug(""String_Node_Str"");
        continue;
      }
      int index=statusList.getLength() - 1;
      Node statusNode=null;
      do {
        Node temp=statusList.item(index);
        if (temp.getNodeType() == Node.ELEMENT_NODE) {
          statusNode=temp;
          break;
        }
        index--;
      }
 while (index >= 0);
      if (statusNode == null) {
        logger.debug(""String_Node_Str"");
        break;
      }
      Element status=(Element)statusNode;
      NodeList basicList=status.getElementsByTagName(BASIC_ELEMENT);
      if (basicList.getLength() == 0) {
        logger.debug(""String_Node_Str"");
        continue;
      }
      index=basicList.getLength() - 1;
      Node basicNode=null;
      do {
        Node temp=basicList.item(index);
        if (temp.getNodeType() == Node.ELEMENT_NODE) {
          basicNode=temp;
          break;
        }
        index--;
      }
 while (index >= 0);
      if (basicNode == null) {
        logger.debug(""String_Node_Str"");
        break;
      }
      Element basic=(Element)basicNode;
      NodeList noteList=tuple.getElementsByTagName(NOTE_ELEMENT);
      boolean changed=false;
      for (int k=0; k < noteList.getLength() && !changed; k++) {
        Node noteNode=noteList.item(k);
        if (noteNode.getNodeType() != Node.ELEMENT_NODE) {
          continue;
        }
        Element note=(Element)noteNode;
        String state=getTextContent(note);
        if (state.equalsIgnoreCase(SipStatusEnum.AWAY.getStatusName())) {
          changed=true;
          changePresenceStatusForContact(sipcontact,SipStatusEnum.AWAY);
        }
 else         if (state.equalsIgnoreCase(SipStatusEnum.DO_NOT_DISTURB.getStatusName())) {
          changed=true;
          changePresenceStatusForContact(sipcontact,SipStatusEnum.DO_NOT_DISTURB);
        }
      }
      if (changed == false) {
        if (getTextContent(basic).equalsIgnoreCase(ONLINE_STATUS)) {
          changePresenceStatusForContact(sipcontact,SipStatusEnum.ONLINE);
        }
 else         if (getTextContent(basic).equalsIgnoreCase(OFFLINE_STATUS)) {
          changePresenceStatusForContact(sipcontact,SipStatusEnum.OFFLINE);
        }
      }
    }
  }
}",0.3169341216216216
104412,"/** 
 * Converts the <tt>PresenceStatus</tt> of <tt>contact</tt> into a PIDF document.
 * @param contact The contact which interest us
 * @return a PIDF document representing the current presence status ofthis contact or null if an error occurs.
 */
public byte[] getPidfPresenceStatus(ContactSipImpl contact){
  Document doc=this.createDocument();
  if (doc == null) {
    return null;
  }
  String contactUri=null;
  try {
    contactUri=this.parseAddressStr(contact.getAddress()).getURI().toString();
  }
 catch (  ParseException e) {
    logger.debug(""String_Node_Str"",e);
    return null;
  }
  Element presence=doc.createElement(PRESENCE_ELEMENT);
  presence.setAttribute(NS_ELEMENT,NS_VALUE);
  presence.setAttribute(ENTITY_ATTRIBUTE,contactUri);
  doc.appendChild(presence);
  Element tuple=doc.createElement(TUPLE_ELEMENT);
  tuple.setAttribute(ID_ATTRIBUTE,String.valueOf(tupleid++));
  presence.appendChild(tuple);
  Element status=doc.createElement(STATUS_ELEMENT);
  tuple.appendChild(status);
  Element basic=doc.createElement(BASIC_ELEMENT);
  if (this.getPresenceStatus().equals(SipStatusEnum.OFFLINE)) {
    basic.appendChild(doc.createTextNode(OFFLINE_STATUS));
  }
 else {
    basic.appendChild(doc.createTextNode(ONLINE_STATUS));
  }
  status.appendChild(basic);
  Element contactUriEl=doc.createElement(CONTACT_ELEMENT);
  Node cValue=doc.createTextNode(contactUri);
  contactUriEl.appendChild(cValue);
  tuple.appendChild(contactUriEl);
  Element noteNodeEl=doc.createElement(NOTE_ELEMENT);
  noteNodeEl.appendChild(doc.createTextNode(this.getPresenceStatus().getStatusName()));
  tuple.appendChild(noteNodeEl);
  String res=convertDocument(doc);
  if (res == null) {
    return null;
  }
  return res.getBytes();
}","/** 
 * Converts the <tt>PresenceStatus</tt> of <tt>contact</tt> into a PIDF document.
 * @param contact The contact which interest us
 * @return a PIDF document representing the current presence status ofthis contact or null if an error occurs.
 */
public byte[] getPidfPresenceStatus(ContactSipImpl contact){
  Document doc=this.createDocument();
  if (doc == null) {
    return null;
  }
  String contactUri=null;
  try {
    contactUri=this.parseAddressStr(contact.getAddress()).getURI().toString();
  }
 catch (  ParseException e) {
    logger.debug(""String_Node_Str"",e);
    return null;
  }
  Element presence=doc.createElement(PRESENCE_ELEMENT);
  presence.setAttribute(NS_ELEMENT,NS_VALUE);
  presence.setAttribute(RPID_NS_ELEMENT,RPID_NS_VALUE);
  presence.setAttribute(DM_NS_ELEMENT,DM_NS_VALUE);
  presence.setAttribute(ENTITY_ATTRIBUTE,contactUri);
  doc.appendChild(presence);
  Element person=doc.createElement(NS_PERSON_ELT);
  person.setAttribute(ID_ATTRIBUTE,""String_Node_Str"" + String.valueOf(tupleid++));
  presence.appendChild(person);
  Element activities=doc.createElement(NS_ACTIVITY_ELT);
  person.appendChild(activities);
  if (getPresenceStatus().equals(SipStatusEnum.AWAY)) {
    Element away=doc.createElement(NS_AWAY_ELT);
    activities.appendChild(away);
  }
 else   if (getPresenceStatus().equals(SipStatusEnum.DO_NOT_DISTURB)) {
    Element busy=doc.createElement(NS_BUSY_ELT);
    activities.appendChild(busy);
  }
  Element tuple=doc.createElement(TUPLE_ELEMENT);
  tuple.setAttribute(ID_ATTRIBUTE,String.valueOf(tupleid++));
  presence.appendChild(tuple);
  Element status=doc.createElement(STATUS_ELEMENT);
  tuple.appendChild(status);
  Element basic=doc.createElement(BASIC_ELEMENT);
  if (this.getPresenceStatus().equals(SipStatusEnum.OFFLINE)) {
    basic.appendChild(doc.createTextNode(OFFLINE_STATUS));
  }
 else {
    basic.appendChild(doc.createTextNode(ONLINE_STATUS));
  }
  status.appendChild(basic);
  Element contactUriEl=doc.createElement(CONTACT_ELEMENT);
  Node cValue=doc.createTextNode(contactUri);
  contactUriEl.appendChild(cValue);
  tuple.appendChild(contactUriEl);
  Element noteNodeEl=doc.createElement(NOTE_ELEMENT);
  noteNodeEl.appendChild(doc.createTextNode(this.getPresenceStatus().getStatusName()));
  tuple.appendChild(noteNodeEl);
  String res=convertDocument(doc);
  if (res == null) {
    return null;
  }
  return res.getBytes();
}",0.8389277952185462
104413,"/** 
 * Sets the contact's presence status using the PIDF document provided. In case of conflict (more than one status per contact) the last valid status in the document is used. This implementation is very tolerant to be more compatible with bad implementations of SIMPLE. The limit of the tolerance is defined by the CPU cost: as far as the tolerance costs nothing more in well structured documents, we do it.
 * @param presenceDoc the pidf document to use
 */
public void setPidfPresenceStatus(String presenceDoc){
  Document doc=convertDocument(presenceDoc);
  if (doc == null) {
    return;
  }
  logger.debug(""String_Node_Str"" + presenceDoc);
  NodeList presList=doc.getElementsByTagName(PRESENCE_ELEMENT);
  if (presList.getLength() == 0) {
    logger.error(""String_Node_Str"");
    return;
  }
  if (presList.getLength() > 1) {
    logger.warn(""String_Node_Str"");
  }
  Node presNode=presList.item(0);
  if (presNode.getNodeType() != Node.ELEMENT_NODE) {
    logger.error(""String_Node_Str"");
    return;
  }
  Element presence=(Element)presNode;
  NodeList tupleList=presence.getElementsByTagName(TUPLE_ELEMENT);
  for (int i=0; i < tupleList.getLength(); i++) {
    Node tupleNode=tupleList.item(i);
    if (tupleNode.getNodeType() != Node.ELEMENT_NODE) {
      continue;
    }
    Element tuple=(Element)tupleNode;
    NodeList contactList=tuple.getElementsByTagName(CONTACT_ELEMENT);
    for (int j=0; j < contactList.getLength(); j++) {
      Node contactNode=contactList.item(j);
      if (contactNode.getNodeType() != Node.ELEMENT_NODE) {
        continue;
      }
      Element contact=(Element)contactNode;
      ContactSipImpl sipcontact=(ContactSipImpl)resolveContactID(getTextContent(contact));
      if (sipcontact == null) {
        logger.debug(""String_Node_Str"" + getTextContent(contact));
        continue;
      }
      NodeList statusList=tuple.getElementsByTagName(STATUS_ELEMENT);
      if (statusList.getLength() == 0) {
        logger.debug(""String_Node_Str"");
        continue;
      }
      int index=statusList.getLength() - 1;
      Node statusNode=null;
      do {
        Node temp=statusList.item(index);
        if (temp.getNodeType() == Node.ELEMENT_NODE) {
          statusNode=temp;
          break;
        }
        index--;
      }
 while (index >= 0);
      if (statusNode == null) {
        logger.debug(""String_Node_Str"");
        break;
      }
      Element status=(Element)statusNode;
      NodeList basicList=status.getElementsByTagName(BASIC_ELEMENT);
      if (basicList.getLength() == 0) {
        logger.debug(""String_Node_Str"");
        continue;
      }
      index=basicList.getLength() - 1;
      Node basicNode=null;
      do {
        Node temp=statusList.item(index);
        if (temp.getNodeType() == Node.ELEMENT_NODE) {
          basicNode=temp;
          break;
        }
        index--;
      }
 while (index >= 0);
      if (basicNode == null) {
        logger.debug(""String_Node_Str"");
        break;
      }
      Element basic=(Element)basicNode;
      if (getTextContent(basic).equalsIgnoreCase(ONLINE_STATUS)) {
        NodeList noteList=tuple.getElementsByTagName(NOTE_ELEMENT);
        boolean changed=false;
        for (int k=0; k < noteList.getLength(); k++) {
          Node noteNode=noteList.item(k);
          if (noteNode.getNodeType() != Node.ELEMENT_NODE) {
            continue;
          }
          Element note=(Element)noteNode;
          String state=getTextContent(note);
          if (state.equalsIgnoreCase(SipStatusEnum.AWAY.getStatusName())) {
            changed=true;
            changePresenceStatusForContact(sipcontact,SipStatusEnum.AWAY);
          }
        }
        if (changed == false) {
          changePresenceStatusForContact(sipcontact,SipStatusEnum.ONLINE);
        }
      }
 else       if (getTextContent(basic).equalsIgnoreCase(OFFLINE_STATUS)) {
        changePresenceStatusForContact(sipcontact,SipStatusEnum.OFFLINE);
      }
    }
  }
}","/** 
 * Sets the contact's presence status using the PIDF document provided. In case of conflict (more than one status per contact) the last valid status in the document is used. This implementation is very tolerant to be more compatible with bad implementations of SIMPLE. The limit of the tolerance is defined by the CPU cost: as far as the tolerance costs nothing more in well structured documents, we do it.
 * @param presenceDoc the pidf document to use
 */
public void setPidfPresenceStatus(String presenceDoc){
  Document doc=convertDocument(presenceDoc);
  if (doc == null) {
    return;
  }
  logger.debug(""String_Node_Str"" + presenceDoc);
  NodeList presList=doc.getElementsByTagName(PRESENCE_ELEMENT);
  if (presList.getLength() == 0) {
    logger.error(""String_Node_Str"");
    return;
  }
  if (presList.getLength() > 1) {
    logger.warn(""String_Node_Str"");
  }
  Node presNode=presList.item(0);
  if (presNode.getNodeType() != Node.ELEMENT_NODE) {
    logger.error(""String_Node_Str"");
    return;
  }
  Element presence=(Element)presNode;
  NodeList tupleList=presence.getElementsByTagName(TUPLE_ELEMENT);
  for (int i=0; i < tupleList.getLength(); i++) {
    Node tupleNode=tupleList.item(i);
    if (tupleNode.getNodeType() != Node.ELEMENT_NODE) {
      continue;
    }
    Element tuple=(Element)tupleNode;
    NodeList contactList=tuple.getElementsByTagName(CONTACT_ELEMENT);
    for (int j=0; j < contactList.getLength(); j++) {
      Node contactNode=contactList.item(j);
      if (contactNode.getNodeType() != Node.ELEMENT_NODE) {
        continue;
      }
      Element contact=(Element)contactNode;
      ContactSipImpl sipcontact=(ContactSipImpl)resolveContactID(getTextContent(contact));
      if (sipcontact == null) {
        logger.debug(""String_Node_Str"" + getTextContent(contact));
        continue;
      }
      NodeList statusList=tuple.getElementsByTagName(STATUS_ELEMENT);
      if (statusList.getLength() == 0) {
        logger.debug(""String_Node_Str"");
        continue;
      }
      int index=statusList.getLength() - 1;
      Node statusNode=null;
      do {
        Node temp=statusList.item(index);
        if (temp.getNodeType() == Node.ELEMENT_NODE) {
          statusNode=temp;
          break;
        }
        index--;
      }
 while (index >= 0);
      if (statusNode == null) {
        logger.debug(""String_Node_Str"");
        break;
      }
      Element status=(Element)statusNode;
      NodeList basicList=status.getElementsByTagName(BASIC_ELEMENT);
      if (basicList.getLength() == 0) {
        logger.debug(""String_Node_Str"");
        continue;
      }
      index=basicList.getLength() - 1;
      Node basicNode=null;
      do {
        Node temp=basicList.item(index);
        if (temp.getNodeType() == Node.ELEMENT_NODE) {
          basicNode=temp;
          break;
        }
        index--;
      }
 while (index >= 0);
      if (basicNode == null) {
        logger.debug(""String_Node_Str"");
        break;
      }
      Element basic=(Element)basicNode;
      if (getTextContent(basic).equalsIgnoreCase(ONLINE_STATUS)) {
        NodeList noteList=tuple.getElementsByTagName(NOTE_ELEMENT);
        boolean changed=false;
        for (int k=0; k < noteList.getLength(); k++) {
          Node noteNode=noteList.item(k);
          if (noteNode.getNodeType() != Node.ELEMENT_NODE) {
            continue;
          }
          Element note=(Element)noteNode;
          String state=getTextContent(note);
          if (state.equalsIgnoreCase(SipStatusEnum.AWAY.getStatusName())) {
            changed=true;
            changePresenceStatusForContact(sipcontact,SipStatusEnum.AWAY);
          }
        }
        if (changed == false) {
          changePresenceStatusForContact(sipcontact,SipStatusEnum.ONLINE);
        }
      }
 else       if (getTextContent(basic).equalsIgnoreCase(OFFLINE_STATUS)) {
        changePresenceStatusForContact(sipcontact,SipStatusEnum.OFFLINE);
      }
    }
  }
}",0.9986088276210952
104414,"/** 
 * Secured call to XMLUtils.getText (no null returned but an empty string)
 * @param node the node with which call <tt>XMLUtils.getText()</tt>
 * @return the string contained in the node or an empty string if there isno text information in the node.
 */
private String getTextContent(Element node){
  String res=XMLUtils.getText(node);
  if (res == null) {
    return ""String_Node_Str"";
  }
  return res;
}","/** 
 * Secured call to XMLUtils.getText (no null returned but an empty string)
 * @param node the node with which call <tt>XMLUtils.getText()</tt>
 * @return the string contained in the node or an empty string if there isno text information in the node.
 */
private String getTextContent(Element node){
  String res=XMLUtils.getText(node);
  if (res == null) {
    logger.warn(""String_Node_Str"" + node.getNodeName() + ""String_Node_Str"");
    return ""String_Node_Str"";
  }
  return res;
}",0.8987764182424917
104415,"/** 
 * Formats message new lines.
 * @param message The source message string.
 * @return The message string with properly formatted new lines.
 */
private String processNewLines(String message,String contentType){
  String startPlainTextTag;
  String endPlainTextTag;
  if (contentType != null && contentType.equals(HTML_CONTENT_TYPE)) {
    startPlainTextTag=""String_Node_Str"";
    endPlainTextTag=""String_Node_Str"";
  }
 else {
    startPlainTextTag=""String_Node_Str"";
    endPlainTextTag=""String_Node_Str"";
  }
  return message.replaceAll(""String_Node_Str"",endPlainTextTag + ""String_Node_Str"" + startPlainTextTag);
}","/** 
 * Formats message new lines.
 * @param message The source message string.
 * @return The message string with properly formatted new lines.
 */
private String processNewLines(String message,String contentType){
  String startPlainTextTag=""String_Node_Str"";
  String endPlainTextTag=""String_Node_Str"";
  return message.replaceAll(""String_Node_Str"",endPlainTextTag + ""String_Node_Str"" + startPlainTextTag);
}",0.7267441860465116
104416,"/** 
 * Formats message smilies.
 * @param message The source message string.
 * @return The message string with properly formated smilies.
 */
private String processSmilies(String message,String contentType){
  String startPlainTextTag;
  String endPlainTextTag;
  if (contentType != null && contentType.equals(HTML_CONTENT_TYPE)) {
    startPlainTextTag=""String_Node_Str"";
    endPlainTextTag=""String_Node_Str"";
  }
 else {
    startPlainTextTag=""String_Node_Str"";
    endPlainTextTag=""String_Node_Str"";
  }
  ArrayList smiliesList=ImageLoader.getDefaultSmiliesPack();
  String regexp=""String_Node_Str"";
  for (int i=0; i < smiliesList.size(); i++) {
    Smiley smiley=(Smiley)smiliesList.get(i);
    String[] smileyStrings=smiley.getSmileyStrings();
    for (int j=0; j < smileyStrings.length; j++) {
      regexp+=GuiUtils.replaceSpecialRegExpChars(smileyStrings[j]) + ""String_Node_Str"";
    }
  }
  regexp=regexp.substring(0,regexp.length() - 1);
  Pattern p=Pattern.compile(regexp);
  Matcher m=p.matcher(message);
  StringBuffer msgBuffer=new StringBuffer();
  boolean matchSuccessfull=false;
  while (m.find()) {
    if (!matchSuccessfull)     matchSuccessfull=true;
    String matchGroup=m.group().trim();
    String replacement=endPlainTextTag + ""String_Node_Str"" + ImageLoader.getSmiley(matchGroup).getImagePath()+ ""String_Node_Str""+ matchGroup+ ""String_Node_Str""+ startPlainTextTag;
    m.appendReplacement(msgBuffer,GuiUtils.replaceSpecialRegExpChars(replacement));
  }
  m.appendTail(msgBuffer);
  return msgBuffer.toString();
}","/** 
 * Formats message smilies.
 * @param message The source message string.
 * @return The message string with properly formated smilies.
 */
private String processSmilies(String message,String contentType){
  String startPlainTextTag=""String_Node_Str"";
  String endPlainTextTag=""String_Node_Str"";
  ArrayList smiliesList=ImageLoader.getDefaultSmiliesPack();
  String regexp=""String_Node_Str"";
  for (int i=0; i < smiliesList.size(); i++) {
    Smiley smiley=(Smiley)smiliesList.get(i);
    String[] smileyStrings=smiley.getSmileyStrings();
    for (int j=0; j < smileyStrings.length; j++) {
      regexp+=GuiUtils.replaceSpecialRegExpChars(smileyStrings[j]) + ""String_Node_Str"";
    }
  }
  regexp=regexp.substring(0,regexp.length() - 1);
  Pattern p=Pattern.compile(regexp);
  Matcher m=p.matcher(message);
  StringBuffer msgBuffer=new StringBuffer();
  boolean matchSuccessfull=false;
  while (m.find()) {
    if (!matchSuccessfull)     matchSuccessfull=true;
    String matchGroup=m.group().trim();
    String replacement=endPlainTextTag + ""String_Node_Str"" + ImageLoader.getSmiley(matchGroup).getImagePath()+ ""String_Node_Str""+ matchGroup+ ""String_Node_Str""+ startPlainTextTag;
    m.appendReplacement(msgBuffer,GuiUtils.replaceSpecialRegExpChars(replacement));
  }
  m.appendTail(msgBuffer);
  return msgBuffer.toString();
}",0.9227557411273486
104417,"/** 
 * Formats the given message. Processes all smilies chars, new lines and all the links.
 * @return the formatted message
 */
private String formatMessage(String message,String contentType){
  String linkProcessedString=processLinks(message,contentType);
  String newLinesProcessedString=processNewLines(linkProcessedString,contentType);
  return processSmilies(newLinesProcessedString,contentType);
}","/** 
 * Formats the given message. Processes all smilies chars, new lines and all the links.
 * @return the formatted message
 */
private String formatMessage(String message,String contentType){
  String processedString=message;
  if (contentType == null || !contentType.equals(HTML_CONTENT_TYPE)) {
    String linkProcessedString=processLinks(message,contentType);
    processedString=processNewLines(linkProcessedString,contentType);
  }
  return processSmilies(processedString,contentType);
}",0.7933333333333333
104418,"/** 
 * Formats all links in the given message.
 * @param message The source message string.
 * @return The message string with properly formatted links.
 */
private String processLinks(String message,String contentType){
  String startPlainTextTag;
  String endPlainTextTag;
  if (contentType != null && contentType.equals(HTML_CONTENT_TYPE)) {
    startPlainTextTag=""String_Node_Str"";
    endPlainTextTag=""String_Node_Str"";
  }
 else {
    startPlainTextTag=""String_Node_Str"";
    endPlainTextTag=""String_Node_Str"";
  }
  String wwwURL=""String_Node_Str"";
  String protocolURL=""String_Node_Str"";
  String url=""String_Node_Str"" + wwwURL + ""String_Node_Str""+ protocolURL+ ""String_Node_Str"";
  Pattern p=Pattern.compile(url);
  Matcher m=p.matcher(message);
  StringBuffer msgBuffer=new StringBuffer();
  boolean matchSuccessfull=false;
  while (m.find()) {
    if (!matchSuccessfull)     matchSuccessfull=true;
    String matchGroup=m.group().trim();
    String replacement;
    if (matchGroup.startsWith(""String_Node_Str"")) {
      replacement=endPlainTextTag + ""String_Node_Str"" + ""String_Node_Str""+ matchGroup+ ""String_Node_Str""+ matchGroup+ ""String_Node_Str""+ startPlainTextTag;
    }
 else {
      replacement=endPlainTextTag + ""String_Node_Str"" + matchGroup+ ""String_Node_Str""+ matchGroup+ ""String_Node_Str""+ startPlainTextTag;
    }
    m.appendReplacement(msgBuffer,replacement);
  }
  m.appendTail(msgBuffer);
  return msgBuffer.toString();
}","/** 
 * Formats all links in the given message.
 * @param message The source message string.
 * @return The message string with properly formatted links.
 */
private String processLinks(String message,String contentType){
  String startPlainTextTag=""String_Node_Str"";
  String endPlainTextTag=""String_Node_Str"";
  String wwwURL=""String_Node_Str"";
  String protocolURL=""String_Node_Str"";
  String url=""String_Node_Str"" + wwwURL + ""String_Node_Str""+ protocolURL+ ""String_Node_Str"";
  Pattern p=Pattern.compile(url);
  Matcher m=p.matcher(message);
  StringBuffer msgBuffer=new StringBuffer();
  boolean matchSuccessfull=false;
  while (m.find()) {
    if (!matchSuccessfull)     matchSuccessfull=true;
    String matchGroup=m.group().trim();
    String replacement;
    if (matchGroup.startsWith(""String_Node_Str"")) {
      replacement=endPlainTextTag + ""String_Node_Str"" + ""String_Node_Str""+ matchGroup+ ""String_Node_Str""+ matchGroup+ ""String_Node_Str""+ startPlainTextTag;
    }
 else {
      replacement=endPlainTextTag + ""String_Node_Str"" + matchGroup+ ""String_Node_Str""+ matchGroup+ ""String_Node_Str""+ startPlainTextTag;
    }
    m.appendReplacement(msgBuffer,replacement);
  }
  m.appendTail(msgBuffer);
  return msgBuffer.toString();
}",0.8951672862453531
104419,"/** 
 * Register a service. The service is registered for access by other jmdns clients. The name of the service may be changed to make it unique.
 * @param info of service
 * @throws java.io.IOException
 */
public void registerService(ServiceInfo info) throws IOException {
  registerServiceType(info.type);
  info.server=localHost.getName();
  info.addr=localHost.getAddress();
synchronized (this) {
    makeServiceNameUnique(info);
    services.put(info.getQualifiedName().toLowerCase(),info);
  }
  new Prober().start();
  try {
synchronized (info) {
      while (info.getState().compareTo(DNSState.ANNOUNCED) < 0) {
        info.wait();
      }
    }
  }
 catch (  InterruptedException e) {
  }
  logger.fine(""String_Node_Str"" + info);
}","/** 
 * Register a service. The service is registered for access by other jmdns clients. The name of the service may be changed to make it unique.
 * @param info of service
 * @throws java.io.IOException
 */
public void registerService(ServiceInfo info) throws IOException {
  registerServiceType(info.type);
  info.server=localHost.getName();
  info.addr=localHost.getAddress();
synchronized (this) {
    makeServiceNameUnique(info);
    services.put(info.getQualifiedName().toLowerCase(),info);
  }
  new Prober().start();
  try {
synchronized (info) {
      while (info.getState().compareTo(DNSState.ANNOUNCED) < 0) {
        info.wait();
      }
    }
  }
 catch (  InterruptedException e) {
    logger.error(e.getMessage(),e);
  }
  logger.debug(""String_Node_Str"" + info);
}",0.970414201183432
104420,"public void run(){
  try {
    if (++count < 3) {
      logger.debug(""String_Node_Str"");
      DNSOutgoing out=new DNSOutgoing(DNSConstants.FLAGS_QR_RESPONSE | DNSConstants.FLAGS_AA);
      for (int i=0; i < infos.length; i++) {
        ServiceInfo info=infos[i];
        out.addAnswer(new DNSRecord.Pointer(info.type,DNSConstants.TYPE_PTR,DNSConstants.CLASS_IN,ttl,info.getQualifiedName()),0);
        out.addAnswer(new DNSRecord.Service(info.getQualifiedName(),DNSConstants.TYPE_SRV,DNSConstants.CLASS_IN,ttl,info.priority,info.weight,info.port,localHost.getName()),0);
        out.addAnswer(new DNSRecord.Text(info.getQualifiedName(),DNSConstants.TYPE_TXT,DNSConstants.CLASS_IN,ttl,info.text),0);
        DNSRecord answer=localHost.getDNS4AddressRecord();
        if (answer != null) {
          out.addAnswer(answer,0);
        }
        answer=localHost.getDNS6AddressRecord();
        if (answer != null) {
          out.addAnswer(answer,0);
        }
      }
      send(out);
    }
 else {
synchronized (lock) {
        closed=true;
        lock.notifyAll();
      }
      this.cancel();
    }
  }
 catch (  Throwable e) {
    logger.log(Level.WARNING,""String_Node_Str"",e);
    recover();
  }
}","public void run(){
  try {
    if (++count < 3) {
      logger.debug(""String_Node_Str"");
      DNSOutgoing out=new DNSOutgoing(DNSConstants.FLAGS_QR_RESPONSE | DNSConstants.FLAGS_AA);
      for (int i=0; i < infos.length; i++) {
        ServiceInfo info=infos[i];
        out.addAnswer(new DNSRecord.Pointer(info.type,DNSConstants.TYPE_PTR,DNSConstants.CLASS_IN,ttl,info.getQualifiedName()),0);
        out.addAnswer(new DNSRecord.Service(info.getQualifiedName(),DNSConstants.TYPE_SRV,DNSConstants.CLASS_IN,ttl,info.priority,info.weight,info.port,localHost.getName()),0);
        out.addAnswer(new DNSRecord.Text(info.getQualifiedName(),DNSConstants.TYPE_TXT,DNSConstants.CLASS_IN,ttl,info.text),0);
        DNSRecord answer=localHost.getDNS4AddressRecord();
        if (answer != null) {
          out.addAnswer(answer,0);
        }
        answer=localHost.getDNS6AddressRecord();
        if (answer != null) {
          out.addAnswer(answer,0);
        }
      }
      send(out);
    }
 else {
synchronized (lock) {
        closed=true;
        lock.notifyAll();
      }
      this.cancel();
    }
  }
 catch (  Throwable e) {
    logger.warn(""String_Node_Str"",e);
    recover();
  }
}",0.965257429886982
104421,"/** 
 * SC-Bonjour Implementation : Method used to update the corresponding DNS entry in the cache of JmDNS with the new information in this ServiceInfo. A call to getLocalService must first be issued to get the ServiceInfo object to be modified. THIS METHOD MUST BE USED INSTEAD OF ANY DIRECT ACCESS TO JMDNS' CACHE!! This is used in the implementation of Zeroconf in SIP Communicator to be able to change fields declared by the local contact (status, etc).
 * @param info Updated service data to be used to replace the oldstuff contained in JmDNS' cache
 * @param old info bytes
 */
public void updateInfos(ServiceInfo info,byte[] old){
  DNSOutgoing out, out2;
synchronized (JmDNS.this) {
    services.put(info.getQualifiedName().toLowerCase(),info);
  }
synchronized (info) {
    logger.debug(""String_Node_Str"" + info.getQualifiedName() + ""String_Node_Str""+ info.getState());
    out=new DNSOutgoing(DNSConstants.FLAGS_RA | DNSConstants.FLAGS_AA);
    out2=new DNSOutgoing(DNSConstants.FLAGS_RA | DNSConstants.FLAGS_AA);
    try {
      out.addAnswer(new DNSRecord.Text(info.getQualifiedName(),DNSConstants.TYPE_TXT,DNSConstants.CLASS_IN,0,old),0);
      out.addAnswer(new DNSRecord.Text(info.getQualifiedName(),DNSConstants.TYPE_TXT,DNSConstants.CLASS_IN | DNSConstants.CLASS_UNIQUE,DNSConstants.DNS_TTL,info.text),0);
      out2.addAnswer(new DNSRecord.Text(info.getQualifiedName(),DNSConstants.TYPE_TXT,DNSConstants.CLASS_IN | DNSConstants.CLASS_UNIQUE,DNSConstants.DNS_TTL,info.text),0);
      logger.debug(""String_Node_Str"" + info);
      send(out);
      Thread.sleep(1000);
      send(out2);
      Thread.sleep(2000);
      send(out2);
    }
 catch (    Exception e) {
      logger.log(Level.WARNING,""String_Node_Str"",e);
    }
  }
}","/** 
 * SC-Bonjour Implementation : Method used to update the corresponding DNS entry in the cache of JmDNS with the new information in this ServiceInfo. A call to getLocalService must first be issued to get the ServiceInfo object to be modified. THIS METHOD MUST BE USED INSTEAD OF ANY DIRECT ACCESS TO JMDNS' CACHE!! This is used in the implementation of Zeroconf in SIP Communicator to be able to change fields declared by the local contact (status, etc).
 * @param info Updated service data to be used to replace the oldstuff contained in JmDNS' cache
 * @param old info bytes
 */
public void updateInfos(ServiceInfo info,byte[] old){
  DNSOutgoing out, out2;
synchronized (JmDNS.this) {
    services.put(info.getQualifiedName().toLowerCase(),info);
  }
synchronized (info) {
    logger.debug(""String_Node_Str"" + info.getQualifiedName() + ""String_Node_Str""+ info.getState());
    out=new DNSOutgoing(DNSConstants.FLAGS_RA | DNSConstants.FLAGS_AA);
    out2=new DNSOutgoing(DNSConstants.FLAGS_RA | DNSConstants.FLAGS_AA);
    try {
      out.addAnswer(new DNSRecord.Text(info.getQualifiedName(),DNSConstants.TYPE_TXT,DNSConstants.CLASS_IN,0,old),0);
      out.addAnswer(new DNSRecord.Text(info.getQualifiedName(),DNSConstants.TYPE_TXT,DNSConstants.CLASS_IN | DNSConstants.CLASS_UNIQUE,DNSConstants.DNS_TTL,info.text),0);
      out2.addAnswer(new DNSRecord.Text(info.getQualifiedName(),DNSConstants.TYPE_TXT,DNSConstants.CLASS_IN | DNSConstants.CLASS_UNIQUE,DNSConstants.DNS_TTL,info.text),0);
      logger.debug(""String_Node_Str"" + info);
      send(out);
      Thread.sleep(1000);
      send(out2);
      Thread.sleep(2000);
      send(out2);
    }
 catch (    Exception e) {
      logger.warn(""String_Node_Str"",e);
    }
  }
}",0.9933812949640288
104422,"/** 
 * Send an outgoing multicast DNS message.
 */
private void send(DNSOutgoing out) throws IOException {
  out.finish();
  if (!out.isEmpty()) {
    DatagramPacket packet=new DatagramPacket(out.data,out.off,group,DNSConstants.MDNS_PORT);
    try {
      DNSIncoming msg=new DNSIncoming(packet);
      logger.finest(""String_Node_Str"" + msg.print(true));
    }
 catch (    IOException e) {
      logger.throwing(getClass().toString(),""String_Node_Str"",e);
    }
    socket.send(packet);
  }
}","/** 
 * Send an outgoing multicast DNS message.
 */
private void send(DNSOutgoing out) throws IOException {
  out.finish();
  if (!out.isEmpty()) {
    DatagramPacket packet=new DatagramPacket(out.data,out.off,group,DNSConstants.MDNS_PORT);
    try {
      DNSIncoming msg=new DNSIncoming(packet);
      logger.trace(""String_Node_Str"" + msg.print(true));
    }
 catch (    IOException exc) {
      logger.error(""String_Node_Str"",exc);
    }
    socket.send(packet);
  }
}",0.946058091286307
104423,"private void closeMulticastSocket(){
  logger.debug(""String_Node_Str"");
  if (socket != null) {
    try {
      socket.leaveGroup(group);
      socket.close();
      if (incomingListener != null) {
        incomingListener.join();
      }
    }
 catch (    Exception exception) {
      logger.log(Level.WARNING,""String_Node_Str"",exception);
    }
    socket=null;
  }
}","private void closeMulticastSocket(){
  logger.debug(""String_Node_Str"");
  if (socket != null) {
    try {
      socket.leaveGroup(group);
      socket.close();
      if (incomingListener != null) {
        incomingListener.join();
      }
    }
 catch (    Exception exception) {
      logger.warn(""String_Node_Str"",exception);
    }
    socket=null;
  }
}",0.9682758620689657
104424,"/** 
 * Recover jmdns when there is an error.
 */
protected void recover(){
  logger.debug(""String_Node_Str"");
  if (DNSState.CANCELED != state) {
synchronized (this) {
      logger.debug(""String_Node_Str"");
      state=DNSState.CANCELED;
      Collection oldServiceInfos=new ArrayList(services.values());
      unregisterAllServices();
      disposeServiceCollectors();
      closeMulticastSocket();
      cache.clear();
      logger.debug(""String_Node_Str"");
      try {
        openMulticastSocket(localHost);
        start(oldServiceInfos);
      }
 catch (      Exception exception) {
        logger.log(Level.WARNING,""String_Node_Str"",exception);
      }
      logger.log(Level.WARNING,""String_Node_Str"");
    }
  }
}","/** 
 * Recover jmdns when there is an error.
 */
protected void recover(){
  logger.debug(""String_Node_Str"");
  if (DNSState.CANCELED != state) {
synchronized (this) {
      logger.debug(""String_Node_Str"");
      state=DNSState.CANCELED;
      Collection oldServiceInfos=new ArrayList(services.values());
      unregisterAllServices();
      disposeServiceCollectors();
      closeMulticastSocket();
      cache.clear();
      logger.debug(""String_Node_Str"");
      try {
        openMulticastSocket(localHost);
        start(oldServiceInfos);
      }
 catch (      Exception exception) {
        logger.warn(""String_Node_Str"",exception);
      }
      logger.warn(""String_Node_Str"");
    }
  }
}",0.943661971830986
104425,"public ServiceCollector(String type){
  String SLevel=System.getProperty(""String_Node_Str"");
  if (SLevel == null)   SLevel=""String_Node_Str"";
  logger.setLevel(Level.parse(SLevel));
  this.type=type;
}","public ServiceCollector(String type){
  this.type=type;
}",0.4401544401544401
104426,"/** 
 * Handle an incoming response. Cache answers, and pass them on to the appropriate questions.
 */
private void handleResponse(DNSIncoming msg) throws IOException {
  long now=System.currentTimeMillis();
  boolean hostConflictDetected=false;
  boolean serviceConflictDetected=false;
  logger.finest(""String_Node_Str"" + msg.answers.size() + ""String_Node_Str"");
  for (Iterator i=msg.answers.iterator(); i.hasNext(); ) {
    DNSRecord rec=(DNSRecord)i.next();
    logger.finest(""String_Node_Str"" + rec);
  }
  for (Iterator i=msg.answers.iterator(); i.hasNext(); ) {
    boolean isInformative=false;
    DNSRecord rec=(DNSRecord)i.next();
    boolean expired=rec.isExpired(now);
    logger.finest(""String_Node_Str"" + rec + ""String_Node_Str""+ expired);
    DNSRecord c=(DNSRecord)cache.get(rec);
    if (c != null) {
      logger.finest(""String_Node_Str"" + rec + ""String_Node_Str"");
      if (expired) {
        isInformative=true;
        cache.remove(c);
      }
 else {
        logger.fine(new Boolean(c.isUnique()).toString() + c.getType() + c.getClazz()+ ""String_Node_Str""+ DNSConstants.TYPE_TXT+ ""String_Node_Str""+ DNSConstants.CLASS_IN);
        if ((rec.isUnique() && ((rec.getType() & DNSConstants.TYPE_TXT) != 0) && ((rec.getClazz() & DNSConstants.CLASS_IN) != 0))) {
          System.out.println(""String_Node_Str"");
          isInformative=true;
          cache.remove(c);
          cache.add(rec);
        }
 else {
          c.resetTTL(rec);
          rec=c;
        }
      }
    }
 else {
      if (!expired) {
        isInformative=true;
        logger.finest(""String_Node_Str"" + rec + ""String_Node_Str"");
        cache.add(rec);
      }
    }
switch (rec.type) {
case DNSConstants.TYPE_PTR:
      if (rec.getName().indexOf(""String_Node_Str"") >= 0) {
        if (!expired && rec.name.startsWith(""String_Node_Str"")) {
          isInformative=true;
          registerServiceType(((DNSRecord.Pointer)rec).alias);
        }
        continue;
      }
    registerServiceType(rec.name);
  break;
}
if ((rec.getType() == DNSConstants.TYPE_A) || (rec.getType() == DNSConstants.TYPE_AAAA)) {
hostConflictDetected|=rec.handleResponse(this);
}
 else {
serviceConflictDetected|=rec.handleResponse(this);
}
if (isInformative) {
updateRecord(now,rec);
}
}
if (hostConflictDetected || serviceConflictDetected) {
new Prober().start();
}
}","/** 
 * Handle an incoming response. Cache answers, and pass them on to the appropriate questions.
 */
private void handleResponse(DNSIncoming msg) throws IOException {
  long now=System.currentTimeMillis();
  boolean hostConflictDetected=false;
  boolean serviceConflictDetected=false;
  logger.trace(""String_Node_Str"" + msg.answers.size() + ""String_Node_Str"");
  for (Iterator i=msg.answers.iterator(); i.hasNext(); ) {
    DNSRecord rec=(DNSRecord)i.next();
    logger.trace(""String_Node_Str"" + rec);
  }
  for (Iterator i=msg.answers.iterator(); i.hasNext(); ) {
    boolean isInformative=false;
    DNSRecord rec=(DNSRecord)i.next();
    boolean expired=rec.isExpired(now);
    logger.trace(""String_Node_Str"" + rec + ""String_Node_Str""+ expired);
    DNSRecord c=(DNSRecord)cache.get(rec);
    if (c != null) {
      logger.trace(""String_Node_Str"" + rec + ""String_Node_Str"");
      if (expired) {
        isInformative=true;
        cache.remove(c);
      }
 else {
        logger.trace(new Boolean(c.isUnique()).toString() + c.getType() + c.getClazz()+ ""String_Node_Str""+ DNSConstants.TYPE_TXT+ ""String_Node_Str""+ DNSConstants.CLASS_IN);
        if ((rec.isUnique() && ((rec.getType() & DNSConstants.TYPE_TXT) != 0) && ((rec.getClazz() & DNSConstants.CLASS_IN) != 0))) {
          System.out.println(""String_Node_Str"");
          isInformative=true;
          cache.remove(c);
          cache.add(rec);
        }
 else {
          c.resetTTL(rec);
          rec=c;
        }
      }
    }
 else {
      if (!expired) {
        isInformative=true;
        logger.trace(""String_Node_Str"" + rec + ""String_Node_Str"");
        cache.add(rec);
      }
    }
switch (rec.type) {
case DNSConstants.TYPE_PTR:
      if (rec.getName().indexOf(""String_Node_Str"") >= 0) {
        if (!expired && rec.name.startsWith(""String_Node_Str"")) {
          isInformative=true;
          registerServiceType(((DNSRecord.Pointer)rec).alias);
        }
        continue;
      }
    registerServiceType(rec.name);
  break;
}
if ((rec.getType() == DNSConstants.TYPE_A) || (rec.getType() == DNSConstants.TYPE_AAAA)) {
hostConflictDetected|=rec.handleResponse(this);
}
 else {
serviceConflictDetected|=rec.handleResponse(this);
}
if (isInformative) {
updateRecord(now,rec);
}
}
if (hostConflictDetected || serviceConflictDetected) {
new Prober().start();
}
}",0.9867351305091998
104427,"/** 
 * Processes the message given by the parameters.
 * @param contact the message source or destination contact
 * @param timestamp the timestamp of the message
 * @param messageType INCOMING or OUTGOING
 * @param messageContent the content text of the message
 */
private void processMessage(Contact contact,Date timestamp,String messageType,String messageContent){
  Contact containedContact=metaContact.getContact(contact.getAddress(),contact.getProtocolProvider());
  if (containedContact != null) {
    int lastDateIndex=datesPanel.getDatesNumber() - 1;
    if (lastDateIndex < 0)     return;
    Date lastDate=datesPanel.getDate(lastDateIndex);
    if (lastDate != null && GuiUtils.compareDates(lastDate,timestamp) == 0) {
      HTMLDocument document=(HTMLDocument)dateHistoryTable.get(lastDate);
      if (document != null) {
        String processedMessage=chatConvPanel.processMessage(contact.getDisplayName(),timestamp,messageType,messageContent,searchKeyword);
        this.appendMessageToDocument(document,processedMessage);
      }
    }
 else     if (lastDate == null || GuiUtils.compareDates(lastDate,timestamp) < 0) {
      long milisecondsPerDay=24 * 60 * 60* 1000;
      Date date=new Date(timestamp.getTime() - timestamp.getTime() % milisecondsPerDay);
      datesVector.add(date);
      datesPanel.addDate(date);
    }
  }
}","/** 
 * Processes the message given by the parameters.
 * @param contact the message source or destination contact
 * @param timestamp the timestamp of the message
 * @param messageType INCOMING or OUTGOING
 * @param messageContent the content text of the message
 */
private void processMessage(Contact contact,Date timestamp,String messageType,String messageContent,String messageContentType){
  Contact containedContact=metaContact.getContact(contact.getAddress(),contact.getProtocolProvider());
  if (containedContact != null) {
    int lastDateIndex=datesPanel.getDatesNumber() - 1;
    if (lastDateIndex < 0)     return;
    Date lastDate=datesPanel.getDate(lastDateIndex);
    if (lastDate != null && GuiUtils.compareDates(lastDate,timestamp) == 0) {
      HTMLDocument document=(HTMLDocument)dateHistoryTable.get(lastDate);
      if (document != null) {
        String processedMessage=chatConvPanel.processMessage(contact.getDisplayName(),timestamp,messageType,messageContent,messageContentType,searchKeyword);
        this.appendMessageToDocument(document,processedMessage);
      }
    }
 else     if (lastDate == null || GuiUtils.compareDates(lastDate,timestamp) < 0) {
      long milisecondsPerDay=24 * 60 * 60* 1000;
      Date date=new Date(timestamp.getTime() - timestamp.getTime() % milisecondsPerDay);
      datesVector.add(date);
      datesPanel.addDate(date);
    }
  }
}",0.9835706462212488
104428,"/** 
 * Implements MessageListener.messageDelivered method in order to refresh the history when new message is sent.
 */
public void messageDelivered(MessageDeliveredEvent evt){
  Contact destContact=evt.getDestinationContact();
  this.processMessage(destContact,evt.getTimestamp(),Constants.OUTGOING_MESSAGE,evt.getSourceMessage().getContent());
}","/** 
 * Implements MessageListener.messageDelivered method in order to refresh the history when new message is sent.
 */
public void messageDelivered(MessageDeliveredEvent evt){
  Contact destContact=evt.getDestinationContact();
  this.processMessage(destContact,evt.getTimestamp(),Constants.OUTGOING_MESSAGE,evt.getSourceMessage().getContent(),evt.getSourceMessage().getContentType());
}",0.9456521739130436
104429,"/** 
 * Implements MessageListener.messageReceived method in order to refresh the history when new message is received.
 */
public void messageReceived(MessageReceivedEvent evt){
  Contact sourceContact=evt.getSourceContact();
  this.processMessage(sourceContact,evt.getTimestamp(),Constants.INCOMING_MESSAGE,evt.getSourceMessage().getContent());
}","/** 
 * Implements MessageListener.messageReceived method in order to refresh the history when new message is received.
 */
public void messageReceived(MessageReceivedEvent evt){
  Contact sourceContact=evt.getSourceContact();
  this.processMessage(sourceContact,evt.getTimestamp(),Constants.INCOMING_MESSAGE,evt.getSourceMessage().getContent(),evt.getSourceMessage().getContentType());
}",0.9456521739130436
104430,"/** 
 * Shows the history given by the collection into a ChatConversationPanel.
 * @param historyRecords a collection of history records
 */
private HTMLDocument createHistory(Collection historyRecords){
  if (historyRecords.size() > 0) {
    Iterator i=historyRecords.iterator();
    String processedMessage=""String_Node_Str"";
    while (i.hasNext()) {
      Object o=i.next();
      if (o instanceof MessageDeliveredEvent) {
        MessageDeliveredEvent evt=(MessageDeliveredEvent)o;
        ProtocolProviderService protocolProvider=evt.getDestinationContact().getProtocolProvider();
        processedMessage=chatConvPanel.processMessage(this.mainFrame.getAccount(protocolProvider),evt.getTimestamp(),Constants.OUTGOING_MESSAGE,evt.getSourceMessage().getContent(),searchKeyword);
      }
 else       if (o instanceof MessageReceivedEvent) {
        MessageReceivedEvent evt=(MessageReceivedEvent)o;
        processedMessage=chatConvPanel.processMessage(evt.getSourceContact().getDisplayName(),evt.getTimestamp(),Constants.INCOMING_MESSAGE,evt.getSourceMessage().getContent(),searchKeyword);
      }
      chatConvPanel.appendMessageToEnd(processedMessage);
    }
  }
  this.chatConvPanel.setDefaultContent();
  return this.chatConvPanel.getContent();
}","/** 
 * Shows the history given by the collection into a ChatConversationPanel.
 * @param historyRecords a collection of history records
 */
private HTMLDocument createHistory(Collection historyRecords){
  if (historyRecords.size() > 0) {
    Iterator i=historyRecords.iterator();
    String processedMessage=""String_Node_Str"";
    while (i.hasNext()) {
      Object o=i.next();
      if (o instanceof MessageDeliveredEvent) {
        MessageDeliveredEvent evt=(MessageDeliveredEvent)o;
        ProtocolProviderService protocolProvider=evt.getDestinationContact().getProtocolProvider();
        processedMessage=chatConvPanel.processMessage(this.mainFrame.getAccount(protocolProvider),evt.getTimestamp(),Constants.OUTGOING_MESSAGE,evt.getSourceMessage().getContent(),evt.getSourceMessage().getContentType(),searchKeyword);
      }
 else       if (o instanceof MessageReceivedEvent) {
        MessageReceivedEvent evt=(MessageReceivedEvent)o;
        processedMessage=chatConvPanel.processMessage(evt.getSourceContact().getDisplayName(),evt.getTimestamp(),Constants.INCOMING_MESSAGE,evt.getSourceMessage().getContent(),evt.getSourceMessage().getContentType(),searchKeyword);
      }
      chatConvPanel.appendMessageToEnd(processedMessage);
    }
  }
  this.chatConvPanel.setDefaultContent();
  return this.chatConvPanel.getContent();
}",0.9691119691119692
104431,"/** 
 * Creates a <tt>MetaContactGroup</tt> with the specified group name. The meta contact group would only be created locally and resolved against the different server stored protocol contact lists upon the creation of the first protocol specific child contact in the respective group. * @param parentGroup the <tt>MetaContactGroup</tt> that should be the parent of the newly created group.
 * @param parent the meta contact group inside which the new child group must be created.
 * @param groupName the name of the <tt>MetaContactGroup</tt> to create.
 * @throws MetaContactListException with an appropriate code if the operation fails for some reason.
 */
public void createMetaContactGroup(MetaContactGroup parent,String groupName) throws MetaContactListException {
  if (!(parent instanceof MetaContactGroupImpl)) {
    throw new IllegalArgumentException(parent + ""String_Node_Str"");
  }
  MetaContactGroupImpl newMetaGroup=new MetaContactGroupImpl(groupName);
  ((MetaContactGroupImpl)parent).addSubgroup(newMetaGroup);
  fireMetaContactGroupEvent(newMetaGroup,null,null,MetaContactGroupEvent.META_CONTACT_GROUP_ADDED);
}","/** 
 * Creates a <tt>MetaContactGroup</tt> with the specified group name. The meta contact group would only be created locally and resolved against the different server stored protocol contact lists upon the creation of the first protocol specific child contact in the respective group. * @param parentGroup the <tt>MetaContactGroup</tt> that should be the parent of the newly created group.
 * @param parent the meta contact group inside which the new child group must be created.
 * @param groupName the name of the <tt>MetaContactGroup</tt> to create.
 * @throws MetaContactListException with an appropriate code if the operation fails for some reason.
 */
public void createMetaContactGroup(MetaContactGroup parent,String groupName) throws MetaContactListException {
  if (!(parent instanceof MetaContactGroupImpl)) {
    throw new IllegalArgumentException(parent + ""String_Node_Str"");
  }
  Iterator subgroups=parent.getSubgroups();
  while (subgroups.hasNext()) {
    MetaContactGroup group=(MetaContactGroup)subgroups.next();
    if (group.getGroupName().equals(groupName)) {
      throw new MetaContactListException(""String_Node_Str"" + parent.getGroupName() + ""String_Node_Str""+ ""String_Node_Str""+ groupName,new CloneNotSupportedException(""String_Node_Str""),MetaContactListException.CODE_GROUP_ALREADY_EXISTS_ERROR);
    }
  }
  MetaContactGroupImpl newMetaGroup=new MetaContactGroupImpl(groupName);
  ((MetaContactGroupImpl)parent).addSubgroup(newMetaGroup);
  fireMetaContactGroupEvent(newMetaGroup,null,null,MetaContactGroupEvent.META_CONTACT_GROUP_ADDED);
}",0.8366061504260838
104432,"/** 
 * Retrns a Contact header containing our sip uri and therefore usable in all but REGISTER requests. Same as calling getContactHeader(false)
 * @return a Contact header containing our sip uri
 */
public ContactHeader getContactHeader(){
  if (this.genericContactHeader == null) {
    genericContactHeader=headerFactory.createContactHeader(ourSipAddress);
    try {
      genericContactHeader.getAddress().setDisplayName(getOurDisplayName());
    }
 catch (    ParseException ex) {
      logger.error(""String_Node_Str"",ex);
    }
    logger.debug(""String_Node_Str"" + genericContactHeader);
  }
  return genericContactHeader;
}","/** 
 * Retrns a Contact header containing a sip URI base on a localhost address and thereforeusable in REGISTER requests only.
 * @param targetAddress the address of the registrar that this contactheader is meant for.
 * @param srcListeningPoint the listening point that will be used whenaccessing the registrar.
 * @return a Contact header based upon a local inet address.
 * @throws OperationFailedException if we fail constructing the contactheader.
 */
ContactHeader getContactHeader(InetAddress targetAddress,ListeningPoint srcListeningPoint) throws OperationFailedException {
  ContactHeader registrationContactHeader=null;
  try {
    InetSocketAddress localAddress=SipActivator.getNetworkAddressManagerService().getPublicAddressFor(targetAddress,srcListeningPoint.getPort());
    SipURI contactURI=addressFactory.createSipURI(((SipURI)ourSipAddress.getURI()).getUser(),localAddress.getAddress().getHostAddress());
    contactURI.setTransportParam(srcListeningPoint.getTransport());
    contactURI.setPort(localAddress.getPort());
    Address contactAddress=addressFactory.createAddress(contactURI);
    if (ourDisplayName != null) {
      contactAddress.setDisplayName(ourDisplayName);
    }
    registrationContactHeader=headerFactory.createContactHeader(contactAddress);
    logger.debug(""String_Node_Str"" + registrationContactHeader);
  }
 catch (  ParseException ex) {
    logger.error(""String_Node_Str"",ex);
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,ex);
  }
  return registrationContactHeader;
}",0.214123006833713
104433,"/** 
 * Returns the listening point that should be used for communiction with our current registrar.
 * @return the listening point that should be used for communiction with ourcurrent registrar.
 */
private ListeningPoint getRegistrarListeningPoint(){
  return sipProvider.getListeningPoint(registrarURI.getTransportParam());
}","/** 
 * Returns the listening point that should be used for communiction with our current registrar.
 * @return the listening point that should be used for communiction with ourcurrent registrar.
 */
ListeningPoint getRegistrarListeningPoint(){
  return sipProvider.getListeningPoint(registrarURI.getTransportParam());
}",0.9876543209876544
104434,"/** 
 * Sends the REGISTER request to the server speciied in the constructor.
 * @throws OperationFailedException with the corresponding error codeif registration or construction of the Register request fail.
 */
void register() throws OperationFailedException {
  setRegistrationState(RegistrationState.REGISTERING,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
  FromHeader fromHeader=null;
  try {
    fromHeader=sipProvider.getHeaderFactory().createFromHeader(sipProvider.getOurSipAddress(),ProtocolProviderServiceSipImpl.generateLocalTag());
  }
 catch (  ParseException ex) {
    logger.error(""String_Node_Str"",ex);
    setRegistrationState(RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_INTERNAL_ERROR,ex.getMessage());
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,ex);
  }
  CallIdHeader callIdHeader=this.getRegistrarJainSipProvider().getNewCallId();
  CSeqHeader cSeqHeader=null;
  try {
    cSeqHeader=sipProvider.getHeaderFactory().createCSeqHeader(getNextCSeqValue(),Request.REGISTER);
  }
 catch (  ParseException ex) {
    logger.error(""String_Node_Str"",ex);
    setRegistrationState(RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_INTERNAL_ERROR,ex.getMessage());
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,ex);
  }
catch (  InvalidArgumentException ex) {
    logger.error(""String_Node_Str"",ex);
    setRegistrationState(RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_INTERNAL_ERROR,ex.getMessage());
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,ex);
  }
  ToHeader toHeader=null;
  try {
    toHeader=sipProvider.getHeaderFactory().createToHeader(sipProvider.getOurSipAddress(),null);
  }
 catch (  ParseException ex) {
    logger.error(""String_Node_Str"" + fromHeader.getAddress(),ex);
    setRegistrationState(RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_INTERNAL_ERROR,ex.getMessage());
    throw new OperationFailedException(""String_Node_Str"" + fromHeader.getAddress(),OperationFailedException.INTERNAL_ERROR,ex);
  }
  ArrayList viaHeaders=sipProvider.getLocalViaHeaders(registrarAddress,getRegistrarListeningPoint());
  MaxForwardsHeader maxForwardsHeader=sipProvider.getMaxForwardsHeader();
  Request request=null;
  try {
    request=sipProvider.getMessageFactory().createRequest(registrarURI,Request.REGISTER,callIdHeader,cSeqHeader,fromHeader,toHeader,viaHeaders,maxForwardsHeader);
  }
 catch (  ParseException ex) {
    logger.error(""String_Node_Str"",ex);
    setRegistrationState(RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_INTERNAL_ERROR,ex.getMessage());
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,ex);
  }
  UserAgentHeader userAgentHeader=sipProvider.getSipCommUserAgentHeader();
  if (userAgentHeader != null)   request.addHeader(userAgentHeader);
  ExpiresHeader expHeader=null;
  for (int retry=0; retry < 2; retry++) {
    try {
      expHeader=sipProvider.getHeaderFactory().createExpiresHeader(registrationsExpiration);
    }
 catch (    InvalidArgumentException ex) {
      if (retry == 0) {
        registrationsExpiration=3600;
        continue;
      }
      logger.error(""String_Node_Str"" + registrationsExpiration,ex);
      setRegistrationState(RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_INTERNAL_ERROR,ex.getMessage());
      throw new OperationFailedException(""String_Node_Str"" + registrationsExpiration,OperationFailedException.INTERNAL_ERROR,ex);
    }
  }
  request.addHeader(expHeader);
  ContactHeader contactHeader=sipProvider.getRegistrationContactHeader(registrarAddress,getRegistrarListeningPoint());
  try {
    contactHeader.setExpires(registrationsExpiration);
  }
 catch (  InvalidArgumentException exc) {
    logger.error(""String_Node_Str"" + registrationsExpiration + ""String_Node_Str""+ ""String_Node_Str"",exc);
  }
  request.addHeader(contactHeader);
  try {
    sipProvider.getJainSipStack().getSipProviders();
    regTrans=getRegistrarJainSipProvider().getNewClientTransaction(request);
  }
 catch (  TransactionUnavailableException ex) {
    logger.error(""String_Node_Str"" + ""String_Node_Str"",ex);
    setRegistrationState(RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_INTERNAL_ERROR,ex.getMessage());
    throw new OperationFailedException(""String_Node_Str"" + ""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,ex);
  }
  try {
    regTrans.sendRequest();
    logger.debug(""String_Node_Str"" + request);
  }
 catch (  Exception ex) {
    logger.error(""String_Node_Str"",ex);
    setRegistrationState(RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_INTERNAL_ERROR,ex.getMessage());
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.NETWORK_FAILURE,ex);
  }
  this.registerRequest=request;
}","/** 
 * Sends the REGISTER request to the server speciied in the constructor.
 * @throws OperationFailedException with the corresponding error codeif registration or construction of the Register request fail.
 */
void register() throws OperationFailedException {
  setRegistrationState(RegistrationState.REGISTERING,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
  FromHeader fromHeader=null;
  try {
    fromHeader=sipProvider.getHeaderFactory().createFromHeader(sipProvider.getOurSipAddress(),ProtocolProviderServiceSipImpl.generateLocalTag());
  }
 catch (  ParseException ex) {
    logger.error(""String_Node_Str"",ex);
    setRegistrationState(RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_INTERNAL_ERROR,ex.getMessage());
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,ex);
  }
  CallIdHeader callIdHeader=this.getRegistrarJainSipProvider().getNewCallId();
  CSeqHeader cSeqHeader=null;
  try {
    cSeqHeader=sipProvider.getHeaderFactory().createCSeqHeader(getNextCSeqValue(),Request.REGISTER);
  }
 catch (  ParseException ex) {
    logger.error(""String_Node_Str"",ex);
    setRegistrationState(RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_INTERNAL_ERROR,ex.getMessage());
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,ex);
  }
catch (  InvalidArgumentException ex) {
    logger.error(""String_Node_Str"",ex);
    setRegistrationState(RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_INTERNAL_ERROR,ex.getMessage());
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,ex);
  }
  ToHeader toHeader=null;
  try {
    toHeader=sipProvider.getHeaderFactory().createToHeader(sipProvider.getOurSipAddress(),null);
  }
 catch (  ParseException ex) {
    logger.error(""String_Node_Str"" + fromHeader.getAddress(),ex);
    setRegistrationState(RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_INTERNAL_ERROR,ex.getMessage());
    throw new OperationFailedException(""String_Node_Str"" + fromHeader.getAddress(),OperationFailedException.INTERNAL_ERROR,ex);
  }
  ArrayList viaHeaders=sipProvider.getLocalViaHeaders(registrarAddress,getRegistrarListeningPoint());
  MaxForwardsHeader maxForwardsHeader=sipProvider.getMaxForwardsHeader();
  Request request=null;
  try {
    request=sipProvider.getMessageFactory().createRequest(registrarURI,Request.REGISTER,callIdHeader,cSeqHeader,fromHeader,toHeader,viaHeaders,maxForwardsHeader);
  }
 catch (  ParseException ex) {
    logger.error(""String_Node_Str"",ex);
    setRegistrationState(RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_INTERNAL_ERROR,ex.getMessage());
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,ex);
  }
  UserAgentHeader userAgentHeader=sipProvider.getSipCommUserAgentHeader();
  if (userAgentHeader != null)   request.addHeader(userAgentHeader);
  ExpiresHeader expHeader=null;
  for (int retry=0; retry < 2; retry++) {
    try {
      expHeader=sipProvider.getHeaderFactory().createExpiresHeader(registrationsExpiration);
    }
 catch (    InvalidArgumentException ex) {
      if (retry == 0) {
        registrationsExpiration=3600;
        continue;
      }
      logger.error(""String_Node_Str"" + registrationsExpiration,ex);
      setRegistrationState(RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_INTERNAL_ERROR,ex.getMessage());
      throw new OperationFailedException(""String_Node_Str"" + registrationsExpiration,OperationFailedException.INTERNAL_ERROR,ex);
    }
  }
  request.addHeader(expHeader);
  ContactHeader contactHeader=sipProvider.getContactHeader(registrarAddress,getRegistrarListeningPoint());
  try {
    contactHeader.setExpires(registrationsExpiration);
  }
 catch (  InvalidArgumentException exc) {
    logger.error(""String_Node_Str"" + registrationsExpiration + ""String_Node_Str""+ ""String_Node_Str"",exc);
  }
  request.addHeader(contactHeader);
  try {
    sipProvider.getJainSipStack().getSipProviders();
    regTrans=getRegistrarJainSipProvider().getNewClientTransaction(request);
  }
 catch (  TransactionUnavailableException ex) {
    logger.error(""String_Node_Str"" + ""String_Node_Str"",ex);
    setRegistrationState(RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_INTERNAL_ERROR,ex.getMessage());
    throw new OperationFailedException(""String_Node_Str"" + ""String_Node_Str"",OperationFailedException.INTERNAL_ERROR,ex);
  }
  try {
    regTrans.sendRequest();
    logger.debug(""String_Node_Str"" + request);
  }
 catch (  Exception ex) {
    logger.error(""String_Node_Str"",ex);
    setRegistrationState(RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_INTERNAL_ERROR,ex.getMessage());
    throw new OperationFailedException(""String_Node_Str"",OperationFailedException.NETWORK_FAILURE,ex);
  }
  this.registerRequest=request;
}",0.998803827751196
104435,"/** 
 * Formats message new lines.
 * @param message The source message string.
 * @return The message string with properly formatted new lines.
 */
private String processNewLines(String message,String contentType){
  String startPlainTextTag;
  String endPlainTextTag;
  if (contentType.equals(HTML_CONTENT_TYPE)) {
    startPlainTextTag=""String_Node_Str"";
    endPlainTextTag=""String_Node_Str"";
  }
 else {
    startPlainTextTag=""String_Node_Str"";
    endPlainTextTag=""String_Node_Str"";
  }
  return message.replaceAll(""String_Node_Str"",endPlainTextTag + ""String_Node_Str"" + startPlainTextTag);
}","/** 
 * Formats message new lines.
 * @param message The source message string.
 * @return The message string with properly formatted new lines.
 */
private String processNewLines(String message,String contentType){
  String startPlainTextTag;
  String endPlainTextTag;
  if (contentType != null && contentType.equals(HTML_CONTENT_TYPE)) {
    startPlainTextTag=""String_Node_Str"";
    endPlainTextTag=""String_Node_Str"";
  }
 else {
    startPlainTextTag=""String_Node_Str"";
    endPlainTextTag=""String_Node_Str"";
  }
  return message.replaceAll(""String_Node_Str"",endPlainTextTag + ""String_Node_Str"" + startPlainTextTag);
}",0.981132075471698
104436,"/** 
 * Formats message smilies.
 * @param message The source message string.
 * @return The message string with properly formated smilies.
 */
private String processSmilies(String message,String contentType){
  String startPlainTextTag;
  String endPlainTextTag;
  if (contentType.equals(HTML_CONTENT_TYPE)) {
    startPlainTextTag=""String_Node_Str"";
    endPlainTextTag=""String_Node_Str"";
  }
 else {
    startPlainTextTag=""String_Node_Str"";
    endPlainTextTag=""String_Node_Str"";
  }
  ArrayList smiliesList=ImageLoader.getDefaultSmiliesPack();
  String regexp=""String_Node_Str"";
  for (int i=0; i < smiliesList.size(); i++) {
    Smiley smiley=(Smiley)smiliesList.get(i);
    String[] smileyStrings=smiley.getSmileyStrings();
    for (int j=0; j < smileyStrings.length; j++) {
      regexp+=GuiUtils.replaceSpecialRegExpChars(smileyStrings[j]) + ""String_Node_Str"";
    }
  }
  regexp=regexp.substring(0,regexp.length() - 1);
  Pattern p=Pattern.compile(regexp);
  Matcher m=p.matcher(message);
  StringBuffer msgBuffer=new StringBuffer();
  boolean matchSuccessfull=false;
  while (m.find()) {
    if (!matchSuccessfull)     matchSuccessfull=true;
    String matchGroup=m.group().trim();
    String replacement=endPlainTextTag + ""String_Node_Str"" + ImageLoader.getSmiley(matchGroup).getImagePath()+ ""String_Node_Str""+ matchGroup+ ""String_Node_Str""+ startPlainTextTag;
    m.appendReplacement(msgBuffer,GuiUtils.replaceSpecialRegExpChars(replacement));
  }
  m.appendTail(msgBuffer);
  return msgBuffer.toString();
}","/** 
 * Formats message smilies.
 * @param message The source message string.
 * @return The message string with properly formated smilies.
 */
private String processSmilies(String message,String contentType){
  String startPlainTextTag;
  String endPlainTextTag;
  if (contentType != null && contentType.equals(HTML_CONTENT_TYPE)) {
    startPlainTextTag=""String_Node_Str"";
    endPlainTextTag=""String_Node_Str"";
  }
 else {
    startPlainTextTag=""String_Node_Str"";
    endPlainTextTag=""String_Node_Str"";
  }
  ArrayList smiliesList=ImageLoader.getDefaultSmiliesPack();
  String regexp=""String_Node_Str"";
  for (int i=0; i < smiliesList.size(); i++) {
    Smiley smiley=(Smiley)smiliesList.get(i);
    String[] smileyStrings=smiley.getSmileyStrings();
    for (int j=0; j < smileyStrings.length; j++) {
      regexp+=GuiUtils.replaceSpecialRegExpChars(smileyStrings[j]) + ""String_Node_Str"";
    }
  }
  regexp=regexp.substring(0,regexp.length() - 1);
  Pattern p=Pattern.compile(regexp);
  Matcher m=p.matcher(message);
  StringBuffer msgBuffer=new StringBuffer();
  boolean matchSuccessfull=false;
  while (m.find()) {
    if (!matchSuccessfull)     matchSuccessfull=true;
    String matchGroup=m.group().trim();
    String replacement=endPlainTextTag + ""String_Node_Str"" + ImageLoader.getSmiley(matchGroup).getImagePath()+ ""String_Node_Str""+ matchGroup+ ""String_Node_Str""+ startPlainTextTag;
    m.appendReplacement(msgBuffer,GuiUtils.replaceSpecialRegExpChars(replacement));
  }
  m.appendTail(msgBuffer);
  return msgBuffer.toString();
}",0.9924861156484808
104437,"/** 
 * Highlights keywords searched in the history.
 * @param message the source message
 * @param keyword the searched keyword
 * @return the formatted message
 */
private String processKeyword(String message,String contentType,String keyword){
  String startPlainTextTag;
  String endPlainTextTag;
  if (contentType.equals(HTML_CONTENT_TYPE)) {
    startPlainTextTag=""String_Node_Str"";
    endPlainTextTag=""String_Node_Str"";
  }
 else {
    startPlainTextTag=""String_Node_Str"";
    endPlainTextTag=""String_Node_Str"";
  }
  Pattern p=Pattern.compile(keyword,Pattern.CASE_INSENSITIVE);
  Matcher m=p.matcher(message);
  StringBuffer msgBuffer=new StringBuffer();
  boolean matchSuccessfull=false;
  while (m.find()) {
    if (!matchSuccessfull)     matchSuccessfull=true;
    String matchGroup=m.group().trim();
    String replacement=endPlainTextTag + ""String_Node_Str"" + matchGroup+ ""String_Node_Str""+ startPlainTextTag;
    m.appendReplacement(msgBuffer,GuiUtils.replaceSpecialRegExpChars(replacement));
  }
  m.appendTail(msgBuffer);
  return msgBuffer.toString();
}","/** 
 * Highlights keywords searched in the history.
 * @param message the source message
 * @param keyword the searched keyword
 * @return the formatted message
 */
private String processKeyword(String message,String contentType,String keyword){
  String startPlainTextTag;
  String endPlainTextTag;
  if (contentType != null && contentType.equals(HTML_CONTENT_TYPE)) {
    startPlainTextTag=""String_Node_Str"";
    endPlainTextTag=""String_Node_Str"";
  }
 else {
    startPlainTextTag=""String_Node_Str"";
    endPlainTextTag=""String_Node_Str"";
  }
  Pattern p=Pattern.compile(keyword,Pattern.CASE_INSENSITIVE);
  Matcher m=p.matcher(message);
  StringBuffer msgBuffer=new StringBuffer();
  boolean matchSuccessfull=false;
  while (m.find()) {
    if (!matchSuccessfull)     matchSuccessfull=true;
    String matchGroup=m.group().trim();
    String replacement=endPlainTextTag + ""String_Node_Str"" + matchGroup+ ""String_Node_Str""+ startPlainTextTag;
    m.appendReplacement(msgBuffer,GuiUtils.replaceSpecialRegExpChars(replacement));
  }
  m.appendTail(msgBuffer);
  return msgBuffer.toString();
}",0.989376443418014
104438,"/** 
 * Formats all links in the given message.
 * @param message The source message string.
 * @return The message string with properly formatted links.
 */
private String processLinks(String message,String contentType){
  String startPlainTextTag;
  String endPlainTextTag;
  if (contentType.equals(HTML_CONTENT_TYPE)) {
    startPlainTextTag=""String_Node_Str"";
    endPlainTextTag=""String_Node_Str"";
  }
 else {
    startPlainTextTag=""String_Node_Str"";
    endPlainTextTag=""String_Node_Str"";
  }
  String wwwURL=""String_Node_Str"";
  String protocolURL=""String_Node_Str"";
  String url=""String_Node_Str"" + wwwURL + ""String_Node_Str""+ protocolURL+ ""String_Node_Str"";
  Pattern p=Pattern.compile(url);
  Matcher m=p.matcher(message);
  StringBuffer msgBuffer=new StringBuffer();
  boolean matchSuccessfull=false;
  while (m.find()) {
    if (!matchSuccessfull)     matchSuccessfull=true;
    String matchGroup=m.group().trim();
    String replacement;
    if (matchGroup.startsWith(""String_Node_Str"")) {
      replacement=endPlainTextTag + ""String_Node_Str"" + ""String_Node_Str""+ matchGroup+ ""String_Node_Str""+ matchGroup+ ""String_Node_Str""+ startPlainTextTag;
    }
 else {
      replacement=endPlainTextTag + ""String_Node_Str"" + matchGroup+ ""String_Node_Str""+ matchGroup+ ""String_Node_Str""+ startPlainTextTag;
    }
    m.appendReplacement(msgBuffer,replacement);
  }
  m.appendTail(msgBuffer);
  return msgBuffer.toString();
}","/** 
 * Formats all links in the given message.
 * @param message The source message string.
 * @return The message string with properly formatted links.
 */
private String processLinks(String message,String contentType){
  String startPlainTextTag;
  String endPlainTextTag;
  if (contentType != null && contentType.equals(HTML_CONTENT_TYPE)) {
    startPlainTextTag=""String_Node_Str"";
    endPlainTextTag=""String_Node_Str"";
  }
 else {
    startPlainTextTag=""String_Node_Str"";
    endPlainTextTag=""String_Node_Str"";
  }
  String wwwURL=""String_Node_Str"";
  String protocolURL=""String_Node_Str"";
  String url=""String_Node_Str"" + wwwURL + ""String_Node_Str""+ protocolURL+ ""String_Node_Str"";
  Pattern p=Pattern.compile(url);
  Matcher m=p.matcher(message);
  StringBuffer msgBuffer=new StringBuffer();
  boolean matchSuccessfull=false;
  while (m.find()) {
    if (!matchSuccessfull)     matchSuccessfull=true;
    String matchGroup=m.group().trim();
    String replacement;
    if (matchGroup.startsWith(""String_Node_Str"")) {
      replacement=endPlainTextTag + ""String_Node_Str"" + ""String_Node_Str""+ matchGroup+ ""String_Node_Str""+ matchGroup+ ""String_Node_Str""+ startPlainTextTag;
    }
 else {
      replacement=endPlainTextTag + ""String_Node_Str"" + matchGroup+ ""String_Node_Str""+ matchGroup+ ""String_Node_Str""+ startPlainTextTag;
    }
    m.appendReplacement(msgBuffer,replacement);
  }
  m.appendTail(msgBuffer);
  return msgBuffer.toString();
}",0.992005561348627
104439,"/** 
 * Initializes this dialog.
 */
private void init(){
  this.getRootPane().setDefaultButton(okButton);
  this.stackTraceScrollPane.getViewport().add(stackTraceTextArea);
  this.stackTraceScrollPane.setPreferredSize(new Dimension(this.getWidth(),100));
  this.buttonsPanel.add(okButton);
  this.okButton.addActionListener(this);
  this.messagePanel.add(iconLabel,BorderLayout.WEST);
  this.mainPanel.add(messagePanel,BorderLayout.NORTH);
  this.mainPanel.add(buttonsPanel,BorderLayout.CENTER);
  this.getContentPane().add(mainPanel);
}","/** 
 * Initializes this dialog.
 */
private void init(){
  this.getRootPane().setDefaultButton(okButton);
  this.stackTraceScrollPane.getViewport().add(stackTraceTextArea);
  this.stackTraceScrollPane.setPreferredSize(new Dimension(this.getWidth(),100));
  this.buttonsPanel.add(okButton);
  this.okButton.addActionListener(this);
  this.mainPanel.add(iconLabel,BorderLayout.WEST);
  this.mainPanel.add(messagePanel,BorderLayout.CENTER);
  this.mainPanel.add(buttonsPanel,BorderLayout.SOUTH);
  this.getContentPane().add(mainPanel);
}",0.8890959925442684
104440,"/** 
 * Handles the <tt>ActionEvent</tt>. Depending on the user choice sets the return code to the appropriate value.
 */
public void actionPerformed(ActionEvent e){
  JButton button=(JButton)e.getSource();
  if (button.equals(okButton))   this.dispose();
}","/** 
 * Handles the <tt>ActionEvent</tt>. Depending on the user choice sets the return code to the appropriate value.
 * @param e the <tt>ActionEvent</tt> instance that has just been fired.
 */
public void actionPerformed(ActionEvent e){
  JButton button=(JButton)e.getSource();
  if (button.equals(okButton))   this.dispose();
}",0.8771331058020477
104441,"/** 
 * @param owner
 * @param message
 * @param title
 * @param type
 */
public ErrorDialog(Frame owner,String message,String title,int type){
  this(owner,message,title);
  if (type == WARNING)   iconLabel.setIcon(new ImageIcon(ImageLoader.getImage(ImageLoader.WARNING_ICON)));
}","/** 
 * Creates an instance of <tt>MessageDialog</tt> by specifying the owner window and the message to be displayed.
 * @param owner The dialog owner.
 * @param message The message to be displayed.
 * @param title the title of the error dialog.
 * @param type the dialog type.
 */
public ErrorDialog(Frame owner,String message,String title,int type){
  this(owner,message,title);
  if (type == WARNING)   iconLabel.setIcon(new ImageIcon(ImageLoader.getImage(ImageLoader.WARNING_ICON)));
}",0.7298701298701299
104442,"public void hyperlinkUpdate(HyperlinkEvent e){
  if (e.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {
    this.messagePanel.add(stackTraceScrollPane,BorderLayout.SOUTH);
    this.messagePanel.revalidate();
    this.messagePanel.repaint();
    this.pack();
  }
}","public void hyperlinkUpdate(HyperlinkEvent e){
  if (e.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {
    this.messagePanel.add(stackTraceScrollPane,BorderLayout.CENTER);
    this.messagePanel.revalidate();
    this.messagePanel.repaint();
    this.pack();
  }
}",0.9796672828096118
104443,"/** 
 * Creates a MetaContactListException with the specified message cause and code.
 * @param message a human readable message describing the exception.
 * @param cause the Exception/Error (if any) that caused this Exception.
 * @param code one of the statuc CODE_XXX variable, describing the natureof the exception.
 */
public MetaContactListException(String message,Exception cause,int code){
  super(message,cause);
  this.errCode=code;
}","/** 
 * Creates a MetaContactListException with the specified message error code.
 * @param message a human readable message describing the exception.
 * @param code one of the statuc CODE_XXX variable, describing the natureof the exception.
 */
public MetaContactListException(String message,int code){
  super(message);
  this.errCode=code;
}",0.8614993646759848
104444,"/** 
 * Compares this meta contact with the specified object for order.  Returns a negative integer, zero, or a positive integer as this meta contact is less than, equal to, or greater than the specified object. <p> The result of this method is calculated the following way: <p> (contactsOnline - o.contactsOnline) * 1 000 000  <br> + getDisplayName().compareTo(o.getDisplayName()) * 100 000 + getMetaUID().compareTo(o.getMetaUID())<br> <p> Or in other words ordering of meta accounts would be first done by presence status, then display name, and finally (in order to avoid equalities) be the fairly random meta contact metaUID. <p>
 * @param o the Object to be compared.
 * @return  a negative integer, zero, or a positive integer as this objectis less than, equal to, or greater than the specified object.
 * @throws ClassCastException if the specified object is nota MetaContactListImpl
 */
public int compareTo(Object o){
  MetaContactImpl target=(MetaContactImpl)o;
  int isOnline=(contactsOnline > 0) ? 1 : 0;
  int targetIsOnline=(target.contactsOnline > 0) ? 1 : 0;
  return ((10 - isOnline) - (10 - targetIsOnline)) * 1000000 + getDisplayName().compareToIgnoreCase(target.getDisplayName()) * 10000 + getMetaUID().compareTo(target.getMetaUID());
}","/** 
 * Compares this meta contact with the specified object for order.  Returns a negative integer, zero, or a positive integer as this meta contact is less than, equal to, or greater than the specified object. <p> The result of this method is calculated the following way: <p> (contactsOnline - o.contactsOnline) * 1 000 000  <br> + getDisplayName().compareTo(o.getDisplayName()) * 100 000 + getMetaUID().compareTo(o.getMetaUID())<br> <p> Or in other words ordering of meta accounts would be first done by presence status, then display name, and finally (in order to avoid equalities) be the fairly random meta contact metaUID. <p>
 * @param o the Object to be compared.
 * @return  a negative integer, zero, or a positive integer as this objectis less than, equal to, or greater than the specified object.
 * @throws ClassCastException if the specified object is nota MetaContactListImpl
 */
public int compareTo(Object o){
  MetaContactImpl target=(MetaContactImpl)o;
  int isOnline=(contactsOnline > 0) ? 1 : 0;
  int targetIsOnline=(target.contactsOnline > 0) ? 1 : 0;
  return ((10 - isOnline) - (10 - targetIsOnline)) * 100000000 + getDisplayName().compareToIgnoreCase(target.getDisplayName()) * 10000 + getMetaUID().compareTo(target.getMetaUID());
}",0.9992044550517104
104445,"/** 
 * Removes a given <tt>ChatPanel</tt> from this chat window.
 * @param chatPanel The <tt>ChatPanel</tt> to remove.
 */
public void removeChat(ChatPanel chatPanel){
  logger.debug(""String_Node_Str"" + chatPanel.getChatName());
  if (getChatTabCount() == 0) {
    this.getContentPane().remove(chatPanel);
    this.setVisible(false);
    return;
  }
  int index=chatTabbedPane.indexOfComponent(chatPanel);
  if (index != -1) {
    if (chatTabbedPane.getTabCount() > 1)     chatTabbedPane.removeTabAt(index);
    if (chatTabbedPane.getTabCount() == 1) {
      ChatPanel currentChatPanel=(ChatPanel)this.chatTabbedPane.getComponentAt(0);
      this.chatTabbedPane.removeAll();
      this.getContentPane().remove(chatTabbedPane);
      this.getContentPane().add(currentChatPanel,BorderLayout.CENTER);
      this.setCurrentChatPanel(currentChatPanel);
    }
  }
}","/** 
 * Removes a given <tt>ChatPanel</tt> from this chat window.
 * @param chatPanel The <tt>ChatPanel</tt> to remove.
 */
public void removeChat(ChatPanel chatPanel){
  logger.debug(""String_Node_Str"" + chatPanel.getChatName());
  if (getChatTabCount() == 0) {
    this.getContentPane().remove(chatPanel);
    this.getContentPane().validate();
    this.getContentPane().repaint();
    this.setVisible(false);
    return;
  }
  int index=chatTabbedPane.indexOfComponent(chatPanel);
  if (index != -1) {
    if (chatTabbedPane.getTabCount() > 1)     chatTabbedPane.removeTabAt(index);
    if (chatTabbedPane.getTabCount() == 1) {
      ChatPanel currentChatPanel=(ChatPanel)this.chatTabbedPane.getComponentAt(0);
      this.chatTabbedPane.removeAll();
      this.getContentPane().remove(chatTabbedPane);
      this.getContentPane().add(currentChatPanel,BorderLayout.CENTER);
      this.setCurrentChatPanel(currentChatPanel);
    }
  }
}",0.958217270194986
104446,"public void actionPerformed(ActionEvent e){
  Object selectedObject=getContactListPanel().getContactList().getSelectedValue();
  if (selectedObject instanceof MetaContact) {
    RenameContactDialog dialog=new RenameContactDialog(MainFrame.this,(MetaContact)selectedObject);
    dialog.setLocation(Toolkit.getDefaultToolkit().getScreenSize().width / 2 - 200,Toolkit.getDefaultToolkit().getScreenSize().height / 2 - 50);
    dialog.setVisible(true);
    dialog.requestFocusInFiled();
  }
 else   if (selectedObject instanceof MetaContactGroup) {
    RenameGroupDialog dialog=new RenameGroupDialog(MainFrame.this,(MetaContactGroup)selectedObject);
    dialog.setLocation(Toolkit.getDefaultToolkit().getScreenSize().width / 2 - 200,Toolkit.getDefaultToolkit().getScreenSize().height / 2 - 50);
    dialog.setVisible(true);
    dialog.requestFocusInFiled();
  }
}","public void actionPerformed(ActionEvent e){
  ContactList clist=getContactListPanel().getContactList();
  Object selectedValue=clist.getSelectedValue();
  if (selectedValue instanceof MetaContact) {
    MetaContact contact=(MetaContact)selectedValue;
    SwingUtilities.invokeLater(getContactListPanel().new RunMessageWindow(contact));
  }
 else   if (selectedValue instanceof MetaContactGroup) {
    MetaContactGroup group=(MetaContactGroup)selectedValue;
    ContactListModel model=(ContactListModel)clist.getModel();
    if (model.isGroupClosed(group)) {
      model.openGroup(group);
    }
  }
}",0.1619766643788606
104447,"/** 
 * Initiates the content of this frame.
 */
private void init(){
  this.addKeyBinding(KeyStroke.getKeyStroke(KeyEvent.VK_F2,0),new RenameAction());
  this.setJMenuBar(menu);
  this.contactListPanel.add(tabbedPane,BorderLayout.CENTER);
  this.contactListPanel.add(callManager,BorderLayout.SOUTH);
  this.mainPanel.add(quickMenu,BorderLayout.NORTH);
  this.mainPanel.add(contactListPanel,BorderLayout.CENTER);
  this.mainPanel.add(statusPanel,BorderLayout.SOUTH);
  this.getContentPane().add(mainPanel);
}","/** 
 * Initiates the content of this frame.
 */
private void init(){
  this.addKeyBinding(KeyStroke.getKeyStroke(KeyEvent.VK_F2,0),new RenameAction());
  this.setJMenuBar(menu);
  this.contactListPanel.add(tabbedPane,BorderLayout.CENTER);
  this.contactListPanel.add(callManager,BorderLayout.SOUTH);
  this.mainPanel.add(quickMenu,BorderLayout.NORTH);
  this.mainPanel.add(contactListPanel,BorderLayout.CENTER);
  this.mainPanel.add(statusPanel,BorderLayout.SOUTH);
  this.mainPanel.getActionMap().put(""String_Node_Str"",new RunMessageWindowAction());
  InputMap imap=this.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
  imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER,0),""String_Node_Str"");
  this.getContentPane().add(mainPanel);
}",0.7946498819826908
104448,"/** 
 * Returns a PresenceStatus instance representing the state this provider is currently in.
 * @return PresenceStatus
 */
public PresenceStatus getPresenceStatus(){
  if (currentIcqStatus == -1)   return IcqStatusEnum.OFFLINE;
  return icqStatusLongToPresenceStatus(currentIcqStatus);
}","/** 
 * Returns a PresenceStatus instance representing the state this provider is currently in.
 * @return PresenceStatus
 */
public PresenceStatus getPresenceStatus(){
  return icqStatusLongToPresenceStatus(currentIcqStatus);
}",0.8803088803088803
104449,"/** 
 * Converts the specified icqstatus to one of the status fields of the IcqStatusEnum class.
 * @param icqStatus the icqStatus as retured in FullUserInfo by the joscarstack
 * @return a PresenceStatus instance representation of the ""long"" icqStatusparameter. The returned result is one of the IcqStatusEnum fields.
 */
private IcqStatusEnum icqStatusLongToPresenceStatus(long icqStatus){
  if ((icqStatus & FullUserInfo.ICQSTATUS_INVISIBLE) != 0) {
    return IcqStatusEnum.INVISIBLE;
  }
 else   if ((icqStatus & FullUserInfo.ICQSTATUS_DND) != 0) {
    return IcqStatusEnum.DO_NOT_DISTURB;
  }
 else   if ((icqStatus & FullUserInfo.ICQSTATUS_OCCUPIED) != 0) {
    return IcqStatusEnum.OCCUPIED;
  }
 else   if ((icqStatus & FullUserInfo.ICQSTATUS_NA) != 0) {
    return IcqStatusEnum.NOT_AVAILABLE;
  }
 else   if ((icqStatus & FullUserInfo.ICQSTATUS_AWAY) != 0) {
    return IcqStatusEnum.AWAY;
  }
 else   if ((icqStatus & FullUserInfo.ICQSTATUS_FFC) != 0) {
    return IcqStatusEnum.FREE_FOR_CHAT;
  }
  return IcqStatusEnum.ONLINE;
}","/** 
 * Converts the specified icqstatus to one of the status fields of the IcqStatusEnum class.
 * @param icqStatus the icqStatus as retured in FullUserInfo by the joscarstack
 * @return a PresenceStatus instance representation of the ""long"" icqStatusparameter. The returned result is one of the IcqStatusEnum fields.
 */
private IcqStatusEnum icqStatusLongToPresenceStatus(long icqStatus){
  if (icqStatus == -1) {
    return IcqStatusEnum.OFFLINE;
  }
 else   if ((icqStatus & FullUserInfo.ICQSTATUS_INVISIBLE) != 0) {
    return IcqStatusEnum.INVISIBLE;
  }
 else   if ((icqStatus & FullUserInfo.ICQSTATUS_DND) != 0) {
    return IcqStatusEnum.DO_NOT_DISTURB;
  }
 else   if ((icqStatus & FullUserInfo.ICQSTATUS_OCCUPIED) != 0) {
    return IcqStatusEnum.OCCUPIED;
  }
 else   if ((icqStatus & FullUserInfo.ICQSTATUS_NA) != 0) {
    return IcqStatusEnum.NOT_AVAILABLE;
  }
 else   if ((icqStatus & FullUserInfo.ICQSTATUS_AWAY) != 0) {
    return IcqStatusEnum.AWAY;
  }
 else   if ((icqStatus & FullUserInfo.ICQSTATUS_FFC) != 0) {
    return IcqStatusEnum.FREE_FOR_CHAT;
  }
  return IcqStatusEnum.ONLINE;
}",0.9679516953088714
104450,"/** 
 * Get the PresenceStatus for a particular contact. This method is not meant to be used by the user interface (which would simply register as a presence listener and always follow contact status) but rather by other plugins that may for some reason need to know the status of a particular contact. <p>
 * @param contactIdentifier the dientifier of the contact whose status we'reinterested in.
 * @return PresenceStatus the <tt>PresenceStatus</tt> of the specified<tt>contact</tt>
 * @throws java.lang.IllegalStateException if the provider is not signedon ICQ
 * @throws java.lang.IllegalArgumentException if <tt>contact</tt> is nota valid <tt>IcqContact</tt>
 */
public PresenceStatus queryContactStatus(String contactIdentifier) throws IllegalStateException, IllegalArgumentException {
  assertConnected();
  StatusResponseRetriever responseRetriever=new StatusResponseRetriever();
  GetInfoCmd getInfoCmd=new GetInfoCmd(GetInfoCmd.CMD_USER_INFO,contactIdentifier);
  icqProvider.getAimConnection().getInfoService().getOscarConnection().sendSnacRequest(getInfoCmd,responseRetriever);
synchronized (responseRetriever) {
    try {
      responseRetriever.wait(10000);
    }
 catch (    InterruptedException ex) {
    }
  }
  if (responseRetriever.status == -1)   return IcqStatusEnum.OFFLINE;
  return icqStatusLongToPresenceStatus(responseRetriever.status);
}","/** 
 * Get the PresenceStatus for a particular contact. This method is not meant to be used by the user interface (which would simply register as a presence listener and always follow contact status) but rather by other plugins that may for some reason need to know the status of a particular contact. <p>
 * @param contactIdentifier the dientifier of the contact whose status we'reinterested in.
 * @return PresenceStatus the <tt>PresenceStatus</tt> of the specified<tt>contact</tt>
 * @throws java.lang.IllegalStateException if the provider is not signedon ICQ
 * @throws java.lang.IllegalArgumentException if <tt>contact</tt> is nota valid <tt>IcqContact</tt>
 */
public PresenceStatus queryContactStatus(String contactIdentifier) throws IllegalStateException, IllegalArgumentException {
  assertConnected();
  StatusResponseRetriever responseRetriever=new StatusResponseRetriever();
  GetInfoCmd getInfoCmd=new GetInfoCmd(GetInfoCmd.CMD_USER_INFO,contactIdentifier);
  icqProvider.getAimConnection().getInfoService().getOscarConnection().sendSnacRequest(getInfoCmd,responseRetriever);
synchronized (responseRetriever) {
    try {
      responseRetriever.wait(10000);
    }
 catch (    InterruptedException ex) {
    }
  }
  return icqStatusLongToPresenceStatus(responseRetriever.status);
}",0.9736644093303236
104451,"/** 
 * Starts the registration process. Connection details such as registration server, user name/number are provided through the configuration service through implementation specific properties.
 * @param authority the security authority that will be used for resolvingany security challenges that may be returned during the registration or at any moment while wer're registered.
 * @throws OperationFailedException with the corresponding code it theregistration fails for some reason (e.g. a networking error or an implementation problem).
 */
public void register(SecurityAuthority authority) throws OperationFailedException {
  if (authority == null)   throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
synchronized (initializationLock) {
    ProtocolProviderFactoryIcqImpl protocolProviderFactory=null;
    if (USING_ICQ)     protocolProviderFactory=IcqActivator.getIcqProtocolProviderFactory();
 else     protocolProviderFactory=IcqActivator.getAimProtocolProviderFactory();
    String password=protocolProviderFactory.loadPassword(getAccountID());
    if (password == null) {
      UserCredentials credentials=new UserCredentials();
      credentials.setUserName(this.getAccountID().getUserID());
      credentials=authority.obtainCredentials(getProtocolName(),credentials);
      char[] pass=credentials.getPassword();
      if (pass == null) {
        fireRegistrationStateChanged(RegistrationState.UNREGISTERED,RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_USER_REQUEST,""String_Node_Str"");
        return;
      }
      password=new String(pass);
      if (credentials.isPasswordPersistent()) {
        protocolProviderFactory.storePassword(getAccountID(),password);
      }
    }
    if (password.length() > 8)     password=password.substring(0,8);
    session=new DefaultAppSession();
    aimSession=session.openAimSession(new Screenname(getAccountID().getUserID()));
    aimConnection=aimSession.openConnection(new AimConnectionProperties(new Screenname(getAccountID().getUserID()),password));
    String proxyAddress=(String)getAccountID().getAccountProperties().get(ProtocolProviderFactory.PROXY_ADDRESS);
    if (proxyAddress != null && proxyAddress.length() > 0) {
      String proxyPortStr=(String)getAccountID().getAccountProperties().get(ProtocolProviderFactory.PROXY_PORT);
      int proxyPort;
      try {
        proxyPort=Integer.parseInt(proxyPortStr);
      }
 catch (      NumberFormatException ex) {
        throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INVALID_ACCOUNT_PROPERTIES,ex);
      }
      String proxyType=(String)getAccountID().getAccountProperties().get(ProtocolProviderFactory.PROXY_TYPE);
      if (proxyType == null)       throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INVALID_ACCOUNT_PROPERTIES);
      String proxyUsername=(String)getAccountID().getAccountProperties().get(ProtocolProviderFactory.PROXY_USERNAME);
      String proxyPassword=(String)getAccountID().getAccountProperties().get(ProtocolProviderFactory.PROXY_PASSWORD);
      if (proxyType.equals(""String_Node_Str""))       aimConnection.setProxy(AimProxyInfo.forHttp(proxyAddress,proxyPort,proxyUsername,proxyPassword));
 else       if (proxyType.equals(""String_Node_Str""))       aimConnection.setProxy(AimProxyInfo.forSocks4(proxyAddress,proxyPort,proxyUsername));
 else       if (proxyType.equals(""String_Node_Str""))       aimConnection.setProxy(AimProxyInfo.forSocks5(proxyAddress,proxyPort,proxyUsername,proxyPassword));
    }
    aimConnStateListener=new AimConnStateListener();
    aimConnection.addStateListener(aimConnStateListener);
    aimConnection.connect();
  }
}","/** 
 * Starts the registration process. Connection details such as registration server, user name/number are provided through the configuration service through implementation specific properties.
 * @param authority the security authority that will be used for resolvingany security challenges that may be returned during the registration or at any moment while wer're registered.
 * @throws OperationFailedException with the corresponding code it theregistration fails for some reason (e.g. a networking error or an implementation problem).
 */
public void register(SecurityAuthority authority) throws OperationFailedException {
  if (authority == null)   throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
synchronized (initializationLock) {
    ProtocolProviderFactoryIcqImpl protocolProviderFactory=null;
    if (USING_ICQ)     protocolProviderFactory=IcqActivator.getIcqProtocolProviderFactory();
 else     protocolProviderFactory=IcqActivator.getAimProtocolProviderFactory();
    String password=protocolProviderFactory.loadPassword(getAccountID());
    if (password == null) {
      UserCredentials credentials=new UserCredentials();
      credentials.setUserName(this.getAccountID().getUserID());
      credentials=authority.obtainCredentials(getProtocolName(),credentials);
      if (credentials == null) {
        fireRegistrationStateChanged(getRegistrationState(),RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_USER_REQUEST,""String_Node_Str"");
        return;
      }
      char[] pass=credentials.getPassword();
      if (pass == null) {
        fireRegistrationStateChanged(RegistrationState.UNREGISTERED,RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_USER_REQUEST,""String_Node_Str"");
        return;
      }
      password=new String(pass);
      if (credentials.isPasswordPersistent()) {
        protocolProviderFactory.storePassword(getAccountID(),password);
      }
    }
    if (password.length() > 8)     password=password.substring(0,8);
    session=new DefaultAppSession();
    aimSession=session.openAimSession(new Screenname(getAccountID().getUserID()));
    aimConnection=aimSession.openConnection(new AimConnectionProperties(new Screenname(getAccountID().getUserID()),password));
    String proxyAddress=(String)getAccountID().getAccountProperties().get(ProtocolProviderFactory.PROXY_ADDRESS);
    if (proxyAddress != null && proxyAddress.length() > 0) {
      String proxyPortStr=(String)getAccountID().getAccountProperties().get(ProtocolProviderFactory.PROXY_PORT);
      int proxyPort;
      try {
        proxyPort=Integer.parseInt(proxyPortStr);
      }
 catch (      NumberFormatException ex) {
        throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INVALID_ACCOUNT_PROPERTIES,ex);
      }
      String proxyType=(String)getAccountID().getAccountProperties().get(ProtocolProviderFactory.PROXY_TYPE);
      if (proxyType == null)       throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INVALID_ACCOUNT_PROPERTIES);
      String proxyUsername=(String)getAccountID().getAccountProperties().get(ProtocolProviderFactory.PROXY_USERNAME);
      String proxyPassword=(String)getAccountID().getAccountProperties().get(ProtocolProviderFactory.PROXY_PASSWORD);
      if (proxyType.equals(""String_Node_Str""))       aimConnection.setProxy(AimProxyInfo.forHttp(proxyAddress,proxyPort,proxyUsername,proxyPassword));
 else       if (proxyType.equals(""String_Node_Str""))       aimConnection.setProxy(AimProxyInfo.forSocks4(proxyAddress,proxyPort,proxyUsername));
 else       if (proxyType.equals(""String_Node_Str""))       aimConnection.setProxy(AimProxyInfo.forSocks5(proxyAddress,proxyPort,proxyUsername,proxyPassword));
    }
    aimConnStateListener=new AimConnStateListener();
    aimConnection.addStateListener(aimConnStateListener);
    aimConnection.connect();
  }
}",0.9554357828316024
104452,"/** 
 * Connects and logins to the server
 * @param authority SecurityAuthority
 * @throws XMPPException if we cannot connect to the server - network problem
 * @throws OperationFailedException if login parametersas server port are not correct
 */
private void connectAndLogin(SecurityAuthority authority) throws XMPPException, OperationFailedException {
synchronized (initializationLock) {
    String password=JabberActivator.getProtocolProviderFactory().loadPassword(getAccountID());
    if (password == null) {
      UserCredentials credentials=new UserCredentials();
      credentials.setUserName(getAccountID().getUserID());
      credentials=authority.obtainCredentials(ProtocolNames.JABBER,credentials);
      char[] pass=credentials.getPassword();
      if (pass == null) {
        fireRegistrationStateChanged(getRegistrationState(),RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_USER_REQUEST,""String_Node_Str"");
        return;
      }
      password=new String(pass);
      if (credentials.isPasswordPersistent()) {
        JabberActivator.getProtocolProviderFactory().storePassword(getAccountID(),password);
      }
    }
    try {
      String userID=StringUtils.parseName(getAccountID().getUserID());
      String serviceName=StringUtils.parseServer(getAccountID().getUserID());
      String serverAddress=(String)getAccountID().getAccountProperties().get(ProtocolProviderFactory.SERVER_ADDRESS);
      String serverPort=(String)getAccountID().getAccountProperties().get(ProtocolProviderFactory.SERVER_PORT);
      try {
        String hosts[]=NetworkUtils.getSRVRecords(""String_Node_Str"" + serviceName);
        if (hosts != null && hosts.length > 0) {
          logger.trace(""String_Node_Str"" + hosts[0]);
          serverAddress=hosts[0];
        }
      }
 catch (      ParseException ex1) {
        logger.error(""String_Node_Str"" + ex1.getMessage());
      }
      Roster.setDefaultSubscriptionMode(Roster.SubscriptionMode.manual);
      try {
        ConnectionConfiguration confConn=new ConnectionConfiguration(serverAddress,Integer.parseInt(serverPort),serviceName);
        connection=new XMPPConnection(confConn);
        connection.connect();
      }
 catch (      XMPPException exc) {
        logger.error(""String_Node_Str"" + getAccountID().getAccountUniqueID(),exc);
        fireRegistrationStateChanged(getRegistrationState(),RegistrationState.CONNECTION_FAILED,OperationFailedException.NETWORK_FAILURE,null);
        throw new OperationFailedException(""String_Node_Str"" + getAccountID().getAccountUniqueID(),OperationFailedException.NETWORK_FAILURE,exc);
      }
      connection.addConnectionListener(new JabberConnectionListener());
      fireRegistrationStateChanged(getRegistrationState(),RegistrationState.REGISTERING,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
      connection.login(userID,password,""String_Node_Str"");
      if (connection.isAuthenticated()) {
        this.reconnecting=false;
        connection.getRoster().setSubscriptionMode(Roster.SubscriptionMode.manual);
        fireRegistrationStateChanged(getRegistrationState(),RegistrationState.REGISTERED,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
      }
 else {
        fireRegistrationStateChanged(getRegistrationState(),RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
      }
    }
 catch (    NumberFormatException ex) {
      throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INVALID_ACCOUNT_PROPERTIES,ex);
    }
  }
}","/** 
 * Connects and logins to the server
 * @param authority SecurityAuthority
 * @throws XMPPException if we cannot connect to the server - network problem
 * @throws OperationFailedException if login parametersas server port are not correct
 */
private void connectAndLogin(SecurityAuthority authority) throws XMPPException, OperationFailedException {
synchronized (initializationLock) {
    String password=JabberActivator.getProtocolProviderFactory().loadPassword(getAccountID());
    if (password == null) {
      UserCredentials credentials=new UserCredentials();
      credentials.setUserName(getAccountID().getUserID());
      credentials=authority.obtainCredentials(ProtocolNames.JABBER,credentials);
      if (credentials == null) {
        fireRegistrationStateChanged(getRegistrationState(),RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_USER_REQUEST,""String_Node_Str"");
        return;
      }
      char[] pass=credentials.getPassword();
      if (pass == null) {
        fireRegistrationStateChanged(getRegistrationState(),RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_USER_REQUEST,""String_Node_Str"");
        return;
      }
      password=new String(pass);
      if (credentials.isPasswordPersistent()) {
        JabberActivator.getProtocolProviderFactory().storePassword(getAccountID(),password);
      }
    }
    try {
      String userID=StringUtils.parseName(getAccountID().getUserID());
      String serviceName=StringUtils.parseServer(getAccountID().getUserID());
      String serverAddress=(String)getAccountID().getAccountProperties().get(ProtocolProviderFactory.SERVER_ADDRESS);
      String serverPort=(String)getAccountID().getAccountProperties().get(ProtocolProviderFactory.SERVER_PORT);
      try {
        String hosts[]=NetworkUtils.getSRVRecords(""String_Node_Str"" + serviceName);
        if (hosts != null && hosts.length > 0) {
          logger.trace(""String_Node_Str"" + hosts[0]);
          serverAddress=hosts[0];
        }
      }
 catch (      ParseException ex1) {
        logger.error(""String_Node_Str"" + ex1.getMessage());
      }
      Roster.setDefaultSubscriptionMode(Roster.SubscriptionMode.manual);
      try {
        ConnectionConfiguration confConn=new ConnectionConfiguration(serverAddress,Integer.parseInt(serverPort),serviceName);
        connection=new XMPPConnection(confConn);
        connection.connect();
      }
 catch (      XMPPException exc) {
        logger.error(""String_Node_Str"" + getAccountID().getAccountUniqueID(),exc);
        fireRegistrationStateChanged(getRegistrationState(),RegistrationState.CONNECTION_FAILED,OperationFailedException.NETWORK_FAILURE,null);
        throw new OperationFailedException(""String_Node_Str"" + getAccountID().getAccountUniqueID(),OperationFailedException.NETWORK_FAILURE,exc);
      }
      connection.addConnectionListener(new JabberConnectionListener());
      fireRegistrationStateChanged(getRegistrationState(),RegistrationState.REGISTERING,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
      connection.login(userID,password,""String_Node_Str"");
      if (connection.isAuthenticated()) {
        this.reconnecting=false;
        connection.getRoster().setSubscriptionMode(Roster.SubscriptionMode.manual);
        fireRegistrationStateChanged(getRegistrationState(),RegistrationState.REGISTERED,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
      }
 else {
        fireRegistrationStateChanged(getRegistrationState(),RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
      }
    }
 catch (    NumberFormatException ex) {
      throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INVALID_ACCOUNT_PROPERTIES,ex);
    }
  }
}",0.970245440833676
104453,"/** 
 * Connects and logins to the server
 * @param authority SecurityAuthority
 * @throws XMPPException if we cannot connect to the server - network problem
 * @throws OperationFailedException if login parametersas server port are not correct
 */
private void connectAndLogin(SecurityAuthority authority) throws OperationFailedException {
synchronized (initializationLock) {
    String password=MsnActivator.getProtocolProviderFactory().loadPassword(getAccountID());
    if (password == null) {
      UserCredentials credentials=new UserCredentials();
      credentials.setUserName(getAccountID().getUserID());
      credentials=authority.obtainCredentials(ProtocolNames.MSN,credentials);
      char[] pass=credentials.getPassword();
      if (pass == null) {
        fireRegistrationStateChanged(getRegistrationState(),RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_USER_REQUEST,""String_Node_Str"");
        return;
      }
      password=new String(pass);
      if (credentials.isPasswordPersistent()) {
        MsnActivator.getProtocolProviderFactory().storePassword(getAccountID(),password);
      }
    }
    messenger=MsnMessengerFactory.createMsnMessenger(getAccountID().getUserID(),password);
    messenger.addMessengerListener(new MsnConnectionListener());
    persistentPresence.setMessenger(messenger);
    typingNotifications.setMessenger(messenger);
    try {
      messenger.login();
    }
 catch (    UnresolvedAddressException ex) {
      fireRegistrationStateChanged(getRegistrationState(),RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_SERVER_NOT_FOUND,null);
    }
  }
}","/** 
 * Connects and logins to the server
 * @param authority SecurityAuthority
 * @throws XMPPException if we cannot connect to the server - network problem
 * @throws OperationFailedException if login parametersas server port are not correct
 */
private void connectAndLogin(SecurityAuthority authority) throws OperationFailedException {
synchronized (initializationLock) {
    String password=MsnActivator.getProtocolProviderFactory().loadPassword(getAccountID());
    if (password == null) {
      UserCredentials credentials=new UserCredentials();
      credentials.setUserName(getAccountID().getUserID());
      credentials=authority.obtainCredentials(ProtocolNames.MSN,credentials);
      if (credentials == null) {
        fireRegistrationStateChanged(getRegistrationState(),RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_USER_REQUEST,""String_Node_Str"");
        return;
      }
      char[] pass=credentials.getPassword();
      if (pass == null) {
        fireRegistrationStateChanged(getRegistrationState(),RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_USER_REQUEST,""String_Node_Str"");
        return;
      }
      password=new String(pass);
      if (credentials.isPasswordPersistent()) {
        MsnActivator.getProtocolProviderFactory().storePassword(getAccountID(),password);
      }
    }
    messenger=MsnMessengerFactory.createMsnMessenger(getAccountID().getUserID(),password);
    messenger.addMessengerListener(new MsnConnectionListener());
    persistentPresence.setMessenger(messenger);
    typingNotifications.setMessenger(messenger);
    try {
      messenger.login();
    }
 catch (    UnresolvedAddressException ex) {
      fireRegistrationStateChanged(getRegistrationState(),RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_SERVER_NOT_FOUND,null);
    }
  }
}",0.9377331420373028
104454,"/** 
 * Returns a PresenceStatus instance representing the state this provider is currently in.
 * @return PresenceStatus
 */
public PresenceStatus getPresenceStatus(){
  return icqStatusLongToPresenceStatus(currentIcqStatus);
}","/** 
 * Returns a PresenceStatus instance representing the state this provider is currently in.
 * @return PresenceStatus
 */
public PresenceStatus getPresenceStatus(){
  if (currentIcqStatus == -1)   return IcqStatusEnum.OFFLINE;
  return icqStatusLongToPresenceStatus(currentIcqStatus);
}",0.8803088803088803
104455,"/** 
 * Get the PresenceStatus for a particular contact. This method is not meant to be used by the user interface (which would simply register as a presence listener and always follow contact status) but rather by other plugins that may for some reason need to know the status of a particular contact. <p>
 * @param contactIdentifier the dientifier of the contact whose status we'reinterested in.
 * @return PresenceStatus the <tt>PresenceStatus</tt> of the specified<tt>contact</tt>
 * @throws java.lang.IllegalStateException if the provider is not signedon ICQ
 * @throws java.lang.IllegalArgumentException if <tt>contact</tt> is nota valid <tt>IcqContact</tt>
 */
public PresenceStatus queryContactStatus(String contactIdentifier) throws IllegalStateException, IllegalArgumentException {
  assertConnected();
  StatusResponseRetriever responseRetriever=new StatusResponseRetriever();
  GetInfoCmd getInfoCmd=new GetInfoCmd(GetInfoCmd.CMD_USER_INFO,contactIdentifier);
  icqProvider.getAimConnection().getInfoService().getOscarConnection().sendSnacRequest(getInfoCmd,responseRetriever);
synchronized (responseRetriever) {
    try {
      responseRetriever.wait(10000);
    }
 catch (    InterruptedException ex) {
    }
  }
  return icqStatusLongToPresenceStatus(responseRetriever.status);
}","/** 
 * Get the PresenceStatus for a particular contact. This method is not meant to be used by the user interface (which would simply register as a presence listener and always follow contact status) but rather by other plugins that may for some reason need to know the status of a particular contact. <p>
 * @param contactIdentifier the dientifier of the contact whose status we'reinterested in.
 * @return PresenceStatus the <tt>PresenceStatus</tt> of the specified<tt>contact</tt>
 * @throws java.lang.IllegalStateException if the provider is not signedon ICQ
 * @throws java.lang.IllegalArgumentException if <tt>contact</tt> is nota valid <tt>IcqContact</tt>
 */
public PresenceStatus queryContactStatus(String contactIdentifier) throws IllegalStateException, IllegalArgumentException {
  assertConnected();
  StatusResponseRetriever responseRetriever=new StatusResponseRetriever();
  GetInfoCmd getInfoCmd=new GetInfoCmd(GetInfoCmd.CMD_USER_INFO,contactIdentifier);
  icqProvider.getAimConnection().getInfoService().getOscarConnection().sendSnacRequest(getInfoCmd,responseRetriever);
synchronized (responseRetriever) {
    try {
      responseRetriever.wait(10000);
    }
 catch (    InterruptedException ex) {
    }
  }
  if (responseRetriever.status == -1)   return IcqStatusEnum.OFFLINE;
  return icqStatusLongToPresenceStatus(responseRetriever.status);
}",0.9736644093303236
104456,"/** 
 * Saves the last status for all accounts. This information is used on loging. Each time user logs in he's logged with the same status as he was the last time before closing the application.
 */
public void saveStatusInformation(ProtocolProviderService protocolProvider,String statusName){
  ServiceReference configReference=SystrayActivator.bundleContext.getServiceReference(ConfigurationService.class.getName());
  ConfigurationService configService=(ConfigurationService)SystrayActivator.bundleContext.getService(configReference);
  if (configService != null) {
    String prefix=""String_Node_Str"";
    List accounts=configService.getPropertyNamesByPrefix(prefix,true);
    boolean savedAccount=false;
    Iterator accountsIter=accounts.iterator();
    while (accountsIter.hasNext()) {
      String accountRootPropName=(String)accountsIter.next();
      String accountUID=configService.getString(accountRootPropName);
      if (accountUID.equals(protocolProvider.getAccountID().getAccountUniqueID())) {
        configService.setProperty(accountRootPropName + ""String_Node_Str"",statusName);
        savedAccount=true;
      }
    }
    if (!savedAccount) {
      String accNodeName=""String_Node_Str"" + Long.toString(System.currentTimeMillis());
      String accountPackage=""String_Node_Str"" + accNodeName;
      configService.setProperty(accountPackage,protocolProvider.getAccountID().getAccountUniqueID());
      configService.setProperty(accountPackage + ""String_Node_Str"",statusName);
    }
  }
}","/** 
 * Saves the last status for all accounts. This information is used on loging. Each time user logs in he's logged with the same status as he was the last time before closing the application.
 */
public void saveStatusInformation(ProtocolProviderService protocolProvider,String statusName){
  ConfigurationService configService=SystrayActivator.getConfigurationService();
  if (configService != null) {
    String prefix=""String_Node_Str"";
    List accounts=configService.getPropertyNamesByPrefix(prefix,true);
    boolean savedAccount=false;
    Iterator accountsIter=accounts.iterator();
    while (accountsIter.hasNext()) {
      String accountRootPropName=(String)accountsIter.next();
      String accountUID=configService.getString(accountRootPropName);
      if (accountUID.equals(protocolProvider.getAccountID().getAccountUniqueID())) {
        configService.setProperty(accountRootPropName + ""String_Node_Str"",statusName);
        savedAccount=true;
      }
    }
    if (!savedAccount) {
      String accNodeName=""String_Node_Str"" + Long.toString(System.currentTimeMillis());
      String accountPackage=""String_Node_Str"" + accNodeName;
      configService.setProperty(accountPackage,protocolProvider.getAccountID().getAccountUniqueID());
      configService.setProperty(accountPackage + ""String_Node_Str"",statusName);
    }
  }
}",0.9055809055809056
104457,"/** 
 * Initializes the systray icon and related listeners.
 */
private void initSystray(){
  menu=new TrayMenu(uiService,this);
  String osName=System.getProperty(""String_Node_Str"");
  if (osName.startsWith(""String_Node_Str"")) {
    logoIcon=new ImageIcon(Resources.getImage(""String_Node_Str""));
  }
 else {
    logoIcon=new ImageIcon(Resources.getImage(""String_Node_Str""));
  }
  trayIcon=new TrayIcon(logoIcon,""String_Node_Str"",menu);
  trayIcon.setIconAutoSize(true);
  trayIcon.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (uiService.isVisible()) {
        uiService.setVisible(false);
      }
 else {
        uiService.setVisible(true);
      }
    }
  }
);
  trayIcon.addBalloonActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      firePopupMessageEvent(e.getSource());
      ExportedWindow chatWindow=uiService.getExportedWindow(ExportedWindow.CHAT_WINDOW);
      if (chatWindow != null && chatWindow.isVisible()) {
        chatWindow.bringToFront();
      }
    }
  }
);
  systray.addTrayIcon(trayIcon);
}","/** 
 * Initializes the systray icon and related listeners.
 */
private void initSystray(){
  menu=new TrayMenu(uiService,this);
  String osName=System.getProperty(""String_Node_Str"");
  if (osName.startsWith(""String_Node_Str"")) {
    logoIcon=new ImageIcon(Resources.getImage(""String_Node_Str""));
  }
 else {
    logoIcon=new ImageIcon(Resources.getImage(""String_Node_Str""));
  }
  trayIcon=new TrayIcon(logoIcon,""String_Node_Str"",menu);
  trayIcon.setIconAutoSize(true);
  trayIcon.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      boolean isVisible;
      isVisible=!uiService.isVisible();
      uiService.setVisible(isVisible);
      ConfigurationService configService=SystrayActivator.getConfigurationService();
      configService.setProperty(""String_Node_Str"",new Boolean(isVisible));
    }
  }
);
  trayIcon.addBalloonActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      firePopupMessageEvent(e.getSource());
      ExportedWindow chatWindow=uiService.getExportedWindow(ExportedWindow.CHAT_WINDOW);
      if (chatWindow != null && chatWindow.isVisible()) {
        chatWindow.bringToFront();
      }
    }
  }
);
  systray.addTrayIcon(trayIcon);
}",0.8462192013593883
104458,"/** 
 * Creates an instance of <tt>StatusSelectorBox</tt> and initializes the selector box with data.
 * @param mainFrame The main application window.
 * @param protocolProvider The protocol provider.
 * @param accountIndex If we have more than one account for a protocol,each account has an index.
 */
public PresenceStatusSelectorBox(MainFrame mainFrame,ProtocolProviderService protocolProvider,int accountIndex){
  this.mainFrame=mainFrame;
  this.protocolProvider=protocolProvider;
  this.accountIndex=accountIndex;
  this.presence=mainFrame.getProtocolPresence(protocolProvider);
  this.statusIterator=this.presence.getSupportedStatusSet();
  String tooltip=""String_Node_Str"" + protocolProvider.getAccountID().getUserID() + ""String_Node_Str"";
  this.setToolTipText(tooltip);
  titleLabel=new JLabel(protocolProvider.getAccountID().getUserID());
  titleLabel.setBorder(BorderFactory.createEmptyBorder(0,5,0,0));
  titleLabel.setFont(Constants.FONT.deriveFont(Font.BOLD));
  this.add(titleLabel);
  this.addSeparator();
  while (statusIterator.hasNext()) {
    PresenceStatus status=(PresenceStatus)statusIterator.next();
    int connectivity=status.getStatus();
    if (connectivity < 1) {
      this.offlineStatus=status;
    }
 else     if ((onlineStatus != null && (onlineStatus.getStatus() < connectivity)) || (onlineStatus == null && (connectivity > 50 && connectivity < 80))) {
      this.onlineStatus=status;
    }
    this.addItem(status.getStatusName(),new ImageIcon(ImageLoader.getBytesInImage(status.getStatusIcon())),new ItemActionListener());
  }
  this.setSelectedStatus(offlineStatus);
}","/** 
 * Creates an instance of <tt>StatusSelectorBox</tt> and initializes the selector box with data.
 * @param mainFrame The main application window.
 * @param protocolProvider The protocol provider.
 * @param accountIndex If we have more than one account for a protocol,each account has an index.
 */
public PresenceStatusSelectorBox(MainFrame mainFrame,ProtocolProviderService protocolProvider,int accountIndex){
  this.mainFrame=mainFrame;
  this.protocolProvider=protocolProvider;
  this.accountIndex=accountIndex;
  this.presence=mainFrame.getProtocolPresenceOpSet(protocolProvider);
  this.statusIterator=this.presence.getSupportedStatusSet();
  String tooltip=""String_Node_Str"" + protocolProvider.getAccountID().getUserID() + ""String_Node_Str"";
  this.setToolTipText(tooltip);
  titleLabel=new JLabel(protocolProvider.getAccountID().getUserID());
  titleLabel.setBorder(BorderFactory.createEmptyBorder(0,5,0,0));
  titleLabel.setFont(Constants.FONT.deriveFont(Font.BOLD));
  this.add(titleLabel);
  this.addSeparator();
  while (statusIterator.hasNext()) {
    PresenceStatus status=(PresenceStatus)statusIterator.next();
    int connectivity=status.getStatus();
    if (connectivity < 1) {
      this.offlineStatus=status;
    }
 else     if ((onlineStatus != null && (onlineStatus.getStatus() < connectivity)) || (onlineStatus == null && (connectivity > 50 && connectivity < 80))) {
      this.onlineStatus=status;
    }
    this.addItem(status.getStatusName(),new ImageIcon(ImageLoader.getBytesInImage(status.getStatusIcon())),new ItemActionListener());
  }
  this.setSelectedStatus(offlineStatus);
}",0.9984457569163816
104459,"/** 
 * Returns the last status that was stored in the configuration xml for the given protocol provider.
 * @param protocolProvider the protocol provider 
 * @return the last status that was stored in the configuration xml for thegiven protocol provider
 */
public PresenceStatus getLastPresenceStatus(ProtocolProviderService protocolProvider){
  String lastStatus=getLastStatusString(protocolProvider);
  OperationSetPresence presence=mainFrame.getProtocolPresence(protocolProvider);
  if (presence == null)   return null;
  Iterator i=presence.getSupportedStatusSet();
  if (lastStatus != null) {
    PresenceStatus status;
    while (i.hasNext()) {
      status=(PresenceStatus)i.next();
      if (status.getStatusName().equals(lastStatus)) {
        return status;
      }
    }
  }
  return null;
}","/** 
 * Returns the last status that was stored in the configuration xml for the given protocol provider.
 * @param protocolProvider the protocol provider 
 * @return the last status that was stored in the configuration xml for thegiven protocol provider
 */
public PresenceStatus getLastPresenceStatus(ProtocolProviderService protocolProvider){
  String lastStatus=getLastStatusString(protocolProvider);
  OperationSetPresence presence=mainFrame.getProtocolPresenceOpSet(protocolProvider);
  if (presence == null)   return null;
  Iterator i=presence.getSupportedStatusSet();
  if (lastStatus != null) {
    PresenceStatus status;
    while (i.hasNext()) {
      status=(PresenceStatus)i.next();
      if (status.getStatusName().equals(lastStatus)) {
        return status;
      }
    }
  }
  return null;
}",0.9969001859888408
104460,"/** 
 * Creates the selector box, containing all protocol statuses, adds it to  the StatusPanel and refreshes the panel.
 * @param protocolProvider The protocol provider.
 */
public void addAccount(ProtocolProviderService protocolProvider){
  StatusSelectorBox protocolStatusCombo;
  int providerIndex=this.mainFrame.getProviderIndex(protocolProvider);
  if (mainFrame.getProtocolPresence(protocolProvider) != null) {
    protocolStatusCombo=new PresenceStatusSelectorBox(this.mainFrame,protocolProvider,providerIndex);
  }
 else {
    protocolStatusCombo=new SimpleStatusSelectorBox(this.mainFrame,protocolProvider,providerIndex);
  }
  protocolStatusCombo.addComponentListener(this);
  this.protocolStatusCombos.put(protocolProvider,protocolStatusCombo);
  if (protocolProvider.getProtocolName().equals(""String_Node_Str""))   this.add(protocolStatusCombo,FlowLayout.LEFT);
 else   this.add(protocolStatusCombo);
  this.getParent().validate();
}","/** 
 * Creates the selector box, containing all protocol statuses, adds it to  the StatusPanel and refreshes the panel.
 * @param protocolProvider The protocol provider.
 */
public void addAccount(ProtocolProviderService protocolProvider){
  StatusSelectorBox protocolStatusCombo;
  int providerIndex=this.mainFrame.getProviderIndex(protocolProvider);
  if (mainFrame.getProtocolPresenceOpSet(protocolProvider) != null) {
    protocolStatusCombo=new PresenceStatusSelectorBox(this.mainFrame,protocolProvider,providerIndex);
  }
 else {
    protocolStatusCombo=new SimpleStatusSelectorBox(this.mainFrame,protocolProvider,providerIndex);
  }
  protocolStatusCombo.addComponentListener(this);
  this.protocolStatusCombos.put(protocolProvider,protocolStatusCombo);
  if (protocolProvider.getProtocolName().equals(""String_Node_Str""))   this.add(protocolStatusCombo,FlowLayout.LEFT);
 else   this.add(protocolStatusCombo);
  this.getParent().validate();
}",0.9973614775725592
104461,"/** 
 * Opens a the specified chatPanel and brings it to the front if so specified.
 * @param chatPanel the chat panel that we will be opening
 * @param setSelected specifies whether we should bring the chat to frontafter creating it.
 */
public void openChat(ChatPanel chatPanel,boolean setSelected){
synchronized (syncChat) {
    ChatWindow chatWindow=chatPanel.getChatWindow();
    boolean isChatVisible=chatPanel.isWindowVisible();
    if (!isChatVisible)     chatWindow.addChat(chatPanel);
    if (chatWindow.isVisible()) {
      if ((ConfigurationManager.isAutoPopupNewMessage() && chatWindow.getExtendedState() != JFrame.ICONIFIED) || setSelected) {
        if (chatWindow.getState() == JFrame.ICONIFIED)         chatWindow.setExtendedState(JFrame.NORMAL);
        chatWindow.toFront();
        chatWindow.setCurrentChatPanel(chatPanel);
      }
 else {
        if (chatWindow.getState() == JFrame.ICONIFIED && !chatWindow.getTitle().startsWith(""String_Node_Str"")) {
          chatWindow.setTitle(""String_Node_Str"" + chatWindow.getTitle());
        }
      }
    }
 else {
      chatWindow.setVisible(true);
      chatWindow.setCurrentChatPanel(chatPanel);
    }
    chatPanel.setCaretToEnd();
    if (!chatWindow.getCurrentChatPanel().equals(chatPanel) && chatWindow.getChatTabCount() > 0) {
      chatPanel.getChatWindow().highlightTab(chatPanel);
    }
  }
}","/** 
 * Opens a the specified chatPanel and brings it to the front if so specified.
 * @param chatPanel the chat panel that we will be opening
 * @param setSelected specifies whether we should bring the chat to frontafter creating it.
 */
public void openChat(ChatPanel chatPanel,boolean setSelected){
synchronized (syncChat) {
    ChatWindow chatWindow=chatPanel.getChatWindow();
    boolean isChatVisible=chatPanel.isWindowVisible();
    if (!isChatVisible)     chatWindow.addChat(chatPanel);
    if (chatWindow.isVisible()) {
      if (chatWindow.getExtendedState() != JFrame.ICONIFIED) {
        if (ConfigurationManager.isAutoPopupNewMessage() || setSelected)         chatWindow.toFront();
      }
 else {
        if (setSelected) {
          chatWindow.setExtendedState(JFrame.NORMAL);
          chatWindow.toFront();
        }
        if (!chatWindow.getTitle().startsWith(""String_Node_Str""))         chatWindow.setTitle(""String_Node_Str"" + chatWindow.getTitle());
      }
      if (setSelected) {
        chatWindow.setCurrentChatPanel(chatPanel);
      }
 else       if (!chatWindow.getCurrentChatPanel().equals(chatPanel) && chatWindow.getChatTabCount() > 0) {
        chatPanel.getChatWindow().highlightTab(chatPanel);
      }
    }
 else {
      chatWindow.setVisible(true);
      chatWindow.setCurrentChatPanel(chatPanel);
    }
    chatPanel.setCaretToEnd();
  }
}",0.584122359796067
104462,"/** 
 * Adds all protocol supported operation sets.
 * @param protocolProvider The protocol provider.
 */
public void addProtocolSupportedOperationSets(ProtocolProviderService protocolProvider){
  Map supportedOperationSets=protocolProvider.getSupportedOperationSets();
  this.protocolSupportedOperationSets.put(protocolProvider,supportedOperationSets);
  String ppOpSetClassName=OperationSetPersistentPresence.class.getName();
  String pOpSetClassName=OperationSetPresence.class.getName();
  if (supportedOperationSets.containsKey(ppOpSetClassName) || supportedOperationSets.containsKey(pOpSetClassName)) {
    OperationSetPresence presence=(OperationSetPresence)supportedOperationSets.get(ppOpSetClassName);
    if (presence == null) {
      presence=(OperationSetPresence)supportedOperationSets.get(pOpSetClassName);
    }
    this.protocolPresenceSets.put(protocolProvider,presence);
    presence.addProviderPresenceStatusListener(new GUIProviderPresenceStatusListener());
    presence.addContactPresenceStatusListener(new GUIContactPresenceStatusListener());
  }
  String imOpSetClassName=OperationSetBasicInstantMessaging.class.getName();
  if (supportedOperationSets.containsKey(imOpSetClassName)) {
    OperationSetBasicInstantMessaging im=(OperationSetBasicInstantMessaging)supportedOperationSets.get(imOpSetClassName);
    this.imOperationSets.put(protocolProvider,im);
    im.addMessageListener(getContactListPanel());
  }
  String tnOpSetClassName=OperationSetTypingNotifications.class.getName();
  if (supportedOperationSets.containsKey(tnOpSetClassName)) {
    OperationSetTypingNotifications tn=(OperationSetTypingNotifications)supportedOperationSets.get(tnOpSetClassName);
    this.tnOperationSets.put(protocolProvider,tn);
    tn.addTypingNotificationsListener(this.getContactListPanel());
  }
  String wciOpSetClassName=OperationSetWebContactInfo.class.getName();
  if (supportedOperationSets.containsKey(wciOpSetClassName)) {
    OperationSetWebContactInfo wContactInfo=(OperationSetWebContactInfo)supportedOperationSets.get(wciOpSetClassName);
    this.webContactInfoOperationSets.put(protocolProvider,wContactInfo);
  }
  String telOpSetClassName=OperationSetBasicTelephony.class.getName();
  if (supportedOperationSets.containsKey(telOpSetClassName)) {
    OperationSetBasicTelephony telephony=(OperationSetBasicTelephony)supportedOperationSets.get(telOpSetClassName);
    telephony.addCallListener(callManager);
    this.getContactListPanel().getContactList().addListSelectionListener(callManager);
    this.tabbedPane.addChangeListener(callManager);
    this.protocolTelephonySets.put(protocolProvider,telephony);
  }
}","/** 
 * Adds all protocol supported operation sets.
 * @param protocolProvider The protocol provider.
 */
public void addProtocolSupportedOperationSets(ProtocolProviderService protocolProvider){
  Map supportedOperationSets=protocolProvider.getSupportedOperationSets();
  this.protocolSupportedOperationSets.put(protocolProvider,supportedOperationSets);
  String ppOpSetClassName=OperationSetPersistentPresence.class.getName();
  String pOpSetClassName=OperationSetPresence.class.getName();
  if (supportedOperationSets.containsKey(ppOpSetClassName) || supportedOperationSets.containsKey(pOpSetClassName)) {
    OperationSetPresence presence=(OperationSetPresence)supportedOperationSets.get(ppOpSetClassName);
    if (presence == null) {
      presence=(OperationSetPresence)supportedOperationSets.get(pOpSetClassName);
    }
    this.protocolPresenceSets.put(protocolProvider,presence);
    presence.addProviderPresenceStatusListener(new GUIProviderPresenceStatusListener());
    presence.addContactPresenceStatusListener(new GUIContactPresenceStatusListener());
  }
  String imOpSetClassName=OperationSetBasicInstantMessaging.class.getName();
  if (supportedOperationSets.containsKey(imOpSetClassName)) {
    OperationSetBasicInstantMessaging im=(OperationSetBasicInstantMessaging)supportedOperationSets.get(imOpSetClassName);
    im.addMessageListener(getContactListPanel());
  }
  String tnOpSetClassName=OperationSetTypingNotifications.class.getName();
  if (supportedOperationSets.containsKey(tnOpSetClassName)) {
    OperationSetTypingNotifications tn=(OperationSetTypingNotifications)supportedOperationSets.get(tnOpSetClassName);
    tn.addTypingNotificationsListener(this.getContactListPanel());
  }
  String wciOpSetClassName=OperationSetWebContactInfo.class.getName();
  if (supportedOperationSets.containsKey(wciOpSetClassName)) {
    OperationSetWebContactInfo wContactInfo=(OperationSetWebContactInfo)supportedOperationSets.get(wciOpSetClassName);
    this.webContactInfoOperationSets.put(protocolProvider,wContactInfo);
  }
  String telOpSetClassName=OperationSetBasicTelephony.class.getName();
  if (supportedOperationSets.containsKey(telOpSetClassName)) {
    OperationSetBasicTelephony telephony=(OperationSetBasicTelephony)supportedOperationSets.get(telOpSetClassName);
    telephony.addCallListener(callManager);
    this.getContactListPanel().getContactList().addListSelectionListener(callManager);
    this.tabbedPane.addChangeListener(callManager);
    this.protocolTelephonySets.put(protocolProvider,telephony);
  }
}",0.980324074074074
104463,"/** 
 * Creates a <tt>ChatPanel</tt> which is added to the given chat window.
 * @param chatWindow The parent window of this chat panel.
 * @param metaContact the meta contact that this chat is about.
 * @param protocolContact The subContact which is selected insthe chat.
 */
public ChatPanel(ChatWindow chatWindow,MetaContact metaContact,Contact protocolContact){
  super(new BorderLayout());
  this.chatWindow=chatWindow;
  this.metaContact=metaContact;
  this.imOperationSet=this.chatWindow.getMainFrame().getProtocolIM(protocolContact.getProtocolProvider());
  this.tnOperationSet=this.chatWindow.getMainFrame().getTypingNotifications(protocolContact.getProtocolProvider());
  this.conversationPanel=new ChatConversationPanel(this);
  this.chatConferencePanel=new ChatConferencePanel(this,metaContact,protocolContact);
  this.sendPanel=new ChatSendPanel(this,metaContact,protocolContact);
  this.writeMessagePanel=new ChatWritePanel(this);
  this.topSplitPane.setResizeWeight(1.0D);
  this.messagePane.setResizeWeight(1.0D);
  this.chatConferencePanel.setPreferredSize(new Dimension(120,100));
  this.chatConferencePanel.setMinimumSize(new Dimension(120,100));
  this.writeMessagePanel.setPreferredSize(new Dimension(500,100));
  this.writeMessagePanel.setMinimumSize(new Dimension(500,100));
  this.conversationPanel.setPreferredSize(new Dimension(400,200));
  this.init();
  addComponentListener(new TabSelectionComponentListener());
  new Thread(){
    public void run(){
      loadHistoryPeriod();
    }
  }
.start();
}","/** 
 * Creates a <tt>ChatPanel</tt> which is added to the given chat window.
 * @param chatWindow The parent window of this chat panel.
 * @param metaContact the meta contact that this chat is about.
 * @param protocolContact The subContact which is selected insthe chat.
 */
public ChatPanel(ChatWindow chatWindow,MetaContact metaContact,Contact protocolContact){
  super(new BorderLayout());
  this.chatWindow=chatWindow;
  this.metaContact=metaContact;
  this.conversationPanel=new ChatConversationPanel(this);
  this.chatConferencePanel=new ChatConferencePanel(this,metaContact,protocolContact);
  this.sendPanel=new ChatSendPanel(this,metaContact,protocolContact);
  this.writeMessagePanel=new ChatWritePanel(this);
  this.topSplitPane.setResizeWeight(1.0D);
  this.messagePane.setResizeWeight(1.0D);
  this.chatConferencePanel.setPreferredSize(new Dimension(120,100));
  this.chatConferencePanel.setMinimumSize(new Dimension(120,100));
  this.writeMessagePanel.setPreferredSize(new Dimension(500,100));
  this.writeMessagePanel.setMinimumSize(new Dimension(500,100));
  this.conversationPanel.setPreferredSize(new Dimension(400,200));
  this.init();
  addComponentListener(new TabSelectionComponentListener());
  new Thread(){
    public void run(){
      loadHistoryPeriod();
    }
  }
.start();
}",0.9212848570420048
104464,"/** 
 * Defines actions when send button is pressed.
 * @param e The <tt>ActionEvent</tt> object.
 */
public void actionPerformed(ActionEvent e){
  if (!this.chatPanel.isWriteAreaEmpty()) {
    OperationSetBasicInstantMessaging im=this.chatPanel.getImOperationSet();
    String body=chatPanel.getTextFromWriteArea();
    Message msg=im.createMessage(body);
    this.chatPanel.getChatWindow().getMainFrame().getWaitToBeDeliveredMsgs().put(msg.getMessageUID(),this.chatPanel);
    Contact contact=(Contact)contactSelectorBox.getMenu().getSelectedObject();
    if (chatPanel.getTnOperationSet() != null) {
      chatPanel.stopTypingNotifications();
    }
    try {
      im.sendInstantMessage(contact,msg);
    }
 catch (    IllegalStateException ex) {
      chatPanel.refreshWriteArea();
      chatPanel.processMessage(contact.getDisplayName(),new Date(System.currentTimeMillis()),Constants.OUTGOING_MESSAGE,msg.getContent());
      chatPanel.processMessage(contact.getDisplayName(),new Date(System.currentTimeMillis()),Constants.ERROR_MESSAGE,Messages.getI18NString(""String_Node_Str"").getText());
    }
  }
  chatPanel.requestFocusInWriteArea();
}","/** 
 * Defines actions when send button is pressed.
 * @param e The <tt>ActionEvent</tt> object.
 */
public void actionPerformed(ActionEvent e){
  if (!this.chatPanel.isWriteAreaEmpty()) {
    Contact contact=(Contact)contactSelectorBox.getMenu().getSelectedObject();
    OperationSetBasicInstantMessaging im=(OperationSetBasicInstantMessaging)contact.getProtocolProvider().getOperationSet(OperationSetBasicInstantMessaging.class);
    OperationSetTypingNotifications tn=(OperationSetTypingNotifications)contact.getProtocolProvider().getOperationSet(OperationSetTypingNotifications.class);
    String body=chatPanel.getTextFromWriteArea();
    Message msg=im.createMessage(body);
    this.chatPanel.getChatWindow().getMainFrame().getWaitToBeDeliveredMsgs().put(msg.getMessageUID(),this.chatPanel);
    if (tn != null) {
      chatPanel.stopTypingNotifications();
    }
    try {
      im.sendInstantMessage(contact,msg);
    }
 catch (    IllegalStateException ex) {
      logger.error(""String_Node_Str"",ex);
      chatPanel.refreshWriteArea();
      chatPanel.processMessage(contact.getDisplayName(),new Date(System.currentTimeMillis()),Constants.OUTGOING_MESSAGE,msg.getContent());
      chatPanel.processMessage(contact.getDisplayName(),new Date(System.currentTimeMillis()),Constants.ERROR_MESSAGE,Messages.getI18NString(""String_Node_Str"").getText());
    }
catch (    Exception ex) {
      logger.error(""String_Node_Str"",ex);
      chatPanel.refreshWriteArea();
      chatPanel.processMessage(contact.getDisplayName(),new Date(System.currentTimeMillis()),Constants.OUTGOING_MESSAGE,msg.getContent());
      chatPanel.processMessage(contact.getDisplayName(),new Date(System.currentTimeMillis()),Constants.ERROR_MESSAGE,Messages.getI18NString(""String_Node_Str"").getText());
    }
  }
  chatPanel.requestFocusInWriteArea();
}",0.5617221661621258
104465,"/** 
 * When a message is received determines whether to open a new chat window or chat window tab, or to indicate that a message is received from a contact which already has an open chat. When the chat is found checks if in mode ""Auto popup enabled"" and if this is the case shows the message in the appropriate chat panel.
 * @param evt the event containing details on the received message
 */
public void messageReceived(MessageReceivedEvent evt){
  logger.trace(""String_Node_Str"" + evt.getSourceContact().getAddress());
  Contact protocolContact=evt.getSourceContact();
  Date date=evt.getTimestamp();
  Message message=evt.getSourceMessage();
  MetaContact metaContact=mainFrame.getContactList().findMetaContactByContact(protocolContact);
  ChatPanel chatPanel;
  if (!Constants.TABBED_CHAT_WINDOW) {
    if (chatWindowManager.containsContactChat(metaContact)) {
      chatPanel=chatWindowManager.getContactChat(metaContact);
      chatPanel.processMessage(protocolContact.getDisplayName(),date,Constants.INCOMING_MESSAGE,message.getContent());
    }
 else {
      chatPanel=chatWindowManager.createChat(metaContact,protocolContact);
      chatPanel.processMessage(protocolContact.getDisplayName(),date,Constants.INCOMING_MESSAGE,message.getContent());
    }
  }
 else {
    if (!chatWindowManager.containsContactChat(metaContact)) {
      logger.trace(""String_Node_Str"" + evt.getSourceContact().getAddress());
      chatPanel=chatWindowManager.createChat(metaContact,protocolContact);
      logger.trace(""String_Node_Str"" + evt.getSourceContact().getAddress());
      chatPanel.processMessage(protocolContact.getDisplayName(),date,Constants.INCOMING_MESSAGE,message.getContent());
    }
 else {
      logger.trace(""String_Node_Str"" + evt.getSourceContact().getAddress());
      chatPanel=chatWindowManager.getContactChat(metaContact);
      logger.trace(""String_Node_Str"" + evt.getSourceContact().getAddress());
      chatPanel.processMessage(protocolContact.getDisplayName(),date,Constants.INCOMING_MESSAGE,message.getContent());
    }
  }
  chatWindowManager.openChat(chatPanel,false);
  GuiActivator.getAudioNotifier().createAudio(Sounds.INCOMING_MESSAGE).play();
  if (!chatPanel.getProtocolContact().getProtocolProvider().equals(protocolContact.getProtocolProvider())) {
    chatPanel.setProtocolContact(protocolContact);
  }
}","/** 
 * When a message is received determines whether to open a new chat window or chat window tab, or to indicate that a message is received from a contact which already has an open chat. When the chat is found checks if in mode ""Auto popup enabled"" and if this is the case shows the message in the appropriate chat panel.
 * @param evt the event containing details on the received message
 */
public void messageReceived(MessageReceivedEvent evt){
  logger.trace(""String_Node_Str"" + evt.getSourceContact().getAddress());
  Contact protocolContact=evt.getSourceContact();
  Date date=evt.getTimestamp();
  Message message=evt.getSourceMessage();
  MetaContact metaContact=mainFrame.getContactList().findMetaContactByContact(protocolContact);
  ChatPanel chatPanel;
  if (!Constants.TABBED_CHAT_WINDOW) {
    if (chatWindowManager.containsContactChat(metaContact)) {
      chatPanel=chatWindowManager.getContactChat(metaContact);
      chatPanel.processMessage(protocolContact.getDisplayName(),date,Constants.INCOMING_MESSAGE,message.getContent());
    }
 else {
      chatPanel=chatWindowManager.createChat(metaContact,protocolContact,message.getMessageUID());
      chatPanel.processMessage(protocolContact.getDisplayName(),date,Constants.INCOMING_MESSAGE,message.getContent());
    }
  }
 else {
    if (!chatWindowManager.containsContactChat(metaContact)) {
      logger.trace(""String_Node_Str"" + evt.getSourceContact().getAddress());
      chatPanel=chatWindowManager.createChat(metaContact,protocolContact,message.getMessageUID());
      logger.trace(""String_Node_Str"" + evt.getSourceContact().getAddress());
      chatPanel.processMessage(protocolContact.getDisplayName(),date,Constants.INCOMING_MESSAGE,message.getContent());
    }
 else {
      logger.trace(""String_Node_Str"" + evt.getSourceContact().getAddress());
      chatPanel=chatWindowManager.getContactChat(metaContact);
      logger.trace(""String_Node_Str"" + evt.getSourceContact().getAddress());
      chatPanel.processMessage(protocolContact.getDisplayName(),date,Constants.INCOMING_MESSAGE,message.getContent());
    }
  }
  chatWindowManager.openChat(chatPanel,false);
  GuiActivator.getAudioNotifier().createAudio(Sounds.INCOMING_MESSAGE).play();
  if (!chatPanel.getProtocolContact().getProtocolProvider().equals(protocolContact.getProtocolProvider())) {
    chatPanel.setProtocolContact(protocolContact);
  }
}",0.9898348157560356
104466,"/** 
 * Creates a <tt>ChatPanel</tt> for the given contact and saves it in the list ot created <tt>ChatPanel</tt>s.
 * @param contact The MetaContact for this chat.
 * @param status The current status.
 * @param protocolContact The protocol contact.
 * @return The <code>ChatPanel</code> newly created.
 */
public ChatPanel createChat(MetaContact contact,Contact protocolContact){
synchronized (syncChat) {
    ChatWindow chatWindow;
    if (Constants.TABBED_CHAT_WINDOW && this.chatWindow != null)     chatWindow=this.chatWindow;
 else {
      chatWindow=new ChatWindow(mainFrame);
      this.chatWindow=chatWindow;
    }
    ChatPanel chatPanel=new ChatPanel(chatWindow,contact,protocolContact);
synchronized (chats) {
      this.chats.put(contact,chatPanel);
    }
    chatPanel.loadHistory();
    return chatPanel;
  }
}","/** 
 * Creates a <tt>ChatPanel</tt> for the given contact and saves it in the list ot created <tt>ChatPanel</tt>s.
 * @param contact The MetaContact for this chat.
 * @param protocolContact The protocol contact.
 * @param the message ID of the message that should be excluded from thehistory when the last one is loaded in the chat.
 * @return The <code>ChatPanel</code> newly created.
 */
public ChatPanel createChat(MetaContact contact,Contact protocolContact,String escapedMessageID){
synchronized (syncChat) {
    ChatWindow chatWindow;
    if (Constants.TABBED_CHAT_WINDOW && this.chatWindow != null)     chatWindow=this.chatWindow;
 else {
      chatWindow=new ChatWindow(mainFrame);
      this.chatWindow=chatWindow;
    }
    ChatPanel chatPanel=new ChatPanel(chatWindow,contact,protocolContact);
synchronized (chats) {
      this.chats.put(contact,chatPanel);
    }
    chatPanel.loadHistory(escapedMessageID);
    return chatPanel;
  }
}",0.8532731376975169
104467,"/** 
 * Returns the chat panel corresponding to the given meta contact.
 * @param metaContact the meta contact.
 * @return the chat panel corresponding to the given meta contact
 */
public ChatPanel getContactChat(MetaContact metaContact){
synchronized (chats) {
    return (ChatPanel)chats.get(metaContact);
  }
}","/** 
 * Returns the chat panel corresponding to the given meta contact
 * @param metaContact the meta contact.
 * @return the chat panel corresponding to the given meta contact
 */
public ChatPanel getContactChat(MetaContact metaContact){
synchronized (chats) {
    return (ChatPanel)chats.get(metaContact);
  }
}",0.9984051036682616
104468,"/** 
 * When a right button click is performed in the editor pane, a popup menu is opened.
 * @param e The MouseEvent.
 */
public void mouseClicked(MouseEvent e){
  Point p=e.getPoint();
  SwingUtilities.convertPointToScreen(p,e.getComponent());
  if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0 || (e.isControlDown() && !e.isMetaDown())) {
    openContextMenu(p);
  }
 else   if ((e.getModifiers() & InputEvent.BUTTON1_MASK) != 0) {
    GuiActivator.getBrowserLauncher().openURL(currentHref);
  }
}","/** 
 * When a right button click is performed in the editor pane, a popup menu is opened.
 * @param e The MouseEvent.
 */
public void mouseClicked(MouseEvent e){
  Point p=e.getPoint();
  SwingUtilities.convertPointToScreen(p,e.getComponent());
  if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0 || (e.isControlDown() && !e.isMetaDown())) {
    openContextMenu(p);
  }
 else   if ((e.getModifiers() & InputEvent.BUTTON1_MASK) != 0 && currentHref != null && currentHref != ""String_Node_Str"") {
    GuiActivator.getBrowserLauncher().openURL(currentHref);
  }
}",0.9448082319925164
104469,"public void authorizationAccepted(Screenname screenname,String reason){
  logger.trace(""String_Node_Str"" + screenname);
  Contact srcContact=findContactByID(screenname.getFormatted());
  authorizationHandler.processAuthorizationResponse(new AuthorizationResponse(AuthorizationResponse.REJECT,reason),srcContact);
}","public void authorizationAccepted(Screenname screenname,String reason){
  logger.trace(""String_Node_Str"" + screenname);
  Contact srcContact=findContactByID(screenname.getFormatted());
  authorizationHandler.processAuthorizationResponse(new AuthorizationResponse(AuthorizationResponse.ACCEPT,reason),srcContact);
}",0.9872611464968152
104470,"/** 
 * Sets window size and position.
 */
private void setSizeAndLocation(){
  ConfigurationService configService=GuiActivator.getConfigurationService();
  String className=this.getClass().getName();
  String widthString=configService.getString(className + ""String_Node_Str"");
  String heightString=configService.getString(className + ""String_Node_Str"");
  String xString=configService.getString(className + ""String_Node_Str"");
  String yString=configService.getString(className + ""String_Node_Str"");
  int width=0;
  int height=0;
  if (widthString != null && heightString != null) {
    width=new Integer(width).intValue();
    height=new Integer(height).intValue();
    if (width > 0 && height > 0)     this.setSize(width,height);
  }
  if (xString != null && yString != null) {
    this.setLocation(new Integer(xString).intValue(),new Integer(yString).intValue());
  }
 else {
    this.setCenterLocation();
  }
}","/** 
 * Sets window size and position.
 */
private void setSizeAndLocation(){
  ConfigurationService configService=GuiActivator.getConfigurationService();
  String className=this.getClass().getName();
  String widthString=configService.getString(className + ""String_Node_Str"");
  String heightString=configService.getString(className + ""String_Node_Str"");
  String xString=configService.getString(className + ""String_Node_Str"");
  String yString=configService.getString(className + ""String_Node_Str"");
  int width=0;
  int height=0;
  if (widthString != null && heightString != null) {
    width=new Integer(widthString).intValue();
    height=new Integer(heightString).intValue();
    if (width > 0 && height > 0)     this.setSize(width,height);
  }
  if (xString != null && yString != null) {
    this.setLocation(new Integer(xString).intValue(),new Integer(yString).intValue());
  }
 else {
    this.setCenterLocation();
  }
}",0.9934994582881906
104471,"/** 
 * Sets window size and position.
 */
public void setSizeAndLocation(){
  ConfigurationService configService=GuiActivator.getConfigurationService();
  String className=this.getClass().getName();
  String widthString=configService.getString(className + ""String_Node_Str"");
  String heightString=configService.getString(className + ""String_Node_Str"");
  String xString=configService.getString(className + ""String_Node_Str"");
  String yString=configService.getString(className + ""String_Node_Str"");
  int width=0;
  int height=0;
  if (widthString != null && heightString != null) {
    width=new Integer(width).intValue();
    height=new Integer(height).intValue();
    if (width > 0 && height > 0)     this.setSize(width,height);
  }
  if (xString != null && yString != null) {
    this.setLocation(new Integer(xString).intValue(),new Integer(yString).intValue());
  }
 else {
    this.setCenterLocation();
  }
}","/** 
 * Sets window size and position.
 */
public void setSizeAndLocation(){
  ConfigurationService configService=GuiActivator.getConfigurationService();
  String className=this.getClass().getName();
  String widthString=configService.getString(className + ""String_Node_Str"");
  String heightString=configService.getString(className + ""String_Node_Str"");
  String xString=configService.getString(className + ""String_Node_Str"");
  String yString=configService.getString(className + ""String_Node_Str"");
  int width=0;
  int height=0;
  if (widthString != null && heightString != null) {
    width=new Integer(widthString).intValue();
    height=new Integer(heightString).intValue();
    if (width > 0 && height > 0)     this.setSize(width,height);
  }
  if (xString != null && yString != null) {
    this.setLocation(new Integer(xString).intValue(),new Integer(yString).intValue());
  }
 else {
    this.setCenterLocation();
  }
}",0.9934924078091106
104472,"/** 
 * Loads an image from a given image path.
 * @param imagePath The identifier of the image.
 * @return The image for the given identifier.
 */
public static byte[] loadIcon(String imagePath){
  InputStream is=JabberStatusEnum.class.getClassLoader().getResourceAsStream(imagePath);
  byte[] icon=null;
  try {
    icon=new byte[is.available()];
    is.read(icon);
  }
 catch (  IOException e) {
    logger.error(""String_Node_Str"" + imagePath,e);
  }
  return icon;
}","/** 
 * Loads an image from a given image path.
 * @param imagePath The identifier of the image.
 * @return The image for the given identifier.
 */
public static byte[] loadIcon(String imagePath){
  InputStream is=IcqStatusEnum.class.getClassLoader().getResourceAsStream(imagePath);
  byte[] icon=null;
  try {
    icon=new byte[is.available()];
    is.read(icon);
  }
 catch (  IOException e) {
    logger.error(""String_Node_Str"" + imagePath,e);
  }
  return icon;
}",0.9903948772678762
104473,"/** 
 * Retrieves (from the configuration service) preferences specified for various formats and assigns default ones to those that haven't been mentioned.
 */
private void initializeFormatPreferences(){
  setEncodingPreference(SdpConstants.H263,1000);
  setEncodingPreference(SdpConstants.JPEG,950);
  setEncodingPreference(SdpConstants.H261,800);
  setEncodingPreference(SdpConstants.GSM,500);
  setEncodingPreference(SdpConstants.PCMU,450);
  setEncodingPreference(SdpConstants.DVI4_8000,400);
  setEncodingPreference(SdpConstants.DVI4_16000,350);
  setEncodingPreference(SdpConstants.PCMA,300);
  setEncodingPreference(SdpConstants.G723,250);
  setEncodingPreference(SdpConstants.G728,200);
  ConfigurationService confService=MediaActivator.getConfigurationService();
  List sdpPreferences=confService.getPropertyNamesByPrefix(PROP_SDP_PREFERENCE,false);
  Iterator sdpPreferencesIter=sdpPreferences.iterator();
  while (sdpPreferencesIter.hasNext()) {
    String pName=(String)sdpPreferencesIter.next();
    String prefStr=confService.getString(pName);
    String fmtName=pName.substring(pName.lastIndexOf('.'));
    int preference=-1;
    int fmt=-1;
    try {
      preference=Integer.parseInt(prefStr);
      fmt=Integer.parseInt(fmtName);
    }
 catch (    NumberFormatException exc) {
      logger.warn(""String_Node_Str"" + fmtName + ""String_Node_Str""+ prefStr+ ""String_Node_Str"",exc);
      continue;
    }
    setEncodingPreference(fmt,preference);
    sortEncodingsArray(this.supportedAudioEncodings);
    sortEncodingsArray(this.supportedVideoEncodings);
  }
}","/** 
 * Retrieves (from the configuration service) preferences specified for various formats and assigns default ones to those that haven't been mentioned.
 */
private void initializeFormatPreferences(){
  setEncodingPreference(SdpConstants.H263,1000);
  setEncodingPreference(SdpConstants.JPEG,950);
  setEncodingPreference(SdpConstants.H261,800);
  setEncodingPreference(97,500);
  setEncodingPreference(SdpConstants.GSM,450);
  setEncodingPreference(SdpConstants.PCMU,400);
  setEncodingPreference(110,350);
  setEncodingPreference(SdpConstants.DVI4_8000,300);
  setEncodingPreference(SdpConstants.DVI4_16000,250);
  setEncodingPreference(SdpConstants.PCMA,200);
  setEncodingPreference(SdpConstants.G723,150);
  setEncodingPreference(SdpConstants.G728,100);
  ConfigurationService confService=MediaActivator.getConfigurationService();
  List sdpPreferences=confService.getPropertyNamesByPrefix(PROP_SDP_PREFERENCE,false);
  Iterator sdpPreferencesIter=sdpPreferences.iterator();
  while (sdpPreferencesIter.hasNext()) {
    String pName=(String)sdpPreferencesIter.next();
    String prefStr=confService.getString(pName);
    String fmtName=pName.substring(pName.lastIndexOf('.'));
    int preference=-1;
    int fmt=-1;
    try {
      preference=Integer.parseInt(prefStr);
      fmt=Integer.parseInt(fmtName);
    }
 catch (    NumberFormatException exc) {
      logger.warn(""String_Node_Str"" + fmtName + ""String_Node_Str""+ prefStr+ ""String_Node_Str"",exc);
      continue;
    }
    setEncodingPreference(fmt,preference);
    sortEncodingsArray(this.supportedAudioEncodings);
    sortEncodingsArray(this.supportedVideoEncodings);
  }
}",0.9754123871770932
104474,"/** 
 * Analyzes the incoming <tt>responseEvent</tt> and then forwards it to the proper event handler.
 * @param responseEvent the responseEvent that we receivedProtocolProviderService.
 */
public void processResponse(ResponseEvent responseEvent){
  ClientTransaction clientTransaction=responseEvent.getClientTransaction();
  Response response=responseEvent.getResponse();
  CSeqHeader cseq=((CSeqHeader)response.getHeader(CSeqHeader.NAME));
  if (cseq == null) {
    logger.error(""String_Node_Str"");
  }
  String method=cseq.getMethod();
  SipProvider sourceProvider=(SipProvider)responseEvent.getSource();
  if (response.getStatusCode() == Response.OK) {
    if (method.equals(Request.INVITE)) {
      processInviteOK(clientTransaction,response);
    }
 else     if (method.equals(Request.BYE)) {
    }
  }
 else   if (response.getStatusCode() == Response.RINGING) {
    processRinging(clientTransaction,response);
  }
 else   if (response.getStatusCode() == Response.TRYING) {
    processTrying(clientTransaction,response);
  }
 else   if (response.getStatusCode() == Response.BUSY_HERE) {
    processBusyHere(clientTransaction,response);
  }
 else   if (response.getStatusCode() == Response.UNAUTHORIZED || response.getStatusCode() == Response.PROXY_AUTHENTICATION_REQUIRED) {
    processAuthenticationChallenge(clientTransaction,response,sourceProvider);
  }
 else   if (response.getStatusCode() / 100 == 4) {
    CallParticipantSipImpl callParticipant=activeCallsRepository.findCallParticipant(clientTransaction.getDialog());
    logger.error(""String_Node_Str"" + response.getStatusCode() + ""String_Node_Str""+ response.getReasonPhrase());
    if (callParticipant != null)     callParticipant.setState(CallParticipantState.FAILED);
  }
}","/** 
 * Analyzes the incoming <tt>responseEvent</tt> and then forwards it to the proper event handler.
 * @param responseEvent the responseEvent that we receivedProtocolProviderService.
 */
public void processResponse(ResponseEvent responseEvent){
  ClientTransaction clientTransaction=responseEvent.getClientTransaction();
  Response response=responseEvent.getResponse();
  CSeqHeader cseq=((CSeqHeader)response.getHeader(CSeqHeader.NAME));
  if (cseq == null) {
    logger.error(""String_Node_Str"");
  }
  String method=cseq.getMethod();
  SipProvider sourceProvider=(SipProvider)responseEvent.getSource();
  if (response.getStatusCode() == Response.OK) {
    if (method.equals(Request.INVITE)) {
      processInviteOK(clientTransaction,response);
    }
 else     if (method.equals(Request.BYE)) {
    }
  }
 else   if (response.getStatusCode() == Response.RINGING) {
    processRinging(clientTransaction,response);
  }
 else   if (response.getStatusCode() == Response.TRYING) {
    processTrying(clientTransaction,response);
  }
 else   if (response.getStatusCode() == Response.BUSY_HERE) {
    processBusyHere(clientTransaction,response);
  }
 else   if (response.getStatusCode() == Response.UNAUTHORIZED || response.getStatusCode() == Response.PROXY_AUTHENTICATION_REQUIRED) {
    processAuthenticationChallenge(clientTransaction,response,sourceProvider);
  }
 else   if (response.getStatusCode() / 100 == 4 || response.getStatusCode() / 100 == 5) {
    CallParticipantSipImpl callParticipant=activeCallsRepository.findCallParticipant(clientTransaction.getDialog());
    logger.error(""String_Node_Str"" + response.getStatusCode() + ""String_Node_Str""+ response.getReasonPhrase());
    if (callParticipant != null)     callParticipant.setState(CallParticipantState.FAILED);
  }
}",0.988923601249645
104475,"/** 
 * This method parses an XML file, and returns a History object created with the information from it. The parsing is non-validating, so if a malformed XML is passed the results are undefined. The file should be with the following structure: <dbstruct version=""1.0""> <id value=""idcomponent1""> <id value=""idcomponent2""> <id value=""idcomponent3""/> </id> </id> <structure> <property name=""propertyName"" type=""textType"" /> <property name=""propertyName"" type=""textType"" /> <property name=""propertyName"" type=""textType"" /> </structure> </dbstruct>
 * @param dbDatFile The file to be parsed.
 * @return A History object corresponding to this dbstruct file.
 * @throws SAXException Thrown if an error occurs during XML parsing.
 * @throws IOException Thrown if an IO error occurs.
 * @throws ParseException Thrown if there is error in the XML data format.
 */
public History loadHistory(File dbDatFile) throws SAXException, IOException, ParseException {
  DocumentBuilder builder=historyService.getDocumentBuilder();
  Document doc=builder.parse(dbDatFile);
  Node root=doc.getFirstChild();
  HistoryID id=loadID(root);
  HistoryRecordStructure structure=loadStructure(root);
  return new HistoryImpl(id,dbDatFile.getParentFile(),structure,historyService);
}","/** 
 * This method parses an XML file, and returns a History object created with the information from it. The parsing is non-validating, so if a malformed XML is passed the results are undefined. The file should be with the following structure: <dbstruct version=""1.0""> <id value=""idcomponent1""> <id value=""idcomponent2""> <id value=""idcomponent3""/> </id> </id> <structure> <property name=""propertyName"" type=""textType"" /> <property name=""propertyName"" type=""textType"" /> <property name=""propertyName"" type=""textType"" /> </structure> </dbstruct>
 * @param dbDatFile The file to be parsed.
 * @return A History object corresponding to this dbstruct file.
 * @throws SAXException Thrown if an error occurs during XML parsing.
 * @throws IOException Thrown if an IO error occurs.
 * @throws ParseException Thrown if there is error in the XML data format.
 */
public History loadHistory(File dbDatFile) throws SAXException, IOException, ParseException {
  Document doc=historyService.parse(dbDatFile);
  Node root=doc.getFirstChild();
  HistoryID id=loadID(root);
  HistoryRecordStructure structure=loadStructure(root);
  return new HistoryImpl(id,dbDatFile.getParentFile(),structure,historyService);
}",0.9265905383360522
104476,"/** 
 * Checks whether the given xml is valid
 * @param str String
 * @return boolean
 */
private boolean isValidXML(String str){
  try {
    this.historyServiceImpl.getDocumentBuilder().parse(new ByteArrayInputStream(str.getBytes(""String_Node_Str"")));
  }
 catch (  Exception ex) {
    log.error(""String_Node_Str"" + str + ""String_Node_Str""+ ex.getMessage());
    return false;
  }
  return true;
}","/** 
 * Checks whether the given xml is valid
 * @param str String
 * @return boolean
 */
private boolean isValidXML(String str){
  try {
    this.historyServiceImpl.parse(new ByteArrayInputStream(str.getBytes(""String_Node_Str"")));
  }
 catch (  Exception ex) {
    log.error(""String_Node_Str"" + str + ""String_Node_Str""+ ex.getMessage());
    return false;
  }
  return true;
}",0.9729032258064516
104477,"/** 
 * Returns the fixed document as xml Document if file cannot be fixed return null
 * @param file File the file trying to fix
 * @return Document the fixed doc
 * @throws Exception
 */
public Document getFixedDocument(File file){
  log.info(""String_Node_Str"" + file);
  StringBuffer resultDocStr=new StringBuffer(""String_Node_Str"");
  try {
    BufferedReader inReader=new BufferedReader(new FileReader(file));
    String line=null;
    while ((line=inReader.readLine()) != null) {
      if (line.indexOf(""String_Node_Str"") == -1) {
        continue;
      }
      String record=getRecordNodeString(line,inReader).toString();
      if (record != null && isValidXML(record)) {
        resultDocStr.append(record);
      }
    }
  }
 catch (  Exception ex1) {
    log.error(""String_Node_Str"" + ex1.getLocalizedMessage());
  }
  resultDocStr.append(""String_Node_Str"");
  try {
    Document result=this.historyServiceImpl.getDocumentBuilder().parse(new ByteArrayInputStream(resultDocStr.toString().getBytes(""String_Node_Str"")));
    log.trace(""String_Node_Str"");
    XMLUtils.writeXML(result,file);
    return result;
  }
 catch (  Exception ex) {
    System.out.println(""String_Node_Str"" + ex.getMessage());
    return null;
  }
}","/** 
 * Returns the fixed document as xml Document if file cannot be fixed return null
 * @param file File the file trying to fix
 * @return Document the fixed doc
 * @throws Exception
 */
public Document getFixedDocument(File file){
  log.info(""String_Node_Str"" + file);
  StringBuffer resultDocStr=new StringBuffer(""String_Node_Str"");
  try {
    BufferedReader inReader=new BufferedReader(new FileReader(file));
    String line=null;
    while ((line=inReader.readLine()) != null) {
      if (line.indexOf(""String_Node_Str"") == -1) {
        continue;
      }
      String record=getRecordNodeString(line,inReader).toString();
      if (record != null && isValidXML(record)) {
        resultDocStr.append(record);
      }
    }
  }
 catch (  Exception ex1) {
    log.error(""String_Node_Str"" + ex1.getLocalizedMessage());
  }
  resultDocStr.append(""String_Node_Str"");
  try {
    Document result=this.historyServiceImpl.parse(new ByteArrayInputStream(resultDocStr.toString().getBytes(""String_Node_Str"")));
    log.trace(""String_Node_Str"");
    XMLUtils.writeXML(result,file);
    return result;
  }
 catch (  Exception ex) {
    System.out.println(""String_Node_Str"" + ex.getMessage());
    return null;
  }
}",0.991396968455551
104478,"protected Document getDocumentForFile(String filename) throws InvalidParameterException, RuntimeException {
  Document retVal=null;
synchronized (this.historyDocuments) {
    if (!this.historyDocuments.containsKey(filename)) {
      throw new InvalidParameterException(""String_Node_Str"" + ""String_Node_Str"");
    }
    Object obj=this.historyDocuments.get(filename);
    if (obj instanceof Document) {
      retVal=(Document)obj;
    }
 else     if (obj instanceof File) {
      File file=(File)obj;
      DocumentBuilder builder=this.historyServiceImpl.getDocumentBuilder();
      try {
        retVal=builder.parse(file);
      }
 catch (      Exception e) {
        log.error(""String_Node_Str"");
        retVal=getFixedDocument(file);
        if (retVal == null)         return null;
      }
      if (historyServiceImpl.isCacheEnabled())       this.historyDocuments.put(filename,retVal);
    }
 else {
    }
  }
  return retVal;
}","protected Document getDocumentForFile(String filename) throws InvalidParameterException, RuntimeException {
  Document retVal=null;
synchronized (this.historyDocuments) {
    if (!this.historyDocuments.containsKey(filename)) {
      throw new InvalidParameterException(""String_Node_Str"" + ""String_Node_Str"");
    }
    Object obj=this.historyDocuments.get(filename);
    if (obj instanceof Document) {
      retVal=(Document)obj;
    }
 else     if (obj instanceof File) {
      File file=(File)obj;
      try {
        retVal=this.historyServiceImpl.parse(file);
      }
 catch (      Exception e) {
        log.error(""String_Node_Str"");
        retVal=getFixedDocument(file);
        if (retVal == null)         return null;
      }
      if (historyServiceImpl.isCacheEnabled())       this.historyDocuments.put(filename,retVal);
    }
 else {
    }
  }
  return retVal;
}",0.9446902654867256
104479,"/** 
 * Writes the symbol corresponding to a choosen smiley icon to the write message area at the end of the current text.
 */
public void actionPerformed(ActionEvent e){
  JButton imageButton=(JButton)e.getSource();
  String buttonText=imageButton.getToolTipText();
  for (int i=0; i < this.imageList.size(); i++) {
    Smiley smiley=(Smiley)this.imageList.get(i);
    if (buttonText.equals(smiley.getSmileyStrings()[0])) {
      ChatPanel chatPanel=this.chatWindow.getCurrentChatPanel();
      chatPanel.addTextInWriteArea(smiley.getSmileyStrings()[0] + ""String_Node_Str"");
      chatPanel.requestFocusInWriteArea();
    }
  }
}","/** 
 * Writes the symbol corresponding to a choosen smiley icon to the write message area at the end of the current text.
 */
public void actionPerformed(ActionEvent e){
  JMenuItem smileyItem=(JMenuItem)e.getSource();
  String buttonText=smileyItem.getToolTipText();
  for (int i=0; i < this.imageList.size(); i++) {
    Smiley smiley=(Smiley)this.imageList.get(i);
    if (buttonText.equals(smiley.getSmileyStrings()[0])) {
      ChatPanel chatPanel=this.chatWindow.getCurrentChatPanel();
      chatPanel.addTextInWriteArea(smiley.getSmileyStrings()[0] + ""String_Node_Str"");
      chatPanel.requestFocusInWriteArea();
    }
  }
}",0.9429477020602218
104480,"/** 
 * Creates an instance of this <tt>SmiliesSelectorBox</tt> and initializes the panel with the smiley icons given by the incoming imageList.
 * @param imageList The pack of smiley icons.
 */
public SmiliesSelectorBox(ArrayList imageList,ChatWindow chatWindow){
  this.imageList=imageList;
  this.chatWindow=chatWindow;
  this.selectorBox.setUI(new SIPCommChatSelectorMenuUI());
  this.selectorBox.setPreferredSize(new Dimension(24,24));
  this.selectorBox.setBorder(BorderFactory.createEmptyBorder(0,0,0,0));
  this.selectorBox.setIcon(new ImageIcon(ImageLoader.getImage(ImageLoader.SMILIES_ICON)));
  this.calculateGridDimensions(imageList.size());
  this.selectorBox.getPopupMenu().setLayout(new GridLayout(this.gridRowCount,this.gridColCount,5,5));
  for (int i=0; i < imageList.size(); i++) {
    Smiley smiley=(Smiley)this.imageList.get(i);
    ChatToolbarButton imageButton=new ChatToolbarButton(ImageLoader.getImage(smiley.getImageID()));
    imageButton.setToolTipText(smiley.getSmileyStrings()[0]);
    imageButton.addActionListener(this);
    this.selectorBox.add(imageButton);
  }
  this.add(selectorBox);
}","/** 
 * Creates an instance of this <tt>SmiliesSelectorBox</tt> and initializes the panel with the smiley icons given by the incoming imageList.
 * @param imageList The pack of smiley icons.
 */
public SmiliesSelectorBox(ArrayList imageList,ChatWindow chatWindow){
  this.imageList=imageList;
  this.chatWindow=chatWindow;
  this.selectorBox.setUI(new SIPCommChatSelectorMenuUI());
  this.selectorBox.setPreferredSize(new Dimension(24,24));
  this.selectorBox.setBorder(BorderFactory.createEmptyBorder(0,0,0,0));
  this.selectorBox.setIcon(new ImageIcon(ImageLoader.getImage(ImageLoader.SMILIES_ICON)));
  this.calculateGridDimensions(imageList.size());
  this.selectorBox.getPopupMenu().setLayout(new GridLayout(this.gridRowCount,this.gridColCount,5,5));
  for (int i=0; i < imageList.size(); i++) {
    Smiley smiley=(Smiley)this.imageList.get(i);
    JMenuItem smileyItem=new JMenuItem(new ImageIcon(ImageLoader.getImage(smiley.getImageID())));
    smileyItem.setPreferredSize(new Dimension(28,28));
    smileyItem.setMargin(new Insets(2,-5,2,0));
    smileyItem.setToolTipText(smiley.getSmileyStrings()[0]);
    smileyItem.addActionListener(this);
    this.selectorBox.add(smileyItem);
  }
  this.add(selectorBox);
}",0.8240819812126388
104481,"/** 
 * The method is called by a ProtocolProvider implementation whenver a change in the registration state of the corresponding provider had occurred.
 * @param evt ProviderStatusChangeEvent the event describing the statuschange.
 */
public void registrationStateChanged(RegistrationStateChangeEvent evt){
  logger.debug(""String_Node_Str"" + evt.getOldState() + ""String_Node_Str""+ evt.getNewState());
  if (evt.getNewState() == RegistrationState.REGISTERED) {
    logger.debug(""String_Node_Str"");
    icqProvider.getAimConnection().getIcbmService().addIcbmListener(joustSimIcbmListener);
    opSetPersPresence=(OperationSetPersistentPresenceIcqImpl)icqProvider.getSupportedOperationSets().get(OperationSetPersistentPresence.class.getName());
    icqProvider.getAimConnection().getIcbmService().getOscarConnection().getSnacProcessor().getCmdFactoryMgr().getDefaultFactoryList().registerAll(channelFourCmdFactory);
    retreiveOfflineMessages();
    if (keepAliveSendTask == null) {
      keepAliveSendTask=new KeepAliveSendTask();
      keepAliveTimer.scheduleAtFixedRate(keepAliveSendTask,KEEPALIVE_INTERVAL,KEEPALIVE_INTERVAL);
    }
  }
}","/** 
 * The method is called by a ProtocolProvider implementation whenver a change in the registration state of the corresponding provider had occurred.
 * @param evt ProviderStatusChangeEvent the event describing the statuschange.
 */
public void registrationStateChanged(RegistrationStateChangeEvent evt){
  logger.debug(""String_Node_Str"" + evt.getOldState() + ""String_Node_Str""+ evt.getNewState());
  if (evt.getNewState() == RegistrationState.REGISTERED) {
    logger.debug(""String_Node_Str"");
    icqProvider.getAimConnection().getIcbmService().addIcbmListener(joustSimIcbmListener);
    opSetPersPresence=(OperationSetPersistentPresenceIcqImpl)icqProvider.getSupportedOperationSets().get(OperationSetPersistentPresence.class.getName());
    icqProvider.getAimConnection().getIcbmService().getOscarConnection().getSnacProcessor().getCmdFactoryMgr().getDefaultFactoryList().registerAll(channelFourCmdFactory);
    retreiveOfflineMessages();
    if (keepAliveSendTask == null) {
      keepAliveSendTask=new KeepAliveSendTask();
      keepAliveTimer=new Timer();
      keepAliveTimer.scheduleAtFixedRate(keepAliveSendTask,KEEPALIVE_INTERVAL,KEEPALIVE_INTERVAL);
    }
  }
 else   if (evt.getNewState() == RegistrationState.UNREGISTERED) {
    if (keepAliveSendTask != null) {
      keepAliveSendTask.cancel();
      keepAliveTimer.cancel();
      keepAliveSendTask=null;
      keepAliveTimer=null;
    }
  }
}",0.8942006269592476
104482,"/** 
 * Creates a RegistrationStateChange event corresponding to the specified old and new states and notifies all currently registered listeners.
 * @param oldState the state that the provider had before the changeoccurred
 * @param newState the state that the provider is currently in.
 * @param reasonCode a value corresponding to one of the REASON_XXX fieldsof the RegistrationStateChangeEvent class, indicating the reason for this state transition.
 * @param reason a String further explaining the reason code or null ifno such explanation is necessary.
 */
void fireRegistrationStateChanged(RegistrationState oldState,RegistrationState newState,int reasonCode,String reason){
  RegistrationStateChangeEvent event=new RegistrationStateChangeEvent(this,oldState,newState,reasonCode,reason);
  logger.debug(""String_Node_Str"" + event + ""String_Node_Str""+ registrationListeners.size()+ ""String_Node_Str"");
  Iterator listeners=null;
synchronized (registrationListeners) {
    listeners=new ArrayList(registrationListeners).iterator();
  }
  while (listeners.hasNext()) {
    RegistrationStateChangeListener listener=(RegistrationStateChangeListener)listeners.next();
    listener.registrationStateChanged(event);
  }
  logger.trace(""String_Node_Str"");
}","/** 
 * Creates a RegistrationStateChange event corresponding to the specified old and new states and notifies all currently registered listeners.
 * @param oldState the state that the provider had before the changeoccurred
 * @param newState the state that the provider is currently in.
 * @param reasonCode a value corresponding to one of the REASON_XXX fieldsof the RegistrationStateChangeEvent class, indicating the reason for this state transition.
 * @param reason a String further explaining the reason code or null ifno such explanation is necessary.
 */
void fireRegistrationStateChanged(RegistrationState oldState,RegistrationState newState,int reasonCode,String reason){
  RegistrationStateChangeEvent event=new RegistrationStateChangeEvent(this,oldState,newState,reasonCode,reason);
  if (newState.equals(RegistrationState.CONNECTION_FAILED) && isRegistered()) {
    unregister();
  }
  logger.debug(""String_Node_Str"" + event + ""String_Node_Str""+ registrationListeners.size()+ ""String_Node_Str"");
  Iterator listeners=null;
synchronized (registrationListeners) {
    listeners=new ArrayList(registrationListeners).iterator();
  }
  while (listeners.hasNext()) {
    RegistrationStateChangeListener listener=(RegistrationStateChangeListener)listeners.next();
    listener.registrationStateChanged(event);
  }
  logger.trace(""String_Node_Str"");
}",0.960919540229885
104483,"/** 
 * Shows the dialog.
 * @return The return code that should indicate what was the choice ofthe user. If the user chooses cancel, the return code is the  CANCEL_RETURN_CODE.
 */
public void showDialog(){
  setVisible(true);
}","/** 
 * Shows the dialog.
 * @return The return code that should indicate what was the choice ofthe user. If the user chooses cancel, the return code is the  CANCEL_RETURN_CODE.
 */
public void showDialog(){
  this.pack();
  this.setVisible(true);
}",0.899581589958159
104484,"/** 
 * When a message is received determines whether to open a new chat window or chat window tab, or to indicate that a message is received from a contact which already has an open chat. When the chat is found checks if in mode ""Auto popup enabled"" and if this is the case shows the message in the appropriate chat panel.
 * @param evt the event containing details on the received message
 */
public void messageReceived(MessageReceivedEvent evt){
  Contact protocolContact=evt.getSourceContact();
  Date date=evt.getTimestamp();
  Message message=evt.getSourceMessage();
  MetaContact metaContact=mainFrame.getContactList().findMetaContactByContact(protocolContact);
  PresenceStatus contactStatus=((ContactListModel)this.contactList.getModel()).getMetaContactStatus(metaContact);
  ChatWindow chatWindow;
  if (!Constants.TABBED_CHAT_WINDOW) {
    if (chatWindows.containsKey(metaContact)) {
      chatWindow=(ChatWindow)chatWindows.get(metaContact);
      chatWindow.getCurrentChatPanel().processMessage(protocolContact.getDisplayName(),date,Constants.INCOMING_MESSAGE,message.getContent());
      if (chatWindow.getState() == JFrame.ICONIFIED) {
        chatWindow.setTitle(""String_Node_Str"" + chatWindow.getTitle());
      }
      if (Constants.AUTO_POPUP_NEW_MESSAGE) {
        if (chatWindow.isVisible()) {
          if (chatWindow.getState() == JFrame.ICONIFIED)           chatWindow.setState(JFrame.NORMAL);
          chatWindow.toFront();
        }
 else         chatWindow.setVisible(true);
      }
    }
 else {
      ChatWindow msgWindow=new ChatWindow(mainFrame);
      chatWindows.put(metaContact,msgWindow);
      ChatPanel chatPanel=msgWindow.createChat(metaContact,contactStatus,protocolContact);
      chatPanel.loadHistory(message.getMessageUID());
      chatPanel.processMessage(protocolContact.getDisplayName(),date,Constants.INCOMING_MESSAGE,message.getContent());
      if (Constants.AUTO_POPUP_NEW_MESSAGE) {
        msgWindow.addChat(chatPanel);
        msgWindow.pack();
        msgWindow.setVisible(true);
        chatPanel.setCaretToEnd();
      }
    }
  }
 else {
    if (chatWindows.isEmpty()) {
      chatWindow=new ChatWindow(mainFrame);
    }
 else {
      chatWindow=(ChatWindow)chatWindows.elements().nextElement();
    }
    ChatPanel chatPanel;
    if (!chatWindow.containsContactChat(metaContact)) {
      chatPanel=chatWindow.createChat(metaContact,contactStatus,protocolContact);
      chatPanel.loadHistory(message.getMessageUID());
      chatPanel.processMessage(protocolContact.getDisplayName(),date,Constants.INCOMING_MESSAGE,message.getContent());
      if (Constants.AUTO_POPUP_NEW_MESSAGE) {
        chatWindow.addChatTab(chatPanel);
        if (chatWindow.isVisible()) {
          if (chatWindow.getState() == JFrame.ICONIFIED)           chatWindow.setState(JFrame.NORMAL);
          chatWindow.toFront();
        }
 else         chatWindow.setVisible(true);
        chatPanel.setCaretToEnd();
        chatWindow.getCurrentChatPanel().requestFocusInWriteArea();
        if (chatWindow.getTabCount() > 1) {
          chatWindow.highlightTab(metaContact);
        }
      }
    }
 else {
      chatPanel=chatWindow.getChatPanel(metaContact);
      chatPanel.processMessage(protocolContact.getDisplayName(),date,Constants.INCOMING_MESSAGE,message.getContent());
      if (chatWindow.getState() == JFrame.ICONIFIED) {
        if (chatWindow.getTabCount() > 1) {
          chatWindow.setSelectedContactTab(metaContact);
        }
        if (!chatWindow.getTitle().startsWith(""String_Node_Str"")) {
          chatWindow.setTitle(""String_Node_Str"" + chatWindow.getTitle());
        }
      }
 else {
        if (chatWindow.getTabCount() > 1) {
          chatWindow.highlightTab(metaContact);
        }
        if (chatWindow.isVisible())         chatWindow.toFront();
 else         chatWindow.setVisible(true);
      }
    }
  }
  if (Constants.AUTO_POPUP_NEW_MESSAGE)   Constants.getDefaultMessageAudio().play();
}","/** 
 * When a message is received determines whether to open a new chat window or chat window tab, or to indicate that a message is received from a contact which already has an open chat. When the chat is found checks if in mode ""Auto popup enabled"" and if this is the case shows the message in the appropriate chat panel.
 * @param evt the event containing details on the received message
 */
public void messageReceived(MessageReceivedEvent evt){
  Contact protocolContact=evt.getSourceContact();
  Date date=evt.getTimestamp();
  Message message=evt.getSourceMessage();
  MetaContact metaContact=mainFrame.getContactList().findMetaContactByContact(protocolContact);
  PresenceStatus contactStatus=((ContactListModel)this.contactList.getModel()).getMetaContactStatus(metaContact);
  ChatWindow chatWindow;
  if (!Constants.TABBED_CHAT_WINDOW) {
    if (chatWindows.containsKey(metaContact)) {
      chatWindow=(ChatWindow)chatWindows.get(metaContact);
      chatWindow.getCurrentChatPanel().processMessage(protocolContact.getDisplayName(),date,Constants.INCOMING_MESSAGE,message.getContent());
      if (chatWindow.getState() == JFrame.ICONIFIED) {
        chatWindow.setTitle(""String_Node_Str"" + chatWindow.getTitle());
      }
      if (Constants.AUTO_POPUP_NEW_MESSAGE) {
        if (chatWindow.isVisible()) {
          if (chatWindow.getState() == JFrame.ICONIFIED)           chatWindow.setState(JFrame.NORMAL);
          chatWindow.toFront();
        }
 else         chatWindow.setVisible(true);
      }
    }
 else {
      ChatWindow msgWindow=new ChatWindow(mainFrame);
      chatWindows.put(metaContact,msgWindow);
      ChatPanel chatPanel=msgWindow.createChat(metaContact,contactStatus,protocolContact);
      chatPanel.loadHistory(message.getMessageUID());
      chatPanel.processMessage(protocolContact.getDisplayName(),date,Constants.INCOMING_MESSAGE,message.getContent());
      if (Constants.AUTO_POPUP_NEW_MESSAGE) {
        msgWindow.addChat(chatPanel);
        msgWindow.pack();
        msgWindow.setVisible(true);
        chatPanel.setCaretToEnd();
      }
    }
  }
 else {
    if (chatWindows.isEmpty()) {
      chatWindow=new ChatWindow(mainFrame);
      chatWindows.put(metaContact,chatWindow);
    }
 else {
      chatWindow=(ChatWindow)chatWindows.elements().nextElement();
    }
    ChatPanel chatPanel;
    if (!chatWindow.containsContactChat(metaContact)) {
      chatPanel=chatWindow.createChat(metaContact,contactStatus,protocolContact);
      chatPanel.loadHistory(message.getMessageUID());
      chatPanel.processMessage(protocolContact.getDisplayName(),date,Constants.INCOMING_MESSAGE,message.getContent());
      if (Constants.AUTO_POPUP_NEW_MESSAGE) {
        chatWindow.addChatTab(chatPanel);
        if (chatWindow.isVisible()) {
          if (chatWindow.getState() == JFrame.ICONIFIED)           chatWindow.setState(JFrame.NORMAL);
          chatWindow.toFront();
        }
 else         chatWindow.setVisible(true);
        chatPanel.setCaretToEnd();
        chatWindow.getCurrentChatPanel().requestFocusInWriteArea();
        if (chatWindow.getTabCount() > 1) {
          chatWindow.highlightTab(metaContact);
        }
      }
    }
 else {
      chatPanel=chatWindow.getChatPanel(metaContact);
      chatPanel.processMessage(protocolContact.getDisplayName(),date,Constants.INCOMING_MESSAGE,message.getContent());
      if (chatWindow.getState() == JFrame.ICONIFIED) {
        if (chatWindow.getTabCount() > 1) {
          chatWindow.setSelectedContactTab(metaContact);
        }
        if (!chatWindow.getTitle().startsWith(""String_Node_Str"")) {
          chatWindow.setTitle(""String_Node_Str"" + chatWindow.getTitle());
        }
      }
 else {
        if (chatWindow.getTabCount() > 1) {
          chatWindow.highlightTab(metaContact);
        }
        if (chatWindow.isVisible())         chatWindow.toFront();
 else         chatWindow.setVisible(true);
      }
    }
  }
  if (Constants.AUTO_POPUP_NEW_MESSAGE)   Constants.getDefaultMessageAudio().play();
}",0.994100665244132
104485,"public CallComboBox(CallManager callManager){
  this.callManager=callManager;
  this.setUI(new SIPCommCallComboBoxUI());
  this.addActionListener(this);
  JTextField textField=(JTextField)this.getEditor().getEditorComponent();
  textField.addFocusListener(this);
  textField.getDocument().addDocumentListener(this);
  textField.getActionMap().put(""String_Node_Str"",new CreateCallAction());
  textField.getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER,0),""String_Node_Str"");
}","public CallComboBox(CallManager callManager){
  this.callManager=callManager;
  this.setUI(new SIPCommCallComboBoxUI());
  this.addActionListener(this);
  JTextField textField=(JTextField)this.getEditor().getEditorComponent();
  textField.getDocument().addDocumentListener(this);
  textField.getActionMap().put(""String_Node_Str"",new CreateCallAction());
  textField.getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER,0),""String_Node_Str"");
}",0.961456102783726
104486,"/** 
 * Enables or disabled the call button according to the content in the  combo box editor field.
 */
protected void handleChange(){
  String item=((CallComboEditor)this.getEditor()).getItem().toString();
  if (item.length() > 0) {
    callManager.setCallMetaContact(false);
    callManager.getCallButton().setEnabled(true);
  }
 else {
    Object o=callManager.getMainFrame().getContactListPanel().getContactList().getSelectedValue();
    if (o == null || !(o instanceof MetaContact))     callManager.getCallButton().setEnabled(false);
  }
}","/** 
 * Enables or disabled the call button according to the content in the  combo box editor field.
 */
protected void handleChange(){
  String item=((CallComboEditor)this.getEditor()).getItem().toString();
  if (item.length() > 0) {
    callManager.setCallMetaContact(false);
    ContactList clist=this.callManager.getMainFrame().getContactListPanel().getContactList();
    clist.removeSelectionInterval(clist.getSelectedIndex(),clist.getSelectedIndex());
    callManager.getCallButton().setEnabled(true);
  }
 else {
    Object o=callManager.getMainFrame().getContactListPanel().getContactList().getSelectedValue();
    if (o == null || !(o instanceof MetaContact))     callManager.getCallButton().setEnabled(false);
  }
}",0.8582677165354331
104487,"/** 
 * Sets the showOffline variable to indicate whether or not  offline contacts should be shown.
 * @param showOffline true if offline contacts should be shown, false otherwise.
 */
public void setShowOffline(boolean showOffline){
  this.showOffline=showOffline;
  this.contentChanged(0,getSize() - 1);
}","/** 
 * Sets the showOffline variable to indicate whether or not  offline contacts should be shown.
 * @param showOffline true if offline contacts should be shown, false otherwise.
 */
public void setShowOffline(boolean showOffline){
  int size=getSize();
  this.showOffline=showOffline;
  this.contentChanged(0,size - 1);
}",0.9540412044374008
104488,"public void run(){
  getChatWindow().setTitle(getMetaContact().getDisplayName());
  chatWindow.setCurrentChatPanel(ChatPanel.this);
  chatWindow.getMainToolBar().changeHistoryButtonsSate(ChatPanel.this);
  writeMessagePanel.getEditorPane().requestFocus();
}","public void run(){
  chatWindow.setCurrentChatPanel(ChatPanel.this);
  writeMessagePanel.getEditorPane().requestFocus();
}",0.6437994722955145
104489,"/** 
 * Loads history period dates for the current chat.
 */
private void loadHistoryPeriod(){
  MessageHistoryService msgHistory=GuiActivator.getMsgHistoryService();
  Collection firstMessage=msgHistory.findFirstMessagesAfter(metaContact,new Date(0),1);
  if (firstMessage.size() > 0) {
    Iterator i=firstMessage.iterator();
    Object o=i.next();
    if (o instanceof MessageDeliveredEvent) {
      MessageDeliveredEvent evt=(MessageDeliveredEvent)o;
      this.firstHistoryMsgTimestamp=evt.getTimestamp();
    }
 else     if (o instanceof MessageReceivedEvent) {
      MessageReceivedEvent evt=(MessageReceivedEvent)o;
      this.firstHistoryMsgTimestamp=evt.getTimestamp();
    }
    Collection lastMessage=msgHistory.findLastMessagesBefore(metaContact,new Date(Long.MAX_VALUE),1);
    Iterator i1=lastMessage.iterator();
    Object o1=i1.next();
    if (o1 instanceof MessageDeliveredEvent) {
      MessageDeliveredEvent evt=(MessageDeliveredEvent)o1;
      this.lastHistoryMsgTimestamp=evt.getTimestamp();
    }
 else     if (o1 instanceof MessageReceivedEvent) {
      MessageReceivedEvent evt=(MessageReceivedEvent)o1;
      this.lastHistoryMsgTimestamp=evt.getTimestamp();
    }
  }
}","/** 
 * Loads history period dates for the current chat.
 */
private void loadHistoryPeriod(){
  MessageHistoryService msgHistory=GuiActivator.getMsgHistoryService();
  Collection firstMessage=msgHistory.findFirstMessagesAfter(metaContact,new Date(0),1);
  if (firstMessage.size() > 0) {
    Iterator i=firstMessage.iterator();
    Object o=i.next();
    if (o instanceof MessageDeliveredEvent) {
      MessageDeliveredEvent evt=(MessageDeliveredEvent)o;
      this.firstHistoryMsgTimestamp=evt.getTimestamp();
    }
 else     if (o instanceof MessageReceivedEvent) {
      MessageReceivedEvent evt=(MessageReceivedEvent)o;
      this.firstHistoryMsgTimestamp=evt.getTimestamp();
    }
    Collection lastMessage=msgHistory.findLastMessagesBefore(metaContact,new Date(Long.MAX_VALUE),1);
    Iterator i1=lastMessage.iterator();
    Object o1=i1.next();
    if (o1 instanceof MessageDeliveredEvent) {
      MessageDeliveredEvent evt=(MessageDeliveredEvent)o1;
      this.lastHistoryMsgTimestamp=evt.getTimestamp();
    }
 else     if (o1 instanceof MessageReceivedEvent) {
      MessageReceivedEvent evt=(MessageReceivedEvent)o1;
      this.lastHistoryMsgTimestamp=evt.getTimestamp();
    }
  }
  this.chatWindow.getMainToolBar().changeHistoryButtonsState(this);
}",0.9723352318958502
104490,"public void componentShown(ComponentEvent e){
  Component component=e.getComponent();
  Container parent=component.getParent();
  if (parent instanceof JTabbedPane) {
    JTabbedPane tabbedPane=(JTabbedPane)parent;
    if (tabbedPane.getSelectedComponent() == component) {
      SwingUtilities.invokeLater(new Runnable(){
        public void run(){
          getChatWindow().setTitle(getMetaContact().getDisplayName());
          chatWindow.setCurrentChatPanel(ChatPanel.this);
          chatWindow.getMainToolBar().changeHistoryButtonsSate(ChatPanel.this);
          writeMessagePanel.getEditorPane().requestFocus();
        }
      }
);
    }
  }
}","public void componentShown(ComponentEvent e){
  Component component=e.getComponent();
  Container parent=component.getParent();
  if (parent instanceof JTabbedPane) {
    JTabbedPane tabbedPane=(JTabbedPane)parent;
    if (tabbedPane.getSelectedComponent() == component) {
      SwingUtilities.invokeLater(new Runnable(){
        public void run(){
          chatWindow.setCurrentChatPanel(ChatPanel.this);
          writeMessagePanel.getEditorPane().requestFocus();
        }
      }
);
    }
  }
}",0.7745865970409052
104491,"/** 
 * Sets the currently selected chat panel.
 * @param currentChatPanel The chat panel which is currently selected.
 */
public void setCurrentChatPanel(ChatPanel currentChatPanel){
  this.currentChatPanel=currentChatPanel;
}","/** 
 * Sets the currently selected chat panel.
 * @param currentChatPanel The chat panel which is currently selected.
 */
public void setCurrentChatPanel(ChatPanel currentChatPanel){
  this.currentChatPanel=currentChatPanel;
  this.setTitle(currentChatPanel.getMetaContact().getDisplayName());
  this.getMainToolBar().changeHistoryButtonsState(currentChatPanel);
}",0.7668918918918919
104492,"/** 
 * Creates an instance and constructs the <tt>MainToolBar</tt>.
 * @param messageWindow The parent <tt>ChatWindow</tt>.
 */
public MainToolBar(ChatWindow messageWindow){
  this.messageWindow=messageWindow;
  this.smiliesBox=new SmiliesSelectorBox(ImageLoader.getDefaultSmiliesPack(),messageWindow);
  this.setRollover(true);
  this.setLayout(new FlowLayout(FlowLayout.LEFT,3,0));
  this.setBorder(BorderFactory.createEmptyBorder(2,2,5,2));
  this.nextButton.setEnabled(false);
  this.add(saveButton);
  this.add(printButton);
  this.addSeparator();
  this.add(cutButton);
  this.add(copyButton);
  this.add(pasteButton);
  this.addSeparator();
  this.add(smiliesBox);
  this.addSeparator();
  this.add(previousButton);
  this.add(nextButton);
  this.addSeparator();
  this.add(sendFileButton);
  this.add(historyButton);
  this.addSeparator();
  this.add(fontButton);
  this.saveButton.setName(""String_Node_Str"");
  this.saveButton.setToolTipText(Messages.getString(""String_Node_Str"") + ""String_Node_Str"");
  this.printButton.setName(""String_Node_Str"");
  this.printButton.setToolTipText(Messages.getString(""String_Node_Str""));
  this.cutButton.setName(""String_Node_Str"");
  this.cutButton.setToolTipText(Messages.getString(""String_Node_Str"") + ""String_Node_Str"");
  this.copyButton.setName(""String_Node_Str"");
  this.copyButton.setToolTipText(Messages.getString(""String_Node_Str"") + ""String_Node_Str"");
  this.pasteButton.setName(""String_Node_Str"");
  this.pasteButton.setToolTipText(Messages.getString(""String_Node_Str"") + ""String_Node_Str"");
  this.smiliesBox.setName(""String_Node_Str"");
  this.smiliesBox.setToolTipText(Messages.getString(""String_Node_Str"") + ""String_Node_Str"");
  this.previousButton.setName(""String_Node_Str"");
  this.previousButton.setToolTipText(Messages.getString(""String_Node_Str""));
  this.nextButton.setName(""String_Node_Str"");
  this.nextButton.setToolTipText(Messages.getString(""String_Node_Str""));
  this.sendFileButton.setName(""String_Node_Str"");
  this.sendFileButton.setToolTipText(Messages.getString(""String_Node_Str""));
  this.historyButton.setName(""String_Node_Str"");
  this.historyButton.setToolTipText(Messages.getString(""String_Node_Str"") + ""String_Node_Str"");
  this.fontButton.setName(""String_Node_Str"");
  this.fontButton.setToolTipText(Messages.getString(""String_Node_Str""));
  this.saveButton.addActionListener(this);
  this.printButton.addActionListener(this);
  this.cutButton.addActionListener(this);
  this.copyButton.addActionListener(this);
  this.pasteButton.addActionListener(this);
  this.previousButton.addActionListener(this);
  this.nextButton.addActionListener(this);
  this.sendFileButton.addActionListener(this);
  this.historyButton.addActionListener(this);
  this.fontButton.addActionListener(this);
  this.saveButton.setEnabled(false);
  this.printButton.setEnabled(false);
  this.sendFileButton.setEnabled(false);
  this.fontButton.setEnabled(false);
}","/** 
 * Creates an instance and constructs the <tt>MainToolBar</tt>.
 * @param messageWindow The parent <tt>ChatWindow</tt>.
 */
public MainToolBar(ChatWindow messageWindow){
  this.messageWindow=messageWindow;
  this.smiliesBox=new SmiliesSelectorBox(ImageLoader.getDefaultSmiliesPack(),messageWindow);
  this.setRollover(true);
  this.setLayout(new FlowLayout(FlowLayout.LEFT,3,0));
  this.setBorder(BorderFactory.createEmptyBorder(2,2,5,2));
  this.nextButton.setEnabled(false);
  this.previousButton.setEnabled(false);
  this.add(saveButton);
  this.add(printButton);
  this.addSeparator();
  this.add(cutButton);
  this.add(copyButton);
  this.add(pasteButton);
  this.addSeparator();
  this.add(smiliesBox);
  this.addSeparator();
  this.add(previousButton);
  this.add(nextButton);
  this.addSeparator();
  this.add(sendFileButton);
  this.add(historyButton);
  this.addSeparator();
  this.add(fontButton);
  this.saveButton.setName(""String_Node_Str"");
  this.saveButton.setToolTipText(Messages.getString(""String_Node_Str"") + ""String_Node_Str"");
  this.printButton.setName(""String_Node_Str"");
  this.printButton.setToolTipText(Messages.getString(""String_Node_Str""));
  this.cutButton.setName(""String_Node_Str"");
  this.cutButton.setToolTipText(Messages.getString(""String_Node_Str"") + ""String_Node_Str"");
  this.copyButton.setName(""String_Node_Str"");
  this.copyButton.setToolTipText(Messages.getString(""String_Node_Str"") + ""String_Node_Str"");
  this.pasteButton.setName(""String_Node_Str"");
  this.pasteButton.setToolTipText(Messages.getString(""String_Node_Str"") + ""String_Node_Str"");
  this.smiliesBox.setName(""String_Node_Str"");
  this.smiliesBox.setToolTipText(Messages.getString(""String_Node_Str"") + ""String_Node_Str"");
  this.previousButton.setName(""String_Node_Str"");
  this.previousButton.setToolTipText(Messages.getString(""String_Node_Str""));
  this.nextButton.setName(""String_Node_Str"");
  this.nextButton.setToolTipText(Messages.getString(""String_Node_Str""));
  this.sendFileButton.setName(""String_Node_Str"");
  this.sendFileButton.setToolTipText(Messages.getString(""String_Node_Str""));
  this.historyButton.setName(""String_Node_Str"");
  this.historyButton.setToolTipText(Messages.getString(""String_Node_Str"") + ""String_Node_Str"");
  this.fontButton.setName(""String_Node_Str"");
  this.fontButton.setToolTipText(Messages.getString(""String_Node_Str""));
  this.saveButton.addActionListener(this);
  this.printButton.addActionListener(this);
  this.cutButton.addActionListener(this);
  this.copyButton.addActionListener(this);
  this.pasteButton.addActionListener(this);
  this.previousButton.addActionListener(this);
  this.nextButton.addActionListener(this);
  this.sendFileButton.addActionListener(this);
  this.historyButton.addActionListener(this);
  this.fontButton.addActionListener(this);
  this.saveButton.setEnabled(false);
  this.printButton.setEnabled(false);
  this.sendFileButton.setEnabled(false);
  this.fontButton.setEnabled(false);
}",0.99303313508921
104493,"public void run(){
  conversationPanel.clear();
  chatPanel.processHistory(msgHistory,""String_Node_Str"");
  conversationPanel.setDefaultContent();
  changeHistoryButtonsSate(chatPanel);
}","public void run(){
  conversationPanel.clear();
  chatPanel.processHistory(msgHistory,""String_Node_Str"");
  conversationPanel.setDefaultContent();
  changeHistoryButtonsState(chatPanel);
}",0.9973333333333332
104494,"public void run(){
  PresenceStatus contactStatus=((ContactListModel)contactList.getModel()).getMetaContactStatus(this.contactItem);
  if (!Constants.TABBED_CHAT_WINDOW) {
    if (contactMsgWindows.containsKey(this.contactItem)) {
      ChatWindow msgWindow=(ChatWindow)contactMsgWindows.get(this.contactItem);
      if (msgWindow.getExtendedState() == JFrame.ICONIFIED)       msgWindow.setExtendedState(JFrame.NORMAL);
      msgWindow.setVisible(true);
    }
 else {
      ChatWindow msgWindow=new ChatWindow(mainFrame);
      contactMsgWindows.put(this.contactItem,msgWindow);
      ChatPanel chatPanel=msgWindow.createChat(this.contactItem,contactStatus,protocolContact);
      chatPanel.loadHistory();
      msgWindow.addChat(chatPanel);
      msgWindow.pack();
      msgWindow.setVisible(true);
      msgWindow.getCurrentChatPanel().requestFocusInWriteArea();
    }
  }
 else {
    if (tabbedChatWindow == null) {
      tabbedChatWindow=new ChatWindow(mainFrame);
      tabbedChatWindow.addWindowListener(new WindowAdapter(){
        public void windowClosing(        WindowEvent e){
          tabbedChatWindow=null;
        }
      }
);
    }
    Hashtable contactTabsTable=tabbedChatWindow.getContactChatsTable();
    if (contactTabsTable.get(this.contactItem.getMetaUID()) == null) {
      ChatPanel chatPanel=tabbedChatWindow.createChat(this.contactItem,contactStatus,protocolContact);
      chatPanel.loadHistory();
      tabbedChatWindow.addChatTab(chatPanel);
      if (tabbedChatWindow.getTabCount() > 1) {
        tabbedChatWindow.setSelectedContactTab(this.contactItem);
      }
      if (tabbedChatWindow.getExtendedState() == JFrame.ICONIFIED)       tabbedChatWindow.setExtendedState(JFrame.NORMAL);
      tabbedChatWindow.setVisible(true);
      tabbedChatWindow.getCurrentChatPanel().requestFocusInWriteArea();
    }
 else {
      if (tabbedChatWindow.getTabCount() > 1) {
        tabbedChatWindow.setSelectedContactTab(this.contactItem);
      }
      if (tabbedChatWindow.getExtendedState() == JFrame.ICONIFIED)       tabbedChatWindow.setExtendedState(JFrame.NORMAL);
      tabbedChatWindow.setVisible(true);
      tabbedChatWindow.getCurrentChatPanel().requestFocusInWriteArea();
    }
  }
}","public void run(){
  PresenceStatus contactStatus=((ContactListModel)contactList.getModel()).getMetaContactStatus(this.contactItem);
  if (!Constants.TABBED_CHAT_WINDOW) {
    if (contactMsgWindows.containsKey(this.contactItem)) {
      ChatWindow msgWindow=(ChatWindow)contactMsgWindows.get(this.contactItem);
      if (msgWindow.isVisible())       msgWindow.toFront();
 else       msgWindow.setVisible(true);
    }
 else {
      ChatWindow msgWindow=new ChatWindow(mainFrame);
      contactMsgWindows.put(this.contactItem,msgWindow);
      ChatPanel chatPanel=msgWindow.createChat(this.contactItem,contactStatus,protocolContact);
      chatPanel.loadHistory();
      msgWindow.addChat(chatPanel);
      msgWindow.pack();
      msgWindow.setVisible(true);
      msgWindow.getCurrentChatPanel().requestFocusInWriteArea();
    }
  }
 else {
    if (tabbedChatWindow == null) {
      tabbedChatWindow=new ChatWindow(mainFrame);
      tabbedChatWindow.addWindowListener(new WindowAdapter(){
        public void windowClosing(        WindowEvent e){
          tabbedChatWindow=null;
        }
      }
);
    }
    Hashtable contactTabsTable=tabbedChatWindow.getContactChatsTable();
    if (contactTabsTable.get(this.contactItem.getMetaUID()) == null) {
      ChatPanel chatPanel=tabbedChatWindow.createChat(this.contactItem,contactStatus,protocolContact);
      chatPanel.loadHistory();
      tabbedChatWindow.addChatTab(chatPanel);
      if (tabbedChatWindow.getTabCount() > 1) {
        tabbedChatWindow.setSelectedContactTab(this.contactItem);
      }
      if (tabbedChatWindow.isVisible())       tabbedChatWindow.toFront();
 else       tabbedChatWindow.setVisible(true);
      tabbedChatWindow.getCurrentChatPanel().requestFocusInWriteArea();
    }
 else {
      if (tabbedChatWindow.getTabCount() > 1) {
        tabbedChatWindow.setSelectedContactTab(this.contactItem);
      }
      if (tabbedChatWindow.isVisible())       tabbedChatWindow.toFront();
 else       tabbedChatWindow.setVisible(true);
      tabbedChatWindow.getCurrentChatPanel().requestFocusInWriteArea();
    }
  }
}",0.7246916453339539
104495,"/** 
 * When a message is received determines whether to open a new chat window or chat window tab, or to indicate that a message is received from a contact which already has an open chat. When the chat is found checks if in mode ""Auto popup enabled"" and if this is the case shows the message in the appropriate chat panel.
 * @param evt the event containing details on the received message
 */
public void messageReceived(MessageReceivedEvent evt){
  Contact protocolContact=evt.getSourceContact();
  Date date=evt.getTimestamp();
  Message message=evt.getSourceMessage();
  MetaContact metaContact=mainFrame.getContactList().findMetaContactByContact(protocolContact);
  PresenceStatus contactStatus=((ContactListModel)this.contactList.getModel()).getMetaContactStatus(metaContact);
  if (!Constants.TABBED_CHAT_WINDOW) {
    if (contactMsgWindows.containsKey(metaContact)) {
      ChatWindow msgWindow=(ChatWindow)contactMsgWindows.get(metaContact);
      msgWindow.getCurrentChatPanel().processMessage(protocolContact.getDisplayName(),date,Constants.INCOMING_MESSAGE,message.getContent());
      if (msgWindow.getState() == JFrame.ICONIFIED) {
        msgWindow.setTitle(msgWindow.getTitle() + ""String_Node_Str"");
      }
      if (Constants.AUTO_POPUP_NEW_MESSAGE) {
        msgWindow.setVisible(true);
      }
    }
 else {
      ChatWindow msgWindow=new ChatWindow(mainFrame);
      contactMsgWindows.put(metaContact,msgWindow);
      ChatPanel chatPanel=msgWindow.createChat(metaContact,contactStatus,protocolContact);
      chatPanel.loadHistory(message.getMessageUID());
      chatPanel.processMessage(protocolContact.getDisplayName(),date,Constants.INCOMING_MESSAGE,message.getContent());
      if (Constants.AUTO_POPUP_NEW_MESSAGE) {
        msgWindow.addChat(chatPanel);
        msgWindow.pack();
        msgWindow.setVisible(true);
        chatPanel.setCaretToEnd();
      }
    }
  }
 else {
    if (tabbedChatWindow == null) {
      tabbedChatWindow=new ChatWindow(mainFrame);
      tabbedChatWindow.addWindowListener(new WindowAdapter(){
        public void windowClosing(        WindowEvent e){
          tabbedChatWindow=null;
        }
      }
);
    }
    Hashtable contactTabsTable=tabbedChatWindow.getContactChatsTable();
    ChatPanel chatPanel;
    if (contactTabsTable.get(metaContact.getMetaUID()) == null) {
      chatPanel=tabbedChatWindow.createChat(metaContact,contactStatus,protocolContact);
      chatPanel.loadHistory(message.getMessageUID());
      chatPanel.processMessage(protocolContact.getDisplayName(),date,Constants.INCOMING_MESSAGE,message.getContent());
      if (Constants.AUTO_POPUP_NEW_MESSAGE) {
        tabbedChatWindow.addChatTab(chatPanel);
        tabbedChatWindow.setVisible(true);
        chatPanel.setCaretToEnd();
        tabbedChatWindow.getCurrentChatPanel().requestFocusInWriteArea();
        if (tabbedChatWindow.getTabCount() > 1) {
          tabbedChatWindow.highlightTab(metaContact);
        }
      }
    }
 else {
      chatPanel=tabbedChatWindow.getChatPanel(metaContact);
      chatPanel.processMessage(protocolContact.getDisplayName(),date,Constants.INCOMING_MESSAGE,message.getContent());
      if (tabbedChatWindow.getState() == JFrame.ICONIFIED) {
        if (tabbedChatWindow.getTabCount() > 1) {
          tabbedChatWindow.setSelectedContactTab(metaContact);
        }
        if (!tabbedChatWindow.getTitle().endsWith(""String_Node_Str"")) {
          tabbedChatWindow.setTitle(tabbedChatWindow.getTitle() + ""String_Node_Str"");
        }
      }
 else {
        if (tabbedChatWindow.getTabCount() > 1) {
          tabbedChatWindow.highlightTab(metaContact);
        }
        tabbedChatWindow.setVisible(true);
      }
    }
  }
  if (Constants.AUTO_POPUP_NEW_MESSAGE)   Constants.getDefaultMessageAudio().play();
}","/** 
 * When a message is received determines whether to open a new chat window or chat window tab, or to indicate that a message is received from a contact which already has an open chat. When the chat is found checks if in mode ""Auto popup enabled"" and if this is the case shows the message in the appropriate chat panel.
 * @param evt the event containing details on the received message
 */
public void messageReceived(MessageReceivedEvent evt){
  Contact protocolContact=evt.getSourceContact();
  Date date=evt.getTimestamp();
  Message message=evt.getSourceMessage();
  MetaContact metaContact=mainFrame.getContactList().findMetaContactByContact(protocolContact);
  PresenceStatus contactStatus=((ContactListModel)this.contactList.getModel()).getMetaContactStatus(metaContact);
  if (!Constants.TABBED_CHAT_WINDOW) {
    if (contactMsgWindows.containsKey(metaContact)) {
      ChatWindow msgWindow=(ChatWindow)contactMsgWindows.get(metaContact);
      msgWindow.getCurrentChatPanel().processMessage(protocolContact.getDisplayName(),date,Constants.INCOMING_MESSAGE,message.getContent());
      if (msgWindow.getState() == JFrame.ICONIFIED) {
        msgWindow.setTitle(""String_Node_Str"" + msgWindow.getTitle());
      }
      if (Constants.AUTO_POPUP_NEW_MESSAGE) {
        if (msgWindow.isVisible())         msgWindow.toFront();
 else         msgWindow.setVisible(true);
      }
    }
 else {
      ChatWindow msgWindow=new ChatWindow(mainFrame);
      contactMsgWindows.put(metaContact,msgWindow);
      ChatPanel chatPanel=msgWindow.createChat(metaContact,contactStatus,protocolContact);
      chatPanel.loadHistory(message.getMessageUID());
      chatPanel.processMessage(protocolContact.getDisplayName(),date,Constants.INCOMING_MESSAGE,message.getContent());
      if (Constants.AUTO_POPUP_NEW_MESSAGE) {
        msgWindow.addChat(chatPanel);
        msgWindow.pack();
        msgWindow.setVisible(true);
        chatPanel.setCaretToEnd();
      }
    }
  }
 else {
    if (tabbedChatWindow == null) {
      tabbedChatWindow=new ChatWindow(mainFrame);
      tabbedChatWindow.addWindowListener(new WindowAdapter(){
        public void windowClosing(        WindowEvent e){
          tabbedChatWindow=null;
        }
      }
);
    }
    Hashtable contactTabsTable=tabbedChatWindow.getContactChatsTable();
    ChatPanel chatPanel;
    if (contactTabsTable.get(metaContact.getMetaUID()) == null) {
      chatPanel=tabbedChatWindow.createChat(metaContact,contactStatus,protocolContact);
      chatPanel.loadHistory(message.getMessageUID());
      chatPanel.processMessage(protocolContact.getDisplayName(),date,Constants.INCOMING_MESSAGE,message.getContent());
      if (Constants.AUTO_POPUP_NEW_MESSAGE) {
        tabbedChatWindow.addChatTab(chatPanel);
        if (tabbedChatWindow.isVisible())         tabbedChatWindow.toFront();
 else         tabbedChatWindow.setVisible(true);
        chatPanel.setCaretToEnd();
        tabbedChatWindow.getCurrentChatPanel().requestFocusInWriteArea();
        if (tabbedChatWindow.getTabCount() > 1) {
          tabbedChatWindow.highlightTab(metaContact);
        }
      }
    }
 else {
      chatPanel=tabbedChatWindow.getChatPanel(metaContact);
      chatPanel.processMessage(protocolContact.getDisplayName(),date,Constants.INCOMING_MESSAGE,message.getContent());
      if (tabbedChatWindow.getState() == JFrame.ICONIFIED) {
        if (tabbedChatWindow.getTabCount() > 1) {
          tabbedChatWindow.setSelectedContactTab(metaContact);
        }
        if (!tabbedChatWindow.getTitle().startsWith(""String_Node_Str"")) {
          tabbedChatWindow.setTitle(""String_Node_Str"" + tabbedChatWindow.getTitle());
        }
      }
 else {
        if (tabbedChatWindow.getTabCount() > 1) {
          tabbedChatWindow.highlightTab(metaContact);
        }
        if (tabbedChatWindow.isVisible())         tabbedChatWindow.toFront();
 else         tabbedChatWindow.setVisible(true);
      }
    }
  }
  if (Constants.AUTO_POPUP_NEW_MESSAGE)   Constants.getDefaultMessageAudio().play();
}",0.9549411162314388
104496,"/** 
 * Selects the contact tab given by <code>index</code>.
 * @param index The index of the tab to select.
 */
public void setSelectedContactTab(int index){
  ChatPanel chatPanel=(ChatPanel)this.chatTabbedPane.getComponentAt(index);
  this.setCurrentChatPanel(chatPanel);
  this.chatTabbedPane.setSelectedIndex(index);
  this.setTitle(chatPanel.getMetaContact().getDisplayName());
  this.setVisible(true);
  chatPanel.requestFocusInWriteArea();
}","/** 
 * Selects the contact tab given by <code>index</code>.
 * @param index The index of the tab to select.
 */
public void setSelectedContactTab(int index){
  ChatPanel chatPanel=(ChatPanel)this.chatTabbedPane.getComponentAt(index);
  this.setCurrentChatPanel(chatPanel);
  this.chatTabbedPane.setSelectedIndex(index);
  this.setTitle(chatPanel.getMetaContact().getDisplayName());
  chatPanel.requestFocusInWriteArea();
}",0.9712973593570609
104497,"public void windowDeiconified(WindowEvent e){
  String title=getTitle();
  if (title.endsWith(""String_Node_Str"")) {
    setTitle(title.substring(0,title.length() - 1));
  }
}","public void windowDeiconified(WindowEvent e){
  String title=getTitle();
  if (title.startsWith(""String_Node_Str"")) {
    setTitle(title.substring(1,title.length()));
  }
}",0.9595375722543352
104498,"public void contactPresenceStatusChanged(ContactPresenceStatusChangeEvent evt){
  ContactListPanel clistPanel=tabbedPane.getContactListPanel();
  Contact sourceContact=evt.getSourceContact();
  MetaContact metaContact=contactList.findMetaContactByContact(sourceContact);
  if (metaContact != null) {
    if (!evt.getOldStatus().equals(evt.getNewStatus())) {
      clistPanel.getContactList().refreshAll();
      clistPanel.updateChatContactStatus(metaContact,sourceContact);
    }
  }
}","public void contactPresenceStatusChanged(ContactPresenceStatusChangeEvent evt){
  ContactListPanel clistPanel=tabbedPane.getContactListPanel();
  Contact sourceContact=evt.getSourceContact();
  MetaContact metaContact=contactList.findMetaContactByContact(sourceContact);
  if (metaContact != null) {
    if (!evt.getOldStatus().equals(evt.getNewStatus())) {
      clistPanel.getContactList().modifyContact(metaContact);
      clistPanel.updateChatContactStatus(metaContact,sourceContact);
    }
  }
}",0.8255578093306288
104499,"/** 
 * Removes the given call panel tab.
 * @param callPanel the CallPanel to remove
 */
public void removeCallPanel(CallPanel callPanel){
  Timer timer=new Timer(5000,new RemoveCallPanelListener(callPanel));
  timer.setRepeats(false);
  timer.start();
}","/** 
 * Removes the given call panel tab.
 * @param callPanel the CallPanel to remove
 */
private void removeCallPanel(CallPanel callPanel){
  this.activeCalls.remove(callPanel.getCall());
  mainFrame.removeCallPanel(callPanel);
  updateButtonsStateAccordingToSelectedPanel();
}",0.3639774859287054
104500,"/** 
 * Implements CallListener.callEnded. Stops sounds that are playing at the moment if there're any. Removes the call panel and disables the hangup button.
 */
public void callEnded(CallEvent event){
  SoundLoader.getSound(SoundLoader.BUSY).stop();
  SoundLoader.stop(Constants.getDefaultIncomingCallAudio());
  Call sourceCall=event.getSourceCall();
  if (activeCalls.get(sourceCall) != null) {
    CallPanel callPanel=(CallPanel)activeCalls.get(sourceCall);
    this.removeCallPanel(callPanel);
  }
}","/** 
 * Implements CallListener.callEnded. Stops sounds that are playing at the moment if there're any. Removes the call panel and disables the hangup button.
 */
public void callEnded(CallEvent event){
  SoundLoader.getSound(SoundLoader.BUSY).stop();
  SoundLoader.stop(Constants.getDefaultIncomingCallAudio());
  Call sourceCall=event.getSourceCall();
  if (activeCalls.get(sourceCall) != null) {
    CallPanel callPanel=(CallPanel)activeCalls.get(sourceCall);
    this.removeCallPanelWait(callPanel);
  }
}",0.9960552268244576
104501,"public void actionPerformed(ActionEvent e){
  activeCalls.remove(callPanel.getCall());
  mainFrame.removeCallPanel(callPanel);
  updateButtonsStateAccordingToSelectedPanel();
}","public void actionPerformed(ActionEvent e){
  removeCallPanel(callPanel);
}",0.5976095617529881
104502,"/** 
 * Implements the CallChangeListener.callParticipantRemoved method. When a call participant is removed from our call remove it from the call panel.
 */
public void callParticipantRemoved(CallParticipantEvent evt){
  if (evt.getSourceCall() == call) {
    CallParticipant participant=evt.getSourceCallParticipant();
    CallParticipantPanel participantPanel=(CallParticipantPanel)participantsPanels.get(participant);
    if (participantPanel != null) {
      CallParticipantState state=participant.getState();
      participantPanel.setState(state.getStateString());
      participantPanel.stopCallTimer();
      GuiCallParticipantRecord participantRecord=new GuiCallParticipantRecord(participantPanel.getName(),participantPanel.getCallType(),participantPanel.getStartTime(),participantPanel.getEndTime());
      callManager.getMainFrame().getCallList().addItem(participantRecord,1);
      this.participantsPanels.remove(participant);
      if (participantsPanels.size() != 0) {
        Timer timer=new Timer(5000,new RemoveParticipantPanelListener(participantPanel));
        timer.setRepeats(false);
        timer.start();
      }
      this.revalidate();
      this.repaint();
    }
  }
}","/** 
 * Implements the CallChangeListener.callParticipantRemoved method. When a call participant is removed from our call remove it from the call panel.
 */
public void callParticipantRemoved(CallParticipantEvent evt){
  if (evt.getSourceCall() == call) {
    CallParticipant participant=evt.getSourceCallParticipant();
    CallParticipantPanel participantPanel=(CallParticipantPanel)participantsPanels.get(participant);
    if (participantPanel != null) {
      CallParticipantState state=participant.getState();
      participantPanel.setState(state.getStateString());
      participantPanel.stopCallTimer();
      GuiCallParticipantRecord participantRecord=new GuiCallParticipantRecord(participantPanel.getParticipantName(),participantPanel.getCallType(),participantPanel.getStartTime(),participantPanel.getEndTime());
      callManager.getMainFrame().getCallListManager().addCallRecord(1,participantRecord);
      this.participantsPanels.remove(participant);
      if (participantsPanels.size() != 0) {
        Timer timer=new Timer(5000,new RemoveParticipantPanelListener(participantPanel));
        timer.setRepeats(false);
        timer.start();
      }
      this.revalidate();
      this.repaint();
    }
  }
}",0.9710024855012428
104503,"/** 
 * Creates a <tt>CallParticipantPanel</tt> for the given call participant.
 * @param participant the call participant
 * @param callType the call type. INCOMING_CALL or OUTGOING_CALL
 */
public CallParticipantPanel(CallParticipant participant){
  super(new BorderLayout());
  this.stateLabel=new JLabel(participant.getState().getStateString(),JLabel.CENTER);
  this.startDate=new Date(System.currentTimeMillis());
  this.timer=new Timer(1000,new CallTimerListener());
  this.timer.setRepeats(true);
  if (participant.getDisplayName() != null)   nameLabel.setText(participant.getDisplayName());
 else   nameLabel.setText(participant.getAddress());
  namePanel.add(nameLabel);
  namePanel.add(stateLabel);
  namePanel.add(timeLabel);
  contactPanel.add(photoLabel,BorderLayout.CENTER);
  contactPanel.add(namePanel,BorderLayout.SOUTH);
  this.add(contactPanel,BorderLayout.NORTH);
  this.setPreferredSize(new Dimension(100,200));
}","/** 
 * Creates a <tt>CallParticipantPanel</tt> for the given call participant.
 * @param participant the call participant
 * @param callType the call type. INCOMING_CALL or OUTGOING_CALL
 */
public CallParticipantPanel(CallParticipant participant){
  super(new BorderLayout());
  this.stateLabel=new JLabel(participant.getState().getStateString(),JLabel.CENTER);
  this.startDate=new Date(System.currentTimeMillis());
  this.timer=new Timer(1000,new CallTimerListener());
  this.timer.setRepeats(true);
  if (participant.getDisplayName() != null)   participantName=participant.getDisplayName();
 else   participantName=participant.getAddress();
  this.nameLabel.setText(participantName);
  namePanel.add(nameLabel);
  namePanel.add(stateLabel);
  namePanel.add(timeLabel);
  contactPanel.add(photoLabel,BorderLayout.CENTER);
  contactPanel.add(namePanel,BorderLayout.SOUTH);
  this.add(contactPanel,BorderLayout.NORTH);
  this.setPreferredSize(new Dimension(100,200));
}",0.9070866141732284
104504,"/** 
 * Connects and logins again to the server
 */
void reregister(){
  try {
    logger.trace(""String_Node_Str"");
    this.unregister(false);
    connectAndLogin(authority);
  }
 catch (  OperationFailedException ex) {
    logger.error(""String_Node_Str"",ex);
    fireRegistrationStateChanged(getRegistrationState(),RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_INTERNAL_ERROR,null);
  }
catch (  XMPPException ex) {
    logger.error(""String_Node_Str"",ex);
    int reason=RegistrationStateChangeEvent.REASON_NOT_SPECIFIED;
    if (ex.getWrappedThrowable() instanceof UnknownHostException)     reason=RegistrationStateChangeEvent.REASON_SERVER_NOT_FOUND;
    fireRegistrationStateChanged(getRegistrationState(),RegistrationState.CONNECTION_FAILED,reason,null);
  }
}","/** 
 * Connects and logins again to the server
 */
void reregister(){
  try {
    logger.trace(""String_Node_Str"");
    this.unregister(false);
    this.reconnecting=true;
    connectAndLogin(authority);
  }
 catch (  OperationFailedException ex) {
    logger.error(""String_Node_Str"",ex);
    fireRegistrationStateChanged(getRegistrationState(),RegistrationState.CONNECTION_FAILED,RegistrationStateChangeEvent.REASON_INTERNAL_ERROR,null);
  }
catch (  XMPPException ex) {
    logger.error(""String_Node_Str"",ex);
    int reason=RegistrationStateChangeEvent.REASON_NOT_SPECIFIED;
    if (ex.getWrappedThrowable() instanceof UnknownHostException)     reason=RegistrationStateChangeEvent.REASON_SERVER_NOT_FOUND;
    fireRegistrationStateChanged(getRegistrationState(),RegistrationState.CONNECTION_FAILED,reason,null);
  }
}",0.9826302729528535
104505,"public void connectionClosedOnError(Exception exception){
  logger.error(""String_Node_Str"" + exception.getLocalizedMessage());
  reregister();
}","public void connectionClosedOnError(Exception exception){
  logger.error(""String_Node_Str"" + exception.getLocalizedMessage());
  if (!reconnecting)   reregister();
 else   reconnecting=false;
}",0.8545994065281899
104506,"/** 
 * Connects and logins to the server
 * @param authority SecurityAuthority
 * @throws XMPPException if we cannot connect to the server - network problem
 * @throws OperationFailedException if login parametersas server port are not correct
 */
private void connectAndLogin(SecurityAuthority authority) throws XMPPException, OperationFailedException {
synchronized (initializationLock) {
    String password=JabberActivator.getProtocolProviderFactory().loadPassword(getAccountID());
    if (password == null) {
      UserCredentials credentials=new UserCredentials();
      credentials.setUserName(getAccountID().getUserID());
      credentials=authority.obtainCredentials(ProtocolNames.JABBER,credentials);
      char[] pass=credentials.getPassword();
      if (pass == null) {
        fireRegistrationStateChanged(getRegistrationState(),RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_USER_REQUEST,""String_Node_Str"");
        return;
      }
      password=new String(pass);
      if (credentials.isPasswordPersistent()) {
        JabberActivator.getProtocolProviderFactory().storePassword(getAccountID(),password);
      }
    }
    try {
      String userID=StringUtils.parseName(getAccountID().getUserID());
      String serviceName=StringUtils.parseServer(getAccountID().getUserID());
      String serverAddress=(String)getAccountID().getAccountProperties().get(ProtocolProviderFactory.SERVER_ADDRESS);
      String serverPort=(String)getAccountID().getAccountProperties().get(ProtocolProviderFactory.SERVER_PORT);
      try {
        String hosts[]=NetworkUtils.getSRVRecords(""String_Node_Str"" + serviceName);
        if (hosts != null && hosts.length > 0) {
          logger.trace(""String_Node_Str"" + hosts[0]);
          serverAddress=hosts[0];
        }
      }
 catch (      NamingException ex1) {
        logger.error(""String_Node_Str"" + ex1.getMessage());
      }
      Roster.setDefaultSubscriptionMode(Roster.SUBSCRIPTION_MANUAL);
      connection=new XMPPConnection(serverAddress,Integer.parseInt(serverPort),serviceName);
      connection.addConnectionListener(new JabberConnectionListener());
      connection.login(userID,password,""String_Node_Str"");
      if (connection.isAuthenticated()) {
        connection.getRoster().setSubscriptionMode(Roster.SUBSCRIPTION_MANUAL);
        fireRegistrationStateChanged(getRegistrationState(),RegistrationState.REGISTERED,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
      }
    }
 catch (    NumberFormatException ex) {
      throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INVALID_ACCOUNT_PROPERTIES,ex);
    }
  }
}","/** 
 * Connects and logins to the server
 * @param authority SecurityAuthority
 * @throws XMPPException if we cannot connect to the server - network problem
 * @throws OperationFailedException if login parametersas server port are not correct
 */
private void connectAndLogin(SecurityAuthority authority) throws XMPPException, OperationFailedException {
synchronized (initializationLock) {
    String password=JabberActivator.getProtocolProviderFactory().loadPassword(getAccountID());
    if (password == null) {
      UserCredentials credentials=new UserCredentials();
      credentials.setUserName(getAccountID().getUserID());
      credentials=authority.obtainCredentials(ProtocolNames.JABBER,credentials);
      char[] pass=credentials.getPassword();
      if (pass == null) {
        fireRegistrationStateChanged(getRegistrationState(),RegistrationState.UNREGISTERED,RegistrationStateChangeEvent.REASON_USER_REQUEST,""String_Node_Str"");
        return;
      }
      password=new String(pass);
      if (credentials.isPasswordPersistent()) {
        JabberActivator.getProtocolProviderFactory().storePassword(getAccountID(),password);
      }
    }
    try {
      String userID=StringUtils.parseName(getAccountID().getUserID());
      String serviceName=StringUtils.parseServer(getAccountID().getUserID());
      String serverAddress=(String)getAccountID().getAccountProperties().get(ProtocolProviderFactory.SERVER_ADDRESS);
      String serverPort=(String)getAccountID().getAccountProperties().get(ProtocolProviderFactory.SERVER_PORT);
      try {
        String hosts[]=NetworkUtils.getSRVRecords(""String_Node_Str"" + serviceName);
        if (hosts != null && hosts.length > 0) {
          logger.trace(""String_Node_Str"" + hosts[0]);
          serverAddress=hosts[0];
        }
      }
 catch (      NamingException ex1) {
        logger.error(""String_Node_Str"" + ex1.getMessage());
      }
      Roster.setDefaultSubscriptionMode(Roster.SUBSCRIPTION_MANUAL);
      connection=new XMPPConnection(serverAddress,Integer.parseInt(serverPort),serviceName);
      connection.addConnectionListener(new JabberConnectionListener());
      connection.login(userID,password,""String_Node_Str"");
      if (connection.isAuthenticated()) {
        this.reconnecting=false;
        connection.getRoster().setSubscriptionMode(Roster.SUBSCRIPTION_MANUAL);
        fireRegistrationStateChanged(getRegistrationState(),RegistrationState.REGISTERED,RegistrationStateChangeEvent.REASON_NOT_SPECIFIED,null);
      }
    }
 catch (    NumberFormatException ex) {
      throw new OperationFailedException(""String_Node_Str"",OperationFailedException.INVALID_ACCOUNT_PROPERTIES,ex);
    }
  }
}",0.99379115710254
104507,"/** 
 * Convienence method that displays a modal wizard dialog and blocks until the dialog has completed.
 * @return Indicates how the dialog was closed. Compare this value againstthe RETURN_CODE constants at the beginning of the class.
 */
public int showDialog(boolean modal){
  if (modal)   wizardDialog.setModal(true);
  wizardDialog.pack();
  wizardDialog.setVisible(true);
  return returnCode;
}","/** 
 * Convienence method that displays a modal wizard dialog and blocks until the dialog has completed.
 * @return Indicates how the dialog was closed. Compare this value againstthe RETURN_CODE constants at the beginning of the class.
 */
public void showDialog(boolean modal){
  if (modal)   wizardDialog.setModal(true);
  wizardDialog.pack();
  wizardDialog.setVisible(true);
}",0.9641943734015346
104508,"/** 
 * If the user presses the close box on the dialog's window, treat it as a cancel.
 * @param e The event passed in from AWT.
 */
public void windowClosing(WindowEvent e){
  returnCode=CANCEL_RETURN_CODE;
}","/** 
 * If the user presses the close box on the dialog's window, treat it as a cancel.
 * @param e The event passed in from AWT.
 */
public void windowClosing(WindowEvent e){
  fireWizardEvent(WizardEvent.CANCEL);
}",0.8779342723004695
104509,"/** 
 * Closes the dialog and sets the return code to the integer parameter.
 * @param code The return code.
 */
void close(int code){
  WizardPage oldPanelDescriptor=wizardModel.getCurrentWizardPage();
  if (oldPanelDescriptor != null)   oldPanelDescriptor.pageHiding();
  if (this.containsPage(WizardPage.DEFAULT_PAGE_IDENTIFIER)) {
    this.unregisterWizardPage(WizardPage.DEFAULT_PAGE_IDENTIFIER);
  }
  if (this.containsPage(WizardPage.SUMMARY_PAGE_IDENTIFIER)) {
    this.unregisterWizardPage(WizardPage.SUMMARY_PAGE_IDENTIFIER);
  }
  this.removeWizzardIcon();
  returnCode=code;
  wizardDialog.dispose();
}","/** 
 * Closes the dialog and sets the return code to the integer parameter.
 * @param code The return code.
 */
void close(int code){
  WizardPage oldPanelDescriptor=wizardModel.getCurrentWizardPage();
  if (oldPanelDescriptor != null)   oldPanelDescriptor.pageHiding();
  if (this.containsPage(WizardPage.DEFAULT_PAGE_IDENTIFIER)) {
    this.unregisterWizardPage(WizardPage.DEFAULT_PAGE_IDENTIFIER);
  }
  if (this.containsPage(WizardPage.SUMMARY_PAGE_IDENTIFIER)) {
    this.unregisterWizardPage(WizardPage.SUMMARY_PAGE_IDENTIFIER);
  }
  this.removeWizzardIcon();
  this.fireWizardEvent(WizardEvent.SUCCESS);
  wizardDialog.dispose();
}",0.9569377990430622
104510,"/** 
 * Handles the <tt>MetaContactGroupEvent</tt>. Refreshes the list model when the contact list groups has been reordered. Moves the selection index to the index of the contact that was selected before the reordered event. This way the selection depends on the contact and not on the index.
 */
public void childContactsReordered(MetaContactGroupEvent evt){
  this.refresh();
  if (currentlySelectedContact != null)   this.setSelectedValue(currentlySelectedContact,false);
}","/** 
 * Handles the <tt>MetaContactGroupEvent</tt>. Refreshes the list model when the contact list groups has been reordered. Moves the selection index to the index of the contact that was selected before the reordered event. This way the selection depends on the contact and not on the index.
 */
public void childContactsReordered(MetaContactGroupEvent evt){
  if (currentlySelectedContact != null)   this.setSelectedValue(currentlySelectedContact,false);
  this.refresh();
}",0.7966457023060797
104511,"public void contactPresenceStatusChanged(ContactPresenceStatusChangeEvent evt){
  ContactListPanel clistPanel=tabbedPane.getContactListPanel();
  clistPanel.getContactList().refresh();
  Contact sourceContact=evt.getSourceContact();
  MetaContact metaContact=contactList.findMetaContactByContact(sourceContact);
  if (metaContact != null) {
    if (!evt.getOldStatus().equals(evt.getNewStatus()))     clistPanel.updateChatContactStatus(metaContact,sourceContact);
  }
}","public void contactPresenceStatusChanged(ContactPresenceStatusChangeEvent evt){
  ContactListPanel clistPanel=tabbedPane.getContactListPanel();
  Contact sourceContact=evt.getSourceContact();
  MetaContact metaContact=contactList.findMetaContactByContact(sourceContact);
  if (metaContact != null) {
    if (!evt.getOldStatus().equals(evt.getNewStatus()))     clistPanel.updateChatContactStatus(metaContact,sourceContact);
  }
}",0.9542920847268672
104512,"/** 
 * Handles the <tt>MetaContactGroupEvent</tt>. Refreshes the list model when a new meta contact group has been added.
 */
public void metaContactGroupAdded(MetaContactGroupEvent evt){
  this.refresh();
}","/** 
 * Handles the <tt>MetaContactGroupEvent</tt>. Refreshes the list model when a new meta contact group has been added.
 */
public void metaContactGroupAdded(MetaContactGroupEvent evt){
  this.refreshAll();
}",0.9928400954653938
104513,"/** 
 * Handles the <tt>ProtoContactEvent</tt>. Refreshes the list when a protocol contact has been added.
 */
public void protoContactAdded(ProtoContactEvent evt){
  int index=this.listModel.indexOf(evt.getNewParent());
  this.listModel.contentChanged(index,index);
}","/** 
 * Handles the <tt>ProtoContactEvent</tt>. Refreshes the list when a protocol contact has been added.
 */
public void protoContactAdded(ProtoContactEvent evt){
  this.refreshAll();
}",0.7868131868131868
104514,"/** 
 * Handles the <tt>MetaContactEvent</tt>. Refreshes the list when a meta contact has been removed.
 */
public void metaContactRemoved(MetaContactEvent evt){
  this.refresh();
}","/** 
 * Handles the <tt>MetaContactEvent</tt>. Refreshes the list when a meta contact has been removed.
 */
public void metaContactRemoved(MetaContactEvent evt){
  this.refreshAll();
}",0.9917808219178084
104515,"public void run(){
  ContactInfoPanel contactInfoPanel=new ContactInfoPanel(mainFrame,contactItem);
  SwingUtilities.convertPointToScreen(p,ContactList.this);
  contactInfoPanel.setPopupLocation(p.x - 140,p.y - 15);
  contactInfoPanel.setVisible(true);
  contactInfoPanel.requestFocusInWindow();
}","public void run(){
  while (refreshEnabled) {
synchronized (refreshLock) {
      if (isModified) {
        try {
          refreshLock.wait(5000);
        }
 catch (        InterruptedException e) {
          logger.error(""String_Node_Str"",e);
        }
      }
    }
    if (isModified) {
      if (groupsToModify.size() > 0) {
        for (int i=0; i < groupsToModify.size(); i++) {
          MetaContactGroup group=(MetaContactGroup)groupsToModify.get(i);
          this.refreshGroup(group);
        }
        groupsToModify.removeAllElements();
      }
 else {
        this.refreshAll();
      }
      isModified=false;
    }
  }
}",0.0836909871244635
104516,"/** 
 * Handles the <tt>MetaContactMovedEvent</tt>. Refreshes the list when a meta contact has been moved.
 */
public void metaContactMoved(MetaContactMovedEvent evt){
  this.refresh();
}","/** 
 * Handles the <tt>MetaContactMovedEvent</tt>. Refreshes the list when a meta contact has been moved.
 */
public void metaContactMoved(MetaContactMovedEvent evt){
  this.refreshAll();
}",0.9920424403183024
104517,"/** 
 * Handles the <tt>MetaContactGroupEvent</tt>. Refreshes the list model when the contact list groups has been reordered. Moves the selection index to the index of the contact that was selected before the reordered event. This way the selection depends on the contact and not on the index.
 */
public void childContactsReordered(MetaContactGroupEvent evt){
  if (currentlySelectedContact != null)   this.setSelectedValue(currentlySelectedContact,false);
  this.refresh();
}","/** 
 * Handles the <tt>MetaContactGroupEvent</tt>. Refreshes the list model when the contact list groups has been reordered. Moves the selection index to the index of the contact that was selected before the reordered event. This way the selection depends on the contact and not on the index.
 */
public void childContactsReordered(MetaContactGroupEvent evt){
  this.refreshGroup(evt.getSourceMetaContactGroup());
}",0.8465845464725644
104518,"/** 
 * Handles the <tt>ProtoContactEvent</tt>. Refreshes the list when a protocol contact has been moved.
 */
public void protoContactMoved(ProtoContactEvent evt){
  this.refresh();
}","/** 
 * Handles the <tt>ProtoContactEvent</tt>. Refreshes the list when a protocol contact has been moved.
 */
public void protoContactMoved(ProtoContactEvent evt){
  this.refreshAll();
}",0.9919137466307276
104519,"/** 
 * Handles the <tt>MetaContactRenamedEvent</tt>. Refreshes the list when a meta contact is renamed.
 */
public void metaContactRenamed(MetaContactRenamedEvent evt){
  this.refresh();
}","/** 
 * Handles the <tt>MetaContactRenamedEvent</tt>. Refreshes the list when a meta contact is renamed.
 */
public void metaContactRenamed(MetaContactRenamedEvent evt){
  this.refreshAll();
}",0.9921259842519684
104520,"/** 
 * Handles the <tt>MetaContactGroupEvent</tt>. Refreshes the list when a meta contact group has been modified.
 */
public void metaContactGroupModified(MetaContactGroupEvent evt){
  this.refresh();
}","/** 
 * Handles the <tt>MetaContactGroupEvent</tt>. Refreshes the list when a meta contact group has been modified.
 */
public void metaContactGroupModified(MetaContactGroupEvent evt){
  this.refreshAll();
}",0.9927007299270072
104521,"/** 
 * Handles the <tt>MetaContactGroupEvent</tt>. Refreshes the list when a meta contact group has been removed.
 */
public void metaContactGroupRemoved(MetaContactGroupEvent evt){
  this.refresh();
}","/** 
 * Handles the <tt>MetaContactGroupEvent</tt>. Refreshes the list when a meta contact group has been removed.
 */
public void metaContactGroupRemoved(MetaContactGroupEvent evt){
  this.refreshAll();
}",0.9926289926289926
104522,"public void valueChanged(ListSelectionEvent e){
  if (getSelectedValue() instanceof MetaContact) {
    currentlySelectedContact=(MetaContact)getSelectedValue();
  }
}","public void valueChanged(ListSelectionEvent e){
  currentlySelectedObject=getSelectedValue();
}",0.6973180076628352
104523,"/** 
 * Creates an instance of the <tt>ContactList</tt>.
 * @param mainFrame The main application window.
 */
public ContactList(MainFrame mainFrame){
  this.mainFrame=mainFrame;
  this.contactList=mainFrame.getContactList();
  this.listModel=new ContactListModel(contactList);
  this.setModel(listModel);
  this.setBorder(BorderFactory.createEmptyBorder(3,3,3,3));
  this.getSelectionModel().setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  this.setCellRenderer(new ContactListCellRenderer(mainFrame));
  this.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
  this.contactList.addMetaContactListListener(this);
  this.addMouseListener(this);
  this.addMouseMotionListener(this);
  this.addListSelectionListener(new ListSelectionListener(){
    public void valueChanged(    ListSelectionEvent e){
      if (getSelectedValue() instanceof MetaContact) {
        currentlySelectedContact=(MetaContact)getSelectedValue();
      }
    }
  }
);
}","/** 
 * Creates an instance of the <tt>ContactList</tt>.
 * @param mainFrame The main application window.
 */
public ContactList(MainFrame mainFrame){
  this.mainFrame=mainFrame;
  this.contactList=mainFrame.getContactList();
  this.listModel=new ContactListModel(contactList);
  this.setModel(listModel);
  this.setBorder(BorderFactory.createEmptyBorder(3,3,3,3));
  this.getSelectionModel().setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  this.setCellRenderer(new ContactListCellRenderer(mainFrame));
  this.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
  this.contactList.addMetaContactListListener(this);
  this.addMouseListener(this);
  this.addMouseMotionListener(this);
  this.addListSelectionListener(new ListSelectionListener(){
    public void valueChanged(    ListSelectionEvent e){
      currentlySelectedObject=getSelectedValue();
    }
  }
);
  new ContactListRefresh().start();
}",0.8789333333333333
104524,"/** 
 * Handles the <tt>MetaContactEvent</tt>. Refreshes the list model.
 */
public void metaContactAdded(MetaContactEvent evt){
  this.refresh();
}","/** 
 * Handles the <tt>MetaContactEvent</tt>. Refreshes the list model.
 */
public void metaContactAdded(MetaContactEvent evt){
  this.refreshAll();
}",0.9899665551839464
104525,"/** 
 * Handles the <tt>ProtoContactEvent</tt>. Refreshes the list when a protocol contact has been removed.
 */
public void protoContactRemoved(ProtoContactEvent evt){
  this.refresh();
}","/** 
 * Handles the <tt>ProtoContactEvent</tt>. Refreshes the list when a protocol contact has been removed.
 */
public void protoContactRemoved(ProtoContactEvent evt){
  this.refreshAll();
}",0.992084432717678
104526,"public void contactPresenceStatusChanged(ContactPresenceStatusChangeEvent evt){
  Contact sourceContact=evt.getSourceContact();
  MetaContact metaContact=contactList.findMetaContactByContact(sourceContact);
  if (metaContact != null) {
    ContactListPanel clistPanel=tabbedPane.getContactListPanel();
    clistPanel.getContactList().refresh();
    if (!evt.getOldStatus().equals(evt.getNewStatus()))     clistPanel.updateChatContactStatus(metaContact,sourceContact);
  }
}","public void contactPresenceStatusChanged(ContactPresenceStatusChangeEvent evt){
  ContactListPanel clistPanel=tabbedPane.getContactListPanel();
  clistPanel.getContactList().refresh();
  Contact sourceContact=evt.getSourceContact();
  MetaContact metaContact=contactList.findMetaContactByContact(sourceContact);
  if (metaContact != null) {
    if (!evt.getOldStatus().equals(evt.getNewStatus()))     clistPanel.updateChatContactStatus(metaContact,sourceContact);
  }
}",0.5265392781316348
104527,"public void contactPresenceStatusChanged(ContactPresenceStatusChangeEvent evt){
  Contact sourceContact=evt.getSourceContact();
  MetaContact metaContact=contactList.findMetaContactByContact(sourceContact);
  if (metaContact != null) {
    ContactListPanel clistPanel=tabbedPane.getContactListPanel();
    clistPanel.getContactList().repaint();
    if (!evt.getOldStatus().equals(evt.getNewStatus()))     clistPanel.updateChatContactStatus(metaContact,sourceContact);
  }
}","public void contactPresenceStatusChanged(ContactPresenceStatusChangeEvent evt){
  Contact sourceContact=evt.getSourceContact();
  MetaContact metaContact=contactList.findMetaContactByContact(sourceContact);
  if (metaContact != null) {
    ContactListPanel clistPanel=tabbedPane.getContactListPanel();
    clistPanel.getContactList().refresh();
    if (!evt.getOldStatus().equals(evt.getNewStatus()))     clistPanel.updateChatContactStatus(metaContact,sourceContact);
  }
}",0.7293868921775899
104528,"/** 
 * Handles the <tt>MetaContactGroupEvent</tt>. Refreshes the list model when a new meta contact group has been added.
 */
public void metaContactGroupAdded(MetaContactGroupEvent evt){
  this.repaint();
}","/** 
 * Handles the <tt>MetaContactGroupEvent</tt>. Refreshes the list model when a new meta contact group has been added.
 */
public void metaContactGroupAdded(MetaContactGroupEvent evt){
  this.refresh();
}",0.9759615384615384
104529,"/** 
 * Handles the <tt>MetaContactEvent</tt>. Refreshes the list when a meta contact has been removed.
 */
public void metaContactRemoved(MetaContactEvent evt){
  this.repaint();
}","/** 
 * Handles the <tt>MetaContactEvent</tt>. Refreshes the list when a meta contact has been removed.
 */
public void metaContactRemoved(MetaContactEvent evt){
  this.refresh();
}",0.9723756906077348
104530,"/** 
 * Handles the <tt>MetaContactMovedEvent</tt>. Refreshes the list when a meta contact has been moved.
 */
public void metaContactMoved(MetaContactMovedEvent evt){
  this.repaint();
}","/** 
 * Handles the <tt>MetaContactMovedEvent</tt>. Refreshes the list when a meta contact has been moved.
 */
public void metaContactMoved(MetaContactMovedEvent evt){
  this.refresh();
}",0.9732620320855616
104531,"/** 
 * Handles the <tt>MetaContactGroupEvent</tt>. Refreshes the list model when the contact list groups has been reordered. Moves the selection index to the index of the contact that was selected before the reordered event. This way the selection depends on the contact and not on the index.
 */
public void childContactsReordered(MetaContactGroupEvent evt){
  this.repaint();
  if (currentlySelectedContact != null)   this.setSelectedValue(currentlySelectedContact,false);
}","/** 
 * Handles the <tt>MetaContactGroupEvent</tt>. Refreshes the list model when the contact list groups has been reordered. Moves the selection index to the index of the contact that was selected before the reordered event. This way the selection depends on the contact and not on the index.
 */
public void childContactsReordered(MetaContactGroupEvent evt){
  this.refresh();
  if (currentlySelectedContact != null)   this.setSelectedValue(currentlySelectedContact,false);
}",0.989517819706499
104532,"/** 
 * Handles the <tt>ProtoContactEvent</tt>. Refreshes the list when a protocol contact has been moved.
 */
public void protoContactMoved(ProtoContactEvent evt){
  this.repaint();
}","/** 
 * Handles the <tt>ProtoContactEvent</tt>. Refreshes the list when a protocol contact has been moved.
 */
public void protoContactMoved(ProtoContactEvent evt){
  this.refresh();
}",0.9728260869565216
104533,"/** 
 * Handles the <tt>MetaContactRenamedEvent</tt>. Refreshes the list when a meta contact is renamed.
 */
public void metaContactRenamed(MetaContactRenamedEvent evt){
  this.repaint();
}","/** 
 * Handles the <tt>MetaContactRenamedEvent</tt>. Refreshes the list when a meta contact is renamed.
 */
public void metaContactRenamed(MetaContactRenamedEvent evt){
  this.refresh();
}",0.9735449735449736
104534,"/** 
 * Handles the <tt>MetaContactGroupEvent</tt>. Refreshes the list when a meta contact group has been modified.
 */
public void metaContactGroupModified(MetaContactGroupEvent evt){
  this.repaint();
}","/** 
 * Handles the <tt>MetaContactGroupEvent</tt>. Refreshes the list when a meta contact group has been modified.
 */
public void metaContactGroupModified(MetaContactGroupEvent evt){
  this.refresh();
}",0.9754901960784312
104535,"/** 
 * Handles the <tt>MetaContactGroupEvent</tt>. Refreshes the list when a meta contact group has been removed.
 */
public void metaContactGroupRemoved(MetaContactGroupEvent evt){
  this.repaint();
}","/** 
 * Handles the <tt>MetaContactGroupEvent</tt>. Refreshes the list when a meta contact group has been removed.
 */
public void metaContactGroupRemoved(MetaContactGroupEvent evt){
  this.refresh();
}",0.9752475247524752
104536,"/** 
 * Creates an instance of the <tt>ContactList</tt>.
 * @param contactList The related meta contactlist.
 */
public ContactList(MainFrame mainFrame){
  this.mainFrame=mainFrame;
  this.contactList=mainFrame.getContactList();
  this.listModel=new ContactListModel(contactList);
  this.setModel(listModel);
  this.setBorder(BorderFactory.createEmptyBorder(3,3,3,3));
  this.getSelectionModel().setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  this.setCellRenderer(new ContactListCellRenderer(mainFrame));
  this.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
  this.contactList.addMetaContactListListener(this);
  this.addMouseListener(this);
  this.addMouseMotionListener(this);
  this.addListSelectionListener(new ListSelectionListener(){
    public void valueChanged(    ListSelectionEvent e){
      if (getSelectedValue() instanceof MetaContact) {
        currentlySelectedContact=(MetaContact)getSelectedValue();
      }
    }
  }
);
}","/** 
 * Creates an instance of the <tt>ContactList</tt>.
 * @param mainFrame The main application window.
 */
public ContactList(MainFrame mainFrame){
  this.mainFrame=mainFrame;
  this.contactList=mainFrame.getContactList();
  this.listModel=new ContactListModel(contactList);
  this.setModel(listModel);
  this.setBorder(BorderFactory.createEmptyBorder(3,3,3,3));
  this.getSelectionModel().setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  this.setCellRenderer(new ContactListCellRenderer(mainFrame));
  this.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
  this.contactList.addMetaContactListListener(this);
  this.addMouseListener(this);
  this.addMouseMotionListener(this);
  this.addListSelectionListener(new ListSelectionListener(){
    public void valueChanged(    ListSelectionEvent e){
      if (getSelectedValue() instanceof MetaContact) {
        currentlySelectedContact=(MetaContact)getSelectedValue();
      }
    }
  }
);
}",0.965122332118688
104537,"/** 
 * Handles the <tt>MetaContactEvent</tt>. Refreshes the list model.
 */
public void metaContactAdded(MetaContactEvent evt){
  this.repaint();
}","/** 
 * Handles the <tt>MetaContactEvent</tt>. Refreshes the list model.
 */
public void metaContactAdded(MetaContactEvent evt){
  this.refresh();
}",0.9662162162162162
104538,"/** 
 * Handles the <tt>ProtoContactEvent</tt>. Refreshes the list when a protocol contact has been removed.
 */
public void protoContactRemoved(ProtoContactEvent evt){
  this.repaint();
}","/** 
 * Handles the <tt>ProtoContactEvent</tt>. Refreshes the list when a protocol contact has been removed.
 */
public void protoContactRemoved(ProtoContactEvent evt){
  this.refresh();
}",0.973404255319149
104539,"/** 
 * @param group
 * @return
 */
public int countChildContacts(MetaContactGroup group){
  if (showOffline)   return group.countChildContacts();
 else {
    int count=0;
    Iterator i=group.getChildContacts();
    while (i.hasNext()) {
      MetaContact metaContact=(MetaContact)i.next();
      if (isContactOnline(metaContact)) {
        count++;
      }
 else {
        break;
      }
    }
    return count;
  }
}","/** 
 * Counts group child contacts depending on the showOffline option.
 * @param group the parent group to count for
 * @return child contacts count for the given group
 */
public int countChildContacts(MetaContactGroup group){
  if (showOffline)   return group.countChildContacts();
 else {
    int count=0;
    Iterator i=group.getChildContacts();
    while (i.hasNext()) {
      MetaContact metaContact=(MetaContact)i.next();
      if (isContactOnline(metaContact)) {
        count++;
      }
 else {
        break;
      }
    }
    return count;
  }
}",0.857727737973388
104540,"/** 
 * Recursively searches all groups for the element at the given index. 
 * @param group The group in which we search.
 * @param searchedIndex The index to search for.
 * @return The element at the given index, if it finds it, otherwise null.
 */
private Object getElementAt(MetaContactGroup group,int currentIndex,int searchedIndex){
  Object element=null;
  if (currentIndex == searchedIndex) {
    element=group;
  }
 else {
    if (!isGroupClosed(group)) {
      int childCount=countChildContacts(group);
      if (searchedIndex <= (currentIndex + childCount)) {
        MetaContact contact=group.getMetaContact(searchedIndex - currentIndex - 1);
        if (showOffline || isContactOnline(contact))         element=contact;
      }
 else {
        currentIndex+=childCount;
        Iterator subgroups=group.getSubgroups();
        while (subgroups.hasNext()) {
          MetaContactGroup subgroup=(MetaContactGroup)subgroups.next();
          element=getElementAt(subgroup,currentIndex + 1,searchedIndex);
          if (element != null)           break;
 else {
            if (!isGroupClosed(subgroup))             currentIndex+=countChildContacts(subgroup) + 1;
 else             currentIndex++;
          }
        }
      }
    }
  }
  return element;
}","/** 
 * Recursively searches the given group in depth for the element at the given index. 
 * @param group the group in which we search
 * @param currentIndex the index, where we currently are
 * @param searchedIndex the index to search for
 * @return The element at the given index, if we find it, otherwise null.
 */
private Object getElementAt(MetaContactGroup group,int currentIndex,int searchedIndex){
  Object element=null;
  if (currentIndex == searchedIndex) {
    element=group;
  }
 else {
    if (!isGroupClosed(group)) {
      int childCount=countChildContacts(group);
      if (searchedIndex <= (currentIndex + childCount)) {
        MetaContact contact=group.getMetaContact(searchedIndex - currentIndex - 1);
        if (showOffline || isContactOnline(contact))         element=contact;
      }
 else {
        currentIndex+=childCount;
        Iterator subgroups=group.getSubgroups();
        while (subgroups.hasNext()) {
          MetaContactGroup subgroup=(MetaContactGroup)subgroups.next();
          element=getElementAt(subgroup,currentIndex + 1,searchedIndex);
          if (element != null)           break;
 else {
            if (!isGroupClosed(subgroup))             currentIndex+=countChildContacts(subgroup) + 1;
 else             currentIndex++;
          }
        }
      }
    }
  }
  return element;
}",0.87
104541,"public void run(){
  while (refreshEnabled) {
synchronized (refreshLock) {
      if (isModified) {
        try {
          refreshLock.wait(5000);
        }
 catch (        InterruptedException e) {
          logger.error(""String_Node_Str"",e);
        }
      }
    }
    if (isModified) {
      if (groupsToModify.size() > 0) {
        for (int i=0; i < groupsToModify.size(); i++) {
          MetaContactGroup group=(MetaContactGroup)groupsToModify.get(i);
          this.refreshGroup(group);
        }
        groupsToModify.removeAllElements();
      }
 else {
        this.refreshAll();
      }
      isModified=false;
    }
  }
}","public void run(){
  while (refreshEnabled) {
synchronized (refreshLock) {
      if (!isModified) {
        try {
          refreshLock.wait(5000);
        }
 catch (        InterruptedException e) {
          logger.error(""String_Node_Str"",e);
        }
      }
    }
    if (isModified) {
      if (groupsToModify.size() > 0) {
        for (int i=0; i < groupsToModify.size(); i++) {
          MetaContactGroup group=(MetaContactGroup)groupsToModify.get(i);
          this.refreshGroup(group);
        }
        groupsToModify.removeAllElements();
      }
 else {
        this.refreshAll();
      }
      isModified=false;
    }
  }
}",0.999213217938631
104542,"/** 
 * Adds all UI components (status selector box, etc) related to the given protocol provider.
 * @param protocolProvider the <tt>ProtocolProviderService</tt>
 */
private void handleProviderAdded(ProtocolProviderService protocolProvider){
  protocolProvider.addRegistrationStateChangeListener(this);
  this.mainFrame.addProtocolProvider(protocolProvider);
  this.login(protocolProvider);
}","/** 
 * Adds all UI components (status selector box, etc) related to the given protocol provider.
 * @param protocolProvider the <tt>ProtocolProviderService</tt>
 */
private void handleProviderAdded(ProtocolProviderService protocolProvider){
  protocolProvider.addRegistrationStateChangeListener(this);
  this.mainFrame.addProtocolProvider(protocolProvider);
  PresenceStatus status=this.mainFrame.getStatusPanel().getProtocolProviderLastStatus(protocolProvider);
  if (status == null || status.getStatus() > PresenceStatus.ONLINE_THRESHOLD) {
    this.login(protocolProvider);
  }
}",0.7835897435897435
104543,"/** 
 * Shows login window for each registered account.
 * @param parent The parent MainFrame window.
 */
public void runLogin(MainFrame parent){
  Set set=GuiActivator.getProtocolProviderFactories().entrySet();
  Iterator iter=set.iterator();
  boolean hasRegisteredAccounts=false;
  while (iter.hasNext()) {
    Map.Entry entry=(Map.Entry)iter.next();
    ProtocolProviderFactory providerFactory=(ProtocolProviderFactory)entry.getValue();
    ArrayList accountsList=providerFactory.getRegisteredAccounts();
    AccountID accountID;
    ServiceReference serRef;
    ProtocolProviderService protocolProvider;
    for (int i=0; i < accountsList.size(); i++) {
      hasRegisteredAccounts=true;
      accountID=(AccountID)accountsList.get(i);
      serRef=providerFactory.getProviderForAccount(accountID);
      protocolProvider=(ProtocolProviderService)GuiActivator.bundleContext.getService(serRef);
      protocolProvider.addRegistrationStateChangeListener(this);
      this.mainFrame.addProtocolProvider(protocolProvider);
      this.login(protocolProvider);
    }
  }
  if (!hasRegisteredAccounts) {
    this.showAccountRegistrationWizard();
  }
}","/** 
 * Shows login window for each registered account.
 * @param parent The parent MainFrame window.
 */
public void runLogin(MainFrame parent){
  Set set=GuiActivator.getProtocolProviderFactories().entrySet();
  Iterator iter=set.iterator();
  boolean hasRegisteredAccounts=false;
  while (iter.hasNext()) {
    Map.Entry entry=(Map.Entry)iter.next();
    ProtocolProviderFactory providerFactory=(ProtocolProviderFactory)entry.getValue();
    ArrayList accountsList=providerFactory.getRegisteredAccounts();
    AccountID accountID;
    ServiceReference serRef;
    ProtocolProviderService protocolProvider;
    for (int i=0; i < accountsList.size(); i++) {
      hasRegisteredAccounts=true;
      accountID=(AccountID)accountsList.get(i);
      serRef=providerFactory.getProviderForAccount(accountID);
      protocolProvider=(ProtocolProviderService)GuiActivator.bundleContext.getService(serRef);
      protocolProvider.addRegistrationStateChangeListener(this);
      this.mainFrame.addProtocolProvider(protocolProvider);
      PresenceStatus status=this.mainFrame.getStatusPanel().getProtocolProviderLastStatus(protocolProvider);
      if (status == null || status.getStatus() > PresenceStatus.ONLINE_THRESHOLD) {
        this.login(protocolProvider);
      }
    }
  }
  if (!hasRegisteredAccounts) {
    this.showAccountRegistrationWizard();
  }
}",0.895641743302679
104544,"/** 
 * Registers the given protocol provider.
 * @param protocolProvider the ProtocolProviderService to register.
 */
public void login(ProtocolProviderService protocolProvider){
  SecurityAuthorityImpl secAuth=new SecurityAuthorityImpl(mainFrame,protocolProvider);
  PresenceStatus status=this.mainFrame.getStatusPanel().getProtocolProviderLastStatus(protocolProvider);
  if (status == null || status.getStatus() > PresenceStatus.ONLINE_THRESHOLD) {
    this.mainFrame.activateAccount(protocolProvider);
    new RegisterProvider(protocolProvider,secAuth).start();
  }
}","/** 
 * Registers the given protocol provider.
 * @param protocolProvider the ProtocolProviderService to register.
 */
public void login(ProtocolProviderService protocolProvider){
  SecurityAuthorityImpl secAuth=new SecurityAuthorityImpl(mainFrame,protocolProvider);
  this.mainFrame.activateAccount(protocolProvider);
  new RegisterProvider(protocolProvider,secAuth).start();
}",0.6554267650158061
104545,"/** 
 * Recursively searches all groups for the element at the given index. 
 * @param group The group in which we search.
 * @param searchedIndex The index to search for.
 * @return The element at the given index, if it finds it, otherwise null.
 */
private Object getElementAt(MetaContactGroup group,int searchedIndex){
  Object element=null;
  if (!this.isGroupClosed(group)) {
    Iterator contacts=group.getChildContacts();
    while (contacts.hasNext()) {
      MetaContact contact=(MetaContact)contacts.next();
      if (!offlineContacts.contains(contact) && this.indexOf(contact) == searchedIndex) {
        element=contact;
        break;
      }
    }
    if (element == null) {
      Iterator subgroups=group.getSubgroups();
      while (subgroups.hasNext()) {
        MetaContactGroup subgroup=(MetaContactGroup)subgroups.next();
        if (this.indexOf(subgroup) != searchedIndex) {
          element=getElementAt(subgroup,searchedIndex);
          if (element != null)           break;
        }
 else {
          element=subgroup;
          break;
        }
      }
    }
  }
  return element;
}","/** 
 * Recursively searches all groups for the element at the given index. 
 * @param group The group in which we search.
 * @param searchedIndex The index to search for.
 * @return The element at the given index, if it finds it, otherwise null.
 */
private Object getElementAt(MetaContactGroup group,int searchedIndex){
  Object element=null;
  if (!this.isGroupClosed(group)) {
    Iterator contacts=group.getChildContacts();
    while (contacts.hasNext()) {
      MetaContact contact=(MetaContact)contacts.next();
      if (!offlineContacts.contains(contact) && this.indexOf(contact) == searchedIndex) {
        element=contact;
        break;
      }
    }
    if (element == null) {
      Iterator subgroups=group.getSubgroups();
      while (subgroups.hasNext()) {
        MetaContactGroup subgroup=(MetaContactGroup)subgroups.next();
        if (this.indexOf(subgroup) != searchedIndex) {
          element=getElementAt(subgroup,searchedIndex);
          if (element != null) {
            break;
          }
        }
 else {
          element=subgroup;
          break;
        }
      }
    }
  }
  return element;
}",0.9928507596067918
104546,"/** 
 * Returns the index of the given MetaContactGroup.
 * @param group The given MetaContactGroup to search for.
 * @return The index of the given MetaContactGroup.
 */
public int indexOf(MetaContactGroup group){
  int index=-1;
  int currentIndex=0;
  MetaContactGroup parentGroup=this.contactList.findParentMetaContactGroup(group);
  if (parentGroup != null && !this.isGroupClosed(parentGroup)) {
    currentIndex+=this.indexOf(parentGroup);
    currentIndex+=parentGroup.indexOf(group) + 1;
    for (int i=0; i < parentGroup.indexOf(group); i++) {
      MetaContactGroup subGroup=parentGroup.getMetaContactSubgroup(i);
      currentIndex+=countSubgroupContacts(subGroup);
    }
    index=currentIndex;
  }
  return index;
}","/** 
 * Returns the index of the given MetaContactGroup.
 * @param group The given MetaContactGroup to search for.
 * @return The index of the given MetaContactGroup.
 */
public int indexOf(MetaContactGroup group){
  int index=-1;
  int currentIndex=0;
  MetaContactGroup parentGroup=this.contactList.findParentMetaContactGroup(group);
  if (parentGroup != null && !this.isGroupClosed(parentGroup)) {
    currentIndex+=this.indexOf(parentGroup);
    currentIndex+=countChildContacts(parentGroup);
    currentIndex+=parentGroup.indexOf(group) + 1;
    for (int i=0; i < parentGroup.indexOf(group); i++) {
      MetaContactGroup subGroup=parentGroup.getMetaContactSubgroup(i);
      currentIndex+=countSubgroupContacts(subGroup);
    }
    index=currentIndex;
  }
  return index;
}",0.9661579296615792
104547,"private QueryResultSet find(Date startDate,Date endDate,String[] keywords,String field,boolean caseSensitive){
  TreeSet result=new TreeSet(new HistoryRecordComparator());
  Vector filelist=filterFilesByDate(this.historyImpl.getFileList(),startDate,endDate);
  double currentProgress=HistorySearchProgressListener.PROGRESS_MINIMUM_VALUE;
  double fileProgressStep=HistorySearchProgressListener.PROGRESS_MAXIMUM_VALUE;
  if (filelist.size() != 0)   fileProgressStep=HistorySearchProgressListener.PROGRESS_MAXIMUM_VALUE / filelist.size();
  fireProgressStateChanged(startDate,endDate,keywords,HistorySearchProgressListener.PROGRESS_MINIMUM_VALUE);
  Iterator fileIterator=filelist.iterator();
  while (fileIterator.hasNext()) {
    String filename=(String)fileIterator.next();
    Document doc=this.historyImpl.getDocumentForFile(filename);
    NodeList nodes=doc.getElementsByTagName(""String_Node_Str"");
    double nodesProgressStep=fileProgressStep;
    if (nodes.getLength() != 0)     nodesProgressStep=fileProgressStep / nodes.getLength();
    Node node;
    for (int i=0; i < nodes.getLength(); i++) {
      node=nodes.item(i);
      String ts=node.getAttributes().getNamedItem(""String_Node_Str"").getNodeValue();
      Date timestamp=new Date(Long.parseLong(ts));
      if (isInPeriod(timestamp,startDate,endDate)) {
        NodeList propertyNodes=node.getChildNodes();
        HistoryRecord record=filterByKeyword(propertyNodes,timestamp,keywords,field,caseSensitive);
        if (record != null) {
          result.add(record);
        }
      }
      currentProgress+=nodesProgressStep;
      fireProgressStateChanged(startDate,endDate,keywords,(int)currentProgress);
    }
  }
  fireProgressStateChanged(startDate,endDate,keywords,HistorySearchProgressListener.PROGRESS_MAXIMUM_VALUE);
  return new OrderedQueryResultSet(result);
}","private QueryResultSet find(Date startDate,Date endDate,String[] keywords,String field,boolean caseSensitive){
  TreeSet result=new TreeSet(new HistoryRecordComparator());
  Vector filelist=filterFilesByDate(this.historyImpl.getFileList(),startDate,endDate);
  double currentProgress=HistorySearchProgressListener.PROGRESS_MINIMUM_VALUE;
  double fileProgressStep=HistorySearchProgressListener.PROGRESS_MAXIMUM_VALUE;
  if (filelist.size() != 0)   fileProgressStep=HistorySearchProgressListener.PROGRESS_MAXIMUM_VALUE / filelist.size();
  fireProgressStateChanged(startDate,endDate,keywords,HistorySearchProgressListener.PROGRESS_MINIMUM_VALUE);
  Iterator fileIterator=filelist.iterator();
  while (fileIterator.hasNext()) {
    String filename=(String)fileIterator.next();
    Document doc=this.historyImpl.getDocumentForFile(filename);
    NodeList nodes=doc.getElementsByTagName(""String_Node_Str"");
    double nodesProgressStep=fileProgressStep;
    if (nodes.getLength() != 0)     nodesProgressStep=fileProgressStep / nodes.getLength();
    Node node;
    for (int i=0; i < nodes.getLength(); i++) {
      node=nodes.item(i);
      String ts=node.getAttributes().getNamedItem(""String_Node_Str"").getNodeValue();
      Date timestamp=new Date(Long.parseLong(ts));
      if (isInPeriod(timestamp,startDate,endDate)) {
        NodeList propertyNodes=node.getChildNodes();
        HistoryRecord record=filterByKeyword(propertyNodes,timestamp,keywords,field,caseSensitive);
        if (record != null) {
          result.add(record);
        }
      }
      currentProgress+=nodesProgressStep;
      fireProgressStateChanged(startDate,endDate,keywords,(int)currentProgress);
    }
  }
  if ((int)currentProgress < HistorySearchProgressListener.PROGRESS_MAXIMUM_VALUE) {
    fireProgressStateChanged(startDate,endDate,keywords,HistorySearchProgressListener.PROGRESS_MAXIMUM_VALUE);
  }
  return new OrderedQueryResultSet(result);
}",0.94770374303159
104548,"/** 
 * Opens a link in the default browser when clicked and shows link url in a popup on mouseover.
 * @param e The HyperlinkEvent.
 */
public void hyperlinkUpdate(HyperlinkEvent e){
  if (e.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {
    URL url=e.getURL();
    CrossPlatformBrowserLauncher.openURL(url.toString());
  }
 else   if (e.getEventType() == HyperlinkEvent.EventType.ENTERED) {
    String href=e.getDescription();
    this.chatContainer.setStatusMessage(href);
    this.currentHref=href;
  }
 else   if (e.getEventType() == HyperlinkEvent.EventType.EXITED) {
    this.chatContainer.setStatusMessage(""String_Node_Str"");
    this.currentHref=""String_Node_Str"";
  }
}","/** 
 * Opens a link in the default browser when clicked and shows link url in a popup on mouseover.
 * @param e The HyperlinkEvent.
 */
public void hyperlinkUpdate(HyperlinkEvent e){
  if (e.getEventType() == HyperlinkEvent.EventType.ENTERED) {
    String href=e.getDescription();
    this.chatContainer.setStatusMessage(href);
    this.currentHref=href;
  }
 else   if (e.getEventType() == HyperlinkEvent.EventType.EXITED) {
    this.chatContainer.setStatusMessage(""String_Node_Str"");
    this.currentHref=""String_Node_Str"";
  }
}",0.8721311475409836
104549,"/** 
 * Opens this panel context menu at the given point.
 * @param p the point where to position the left-top cornet of thecontext menu
 */
private void openContextMenu(Point p){
  if (currentHref != null) {
    if (currentHref != ""String_Node_Str"") {
      rightButtonMenu.insert(openLinkItem,0);
      rightButtonMenu.insert(copyLinkItem,1);
      rightButtonMenu.insert(copyLinkSeparator,2);
    }
 else {
      rightButtonMenu.remove(openLinkItem);
      rightButtonMenu.remove(copyLinkItem);
      rightButtonMenu.remove(copyLinkSeparator);
    }
  }
  if (chatEditorPane.getSelectedText() != null) {
    rightButtonMenu.enableCopy();
  }
 else {
    rightButtonMenu.disableCopy();
  }
  rightButtonMenu.setInvoker(chatEditorPane);
  rightButtonMenu.setLocation(p.x,p.y);
  rightButtonMenu.setVisible(true);
}","/** 
 * Opens this panel context menu at the given point.
 * @param p the point where to position the left-top cornet of thecontext menu
 */
private void openContextMenu(Point p){
  if (currentHref != null && currentHref != ""String_Node_Str"") {
    rightButtonMenu.insert(openLinkItem,0);
    rightButtonMenu.insert(copyLinkItem,1);
    rightButtonMenu.insert(copyLinkSeparator,2);
  }
 else {
    rightButtonMenu.remove(openLinkItem);
    rightButtonMenu.remove(copyLinkItem);
    rightButtonMenu.remove(copyLinkSeparator);
  }
  if (chatEditorPane.getSelectedText() != null) {
    rightButtonMenu.enableCopy();
  }
 else {
    rightButtonMenu.disableCopy();
  }
  rightButtonMenu.setInvoker(chatEditorPane);
  rightButtonMenu.setLocation(p.x,p.y);
  rightButtonMenu.setVisible(true);
}",0.9775280898876404
104550,"/** 
 * When a right button click is performed in the editor pane, a popup menu is opened.
 * @param e The MouseEvent.
 */
public void mouseClicked(MouseEvent e){
  Point p=e.getPoint();
  SwingUtilities.convertPointToScreen(p,e.getComponent());
  if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0 || (e.isControlDown() && !e.isMetaDown())) {
    openContextMenu(p);
  }
}","/** 
 * When a right button click is performed in the editor pane, a popup menu is opened.
 * @param e The MouseEvent.
 */
public void mouseClicked(MouseEvent e){
  Point p=e.getPoint();
  SwingUtilities.convertPointToScreen(p,e.getComponent());
  if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0 || (e.isControlDown() && !e.isMetaDown())) {
    openContextMenu(p);
  }
 else   if ((e.getModifiers() & InputEvent.BUTTON1_MASK) != 0) {
    CrossPlatformBrowserLauncher.openURL(currentHref);
  }
}",0.8584474885844748
104551,"private void fireProgressStateChanged(Date startDate,Date endDate,String[] keywords,int progress){
  ProgressEvent event=new ProgressEvent(this,startDate,endDate,keywords,progress);
  Iterator iter=progressListeners.iterator();
  while (iter.hasNext()) {
    HistorySearchProgressListener item=(HistorySearchProgressListener)iter.next();
    item.progressChanged(event);
  }
}","private void fireProgressStateChanged(Date startDate,Date endDate,String[] keywords,int progress){
  ProgressEvent event=new ProgressEvent(this,startDate,endDate,keywords,progress);
synchronized (progressListeners) {
    Iterator iter=progressListeners.iterator();
    while (iter.hasNext()) {
      HistorySearchProgressListener item=(HistorySearchProgressListener)iter.next();
      item.progressChanged(event);
    }
  }
}",0.9388264669163544
104552,"/** 
 * Removing progress listener
 * @param listener HistorySearchProgressListener
 */
public void removeSearchProgressListener(HistorySearchProgressListener listener){
  progressListeners.remove(listener);
}","/** 
 * Removing progress listener
 * @param listener HistorySearchProgressListener
 */
public void removeSearchProgressListener(HistorySearchProgressListener listener){
synchronized (progressListeners) {
    progressListeners.remove(listener);
  }
}",0.9106753812636166
104553,"/** 
 * Adding progress listener for monitoring progress of search process
 * @param listener HistorySearchProgressListener
 */
public void addSearchProgressListener(HistorySearchProgressListener listener){
  progressListeners.add(listener);
}","/** 
 * Adding progress listener for monitoring progress of search process
 * @param listener HistorySearchProgressListener
 */
public void addSearchProgressListener(HistorySearchProgressListener listener){
synchronized (progressListeners) {
    progressListeners.add(listener);
  }
}",0.922201138519924
104554,"/** 
 * Add the registered MessageHistorySearchProgressListeners to the given HistoryReader
 * @param reader HistoryReader
 */
private void addHistorySearchProgressListeners(HistoryReader reader){
  Iterator iter=progressListeners.values().iterator();
  while (iter.hasNext()) {
    HistorySearchProgressListener l=(HistorySearchProgressListener)iter.next();
    reader.addSearchProgressListener(l);
  }
}","/** 
 * Add the registered MessageHistorySearchProgressListeners to the given HistoryReader
 * @param reader HistoryReader
 */
private void addHistorySearchProgressListeners(HistoryReader reader){
synchronized (progressListeners) {
    Iterator iter=progressListeners.values().iterator();
    while (iter.hasNext()) {
      HistorySearchProgressListener l=(HistorySearchProgressListener)iter.next();
      reader.addSearchProgressListener(l);
    }
  }
}",0.9429569266589056
104555,"/** 
 * Removing progress listener
 * @param listener HistorySearchProgressListener
 */
public void removeSearchProgressListener(MessageHistorySearchProgressListener listener){
  progressListeners.remove(listener);
}","/** 
 * Removing progress listener
 * @param listener HistorySearchProgressListener
 */
public void removeSearchProgressListener(MessageHistorySearchProgressListener listener){
synchronized (progressListeners) {
    progressListeners.remove(listener);
  }
}",0.9133192389006344
104556,"/** 
 * Removes the registered MessageHistorySearchProgressListeners from the given HistoryReader
 * @param reader HistoryReader
 */
private void removeHistorySearchProgressListeners(HistoryReader reader){
  Iterator iter=progressListeners.values().iterator();
  while (iter.hasNext()) {
    HistorySearchProgressListener l=(HistorySearchProgressListener)iter.next();
    reader.removeSearchProgressListener(l);
  }
}","/** 
 * Removes the registered MessageHistorySearchProgressListeners from the given HistoryReader
 * @param reader HistoryReader
 */
private void removeHistorySearchProgressListeners(HistoryReader reader){
synchronized (progressListeners) {
    Iterator iter=progressListeners.values().iterator();
    while (iter.hasNext()) {
      HistorySearchProgressListener l=(HistorySearchProgressListener)iter.next();
      reader.removeSearchProgressListener(l);
    }
  }
}",0.9445073612684032
104557,"/** 
 * Adding progress listener for monitoring progress of search process
 * @param listener HistorySearchProgressListener
 */
public void addSearchProgressListener(MessageHistorySearchProgressListener listener){
  HistorySearchProgressListener wrapperListener=new SearchProgressWrapper(listener);
  progressListeners.put(listener,wrapperListener);
}","/** 
 * Adding progress listener for monitoring progress of search process
 * @param listener HistorySearchProgressListener
 */
public void addSearchProgressListener(MessageHistorySearchProgressListener listener){
synchronized (progressListeners) {
    HistorySearchProgressListener wrapperListener=new SearchProgressWrapper(listener);
    progressListeners.put(listener,wrapperListener);
  }
}",0.9422818791946308
104558,"public void run(){
  try {
    while (true) {
synchronized (contactsForUpdate) {
        if (contactsForUpdate.isEmpty())         contactsForUpdate.wait();
        Iterator iter=contactsForUpdate.iterator();
        while (iter.hasNext()) {
          ContactIcqImpl contact=(ContactIcqImpl)iter.next();
          String oldNickname=contact.getDisplayName();
          String nickName=getParentProvider().getInfoRetreiver().getNickName(contact.getUIN());
          if (nickName != null) {
            contact.setNickname(nickName);
            parentOperationSet.fireContactPropertyChangeEvent(ContactPropertyChangeEvent.PROPERTY_DISPLAY_NAME,contact,oldNickname,nickName);
          }
        }
        contactsForUpdate.clear();
      }
    }
  }
 catch (  InterruptedException ex) {
    logger.error(""String_Node_Str"",ex);
  }
}","public void run(){
  try {
    Collection copyContactsForUpdate=null;
    while (true) {
synchronized (contactsForUpdate) {
        if (contactsForUpdate.isEmpty())         contactsForUpdate.wait();
        copyContactsForUpdate=new Vector(contactsForUpdate);
        contactsForUpdate.clear();
      }
      Iterator iter=copyContactsForUpdate.iterator();
      while (iter.hasNext()) {
        ContactIcqImpl contact=(ContactIcqImpl)iter.next();
        String oldNickname=contact.getDisplayName();
        String nickName=getParentProvider().getInfoRetreiver().getNickName(contact.getUIN());
        if (nickName != null) {
          contact.setNickname(nickName);
          parentOperationSet.fireContactPropertyChangeEvent(ContactPropertyChangeEvent.PROPERTY_DISPLAY_NAME,contact,oldNickname,nickName);
        }
      }
    }
  }
 catch (  InterruptedException ex) {
    logger.error(""String_Node_Str"",ex);
  }
}",0.879862700228833
104559,"private void fireProgressStateChanged(ProgressEvent event,int progress){
  event.setProgress(progress);
  Iterator iter=progressListeners.iterator();
  while (iter.hasNext()) {
    HistorySearchProgressListener item=(HistorySearchProgressListener)iter.next();
    item.progressChanged(event);
  }
}","private void fireProgressStateChanged(Date startDate,Date endDate,String[] keywords,int progress){
  ProgressEvent event=new ProgressEvent(this,startDate,endDate,keywords,progress);
  Iterator iter=progressListeners.iterator();
  while (iter.hasNext()) {
    HistorySearchProgressListener item=(HistorySearchProgressListener)iter.next();
    item.progressChanged(event);
  }
}",0.7774480712166172
104560,"private QueryResultSet find(Date startDate,Date endDate,String[] keywords,String field,boolean caseSensitive){
  TreeSet result=new TreeSet(new HistoryRecordComparator());
  Vector filelist=filterFilesByDate(this.historyImpl.getFileList(),startDate,endDate);
  ProgressEvent progressEvent=new ProgressEvent(this,startDate,endDate,keywords);
  int currentProgress=HistorySearchProgressListener.PROGRESS_MINIMUM_VALUE;
  int fileProgressStep=HistorySearchProgressListener.PROGRESS_MAXIMUM_VALUE;
  if (filelist.size() != 0)   fileProgressStep=HistorySearchProgressListener.PROGRESS_MAXIMUM_VALUE / filelist.size();
  fireProgressStateChanged(progressEvent,HistorySearchProgressListener.PROGRESS_MINIMUM_VALUE);
  Iterator fileIterator=filelist.iterator();
  while (fileIterator.hasNext()) {
    String filename=(String)fileIterator.next();
    Document doc=this.historyImpl.getDocumentForFile(filename);
    NodeList nodes=doc.getElementsByTagName(""String_Node_Str"");
    int nodesProgressStep=fileProgressStep;
    if (nodes.getLength() != 0)     nodesProgressStep=fileProgressStep / nodes.getLength();
    Node node;
    for (int i=0; i < nodes.getLength(); i++) {
      node=nodes.item(i);
      String ts=node.getAttributes().getNamedItem(""String_Node_Str"").getNodeValue();
      Date timestamp=new Date(Long.parseLong(ts));
      if (isInPeriod(timestamp,startDate,endDate)) {
        NodeList propertyNodes=node.getChildNodes();
        HistoryRecord record=filterByKeyword(propertyNodes,timestamp,keywords,field,caseSensitive);
        if (record != null) {
          result.add(record);
        }
      }
      currentProgress+=nodesProgressStep;
      fireProgressStateChanged(progressEvent,currentProgress);
    }
  }
  fireProgressStateChanged(progressEvent,HistorySearchProgressListener.PROGRESS_MAXIMUM_VALUE);
  return new OrderedQueryResultSet(result);
}","private QueryResultSet find(Date startDate,Date endDate,String[] keywords,String field,boolean caseSensitive){
  TreeSet result=new TreeSet(new HistoryRecordComparator());
  Vector filelist=filterFilesByDate(this.historyImpl.getFileList(),startDate,endDate);
  int currentProgress=HistorySearchProgressListener.PROGRESS_MINIMUM_VALUE;
  int fileProgressStep=HistorySearchProgressListener.PROGRESS_MAXIMUM_VALUE;
  if (filelist.size() != 0)   fileProgressStep=HistorySearchProgressListener.PROGRESS_MAXIMUM_VALUE / filelist.size();
  fireProgressStateChanged(startDate,endDate,keywords,HistorySearchProgressListener.PROGRESS_MINIMUM_VALUE);
  Iterator fileIterator=filelist.iterator();
  while (fileIterator.hasNext()) {
    String filename=(String)fileIterator.next();
    Document doc=this.historyImpl.getDocumentForFile(filename);
    NodeList nodes=doc.getElementsByTagName(""String_Node_Str"");
    int nodesProgressStep=fileProgressStep;
    if (nodes.getLength() != 0)     nodesProgressStep=fileProgressStep / nodes.getLength();
    Node node;
    for (int i=0; i < nodes.getLength(); i++) {
      node=nodes.item(i);
      String ts=node.getAttributes().getNamedItem(""String_Node_Str"").getNodeValue();
      Date timestamp=new Date(Long.parseLong(ts));
      if (isInPeriod(timestamp,startDate,endDate)) {
        NodeList propertyNodes=node.getChildNodes();
        HistoryRecord record=filterByKeyword(propertyNodes,timestamp,keywords,field,caseSensitive);
        if (record != null) {
          result.add(record);
        }
      }
      currentProgress+=nodesProgressStep;
      fireProgressStateChanged(startDate,endDate,keywords,currentProgress);
    }
  }
  fireProgressStateChanged(startDate,endDate,keywords,HistorySearchProgressListener.PROGRESS_MAXIMUM_VALUE);
  return new OrderedQueryResultSet(result);
}",0.9460850717962612
104561,"/** 
 * Used to convert HistoryRecord in MessageDeliveredEvent or MessageReceivedEvent which are returned by the finder methods
 * @param hr HistoryRecord
 * @param contact Contact
 * @return Object
 */
private Object convertHistoryRecordToMessageEvent(HistoryRecord hr,Contact contact){
  MessageImpl msg=new MessageImpl(hr);
  Date timestamp=null;
  if (msg.getMessageReceivedDate() != null)   timestamp=msg.getMessageReceivedDate();
 else   timestamp=hr.getTimestamp();
  if (msg.isOutgoing) {
    return new MessageDeliveredEvent(msg,contact,timestamp);
  }
 else   return new MessageReceivedEvent(msg,contact,timestamp);
}","/** 
 * Used to convert HistoryRecord in MessageDeliveredEvent or MessageReceivedEvent which are returned by the finder methods
 * @param hr HistoryRecord
 * @param contact Contact
 * @return Object
 */
private Object convertHistoryRecordToMessageEvent(HistoryRecord hr,Contact contact){
  MessageImpl msg=new MessageImpl(hr);
  Date timestamp=null;
  if (msg.getMessageReceivedDate() != null) {
    if (msg.getMessageReceivedDate().after(hr.getTimestamp()) && (msg.getMessageReceivedDate().getTime() - hr.getTimestamp().getTime()) > 86400000)     timestamp=hr.getTimestamp();
 else     timestamp=msg.getMessageReceivedDate();
  }
 else   timestamp=hr.getTimestamp();
  if (msg.isOutgoing) {
    return new MessageDeliveredEvent(msg,contact,timestamp);
  }
 else   return new MessageReceivedEvent(msg,contact,timestamp);
}",0.865424430641822
104562,"/** 
 * Constructs a new <tt>ProgressEvent</tt>.
 * @param source Object The source firing this event
 * @param startDate Date The start date in the search condition.
 * @param endDate Date The end date in the search condition.
 */
public ProgressEvent(Object source,Date startDate,Date endDate){
  this(source,startDate,endDate,null,-1,0);
}","/** 
 * Constructs a new <tt>ProgressEvent</tt>.
 * @param source Object The source firing this event
 * @param startDate Date The start date in the search condition.
 * @param endDate Date The end date in the search condition.
 */
public ProgressEvent(Object source,Date startDate,Date endDate){
  this(source,startDate,endDate,null,0);
}",0.9955947136563876
104563,"/** 
 * Handles the <tt>ActionEvent</tt> triggered when user clicks on one of the buttons in this toolbar.
 */
public void actionPerformed(ActionEvent e){
  JButton button=(JButton)e.getSource();
  String buttonName=button.getName();
  if (buttonName.equals(""String_Node_Str"")) {
    Wizard wizard=new Wizard();
    wizard.getDialog().setTitle(Messages.getString(""String_Node_Str""));
    NewContact newContact=new NewContact();
    AddContactWizardPage1 page1=new AddContactWizardPage1(wizard,newContact,mainFrame.getProtocolProviders());
    wizard.registerWizardPage(AddContactWizardPage1.IDENTIFIER,page1);
    AddContactWizardPage2 page2=new AddContactWizardPage2(wizard,newContact,mainFrame.getAllGroups());
    wizard.registerWizardPage(AddContactWizardPage2.IDENTIFIER,page2);
    AddContactWizardPage3 page3=new AddContactWizardPage3(newContact);
    wizard.registerWizardPage(AddContactWizardPage3.IDENTIFIER,page3);
    wizard.setCurrentPage(AddContactWizardPage1.IDENTIFIER);
    wizard.getDialog().setLocation(Toolkit.getDefaultToolkit().getScreenSize().width / 2 - 250,Toolkit.getDefaultToolkit().getScreenSize().height / 2 - 100);
    int returnCode=wizard.showModalDialog();
    if (returnCode == 0) {
      ArrayList ppList=newContact.getProtocolProviders();
      ArrayList groupList=newContact.getGroups();
      for (int i=0; i < ppList.size(); i++) {
        ProtocolProviderService pps=(ProtocolProviderService)ppList.get(i);
        for (int j=0; j < groupList.size(); j++) {
          MetaContactGroup group=(MetaContactGroup)groupList.get(j);
          try {
            mainFrame.getContactList().createMetaContact(pps,group,newContact.getUin());
          }
 catch (          MetaContactListException ex) {
            JOptionPane.showMessageDialog(mainFrame,Messages.getString(""String_Node_Str"",newContact.getUin()),Messages.getString(""String_Node_Str""),JOptionPane.WARNING_MESSAGE);
          }
        }
      }
    }
 else     if (returnCode == 1) {
      wizard.getDialog().dispose();
    }
  }
 else   if (buttonName.equals(""String_Node_Str"")) {
    configDialog=GuiActivator.getUIService().getConfigurationManager();
    configDialog.showDialog();
  }
 else   if (buttonName.equals(""String_Node_Str"")) {
    ContactList contactList=mainFrame.getTabbedPane().getContactListPanel().getContactList();
    ContactListModel listModel=(ContactListModel)contactList.getModel();
    if (listModel.showOffline()) {
      listModel.setShowOffline(false);
      listModel.removeOfflineContacts();
    }
 else {
      int currentlySelectedIndex=contactList.getSelectedIndex();
      Object selectedObject=listModel.getElementAt(currentlySelectedIndex);
      listModel.setShowOffline(true);
      listModel.addOfflineContacts();
      if (selectedObject != null) {
        if (selectedObject instanceof MetaContact) {
          contactList.setSelectedIndex(listModel.indexOf((MetaContact)selectedObject));
        }
 else {
          contactList.setSelectedIndex(listModel.indexOf((MetaContactGroup)selectedObject));
        }
      }
    }
  }
 else   if (buttonName.equals(""String_Node_Str"")) {
    MetaContact selectedMetaContact=(MetaContact)mainFrame.getTabbedPane().getContactListPanel().getContactList().getSelectedValue();
    if (selectedMetaContact != null) {
      Contact defaultContact=selectedMetaContact.getDefaultContact();
      ProtocolProviderService defaultProvider=defaultContact.getProtocolProvider();
      OperationSetWebContactInfo wContactInfo=mainFrame.getWebContactInfo(defaultProvider);
      CrossPlatformBrowserLauncher.openURL(wContactInfo.getWebContactInfo(defaultContact).toString());
    }
  }
}","/** 
 * Handles the <tt>ActionEvent</tt> triggered when user clicks on one of the buttons in this toolbar.
 */
public void actionPerformed(ActionEvent e){
  JButton button=(JButton)e.getSource();
  String buttonName=button.getName();
  if (buttonName.equals(""String_Node_Str"")) {
    Wizard wizard=new Wizard();
    wizard.getDialog().setTitle(Messages.getString(""String_Node_Str""));
    NewContact newContact=new NewContact();
    AddContactWizardPage1 page1=new AddContactWizardPage1(wizard,newContact,mainFrame.getProtocolProviders());
    wizard.registerWizardPage(AddContactWizardPage1.IDENTIFIER,page1);
    AddContactWizardPage2 page2=new AddContactWizardPage2(wizard,newContact,mainFrame.getAllGroups());
    wizard.registerWizardPage(AddContactWizardPage2.IDENTIFIER,page2);
    AddContactWizardPage3 page3=new AddContactWizardPage3(newContact);
    wizard.registerWizardPage(AddContactWizardPage3.IDENTIFIER,page3);
    wizard.setCurrentPage(AddContactWizardPage1.IDENTIFIER);
    wizard.getDialog().setLocation(Toolkit.getDefaultToolkit().getScreenSize().width / 2 - 250,Toolkit.getDefaultToolkit().getScreenSize().height / 2 - 100);
    int returnCode=wizard.showModalDialog();
    if (returnCode == 0) {
      ArrayList ppList=newContact.getProtocolProviders();
      ArrayList groupList=newContact.getGroups();
      for (int i=0; i < ppList.size(); i++) {
        ProtocolProviderService pps=(ProtocolProviderService)ppList.get(i);
        for (int j=0; j < groupList.size(); j++) {
          MetaContactGroup group=(MetaContactGroup)groupList.get(j);
          try {
            mainFrame.getContactList().createMetaContact(pps,group,newContact.getUin());
          }
 catch (          MetaContactListException ex) {
            JOptionPane.showMessageDialog(mainFrame,Messages.getString(""String_Node_Str"",newContact.getUin()),Messages.getString(""String_Node_Str""),JOptionPane.WARNING_MESSAGE);
          }
        }
      }
    }
 else     if (returnCode == 1) {
      wizard.getDialog().dispose();
    }
  }
 else   if (buttonName.equals(""String_Node_Str"")) {
    configDialog=GuiActivator.getUIService().getConfigurationManager();
    configDialog.showDialog();
  }
 else   if (buttonName.equals(""String_Node_Str"")) {
    ContactList contactList=mainFrame.getTabbedPane().getContactListPanel().getContactList();
    ContactListModel listModel=(ContactListModel)contactList.getModel();
    if (listModel.showOffline()) {
      listModel.setShowOffline(false);
      listModel.removeOfflineContacts();
    }
 else {
      Object selectedObject=null;
      int currentlySelectedIndex=contactList.getSelectedIndex();
      if (currentlySelectedIndex != -1) {
        selectedObject=listModel.getElementAt(currentlySelectedIndex);
      }
      listModel.setShowOffline(true);
      listModel.addOfflineContacts();
      if (selectedObject != null) {
        if (selectedObject instanceof MetaContact) {
          contactList.setSelectedIndex(listModel.indexOf((MetaContact)selectedObject));
        }
 else {
          contactList.setSelectedIndex(listModel.indexOf((MetaContactGroup)selectedObject));
        }
      }
    }
  }
 else   if (buttonName.equals(""String_Node_Str"")) {
    MetaContact selectedMetaContact=(MetaContact)mainFrame.getTabbedPane().getContactListPanel().getContactList().getSelectedValue();
    if (selectedMetaContact != null) {
      Contact defaultContact=selectedMetaContact.getDefaultContact();
      ProtocolProviderService defaultProvider=defaultContact.getProtocolProvider();
      OperationSetWebContactInfo wContactInfo=mainFrame.getWebContactInfo(defaultProvider);
      CrossPlatformBrowserLauncher.openURL(wContactInfo.getWebContactInfo(defaultContact).toString());
    }
  }
}",0.9085489771033736
104564,"/** 
 * Returns the screenname of this contact
 * @return this contact's screen name.
 */
public String getAlias(){
  return screenname.getFormatted();
}","/** 
 * Returns the screenname of this contact
 * @return this contact's screen name.
 */
public String getAlias(){
  return null;
}",0.9052631578947368
104565,"/** 
 * Called whnever an indication is received that a new server stored group is created.
 * @param evt a ServerStoredGroupEvent containing a reference to thenewly created group.
 */
public void groupCreated(ServerStoredGroupEvent evt){
synchronized (this) {
    Contact contact=evt.getSourceGroup().getContact(subscriptionAddress);
    if (sourceContact != null) {
      this.evt=evt;
      this.sourceContact=contact;
      this.notifyAll();
    }
  }
}","/** 
 * Called whnever an indication is received that a new server stored group is created.
 * @param evt a ServerStoredGroupEvent containing a reference to thenewly created group.
 */
public void groupCreated(ServerStoredGroupEvent evt){
synchronized (this) {
    Contact contact=evt.getSourceGroup().getContact(subscriptionAddress);
    if (contact != null) {
      this.evt=evt;
      this.sourceContact=contact;
      this.notifyAll();
    }
  }
}",0.9911894273127754
104566,"/** 
 * Initialized the service implementation, and puts it in a sate where it could interoperate with other services. It is strongly recomended that properties in this Map be mapped to property names as specified by <tt>AccountProperties</tt>.
 * @param screenname the account id/uin/screenname of the account that we'reabout to create
 * @param initializationProperties all properties needed fo initializing theaccount.
 * @param accountID the identifier of the account that this protocolprovider represents.
 * @see net.java.sip.communicator.service.protocol.AccountID
 */
protected void initialize(String screenname,Map initializationProperties,AccountID accountID){
synchronized (initializationLock) {
    this.accountID=accountID;
    String password=(String)initializationProperties.get(AccountProperties.PASSWORD);
    session=new DefaultAppSession();
    aimSession=session.openAimSession(new Screenname(screenname));
    aimConnection=aimSession.openConnection(new AimConnectionProperties(new Screenname(screenname),password));
    aimConnStateListener=new AimConnStateListener();
    aimConnection.addStateListener(aimConnStateListener);
    aimIcbmListener=new AimIcbmListener();
    OperationSetPersistentPresence persistentPresence=new OperationSetPersistentPresenceIcqImpl(this,screenname);
    supportedOperationSets.put(OperationSetPersistentPresence.class.getName(),persistentPresence);
    supportedOperationSets.put(OperationSetPresence.class.getName(),persistentPresence);
    OperationSetBasicInstantMessaging basicInstantMessaging=new OperationSetBasicInstantMessagingIcqImpl(this);
    supportedOperationSets.put(OperationSetBasicInstantMessaging.class.getName(),basicInstantMessaging);
    OperationSetTypingNotifications typingNotifications=new OperationSetTypingNotificationsIcqImpl(this);
    supportedOperationSets.put(OperationSetTypingNotifications.class.getName(),typingNotifications);
    this.infoRetreiver=new InfoRetreiver(this,screenname);
    OperationSetServerStoredContactInfo serverStoredContactInfo=new OperationSetServerStoredContactInfoIcqImpl(infoRetreiver);
    supportedOperationSets.put(OperationSetServerStoredContactInfo.class.getName(),serverStoredContactInfo);
    OperationSetServerStoredAccountInfo serverStoredAccountInfo=new OperationSetServerStoredAccountInfoIcqImpl(infoRetreiver,screenname,this);
    supportedOperationSets.put(OperationSetServerStoredAccountInfo.class.getName(),serverStoredAccountInfo);
    OperationSetWebAccountRegistration webAccountRegistration=new OperationSetWebAccountRegistrationIcqImpl();
    supportedOperationSets.put(OperationSetWebAccountRegistration.class.getName(),webAccountRegistration);
    OperationSetWebContactInfo webContactInfo=new OperationSetWebContactInfoIcqImpl();
    supportedOperationSets.put(OperationSetWebContactInfo.class.getName(),webContactInfo);
    isInitialized=true;
  }
}","/** 
 * Initialized the service implementation, and puts it in a sate where it could interoperate with other services. It is strongly recomended that properties in this Map be mapped to property names as specified by <tt>AccountProperties</tt>.
 * @param screenname the account id/uin/screenname of the account that we'reabout to create
 * @param initializationProperties all properties needed fo initializing theaccount.
 * @param accountID the identifier of the account that this protocolprovider represents.
 * @see net.java.sip.communicator.service.protocol.AccountID
 */
protected void initialize(String screenname,Map initializationProperties,AccountID accountID){
synchronized (initializationLock) {
    this.accountID=accountID;
    OperationSetPersistentPresence persistentPresence=new OperationSetPersistentPresenceIcqImpl(this,screenname);
    supportedOperationSets.put(OperationSetPersistentPresence.class.getName(),persistentPresence);
    supportedOperationSets.put(OperationSetPresence.class.getName(),persistentPresence);
    OperationSetBasicInstantMessaging basicInstantMessaging=new OperationSetBasicInstantMessagingIcqImpl(this);
    supportedOperationSets.put(OperationSetBasicInstantMessaging.class.getName(),basicInstantMessaging);
    OperationSetTypingNotifications typingNotifications=new OperationSetTypingNotificationsIcqImpl(this);
    supportedOperationSets.put(OperationSetTypingNotifications.class.getName(),typingNotifications);
    this.infoRetreiver=new InfoRetreiver(this,screenname);
    OperationSetServerStoredContactInfo serverStoredContactInfo=new OperationSetServerStoredContactInfoIcqImpl(infoRetreiver);
    supportedOperationSets.put(OperationSetServerStoredContactInfo.class.getName(),serverStoredContactInfo);
    OperationSetServerStoredAccountInfo serverStoredAccountInfo=new OperationSetServerStoredAccountInfoIcqImpl(infoRetreiver,screenname,this);
    supportedOperationSets.put(OperationSetServerStoredAccountInfo.class.getName(),serverStoredAccountInfo);
    OperationSetWebAccountRegistration webAccountRegistration=new OperationSetWebAccountRegistrationIcqImpl();
    supportedOperationSets.put(OperationSetWebAccountRegistration.class.getName(),webAccountRegistration);
    OperationSetWebContactInfo webContactInfo=new OperationSetWebContactInfoIcqImpl();
    supportedOperationSets.put(OperationSetWebContactInfo.class.getName(),webContactInfo);
    isInitialized=true;
  }
}",0.9145539906103286
104567,"/** 
 * Starts the registration process. Connection details such as registration server, user name/number are provided through the configuration service through implementation specific properties.
 * @param authority the security authority that will be used for resolvingany security challenges that may be returned during the registration or at any moment while wer're registered.
 */
public void register(SecurityAuthority authority){
  aimConnection.connect();
}","/** 
 * Starts the registration process. Connection details such as registration server, user name/number are provided through the configuration service through implementation specific properties.
 * @param authority the security authority that will be used for resolvingany security challenges that may be returned during the registration or at any moment while wer're registered.
 */
public void register(SecurityAuthority authority){
synchronized (initializationLock) {
    String accountPrefix=IcqActivator.getProtocolProviderFactory().findAccountPrefix(getAccountID());
    String password=IcqActivator.getConfigurationService().getString(accountPrefix + ""String_Node_Str"" + ProtocolProviderFactory.PASSWORD);
    if (password != null) {
      password=new String(Base64.decode(password));
    }
 else {
    }
    session=new DefaultAppSession();
    aimSession=session.openAimSession(new Screenname(getAccountID().getUserID()));
    aimConnection=aimSession.openConnection(new AimConnectionProperties(new Screenname(getAccountID().getUserID()),password));
    aimConnStateListener=new AimConnStateListener();
    aimConnection.addStateListener(aimConnStateListener);
    aimConnection.connect();
  }
}",0.5311004784688995
104568,"public Component getTableCellRendererComponent(JTable table,Object value,boolean isSelected,boolean hasFocus,int row,int column){
  if (value instanceof JLabel) {
    JLabel labelValue=(JLabel)value;
    label.setText(labelValue.getText());
    label.setIcon(labelValue.getIcon());
  }
 else   if (value instanceof ProtocolProviderService) {
    ProtocolProviderService pps=(ProtocolProviderService)value;
    label.setText(pps.getAccountID().getAccountUserID());
  }
 else   if (value instanceof MetaContactGroup) {
    MetaContactGroup group=(MetaContactGroup)value;
    label.setText(group.getGroupName());
  }
 else {
    label.setText(value.toString());
  }
  if (isSelected)   this.setBackground(Constants.SELECTED_END_COLOR);
  return this;
}","public Component getTableCellRendererComponent(JTable table,Object value,boolean isSelected,boolean hasFocus,int row,int column){
  if (value instanceof JLabel) {
    JLabel labelValue=(JLabel)value;
    label.setText(labelValue.getText());
    label.setIcon(labelValue.getIcon());
  }
 else   if (value instanceof ProtocolProviderService) {
    ProtocolProviderService pps=(ProtocolProviderService)value;
    label.setText(pps.getAccountID().getAccountUserID());
  }
 else   if (value instanceof MetaContactGroup) {
    MetaContactGroup group=(MetaContactGroup)value;
    label.setText(group.getGroupName());
  }
 else {
    label.setText(value.toString());
  }
  if (isSelected)   this.setBackground(Constants.SELECTED_END_COLOR);
 else   this.setBackground(UIManager.getColor(""String_Node_Str""));
  return this;
}",0.9482428115015974
104569,"public void actionPerformed(ActionEvent e){
  JButton button=(JButton)e.getSource();
  String name=button.getName();
  if (name.equals(""String_Node_Str"")) {
    if (metaContact != null) {
      this.clist.renameMetaContact(metaContact,renameContactPanel.getName());
    }
    this.dispose();
  }
 else {
    this.dispose();
  }
}","public void actionPerformed(ActionEvent e){
  JButton button=(JButton)e.getSource();
  String name=button.getName();
  if (name.equals(""String_Node_Str"")) {
    if (metaContact != null) {
      this.clist.renameMetaContact(metaContact,renameContactPanel.getNewName());
    }
    this.dispose();
  }
 else {
    this.dispose();
  }
}",0.9954614220877458
104570,"public static void loadAdiumStyle(){
  try {
    File is=new File(Constants.class.getClassLoader().getResource(DEFAULT_STYLE_PATH + ""String_Node_Str"").toURI());
    System.out.println(""String_Node_Str"" + is);
  }
 catch (  URISyntaxException e) {
    logger.error(""String_Node_Str"",e);
  }
}","public static void loadAdiumStyle(){
  File is=new File(Constants.class.getClassLoader().getResource(DEFAULT_STYLE_PATH + ""String_Node_Str"").toString());
  System.out.println(""String_Node_Str"" + is);
}",0.7926829268292683
104571,"/** 
 * Called by joust sim to notify us that a new buddy has been added to the contact list.
 * @param list the <tt>BuddyList</tt> owning the newly added buddy.
 * @param joustSimGroup the parent group of the added buddy.
 * @param oldItems unused
 * @param newItems unused
 * @param buddy the newly added <tt>buddy</tt>
 */
public void buddyAdded(BuddyList list,Group joustSimGroup,List oldItems,List newItems,Buddy buddy){
  ContactGroupIcqImpl oldParentGroup=null;
  ContactIcqImpl newContact=findContactByScreenName(buddy.getScreenname().getFormatted());
  if (newContact == null) {
    newContact=new ContactIcqImpl(buddy,ServerStoredContactListIcqImpl.this,true);
  }
 else {
    oldParentGroup=findContactGroup(newContact);
    newContact.setJoustSimBuddy(buddy);
    newContact.setPersistent(true);
  }
  ContactGroupIcqImpl parentGroup=findContactGroup(joustSimGroup);
  if (parentGroup == null) {
    logger.debug(""String_Node_Str"" + joustSimGroup + ""String_Node_Str""+ buddy);
    return;
  }
  int buddyIndex=newItems.indexOf(buddy);
  if (buddyIndex == -1) {
    logger.debug(buddy + ""String_Node_Str"" + newItems);
  }
  int insertPos=0;
  if (buddyIndex == 0) {
    parentGroup.addContact(insertPos,newContact);
  }
 else {
    for (; buddyIndex >= 0; buddyIndex--) {
      int prevContactIndex=parentGroup.findContactIndex((Buddy)newItems.get(buddyIndex));
      if (prevContactIndex != -1)       insertPos=prevContactIndex + 1;
    }
    parentGroup.addContact(insertPos,newContact);
  }
  buddy.addBuddyListener(jsimBuddyListener);
  if (oldParentGroup == null) {
    fireContactAdded(parentGroup,newContact,insertPos);
  }
 else {
    fireContactMoved(oldParentGroup,parentGroup,newContact,insertPos);
  }
}","/** 
 * Called by joust sim to notify us that a new buddy has been added to the contact list.
 * @param list the <tt>BuddyList</tt> owning the newly added buddy.
 * @param joustSimGroup the parent group of the added buddy.
 * @param oldItems unused
 * @param newItems unused
 * @param buddy the newly added <tt>buddy</tt>
 */
public void buddyAdded(BuddyList list,Group joustSimGroup,List oldItems,List newItems,Buddy buddy){
  ContactGroupIcqImpl oldParentGroup=null;
  ContactIcqImpl newContact=findContactByScreenName(buddy.getScreenname().getFormatted());
  if (newContact == null) {
    newContact=new ContactIcqImpl(buddy,ServerStoredContactListIcqImpl.this,true);
  }
 else {
    oldParentGroup=findContactGroup(newContact);
    oldParentGroup.removeContact(newContact);
    newContact.setJoustSimBuddy(buddy);
    newContact.setPersistent(true);
  }
  ContactGroupIcqImpl parentGroup=findContactGroup(joustSimGroup);
  if (parentGroup == null) {
    logger.debug(""String_Node_Str"" + joustSimGroup + ""String_Node_Str""+ buddy);
    return;
  }
  int buddyIndex=newItems.indexOf(buddy);
  if (buddyIndex == -1) {
    logger.debug(buddy + ""String_Node_Str"" + newItems);
  }
  int insertPos=0;
  if (buddyIndex == 0) {
    parentGroup.addContact(insertPos,newContact);
  }
 else {
    for (; buddyIndex >= 0; buddyIndex--) {
      int prevContactIndex=parentGroup.findContactIndex((Buddy)newItems.get(buddyIndex));
      if (prevContactIndex != -1)       insertPos=prevContactIndex + 1;
    }
    parentGroup.addContact(insertPos,newContact);
  }
  buddy.addBuddyListener(jsimBuddyListener);
  if (oldParentGroup == null) {
    fireContactAdded(parentGroup,newContact,insertPos);
  }
 else {
    fireContactMoved(oldParentGroup,parentGroup,newContact,insertPos);
  }
}",0.986842105263158
104572,"public void actionPerformed(ActionEvent e){
  JButton button=(JButton)e.getSource();
  String buttonName=button.getName();
  if (buttonName.equals(""String_Node_Str"")) {
  }
 else   if (buttonName.equals(""String_Node_Str"")) {
    mainFrame.getConfigFrame().setCalculatedSize();
    mainFrame.getConfigFrame().setVisible(true);
  }
 else   if (buttonName.equals(""String_Node_Str"")) {
    ContactListModel listModel=(ContactListModel)mainFrame.getTabbedPane().getContactListPanel().getContactList().getModel();
    if (listModel.showOffline()) {
      listModel.setShowOffline(false);
      listModel.removeOfflineContacts();
    }
 else {
      listModel.setShowOffline(true);
      listModel.addOfflineContacts();
    }
  }
 else   if (buttonName.equals(""String_Node_Str"")) {
  }
}","public void actionPerformed(ActionEvent e){
  JButton button=(JButton)e.getSource();
  String buttonName=button.getName();
  if (buttonName.equals(""String_Node_Str"")) {
  }
 else   if (buttonName.equals(""String_Node_Str"")) {
    mainFrame.getConfigFrame().setCalculatedSize();
    mainFrame.getConfigFrame().setVisible(true);
  }
 else   if (buttonName.equals(""String_Node_Str"")) {
    ContactList contactList=mainFrame.getTabbedPane().getContactListPanel().getContactList();
    ContactListModel listModel=(ContactListModel)contactList.getModel();
    if (listModel.showOffline()) {
      listModel.setShowOffline(false);
      listModel.removeOfflineContacts();
    }
 else {
      int currentlySelectedIndex=contactList.getSelectedIndex();
      Object selectedObject=listModel.getElementAt(currentlySelectedIndex);
      listModel.setShowOffline(true);
      listModel.addOfflineContacts();
      if (selectedObject != null) {
        if (selectedObject instanceof MetaContact) {
          contactList.setSelectedIndex(listModel.indexOf((MetaContact)selectedObject));
        }
 else {
          contactList.setSelectedIndex(listModel.indexOf((MetaContactGroup)selectedObject));
        }
      }
    }
  }
 else   if (buttonName.equals(""String_Node_Str"")) {
  }
}",0.708984375
104573,"public Component getListCellRendererComponent(JList list,Object value,int index,boolean isSelected,boolean cellHasFocus){
  ContactList contactList=(ContactList)list;
  ContactListModel listModel=(ContactListModel)contactList.getModel();
  if (value instanceof MetaContact) {
    MetaContact contactItem=(MetaContact)value;
    String toolTipText=""String_Node_Str"" + contactItem.getDisplayName();
    this.nameLabel.setText(contactItem.getDisplayName());
    this.nameLabel.setIcon(listModel.getMetaContactStatusIcon(contactItem));
    this.nameLabel.setFont(this.getFont().deriveFont(Font.PLAIN));
    this.setBorder(BorderFactory.createEmptyBorder(1,1,1,1));
    this.setBounds(0,0,list.getWidth() - 2,17);
    this.buttonsPanel.removeAll();
    Iterator i=contactItem.getContacts();
    int buttonsPanelWidth=0;
    while (i.hasNext()) {
      Contact protocolContact=(Contact)i.next();
      String protocolName=protocolContact.getProtocolProvider().getProtocolName();
      Image protocolStatusIcon=(Image)Constants.getProtocolStatusIcons(protocolName).get(protocolContact.getPresenceStatus());
      ContactProtocolButton contactProtocolButton=new ContactProtocolButton(protocolStatusIcon,protocolStatusIcon);
      contactProtocolButton.setProtocolContact(protocolContact);
      contactProtocolButton.setSize(protocolStatusIcon.getWidth(null),protocolStatusIcon.getHeight(null));
      this.buttonsPanel.add(contactProtocolButton);
      buttonsPanelWidth+=contactProtocolButton.getWidth();
    }
    this.add(buttonsPanel,BorderLayout.EAST);
    toolTipText+=""String_Node_Str"";
    this.setToolTipText(toolTipText);
    this.isLeaf=true;
  }
 else   if (value instanceof MetaContactGroup) {
    MetaContactGroup groupItem=(MetaContactGroup)value;
    this.nameLabel.setText(groupItem.getGroupName());
    this.nameLabel.setIcon(new ImageIcon(ImageLoader.getImage(ImageLoader.GROUPS_16x16_ICON)));
    this.nameLabel.setFont(this.getFont().deriveFont(Font.BOLD));
    this.setBorder(BorderFactory.createEmptyBorder(2,2,2,2));
    this.setBounds(0,0,list.getWidth() - 2,20);
    this.remove(buttonsPanel);
    this.isLeaf=false;
  }
  this.isSelected=isSelected;
  return this;
}","public Component getListCellRendererComponent(JList list,Object value,int index,boolean isSelected,boolean cellHasFocus){
  ContactList contactList=(ContactList)list;
  ContactListModel listModel=(ContactListModel)contactList.getModel();
  if (value instanceof MetaContact) {
    MetaContact contactItem=(MetaContact)value;
    String toolTipText=""String_Node_Str"" + contactItem.getDisplayName();
    this.nameLabel.setText(contactItem.getDisplayName());
    this.nameLabel.setIcon(listModel.getMetaContactStatusIcon(contactItem));
    this.nameLabel.setFont(this.getFont().deriveFont(Font.PLAIN));
    this.setBorder(BorderFactory.createEmptyBorder(1,1,1,1));
    this.setBounds(0,0,list.getWidth() - 2,17);
    this.buttonsPanel.removeAll();
    Iterator i=contactItem.getContacts();
    int buttonsPanelWidth=0;
    while (i.hasNext()) {
      Contact protocolContact=(Contact)i.next();
      String protocolName=protocolContact.getProtocolProvider().getProtocolName();
      Image protocolStatusIcon=(Image)Constants.getProtocolStatusIcons(protocolName).get(protocolContact.getPresenceStatus());
      ContactProtocolButton contactProtocolButton=new ContactProtocolButton(protocolStatusIcon,protocolStatusIcon);
      contactProtocolButton.setProtocolContact(protocolContact);
      contactProtocolButton.setSize(protocolStatusIcon.getWidth(null),protocolStatusIcon.getHeight(null));
      this.buttonsPanel.add(contactProtocolButton);
      buttonsPanelWidth+=contactProtocolButton.getWidth();
    }
    this.add(buttonsPanel,BorderLayout.EAST);
    toolTipText+=""String_Node_Str"";
    this.setToolTipText(toolTipText);
    this.isLeaf=true;
  }
 else   if (value instanceof MetaContactGroup) {
    MetaContactGroup groupItem=(MetaContactGroup)value;
    this.nameLabel.setText(groupItem.getGroupName() + ""String_Node_Str"" + groupItem.countChildContacts()+ ""String_Node_Str"");
    this.nameLabel.setIcon(new ImageIcon(ImageLoader.getImage(ImageLoader.GROUPS_16x16_ICON)));
    this.nameLabel.setFont(this.getFont().deriveFont(Font.BOLD));
    this.setBorder(BorderFactory.createEmptyBorder(2,2,2,2));
    this.setBounds(0,0,list.getWidth() - 2,20);
    this.remove(buttonsPanel);
    this.isLeaf=false;
  }
  this.isSelected=isSelected;
  return this;
}",0.9837983798379838
104574,"/** 
 * Removes all offline contacts from the contact list.
 */
public void removeOfflineContacts(){
  Vector offlineContactsCopy=new Vector();
  int size=this.getSize();
  for (int i=0; i < size; i++) {
    Object element=this.getElementAt(i);
    if (element instanceof MetaContact) {
      MetaContact contactNode=(MetaContact)element;
      if (!getMetaContactStatus(contactNode).isOnline()) {
        int index=indexOf(contactNode);
        this.contentRemoved(index,index);
        offlineContactsCopy.add(contactNode);
      }
    }
  }
  this.offlineContacts=offlineContactsCopy;
}","/** 
 * Removes all offline contacts from the contact list.
 */
public void removeOfflineContacts(){
  Vector offlineContactsCopy=new Vector();
  int size=this.getSize();
  for (int i=0; i < size; i++) {
    Object element=this.getElementAt(i);
    if (element instanceof MetaContact) {
      MetaContact contactNode=(MetaContact)element;
      if (!getMetaContactStatus(contactNode).isOnline()) {
        int index=indexOf(contactNode);
        this.contentRemoved(index,index);
        offlineContactsCopy.add(contactNode);
      }
    }
  }
  for (int j=0; j < closedGroups.size(); j++) {
    MetaContactGroup closedGroup=(MetaContactGroup)closedGroups.get(j);
    removeClosedOfflineContacts(closedGroup,offlineContactsCopy);
  }
  this.offlineContacts=offlineContactsCopy;
}",0.8611111111111112
104575,"/** 
 * Closes the given group by hiding all containing contacts.
 * @param group The group to close.
 */
public void closeGroup(MetaContactGroup group){
  contentRemoved(this.indexOf(group.getMetaContact(0)),this.indexOf(group.getMetaContact(group.countChildContacts() - 1)));
  this.closedGroups.add(group);
}","/** 
 * Closes the given group by hiding all containing contacts.
 * @param group The group to close.
 */
public void closeGroup(MetaContactGroup group){
  if (countSubgroupContacts(group) > 0) {
    contentRemoved(this.indexOf(group.getMetaContact(0)),this.indexOf(group.getMetaContact(countSubgroupContacts(group) - 1)));
    this.closedGroups.add(group);
  }
}",0.8486646884272997
104576,"/** 
 * Opens the given group by showing all containing contacts.
 * @param group The group to open.
 */
public void openGroup(MetaContactGroup group){
  this.closedGroups.remove(group);
  contentAdded(this.indexOf(group.getMetaContact(0)),this.indexOf(group.getMetaContact(group.countChildContacts() - 1)));
}","/** 
 * Opens the given group by showing all containing contacts.
 * @param group The group to open.
 */
public void openGroup(MetaContactGroup group){
  this.closedGroups.remove(group);
  contentAdded(this.indexOf(group.getMetaContact(0)),this.indexOf(group.getMetaContact(countSubgroupContacts(group) - 1)));
}",0.919614147909968
104577,"/** 
 * Adds all offline contacts back to the contact list.
 */
public void addOfflineContacts(){
  Vector contacts=(Vector)this.offlineContacts.clone();
  this.offlineContacts.removeAllElements();
  for (int i=0; i < contacts.size(); i++) {
    MetaContact contact=(MetaContact)contacts.get(i);
    this.offlineContacts.remove(contact);
    int index=this.indexOf(contact);
    contentAdded(index,index);
  }
}","/** 
 * Adds all offline contacts back to the contact list.
 */
public void addOfflineContacts(){
  Vector contacts=(Vector)this.offlineContacts.clone();
  this.offlineContacts.removeAllElements();
  for (int i=0; i < contacts.size(); i++) {
    MetaContact contact=(MetaContact)contacts.get(i);
    if (!isGroupClosed(contact.getParentMetaContactGroup())) {
      int index=this.indexOf(contact);
      contentAdded(index,index);
    }
  }
}",0.8745603751465416
104578,"/** 
 * Indicates that a MetaContactGroup has been added.
 * @param evt The MetaContactGroupEvent event.
 */
public void metaContactGroupAdded(MetaContactGroupEvent evt){
  MetaContactGroup sourceGroup=evt.getSourceMetaContactGroup();
  this.groupAdded(sourceGroup);
  this.ensureIndexIsVisible(0);
}","/** 
 * Indicates that a MetaContactGroup has been added.
 * @param evt The MetaContactGroupEvent event.
 */
public void metaContactGroupAdded(MetaContactGroupEvent evt){
  MetaContactGroup sourceGroup=evt.getSourceMetaContactGroup();
  this.groupAdded(sourceGroup);
  this.revalidate();
}",0.9473684210526316
104579,"/** 
 * Creates an instance of this operation set.
 * @param icqProvider a ref to the <tt>ProtocolProviderServiceIcqImpl</tt>that created us and that we'll use for retrieving the underlying aim connection.
 */
OperationSetBasicInstantMessagingIcqImpl(ProtocolProviderServiceIcqImpl icqProvider){
  this.icqProvider=icqProvider;
  icqProvider.addRegistrationStateChangeListener(providerRegListener);
}","/** 
 * Creates an instance of this operation set.
 * @param icqProvider a ref to the <tt>ProtocolProviderServiceIcqImpl</tt>that created us and that we'll use for retrieving the underlying aim connection.
 */
OperationSetBasicInstantMessagingIcqImpl(ProtocolProviderServiceIcqImpl icqProvider){
  this.icqProvider=icqProvider;
  icqProvider.addRegistrationStateChangeListener(providerRegListener);
  channelFourCmdFactory.addCommandHandler(IcbmChannelFourCommand.MTYPE_PLAIN,new PlainMessageHandler());
}",0.8839779005524862
104580,"/** 
 * The method is called by a ProtocolProvider implementation whenver a change in the registration state of the corresponding provider had occurred.
 * @param evt ProviderStatusChangeEvent the event describing the statuschange.
 */
public void registrationStateChanged(RegistrationStateChangeEvent evt){
  logger.debug(""String_Node_Str"" + evt.getOldState() + ""String_Node_Str""+ evt.getNewState());
  if (evt.getNewState() == RegistrationState.REGISTERED) {
    System.out.println(""String_Node_Str"");
    icqProvider.getAimConnection().getIcbmService().addIcbmListener(joustSimIcbmListener);
    opSetPersPresence=(OperationSetPersistentPresenceIcqImpl)icqProvider.getSupportedOperationSets().get(OperationSetPersistentPresence.class.getName());
    retreiveOfflineMessages();
  }
}","/** 
 * The method is called by a ProtocolProvider implementation whenver a change in the registration state of the corresponding provider had occurred.
 * @param evt ProviderStatusChangeEvent the event describing the statuschange.
 */
public void registrationStateChanged(RegistrationStateChangeEvent evt){
  logger.debug(""String_Node_Str"" + evt.getOldState() + ""String_Node_Str""+ evt.getNewState());
  if (evt.getNewState() == RegistrationState.REGISTERED) {
    System.out.println(""String_Node_Str"");
    icqProvider.getAimConnection().getIcbmService().addIcbmListener(joustSimIcbmListener);
    opSetPersPresence=(OperationSetPersistentPresenceIcqImpl)icqProvider.getSupportedOperationSets().get(OperationSetPersistentPresence.class.getName());
    icqProvider.getAimConnection().getIcbmService().getOscarConnection().getSnacProcessor().getCmdFactoryMgr().getDefaultFactoryList().registerAll(channelFourCmdFactory);
    retreiveOfflineMessages();
  }
}",0.9017805858701896
104581,"/** 
 * Adds the specified group to the end of the list of sub groups.
 * @param group the group to add.
 */
void addSubGroup(ContactGroupIcqImpl group){
  addSubGroup(countContacts(),group);
}","/** 
 * Adds the specified group to the end of the list of sub groups.
 * @param group the group to add.
 */
void addSubGroup(ContactGroupIcqImpl group){
  addSubGroup(countContacts() + countSubgroups(),group);
}",0.9530864197530864
104582,"/** 
 * Updates the status of the given metacontact in all opened chats containing this contact.
 * @param metaContact
 */
public void updateChatContactStatus(MetaContact metaContact){
  ContactListModel listModel=(ContactListModel)this.getContactList().getModel();
  if (!Constants.TABBED_CHAT_WINDOW) {
  }
 else   if (tabbedChatWindow != null && tabbedChatWindow.getTabCount() > 0) {
    Hashtable contactTabsTable=tabbedChatWindow.getContactTabsTable();
    ChatPanel chatPanel=(ChatPanel)contactTabsTable.get(metaContact.getMetaUID());
    if (chatPanel != null) {
      tabbedChatWindow.setTabIcon(metaContact,listModel.getMetaContactStatusIcon(metaContact));
      chatPanel.updateContactStatus(listModel.getMetaContactStatus(metaContact));
    }
  }
}","/** 
 * Updates the status of the given metacontact in all opened chats containing this contact.
 * @param metaContact
 */
public void updateChatContactStatus(MetaContact metaContact){
  ContactListModel listModel=(ContactListModel)this.getContactList().getModel();
  if (!Constants.TABBED_CHAT_WINDOW) {
    if (contactMsgWindows.containsKey(metaContact)) {
      ChatWindow msgWindow=(ChatWindow)contactMsgWindows.get(metaContact);
      msgWindow.getCurrentChatPanel().updateContactStatus(listModel.getMetaContactStatus(metaContact));
    }
  }
 else   if (tabbedChatWindow != null) {
    Hashtable contactTabsTable=tabbedChatWindow.getContactTabsTable();
    ChatPanel chatPanel=(ChatPanel)contactTabsTable.get(metaContact.getMetaUID());
    if (chatPanel != null) {
      if (tabbedChatWindow.getTabCount() > 0) {
        tabbedChatWindow.setTabIcon(metaContact,listModel.getMetaContactStatusIcon(metaContact));
      }
      chatPanel.updateContactStatus(listModel.getMetaContactStatus(metaContact));
    }
  }
}",0.8103545301069218
104583,"public void actionPerformed(ActionEvent e){
  MsgToolbarButton button=(MsgToolbarButton)e.getSource();
  String buttonText=button.getName();
  if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
  }
 else   if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
  }
 else   if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
    JEditorPane editorPane=this.messageWindow.getCurrentChatWritePanel().getEditorPane();
    editorPane.cut();
  }
 else   if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
    JEditorPane editorPane=this.messageWindow.getCurrentConversationPanel().getChatEditorPane();
    if (editorPane.getSelectedText() == null) {
      editorPane=this.messageWindow.getCurrentChatWritePanel().getEditorPane();
    }
    editorPane.copy();
  }
 else   if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
    JEditorPane editorPane=this.messageWindow.getCurrentChatWritePanel().getEditorPane();
    editorPane.paste();
  }
 else   if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
    if (e.getSource() instanceof SIPCommButton) {
      SmiliesSelectorBox smiliesBox=new SmiliesSelectorBox(ImageLoader.getDefaultSmiliesPack());
      if (!smiliesBox.isVisible()) {
        smiliesBox.setInvoker((Component)e.getSource());
        smiliesBox.setMessageWindow(this.messageWindow);
        smiliesBox.setLocation(smiliesBox.getPopupLocation());
        smiliesBox.setVisible(true);
      }
    }
  }
 else   if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
  }
 else   if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
  }
 else   if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
  }
 else   if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
    HistoryWindow history=new HistoryWindow();
    history.setContacts(messageWindow.getCurrentChatPanel().getChatContacts());
    history.setVisible(true);
  }
 else   if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
  }
}","public void actionPerformed(ActionEvent e){
  MsgToolbarButton button=(MsgToolbarButton)e.getSource();
  String buttonText=button.getName();
  if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
  }
 else   if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
  }
 else   if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
    JEditorPane editorPane=this.messageWindow.getCurrentChatWritePanel().getEditorPane();
    editorPane.cut();
  }
 else   if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
    JEditorPane editorPane=this.messageWindow.getCurrentConversationPanel().getChatEditorPane();
    if (editorPane.getSelectedText() == null) {
      editorPane=this.messageWindow.getCurrentChatWritePanel().getEditorPane();
    }
    editorPane.copy();
  }
 else   if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
    JEditorPane editorPane=this.messageWindow.getCurrentChatWritePanel().getEditorPane();
    editorPane.paste();
    editorPane.requestFocus();
  }
 else   if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
    if (e.getSource() instanceof SIPCommButton) {
      SmiliesSelectorBox smiliesBox=new SmiliesSelectorBox(ImageLoader.getDefaultSmiliesPack());
      if (!smiliesBox.isVisible()) {
        smiliesBox.setInvoker((Component)e.getSource());
        smiliesBox.setMessageWindow(this.messageWindow);
        smiliesBox.setLocation(smiliesBox.getPopupLocation());
        smiliesBox.setVisible(true);
      }
    }
  }
 else   if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
  }
 else   if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
  }
 else   if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
  }
 else   if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
    HistoryWindow history=new HistoryWindow();
    history.setContacts(messageWindow.getCurrentChatPanel().getChatContacts());
    history.setVisible(true);
  }
 else   if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
  }
}",0.9919543213080716
104584,"/** 
 * Paints the bar of the scroll bar.
 */
protected void paintThumb(Graphics g,JComponent c,Rectangle thumbBounds){
  if (!c.isEnabled()) {
    return;
  }
  boolean leftToRight=c.getComponentOrientation().isLeftToRight();
  g.translate(thumbBounds.x,thumbBounds.y);
  int imgWidth;
  int imgHeight;
  int indentWidth=10;
  if (scrollbar.getOrientation() == JScrollBar.VERTICAL) {
    if (!isFreeStanding) {
      thumbBounds.width+=2;
      if (!leftToRight) {
        g.translate(-1,0);
      }
    }
    imgWidth=verticalThumb.getWidth();
    imgHeight=verticalThumb.getHeight();
    Image topImage=verticalThumb.getSubimage(0,0,imgWidth,indentWidth);
    Image middleImage=verticalThumb.getSubimage(0,indentWidth,imgWidth,imgHeight - 2 * indentWidth);
    Image bottomImage=verticalThumb.getSubimage(0,imgHeight - indentWidth,imgWidth,indentWidth);
    g.drawImage(topImage,0,0,thumbBounds.width - 2,indentWidth,null);
    g.drawImage(middleImage,thumbBounds.x,indentWidth,thumbBounds.width - 2,thumbBounds.height - indentWidth,null);
    g.drawImage(bottomImage,thumbBounds.x,thumbBounds.height - indentWidth,thumbBounds.width - 2,indentWidth,null);
    g.drawImage(verticalThumbHandle,thumbBounds.width / 2 - verticalThumbHandle.getWidth() / 2,thumbBounds.height / 2 - verticalThumbHandle.getHeight() / 2,verticalThumbHandle.getWidth(),verticalThumbHandle.getHeight(),null);
    if (!isFreeStanding) {
      thumbBounds.width-=2;
      if (!leftToRight) {
        g.translate(1,0);
      }
    }
  }
 else {
    if (!isFreeStanding) {
      thumbBounds.height+=2;
    }
    imgWidth=horizontalThumb.getWidth();
    imgHeight=horizontalThumb.getHeight();
    Image leftImage=horizontalThumb.getSubimage(0,0,indentWidth,imgHeight);
    Image middleImage=horizontalThumb.getSubimage(indentWidth,0,imgWidth - 2 * indentWidth,imgHeight);
    Image rightImage=horizontalThumb.getSubimage(imgWidth - indentWidth,0,indentWidth,imgHeight);
    g.drawImage(leftImage,0,0,indentWidth,thumbBounds.height,null);
    g.drawImage(middleImage,thumbBounds.x + indentWidth,thumbBounds.y,thumbBounds.width - 2 * indentWidth,thumbBounds.height,null);
    g.drawImage(rightImage,thumbBounds.width - indentWidth,thumbBounds.y,indentWidth,thumbBounds.height,null);
    g.drawImage(horizontalThumbHandle,thumbBounds.width / 2 - horizontalThumbHandle.getWidth() / 2,thumbBounds.height / 2 - horizontalThumbHandle.getHeight() / 2,horizontalThumbHandle.getWidth(),horizontalThumbHandle.getHeight(),null);
    if (!isFreeStanding) {
      thumbBounds.height-=2;
    }
  }
  g.translate(-thumbBounds.x,-thumbBounds.y);
}","/** 
 * Paints the bar of the scroll bar.
 */
protected void paintThumb(Graphics g,JComponent c,Rectangle thumbBounds){
  if (!c.isEnabled()) {
    return;
  }
  boolean leftToRight=c.getComponentOrientation().isLeftToRight();
  g.translate(thumbBounds.x,thumbBounds.y);
  int imgWidth;
  int imgHeight;
  int indentWidth=10;
  if (scrollbar.getOrientation() == JScrollBar.VERTICAL) {
    if (!isFreeStanding) {
      thumbBounds.width+=2;
      if (!leftToRight) {
        g.translate(-1,0);
      }
    }
    imgWidth=verticalThumb.getWidth();
    imgHeight=verticalThumb.getHeight();
    Image topImage=verticalThumb.getSubimage(0,0,imgWidth,indentWidth);
    Image middleImage=verticalThumb.getSubimage(0,indentWidth,imgWidth,imgHeight - 2 * indentWidth);
    Image bottomImage=verticalThumb.getSubimage(0,imgHeight - indentWidth,imgWidth,indentWidth);
    g.drawImage(topImage,0,0,thumbBounds.width - 2,indentWidth,null);
    g.drawImage(middleImage,thumbBounds.x,indentWidth,thumbBounds.width - 2,thumbBounds.height - indentWidth,null);
    g.drawImage(bottomImage,thumbBounds.x,thumbBounds.height - indentWidth,thumbBounds.width - 2,indentWidth,null);
    g.drawImage(verticalThumbHandle,thumbBounds.width / 2 - verticalThumbHandle.getWidth() / 2,thumbBounds.height / 2 - verticalThumbHandle.getHeight() / 2,verticalThumbHandle.getWidth(),verticalThumbHandle.getHeight(),null);
    if (!isFreeStanding) {
      thumbBounds.width-=2;
      if (!leftToRight) {
        g.translate(1,0);
      }
    }
  }
 else {
    if (!isFreeStanding) {
      thumbBounds.height+=2;
    }
    imgWidth=horizontalThumb.getWidth();
    imgHeight=horizontalThumb.getHeight();
    Image leftImage=horizontalThumb.getSubimage(0,0,indentWidth,imgHeight);
    Image middleImage=horizontalThumb.getSubimage(indentWidth,0,imgWidth - 2 * indentWidth,imgHeight);
    Image rightImage=horizontalThumb.getSubimage(imgWidth - indentWidth,0,indentWidth,imgHeight);
    g.drawImage(leftImage,0,0,indentWidth,thumbBounds.height - 2,null);
    g.drawImage(middleImage,indentWidth,thumbBounds.y,thumbBounds.width - indentWidth,thumbBounds.height - 2,null);
    g.drawImage(rightImage,thumbBounds.width - indentWidth,thumbBounds.y,indentWidth,thumbBounds.height - 2,null);
    g.drawImage(horizontalThumbHandle,thumbBounds.width / 2 - horizontalThumbHandle.getWidth() / 2,thumbBounds.height / 2 - horizontalThumbHandle.getHeight() / 2,horizontalThumbHandle.getWidth(),horizontalThumbHandle.getHeight(),null);
    if (!isFreeStanding) {
      thumbBounds.height-=2;
    }
  }
  g.translate(-thumbBounds.x,-thumbBounds.y);
}",0.9826723142087024
104585,"/** 
 * Converts the specified icqstatus to one of the status fields of the IcqStatusEnum class.
 * @param icqStatus the icqStatus as retured in FullUserInfo by the joscarstack
 * @return a PresenceStatus instance representation of the ""long"" icqStatusparameter. The returned result is one of the IcqStatusEnum fields.
 */
private IcqStatusEnum icqStatusLongToPresenceStatus(long icqStatus){
  if (icqStatus == -1) {
    return IcqStatusEnum.OFFLINE;
  }
 else   if ((icqStatus & FullUserInfo.ICQSTATUS_AWAY) != 0) {
    return IcqStatusEnum.AWAY;
  }
 else   if ((icqStatus & FullUserInfo.ICQSTATUS_DND) != 0) {
    return IcqStatusEnum.DO_NOT_DISTURB;
  }
 else   if ((icqStatus & FullUserInfo.ICQSTATUS_FFC) != 0) {
    return IcqStatusEnum.FREE_FOR_CHAT;
  }
 else   if ((icqStatus & FullUserInfo.ICQSTATUS_INVISIBLE) != 0) {
    return IcqStatusEnum.INVISIBLE;
  }
 else   if ((icqStatus & FullUserInfo.ICQSTATUS_NA) != 0) {
    return IcqStatusEnum.NOT_AVAILABLE;
  }
 else   if ((icqStatus & FullUserInfo.ICQSTATUS_OCCUPIED) != 0) {
    return IcqStatusEnum.OCCUPIED;
  }
 else   if ((icqStatus & ICQ_ONLINE_MASK) == 0) {
    return IcqStatusEnum.OFFLINE;
  }
  return IcqStatusEnum.ONLINE;
}","/** 
 * Converts the specified icqstatus to one of the status fields of the IcqStatusEnum class.
 * @param icqStatus the icqStatus as retured in FullUserInfo by the joscarstack
 * @return a PresenceStatus instance representation of the ""long"" icqStatusparameter. The returned result is one of the IcqStatusEnum fields.
 */
private IcqStatusEnum icqStatusLongToPresenceStatus(long icqStatus){
  if (icqStatus == -1) {
    return IcqStatusEnum.OFFLINE;
  }
 else   if ((icqStatus & FullUserInfo.ICQSTATUS_AWAY) != 0) {
    return IcqStatusEnum.AWAY;
  }
 else   if ((icqStatus & FullUserInfo.ICQSTATUS_DND) != 0) {
    return IcqStatusEnum.DO_NOT_DISTURB;
  }
 else   if ((icqStatus & FullUserInfo.ICQSTATUS_FFC) != 0) {
    return IcqStatusEnum.FREE_FOR_CHAT;
  }
 else   if ((icqStatus & FullUserInfo.ICQSTATUS_INVISIBLE) != 0) {
    return IcqStatusEnum.INVISIBLE;
  }
 else   if ((icqStatus & FullUserInfo.ICQSTATUS_NA) != 0) {
    return IcqStatusEnum.NOT_AVAILABLE;
  }
 else   if ((icqStatus & FullUserInfo.ICQSTATUS_OCCUPIED) != 0) {
    return IcqStatusEnum.OCCUPIED;
  }
  return IcqStatusEnum.ONLINE;
}",0.9428571428571428
104586,"/** 
 * Creates the contactlist scroll panel defining the parent frame.
 * @param mainFrame The parent frame.
 */
public ContactListPanel(MainFrame mainFrame){
  this.mainFrame=mainFrame;
  this.getViewport().add(treePanel);
  this.treePanel.setBackground(Color.WHITE);
  this.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
}","/** 
 * Creates the contactlist scroll panel defining the parent frame.
 * @param mainFrame The parent frame.
 */
public ContactListPanel(MainFrame mainFrame){
  this.mainFrame=mainFrame;
  this.getViewport().add(treePanel);
  this.treePanel.setBackground(Color.WHITE);
  this.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  this.getVerticalScrollBar().setUnitIncrement(30);
}",0.93048128342246
104587,"/** 
 * Updates the status of the given metacontact in all opened chats containing this contact.
 * @param metaContact
 */
public void updateChatContactStatus(MetaContact metaContact){
  ContactListModel listModel=(ContactListModel)this.getContactList().getModel();
  if (!Constants.TABBED_CHAT_WINDOW) {
  }
 else   if (tabbedChatWindow != null) {
    Hashtable contactTabsTable=tabbedChatWindow.getContactTabsTable();
    ChatPanel chatPanel=(ChatPanel)contactTabsTable.get(metaContact.getDisplayName());
    if (chatPanel != null) {
      int contactTabIndex=tabbedChatWindow.getTabInex(metaContact);
      tabbedChatWindow.setTabIcon(contactTabIndex,listModel.getMetaContactStatusIcon(metaContact));
      chatPanel.updateContactStatus(listModel.getMetaContactStatus(metaContact));
    }
  }
}","/** 
 * Updates the status of the given metacontact in all opened chats containing this contact.
 * @param metaContact
 */
public void updateChatContactStatus(MetaContact metaContact){
  ContactListModel listModel=(ContactListModel)this.getContactList().getModel();
  if (!Constants.TABBED_CHAT_WINDOW) {
  }
 else   if (tabbedChatWindow != null && tabbedChatWindow.getTabCount() > 0) {
    Hashtable contactTabsTable=tabbedChatWindow.getContactTabsTable();
    ChatPanel chatPanel=(ChatPanel)contactTabsTable.get(metaContact.getDisplayName());
    if (chatPanel != null) {
      int contactTabIndex=tabbedChatWindow.getTabInex(metaContact);
      tabbedChatWindow.setTabIcon(contactTabIndex,listModel.getMetaContactStatusIcon(metaContact));
      chatPanel.updateContactStatus(listModel.getMetaContactStatus(metaContact));
    }
  }
}",0.9767156862745098
104588,"public ChatConversationPanel(ChatPanel chatPanel){
  super();
  this.chatEditorPane.setContentType(""String_Node_Str"");
  this.chatEditorPane.setEditable(false);
  this.chatEditorPane.setEditorKit(editorKit);
  this.document=(HTMLDocument)this.chatEditorPane.getDocument();
  Constants.loadStyle(document.getStyleSheet());
  this.initEditor();
  this.chatEditorPane.addHyperlinkListener(this);
  this.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));
  this.setWheelScrollingEnabled(true);
  this.getViewport().add(chatEditorPane);
}","public ChatConversationPanel(ChatPanel chatPanel){
  super();
  this.chatEditorPane.setContentType(""String_Node_Str"");
  this.chatEditorPane.setEditable(false);
  this.chatEditorPane.setEditorKit(editorKit);
  this.document=(HTMLDocument)this.chatEditorPane.getDocument();
  Constants.loadStyle(document.getStyleSheet());
  this.initEditor();
  this.chatEditorPane.addHyperlinkListener(this);
  this.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));
  this.setWheelScrollingEnabled(true);
  this.getViewport().add(chatEditorPane);
  this.getVerticalScrollBar().setUnitIncrement(30);
}",0.9536541889483066
104589,"public ChatWritePanel(ChatPanel chatPanel){
  super();
  this.chatPanel=chatPanel;
  this.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));
  this.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  this.editorPane.getDocument().addUndoableEditListener(this);
  this.enableKeyboardEvents();
  this.getViewport().add(editorPane,BorderLayout.CENTER);
}","public ChatWritePanel(ChatPanel chatPanel){
  super();
  this.chatPanel=chatPanel;
  this.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));
  this.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  this.editorPane.getDocument().addUndoableEditListener(this);
  this.enableKeyboardEvents();
  this.getViewport().add(editorPane,BorderLayout.CENTER);
  this.getVerticalScrollBar().setUnitIncrement(30);
}",0.9348370927318296
104590,"/** 
 * When message is received determines whether to open a new chat window or chat window tab, or to indicate that a message is received from a contact which already has an open chat. When the chat is found  shows the message in the appropriate chat panel.
 */
public void messageReceived(MessageReceivedEvent evt){
  Calendar calendar=Calendar.getInstance();
  calendar.setTime(evt.getTimestamp());
  MetaContact metaContact=mainFrame.getContactList().findMetaContactByContact(evt.getSourceContact());
  PresenceStatus contactStatus=((ContactListModel)this.contactList.getModel()).getMetaContactStatus(metaContact);
  if (!Constants.TABBED_CHAT_WINDOW) {
    if (contactMsgWindows.containsKey(metaContact)) {
      ChatWindow msgWindow=(ChatWindow)contactMsgWindows.get(metaContact);
      msgWindow.getCurrentChatPanel().getConversationPanel().processMessage(evt.getSourceContact().getDisplayName(),calendar,ChatMessage.INCOMING_MESSAGE,evt.getSourceMessage().getContent());
      if (!msgWindow.isVisible())       msgWindow.setVisible(true);
    }
 else {
      ChatWindow msgWindow=new ChatWindow(mainFrame);
      contactMsgWindows.put(metaContact,msgWindow);
      msgWindow.addChat(metaContact,contactStatus);
      msgWindow.getCurrentChatPanel().getConversationPanel().processMessage(evt.getSourceContact().getDisplayName(),calendar,ChatMessage.INCOMING_MESSAGE,evt.getSourceMessage().getContent());
      msgWindow.pack();
      msgWindow.setVisible(true);
    }
  }
 else {
    if (tabbedChatWindow == null) {
      tabbedChatWindow=new ChatWindow(mainFrame);
      tabbedChatWindow.addWindowListener(new WindowAdapter(){
        public void windowClosing(        WindowEvent e){
          tabbedChatWindow=null;
        }
      }
);
    }
    Hashtable contactTabsTable=tabbedChatWindow.getContactTabsTable();
    if (contactTabsTable.get(metaContact.getDisplayName()) == null) {
      tabbedChatWindow.addChatTab(metaContact,contactStatus);
      tabbedChatWindow.getCurrentChatPanel().getConversationPanel().processMessage(evt.getSourceContact().getDisplayName(),calendar,ChatMessage.INCOMING_MESSAGE,evt.getSourceMessage().getContent());
      if (!tabbedChatWindow.isVisible())       tabbedChatWindow.setVisible(true);
      tabbedChatWindow.getWriteMessagePanel().getEditorPane().requestFocus();
    }
 else {
      tabbedChatWindow.getChatPanel(metaContact).getConversationPanel().processMessage(evt.getSourceContact().getDisplayName(),calendar,ChatMessage.INCOMING_MESSAGE,evt.getSourceMessage().getContent());
      if (!tabbedChatWindow.isVisible())       tabbedChatWindow.setVisible(true);
      tabbedChatWindow.getWriteMessagePanel().getEditorPane().requestFocus();
    }
    if (tabbedChatWindow.getTabCount() > 1) {
      tabbedChatWindow.highlightTab(metaContact);
    }
  }
  Constants.getDefaultAudio().play();
}","/** 
 * When message is received determines whether to open a new chat window or chat window tab, or to indicate that a message is received from a contact which already has an open chat. When the chat is found  shows the message in the appropriate chat panel.
 */
public void messageReceived(MessageReceivedEvent evt){
  Calendar calendar=Calendar.getInstance();
  calendar.setTime(evt.getTimestamp());
  MetaContact metaContact=mainFrame.getContactList().findMetaContactByContact(evt.getSourceContact());
  PresenceStatus contactStatus=((ContactListModel)this.contactList.getModel()).getMetaContactStatus(metaContact);
  if (!Constants.TABBED_CHAT_WINDOW) {
    if (contactMsgWindows.containsKey(metaContact)) {
      ChatWindow msgWindow=(ChatWindow)contactMsgWindows.get(metaContact);
      msgWindow.getCurrentChatPanel().getConversationPanel().processMessage(evt.getSourceContact().getDisplayName(),calendar,ChatMessage.INCOMING_MESSAGE,evt.getSourceMessage().getContent());
      msgWindow.setVisible(true);
    }
 else {
      ChatWindow msgWindow=new ChatWindow(mainFrame);
      contactMsgWindows.put(metaContact,msgWindow);
      msgWindow.addChat(metaContact,contactStatus);
      msgWindow.getCurrentChatPanel().getConversationPanel().processMessage(evt.getSourceContact().getDisplayName(),calendar,ChatMessage.INCOMING_MESSAGE,evt.getSourceMessage().getContent());
      msgWindow.pack();
      msgWindow.setVisible(true);
    }
  }
 else {
    if (tabbedChatWindow == null) {
      tabbedChatWindow=new ChatWindow(mainFrame);
      tabbedChatWindow.addWindowListener(new WindowAdapter(){
        public void windowClosing(        WindowEvent e){
          tabbedChatWindow=null;
        }
      }
);
    }
    Hashtable contactTabsTable=tabbedChatWindow.getContactTabsTable();
    if (contactTabsTable.get(metaContact.getDisplayName()) == null) {
      tabbedChatWindow.addChatTab(metaContact,contactStatus);
      tabbedChatWindow.getCurrentChatPanel().getConversationPanel().processMessage(evt.getSourceContact().getDisplayName(),calendar,ChatMessage.INCOMING_MESSAGE,evt.getSourceMessage().getContent());
      tabbedChatWindow.setVisible(true);
      tabbedChatWindow.getWriteMessagePanel().getEditorPane().requestFocus();
    }
 else {
      tabbedChatWindow.getChatPanel(metaContact).getConversationPanel().processMessage(evt.getSourceContact().getDisplayName(),calendar,ChatMessage.INCOMING_MESSAGE,evt.getSourceMessage().getContent());
      tabbedChatWindow.setVisible(true);
      tabbedChatWindow.getWriteMessagePanel().getEditorPane().requestFocus();
    }
    if (tabbedChatWindow.getTabCount() > 1) {
      tabbedChatWindow.highlightTab(metaContact);
    }
  }
  Constants.getDefaultAudio().play();
}",0.8901651112706389
104591,"/** 
 * Creates a chat panel which is added to the  given chat window.
 * @param chatWindow The parent window of this chat panel.
 */
public ChatPanel(ChatWindow chatWindow,OperationSetBasicInstantMessaging imOperationSet){
  super(new BorderLayout());
  this.chatWindow=chatWindow;
  this.imOperationSet=imOperationSet;
  conversationPanel=new ChatConversationPanel(this);
  sendPanel=new ChatSendPanel(this);
  writeMessagePanel=new ChatWritePanel(this);
  this.topSplitPane.setResizeWeight(1.0D);
  this.messagePane.setResizeWeight(1.0D);
  this.chatConferencePanel.setPreferredSize(new Dimension(120,100));
  this.chatConferencePanel.setMinimumSize(new Dimension(120,100));
  this.writeMessagePanel.setPreferredSize(new Dimension(400,100));
  this.writeMessagePanel.setMinimumSize(new Dimension(400,100));
  this.init();
}","/** 
 * Creates a chat panel which is added to the  given chat window.
 * @param chatWindow The parent window of this chat panel.
 */
public ChatPanel(ChatWindow chatWindow,OperationSetBasicInstantMessaging imOperationSet){
  super(new BorderLayout());
  this.chatWindow=chatWindow;
  this.imOperationSet=imOperationSet;
  conversationPanel=new ChatConversationPanel(this);
  sendPanel=new ChatSendPanel(this);
  writeMessagePanel=new ChatWritePanel(this);
  this.topSplitPane.setResizeWeight(1.0D);
  this.messagePane.setResizeWeight(1.0D);
  this.chatConferencePanel.setPreferredSize(new Dimension(120,100));
  this.chatConferencePanel.setMinimumSize(new Dimension(120,100));
  this.writeMessagePanel.setPreferredSize(new Dimension(400,100));
  this.writeMessagePanel.setMinimumSize(new Dimension(400,100));
  this.init();
  addComponentListener(new TabSelectionFocusGainListener());
}",0.9643899591360188
104592,"public void actionPerformed(ActionEvent e){
  if (chatTabbedPane != null) {
    if (chatTabbedPane.getSelectedIndex() != 0) {
      ChatWindow.this.chatTabbedPane.setSelectedIndex(chatTabbedPane.getSelectedIndex() - 1);
    }
 else {
      ChatWindow.this.chatTabbedPane.setSelectedIndex(chatTabbedPane.getTabCount() - 1);
    }
  }
}","public void actionPerformed(ActionEvent e){
  if (chatTabbedPane != null) {
    int selectedIndex=chatTabbedPane.getSelectedIndex();
    if (selectedIndex != 0) {
      setSelectedContactTab(selectedIndex - 1);
    }
 else {
      setSelectedContactTab(chatTabbedPane.getTabCount() - 1);
    }
  }
}",0.5560821484992101
104593,"/** 
 * Selects the chat tab which corresponds to the given MetaContact.
 * @param contact The MetaContact to select.
 */
public void setSelectedContactTab(MetaContact contact){
  if (this.contactTabsTable != null && !this.contactTabsTable.isEmpty()) {
    int selectedIndex=((ChatPanel)this.contactTabsTable.get(contact.getDisplayName())).getTabIndex();
    this.chatTabbedPane.setSelectedIndex(selectedIndex);
  }
}","public void setSelectedContactTab(int index){
  Enumeration chatsTable=this.contactTabsTable.elements();
  while (chatsTable.hasMoreElements()) {
    ChatPanel chatPanel=(ChatPanel)chatsTable.nextElement();
    if (chatPanel.getTabIndex() == index) {
      this.setCurrentChatPanel(chatPanel);
      this.chatTabbedPane.setSelectedIndex(index);
      this.setVisible(true);
      getWriteMessagePanel().getEditorPane().requestFocus();
      break;
    }
  }
}",0.0433789954337899
104594,"/** 
 * Creates a ChatPanel for the given contact and adds it to a tabbedPane.
 * @param contact The MetaContact added to the chat.
 */
public void addChatTab(MetaContact contact,PresenceStatus status){
  OperationSetBasicInstantMessaging contactIMOperationSet=this.mainFrame.getProtocolIM(contact.getDefaultContact().getProtocolProvider());
  if (chatTabbedPane == null) {
    this.setCurrentChatPanel(new ChatPanel(this,contactIMOperationSet));
    this.currentChatPanel.addContactToChat(contact,status);
    chatTabbedPane=new SIPCommTabbedPane(true);
    chatTabbedPane.addCloseListener(new CloseListener(){
      public void closeOperation(      MouseEvent e){
        int selectedIndex=chatTabbedPane.getOverTabIndex();
        removeContactTab(selectedIndex);
      }
    }
);
    chatTabbedPane.addChangeListener(new ChangeListener(){
      public void stateChanged(      ChangeEvent e){
        ChatPanel chatPanel=(ChatPanel)chatTabbedPane.getSelectedComponent();
        if (chatPanel != null) {
          setTitle(chatPanel.getDefaultContact().getDisplayName());
          setCurrentChatPanel(chatPanel);
        }
      }
    }
);
    this.getContentPane().add(this.currentChatPanel,BorderLayout.CENTER);
    this.currentChatPanel.setTabIndex(0);
    this.contactTabsTable.put(contact.getDisplayName(),currentChatPanel);
    this.setTitle(contact.getDisplayName());
  }
 else {
    PresenceStatus defaultStatus=contact.getDefaultContact().getPresenceStatus();
    if (chatTabbedPane.getTabCount() > 0) {
      this.setCurrentChatPanel(new ChatPanel(this,contactIMOperationSet));
      this.currentChatPanel.addContactToChat(contact,status);
      chatTabbedPane.addTab(contact.getDisplayName(),new ImageIcon(Constants.getStatusIcon(defaultStatus)),currentChatPanel);
      chatTabbedPane.getParent().validate();
      this.currentChatPanel.setTabIndex(chatTabbedPane.getTabCount() - 1);
      this.contactTabsTable.put(contact.getDisplayName(),currentChatPanel);
    }
 else {
      PresenceStatus currentContactStatus=currentChatPanel.getDefaultContact().getDefaultContact().getPresenceStatus();
      chatTabbedPane.addTab(currentChatPanel.getDefaultContact().getDisplayName(),new ImageIcon(Constants.getStatusIcon(currentContactStatus)),currentChatPanel);
      this.setCurrentChatPanel(new ChatPanel(this,contactIMOperationSet));
      this.currentChatPanel.addContactToChat(contact,status);
      chatTabbedPane.addTab(contact.getDisplayName(),new ImageIcon(Constants.getStatusIcon(defaultStatus)),currentChatPanel);
      currentChatPanel.setTabIndex(chatTabbedPane.getTabCount() - 1);
      this.contactTabsTable.put(contact.getDisplayName(),currentChatPanel);
    }
    this.getContentPane().add(chatTabbedPane,BorderLayout.CENTER);
    this.getContentPane().validate();
  }
}","/** 
 * Creates a ChatPanel for the given contact and adds it to a tabbedPane.
 * @param contact The MetaContact added to the chat.
 */
public void addChatTab(MetaContact contact,PresenceStatus status){
  OperationSetBasicInstantMessaging contactIMOperationSet=this.mainFrame.getProtocolIM(contact.getDefaultContact().getProtocolProvider());
  if (chatTabbedPane == null) {
    this.setCurrentChatPanel(new ChatPanel(this,contactIMOperationSet));
    this.currentChatPanel.addContactToChat(contact,status);
    chatTabbedPane=new SIPCommTabbedPane(true);
    chatTabbedPane.addCloseListener(new CloseListener(){
      public void closeOperation(      MouseEvent e){
        int selectedIndex=chatTabbedPane.getOverTabIndex();
        removeContactTab(selectedIndex);
      }
    }
);
    this.getContentPane().add(this.currentChatPanel,BorderLayout.CENTER);
    this.currentChatPanel.setTabIndex(0);
    this.contactTabsTable.put(contact.getDisplayName(),currentChatPanel);
    this.setTitle(contact.getDisplayName());
  }
 else {
    PresenceStatus defaultStatus=contact.getDefaultContact().getPresenceStatus();
    if (chatTabbedPane.getTabCount() > 0) {
      this.setCurrentChatPanel(new ChatPanel(this,contactIMOperationSet));
      this.currentChatPanel.addContactToChat(contact,status);
      chatTabbedPane.addTab(contact.getDisplayName(),new ImageIcon(Constants.getStatusIcon(defaultStatus)),currentChatPanel);
      chatTabbedPane.getParent().validate();
      this.currentChatPanel.setTabIndex(chatTabbedPane.getTabCount() - 1);
      this.contactTabsTable.put(contact.getDisplayName(),currentChatPanel);
    }
 else {
      PresenceStatus currentContactStatus=currentChatPanel.getDefaultContact().getDefaultContact().getPresenceStatus();
      chatTabbedPane.addTab(currentChatPanel.getDefaultContact().getDisplayName(),new ImageIcon(Constants.getStatusIcon(currentContactStatus)),currentChatPanel);
      this.setCurrentChatPanel(new ChatPanel(this,contactIMOperationSet));
      this.currentChatPanel.addContactToChat(contact,status);
      chatTabbedPane.addTab(contact.getDisplayName(),new ImageIcon(Constants.getStatusIcon(defaultStatus)),currentChatPanel);
      currentChatPanel.setTabIndex(chatTabbedPane.getTabCount() - 1);
      this.contactTabsTable.put(contact.getDisplayName(),currentChatPanel);
    }
    this.getContentPane().add(chatTabbedPane,BorderLayout.CENTER);
    this.getContentPane().validate();
  }
}",0.931218952999618
104595,"/** 
 * Enables all key actions on this chat window. Closes  tab or window when esc is pressed and changes tabs when  Alt+Right/Left Arrow is pressed. 
 */
private void enableKeyActions(){
  AbstractAction close=new AbstractAction(){
    public void actionPerformed(    ActionEvent e){
      if (chatTabbedPane.getTabCount() > 1) {
        removeContactTab(chatTabbedPane.getSelectedIndex());
      }
 else {
        ChatWindow.this.dispose();
        mainFrame.getTabbedPane().getContactListPanel().setTabbedChatWindow(null);
      }
    }
  }
;
  AbstractAction changeTabForword=new AbstractAction(){
    public void actionPerformed(    ActionEvent e){
      if (chatTabbedPane != null) {
        if (chatTabbedPane.getSelectedIndex() < chatTabbedPane.getTabCount() - 1) {
          ChatWindow.this.chatTabbedPane.setSelectedIndex(chatTabbedPane.getSelectedIndex() + 1);
        }
 else {
          ChatWindow.this.chatTabbedPane.setSelectedIndex(0);
        }
      }
    }
  }
;
  AbstractAction changeTabBackword=new AbstractAction(){
    public void actionPerformed(    ActionEvent e){
      if (chatTabbedPane != null) {
        if (chatTabbedPane.getSelectedIndex() != 0) {
          ChatWindow.this.chatTabbedPane.setSelectedIndex(chatTabbedPane.getSelectedIndex() - 1);
        }
 else {
          ChatWindow.this.chatTabbedPane.setSelectedIndex(chatTabbedPane.getTabCount() - 1);
        }
      }
    }
  }
;
  getRootPane().getActionMap().put(""String_Node_Str"",close);
  getRootPane().getActionMap().put(""String_Node_Str"",changeTabForword);
  getRootPane().getActionMap().put(""String_Node_Str"",changeTabBackword);
  InputMap imap=this.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
  imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE,0),""String_Node_Str"");
  imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_RIGHT,KeyEvent.ALT_DOWN_MASK),""String_Node_Str"");
  imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_LEFT,KeyEvent.ALT_DOWN_MASK),""String_Node_Str"");
}","/** 
 * Enables all key actions on this chat window. Closes  tab or window when esc is pressed and changes tabs when  Alt+Right/Left Arrow is pressed. 
 */
private void enableKeyActions(){
  AbstractAction close=new AbstractAction(){
    public void actionPerformed(    ActionEvent e){
      if (chatTabbedPane.getTabCount() > 1) {
        removeContactTab(chatTabbedPane.getSelectedIndex());
      }
 else {
        ChatWindow.this.dispose();
        mainFrame.getTabbedPane().getContactListPanel().setTabbedChatWindow(null);
      }
    }
  }
;
  AbstractAction changeTabForword=new AbstractAction(){
    public void actionPerformed(    ActionEvent e){
      if (chatTabbedPane != null) {
        int selectedIndex=chatTabbedPane.getSelectedIndex();
        if (selectedIndex < chatTabbedPane.getTabCount() - 1) {
          setSelectedContactTab(selectedIndex + 1);
        }
 else {
          setSelectedContactTab(0);
        }
      }
    }
  }
;
  AbstractAction changeTabBackword=new AbstractAction(){
    public void actionPerformed(    ActionEvent e){
      if (chatTabbedPane != null) {
        int selectedIndex=chatTabbedPane.getSelectedIndex();
        if (selectedIndex != 0) {
          setSelectedContactTab(selectedIndex - 1);
        }
 else {
          setSelectedContactTab(chatTabbedPane.getTabCount() - 1);
        }
      }
    }
  }
;
  getRootPane().getActionMap().put(""String_Node_Str"",close);
  getRootPane().getActionMap().put(""String_Node_Str"",changeTabForword);
  getRootPane().getActionMap().put(""String_Node_Str"",changeTabBackword);
  InputMap imap=this.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
  imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE,0),""String_Node_Str"");
  imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_RIGHT,KeyEvent.ALT_DOWN_MASK),""String_Node_Str"");
  imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_LEFT,KeyEvent.ALT_DOWN_MASK),""String_Node_Str"");
}",0.8381827462991323
104596,"public void actionPerformed(ActionEvent e){
  if (chatTabbedPane != null && chatTabbedPane.getSelectedIndex() != 0) {
    ChatWindow.this.chatTabbedPane.setSelectedIndex(chatTabbedPane.getSelectedIndex() - 1);
  }
}","public void actionPerformed(ActionEvent e){
  if (chatTabbedPane != null) {
    if (chatTabbedPane.getSelectedIndex() != 0) {
      ChatWindow.this.chatTabbedPane.setSelectedIndex(chatTabbedPane.getSelectedIndex() - 1);
    }
 else {
      ChatWindow.this.chatTabbedPane.setSelectedIndex(chatTabbedPane.getTabCount() - 1);
    }
  }
}",0.7686703096539163
104597,"/** 
 * Enables all key actions on this chat window. Closes  tab or window when esc is pressed and changes tabs when  Alt+Right/Left Arrow is pressed. 
 */
private void enableKeyActions(){
  AbstractAction close=new AbstractAction(){
    public void actionPerformed(    ActionEvent e){
      if (chatTabbedPane.getTabCount() > 1) {
        removeContactTab(chatTabbedPane.getSelectedIndex());
      }
 else {
        ChatWindow.this.dispose();
        mainFrame.getTabbedPane().getContactListPanel().setTabbedChatWindow(null);
      }
    }
  }
;
  AbstractAction changeTabForword=new AbstractAction(){
    public void actionPerformed(    ActionEvent e){
      if (chatTabbedPane != null && chatTabbedPane.getSelectedIndex() < chatTabbedPane.getTabCount() - 1) {
        ChatWindow.this.chatTabbedPane.setSelectedIndex(chatTabbedPane.getSelectedIndex() + 1);
      }
    }
  }
;
  AbstractAction changeTabBackword=new AbstractAction(){
    public void actionPerformed(    ActionEvent e){
      if (chatTabbedPane != null && chatTabbedPane.getSelectedIndex() != 0) {
        ChatWindow.this.chatTabbedPane.setSelectedIndex(chatTabbedPane.getSelectedIndex() - 1);
      }
    }
  }
;
  getRootPane().getActionMap().put(""String_Node_Str"",close);
  getRootPane().getActionMap().put(""String_Node_Str"",changeTabForword);
  getRootPane().getActionMap().put(""String_Node_Str"",changeTabBackword);
  InputMap imap=this.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
  imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE,0),""String_Node_Str"");
  imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_RIGHT,KeyEvent.ALT_DOWN_MASK),""String_Node_Str"");
  imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_LEFT,KeyEvent.ALT_DOWN_MASK),""String_Node_Str"");
}","/** 
 * Enables all key actions on this chat window. Closes  tab or window when esc is pressed and changes tabs when  Alt+Right/Left Arrow is pressed. 
 */
private void enableKeyActions(){
  AbstractAction close=new AbstractAction(){
    public void actionPerformed(    ActionEvent e){
      if (chatTabbedPane.getTabCount() > 1) {
        removeContactTab(chatTabbedPane.getSelectedIndex());
      }
 else {
        ChatWindow.this.dispose();
        mainFrame.getTabbedPane().getContactListPanel().setTabbedChatWindow(null);
      }
    }
  }
;
  AbstractAction changeTabForword=new AbstractAction(){
    public void actionPerformed(    ActionEvent e){
      if (chatTabbedPane != null) {
        if (chatTabbedPane.getSelectedIndex() < chatTabbedPane.getTabCount() - 1) {
          ChatWindow.this.chatTabbedPane.setSelectedIndex(chatTabbedPane.getSelectedIndex() + 1);
        }
 else {
          ChatWindow.this.chatTabbedPane.setSelectedIndex(0);
        }
      }
    }
  }
;
  AbstractAction changeTabBackword=new AbstractAction(){
    public void actionPerformed(    ActionEvent e){
      if (chatTabbedPane != null) {
        if (chatTabbedPane.getSelectedIndex() != 0) {
          ChatWindow.this.chatTabbedPane.setSelectedIndex(chatTabbedPane.getSelectedIndex() - 1);
        }
 else {
          ChatWindow.this.chatTabbedPane.setSelectedIndex(chatTabbedPane.getTabCount() - 1);
        }
      }
    }
  }
;
  getRootPane().getActionMap().put(""String_Node_Str"",close);
  getRootPane().getActionMap().put(""String_Node_Str"",changeTabForword);
  getRootPane().getActionMap().put(""String_Node_Str"",changeTabBackword);
  InputMap imap=this.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
  imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE,0),""String_Node_Str"");
  imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_RIGHT,KeyEvent.ALT_DOWN_MASK),""String_Node_Str"");
  imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_LEFT,KeyEvent.ALT_DOWN_MASK),""String_Node_Str"");
}",0.9318364073777065
104598,"/** 
 * Removes the chat tab with the given tab index.
 * @param index
 */
public void removeContactTab(int index){
  String title=chatTabbedPane.getTitleAt(index);
  if (chatTabbedPane.getTabCount() > 1)   this.contactTabsTable.remove(title);
  Enumeration contactTabs=this.contactTabsTable.elements();
  while (contactTabs.hasMoreElements()) {
    ChatPanel chatPanel=(ChatPanel)contactTabs.nextElement();
    int tabIndex=chatPanel.getTabIndex();
    if (tabIndex > index) {
      chatPanel.setTabIndex(tabIndex - 1);
    }
  }
  int selectedIndex=chatTabbedPane.getSelectedIndex();
  if (selectedIndex > index) {
    chatTabbedPane.setSelectedIndex(selectedIndex - 1);
  }
  if (chatTabbedPane.getTabCount() > 1)   chatTabbedPane.remove(index);
  if (chatTabbedPane.getTabCount() == 1) {
    String onlyTabtitle=chatTabbedPane.getTitleAt(0);
    this.getContentPane().remove(chatTabbedPane);
    this.chatTabbedPane.removeAll();
    ChatPanel chatPanel=(ChatPanel)this.contactTabsTable.get(onlyTabtitle);
    this.getContentPane().add(chatPanel,BorderLayout.CENTER);
    this.setCurrentChatPanel(chatPanel);
    this.setTitle(onlyTabtitle);
  }
}","/** 
 * Removes the tab with the given index.
 * @param index Tab index.
 */
public void removeContactTab(int index){
  String title=chatTabbedPane.getTitleAt(index);
  if (title != null) {
    if (chatTabbedPane.getTabCount() > 1)     this.contactTabsTable.remove(title);
    Enumeration contactTabs=this.contactTabsTable.elements();
    while (contactTabs.hasMoreElements()) {
      ChatPanel chatPanel=(ChatPanel)contactTabs.nextElement();
      int tabIndex=chatPanel.getTabIndex();
      if (tabIndex > index) {
        chatPanel.setTabIndex(tabIndex - 1);
      }
    }
    int selectedIndex=chatTabbedPane.getSelectedIndex();
    if (selectedIndex > index) {
      chatTabbedPane.setSelectedIndex(selectedIndex - 1);
    }
    if (chatTabbedPane.getTabCount() > 1)     chatTabbedPane.remove(index);
    if (chatTabbedPane.getTabCount() == 1) {
      String onlyTabtitle=chatTabbedPane.getTitleAt(0);
      this.getContentPane().remove(chatTabbedPane);
      this.chatTabbedPane.removeAll();
      ChatPanel chatPanel=(ChatPanel)this.contactTabsTable.get(onlyTabtitle);
      this.getContentPane().add(chatPanel,BorderLayout.CENTER);
      this.setCurrentChatPanel(chatPanel);
      this.setTitle(onlyTabtitle);
    }
  }
}",0.9592265657839428
104599,"/** 
 * Creates a ChatPanel for the given contact and adds it to a tabbedPane.
 * @param contact The MetaContact added to the chat.
 */
public void addChatTab(MetaContact contact){
  OperationSetBasicInstantMessaging contactIMOperationSet=this.mainFrame.getProtocolIM(contact.getDefaultContact().getProtocolProvider());
  if (chatTabbedPane == null) {
    this.setCurrentChatPanel(new ChatPanel(this,contactIMOperationSet));
    this.currentChatPanel.addContactToChat(contact);
    chatTabbedPane=new SIPCommTabbedPane(true);
    chatTabbedPane.addCloseListener(new CloseListener(){
      public void closeOperation(      MouseEvent e){
        int selectedIndex=chatTabbedPane.getOverTabIndex();
        removeContactTab(selectedIndex);
      }
    }
);
    chatTabbedPane.addChangeListener(new ChangeListener(){
      public void stateChanged(      ChangeEvent e){
        ChatPanel chatPanel=(ChatPanel)chatTabbedPane.getSelectedComponent();
        if (chatPanel != null) {
          setTitle(chatPanel.getDefaultContact().getDisplayName());
          setCurrentChatPanel(chatPanel);
        }
      }
    }
);
    this.getContentPane().add(this.currentChatPanel,BorderLayout.CENTER);
    this.currentChatPanel.setTabIndex(0);
    this.contactTabsTable.put(contact.getDisplayName(),currentChatPanel);
    this.setTitle(contact.getDisplayName());
  }
 else {
    if (chatTabbedPane.getTabCount() > 0) {
      this.setCurrentChatPanel(new ChatPanel(this,contactIMOperationSet));
      this.currentChatPanel.addContactToChat(contact);
      chatTabbedPane.addTab(contact.getDisplayName(),currentChatPanel);
      chatTabbedPane.getParent().validate();
      this.currentChatPanel.setTabIndex(chatTabbedPane.getTabCount() - 1);
      this.contactTabsTable.put(contact.getDisplayName(),currentChatPanel);
    }
 else {
      chatTabbedPane.addTab(currentChatPanel.getDefaultContact().getDisplayName(),currentChatPanel);
      this.setCurrentChatPanel(new ChatPanel(this,contactIMOperationSet));
      this.currentChatPanel.addContactToChat(contact);
      chatTabbedPane.addTab(contact.getDisplayName(),currentChatPanel);
      currentChatPanel.setTabIndex(chatTabbedPane.getTabCount() - 1);
      this.contactTabsTable.put(contact.getDisplayName(),currentChatPanel);
    }
    this.getContentPane().add(chatTabbedPane,BorderLayout.CENTER);
    this.getContentPane().validate();
  }
}","/** 
 * Creates a ChatPanel for the given contact and adds it to a tabbedPane.
 * @param contact The MetaContact added to the chat.
 */
public void addChatTab(MetaContact contact,PresenceStatus status){
  OperationSetBasicInstantMessaging contactIMOperationSet=this.mainFrame.getProtocolIM(contact.getDefaultContact().getProtocolProvider());
  if (chatTabbedPane == null) {
    this.setCurrentChatPanel(new ChatPanel(this,contactIMOperationSet));
    this.currentChatPanel.addContactToChat(contact,status);
    chatTabbedPane=new SIPCommTabbedPane(true);
    chatTabbedPane.addCloseListener(new CloseListener(){
      public void closeOperation(      MouseEvent e){
        int selectedIndex=chatTabbedPane.getOverTabIndex();
        removeContactTab(selectedIndex);
      }
    }
);
    chatTabbedPane.addChangeListener(new ChangeListener(){
      public void stateChanged(      ChangeEvent e){
        ChatPanel chatPanel=(ChatPanel)chatTabbedPane.getSelectedComponent();
        if (chatPanel != null) {
          setTitle(chatPanel.getDefaultContact().getDisplayName());
          setCurrentChatPanel(chatPanel);
        }
      }
    }
);
    this.getContentPane().add(this.currentChatPanel,BorderLayout.CENTER);
    this.currentChatPanel.setTabIndex(0);
    this.contactTabsTable.put(contact.getDisplayName(),currentChatPanel);
    this.setTitle(contact.getDisplayName());
  }
 else {
    PresenceStatus defaultStatus=contact.getDefaultContact().getPresenceStatus();
    if (chatTabbedPane.getTabCount() > 0) {
      this.setCurrentChatPanel(new ChatPanel(this,contactIMOperationSet));
      this.currentChatPanel.addContactToChat(contact,status);
      chatTabbedPane.addTab(contact.getDisplayName(),new ImageIcon(Constants.getStatusIcon(defaultStatus)),currentChatPanel);
      chatTabbedPane.getParent().validate();
      this.currentChatPanel.setTabIndex(chatTabbedPane.getTabCount() - 1);
      this.contactTabsTable.put(contact.getDisplayName(),currentChatPanel);
    }
 else {
      PresenceStatus currentContactStatus=currentChatPanel.getDefaultContact().getDefaultContact().getPresenceStatus();
      chatTabbedPane.addTab(currentChatPanel.getDefaultContact().getDisplayName(),new ImageIcon(Constants.getStatusIcon(currentContactStatus)),currentChatPanel);
      this.setCurrentChatPanel(new ChatPanel(this,contactIMOperationSet));
      this.currentChatPanel.addContactToChat(contact,status);
      chatTabbedPane.addTab(contact.getDisplayName(),new ImageIcon(Constants.getStatusIcon(defaultStatus)),currentChatPanel);
      currentChatPanel.setTabIndex(chatTabbedPane.getTabCount() - 1);
      this.contactTabsTable.put(contact.getDisplayName(),currentChatPanel);
    }
    this.getContentPane().add(chatTabbedPane,BorderLayout.CENTER);
    this.getContentPane().validate();
  }
}",0.92007722007722
104600,"/** 
 * Creates a ChatPanel for the given contact and adds it directly to the chat window.
 */
public void addChat(MetaContact contact){
  OperationSetBasicInstantMessaging contactIMOperationSet=this.mainFrame.getProtocolIM(contact.getDefaultContact().getProtocolProvider());
  this.setCurrentChatPanel(new ChatPanel(this,contactIMOperationSet));
  this.currentChatPanel.addContactToChat(contact);
  this.getContentPane().add(this.currentChatPanel,BorderLayout.CENTER);
  this.windowTitle+=contact.getDisplayName() + ""String_Node_Str"";
  this.setTitle(this.windowTitle);
}","/** 
 * Creates a ChatPanel for the given contact and  adds it directly to the chat window.
 */
public void addChat(MetaContact contact,PresenceStatus status){
  OperationSetBasicInstantMessaging contactIMOperationSet=this.mainFrame.getProtocolIM(contact.getDefaultContact().getProtocolProvider());
  this.setCurrentChatPanel(new ChatPanel(this,contactIMOperationSet));
  this.currentChatPanel.addContactToChat(contact,status);
  this.getContentPane().add(this.currentChatPanel,BorderLayout.CENTER);
  this.windowTitle+=contact.getDisplayName() + ""String_Node_Str"";
  this.setTitle(this.windowTitle);
}",0.9744463373083476
104601,"/** 
 * Enables all key actions on this chat window. For now  closes the window when esc is pressed.
 */
private void enableKeyActions(){
  AbstractAction close=new AbstractAction(){
    public void actionPerformed(    ActionEvent e){
      if (Constants.TABBED_CHAT_WINDOW && chatTabbedPane.getTabCount() > 1) {
        removeContactTab(chatTabbedPane.getSelectedIndex());
      }
 else {
        ChatWindow.this.dispose();
      }
    }
  }
;
  AbstractAction changeTabForword=new AbstractAction(){
    public void actionPerformed(    ActionEvent e){
      if (chatTabbedPane != null && chatTabbedPane.getSelectedIndex() < chatTabbedPane.getTabCount() - 1) {
        ChatWindow.this.chatTabbedPane.setSelectedIndex(chatTabbedPane.getSelectedIndex() + 1);
      }
    }
  }
;
  AbstractAction changeTabBackword=new AbstractAction(){
    public void actionPerformed(    ActionEvent e){
      if (chatTabbedPane != null && chatTabbedPane.getSelectedIndex() != 0) {
        ChatWindow.this.chatTabbedPane.setSelectedIndex(chatTabbedPane.getSelectedIndex() - 1);
      }
    }
  }
;
  getRootPane().getActionMap().put(""String_Node_Str"",close);
  getRootPane().getActionMap().put(""String_Node_Str"",changeTabForword);
  getRootPane().getActionMap().put(""String_Node_Str"",changeTabBackword);
  InputMap imap=this.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
  imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE,0),""String_Node_Str"");
  imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_RIGHT,KeyEvent.ALT_DOWN_MASK),""String_Node_Str"");
  imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_LEFT,KeyEvent.ALT_DOWN_MASK),""String_Node_Str"");
}","/** 
 * Enables all key actions on this chat window. Closes  tab or window when esc is pressed and changes tabs when  Alt+Right/Left Arrow is pressed. 
 */
private void enableKeyActions(){
  AbstractAction close=new AbstractAction(){
    public void actionPerformed(    ActionEvent e){
      if (chatTabbedPane.getTabCount() > 1) {
        removeContactTab(chatTabbedPane.getSelectedIndex());
      }
 else {
        ChatWindow.this.dispose();
        mainFrame.getTabbedPane().getContactListPanel().setTabbedChatWindow(null);
      }
    }
  }
;
  AbstractAction changeTabForword=new AbstractAction(){
    public void actionPerformed(    ActionEvent e){
      if (chatTabbedPane != null && chatTabbedPane.getSelectedIndex() < chatTabbedPane.getTabCount() - 1) {
        ChatWindow.this.chatTabbedPane.setSelectedIndex(chatTabbedPane.getSelectedIndex() + 1);
      }
    }
  }
;
  AbstractAction changeTabBackword=new AbstractAction(){
    public void actionPerformed(    ActionEvent e){
      if (chatTabbedPane != null && chatTabbedPane.getSelectedIndex() != 0) {
        ChatWindow.this.chatTabbedPane.setSelectedIndex(chatTabbedPane.getSelectedIndex() - 1);
      }
    }
  }
;
  getRootPane().getActionMap().put(""String_Node_Str"",close);
  getRootPane().getActionMap().put(""String_Node_Str"",changeTabForword);
  getRootPane().getActionMap().put(""String_Node_Str"",changeTabBackword);
  InputMap imap=this.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
  imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE,0),""String_Node_Str"");
  imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_RIGHT,KeyEvent.ALT_DOWN_MASK),""String_Node_Str"");
  imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_LEFT,KeyEvent.ALT_DOWN_MASK),""String_Node_Str"");
}",0.8470588235294118
104602,"public EditMenu(){
  super(Messages.getString(""String_Node_Str""));
  this.add(cutMenuItem);
  this.add(copyMenuItem);
  this.add(pasteMenuItem);
}","public EditMenu(ChatWindow chatWindow){
  super(Messages.getString(""String_Node_Str""));
  this.chatWindow=chatWindow;
  this.cutMenuItem.setName(""String_Node_Str"");
  this.copyMenuItem.setName(""String_Node_Str"");
  this.pasteMenuItem.setName(""String_Node_Str"");
  this.cutMenuItem.addActionListener(this);
  this.copyMenuItem.addActionListener(this);
  this.pasteMenuItem.addActionListener(this);
  this.add(cutMenuItem);
  this.add(copyMenuItem);
  this.add(pasteMenuItem);
}",0.3762057877813505
104603,"public MessageWindowMenuBar(ChatWindow parentWindow){
  this.parentWindow=parentWindow;
  fileMenu=new FileMenu(this.parentWindow);
  this.init();
}","public MessageWindowMenuBar(ChatWindow parentWindow){
  this.parentWindow=parentWindow;
  fileMenu=new FileMenu(this.parentWindow);
  editMenu=new EditMenu(this.parentWindow);
  this.init();
}",0.8705882352941177
104604,"public void actionPerformed(ActionEvent e){
  MsgToolbarButton button=(MsgToolbarButton)e.getSource();
  String buttonText=button.getName();
  if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
  }
 else   if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
  }
 else   if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
    JEditorPane editorPane=this.messageWindow.getWriteMessagePanel().getEditorPane();
    editorPane.cut();
  }
 else   if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
    JEditorPane editorPane=this.messageWindow.getWriteMessagePanel().getEditorPane();
    editorPane.copy();
  }
 else   if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
    JEditorPane editorPane=this.messageWindow.getWriteMessagePanel().getEditorPane();
    editorPane.paste();
  }
 else   if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
    if (e.getSource() instanceof SIPCommButton) {
      SmiliesSelectorBox smiliesBox=new SmiliesSelectorBox(ImageLoader.getDefaultSmiliesPack());
      if (!smiliesBox.isVisible()) {
        smiliesBox.setInvoker((Component)e.getSource());
        smiliesBox.setMessageWindow(this.messageWindow);
        smiliesBox.setLocation(smiliesBox.getPopupLocation());
        smiliesBox.setVisible(true);
      }
    }
  }
 else   if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
  }
 else   if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
  }
 else   if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
  }
 else   if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
    HistoryWindow history=new HistoryWindow();
    history.setContacts(messageWindow.getCurrentChatPanel().getChatContacts());
    history.setVisible(true);
  }
 else   if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
  }
}","public void actionPerformed(ActionEvent e){
  MsgToolbarButton button=(MsgToolbarButton)e.getSource();
  String buttonText=button.getName();
  if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
  }
 else   if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
  }
 else   if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
    JEditorPane editorPane=this.messageWindow.getWriteMessagePanel().getEditorPane();
    editorPane.cut();
  }
 else   if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
    JEditorPane editorPane=this.messageWindow.getConversationPanel().getChatEditorPane();
    if (editorPane.getSelectedText() == null) {
      editorPane=this.messageWindow.getWriteMessagePanel().getEditorPane();
    }
    editorPane.copy();
  }
 else   if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
    JEditorPane editorPane=this.messageWindow.getWriteMessagePanel().getEditorPane();
    editorPane.paste();
  }
 else   if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
    if (e.getSource() instanceof SIPCommButton) {
      SmiliesSelectorBox smiliesBox=new SmiliesSelectorBox(ImageLoader.getDefaultSmiliesPack());
      if (!smiliesBox.isVisible()) {
        smiliesBox.setInvoker((Component)e.getSource());
        smiliesBox.setMessageWindow(this.messageWindow);
        smiliesBox.setLocation(smiliesBox.getPopupLocation());
        smiliesBox.setVisible(true);
      }
    }
  }
 else   if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
  }
 else   if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
  }
 else   if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
  }
 else   if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
    HistoryWindow history=new HistoryWindow();
    history.setContacts(messageWindow.getCurrentChatPanel().getChatContacts());
    history.setVisible(true);
  }
 else   if (buttonText.equalsIgnoreCase(""String_Node_Str"")) {
  }
}",0.9632876712328768
104605,"/** 
 * Highlights the tab with the given index.
 * @param tabIndex The tab index.
 */
public void highlightTab(int tabIndex){
  if (!paneUI.isTabHighlighted(tabIndex))   this.paneUI.tabAddHightlight(tabIndex);
  this.repaint();
}","/** 
 * Highlights the tab with the given index.
 * @param tabIndex The tab index.
 */
public void highlightTab(int tabIndex){
  if (!paneUI.isTabHighlighted(tabIndex) && this.getSelectedIndex() != tabIndex)   this.paneUI.tabAddHightlight(tabIndex);
  this.repaint();
}",0.9218436873747496
104606,"/** 
 * Overrides setSelectedIndex in JTabbedPane in order to remove the  hightlight if the tab which is selected is highlighted.
 */
public void setSelectedIndex(int tabIndex){
  if (paneUI.isTabHighlighted(tabIndex)) {
    paneUI.tabRemoveHighlight(tabIndex);
  }
  super.setSelectedIndex(tabIndex);
}","/** 
 * Overrides setSelectedIndex in JTabbedPane in order to remove the  hightlight if the tab which is selected.
 */
public void setSelectedIndex(int tabIndex){
  if (paneUI.isTabHighlighted(tabIndex)) {
    paneUI.tabRemoveHighlight(tabIndex);
  }
  super.setSelectedIndex(tabIndex);
}",0.9746192893401016
104607,"/** 
 * Shows message to the user when message delivery failed.
 */
public void messageDeliveryFailed(MessageDeliveryFailedEvent evt){
}","/** 
 * Shows message to the user when message delivery failed.
 */
public void messageDeliveryFailed(MessageDeliveryFailedEvent evt){
  String msg=Messages.getString(""String_Node_Str"",evt.getDestinationContact().getDisplayName());
  String title=Messages.getString(""String_Node_Str"");
  JOptionPane.showMessageDialog(this,msg,title,JOptionPane.WARNING_MESSAGE);
}",0.544
104608,"public static String getString(String key){
  try {
    return RESOURCE_BUNDLE.getString(key);
  }
 catch (  MissingResourceException e) {
    return '!' + key + '!';
  }
}","public static String getString(String key,String param){
  try {
    String sourceString=RESOURCE_BUNDLE.getString(key);
    return sourceString.replaceAll(""String_Node_Str"",param);
  }
 catch (  MissingResourceException e) {
    return '!' + key + '!';
  }
}",0.765661252900232
104609,"/** 
 * Indicates that a MetaContactGroup has been added.
 */
public void metaContactGroupAdded(MetaContactGroupEvent evt){
  MetaContactGroup sourceGroup=evt.getSourceMetaContactGroup();
  this.groupAdded(sourceGroup);
}","/** 
 * Indicates that a MetaContactGroup has been added.
 */
public void metaContactGroupAdded(MetaContactGroupEvent evt){
  MetaContactGroup sourceGroup=evt.getSourceMetaContactGroup();
  this.groupAdded(sourceGroup);
  this.ensureIndexIsVisible(this.listModel.getSize() - 1);
}",0.8822355289421158
104610,"/** 
 * Refreshes the jlist when a group is added.
 * @param group The group which is added.
 */
private void groupAdded(MetaContactGroup group){
  int index=this.listModel.indexOf(group);
  this.listModel.contentAdded(index,index);
  this.ensureIndexIsVisible(index);
  Iterator childContacts=group.getChildContacts();
  while (childContacts.hasNext()) {
    MetaContact contact=(MetaContact)childContacts.next();
    int contactIndex=this.listModel.indexOf(contact);
    this.listModel.contentAdded(contactIndex,contactIndex);
    this.ensureIndexIsVisible(contactIndex);
  }
  Iterator subGroups=group.getSubgroups();
  while (subGroups.hasNext()) {
    MetaContactGroup subGroup=(MetaContactGroup)subGroups.next();
    this.groupAdded(subGroup);
  }
}","/** 
 * Refreshes the jlist when a group is added.
 * @param group The group which is added.
 */
private void groupAdded(MetaContactGroup group){
  int index=this.listModel.indexOf(group);
  this.listModel.contentAdded(index,index);
  Iterator childContacts=group.getChildContacts();
  while (childContacts.hasNext()) {
    MetaContact contact=(MetaContact)childContacts.next();
    int contactIndex=this.listModel.indexOf(contact);
    this.listModel.contentAdded(contactIndex,contactIndex);
  }
  Iterator subGroups=group.getSubgroups();
  while (subGroups.hasNext()) {
    MetaContactGroup subGroup=(MetaContactGroup)subGroups.next();
    this.groupAdded(subGroup);
  }
}",0.7067879636109167
104611,"/** 
 * Indicates that a MetaContactGroup has been added.
 */
public void metaContactGroupAdded(MetaContactGroupEvent evt){
  MetaContactGroup sourceGroup=evt.getSourceMetaContactGroup();
  this.groupAdded(sourceGroup);
  this.ensureIndexIsVisible(this.listModel.getSize() - 1);
}","/** 
 * Indicates that a MetaContactGroup has been added.
 */
public void metaContactGroupAdded(MetaContactGroupEvent evt){
  MetaContactGroup sourceGroup=evt.getSourceMetaContactGroup();
  this.groupAdded(sourceGroup);
  this.ensureIndexIsVisible(0);
}",0.9455909943714822
104612,"/** 
 * Delivers a <tt>TypingNotificationEvent</tt> to all registered listeners.
 * @param sourceContact the contact who has sent the notification.
 * @param evtCode the code of the event to deliver.
 */
private void fireTypingNotificationsEvent(Contact sourceContact,int evtCode){
  TypingNotificationEvent evt=new TypingNotificationEvent(sourceContact,evtCode);
synchronized (typingNotificationsListeners) {
    for (int i=0; i < typingNotificationsListeners.size(); i++) {
      ((TypingNotificationsListener)typingNotificationsListeners.get(i)).typingNotificationReceifed(evt);
    }
  }
}","/** 
 * Delivers a <tt>TypingNotificationEvent</tt> to all registered listeners.
 * @param sourceContact the contact who has sent the notification.
 * @param evtCode the code of the event to deliver.
 */
private void fireTypingNotificationsEvent(Contact sourceContact,int evtCode){
  logger.debug(""String_Node_Str"" + typingNotificationsListeners.size() + ""String_Node_Str""+ sourceContact.getAddress()+ ""String_Node_Str""+ evtCode);
  TypingNotificationEvent evt=new TypingNotificationEvent(sourceContact,evtCode);
synchronized (typingNotificationsListeners) {
    for (int i=0; i < typingNotificationsListeners.size(); i++) {
      ((TypingNotificationsListener)typingNotificationsListeners.get(i)).typingNotificationReceifed(evt);
    }
  }
}",0.8883895131086142
104613,"public void gotTypingState(Conversation conversation,TypingInfo typingInfo){
  Contact sourceContact=opSetPersPresence.findContactByID(conversation.getBuddy().getFormatted());
  if (sourceContact == null) {
    logger.debug(""String_Node_Str"" + ""String_Node_Str"" + conversation.getBuddy());
  }
  fireTypingNotificationsEvent(sourceContact,typingStateToInt(typingInfo.getTypingState()));
}","public void gotTypingState(Conversation conversation,TypingInfo typingInfo){
  Contact sourceContact=opSetPersPresence.findContactByID(conversation.getBuddy().getFormatted());
  if (sourceContact == null) {
    logger.debug(""String_Node_Str"" + ""String_Node_Str"" + conversation.getBuddy());
    sourceContact=opSetPersPresence.createVolatileContact(conversation.getBuddy());
  }
  fireTypingNotificationsEvent(sourceContact,typingStateToInt(typingInfo.getTypingState()));
}",0.9023255813953488
104614,"private void initialize(Element elem){
synchronized (this) {
    loading=true;
    fWidth=fHeight=0;
  }
  int width=0;
  int height=0;
  boolean customWidth=false;
  boolean customHeight=false;
  try {
    fElement=elem;
    AttributeSet attr=elem.getAttributes();
    if (isURL()) {
      URL src=getSourceURL();
      if (src != null) {
        Dictionary cache=(Dictionary)getDocument().getProperty(IMAGE_CACHE_PROPERTY);
        if (cache != null)         fImage=(Image)cache.get(src);
 else         fImage=Toolkit.getDefaultToolkit().getImage(src);
      }
    }
 else {
      String src=(String)fElement.getAttributes().getAttribute(HTML.Attribute.SRC);
      try {
        fImage=ImageIO.read(Constants.class.getResource(src));
        try {
          waitForImage();
        }
 catch (        InterruptedException e) {
          fImage=null;
        }
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
    height=getIntAttr(HTML.Attribute.HEIGHT,-1);
    customHeight=(height > 0);
    if (!customHeight && fImage != null)     height=fImage.getHeight(this);
    if (height <= 0)     height=DEFAULT_HEIGHT;
    width=getIntAttr(HTML.Attribute.WIDTH,-1);
    customWidth=(width > 0);
    if (!customWidth && fImage != null)     width=fImage.getWidth(this);
    if (width <= 0)     width=DEFAULT_WIDTH;
    if (fImage != null)     if (customWidth && customHeight)     Toolkit.getDefaultToolkit().prepareImage(fImage,height,width,this);
 else     Toolkit.getDefaultToolkit().prepareImage(fImage,-1,-1,this);
  }
  finally {
synchronized (this) {
      loading=false;
      if (customWidth || fWidth == 0) {
        fWidth=width;
      }
      if (customHeight || fHeight == 0) {
        fHeight=height;
      }
    }
  }
}","private void initialize(Element elem){
synchronized (this) {
    loading=true;
    fWidth=fHeight=0;
  }
  int width=0;
  int height=0;
  boolean customWidth=false;
  boolean customHeight=false;
  try {
    fElement=elem;
    AttributeSet attr=elem.getAttributes();
    if (isURL()) {
      URL src=getSourceURL();
      if (src != null) {
        Dictionary cache=(Dictionary)getDocument().getProperty(IMAGE_CACHE_PROPERTY);
        if (cache != null)         fImage=(Image)cache.get(src);
 else         fImage=Toolkit.getDefaultToolkit().getImage(src);
      }
    }
 else {
      String src=(String)fElement.getAttributes().getAttribute(HTML.Attribute.SRC);
      try {
        fImage=ImageIO.read(ImageLoader.class.getClassLoader().getResource(src));
        try {
          waitForImage();
        }
 catch (        InterruptedException e) {
          fImage=null;
        }
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
    height=getIntAttr(HTML.Attribute.HEIGHT,-1);
    customHeight=(height > 0);
    if (!customHeight && fImage != null)     height=fImage.getHeight(this);
    if (height <= 0)     height=DEFAULT_HEIGHT;
    width=getIntAttr(HTML.Attribute.WIDTH,-1);
    customWidth=(width > 0);
    if (!customWidth && fImage != null)     width=fImage.getWidth(this);
    if (width <= 0)     width=DEFAULT_WIDTH;
    if (fImage != null)     if (customWidth && customHeight)     Toolkit.getDefaultToolkit().prepareImage(fImage,height,width,this);
 else     Toolkit.getDefaultToolkit().prepareImage(fImage,-1,-1,this);
  }
  finally {
synchronized (this) {
      loading=false;
      if (customWidth || fWidth == 0) {
        fWidth=width;
      }
      if (customHeight || fHeight == 0) {
        fHeight=height;
      }
    }
  }
}",0.9867119027424373
104615,"/** 
 * Load default smilies pack
 * @return the ArrayList of all smilies.
 */
public static ArrayList getDefaultSmiliesPack(){
  ArrayList defaultPackList=new ArrayList();
  defaultPackList.add(new Smily(ImageLoader.SMILY1.getId(),new String[]{""String_Node_Str"",""String_Node_Str""}));
  defaultPackList.add(new Smily(ImageLoader.SMILY2.getId(),new String[]{""String_Node_Str"",""String_Node_Str""}));
  defaultPackList.add(new Smily(ImageLoader.SMILY3.getId(),new String[]{""String_Node_Str"",""String_Node_Str""}));
  defaultPackList.add(new Smily(ImageLoader.SMILY4.getId(),new String[]{""String_Node_Str"",""String_Node_Str""}));
  defaultPackList.add(new Smily(ImageLoader.SMILY5.getId(),new String[]{""String_Node_Str"",""String_Node_Str""}));
  defaultPackList.add(new Smily(ImageLoader.SMILY6.getId(),new String[]{""String_Node_Str"",""String_Node_Str""}));
  defaultPackList.add(new Smily(ImageLoader.SMILY7.getId(),new String[]{""String_Node_Str"",""String_Node_Str""}));
  defaultPackList.add(new Smily(ImageLoader.SMILY8.getId(),new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}));
  defaultPackList.add(new Smily(ImageLoader.SMILY9.getId(),new String[]{""String_Node_Str"",""String_Node_Str""}));
  defaultPackList.add(new Smily(ImageLoader.SMILY10.getId(),new String[]{""String_Node_Str"",""String_Node_Str""}));
  defaultPackList.add(new Smily(ImageLoader.SMILY11.getId(),new String[]{""String_Node_Str"",""String_Node_Str""}));
  defaultPackList.add(new Smily(ImageLoader.SMILY12.getId(),new String[]{""String_Node_Str"",""String_Node_Str""}));
  return defaultPackList;
}","/** 
 * Load default smilies pack
 * @return the ArrayList of all smilies.
 */
public static ArrayList getDefaultSmiliesPack(){
  ArrayList defaultPackList=new ArrayList();
  defaultPackList.add(new Smily(ImageLoader.SMILY1,new String[]{""String_Node_Str"",""String_Node_Str""}));
  defaultPackList.add(new Smily(ImageLoader.SMILY2,new String[]{""String_Node_Str"",""String_Node_Str""}));
  defaultPackList.add(new Smily(ImageLoader.SMILY3,new String[]{""String_Node_Str"",""String_Node_Str""}));
  defaultPackList.add(new Smily(ImageLoader.SMILY4,new String[]{""String_Node_Str"",""String_Node_Str""}));
  defaultPackList.add(new Smily(ImageLoader.SMILY5,new String[]{""String_Node_Str"",""String_Node_Str""}));
  defaultPackList.add(new Smily(ImageLoader.SMILY6,new String[]{""String_Node_Str"",""String_Node_Str""}));
  defaultPackList.add(new Smily(ImageLoader.SMILY7,new String[]{""String_Node_Str"",""String_Node_Str""}));
  defaultPackList.add(new Smily(ImageLoader.SMILY8,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}));
  defaultPackList.add(new Smily(ImageLoader.SMILY9,new String[]{""String_Node_Str"",""String_Node_Str""}));
  defaultPackList.add(new Smily(ImageLoader.SMILY10,new String[]{""String_Node_Str"",""String_Node_Str""}));
  defaultPackList.add(new Smily(ImageLoader.SMILY11,new String[]{""String_Node_Str"",""String_Node_Str""}));
  defaultPackList.add(new Smily(ImageLoader.SMILY12,new String[]{""String_Node_Str"",""String_Node_Str""}));
  return defaultPackList;
}",0.968729641693811
104616,"public ImageID getImageID(){
  return imageID;
}","public ImageID getImageID(){
  return this.imageID;
}",0.9504950495049505
104617,"public Smily(String imagePath,String[] smilyStrings){
  this.setImageID(imageID);
  this.setSmilyStrings(smilyStrings);
}","public Smily(ImageID imageID,String[] smilyStrings){
  this.imageID=imageID;
  this.setSmilyStrings(smilyStrings);
}",0.8438818565400844
104618,"public String getImagePath(){
  return Images.getString(this.imageID.getId());
}","public String getImagePath(){
  return Images.getString(this.getImageID().getId());
}",0.9575757575757576
104619,"@Override public Object execute(Object[] parameters){
  ParametersParameterAccessor accessor=new ParametersParameterAccessor(queryMethod.getParameters(),parameters);
  CriteriaQuery query=createQuery(accessor);
  if (queryMethod.isPageQuery()) {
    return elasticsearchOperations.queryForPage(query,queryMethod.getEntityInformation().getJavaType());
  }
  return elasticsearchOperations.queryForObject(query,queryMethod.getEntityInformation().getJavaType());
}","@Override public Object execute(Object[] parameters){
  ParametersParameterAccessor accessor=new ParametersParameterAccessor(queryMethod.getParameters(),parameters);
  CriteriaQuery query=createQuery(accessor);
  if (queryMethod.isPageQuery()) {
    query.setPageable(accessor.getPageable());
    return elasticsearchOperations.queryForPage(query,queryMethod.getEntityInformation().getJavaType());
  }
  return elasticsearchOperations.queryForObject(query,queryMethod.getEntityInformation().getJavaType());
}",0.9514963880288958
104620,"@Override public Object execute(Object[] parameters){
  ParametersParameterAccessor accessor=new ParametersParameterAccessor(queryMethod.getParameters(),parameters);
  StringQuery stringQuery=createQuery(accessor);
  if (queryMethod.isPageQuery()) {
    return elasticsearchOperations.queryForPage(stringQuery,queryMethod.getEntityInformation().getJavaType());
  }
  return elasticsearchOperations.queryForObject(stringQuery,queryMethod.getEntityInformation().getJavaType());
}","@Override public Object execute(Object[] parameters){
  ParametersParameterAccessor accessor=new ParametersParameterAccessor(queryMethod.getParameters(),parameters);
  StringQuery stringQuery=createQuery(accessor);
  if (queryMethod.isPageQuery()) {
    stringQuery.setPageable(accessor.getPageable());
    return elasticsearchOperations.queryForPage(stringQuery,queryMethod.getEntityInformation().getJavaType());
  }
  return elasticsearchOperations.queryForObject(stringQuery,queryMethod.getEntityInformation().getJavaType());
}",0.9473684210526316
104621,"@Override public <T>Page<T> moreLikeThis(MoreLikeThisQuery query,Class<T> clazz){
  int startRecord=0;
  ElasticsearchPersistentEntity persistentEntity=getPersistentEntityFor(clazz);
  String indexName=isNotBlank(query.getIndexName()) ? query.getIndexName() : persistentEntity.getIndexName();
  String type=isNotBlank(query.getType()) ? query.getType() : persistentEntity.getIndexType();
  Assert.notNull(indexName,""String_Node_Str"");
  Assert.notNull(type,""String_Node_Str"");
  Assert.notNull(query.getId(),""String_Node_Str"");
  MoreLikeThisRequestBuilder requestBuilder=client.prepareMoreLikeThis(indexName,type,query.getId());
  if (query.getPageable() != null) {
    startRecord=((query.getPageable().getPageNumber() - 1) * query.getPageable().getPageSize());
    requestBuilder.setSearchSize(query.getPageable().getPageSize());
  }
  requestBuilder.setSearchFrom(startRecord < 0 ? 0 : startRecord);
  if (isNotEmpty(query.getSearchIndices())) {
    requestBuilder.setSearchIndices(toArray(query.getSearchIndices()));
  }
  if (isNotEmpty(query.getSearchTypes())) {
    requestBuilder.setSearchTypes(toArray(query.getSearchTypes()));
  }
  if (isNotEmpty(query.getFields())) {
    requestBuilder.setField(toArray(query.getFields()));
  }
  if (isNotBlank(query.getRouting())) {
    requestBuilder.setRouting(query.getRouting());
  }
  if (query.getPercentTermsToMatch() != null) {
    requestBuilder.setPercentTermsToMatch(query.getPercentTermsToMatch());
  }
  if (query.getMinTermFreq() != null) {
    requestBuilder.setMinTermFreq(query.getMinTermFreq());
  }
  if (query.getMaxQueryTerms() != null) {
    requestBuilder.maxQueryTerms(query.getMaxQueryTerms());
  }
  if (isNotEmpty(query.getStopWords())) {
    requestBuilder.setStopWords(toArray(query.getStopWords()));
  }
  if (query.getMinDocFreq() != null) {
    requestBuilder.setMinDocFreq(query.getMinDocFreq());
  }
  if (query.getMaxDocFreq() != null) {
    requestBuilder.setMaxDocFreq(query.getMaxDocFreq());
  }
  if (query.getMinWordLen() != null) {
    requestBuilder.setMinWordLen(query.getMinWordLen());
  }
  if (query.getMaxWordLen() != null) {
    requestBuilder.setMaxWordLen(query.getMaxWordLen());
  }
  if (query.getBoostTerms() != null) {
    requestBuilder.setBoostTerms(query.getBoostTerms());
  }
  SearchResponse response=requestBuilder.execute().actionGet();
  return mapResults(response,clazz,query.getPageable());
}","@Override public <T>Page<T> moreLikeThis(MoreLikeThisQuery query,Class<T> clazz){
  int startRecord=0;
  ElasticsearchPersistentEntity persistentEntity=getPersistentEntityFor(clazz);
  String indexName=isNotBlank(query.getIndexName()) ? query.getIndexName() : persistentEntity.getIndexName();
  String type=isNotBlank(query.getType()) ? query.getType() : persistentEntity.getIndexType();
  Assert.notNull(indexName,""String_Node_Str"");
  Assert.notNull(type,""String_Node_Str"");
  Assert.notNull(query.getId(),""String_Node_Str"");
  MoreLikeThisRequestBuilder requestBuilder=client.prepareMoreLikeThis(indexName,type,query.getId());
  if (query.getPageable() != null) {
    startRecord=query.getPageable().getPageNumber() * query.getPageable().getPageSize();
    requestBuilder.setSearchSize(query.getPageable().getPageSize());
  }
  requestBuilder.setSearchFrom(startRecord);
  if (isNotEmpty(query.getSearchIndices())) {
    requestBuilder.setSearchIndices(toArray(query.getSearchIndices()));
  }
  if (isNotEmpty(query.getSearchTypes())) {
    requestBuilder.setSearchTypes(toArray(query.getSearchTypes()));
  }
  if (isNotEmpty(query.getFields())) {
    requestBuilder.setField(toArray(query.getFields()));
  }
  if (isNotBlank(query.getRouting())) {
    requestBuilder.setRouting(query.getRouting());
  }
  if (query.getPercentTermsToMatch() != null) {
    requestBuilder.setPercentTermsToMatch(query.getPercentTermsToMatch());
  }
  if (query.getMinTermFreq() != null) {
    requestBuilder.setMinTermFreq(query.getMinTermFreq());
  }
  if (query.getMaxQueryTerms() != null) {
    requestBuilder.maxQueryTerms(query.getMaxQueryTerms());
  }
  if (isNotEmpty(query.getStopWords())) {
    requestBuilder.setStopWords(toArray(query.getStopWords()));
  }
  if (query.getMinDocFreq() != null) {
    requestBuilder.setMinDocFreq(query.getMinDocFreq());
  }
  if (query.getMaxDocFreq() != null) {
    requestBuilder.setMaxDocFreq(query.getMaxDocFreq());
  }
  if (query.getMinWordLen() != null) {
    requestBuilder.setMinWordLen(query.getMinWordLen());
  }
  if (query.getMaxWordLen() != null) {
    requestBuilder.setMaxWordLen(query.getMaxWordLen());
  }
  if (query.getBoostTerms() != null) {
    requestBuilder.setBoostTerms(query.getBoostTerms());
  }
  SearchResponse response=requestBuilder.execute().actionGet();
  return mapResults(response,clazz,query.getPageable());
}",0.9937238493723848
104622,"private SearchRequestBuilder prepareSearch(Query query){
  Assert.notNull(query.getIndices(),""String_Node_Str"");
  Assert.notNull(query.getTypes(),""String_Node_Str"");
  int startRecord=0;
  SearchRequestBuilder searchRequestBuilder=client.prepareSearch(toArray(query.getIndices())).setSearchType(DFS_QUERY_THEN_FETCH).setTypes(toArray(query.getTypes()));
  if (query.getPageable() != null) {
    startRecord=((query.getPageable().getPageNumber() - 1) * query.getPageable().getPageSize());
    searchRequestBuilder.setSize(query.getPageable().getPageSize());
  }
  searchRequestBuilder.setFrom(startRecord < 0 ? 0 : startRecord);
  if (!query.getFields().isEmpty()) {
    searchRequestBuilder.addFields(toArray(query.getFields()));
  }
  if (query.getSort() != null) {
    for (    Sort.Order order : query.getSort()) {
      searchRequestBuilder.addSort(order.getProperty(),order.getDirection() == Sort.Direction.DESC ? SortOrder.DESC : SortOrder.ASC);
    }
  }
  return searchRequestBuilder;
}","private SearchRequestBuilder prepareSearch(Query query){
  Assert.notNull(query.getIndices(),""String_Node_Str"");
  Assert.notNull(query.getTypes(),""String_Node_Str"");
  int startRecord=0;
  SearchRequestBuilder searchRequestBuilder=client.prepareSearch(toArray(query.getIndices())).setSearchType(DFS_QUERY_THEN_FETCH).setTypes(toArray(query.getTypes()));
  if (query.getPageable() != null) {
    startRecord=query.getPageable().getPageNumber() * query.getPageable().getPageSize();
    searchRequestBuilder.setSize(query.getPageable().getPageSize());
  }
  searchRequestBuilder.setFrom(startRecord);
  if (!query.getFields().isEmpty()) {
    searchRequestBuilder.addFields(toArray(query.getFields()));
  }
  if (query.getSort() != null) {
    for (    Sort.Order order : query.getSort()) {
      searchRequestBuilder.addSort(order.getProperty(),order.getDirection() == Sort.Direction.DESC ? SortOrder.DESC : SortOrder.ASC);
    }
  }
  return searchRequestBuilder;
}",0.9846938775510204
104623,"private SearchRequestBuilder prepareSearch(Query query){
  Assert.notNull(query.getIndices(),""String_Node_Str"");
  Assert.notNull(query.getTypes(),""String_Node_Str"");
  int startRecord=0;
  SearchRequestBuilder searchRequestBuilder=client.prepareSearch(toArray(query.getIndices())).setSearchType(DFS_QUERY_THEN_FETCH).setTypes(toArray(query.getTypes()));
  if (query.getPageable() != null) {
    startRecord=query.getPageable().getPageNumber() * query.getPageable().getPageSize();
    searchRequestBuilder.setSize(query.getPageable().getPageSize());
  }
  searchRequestBuilder.setFrom(startRecord);
  if (!query.getFields().isEmpty()) {
    searchRequestBuilder.addFields(toArray(query.getFields()));
  }
  if (query.getSort() != null) {
    for (    Sort.Order order : query.getSort()) {
      searchRequestBuilder.addSort(order.getProperty(),order.getDirection() == Sort.Direction.DESC ? SortOrder.DESC : SortOrder.ASC);
    }
  }
  return searchRequestBuilder;
}","private SearchRequestBuilder prepareSearch(Query query){
  Assert.notNull(query.getIndices(),""String_Node_Str"");
  Assert.notNull(query.getTypes(),""String_Node_Str"");
  int startRecord=0;
  SearchRequestBuilder searchRequestBuilder=client.prepareSearch(toArray(query.getIndices())).setSearchType(DFS_QUERY_THEN_FETCH).setTypes(toArray(query.getTypes()));
  if (query.getPageable() != null) {
    startRecord=((query.getPageable().getPageNumber() - 1) * query.getPageable().getPageSize());
    searchRequestBuilder.setSize(query.getPageable().getPageSize());
  }
  searchRequestBuilder.setFrom(startRecord < 0 ? 0 : startRecord);
  if (!query.getFields().isEmpty()) {
    searchRequestBuilder.addFields(toArray(query.getFields()));
  }
  if (query.getSort() != null) {
    for (    Sort.Order order : query.getSort()) {
      searchRequestBuilder.addSort(order.getProperty(),order.getDirection() == Sort.Direction.DESC ? SortOrder.DESC : SortOrder.ASC);
    }
  }
  return searchRequestBuilder;
}",0.9846938775510204
104624,"private IndexRequestBuilder prepareIndex(IndexQuery query){
  try {
    ElasticsearchPersistentEntity persistentEntity=getPersistentEntityFor(query.getObject().getClass());
    IndexRequestBuilder indexRequestBuilder=client.prepareIndex(persistentEntity.getIndexName(),persistentEntity.getIndexType(),query.getId()).setSource(objectMapper.writeValueAsString(query.getObject()));
    if (query.getVersion() != null) {
      indexRequestBuilder.setVersion(query.getVersion());
    }
    return indexRequestBuilder;
  }
 catch (  IOException e) {
    throw new ElasticsearchException(""String_Node_Str"" + query.getId() + ""String_Node_Str"",e);
  }
}","private IndexRequestBuilder prepareIndex(IndexQuery query){
  try {
    ElasticsearchPersistentEntity persistentEntity=getPersistentEntityFor(query.getObject().getClass());
    IndexRequestBuilder indexRequestBuilder=client.prepareIndex(persistentEntity.getIndexName(),persistentEntity.getIndexType(),query.getId()).setSource(objectMapper.writeValueAsString(query.getObject()));
    if (query.getVersion() != null) {
      indexRequestBuilder.setVersion(query.getVersion());
      indexRequestBuilder.setVersionType(EXTERNAL);
    }
    return indexRequestBuilder;
  }
 catch (  IOException e) {
    throw new ElasticsearchException(""String_Node_Str"" + query.getId() + ""String_Node_Str"",e);
  }
}",0.9611940298507464
104625,"public SimpleElasticsearchRepository(ElasticsearchEntityInformation<T,String> metadata,ElasticsearchOperations elasticsearchOperations){
  this(elasticsearchOperations);
  Assert.notNull(metadata);
  this.entityInformation=metadata;
  setEntityClass(this.entityInformation.getJavaType());
}","public SimpleElasticsearchRepository(ElasticsearchEntityInformation<T,String> metadata,ElasticsearchOperations elasticsearchOperations){
  this(elasticsearchOperations);
  Assert.notNull(metadata);
  this.entityInformation=metadata;
  setEntityClass(this.entityInformation.getJavaType());
  createIndex();
}",0.9715242881072028
104626,"@PostConstruct public void createIndex(){
  elasticsearchOperations.createIndex(getEntityClass());
}","private void createIndex(){
  elasticsearchOperations.createIndex(getEntityClass());
}",0.8602150537634409
104627,"@Test public void shouldDoBulkIndexDocument(){
  String documentId=randomNumeric(5);
  SampleEntity sampleEntity1=new SampleEntity();
  sampleEntity1.setId(documentId);
  sampleEntity1.setMessage(""String_Node_Str"");
  SampleEntity sampleEntity2=new SampleEntity();
  sampleEntity2.setId(documentId);
  sampleEntity2.setMessage(""String_Node_Str"");
  repository.save(Arrays.asList(sampleEntity1,sampleEntity2));
  SampleEntity entityFromElasticSearch=repository.findOne(documentId);
  assertThat(entityFromElasticSearch,is(notNullValue()));
}","@Test public void shouldDoBulkIndexDocument(){
  String documentId1=randomNumeric(5);
  SampleEntity sampleEntity1=new SampleEntity();
  sampleEntity1.setId(documentId1);
  sampleEntity1.setMessage(""String_Node_Str"");
  sampleEntity1.setVersion(System.currentTimeMillis());
  String documentId2=randomNumeric(5);
  SampleEntity sampleEntity2=new SampleEntity();
  sampleEntity2.setId(documentId2);
  sampleEntity2.setMessage(""String_Node_Str"");
  sampleEntity2.setVersion(System.currentTimeMillis());
  repository.save(Arrays.asList(sampleEntity1,sampleEntity2));
  SampleEntity entity1FromElasticSearch=repository.findOne(documentId1);
  assertThat(entity1FromElasticSearch,is(notNullValue()));
  SampleEntity entity2FromElasticSearch=repository.findOne(documentId2);
  assertThat(entity2FromElasticSearch,is(notNullValue()));
}",0.7523739956172388
104628,"@Test @Ignore public void shouldFindAllByIdQuery(){
  String documentId=randomNumeric(5);
  SampleEntity sampleEntity=new SampleEntity();
  sampleEntity.setId(documentId);
  sampleEntity.setMessage(""String_Node_Str"");
  repository.save(sampleEntity);
  String documentId2=randomNumeric(5);
  SampleEntity sampleEntity2=new SampleEntity();
  sampleEntity2.setId(documentId2);
  sampleEntity2.setMessage(""String_Node_Str"");
  repository.save(sampleEntity2);
  Iterable<SampleEntity> sampleEntities=repository.findAll(Arrays.asList(documentId,documentId2));
  assertNotNull(""String_Node_Str"",sampleEntities);
}","@Test @Ignore public void shouldFindAllByIdQuery(){
  String documentId=randomNumeric(5);
  SampleEntity sampleEntity=new SampleEntity();
  sampleEntity.setId(documentId);
  sampleEntity.setMessage(""String_Node_Str"");
  sampleEntity.setVersion(System.currentTimeMillis());
  repository.save(sampleEntity);
  String documentId2=randomNumeric(5);
  SampleEntity sampleEntity2=new SampleEntity();
  sampleEntity2.setId(documentId2);
  sampleEntity2.setMessage(""String_Node_Str"");
  sampleEntity2.setVersion(System.currentTimeMillis());
  repository.save(sampleEntity2);
  Iterable<SampleEntity> sampleEntities=repository.findAll(Arrays.asList(documentId,documentId2));
  assertNotNull(""String_Node_Str"",sampleEntities);
}",0.9162264150943396
104629,"@Test public void shouldSearchDocumentsGivenSearchQuery(){
  String documentId=randomNumeric(5);
  SampleEntity sampleEntity=new SampleEntity();
  sampleEntity.setId(documentId);
  sampleEntity.setMessage(""String_Node_Str"");
  repository.save(sampleEntity);
  SearchQuery query=new SearchQuery();
  query.setElasticsearchQuery(termQuery(""String_Node_Str"",""String_Node_Str""));
  Page<SampleEntity> page=repository.search(query);
  assertThat(page,is(notNullValue()));
  assertThat(page.getNumberOfElements(),is(greaterThanOrEqualTo(1)));
}","@Test public void shouldSearchDocumentsGivenSearchQuery(){
  String documentId=randomNumeric(5);
  SampleEntity sampleEntity=new SampleEntity();
  sampleEntity.setId(documentId);
  sampleEntity.setMessage(""String_Node_Str"");
  sampleEntity.setVersion(System.currentTimeMillis());
  repository.save(sampleEntity);
  SearchQuery query=new SearchQuery();
  query.setElasticsearchQuery(termQuery(""String_Node_Str"",""String_Node_Str""));
  Page<SampleEntity> page=repository.search(query);
  assertThat(page,is(notNullValue()));
  assertThat(page.getNumberOfElements(),is(greaterThanOrEqualTo(1)));
}",0.951370468611848
104630,"@Test public void shouldSaveDocument(){
  String documentId=randomNumeric(5);
  SampleEntity sampleEntity=new SampleEntity();
  sampleEntity.setId(documentId);
  sampleEntity.setMessage(""String_Node_Str"");
  repository.save(sampleEntity);
  SampleEntity entityFromElasticSearch=repository.findOne(documentId);
  assertThat(entityFromElasticSearch,is(notNullValue()));
}","@Test public void shouldSaveDocument(){
  String documentId=randomNumeric(5);
  SampleEntity sampleEntity=new SampleEntity();
  sampleEntity.setId(documentId);
  sampleEntity.setMessage(""String_Node_Str"");
  sampleEntity.setVersion(System.currentTimeMillis());
  repository.save(sampleEntity);
  SampleEntity entityFromElasticSearch=repository.findOne(documentId);
  assertThat(entityFromElasticSearch,is(notNullValue()));
}",0.9306431273644388
104631,"@Test public void shouldDeleteDocument(){
  String documentId=randomNumeric(5);
  SampleEntity sampleEntity=new SampleEntity();
  sampleEntity.setId(documentId);
  sampleEntity.setMessage(""String_Node_Str"");
  repository.save(sampleEntity);
  repository.delete(documentId);
  SampleEntity entityFromElasticSearch=repository.findOne(documentId);
  assertThat(entityFromElasticSearch,is(nullValue()));
}","@Test public void shouldDeleteDocument(){
  String documentId=randomNumeric(5);
  SampleEntity sampleEntity=new SampleEntity();
  sampleEntity.setId(documentId);
  sampleEntity.setMessage(""String_Node_Str"");
  sampleEntity.setVersion(System.currentTimeMillis());
  repository.save(sampleEntity);
  repository.delete(documentId);
  SampleEntity entityFromElasticSearch=repository.findOne(documentId);
  assertThat(entityFromElasticSearch,is(nullValue()));
}",0.9358226371061844
104632,"@Test public void shouldSearchDocumentsGivenElasticsearchQuery(){
  String documentId=randomNumeric(5);
  SampleEntity sampleEntity=new SampleEntity();
  sampleEntity.setId(documentId);
  sampleEntity.setMessage(""String_Node_Str"");
  repository.save(sampleEntity);
  Page<SampleEntity> page=repository.search(termQuery(""String_Node_Str"",""String_Node_Str""),new PageRequest(0,50));
  assertThat(page,is(notNullValue()));
  assertThat(page.getNumberOfElements(),is(greaterThanOrEqualTo(1)));
}","@Test public void shouldSearchDocumentsGivenElasticsearchQuery(){
  String documentId=randomNumeric(5);
  SampleEntity sampleEntity=new SampleEntity();
  sampleEntity.setId(documentId);
  sampleEntity.setMessage(""String_Node_Str"");
  sampleEntity.setVersion(System.currentTimeMillis());
  repository.save(sampleEntity);
  Page<SampleEntity> page=repository.search(termQuery(""String_Node_Str"",""String_Node_Str""),new PageRequest(0,50));
  assertThat(page,is(notNullValue()));
  assertThat(page.getNumberOfElements(),is(greaterThanOrEqualTo(1)));
}",0.9468599033816424
104633,"@Test public void shouldFindDocumentById(){
  String documentId=randomNumeric(5);
  SampleEntity sampleEntity=new SampleEntity();
  sampleEntity.setId(documentId);
  sampleEntity.setMessage(""String_Node_Str"");
  repository.save(sampleEntity);
  SampleEntity entityFromElasticSearch=repository.findOne(documentId);
  assertThat(entityFromElasticSearch,is(notNullValue()));
  assertThat(sampleEntity,is((equalTo(sampleEntity))));
}","@Test public void shouldFindDocumentById(){
  String documentId=randomNumeric(5);
  SampleEntity sampleEntity=new SampleEntity();
  sampleEntity.setId(documentId);
  sampleEntity.setMessage(""String_Node_Str"");
  sampleEntity.setVersion(System.currentTimeMillis());
  repository.save(sampleEntity);
  SampleEntity entityFromElasticSearch=repository.findOne(documentId);
  assertThat(entityFromElasticSearch,is(notNullValue()));
  assertThat(sampleEntity,is((equalTo(sampleEntity))));
}",0.9397590361445785
104634,"@Test public void shouldReturnIterableEntities(){
  String documentId=randomNumeric(5);
  SampleEntity sampleEntity1=new SampleEntity();
  sampleEntity1.setId(documentId);
  sampleEntity1.setMessage(""String_Node_Str"");
  sampleEntity1.setVersion(System.currentTimeMillis());
  repository.save(sampleEntity1);
  String documentId2=randomNumeric(5);
  SampleEntity sampleEntity2=new SampleEntity();
  sampleEntity2.setId(documentId2);
  sampleEntity2.setMessage(""String_Node_Str"");
  sampleEntity2.setVersion(System.currentTimeMillis());
  repository.save(sampleEntity2);
  Iterable<SampleEntity> sampleEntities=repository.search(fieldQuery(""String_Node_Str"",documentId));
  assertNotNull(""String_Node_Str"",sampleEntities);
}","@Test public void shouldReturnIterableEntities(){
  String documentId1=randomNumeric(5);
  SampleEntity sampleEntity1=new SampleEntity();
  sampleEntity1.setId(documentId1);
  sampleEntity1.setMessage(""String_Node_Str"");
  sampleEntity1.setVersion(System.currentTimeMillis());
  repository.save(sampleEntity1);
  String documentId2=randomNumeric(5);
  SampleEntity sampleEntity2=new SampleEntity();
  sampleEntity2.setId(documentId2);
  sampleEntity2.setMessage(""String_Node_Str"");
  sampleEntity2.setVersion(System.currentTimeMillis());
  repository.save(sampleEntity2);
  Iterable<SampleEntity> sampleEntities=repository.search(fieldQuery(""String_Node_Str"",documentId1));
  assertNotNull(""String_Node_Str"",sampleEntities);
}",0.9344375431331952
104635,"@Test public void shouldReturnCountOfDocuments(){
  String documentId=randomNumeric(5);
  SampleEntity sampleEntity=new SampleEntity();
  sampleEntity.setId(documentId);
  sampleEntity.setMessage(""String_Node_Str"");
  repository.save(sampleEntity);
  Long count=repository.count();
  assertThat(count,is(greaterThanOrEqualTo(1L)));
}","@Test public void shouldReturnCountOfDocuments(){
  String documentId=randomNumeric(5);
  SampleEntity sampleEntity=new SampleEntity();
  sampleEntity.setId(documentId);
  sampleEntity.setMessage(""String_Node_Str"");
  sampleEntity.setVersion(System.currentTimeMillis());
  repository.save(sampleEntity);
  Long count=repository.count();
  assertThat(count,is(greaterThanOrEqualTo(1L)));
}",0.9237170596393898
104636,"@Test public void shouldReturnResultsForGivenSearchQuery(){
  String documentId=randomNumeric(5);
  SampleEntity sampleEntity=new SampleEntity();
  sampleEntity.setId(documentId);
  sampleEntity.setMessage(""String_Node_Str"");
  repository.save(sampleEntity);
  SearchQuery searchQuery=new SearchQuery();
  searchQuery.setElasticsearchQuery(fieldQuery(""String_Node_Str"",documentId));
  Page<SampleEntity> sampleEntities=repository.search(searchQuery);
  assertThat(sampleEntities.getTotalElements(),equalTo(1L));
}","@Test public void shouldReturnResultsForGivenSearchQuery(){
  String documentId=randomNumeric(5);
  SampleEntity sampleEntity=new SampleEntity();
  sampleEntity.setId(documentId);
  sampleEntity.setMessage(""String_Node_Str"");
  sampleEntity.setVersion(System.currentTimeMillis());
  repository.save(sampleEntity);
  SearchQuery searchQuery=new SearchQuery();
  searchQuery.setElasticsearchQuery(fieldQuery(""String_Node_Str"",documentId));
  Page<SampleEntity> sampleEntities=repository.search(searchQuery);
  assertThat(sampleEntities.getTotalElements(),equalTo(1L));
}",0.9491211840888066
104637,"@Test public void shouldDeleteEntity(){
  String documentId=randomNumeric(5);
  SampleEntity sampleEntity=new SampleEntity();
  sampleEntity.setId(documentId);
  sampleEntity.setMessage(""String_Node_Str"");
  repository.save(sampleEntity);
  repository.delete(sampleEntity);
  SearchQuery searchQuery=new SearchQuery();
  searchQuery.setElasticsearchQuery(fieldQuery(""String_Node_Str"",documentId));
  Page<SampleEntity> sampleEntities=repository.search(searchQuery);
  assertThat(sampleEntities.getTotalElements(),equalTo(0L));
}","@Test public void shouldDeleteEntity(){
  String documentId=randomNumeric(5);
  SampleEntity sampleEntity=new SampleEntity();
  sampleEntity.setId(documentId);
  sampleEntity.setMessage(""String_Node_Str"");
  sampleEntity.setVersion(System.currentTimeMillis());
  repository.save(sampleEntity);
  repository.delete(sampleEntity);
  SearchQuery searchQuery=new SearchQuery();
  searchQuery.setElasticsearchQuery(fieldQuery(""String_Node_Str"",documentId));
  Page<SampleEntity> sampleEntities=repository.search(searchQuery);
  assertThat(sampleEntities.getTotalElements(),equalTo(0L));
}",0.9504950495049505
104638,"@Test public void shouldReturnTrueGivenDocumentWithIdExists(){
  String documentId=randomNumeric(5);
  SampleEntity sampleEntity=new SampleEntity();
  sampleEntity.setId(documentId);
  sampleEntity.setMessage(""String_Node_Str"");
  repository.save(sampleEntity);
  boolean exist=repository.exists(documentId);
  assertEquals(exist,true);
}","@Test public void shouldReturnTrueGivenDocumentWithIdExists(){
  String documentId=randomNumeric(5);
  SampleEntity sampleEntity=new SampleEntity();
  sampleEntity.setId(documentId);
  sampleEntity.setMessage(""String_Node_Str"");
  sampleEntity.setVersion(System.currentTimeMillis());
  repository.save(sampleEntity);
  boolean exist=repository.exists(documentId);
  assertEquals(exist,true);
}",0.9247606019151848
104639,"@Override public Long getVersion(T entity){
  ElasticsearchPersistentProperty versionProperty=entityMetadata.getIdProperty();
  try {
    if (versionProperty != null) {
      return (Long)BeanWrapper.create(entity,null).getProperty(versionProperty);
    }
  }
 catch (  Exception e) {
    logger.debug(""String_Node_Str"",e);
  }
  return null;
}","@Override public Long getVersion(T entity){
  ElasticsearchPersistentProperty versionProperty=entityMetadata.getVersionProperty();
  try {
    if (versionProperty != null) {
      return (Long)BeanWrapper.create(entity,null).getProperty(versionProperty);
    }
  }
 catch (  Exception e) {
    logger.debug(""String_Node_Str"",e);
  }
  return null;
}",0.987012987012987
104640,"@Override public Long getVersion(T entity){
  ElasticsearchPersistentProperty versionProperty=entityMetadata.getVersionProperty();
  try {
    if (versionProperty != null) {
      return (Long)BeanWrapper.create(entity,null).getProperty(versionProperty);
    }
  }
 catch (  Exception e) {
    logger.debug(""String_Node_Str"",e);
  }
  return null;
}","@Override public Long getVersion(T entity){
  ElasticsearchPersistentProperty versionProperty=entityMetadata.getVersionProperty();
  try {
    if (versionProperty != null) {
      return (Long)BeanWrapper.create(entity,null).getProperty(versionProperty);
    }
  }
 catch (  Exception e) {
    throw new IllegalStateException(""String_Node_Str"",e);
  }
  return null;
}",0.9400278940027894
104641,"private ElasticsearchPersistentEntity getPersistentEntityFor(Class clazz){
  return elasticsearchConverter.getMappingContext().getPersistentEntity(clazz);
}","private ElasticsearchPersistentEntity getPersistentEntityFor(Class clazz){
  Assert.isTrue(clazz.isAnnotationPresent(Document.class),""String_Node_Str"" + clazz.getSimpleName() + ""String_Node_Str"");
  return elasticsearchConverter.getMappingContext().getPersistentEntity(clazz);
}",0.7188940092165899
104642,"public SimpleElasticsearchPersistentEntity(TypeInformation<T> typeInformation){
  super(typeInformation);
  this.context=new StandardEvaluationContext();
  Class<T> clazz=typeInformation.getType();
  Assert.isTrue(clazz.isAnnotationPresent(Document.class),clazz.getSimpleName() + ""String_Node_Str"");
  Document document=clazz.getAnnotation(Document.class);
  Assert.hasText(document.indexName(),""String_Node_Str"");
  this.indexName=typeInformation.getType().getAnnotation(Document.class).indexName();
  this.indexType=hasText(document.type()) ? document.type() : clazz.getSimpleName().toLowerCase(Locale.ENGLISH);
}","public SimpleElasticsearchPersistentEntity(TypeInformation<T> typeInformation){
  super(typeInformation);
  this.context=new StandardEvaluationContext();
  Class<T> clazz=typeInformation.getType();
  if (clazz.isAnnotationPresent(Document.class)) {
    Document document=clazz.getAnnotation(Document.class);
    Assert.hasText(document.indexName(),""String_Node_Str"");
    this.indexName=typeInformation.getType().getAnnotation(Document.class).indexName();
    this.indexType=hasText(document.type()) ? document.type() : clazz.getSimpleName().toLowerCase(Locale.ENGLISH);
  }
}",0.6448362720403022
104643,"@SuppressWarnings(""String_Node_Str"") private void readMap(final Datastore datastore,final Mapper mapper,final Object entity,final EntityCache cache,final MappedField mf,final DBObject dbObject){
  final Map map=mapper.getOptions().getObjectFactory().createMap(mf);
  final DBObject dbObj=(DBObject)mf.getDbObjectValue(dbObject);
  final EphemeralMappedField ephemeralMappedField=isMapOrCollection(mf) ? new EphemeralMappedField((ParameterizedType)mf.getSubType(),mf,mapper) : null;
  new IterHelper<Object,Object>().loopMap(dbObj,new MapIterCallback<Object,Object>(){
    @Override public void eval(    final Object k,    final Object val){
      Object newEntity=null;
      if (val != null) {
        if (mapper.getConverters().hasSimpleValueConverter(mf) || mapper.getConverters().hasSimpleValueConverter(mf.getSubClass())) {
          newEntity=mapper.getConverters().decode(mf.getSubClass(),val,mf);
        }
 else {
          if (val instanceof DBObject) {
            newEntity=readMapOrCollectionOrEntity(datastore,mapper,cache,mf,ephemeralMappedField,(DBObject)val);
          }
 else {
            newEntity=val;
          }
        }
      }
      final Object objKey=mapper.getConverters().decode(mf.getMapKeyClass(),k,mf);
      map.put(objKey,newEntity);
    }
  }
);
  if (!map.isEmpty() || mapper.getOptions().isStoreEmpties()) {
    mf.setFieldValue(entity,map);
  }
}","@SuppressWarnings(""String_Node_Str"") private void readMap(final Datastore datastore,final Mapper mapper,final Object entity,final EntityCache cache,final MappedField mf,final DBObject dbObject){
  final DBObject dbObj=(DBObject)mf.getDbObjectValue(dbObject);
  if (dbObj != null) {
    final Map map=mapper.getOptions().getObjectFactory().createMap(mf);
    final EphemeralMappedField ephemeralMappedField=isMapOrCollection(mf) ? new EphemeralMappedField((ParameterizedType)mf.getSubType(),mf,mapper) : null;
    new IterHelper<Object,Object>().loopMap(dbObj,new MapIterCallback<Object,Object>(){
      @Override public void eval(      final Object k,      final Object val){
        Object newEntity=null;
        if (val != null) {
          if (mapper.getConverters().hasSimpleValueConverter(mf) || mapper.getConverters().hasSimpleValueConverter(mf.getSubClass())) {
            newEntity=mapper.getConverters().decode(mf.getSubClass(),val,mf);
          }
 else {
            if (val instanceof DBObject) {
              newEntity=readMapOrCollectionOrEntity(datastore,mapper,cache,mf,ephemeralMappedField,(DBObject)val);
            }
 else {
              newEntity=val;
            }
          }
        }
        final Object objKey=mapper.getConverters().decode(mf.getMapKeyClass(),k,mf);
        map.put(objKey,newEntity);
      }
    }
);
    if (!map.isEmpty() || mapper.getOptions().isStoreEmpties()) {
      mf.setFieldValue(entity,map);
    }
  }
}",0.9238329238329238
104644,"@SuppressWarnings(""String_Node_Str"") private void readCollection(final Datastore datastore,final Mapper mapper,final Object entity,final EntityCache cache,final MappedField mf,final DBObject dbObject){
  Collection values=null;
  final Object dbVal=mf.getDbObjectValue(dbObject);
  if (dbVal != null) {
    values=mf.isSet() ? mapper.getOptions().getObjectFactory().createSet(mf) : mapper.getOptions().getObjectFactory().createList(mf);
    final List dbValues;
    if (dbVal instanceof List) {
      dbValues=(List)dbVal;
    }
 else {
      dbValues=new BasicDBList();
      dbValues.add(dbVal);
    }
    EphemeralMappedField ephemeralMappedField=!mapper.isMapped(mf.getType()) && isMapOrCollection(mf) && (mf.getSubType() instanceof ParameterizedType) ? new EphemeralMappedField((ParameterizedType)mf.getSubType(),mf,mapper) : null;
    for (    final Object o : dbValues) {
      Object newEntity=null;
      if (o != null) {
        if (mapper.getConverters().hasSimpleValueConverter(mf) || mapper.getConverters().hasSimpleValueConverter(mf.getSubClass())) {
          newEntity=mapper.getConverters().decode(mf.getSubClass(),o,mf);
        }
 else {
          newEntity=readMapOrCollectionOrEntity(datastore,mapper,cache,mf,ephemeralMappedField,(DBObject)o);
        }
      }
      values.add(newEntity);
    }
    if (!values.isEmpty() || mapper.getOptions().isStoreEmpties()) {
      if (mf.getType().isArray()) {
        mf.setFieldValue(entity,ReflectionUtils.convertToArray(mf.getSubClass(),ReflectionUtils.iterToList(values)));
      }
 else {
        mf.setFieldValue(entity,values);
      }
    }
  }
}","@SuppressWarnings(""String_Node_Str"") private void readCollection(final Datastore datastore,final Mapper mapper,final Object entity,final EntityCache cache,final MappedField mf,final DBObject dbObject){
  Collection values;
  final Object dbVal=mf.getDbObjectValue(dbObject);
  if (dbVal != null) {
    values=mf.isSet() ? mapper.getOptions().getObjectFactory().createSet(mf) : mapper.getOptions().getObjectFactory().createList(mf);
    final List dbValues;
    if (dbVal instanceof List) {
      dbValues=(List)dbVal;
    }
 else {
      dbValues=new BasicDBList();
      dbValues.add(dbVal);
    }
    EphemeralMappedField ephemeralMappedField=!mapper.isMapped(mf.getType()) && isMapOrCollection(mf) && (mf.getSubType() instanceof ParameterizedType) ? new EphemeralMappedField((ParameterizedType)mf.getSubType(),mf,mapper) : null;
    for (    final Object o : dbValues) {
      Object newEntity=null;
      if (o != null) {
        if (mapper.getConverters().hasSimpleValueConverter(mf) || mapper.getConverters().hasSimpleValueConverter(mf.getSubClass())) {
          newEntity=mapper.getConverters().decode(mf.getSubClass(),o,mf);
        }
 else {
          newEntity=readMapOrCollectionOrEntity(datastore,mapper,cache,mf,ephemeralMappedField,(DBObject)o);
        }
      }
      values.add(newEntity);
    }
    if (!values.isEmpty() || mapper.getOptions().isStoreEmpties()) {
      if (mf.getType().isArray()) {
        mf.setFieldValue(entity,ReflectionUtils.convertToArray(mf.getSubClass(),ReflectionUtils.iterToList(values)));
      }
 else {
        mf.setFieldValue(entity,values);
      }
    }
  }
}",0.9984524914887032
104645,"public static boolean shouldSaveClassName(final Object rawVal,final Object convertedVal,final MappedField mf){
  if (rawVal == null || mf == null) {
    return true;
  }
  if (mf.isSingleValue()) {
    return !(mf.getType().equals(rawVal.getClass()) && !(convertedVal instanceof BasicDBList));
  }
  return !(convertedVal != null && convertedVal instanceof DBObject && !mf.getSubClass().isInterface() && !Modifier.isAbstract(mf.getSubClass().getModifiers()) && mf.getSubClass().equals(rawVal.getClass()));
}","static boolean shouldSaveClassName(final Object rawVal,final Object convertedVal,final MappedField mf){
  if (rawVal == null || mf == null) {
    return true;
  }
  if (mf.isSingleValue()) {
    return !(mf.getType().equals(rawVal.getClass()) && !(convertedVal instanceof BasicDBList));
  }
  return !(convertedVal != null && convertedVal instanceof DBObject && !mf.getSubClass().isInterface() && !Modifier.isAbstract(mf.getSubClass().getModifiers()) && mf.getSubClass().equals(rawVal.getClass()));
}",0.99304865938431
104646,"public Map<Integer,String> getLinkedHashMap(){
  return linkedHashMap;
}","private Map<Integer,String> getLinkedHashMap(){
  return linkedHashMap;
}",0.9379310344827586
104647,"@Test public void testKeyOrdering(){
  getMorphia().map(LinkedHashMapTestEntity.class);
  final LinkedHashMapTestEntity expectedEntity=new LinkedHashMapTestEntity();
  for (int i=100; i >= 0; i--) {
    expectedEntity.getLinkedHashMap().put(i,""String_Node_Str"" + i);
  }
  getDs().save(expectedEntity);
  LinkedHashMapTestEntity storedEntity=getDs().find(LinkedHashMapTestEntity.class).get();
  Assert.assertNotNull(storedEntity);
  Assert.assertEquals(new ArrayList<Integer>(expectedEntity.getLinkedHashMap().keySet()),new ArrayList<Integer>(storedEntity.getLinkedHashMap().keySet()));
}","@Test public void testKeyOrdering(){
  getMorphia().map(LinkedHashMapTestEntity.class);
  final LinkedHashMapTestEntity expectedEntity=new LinkedHashMapTestEntity();
  for (int i=100; i >= 0; i--) {
    expectedEntity.getLinkedHashMap().put(i,""String_Node_Str"" + i);
  }
  getDs().save(expectedEntity);
  LinkedHashMapTestEntity storedEntity=getDs().find(LinkedHashMapTestEntity.class).get();
  Assert.assertNotNull(storedEntity);
  Assert.assertEquals(expectedEntity.getLinkedHashMap(),storedEntity.getLinkedHashMap());
}",0.8864864864864865
104648,"private void empties(){
  Datastore ds=getDs();
  ds.delete(ds.createQuery(Employee.class));
  Employee employee=new Employee();
  HashMap<String,Byte> byteMap=new HashMap<String,Byte>();
  byteMap.put(""String_Node_Str"",(byte)1);
  employee.setByteMap(byteMap);
  ds.save(employee);
  Employee loaded=ds.createQuery(Employee.class).get();
  assertEquals(Byte.valueOf((byte)1),loaded.getByteMap().get(""String_Node_Str""));
  assertNull(loaded.getFloatMap());
}","private void empties(){
  Datastore ds=getDs();
  ds.delete(ds.createQuery(Employee.class));
  Employee employee=new Employee();
  HashMap<String,Byte> byteMap=new HashMap<String,Byte>();
  byteMap.put(""String_Node_Str"",(byte)1);
  employee.byteMap=byteMap;
  ds.save(employee);
  Employee loaded=ds.createQuery(Employee.class).get();
  assertEquals(Byte.valueOf((byte)1),loaded.byteMap.get(""String_Node_Str""));
  assertNull(loaded.floatMap);
}",0.917960088691796
104649,"/** 
 * @return the projections for the group
 */
public Projection[] getProjections(){
  return projections;
}","/** 
 * @return the projections for the group
 */
public List<Projection> getProjections(){
  return projections != null ? new ArrayList<Projection>(projections) : null;
}",0.7730496453900709
104650,"/** 
 * Create a group of Groups for use as an ID
 * @param fields the Groups to group
 * @return the Group
 */
public static List<Group> id(final Group... fields){
  return Arrays.asList(fields);
}","/** 
 * Create a group of Groups for use as an ID
 * @param fields the Groups to group
 * @return the Group
 */
public static List<Group> id(final Group... fields){
  return asList(fields);
}",0.9820051413881749
104651,"@Override @SuppressWarnings(""String_Node_Str"") public Object decode(final Class targetClass,final Object fromDBObject,final MappedField mf){
  if (mf == null || fromDBObject == null) {
    return fromDBObject;
  }
  final Class subtypeDest=mf.getSubClass();
  final Collection values=createNewCollection(mf);
  if (fromDBObject.getClass().isArray()) {
    for (    final Object o : (Object[])fromDBObject) {
      values.add(getMapper().getConverters().decode((subtypeDest != null) ? subtypeDest : o.getClass(),o,mf));
    }
  }
 else   if (fromDBObject instanceof Iterable) {
    for (    final Object o : (Iterable)fromDBObject) {
      if (o instanceof DBObject) {
        final MappedField mappedField=mf.getTypeParameters().get(0);
        if (mappedField instanceof EphemeralMappedField) {
          final EphemeralMappedField field=(EphemeralMappedField)getMapper().fromDb((DBObject)o,mappedField,new DefaultEntityCache());
          values.add(field.getValue());
        }
      }
 else {
        values.add(getMapper().getConverters().decode((subtypeDest != null) ? subtypeDest : o.getClass(),o,mf));
      }
    }
  }
 else {
    values.add(getMapper().getConverters().decode((subtypeDest != null) ? subtypeDest : fromDBObject.getClass(),fromDBObject,mf));
  }
  if (mf.getType().isArray()) {
    return ReflectionUtils.convertToArray(subtypeDest,(List)values);
  }
 else {
    return values;
  }
}","@Override @SuppressWarnings(""String_Node_Str"") public Object decode(final Class targetClass,final Object fromDBObject,final MappedField mf){
  if (mf == null || fromDBObject == null) {
    return fromDBObject;
  }
  final Class subtypeDest=mf.getSubClass();
  final Collection values=createNewCollection(mf);
  if (fromDBObject.getClass().isArray()) {
    for (    final Object o : (Object[])fromDBObject) {
      values.add(getMapper().getConverters().decode((subtypeDest != null) ? subtypeDest : o.getClass(),o,mf));
    }
  }
 else   if (fromDBObject instanceof Iterable) {
    for (    final Object o : (Iterable)fromDBObject) {
      if (o instanceof DBObject) {
        final List<MappedField> typeParameters=mf.getTypeParameters();
        if (!typeParameters.isEmpty()) {
          final MappedField mappedField=typeParameters.get(0);
          if (mappedField instanceof EphemeralMappedField) {
            final EphemeralMappedField field=(EphemeralMappedField)getMapper().fromDb((DBObject)o,mappedField,new DefaultEntityCache());
            values.add(field.getValue());
          }
        }
 else {
          values.add(getMapper().getConverters().decode((subtypeDest != null) ? subtypeDest : o.getClass(),o,mf));
        }
      }
 else {
        values.add(getMapper().getConverters().decode((subtypeDest != null) ? subtypeDest : o.getClass(),o,mf));
      }
    }
  }
 else {
    values.add(getMapper().getConverters().decode((subtypeDest != null) ? subtypeDest : fromDBObject.getClass(),fromDBObject,mf));
  }
  if (mf.getType().isArray()) {
    return ReflectionUtils.convertToArray(subtypeDest,(List)values);
  }
 else {
    return values;
  }
}",0.9066059225512528
104652,"@Test public void testTwoDimensionalArrayMapping() throws Exception {
  getMorphia().map(ContainsTwoDimensionalArray.class);
  final ContainsTwoDimensionalArray entity=new ContainsTwoDimensionalArray();
  entity.oneDimArray=""String_Node_Str"".getBytes();
  entity.twoDimArray=new byte[][]{""String_Node_Str"".getBytes(),""String_Node_Str"".getBytes()};
  final Key<ContainsTwoDimensionalArray> savedKey=getDs().save(entity);
  final ContainsTwoDimensionalArray loaded=getDs().get(ContainsTwoDimensionalArray.class,entity.id);
  Assert.assertNotNull(loaded.id);
  Assert.assertNotNull(loaded.oneDimArray);
  Assert.assertNotNull(loaded.twoDimArray);
  compare(entity.oneDimArray,loaded.oneDimArray);
  compare(entity.twoDimArray[0],loaded.twoDimArray[0]);
  compare(entity.twoDimArray[1],loaded.twoDimArray[1]);
}","@Test public void testTwoDimensionalArrayMapping() throws Exception {
  getMorphia().map(ContainsTwoDimensionalArray.class);
  final ContainsTwoDimensionalArray entity=new ContainsTwoDimensionalArray();
  entity.oneDimArray=""String_Node_Str"".getBytes();
  entity.twoDimArray=new byte[][]{""String_Node_Str"".getBytes(),""String_Node_Str"".getBytes()};
  getDs().save(entity);
  final ContainsTwoDimensionalArray loaded=getDs().get(ContainsTwoDimensionalArray.class,entity.id);
  Assert.assertNotNull(loaded.id);
  Assert.assertNotNull(loaded.oneDimArray);
  Assert.assertNotNull(loaded.twoDimArray);
  compare(entity.oneDimArray,loaded.oneDimArray);
  compare(entity.twoDimArray[0],loaded.twoDimArray[0]);
  compare(entity.twoDimArray[1],loaded.twoDimArray[1]);
}",0.9693486590038314
104653,"/** 
 * Returns the parameterized type in the given position
 * @param c     the class to examine
 * @param index the position of the type to return
 * @return the type
 */
public static Class getParameterizedClass(final Class c,final int index){
  final TypeVariable[] typeVars=c.getTypeParameters();
  if (typeVars.length > 0) {
    final TypeVariable typeVariable=typeVars[index];
    final Type[] bounds=typeVariable.getBounds();
    final Type type=bounds[0];
    if (type instanceof Class) {
      return (Class)type;
    }
 else {
      return null;
    }
  }
 else {
    final Type superclass=c.getGenericSuperclass();
    if (superclass instanceof ParameterizedType) {
      final Type[] actualTypeArguments=((ParameterizedType)superclass).getActualTypeArguments();
      return actualTypeArguments.length > index ? (Class<?>)actualTypeArguments[index] : null;
    }
 else     if (!Object.class.equals(superclass)) {
      return getParameterizedClass((Class)superclass);
    }
 else {
      return null;
    }
  }
}","/** 
 * Returns the parameterized type in the given position
 * @param c     the class to examine
 * @param index the position of the type to return
 * @return the type
 */
public static Class getParameterizedClass(final Class c,final int index){
  final TypeVariable[] typeVars=c.getTypeParameters();
  if (typeVars.length > 0) {
    final TypeVariable typeVariable=typeVars[index];
    final Type[] bounds=typeVariable.getBounds();
    final Type type=bounds[0];
    if (type instanceof Class) {
      return (Class)type;
    }
 else {
      return null;
    }
  }
 else {
    Type superclass=c.getGenericSuperclass();
    if (superclass == null && c.isInterface()) {
      Type[] interfaces=c.getGenericInterfaces();
      if (interfaces.length > 0) {
        superclass=interfaces[index];
      }
    }
    if (superclass instanceof ParameterizedType) {
      final Type[] actualTypeArguments=((ParameterizedType)superclass).getActualTypeArguments();
      return actualTypeArguments.length > index ? (Class<?>)actualTypeArguments[index] : null;
    }
 else     if (!Object.class.equals(superclass)) {
      return getParameterizedClass((Class)superclass);
    }
 else {
      return null;
    }
  }
}",0.9139013452914798
104654,"public DBCursor prepareCursor(){
  final DBObject query=getQueryObject();
  final DBObject fields=getFieldsObject();
  if (LOG.isTraceEnabled()) {
    LOG.trace(""String_Node_Str"" + dbColl.getName() + ""String_Node_Str""+ query+ ""String_Node_Str""+ fields+ ""String_Node_Str""+ offset+ ""String_Node_Str""+ limit);
  }
  final DBCursor cursor=dbColl.find(query,fields);
  cursor.setDecoderFactory(ds.getDecoderFact());
  if (offset > 0) {
    cursor.skip(offset);
  }
  if (limit > 0) {
    cursor.limit(limit);
  }
  if (batchSize != 0) {
    cursor.batchSize(batchSize);
  }
  if (snapshotted) {
    cursor.snapshot();
  }
  if (sort != null) {
    cursor.sort(sort);
  }
  if (indexHint != null) {
    cursor.hint(indexHint);
  }
  if (null != readPref) {
    cursor.setReadPreference(readPref);
  }
  if (noTimeout) {
    cursor.addOption(Bytes.QUERYOPTION_NOTIMEOUT);
  }
  if (tail) {
    cursor.addOption(Bytes.QUERYOPTION_TAILABLE);
    if (tailAwaitData) {
      cursor.addOption(Bytes.QUERYOPTION_AWAITDATA);
    }
  }
  if (snapshotted && (sort != null || indexHint != null)) {
    LOG.warning(""String_Node_Str"");
  }
  if (tail && (sort != null)) {
    LOG.warning(""String_Node_Str"");
  }
  if (maxScan != null) {
    cursor.addSpecial(""String_Node_Str"",maxScan);
  }
  if (max != null) {
    cursor.addSpecial(""String_Node_Str"",max);
  }
  if (min != null) {
    cursor.addSpecial(""String_Node_Str"",min);
  }
  if (comment != null) {
    cursor.addSpecial(""String_Node_Str"",comment);
  }
  if (returnKey) {
    cursor.returnKey();
  }
  return cursor;
}","public DBCursor prepareCursor(){
  final DBObject query=getQueryObject();
  final DBObject fields=getFieldsObject();
  if (LOG.isTraceEnabled()) {
    LOG.trace(""String_Node_Str"" + dbColl.getName() + ""String_Node_Str""+ query+ ""String_Node_Str""+ fields+ ""String_Node_Str""+ offset+ ""String_Node_Str""+ limit);
  }
  final DBCursor cursor=dbColl.find(query,fields);
  cursor.setDecoderFactory(ds.getDecoderFact());
  if (offset > 0) {
    cursor.skip(offset);
  }
  if (limit > 0) {
    cursor.limit(limit);
  }
  if (batchSize != 0) {
    cursor.batchSize(batchSize);
  }
  if (snapshotted) {
    cursor.snapshot();
  }
  if (sort != null) {
    cursor.sort(sort);
  }
  if (indexHint != null) {
    cursor.hint(indexHint);
  }
  if (null != readPref) {
    cursor.setReadPreference(readPref);
  }
  if (noTimeout) {
    cursor.addOption(Bytes.QUERYOPTION_NOTIMEOUT);
  }
  if (tail) {
    cursor.addOption(Bytes.QUERYOPTION_TAILABLE);
    if (tailAwaitData) {
      cursor.addOption(Bytes.QUERYOPTION_AWAITDATA);
    }
  }
  if (snapshotted && (sort != null || indexHint != null)) {
    LOG.warning(""String_Node_Str"");
  }
  if (tail && (sort != null)) {
    LOG.warning(""String_Node_Str"");
  }
  if (maxScan != null) {
    cursor.addSpecial(""String_Node_Str"",maxScan);
  }
  if (maxTime != null && maxTimeUnit != null) {
    cursor.maxTime(maxTime,maxTimeUnit);
  }
  if (max != null) {
    cursor.addSpecial(""String_Node_Str"",max);
  }
  if (min != null) {
    cursor.addSpecial(""String_Node_Str"",min);
  }
  if (comment != null) {
    cursor.addSpecial(""String_Node_Str"",comment);
  }
  if (returnKey) {
    cursor.returnKey();
  }
  return cursor;
}",0.9024618261140542
104655,"private Object readMapOrCollectionOrEntity(final DBObject dbObj,final MappedField mf,final EntityCache cache,final Mapper mapper,MapOrCollectionMF mapOrCollectionMF){
  if (mapOrCollectionMF != null) {
    mapper.fromDb(dbObj,mapOrCollectionMF,cache);
    return mapOrCollectionMF.getValue();
  }
 else {
    final Object newEntity=mapper.getOptions().getObjectFactory().createInstance(mapper,mf,dbObj);
    return mapper.fromDb(dbObj,newEntity,cache);
  }
}","private Object readMapOrCollectionOrEntity(final DBObject dbObj,final MappedField mf,final EntityCache cache,final Mapper mapper,final MapOrCollectionMF mapOrCollectionMF){
  if (mapOrCollectionMF != null) {
    mapper.fromDb(dbObj,mapOrCollectionMF,cache);
    return mapOrCollectionMF.getValue();
  }
 else {
    final Object newEntity=mapper.getOptions().getObjectFactory().createInstance(mapper,mf,dbObj);
    return mapper.fromDb(dbObj,newEntity,cache);
  }
}",0.9934924078091106
104656,"private boolean isMapOrCollection(MappedField mf){
  return Map.class.isAssignableFrom(mf.getSubClass()) || Iterable.class.isAssignableFrom(mf.getSubClass());
}","private static boolean isMapOrCollection(final MappedField mf){
  return Map.class.isAssignableFrom(mf.getSubClass()) || Iterable.class.isAssignableFrom(mf.getSubClass());
}",0.960960960960961
104657,"public void setMeta(Map<String,String> meta){
  this.meta=meta;
}","public void setMeta(final Map<String,String> meta){
  this.meta=meta;
}",0.9558823529411764
104658,"public void setValues(Map<String,List<Value>> values){
  this.values=values;
}","public void setValues(final Map<String,List<Value>> values){
  this.values=values;
}",0.9629629629629628
104659,"public void setId(ObjectId id){
  this.id=id;
}","public void setId(final ObjectId id){
  this.id=id;
}",0.94
104660,"public void setRaw(String raw){
  this.raw=raw;
}","public void setRaw(final String raw){
  this.raw=raw;
}",0.9423076923076924
104661,"/** 
 * Add MappedClass to internal cache, possibly validating first.
 */
private MappedClass addMappedClass(final MappedClass mc,final boolean validate){
  if (validate) {
    mc.validate();
  }
  final Converters c=(Converters)mc.getAnnotation(Converters.class);
  if (c != null) {
    for (    final Class<? extends TypeConverter> clazz : c.value()) {
      if (!getConverters().isRegistered(clazz)) {
        getConverters().addConverter(clazz);
      }
    }
  }
  mappedClasses.put(mc.getClazz().getName(),mc);
  Set<MappedClass> mcs=mappedClassesByCollection.get(mc.getCollectionName());
  if (mcs == null) {
    mcs=new CopyOnWriteArraySet<MappedClass>();
    final Set<MappedClass> temp=mappedClassesByCollection.putIfAbsent(mc.getCollectionName(),mcs);
    if (temp != null) {
      mcs=temp;
    }
  }
  mcs.add(mc);
  return mc;
}","/** 
 * Add MappedClass to internal cache, possibly validating first.
 */
private MappedClass addMappedClass(final MappedClass mc,final boolean validate){
  if (validate) {
    mc.validate();
  }
  final List<Annotation> convertersList=mc.getAnnotations(Converters.class);
  if (convertersList != null) {
    for (    Annotation a : convertersList) {
      final Converters c=(Converters)a;
      if (c != null) {
        for (        final Class<? extends TypeConverter> clazz : c.value()) {
          if (!getConverters().isRegistered(clazz)) {
            getConverters().addConverter(clazz);
          }
        }
      }
    }
  }
  mappedClasses.put(mc.getClazz().getName(),mc);
  Set<MappedClass> mcs=mappedClassesByCollection.get(mc.getCollectionName());
  if (mcs == null) {
    mcs=new CopyOnWriteArraySet<MappedClass>();
    final Set<MappedClass> temp=mappedClassesByCollection.putIfAbsent(mc.getCollectionName(),mcs);
    if (temp != null) {
      mcs=temp;
    }
  }
  mcs.add(mc);
  return mc;
}",0.8833693304535637
104662,"public static <T>Class<?> getTypeArgument(final Class<? extends T> clazz,final TypeVariable<? extends GenericDeclaration> tv){
  final Map<Type,Type> resolvedTypes=new HashMap<Type,Type>();
  Type type=clazz;
  while (!getClass(type).equals(Object.class)) {
    if (type instanceof Class) {
      type=((Class)type).getGenericSuperclass();
    }
 else {
      final ParameterizedType parameterizedType=(ParameterizedType)type;
      final Class<?> rawType=(Class)parameterizedType.getRawType();
      final Type[] actualTypeArguments=parameterizedType.getActualTypeArguments();
      final TypeVariable<?>[] typeParameters=rawType.getTypeParameters();
      for (int i=0; i < actualTypeArguments.length; i++) {
        if (typeParameters[i].equals(tv)) {
          final Class cls=getClass(actualTypeArguments[i]);
          if (cls != null) {
            return cls;
          }
          return getClass(resolvedTypes.get(actualTypeArguments[i]));
        }
        resolvedTypes.put(typeParameters[i],actualTypeArguments[i]);
      }
      if (!rawType.equals(Object.class)) {
        type=rawType.getGenericSuperclass();
      }
    }
  }
  return null;
}","public static <T>Class<?> getTypeArgument(final Class<? extends T> clazz,final TypeVariable<? extends GenericDeclaration> tv){
  final Map<Type,Type> resolvedTypes=new HashMap<Type,Type>();
  Type type=clazz;
  while (!getClass(type).equals(Object.class)) {
    if (type instanceof Class) {
      type=((Class)type).getGenericSuperclass();
    }
 else {
      final ParameterizedType parameterizedType=(ParameterizedType)type;
      final Class<?> rawType=(Class)parameterizedType.getRawType();
      final Type[] actualTypeArguments=parameterizedType.getActualTypeArguments();
      final TypeVariable<?>[] typeParameters=rawType.getTypeParameters();
      for (int i=0; i < actualTypeArguments.length; i++) {
        if (typeParameters[i].equals(tv)) {
          final Class cls=getClass(actualTypeArguments[i]);
          if (cls != null) {
            return cls;
          }
          Type typeToTest=resolvedTypes.get(actualTypeArguments[i]);
          while (typeToTest != null) {
            final Class classToTest=getClass(typeToTest);
            if (classToTest != null) {
              return classToTest;
            }
            typeToTest=resolvedTypes.get(typeToTest);
          }
        }
        resolvedTypes.put(typeParameters[i],actualTypeArguments[i]);
      }
      if (!rawType.equals(Object.class)) {
        type=rawType.getGenericSuperclass();
      }
    }
  }
  return null;
}",0.872613946240748
104663,"/** 
 * <p> Converts a java object to a mongo-compatible object (possibly a DBObject for complex mappings). Very similar to   {@link Mapper#toDBObject} </p> <p> Used (mainly) by query/update operations </p>
 */
public Object toMongoObject(final MappedField mf,final MappedClass mc,final Object value){
  Object mappedValue=value;
  if (isAssignable(mf,value) || isEntity(mc)) {
    try {
      if (value instanceof Iterable) {
        MappedClass mapped=getMappedClass(mf.getSubClass());
        if (mapped != null && (Key.class.isAssignableFrom(mapped.getClazz()) || mapped.getEntityAnnotation() != null)) {
          mappedValue=getDBRefs((Iterable)value);
        }
 else {
          mappedValue=toMongoObject(value,false);
        }
      }
 else {
        final Key<?> key=(value instanceof Key) ? (Key<?>)value : getKey(value);
        if (key == null) {
          mappedValue=toMongoObject(value,false);
        }
 else {
          mappedValue=keyToRef(key);
          if (mappedValue == value) {
            throw new ValidationException(""String_Node_Str"" + value);
          }
        }
      }
    }
 catch (    Exception e) {
      LOG.error(""String_Node_Str"" + value + ""String_Node_Str"",e);
      mappedValue=toMongoObject(value,false);
    }
  }
 else   if (mf != null && mf.hasAnnotation(Serialized.class)) {
    try {
      mappedValue=Serializer.serialize(value,!mf.getAnnotation(Serialized.class).disableCompression());
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
  }
 else   if (value instanceof DBObject) {
    mappedValue=value;
  }
 else {
    mappedValue=toMongoObject(value,EmbeddedMapper.shouldSaveClassName(value,mappedValue,mf));
    if (mappedValue instanceof BasicDBList) {
      final BasicDBList list=(BasicDBList)mappedValue;
      if (list.size() != 0) {
        if (!EmbeddedMapper.shouldSaveClassName(extractFirstElement(value),list.get(0),mf)) {
          for (          Object o : list) {
            if (o instanceof DBObject) {
              ((DBObject)o).removeField(CLASS_NAME_FIELDNAME);
            }
          }
        }
      }
    }
 else     if (mappedValue instanceof DBObject && !EmbeddedMapper.shouldSaveClassName(value,mappedValue,mf)) {
      ((DBObject)mappedValue).removeField(CLASS_NAME_FIELDNAME);
    }
  }
  return mappedValue;
}","/** 
 * <p> Converts a java object to a mongo-compatible object (possibly a DBObject for complex mappings). Very similar to   {@link Mapper#toDBObject} </p> <p> Used (mainly) by query/update operations </p>
 */
public Object toMongoObject(final MappedField mf,final MappedClass mc,final Object value){
  Object mappedValue=value;
  if (isAssignable(mf,value) || isEntity(mc)) {
    try {
      if (value instanceof Iterable) {
        MappedClass mapped=getMappedClass(mf.getSubClass());
        if (mapped != null && (Key.class.isAssignableFrom(mapped.getClazz()) || mapped.getEntityAnnotation() != null)) {
          mappedValue=getDBRefs((Iterable)value);
        }
 else {
          if (mf.getSubClass() == null) {
            mappedValue=getDBRefs((Iterable)value);
          }
 else {
            mappedValue=toMongoObject(value,false);
          }
        }
      }
 else {
        final Key<?> key=(value instanceof Key) ? (Key<?>)value : getKey(value);
        if (key == null) {
          mappedValue=toMongoObject(value,false);
        }
 else {
          mappedValue=keyToRef(key);
          if (mappedValue == value) {
            throw new ValidationException(""String_Node_Str"" + value);
          }
        }
      }
    }
 catch (    Exception e) {
      LOG.error(""String_Node_Str"" + value + ""String_Node_Str"",e);
      mappedValue=toMongoObject(value,false);
    }
  }
 else   if (mf != null && mf.hasAnnotation(Serialized.class)) {
    try {
      mappedValue=Serializer.serialize(value,!mf.getAnnotation(Serialized.class).disableCompression());
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
  }
 else   if (value instanceof DBObject) {
    mappedValue=value;
  }
 else {
    mappedValue=toMongoObject(value,EmbeddedMapper.shouldSaveClassName(value,mappedValue,mf));
    if (mappedValue instanceof BasicDBList) {
      final BasicDBList list=(BasicDBList)mappedValue;
      if (list.size() != 0) {
        if (!EmbeddedMapper.shouldSaveClassName(extractFirstElement(value),list.get(0),mf)) {
          for (          Object o : list) {
            if (o instanceof DBObject) {
              ((DBObject)o).removeField(CLASS_NAME_FIELDNAME);
            }
          }
        }
      }
    }
 else     if (mappedValue instanceof DBObject && !EmbeddedMapper.shouldSaveClassName(value,mappedValue,mf)) {
      ((DBObject)mappedValue).removeField(CLASS_NAME_FIELDNAME);
    }
  }
  return mappedValue;
}",0.9731656184486374
104664,"@Override public int hashCode(){
  return id.hashCode();
}","@Override public int hashCode(){
  return id != null ? id.hashCode() : 0;
}",0.8721804511278195
104665,"@Override public boolean equals(final Object obj){
  if (obj == null || obj.getClass() != Ref.class) {
    return false;
  }
  Ref other=(Ref)obj;
  return id.equals(other.id);
}","@Override public boolean equals(final Object o){
  if (this == o) {
    return true;
  }
  if (!(o instanceof Ref)) {
    return false;
  }
  final Ref ref=(Ref)o;
  if (id != null ? !id.equals(ref.id) : ref.id != null) {
    return false;
  }
  return true;
}",0.2328767123287671
104666,"protected void cleanup(){
  super.cleanup();
  db.getCollection(""String_Node_Str"").drop();
  db.getCollection(""String_Node_Str"").drop();
  db.getCollection(""String_Node_Str"").drop();
  db.getCollection(""String_Node_Str"").drop();
  db.getCollection(""String_Node_Str"").drop();
}","protected void cleanup(){
  super.cleanup();
  DB db=getDb();
  db.getCollection(""String_Node_Str"").drop();
  db.getCollection(""String_Node_Str"").drop();
  db.getCollection(""String_Node_Str"").drop();
  db.getCollection(""String_Node_Str"").drop();
  db.getCollection(""String_Node_Str"").drop();
}",0.9701230228471002
104667,"@Test public void testEmbedded(){
  AdvancedDatastore ads=((AdvancedDatastore)ds);
  ads.save(""String_Node_Str"",new B(new BB(""String_Node_Str"")));
  assertEquals(1,db.getCollection(""String_Node_Str"").getIndexInfo().size());
  ads.ensureIndexes(""String_Node_Str"",B.class);
  assertEquals(2,db.getCollection(""String_Node_Str"").getIndexInfo().size());
}","@Test public void testEmbedded(){
  AdvancedDatastore ads=getAds();
  DB db=getDb();
  ads.save(""String_Node_Str"",new B(new BB(""String_Node_Str"")));
  assertEquals(1,db.getCollection(""String_Node_Str"").getIndexInfo().size());
  ads.ensureIndexes(""String_Node_Str"",B.class);
  assertEquals(2,db.getCollection(""String_Node_Str"").getIndexInfo().size());
}",0.9430199430199432
104668,"/** 
 * Test that indexes created on one collection do not affect other collections.
 */
@Test public void testA(){
  ads.ensureIndexes(""String_Node_Str"",A.class);
  assertEquals(2,db.getCollection(""String_Node_Str"").getIndexInfo().size());
  ads.ensureIndex(""String_Node_Str"",A.class,""String_Node_Str"");
  ads.ensureIndex(""String_Node_Str"",A.class,""String_Node_Str"");
  ads.ensureIndexes(""String_Node_Str"",A.class);
  assertEquals(4,db.getCollection(""String_Node_Str"").getIndexInfo().size());
  ads.ensureIndex(""String_Node_Str"",A.class,""String_Node_Str"");
  assertEquals(2,db.getCollection(""String_Node_Str"").getIndexInfo().size());
  ads.ensureIndexes();
  assertEquals(2,db.getCollection(""String_Node_Str"").getIndexInfo().size());
  assertEquals(4,db.getCollection(""String_Node_Str"").getIndexInfo().size());
  assertEquals(2,db.getCollection(""String_Node_Str"").getIndexInfo().size());
}","/** 
 * Test that indexes created on one collection do not affect other collections.
 */
@Test public void testA(){
  AdvancedDatastore ads=getAds();
  DB db=getDb();
  ads.ensureIndexes(""String_Node_Str"",A.class);
  assertEquals(2,db.getCollection(""String_Node_Str"").getIndexInfo().size());
  ads.ensureIndex(""String_Node_Str"",A.class,""String_Node_Str"");
  ads.ensureIndex(""String_Node_Str"",A.class,""String_Node_Str"");
  ads.ensureIndexes(""String_Node_Str"",A.class);
  assertEquals(4,db.getCollection(""String_Node_Str"").getIndexInfo().size());
  ads.ensureIndex(""String_Node_Str"",A.class,""String_Node_Str"");
  assertEquals(2,db.getCollection(""String_Node_Str"").getIndexInfo().size());
  ads.ensureIndexes();
  assertEquals(2,db.getCollection(""String_Node_Str"").getIndexInfo().size());
  assertEquals(4,db.getCollection(""String_Node_Str"").getIndexInfo().size());
  assertEquals(2,db.getCollection(""String_Node_Str"").getIndexInfo().size());
}",0.9721463681048608
104669,"/** 
 * <p> Converts a java object to a mongo-compatible object (possibly a DBObject for complex mappings). Very similar to   {@link Mapper#toDBObject} </p> <p> Used (mainly) by query/update operations </p>
 */
public Object toMongoObject(final MappedField mf,final MappedClass mc,final Object value){
  Object mappedValue=value;
  if (isAssignable(mf,value) || isEntity(mc)) {
    try {
      if (value instanceof Iterable) {
        MappedClass mapped=getMappedClass(mf.getSubClass());
        if (mapped != null && Key.class.isAssignableFrom(mapped.getClazz())) {
          mappedValue=getDBRefs((Iterable)value);
        }
 else {
          mappedValue=toMongoObject(value,false);
        }
      }
 else {
        final Key<?> key=(value instanceof Key) ? (Key<?>)value : getKey(value);
        if (key == null) {
          mappedValue=toMongoObject(value,false);
        }
 else {
          mappedValue=keyToRef(key);
          if (mappedValue == value) {
            throw new ValidationException(""String_Node_Str"" + value);
          }
        }
      }
    }
 catch (    Exception e) {
      LOG.error(""String_Node_Str"" + value + ""String_Node_Str"",e);
      mappedValue=toMongoObject(value,false);
    }
  }
 else   if (mf != null && mf.hasAnnotation(Serialized.class)) {
    try {
      mappedValue=Serializer.serialize(value,!mf.getAnnotation(Serialized.class).disableCompression());
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
  }
 else   if (value instanceof DBObject) {
    mappedValue=value;
  }
 else {
    mappedValue=toMongoObject(value,EmbeddedMapper.shouldSaveClassName(value,mappedValue,mf));
    if (mappedValue instanceof BasicDBList) {
      final BasicDBList list=(BasicDBList)mappedValue;
      if (list.size() != 0) {
        if (!EmbeddedMapper.shouldSaveClassName(extractFirstElement(value),list.get(0),mf)) {
          for (          Object o : list) {
            if (o instanceof DBObject) {
              ((DBObject)o).removeField(CLASS_NAME_FIELDNAME);
            }
          }
        }
      }
    }
 else     if (mappedValue instanceof DBObject && !EmbeddedMapper.shouldSaveClassName(value,mappedValue,mf)) {
      ((DBObject)mappedValue).removeField(CLASS_NAME_FIELDNAME);
    }
  }
  return mappedValue;
}","/** 
 * <p> Converts a java object to a mongo-compatible object (possibly a DBObject for complex mappings). Very similar to   {@link Mapper#toDBObject} </p> <p> Used (mainly) by query/update operations </p>
 */
public Object toMongoObject(final MappedField mf,final MappedClass mc,final Object value){
  Object mappedValue=value;
  if (isAssignable(mf,value) || isEntity(mc)) {
    try {
      if (value instanceof Iterable) {
        MappedClass mapped=getMappedClass(mf.getSubClass());
        if (mapped != null && (Key.class.isAssignableFrom(mapped.getClazz()) || mapped.getEntityAnnotation() != null)) {
          mappedValue=getDBRefs((Iterable)value);
        }
 else {
          mappedValue=toMongoObject(value,false);
        }
      }
 else {
        final Key<?> key=(value instanceof Key) ? (Key<?>)value : getKey(value);
        if (key == null) {
          mappedValue=toMongoObject(value,false);
        }
 else {
          mappedValue=keyToRef(key);
          if (mappedValue == value) {
            throw new ValidationException(""String_Node_Str"" + value);
          }
        }
      }
    }
 catch (    Exception e) {
      LOG.error(""String_Node_Str"" + value + ""String_Node_Str"",e);
      mappedValue=toMongoObject(value,false);
    }
  }
 else   if (mf != null && mf.hasAnnotation(Serialized.class)) {
    try {
      mappedValue=Serializer.serialize(value,!mf.getAnnotation(Serialized.class).disableCompression());
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
  }
 else   if (value instanceof DBObject) {
    mappedValue=value;
  }
 else {
    mappedValue=toMongoObject(value,EmbeddedMapper.shouldSaveClassName(value,mappedValue,mf));
    if (mappedValue instanceof BasicDBList) {
      final BasicDBList list=(BasicDBList)mappedValue;
      if (list.size() != 0) {
        if (!EmbeddedMapper.shouldSaveClassName(extractFirstElement(value),list.get(0),mf)) {
          for (          Object o : list) {
            if (o instanceof DBObject) {
              ((DBObject)o).removeField(CLASS_NAME_FIELDNAME);
            }
          }
        }
      }
    }
 else     if (mappedValue instanceof DBObject && !EmbeddedMapper.shouldSaveClassName(value,mappedValue,mf)) {
      ((DBObject)mappedValue).removeField(CLASS_NAME_FIELDNAME);
    }
  }
  return mappedValue;
}",0.9908695652173912
104670,"@Test public void testInQueryByKey() throws Exception {
  final HasRefs hr=new HasRefs();
  List<Key<ReferencedEntity>> refs=new ArrayList<Key<ReferencedEntity>>();
  for (int x=0; x < 10; x++) {
    final ReferencedEntity re=new ReferencedEntity(""String_Node_Str"" + x);
    getDs().save(re);
    refs.add(new Key<QueryInForKeyTest.ReferencedEntity>(ReferencedEntity.class.getName(),re.getId()));
  }
  hr.ref=refs.get(0);
  getDs().save(hr);
  Query<HasRefs> query=getDs().createQuery(HasRefs.class).field(""String_Node_Str"").in(refs);
  final List<HasRefs> res=query.asList();
  Assert.assertEquals(1,res.size());
}","@Test public void testInQueryByKey() throws Exception {
  final HasRefs hr=new HasRefs();
  List<Key<ReferencedEntity>> refs=new ArrayList<Key<ReferencedEntity>>();
  for (int x=0; x < 10; x++) {
    final ReferencedEntity re=new ReferencedEntity(""String_Node_Str"" + x);
    getDs().save(re);
    refs.add(new Key<QueryInForKeyTest.ReferencedEntity>(ReferencedEntity.class.getName(),re.getId()));
  }
  hr.ref=refs.get(0);
  getDs().save(hr);
  Query<HasRefs> query=getDs().createQuery(HasRefs.class).field(""String_Node_Str"").in(refs);
  try {
    final List<HasRefs> res=query.asList();
    Assert.assertEquals(1,res.size());
  }
 catch (  MongoException e) {
    LOG.debug(""String_Node_Str"" + query);
    throw e;
  }
}",0.9214659685863874
104671,"@Test @Ignore(""String_Node_Str"" + ""String_Node_Str"") public void testInQuery() throws Exception {
  final HasRefs hr=new HasRefs();
  for (int x=0; x < 10; x++) {
    final ReferencedEntity re=new ReferencedEntity(""String_Node_Str"" + x);
    hr.refs.add(re);
  }
  getDs().save(hr.refs);
  getDs().save(hr);
  Query<HasRefs> query=getDs().createQuery(HasRefs.class).field(""String_Node_Str"").in(hr.refs.subList(1,3));
  final List<HasRefs> res=query.asList();
  Assert.assertEquals(1,res.size());
}","@Test public void testInQuery() throws Exception {
  final HasRefs hr=new HasRefs();
  for (int x=0; x < 10; x++) {
    final ReferencedEntity re=new ReferencedEntity(""String_Node_Str"" + x);
    hr.refs.add(re);
  }
  getDs().save(hr.refs);
  getDs().save(hr);
  Query<HasRefs> query=getDs().createQuery(HasRefs.class).field(""String_Node_Str"").in(hr.refs.subList(1,3));
  final List<HasRefs> res=query.asList();
  Assert.assertEquals(1,res.size());
}",0.3231256599788806
104672,"public void addTo(final DBObject obj){
  if (joinMethod == CriteriaJoin.AND) {
    Map<String,Integer> fields=new HashMap<String,Integer>();
    for (    final Criteria child : children) {
      String field=child.getFieldName();
      if (null != field) {
        if (fields.containsKey(field))         fields.put(field,fields.get(field) + 1);
 else         fields.put(field,1);
      }
    }
    List<Criteria> ands=new ArrayList<Criteria>();
    for (    Criteria child : this.children) {
      String field=child.getFieldName();
      if (null != field || fields.get(field) <= 1) {
        child.addTo(obj);
      }
 else {
        ands.add(child);
      }
    }
    if (ands.size() > 0) {
      final BasicDBList and=new BasicDBList();
      for (      final Criteria child : ands) {
        final BasicDBObject container=new BasicDBObject();
        child.addTo(container);
        and.add(container);
      }
      obj.put(""String_Node_Str"",and);
    }
  }
 else   if (joinMethod == CriteriaJoin.OR) {
    final BasicDBList or=new BasicDBList();
    for (    final Criteria child : children) {
      final BasicDBObject container=new BasicDBObject();
      child.addTo(container);
      or.add(container);
    }
    obj.put(""String_Node_Str"",or);
  }
}","public void addTo(final DBObject obj){
  if (joinMethod == CriteriaJoin.AND) {
    final Set<String> fields=new HashSet<String>();
    int nonNullFieldNames=0;
    for (    final Criteria child : children) {
      if (null != child.getFieldName()) {
        fields.add(child.getFieldName());
        nonNullFieldNames++;
      }
    }
    if (fields.size() < nonNullFieldNames) {
      final BasicDBList and=new BasicDBList();
      for (      final Criteria child : children) {
        final BasicDBObject container=new BasicDBObject();
        child.addTo(container);
        and.add(container);
      }
      obj.put(""String_Node_Str"",and);
    }
 else {
      for (      final Criteria child : children) {
        child.addTo(obj);
      }
    }
  }
 else   if (joinMethod == CriteriaJoin.OR) {
    final BasicDBList or=new BasicDBList();
    for (    final Criteria child : children) {
      final BasicDBObject container=new BasicDBObject();
      child.addTo(container);
      or.add(container);
    }
    obj.put(""String_Node_Str"",or);
  }
}",0.6022530329289428
104673,"public void addTo(final DBObject obj){
  if (joinMethod == CriteriaJoin.AND) {
    final Set<String> fields=new HashSet<String>();
    int nonNullFieldNames=0;
    for (    final Criteria child : children) {
      if (null != child.getFieldName()) {
        fields.add(child.getFieldName());
        nonNullFieldNames++;
      }
    }
    if (fields.size() < nonNullFieldNames) {
      final BasicDBList and=new BasicDBList();
      for (      final Criteria child : children) {
        final BasicDBObject container=new BasicDBObject();
        child.addTo(container);
        and.add(container);
      }
      obj.put(""String_Node_Str"",and);
    }
 else {
      for (      final Criteria child : children) {
        child.addTo(obj);
      }
    }
  }
 else   if (joinMethod == CriteriaJoin.OR) {
    final BasicDBList or=new BasicDBList();
    for (    final Criteria child : children) {
      final BasicDBObject container=new BasicDBObject();
      child.addTo(container);
      or.add(container);
    }
    obj.put(""String_Node_Str"",or);
  }
}","public void addTo(final DBObject obj){
  if (joinMethod == CriteriaJoin.AND) {
    Map<String,Integer> fields=new HashMap<String,Integer>();
    for (    final Criteria child : children) {
      String field=child.getFieldName();
      if (null != field) {
        if (fields.containsKey(field))         fields.put(field,fields.get(field) + 1);
 else         fields.put(field,1);
      }
    }
    List<Criteria> ands=new ArrayList<Criteria>();
    for (    Criteria child : this.children) {
      String field=child.getFieldName();
      if (null != field || fields.get(field) <= 1) {
        child.addTo(obj);
      }
 else {
        ands.add(child);
      }
    }
    if (ands.size() > 0) {
      final BasicDBList and=new BasicDBList();
      for (      final Criteria child : ands) {
        final BasicDBObject container=new BasicDBObject();
        child.addTo(container);
        and.add(container);
      }
      obj.put(""String_Node_Str"",and);
    }
  }
 else   if (joinMethod == CriteriaJoin.OR) {
    final BasicDBList or=new BasicDBList();
    for (    final Criteria child : children) {
      final BasicDBObject container=new BasicDBObject();
      child.addTo(container);
      or.add(container);
    }
    obj.put(""String_Node_Str"",or);
  }
}",0.5528596187175043
104674,"public <T>Key<T> merge(final T entity,final WriteConcern wc){
  T unwrapped=entity;
  final LinkedHashMap<Object,DBObject> involvedObjects=new LinkedHashMap<Object,DBObject>();
  final DBObject dbObj=mapper.toDBObject(unwrapped,involvedObjects);
  final Key<T> key=getKey(unwrapped);
  unwrapped=ProxyHelper.unwrap(unwrapped);
  final Object id=getId(unwrapped);
  if (id == null) {
    throw new MappingException(""String_Node_Str"" + unwrapped.getClass().getName());
  }
  dbObj.removeField(Mapper.ID_KEY);
  WriteResult wr;
  final MappedClass mc=mapper.getMappedClass(unwrapped);
  final DBCollection dbColl=getCollection(unwrapped);
  wr=tryVersionedUpdate(dbColl,unwrapped,dbObj,wc,db,mc);
  if (wr == null) {
    final Query<T> query=(Query<T>)createQuery(unwrapped.getClass()).filter(Mapper.ID_KEY,id);
    wr=update(query,new BasicDBObject(""String_Node_Str"",dbObj),false,false,wc).getWriteResult();
  }
  final UpdateResults<T> res=new UpdateResults<T>(wr);
  throwOnError(wc,wr);
  final CommandResult gle=wr.getCachedLastError();
  if (gle != null && res.getUpdatedCount() == 0) {
    throw new UpdateException(""String_Node_Str"" + gle);
  }
  postSaveOperations(unwrapped,dbObj,involvedObjects);
  return key;
}","public <T>Key<T> merge(final T entity,final WriteConcern wc){
  T unwrapped=entity;
  final LinkedHashMap<Object,DBObject> involvedObjects=new LinkedHashMap<Object,DBObject>();
  final DBObject dbObj=mapper.toDBObject(unwrapped,involvedObjects);
  final Key<T> key=getKey(unwrapped);
  unwrapped=ProxyHelper.unwrap(unwrapped);
  final Object id=getId(unwrapped);
  if (id == null) {
    throw new MappingException(""String_Node_Str"" + unwrapped.getClass().getName());
  }
  final Object idValue=dbObj.get(Mapper.ID_KEY);
  dbObj.removeField(Mapper.ID_KEY);
  WriteResult wr;
  final MappedClass mc=mapper.getMappedClass(unwrapped);
  final DBCollection dbColl=getCollection(unwrapped);
  wr=tryVersionedUpdate(dbColl,unwrapped,dbObj,idValue,wc,db,mc);
  if (wr == null) {
    final Query<T> query=(Query<T>)createQuery(unwrapped.getClass()).filter(Mapper.ID_KEY,id);
    wr=update(query,new BasicDBObject(""String_Node_Str"",dbObj),false,false,wc).getWriteResult();
  }
  final UpdateResults<T> res=new UpdateResults<T>(wr);
  throwOnError(wc,wr);
  final CommandResult gle=wr.getCachedLastError();
  if (gle != null && res.getUpdatedCount() == 0) {
    throw new UpdateException(""String_Node_Str"" + gle);
  }
  postSaveOperations(unwrapped,dbObj,involvedObjects);
  return key;
}",0.6271525830997197
104675,"protected <T>WriteResult tryVersionedUpdate(final DBCollection dbColl,final T entity,final DBObject dbObj,final WriteConcern wc,final DB database,final MappedClass mc){
  WriteResult wr=null;
  if (mc.getFieldsAnnotatedWith(Version.class).isEmpty()) {
    return wr;
  }
  final MappedField mfVersion=mc.getFieldsAnnotatedWith(Version.class).get(0);
  final String versionKeyName=mfVersion.getNameToStore();
  final Long oldVersion=(Long)mfVersion.getFieldValue(entity);
  final long newVersion=VersionHelper.nextValue(oldVersion);
  dbObj.put(versionKeyName,newVersion);
  if (oldVersion != null && oldVersion > 0) {
    final Object idValue=dbObj.get(Mapper.ID_KEY);
    final UpdateResults<T> res=update(find(dbColl.getName(),(Class<T>)entity.getClass()).filter(Mapper.ID_KEY,idValue).filter(versionKeyName,oldVersion),dbObj,false,false,wc);
    wr=res.getWriteResult();
    if (res.getUpdatedCount() != 1) {
      throw new ConcurrentModificationException(""String_Node_Str"" + entity.getClass().getName() + ""String_Node_Str""+ idValue+ ""String_Node_Str""+ oldVersion+ ""String_Node_Str"");
    }
  }
 else   if (wc == null) {
    wr=dbColl.save(dbObj);
  }
 else {
    wr=dbColl.save(dbObj,wc);
  }
  mfVersion.setFieldValue(entity,newVersion);
  return wr;
}","protected <T>WriteResult tryVersionedUpdate(final DBCollection dbColl,final T entity,final DBObject dbObj,final Object idValue,final WriteConcern wc,final DB database,final MappedClass mc){
  WriteResult wr=null;
  if (mc.getFieldsAnnotatedWith(Version.class).isEmpty()) {
    return wr;
  }
  final MappedField mfVersion=mc.getFieldsAnnotatedWith(Version.class).get(0);
  final String versionKeyName=mfVersion.getNameToStore();
  final Long oldVersion=(Long)mfVersion.getFieldValue(entity);
  final long newVersion=VersionHelper.nextValue(oldVersion);
  dbObj.put(versionKeyName,newVersion);
  if (oldVersion != null && oldVersion > 0) {
    final UpdateResults<T> res=update(find(dbColl.getName(),(Class<T>)entity.getClass()).filter(Mapper.ID_KEY,idValue).filter(versionKeyName,oldVersion),dbObj,false,false,wc);
    wr=res.getWriteResult();
    if (res.getUpdatedCount() != 1) {
      throw new ConcurrentModificationException(""String_Node_Str"" + entity.getClass().getName() + ""String_Node_Str""+ idValue+ ""String_Node_Str""+ oldVersion+ ""String_Node_Str"");
    }
  }
 else   if (wc == null) {
    wr=dbColl.save(dbObj);
  }
 else {
    wr=dbColl.save(dbObj,wc);
  }
  mfVersion.setFieldValue(entity,newVersion);
  return wr;
}",0.9034593724859212
104676,"private Class getClass(DBObject dbObj){
  String className=(String)dbObj.get(Mapper.CLASS_NAME_FIELDNAME);
  Class c=null;
  if (className != null) {
    try {
      c=Class.forName(className,true,Thread.currentThread().getContextClassLoader());
    }
 catch (    ClassNotFoundException e) {
      if (log.isWarningEnabled())       log.warning(""String_Node_Str"",e);
    }
  }
  return c;
}","private Class getClass(DBObject dbObj){
  String className=(String)dbObj.get(Mapper.CLASS_NAME_FIELDNAME);
  Class c=null;
  if (className != null) {
    try {
      c=Class.forName(className,true,getClassLoaderForClass(className,dbObj));
    }
 catch (    ClassNotFoundException e) {
      if (log.isWarningEnabled())       log.warning(""String_Node_Str"",e);
    }
  }
  return c;
}",0.9234760051880676
104677,"private void writeCollection(final MappedField mf,final DBObject dbObject,Map<Object,DBObject> involvedObjects,String name,Object fieldValue,Mapper mapr){
  Iterable coll=null;
  if (mf.isArray)   coll=Arrays.asList((Object[])fieldValue);
 else   coll=(Iterable)fieldValue;
  if (coll != null) {
    List values=new ArrayList();
    for (    Object o : coll) {
      if (mapr.converters.hasSimpleValueConverter(mf) || mapr.converters.hasSimpleValueConverter(o.getClass()))       values.add(mapr.converters.encode(o));
 else {
        Object val;
        if (Collection.class.isAssignableFrom(o.getClass()) || Map.class.isAssignableFrom(o.getClass()))         val=mapr.toMongoObject(o,true);
 else         val=mapr.toDBObject(o,involvedObjects);
        if (!shouldSaveClassName(o,val,mf))         ((DBObject)val).removeField(Mapper.CLASS_NAME_FIELDNAME);
        values.add(val);
      }
    }
    if (values.size() > 0 || mapr.getOptions().storeEmpties) {
      dbObject.put(name,values);
    }
  }
}","private void writeCollection(final MappedField mf,final DBObject dbObject,Map<Object,DBObject> involvedObjects,String name,Object fieldValue,Mapper mapr){
  Iterable coll=null;
  if (fieldValue != null)   if (mf.isArray)   coll=Arrays.asList((Object[])fieldValue);
 else   coll=(Iterable)fieldValue;
  if (coll != null) {
    List values=new ArrayList();
    for (    Object o : coll) {
      if (mapr.converters.hasSimpleValueConverter(mf) || mapr.converters.hasSimpleValueConverter(o.getClass()))       values.add(mapr.converters.encode(o));
 else {
        Object val;
        if (Collection.class.isAssignableFrom(o.getClass()) || Map.class.isAssignableFrom(o.getClass()))         val=mapr.toMongoObject(o,true);
 else         val=mapr.toDBObject(o,involvedObjects);
        if (!shouldSaveClassName(o,val,mf))         ((DBObject)val).removeField(Mapper.CLASS_NAME_FIELDNAME);
        values.add(val);
      }
    }
    if (values.size() > 0 || mapr.getOptions().storeEmpties) {
      dbObject.put(name,values);
    }
  }
}",0.9871794871794872
104678,"<T>WriteResult delete(String kind,T id);","<T,V>WriteResult delete(String kind,Class<T> clazz,V id);",0.8247422680412371
104679,"private void writeCollection(final MappedField mf,final DBObject dbObject,Map<Object,DBObject> involvedObjects,String name,Object fieldValue,Mapper mapr){
  Iterable coll=null;
  if (fieldValue != null)   if (mf.isArray)   coll=Arrays.asList((Object[])fieldValue);
 else   coll=(Iterable)fieldValue;
  if (coll != null) {
    List values=new ArrayList();
    for (    Object o : coll) {
      if (mapr.converters.hasSimpleValueConverter(mf) || mapr.converters.hasSimpleValueConverter(o.getClass()))       values.add(mapr.converters.encode(o));
 else {
        Object val;
        if (Collection.class.isAssignableFrom(o.getClass()) || Map.class.isAssignableFrom(o.getClass()))         val=mapr.toMongoObject(o,true);
 else         val=mapr.toDBObject(o,involvedObjects);
        if (!shouldSaveClassName(o,val,mf))         ((DBObject)val).removeField(Mapper.CLASS_NAME_FIELDNAME);
        values.add(val);
      }
    }
    if (values.size() > 0 || mapr.getOptions().storeEmpties) {
      dbObject.put(name,values);
    }
  }
}","private void writeCollection(final MappedField mf,final DBObject dbObject,Map<Object,DBObject> involvedObjects,String name,Object fieldValue,Mapper mapr){
  Iterable coll=null;
  if (fieldValue != null)   if (mf.isArray)   coll=Arrays.asList((Object[])fieldValue);
 else   coll=(Iterable)fieldValue;
  if (coll != null) {
    List values=new ArrayList();
    for (    Object o : coll) {
      if (null == o)       values.add(null);
 else       if (mapr.converters.hasSimpleValueConverter(mf) || mapr.converters.hasSimpleValueConverter(o.getClass()))       values.add(mapr.converters.encode(o));
 else {
        Object val;
        if (Collection.class.isAssignableFrom(o.getClass()) || Map.class.isAssignableFrom(o.getClass()))         val=mapr.toMongoObject(o,true);
 else         val=mapr.toDBObject(o,involvedObjects);
        if (!shouldSaveClassName(o,val,mf))         ((DBObject)val).removeField(Mapper.CLASS_NAME_FIELDNAME);
        values.add(val);
      }
    }
    if (values.size() > 0 || mapr.getOptions().storeEmpties) {
      dbObject.put(name,values);
    }
  }
}",0.975771971496437
104680,"@Override public String encode(Object uri,MappedField optionalExtraInfo){
  return ((URI)uri).toString().replace(""String_Node_Str"",""String_Node_Str"");
}","@Override public String encode(Object uri,MappedField optionalExtraInfo){
  if (uri == null)   return null;
  return ((URI)uri).toString().replace(""String_Node_Str"",""String_Node_Str"");
}",0.8994082840236687
104681,"public List<T> findIds(Query<T> q){
  return (List<T>)keysToIds(q.asKeyList());
}","public List<K> findIds(Query<T> q){
  return (List<K>)keysToIds(q.asKeyList());
}",0.9753086419753086
104682,"/** 
 * Finds the entities Ts by the criteria {key:value}
 */
public List<T> findIds(Query<T> q);","/** 
 * Finds the entities Ts by the criteria {key:value}
 */
public List<K> findIds(Query<T> q);",0.9896907216494846
104683,"@SuppressWarnings(""String_Node_Str"") <T>MapreduceResults<T> mapReduce(MapreduceType type,Query q,String map,String reduce,String finalize,Map<String,Object> scopeFields,Class<T> outputType);","/** 
 * Runs a map/reduce job at the server; this should be used with a server version 1.7.4 or higher
 * @param < T > The type of resulting data
 * @param type MapreduceType
 * @param q The query (only the criteria, limit and sort will be used)
 * @param outputType The type of resulting data; inline is not working yet
 * @param baseCommand The base command to fill in and send to the server
 * @return counts and stuff
 */
<T>MapreduceResults<T> mapReduce(MapreduceType type,Query q,Class<T> outputType,MapReduceCommand baseCommand);",0.2121212121212121
104684,"@SuppressWarnings(""String_Node_Str"") public <T>MapreduceResults<T> mapReduce(MapreduceType type,Query query,String map,String reduce,String finalize,Map<String,Object> scopeFields,Class<T> outputType){
  Assert.parametersNotNull(""String_Node_Str"",map);
  Assert.parameterNotEmpty(map,""String_Node_Str"");
  Assert.parametersNotNull(""String_Node_Str"",reduce);
  Assert.parameterNotEmpty(reduce,""String_Node_Str"");
  if (MapreduceType.INLINE.equals(type))   throw new IllegalArgumentException(""String_Node_Str"");
  QueryImpl<T> qi=(QueryImpl<T>)query;
  DBCollection dbColl=qi.getCollection();
  if (dbColl == null)   dbColl=getCollection(qi.getEntityClass());
  if (log.isTraceEnabled())   log.info(""String_Node_Str"" + dbColl.getName() + ""String_Node_Str""+ qi.toString()+ ""String_Node_Str""+ map+ ""String_Node_Str""+ reduce+ ""String_Node_Str""+ finalize+ ""String_Node_Str""+ scopeFields+ ""String_Node_Str"");
  String outColl=mapr.getCollectionName(outputType);
  BasicDBObjectBuilder bldr=BasicDBObjectBuilder.start(""String_Node_Str"",mapr.getCollectionName(qi.getEntityClass()));
switch (type) {
case REDUCE:
    bldr.push(""String_Node_Str"").add(""String_Node_Str"",outColl).pop();
  break;
case MERGE:
bldr.push(""String_Node_Str"").add(""String_Node_Str"",outColl).pop();
break;
case INLINE:
bldr.push(""String_Node_Str"").add(""String_Node_Str"",1).pop();
break;
default :
bldr.add(""String_Node_Str"",outColl);
break;
}
if (qi.getOffset() != 0 || qi.getFieldsObject() != null) throw new QueryException(""String_Node_Str"");
if (qi.getQueryObject() != null) bldr.add(""String_Node_Str"",qi.getQueryObject());
if (qi.getLimit() > 0) bldr.add(""String_Node_Str"",qi.getLimit());
if (qi.getSortObject() != null) bldr.add(""String_Node_Str"",qi.getSortObject());
bldr.add(""String_Node_Str"",map);
bldr.add(""String_Node_Str"",reduce);
if (finalize != null && finalize.length() > 0) bldr.add(""String_Node_Str"",finalize);
if (scopeFields != null && scopeFields.size() > 0) bldr.add(""String_Node_Str"",mapr.toMongoObject(null,null,scopeFields));
DBObject dbObj=bldr.get();
CommandResult cr=dbColl.getDB().command(dbObj);
cr.throwOnError();
MapreduceResults mrRes=(MapreduceResults)mapr.fromDBObject(MapreduceResults.class,cr,createCache());
QueryImpl baseQ=null;
if (!MapreduceType.INLINE.equals(type)) baseQ=new QueryImpl(outputType,db.getCollection(mrRes.getOutputCollectionName()),this);
mrRes.setBits(type,baseQ);
return mrRes;
}","@SuppressWarnings(""String_Node_Str"") public <T>MapreduceResults<T> mapReduce(MapreduceType type,Query query,String map,String reduce,String finalize,Map<String,Object> scopeFields,Class<T> outputType){
  QueryImpl<T> qi=(QueryImpl<T>)query;
  DBCollection dbColl=qi.getCollection();
  String outColl=mapr.getCollectionName(outputType);
  OutputType outType=OutputType.REPLACE;
switch (type) {
case REDUCE:
    outType=OutputType.REDUCE;
  break;
case MERGE:
outType=OutputType.MERGE;
break;
case INLINE:
outType=OutputType.INLINE;
break;
default :
outType=OutputType.REPLACE;
break;
}
MapReduceCommand cmd=new MapReduceCommand(dbColl,map,reduce,outColl,outType,qi.getQueryObject());
if (qi.getLimit() > 0) cmd.setLimit(qi.getLimit());
if (qi.getSortObject() != null) cmd.setSort(qi.getSortObject());
if (finalize != null && finalize.length() > 0) cmd.setFinalize(finalize);
if (scopeFields != null && scopeFields.size() > 0) cmd.setScope(scopeFields);
return mapReduce(type,query,outputType,cmd);
}",0.2313806299676185
104685,"public DBObject getFieldsObject(){
  if (fields == null || fields.length == 0)   return null;
  Map<String,Integer> fieldsFilter=new HashMap<String,Integer>();
  for (  String field : this.fields) {
    StringBuffer sb=new StringBuffer(field);
    Mapper.validate(clazz,ds.getMapper(),sb,FilterOperator.EQUAL,null,validateName,false);
    field=sb.toString();
    fieldsFilter.put(field,(includeFields ? 1 : 0));
  }
  return new BasicDBObject(fieldsFilter);
}","public DBObject getFieldsObject(){
  if (fields == null || fields.length == 0)   return null;
  Map<String,Integer> fieldsFilter=new HashMap<String,Integer>();
  for (  String field : this.fields) {
    StringBuffer sb=new StringBuffer(field);
    Mapper.validate(clazz,ds.getMapper(),sb,FilterOperator.EQUAL,null,validateName,false);
    field=sb.toString();
    fieldsFilter.put(field,(includeFields ? 1 : 0));
  }
  if (includeFields)   fieldsFilter.put(Mapper.CLASS_NAME_FIELDNAME,1);
  return new BasicDBObject(fieldsFilter);
}",0.9274193548387096
104686,"@Override public Object encode(Object value,MappedField mf){
  if (value == null)   return null;
  Iterable<?> iterableValues=null;
  if (value.getClass().isArray()) {
    if (Array.getLength(value) == 0) {
      return value;
    }
    if (value.getClass().getComponentType().isPrimitive())     return value;
    iterableValues=Arrays.asList((Object[])value);
  }
 else {
    if (!(value instanceof Iterable))     throw new ConverterException(""String_Node_Str"" + value.getClass() + ""String_Node_Str""+ mf);
    iterableValues=(Iterable<?>)value;
  }
  List values=new ArrayList();
  if (mf != null && mf.getSubClass() != null) {
    for (    Object o : iterableValues) {
      values.add(chain.encode(mf.getSubClass(),o));
    }
  }
 else {
    for (    Object o : iterableValues) {
      values.add(chain.encode(o));
    }
  }
  if (values.size() > 0) {
    return values;
  }
 else   return null;
}","@Override public Object encode(Object value,MappedField mf){
  if (value == null)   return null;
  Iterable<?> iterableValues=null;
  if (value.getClass().isArray()) {
    if (Array.getLength(value) == 0) {
      return value;
    }
    if (value.getClass().getComponentType().isPrimitive())     return value;
    iterableValues=Arrays.asList((Object[])value);
  }
 else {
    if (!(value instanceof Iterable))     throw new ConverterException(""String_Node_Str"" + value.getClass() + ""String_Node_Str""+ mf);
    iterableValues=(Iterable<?>)value;
  }
  List values=new ArrayList();
  if (mf != null && mf.getSubClass() != null) {
    for (    Object o : iterableValues) {
      values.add(chain.encode(mf.getSubClass(),o));
    }
  }
 else {
    for (    Object o : iterableValues) {
      values.add(chain.encode(o));
    }
  }
  if (values.size() > 0 || mapr.getOptions().storeEmpties) {
    return values;
  }
 else   return null;
}",0.9814612868047984
104687,"public List<Key<T>> findIds(Query<T> q){
  return (List<Key<T>>)keysToIds(q.asKeyList());
}","public Lis<T> findIds(Query<T> q){
  return (List<T>)keysToIds(q.asKeyList());
}",0.935672514619883
104688,"/** 
 * Finds the entities Key<T>s by the criteria {key:value}
 */
public List<Key<T>> findIds(Query<T> q);","/** 
 * Finds the entities Ts by the criteria {key:value}
 */
public List<T> findIds(Query<T> q);",0.9509803921568628
104689,"/** 
 * Add MappedClass to internal cache, possibly validating first. 
 */
private MappedClass addMappedClass(MappedClass mc,boolean validate){
  if (validate)   mc.validate();
  Converters c=(Converters)mc.getAnnotation(Converters.class);
  if (c != null)   for (  Class<? extends TypeConverter> clazz : c.value())   if (!converters.isRegistered(clazz))   converters.addConverter(clazz);
  mappedClasses.put(mc.getClazz().getName(),mc);
  Set<MappedClass> mcs=mappedClassesByCollection.get(mc.getCollectionName());
  if (mcs == null) {
    mcs=new HashSet();
    mappedClassesByCollection.putIfAbsent(mc.getCollectionName(),mcs);
  }
  mcs.add(mc);
  return mc;
}","/** 
 * Add MappedClass to internal cache, possibly validating first. 
 */
private MappedClass addMappedClass(MappedClass mc,boolean validate){
  if (validate)   mc.validate();
  Converters c=(Converters)mc.getAnnotation(Converters.class);
  if (c != null)   for (  Class<? extends TypeConverter> clazz : c.value())   if (!converters.isRegistered(clazz))   converters.addConverter(clazz);
  mappedClasses.put(mc.getClazz().getName(),mc);
  Set<MappedClass> mcs=mappedClassesByCollection.get(mc.getCollectionName());
  if (mcs == null) {
    mcs=new CopyOnWriteArraySet<MappedClass>();
    Set<MappedClass> temp=mappedClassesByCollection.putIfAbsent(mc.getCollectionName(),mcs);
    if (temp != null)     mcs=temp;
  }
  mcs.add(mc);
  return mc;
}",0.9241672572643516
104690,"public T sizeEq(int val){
  Assert.parametersNotNull(""String_Node_Str"",val);
  return addCrit(FilterOperator.SIZE,val);
}","public T sizeEq(int val){
  return addCrit(FilterOperator.SIZE,val);
}",0.7329842931937173
104691,"@Test public final void testMissingIdNoImplicitMapCall(){
  Key<E> save=ds.save(new E());
  E byKey=ds.getByKey(E.class,save);
}","@Test public final void testMissingIdNoImplicitMapCall(){
  final Key<E> save=ds.save(new E());
  new AssertedFailure(){
    @Override protected void thisMustFail() throws Throwable {
      E byKey=ds.getByKey(E.class,save);
    }
  }
;
}",0.6994535519125683
104692,"@Override protected void thisMustFail() throws Throwable {
  morphia.map(E.class);
}","@Override protected void thisMustFail() throws Throwable {
  E byKey=ds.getByKey(E.class,save);
}",0.8176795580110497
104693,"public void addTo(DBObject obj){
  if (this.joinMethod == CriteriaJoin.AND) {
    for (    Criteria child : this.children) {
      child.addTo(obj);
    }
  }
 else   if (this.joinMethod == CriteriaJoin.OR) {
    BasicDBList or=new BasicDBList();
    for (    Criteria child : this.children) {
      BasicDBObject container=new BasicDBObject();
      child.addTo(container);
      or.add(container);
    }
    obj.put(""String_Node_Str"",or);
  }
}","public void addTo(DBObject obj){
  if (this.joinMethod == CriteriaJoin.AND) {
    Set<String> fields=new HashSet<String>();
    int nonNullFieldNames=0;
    for (    Criteria child : this.children) {
      if (null != child.getFieldName()) {
        fields.add(child.getFieldName());
        nonNullFieldNames++;
      }
    }
    if (fields.size() < nonNullFieldNames) {
      BasicDBList and=new BasicDBList();
      for (      Criteria child : this.children) {
        BasicDBObject container=new BasicDBObject();
        child.addTo(container);
        and.add(container);
      }
      obj.put(""String_Node_Str"",and);
    }
 else {
      for (      Criteria child : this.children) {
        child.addTo(obj);
      }
    }
  }
 else   if (this.joinMethod == CriteriaJoin.OR) {
    BasicDBList or=new BasicDBList();
    for (    Criteria child : this.children) {
      BasicDBObject container=new BasicDBObject();
      child.addTo(container);
      or.add(container);
    }
    obj.put(""String_Node_Str"",or);
  }
}",0.4
104694,"public Query<T> queryNonPrimary(){
  slaveOk=true;
  return this;
}","public Query<T> queryNonPrimary(){
  readPref=ReadPreference.SECONDARY;
  return this;
}",0.7483870967741936
104695,"public Query<T> queryPrimaryOnly(){
  slaveOk=false;
  return this;
}","public Query<T> queryPrimaryOnly(){
  readPref=ReadPreference.PRIMARY;
  return this;
}",0.782051282051282
104696,"public DBCursor prepareCursor(){
  DBObject query=getQueryObject();
  DBObject fields=getFieldsObject();
  if (log.isTraceEnabled())   log.trace(""String_Node_Str"" + dbColl.getName() + ""String_Node_Str""+ query+ ""String_Node_Str""+ fields+ ""String_Node_Str""+ offset+ ""String_Node_Str""+ limit);
  DBCursor cursor=dbColl.find(query,fields);
  cursor.setDecoderFactory(this.ds.getDecoderFact());
  if (offset > 0)   cursor.skip(offset);
  if (limit > 0)   cursor.limit(limit);
  if (batchSize > 0)   cursor.batchSize(batchSize);
  if (snapshotted)   cursor.snapshot();
  if (sort != null)   cursor.sort(sort);
  if (indexHint != null)   cursor.hint(indexHint);
  if (slaveOk) {
    cursor.addOption(Bytes.QUERYOPTION_SLAVEOK);
  }
  if (noTimeout) {
    cursor.addOption(Bytes.QUERYOPTION_NOTIMEOUT);
  }
  if (tail) {
    cursor.addOption(Bytes.QUERYOPTION_TAILABLE);
    if (tail_await_data)     cursor.addOption(Bytes.QUERYOPTION_AWAITDATA);
  }
  if (snapshotted && (sort != null || indexHint != null))   log.warning(""String_Node_Str"");
  if (tail && (sort != null)) {
    log.warning(""String_Node_Str"");
  }
  return cursor;
}","public DBCursor prepareCursor(){
  DBObject query=getQueryObject();
  DBObject fields=getFieldsObject();
  if (log.isTraceEnabled())   log.trace(""String_Node_Str"" + dbColl.getName() + ""String_Node_Str""+ query+ ""String_Node_Str""+ fields+ ""String_Node_Str""+ offset+ ""String_Node_Str""+ limit);
  DBCursor cursor=dbColl.find(query,fields);
  cursor.setDecoderFactory(this.ds.getDecoderFact());
  if (offset > 0)   cursor.skip(offset);
  if (limit > 0)   cursor.limit(limit);
  if (batchSize > 0)   cursor.batchSize(batchSize);
  if (snapshotted)   cursor.snapshot();
  if (sort != null)   cursor.sort(sort);
  if (indexHint != null)   cursor.hint(indexHint);
  if (null != readPref) {
    cursor.setReadPreference(readPref);
  }
  if (noTimeout) {
    cursor.addOption(Bytes.QUERYOPTION_NOTIMEOUT);
  }
  if (tail) {
    cursor.addOption(Bytes.QUERYOPTION_TAILABLE);
    if (tail_await_data)     cursor.addOption(Bytes.QUERYOPTION_AWAITDATA);
  }
  if (snapshotted && (sort != null || indexHint != null))   log.warning(""String_Node_Str"");
  if (tail && (sort != null)) {
    log.warning(""String_Node_Str"");
  }
  return cursor;
}",0.9644444444444444
104697,"@Override public QueryImpl<T> clone(){
  QueryImpl<T> n=new QueryImpl<T>(clazz,dbColl,ds);
  n.batchSize=batchSize;
  n.cache=this.ds.getMapper().createEntityCache();
  n.fields=fields == null ? null : Arrays.copyOf(fields,fields.length);
  n.includeFields=includeFields;
  n.indexHint=indexHint;
  n.limit=limit;
  n.noTimeout=noTimeout;
  n.query=n;
  n.offset=offset;
  n.slaveOk=slaveOk;
  n.snapshotted=snapshotted;
  n.validateName=validateName;
  n.validateType=validateType;
  n.sort=(BasicDBObject)(sort == null ? null : sort.clone());
  n.baseQuery=(BasicDBObject)(baseQuery == null ? null : baseQuery.clone());
  n.attachedTo=attachedTo;
  n.children=children == null ? null : new ArrayList<Criteria>(children);
  n.tail=tail;
  n.tail_await_data=tail_await_data;
  return n;
}","@Override public QueryImpl<T> clone(){
  QueryImpl<T> n=new QueryImpl<T>(clazz,dbColl,ds);
  n.batchSize=batchSize;
  n.cache=this.ds.getMapper().createEntityCache();
  n.fields=fields == null ? null : Arrays.copyOf(fields,fields.length);
  n.includeFields=includeFields;
  n.indexHint=indexHint;
  n.limit=limit;
  n.noTimeout=noTimeout;
  n.query=n;
  n.offset=offset;
  n.readPref=readPref;
  n.snapshotted=snapshotted;
  n.validateName=validateName;
  n.validateType=validateType;
  n.sort=(BasicDBObject)(sort == null ? null : sort.clone());
  n.baseQuery=(BasicDBObject)(baseQuery == null ? null : baseQuery.clone());
  n.attachedTo=attachedTo;
  n.children=children == null ? null : new ArrayList<Criteria>(children);
  n.tail=tail;
  n.tail_await_data=tail_await_data;
  return n;
}",0.9797211660329532
104698,"public Object getId(Object entity){
  entity=ProxyHelper.unwrap(entity);
  MappedClass mc=getMappedClass(entity.getClass());
  try {
    return mc.getIdField().get(entity);
  }
 catch (  Exception e) {
    return null;
  }
}","public Object getId(Object entity){
  if (entity == null)   return null;
  entity=ProxyHelper.unwrap(entity);
  MappedClass mc=getMappedClass(entity.getClass());
  try {
    return mc.getIdField().get(entity);
  }
 catch (  Exception e) {
    return null;
  }
}",0.9237113402061856
104699,"/** 
 * <p> Converts a java object to a mongo-compatible object (possibly a DBObject for complex mappings). Very similar to   {@link Mapper.toDBObject}</p> <p> Used (mainly) by query/update operations </p>
 */
public Object toMongoObject(MappedField mf,MappedClass mc,Object value){
  Object mappedValue=value;
  if ((mf != null && (mf.hasAnnotation(Reference.class) || mf.getType().isAssignableFrom(Key.class) || mf.getType().isAssignableFrom(DBRef.class)|| (value instanceof Iterable && mf.isMultipleValues() && (mf.getSubClass().isAssignableFrom(Key.class) || mf.getSubClass().isAssignableFrom(DBRef.class))))) || (mc != null && mc.getEntityAnnotation() != null)) {
    try {
      if (value instanceof Iterable) {
        ArrayList<DBRef> refs=new ArrayList<DBRef>();
        Iterable it=(Iterable)value;
        for (        Object o : it) {
          Key<?> k=(o instanceof Key) ? (Key<?>)o : getKey(o);
          DBRef dbref=keyToRef(k);
          refs.add(dbref);
        }
        mappedValue=refs;
      }
 else {
        if (value == null)         mappedValue=null;
        Key<?> k=(value instanceof Key) ? (Key<?>)value : getKey(value);
        mappedValue=keyToRef(k);
        if (mappedValue == value)         throw new ValidationException(""String_Node_Str"");
      }
    }
 catch (    Exception e) {
      log.error(""String_Node_Str"" + value + ""String_Node_Str"",e);
      mappedValue=toMongoObject(value,false);
    }
  }
 else   if (mf != null && mf.hasAnnotation(Serialized.class))   try {
    mappedValue=Serializer.serialize(value,!mf.getAnnotation(Serialized.class).disableCompression());
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
 else   if (value instanceof DBObject)   mappedValue=value;
 else {
    mappedValue=toMongoObject(value,EmbeddedMapper.shouldSaveClassName(value,mappedValue,mf));
    if (mappedValue instanceof DBObject && !EmbeddedMapper.shouldSaveClassName(value,mappedValue,mf))     ((DBObject)mappedValue).removeField(CLASS_NAME_FIELDNAME);
  }
  return mappedValue;
}","/** 
 * <p> Converts a java object to a mongo-compatible object (possibly a DBObject for complex mappings). Very similar to   {@link Mapper.toDBObject}</p> <p> Used (mainly) by query/update operations </p>
 */
public Object toMongoObject(MappedField mf,MappedClass mc,Object value){
  Object mappedValue=value;
  if ((mf != null && (mf.hasAnnotation(Reference.class) || mf.getType().isAssignableFrom(Key.class) || mf.getType().isAssignableFrom(DBRef.class)|| (value instanceof Iterable && mf.isMultipleValues() && (mf.getSubClass().isAssignableFrom(Key.class) || mf.getSubClass().isAssignableFrom(DBRef.class))))) || (mc != null && mc.getEntityAnnotation() != null)) {
    try {
      if (value instanceof Iterable) {
        ArrayList<DBRef> refs=new ArrayList<DBRef>();
        Iterable it=(Iterable)value;
        for (        Object o : it) {
          Key<?> k=(o instanceof Key) ? (Key<?>)o : getKey(o);
          DBRef dbref=keyToRef(k);
          refs.add(dbref);
        }
        mappedValue=refs;
      }
 else {
        if (value == null)         mappedValue=null;
        Key<?> k=(value instanceof Key) ? (Key<?>)value : getKey(value);
        mappedValue=keyToRef(k);
        if (mappedValue == value)         throw new ValidationException(""String_Node_Str"" + value);
      }
    }
 catch (    Exception e) {
      log.error(""String_Node_Str"" + value + ""String_Node_Str"",e);
      mappedValue=toMongoObject(value,false);
    }
  }
 else   if (mf != null && mf.hasAnnotation(Serialized.class))   try {
    mappedValue=Serializer.serialize(value,!mf.getAnnotation(Serialized.class).disableCompression());
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
 else   if (value instanceof DBObject)   mappedValue=value;
 else {
    mappedValue=toMongoObject(value,EmbeddedMapper.shouldSaveClassName(value,mappedValue,mf));
    if (mappedValue instanceof DBObject && !EmbeddedMapper.shouldSaveClassName(value,mappedValue,mf))     ((DBObject)mappedValue).removeField(CLASS_NAME_FIELDNAME);
  }
  return mappedValue;
}",0.998038254046101
104700,"public <T>Key<T> refToKey(DBRef ref){
  Key<T> key=new Key<T>(ref.getRef(),ref.getId());
  return key;
}","public <T>Key<T> refToKey(DBRef ref){
  if (ref == null)   return null;
  Key<T> key=new Key<T>(ref.getRef(),ref.getId());
  return key;
}",0.859504132231405
104701,"public DBRef keyToRef(Key key){
  if (key.getKindClass() == null && key.getKind() == null)   throw new IllegalStateException(""String_Node_Str"");
  if (key.getKind() == null)   key.setKind(getCollectionName(key.getKindClass()));
  return new DBRef(null,key.getKind(),key.getId());
}","public DBRef keyToRef(Key key){
  if (key == null)   return null;
  if (key.getKindClass() == null && key.getKind() == null)   throw new IllegalStateException(""String_Node_Str"");
  if (key.getKind() == null)   key.setKind(getCollectionName(key.getKindClass()));
  return new DBRef(null,key.getKind(),key.getId());
}",0.9429530201342282
104702,"protected <T>WriteResult tryVersionedUpdate(DBCollection dbColl,T entity,DBObject dbObj,WriteConcern wc,DB db,MappedClass mc){
  WriteResult wr=null;
  if (mc.getFieldsAnnotatedWith(Version.class).isEmpty())   return wr;
  MappedField mfVersion=mc.getFieldsAnnotatedWith(Version.class).get(0);
  String versionKeyName=mfVersion.getNameToStore();
  Long oldVersion=(Long)mfVersion.getFieldValue(entity);
  long newVersion=VersionHelper.nextValue(oldVersion);
  dbObj.put(versionKeyName,newVersion);
  if (oldVersion != null && oldVersion > 0) {
    Object idValue=dbObj.get(Mapper.ID_KEY);
    UpdateResults<T> res=update(find((Class<T>)entity.getClass(),Mapper.ID_KEY,idValue).filter(versionKeyName,oldVersion),dbObj,false,false,wc);
    wr=res.getWriteResult();
    if (res.getUpdatedCount() != 1)     throw new ConcurrentModificationException(""String_Node_Str"" + entity.getClass().getName() + ""String_Node_Str""+ idValue+ ""String_Node_Str""+ oldVersion+ ""String_Node_Str"");
  }
 else   if (wc == null)   wr=dbColl.save(dbObj);
 else   wr=dbColl.save(dbObj,wc);
  mfVersion.setFieldValue(entity,newVersion);
  return wr;
}","protected <T>WriteResult tryVersionedUpdate(DBCollection dbColl,T entity,DBObject dbObj,WriteConcern wc,DB db,MappedClass mc){
  WriteResult wr=null;
  if (mc.getFieldsAnnotatedWith(Version.class).isEmpty())   return wr;
  MappedField mfVersion=mc.getFieldsAnnotatedWith(Version.class).get(0);
  String versionKeyName=mfVersion.getNameToStore();
  Long oldVersion=(Long)mfVersion.getFieldValue(entity);
  long newVersion=VersionHelper.nextValue(oldVersion);
  dbObj.put(versionKeyName,newVersion);
  if (oldVersion != null && oldVersion > 0) {
    Object idValue=dbObj.get(Mapper.ID_KEY);
    UpdateResults<T> res=update(find(dbColl.getName(),(Class<T>)entity.getClass()).filter(Mapper.ID_KEY,idValue).filter(versionKeyName,oldVersion),dbObj,false,false,wc);
    wr=res.getWriteResult();
    if (res.getUpdatedCount() != 1)     throw new ConcurrentModificationException(""String_Node_Str"" + entity.getClass().getName() + ""String_Node_Str""+ idValue+ ""String_Node_Str""+ oldVersion+ ""String_Node_Str"");
  }
 else   if (wc == null)   wr=dbColl.save(dbObj);
 else   wr=dbColl.save(dbObj,wc);
  mfVersion.setFieldValue(entity,newVersion);
  return wr;
}",0.988089986766652
104703,"public <T>Query<T> queryByExample(T ex){
  return new QueryImpl<T>((Class<T>)ex.getClass(),getCollection(ex),this,entityToDBObj(ex,new HashMap<Object,DBObject>()));
}","private <T>Query<T> queryByExample(DBCollection coll,T example){
  return new QueryImpl<T>((Class<T>)example.getClass(),coll,this,entityToDBObj(example,new HashMap<Object,DBObject>()));
}",0.8385269121813032
104704,"<T>Iterable<Key<T>> insert(Iterable<T> entities,WriteConcern wc);","<T>Iterable<Key<T>> insert(String kind,Iterable<T> entities,WriteConcern wc);",0.9154929577464788
104705,"public static long nextValue(Long oldVersion){
  long currentTimeMillis=System.currentTimeMillis();
  if (oldVersion != null && oldVersion.longValue() == currentTimeMillis)   currentTimeMillis++;
  return currentTimeMillis;
}","public static long nextValue(Long oldVersion){
  long newVersion=oldVersion == null ? 1 : oldVersion + 1;
  return newVersion;
}",0.5892351274787535
104706,"public WriteResult deleteByQuery(Query q){
  return ds.delete(q);
}","public WriteResult deleteByQuery(Query<T> q){
  return ds.delete(q);
}",0.978102189781022
104707,"/** 
 * Returns an tailing iterator over a set of elements of type T. If awaitData is true, this iterator blocks on hasNext() until new data is avail. Note that if no data is available  at all, hasNext() might return immediately.
 * @return an Iterator.
 */
Iterator<T> tail(boolean awaitData);","/** 
 * Returns an tailing iterator over a set of elements of type T. If awaitData is true, this iterator blocks on hasNext() until new data is avail (or some amount of time has passed). Note that if no data is available  at all, hasNext() might return immediately. You should wrap tail calls in a loop if you want this to be blocking.
 * @return an Iterator.
 */
Iterator<T> tail(boolean awaitData);",0.8472622478386167
104708,"public T near(double x,double y,boolean spherical){
  return addGeoCrit(FilterOperator.NEAR,new double[]{x,y},spherical ? opts(""String_Node_Str"",true) : null);
}","public T near(double x,double y,boolean spherical){
  return addGeoCrit(spherical ? FilterOperator.NEAR_SPHERE : FilterOperator.NEAR,new double[]{x,y},null);
}",0.7375
104709,"@Override public void addTo(DBObject obj){
  BasicDBObjectBuilder query=null;
switch (operator) {
case NEAR:
    query=BasicDBObjectBuilder.start(FilterOperator.NEAR.val(),value);
  break;
case WITHIN_BOX:
query=BasicDBObjectBuilder.start().push(FilterOperator.WITHIN.val()).add(operator.val(),value);
break;
case WITHIN_CIRCLE:
query=BasicDBObjectBuilder.start().push(FilterOperator.WITHIN.val()).add(operator.val(),value);
break;
default :
throw new UnsupportedOperationException(operator + ""String_Node_Str"");
}
if (opts != null) for (Map.Entry<String,Object> e : opts.entrySet()) query.append(e.getKey(),e.getValue());
obj.put(field,query.get());
}","@Override public void addTo(DBObject obj){
  BasicDBObjectBuilder query=null;
switch (operator) {
case NEAR:
    query=BasicDBObjectBuilder.start(FilterOperator.NEAR.val(),value);
  break;
case NEAR_SPHERE:
query=BasicDBObjectBuilder.start(FilterOperator.NEAR_SPHERE.val(),value);
break;
case WITHIN_BOX:
query=BasicDBObjectBuilder.start().push(FilterOperator.WITHIN.val()).add(operator.val(),value);
break;
case WITHIN_CIRCLE:
query=BasicDBObjectBuilder.start().push(FilterOperator.WITHIN.val()).add(operator.val(),value);
break;
case WITHIN_CIRCLE_SPHERE:
query=BasicDBObjectBuilder.start().push(FilterOperator.WITHIN.val()).add(operator.val(),value);
break;
default :
throw new UnsupportedOperationException(operator + ""String_Node_Str"");
}
if (opts != null) for (Map.Entry<String,Object> e : opts.entrySet()) query.append(e.getKey(),e.getValue());
obj.put(field,query.get());
}",0.8506196999347684
104710,"/** 
 * <p>Compares based on the following traits, in order:</p> <ol> <li>kind/kindClass</li> <li>parent</li> <li>id or name</li> </ol>
 */
@SuppressWarnings(""String_Node_Str"") public int compareTo(Key<?> other){
  checkState(this);
  checkState(other);
  int cmp=0;
  if (other.kindClass != null && kindClass != null) {
    cmp=this.kindClass.getName().compareTo(other.kindClass.getName());
    if (cmp != 0)     return cmp;
  }
  cmp=compareNullable(this.kind,other.kind);
  if (cmp != 0)   return cmp;
  try {
    cmp=compareNullable((Comparable<?>)this.id,(Comparable<?>)other.id);
    if (cmp != 0)     return cmp;
  }
 catch (  Exception e) {
  }
  return 0;
}","/** 
 * <p> Compares based on the following traits, in order: </p> <ol> <li>kind/kindClass</li> <li>parent</li> <li>id or name</li> </ol>
 */
@SuppressWarnings(""String_Node_Str"") public int compareTo(Key<?> other){
  checkState(this);
  checkState(other);
  int cmp=0;
  if (other.kindClass != null && kindClass != null) {
    cmp=this.kindClass.getName().compareTo(other.kindClass.getName());
    if (cmp != 0)     return cmp;
  }
  cmp=compareNullable(this.kind,other.kind);
  if (cmp != 0)   return cmp;
  try {
    cmp=compareNullable((Comparable<?>)this.id,(Comparable<?>)other.id);
    if (cmp != 0)     return cmp;
  }
 catch (  Exception e) {
    cmp=this.id.equals(other.id) ? 0 : 1;
    if (cmp != 0)     return this.id.toString().compareTo(other.id.toString());
  }
  return 0;
}",0.9148351648351648
104711,"public DBObject getFieldsObject(){
  if (fields == null || fields.length == 0)   return null;
  Map<String,Boolean> fieldsFilter=new HashMap<String,Boolean>();
  for (  String field : this.fields) {
    StringBuffer sb=new StringBuffer(field);
    Mapper.validate(clazz,ds.getMapper(),sb,FilterOperator.EQUAL,null,validateName,false);
    field=sb.toString();
    fieldsFilter.put(field,(includeFields));
  }
  return new BasicDBObject(fieldsFilter);
}","public DBObject getFieldsObject(){
  if (fields == null || fields.length == 0)   return null;
  Map<String,Integer> fieldsFilter=new HashMap<String,Integer>();
  for (  String field : this.fields) {
    StringBuffer sb=new StringBuffer(field);
    Mapper.validate(clazz,ds.getMapper(),sb,FilterOperator.EQUAL,null,validateName,false);
    field=sb.toString();
    fieldsFilter.put(field,(includeFields ? 1 : 0));
  }
  return new BasicDBObject(fieldsFilter);
}",0.9605263157894736
104712,"public Object toMongoObject(MappedField mf,MappedClass mc,Object value){
  Object mappedValue=value;
  if ((mf != null && (mf.hasAnnotation(Reference.class) || mf.getType().isAssignableFrom(Key.class) || mf.getType().isAssignableFrom(DBRef.class))) || (mc != null && mc.getEntityAnnotation() != null)) {
    try {
      Key<?> k=(value instanceof Key) ? (Key<?>)value : getKey(value);
      mappedValue=keyToRef(k);
    }
 catch (    Exception e) {
      log.debug(""String_Node_Str"" + value + ""String_Node_Str"",e);
      mappedValue=toMongoObject(value,false);
    }
  }
 else   if (mf != null && mf.hasAnnotation(Serialized.class))   try {
    mappedValue=Serializer.serialize(value,!mf.getAnnotation(Serialized.class).disableCompression());
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
 else   if (value instanceof DBObject)   mappedValue=value;
 else {
    mappedValue=toMongoObject(value,EmbeddedMapper.shouldSaveClassName(value,mappedValue,mf));
    if (mappedValue instanceof DBObject && !EmbeddedMapper.shouldSaveClassName(value,mappedValue,mf))     ((DBObject)mappedValue).removeField(CLASS_NAME_FIELDNAME);
  }
  return mappedValue;
}","public Object toMongoObject(MappedField mf,MappedClass mc,Object value){
  Object mappedValue=value;
  if ((mf != null && (mf.hasAnnotation(Reference.class) || mf.getType().isAssignableFrom(Key.class) || mf.getType().isAssignableFrom(DBRef.class)|| (value instanceof Iterable && (mf.getSubClass().isAssignableFrom(Key.class) || mf.getSubClass().isAssignableFrom(DBRef.class))))) || (mc != null && mc.getEntityAnnotation() != null)) {
    try {
      if (value instanceof Iterable) {
        ArrayList<DBRef> refs=new ArrayList<DBRef>();
        Iterable it=(Iterable)value;
        for (        Object o : it) {
          Key<?> k=(o instanceof Key) ? (Key<?>)o : getKey(o);
          DBRef dbref=keyToRef(k);
          refs.add(dbref);
        }
        mappedValue=refs;
      }
 else {
        Key<?> k=(value instanceof Key) ? (Key<?>)value : getKey(value);
        mappedValue=keyToRef(k);
        if (mappedValue == value)         throw new ValidationException(""String_Node_Str"");
      }
    }
 catch (    Exception e) {
      log.error(""String_Node_Str"" + value + ""String_Node_Str"",e);
      mappedValue=toMongoObject(value,false);
    }
  }
 else   if (mf != null && mf.hasAnnotation(Serialized.class))   try {
    mappedValue=Serializer.serialize(value,!mf.getAnnotation(Serialized.class).disableCompression());
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
 else   if (value instanceof DBObject)   mappedValue=value;
 else {
    mappedValue=toMongoObject(value,EmbeddedMapper.shouldSaveClassName(value,mappedValue,mf));
    if (mappedValue instanceof DBObject && !EmbeddedMapper.shouldSaveClassName(value,mappedValue,mf))     ((DBObject)mappedValue).removeField(CLASS_NAME_FIELDNAME);
  }
  return mappedValue;
}",0.7711835334476844
104713,"public Query<T> order(String condition){
  if (snapshotted)   throw new QueryException(""String_Node_Str"");
  sort=parseFieldsString(condition,clazz,this.ds.getMapper(),this.validateName);
  return this;
}","public Query<T> order(String condition){
  if (snapshotted)   throw new QueryException(""String_Node_Str"");
  if (condition == null || condition.trim() == ""String_Node_Str"")   sort=null;
  sort=parseFieldsString(condition,clazz,this.ds.getMapper(),this.validateName);
  return this;
}",0.837782340862423
104714,"/** 
 * parses the string and validates each part
 */
public static BasicDBObject parseFieldsString(String str,Class clazz,Mapper mapr,boolean validate){
  BasicDBObjectBuilder ret=BasicDBObjectBuilder.start();
  String[] parts=str.split(""String_Node_Str"");
  for (  String s : parts) {
    s=s.trim();
    int dir=1;
    if (s.startsWith(""String_Node_Str"")) {
      dir=-1;
      s=s.substring(1).trim();
    }
    if (validate) {
      StringBuffer sb=new StringBuffer(s);
      Mapper.validate(clazz,mapr,sb,FilterOperator.IN,""String_Node_Str"",true,false);
      s=sb.toString();
    }
    ret=ret.add(s,dir);
  }
  return (BasicDBObject)ret.get();
}","/** 
 * parses the string and validates each part
 */
@SuppressWarnings(""String_Node_Str"") public static BasicDBObject parseFieldsString(String str,Class clazz,Mapper mapr,boolean validate){
  BasicDBObjectBuilder ret=BasicDBObjectBuilder.start();
  String[] parts=str.split(""String_Node_Str"");
  for (  String s : parts) {
    s=s.trim();
    int dir=1;
    if (s.startsWith(""String_Node_Str"")) {
      dir=-1;
      s=s.substring(1).trim();
    }
    if (validate) {
      StringBuffer sb=new StringBuffer(s);
      Mapper.validate(clazz,mapr,sb,FilterOperator.IN,""String_Node_Str"",true,false);
      s=sb.toString();
    }
    ret=ret.add(s,dir);
  }
  return (BasicDBObject)ret.get();
}",0.9724497393894268
104715,"public DBObject getQueryObject(){
  DBObject obj=new BasicDBObject();
  if (this.baseQuery != null) {
    obj.putAll(this.baseQuery);
  }
  this.addTo(obj);
  return obj;
}","public DBObject getQueryObject(){
  DBObject obj=new BasicDBObject();
  if (this.baseQuery != null) {
    obj.putAll((BSONObject)this.baseQuery);
  }
  this.addTo(obj);
  return obj;
}",0.9662921348314608
104716,"public QueryImpl(Class<T> clazz,DBCollection coll,DatastoreImpl ds,DBObject baseQuery){
  this(clazz,coll,ds);
  this.baseQuery=baseQuery;
}","public QueryImpl(Class<T> clazz,DBCollection coll,DatastoreImpl ds,DBObject baseQuery){
  this(clazz,coll,ds);
  this.baseQuery=(BasicDBObject)baseQuery;
}",0.9491525423728814
104717,"public void setQueryObject(DBObject query){
  this.baseQuery=query;
}","public void setQueryObject(DBObject query){
  this.baseQuery=(BasicDBObject)query;
}",0.9019607843137256
104718,"@Override public QueryImpl<T> clone(){
  QueryImpl<T> n=new QueryImpl<T>(clazz,dbColl,ds);
  n.batchSize=batchSize;
  n.cache=this.ds.getMapper().createEntityCache();
  n.fields=fields == null ? null : Arrays.copyOf(fields,fields.length);
  n.includeFields=includeFields;
  n.indexHint=indexHint;
  n.limit=limit;
  n.noTimeout=noTimeout;
  n.query=n;
  n.offset=offset;
  n.slaveOk=slaveOk;
  n.snapshotted=snapshotted;
  n.validateName=validateName;
  n.validateType=validateType;
  n.sort=(DBObject)(sort == null ? null : ((BasicDBObject)sort).clone());
  n.baseQuery=(DBObject)(baseQuery == null ? null : ((BasicDBObject)baseQuery).clone());
  n.attachedTo=attachedTo;
  n.children=children == null ? null : new ArrayList<Criteria>(children);
  n.tail=tail;
  n.tail_await_data=tail_await_data;
  return n;
}","@Override public QueryImpl<T> clone(){
  QueryImpl<T> n=new QueryImpl<T>(clazz,dbColl,ds);
  n.batchSize=batchSize;
  n.cache=this.ds.getMapper().createEntityCache();
  n.fields=fields == null ? null : Arrays.copyOf(fields,fields.length);
  n.includeFields=includeFields;
  n.indexHint=indexHint;
  n.limit=limit;
  n.noTimeout=noTimeout;
  n.query=n;
  n.offset=offset;
  n.slaveOk=slaveOk;
  n.snapshotted=snapshotted;
  n.validateName=validateName;
  n.validateType=validateType;
  n.sort=(BasicDBObject)(sort == null ? null : sort.clone());
  n.baseQuery=(BasicDBObject)(baseQuery == null ? null : baseQuery.clone());
  n.attachedTo=attachedTo;
  n.children=children == null ? null : new ArrayList<Criteria>(children);
  n.tail=tail;
  n.tail_await_data=tail_await_data;
  return n;
}",0.91875
104719,"public static boolean isPropertyType(final Class type){
  if (type == null) {
    return false;
  }
  return isPrimitiveLike(type) || (type == DBRef.class) || (type == Pattern.class)|| (type == CodeWScope.class)|| (type == ObjectId.class)|| (type == Key.class);
}","public static boolean isPropertyType(final Class type){
  if (type == null) {
    return false;
  }
  return isPrimitiveLike(type) || (type == DBRef.class) || (type == Pattern.class)|| (type == CodeWScope.class)|| (type == ObjectId.class)|| (type == Key.class)|| (type == DBObject.class)|| (type == BasicDBObject.class);
}",0.8991452991452992
104720,"public DefaultConverters(){
  addConverter(new PassthroughConverter(DBObject.class,BasicDBObject.class));
  addConverter(new PassthroughConverter(byte[].class));
  addConverter(new EnumSetConverter());
  addConverter(new EnumConverter());
  addConverter(new StringConverter());
  addConverter(new CharacterConverter());
  addConverter(new ByteConverter());
  addConverter(new BooleanConverter());
  addConverter(new DoubleConverter());
  addConverter(new FloatConverter());
  addConverter(new LongConverter());
  addConverter(new LocaleConverter());
  addConverter(new ShortConverter());
  addConverter(new IntegerConverter());
  addConverter(new SerializedObjectConverter());
  addConverter(new CharArrayConverter());
  addConverter(new DateConverter());
  addConverter(new KeyConverter());
  addConverter(new MapOfValuesConverter(this));
  addConverter(new IterableConverter(this));
  addConverter(new ClassConverter());
  addConverter(new ObjectIdConverter());
  addConverter(new TimestampConverter());
  addConverter(new PassthroughConverter());
}","public DefaultConverters(){
  addConverter(new PassthroughConverter(DBObject.class,BasicDBObject.class));
  addConverter(new PassthroughConverter(byte[].class));
  addConverter(new EnumSetConverter());
  addConverter(new EnumConverter());
  addConverter(new StringConverter());
  addConverter(new CharacterConverter());
  addConverter(new ByteConverter());
  addConverter(new BooleanConverter());
  addConverter(new DoubleConverter());
  addConverter(new FloatConverter());
  addConverter(new LongConverter());
  addConverter(new LocaleConverter());
  addConverter(new ShortConverter());
  addConverter(new IntegerConverter());
  addConverter(new SerializedObjectConverter());
  addConverter(new CharArrayConverter());
  addConverter(new DateConverter());
  addConverter(new URIConverter());
  addConverter(new KeyConverter());
  addConverter(new MapOfValuesConverter(this));
  addConverter(new IterableConverter(this));
  addConverter(new ClassConverter());
  addConverter(new ObjectIdConverter());
  addConverter(new TimestampConverter());
  addConverter(new PassthroughConverter());
}",0.9831618334892422
104721,"public static boolean isPrimitiveLike(final Class type){
  if (type == null) {
    return false;
  }
  return (type == String.class) || (type == char.class) || (type == Character.class)|| (type == short.class)|| (type == Short.class)|| (type == Integer.class)|| (type == int.class)|| (type == Long.class)|| (type == long.class)|| (type == Double.class)|| (type == double.class)|| (type == float.class)|| (type == Float.class)|| (type == Boolean.class)|| (type == boolean.class)|| (type == Byte.class)|| (type == byte.class)|| (type == Date.class)|| (type == Locale.class)|| (type == Class.class)|| (type == UUID.class)|| type.isEnum();
}","public static boolean isPrimitiveLike(final Class type){
  if (type == null) {
    return false;
  }
  return (type == String.class) || (type == char.class) || (type == Character.class)|| (type == short.class)|| (type == Short.class)|| (type == Integer.class)|| (type == int.class)|| (type == Long.class)|| (type == long.class)|| (type == Double.class)|| (type == double.class)|| (type == float.class)|| (type == Float.class)|| (type == Boolean.class)|| (type == boolean.class)|| (type == Byte.class)|| (type == byte.class)|| (type == Date.class)|| (type == Locale.class)|| (type == Class.class)|| (type == UUID.class)|| (type == URI.class)|| type.isEnum();
}",0.9830246913580248
104722,"public <T>Key<T> merge(T entity,WriteConcern wc){
  LinkedHashMap<Object,DBObject> involvedObjects=new LinkedHashMap<Object,DBObject>();
  DBObject dbObj=mapr.toDBObject(entity,involvedObjects);
  Key<T> key=getKey(entity);
  entity=ProxyHelper.unwrap(entity);
  Object id=getId(entity);
  if (id == null)   throw new MappingException(""String_Node_Str"" + entity.getClass().getName());
  Query<T> query=(Query<T>)createQuery(entity.getClass()).filter(Mapper.ID_KEY,id);
  dbObj.removeField(Mapper.ID_KEY);
  UpdateResults<T> res=update(query,new BasicDBObject(""String_Node_Str"",dbObj),false,false,wc);
  CommandResult gle=res.getWriteResult().getCachedLastError();
  if (gle != null && res.getUpdatedCount() == 0)   throw new UpdateException(""String_Node_Str"" + gle);
  postSaveOperations(entity,dbObj,involvedObjects);
  return key;
}","public <T>Key<T> merge(T entity,WriteConcern wc){
  LinkedHashMap<Object,DBObject> involvedObjects=new LinkedHashMap<Object,DBObject>();
  DBObject dbObj=mapr.toDBObject(entity,involvedObjects);
  Key<T> key=getKey(entity);
  entity=ProxyHelper.unwrap(entity);
  Object id=getId(entity);
  if (id == null)   throw new MappingException(""String_Node_Str"" + entity.getClass().getName());
  dbObj.removeField(Mapper.ID_KEY);
  WriteResult wr=null;
  MappedClass mc=mapr.getMappedClass(entity);
  DBCollection dbColl=getCollection(entity);
  wr=tryVersionedUpdate(dbColl,entity,dbObj,wc,db,mc);
  if (wr == null) {
    Query<T> query=(Query<T>)createQuery(entity.getClass()).filter(Mapper.ID_KEY,id);
    wr=update(query,new BasicDBObject(""String_Node_Str"",dbObj),false,false,wc).getWriteResult();
  }
  UpdateResults<T> res=new UpdateResults<T>(wr);
  throwOnError(wc,wr);
  CommandResult gle=wr.getCachedLastError();
  if (gle != null && res.getUpdatedCount() == 0)   throw new UpdateException(""String_Node_Str"" + gle);
  postSaveOperations(entity,dbObj,involvedObjects);
  return key;
}",0.5411887382690302
104723,"public void thisMustFail() throws Throwable {
  ds.save(a1);
}","public void thisMustFail() throws Throwable {
  ds.merge(a1);
}",0.944
104724,"public String getCollectionName(Object object){
  MappedClass mc=getMappedClass(object);
  return mc.getCollectionName();
}","public String getCollectionName(Object object){
  if (object == null)   throw new IllegalArgumentException();
  MappedClass mc=getMappedClass(object);
  return mc.getCollectionName();
}",0.7987012987012987
104725,"/** 
 * Add MappedClass to internal cache, possibly validating first. 
 */
private MappedClass addMappedClass(MappedClass mc,boolean validate){
  if (validate)   mc.validate();
  Converters c=(Converters)mc.getAnnotation(Converters.class);
  if (c != null)   for (  Class<? extends TypeConverter> clazz : c.value())   if (!converters.isRegistered(clazz))   converters.addConverter(clazz);
  mappedClasses.put(mc.getClazz().getName(),mc);
  Set<MappedClass> mcs=mappedClassesByCollection.get(mc.getCollectionName());
  if (mcs == null)   mcs=new HashSet();
  mcs.add(mc);
  return mc;
}","/** 
 * Add MappedClass to internal cache, possibly validating first. 
 */
private MappedClass addMappedClass(MappedClass mc,boolean validate){
  if (validate)   mc.validate();
  Converters c=(Converters)mc.getAnnotation(Converters.class);
  if (c != null)   for (  Class<? extends TypeConverter> clazz : c.value())   if (!converters.isRegistered(clazz))   converters.addConverter(clazz);
  mappedClasses.put(mc.getClazz().getName(),mc);
  Set<MappedClass> mcs=mappedClassesByCollection.get(mc.getCollectionName());
  if (mcs == null) {
    mcs=new HashSet();
    mappedClassesByCollection.put(mc.getCollectionName(),mcs);
  }
  mcs.add(mc);
  return mc;
}",0.902497985495568
104726,"public Object toMongoObject(MappedField mf,MappedClass mc,Object value){
  Object mappedValue=value;
  if ((mf != null && (mf.hasAnnotation(Reference.class) || mf.getType().isAssignableFrom(Key.class) || mf.getType().isAssignableFrom(DBRef.class)|| (value instanceof Iterable && (mf.getSubClass().isAssignableFrom(Key.class) || mf.getSubClass().isAssignableFrom(DBRef.class))))) || (mc != null && mc.getEntityAnnotation() != null)) {
    try {
      if (value instanceof Iterable) {
        ArrayList<DBRef> refs=new ArrayList<DBRef>();
        Iterable it=(Iterable)value;
        for (        Object o : it) {
          Key<?> k=(o instanceof Key) ? (Key<?>)o : getKey(o);
          DBRef dbref=keyToRef(k);
          refs.add(dbref);
        }
        mappedValue=refs;
      }
 else {
        Key<?> k=(value instanceof Key) ? (Key<?>)value : getKey(value);
        mappedValue=keyToRef(k);
        if (mappedValue == value)         throw new ValidationException(""String_Node_Str"");
      }
    }
 catch (    Exception e) {
      log.error(""String_Node_Str"" + value + ""String_Node_Str"",e);
      mappedValue=toMongoObject(value,false);
    }
  }
 else   if (mf != null && mf.hasAnnotation(Serialized.class))   try {
    mappedValue=Serializer.serialize(value,!mf.getAnnotation(Serialized.class).disableCompression());
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
 else   if (value instanceof DBObject)   mappedValue=value;
 else {
    mappedValue=toMongoObject(value,EmbeddedMapper.shouldSaveClassName(value,mappedValue,mf));
    if (mappedValue instanceof DBObject && !EmbeddedMapper.shouldSaveClassName(value,mappedValue,mf))     ((DBObject)mappedValue).removeField(CLASS_NAME_FIELDNAME);
  }
  return mappedValue;
}","public Object toMongoObject(MappedField mf,MappedClass mc,Object value){
  Object mappedValue=value;
  if ((mf != null && (mf.hasAnnotation(Reference.class) || mf.getType().isAssignableFrom(Key.class) || mf.getType().isAssignableFrom(DBRef.class)|| (value instanceof Iterable && mf.isMultipleValues() && (mf.getSubClass().isAssignableFrom(Key.class) || mf.getSubClass().isAssignableFrom(DBRef.class))))) || (mc != null && mc.getEntityAnnotation() != null)) {
    try {
      if (value instanceof Iterable) {
        ArrayList<DBRef> refs=new ArrayList<DBRef>();
        Iterable it=(Iterable)value;
        for (        Object o : it) {
          Key<?> k=(o instanceof Key) ? (Key<?>)o : getKey(o);
          DBRef dbref=keyToRef(k);
          refs.add(dbref);
        }
        mappedValue=refs;
      }
 else {
        Key<?> k=(value instanceof Key) ? (Key<?>)value : getKey(value);
        mappedValue=keyToRef(k);
        if (mappedValue == value)         throw new ValidationException(""String_Node_Str"");
      }
    }
 catch (    Exception e) {
      log.error(""String_Node_Str"" + value + ""String_Node_Str"",e);
      mappedValue=toMongoObject(value,false);
    }
  }
 else   if (mf != null && mf.hasAnnotation(Serialized.class))   try {
    mappedValue=Serializer.serialize(value,!mf.getAnnotation(Serialized.class).disableCompression());
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
 else   if (value instanceof DBObject)   mappedValue=value;
 else {
    mappedValue=toMongoObject(value,EmbeddedMapper.shouldSaveClassName(value,mappedValue,mf));
    if (mappedValue instanceof DBObject && !EmbeddedMapper.shouldSaveClassName(value,mappedValue,mf))     ((DBObject)mappedValue).removeField(CLASS_NAME_FIELDNAME);
  }
  return mappedValue;
}",0.992895709008241
104727,"@Override public Object decode(Class targetClass,Object val,MappedField optionalExtraInfo) throws MappingException {
  if (val == null)   return null;
  if (val instanceof Double)   return (Double)val;
  if (val instanceof Number)   return ((Number)val).doubleValue();
  String sVal=val.toString();
  return Double.parseDouble(sVal);
}","@Override public Object decode(Class targetClass,Object val,MappedField optionalExtraInfo) throws MappingException {
  if (val == null)   return null;
  if (val instanceof Double)   return (Double)val;
  if (val instanceof Number)   return ((Number)val).doubleValue();
  if (val instanceof ArrayList)   return ReflectionUtils.convertToArray(double.class,(ArrayList)val);
  String sVal=val.toString();
  return Double.parseDouble(sVal);
}",0.8678756476683938
104728,"private Class discoverType(){
  Class type=field.getType();
  Type gType=field.getGenericType();
  TypeVariable<GenericDeclaration> tv=null;
  ParameterizedType pt=null;
  if (gType instanceof TypeVariable)   tv=(TypeVariable<GenericDeclaration>)gType;
 else   if (gType instanceof ParameterizedType)   pt=(ParameterizedType)gType;
  if (tv != null) {
    type=ReflectionUtils.getTypeArgument(persistedClass,tv);
  }
 else   if (pt != null) {
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"" + pt);
  }
  if (Object.class.equals(realType) && (tv != null || pt != null))   if (log.isWarningEnabled())   log.warning(""String_Node_Str"" + field.getName() + ""String_Node_Str""+ field.getDeclaringClass());
  if (type == null)   throw new MappingException(""String_Node_Str"" + this.field);
  return type;
}","private Class discoverType(){
  Class type=field.getType();
  Type gType=field.getGenericType();
  TypeVariable<GenericDeclaration> tv=null;
  ParameterizedType pt=null;
  if (gType instanceof TypeVariable)   tv=(TypeVariable<GenericDeclaration>)gType;
 else   if (gType instanceof ParameterizedType)   pt=(ParameterizedType)gType;
  if (tv != null) {
    Class typeArgument=ReflectionUtils.getTypeArgument(persistedClass,tv);
    if (typeArgument != null)     type=typeArgument;
  }
 else   if (pt != null) {
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"" + pt);
  }
  if (Object.class.equals(realType) && (tv != null || pt != null))   if (log.isWarningEnabled())   log.warning(""String_Node_Str"" + field.getName() + ""String_Node_Str""+ field.getDeclaringClass());
  if (type == null)   throw new MappingException(""String_Node_Str"" + this.field);
  return type;
}",0.9555423829282752
104729,"@SuppressWarnings(""String_Node_Str"") public void addTo(DBObject obj){
  if (FilterOperator.EQUAL.equals(this.operator)) {
    obj.put(this.field,this.value);
  }
 else {
    Object inner=obj.get(this.field);
    if (!(inner instanceof Map)) {
      inner=new HashMap<String,Object>();
      obj.put(this.field,inner);
    }
    ((Map<String,Object>)inner).put(this.operator.val(),this.value);
  }
}","@SuppressWarnings(""String_Node_Str"") public void addTo(DBObject obj){
  if (FilterOperator.EQUAL.equals(operator)) {
    obj.put(this.field,value);
  }
 else {
    Object inner=obj.get(field);
    if (!(inner instanceof Map)) {
      inner=new HashMap<String,Object>();
      obj.put(field,inner);
    }
    Object val=not ? new BasicDBObject(""String_Node_Str"",value) : value;
    ((Map<String,Object>)inner).put(operator.val(),val);
  }
}",0.7168458781362007
104730,"@SuppressWarnings(""String_Node_Str"") protected FieldCriteria(QueryImpl<?> query,String field,FilterOperator op,Object value,boolean validateNames,boolean validateTypes){
  StringBuffer sb=new StringBuffer(field);
  MappedField mf=Mapper.validate(query.getEntityClass(),query.getDatastore().getMapper(),sb,op,value,validateNames,validateTypes);
  field=sb.toString();
  Mapper mapr=query.getDatastore().getMapper();
  MappedClass mc=null;
  try {
    if (value != null && !ReflectionUtils.isPropertyType(value.getClass()) && !ReflectionUtils.implementsInterface(value.getClass(),Iterable.class))     if (mf != null && !mf.isTypeMongoCompatible())     mc=mapr.getMappedClass((mf.isSingleValue()) ? mf.getType() : mf.getSubClass());
 else     mc=mapr.getMappedClass(value);
  }
 catch (  Exception e) {
    log.debug(""String_Node_Str"",e);
  }
  Object mappedValue=mapr.toMongoObject(mf,mc,value);
  Class<?> type=(mappedValue == null) ? null : mappedValue.getClass();
  if (type != null && (op == FilterOperator.IN || op == FilterOperator.NOT_IN) && !type.isArray() && !Iterable.class.isAssignableFrom(type)) {
    mappedValue=Collections.singletonList(mappedValue);
  }
  if (op == FilterOperator.ELEMENT_MATCH && mappedValue instanceof DBObject)   ((DBObject)mappedValue).removeField(Mapper.ID_KEY);
  this.field=field;
  this.operator=op;
  this.value=mappedValue;
}","protected FieldCriteria(QueryImpl<?> query,String field,FilterOperator op,Object value,boolean validateNames,boolean validateTypes,boolean not){
  StringBuffer sb=new StringBuffer(field);
  MappedField mf=Mapper.validate(query.getEntityClass(),query.getDatastore().getMapper(),sb,op,value,validateNames,validateTypes);
  field=sb.toString();
  Mapper mapr=query.getDatastore().getMapper();
  MappedClass mc=null;
  try {
    if (value != null && !ReflectionUtils.isPropertyType(value.getClass()) && !ReflectionUtils.implementsInterface(value.getClass(),Iterable.class))     if (mf != null && !mf.isTypeMongoCompatible())     mc=mapr.getMappedClass((mf.isSingleValue()) ? mf.getType() : mf.getSubClass());
 else     mc=mapr.getMappedClass(value);
  }
 catch (  Exception e) {
    log.debug(""String_Node_Str"",e);
  }
  Object mappedValue=mapr.toMongoObject(mf,mc,value);
  Class<?> type=(mappedValue == null) ? null : mappedValue.getClass();
  if (type != null && (op == FilterOperator.IN || op == FilterOperator.NOT_IN) && !type.isArray() && !Iterable.class.isAssignableFrom(type)) {
    mappedValue=Collections.singletonList(mappedValue);
  }
  if (op == FilterOperator.ELEMENT_MATCH && mappedValue instanceof DBObject)   ((DBObject)mappedValue).removeField(Mapper.ID_KEY);
  this.field=field;
  this.operator=op;
  if (not)   this.value=new BasicDBObject(""String_Node_Str"",mappedValue);
 else   this.value=mappedValue;
  this.not=not;
}",0.948269711023903
104731,"/** 
 * Add a criteria 
 */
private T addCrit(FilterOperator op,Object val){
  target.add(new FieldCriteria(query,field,op,val,validateName,query.isValidatingTypes()));
  return target;
}","/** 
 * Add a criteria 
 */
private T addCrit(FilterOperator op,Object val){
  target.add(new FieldCriteria(query,field,op,val,validateName,query.isValidatingTypes(),not));
  return target;
}",0.9894179894179894
104732,"private T addGeoCrit(FilterOperator op,Object val,Map<String,Object> opts){
  target.add(new GeoFieldCriteria(query,field,op,val,validateName,false,opts));
  return target;
}","private T addGeoCrit(FilterOperator op,Object val,Map<String,Object> opts){
  if (not)   throw new QueryException(""String_Node_Str"");
  target.add(new GeoFieldCriteria(query,field,op,val,validateName,false,opts));
  return target;
}",0.8571428571428571
104733,"public FieldEndImpl(QueryImpl<?> query,String field,T target,boolean validateName){
  this.query=query;
  this.field=field;
  this.target=target;
  this.validateName=validateName;
}","public FieldEndImpl(QueryImpl<?> query,String field,T target,boolean validateName){
  this(query,field,target,validateName,false);
}",0.792332268370607
104734,"public DBObject getFieldsObject(){
  if (fields == null || fields.length == 0)   return null;
  Map<String,Boolean> fieldsFilter=new HashMap<String,Boolean>();
  for (  String field : this.fields)   fieldsFilter.put(field,(includeFields));
  return new BasicDBObject(fieldsFilter);
}","public DBObject getFieldsObject(){
  if (fields == null || fields.length == 0)   return null;
  Map<String,Boolean> fieldsFilter=new HashMap<String,Boolean>();
  for (  String field : this.fields) {
    StringBuffer sb=new StringBuffer(field);
    Mapper.validate(clazz,ds.getMapper(),sb,FilterOperator.EQUAL,null,validateName,false);
    field=sb.toString();
    fieldsFilter.put(field,(includeFields));
  }
  return new BasicDBObject(fieldsFilter);
}",0.6285714285714286
104735,"<T>void delete(String kind,T id);","<T>WriteResult delete(String kind,T id);",0.821917808219178
104736,"/** 
 * Deletes the given entity (by @Id), with the WriteConcern 
 */
<T>void delete(T entity,WriteConcern wc);","/** 
 * Deletes the given entity (by @Id), with the WriteConcern 
 */
<T>WriteResult delete(T entity,WriteConcern wc);",0.9432314410480348
104737,"public <T>void delete(Query<T> query,WriteConcern wc){
  QueryImpl<T> q=(QueryImpl<T>)query;
  DBCollection dbColl=q.getCollection();
  if (dbColl == null)   dbColl=getCollection(q.getEntityClass());
  WriteResult wr;
  if (q.getSortObject() != null || q.getOffset() != 0 || q.getLimit() > 0)   throw new QueryException(""String_Node_Str"");
  if (q.getQueryObject() != null)   if (wc == null)   wr=dbColl.remove(q.getQueryObject());
 else   wr=dbColl.remove(q.getQueryObject(),wc);
 else   if (wc == null)   wr=dbColl.remove(new BasicDBObject());
 else   wr=dbColl.remove(new BasicDBObject(),wc);
  throwOnError(wc,wr);
}","public <T>WriteResult delete(Query<T> query,WriteConcern wc){
  QueryImpl<T> q=(QueryImpl<T>)query;
  DBCollection dbColl=q.getCollection();
  if (dbColl == null)   dbColl=getCollection(q.getEntityClass());
  WriteResult wr;
  if (q.getSortObject() != null || q.getOffset() != 0 || q.getLimit() > 0)   throw new QueryException(""String_Node_Str"");
  if (q.getQueryObject() != null)   if (wc == null)   wr=dbColl.remove(q.getQueryObject());
 else   wr=dbColl.remove(q.getQueryObject(),wc);
 else   if (wc == null)   wr=dbColl.remove(new BasicDBObject());
 else   wr=dbColl.remove(new BasicDBObject(),wc);
  throwOnError(wc,wr);
  return wr;
}",0.9777777777777776
104738,"public void delete(T entity,WriteConcern wc){
  ds.delete(entity,wc);
}","public WriteResult delete(T entity,WriteConcern wc){
  return ds.delete(entity,wc);
}",0.8717948717948718
104739,"public void deleteByQuery(Query q){
  ds.delete(q);
}","public WriteResult deleteByQuery(Query q){
  return ds.delete(q);
}",0.8333333333333334
104740,"public void deleteById(K id){
  ds.delete(entityClazz,id);
}","public WriteResult deleteById(K id){
  return ds.delete(entityClazz,id);
}",0.8507462686567164
104741,"/** 
 * Deletes the entity 
 */
public void delete(T entity,WriteConcern wc);","/** 
 * Deletes the entity 
 * @return 
 */
public WriteResult delete(T entity,WriteConcern wc);",0.8554913294797688
104742,"/** 
 * Saves the entities given the query
 */
public void deleteByQuery(Query<T> q);","/** 
 * Saves the entities given the query
 */
public WriteResult deleteByQuery(Query<T> q);",0.9265536723163842
104743,"/** 
 * Delete the entity by id value 
 */
public void deleteById(K id);","/** 
 * Delete the entity by id value 
 */
public WriteResult deleteById(K id);",0.913907284768212
104744,"@Test public void testGet() throws Exception {
  String ns=""String_Node_Str"";
  Rectangle rect=new Rectangle(10,10);
  rect.setId(""String_Node_Str"");
  ads.save(ns,rect);
  assertEquals(1,ads.getCount(ns));
  Rectangle rectLoaded=ads.get(ns,Rectangle.class,rect.getId());
  assertEquals(rect.getId(),rectLoaded.getId());
  assertEquals(rect.getArea(),rectLoaded.getArea(),0);
}","@Test public void testGet() throws Exception {
  String ns=""String_Node_Str"";
  Rectangle rect=new Rectangle(10,10);
  rect.setId(""String_Node_Str"");
  db.getCollection(ns).remove(new BasicDBObject());
  ads.save(ns,rect);
  assertEquals(1,ads.getCount(ns));
  Rectangle rectLoaded=ads.get(ns,Rectangle.class,rect.getId());
  assertEquals(rect.getId(),rectLoaded.getId());
  assertEquals(rect.getArea(),rectLoaded.getArea(),0);
}",0.935483870967742
104745,"@Test public void testSaveAndDelete() throws Exception {
  String ns=""String_Node_Str"";
  Rectangle rect=new Rectangle(10,10);
  rect.setId(""String_Node_Str"");
  ads.save(ns,rect);
  assertEquals(1,ads.getCount(ns));
  ads.delete(ns,1);
  assertEquals(1,ads.getCount(ns));
  ads.delete(ns,""String_Node_Str"");
  assertEquals(0,ads.getCount(ns));
}","@Test public void testSaveAndDelete() throws Exception {
  String ns=""String_Node_Str"";
  Rectangle rect=new Rectangle(10,10);
  rect.setId(""String_Node_Str"");
  db.getCollection(ns).remove(new BasicDBObject());
  ads.save(ns,rect);
  assertEquals(1,ads.getCount(ns));
  ads.delete(ns,1);
  assertEquals(1,ads.getCount(ns));
  ads.delete(ns,""String_Node_Str"");
  assertEquals(0,ads.getCount(ns));
}",0.9301075268817204
104746,"@Test public void testFind() throws Exception {
  String ns=""String_Node_Str"";
  Rectangle rect=new Rectangle(10,10);
  rect.setId(""String_Node_Str"");
  ads.save(ns,rect);
  assertEquals(1,ads.getCount(ns));
  Rectangle rectLoaded=ads.find(ns,Rectangle.class).get();
  assertEquals(rect.getId(),rectLoaded.getId());
  assertEquals(rect.getArea(),rectLoaded.getArea(),0);
  rect=new Rectangle(2,1);
  rect.setId(""String_Node_Str"");
  ads.save(rect);
  assertEquals(1,ads.getCount(rect));
  rect.setId(""String_Node_Str"");
  ads.save(rect);
  assertEquals(2,ads.getCount(rect));
  rect=new Rectangle(4,3);
  rect.setId(""String_Node_Str"");
  ads.save(ns,rect);
  assertEquals(2,ads.getCount(ns));
  List<Rectangle> rects=ads.find(ns,Rectangle.class).asList();
  rectLoaded=rects.get(1);
  assertEquals(rect.getId(),rectLoaded.getId());
  assertEquals(rect.getArea(),rectLoaded.getArea(),0);
  rectLoaded=ads.find(ns,Rectangle.class,""String_Node_Str"",""String_Node_Str"",1,1).get();
}","@Test public void testFind() throws Exception {
  String ns=""String_Node_Str"";
  Rectangle rect=new Rectangle(10,10);
  rect.setId(""String_Node_Str"");
  db.getCollection(ns).remove(new BasicDBObject());
  ads.save(ns,rect);
  assertEquals(1,ads.getCount(ns));
  Rectangle rectLoaded=ads.find(ns,Rectangle.class).get();
  assertEquals(rect.getId(),rectLoaded.getId());
  assertEquals(rect.getArea(),rectLoaded.getArea(),0);
  rect=new Rectangle(2,1);
  rect.setId(""String_Node_Str"");
  ads.save(rect);
  assertEquals(1,ads.getCount(rect));
  rect.setId(""String_Node_Str"");
  ads.save(rect);
  assertEquals(2,ads.getCount(rect));
  rect=new Rectangle(4,3);
  rect.setId(""String_Node_Str"");
  ads.save(ns,rect);
  assertEquals(2,ads.getCount(ns));
  List<Rectangle> rects=ads.find(ns,Rectangle.class).asList();
  rectLoaded=rects.get(1);
  assertEquals(rect.getId(),rectLoaded.getId());
  assertEquals(rect.getArea(),rectLoaded.getArea(),0);
  rectLoaded=ads.find(ns,Rectangle.class,""String_Node_Str"",""String_Node_Str"",1,1).get();
}",0.9740777666999004
104747,"private <T>void postSaveOperations(Object entity,DBObject dbObj,Map<Object,DBObject> involvedObjects){
  MappedClass mc=mapr.getMappedClass(entity);
  mapr.updateKeyInfo(entity,dbObj,createCache());
  firePostPersistForChildren(involvedObjects);
  mc.callLifecycleMethods(PostPersist.class,entity,dbObj,mapr);
}","private <T>void postSaveOperations(Object entity,DBObject dbObj,Map<Object,DBObject> involvedObjects){
  mapr.updateKeyInfo(entity,dbObj,createCache());
  for (  Map.Entry<Object,DBObject> e : involvedObjects.entrySet()) {
    Object ent=e.getKey();
    DBObject dbO=e.getValue();
    MappedClass mc=mapr.getMappedClass(entity);
    mc.callLifecycleMethods(PostPersist.class,ent,dbO,mapr);
  }
}",0.3852691218130311
104748,"@PreLoad void PreLoad(){
  preLoad=true;
}","@PreLoad void PreLoad(){
  if (preLoad == true)   throw new RuntimeException(""String_Node_Str"");
  preLoad=true;
}",0.5384615384615384
104749,"@PreLoad void PostLoadWithParam(DBObject dbObj){
  postLoadWithParam=true;
}","@PreLoad void PostLoadWithParam(DBObject dbObj){
  if (postLoadWithParam == true)   throw new RuntimeException(""String_Node_Str"");
  postLoadWithParam=true;
}",0.6495726495726496
104750,"@PrePersist protected void PrePersistWithParam(DBObject dbObj){
  prePersistWithParam=true;
}","@PrePersist protected void PrePersistWithParam(DBObject dbObj){
  if (prePersistWithParam == true)   throw new RuntimeException(""String_Node_Str"");
  prePersistWithParam=true;
}",0.6888888888888889
104751,"@PostLoad void PostLoad(){
  postLoad=true;
}","@PostLoad void PostLoad(){
  if (postLoad == true)   throw new RuntimeException(""String_Node_Str"");
  postLoad=true;
}",0.5521472392638037
104752,"@SuppressWarnings(""String_Node_Str"") @PostPersist private void PostPersistPersist(){
  postPersist=true;
}","@SuppressWarnings(""String_Node_Str"") @PostPersist private void PostPersistPersist(){
  if (postPersist == true)   throw new RuntimeException(""String_Node_Str"");
  postPersist=true;
}",0.7361111111111112
104753,"@PrePersist public DBObject PrePersistWithParamAndReturn(DBObject dbObj){
  prePersistWithParamAndReturn=true;
  return null;
}","@PrePersist public DBObject PrePersistWithParamAndReturn(DBObject dbObj){
  if (prePersistWithParamAndReturn == true)   throw new RuntimeException(""String_Node_Str"");
  prePersistWithParamAndReturn=true;
  return null;
}",0.7319884726224783
104754,"@PrePersist void PrePersist(){
  prePersist=true;
}","@PrePersist void PrePersist(){
  if (prePersist == true)   throw new RuntimeException(""String_Node_Str"");
  prePersist=true;
}",0.576271186440678
104755,"@Override protected void check(MappedClass mc,MappedField mf,Set<ConstraintViolation> ve){
  if (mf.isMap() && (!mf.hasAnnotation(Serialized.class))) {
    Class<?> parameterizedClass=ReflectionUtils.getParameterizedClass(mf.getField(),0);
    if (parameterizedClass == null) {
      ve.add(new ConstraintViolation(Level.WARNING,mc,mf,this.getClass(),""String_Node_Str"" + supportedExample));
    }
 else     if (!parameterizedClass.equals(String.class) && !ReflectionUtils.isPrimitiveLike(parameterizedClass))     ve.add(new ConstraintViolation(Level.FATAL,mc,mf,this.getClass(),""String_Node_Str"" + supportedExample + ""String_Node_Str""+ parameterizedClass+ ""String_Node_Str""));
  }
}","@Override protected void check(MappedClass mc,MappedField mf,Set<ConstraintViolation> ve){
  if (mf.isMap() && (!mf.hasAnnotation(Serialized.class))) {
    Class<?> parameterizedClass=ReflectionUtils.getParameterizedClass(mf.getField(),0);
    if (parameterizedClass == null) {
      ve.add(new ConstraintViolation(Level.WARNING,mc,mf,this.getClass(),""String_Node_Str"" + supportedExample));
    }
 else     if (!parameterizedClass.equals(String.class) && !parameterizedClass.equals(ObjectId.class) && !ReflectionUtils.isPrimitiveLike(parameterizedClass))     ve.add(new ConstraintViolation(Level.FATAL,mc,mf,this.getClass(),""String_Node_Str"" + supportedExample + ""String_Node_Str""+ parameterizedClass+ ""String_Node_Str""));
  }
}",0.9673758865248226
104756,"@Test public void testObjectIdKeyedMap() throws Exception {
  ContainsObjectIdKeyMap map=new ContainsObjectIdKeyMap();
  ObjectId o1=new ObjectId(""String_Node_Str"");
  ObjectId o2=new ObjectId(""String_Node_Str"");
  map.values.put(o1,""String_Node_Str"");
  map.values.put(o2,""String_Node_Str"");
  Key<?> mapKey=ds.save(map);
  ContainsObjectIdKeyMap mapLoaded=ds.get(ContainsObjectIdKeyMap.class,mapKey.getId());
  assertNotNull(mapLoaded);
  assertEquals(2,mapLoaded.values.size());
  assertNotNull(mapLoaded.values.get(o1));
  assertNotNull(mapLoaded.values.get(o2));
  assertNotNull(ds.find(ContainsIntKeyMap.class).field(""String_Node_Str"").exists());
  assertEquals(0,ds.find(ContainsIntKeyMap.class).field(""String_Node_Str"").doesNotExist().countAll());
  assertNotNull(ds.find(ContainsIntKeyMap.class).field(""String_Node_Str"").doesNotExist());
  assertEquals(0,ds.find(ContainsIntKeyMap.class).field(""String_Node_Str"").exists().countAll());
}","@Test public void testObjectIdKeyedMap() throws Exception {
  morphia.map(ContainsObjectIdKeyMap.class);
  ContainsObjectIdKeyMap map=new ContainsObjectIdKeyMap();
  ObjectId o1=new ObjectId(""String_Node_Str"");
  ObjectId o2=new ObjectId(""String_Node_Str"");
  map.values.put(o1,""String_Node_Str"");
  map.values.put(o2,""String_Node_Str"");
  Key<?> mapKey=ds.save(map);
  ContainsObjectIdKeyMap mapLoaded=ds.get(ContainsObjectIdKeyMap.class,mapKey.getId());
  assertNotNull(mapLoaded);
  assertEquals(2,mapLoaded.values.size());
  assertNotNull(mapLoaded.values.get(o1));
  assertNotNull(mapLoaded.values.get(o2));
  assertNotNull(ds.find(ContainsIntKeyMap.class).field(""String_Node_Str"").exists());
  assertEquals(0,ds.find(ContainsIntKeyMap.class).field(""String_Node_Str"").doesNotExist().countAll());
  assertNotNull(ds.find(ContainsIntKeyMap.class).field(""String_Node_Str"").doesNotExist());
  assertEquals(0,ds.find(ContainsIntKeyMap.class).field(""String_Node_Str"").exists().countAll());
}",0.9767441860465116
104757,"<T>Query<T> createQuery(Class<T> kind,DBObject q);","<T>Query<T> createQuery(String kind,Class<T> clazz,DBObject q);",0.8141592920353983
104758,"private <T>UpdateResults<T> update(Query<T> query,DBObject u,boolean createIfMissing,boolean multi,WriteConcern wc){
  DBCollection dbColl=getCollection(((QueryImpl<T>)query).getEntityClass());
  QueryImpl<T> qImpl=(QueryImpl<T>)query;
  if (qImpl.getSortObject() != null && qImpl.getSortObject().keySet() != null && !qImpl.getSortObject().keySet().isEmpty())   throw new QueryException(""String_Node_Str"");
  if (qImpl.getOffset() > 0)   throw new QueryException(""String_Node_Str"");
  if (qImpl.getLimit() > 0)   throw new QueryException(""String_Node_Str"");
  DBObject q=qImpl.getQueryObject();
  if (q == null)   q=new BasicDBObject();
  if (log.isTraceEnabled())   log.trace(""String_Node_Str"" + dbColl.getName() + ""String_Node_Str""+ q+ ""String_Node_Str""+ u+ ""String_Node_Str""+ multi+ ""String_Node_Str""+ createIfMissing);
  WriteResult wr;
  if (wc == null)   wr=dbColl.update(q,u,createIfMissing,multi);
 else   wr=dbColl.update(q,u,createIfMissing,multi,wc);
  throwOnError(wc,wr);
  return new UpdateResults<T>(wr);
}","private <T>UpdateResults<T> update(Query<T> query,DBObject u,boolean createIfMissing,boolean multi,WriteConcern wc){
  QueryImpl<T> qi=(QueryImpl<T>)query;
  DBCollection dbColl=qi.getCollection();
  if (dbColl == null)   dbColl=getCollection(qi.getEntityClass());
  if (qi.getSortObject() != null && qi.getSortObject().keySet() != null && !qi.getSortObject().keySet().isEmpty())   throw new QueryException(""String_Node_Str"");
  if (qi.getOffset() > 0)   throw new QueryException(""String_Node_Str"");
  if (qi.getLimit() > 0)   throw new QueryException(""String_Node_Str"");
  DBObject q=qi.getQueryObject();
  if (q == null)   q=new BasicDBObject();
  if (log.isTraceEnabled())   log.trace(""String_Node_Str"" + dbColl.getName() + ""String_Node_Str""+ q+ ""String_Node_Str""+ u+ ""String_Node_Str""+ multi+ ""String_Node_Str""+ createIfMissing);
  WriteResult wr;
  if (wc == null)   wr=dbColl.update(q,u,createIfMissing,multi);
 else   wr=dbColl.update(q,u,createIfMissing,multi,wc);
  throwOnError(wc,wr);
  return new UpdateResults<T>(wr);
}",0.1656113005358012
104759,"public <T>UpdateResults<T> updateFirst(Query<T> query,T entity,boolean createIfMissing){
  LinkedHashMap<Object,DBObject> involvedObjects=new LinkedHashMap<Object,DBObject>();
  DBObject dbObj=mapr.toDBObject(entity,involvedObjects);
  UpdateResults<T> res=update(query,dbObj,createIfMissing,false,getWriteConcern(entity));
  CommandResult gle=res.getWriteResult().getCachedLastError();
  if (gle != null && res.getInsertedCount() > 0)   dbObj.put(Mapper.ID_KEY,res.getNewId());
  postSaveOperations(entity,dbObj,getCollection(entity),involvedObjects);
  return res;
}","public <T>UpdateResults<T> updateFirst(Query<T> query,T entity,boolean createIfMissing){
  LinkedHashMap<Object,DBObject> involvedObjects=new LinkedHashMap<Object,DBObject>();
  DBObject dbObj=mapr.toDBObject(entity,involvedObjects);
  UpdateResults<T> res=update(query,dbObj,createIfMissing,false,getWriteConcern(entity));
  CommandResult gle=res.getWriteResult().getCachedLastError();
  if (gle != null && res.getInsertedCount() > 0)   dbObj.put(Mapper.ID_KEY,res.getNewId());
  postSaveOperations(entity,dbObj,involvedObjects);
  return res;
}",0.9802513464991024
104760,"public <T>T findAndDelete(Query<T> query){
  DBCollection dbColl=getCollection(((QueryImpl<T>)query).getEntityClass());
  QueryImpl<T> qi=((QueryImpl<T>)query);
  EntityCache cache=createCache();
  if (log.isTraceEnabled())   log.trace(""String_Node_Str"" + dbColl.getName() + ""String_Node_Str"");
  DBObject result=dbColl.findAndModify(qi.getQueryObject(),qi.getFieldsObject(),qi.getSortObject(),true,null,false,false);
  if (result != null) {
    T entity=(T)mapr.fromDBObject(qi.getEntityClass(),result,cache);
    return entity;
  }
  return null;
}","public <T>T findAndDelete(Query<T> query){
  DBCollection dbColl=((QueryImpl<T>)query).getCollection();
  if (dbColl == null)   dbColl=getCollection(((QueryImpl<T>)query).getEntityClass());
  QueryImpl<T> qi=((QueryImpl<T>)query);
  EntityCache cache=createCache();
  if (log.isTraceEnabled())   log.trace(""String_Node_Str"" + dbColl.getName() + ""String_Node_Str"");
  DBObject result=dbColl.findAndModify(qi.getQueryObject(),qi.getFieldsObject(),qi.getSortObject(),true,null,false,false);
  if (result != null) {
    T entity=(T)mapr.fromDBObject(qi.getEntityClass(),result,cache);
    return entity;
  }
  return null;
}",0.9401709401709402
104761,"public <T>void delete(Query<T> query,WriteConcern wc){
  QueryImpl<T> q=(QueryImpl<T>)query;
  DBCollection dbColl=getCollection(q.getEntityClass());
  WriteResult wr;
  if (q.getSortObject() != null || q.getOffset() != 0 || q.getLimit() > 0)   throw new QueryException(""String_Node_Str"");
  if (q.getQueryObject() != null)   if (wc == null)   wr=dbColl.remove(q.getQueryObject());
 else   wr=dbColl.remove(q.getQueryObject(),wc);
 else   if (wc == null)   wr=dbColl.remove(new BasicDBObject());
 else   wr=dbColl.remove(new BasicDBObject(),wc);
  throwOnError(wc,wr);
}","public <T>void delete(Query<T> query,WriteConcern wc){
  QueryImpl<T> q=(QueryImpl<T>)query;
  DBCollection dbColl=q.getCollection();
  if (dbColl == null)   dbColl=getCollection(q.getEntityClass());
  WriteResult wr;
  if (q.getSortObject() != null || q.getOffset() != 0 || q.getLimit() > 0)   throw new QueryException(""String_Node_Str"");
  if (q.getQueryObject() != null)   if (wc == null)   wr=dbColl.remove(q.getQueryObject());
 else   wr=dbColl.remove(q.getQueryObject(),wc);
 else   if (wc == null)   wr=dbColl.remove(new BasicDBObject());
 else   wr=dbColl.remove(new BasicDBObject(),wc);
  throwOnError(wc,wr);
}",0.957983193277311
104762,"/** 
 * call postSaveOperations and returns Key for entity 
 */
protected <T>Key<T> postSaveGetKey(T entity,DBObject dbObj,DBCollection dbColl,Map<Object,DBObject> involvedObjects){
  if (dbObj.get(Mapper.ID_KEY) == null)   throw new MappingException(""String_Node_Str"");
  postSaveOperations(entity,dbObj,dbColl,involvedObjects);
  Key<T> key=new Key<T>(dbColl.getName(),getId(entity));
  key.setKindClass((Class<? extends T>)entity.getClass());
  return key;
}","/** 
 * call postSaveOperations and returns Key for entity 
 */
protected <T>Key<T> postSaveGetKey(T entity,DBObject dbObj,DBCollection dbColl,Map<Object,DBObject> involvedObjects){
  if (dbObj.get(Mapper.ID_KEY) == null)   throw new MappingException(""String_Node_Str"");
  postSaveOperations(entity,dbObj,involvedObjects);
  Key<T> key=new Key<T>(dbColl.getName(),getId(entity));
  key.setKindClass((Class<? extends T>)entity.getClass());
  return key;
}",0.9923497267759562
104763,"public <T>Key<T> merge(T entity,WriteConcern wc){
  LinkedHashMap<Object,DBObject> involvedObjects=new LinkedHashMap<Object,DBObject>();
  DBObject dbObj=mapr.toDBObject(entity,involvedObjects);
  Key<T> key=getKey(entity);
  entity=ProxyHelper.unwrap(entity);
  Object id=getId(entity);
  if (id == null)   throw new MappingException(""String_Node_Str"" + entity.getClass().getName());
  Query<T> query=(Query<T>)createQuery(entity.getClass()).filter(Mapper.ID_KEY,id);
  dbObj.removeField(Mapper.ID_KEY);
  UpdateResults<T> res=update(query,new BasicDBObject(""String_Node_Str"",dbObj),false,false,wc);
  CommandResult gle=res.getWriteResult().getCachedLastError();
  if (gle != null && res.getUpdatedCount() == 0)   throw new UpdateException(""String_Node_Str"" + gle);
  postSaveOperations(entity,dbObj,getCollection(entity),involvedObjects);
  return key;
}","public <T>Key<T> merge(T entity,WriteConcern wc){
  LinkedHashMap<Object,DBObject> involvedObjects=new LinkedHashMap<Object,DBObject>();
  DBObject dbObj=mapr.toDBObject(entity,involvedObjects);
  Key<T> key=getKey(entity);
  entity=ProxyHelper.unwrap(entity);
  Object id=getId(entity);
  if (id == null)   throw new MappingException(""String_Node_Str"" + entity.getClass().getName());
  Query<T> query=(Query<T>)createQuery(entity.getClass()).filter(Mapper.ID_KEY,id);
  dbObj.removeField(Mapper.ID_KEY);
  UpdateResults<T> res=update(query,new BasicDBObject(""String_Node_Str"",dbObj),false,false,wc);
  CommandResult gle=res.getWriteResult().getCachedLastError();
  if (gle != null && res.getUpdatedCount() == 0)   throw new UpdateException(""String_Node_Str"" + gle);
  postSaveOperations(entity,dbObj,involvedObjects);
  return key;
}",0.98698224852071
104764,"private <T>void postSaveOperations(Object entity,DBObject dbObj,DBCollection dbColl,Map<Object,DBObject> involvedObjects){
  MappedClass mc=mapr.getMappedClass(entity);
  mapr.updateKeyInfo(entity,dbObj,createCache());
  firePostPersistForChildren(involvedObjects);
  mc.callLifecycleMethods(PostPersist.class,entity,dbObj,mapr);
}","private <T>void postSaveOperations(Object entity,DBObject dbObj,Map<Object,DBObject> involvedObjects){
  MappedClass mc=mapr.getMappedClass(entity);
  mapr.updateKeyInfo(entity,dbObj,createCache());
  firePostPersistForChildren(involvedObjects);
  mc.callLifecycleMethods(PostPersist.class,entity,dbObj,mapr);
}",0.9345794392523364
104765,"public <T>Query<T> createQuery(Class<T> kind,DBObject q){
  return new QueryImpl<T>(kind,getCollection(kind),this,q);
}","public <T>Query<T> createQuery(String kind,Class<T> clazz){
  return new QueryImpl<T>(clazz,db.getCollection(kind),this);
}",0.8181818181818182
104766,"@SuppressWarnings(""String_Node_Str"") public <T>MapreduceResults<T> mapReduce(MapreduceType type,Query query,String map,String reduce,String finalize,Map<String,Object> scopeFields,Class<T> outputType){
  Assert.parametersNotNull(""String_Node_Str"",map);
  Assert.parameterNotEmpty(map,""String_Node_Str"");
  Assert.parametersNotNull(""String_Node_Str"",reduce);
  Assert.parameterNotEmpty(reduce,""String_Node_Str"");
  QueryImpl<T> qi=((QueryImpl<T>)query);
  DBCollection dbColl=getCollection((qi).getEntityClass());
  if (log.isTraceEnabled())   log.info(""String_Node_Str"" + dbColl.getName() + ""String_Node_Str""+ qi.toString()+ ""String_Node_Str""+ map+ ""String_Node_Str""+ reduce+ ""String_Node_Str""+ finalize+ ""String_Node_Str""+ scopeFields+ ""String_Node_Str"");
  String outColl=mapr.getCollectionName(outputType);
  BasicDBObjectBuilder bldr=BasicDBObjectBuilder.start(""String_Node_Str"",mapr.getCollectionName(qi.getEntityClass()));
switch (type) {
case REDUCE:
    bldr.push(""String_Node_Str"").add(""String_Node_Str"",outColl).pop();
  break;
case MERGE:
bldr.push(""String_Node_Str"").add(""String_Node_Str"",outColl).pop();
break;
case INLINE:
bldr.push(""String_Node_Str"").add(""String_Node_Str"",1).pop();
break;
default :
bldr.add(""String_Node_Str"",outColl);
break;
}
if (qi.getOffset() != 0 || qi.getFieldsObject() != null) throw new QueryException(""String_Node_Str"");
if (qi.getQueryObject() != null) bldr.add(""String_Node_Str"",qi.getQueryObject());
if (qi.getLimit() > 0) bldr.add(""String_Node_Str"",qi.getLimit());
if (qi.getSortObject() != null) bldr.add(""String_Node_Str"",qi.getSortObject());
bldr.add(""String_Node_Str"",map);
bldr.add(""String_Node_Str"",reduce);
if (finalize != null && finalize.length() > 0) bldr.add(""String_Node_Str"",finalize);
if (scopeFields != null && scopeFields.size() > 0) bldr.add(""String_Node_Str"",mapr.toMongoObject(null,null,scopeFields));
DBObject dbObj=bldr.get();
CommandResult cr=dbColl.getDB().command(dbObj);
cr.throwOnError();
MapreduceResults mrRes=(MapreduceResults)mapr.fromDBObject(MapreduceResults.class,cr,createCache());
QueryImpl baseQ=null;
if (!MapreduceType.INLINE.equals(type)) baseQ=new QueryImpl(outputType,db.getCollection(mrRes.getOutputCollectionName()),this);
mrRes.setBits(type,baseQ);
return mrRes;
}","@SuppressWarnings(""String_Node_Str"") public <T>MapreduceResults<T> mapReduce(MapreduceType type,Query query,String map,String reduce,String finalize,Map<String,Object> scopeFields,Class<T> outputType){
  Assert.parametersNotNull(""String_Node_Str"",map);
  Assert.parameterNotEmpty(map,""String_Node_Str"");
  Assert.parametersNotNull(""String_Node_Str"",reduce);
  Assert.parameterNotEmpty(reduce,""String_Node_Str"");
  QueryImpl<T> qi=(QueryImpl<T>)query;
  DBCollection dbColl=qi.getCollection();
  if (dbColl == null)   dbColl=getCollection(qi.getEntityClass());
  if (log.isTraceEnabled())   log.info(""String_Node_Str"" + dbColl.getName() + ""String_Node_Str""+ qi.toString()+ ""String_Node_Str""+ map+ ""String_Node_Str""+ reduce+ ""String_Node_Str""+ finalize+ ""String_Node_Str""+ scopeFields+ ""String_Node_Str"");
  String outColl=mapr.getCollectionName(outputType);
  BasicDBObjectBuilder bldr=BasicDBObjectBuilder.start(""String_Node_Str"",mapr.getCollectionName(qi.getEntityClass()));
switch (type) {
case REDUCE:
    bldr.push(""String_Node_Str"").add(""String_Node_Str"",outColl).pop();
  break;
case MERGE:
bldr.push(""String_Node_Str"").add(""String_Node_Str"",outColl).pop();
break;
case INLINE:
bldr.push(""String_Node_Str"").add(""String_Node_Str"",1).pop();
break;
default :
bldr.add(""String_Node_Str"",outColl);
break;
}
if (qi.getOffset() != 0 || qi.getFieldsObject() != null) throw new QueryException(""String_Node_Str"");
if (qi.getQueryObject() != null) bldr.add(""String_Node_Str"",qi.getQueryObject());
if (qi.getLimit() > 0) bldr.add(""String_Node_Str"",qi.getLimit());
if (qi.getSortObject() != null) bldr.add(""String_Node_Str"",qi.getSortObject());
bldr.add(""String_Node_Str"",map);
bldr.add(""String_Node_Str"",reduce);
if (finalize != null && finalize.length() > 0) bldr.add(""String_Node_Str"",finalize);
if (scopeFields != null && scopeFields.size() > 0) bldr.add(""String_Node_Str"",mapr.toMongoObject(null,null,scopeFields));
DBObject dbObj=bldr.get();
CommandResult cr=dbColl.getDB().command(dbObj);
cr.throwOnError();
MapreduceResults mrRes=(MapreduceResults)mapr.fromDBObject(MapreduceResults.class,cr,createCache());
QueryImpl baseQ=null;
if (!MapreduceType.INLINE.equals(type)) baseQ=new QueryImpl(outputType,db.getCollection(mrRes.getOutputCollectionName()),this);
mrRes.setBits(type,baseQ);
return mrRes;
}",0.988364434687157
104767,"public <T>T findAndModify(Query<T> query,UpdateOperations<T> ops,boolean oldVersion,boolean createIfMissing){
  QueryImpl<T> qi=((QueryImpl<T>)query);
  DBCollection dbColl=getCollection((qi).getEntityClass());
  if (log.isTraceEnabled())   log.info(""String_Node_Str"" + dbColl.getName() + ""String_Node_Str"");
  DBObject res=dbColl.findAndModify(qi.getQueryObject(),qi.getFieldsObject(),qi.getSortObject(),false,((UpdateOpsImpl<T>)ops).getOps(),!oldVersion,createIfMissing);
  if (res == null)   return null;
 else   return (T)mapr.fromDBObject(qi.getEntityClass(),res,createCache());
}","public <T>T findAndModify(Query<T> query,UpdateOperations<T> ops,boolean oldVersion,boolean createIfMissing){
  QueryImpl<T> qi=(QueryImpl<T>)query;
  DBCollection dbColl=qi.getCollection();
  if (dbColl == null)   dbColl=getCollection(qi.getEntityClass());
  if (log.isTraceEnabled())   log.info(""String_Node_Str"" + dbColl.getName() + ""String_Node_Str"");
  DBObject res=dbColl.findAndModify(qi.getQueryObject(),qi.getFieldsObject(),qi.getSortObject(),false,((UpdateOpsImpl<T>)ops).getOps(),!oldVersion,createIfMissing);
  if (res == null)   return null;
 else   return (T)mapr.fromDBObject(qi.getEntityClass(),res,createCache());
}",0.9285127362366477
104768,"/** 
 * Gets the write concern for entity or returns the default write concern for this datastore 
 */
public WriteConcern getWriteConcern(Object clazzOrEntity){
  if (clazzOrEntity != null) {
    Entity entityAnn=getMapper().getMappedClass(clazzOrEntity).getEntityAnnotation();
    if (entityAnn != null && entityAnn.concern() != null && entityAnn.concern() != ""String_Node_Str"")     return WriteConcern.valueOf(entityAnn.concern());
  }
  return defConcern;
}","/** 
 * Gets the write concern for entity or returns the default write concern for this datastore 
 */
public WriteConcern getWriteConcern(Object clazzOrEntity){
  WriteConcern wc=null;
  if (clazzOrEntity != null) {
    Entity entityAnn=getMapper().getMappedClass(clazzOrEntity).getEntityAnnotation();
    if (entityAnn != null && entityAnn.concern() != null && entityAnn.concern() != ""String_Node_Str"")     wc=WriteConcern.valueOf(entityAnn.concern());
  }
  if (wc == null)   wc=defConcern;
  return wc;
}",0.9226006191950464
104769,"public static Set<Class<?>> getClasses(final ClassLoader loader,final String packageName) throws IOException, ClassNotFoundException {
  Set<Class<?>> classes=new HashSet<Class<?>>();
  String path=packageName.replace('.','/');
  Enumeration<URL> resources=loader.getResources(path);
  if (resources != null) {
    while (resources.hasMoreElements()) {
      String filePath=resources.nextElement().getFile();
      if (filePath.indexOf(""String_Node_Str"") > 0) {
        filePath=filePath.replaceAll(""String_Node_Str"",""String_Node_Str"");
      }
      if (filePath != null) {
        if ((filePath.indexOf(""String_Node_Str"") > 0) & (filePath.indexOf(""String_Node_Str"") > 0)) {
          String jarPath=filePath.substring(0,filePath.indexOf(""String_Node_Str"")).substring(filePath.indexOf(""String_Node_Str"") + 1);
          if (jarPath.indexOf(""String_Node_Str"") >= 0) {
            jarPath=jarPath.substring(1);
          }
          classes.addAll(getFromJARFile(jarPath,path));
        }
 else {
          classes.addAll(getFromDirectory(new File(filePath),packageName));
        }
      }
    }
  }
  return classes;
}","public static Set<Class<?>> getClasses(final ClassLoader loader,final String packageName) throws IOException, ClassNotFoundException {
  Set<Class<?>> classes=new HashSet<Class<?>>();
  String path=packageName.replace('.','/');
  Enumeration<URL> resources=loader.getResources(path);
  if (resources != null) {
    while (resources.hasMoreElements()) {
      String filePath=resources.nextElement().getFile();
      if (filePath.indexOf(""String_Node_Str"") > 0)       filePath=filePath.replaceAll(""String_Node_Str"",""String_Node_Str"");
      if (filePath.indexOf(""String_Node_Str"") > 0)       filePath=filePath.replaceAll(""String_Node_Str"",""String_Node_Str"");
      if (filePath != null) {
        if ((filePath.indexOf(""String_Node_Str"") > 0) & (filePath.indexOf(""String_Node_Str"") > 0)) {
          String jarPath=filePath.substring(0,filePath.indexOf(""String_Node_Str"")).substring(filePath.indexOf(""String_Node_Str"") + 1);
          if (jarPath.indexOf(""String_Node_Str"") >= 0) {
            jarPath=jarPath.substring(1);
          }
          classes.addAll(getFromJARFile(jarPath,path));
        }
 else {
          classes.addAll(getFromDirectory(new File(filePath),packageName));
        }
      }
    }
  }
  return classes;
}",0.9481292517006804
104770,"public <T>T findAndModify(Query<T> query,UpdateOperations<T> ops,boolean oldVersion,boolean createIfMissing){
  DBCollection dbColl=getCollection(((QueryImpl<T>)query).getEntityClass());
  QueryImpl<T> qi=((QueryImpl<T>)query);
  if (log.isTraceEnabled())   log.info(""String_Node_Str"" + dbColl.getName() + ""String_Node_Str"");
  DBObject res=dbColl.findAndModify(qi.getQueryObject(),qi.getFieldsObject(),qi.getSortObject(),false,((UpdateOpsImpl<T>)ops).getOps(),!oldVersion,createIfMissing);
  if (res == null)   return null;
 else   return (T)mapr.fromDBObject(qi.getEntityClass(),res,createCache());
}","public <T>T findAndModify(Query<T> query,UpdateOperations<T> ops,boolean oldVersion,boolean createIfMissing){
  QueryImpl<T> qi=((QueryImpl<T>)query);
  DBCollection dbColl=getCollection((qi).getEntityClass());
  if (log.isTraceEnabled())   log.info(""String_Node_Str"" + dbColl.getName() + ""String_Node_Str"");
  DBObject res=dbColl.findAndModify(qi.getQueryObject(),qi.getFieldsObject(),qi.getSortObject(),false,((UpdateOpsImpl<T>)ops).getOps(),!oldVersion,createIfMissing);
  if (res == null)   return null;
 else   return (T)mapr.fromDBObject(qi.getEntityClass(),res,createCache());
}",0.9132266217354676
104771,"@Override public Object decode(Class targetClass,Object val,MappedField optionalExtraInfo) throws MappingException {
  if (val == null)   return null;
  if (val instanceof Boolean)   return (Boolean)val;
  String sVal=val.toString();
  return Boolean.parseBoolean(sVal);
}","@Override public Object decode(Class targetClass,Object val,MappedField optionalExtraInfo) throws MappingException {
  if (val == null)   return null;
  if (val instanceof Boolean)   return (Boolean)val;
  if (val instanceof Number)   return ((Number)val).doubleValue() == 1D;
  String sVal=val.toString();
  return Boolean.parseBoolean(sVal);
}",0.8816855753646677
104772,"Object fromDb(DBObject dbObject,final Object entity,EntityCache cache){
  if (entity instanceof MappedField) {
    readMappedField(dbObject,(MappedField)entity,entity,cache);
    return entity;
  }
  if (dbObject.containsField(ID_KEY) && getMappedClass(entity).getIdField() != null && getMappedClass(entity).getEntityAnnotation() != null) {
    Key key=new Key(entity.getClass(),dbObject.get(ID_KEY));
    Object cachedInstance=cache.getEntity(key);
    if (cachedInstance != null)     return cachedInstance;
 else     cache.putEntity(key,entity);
  }
  MappedClass mc=getMappedClass(entity);
  dbObject=(BasicDBObject)mc.callLifecycleMethods(PreLoad.class,entity,dbObject,this);
  try {
    for (    MappedField mf : mc.getPersistenceFields()) {
      readMappedField(dbObject,mf,entity,cache);
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  if (dbObject.containsField(ID_KEY) && getMappedClass(entity).getIdField() != null) {
    Key key=new Key(entity.getClass(),dbObject.get(ID_KEY));
    cache.putEntity(key,entity);
  }
  mc.callLifecycleMethods(PostLoad.class,entity,dbObject,this);
  return entity;
}","Object fromDb(DBObject dbObject,Object entity,EntityCache cache){
  if (entity instanceof MappedField) {
    readMappedField(dbObject,(MappedField)entity,entity,cache);
    return entity;
  }
  if (dbObject.containsField(ID_KEY) && getMappedClass(entity).getIdField() != null && getMappedClass(entity).getEntityAnnotation() != null) {
    Key key=new Key(entity.getClass(),dbObject.get(ID_KEY));
    Object cachedInstance=cache.getEntity(key);
    if (cachedInstance != null)     return cachedInstance;
 else     cache.putEntity(key,entity);
  }
  MappedClass mc=getMappedClass(entity);
  dbObject=(BasicDBObject)mc.callLifecycleMethods(PreLoad.class,entity,dbObject,this);
  try {
    for (    MappedField mf : mc.getPersistenceFields()) {
      readMappedField(dbObject,mf,entity,cache);
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  if (dbObject.containsField(ID_KEY) && getMappedClass(entity).getIdField() != null) {
    Key key=new Key(entity.getClass(),dbObject.get(ID_KEY));
    cache.putEntity(key,entity);
  }
  mc.callLifecycleMethods(PostLoad.class,entity,dbObject,this);
  return entity;
}",0.9973544973544972
104773,"@Before public void setUp(){
  this.db=this.mongo.getDB(""String_Node_Str"");
  this.ds=this.morphia.createDatastore(this.mongo,this.db.getName());
}","@Before public void setUp(){
  this.db=this.mongo.getDB(""String_Node_Str"");
  this.ds=this.morphia.createDatastore(this.mongo,this.db.getName());
  this.ads=(AdvancedDatastore)ds;
}",0.8963414634146342
104774,"public static <T>Class<?> getTypeArgument(Class<? extends T> clazz,TypeVariable<? extends GenericDeclaration> tv){
  Map<Type,Type> resolvedTypes=new HashMap<Type,Type>();
  Type type=clazz;
  while (!getClass(type).equals(Object.class)) {
    if (type instanceof Class) {
      type=((Class)type).getGenericSuperclass();
    }
 else {
      ParameterizedType parameterizedType=(ParameterizedType)type;
      Class<?> rawType=(Class)parameterizedType.getRawType();
      Type[] actualTypeArguments=parameterizedType.getActualTypeArguments();
      TypeVariable<?>[] typeParameters=rawType.getTypeParameters();
      for (int i=0; i < actualTypeArguments.length; i++) {
        if (typeParameters[i].equals(tv))         return getClass(actualTypeArguments[i]);
        resolvedTypes.put(typeParameters[i],actualTypeArguments[i]);
      }
      if (!rawType.equals(Object.class)) {
        type=rawType.getGenericSuperclass();
      }
    }
  }
  return null;
}","public static <T>Class<?> getTypeArgument(Class<? extends T> clazz,TypeVariable<? extends GenericDeclaration> tv){
  Map<Type,Type> resolvedTypes=new HashMap<Type,Type>();
  Type type=clazz;
  while (!getClass(type).equals(Object.class)) {
    if (type instanceof Class) {
      type=((Class)type).getGenericSuperclass();
    }
 else {
      ParameterizedType parameterizedType=(ParameterizedType)type;
      Class<?> rawType=(Class)parameterizedType.getRawType();
      Type[] actualTypeArguments=parameterizedType.getActualTypeArguments();
      TypeVariable<?>[] typeParameters=rawType.getTypeParameters();
      for (int i=0; i < actualTypeArguments.length; i++) {
        if (typeParameters[i].equals(tv)) {
          Class cls=getClass(actualTypeArguments[i]);
          if (cls != null)           return cls;
          return getClass(resolvedTypes.get(actualTypeArguments[i]));
        }
        resolvedTypes.put(typeParameters[i],actualTypeArguments[i]);
      }
      if (!rawType.equals(Object.class)) {
        type=rawType.getGenericSuperclass();
      }
    }
  }
  return null;
}",0.9162609542356378
104775,"/** 
 * Gets the write concern for entity or returns the default write concern for this datastore 
 */
public WriteConcern getWriteConcern(Object clazzOrEntity){
  WriteConcern wc=null;
  if (clazzOrEntity != null) {
    Entity entityAnn=getMapper().getMappedClass(clazzOrEntity).getEntityAnnotation();
    if (entityAnn != null && entityAnn.concern() != null && entityAnn.concern() != ""String_Node_Str"")     wc=WriteConcern.valueOf(entityAnn.concern());
  }
  if (wc == null)   wc=defConcern;
  return wc;
}","/** 
 * Gets the write concern for entity or returns the default write concern for this datastore 
 */
public WriteConcern getWriteConcern(Object clazzOrEntity){
  WriteConcern wc=null;
  if (clazzOrEntity != null) {
    Entity entityAnn=getMapper().getMappedClass(clazzOrEntity).getEntityAnnotation();
    if (entityAnn != null && entityAnn.concern() != null && !""String_Node_Str"".equals(entityAnn.concern()))     wc=WriteConcern.valueOf(entityAnn.concern());
  }
  if (wc == null)   wc=defConcern;
  return wc;
}",0.9510763209393346
104776,"/** 
 * Find the first Entity from the Query, and modify it.
 * @param q the query to find the Entity with; You are not allowed to offset/skip in the query.
 * @param oldVersion indicated the old version of the Entity should be returned
 * @return The Entity (the result of the update if oldVersion is false)
 */
<T>T findAndModify(Query<T> q,UpdateOperations<T> ops,boolean oldVersion);","/** 
 * Find the first Entity from the Query, and modify it.
 * @param q the query to find the Entity with; You are not allowed to offset/skip in the query.
 * @param oldVersion indicated the old version of the Entity should be returned
 * @param createIfMissing if the query returns no results, then a new object will be created (sets upsert=true)
 * @return The Entity (the result of the update if oldVersion is false)
 */
<T>T findAndModify(Query<T> q,UpdateOperations<T> ops,boolean oldVersion,boolean createIfMissing);",0.8505494505494505
104777,"public <T>T findAndModify(Query<T> query,UpdateOperations<T> ops,boolean oldVersion){
  DBCollection dbColl=getCollection(((QueryImpl<T>)query).getEntityClass());
  QueryImpl<T> qi=((QueryImpl<T>)query);
  if (log.isTraceEnabled())   log.info(""String_Node_Str"" + dbColl.getName() + ""String_Node_Str"");
  DBObject res=dbColl.findAndModify(qi.getQueryObject(),qi.getFieldsObject(),qi.getSortObject(),false,((UpdateOpsImpl<T>)ops).getOps(),!oldVersion,false);
  if (res == null)   return null;
 else   return (T)mapr.fromDBObject(qi.getEntityClass(),res,createCache());
}","public <T>T findAndModify(Query<T> query,UpdateOperations<T> ops,boolean oldVersion,boolean createIfMissing){
  DBCollection dbColl=getCollection(((QueryImpl<T>)query).getEntityClass());
  QueryImpl<T> qi=((QueryImpl<T>)query);
  if (log.isTraceEnabled())   log.info(""String_Node_Str"" + dbColl.getName() + ""String_Node_Str"");
  DBObject res=dbColl.findAndModify(qi.getQueryObject(),qi.getFieldsObject(),qi.getSortObject(),false,((UpdateOpsImpl<T>)ops).getOps(),!oldVersion,createIfMissing);
  if (res == null)   return null;
 else   return (T)mapr.fromDBObject(qi.getEntityClass(),res,createCache());
}",0.9623931623931624
104778,"public DatastoreImpl(Morphia morphia,Mongo mongo,String dbName){
  this(morphia,mongo,dbName,null,null);
}","public DatastoreImpl(Morphia morphia,Mongo mongo,String dbName){
  this(morphia.getMapper(),mongo,dbName);
}",0.897196261682243
104779,"@SuppressWarnings(""String_Node_Str"") public <T>MapreduceResults<T> mapReduce(MapreduceType type,Query query,String map,String reduce,String finalize,Map<String,Object> scopeFields,Class<T> outputType){
  Assert.parametersNotNull(""String_Node_Str"",map);
  Assert.parameterNotEmpty(map,""String_Node_Str"");
  Assert.parametersNotNull(""String_Node_Str"",reduce);
  Assert.parameterNotEmpty(reduce,""String_Node_Str"");
  QueryImpl<T> qi=(QueryImpl<T>)query;
  DBCollection dbColl=qi.getCollection();
  if (dbColl == null)   dbColl=getCollection(qi.getEntityClass());
  if (log.isTraceEnabled())   log.info(""String_Node_Str"" + dbColl.getName() + ""String_Node_Str""+ qi.toString()+ ""String_Node_Str""+ map+ ""String_Node_Str""+ reduce+ ""String_Node_Str""+ finalize+ ""String_Node_Str""+ scopeFields+ ""String_Node_Str"");
  String outColl=mapr.getCollectionName(outputType);
  BasicDBObjectBuilder bldr=BasicDBObjectBuilder.start(""String_Node_Str"",mapr.getCollectionName(qi.getEntityClass()));
switch (type) {
case REDUCE:
    bldr.push(""String_Node_Str"").add(""String_Node_Str"",outColl).pop();
  break;
case MERGE:
bldr.push(""String_Node_Str"").add(""String_Node_Str"",outColl).pop();
break;
case INLINE:
bldr.push(""String_Node_Str"").add(""String_Node_Str"",1).pop();
break;
default :
bldr.add(""String_Node_Str"",outColl);
break;
}
if (qi.getOffset() != 0 || qi.getFieldsObject() != null) throw new QueryException(""String_Node_Str"");
if (qi.getQueryObject() != null) bldr.add(""String_Node_Str"",qi.getQueryObject());
if (qi.getLimit() > 0) bldr.add(""String_Node_Str"",qi.getLimit());
if (qi.getSortObject() != null) bldr.add(""String_Node_Str"",qi.getSortObject());
bldr.add(""String_Node_Str"",map);
bldr.add(""String_Node_Str"",reduce);
if (finalize != null && finalize.length() > 0) bldr.add(""String_Node_Str"",finalize);
if (scopeFields != null && scopeFields.size() > 0) bldr.add(""String_Node_Str"",mapr.toMongoObject(null,null,scopeFields));
DBObject dbObj=bldr.get();
CommandResult cr=dbColl.getDB().command(dbObj);
cr.throwOnError();
MapreduceResults mrRes=(MapreduceResults)mapr.fromDBObject(MapreduceResults.class,cr,createCache());
QueryImpl baseQ=null;
if (!MapreduceType.INLINE.equals(type)) baseQ=new QueryImpl(outputType,db.getCollection(mrRes.getOutputCollectionName()),this);
mrRes.setBits(type,baseQ);
return mrRes;
}","@SuppressWarnings(""String_Node_Str"") public <T>MapreduceResults<T> mapReduce(MapreduceType type,Query query,String map,String reduce,String finalize,Map<String,Object> scopeFields,Class<T> outputType){
  Assert.parametersNotNull(""String_Node_Str"",map);
  Assert.parameterNotEmpty(map,""String_Node_Str"");
  Assert.parametersNotNull(""String_Node_Str"",reduce);
  Assert.parameterNotEmpty(reduce,""String_Node_Str"");
  if (MapreduceType.INLINE.equals(type))   throw new IllegalArgumentException(""String_Node_Str"");
  QueryImpl<T> qi=(QueryImpl<T>)query;
  DBCollection dbColl=qi.getCollection();
  if (dbColl == null)   dbColl=getCollection(qi.getEntityClass());
  if (log.isTraceEnabled())   log.info(""String_Node_Str"" + dbColl.getName() + ""String_Node_Str""+ qi.toString()+ ""String_Node_Str""+ map+ ""String_Node_Str""+ reduce+ ""String_Node_Str""+ finalize+ ""String_Node_Str""+ scopeFields+ ""String_Node_Str"");
  String outColl=mapr.getCollectionName(outputType);
  BasicDBObjectBuilder bldr=BasicDBObjectBuilder.start(""String_Node_Str"",mapr.getCollectionName(qi.getEntityClass()));
switch (type) {
case REDUCE:
    bldr.push(""String_Node_Str"").add(""String_Node_Str"",outColl).pop();
  break;
case MERGE:
bldr.push(""String_Node_Str"").add(""String_Node_Str"",outColl).pop();
break;
case INLINE:
bldr.push(""String_Node_Str"").add(""String_Node_Str"",1).pop();
break;
default :
bldr.add(""String_Node_Str"",outColl);
break;
}
if (qi.getOffset() != 0 || qi.getFieldsObject() != null) throw new QueryException(""String_Node_Str"");
if (qi.getQueryObject() != null) bldr.add(""String_Node_Str"",qi.getQueryObject());
if (qi.getLimit() > 0) bldr.add(""String_Node_Str"",qi.getLimit());
if (qi.getSortObject() != null) bldr.add(""String_Node_Str"",qi.getSortObject());
bldr.add(""String_Node_Str"",map);
bldr.add(""String_Node_Str"",reduce);
if (finalize != null && finalize.length() > 0) bldr.add(""String_Node_Str"",finalize);
if (scopeFields != null && scopeFields.size() > 0) bldr.add(""String_Node_Str"",mapr.toMongoObject(null,null,scopeFields));
DBObject dbObj=bldr.get();
CommandResult cr=dbColl.getDB().command(dbObj);
cr.throwOnError();
MapreduceResults mrRes=(MapreduceResults)mapr.fromDBObject(MapreduceResults.class,cr,createCache());
QueryImpl baseQ=null;
if (!MapreduceType.INLINE.equals(type)) baseQ=new QueryImpl(outputType,db.getCollection(mrRes.getOutputCollectionName()),this);
mrRes.setBits(type,baseQ);
return mrRes;
}",0.9791489361702128
104780,"public Query<T> order(String condition){
  if (snapshotted)   throw new QueryException(""String_Node_Str"");
  sort=parseSortString(condition);
  return this;
}","public Query<T> order(String condition){
  if (snapshotted)   throw new QueryException(""String_Node_Str"");
  sort=parseFieldsString(condition,clazz,this.ds.getMapper(),this.validateName);
  return this;
}",0.7624309392265194
104781,"@Test public void testIdFieldNameMapping() throws Exception {
  Rectangle r=new Rectangle(1,12);
  BasicDBObject dbObj=(BasicDBObject)morphia.toDBObject(r);
  assertFalse(dbObj.containsField(""String_Node_Str""));
  assertTrue(dbObj.containsField(Mapper.ID_KEY));
  assertTrue(dbObj.containsField(""String_Node_Str""));
  assertTrue(dbObj.containsField(""String_Node_Str""));
  assertEquals(4,dbObj.size());
}","@Test public void testIdFieldNameMapping() throws Exception {
  Rectangle r=new Rectangle(1,12);
  BasicDBObject dbObj=(BasicDBObject)morphia.toDBObject(r);
  assertFalse(dbObj.containsField(""String_Node_Str""));
  assertTrue(dbObj.containsField(Mapper.ID_KEY));
  assertEquals(4,dbObj.size());
}",0.8452722063037249
104782,"@Override public String toString(){
  StringBuffer sb=new StringBuffer();
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(realType.getSimpleName()).append(""String_Node_Str"");
  if (isSingleValue())   sb.append(""String_Node_Str"");
 else {
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"").append(getSubClass()).append(""String_Node_Str"");
  }
  if (isMap()) {
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"").append(getMapKeyClass().getSimpleName());
  }
  if (isSet())   sb.append(""String_Node_Str"");
  if (isCollection)   sb.append(""String_Node_Str"");
  if (isArray)   sb.append(""String_Node_Str"");
  if (sb.charAt(sb.length() - 1) == ',')   sb.setLength(sb.length() - 1);
  sb.append(""String_Node_Str"").append(this.foundAnnotations.toString());
  return sb.toString();
}","@Override public String toString(){
  StringBuffer sb=new StringBuffer();
  sb.append(name).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(realType.getSimpleName()).append(""String_Node_Str"");
  if (isSingleValue())   sb.append(""String_Node_Str"");
 else {
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"").append(getSubClass()).append(""String_Node_Str"");
  }
  if (isMap()) {
    sb.append(""String_Node_Str"");
    if (getMapKeyClass() != null)     sb.append(""String_Node_Str"").append(getMapKeyClass().getSimpleName());
 else     sb.append(""String_Node_Str"");
  }
  if (isSet())   sb.append(""String_Node_Str"");
  if (isCollection)   sb.append(""String_Node_Str"");
  if (isArray)   sb.append(""String_Node_Str"");
  if (sb.charAt(sb.length() - 1) == ',')   sb.setLength(sb.length() - 1);
  sb.append(""String_Node_Str"").append(this.foundAnnotations.toString());
  return sb.toString();
}",0.917995444191344
104783,"protected DAO(Datastore ds){
  this.ds=(DatastoreImpl)ds;
  initType(((Class<T>)((ParameterizedType)getClass().getGenericSuperclass()).getActualTypeArguments()[0]));
}","public DAO(Class<T> entityClass,Datastore ds){
  super(entityClass,ds);
}",0.325
104784,"@Override public String toString(){
  return this.field + ""String_Node_Str"" + this.value;
}","@Override public String toString(){
  return this.field + ""String_Node_Str"" + this.operator.val()+ ""String_Node_Str""+ this.value;
}",0.8198198198198198
104785,"@SuppressWarnings(""String_Node_Str"") protected FieldCriteria(QueryImpl<?> query,String field,FilterOperator op,Object value,boolean validateNames,boolean validateTypes){
  StringBuffer sb=new StringBuffer(field);
  MappedField mf=Mapper.validate(query.getEntityClass(),query.getDatastore().getMapper(),sb,op,value,validateNames,validateTypes);
  field=sb.toString();
  Mapper mapr=query.getDatastore().getMapper();
  Object mappedValue;
  MappedClass mc=null;
  try {
    if (value != null && !ReflectionUtils.isPropertyType(value.getClass()) && !ReflectionUtils.implementsInterface(value.getClass(),Iterable.class))     if (mf != null && !mf.isTypeMongoCompatible())     mc=mapr.getMappedClass((mf.isSingleValue()) ? mf.getType() : mf.getSubClass());
 else     mc=mapr.getMappedClass(value);
  }
 catch (  Exception e) {
    log.debug(""String_Node_Str"",e);
  }
  if ((mf != null && (mf.hasAnnotation(Reference.class) || mf.getType().isAssignableFrom(Key.class))) || (mc != null && mc.getEntityAnnotation() != null)) {
    try {
      Key<?> k=(value instanceof Key) ? (Key<?>)value : query.getDatastore().getKey(value);
      mappedValue=mapr.keyToRef(k);
    }
 catch (    Exception e) {
      log.debug(""String_Node_Str"" + value + ""String_Node_Str"",e);
      mappedValue=mapr.toMongoObject(value);
    }
  }
 else   if (mf != null && mf.hasAnnotation(Serialized.class))   try {
    mappedValue=Serializer.serialize(value,!mf.getAnnotation(Serialized.class).disableCompression());
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
 else   if (value instanceof DBObject)   mappedValue=value;
 else   mappedValue=mapr.toMongoObject(value);
  Class<?> type=(mappedValue != null) ? mappedValue.getClass() : null;
  if (type != null && (op == FilterOperator.IN || op == FilterOperator.NOT_IN) && !type.isArray() && !Iterable.class.isAssignableFrom(type)) {
    mappedValue=Collections.singletonList(mappedValue);
  }
  this.field=field;
  this.operator=op;
  this.value=mappedValue;
}","@SuppressWarnings(""String_Node_Str"") protected FieldCriteria(QueryImpl<?> query,String field,FilterOperator op,Object value,boolean validateNames,boolean validateTypes){
  StringBuffer sb=new StringBuffer(field);
  MappedField mf=Mapper.validate(query.getEntityClass(),query.getDatastore().getMapper(),sb,op,value,validateNames,validateTypes);
  field=sb.toString();
  Mapper mapr=query.getDatastore().getMapper();
  Object mappedValue;
  MappedClass mc=null;
  try {
    if (value != null && !ReflectionUtils.isPropertyType(value.getClass()) && !ReflectionUtils.implementsInterface(value.getClass(),Iterable.class))     if (mf != null && !mf.isTypeMongoCompatible())     mc=mapr.getMappedClass((mf.isSingleValue()) ? mf.getType() : mf.getSubClass());
 else     mc=mapr.getMappedClass(value);
  }
 catch (  Exception e) {
    log.debug(""String_Node_Str"",e);
  }
  if ((mf != null && (mf.hasAnnotation(Reference.class) || mf.getType().isAssignableFrom(Key.class))) || (mc != null && mc.getEntityAnnotation() != null)) {
    try {
      Key<?> k=(value instanceof Key) ? (Key<?>)value : query.getDatastore().getKey(value);
      mappedValue=mapr.keyToRef(k);
    }
 catch (    Exception e) {
      log.debug(""String_Node_Str"" + value + ""String_Node_Str"",e);
      mappedValue=mapr.toMongoObject(value);
    }
  }
 else   if (mf != null && mf.hasAnnotation(Serialized.class))   try {
    mappedValue=Serializer.serialize(value,!mf.getAnnotation(Serialized.class).disableCompression());
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
 else   if (value instanceof DBObject)   mappedValue=value;
 else   mappedValue=mapr.toMongoObject(value);
  Class<?> type=(mappedValue != null) ? mappedValue.getClass() : null;
  if (type != null && (op == FilterOperator.IN || op == FilterOperator.NOT_IN) && !type.isArray() && !Iterable.class.isAssignableFrom(type)) {
    mappedValue=Collections.singletonList(mappedValue);
  }
  if (op == FilterOperator.ELEMENT_MATCH && mappedValue instanceof DBObject)   ((DBObject)mappedValue).removeField(Mapper.ID_KEY);
  this.field=field;
  this.operator=op;
  this.value=mappedValue;
}",0.9683038954754416
104786,"public T endsWithIgnoreCase(String suffix){
  return this.endsWithIgnoreCase(suffix,this.query.isValidatingTypes());
}","public T endsWithIgnoreCase(String suffix){
  Assert.parametersNotNull(""String_Node_Str"",suffix);
  return addCrit(FilterOperator.EQUAL,Pattern.compile(suffix + ""String_Node_Str"",Pattern.CASE_INSENSITIVE));
}",0.3803680981595092
104787,"public T hasAllOf(Iterable<?> vals){
  return this.hasAllOf(vals,this.query.isValidatingTypes());
}","public T hasAllOf(Iterable<?> vals){
  Assert.parametersNotNull(""String_Node_Str"",vals);
  Assert.parameterNotEmpty(vals,""String_Node_Str"");
  return addCrit(FilterOperator.ALL,vals);
}",0.4084507042253521
104788,"public T hasThisOne(Object val){
  return this.hasThisOne(val,this.query.isValidatingTypes());
}","public T hasThisOne(Object val){
  return addCrit(FilterOperator.EQUAL,val);
}",0.5977011494252874
104789,"public T in(Iterable<?> vals){
  return this.hasAnyOf(vals,this.query.isValidatingTypes());
}","public T in(Iterable<?> vals){
  return this.hasAnyOf(vals);
}",0.8
104790,"public T hasThisElement(Object val){
  return this.hasThisElement(val,this.query.isValidatingTypes());
}","public T hasThisElement(Object val){
  Assert.parametersNotNull(""String_Node_Str"",val);
  return addCrit(FilterOperator.ELEMENT_MATCH,val);
}",0.4571428571428571
104791,"public T lessThanOrEq(Object val){
  return this.lessThanOrEq(val,this.query.isValidatingTypes());
}","public T lessThanOrEq(Object val){
  Assert.parametersNotNull(""String_Node_Str"",val);
  return addCrit(FilterOperator.LESS_THAN_OR_EQUAL,val);
}",0.4672131147540984
104792,"public T notEqual(Object val){
  return this.notEqual(val,this.query.isValidatingTypes());
}","public T notEqual(Object val){
  return addCrit(FilterOperator.NOT_EQUAL,val);
}",0.5930232558139535
104793,"public T containsIgnoreCase(String string){
  return this.containsIgnoreCase(string,this.query.isValidatingTypes());
}","public T containsIgnoreCase(String string){
  Assert.parametersNotNull(""String_Node_Str"",string);
  return addCrit(FilterOperator.EQUAL,Pattern.compile(string,Pattern.CASE_INSENSITIVE));
}",0.5098039215686274
104794,"public T greaterThanOrEq(Object val){
  return this.greaterThanOrEq(val,this.query.isValidatingTypes());
}","public T greaterThanOrEq(Object val){
  Assert.parametersNotNull(""String_Node_Str"",val);
  return addCrit(FilterOperator.GREATER_THAN_OR_EQUAL,val);
}",0.484375
104795,"public T equal(Object val){
  return this.equal(val,this.query.isValidatingTypes());
}","public T equal(Object val){
  return addCrit(FilterOperator.EQUAL,val);
}",0.5911949685534591
104796,"public T sizeEq(int val){
  return this.sizeEq(val,this.query.isValidatingTypes());
}","public T sizeEq(int val){
  Assert.parametersNotNull(""String_Node_Str"",val);
  return addCrit(FilterOperator.SIZE,val);
}",0.4466019417475728
104797,"public T contains(String string){
  return this.contains(string,this.query.isValidatingTypes());
}","public T contains(String string){
  Assert.parametersNotNull(""String_Node_Str"",string);
  return addCrit(FilterOperator.EQUAL,Pattern.compile(string));
}",0.4860557768924303
104798,"public T hasAnyOf(Iterable<?> vals){
  return this.hasAnyOf(vals,this.query.isValidatingTypes());
}","public T hasAnyOf(Iterable<?> vals){
  Assert.parametersNotNull(""String_Node_Str"",vals);
  Assert.parameterNotEmpty(vals,""String_Node_Str"");
  return addCrit(FilterOperator.IN,vals);
}",0.4028268551236749
104799,"public T doesNotExist(){
  this.target.add(new FieldCriteria(this.query,this.field,FilterOperator.EXISTS,false,this.validateName,this.query.isValidatingTypes()));
  return this.target;
}","public T doesNotExist(){
  return addCrit(FilterOperator.EXISTS,false);
}",0.5328185328185329
104800,"public T lessThan(Object val){
  return this.lessThan(val,this.query.isValidatingTypes());
}","public T lessThan(Object val){
  Assert.parametersNotNull(""String_Node_Str"",val);
  return addCrit(FilterOperator.LESS_THAN,val);
}",0.4573991031390134
104801,"public T endsWith(String suffix){
  return this.endsWith(suffix,this.query.isValidatingTypes());
}","public T endsWith(String suffix){
  Assert.parametersNotNull(""String_Node_Str"",suffix);
  return addCrit(FilterOperator.EQUAL,Pattern.compile(suffix + ""String_Node_Str""));
}",0.4723247232472324
104802,"public T exists(){
  this.target.add(new FieldCriteria(this.query,this.field,FilterOperator.EXISTS,true,this.validateName,this.query.isValidatingTypes()));
  return this.target;
}","public T exists(){
  return addCrit(FilterOperator.EXISTS,true);
}",0.5061224489795918
104803,"public T notIn(Iterable<?> vals){
  return this.hasNoneOf(vals,this.query.isValidatingTypes());
}","public T notIn(Iterable<?> vals){
  return this.hasNoneOf(vals);
}",0.8098159509202454
104804,"public T near(int x,int y){
  return this.near(x,y,this.query.isValidatingTypes());
}","public T near(double x1,double y1,double x2,double y2){
  throw new RuntimeException();
}",0.425287356321839
104805,"public T hasNoneOf(Iterable<?> vals){
  return this.hasNoneOf(vals,this.query.isValidatingTypes());
}","public T hasNoneOf(Iterable<?> vals){
  Assert.parametersNotNull(""String_Node_Str"",vals);
  Assert.parameterNotEmpty(vals,""String_Node_Str"");
  return addCrit(FilterOperator.NOT_IN,vals);
}",0.4137931034482758
104806,"public T startsWithIgnoreCase(String prefix){
  return this.startsWithIgnoreCase(prefix,this.query.isValidatingTypes());
}","public T startsWithIgnoreCase(String prefix){
  Assert.parametersNotNull(""String_Node_Str"",prefix);
  return addCrit(FilterOperator.EQUAL,Pattern.compile(""String_Node_Str"" + prefix,Pattern.CASE_INSENSITIVE));
}",0.3795180722891566
104807,"public T startsWith(String prefix){
  return this.startsWith(prefix,this.query.isValidatingTypes());
}","public T startsWith(String prefix){
  Assert.parametersNotNull(""String_Node_Str"",prefix);
  return addCrit(FilterOperator.EQUAL,Pattern.compile(""String_Node_Str"" + prefix));
}",0.4404332129963899
104808,"public T greaterThan(Object val){
  return this.greaterThan(val,this.query.isValidatingTypes());
}","public T greaterThan(Object val){
  Assert.parametersNotNull(""String_Node_Str"",val);
  return addCrit(FilterOperator.GREATER_THAN,val);
}",0.4765957446808511
104809,"/** 
 * Discovers interesting (that we care about) things about the class. 
 */
protected void discover(){
  for (  Class<? extends Annotation> c : interestingAnnotations) {
    addAnnotation(c);
  }
  List<Class<?>> lifecycleClasses=new ArrayList<Class<?>>();
  lifecycleClasses.add(clazz);
  EntityListeners entityLisAnn=(EntityListeners)foundAnnotations.get(EntityListeners.class);
  if (entityLisAnn != null && entityLisAnn.value() != null && entityLisAnn.value().length != 0)   for (  Class<?> c : entityLisAnn.value())   lifecycleClasses.add(c);
  for (  Class<?> cls : lifecycleClasses) {
    for (    Method m : ReflectionUtils.getDeclaredAndInheritedMethods(cls)) {
      for (      Class<? extends Annotation> c : lifecycleAnnotations) {
        if (m.isAnnotationPresent(c)) {
          addLifecycleEventMethod(c,m,cls.equals(clazz) ? null : cls);
        }
      }
    }
  }
  embeddedAn=(Embedded)foundAnnotations.get(Embedded.class);
  entityAn=(Entity)foundAnnotations.get(Entity.class);
  collName=(entityAn == null || entityAn.value().equals(Mapper.IGNORED_FIELDNAME)) ? clazz.getSimpleName() : entityAn.value();
  for (  Field field : ReflectionUtils.getDeclaredAndInheritedFields(clazz,true)) {
    field.setAccessible(true);
    int fieldMods=field.getModifiers();
    if (field.isAnnotationPresent(Transient.class))     continue;
 else     if (field.isSynthetic() && (fieldMods & Modifier.TRANSIENT) == Modifier.TRANSIENT)     continue;
 else     if (mapr.getOptions().actLikeSerializer && ((fieldMods & Modifier.TRANSIENT) == Modifier.TRANSIENT))     continue;
 else     if (mapr.getOptions().ignoreFinals && ((fieldMods & Modifier.FINAL) == Modifier.FINAL))     continue;
 else     if (field.isAnnotationPresent(Id.class)) {
      idField=field;
      MappedField mf=new MappedField(idField);
      persistenceFields.add(mf);
    }
 else     if (field.isAnnotationPresent(Property.class) || field.isAnnotationPresent(Reference.class) || field.isAnnotationPresent(Embedded.class)|| field.isAnnotationPresent(Serialized.class)|| isSupportedType(field.getType())|| ReflectionUtils.implementsInterface(field.getType(),Serializable.class)) {
      persistenceFields.add(new MappedField(field));
    }
 else {
      if (mapr.getOptions().defaultMapper != null)       persistenceFields.add(new MappedField(field));
 else       log.warning(""String_Node_Str"" + clazz.getName() + ""String_Node_Str""+ field.getName()+ ""String_Node_Str""+ field.getType().getName()+ ""String_Node_Str"");
    }
  }
}","/** 
 * Discovers interesting (that we care about) things about the class. 
 */
protected void discover(){
  for (  Class<? extends Annotation> c : interestingAnnotations) {
    addAnnotation(c);
  }
  List<Class<?>> lifecycleClasses=new ArrayList<Class<?>>();
  lifecycleClasses.add(clazz);
  EntityListeners entityLisAnn=(EntityListeners)foundAnnotations.get(EntityListeners.class);
  if (entityLisAnn != null && entityLisAnn.value() != null && entityLisAnn.value().length != 0)   for (  Class<?> c : entityLisAnn.value())   lifecycleClasses.add(c);
  for (  Class<?> cls : lifecycleClasses) {
    for (    Method m : ReflectionUtils.getDeclaredAndInheritedMethods(cls)) {
      for (      Class<? extends Annotation> c : lifecycleAnnotations) {
        if (m.isAnnotationPresent(c)) {
          addLifecycleEventMethod(c,m,cls.equals(clazz) ? null : cls);
        }
      }
    }
  }
  embeddedAn=(Embedded)foundAnnotations.get(Embedded.class);
  entityAn=(Entity)foundAnnotations.get(Entity.class);
  collName=(entityAn == null || entityAn.value().equals(Mapper.IGNORED_FIELDNAME)) ? clazz.getSimpleName() : entityAn.value();
  for (  Field field : ReflectionUtils.getDeclaredAndInheritedFields(clazz,true)) {
    field.setAccessible(true);
    int fieldMods=field.getModifiers();
    if (field.isAnnotationPresent(Transient.class))     continue;
 else     if (field.isSynthetic() && (fieldMods & Modifier.TRANSIENT) == Modifier.TRANSIENT)     continue;
 else     if (mapr.getOptions().actLikeSerializer && ((fieldMods & Modifier.TRANSIENT) == Modifier.TRANSIENT))     continue;
 else     if (mapr.getOptions().ignoreFinals && ((fieldMods & Modifier.FINAL) == Modifier.FINAL))     continue;
 else     if (field.isAnnotationPresent(Id.class)) {
      idField=field;
      MappedField mf=new MappedField(idField,clazz);
      persistenceFields.add(mf);
    }
 else     if (field.isAnnotationPresent(Property.class) || field.isAnnotationPresent(Reference.class) || field.isAnnotationPresent(Embedded.class)|| field.isAnnotationPresent(Serialized.class)|| isSupportedType(field.getType())|| ReflectionUtils.implementsInterface(field.getType(),Serializable.class)) {
      persistenceFields.add(new MappedField(field,clazz));
    }
 else {
      if (mapr.getOptions().defaultMapper != null)       persistenceFields.add(new MappedField(field,clazz));
 else       log.warning(""String_Node_Str"" + clazz.getName() + ""String_Node_Str""+ field.getName()+ ""String_Node_Str""+ field.getType().getName()+ ""String_Node_Str"");
    }
  }
}",0.9964214711729622
104810,"/** 
 * Discovers interesting (that we care about) things about the field. 
 */
protected void discover(){
  for (  Class<? extends Annotation> clazz : interestingAnnotations)   addAnnotation(clazz);
  Class ctorType=null;
  for (  Annotation an : foundAnnotations.values()) {
    try {
      Method m=an.getClass().getMethod(""String_Node_Str"");
      m.setAccessible(true);
      Object o=m.invoke(an);
      if (o != null && !(o.equals(Object.class))) {
        ctorType=(Class)o;
        break;
      }
    }
 catch (    NoSuchMethodException e) {
    }
catch (    IllegalArgumentException e) {
      log.warning(""String_Node_Str"",e);
    }
catch (    Exception e) {
      log.warning(""String_Node_Str"",e);
    }
  }
  if (ctorType != null)   try {
    ctor=ctorType.getDeclaredConstructor();
    ctor.setAccessible(true);
  }
 catch (  NoSuchMethodException e) {
    throw new MappingException(""String_Node_Str"" + field.getType().getName(),e);
  }
 else {
    try {
      ctor=field.getType().getDeclaredConstructor();
      ctor.setAccessible(true);
    }
 catch (    NoSuchMethodException e) {
    }
catch (    SecurityException e) {
    }
  }
  this.name=getMappedFieldName();
  Class type=field.getType();
  if (type.isArray() || Collection.class.isAssignableFrom(type) || Map.class.isAssignableFrom(type)) {
    isSingleValue=false;
    isMap=Map.class.isAssignableFrom(type);
    isSet=Set.class.isAssignableFrom(type);
    isCollection=Collection.class.isAssignableFrom(type);
    isArray=type.isArray();
    if (!isMap && !isSet && !isCollection&& !isArray)     throw new MappingException(""String_Node_Str"" + type);
    subType=(type.isArray()) ? type.getComponentType() : ReflectionUtils.getParameterizedType(field,(isMap) ? 1 : 0);
    if (isMap)     mapKeyType=ReflectionUtils.getParameterizedType(field,0);
  }
  isMongoType=ReflectionUtils.isPropertyType(type);
  if (!isMongoType && subType != null)   isMongoType=ReflectionUtils.isPropertyType(subType);
  if (!isMongoType && !isSingleValue && (subType == null || subType.equals(Object.class))) {
    log.warning(""String_Node_Str"" + getFullName() + ""String_Node_Str""+ subType);
    isMongoType=true;
  }
}","/** 
 * Discovers interesting (that we care about) things about the field. 
 */
protected void discover(){
  for (  Class<? extends Annotation> clazz : interestingAnnotations)   addAnnotation(clazz);
  Class ctorType=null;
  for (  Annotation an : foundAnnotations.values()) {
    try {
      Method m=an.getClass().getMethod(""String_Node_Str"");
      m.setAccessible(true);
      Object o=m.invoke(an);
      if (o != null && !(o.equals(Object.class))) {
        ctorType=(Class)o;
        break;
      }
    }
 catch (    NoSuchMethodException e) {
    }
catch (    IllegalArgumentException e) {
      log.warning(""String_Node_Str"",e);
    }
catch (    Exception e) {
      log.warning(""String_Node_Str"",e);
    }
  }
  if (ctorType != null)   try {
    ctor=ctorType.getDeclaredConstructor();
    ctor.setAccessible(true);
  }
 catch (  NoSuchMethodException e) {
    throw new MappingException(""String_Node_Str"" + field.getType().getName(),e);
  }
 else {
    try {
      ctor=field.getType().getDeclaredConstructor();
      ctor.setAccessible(true);
    }
 catch (    NoSuchMethodException e) {
    }
catch (    SecurityException e) {
    }
  }
  this.name=getMappedFieldName();
  Class type=field.getType();
  Type gType=field.getGenericType();
  TypeVariable<GenericDeclaration> tv=null;
  ParameterizedType pt=null;
  if (gType instanceof TypeVariable)   tv=(TypeVariable<GenericDeclaration>)gType;
 else   if (gType instanceof ParameterizedType)   pt=(ParameterizedType)gType;
  if (tv != null) {
    type=ReflectionUtils.getTypeArgument(persistedClass,tv);
  }
 else   if (pt != null) {
    log.debug(""String_Node_Str"" + pt);
  }
  if (Object.class.equals(type) && (tv != null || pt != null))   throw new MappingException(""String_Node_Str"" + field.getName() + ""String_Node_Str""+ field.getDeclaringClass());
  if (type.isArray() || Collection.class.isAssignableFrom(type) || Map.class.isAssignableFrom(type)) {
    isSingleValue=false;
    isMap=Map.class.isAssignableFrom(type);
    isSet=Set.class.isAssignableFrom(type);
    isCollection=Collection.class.isAssignableFrom(type);
    isArray=type.isArray();
    if (!isMap && !isSet && !isCollection&& !isArray)     throw new MappingException(""String_Node_Str"" + type);
    subType=(type.isArray()) ? type.getComponentType() : ReflectionUtils.getParameterizedType(field,(isMap) ? 1 : 0);
    if (isMap)     mapKeyType=ReflectionUtils.getParameterizedType(field,0);
  }
  isMongoType=ReflectionUtils.isPropertyType(type);
  if (!isMongoType && subType != null)   isMongoType=ReflectionUtils.isPropertyType(subType);
  if (!isMongoType && !isSingleValue && (subType == null || subType.equals(Object.class))) {
    log.warning(""String_Node_Str"" + getFullName() + ""String_Node_Str""+ subType);
    isMongoType=true;
  }
}",0.5344374873762876
104811,"@Override public Object decode(Class targetClass,Object fromDBObject,MappedField mf) throws MappingException {
  if (mf == null || fromDBObject == null)   return fromDBObject;
  Class subtypeDest=mf.getSubClass();
  Collection vals=null;
  if (fromDBObject.getClass().isArray()) {
    vals=new ArrayList();
    for (    Object o : (Object[])fromDBObject)     vals.add(chain.decode((subtypeDest != null) ? subtypeDest : o.getClass(),o));
  }
 else   if (fromDBObject instanceof Iterable) {
    vals=createNewCollection(mf);
    for (    Object o : (Iterable)fromDBObject)     vals.add(chain.decode((subtypeDest != null) ? subtypeDest : o.getClass(),o));
  }
  if (mf.getType().isArray()) {
    return ReflectionUtils.convertToArray(subtypeDest,(ArrayList)vals);
  }
 else   return vals;
}","@Override public Object decode(Class targetClass,Object fromDBObject,MappedField mf) throws MappingException {
  if (mf == null || fromDBObject == null)   return fromDBObject;
  Class subtypeDest=mf.getSubClass();
  Collection vals=createNewCollection(mf);
  if (fromDBObject.getClass().isArray()) {
    for (    Object o : (Object[])fromDBObject)     vals.add(chain.decode((subtypeDest != null) ? subtypeDest : o.getClass(),o));
  }
 else   if (fromDBObject instanceof Iterable) {
    for (    Object o : (Iterable)fromDBObject)     vals.add(chain.decode((subtypeDest != null) ? subtypeDest : o.getClass(),o));
  }
 else {
    vals.add(chain.decode((subtypeDest != null) ? subtypeDest : fromDBObject.getClass(),fromDBObject));
  }
  if (mf.getType().isArray()) {
    return ReflectionUtils.convertToArray(subtypeDest,(ArrayList)vals);
  }
 else   return vals;
}",0.8684050939963615
104812,"public Object createInstance(MappedField mf,DBObject dbObj);","public Object createInstance(Mapper mapr,MappedField mf,DBObject dbObj);",0.9090909090909092
104813,"public Object createInstance(MappedField mf,DBObject dbObj){
  return createInstance(mf.getConcreteType(),dbObj);
}","public Object createInstance(Mapper mapr,MappedField mf,DBObject dbObj){
  Class c=getClass(dbObj);
  if (c == null)   c=mf.isSingleValue ? mf.getConcreteType() : mf.getSubClass();
  try {
    return createInstance(c,dbObj);
  }
 catch (  RuntimeException e) {
    ConstructorArgs argAnn=mf.getAnnotation(ConstructorArgs.class);
    if (argAnn == null)     throw e;
    Object[] args=new Object[argAnn.value().length];
    Class[] argTypes=new Class[argAnn.value().length];
    for (int i=0; i < argAnn.value().length; i++) {
      Object val=dbObj.get(argAnn.value()[i]);
      args[i]=val;
      argTypes[i]=val.getClass();
    }
    try {
      Constructor ctor=c.getDeclaredConstructor(argTypes);
      ctor.setAccessible(true);
      return ctor.newInstance(args);
    }
 catch (    Exception ex) {
      throw new RuntimeException(ex);
    }
  }
}",0.1921487603305785
104814,"public void fromDBObject(final DBObject dbObject,final MappedField mf,final Object entity,EntityCache cache,Mapper mapr){
  try {
    if (mf.isMap()) {
      readMap(dbObject,mf,entity,cache,mapr);
    }
 else     if (mf.isMultipleValues()) {
      readCollection(dbObject,mf,entity,cache,mapr);
    }
 else {
      Object dbVal=mf.getDbObjectValue(dbObject);
      if (dbVal != null) {
        boolean isDBObject=dbVal instanceof DBObject;
        if (isDBObject && (mapr.converters.hasDbObjectConverter(mf) || mapr.converters.hasDbObjectConverter(mf.getType()))) {
          mapr.converters.fromDBObject(((DBObject)dbVal),mf,entity);
          return;
        }
 else {
          Object refObj=null;
          if (mapr.converters.hasSimpleValueConverter(mf) || mapr.converters.hasSimpleValueConverter(mf.getType()))           refObj=mapr.converters.decode(mf.getType(),dbVal,mf);
 else {
            refObj=mapr.getOptions().objectFactory.createInstance(mf,((DBObject)dbVal));
            refObj=mapr.fromDb(((DBObject)dbVal),refObj,cache);
          }
          if (refObj != null) {
            mf.setFieldValue(entity,refObj);
          }
        }
      }
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","public void fromDBObject(final DBObject dbObject,final MappedField mf,final Object entity,EntityCache cache,Mapper mapr){
  try {
    if (mf.isMap()) {
      readMap(dbObject,mf,entity,cache,mapr);
    }
 else     if (mf.isMultipleValues()) {
      readCollection(dbObject,mf,entity,cache,mapr);
    }
 else {
      Object dbVal=mf.getDbObjectValue(dbObject);
      if (dbVal != null) {
        boolean isDBObject=dbVal instanceof DBObject;
        if (isDBObject && (mapr.converters.hasDbObjectConverter(mf) || mapr.converters.hasDbObjectConverter(mf.getType()))) {
          mapr.converters.fromDBObject(((DBObject)dbVal),mf,entity);
          return;
        }
 else {
          Object refObj=null;
          if (mapr.converters.hasSimpleValueConverter(mf) || mapr.converters.hasSimpleValueConverter(mf.getType()))           refObj=mapr.converters.decode(mf.getType(),dbVal,mf);
 else {
            refObj=mapr.getOptions().objectFactory.createInstance(mapr,mf,((DBObject)dbVal));
            refObj=mapr.fromDb(((DBObject)dbVal),refObj,cache);
          }
          if (refObj != null) {
            mf.setFieldValue(entity,refObj);
          }
        }
      }
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}",0.9979830576845502
104815,"private Object readMapOrCollectionOrEntity(DBObject dbObj,MappedField mf,EntityCache cache,Mapper mapr){
  if (Map.class.isAssignableFrom(mf.getSubClass()) || Iterable.class.isAssignableFrom(mf.getSubClass())) {
    MapOrCollectionMF mocMF=new MapOrCollectionMF((ParameterizedType)mf.getSubType());
    mapr.fromDb(dbObj,mocMF,cache);
    return mocMF.getValue();
  }
 else {
    Object newEntity=mapr.getOptions().objectFactory.createInstance(mf.getSubClass(),dbObj);
    return mapr.fromDb(dbObj,newEntity,cache);
  }
}","private Object readMapOrCollectionOrEntity(DBObject dbObj,MappedField mf,EntityCache cache,Mapper mapr){
  if (Map.class.isAssignableFrom(mf.getSubClass()) || Iterable.class.isAssignableFrom(mf.getSubClass())) {
    MapOrCollectionMF mocMF=new MapOrCollectionMF((ParameterizedType)mf.getSubType());
    mapr.fromDb(dbObj,mocMF,cache);
    return mocMF.getValue();
  }
 else {
    Object newEntity=mapr.getOptions().objectFactory.createInstance(mapr,mf,dbObj);
    return mapr.fromDb(dbObj,newEntity,cache);
  }
}",0.9796708615682478
104816,"/** 
 * Discovers interesting (that we care about) things about the field. 
 */
protected void discover(){
  for (  Class<? extends Annotation> clazz : interestingAnnotations)   addAnnotation(clazz);
  Class ctorType=null;
  for (  Annotation an : foundAnnotations.values()) {
    try {
      Method m=an.getClass().getMethod(""String_Node_Str"");
      m.setAccessible(true);
      Object o=m.invoke(an);
      if (o != null && !(o.equals(Object.class))) {
        ctorType=(Class)o;
        break;
      }
    }
 catch (    NoSuchMethodException e) {
    }
catch (    IllegalArgumentException e) {
      log.warning(""String_Node_Str"",e);
    }
catch (    Exception e) {
      log.warning(""String_Node_Str"",e);
    }
  }
  if (ctorType != null)   try {
    ctor=ctorType.getDeclaredConstructor();
    ctor.setAccessible(true);
  }
 catch (  NoSuchMethodException e) {
    throw new MappingException(""String_Node_Str"" + field.getType().getName(),e);
  }
 else {
    try {
      ctor=field.getType().getDeclaredConstructor();
      ctor.setAccessible(true);
    }
 catch (    NoSuchMethodException e) {
    }
catch (    SecurityException e) {
    }
  }
  this.name=getMappedFieldName();
  Class type=field.getType();
  Type gType=field.getGenericType();
  TypeVariable<GenericDeclaration> tv=null;
  ParameterizedType pt=null;
  if (gType instanceof TypeVariable)   tv=(TypeVariable<GenericDeclaration>)gType;
 else   if (gType instanceof ParameterizedType)   pt=(ParameterizedType)gType;
  if (tv != null) {
    type=ReflectionUtils.getTypeArgument(persistedClass,tv);
  }
 else   if (pt != null) {
    log.debug(""String_Node_Str"" + pt);
  }
  if (Object.class.equals(type) && (tv != null || pt != null))   throw new MappingException(""String_Node_Str"" + field.getName() + ""String_Node_Str""+ field.getDeclaringClass());
  if (type.isArray() || Collection.class.isAssignableFrom(type) || Map.class.isAssignableFrom(type)) {
    isSingleValue=false;
    isMap=Map.class.isAssignableFrom(type);
    isSet=Set.class.isAssignableFrom(type);
    isCollection=Collection.class.isAssignableFrom(type);
    isArray=type.isArray();
    if (!isMap && !isSet && !isCollection&& !isArray)     throw new MappingException(""String_Node_Str"" + type);
    subType=(type.isArray()) ? type.getComponentType() : ReflectionUtils.getParameterizedType(field,(isMap) ? 1 : 0);
    if (isMap)     mapKeyType=ReflectionUtils.getParameterizedType(field,0);
  }
  isMongoType=ReflectionUtils.isPropertyType(type);
  if (!isMongoType && subType != null)   isMongoType=ReflectionUtils.isPropertyType(subType);
  if (!isMongoType && !isSingleValue && (subType == null || subType.equals(Object.class))) {
    log.warning(""String_Node_Str"" + getFullName() + ""String_Node_Str""+ subType);
    isMongoType=true;
  }
}","/** 
 * Discovers interesting (that we care about) things about the field. 
 */
protected void discover(){
  for (  Class<? extends Annotation> clazz : interestingAnnotations)   addAnnotation(clazz);
  Class ctorType=null;
  for (  Annotation an : foundAnnotations.values()) {
    try {
      Method m=an.getClass().getMethod(""String_Node_Str"");
      m.setAccessible(true);
      Object o=m.invoke(an);
      if (o != null && !(o.equals(Object.class))) {
        ctorType=(Class)o;
        break;
      }
    }
 catch (    NoSuchMethodException e) {
    }
catch (    IllegalArgumentException e) {
      log.warning(""String_Node_Str"",e);
    }
catch (    Exception e) {
      log.warning(""String_Node_Str"",e);
    }
  }
  if (ctorType != null)   try {
    ctor=ctorType.getDeclaredConstructor();
    ctor.setAccessible(true);
  }
 catch (  NoSuchMethodException e) {
    if (!hasAnnotation(ConstructorArgs.class))     throw new MappingException(""String_Node_Str"" + field.getType().getName(),e);
  }
 else {
    try {
      ctor=field.getType().getDeclaredConstructor();
      ctor.setAccessible(true);
    }
 catch (    NoSuchMethodException e) {
    }
catch (    SecurityException e) {
    }
  }
  this.name=getMappedFieldName();
  Class type=field.getType();
  Type gType=field.getGenericType();
  TypeVariable<GenericDeclaration> tv=null;
  ParameterizedType pt=null;
  if (gType instanceof TypeVariable)   tv=(TypeVariable<GenericDeclaration>)gType;
 else   if (gType instanceof ParameterizedType)   pt=(ParameterizedType)gType;
  if (tv != null) {
    type=ReflectionUtils.getTypeArgument(persistedClass,tv);
  }
 else   if (pt != null) {
    log.debug(""String_Node_Str"" + pt);
  }
  if (Object.class.equals(type) && (tv != null || pt != null))   throw new MappingException(""String_Node_Str"" + field.getName() + ""String_Node_Str""+ field.getDeclaringClass());
  if (type.isArray() || Collection.class.isAssignableFrom(type) || Map.class.isAssignableFrom(type)) {
    isSingleValue=false;
    isMap=Map.class.isAssignableFrom(type);
    isSet=Set.class.isAssignableFrom(type);
    isCollection=Collection.class.isAssignableFrom(type);
    isArray=type.isArray();
    if (!isMap && !isSet && !isCollection&& !isArray)     throw new MappingException(""String_Node_Str"" + type);
    subType=(type.isArray()) ? type.getComponentType() : ReflectionUtils.getParameterizedType(field,(isMap) ? 1 : 0);
    if (isMap)     mapKeyType=ReflectionUtils.getParameterizedType(field,0);
  }
  isMongoType=ReflectionUtils.isPropertyType(type);
  if (!isMongoType && subType != null)   isMongoType=ReflectionUtils.isPropertyType(subType);
  if (!isMongoType && !isSingleValue && (subType == null || subType.equals(Object.class))) {
    log.warning(""String_Node_Str"" + getFullName() + ""String_Node_Str""+ subType);
    isMongoType=true;
  }
}",0.991608641314051
104817,"private void readMap(final DBObject dbObject,final MappedField mf,final Object entity,final Reference refAnn,EntityCache cache,Mapper mapr){
  Class referenceObjClass=mf.getSubClass();
  Map map=mapr.getOptions().objectFactory.createMap(mf);
  BasicDBObject dbVal=(BasicDBObject)mf.getDbObjectValue(dbObject);
  if (dbVal != null) {
    if (refAnn.lazy() && LazyFeatureDependencies.assertDependencyFullFilled()) {
      map=mapr.proxyFactory.createMapProxy(map,referenceObjClass,refAnn.ignoreMissing(),mapr.datastoreProvider);
    }
    for (    Map.Entry<String,?> entry : dbVal.entrySet()) {
      DBRef dbRef=(DBRef)entry.getValue();
      if (refAnn.lazy() && LazyFeatureDependencies.assertDependencyFullFilled()) {
        ProxiedEntityReferenceMap proxiedMap=(ProxiedEntityReferenceMap)map;
        proxiedMap.__put(entry.getKey(),mapr.refToKey(dbRef));
      }
 else {
        Object resolvedObject=resolveObject(dbRef,referenceObjClass,refAnn.ignoreMissing(),mf,cache,mapr);
        map.put(entry.getKey(),resolvedObject);
      }
    }
  }
  mf.setFieldValue(entity,map);
}","private void readMap(final DBObject dbObject,final MappedField mf,final Object entity,final Reference refAnn,EntityCache cache,Mapper mapr){
  Class referenceObjClass=mf.getSubClass();
  Map map=mapr.getOptions().objectFactory.createMap(mf);
  BasicDBObject dbVal=(BasicDBObject)mf.getDbObjectValue(dbObject);
  if (dbVal != null) {
    if (refAnn.lazy() && LazyFeatureDependencies.assertDependencyFullFilled()) {
      map=mapr.proxyFactory.createMapProxy(map,referenceObjClass,refAnn.ignoreMissing(),mapr.datastoreProvider);
    }
    for (    Map.Entry<String,?> entry : dbVal.entrySet()) {
      DBRef dbRef=(DBRef)entry.getValue();
      if (refAnn.lazy() && LazyFeatureDependencies.assertDependencyFullFilled()) {
        ProxiedEntityReferenceMap proxiedMap=(ProxiedEntityReferenceMap)map;
        proxiedMap.__put(entry.getKey(),mapr.refToKey(dbRef));
      }
 else {
        Object resolvedObject=resolveObject(dbRef,mf,cache,mapr);
        map.put(entry.getKey(),resolvedObject);
      }
    }
  }
  mf.setFieldValue(entity,map);
}",0.886481394253415
104818,"private void readCollection(final DBObject dbObject,final MappedField mf,final Object entity,Reference refAnn,EntityCache cache,Mapper mapr){
  Class referenceObjClass=mf.getSubClass();
  Collection references=mf.isSet() ? mapr.getOptions().objectFactory.createSet(mf) : mapr.getOptions().objectFactory.createList(mf);
  if (refAnn.lazy() && LazyFeatureDependencies.assertDependencyFullFilled()) {
    Object dbVal=mf.getDbObjectValue(dbObject);
    if (dbVal != null) {
      references=mapr.proxyFactory.createListProxy(references,referenceObjClass,refAnn.ignoreMissing(),mapr.datastoreProvider);
      ProxiedEntityReferenceList referencesAsProxy=(ProxiedEntityReferenceList)references;
      if (dbVal instanceof List) {
        List<DBRef> refList=(List)dbVal;
        DatastoreImpl dsi=(DatastoreImpl)mapr.datastoreProvider.get();
        List<Key<Object>> keys=dsi.getKeysByRefs(refList);
        if (keys.size() != refList.size()) {
          String msg=""String_Node_Str"" + mf.getFullName() + ""String_Node_Str""+ refList+ ""String_Node_Str""+ keys;
          if (!refAnn.ignoreMissing())           throw new MappingException(msg);
 else           log.warning(msg);
        }
        referencesAsProxy.__addAll(keys);
      }
 else {
        DBRef dbRef=(DBRef)dbVal;
        if (!exists(mf.getSubClass(),dbRef,cache,mapr)) {
          String msg=""String_Node_Str"" + dbRef.toString() + ""String_Node_Str""+ mf.getFullName();
          if (!refAnn.ignoreMissing())           throw new MappingException(msg);
 else           log.warning(msg);
        }
 else {
          referencesAsProxy.__add(mapr.refToKey(dbRef));
        }
      }
    }
  }
 else {
    Object dbVal=mf.getDbObjectValue(dbObject);
    if (dbVal != null) {
      if (dbVal instanceof List) {
        List refList=(List)dbVal;
        for (        Object dbRefObj : refList) {
          DBRef dbRef=(DBRef)dbRefObj;
          Key k=mapr.refToKey(dbRef);
          Object cachedEntity=cache.getEntity(k);
          if (cachedEntity != null) {
            references.add(cachedEntity);
          }
 else {
            BasicDBObject refDbObject=(BasicDBObject)dbRef.fetch();
            if (refDbObject == null) {
              if (!refAnn.ignoreMissing()) {
                throw new MappingException(""String_Node_Str"" + dbRef.toString() + ""String_Node_Str""+ mf.getFullName());
              }
            }
 else {
              Object refObj=mapr.getOptions().objectFactory.createInstance(referenceObjClass,refDbObject);
              refObj=mapr.fromDb(refDbObject,refObj,cache);
              references.add(refObj);
              cache.putEntity(k,refObj);
            }
          }
        }
      }
 else {
        DBRef dbRef=(DBRef)dbVal;
        Key k=mapr.refToKey(dbRef);
        Object cachedEntity=cache.getEntity(k);
        if (cachedEntity != null) {
          references.add(cachedEntity);
        }
 else {
          BasicDBObject refDbObject=(BasicDBObject)dbRef.fetch();
          if (refDbObject == null) {
            if (!refAnn.ignoreMissing()) {
              throw new MappingException(""String_Node_Str"" + dbRef.toString() + ""String_Node_Str""+ mf.getFullName());
            }
          }
 else {
            Object newEntity=mapr.getOptions().objectFactory.createInstance(referenceObjClass,refDbObject);
            newEntity=mapr.fromDb(refDbObject,newEntity,cache);
            references.add(newEntity);
          }
        }
      }
    }
  }
  if (mf.getType().isArray()) {
    mf.setFieldValue(entity,ReflectionUtils.convertToArray(mf.getSubClass(),ReflectionUtils.iterToList(references)));
  }
 else {
    mf.setFieldValue(entity,references);
  }
}","private void readCollection(final DBObject dbObject,final MappedField mf,final Object entity,Reference refAnn,EntityCache cache,Mapper mapr){
  Class referenceObjClass=mf.getSubClass();
  Collection references=mf.isSet() ? mapr.getOptions().objectFactory.createSet(mf) : mapr.getOptions().objectFactory.createList(mf);
  if (refAnn.lazy() && LazyFeatureDependencies.assertDependencyFullFilled()) {
    Object dbVal=mf.getDbObjectValue(dbObject);
    if (dbVal != null) {
      references=mapr.proxyFactory.createListProxy(references,referenceObjClass,refAnn.ignoreMissing(),mapr.datastoreProvider);
      ProxiedEntityReferenceList referencesAsProxy=(ProxiedEntityReferenceList)references;
      if (dbVal instanceof List) {
        List<DBRef> refList=(List)dbVal;
        DatastoreImpl dsi=(DatastoreImpl)mapr.datastoreProvider.get();
        List<Key<Object>> keys=dsi.getKeysByRefs(refList);
        if (keys.size() != refList.size()) {
          String msg=""String_Node_Str"" + mf.getFullName() + ""String_Node_Str""+ refList+ ""String_Node_Str""+ keys;
          if (!refAnn.ignoreMissing())           throw new MappingException(msg);
 else           log.warning(msg);
        }
        referencesAsProxy.__addAll(keys);
      }
 else {
        DBRef dbRef=(DBRef)dbVal;
        if (!exists(mf.getSubClass(),dbRef,cache,mapr)) {
          String msg=""String_Node_Str"" + dbRef.toString() + ""String_Node_Str""+ mf.getFullName();
          if (!refAnn.ignoreMissing())           throw new MappingException(msg);
 else           log.warning(msg);
        }
 else {
          referencesAsProxy.__add(mapr.refToKey(dbRef));
        }
      }
    }
  }
 else {
    Object dbVal=mf.getDbObjectValue(dbObject);
    if (dbVal != null) {
      if (dbVal instanceof List) {
        List refList=(List)dbVal;
        for (        Object dbRefObj : refList) {
          DBRef dbRef=(DBRef)dbRefObj;
          Object ent=resolveObject(dbRef,mf,cache,mapr);
          if (ent != null)           references.add(ent);
        }
      }
 else {
        DBRef dbRef=(DBRef)dbVal;
        Object ent=resolveObject(dbRef,mf,cache,mapr);
        if (ent != null)         references.add(ent);
      }
    }
  }
  if (mf.getType().isArray()) {
    mf.setFieldValue(entity,ReflectionUtils.convertToArray(mf.getSubClass(),ReflectionUtils.iterToList(references)));
  }
 else {
    mf.setFieldValue(entity,references);
  }
}",0.739454094292804
104819,"private void readSingle(final DBObject dbObject,final MappedField mf,final Object entity,Class fieldType,Reference refAnn,EntityCache cache,Mapper mapr){
  Class referenceObjClass=fieldType;
  DBRef dbRef=(DBRef)mf.getDbObjectValue(dbObject);
  if (dbRef != null) {
    Object resolvedObject=null;
    if (refAnn.lazy() && LazyFeatureDependencies.assertDependencyFullFilled()) {
      if (exists(referenceObjClass,dbRef,cache,mapr)) {
        resolvedObject=createOrReuseProxy(referenceObjClass,dbRef,cache,mapr);
      }
 else {
        if (!refAnn.ignoreMissing()) {
          throw new MappingException(""String_Node_Str"" + dbRef.toString() + ""String_Node_Str""+ mf.getFullName());
        }
      }
    }
 else {
      resolvedObject=resolveObject(dbRef,referenceObjClass,refAnn.ignoreMissing(),mf,cache,mapr);
    }
    mf.setFieldValue(entity,resolvedObject);
  }
}","private void readSingle(final DBObject dbObject,final MappedField mf,final Object entity,Class fieldType,Reference refAnn,EntityCache cache,Mapper mapr){
  Class referenceObjClass=fieldType;
  DBRef dbRef=(DBRef)mf.getDbObjectValue(dbObject);
  if (dbRef != null) {
    Object resolvedObject=null;
    if (refAnn.lazy() && LazyFeatureDependencies.assertDependencyFullFilled()) {
      if (exists(referenceObjClass,dbRef,cache,mapr)) {
        resolvedObject=createOrReuseProxy(referenceObjClass,dbRef,cache,mapr);
      }
 else {
        if (!refAnn.ignoreMissing()) {
          throw new MappingException(""String_Node_Str"" + dbRef.toString() + ""String_Node_Str""+ mf.getFullName());
        }
      }
    }
 else {
      resolvedObject=resolveObject(dbRef,mf,cache,mapr);
    }
    mf.setFieldValue(entity,resolvedObject);
  }
}",0.901591043017089
104820,"Object resolveObject(final DBRef dbRef,final Class referenceObjClass,final boolean ignoreMissing,final MappedField mf,EntityCache cache,Mapper mapr){
  Key key=new Key(referenceObjClass,dbRef.getId());
  Object cached=cache.getEntity(key);
  if (cached != null)   return cached;
  BasicDBObject refDbObject=(BasicDBObject)dbRef.fetch();
  if (refDbObject != null) {
    Object refObj=mapr.getOptions().objectFactory.createInstance(referenceObjClass,refDbObject);
    refObj=mapr.fromDb(refDbObject,refObj,cache);
    cache.putEntity(key,refObj);
    return refObj;
  }
  if (!ignoreMissing) {
    throw new MappingException(""String_Node_Str"" + dbRef.toString() + ""String_Node_Str""+ mf.getFullName());
  }
 else {
    return null;
  }
}","Object resolveObject(final DBRef dbRef,final MappedField mf,EntityCache cache,Mapper mapr){
  Key key=new Key(mf.getSubClass(),dbRef.getId());
  Object cached=cache.getEntity(key);
  if (cached != null)   return cached;
  BasicDBObject refDbObject=(BasicDBObject)dbRef.fetch();
  if (refDbObject != null) {
    Object refObj=mapr.getOptions().objectFactory.createInstance(mapr,mf,refDbObject);
    refObj=mapr.fromDb(refDbObject,refObj,cache);
    cache.putEntity(key,refObj);
    return refObj;
  }
  boolean ignoreMissing=mf.getAnnotation(Reference.class) != null && mf.getAnnotation(Reference.class).ignoreMissing();
  if (!ignoreMissing) {
    throw new MappingException(""String_Node_Str"" + dbRef.toString() + ""String_Node_Str""+ mf.getFullName());
  }
 else {
    return null;
  }
}",0.7679158448389217
104821,"/** 
 * <p>Compares based on the following traits, in order:</p> <ol> <li>kind/kindClass</li> <li>parent</li> <li>id or name</li> </ol>
 */
@SuppressWarnings(""String_Node_Str"") public int compareTo(Key<?> other){
  int cmp=0;
  if (other.kindClass != null && kindClass != null) {
    cmp=this.kindClass.getName().compareTo(other.kindClass.getName());
    if (cmp != 0)     return cmp;
  }
  cmp=compareNullable(this.kind,other.kind);
  if (cmp != 0)   return cmp;
  try {
    cmp=compareNullable((Comparable<?>)this.id,(Comparable<?>)other.id);
    if (cmp != 0)     return cmp;
  }
 catch (  Exception e) {
  }
  return 0;
}","/** 
 * <p>Compares based on the following traits, in order:</p> <ol> <li>kind/kindClass</li> <li>parent</li> <li>id or name</li> </ol>
 */
@SuppressWarnings(""String_Node_Str"") public int compareTo(Key<?> other){
  checkState(this);
  checkState(other);
  int cmp=0;
  if (other.kindClass != null && kindClass != null) {
    cmp=this.kindClass.getName().compareTo(other.kindClass.getName());
    if (cmp != 0)     return cmp;
  }
  cmp=compareNullable(this.kind,other.kind);
  if (cmp != 0)   return cmp;
  try {
    cmp=compareNullable((Comparable<?>)this.id,(Comparable<?>)other.id);
    if (cmp != 0)     return cmp;
  }
 catch (  Exception e) {
  }
  return 0;
}",0.9682416731216112
104822,"Object resolveObject(final DBRef dbRef,final MappedField mf,EntityCache cache,Mapper mapr){
  Key key=new Key(mf.getSubClass(),dbRef.getId());
  Object cached=cache.getEntity(key);
  if (cached != null)   return cached;
  BasicDBObject refDbObject=(BasicDBObject)dbRef.fetch();
  if (refDbObject != null) {
    Object refObj=mapr.getOptions().objectFactory.createInstance(mapr,mf,refDbObject);
    refObj=mapr.fromDb(refDbObject,refObj,cache);
    cache.putEntity(key,refObj);
    return refObj;
  }
  boolean ignoreMissing=mf.getAnnotation(Reference.class) != null && mf.getAnnotation(Reference.class).ignoreMissing();
  if (!ignoreMissing) {
    throw new MappingException(""String_Node_Str"" + dbRef.toString() + ""String_Node_Str""+ mf.getFullName());
  }
 else {
    return null;
  }
}","Object resolveObject(final DBRef dbRef,final MappedField mf,EntityCache cache,Mapper mapr){
  Key key=mapr.createKey(mf.isSingleValue() ? mf.getType() : mf.getSubClass(),dbRef.getId());
  Object cached=cache.getEntity(key);
  if (cached != null)   return cached;
  BasicDBObject refDbObject=(BasicDBObject)dbRef.fetch();
  if (refDbObject != null) {
    Object refObj=mapr.getOptions().objectFactory.createInstance(mapr,mf,refDbObject);
    refObj=mapr.fromDb(refDbObject,refObj,cache);
    cache.putEntity(key,refObj);
    return refObj;
  }
  boolean ignoreMissing=mf.getAnnotation(Reference.class) != null && mf.getAnnotation(Reference.class).ignoreMissing();
  if (!ignoreMissing) {
    throw new MappingException(""String_Node_Str"" + dbRef.toString() + ""String_Node_Str""+ mf.getFullName());
  }
 else {
    return null;
  }
}",0.968421052631579
104823,"public Mapper(MapperOptions opts){
  converters.setMapper(this);
  this.opts=opts;
}","public Mapper(MapperOptions opts){
  this();
  this.opts=opts;
}",0.8513513513513513
104824,"/** 
 * Converts a DBObject back to a type-safe java object (POJO)
 * @param entityClass The type to return, or use; can be overridden by the @see Mapper.CLASS_NAME_FIELDNAME in the DBObject
 */
public Object fromDBObject(final Class entityClass,final DBObject dbObject,EntityCache cache){
  if (dbObject == null) {
    Throwable t=new Throwable();
    logger.error(""String_Node_Str"",t);
    return null;
  }
  Object entity=null;
  entity=opts.objectFactory.createInstance(entityClass,dbObject);
  entity=fromDb(dbObject,entity,cache);
  return entity;
}","/** 
 * Converts a DBObject back to a type-safe java object (POJO)
 * @param entityClass The type to return, or use; can be overridden by the @see Mapper.CLASS_NAME_FIELDNAME in the DBObject
 */
public Object fromDBObject(final Class entityClass,final DBObject dbObject,EntityCache cache){
  if (dbObject == null) {
    Throwable t=new Throwable();
    log.error(""String_Node_Str"",t);
    return null;
  }
  Object entity=null;
  entity=opts.objectFactory.createInstance(entityClass,dbObject);
  entity=fromDb(dbObject,entity,cache);
  return entity;
}",0.997289972899729
104825,"private void writeMappedField(BasicDBObject dbObject,MappedField mf,Object entity,Map<Object,DBObject> involvedObjects){
  Class<? extends Annotation> annType=null;
  if (mf.hasAnnotation(NotSaved.class))   return;
  for (  Class<? extends Annotation> testType : new Class[]{Property.class,Embedded.class,Serialized.class,Reference.class}) {
    if (mf.hasAnnotation(testType)) {
      annType=testType;
      break;
    }
  }
  if (Property.class.equals(annType) || Serialized.class.equals(annType) || mf.isTypeMongoCompatible()|| (converters.hasSimpleValueConverter(mf) || (converters.hasSimpleValueConverter(mf.getFieldValue(entity)))))   opts.valueMapper.toDBObject(entity,mf,dbObject,involvedObjects,this);
 else   if (Reference.class.equals(annType))   opts.referenceMapper.toDBObject(entity,mf,dbObject,involvedObjects,this);
 else   if (Embedded.class.equals(annType)) {
    opts.embeddedMapper.toDBObject(entity,mf,dbObject,involvedObjects,this);
  }
 else {
    logger.debug(""String_Node_Str"" + opts.defaultMapper + ""String_Node_Str""+ mf);
    opts.defaultMapper.toDBObject(entity,mf,dbObject,involvedObjects,this);
  }
}","private void writeMappedField(BasicDBObject dbObject,MappedField mf,Object entity,Map<Object,DBObject> involvedObjects){
  Class<? extends Annotation> annType=null;
  if (mf.hasAnnotation(NotSaved.class))   return;
  for (  Class<? extends Annotation> testType : new Class[]{Property.class,Embedded.class,Serialized.class,Reference.class}) {
    if (mf.hasAnnotation(testType)) {
      annType=testType;
      break;
    }
  }
  if (Property.class.equals(annType) || Serialized.class.equals(annType) || mf.isTypeMongoCompatible()|| (converters.hasSimpleValueConverter(mf) || (converters.hasSimpleValueConverter(mf.getFieldValue(entity)))))   opts.valueMapper.toDBObject(entity,mf,dbObject,involvedObjects,this);
 else   if (Reference.class.equals(annType))   opts.referenceMapper.toDBObject(entity,mf,dbObject,involvedObjects,this);
 else   if (Embedded.class.equals(annType)) {
    opts.embeddedMapper.toDBObject(entity,mf,dbObject,involvedObjects,this);
  }
 else {
    log.debug(""String_Node_Str"" + opts.defaultMapper + ""String_Node_Str""+ mf);
    opts.defaultMapper.toDBObject(entity,mf,dbObject,involvedObjects,this);
  }
}",0.99867197875166
104826,"public Object toMongoObject(final Object javaObj,boolean includeClassName){
  if (javaObj == null) {
    return null;
  }
  Class origClass=javaObj.getClass();
  Object newObj=converters.encode(origClass,javaObj);
  if (newObj == null) {
    logger.warning(""String_Node_Str"" + javaObj + ""String_Node_Str"");
    return newObj;
  }
  Class type=newObj.getClass();
  boolean bSameType=origClass.equals(type);
  if (!bSameType && !(Map.class.isAssignableFrom(type) || Iterable.class.isAssignableFrom(type)))   return newObj;
 else {
    boolean isSingleValue=true;
    boolean isMap=false;
    Class subType=null;
    if (type.isArray() || Map.class.isAssignableFrom(type) || Iterable.class.isAssignableFrom(type)) {
      isSingleValue=false;
      isMap=ReflectionUtils.implementsInterface(type,Map.class);
      subType=(type.isArray()) ? type.getComponentType() : ReflectionUtils.getParameterizedClass(type,(isMap) ? 1 : 0);
    }
    if (isSingleValue && !ReflectionUtils.isPropertyType(type)) {
      DBObject dbObj=toDBObject(newObj);
      if (!includeClassName)       dbObj.removeField(CLASS_NAME_FIELDNAME);
      return dbObj;
    }
 else     if (newObj instanceof DBObject) {
      return newObj;
    }
 else     if (isMap) {
      if (ReflectionUtils.isPropertyType(subType))       return toDBObject(newObj);
 else {
        HashMap m=new HashMap();
        for (        Map.Entry e : (Iterable<Map.Entry>)((Map)newObj).entrySet())         m.put(e.getKey(),toMongoObject(e.getValue(),includeClassName));
        return m;
      }
    }
 else     if (!isSingleValue && !ReflectionUtils.isPropertyType(subType)) {
      ArrayList<Object> vals=new ArrayList<Object>();
      if (type.isArray())       for (      Object obj : (Object[])newObj)       vals.add(toMongoObject(obj,includeClassName));
 else       for (      Object obj : (Iterable)newObj)       vals.add(toMongoObject(obj,includeClassName));
      return vals;
    }
 else {
      return newObj;
    }
  }
}","public Object toMongoObject(final Object javaObj,boolean includeClassName){
  if (javaObj == null) {
    return null;
  }
  Class origClass=javaObj.getClass();
  Object newObj=converters.encode(origClass,javaObj);
  if (newObj == null) {
    log.warning(""String_Node_Str"" + javaObj + ""String_Node_Str"");
    return newObj;
  }
  Class type=newObj.getClass();
  boolean bSameType=origClass.equals(type);
  if (!bSameType && !(Map.class.isAssignableFrom(type) || Iterable.class.isAssignableFrom(type)))   return newObj;
 else {
    boolean isSingleValue=true;
    boolean isMap=false;
    Class subType=null;
    if (type.isArray() || Map.class.isAssignableFrom(type) || Iterable.class.isAssignableFrom(type)) {
      isSingleValue=false;
      isMap=ReflectionUtils.implementsInterface(type,Map.class);
      subType=(type.isArray()) ? type.getComponentType() : ReflectionUtils.getParameterizedClass(type,(isMap) ? 1 : 0);
    }
    if (isSingleValue && !ReflectionUtils.isPropertyType(type)) {
      DBObject dbObj=toDBObject(newObj);
      if (!includeClassName)       dbObj.removeField(CLASS_NAME_FIELDNAME);
      return dbObj;
    }
 else     if (newObj instanceof DBObject) {
      return newObj;
    }
 else     if (isMap) {
      if (ReflectionUtils.isPropertyType(subType))       return toDBObject(newObj);
 else {
        HashMap m=new HashMap();
        for (        Map.Entry e : (Iterable<Map.Entry>)((Map)newObj).entrySet())         m.put(e.getKey(),toMongoObject(e.getValue(),includeClassName));
        return m;
      }
    }
 else     if (!isSingleValue && !ReflectionUtils.isPropertyType(subType)) {
      ArrayList<Object> vals=new ArrayList<Object>();
      if (type.isArray())       for (      Object obj : (Object[])newObj)       vals.add(toMongoObject(obj,includeClassName));
 else       for (      Object obj : (Iterable)newObj)       vals.add(toMongoObject(obj,includeClassName));
      return vals;
    }
 else {
      return newObj;
    }
  }
}",0.9992395437262356
104827,"/** 
 * Converts a list of refs to keys 
 */
@SuppressWarnings(""String_Node_Str"") public static <T>List<Key<T>> refsToKeys(List<DBRef> refs,Class<T> c){
  ArrayList<Key<T>> keys=new ArrayList<Key<T>>(refs.size());
  for (  DBRef ref : refs) {
    keys.add(new Key(ref));
  }
  return keys;
}","/** 
 * Converts a list of refs to keys 
 */
public static <T>List<Key<T>> refsToKeys(List<DBRef> refs,Class<T> c){
  ArrayList<Key<T>> keys=new ArrayList<Key<T>>(refs.size());
  for (  DBRef ref : refs) {
    keys.add(new Key<T>(ref));
  }
  return keys;
}",0.927007299270073
104828,"/** 
 * Queries the server to check for each DBRef 
 */
@SuppressWarnings(""String_Node_Str"") public <T>List<Key<T>> getKeysByRefs(List<DBRef> refs){
  ArrayList<Key<T>> tempKeys=new ArrayList<Key<T>>(refs.size());
  Map<String,List<DBRef>> kindMap=new HashMap<String,List<DBRef>>();
  for (  DBRef ref : refs) {
    if (kindMap.containsKey(ref.getRef()))     kindMap.get(ref.getRef()).add(ref);
 else     kindMap.put(ref.getRef(),new ArrayList<DBRef>(Collections.singletonList((DBRef)ref)));
  }
  for (  String kind : kindMap.keySet()) {
    List objIds=new ArrayList();
    List<DBRef> kindRefs=kindMap.get(kind);
    for (    DBRef key : kindRefs) {
      objIds.add(key.getId());
    }
    List<Key<T>> kindResults=this.<T>find(kind,null).disableValidation().filter(""String_Node_Str"",objIds).asKeyList();
    tempKeys.addAll(kindResults);
  }
  ArrayList<Key<T>> keys=new ArrayList<Key<T>>(refs.size());
  for (  DBRef ref : refs) {
    Key<T> testKey=new Key<T>(ref);
    if (tempKeys.contains(testKey))     keys.add(testKey);
  }
  return keys;
}","/** 
 * Queries the server to check for each DBRef 
 */
public <T>List<Key<T>> getKeysByRefs(List<DBRef> refs){
  ArrayList<Key<T>> tempKeys=new ArrayList<Key<T>>(refs.size());
  Map<String,List<DBRef>> kindMap=new HashMap<String,List<DBRef>>();
  for (  DBRef ref : refs) {
    if (kindMap.containsKey(ref.getRef()))     kindMap.get(ref.getRef()).add(ref);
 else     kindMap.put(ref.getRef(),new ArrayList<DBRef>(Collections.singletonList((DBRef)ref)));
  }
  for (  String kind : kindMap.keySet()) {
    List<Object> objIds=new ArrayList<Object>();
    List<DBRef> kindRefs=kindMap.get(kind);
    for (    DBRef key : kindRefs) {
      objIds.add(key.getId());
    }
    List<Key<T>> kindResults=this.<T>find(kind,null).disableValidation().filter(""String_Node_Str"",objIds).asKeyList();
    tempKeys.addAll(kindResults);
  }
  ArrayList<Key<T>> keys=new ArrayList<Key<T>>(refs.size());
  for (  DBRef ref : refs) {
    Key<T> testKey=new Key<T>(ref);
    if (tempKeys.contains(testKey))     keys.add(testKey);
  }
  return keys;
}",0.9745559289486316
104829,"@SuppressWarnings(""String_Node_Str"") public <T>List<T> getByKeys(Class<T> clazz,Iterable<Key<T>> keys){
  Map<String,List<Key>> kindMap=new HashMap<String,List<Key>>();
  List<T> entities=new ArrayList<T>();
  for (  Key<?> key : keys) {
    key.updateKind(getMapper());
    if (kindMap.containsKey(key.getKind()))     kindMap.get(key.getKind()).add(key);
 else     kindMap.put(key.getKind(),new ArrayList<Key>(Collections.singletonList((Key)key)));
  }
  for (  String kind : kindMap.keySet()) {
    List objIds=new ArrayList();
    List<Key> kindKeys=kindMap.get(kind);
    for (    Key key : kindKeys) {
      objIds.add(key.getId());
    }
    List kindResults=find(kind,null).disableValidation().filter(""String_Node_Str"",objIds).asList();
    entities.addAll(kindResults);
  }
  return entities;
}","@SuppressWarnings(""String_Node_Str"") public <T>List<T> getByKeys(Class<T> clazz,Iterable<Key<T>> keys){
  Map<String,List<Key>> kindMap=new HashMap<String,List<Key>>();
  List<T> entities=new ArrayList<T>();
  for (  Key<?> key : keys) {
    key.updateKind(getMapper());
    if (kindMap.containsKey(key.getKind()))     kindMap.get(key.getKind()).add(key);
 else     kindMap.put(key.getKind(),new ArrayList<Key>(Collections.singletonList((Key)key)));
  }
  for (  String kind : kindMap.keySet()) {
    List<Object> objIds=new ArrayList<Object>();
    List<Key> kindKeys=kindMap.get(kind);
    for (    Key key : kindKeys) {
      objIds.add(key.getId());
    }
    List kindResults=find(kind,null).disableValidation().filter(""String_Node_Str"",objIds).asList();
    entities.addAll(kindResults);
  }
  return entities;
}",0.9901234567901236
104830,"@Test public void testIndexes(){
  MappedClass mc=morphia.getMapper().getMappedClass(Ad2.class);
  this.morphia.map(Ad2.class);
  assertFalse(hasNamedIndex(""String_Node_Str"",db.getCollection(mc.getCollectionName()).getIndexInfo()));
  ds.ensureIndexes(Ad2.class);
  assertTrue(hasNamedIndex(""String_Node_Str"",db.getCollection(mc.getCollectionName()).getIndexInfo()));
}","@Test public void testIndexes(){
  MappedClass mc=this.morphia.getMapper().addMappedClass(Ad2.class);
  assertFalse(hasNamedIndex(""String_Node_Str"",db.getCollection(mc.getCollectionName()).getIndexInfo()));
  ds.ensureIndexes(Ad2.class);
  assertTrue(hasNamedIndex(""String_Node_Str"",db.getCollection(mc.getCollectionName()).getIndexInfo()));
}",0.9297752808988764
104831,"/** 
 * Ensures (creating if necessary) the indexes found during class mapping (using   {@code @Indexed)}
 */
<T>void ensureIndexes(Class<T> clazz);","/** 
 * Ensures (creating if necessary) the indexes found during class mapping (using   {@code @Indexed)}, possibly in the background
 */
<T>void ensureIndexes(Class<T> clazz,boolean background);",0.8629737609329446
104832,"public void ensureIndexes(){
  for (  MappedClass mc : mapr.getMappedClasses().values()) {
    ensureIndexes(mc);
  }
}","public void ensureIndexes(boolean background){
  for (  MappedClass mc : mapr.getMappedClasses().values()) {
    ensureIndexes(mc,background);
  }
}",0.8913857677902621
104833,"public <T>void ensureIndex(Class<T> type,IndexFieldDef... fields){
  ensureIndex(type,null,fields,false,false);
}","public <T>void ensureIndex(Class<T> type,boolean background,IndexFieldDef... fields){
  ensureIndex(type,null,fields,false,false,background);
}",0.8828125
104834,"private void writeCollection(final MappedField mf,final BasicDBObject dbObject,Map<Object,DBObject> involvedObjects,String name,Object fieldValue,Mapper mapr){
  Iterable coll=(Iterable)fieldValue;
  if (coll != null) {
    List values=new ArrayList();
    for (    Object o : coll) {
      if (mapr.converters.hasSimpleValueConverter(mf) || mapr.converters.hasSimpleValueConverter(o.getClass()))       values.add(mapr.converters.encode(o));
 else {
        DBObject dbObj=mapr.toDBObject(o,involvedObjects);
        if (mf.getSubType().equals(o.getClass()) && !(dbObj instanceof BasicDBList)) {
          dbObj.removeField(Mapper.CLASS_NAME_FIELDNAME);
        }
        values.add(dbObj);
      }
    }
    if (values.size() > 0 || mapr.getOptions().storeEmpties) {
      dbObject.put(name,values);
    }
  }
}","private void writeCollection(final MappedField mf,final BasicDBObject dbObject,Map<Object,DBObject> involvedObjects,String name,Object fieldValue,Mapper mapr){
  Iterable coll=(Iterable)fieldValue;
  if (coll != null) {
    List values=new ArrayList();
    for (    Object o : coll) {
      if (mapr.converters.hasSimpleValueConverter(mf) || mapr.converters.hasSimpleValueConverter(o.getClass()))       values.add(mapr.converters.encode(o));
 else {
        DBObject dbObj=mapr.toDBObject(o,involvedObjects);
        if (!mf.getSubType().isInterface() && !Modifier.isAbstract(mf.getSubType().getModifiers()) && mf.getSubType().equals(o.getClass())&& !(dbObj instanceof BasicDBList)) {
          dbObj.removeField(Mapper.CLASS_NAME_FIELDNAME);
        }
        values.add(dbObj);
      }
    }
    if (values.size() > 0 || mapr.getOptions().storeEmpties) {
      dbObject.put(name,values);
    }
  }
}",0.9468768242848804
104835,"private void writeMap(final MappedField mf,final BasicDBObject dbObject,Map<Object,DBObject> involvedObjects,String name,Object fieldValue,Mapper mapr){
  Map<String,Object> map=(Map<String,Object>)fieldValue;
  if (map != null) {
    BasicDBObject values=new BasicDBObject();
    for (    Map.Entry<String,Object> entry : map.entrySet()) {
      Object entryVal=entry.getValue();
      Object val;
      if (entryVal == null)       val=null;
 else       if (mapr.converters.hasSimpleValueConverter(mf) || mapr.converters.hasSimpleValueConverter(entryVal.getClass()))       val=mapr.converters.encode(entryVal);
 else {
        val=mapr.toDBObject(entryVal,involvedObjects);
        if (mf.getSubType().equals(entryVal.getClass()) && !(val instanceof BasicDBList))         ((DBObject)val).removeField(Mapper.CLASS_NAME_FIELDNAME);
      }
      String strKey=mapr.converters.encode(entry.getKey()).toString();
      values.put(strKey,val);
    }
    if (values.size() > 0 || mapr.getOptions().storeEmpties)     dbObject.put(name,values);
  }
}","private void writeMap(final MappedField mf,final BasicDBObject dbObject,Map<Object,DBObject> involvedObjects,String name,Object fieldValue,Mapper mapr){
  Map<String,Object> map=(Map<String,Object>)fieldValue;
  if (map != null) {
    BasicDBObject values=new BasicDBObject();
    for (    Map.Entry<String,Object> entry : map.entrySet()) {
      Object entryVal=entry.getValue();
      Object val;
      if (entryVal == null)       val=null;
 else       if (mapr.converters.hasSimpleValueConverter(mf) || mapr.converters.hasSimpleValueConverter(entryVal.getClass()))       val=mapr.converters.encode(entryVal);
 else {
        val=mapr.toDBObject(entryVal,involvedObjects);
        if (!mf.getSubType().isInterface() && !Modifier.isAbstract(mf.getSubType().getModifiers()) && !(val instanceof BasicDBList)&& mf.getSubType().equals(entryVal.getClass()))         ((DBObject)val).removeField(Mapper.CLASS_NAME_FIELDNAME);
      }
      String strKey=mapr.converters.encode(entry.getKey()).toString();
      values.put(strKey,val);
    }
    if (values.size() > 0 || mapr.getOptions().storeEmpties)     dbObject.put(name,values);
  }
}",0.9379310344827586
104836,"/** 
 * <p> Converts a java object to a mongo-compatible object (possibly a DBObject for complex mappings). Very similar to   {@link Mapper.toDBObject}</p> <p> Used (mainly) by query/update operations </p>
 */
public Object toMongoObject(final Object javaObj){
  if (javaObj == null) {
    return null;
  }
  Class origClass=javaObj.getClass();
  Object newObj=converters.encode(origClass,javaObj);
  if (newObj == null) {
    logger.warning(""String_Node_Str"" + javaObj + ""String_Node_Str"");
    return newObj;
  }
  Class type=newObj.getClass();
  boolean bSameType=origClass.equals(type);
  if (!bSameType)   return newObj;
 else {
    boolean isSingleValue=true;
    boolean isMap=false;
    Class subType=null;
    if (type.isArray() || ReflectionUtils.implementsAnyInterface(type,Iterable.class,Map.class)) {
      isSingleValue=false;
      isMap=ReflectionUtils.implementsInterface(type,Map.class);
      subType=(type.isArray()) ? type.getComponentType() : ReflectionUtils.getParameterizedClass(type,(isMap) ? 1 : 0);
    }
    if (isSingleValue && !ReflectionUtils.isPropertyType(type)) {
      DBObject dbObj=toDBObject(newObj);
      dbObj.removeField(CLASS_NAME_FIELDNAME);
      return dbObj;
    }
 else     if (newObj instanceof DBObject) {
      return newObj;
    }
 else     if (isMap) {
      if (ReflectionUtils.isPropertyType(subType))       return toDBObject(newObj);
 else {
        HashMap m=new HashMap();
        for (        Map.Entry e : (Iterable<Map.Entry>)((Map)newObj).entrySet())         m.put(e.getKey(),toMongoObject(e.getValue()));
        return toDBObject(m);
      }
    }
 else     if (!isSingleValue && !ReflectionUtils.isPropertyType(subType)) {
      ArrayList<Object> vals=new ArrayList<Object>();
      if (type.isArray())       for (      Object obj : (Object[])newObj)       vals.add(toMongoObject(obj));
 else       for (      Object obj : (Iterable)newObj)       vals.add(toMongoObject(obj));
      return vals;
    }
 else {
      return newObj;
    }
  }
}","public Object toMongoObject(final Object javaObj,boolean includeClassName){
  if (javaObj == null) {
    return null;
  }
  Class origClass=javaObj.getClass();
  Object newObj=converters.encode(origClass,javaObj);
  if (newObj == null) {
    logger.warning(""String_Node_Str"" + javaObj + ""String_Node_Str"");
    return newObj;
  }
  Class type=newObj.getClass();
  boolean bSameType=origClass.equals(type);
  if (!bSameType)   return newObj;
 else {
    boolean isSingleValue=true;
    boolean isMap=false;
    Class subType=null;
    if (type.isArray() || ReflectionUtils.implementsAnyInterface(type,Iterable.class,Map.class)) {
      isSingleValue=false;
      isMap=ReflectionUtils.implementsInterface(type,Map.class);
      subType=(type.isArray()) ? type.getComponentType() : ReflectionUtils.getParameterizedClass(type,(isMap) ? 1 : 0);
    }
    if (isSingleValue && !ReflectionUtils.isPropertyType(type)) {
      DBObject dbObj=toDBObject(newObj);
      if (!includeClassName)       dbObj.removeField(CLASS_NAME_FIELDNAME);
      return dbObj;
    }
 else     if (newObj instanceof DBObject) {
      return newObj;
    }
 else     if (isMap) {
      if (ReflectionUtils.isPropertyType(subType))       return toDBObject(newObj);
 else {
        HashMap m=new HashMap();
        for (        Map.Entry e : (Iterable<Map.Entry>)((Map)newObj).entrySet())         m.put(e.getKey(),toMongoObject(e.getValue(),includeClassName));
        return toDBObject(m);
      }
    }
 else     if (!isSingleValue && !ReflectionUtils.isPropertyType(subType)) {
      ArrayList<Object> vals=new ArrayList<Object>();
      if (type.isArray())       for (      Object obj : (Object[])newObj)       vals.add(toMongoObject(obj,includeClassName));
 else       for (      Object obj : (Iterable)newObj)       vals.add(toMongoObject(obj,includeClassName));
      return vals;
    }
 else {
      return newObj;
    }
  }
}",0.4594525454080327
104837,"public UpdateOperations<T> add(String fieldExpr,Object value,boolean addDups){
  if (value == null)   throw new QueryException(""String_Node_Str"");
  Object dbObj=mapr.toMongoObject(value);
  add((addDups) ? ""String_Node_Str"" : ""String_Node_Str"",fieldExpr,dbObj);
  return this;
}","public UpdateOperations<T> add(String fieldExpr,Object value,boolean addDups){
  if (value == null)   throw new QueryException(""String_Node_Str"");
  Object dbObj=mapr.toMongoObject(value,true);
  add((addDups) ? ""String_Node_Str"" : ""String_Node_Str"",fieldExpr,dbObj);
  return this;
}",0.9911190053285968
104838,"public UpdateOperations<T> set(String fieldExpr,Object value){
  if (value == null)   throw new QueryException(""String_Node_Str"");
  Object dbObj=mapr.toMongoObject(value);
  add(""String_Node_Str"",fieldExpr,dbObj);
  return this;
}","public UpdateOperations<T> set(String fieldExpr,Object value){
  if (value == null)   throw new QueryException(""String_Node_Str"");
  Object dbObj=mapr.toMongoObject(value,true);
  add(""String_Node_Str"",fieldExpr,dbObj);
  return this;
}",0.9892933618843684
104839,"public UpdateOperations<T> addAll(String fieldExpr,List<?> values,boolean addDups){
  if (values == null || values.isEmpty())   throw new QueryException(""String_Node_Str"");
  List<?> convertedValues=(List<?>)mapr.toMongoObject(values);
  if (addDups)   add(""String_Node_Str"",fieldExpr,convertedValues);
 else   add(""String_Node_Str"",fieldExpr,new BasicDBObject(""String_Node_Str"",convertedValues));
  return this;
}","public UpdateOperations<T> addAll(String fieldExpr,List<?> values,boolean addDups){
  if (values == null || values.isEmpty())   throw new QueryException(""String_Node_Str"");
  List<?> convertedValues=(List<?>)mapr.toMongoObject(values,true);
  if (addDups)   add(""String_Node_Str"",fieldExpr,convertedValues);
 else   add(""String_Node_Str"",fieldExpr,new BasicDBObject(""String_Node_Str"",convertedValues));
  return this;
}",0.9939975990396158
104840,"@Test @Ignore public void retainsClassName(){
  X x=new X();
  E1 e1=new E1();
  e1.foo=""String_Node_Str"";
  x.map.put(""String_Node_Str"",e1);
  E2 e2=new E2();
  e2.bar=""String_Node_Str"";
  x.map.put(""String_Node_Str"",e2);
  ds.save(x);
  Query<X> state_query=ds.createQuery(X.class);
  UpdateOperations<X> state_update=ds.createUpdateOperations(X.class);
  state_update.set(""String_Node_Str"",e2);
  ds.update(state_query,state_update);
  x=ds.find(X.class).get();
}","@Test public void retainsClassName(){
  X x=new X();
  E1 e1=new E1();
  e1.foo=""String_Node_Str"";
  x.map.put(""String_Node_Str"",e1);
  E2 e2=new E2();
  e2.bar=""String_Node_Str"";
  x.map.put(""String_Node_Str"",e2);
  ds.save(x);
  Query<X> state_query=ds.createQuery(X.class);
  UpdateOperations<X> state_update=ds.createUpdateOperations(X.class);
  state_update.set(""String_Node_Str"",e2);
  ds.update(state_query,state_update);
  x=ds.find(X.class).get();
}",0.9913419913419912
104841,"/** 
 * Converts a DBObject back to a type-safe java object (POJO)
 * @param entityClass The type to return, or use; can be overridden by the @see Mapper.CLASS_NAME_FIELDNAME in the DBObject
 */
public Object fromDBObject(final Class entityClass,final DBObject dbObject,EntityCache cache){
  if (dbObject == null) {
    Throwable t=new Throwable();
    logger.error(""String_Node_Str"",t);
    return null;
  }
  Object entity=null;
  entity=ReflectionUtils.createInstance(entityClass,dbObject);
  fromDb(dbObject,entity,cache);
  return entity;
}","/** 
 * Converts a DBObject back to a type-safe java object (POJO)
 * @param entityClass The type to return, or use; can be overridden by the @see Mapper.CLASS_NAME_FIELDNAME in the DBObject
 */
public Object fromDBObject(final Class entityClass,final DBObject dbObject,EntityCache cache){
  if (dbObject == null) {
    Throwable t=new Throwable();
    logger.error(""String_Node_Str"",t);
    return null;
  }
  Object entity=null;
  entity=ReflectionUtils.createInstance(entityClass,dbObject);
  entity=fromDb(dbObject,entity,cache);
  return entity;
}",0.9936189608021878
104842,"public DefaultConverters(){
  addConverter(new PassthroughConverter(DBObject.class,BasicDBObject.class));
  addConverter(new PassthroughConverter(byte[].class));
  addConverter(new EnumSetConverter());
  addConverter(new EnumConverter());
  addConverter(new StringConverter());
  addConverter(new CharacterConverter());
  addConverter(new ByteConverter());
  addConverter(new BooleanConverter());
  addConverter(new DoubleConverter());
  addConverter(new FloatConverter());
  addConverter(new LongConverter());
  addConverter(new LocaleConverter());
  addConverter(new ShortConverter());
  addConverter(new IntegerConverter());
  addConverter(new SerializedObjectConverter());
  addConverter(new CharArrayConverter());
  addConverter(new DateConverter());
  addConverter(new KeyConverter());
  addConverter(new MapOfValuesConverter(this));
  addConverter(new IterableConverter(this));
  addConverter(new ClassConverter());
  addConverter(new PassthroughConverter());
}","public DefaultConverters(){
  addConverter(new PassthroughConverter(DBObject.class,BasicDBObject.class));
  addConverter(new PassthroughConverter(byte[].class));
  addConverter(new EnumSetConverter());
  addConverter(new EnumConverter());
  addConverter(new StringConverter());
  addConverter(new CharacterConverter());
  addConverter(new ByteConverter());
  addConverter(new BooleanConverter());
  addConverter(new DoubleConverter());
  addConverter(new FloatConverter());
  addConverter(new LongConverter());
  addConverter(new LocaleConverter());
  addConverter(new ShortConverter());
  addConverter(new IntegerConverter());
  addConverter(new SerializedObjectConverter());
  addConverter(new CharArrayConverter());
  addConverter(new DateConverter());
  addConverter(new KeyConverter());
  addConverter(new MapOfValuesConverter(this));
  addConverter(new IterableConverter(this));
  addConverter(new ClassConverter());
  addConverter(new ObjectIdConverter());
  addConverter(new PassthroughConverter());
}",0.9792615073343448
104843,"/** 
 * Discovers interesting (that we care about) things about the class. 
 */
protected void discover(){
  for (  Class<? extends Annotation> c : interestingAnnotations) {
    addAnnotation(c);
  }
  Class<?> type=clazz;
  try {
    ctor=type.getDeclaredConstructor();
    ctor.setAccessible(true);
  }
 catch (  NoSuchMethodException e) {
    throw new MappingException(""String_Node_Str"" + type.getName() + ""String_Node_Str"",e);
  }
  List<Class<?>> lifecycleClasses=new ArrayList<Class<?>>();
  lifecycleClasses.add(clazz);
  EntityListeners entityLisAnn=(EntityListeners)releventAnnotations.get(EntityListeners.class);
  if (entityLisAnn != null && entityLisAnn.value() != null && entityLisAnn.value().length != 0)   for (  Class<?> c : entityLisAnn.value())   lifecycleClasses.add(c);
  Class<? extends Annotation>[] lifecycleAnnotations=new Class[]{PrePersist.class,PreSave.class,PostPersist.class,PreLoad.class,PostLoad.class};
  for (  Class<?> cls : lifecycleClasses) {
    for (    Method m : ReflectionUtils.getDeclaredAndInheritedMethods(cls)) {
      for (      Class<? extends Annotation> c : lifecycleAnnotations) {
        if (m.isAnnotationPresent(c)) {
          addLifecycleEventMethod(c,m,cls.equals(clazz) ? null : cls);
        }
      }
    }
  }
  embeddedAn=(Embedded)releventAnnotations.get(Embedded.class);
  entityAn=(Entity)releventAnnotations.get(Entity.class);
  collName=(entityAn == null || entityAn.value().equals(Mapper.IGNORED_FIELDNAME)) ? clazz.getSimpleName() : entityAn.value();
  for (  Field field : ReflectionUtils.getDeclaredAndInheritedFields(clazz,true)) {
    field.setAccessible(true);
    int fieldMods=field.getModifiers();
    if (field.isAnnotationPresent(Transient.class))     continue;
 else     if (field.isSynthetic() && (fieldMods & Modifier.TRANSIENT) == Modifier.TRANSIENT)     continue;
 else     if (mapr.getOptions().actLikeSerializer && ((fieldMods & Modifier.TRANSIENT) == Modifier.TRANSIENT))     continue;
 else     if (mapr.getOptions().ignoreFinals && ((fieldMods & Modifier.FINAL) == Modifier.FINAL))     continue;
 else     if (field.isAnnotationPresent(Id.class)) {
      idField=field;
      MappedField mf=new MappedField(idField);
      persistenceFields.add(mf);
    }
 else     if (field.isAnnotationPresent(Property.class) || field.isAnnotationPresent(Reference.class) || field.isAnnotationPresent(Embedded.class)|| field.isAnnotationPresent(Serialized.class)|| isSupportedType(field.getType())|| ReflectionUtils.implementsInterface(field.getType(),Serializable.class)) {
      persistenceFields.add(new MappedField(field));
    }
 else {
      if (mapr.getOptions().defaultFieldAnnotation != null)       persistenceFields.add(new MappedField(field));
 else       log.warning(""String_Node_Str"" + clazz.getName() + ""String_Node_Str""+ field.getName()+ ""String_Node_Str""+ field.getType().getName()+ ""String_Node_Str"");
    }
  }
}","/** 
 * Discovers interesting (that we care about) things about the class. 
 */
protected void discover(){
  for (  Class<? extends Annotation> c : interestingAnnotations) {
    addAnnotation(c);
  }
  Class<?> type=clazz;
  try {
    ctor=type.getDeclaredConstructor();
    ctor.setAccessible(true);
  }
 catch (  NoSuchMethodException e) {
    throw new MappingException(""String_Node_Str"" + type.getName() + ""String_Node_Str"",e);
  }
  List<Class<?>> lifecycleClasses=new ArrayList<Class<?>>();
  lifecycleClasses.add(clazz);
  EntityListeners entityLisAnn=(EntityListeners)releventAnnotations.get(EntityListeners.class);
  if (entityLisAnn != null && entityLisAnn.value() != null && entityLisAnn.value().length != 0)   for (  Class<?> c : entityLisAnn.value())   lifecycleClasses.add(c);
  Class<? extends Annotation>[] lifecycleAnnotations=new Class[]{PrePersist.class,PreSave.class,PostPersist.class,PreLoad.class,PostLoad.class};
  for (  Class<?> cls : lifecycleClasses) {
    for (    Method m : ReflectionUtils.getDeclaredAndInheritedMethods(cls)) {
      for (      Class<? extends Annotation> c : lifecycleAnnotations) {
        if (m.isAnnotationPresent(c)) {
          addLifecycleEventMethod(c,m,cls.equals(clazz) ? null : cls);
        }
      }
    }
  }
  embeddedAn=(Embedded)releventAnnotations.get(Embedded.class);
  entityAn=(Entity)releventAnnotations.get(Entity.class);
  collName=(entityAn == null || entityAn.value().equals(Mapper.IGNORED_FIELDNAME)) ? clazz.getSimpleName() : entityAn.value();
  for (  Field field : ReflectionUtils.getDeclaredAndInheritedFields(clazz,true)) {
    field.setAccessible(true);
    int fieldMods=field.getModifiers();
    if (field.isAnnotationPresent(Transient.class))     continue;
 else     if (field.isSynthetic() && (fieldMods & Modifier.TRANSIENT) == Modifier.TRANSIENT)     continue;
 else     if (mapr.getOptions().actLikeSerializer && ((fieldMods & Modifier.TRANSIENT) == Modifier.TRANSIENT))     continue;
 else     if (mapr.getOptions().ignoreFinals && ((fieldMods & Modifier.FINAL) == Modifier.FINAL))     continue;
 else     if (field.isAnnotationPresent(Id.class)) {
      idField=field;
      MappedField mf=new MappedField(idField);
      persistenceFields.add(mf);
    }
 else     if (field.isAnnotationPresent(Property.class) || field.isAnnotationPresent(Reference.class) || field.isAnnotationPresent(Embedded.class)|| field.isAnnotationPresent(Serialized.class)|| isSupportedType(field.getType())|| ReflectionUtils.implementsInterface(field.getType(),Serializable.class)) {
      persistenceFields.add(new MappedField(field));
    }
 else {
      if (mapr.getOptions().defaultMapper != null)       persistenceFields.add(new MappedField(field));
 else       log.warning(""String_Node_Str"" + clazz.getName() + ""String_Node_Str""+ field.getName()+ ""String_Node_Str""+ field.getType().getName()+ ""String_Node_Str"");
    }
  }
}",0.9963799344940528
104844,"Object fromDb(DBObject dbObject,final Object entity,EntityCache cache){
  if (dbObject.containsField(ID_KEY) && getMappedClass(entity).getIdField() != null && getMappedClass(entity).getEntityAnnotation() != null) {
    Key key=new Key(entity.getClass(),dbObject.get(ID_KEY));
    Object cachedInstance=cache.getEntity(key);
    if (cachedInstance != null)     return cachedInstance;
 else     cache.putEntity(key,entity);
  }
  MappedClass mc=getMappedClass(entity);
  dbObject=(BasicDBObject)mc.callLifecycleMethods(PreLoad.class,entity,dbObject,this);
  try {
    for (    MappedField mf : mc.getPersistenceFields()) {
      if (mf.hasAnnotation(Id.class)) {
        setIdValue(entity,mf,dbObject,cache);
      }
 else       if (mf.hasAnnotation(Property.class) || mf.hasAnnotation(Serialized.class) || mf.isTypeMongoCompatible()|| converters.hasSimpleValueConverter(mf))       opts.valueMapper.fromDBObject(dbObject,mf,entity,cache,this);
 else       if (mf.hasAnnotation(Embedded.class))       opts.embeddedMapper.fromDBObject(dbObject,mf,entity,cache,this);
 else       if (mf.hasAnnotation(Reference.class))       opts.referenceMapper.fromDBObject(dbObject,mf,entity,cache,this);
 else {
        opts.embeddedMapper.fromDBObject(dbObject,mf,entity,cache,this);
      }
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  if (dbObject.containsField(ID_KEY) && getMappedClass(entity).getIdField() != null) {
    Key key=new Key(entity.getClass(),dbObject.get(ID_KEY));
    cache.putEntity(key,entity);
  }
  mc.callLifecycleMethods(PostLoad.class,entity,dbObject,this);
  return entity;
}","Object fromDb(DBObject dbObject,final Object entity,EntityCache cache){
  if (dbObject.containsField(ID_KEY) && getMappedClass(entity).getIdField() != null && getMappedClass(entity).getEntityAnnotation() != null) {
    Key key=new Key(entity.getClass(),dbObject.get(ID_KEY));
    Object cachedInstance=cache.getEntity(key);
    if (cachedInstance != null)     return cachedInstance;
 else     cache.putEntity(key,entity);
  }
  MappedClass mc=getMappedClass(entity);
  dbObject=(BasicDBObject)mc.callLifecycleMethods(PreLoad.class,entity,dbObject,this);
  try {
    for (    MappedField mf : mc.getPersistenceFields()) {
      if (mf.hasAnnotation(Id.class)) {
        setIdValue(entity,mf,dbObject,cache);
      }
 else       if (mf.hasAnnotation(Property.class) || mf.hasAnnotation(Serialized.class) || mf.isTypeMongoCompatible()|| converters.hasSimpleValueConverter(mf))       opts.valueMapper.fromDBObject(dbObject,mf,entity,cache,this);
 else       if (mf.hasAnnotation(Embedded.class))       opts.embeddedMapper.fromDBObject(dbObject,mf,entity,cache,this);
 else       if (mf.hasAnnotation(Reference.class))       opts.referenceMapper.fromDBObject(dbObject,mf,entity,cache,this);
 else {
        opts.defaultMapper.fromDBObject(dbObject,mf,entity,cache,this);
      }
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  if (dbObject.containsField(ID_KEY) && getMappedClass(entity).getIdField() != null) {
    Key key=new Key(entity.getClass(),dbObject.get(ID_KEY));
    cache.putEntity(key,entity);
  }
  mc.callLifecycleMethods(PostLoad.class,entity,dbObject,this);
  return entity;
}",0.9953574744661096
104845,"/** 
 * <p> Converts an entity (POJO) to a DBObject (for use with low-level driver); A special field will be added to keep track of the class:   {@link Mapper.CLASS_NAME_FIELDNAME} </p>
 * @param entity The POJO
 * @param involvedObjects A Map of (already converted) POJOs
 */
public DBObject toDBObject(Object entity,Map<Object,DBObject> involvedObjects){
  BasicDBObject dbObject=new BasicDBObject();
  MappedClass mc=getMappedClass(entity);
  if (mc.getEntityAnnotation() == null || !mc.getEntityAnnotation().noClassnameStored())   dbObject.put(CLASS_NAME_FIELDNAME,entity.getClass().getName());
  dbObject=(BasicDBObject)mc.callLifecycleMethods(PrePersist.class,entity,dbObject,this);
  for (  MappedField mf : mc.getPersistenceFields()) {
    try {
      Class<? extends Annotation> annType=null;
      if (mf.hasAnnotation(NotSaved.class))       continue;
      for (      Class<? extends Annotation> testType : new Class[]{Id.class,Property.class,Embedded.class,Serialized.class,Reference.class}) {
        if (mf.hasAnnotation(testType)) {
          annType=testType;
          break;
        }
      }
      if (Id.class.equals(annType)) {
        Object idVal=mf.getFieldValue(entity);
        if (idVal != null) {
          if (!mf.isTypeMongoCompatible() && !converters.hasSimpleValueConverter(mf)) {
            opts.embeddedMapper.toDBObject(entity,mf,dbObject,involvedObjects,this);
          }
 else {
            Object dbVal=converters.encode(idVal);
            dbObject.put(ID_KEY,dbVal);
          }
        }
      }
 else       if (Property.class.equals(annType) || Serialized.class.equals(annType) || mf.isTypeMongoCompatible()|| (converters.hasSimpleValueConverter(mf)))       opts.valueMapper.toDBObject(entity,mf,dbObject,involvedObjects,this);
 else       if (Reference.class.equals(annType))       opts.referenceMapper.toDBObject(entity,mf,dbObject,involvedObjects,this);
 else       if (Embedded.class.equals(annType)) {
        opts.embeddedMapper.toDBObject(entity,mf,dbObject,involvedObjects,this);
      }
 else {
        logger.debug(""String_Node_Str"" + mf);
        opts.embeddedMapper.toDBObject(entity,mf,dbObject,involvedObjects,this);
      }
    }
 catch (    Exception e) {
      throw new MappingException(""String_Node_Str"" + mf.getFullName(),e);
    }
  }
  if (involvedObjects != null)   involvedObjects.put(entity,dbObject);
  mc.callLifecycleMethods(PreSave.class,entity,dbObject,this);
  return dbObject;
}","/** 
 * <p> Converts an entity (POJO) to a DBObject (for use with low-level driver); A special field will be added to keep track of the class:   {@link Mapper.CLASS_NAME_FIELDNAME} </p>
 * @param entity The POJO
 * @param involvedObjects A Map of (already converted) POJOs
 */
public DBObject toDBObject(Object entity,Map<Object,DBObject> involvedObjects){
  BasicDBObject dbObject=new BasicDBObject();
  MappedClass mc=getMappedClass(entity);
  if (mc.getEntityAnnotation() == null || !mc.getEntityAnnotation().noClassnameStored())   dbObject.put(CLASS_NAME_FIELDNAME,entity.getClass().getName());
  dbObject=(BasicDBObject)mc.callLifecycleMethods(PrePersist.class,entity,dbObject,this);
  for (  MappedField mf : mc.getPersistenceFields()) {
    try {
      Class<? extends Annotation> annType=null;
      if (mf.hasAnnotation(NotSaved.class))       continue;
      for (      Class<? extends Annotation> testType : new Class[]{Id.class,Property.class,Embedded.class,Serialized.class,Reference.class}) {
        if (mf.hasAnnotation(testType)) {
          annType=testType;
          break;
        }
      }
      if (Id.class.equals(annType)) {
        Object idVal=mf.getFieldValue(entity);
        if (idVal != null) {
          if (!mf.isTypeMongoCompatible() && !converters.hasSimpleValueConverter(mf)) {
            opts.embeddedMapper.toDBObject(entity,mf,dbObject,involvedObjects,this);
          }
 else {
            Object dbVal=converters.encode(idVal);
            dbObject.put(ID_KEY,dbVal);
          }
        }
      }
 else       if (Property.class.equals(annType) || Serialized.class.equals(annType) || mf.isTypeMongoCompatible()|| (converters.hasSimpleValueConverter(mf)))       opts.valueMapper.toDBObject(entity,mf,dbObject,involvedObjects,this);
 else       if (Reference.class.equals(annType))       opts.referenceMapper.toDBObject(entity,mf,dbObject,involvedObjects,this);
 else       if (Embedded.class.equals(annType)) {
        opts.embeddedMapper.toDBObject(entity,mf,dbObject,involvedObjects,this);
      }
 else {
        logger.debug(""String_Node_Str"" + opts.defaultMapper + ""String_Node_Str""+ mf);
        opts.defaultMapper.toDBObject(entity,mf,dbObject,involvedObjects,this);
      }
    }
 catch (    Exception e) {
      throw new MappingException(""String_Node_Str"" + mf.getFullName(),e);
    }
  }
  if (involvedObjects != null)   involvedObjects.put(entity,dbObject);
  mc.callLifecycleMethods(PreSave.class,entity,dbObject,this);
  return dbObject;
}",0.9888821507984638
104846,"@Override public Object decode(Class targetClass,Object val,MappedField optionalExtraInfo) throws MappingException {
  Object dbValue=val;
  if (dbValue instanceof Boolean) {
    return (Boolean)val;
  }
  String sVal=val.toString();
  return Boolean.parseBoolean(sVal);
}","@Override public Object decode(Class targetClass,Object val,MappedField optionalExtraInfo) throws MappingException {
  if (val == null)   return null;
  if (val instanceof Boolean)   return (Boolean)val;
  String sVal=val.toString();
  return Boolean.parseBoolean(sVal);
}",0.4779411764705882
104847,"@Override public Object decode(Class targetClass,Object val,MappedField optionalExtraInfo) throws MappingException {
  if (val instanceof Number)   return ((Number)val).byteValue();
  String sVal=val.toString();
  return Byte.parseByte(sVal);
}","@Override public Object decode(Class targetClass,Object val,MappedField optionalExtraInfo) throws MappingException {
  if (val == null)   return null;
  if (val instanceof Number)   return ((Number)val).byteValue();
  String sVal=val.toString();
  return Byte.parseByte(sVal);
}",0.9348659003831418
104848,"@Override public Object decode(Class targetClass,Object fromDBObject,MappedField optionalExtraInfo) throws MappingException {
  return fromDBObject.toString().toCharArray();
}","@Override public Object decode(Class targetClass,Object fromDBObject,MappedField optionalExtraInfo) throws MappingException {
  if (fromDBObject == null)   return null;
  return fromDBObject.toString().toCharArray();
}",0.8549618320610687
104849,"@Override public Object decode(Class targetClass,Object fromDBObject,MappedField optionalExtraInfo) throws MappingException {
  return fromDBObject.toString().charAt(0);
}","@Override public Object decode(Class targetClass,Object fromDBObject,MappedField optionalExtraInfo) throws MappingException {
  if (fromDBObject == null)   return null;
  return fromDBObject.toString().charAt(0);
}",0.8519480519480519
104850,"@Override public Object decode(Class targetClass,Object fromDBObject,MappedField optionalExtraInfo) throws MappingException {
  if (fromDBObject == null) {
    return null;
  }
  String l=fromDBObject.toString();
  try {
    return Class.forName(l);
  }
 catch (  ClassNotFoundException e) {
    throw new MappingException(""String_Node_Str"" + l + ""String_Node_Str"",e);
  }
}","@Override public Object decode(Class targetClass,Object fromDBObject,MappedField optionalExtraInfo) throws MappingException {
  if (fromDBObject == null)   return null;
  String l=fromDBObject.toString();
  try {
    return Class.forName(l);
  }
 catch (  ClassNotFoundException e) {
    throw new MappingException(""String_Node_Str"" + l + ""String_Node_Str"",e);
  }
}",0.9891891891891892
104851,"@SuppressWarnings(""String_Node_Str"") @Override public Object decode(Class targetClass,Object val,MappedField optionalExtraInfo) throws MappingException {
  if (val instanceof Date) {
    return val;
  }
  return new Date(Date.parse(val.toString()));
}","@SuppressWarnings(""String_Node_Str"") @Override public Object decode(Class targetClass,Object val,MappedField optionalExtraInfo) throws MappingException {
  if (val == null)   return null;
  if (val instanceof Date)   return val;
  return new Date(Date.parse(val.toString()));
}",0.75
104852,"@Override public Object decode(Class targetClass,Object val,MappedField optionalExtraInfo) throws MappingException {
  if (val instanceof Double) {
    return (Double)val;
  }
  if (val instanceof Number) {
    return ((Number)val).doubleValue();
  }
  String sVal=val.toString();
  return Double.parseDouble(sVal);
}","@Override public Object decode(Class targetClass,Object val,MappedField optionalExtraInfo) throws MappingException {
  if (val == null)   return null;
  if (val instanceof Double)   return (Double)val;
  if (val instanceof Number)   return ((Number)val).doubleValue();
  String sVal=val.toString();
  return Double.parseDouble(sVal);
}",0.5245398773006135
104853,"@Override public Object decode(Class targetClass,Object fromDBObject,MappedField optionalExtraInfo) throws MappingException {
  return Enum.valueOf(targetClass,fromDBObject.toString());
}","@Override public Object decode(Class targetClass,Object fromDBObject,MappedField optionalExtraInfo) throws MappingException {
  if (fromDBObject == null)   return null;
  return Enum.valueOf(targetClass,fromDBObject.toString());
}",0.8968824940047961
104854,"@Override public Object decode(Class targetClass,Object val,MappedField optionalExtraInfo) throws MappingException {
  if (val instanceof Float)   return val;
  if (val instanceof Number) {
    return ((Number)val).floatValue();
  }
  String sVal=val.toString();
  return Float.parseFloat(sVal);
}","@Override public Object decode(Class targetClass,Object val,MappedField optionalExtraInfo) throws MappingException {
  if (val == null)   return null;
  if (val instanceof Float)   return val;
  if (val instanceof Number) {
    return ((Number)val).floatValue();
  }
  String sVal=val.toString();
  return Float.parseFloat(sVal);
}",0.945859872611465
104855,"@Override public Object decode(Class targetClass,Object val,MappedField optionalExtraInfo) throws MappingException {
  if (val instanceof Integer)   return val;
  if (val instanceof Number)   return ((Number)val).intValue();
 else   return Integer.parseInt(val.toString());
}","@Override public Object decode(Class targetClass,Object val,MappedField optionalExtraInfo) throws MappingException {
  if (val == null)   return null;
  if (val instanceof Integer)   return val;
  if (val instanceof Number)   return ((Number)val).intValue();
 else   return Integer.parseInt(val.toString());
}",0.9417808219178082
104856,"@SuppressWarnings(""String_Node_Str"") @Override public Object decode(Class targetClass,Object fromDBObject,MappedField mf) throws MappingException {
  if (mf == null)   return fromDBObject;
  if (fromDBObject == null)   return null;
  Class subtypeDest=mf.getSubType();
  Collection vals=null;
  if (fromDBObject.getClass().isArray()) {
    vals=new ArrayList();
    for (    Object o : (Object[])fromDBObject)     vals.add(chain.decode((subtypeDest != null) ? subtypeDest : o.getClass(),o));
  }
 else   if (fromDBObject instanceof Iterable) {
    vals=createNewCollection(mf);
    for (    Object o : (Iterable)fromDBObject)     vals.add(chain.decode((subtypeDest != null) ? subtypeDest : o.getClass(),o));
  }
  if (mf.getType().isArray()) {
    Object[] retArray=ReflectionUtils.convertToArray(subtypeDest,(ArrayList)vals);
    return retArray;
  }
 else   return vals;
}","@SuppressWarnings(""String_Node_Str"") @Override public Object decode(Class targetClass,Object fromDBObject,MappedField mf) throws MappingException {
  if (mf == null || fromDBObject == null)   return fromDBObject;
  Class subtypeDest=mf.getSubType();
  Collection vals=null;
  if (fromDBObject.getClass().isArray()) {
    vals=new ArrayList();
    for (    Object o : (Object[])fromDBObject)     vals.add(chain.decode((subtypeDest != null) ? subtypeDest : o.getClass(),o));
  }
 else   if (fromDBObject instanceof Iterable) {
    vals=createNewCollection(mf);
    for (    Object o : (Iterable)fromDBObject)     vals.add(chain.decode((subtypeDest != null) ? subtypeDest : o.getClass(),o));
  }
  if (mf.getType().isArray()) {
    Object[] retArray=ReflectionUtils.convertToArray(subtypeDest,(ArrayList)vals);
    return retArray;
  }
 else   return vals;
}",0.9635627530364372
104857,"@Override public Object decode(Class targetClass,Object o,MappedField optionalExtraInfo) throws MappingException {
  return new Key((DBRef)o);
}","@Override public Object decode(Class targetClass,Object o,MappedField optionalExtraInfo) throws MappingException {
  if (o == null)   return null;
  return new Key((DBRef)o);
}",0.9
104858,"@Override public Object encode(Object value,MappedField optionalExtraInfo){
  if (value == null)   return null;
  return value.toString();
}","@Override public Object encode(Object val,MappedField optionalExtraInfo){
  if (val == null)   return null;
  return val.toString();
}",0.978102189781022
104859,"@Override public Object decode(Class targetClass,Object val,MappedField optionalExtraInfo) throws MappingException {
  if (val instanceof Number)   return ((Number)val).longValue();
 else   return Long.parseLong(val.toString());
}","@Override public Object decode(Class targetClass,Object val,MappedField optionalExtraInfo) throws MappingException {
  if (val == null)   return null;
  if (val instanceof Number)   return ((Number)val).longValue();
 else   return Long.parseLong(val.toString());
}",0.931174089068826
104860,"@Override public Object decode(Class targetClass,Object fromDBObject,MappedField f) throws MappingException {
  Map<Object,Object> map=(Map<Object,Object>)fromDBObject;
  Map values=(Map)ReflectionUtils.newInstance(f.getCTor(),HashMap.class);
  for (  Map.Entry<Object,Object> entry : map.entrySet()) {
    Object objKey=converters.decode(f.getMapKeyType(),entry.getKey());
    values.put(objKey,converters.decode(f.getSubType(),entry.getValue()));
  }
  return values;
}","@Override public Object decode(Class targetClass,Object fromDBObject,MappedField f) throws MappingException {
  if (fromDBObject == null)   return null;
  Map<Object,Object> map=(Map<Object,Object>)fromDBObject;
  Map values=(Map)ReflectionUtils.newInstance(f.getCTor(),HashMap.class);
  for (  Map.Entry<Object,Object> entry : map.entrySet()) {
    Object objKey=converters.decode(f.getMapKeyType(),entry.getKey());
    values.put(objKey,converters.decode(f.getSubType(),entry.getValue()));
  }
  return values;
}",0.8690355329949239
104861,"@Override public Object decode(Class targetClass,Object fromDBObject,MappedField f) throws MappingException {
  if (!((fromDBObject instanceof Binary) || (fromDBObject instanceof byte[]))) {
    throw new MappingException(""String_Node_Str"" + f.getFullName() + ""String_Node_Str""+ fromDBObject.getClass().getName());
  }
  try {
    boolean useCompression=!f.getAnnotation(Serialized.class).disableCompression();
    return Serializer.deserialize(fromDBObject,useCompression);
  }
 catch (  IOException e) {
    throw new MappingException(""String_Node_Str"" + f.getFullName(),e);
  }
catch (  ClassNotFoundException e) {
    throw new MappingException(""String_Node_Str"" + f.getFullName(),e);
  }
}","@Override public Object decode(Class targetClass,Object fromDBObject,MappedField f) throws MappingException {
  if (fromDBObject == null)   return null;
  if (!((fromDBObject instanceof Binary) || (fromDBObject instanceof byte[]))) {
    throw new MappingException(""String_Node_Str"" + f.getFullName() + ""String_Node_Str""+ fromDBObject.getClass().getName());
  }
  try {
    boolean useCompression=!f.getAnnotation(Serialized.class).disableCompression();
    return Serializer.deserialize(fromDBObject,useCompression);
  }
 catch (  IOException e) {
    throw new MappingException(""String_Node_Str"" + f.getFullName(),e);
  }
catch (  ClassNotFoundException e) {
    throw new MappingException(""String_Node_Str"" + f.getFullName(),e);
  }
}",0.96575821104123
104862,"@Override public Object decode(Class targetClass,Object val,MappedField optionalExtraInfo) throws MappingException {
  Object dbValue=val;
  if (dbValue instanceof Number)   return ((Number)dbValue).shortValue();
  String sVal=val.toString();
  return Short.parseShort(sVal);
}","@Override public Object decode(Class targetClass,Object val,MappedField optionalExtraInfo) throws MappingException {
  if (val == null)   return null;
  Object dbValue=val;
  if (dbValue instanceof Number)   return ((Number)dbValue).shortValue();
  String sVal=val.toString();
  return Short.parseShort(sVal);
}",0.9421768707482994
104863,"@Override public Object decode(Class targetClass,Object fromDBObject,MappedField optionalExtraInfo) throws MappingException {
  if (fromDBObject instanceof String) {
    return (String)fromDBObject;
  }
  return fromDBObject.toString();
}","@Override public Object decode(Class targetClass,Object fromDBObject,MappedField optionalExtraInfo) throws MappingException {
  if (fromDBObject == null)   return null;
  if (fromDBObject instanceof String)   return (String)fromDBObject;
  return fromDBObject.toString();
}",0.7749510763209393
104864,"public UpdateOperations<T> add(String fieldExpr,Object value,boolean addDups){
  Object dbObj=mapr.toMongoObject(value);
  add((addDups) ? ""String_Node_Str"" : ""String_Node_Str"",fieldExpr,dbObj);
  return this;
}","public UpdateOperations<T> add(String fieldExpr,Object value,boolean addDups){
  if (value == null)   throw new QueryException(""String_Node_Str"");
  Object dbObj=mapr.toMongoObject(value);
  add((addDups) ? ""String_Node_Str"" : ""String_Node_Str"",fieldExpr,dbObj);
  return this;
}",0.8612244897959184
104865,"public UpdateOperations<T> set(String fieldExpr,Object value){
  Object dbObj=mapr.toMongoObject(value);
  add(""String_Node_Str"",fieldExpr,dbObj);
  return this;
}","public UpdateOperations<T> set(String fieldExpr,Object value){
  if (value == null)   throw new QueryException(""String_Node_Str"");
  Object dbObj=mapr.toMongoObject(value);
  add(""String_Node_Str"",fieldExpr,dbObj);
  return this;
}",0.8274111675126904
104866,"public UpdateOperations<T> removeAll(String fieldExpr,List<?> values){
  List<Object> vals=toDBObjList(values);
  add(""String_Node_Str"",fieldExpr,vals);
  return this;
}","public UpdateOperations<T> removeAll(String fieldExpr,List<?> values){
  if (values == null || values.isEmpty())   throw new QueryException(""String_Node_Str"");
  List<Object> vals=toDBObjList(values);
  add(""String_Node_Str"",fieldExpr,vals);
  return this;
}",0.7915690866510539
104867,"public UpdateOperations<T> addAll(String fieldExpr,List<?> values,boolean addDups){
  List<?> convertedValues=(List<?>)mapr.toMongoObject(values);
  if (addDups)   add(""String_Node_Str"",fieldExpr,convertedValues);
 else   add(""String_Node_Str"",fieldExpr,new BasicDBObject(""String_Node_Str"",convertedValues));
  return this;
}","public UpdateOperations<T> addAll(String fieldExpr,List<?> values,boolean addDups){
  if (values == null || values.isEmpty())   throw new QueryException(""String_Node_Str"");
  List<?> convertedValues=(List<?>)mapr.toMongoObject(values);
  if (addDups)   add(""String_Node_Str"",fieldExpr,convertedValues);
 else   add(""String_Node_Str"",fieldExpr,new BasicDBObject(""String_Node_Str"",convertedValues));
  return this;
}",0.8795669824086604
104868,"public UpdateOperations<T> inc(String fieldExpr,Number value){
  add(""String_Node_Str"",fieldExpr,value);
  return this;
}","public UpdateOperations<T> inc(String fieldExpr,Number value){
  if (value == null)   throw new QueryException(""String_Node_Str"");
  add(""String_Node_Str"",fieldExpr,value);
  return this;
}",0.7806451612903226
104869,"public Query<T> hasThisOne(Object val){
  Assert.parametersNotNull(""String_Node_Str"",val);
  query.filter(fieldExpr + ""String_Node_Str"",val);
  return query;
}","public Query<T> hasThisOne(Object val){
  query.filter(fieldExpr + ""String_Node_Str"",val);
  return query;
}",0.8089887640449438
104870,"/** 
 * Validate the path, and value type, returning the mappedfield for the field at the path 
 */
private MappedField validate(String prop,Object value){
  String[] parts=prop.split(""String_Node_Str"");
  if (this.clazz == null)   return null;
  MappedClass mc=ds.getMapper().getMappedClass(this.clazz);
  MappedField mf;
  for (int i=0; ; ) {
    String part=parts[i];
    mf=mc.getMappedField(part);
    if (mf == null) {
      mf=mc.getMappedFieldByJavaField(part);
      if (mf != null)       throw new MappingException(""String_Node_Str"" + part + ""String_Node_Str""+ mf.getNameToStore()+ ""String_Node_Str""+ this.clazz.getName()+ ""String_Node_Str""+ ""String_Node_Str""+ prop+ ""String_Node_Str""+ mf.getNameToStore()+ ""String_Node_Str"");
 else       throw new MappingException(""String_Node_Str"" + part + ""String_Node_Str""+ this.clazz.getName()+ ""String_Node_Str""+ prop);
    }
    i++;
    if (mf.isMap()) {
      i++;
    }
    if (i >= parts.length)     break;
    mc=ds.getMapper().getMappedClass((mf.isSingleValue()) ? mf.getType() : mf.getSubType());
  }
  if ((mf.isSingleValue() && !isCompatibleForQuery(mf.getType(),value)) || ((mf.isMultipleValues() && !isCompatibleForQuery(mf.getSubType(),value)))) {
    Throwable t=new Throwable();
    log.warning(""String_Node_Str"" + value.getClass().getName() + ""String_Node_Str""+ mf.getDeclaringClass().getName()+ ""String_Node_Str""+ mf.getJavaFieldName()+ ""String_Node_Str""+ mf.getType().getName());
    log.debug(""String_Node_Str"",t);
  }
  return mf;
}","/** 
 * Validate the path, and value type, returning the mappedfield for the field at the path 
 */
private MappedField validate(String prop,Object value){
  String[] parts=prop.split(""String_Node_Str"");
  if (this.clazz == null)   return null;
  MappedClass mc=ds.getMapper().getMappedClass(this.clazz);
  MappedField mf;
  for (int i=0; ; ) {
    String part=parts[i];
    mf=mc.getMappedField(part);
    if (mf == null) {
      mf=mc.getMappedFieldByJavaField(part);
      if (mf != null)       throw new MappingException(""String_Node_Str"" + part + ""String_Node_Str""+ mf.getNameToStore()+ ""String_Node_Str""+ this.clazz.getName()+ ""String_Node_Str""+ ""String_Node_Str""+ prop+ ""String_Node_Str""+ mf.getNameToStore()+ ""String_Node_Str"");
 else       throw new MappingException(""String_Node_Str"" + part + ""String_Node_Str""+ this.clazz.getName()+ ""String_Node_Str""+ prop);
    }
    i++;
    if (mf.isMap()) {
      i++;
    }
    if (i < parts.length && !canQueryPast(mf))     throw new MappingException(""String_Node_Str"" + part + ""String_Node_Str""+ this.clazz.getName()+ ""String_Node_Str""+ prop);
    if (i >= parts.length)     break;
    mc=ds.getMapper().getMappedClass((mf.isSingleValue()) ? mf.getType() : mf.getSubType());
  }
  if ((mf.isSingleValue() && !isCompatibleForQuery(mf.getType(),value)) || ((mf.isMultipleValues() && !isCompatibleForQuery(mf.getSubType(),value)))) {
    Throwable t=new Throwable();
    log.warning(""String_Node_Str"" + value.getClass().getName() + ""String_Node_Str""+ mf.getDeclaringClass().getName()+ ""String_Node_Str""+ mf.getJavaFieldName()+ ""String_Node_Str""+ mf.getType().getName());
    log.debug(""String_Node_Str"",t);
  }
  return mf;
}",0.9458438287153652
104871,"public Query<T> notEqual(Object val){
  Assert.parametersNotNull(""String_Node_Str"",val);
  query.filter(fieldExpr + ""String_Node_Str"",val);
  return query;
}","public Query<T> notEqual(Object val){
  query.filter(fieldExpr + ""String_Node_Str"",val);
  return query;
}",0.8060836501901141
104872,"public Query<T> equal(Object val){
  Assert.parametersNotNull(""String_Node_Str"",val);
  query.filter(fieldExpr + ""String_Node_Str"",val);
  return query;
}","public Query<T> equal(Object val){
  query.filter(fieldExpr + ""String_Node_Str"",val);
  return query;
}",0.8015564202334631
104873,"@Test public void testQueryOverReference() throws Exception {
  ContainsPic cpk=new ContainsPic();
  Pic p=new Pic();
  ds.save(p);
  cpk.pic=p;
  ds.save(cpk);
  Query<ContainsPic> query=ds.createQuery(ContainsPic.class);
  assertEquals(1,query.field(""String_Node_Str"").equal(p).asList().size());
}","@Test public void testQueryOverReference() throws Exception {
  ContainsPic cpk=new ContainsPic();
  Pic p=new Pic();
  ds.save(p);
  cpk.pic=p;
  ds.save(cpk);
  Query<ContainsPic> query=ds.createQuery(ContainsPic.class);
  assertEquals(1,query.field(""String_Node_Str"").equal(p).asList().size());
  try {
    ds.find(ContainsPic.class,""String_Node_Str"",""String_Node_Str"").get();
    assertNull(""String_Node_Str"");
  }
 catch (  MappingException e) {
  }
}",0.7920529801324503
104874,"@Test public void testReferenceQuery() throws Exception {
  Photo p=new Photo();
  ContainsPhotoKey cpk=new ContainsPhotoKey();
  cpk.photo=ds.save(p);
  ds.save(cpk);
  assertNotNull(ds.find(ContainsPhotoKey.class,""String_Node_Str"",p).get());
  assertNotNull(ds.find(ContainsPhotoKey.class,""String_Node_Str"",cpk.photo).get());
  assertNull(ds.find(ContainsPhotoKey.class,""String_Node_Str"",1).get());
}","@Test public void testReferenceQuery() throws Exception {
  Photo p=new Photo();
  ContainsPhotoKey cpk=new ContainsPhotoKey();
  cpk.photo=ds.save(p);
  ds.save(cpk);
  assertNotNull(ds.find(ContainsPhotoKey.class,""String_Node_Str"",p).get());
  assertNotNull(ds.find(ContainsPhotoKey.class,""String_Node_Str"",cpk.photo).get());
  assertNull(ds.find(ContainsPhotoKey.class,""String_Node_Str"",1).get());
  try {
    ds.find(ContainsPhotoKey.class,""String_Node_Str"",""String_Node_Str"").get();
    assertNull(""String_Node_Str"");
  }
 catch (  MappingException e) {
  }
}",0.8322981366459627
104875,"boolean exists(Class c,final DBRef dbRef){
  Datastore ds=mapper.datastoreProvider.get();
  return ds.createQuery(c).filter(Mapper.ID_KEY,dbRef.getId()).countAll() == 1;
}","boolean exists(Class c,final DBRef dbRef){
  Datastore ds=mapper.datastoreProvider.get();
  return dbRef.fetch() != null;
}",0.7891156462585034
104876,"@Test @Ignore public void testLoadingOfRefThroughInheritanceInField() throws Exception {
  morphia.map(ContainerWithRefInField.class);
  morphia.map(OtherEntityChild.class);
  OtherEntityChild otherEntity=new OtherEntityChild();
  ContainerWithRefInField containerWithRefInField=new ContainerWithRefInField();
  ds.save(otherEntity,containerWithRefInField);
  otherEntity=ds.get(otherEntity);
  final ContainerWithRefInField reload=ds.get(containerWithRefInField);
  Assert.assertNotNull(otherEntity);
  Assert.assertNotNull(reload);
  EmbedWithRef embedWithRef=new EmbedWithRef();
  embedWithRef.otherEntity=otherEntity;
  reload.embedWithRef=embedWithRef;
  ds.save(reload);
  ds.get(reload);
  containerWithRefInField=ds.get(containerWithRefInField);
  Assert.assertNotNull(containerWithRefInField);
}","@Test public void testLoadingOfRefThroughInheritanceInField() throws Exception {
  morphia.map(ContainerWithRefInField.class);
  morphia.map(OtherEntityChild.class);
  OtherEntityChild otherEntity=new OtherEntityChild();
  ContainerWithRefInField containerWithRefInField=new ContainerWithRefInField();
  ds.save(otherEntity,containerWithRefInField);
  otherEntity=ds.get(otherEntity);
  final ContainerWithRefInField reload=ds.get(containerWithRefInField);
  Assert.assertNotNull(otherEntity);
  Assert.assertNotNull(reload);
  EmbedWithRef embedWithRef=new EmbedWithRef();
  embedWithRef.otherEntity=otherEntity;
  reload.embedWithRef=embedWithRef;
  ds.save(reload);
  ds.get(reload);
  containerWithRefInField=ds.get(containerWithRefInField);
  Assert.assertNotNull(containerWithRefInField);
}",0.995
104877,"@Test @Ignore public void testLoadingOfRefThroughInheritanceInList() throws Exception {
  morphia.map(ContainerWithRefList.class);
  morphia.map(OtherEntityChild.class);
  OtherEntityChild otherEntity=new OtherEntityChild();
  ContainerWithRefList containerWithRefInList=new ContainerWithRefList();
  ds.save(otherEntity,containerWithRefInList);
  otherEntity=ds.get(otherEntity);
  final ContainerWithRefList reload=ds.get(containerWithRefInList);
  Assert.assertNotNull(otherEntity);
  Assert.assertNotNull(reload);
  EmbedWithRef embedWithRef=new EmbedWithRef();
  embedWithRef.otherEntity=otherEntity;
  reload.embedWithRef.add(embedWithRef);
  ds.save(otherEntity,reload);
  ds.get(reload);
  containerWithRefInList=ds.get(reload);
  Assert.assertNotNull(containerWithRefInList);
  Query<ContainerWithRefList> createQuery=ds.createQuery(ContainerWithRefList.class);
  containerWithRefInList=createQuery.get();
  Assert.assertNotNull(containerWithRefInList);
}","@Test public void testLoadingOfRefThroughInheritanceInList() throws Exception {
  morphia.map(ContainerWithRefList.class);
  morphia.map(OtherEntityChild.class);
  OtherEntityChild otherEntity=new OtherEntityChild();
  ContainerWithRefList containerWithRefInList=new ContainerWithRefList();
  ds.save(otherEntity,containerWithRefInList);
  otherEntity=ds.get(otherEntity);
  final ContainerWithRefList reload=ds.get(containerWithRefInList);
  Assert.assertNotNull(otherEntity);
  Assert.assertNotNull(reload);
  EmbedWithRef embedWithRef=new EmbedWithRef();
  embedWithRef.otherEntity=otherEntity;
  reload.embedWithRef.add(embedWithRef);
  ds.save(otherEntity,reload);
  ds.get(reload);
  containerWithRefInList=ds.get(reload);
  Assert.assertNotNull(containerWithRefInList);
  Query<ContainerWithRefList> createQuery=ds.createQuery(ContainerWithRefList.class);
  containerWithRefInList=createQuery.get();
  Assert.assertNotNull(containerWithRefInList);
}",0.9958333333333332
104878,"@Test @Ignore public void testLoadingOfRefInList() throws Exception {
  morphia.map(ContainerWithRefList.class);
  morphia.map(OtherEntity.class);
  OtherEntity otherEntity=new OtherEntity();
  ContainerWithRefList containerWithRefInList=new ContainerWithRefList();
  ds.save(otherEntity,containerWithRefInList);
  otherEntity=ds.get(otherEntity);
  containerWithRefInList=ds.get(containerWithRefInList);
  Assert.assertNotNull(otherEntity);
  Assert.assertNotNull(containerWithRefInList);
  EmbedWithRef embedWithRef=new EmbedWithRef();
  embedWithRef.otherEntity=otherEntity;
  containerWithRefInList.embedWithRef.add(embedWithRef);
  ds.save(otherEntity,containerWithRefInList);
  containerWithRefInList=ds.get(containerWithRefInList);
  Assert.assertNotNull(containerWithRefInList);
  Query<ContainerWithRefList> createQuery=ds.createQuery(ContainerWithRefList.class);
  containerWithRefInList=createQuery.get();
  Assert.assertNotNull(containerWithRefInList);
}","@Test public void testLoadingOfRefInList() throws Exception {
  morphia.map(ContainerWithRefList.class);
  morphia.map(OtherEntity.class);
  OtherEntity otherEntity=new OtherEntity();
  ContainerWithRefList containerWithRefInList=new ContainerWithRefList();
  ds.save(otherEntity,containerWithRefInList);
  otherEntity=ds.get(otherEntity);
  containerWithRefInList=ds.get(containerWithRefInList);
  Assert.assertNotNull(otherEntity);
  Assert.assertNotNull(containerWithRefInList);
  EmbedWithRef embedWithRef=new EmbedWithRef();
  embedWithRef.otherEntity=otherEntity;
  containerWithRefInList.embedWithRef.add(embedWithRef);
  ds.save(otherEntity,containerWithRefInList);
  containerWithRefInList=ds.get(containerWithRefInList);
  Assert.assertNotNull(containerWithRefInList);
  Query<ContainerWithRefList> createQuery=ds.createQuery(ContainerWithRefList.class);
  containerWithRefInList=createQuery.get();
  Assert.assertNotNull(containerWithRefInList);
}",0.9958419958419958
104879,"private <T>void postSaveOperations(Object entity,DBObject dbObj,DBCollection dbColl,LinkedHashMap<Object,DBObject> involvedObjects){
  Mapper mapr=morphia.getMapper();
  MappedClass mc=mapr.getMappedClass(entity);
  mapr.updateKeyInfo(entity,dbObj.get(Mapper.ID_KEY));
  firePostPersistForChildren(involvedObjects,mapr);
  mc.callLifecycleMethods(PostPersist.class,entity,dbObj,mapr);
}","private <T>void postSaveOperations(Object entity,DBObject dbObj,DBCollection dbColl,LinkedHashMap<Object,DBObject> involvedObjects){
  Mapper mapr=morphia.getMapper();
  MappedClass mc=mapr.getMappedClass(entity);
  mapr.updateKeyInfo(entity,dbObj);
  firePostPersistForChildren(involvedObjects,mapr);
  mc.callLifecycleMethods(PostPersist.class,entity,dbObj,mapr);
}",0.9747675962815404
104880,"/** 
 * Returns the name of the field's key-name for mongodb
 */
private String getMappedFieldName(){
  if (hasAnnotation(Property.class)) {
    Property mv=(Property)mappingAnnotations.get(Property.class);
    if (!mv.value().equals(Mapper.IGNORED_FIELDNAME))     return mv.value();
  }
 else   if (hasAnnotation(Reference.class)) {
    Reference mr=(Reference)mappingAnnotations.get(Reference.class);
    if (!mr.value().equals(Mapper.IGNORED_FIELDNAME))     return mr.value();
  }
 else   if (hasAnnotation(Embedded.class)) {
    Embedded me=(Embedded)mappingAnnotations.get(Embedded.class);
    if (!me.value().equals(Mapper.IGNORED_FIELDNAME))     return me.value();
  }
 else   if (hasAnnotation(Serialized.class)) {
    Serialized me=(Serialized)mappingAnnotations.get(Serialized.class);
    if (!me.value().equals(Mapper.IGNORED_FIELDNAME))     return me.value();
  }
  return this.field.getName();
}","/** 
 * Returns the name of the field's key-name for mongodb
 */
private String getMappedFieldName(){
  if (hasAnnotation(Property.class)) {
    Property mv=(Property)mappingAnnotations.get(Property.class);
    if (!mv.value().equals(Mapper.IGNORED_FIELDNAME))     return mv.value();
  }
 else   if (hasAnnotation(Reference.class)) {
    Reference mr=(Reference)mappingAnnotations.get(Reference.class);
    if (!mr.value().equals(Mapper.IGNORED_FIELDNAME))     return mr.value();
  }
 else   if (hasAnnotation(Embedded.class)) {
    Embedded me=(Embedded)mappingAnnotations.get(Embedded.class);
    if (!me.value().equals(Mapper.IGNORED_FIELDNAME))     return me.value();
  }
 else   if (hasAnnotation(Serialized.class)) {
    Serialized me=(Serialized)mappingAnnotations.get(Serialized.class);
    if (!me.value().equals(Mapper.IGNORED_FIELDNAME))     return me.value();
  }
 else   if (hasAnnotation(Id.class))   return Mapper.ID_KEY;
  return this.field.getName();
}",0.9579115610015982
104881,"Object fromDb(DBObject dbObject,final Object entity,Map<Key,Object> retrieved){
  if (dbObject.containsField(ID_KEY) && getMappedClass(entity).getIdField() != null) {
    Key key=new Key(entity.getClass(),dbObject.get(ID_KEY));
    Object cachedInstance=retrieved.get(key);
    if (cachedInstance != null)     return cachedInstance;
 else     retrieved.put(key,entity);
  }
  MappedClass mc=getMappedClass(entity);
  dbObject=(BasicDBObject)mc.callLifecycleMethods(PreLoad.class,entity,dbObject,this);
  try {
    for (    MappedField mf : mc.getPersistenceFields()) {
      if (mf.hasAnnotation(Id.class)) {
        if (dbObject.get(ID_KEY) != null) {
          mf.setFieldValue(entity,converters.decode(mf.getType(),dbObject.get(ID_KEY)));
        }
      }
 else       if (mf.hasAnnotation(Property.class) || mf.hasAnnotation(Serialized.class) || mf.isTypeMongoCompatible()|| converters.hasSimpleValueConverter(mf))       valueMapper.fromDBObject(dbObject,mf,entity);
 else       if (mf.hasAnnotation(Embedded.class))       embeddedMapper.fromDBObject(dbObject,mf,entity,retrieved);
 else       if (mf.hasAnnotation(Reference.class))       referenceMapper.fromDBObject(dbObject,mf,entity,retrieved);
 else {
        embeddedMapper.fromDBObject(dbObject,mf,entity,retrieved);
      }
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  if (dbObject.containsField(ID_KEY) && getMappedClass(entity).getIdField() != null) {
    String id=dbObject.get(ID_KEY).toString();
    Key key=new Key(entity.getClass(),id);
    retrieved.put(key,entity);
  }
  mc.callLifecycleMethods(PostLoad.class,entity,dbObject,this);
  return entity;
}","Object fromDb(DBObject dbObject,final Object entity,Map<Key,Object> retrieved){
  if (dbObject.containsField(ID_KEY) && getMappedClass(entity).getIdField() != null) {
    Key key=new Key(entity.getClass(),dbObject.get(ID_KEY));
    Object cachedInstance=retrieved.get(key);
    if (cachedInstance != null)     return cachedInstance;
 else     retrieved.put(key,entity);
  }
  MappedClass mc=getMappedClass(entity);
  dbObject=(BasicDBObject)mc.callLifecycleMethods(PreLoad.class,entity,dbObject,this);
  try {
    for (    MappedField mf : mc.getPersistenceFields()) {
      if (mf.hasAnnotation(Id.class)) {
        setIdValue(entity,mf,dbObject,retrieved);
      }
 else       if (mf.hasAnnotation(Property.class) || mf.hasAnnotation(Serialized.class) || mf.isTypeMongoCompatible()|| converters.hasSimpleValueConverter(mf))       valueMapper.fromDBObject(dbObject,mf,entity);
 else       if (mf.hasAnnotation(Embedded.class))       embeddedMapper.fromDBObject(dbObject,mf,entity,retrieved);
 else       if (mf.hasAnnotation(Reference.class))       referenceMapper.fromDBObject(dbObject,mf,entity,retrieved);
 else {
        embeddedMapper.fromDBObject(dbObject,mf,entity,retrieved);
      }
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  if (dbObject.containsField(ID_KEY) && getMappedClass(entity).getIdField() != null) {
    String id=dbObject.get(ID_KEY).toString();
    Key key=new Key(entity.getClass(),id);
    retrieved.put(key,entity);
  }
  mc.callLifecycleMethods(PostLoad.class,entity,dbObject,this);
  return entity;
}",0.416796267496112
104882,"/** 
 * <p> Updates the @  {@link Id} fields.</p>
 * @param entity The object to update
 * @param rawIdValue Value to update with; null means skip
 */
public void updateKeyInfo(final Object entity,final Object rawIdValue){
  MappedClass mc=getMappedClass(entity);
  if ((mc.getIdField() != null) && (rawIdValue != null)) {
    try {
      Object dbIdValue=converters.decode(mc.getIdField().getType(),rawIdValue);
      Object idValue=mc.getIdField().get(entity);
      if (idValue != null) {
        if (!dbIdValue.equals(idValue)) {
          throw new RuntimeException(""String_Node_Str"" + idValue + ""String_Node_Str""+ dbIdValue+ ""String_Node_Str""+ entity.getClass().getName());
        }
      }
 else {
        mc.getIdField().set(entity,dbIdValue);
      }
    }
 catch (    Exception e) {
      if (e.getClass().equals(RuntimeException.class)) {
        throw (RuntimeException)e;
      }
      throw new RuntimeException(e);
    }
  }
}","/** 
 * <p> Updates the @  {@link Id} fields.</p>
 * @param entity The object to update
 * @param rawIdValue Value to update with; null means skip
 */
public void updateKeyInfo(final Object entity,final DBObject dbObj){
  MappedClass mc=getMappedClass(entity);
  if ((mc.getIdField() != null) && (dbObj != null) && (dbObj.get(ID_KEY) != null)) {
    try {
      MappedField mf=mc.getMappedField(ID_KEY);
      Object oldIdValue=mc.getIdField().get(entity);
      setIdValue(entity,mf,dbObj,new HashMap<Key,Object>());
      Object dbIdValue=mc.getIdField().get(entity);
      if (oldIdValue != null) {
        if (!dbIdValue.equals(oldIdValue)) {
          mf.setFieldValue(entity,oldIdValue);
          throw new RuntimeException(""String_Node_Str"" + oldIdValue + ""String_Node_Str""+ dbIdValue+ ""String_Node_Str""+ entity.getClass().getName());
        }
      }
 else {
        mc.getIdField().set(entity,dbIdValue);
      }
    }
 catch (    Exception e) {
      if (e.getClass().equals(RuntimeException.class)) {
        throw (RuntimeException)e;
      }
      throw new RuntimeException(e);
    }
  }
}",0.7376648754274548
104883,"/** 
 * <p> Converts an entity (POJO) to a DBObject </p>
 */
public DBObject toDBObject(Object entity,final LinkedHashMap<Object,DBObject> involvedObjects){
  entity=ProxyHelper.unwrap(entity);
  BasicDBObject dbObject=new BasicDBObject();
  MappedClass mc=getMappedClass(entity);
  if (mc.getEntityAnnotation() == null || !mc.getEntityAnnotation().noClassnameStored())   dbObject.put(CLASS_NAME_FIELDNAME,entity.getClass().getName());
  dbObject=(BasicDBObject)mc.callLifecycleMethods(PrePersist.class,entity,dbObject,this);
  for (  MappedField mf : mc.getPersistenceFields()) {
    try {
      Class<? extends Annotation> annType=null;
      boolean foundAnnotation=false;
      for (      Class<? extends Annotation> testType : new Class[]{Id.class,Property.class,Embedded.class,Serialized.class,Reference.class})       if (mf.hasAnnotation(testType)) {
        annType=testType;
        foundAnnotation=true;
        break;
      }
      if (Id.class.equals(annType)) {
        Object dbVal=mf.getFieldValue(entity);
        if (dbVal != null)         dbObject.put(ID_KEY,converters.encode(ReflectionUtils.asObjectIdMaybe(dbVal)));
      }
 else       if (Property.class.equals(annType) || Serialized.class.equals(annType) || mf.isTypeMongoCompatible()|| (converters.hasSimpleValueConverter(mf)))       valueMapper.toDBObject(entity,mf,dbObject,opts);
 else       if (Reference.class.equals(annType))       referenceMapper.toDBObject(entity,mf,dbObject,opts);
 else       if (Embedded.class.equals(annType)) {
        embeddedMapper.toDBObject(entity,mf,dbObject,involvedObjects,opts);
      }
 else {
        logger.fine(""String_Node_Str"" + mf);
        embeddedMapper.toDBObject(entity,mf,dbObject,involvedObjects,opts);
      }
    }
 catch (    Exception e) {
      throw new MappingException(""String_Node_Str"" + mf.getFullName(),e);
    }
  }
  if (involvedObjects != null) {
    involvedObjects.put(entity,dbObject);
  }
  mc.callLifecycleMethods(PreSave.class,entity,dbObject,this);
  return dbObject;
}","/** 
 * <p> Converts an entity (POJO) to a DBObject </p>
 */
public DBObject toDBObject(Object entity,final LinkedHashMap<Object,DBObject> involvedObjects){
  entity=ProxyHelper.unwrap(entity);
  BasicDBObject dbObject=new BasicDBObject();
  MappedClass mc=getMappedClass(entity);
  if (mc.getEntityAnnotation() == null || !mc.getEntityAnnotation().noClassnameStored())   dbObject.put(CLASS_NAME_FIELDNAME,entity.getClass().getName());
  dbObject=(BasicDBObject)mc.callLifecycleMethods(PrePersist.class,entity,dbObject,this);
  for (  MappedField mf : mc.getPersistenceFields()) {
    try {
      Class<? extends Annotation> annType=null;
      for (      Class<? extends Annotation> testType : new Class[]{Id.class,Property.class,Embedded.class,Serialized.class,Reference.class})       if (mf.hasAnnotation(testType)) {
        annType=testType;
        break;
      }
      if (Id.class.equals(annType)) {
        Object idVal=mf.getFieldValue(entity);
        if (idVal != null) {
          if (!mf.isTypeMongoCompatible() && !converters.hasSimpleValueConverter(mf)) {
            embeddedMapper.toDBObject(entity,mf,dbObject,involvedObjects,opts);
          }
 else {
            Object dbVal=converters.encode(ReflectionUtils.asObjectIdMaybe(idVal));
            dbObject.put(ID_KEY,dbVal);
          }
        }
      }
 else       if (Property.class.equals(annType) || Serialized.class.equals(annType) || mf.isTypeMongoCompatible()|| (converters.hasSimpleValueConverter(mf)))       valueMapper.toDBObject(entity,mf,dbObject,opts);
 else       if (Reference.class.equals(annType))       referenceMapper.toDBObject(entity,mf,dbObject,opts);
 else       if (Embedded.class.equals(annType)) {
        embeddedMapper.toDBObject(entity,mf,dbObject,involvedObjects,opts);
      }
 else {
        logger.fine(""String_Node_Str"" + mf);
        embeddedMapper.toDBObject(entity,mf,dbObject,involvedObjects,opts);
      }
    }
 catch (    Exception e) {
      throw new MappingException(""String_Node_Str"" + mf.getFullName(),e);
    }
  }
  if (involvedObjects != null) {
    involvedObjects.put(entity,dbObject);
  }
  mc.callLifecycleMethods(PreSave.class,entity,dbObject,this);
  return dbObject;
}",0.8985989076228924
104884,"@Test @Ignore public void SerializableId() throws Exception {
  CustomId cId=new CustomId();
  cId.id=new ObjectId();
  cId.type=""String_Node_Str"";
  UsesCustomIdObject ucio=new UsesCustomIdObject();
  ucio.id=cId;
  ucio.text=""String_Node_Str"";
  this.ds.save(ucio);
}","@Test public void SerializableId() throws Exception {
  CustomId cId=new CustomId();
  cId.id=new ObjectId();
  cId.type=""String_Node_Str"";
  UsesCustomIdObject ucio=new UsesCustomIdObject();
  ucio.id=cId;
  ucio.text=""String_Node_Str"";
  this.ds.save(ucio);
}",0.9849056603773584
104885,"@Override public Query<T> order(String condition){
  sort=BasicDBObjectBuilder.start();
  String[] sorts=condition.split(""String_Node_Str"");
  for (int i=0; i < sorts.length; i++) {
    String s=sorts[i];
    condition=condition.trim();
    int dir=1;
    if (condition.startsWith(""String_Node_Str"")) {
      dir=-1;
      condition=condition.substring(1).trim();
    }
    sort=sort.add(s,dir);
  }
  return this;
}","@Override public Query<T> order(String condition){
  sort=BasicDBObjectBuilder.start();
  String[] sorts=condition.split(""String_Node_Str"");
  for (  String s : sorts) {
    condition=condition.trim();
    int dir=1;
    if (condition.startsWith(""String_Node_Str"")) {
      dir=-1;
      condition=condition.substring(1).trim();
    }
    sort=sort.add(s,dir);
  }
  return this;
}",0.9109159347553324
104886,"@SuppressWarnings(""String_Node_Str"") @Override public Query<T> filter(String condition,Object value){
  String[] parts=condition.trim().split(""String_Node_Str"");
  if (parts.length < 1 || parts.length > 6)   throw new IllegalArgumentException(""String_Node_Str"" + condition + ""String_Node_Str"");
  String prop=parts[0].trim();
  FilterOperator op=(parts.length == 2) ? this.translate(parts[1]) : FilterOperator.EQUAL;
  MappedField mf=null;
  if (validating)   mf=validate(prop,value);
  if (query == null)   query=BasicDBObjectBuilder.start();
  Mapper mapr=ds.getMapper();
  Object mappedValue;
  MappedClass mc=null;
  try {
    if (value != null && !ReflectionUtils.isPropertyType(value.getClass()))     if (mf != null && !mf.isTypeMongoCompatible())     mc=mapr.getMappedClass((mf.isSingleValue()) ? mf.getType() : mf.getSubType());
 else     mc=mapr.getMappedClass(value);
  }
 catch (  Exception e) {
    log.log(Level.FINEST,""String_Node_Str"",e);
  }
  if ((mf != null && (mf.hasAnnotation(Reference.class) || mf.getType().isAssignableFrom(Key.class))) || (mc != null && mc.getEntityAnnotation() != null)) {
    try {
      Key<?> k=(value instanceof Key) ? (Key<?>)value : ds.getKey(value);
      mappedValue=k.toRef(mapr);
    }
 catch (    Exception e) {
      log.log(Level.WARNING,""String_Node_Str"" + value + ""String_Node_Str"",e);
      mappedValue=mapr.toMongoObject(value);
    }
  }
 else   if (mf != null && mf.hasAnnotation(Serialized.class))   try {
    mappedValue=mapr.serialize(value);
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
 else   mappedValue=Mapper.asObjectIdMaybe(mapr.toMongoObject(value));
  Class<?> type=(mappedValue != null) ? mappedValue.getClass() : null;
  if (type != null && (op == FilterOperator.IN || op == FilterOperator.NOT_IN) && !type.isArray() && !ReflectionUtils.implementsAnyInterface(type,Iterable.class,Collection.class,List.class,Set.class,Map.class)) {
    mappedValue=Collections.singletonList(mappedValue);
  }
  if (FilterOperator.EQUAL.equals(op))   query.add(prop,mappedValue);
 else   query.push(prop).add(op.val(),mappedValue);
  return this;
}","@SuppressWarnings(""String_Node_Str"") @Override public Query<T> filter(String condition,Object value){
  String[] parts=condition.trim().split(""String_Node_Str"");
  if (parts.length < 1 || parts.length > 6)   throw new IllegalArgumentException(""String_Node_Str"" + condition + ""String_Node_Str"");
  String prop=parts[0].trim();
  FilterOperator op=(parts.length == 2) ? this.translate(parts[1]) : FilterOperator.EQUAL;
  MappedField mf=null;
  if (validating)   mf=validate(prop,value);
  if (query == null)   query=BasicDBObjectBuilder.start();
  Mapper mapr=ds.getMapper();
  Object mappedValue;
  MappedClass mc=null;
  try {
    if (value != null && !ReflectionUtils.isPropertyType(value.getClass()))     if (mf != null && !mf.isTypeMongoCompatible())     mc=mapr.getMappedClass((mf.isSingleValue()) ? mf.getType() : mf.getSubType());
 else     mc=mapr.getMappedClass(value);
  }
 catch (  Exception e) {
    log.log(Level.FINEST,""String_Node_Str"",e);
  }
  if ((mf != null && (mf.hasAnnotation(Reference.class) || mf.getType().isAssignableFrom(Key.class))) || (mc != null && mc.getEntityAnnotation() != null)) {
    try {
      Key<?> k=(value instanceof Key) ? (Key<?>)value : ds.getKey(value);
      mappedValue=k.toRef(mapr);
    }
 catch (    Exception e) {
      log.log(Level.WARNING,""String_Node_Str"" + value + ""String_Node_Str"",e);
      mappedValue=mapr.toMongoObject(value);
    }
  }
 else   if (mf != null && mf.hasAnnotation(Serialized.class))   try {
    mappedValue=mapr.serialize(value);
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
 else   try {
    mappedValue=Mapper.asObjectIdMaybe(mapr.toMongoObject(value));
  }
 catch (  Exception e) {
    log.log(Level.WARNING,""String_Node_Str"" + value.getClass() + ""String_Node_Str"",e);
    mappedValue=value;
  }
  Class<?> type=(mappedValue != null) ? mappedValue.getClass() : null;
  if (type != null && (op == FilterOperator.IN || op == FilterOperator.NOT_IN) && !type.isArray() && !ReflectionUtils.implementsAnyInterface(type,Iterable.class,Collection.class,List.class,Set.class,Map.class)) {
    mappedValue=Collections.singletonList(mappedValue);
  }
  if (FilterOperator.EQUAL.equals(op))   query.add(prop,mappedValue);
 else   query.push(prop).add(op.val(),mappedValue);
  return this;
}",0.9653297076818492
104887,"@Test public void testSaveAndDelete() throws Exception {
  Rectangle rect=new Rectangle(10,10);
  rect.setId(""String_Node_Str"");
  ds.save(rect);
  assertEquals(1,ds.getCount(rect));
  ds.delete(rect);
  assertEquals(0,ds.getCount(rect));
  ds.save(rect);
  assertEquals(1,ds.getCount(rect));
  ds.delete(rect.getClass(),1);
  assertEquals(1,ds.getCount(rect));
  ds.delete(rect.getClass(),""String_Node_Str"");
  assertEquals(0,ds.getCount(rect));
  ds.save(rect);
  assertEquals(1,ds.getCount(rect));
  List<String> ids=new ArrayList<String>();
  ids.add(""String_Node_Str"");
  ds.delete(rect.getClass(),ids);
  assertEquals(0,ds.getCount(rect));
  rect.setId(""String_Node_Str"");
  ds.save(rect);
  rect.setId(""String_Node_Str"");
  ds.save(rect);
  assertEquals(2,ds.getCount(rect));
  ids.clear();
  ids.add(""String_Node_Str"");
  ids.add(""String_Node_Str"");
  ds.delete(rect.getClass(),ids);
  assertEquals(0,ds.getCount(rect));
  rect.setId(""String_Node_Str"");
  ds.save(rect);
  rect.setId(""String_Node_Str"");
  ds.save(rect);
  assertEquals(2,ds.getCount(rect));
  ids.clear();
  ids.add(""String_Node_Str"");
  ds.delete(rect.getClass(),ids);
  assertEquals(1,ds.getCount(rect));
  rect.setId(""String_Node_Str"");
  ds.save(rect);
  rect.setId(""String_Node_Str"");
  ds.save(rect);
  assertEquals(2,ds.getCount(rect));
  ids.clear();
  ids.add(""String_Node_Str"");
  ds.delete(Rectangle.class,ids);
  assertEquals(1,ds.getCount(rect));
}","@Test public void testSaveAndDelete() throws Exception {
  Rectangle rect=new Rectangle(10,10);
  rect.setId(""String_Node_Str"");
  ds.save(rect);
  assertEquals(1,ds.getCount(rect));
  ds.delete(rect);
  assertEquals(0,ds.getCount(rect));
  ds.save(rect);
  assertEquals(1,ds.getCount(rect));
  ds.delete(rect.getClass(),1);
  assertEquals(1,ds.getCount(rect));
  ds.delete(rect.getClass(),""String_Node_Str"");
  assertEquals(0,ds.getCount(rect));
  ds.save(rect);
  assertEquals(1,ds.getCount(rect));
  List<String> ids=new ArrayList<String>();
  ids.add(""String_Node_Str"");
  ds.delete(rect.getClass(),ids);
  assertEquals(0,ds.getCount(rect));
  rect.setId(""String_Node_Str"");
  ds.save(rect);
  rect.setId(""String_Node_Str"");
  ds.save(rect);
  assertEquals(2,ds.getCount(rect));
  ids.clear();
  ids.add(""String_Node_Str"");
  ids.add(""String_Node_Str"");
  ds.delete(rect.getClass(),ids);
  assertEquals(0,ds.getCount(rect));
  ids.clear();
  rect.setId(null);
  ds.save(rect);
  ids.add(rect.getId());
  rect.setId(null);
  ds.save(rect);
  ids.add(rect.getId());
  assertEquals(""String_Node_Str"",2,ds.getCount(rect));
  ds.delete(rect.getClass(),ids);
  assertEquals(""String_Node_Str"",0,ds.getCount(rect));
  rect.setId(""String_Node_Str"");
  ds.save(rect);
  rect.setId(""String_Node_Str"");
  ds.save(rect);
  assertEquals(2,ds.getCount(rect));
  ids.clear();
  ids.add(""String_Node_Str"");
  ds.delete(rect.getClass(),ids);
  assertEquals(1,ds.getCount(rect));
  rect.setId(""String_Node_Str"");
  ds.save(rect);
  rect.setId(""String_Node_Str"");
  ds.save(rect);
  assertEquals(2,ds.getCount(rect));
  ids.clear();
  ids.add(""String_Node_Str"");
  ds.delete(Rectangle.class,ids);
  assertEquals(1,ds.getCount(rect));
}",0.8462757527733756
104888,"void fromDBObject(final DBObject dbObject,final MappedField mf,final Object entity,final Map<Key,Object> retrieved){
  String name=mf.getName();
  Class fieldType=mf.getType();
  try {
    if (mf.isMap()) {
      readMap(dbObject,mf,entity,name,retrieved);
    }
 else     if (mf.isMultipleValues()) {
      readCollection(dbObject,mf,entity,name,retrieved);
    }
 else {
      if (dbObject.containsField(name)) {
        BasicDBObject dbVal=(BasicDBObject)dbObject.get(name);
        Object refObj=ReflectionUtils.createInstance(fieldType,dbVal);
        refObj=mapper.fromDb(dbVal,refObj,null);
        if (refObj != null) {
          mf.setFieldValue(entity,refObj);
        }
      }
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","void fromDBObject(final DBObject dbObject,final MappedField mf,final Object entity,final Map<Key,Object> retrieved){
  String name=mf.getName();
  Class fieldType=mf.getType();
  try {
    if (mf.isMap()) {
      readMap(dbObject,mf,entity,name,retrieved);
    }
 else     if (mf.isMultipleValues()) {
      readCollection(dbObject,mf,entity,name,retrieved);
    }
 else {
      if (dbObject.containsField(name)) {
        BasicDBObject dbVal=(BasicDBObject)dbObject.get(name);
        Object refObj=ReflectionUtils.createInstance(fieldType,dbVal);
        refObj=mapper.fromDb(dbVal,refObj,retrieved);
        if (refObj != null) {
          mf.setFieldValue(entity,refObj);
        }
      }
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}",0.9915198956294846
104889,"UpdateOperations add(String fieldExpr,List<?> values,boolean addDups);","UpdateOperations add(String fieldExpr,Object value,boolean addDups);",0.9130434782608696
104890,"public UpdateOperations add(String fieldExpr,List<?> values,boolean addDups){
  List<Object> vals=toDBObjList(values);
  add((addDups) ? ""String_Node_Str"" : ""String_Node_Str"",fieldExpr,vals);
  return this;
}","public UpdateOperations add(String fieldExpr,Object value,boolean addDups){
  Object dbObj=mapr.toMongoObject(value);
  add((addDups) ? ""String_Node_Str"" : ""String_Node_Str"",fieldExpr,dbObj);
  return this;
}",0.7836538461538461
104891,"private void readMap(final DBObject dbObject,final MappedField mf,final Object entity,String name){
  Map map=(Map)ReflectionUtils.newInstance(mf.getCTor(),HashMap.class);
  if (dbObject.containsField(name)) {
    BasicDBObject dbVal=(BasicDBObject)dbObject.get(name);
    for (    Map.Entry entry : dbVal.entrySet()) {
      Object newEntity=ReflectionUtils.createInstance(mf.getSubType(),(BasicDBObject)entry.getValue());
      newEntity=mapper.fromDb((BasicDBObject)entry.getValue(),newEntity,null);
      Object objKey=converters.decode(mf.getMapKeyType(),entry.getKey());
      map.put(objKey,newEntity);
    }
  }
  if (map.size() > 0) {
    mf.setFieldValue(entity,map);
  }
}","private void readMap(final DBObject dbObject,final MappedField mf,final Object entity,String name,Map<Key,Object> retrieved){
  Map map=(Map)ReflectionUtils.newInstance(mf.getCTor(),HashMap.class);
  if (dbObject.containsField(name)) {
    BasicDBObject dbVal=(BasicDBObject)dbObject.get(name);
    for (    Map.Entry entry : dbVal.entrySet()) {
      Object newEntity=ReflectionUtils.createInstance(mf.getSubType(),(BasicDBObject)entry.getValue());
      newEntity=mapper.fromDb((BasicDBObject)entry.getValue(),newEntity,retrieved);
      Object objKey=converters.decode(mf.getMapKeyType(),entry.getKey());
      map.put(objKey,newEntity);
    }
  }
  if (map.size() > 0) {
    mf.setFieldValue(entity,map);
  }
}",0.972083035075161
104892,"private void readCollection(final DBObject dbObject,final MappedField mf,final Object entity,String name){
  Class newEntityType=mf.getSubType();
  Collection values=(Collection)ReflectionUtils.newInstance(mf.getCTor(),(!mf.isSet()) ? ArrayList.class : HashSet.class);
  if (dbObject.containsField(name)) {
    Object dbVal=dbObject.get(name);
    List<BasicDBObject> dbVals=(dbVal instanceof List) ? (List<BasicDBObject>)dbVal : Collections.singletonList((BasicDBObject)dbVal);
    for (    BasicDBObject dbObj : dbVals) {
      Object newEntity=ReflectionUtils.createInstance(newEntityType,dbObj);
      newEntity=mapper.fromDb(dbObj,newEntity,null);
      values.add(newEntity);
    }
  }
  if (values.size() > 0) {
    if (mf.getType().isArray()) {
      Object[] array=ReflectionUtils.convertToArray(mf.getSubType(),values);
      mf.setFieldValue(entity,array);
    }
 else {
      mf.setFieldValue(entity,values);
    }
  }
}","private void readCollection(final DBObject dbObject,final MappedField mf,final Object entity,String name,final Map<Key,Object> retrieved){
  Class newEntityType=mf.getSubType();
  Collection values=(Collection)ReflectionUtils.newInstance(mf.getCTor(),(!mf.isSet()) ? ArrayList.class : HashSet.class);
  if (dbObject.containsField(name)) {
    Object dbVal=dbObject.get(name);
    List<BasicDBObject> dbVals=(dbVal instanceof List) ? (List<BasicDBObject>)dbVal : Collections.singletonList((BasicDBObject)dbVal);
    for (    BasicDBObject dbObj : dbVals) {
      Object newEntity=ReflectionUtils.createInstance(newEntityType,dbObj);
      newEntity=mapper.fromDb(dbObj,newEntity,retrieved);
      values.add(newEntity);
    }
  }
  if (values.size() > 0) {
    if (mf.getType().isArray()) {
      Object[] array=ReflectionUtils.convertToArray(mf.getSubType(),values);
      mf.setFieldValue(entity,array);
    }
 else {
      mf.setFieldValue(entity,values);
    }
  }
}",0.9763282482903736
104893,"void fromDBObject(final DBObject dbObject,final MappedField mf,final Object entity){
  String name=mf.getName();
  Class fieldType=mf.getType();
  try {
    if (mf.isMap()) {
      readMap(dbObject,mf,entity,name);
    }
 else     if (mf.isMultipleValues()) {
      readCollection(dbObject,mf,entity,name);
    }
 else {
      if (dbObject.containsField(name)) {
        BasicDBObject dbVal=(BasicDBObject)dbObject.get(name);
        Object refObj=ReflectionUtils.createInstance(fieldType,dbVal);
        refObj=mapper.fromDb(dbVal,refObj,null);
        if (refObj != null) {
          mf.setFieldValue(entity,refObj);
        }
      }
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","void fromDBObject(final DBObject dbObject,final MappedField mf,final Object entity,final Map<Key,Object> retrieved){
  String name=mf.getName();
  Class fieldType=mf.getType();
  try {
    if (mf.isMap()) {
      readMap(dbObject,mf,entity,name,retrieved);
    }
 else     if (mf.isMultipleValues()) {
      readCollection(dbObject,mf,entity,name,retrieved);
    }
 else {
      if (dbObject.containsField(name)) {
        BasicDBObject dbVal=(BasicDBObject)dbObject.get(name);
        Object refObj=ReflectionUtils.createInstance(fieldType,dbVal);
        refObj=mapper.fromDb(dbVal,refObj,null);
        if (refObj != null) {
          mf.setFieldValue(entity,refObj);
        }
      }
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}",0.964769647696477
104894,"/** 
 * constructor 
 */
public MappedClass(Class clazz,Mapper mapr){
  this.mapr=mapr;
  this.clazz=clazz;
  for (  Class<? extends Annotation> c : interestingAnnotations) {
    addAnnotation(c);
  }
  Class type=clazz;
  try {
    ctor=type.getDeclaredConstructor();
    ctor.setAccessible(true);
  }
 catch (  NoSuchMethodException e) {
    throw new MappingException(""String_Node_Str"" + type.getName(),e);
  }
  List<Class<?>> lifecycleClasses=new ArrayList<Class<?>>();
  lifecycleClasses.add(clazz);
  EntityListeners entityLisAnn=(EntityListeners)releventAnnotations.get(EntityListeners.class);
  if (entityLisAnn != null && entityLisAnn.value() != null && entityLisAnn.value().length != 0)   for (  Class<?> c : entityLisAnn.value())   lifecycleClasses.add(c);
  Class<? extends Annotation>[] lifecycleAnnotations=new Class[]{PrePersist.class,PreSave.class,PostPersist.class,PreLoad.class,PostLoad.class};
  for (  Class<?> cls : lifecycleClasses) {
    for (    Method m : ReflectionUtils.getDeclaredAndInheritedMethods(cls)) {
      for (      Class<? extends Annotation> c : lifecycleAnnotations) {
        if (m.isAnnotationPresent(c)) {
          addLifecycleEventMethod(c,m,cls.equals(clazz) ? null : cls);
        }
      }
    }
  }
  embeddedAn=(Embedded)releventAnnotations.get(Embedded.class);
  entityAn=(Entity)releventAnnotations.get(Entity.class);
  collName=(entityAn == null || entityAn.value().equals(Mapper.IGNORED_FIELDNAME)) ? clazz.getSimpleName() : entityAn.value();
  for (  Field field : ReflectionUtils.getDeclaredAndInheritedFields(clazz,true)) {
    field.setAccessible(true);
    if (field.isAnnotationPresent(Id.class)) {
      idField=field;
      MappedField mf=new MappedField(idField);
      persistenceFields.add(mf);
    }
 else     if (field.isAnnotationPresent(Transient.class) || (mapr.getOptions().actLikeSerializer && ((field.getModifiers() & Modifier.TRANSIENT) == Modifier.TRANSIENT))) {
      continue;
    }
 else     if (mapr.getOptions().ignoreFinals && ((field.getModifiers() & Modifier.FINAL) == Modifier.FINAL)) {
      continue;
    }
 else     if (field.isAnnotationPresent(Property.class) || field.isAnnotationPresent(Reference.class) || field.isAnnotationPresent(Embedded.class)|| isSupportedType(field.getType())|| ReflectionUtils.implementsInterface(field.getType(),Serializable.class)) {
      persistenceFields.add(new MappedField(field));
    }
 else {
      if (mapr.getOptions().defaultFieldAnnotation != null)       persistenceFields.add(new MappedField(field));
 else       log.warning(""String_Node_Str"" + clazz.getName() + ""String_Node_Str""+ field.getName()+ ""String_Node_Str""+ field.getType().getName()+ ""String_Node_Str"");
    }
  }
}","/** 
 * constructor 
 */
public MappedClass(Class clazz,Mapper mapr){
  this.mapr=mapr;
  this.clazz=clazz;
  for (  Class<? extends Annotation> c : interestingAnnotations) {
    addAnnotation(c);
  }
  Class type=clazz;
  try {
    ctor=type.getDeclaredConstructor();
    ctor.setAccessible(true);
  }
 catch (  NoSuchMethodException e) {
    throw new MappingException(""String_Node_Str"" + type.getName(),e);
  }
  List<Class<?>> lifecycleClasses=new ArrayList<Class<?>>();
  lifecycleClasses.add(clazz);
  EntityListeners entityLisAnn=(EntityListeners)releventAnnotations.get(EntityListeners.class);
  if (entityLisAnn != null && entityLisAnn.value() != null && entityLisAnn.value().length != 0)   for (  Class<?> c : entityLisAnn.value())   lifecycleClasses.add(c);
  Class<? extends Annotation>[] lifecycleAnnotations=new Class[]{PrePersist.class,PreSave.class,PostPersist.class,PreLoad.class,PostLoad.class};
  for (  Class<?> cls : lifecycleClasses) {
    for (    Method m : ReflectionUtils.getDeclaredAndInheritedMethods(cls)) {
      for (      Class<? extends Annotation> c : lifecycleAnnotations) {
        if (m.isAnnotationPresent(c)) {
          addLifecycleEventMethod(c,m,cls.equals(clazz) ? null : cls);
        }
      }
    }
  }
  embeddedAn=(Embedded)releventAnnotations.get(Embedded.class);
  entityAn=(Entity)releventAnnotations.get(Entity.class);
  collName=(entityAn == null || entityAn.value().equals(Mapper.IGNORED_FIELDNAME)) ? clazz.getSimpleName() : entityAn.value();
  for (  Field field : ReflectionUtils.getDeclaredAndInheritedFields(clazz,true)) {
    field.setAccessible(true);
    int fieldMods=field.getModifiers();
    if (field.isAnnotationPresent(Transient.class))     continue;
 else     if (field.isSynthetic() && (fieldMods & Modifier.TRANSIENT) == Modifier.TRANSIENT)     continue;
 else     if (mapr.getOptions().actLikeSerializer && ((fieldMods & Modifier.TRANSIENT) == Modifier.TRANSIENT))     continue;
 else     if (mapr.getOptions().ignoreFinals && ((fieldMods & Modifier.FINAL) == Modifier.FINAL))     continue;
 else     if (field.isAnnotationPresent(Id.class)) {
      idField=field;
      MappedField mf=new MappedField(idField);
      persistenceFields.add(mf);
    }
 else     if (field.isAnnotationPresent(Property.class) || field.isAnnotationPresent(Reference.class) || field.isAnnotationPresent(Embedded.class)|| isSupportedType(field.getType())|| ReflectionUtils.implementsInterface(field.getType(),Serializable.class)) {
      persistenceFields.add(new MappedField(field));
    }
 else {
      if (mapr.getOptions().defaultFieldAnnotation != null)       persistenceFields.add(new MappedField(field));
 else       log.warning(""String_Node_Str"" + clazz.getName() + ""String_Node_Str""+ field.getName()+ ""String_Node_Str""+ field.getType().getName()+ ""String_Node_Str"");
    }
  }
}",0.8793507664562669
104895,"Object fromDb(DBObject dbObject,final Object entity,Map<Key,Object> retrieved){
  if (dbObject.containsField(ID_KEY) && getMappedClass(entity).getIdField() != null) {
    Key key=new Key(entity.getClass(),dbObject.get(ID_KEY));
    Object cachedInstance=retrieved.get(key);
    if (cachedInstance != null)     return cachedInstance;
 else     retrieved.put(key,entity);
  }
  MappedClass mc=getMappedClass(entity);
  dbObject=(BasicDBObject)mc.callLifecycleMethods(PreLoad.class,entity,dbObject,this);
  try {
    for (    MappedField mf : mc.getPersistenceFields()) {
      if (mf.hasAnnotation(Id.class)) {
        if (dbObject.get(ID_KEY) != null) {
          mf.setFieldValue(entity,converters.decode(mf.getType(),dbObject.get(ID_KEY)));
        }
      }
 else       if (mf.hasAnnotation(Property.class) || mf.hasAnnotation(Serialized.class) || mf.isTypeMongoCompatible())       valueMapper.fromDBObject(dbObject,mf,entity);
 else       if (mf.hasAnnotation(Embedded.class))       embeddedMapper.fromDBObject(dbObject,mf,entity);
 else       if (mf.hasAnnotation(Reference.class))       referenceMapper.fromDBObject(dbObject,mf,entity,retrieved);
 else       logger.warning(""String_Node_Str"" + mf.getFullName() + ""String_Node_Str""+ mf.getType().getName()+ ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  if (dbObject.containsField(ID_KEY) && getMappedClass(entity).getIdField() != null) {
    String id=dbObject.get(ID_KEY).toString();
    Key key=new Key(entity.getClass(),id);
    retrieved.put(key,entity);
  }
  mc.callLifecycleMethods(PostLoad.class,entity,dbObject,this);
  return entity;
}","Object fromDb(DBObject dbObject,final Object entity,Map<Key,Object> retrieved){
  if (dbObject.containsField(ID_KEY) && getMappedClass(entity).getIdField() != null) {
    Key key=new Key(entity.getClass(),dbObject.get(ID_KEY));
    Object cachedInstance=retrieved.get(key);
    if (cachedInstance != null)     return cachedInstance;
 else     retrieved.put(key,entity);
  }
  MappedClass mc=getMappedClass(entity);
  dbObject=(BasicDBObject)mc.callLifecycleMethods(PreLoad.class,entity,dbObject,this);
  try {
    for (    MappedField mf : mc.getPersistenceFields()) {
      if (mf.hasAnnotation(Id.class)) {
        if (dbObject.get(ID_KEY) != null) {
          mf.setFieldValue(entity,converters.decode(mf.getType(),dbObject.get(ID_KEY)));
        }
      }
 else       if (mf.hasAnnotation(Property.class) || mf.hasAnnotation(Serialized.class) || mf.isTypeMongoCompatible())       valueMapper.fromDBObject(dbObject,mf,entity);
 else       if (mf.hasAnnotation(Embedded.class))       embeddedMapper.fromDBObject(dbObject,mf,entity,retrieved);
 else       if (mf.hasAnnotation(Reference.class))       referenceMapper.fromDBObject(dbObject,mf,entity,retrieved);
 else       logger.warning(""String_Node_Str"" + mf.getFullName() + ""String_Node_Str""+ mf.getType().getName()+ ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  if (dbObject.containsField(ID_KEY) && getMappedClass(entity).getIdField() != null) {
    String id=dbObject.get(ID_KEY).toString();
    Key key=new Key(entity.getClass(),id);
    retrieved.put(key,entity);
  }
  mc.callLifecycleMethods(PostLoad.class,entity,dbObject,this);
  return entity;
}",0.9969770253929868
104896,"public void save(T entity){
  DBObject dbObj=morphia.toDBObject(entity);
  collection().save(dbObj);
  DBObject lastErr=collection().getDB().getLastError();
  if (lastErr.get(""String_Node_Str"") != null)   throw new MappingException(""String_Node_Str"" + lastErr.toString());
  morphia.getMapper().updateKeyInfo(entity,dbObj.get(Mapper.ID_KEY),collectionName);
  morphia.getMapper().getMappedClass(entity).callLifecycleMethods(PostPersist.class,entity,dbObj);
}","public void save(T entity){
  DBObject dbObj=morphia.getMapper().toDBObject(entity,false);
  collection().save(dbObj);
  DBObject lastErr=collection().getDB().getLastError();
  if (lastErr.get(""String_Node_Str"") != null)   throw new MappingException(""String_Node_Str"" + lastErr.toString());
  morphia.getMapper().updateKeyInfo(entity,dbObj.get(Mapper.ID_KEY),collectionName);
  morphia.getMapper().getMappedClass(entity).callLifecycleMethods(PostPersist.class,entity,dbObj);
}",0.9807280513918628
104897,"public <T>T fromDBObject(Class<T> entityClass,DBObject dbObject){
  if (!entityClass.isInterface() && !mapper.isMapped(entityClass)) {
    throw new MappingException(""String_Node_Str"" + entityClass.getName());
  }
  try {
    return (T)mapper.fromDBObject(entityClass,(BasicDBObject)dbObject);
  }
 catch (  Exception e) {
    throw new MappingException(""String_Node_Str"",e);
  }
 finally {
    mapper.clearHistory();
  }
}","public <T>T fromDBObject(Class<T> entityClass,DBObject dbObject){
  if (!entityClass.isInterface() && !mapper.isMapped(entityClass)) {
    throw new MappingException(""String_Node_Str"" + entityClass.getName());
  }
  try {
    return (T)mapper.fromDBObject(entityClass,(BasicDBObject)dbObject);
  }
 catch (  Exception e) {
    throw new MappingException(""String_Node_Str"",e);
  }
}",0.9477611940298508
104898,"public DBObject toDBObject(Object entity){
  if (!mapper.isMapped(entity.getClass())) {
    throw new MappingException(""String_Node_Str"" + entity.getClass().getName());
  }
  try {
    return mapper.toDBObject(entity);
  }
 catch (  Exception e) {
    throw new MappingException(""String_Node_Str"",e);
  }
 finally {
    mapper.clearHistory();
  }
}","public DBObject toDBObject(Object entity){
  try {
    return mapper.toDBObject(entity);
  }
 catch (  Exception e) {
    throw new MappingException(""String_Node_Str"",e);
  }
}",0.6717557251908397
104899,"/** 
 * converts an entity to a DBObject 
 */
public DBObject toDBObject(Object entity){
  BasicDBObject dbObject=new BasicDBObject();
  MappedClass mc=getMappedClass(entity);
  if (mc.getPolymorphicAnnotation() != null) {
    dbObject.put(CLASS_NAME_FIELDNAME,entity.getClass().getCanonicalName());
  }
  dbObject=(BasicDBObject)mc.callLifecycleMethods(PrePersist.class,entity,dbObject);
  for (  MappedField mf : mc.getPersistenceFields()) {
    try {
      if (mf.hasAnnotation(Id.class)) {
        Object dbVal=mf.getFieldValue(entity);
        if (dbVal != null) {
          dbObject.put(ID_KEY,objectToValue(asObjectIdMaybe(dbVal)));
        }
      }
 else       if (mf.hasAnnotation(Reference.class)) {
        mapReferencesToDBObject(entity,mf,dbObject);
      }
 else       if (mf.hasAnnotation(Embedded.class) && !mf.isTypeMongoCompatible()) {
        mapEmbeddedToDBObject(entity,mf,dbObject);
      }
 else       if (mf.hasAnnotation(Property.class) || mf.hasAnnotation(Serialized.class) || mf.isTypeMongoCompatible()) {
        mapValuesToDBObject(entity,mf,dbObject);
      }
 else {
        logger.warning(""String_Node_Str"" + mf.getFullName() + ""String_Node_Str""+ mf.getType().getSimpleName()+ ""String_Node_Str"");
      }
    }
 catch (    Exception e) {
      throw new MappingException(""String_Node_Str"" + mf.getFullName(),e);
    }
  }
  return dbObject;
}","public DBObject toDBObject(Object entity,boolean callPostPersist){
  BasicDBObject dbObject=new BasicDBObject();
  MappedClass mc=getMappedClass(entity);
  if (mc.getPolymorphicAnnotation() != null) {
    dbObject.put(CLASS_NAME_FIELDNAME,entity.getClass().getCanonicalName());
  }
  dbObject=(BasicDBObject)mc.callLifecycleMethods(PrePersist.class,entity,dbObject);
  for (  MappedField mf : mc.getPersistenceFields()) {
    try {
      if (mf.hasAnnotation(Id.class)) {
        Object dbVal=mf.getFieldValue(entity);
        if (dbVal != null) {
          dbObject.put(ID_KEY,objectToValue(asObjectIdMaybe(dbVal)));
        }
      }
 else       if (mf.hasAnnotation(Reference.class)) {
        mapReferencesToDBObject(entity,mf,dbObject);
      }
 else       if (mf.hasAnnotation(Embedded.class) && !mf.isTypeMongoCompatible()) {
        mapEmbeddedToDBObject(entity,mf,dbObject);
      }
 else       if (mf.hasAnnotation(Property.class) || mf.hasAnnotation(Serialized.class) || mf.isTypeMongoCompatible()) {
        mapValuesToDBObject(entity,mf,dbObject);
      }
 else {
        logger.warning(""String_Node_Str"" + mf.getFullName() + ""String_Node_Str""+ mf.getType().getSimpleName()+ ""String_Node_Str"");
      }
    }
 catch (    Exception e) {
      throw new MappingException(""String_Node_Str"" + mf.getFullName(),e);
    }
  }
  if (callPostPersist)   mc.callLifecycleMethods(PostPersist.class,entity,dbObject);
  return dbObject;
}",0.929257020974049
104900,"/** 
 * coverts a DBObject back to a type-safe java object
 */
public Object fromDBObject(Class entityClass,BasicDBObject dbObject){
  if (dbObject == null) {
    Throwable t=new Throwable();
    logger.log(Level.SEVERE,""String_Node_Str"",t);
    return null;
  }
  entityCache.set(new HashMap<String,Object>());
  Object entity=createInstance(entityClass,dbObject);
  mapDBObjectToEntity(dbObject,entity);
  entityCache.remove();
  return entity;
}","/** 
 * coverts a DBObject back to a type-safe java object
 */
public Object fromDBObject(Class entityClass,BasicDBObject dbObject){
  if (dbObject == null) {
    Throwable t=new Throwable();
    logger.log(Level.SEVERE,""String_Node_Str"",t);
    return null;
  }
  entityCache.set(new HashMap<String,Object>());
  Object entity=null;
  try {
    entity=createInstance(entityClass,dbObject);
    mapDBObjectToEntity(dbObject,entity);
  }
  finally {
    entityCache.remove();
  }
  return entity;
}",0.9164021164021164
104901,"void mapReferencesFromDBObject(BasicDBObject dbObject,MappedField mf,Object entity){
  String name=mf.getName();
  Class fieldType=mf.getType();
  try {
    if (mf.isMap()) {
      Class referenceObjClass=mf.getSubType();
      Map map=(Map)tryConstructor(HashMap.class,mf.getCTor());
      if (dbObject.containsField(name)) {
        BasicDBObject dbVal=(BasicDBObject)dbObject.get(name);
        for (        Map.Entry entry : dbVal.entrySet()) {
          DBRef dbRef=(DBRef)entry.getValue();
          BasicDBObject refDbObject=(BasicDBObject)dbRef.fetch();
          if (refDbObject != null) {
            Object refObj=createInstance(referenceObjClass,refDbObject);
            refObj=mapDBObjectToEntity(refDbObject,refObj);
            map.put(entry.getKey(),refObj);
          }
        }
      }
      mf.setFieldValue(entity,map);
    }
 else     if (mf.isMultipleValues()) {
      Class referenceObjClass=mf.getSubType();
      Collection references=(Collection)tryConstructor((!mf.isSet()) ? ArrayList.class : HashSet.class,mf.getCTor());
      if (dbObject.containsField(name)) {
        Object dbVal=dbObject.get(name);
        if (dbVal instanceof List) {
          List refList=(List)dbVal;
          for (          Object dbRefObj : refList) {
            DBRef dbRef=(DBRef)dbRefObj;
            BasicDBObject refDbObject=(BasicDBObject)dbRef.fetch();
            if (refDbObject != null) {
              Object refObj=createInstance(referenceObjClass,refDbObject);
              refObj=mapDBObjectToEntity(refDbObject,refObj);
              references.add(refObj);
            }
          }
        }
 else {
          DBRef dbRef=(DBRef)dbObject.get(name);
          BasicDBObject refDbObject=(BasicDBObject)dbRef.fetch();
          if (refDbObject != null) {
            Object newEntity=createInstance(referenceObjClass,refDbObject);
            newEntity=mapDBObjectToEntity(refDbObject,newEntity);
            references.add(newEntity);
          }
        }
      }
      mf.setFieldValue(entity,references);
    }
 else {
      Class referenceObjClass=fieldType;
      if (dbObject.containsField(name)) {
        DBRef dbRef=(DBRef)dbObject.get(name);
        BasicDBObject refDbObject=(BasicDBObject)dbRef.fetch();
        if (refDbObject != null) {
          Object refObj=createInstance(referenceObjClass,refDbObject);
          refObj=mapDBObjectToEntity(refDbObject,refObj);
          mf.setFieldValue(entity,refObj);
        }
      }
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","void mapReferencesFromDBObject(BasicDBObject dbObject,MappedField mf,Object entity){
  String name=mf.getName();
  Class fieldType=mf.getType();
  try {
    Reference refAnn=mf.getAnnotation(Reference.class);
    if (mf.isMap()) {
      Class referenceObjClass=mf.getSubType();
      Map map=(Map)tryConstructor(HashMap.class,mf.getCTor());
      if (dbObject.containsField(name)) {
        BasicDBObject dbVal=(BasicDBObject)dbObject.get(name);
        for (        Map.Entry entry : dbVal.entrySet()) {
          DBRef dbRef=(DBRef)entry.getValue();
          BasicDBObject refDbObject=(BasicDBObject)dbRef.fetch();
          if (refDbObject == null) {
            if (!refAnn.ignoreMissing())             throw new MappingException(""String_Node_Str"" + dbRef.toString() + ""String_Node_Str""+ mf.getFullName());
          }
 else {
            Object refObj=createInstance(referenceObjClass,refDbObject);
            refObj=mapDBObjectToEntity(refDbObject,refObj);
            map.put(entry.getKey(),refObj);
          }
        }
      }
      mf.setFieldValue(entity,map);
    }
 else     if (mf.isMultipleValues()) {
      Class referenceObjClass=mf.getSubType();
      Collection references=(Collection)tryConstructor((!mf.isSet()) ? ArrayList.class : HashSet.class,mf.getCTor());
      if (dbObject.containsField(name)) {
        Object dbVal=dbObject.get(name);
        if (dbVal instanceof List) {
          List refList=(List)dbVal;
          for (          Object dbRefObj : refList) {
            DBRef dbRef=(DBRef)dbRefObj;
            BasicDBObject refDbObject=(BasicDBObject)dbRef.fetch();
            if (refDbObject == null) {
              if (!refAnn.ignoreMissing())               throw new MappingException(""String_Node_Str"" + dbRef.toString() + ""String_Node_Str""+ mf.getFullName());
            }
 else {
              Object refObj=createInstance(referenceObjClass,refDbObject);
              refObj=mapDBObjectToEntity(refDbObject,refObj);
              references.add(refObj);
            }
          }
        }
 else {
          DBRef dbRef=(DBRef)dbObject.get(name);
          BasicDBObject refDbObject=(BasicDBObject)dbRef.fetch();
          if (refDbObject == null) {
            if (!refAnn.ignoreMissing())             throw new MappingException(""String_Node_Str"" + dbRef.toString() + ""String_Node_Str""+ mf.getFullName());
          }
 else {
            Object newEntity=createInstance(referenceObjClass,refDbObject);
            newEntity=mapDBObjectToEntity(refDbObject,newEntity);
            references.add(newEntity);
          }
        }
      }
      mf.setFieldValue(entity,references);
    }
 else {
      Class referenceObjClass=fieldType;
      if (dbObject.containsField(name)) {
        DBRef dbRef=(DBRef)dbObject.get(name);
        BasicDBObject refDbObject=(BasicDBObject)dbRef.fetch();
        if (refDbObject == null) {
          if (!refAnn.ignoreMissing())           throw new MappingException(""String_Node_Str"" + dbRef.toString() + ""String_Node_Str""+ mf.getFullName());
        }
 else {
          Object refObj=createInstance(referenceObjClass,refDbObject);
          refObj=mapDBObjectToEntity(refDbObject,refObj);
          mf.setFieldValue(entity,refObj);
        }
      }
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}",0.8639316239316239
104902,"@Test public void testDynamicInstantiation() throws Exception {
  Mongo mongo=new Mongo();
  DB db=mongo.getDB(""String_Node_Str"");
  try {
    DBCollection shapes=db.getCollection(""String_Node_Str"");
    DBCollection shapeshifters=db.getCollection(""String_Node_Str"");
    Morphia morphia=new Morphia();
    morphia.map(Circle.class).map(Rectangle.class).map(ShapeShifter.class);
    Shape rectangle=new Rectangle(2,5);
    DBObject rectangleDbObj=morphia.toDBObject(rectangle);
    shapes.save(rectangleDbObj);
    BasicDBObject rectangleDbObjLoaded=(BasicDBObject)shapes.findOne(new BasicDBObject(Mapper.ID_KEY,rectangleDbObj.get(Mapper.ID_KEY)));
    Shape rectangleLoaded=morphia.fromDBObject(Shape.class,rectangleDbObjLoaded);
    assertTrue(rectangle.getArea() == rectangleLoaded.getArea());
    assertTrue(rectangleLoaded instanceof Rectangle);
    ShapeShifter shifter=new ShapeShifter();
    shifter.setReferencedShape(rectangleLoaded);
    shifter.setMainShape(new Circle(2.2));
    shifter.getAvailableShapes().add(new Rectangle(3,3));
    shifter.getAvailableShapes().add(new Circle(4.4));
    DBObject shifterDbObj=morphia.toDBObject(shifter);
    shapeshifters.save(shifterDbObj);
    BasicDBObject shifterDbObjLoaded=(BasicDBObject)shapeshifters.findOne(new BasicDBObject(Mapper.ID_KEY,shifterDbObj.get(Mapper.ID_KEY)));
    ShapeShifter shifterLoaded=morphia.fromDBObject(ShapeShifter.class,shifterDbObjLoaded);
    assertTrue(rectangle.getArea() == shifterLoaded.getReferencedShape().getArea());
    assertTrue(shifterLoaded.getReferencedShape() instanceof Rectangle);
    assertTrue(shifter.getMainShape().getArea() == shifterLoaded.getMainShape().getArea());
    assertEquals(shifter.getAvailableShapes().size(),shifterLoaded.getAvailableShapes().size());
  }
  finally {
    db.dropDatabase();
  }
}","@Test public void testDynamicInstantiation() throws Exception {
  Mongo mongo=new Mongo();
  DB db=mongo.getDB(""String_Node_Str"");
  try {
    DBCollection shapes=db.getCollection(""String_Node_Str"");
    DBCollection shapeshifters=db.getCollection(""String_Node_Str"");
    Morphia morphia=new Morphia();
    morphia.map(Circle.class).map(Rectangle.class).map(ShapeShifter.class);
    Shape rectangle=new Rectangle(2,5);
    DBObject rectangleDbObj=morphia.toDBObject(rectangle);
    shapes.save(rectangleDbObj);
    BasicDBObject rectangleDbObjLoaded=(BasicDBObject)shapes.findOne(new BasicDBObject(Mapper.ID_KEY,rectangleDbObj.get(Mapper.ID_KEY)));
    Shape rectangleLoaded=morphia.fromDBObject(Shape.class,rectangleDbObjLoaded);
    assertTrue(rectangle.getArea() == rectangleLoaded.getArea());
    assertTrue(rectangleLoaded instanceof Rectangle);
    ShapeShifter shifter=new ShapeShifter();
    shifter.setReferencedShape(rectangleLoaded);
    shifter.setMainShape(new Circle(2.2));
    shifter.getAvailableShapes().add(new Rectangle(3,3));
    shifter.getAvailableShapes().add(new Circle(4.4));
    DBObject shifterDbObj=morphia.toDBObject(shifter);
    shapeshifters.save(shifterDbObj);
    BasicDBObject shifterDbObjLoaded=(BasicDBObject)shapeshifters.findOne(new BasicDBObject(Mapper.ID_KEY,shifterDbObj.get(Mapper.ID_KEY)));
    ShapeShifter shifterLoaded=morphia.fromDBObject(ShapeShifter.class,shifterDbObjLoaded);
    assertNotNull(shifterLoaded);
    assertNotNull(shifterLoaded.getReferencedShape());
    assertNotNull(shifterLoaded.getReferencedShape().getArea());
    assertNotNull(rectangle);
    assertNotNull(rectangle.getArea());
    assertTrue(rectangle.getArea() == shifterLoaded.getReferencedShape().getArea());
    assertTrue(shifterLoaded.getReferencedShape() instanceof Rectangle);
    assertTrue(shifter.getMainShape().getArea() == shifterLoaded.getMainShape().getArea());
    assertEquals(shifter.getAvailableShapes().size(),shifterLoaded.getAvailableShapes().size());
  }
  finally {
    db.dropDatabase();
  }
}",0.9419689119170984
104903,"/** 
 * Connects to ""test"" database on localhost 
 */
public static Datastore getDatastore(){
  return ds;
}","/** 
 * Connects to ""test"" database on localhost by default 
 */
public static Datastore getDatastore(){
  return ds;
}",0.9515418502202644
104904,"void mapValuesFromDBObject(BasicDBObject dbObject,MappedField mf,Object entity){
  String name=mf.getName();
  try {
    Class fieldType=mf.getType();
    if (mf.hasAnnotation(Serialized.class)) {
      Object data=dbObject.get(name);
      if (!(data instanceof DBBinary || data instanceof byte[]))       throw new MappingException(""String_Node_Str"" + mf.getFullName() + ""String_Node_Str""+ data.getClass().getName());
      try {
        mf.setFieldValue(entity,deserialize(data));
      }
 catch (      IOException ex) {
        throw new RuntimeException(ex);
      }
catch (      ClassNotFoundException ex) {
        throw new IllegalStateException(""String_Node_Str"" + data + ""String_Node_Str""+ mf.getFullName(),ex);
      }
    }
 else     if (mf.isMap()) {
      if (dbObject.containsField(name)) {
        Map<Object,Object> map=(Map<Object,Object>)dbObject.get(name);
        Map values=(Map)tryConstructor(HashMap.class,mf.getCTor());
        for (        Map.Entry<Object,Object> entry : map.entrySet()) {
          Object objKey=objectFromValue(mf.getMapKeyType(),entry.getKey());
          values.put(objKey,objectFromValue(mf.getSubType(),entry.getValue()));
        }
        mf.setFieldValue(entity,values);
      }
    }
 else     if (mf.isMultipleValues()) {
      if (dbObject.containsField(name)) {
        Class subtype=mf.getSubType();
        if (subtype == byte.class && fieldType.isArray()) {
          mf.setFieldValue(entity,dbObject.get(name));
          return;
        }
        List list=(List)dbObject.get(name);
        if (subtype != null) {
          Collection values;
          if (!mf.isSet())           values=(List)tryConstructor(ArrayList.class,mf.getCTor());
 else           values=(Set)tryConstructor(HashSet.class,mf.getCTor());
          if (subtype == Locale.class) {
            for (            Object o : list)             values.add(parseLocale((String)o));
          }
 else           if (subtype == Key.class) {
            for (            Object o : list)             values.add(new Key((DBRef)o));
          }
 else           if (subtype.isEnum()) {
            for (            Object o : list)             values.add(Enum.valueOf(subtype,(String)o));
          }
 else {
            for (            Object o : list)             values.add(o);
          }
          if (fieldType.isArray()) {
            Object exampleArray=Array.newInstance(subtype,1);
            Object[] array=((ArrayList)values).toArray((Object[])exampleArray);
            mf.setFieldValue(entity,array);
          }
 else           mf.setFieldValue(entity,values);
        }
 else {
          mf.setFieldValue(entity,list);
        }
      }
    }
 else {
      if (dbObject.containsField(name)) {
        mf.setFieldValue(entity,objectFromValue(fieldType,dbObject,name));
      }
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","void mapValuesFromDBObject(BasicDBObject dbObject,MappedField mf,Object entity){
  String name=mf.getName();
  try {
    Class fieldType=mf.getType();
    if (mf.hasAnnotation(Serialized.class)) {
      Object data=dbObject.get(name);
      if (!(data instanceof DBBinary || data instanceof byte[]))       throw new MappingException(""String_Node_Str"" + mf.getFullName() + ""String_Node_Str""+ data.getClass().getName());
      try {
        mf.setFieldValue(entity,deserialize(data));
      }
 catch (      IOException ex) {
        throw new RuntimeException(ex);
      }
catch (      ClassNotFoundException ex) {
        throw new IllegalStateException(""String_Node_Str"" + data + ""String_Node_Str""+ mf.getFullName(),ex);
      }
    }
 else     if (mf.isMap()) {
      if (dbObject.containsField(name)) {
        Map<Object,Object> map=(Map<Object,Object>)dbObject.get(name);
        Map values=(Map)tryConstructor(HashMap.class,mf.getCTor());
        for (        Map.Entry<Object,Object> entry : map.entrySet()) {
          Object objKey=objectFromValue(mf.getMapKeyType(),entry.getKey());
          values.put(objKey,objectFromValue(mf.getSubType(),entry.getValue()));
        }
        mf.setFieldValue(entity,values);
      }
    }
 else     if (mf.isMultipleValues()) {
      if (dbObject.containsField(name)) {
        Class subtype=mf.getSubType();
        if (subtype == byte.class && fieldType.isArray()) {
          mf.setFieldValue(entity,dbObject.get(name));
          return;
        }
        List list=(List)dbObject.get(name);
        if (subtype != null) {
          Collection values;
          if (!mf.isSet())           values=(List)tryConstructor(ArrayList.class,mf.getCTor());
 else           values=(Set)tryConstructor(HashSet.class,mf.getCTor());
          if (subtype == Locale.class) {
            for (            Object o : list)             values.add(parseLocale((String)o));
          }
 else           if (subtype == Key.class) {
            for (            Object o : list)             values.add(new Key((DBRef)o));
          }
 else           if (subtype.isEnum()) {
            for (            Object o : list)             values.add(Enum.valueOf(subtype,(String)o));
          }
 else {
            for (            Object o : list)             values.add(o);
          }
          if (fieldType.isArray()) {
            Object[] array=convertToArray(subtype,values);
            mf.setFieldValue(entity,array);
          }
 else           mf.setFieldValue(entity,values);
        }
 else {
          mf.setFieldValue(entity,list);
        }
      }
    }
 else {
      if (dbObject.containsField(name)) {
        mf.setFieldValue(entity,objectFromValue(fieldType,dbObject,name));
      }
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}",0.9425408539799685
104905,"void mapReferencesFromDBObject(BasicDBObject dbObject,MappedField mf,Object entity){
  String name=mf.getName();
  Class fieldType=mf.getType();
  try {
    Reference refAnn=mf.getAnnotation(Reference.class);
    if (mf.isMap()) {
      Class referenceObjClass=mf.getSubType();
      Map map=(Map)tryConstructor(HashMap.class,mf.getCTor());
      if (dbObject.containsField(name)) {
        BasicDBObject dbVal=(BasicDBObject)dbObject.get(name);
        for (        Map.Entry entry : dbVal.entrySet()) {
          DBRef dbRef=(DBRef)entry.getValue();
          BasicDBObject refDbObject=(BasicDBObject)dbRef.fetch();
          if (refDbObject == null) {
            if (!refAnn.ignoreMissing())             throw new MappingException(""String_Node_Str"" + dbRef.toString() + ""String_Node_Str""+ mf.getFullName());
          }
 else {
            Object refObj=createInstance(referenceObjClass,refDbObject);
            refObj=mapDBObjectToEntity(refDbObject,refObj);
            map.put(entry.getKey(),refObj);
          }
        }
      }
      mf.setFieldValue(entity,map);
    }
 else     if (mf.isMultipleValues()) {
      Class referenceObjClass=mf.getSubType();
      Collection references=(Collection)tryConstructor((!mf.isSet()) ? ArrayList.class : HashSet.class,mf.getCTor());
      if (dbObject.containsField(name)) {
        Object dbVal=dbObject.get(name);
        if (dbVal instanceof List) {
          List refList=(List)dbVal;
          for (          Object dbRefObj : refList) {
            DBRef dbRef=(DBRef)dbRefObj;
            BasicDBObject refDbObject=(BasicDBObject)dbRef.fetch();
            if (refDbObject == null) {
              if (!refAnn.ignoreMissing())               throw new MappingException(""String_Node_Str"" + dbRef.toString() + ""String_Node_Str""+ mf.getFullName());
            }
 else {
              Object refObj=createInstance(referenceObjClass,refDbObject);
              refObj=mapDBObjectToEntity(refDbObject,refObj);
              references.add(refObj);
            }
          }
        }
 else {
          DBRef dbRef=(DBRef)dbObject.get(name);
          BasicDBObject refDbObject=(BasicDBObject)dbRef.fetch();
          if (refDbObject == null) {
            if (!refAnn.ignoreMissing())             throw new MappingException(""String_Node_Str"" + dbRef.toString() + ""String_Node_Str""+ mf.getFullName());
          }
 else {
            Object newEntity=createInstance(referenceObjClass,refDbObject);
            newEntity=mapDBObjectToEntity(refDbObject,newEntity);
            references.add(newEntity);
          }
        }
      }
      mf.setFieldValue(entity,references);
    }
 else {
      Class referenceObjClass=fieldType;
      if (dbObject.containsField(name)) {
        DBRef dbRef=(DBRef)dbObject.get(name);
        BasicDBObject refDbObject=(BasicDBObject)dbRef.fetch();
        if (refDbObject == null) {
          if (!refAnn.ignoreMissing())           throw new MappingException(""String_Node_Str"" + dbRef.toString() + ""String_Node_Str""+ mf.getFullName());
        }
 else {
          Object refObj=createInstance(referenceObjClass,refDbObject);
          refObj=mapDBObjectToEntity(refDbObject,refObj);
          mf.setFieldValue(entity,refObj);
        }
      }
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","void mapReferencesFromDBObject(BasicDBObject dbObject,MappedField mf,Object entity){
  String name=mf.getName();
  Class fieldType=mf.getType();
  try {
    Reference refAnn=mf.getAnnotation(Reference.class);
    if (mf.isMap()) {
      Class referenceObjClass=mf.getSubType();
      Map map=(Map)tryConstructor(HashMap.class,mf.getCTor());
      if (dbObject.containsField(name)) {
        BasicDBObject dbVal=(BasicDBObject)dbObject.get(name);
        for (        Map.Entry entry : dbVal.entrySet()) {
          DBRef dbRef=(DBRef)entry.getValue();
          BasicDBObject refDbObject=(BasicDBObject)dbRef.fetch();
          if (refDbObject == null) {
            if (!refAnn.ignoreMissing())             throw new MappingException(""String_Node_Str"" + dbRef.toString() + ""String_Node_Str""+ mf.getFullName());
          }
 else {
            Object refObj=createInstance(referenceObjClass,refDbObject);
            refObj=mapDBObjectToEntity(refDbObject,refObj);
            map.put(entry.getKey(),refObj);
          }
        }
      }
      mf.setFieldValue(entity,map);
    }
 else     if (mf.isMultipleValues()) {
      Class referenceObjClass=mf.getSubType();
      Collection references=(Collection)tryConstructor((!mf.isSet()) ? ArrayList.class : HashSet.class,mf.getCTor());
      if (dbObject.containsField(name)) {
        Object dbVal=dbObject.get(name);
        List<DBRef> dbVals=(dbVal instanceof List) ? (List<DBRef>)dbVal : Collections.singletonList((DBRef)dbVal);
        for (        DBRef dbRef : dbVals) {
          BasicDBObject dbRefObj=(BasicDBObject)dbRef.fetch();
          if (dbRefObj == null) {
            if (!refAnn.ignoreMissing())             throw new MappingException(""String_Node_Str"" + dbRef.toString() + ""String_Node_Str""+ mf.getFullName());
          }
 else {
            Object refObj=createInstance(referenceObjClass,dbRefObj);
            refObj=mapDBObjectToEntity(dbRefObj,refObj);
            references.add(refObj);
          }
        }
      }
      if (references.size() > 0)       if (mf.getType().isArray()) {
        Object[] array=convertToArray(mf.getSubType(),references);
        mf.setFieldValue(entity,array);
      }
 else       mf.setFieldValue(entity,references);
    }
 else {
      Class referenceObjClass=fieldType;
      if (dbObject.containsField(name)) {
        DBRef dbRef=(DBRef)dbObject.get(name);
        BasicDBObject refDbObject=(BasicDBObject)dbRef.fetch();
        if (refDbObject == null) {
          if (!refAnn.ignoreMissing())           throw new MappingException(""String_Node_Str"" + dbRef.toString() + ""String_Node_Str""+ mf.getFullName());
        }
 else {
          Object refObj=createInstance(referenceObjClass,refDbObject);
          refObj=mapDBObjectToEntity(refDbObject,refObj);
          mf.setFieldValue(entity,refObj);
        }
      }
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}",0.7821049243643385
104906,"void mapEmbeddedFromDBObject(BasicDBObject dbObject,MappedField mf,Object entity){
  String name=mf.getName();
  Class fieldType=mf.getType();
  try {
    if (mf.isMap()) {
      Map map=(Map)tryConstructor(HashMap.class,mf.getCTor());
      if (dbObject.containsField(name)) {
        BasicDBObject dbVal=(BasicDBObject)dbObject.get(name);
        for (        Map.Entry entry : dbVal.entrySet()) {
          Object newEntity=createInstance(mf.getSubType(),(BasicDBObject)entry.getValue());
          newEntity=mapDBObjectToEntity((BasicDBObject)entry.getValue(),newEntity);
          Object objKey=objectFromValue(mf.getMapKeyType(),entry.getKey());
          map.put(objKey,newEntity);
        }
      }
      if (map.size() > 0)       mf.setFieldValue(entity,map);
    }
 else     if (mf.isMultipleValues()) {
      Class newEntityType=mf.getSubType();
      Collection entities=(Collection)tryConstructor((!mf.isSet()) ? ArrayList.class : HashSet.class,mf.getCTor());
      if (dbObject.containsField(name)) {
        Object dbVal=dbObject.get(name);
        if (dbVal instanceof List) {
          List refList=(List)dbVal;
          for (          Object docDbObject : refList) {
            Object newEntity=createInstance(newEntityType,(BasicDBObject)docDbObject);
            newEntity=mapDBObjectToEntity((BasicDBObject)docDbObject,newEntity);
            entities.add(newEntity);
          }
        }
 else {
          BasicDBObject dbObj=(BasicDBObject)dbObject.get(name);
          Object newEntity=createInstance(newEntityType,dbObj);
          newEntity=mapDBObjectToEntity(dbObj,newEntity);
          entities.add(newEntity);
        }
      }
      if (entities.size() > 0)       mf.setFieldValue(entity,entities);
    }
 else {
      if (dbObject.containsField(name)) {
        BasicDBObject dbVal=(BasicDBObject)dbObject.get(name);
        Object refObj=createInstance(fieldType,dbVal);
        refObj=mapDBObjectToEntity(dbVal,refObj);
        if (refObj != null)         mf.setFieldValue(entity,refObj);
      }
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","void mapEmbeddedFromDBObject(BasicDBObject dbObject,MappedField mf,Object entity){
  String name=mf.getName();
  Class fieldType=mf.getType();
  try {
    if (mf.isMap()) {
      Map map=(Map)tryConstructor(HashMap.class,mf.getCTor());
      if (dbObject.containsField(name)) {
        BasicDBObject dbVal=(BasicDBObject)dbObject.get(name);
        for (        Map.Entry entry : dbVal.entrySet()) {
          Object newEntity=createInstance(mf.getSubType(),(BasicDBObject)entry.getValue());
          newEntity=mapDBObjectToEntity((BasicDBObject)entry.getValue(),newEntity);
          Object objKey=objectFromValue(mf.getMapKeyType(),entry.getKey());
          map.put(objKey,newEntity);
        }
      }
      if (map.size() > 0)       mf.setFieldValue(entity,map);
    }
 else     if (mf.isMultipleValues()) {
      Class newEntityType=mf.getSubType();
      Collection values=(Collection)tryConstructor((!mf.isSet()) ? ArrayList.class : HashSet.class,mf.getCTor());
      if (dbObject.containsField(name)) {
        Object dbVal=dbObject.get(name);
        List<BasicDBObject> dbVals=(dbVal instanceof List) ? (List<BasicDBObject>)dbVal : Collections.singletonList((BasicDBObject)dbVal);
        for (        BasicDBObject dbObj : dbVals) {
          Object newEntity=createInstance(newEntityType,dbObj);
          newEntity=mapDBObjectToEntity(dbObj,newEntity);
          values.add(newEntity);
        }
      }
      if (values.size() > 0)       if (mf.getType().isArray()) {
        Object[] array=convertToArray(mf.getSubType(),values);
        mf.setFieldValue(entity,array);
      }
 else       mf.setFieldValue(entity,values);
    }
 else {
      if (dbObject.containsField(name)) {
        BasicDBObject dbVal=(BasicDBObject)dbObject.get(name);
        Object refObj=createInstance(fieldType,dbVal);
        refObj=mapDBObjectToEntity(dbVal,refObj);
        if (refObj != null)         mf.setFieldValue(entity,refObj);
      }
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}",0.816
104907,"/** 
 * Get a set of all classes that are mapped by this instance.
 * @return all classes that are mapped by this instance
 */
public Map<String,MappedClass> getMappedClasses(){
  return new HashMap(mapper.getMappedClasses());
}","/** 
 * Get a set of all classes that are mapped by this instance.
 * @return all classes that are mapped by this instance
 */
public Map<String,MappedClass> getMappedClasses(){
  return Collections.unmodifiableMap(mapper.getMappedClasses());
}",0.9322033898305084
104908,"/** 
 * Converts known types from mongodb -> java.
 */
protected static Object objectFromValue(Class javaType,Object val){
  if (val == null)   return null;
  if (javaType == null)   return val;
  if (javaType == String.class) {
    return val.toString();
  }
 else   if (javaType == Character.class || javaType == char.class) {
    return val.toString().charAt(0);
  }
 else   if (javaType == Integer.class || javaType == int.class) {
    return ((Number)val).intValue();
  }
 else   if (javaType == Long.class || javaType == long.class) {
    return ((Number)val).longValue();
  }
 else   if (javaType == Byte.class || javaType == byte.class) {
    Object dbValue=val;
    if (dbValue instanceof Byte)     return dbValue;
 else     if (dbValue instanceof Double)     return ((Double)dbValue).byteValue();
 else     if (dbValue instanceof Integer)     return ((Integer)dbValue).byteValue();
    String sVal=val.toString();
    return Byte.parseByte(sVal);
  }
 else   if (javaType == Short.class || javaType == short.class) {
    Object dbValue=val;
    if (dbValue instanceof Short)     return dbValue;
 else     if (dbValue instanceof Double)     return ((Double)dbValue).shortValue();
 else     if (dbValue instanceof Integer)     return ((Integer)dbValue).shortValue();
    String sVal=val.toString();
    return Short.parseShort(sVal);
  }
 else   if (javaType == Float.class || javaType == float.class) {
    Object dbValue=val;
    if (dbValue instanceof Double)     return ((Double)dbValue).floatValue();
    String sVal=val.toString();
    return Float.parseFloat(sVal);
  }
 else   if (javaType == Locale.class) {
    return parseLocale(val.toString());
  }
 else   if (javaType.isEnum()) {
    return Enum.valueOf(javaType,val.toString());
  }
 else   if (javaType == Key.class) {
    return new Key((DBRef)val);
  }
  return val;
}","/** 
 * Converts known types from mongodb -> java.
 */
protected static Object objectFromValue(Class javaType,Object val){
  if (val == null)   return null;
  if (javaType == null)   return val;
  if (javaType == String.class) {
    return val.toString();
  }
 else   if (javaType == Character.class || javaType == char.class) {
    return val.toString().charAt(0);
  }
 else   if (javaType == Integer.class || javaType == int.class) {
    if (val instanceof String) {
      return Integer.parseInt((String)val);
    }
 else {
      return ((Number)val).intValue();
    }
  }
 else   if (javaType == Long.class || javaType == long.class) {
    if (val instanceof String) {
      return Long.parseLong((String)val);
    }
 else {
      return ((Number)val).longValue();
    }
  }
 else   if (javaType == Byte.class || javaType == byte.class) {
    Object dbValue=val;
    if (dbValue instanceof Byte)     return dbValue;
 else     if (dbValue instanceof Double)     return ((Double)dbValue).byteValue();
 else     if (dbValue instanceof Integer)     return ((Integer)dbValue).byteValue();
    String sVal=val.toString();
    return Byte.parseByte(sVal);
  }
 else   if (javaType == Short.class || javaType == short.class) {
    Object dbValue=val;
    if (dbValue instanceof Short)     return dbValue;
 else     if (dbValue instanceof Double)     return ((Double)dbValue).shortValue();
 else     if (dbValue instanceof Integer)     return ((Integer)dbValue).shortValue();
    String sVal=val.toString();
    return Short.parseShort(sVal);
  }
 else   if (javaType == Float.class || javaType == float.class) {
    Object dbValue=val;
    if (dbValue instanceof Double)     return ((Double)dbValue).floatValue();
    String sVal=val.toString();
    return Float.parseFloat(sVal);
  }
 else   if (javaType == Locale.class) {
    return parseLocale(val.toString());
  }
 else   if (javaType.isEnum()) {
    return Enum.valueOf(javaType,val.toString());
  }
 else   if (javaType == Key.class) {
    return new Key((DBRef)val);
  }
  return val;
}",0.9495365602471678
104909,"private void firePostPersistForChildren(Object entity,DBObject dbObj,Mapper mapr){
  MappedClass mc=mapr.getMappedClass(entity);
  for (  MappedField mf : mc.getPersistenceFields()) {
    try {
      if (mf.hasAnnotation(Embedded.class) && !mf.isTypeMongoCompatible()) {
        Object embedded=mf.getFieldValue(entity);
        if (embedded != null) {
          if (mf.isMap()) {
            Map<?,?> map=(Map<?,?>)embedded;
            for (            Map.Entry<?,?> entry : map.entrySet()) {
              Object key=entry.getKey();
              Object value=entry.getValue();
              Class<? extends Object> keyClass=entry.getKey().getClass();
              Class<? extends Object> valueClass=entry.getValue().getClass();
              if (mapr.isMapped(keyClass)) {
                mapr.getMappedClass(keyClass).callLifecycleMethods(PostPersist.class,key,dbObj,mapr);
                firePostPersistForChildren(key,dbObj,mapr);
              }
              if (mapr.isMapped(valueClass)) {
                mapr.getMappedClass(valueClass).callLifecycleMethods(PostPersist.class,value,dbObj,mapr);
                firePostPersistForChildren(value,dbObj,mapr);
              }
            }
          }
 else           if (mf.isMultipleValues()) {
            Iterable col=(Iterable)embedded;
            for (            Object o : col) {
              Class<? extends Object> clazz=o.getClass();
              if (mapr.isMapped(clazz)) {
                mapr.getMappedClass(clazz).callLifecycleMethods(PostPersist.class,o,dbObj,mapr);
                firePostPersistForChildren(o,dbObj,mapr);
              }
            }
          }
 else {
            MappedClass embedClass=mapr.getMappedClass(embedded);
            embedClass.callLifecycleMethods(PostPersist.class,embedded,dbObj,mapr);
            firePostPersistForChildren(embedded,dbObj,mapr);
          }
        }
      }
    }
 catch (    Exception e) {
      throw new MappingException(""String_Node_Str"" + mf.getFullName(),e);
    }
  }
}","private void firePostPersistForChildren(LinkedHashMap<Object,DBObject> involvedObjects,Mapper mapr){
  for (  Map.Entry<Object,DBObject> e : involvedObjects.entrySet()) {
    Object entity=e.getKey();
    DBObject dbObj=e.getValue();
    MappedClass mc=mapr.getMappedClass(entity);
    mc.callLifecycleMethods(PostPersist.class,entity,dbObj,mapr);
  }
}",0.1030405405405405
104910,"/** 
 * converts an entity to a DBObject 
 */
public DBObject toDBObject(Object entity){
  BasicDBObject dbObject=new BasicDBObject();
  MappedClass mc=getMappedClass(entity);
  dbObject.put(CLASS_NAME_FIELDNAME,entity.getClass().getCanonicalName());
  dbObject=(BasicDBObject)mc.callLifecycleMethods(PrePersist.class,entity,dbObject,this);
  for (  MappedField mf : mc.getPersistenceFields()) {
    try {
      if (mf.hasAnnotation(Id.class)) {
        Object dbVal=mf.getFieldValue(entity);
        if (dbVal != null) {
          dbObject.put(ID_KEY,objectToValue(asObjectIdMaybe(dbVal)));
        }
      }
 else       if (mf.hasAnnotation(Reference.class)) {
        mapReferencesToDBObject(entity,mf,dbObject);
      }
 else       if (mf.hasAnnotation(Embedded.class) && !mf.isTypeMongoCompatible()) {
        mapEmbeddedToDBObject(entity,mf,dbObject);
      }
 else       if (mf.hasAnnotation(Property.class) || mf.hasAnnotation(Serialized.class) || mf.isTypeMongoCompatible()) {
        mapValuesToDBObject(entity,mf,dbObject);
      }
 else {
        logger.warning(""String_Node_Str"" + mf.getFullName() + ""String_Node_Str""+ mf.getType().getSimpleName()+ ""String_Node_Str"");
      }
    }
 catch (    Exception e) {
      throw new MappingException(""String_Node_Str"" + mf.getFullName(),e);
    }
  }
  mc.callLifecycleMethods(PreSave.class,entity,dbObject,this);
  return dbObject;
}","/** 
 * converts an entity to a DBObject
 */
public DBObject toDBObject(Object entity,LinkedHashMap<Object,DBObject> involvedObjects){
  BasicDBObject dbObject=new BasicDBObject();
  MappedClass mc=getMappedClass(entity);
  dbObject.put(CLASS_NAME_FIELDNAME,entity.getClass().getCanonicalName());
  dbObject=(BasicDBObject)mc.callLifecycleMethods(PrePersist.class,entity,dbObject,this);
  for (  MappedField mf : mc.getPersistenceFields()) {
    try {
      if (mf.hasAnnotation(Id.class)) {
        Object dbVal=mf.getFieldValue(entity);
        if (dbVal != null) {
          dbObject.put(ID_KEY,objectToValue(asObjectIdMaybe(dbVal)));
        }
      }
 else       if (mf.hasAnnotation(Reference.class)) {
        mapReferencesToDBObject(entity,mf,dbObject);
      }
 else       if (mf.hasAnnotation(Embedded.class) && !mf.isTypeMongoCompatible()) {
        mapEmbeddedToDBObject(entity,mf,dbObject,involvedObjects);
      }
 else       if (mf.hasAnnotation(Property.class) || mf.hasAnnotation(Serialized.class) || mf.isTypeMongoCompatible()) {
        mapValuesToDBObject(entity,mf,dbObject);
      }
 else {
        logger.warning(""String_Node_Str"" + mf.getFullName() + ""String_Node_Str""+ mf.getType().getSimpleName()+ ""String_Node_Str"");
      }
    }
 catch (    Exception e) {
      throw new MappingException(""String_Node_Str"" + mf.getFullName(),e);
    }
  }
  if (involvedObjects != null)   involvedObjects.put(entity,dbObject);
  mc.callLifecycleMethods(PreSave.class,entity,dbObject,this);
  return dbObject;
}",0.9536560247167868
104911,"void mapEmbeddedToDBObject(Object entity,MappedField mf,BasicDBObject dbObject){
  String name=mf.getName();
  Object fieldValue=null;
  try {
    fieldValue=mf.getFieldValue(entity);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  if (mf.isMap()) {
    Map<String,Object> map=(Map<String,Object>)fieldValue;
    if (map != null) {
      BasicDBObject values=new BasicDBObject();
      for (      Map.Entry<String,Object> entry : map.entrySet()) {
        Object entryVal=entry.getValue();
        DBObject convertedVal=toDBObject(entryVal);
        if (mf.getSubType().equals(entryVal.getClass()))         convertedVal.removeField(Mapper.CLASS_NAME_FIELDNAME);
        String strKey=objectToValue(entry.getKey()).toString();
        values.put(strKey,convertedVal);
      }
      if (values.size() > 0)       dbObject.put(name,values);
    }
  }
 else   if (mf.isMultipleValues()) {
    Iterable coll=(Iterable)fieldValue;
    if (coll != null) {
      List values=new ArrayList();
      for (      Object o : coll) {
        DBObject dbObj=toDBObject(o);
        if (mf.getSubType().equals(o.getClass()))         dbObj.removeField(Mapper.CLASS_NAME_FIELDNAME);
        values.add(dbObj);
      }
      if (values.size() > 0)       dbObject.put(name,values);
    }
  }
 else {
    DBObject dbObj=fieldValue == null ? null : toDBObject(fieldValue);
    if (dbObj != null) {
      if (mf.getType().equals(fieldValue.getClass()))       dbObj.removeField(Mapper.CLASS_NAME_FIELDNAME);
      if (dbObj.keySet().size() > 0)       dbObject.put(name,dbObj);
    }
  }
}","void mapEmbeddedToDBObject(Object entity,MappedField mf,BasicDBObject dbObject,LinkedHashMap<Object,DBObject> involvedObjects){
  String name=mf.getName();
  Object fieldValue=null;
  try {
    fieldValue=mf.getFieldValue(entity);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  if (mf.isMap()) {
    Map<String,Object> map=(Map<String,Object>)fieldValue;
    if (map != null) {
      BasicDBObject values=new BasicDBObject();
      for (      Map.Entry<String,Object> entry : map.entrySet()) {
        Object entryVal=entry.getValue();
        DBObject convertedVal=toDBObject(entryVal,involvedObjects);
        if (mf.getSubType().equals(entryVal.getClass()))         convertedVal.removeField(Mapper.CLASS_NAME_FIELDNAME);
        String strKey=objectToValue(entry.getKey()).toString();
        values.put(strKey,convertedVal);
      }
      if (values.size() > 0)       dbObject.put(name,values);
    }
  }
 else   if (mf.isMultipleValues()) {
    Iterable coll=(Iterable)fieldValue;
    if (coll != null) {
      List values=new ArrayList();
      for (      Object o : coll) {
        DBObject dbObj=toDBObject(o,involvedObjects);
        if (mf.getSubType().equals(o.getClass()))         dbObj.removeField(Mapper.CLASS_NAME_FIELDNAME);
        values.add(dbObj);
      }
      if (values.size() > 0)       dbObject.put(name,values);
    }
  }
 else {
    DBObject dbObj=fieldValue == null ? null : toDBObject(fieldValue,involvedObjects);
    if (dbObj != null) {
      if (mf.getType().equals(fieldValue.getClass()))       dbObj.removeField(Mapper.CLASS_NAME_FIELDNAME);
      if (dbObj.keySet().size() > 0)       dbObject.put(name,dbObj);
    }
  }
}",0.970885688017162
104912,"public void save(T entity){
  DBObject dbObj=morphia.getMapper().toDBObject(entity);
  morphia.getMapper().getMappedClass(entity).callLifecycleMethods(PreSave.class,entity,dbObj,morphia.getMapper());
  collection().save(dbObj);
  DBObject lastErr=collection().getDB().getLastError();
  if (lastErr.get(""String_Node_Str"") != null)   throw new MappingException(""String_Node_Str"" + lastErr.toString());
  morphia.getMapper().updateKeyInfo(entity,dbObj.get(Mapper.ID_KEY),collectionName);
  morphia.getMapper().getMappedClass(entity).callLifecycleMethods(PostPersist.class,entity,dbObj,morphia.getMapper());
}","public void save(T entity){
  DBObject dbObj=morphia.getMapper().toDBObject(entity);
  collection().save(dbObj);
  DBObject lastErr=collection().getDB().getLastError();
  if (lastErr.get(""String_Node_Str"") != null)   throw new MappingException(""String_Node_Str"" + lastErr.toString());
  morphia.getMapper().updateKeyInfo(entity,dbObj.get(Mapper.ID_KEY),collectionName);
  morphia.getMapper().getMappedClass(entity).callLifecycleMethods(PostPersist.class,entity,dbObj,morphia.getMapper());
}",0.8949771689497716
104913,"Object fromDBObject(Class entityClass,BasicDBObject dbObject){
  entityCache.set(new HashMap<String,Object>());
  Object entity=createEntityInstanceForDbObject(entityClass,dbObject);
  mapDBObjectToEntity(dbObject,entity);
  entityCache.remove();
  return entity;
}","Object fromDBObject(Class entityClass,BasicDBObject dbObject){
  if (dbObject == null) {
    Throwable t=new Throwable();
    logger.log(Level.SEVERE,""String_Node_Str"",t);
    return null;
  }
  entityCache.set(new HashMap<String,Object>());
  Object entity=createEntityInstanceForDbObject(entityClass,dbObject);
  mapDBObjectToEntity(dbObject,entity);
  entityCache.remove();
  return entity;
}",0.803030303030303
104914,"void updateKeyInfo(Object entity,DBObject dbObj){
  MappedClass mc=getMappedClass(entity);
  if (mc.idField != null) {
    try {
      Object value=mc.idField.get(entity);
      Object dbId=dbObj.get(Mapper.ID_KEY);
      if (value != null) {
        if (!value.equals(dbId))         throw new RuntimeException(""String_Node_Str"" + value + ""String_Node_Str""+ dbId+ ""String_Node_Str""+ entity.getClass().getSimpleName());
      }
 else {
        if (dbId instanceof ObjectId && mc.idField.getType().isAssignableFrom(String.class)) {
          dbId=dbId.toString();
        }
        mc.idField.set(entity,dbId);
      }
    }
 catch (    Exception e) {
      if (e.getClass().equals(RuntimeException.class))       throw (RuntimeException)e;
      throw new RuntimeException(e);
    }
  }
  if (mc.collectionNameField != null) {
    try {
      String value=(String)mc.collectionNameField.get(entity);
      String dbNs=dbObj.get(""String_Node_Str"").toString();
      if (value != null && value.length() > 0) {
        if (value != null && !value.equals(dbNs))         throw new RuntimeException(""String_Node_Str"" + value + ""String_Node_Str""+ dbNs+ ""String_Node_Str""+ entity.getClass().getSimpleName());
      }
 else       if (value == null)       mc.collectionNameField.set(entity,dbNs);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
}","void updateKeyInfo(Object entity,DBObject dbObj){
  MappedClass mc=getMappedClass(entity);
  if (mc.idField != null) {
    try {
      Object value=mc.idField.get(entity);
      Object dbId=dbObj.get(Mapper.ID_KEY);
      if (value != null) {
        if (!dbId.equals(value))         throw new RuntimeException(""String_Node_Str"" + value + ""String_Node_Str""+ dbId+ ""String_Node_Str""+ entity.getClass().getSimpleName());
      }
 else {
        if (dbId instanceof ObjectId && mc.idField.getType().isAssignableFrom(String.class)) {
          dbId=dbId.toString();
        }
        mc.idField.set(entity,dbId);
      }
    }
 catch (    Exception e) {
      if (e.getClass().equals(RuntimeException.class))       throw (RuntimeException)e;
      throw new RuntimeException(e);
    }
  }
  if (mc.collectionNameField != null) {
    try {
      String value=(String)mc.collectionNameField.get(entity);
      String dbNs=dbObj.get(""String_Node_Str"").toString();
      if (value != null && value.length() > 0) {
        if (value != null && !value.equals(dbNs))         throw new RuntimeException(""String_Node_Str"" + value + ""String_Node_Str""+ dbNs+ ""String_Node_Str""+ entity.getClass().getSimpleName());
      }
 else       if (value == null)       mc.collectionNameField.set(entity,dbNs);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
}",0.9912152269399708
104915,"/** 
 * Returns the (first) instance of the annotation, on the class (or any superclass, or interfaces implemented).
 */
protected static <T>T getAnnotation(Class c,Class<T> ann){
  if (c.isAnnotationPresent(ann)) {
    return (T)c.getAnnotation(ann);
  }
 else {
    Class parent=c.getSuperclass();
    while (parent != null && parent != Object.class) {
      if (parent.isAnnotationPresent(ann)) {
        return (T)parent.getAnnotation(ann);
      }
      for (      Class interfaceClass : parent.getInterfaces()) {
        if (interfaceClass.isAnnotationPresent(ann)) {
          return (T)interfaceClass.getAnnotation(ann);
        }
      }
      parent=parent.getSuperclass();
    }
    for (    Class interfaceClass : c.getInterfaces()) {
      if (interfaceClass.isAnnotationPresent(ann)) {
        return (T)interfaceClass.getAnnotation(ann);
      }
    }
  }
  return null;
}","/** 
 * Returns the (first) instance of the annotation, on the class (or any superclass, or interfaces implemented).
 */
public static <T>T getAnnotation(Class c,Class<T> ann){
  if (c.isAnnotationPresent(ann)) {
    return (T)c.getAnnotation(ann);
  }
 else {
    Class parent=c.getSuperclass();
    while (parent != null && parent != Object.class) {
      if (parent.isAnnotationPresent(ann)) {
        return (T)parent.getAnnotation(ann);
      }
      for (      Class interfaceClass : parent.getInterfaces()) {
        if (interfaceClass.isAnnotationPresent(ann)) {
          return (T)interfaceClass.getAnnotation(ann);
        }
      }
      parent=parent.getSuperclass();
    }
    for (    Class interfaceClass : c.getInterfaces()) {
      if (interfaceClass.isAnnotationPresent(ann)) {
        return (T)interfaceClass.getAnnotation(ann);
      }
    }
  }
  return null;
}",0.9926595143986447
104916,"public MappedClass(Class clazz){
  this.clazz=clazz;
  for (  Class<Annotation> c : interestingAnnotations) {
    addAnnotation(c);
  }
  embeddedAn=ReflectionUtils.getClassEmbeddedAnnotation(clazz);
  entityAn=ReflectionUtils.getClassEntityAnnotation(clazz);
  defCollName=(entityAn == null || entityAn.value().equals(Mapper.IGNORED_FIELDNAME)) ? clazz.getSimpleName() : entityAn.value();
  for (  Field field : ReflectionUtils.getDeclaredAndInheritedFields(clazz,false)) {
    if (field.isAnnotationPresent(Id.class)) {
      idField=field;
      persistenceFields.add(new MappedField(field));
    }
 else     if (field.isAnnotationPresent(Transient.class)) {
      continue;
    }
 else     if (field.isAnnotationPresent(CollectionName.class)) {
      collectionNameField=field;
      persistenceFields.add(new MappedField(field));
    }
 else     if (field.isAnnotationPresent(Property.class) || field.isAnnotationPresent(Reference.class) || field.isAnnotationPresent(Embedded.class)|| isSupportedType(field.getType())) {
      persistenceFields.add(new MappedField(field));
    }
 else {
      logger.warning(""String_Node_Str"" + clazz.getName() + ""String_Node_Str""+ field.getName()+ ""String_Node_Str""+ field.getType().getSimpleName()+ ""String_Node_Str"");
    }
  }
}","/** 
 * constructor 
 */
public MappedClass(Class clazz){
  this.clazz=clazz;
  for (  Class<Annotation> c : classAnnotations) {
    addAnnotation(c);
  }
  for (  Method m : ReflectionUtils.getDeclaredAndInheritedMethods(clazz)) {
    Class<? extends Annotation> lifecycleType;
    if (m.isAnnotationPresent(PrePersist.class))     lifecycleType=PrePersist.class;
 else     if (m.isAnnotationPresent(PostPersist.class))     lifecycleType=PostPersist.class;
 else     if (m.isAnnotationPresent(PreLoad.class))     lifecycleType=PreLoad.class;
 else     if (m.isAnnotationPresent(PostLoad.class))     lifecycleType=PostLoad.class;
 else     continue;
    addLifecycleEventMethod((Class<Annotation>)lifecycleType,m);
  }
  embeddedAn=(Embedded)this.releventAnnotations.get(Embedded.class);
  entityAn=(Entity)this.releventAnnotations.get(Entity.class);
  defCollName=(entityAn == null || entityAn.value().equals(Mapper.IGNORED_FIELDNAME)) ? clazz.getSimpleName() : entityAn.value();
  for (  Field field : ReflectionUtils.getDeclaredAndInheritedFields(clazz,false)) {
    if (field.isAnnotationPresent(Id.class)) {
      idField=field;
      persistenceFields.add(new MappedField(field));
    }
 else     if (field.isAnnotationPresent(Transient.class)) {
      continue;
    }
 else     if (field.isAnnotationPresent(CollectionName.class)) {
      collectionNameField=field;
      persistenceFields.add(new MappedField(field));
    }
 else     if (field.isAnnotationPresent(Property.class) || field.isAnnotationPresent(Reference.class) || field.isAnnotationPresent(Embedded.class)|| isSupportedType(field.getType())) {
      persistenceFields.add(new MappedField(field));
    }
 else {
      logger.warning(""String_Node_Str"" + clazz.getName() + ""String_Node_Str""+ field.getName()+ ""String_Node_Str""+ field.getType().getSimpleName()+ ""String_Node_Str"");
    }
  }
}",0.7407407407407407
104917,"DBObject toDBObject(Object entity) throws Exception {
  BasicDBObject dbObject=new BasicDBObject();
  dbObject.put(CLASS_NAME_KEY,entity.getClass().getCanonicalName());
  String collName=getCollectionName(entity);
  if (collName != null && collName.length() > 0)   dbObject.put(COLLECTION_NAME_KEY,collName);
  MappedClass mc=getMappedClass(entity);
  if (mc == null)   mc=new MappedClass(entity.getClass());
  for (  MappedField mf : mc.persistenceFields) {
    Field field=mf.field;
    Class fieldType=field.getType();
    field.setAccessible(true);
    if (mf.hasAnnotation(Id.class)) {
      Object value=field.get(entity);
      if (value != null) {
        dbObject.put(ID_KEY,fixupId(value));
      }
    }
 else     if (mf.hasAnnotation(Reference.class)) {
      mapReferencesToDBObject(entity,mf,dbObject);
    }
 else     if (mf.hasAnnotation(Embedded.class)) {
      mapEmbeddedToDBObject(entity,mf,dbObject);
    }
 else     if (mf.hasAnnotation(Property.class) || ReflectionUtils.isPropertyType(field.getType()) || ReflectionUtils.implementsAnyInterface(fieldType,Map.class,List.class,Set.class)) {
      mapValuesToDBObject(entity,mf,dbObject);
    }
 else {
      logger.warning(""String_Node_Str"" + field.getName() + ""String_Node_Str""+ field.getType().getSimpleName()+ ""String_Node_Str"");
    }
  }
  return dbObject;
}","DBObject toDBObject(Object entity) throws Exception {
  BasicDBObject dbObject=new BasicDBObject();
  dbObject.put(CLASS_NAME_KEY,entity.getClass().getCanonicalName());
  MappedClass mc=getMappedClass(entity);
  if (mc == null)   mc=new MappedClass(entity.getClass());
  String collName=(mc.collectionNameField == null) ? null : (String)mc.collectionNameField.get(entity);
  if (collName != null && collName.length() > 0)   dbObject.put(COLLECTION_NAME_KEY,collName);
  for (  MappedField mf : mc.persistenceFields) {
    Field field=mf.field;
    Class fieldType=field.getType();
    field.setAccessible(true);
    if (mf.hasAnnotation(Id.class)) {
      Object value=field.get(entity);
      if (value != null) {
        dbObject.put(ID_KEY,fixupId(value));
      }
    }
 else     if (mf.hasAnnotation(Reference.class)) {
      mapReferencesToDBObject(entity,mf,dbObject);
    }
 else     if (mf.hasAnnotation(Embedded.class)) {
      mapEmbeddedToDBObject(entity,mf,dbObject);
    }
 else     if (mf.hasAnnotation(Property.class) || ReflectionUtils.isPropertyType(field.getType()) || ReflectionUtils.implementsAnyInterface(fieldType,Map.class,List.class,Set.class)) {
      mapValuesToDBObject(entity,mf,dbObject);
    }
 else {
      logger.warning(""String_Node_Str"" + field.getName() + ""String_Node_Str""+ field.getType().getSimpleName()+ ""String_Node_Str"");
    }
  }
  return dbObject;
}",0.8926346647123489
104918,"@Override public T save(T entity){
  BasicDBObject obj=(BasicDBObject)morphia.toDBObject(entity);
  collection().save(obj);
  return get(obj.get(""String_Node_Str"").toString());
}","@Override public T save(T entity){
  BasicDBObject obj=(BasicDBObject)morphia.toDBObject(entity);
  obj.put(Mapper.COLLECTION_NAME_KEY,collection().getName());
  collection().save(obj);
  return get(obj.get(""String_Node_Str"").toString());
}",0.8516746411483254
104919,"@Test public void testCollectionNames() throws Exception {
  assertTrue(""String_Node_Str"".equals(morphia.getMapper().getCollectionName(FacebookUser.class)));
}","@Test public void testCollectionNames() throws Exception {
  assertEquals(""String_Node_Str"",morphia.getMapper().getCollectionName(FacebookUser.class));
}",0.9423076923076924
104920,"@Override public WebResourceResponse shouldInterceptRequest(WebView view,WebResourceRequest resourceRequest){
  if (!mTrackingProtectionEnabled && !mAdblockEnabled && !mHttpsEverywhereEnabled) {
    return null;
  }
  String filterOption=""String_Node_Str"";
  Map<String,String> requestHeaders=resourceRequest.getRequestHeaders();
  for (  Map.Entry<String,String> entry : requestHeaders.entrySet()) {
    if (entry.getKey().equals(""String_Node_Str"")) {
      if (entry.getValue().contains(""String_Node_Str"")) {
        filterOption=""String_Node_Str"";
        break;
      }
 else       if (entry.getValue().contains(""String_Node_Str"")) {
        filterOption=""String_Node_Str"";
        break;
      }
 else       if (entry.getValue().contains(""String_Node_Str"")) {
        filterOption=""String_Node_Str"";
        break;
      }
    }
  }
  return interceptTheCall(view,resourceRequest.getUrl().toString(),filterOption,true);
}","@Override public WebResourceResponse shouldInterceptRequest(WebView view,WebResourceRequest resourceRequest){
  String currentUrl=resourceRequest.getUrl().toString();
  if (!mTrackingProtectionEnabled && !mAdblockEnabled && !mHttpsEverywhereEnabled || mUrl.toString().equals(currentUrl)) {
    return null;
  }
  String filterOption=""String_Node_Str"";
  Map<String,String> requestHeaders=resourceRequest.getRequestHeaders();
  for (  Map.Entry<String,String> entry : requestHeaders.entrySet()) {
    if (entry.getKey().equals(""String_Node_Str"")) {
      if (entry.getValue().contains(""String_Node_Str"")) {
        filterOption=""String_Node_Str"";
        break;
      }
 else       if (entry.getValue().contains(""String_Node_Str"")) {
        filterOption=""String_Node_Str"";
        break;
      }
 else       if (entry.getValue().contains(""String_Node_Str"")) {
        filterOption=""String_Node_Str"";
        break;
      }
    }
  }
  return interceptTheCall(view,currentUrl,filterOption,true);
}",0.931321540062435
104921,"public void show(){
  int duration=667;
  if (mView.getVisibility() != View.VISIBLE) {
    duration=500;
    mView.animate().cancel();
    mView.setAlpha(0f);
    mView.setVisibility(View.VISIBLE);
    mView.setScaleX(0.33f);
    mView.setScaleY(0.33f);
  }
 else   if (mAnimState == AnimState.Hiding) {
    mView.animate().cancel();
    mView.setVisibility(View.VISIBLE);
  }
  mView.animate().alpha(mAlpha).scaleX(1f).scaleY(1f).setDuration(duration).setInterpolator(new AnticipateOvershootInterpolator()).setListener(mShowListener);
}","public void show(){
  int duration=667;
  if (mView.getVisibility() != View.VISIBLE) {
    duration=500;
    mView.animate().cancel();
    mView.setAlpha(0f);
    mView.setScaleX(0.33f);
    mView.setScaleY(0.33f);
  }
 else   if (mAnimState == AnimState.Hiding) {
    mView.animate().cancel();
  }
  mView.setVisibility(View.VISIBLE);
  mView.animate().alpha(mAlpha).scaleX(1f).scaleY(1f).setDuration(duration).setInterpolator(new AnticipateOvershootInterpolator()).setListener(mShowListener);
}",0.6931268151016456
104922,"public void doUpdateVisitedHistory(String url,boolean isReload);","public void doUpdateVisitedHistory(String url,boolean isReload,boolean unknownClick);",0.8590604026845637
104923,"@Override public void doUpdateVisitedHistory(WebView view,String url,boolean isReload){
  mController.doUpdateVisitedHistory(url,isReload);
}","@Override public void doUpdateVisitedHistory(WebView view,String url,boolean isReload){
  String extraRes=mWebView.getHitTestResult().getExtra();
  if (null == extraRes || (null != extraRes && url.equals(extraRes))) {
    mController.doUpdateVisitedHistory(url,isReload,mWebView.getHitTestResult().getType() == WebView.HitTestResult.UNKNOWN_TYPE);
  }
}",0.5708502024291497
104924,"public void adjustBubblesPanel(int newX,int newY,int oldX,int oldY,boolean afterTouchAdjust,boolean resetToOriginal){
  if (!afterTouchAdjust && !resetToOriginal && (null == mOriginalBubbleFlowDraggableParams || (mPreviousBubbleAdjustmentValue - newY > -5 && mPreviousBubbleAdjustmentValue - newY < 5))) {
    return;
  }
  mPreviousBubbleAdjustmentValue=newY;
  int adjustOn=newY - oldY;
  FrameLayout.LayoutParams currentParams=null;
  try {
    currentParams=(FrameLayout.LayoutParams)mBubbleFlowDraggable.getChildAt(0).getLayoutParams();
  }
 catch (  NullPointerException exc) {
  }
  if (null == currentParams) {
    return;
  }
  boolean originalTopMargin=false;
  boolean heightSizeTopMargin=false;
  if (!afterTouchAdjust && 0 == oldY && adjustOn > -5 && adjustOn < 5 || resetToOriginal) {
    currentParams.topMargin=mOriginalBubbleFlowDraggableLayoutTopMargin;
    originalTopMargin=true;
  }
 else   if (0 == adjustOn) {
    int half=(mOriginalBubbleFlowDraggableParams.height + currentParams.height) / 2;
    if (0 - currentParams.topMargin > half) {
      currentParams.topMargin=0 - (mOriginalBubbleFlowDraggableParams.height + currentParams.height);
      heightSizeTopMargin=true;
    }
 else {
      currentParams.topMargin=mOriginalBubbleFlowDraggableLayoutTopMargin;
      originalTopMargin=true;
    }
  }
 else {
    currentParams.topMargin-=adjustOn;
    if (currentParams.topMargin + (mOriginalBubbleFlowDraggableParams.height + currentParams.height) < 0) {
      currentParams.topMargin=0 - (mOriginalBubbleFlowDraggableParams.height + currentParams.height);
      heightSizeTopMargin=true;
    }
 else     if (currentParams.topMargin > 0) {
      currentParams.topMargin=mOriginalBubbleFlowDraggableLayoutTopMargin;
      originalTopMargin=true;
    }
  }
  TabView currentTabView=getCurrentTab();
  if (null != currentTabView) {
    if (currentTabView.adjustBubblesPanel(adjustOn,originalTopMargin,heightSizeTopMargin)) {
      mBubbleFlowDraggable.getChildAt(0).setLayoutParams(currentParams);
    }
  }
  if (!heightSizeTopMargin) {
    mBubbleFlowDraggable.setVisibility(View.VISIBLE);
  }
 else {
    mBubbleFlowDraggable.setVisibility(View.GONE);
  }
}","public void adjustBubblesPanel(int newX,int newY,int oldX,int oldY,boolean afterTouchAdjust,boolean resetToOriginal){
  if (!afterTouchAdjust && !resetToOriginal && (null == mOriginalBubbleFlowDraggableParams || (mPreviousBubbleAdjustmentValue - newY > -5 && mPreviousBubbleAdjustmentValue - newY < 5))) {
    return;
  }
  mPreviousBubbleAdjustmentValue=newY;
  int adjustOn=newY - oldY;
  FrameLayout.LayoutParams currentParams=null;
  try {
    currentParams=(FrameLayout.LayoutParams)mBubbleFlowDraggable.getChildAt(0).getLayoutParams();
  }
 catch (  NullPointerException exc) {
  }
  if (null == currentParams) {
    return;
  }
  boolean originalTopMargin=false;
  boolean heightSizeTopMargin=false;
  if (!afterTouchAdjust && 0 == oldY && adjustOn > -5 && adjustOn < 5 || resetToOriginal) {
    currentParams.topMargin=mOriginalBubbleFlowDraggableLayoutTopMargin;
    originalTopMargin=true;
  }
 else   if (0 == adjustOn) {
    int half=(mOriginalBubbleFlowDraggableParams.height + currentParams.height) / 2;
    if (0 - currentParams.topMargin > half) {
      currentParams.topMargin=0 - (mOriginalBubbleFlowDraggableParams.height + currentParams.height);
      heightSizeTopMargin=true;
    }
 else {
      currentParams.topMargin=mOriginalBubbleFlowDraggableLayoutTopMargin;
      originalTopMargin=true;
    }
  }
 else {
    currentParams.topMargin-=adjustOn;
    if (currentParams.topMargin + (mOriginalBubbleFlowDraggableParams.height + currentParams.height) < 0) {
      currentParams.topMargin=0 - (mOriginalBubbleFlowDraggableParams.height + currentParams.height);
      heightSizeTopMargin=true;
    }
 else     if (currentParams.topMargin > 0) {
      currentParams.topMargin=mOriginalBubbleFlowDraggableLayoutTopMargin;
      originalTopMargin=true;
    }
  }
  TabView currentTabView=getCurrentTab();
  if (null != currentTabView) {
    if (currentTabView.adjustBubblesPanel(adjustOn,originalTopMargin,heightSizeTopMargin)) {
      mBubbleFlowDraggable.getChildAt(0).setLayoutParams(currentParams);
    }
  }
  if (!heightSizeTopMargin) {
    if (mBubbleFlowDraggable.isExpanded()) {
      mBubbleFlowDraggable.setVisibility(View.VISIBLE);
    }
  }
 else {
    mBubbleFlowDraggable.setVisibility(View.GONE);
  }
}",0.9880117620447862
104925,"public void collapseBubbleFlow(long time){
  try {
    FrameLayout.LayoutParams currentParams=(FrameLayout.LayoutParams)mBubbleFlowDraggable.getChildAt(0).getLayoutParams();
    currentParams.topMargin=mOriginalBubbleFlowDraggableLayoutTopMargin;
    TabView currentTabView=getCurrentTab();
    if (null != currentTabView) {
      if (currentTabView.adjustBubblesPanel(0,true,false)) {
        mBubbleFlowDraggable.getChildAt(0).setLayoutParams(currentParams);
      }
    }
    mBubbleFlowDraggable.setVisibility(View.VISIBLE);
  }
 catch (  NullPointerException exc) {
  }
  mBubbleFlowDraggable.collapse(time,mOnBubbleFlowCollapseFinishedListener);
}","public void collapseBubbleFlow(long time){
  try {
    FrameLayout.LayoutParams currentParams=(FrameLayout.LayoutParams)mBubbleFlowDraggable.getChildAt(0).getLayoutParams();
    currentParams.topMargin=mOriginalBubbleFlowDraggableLayoutTopMargin;
    TabView currentTabView=getCurrentTab();
    if (null != currentTabView) {
      if (currentTabView.adjustBubblesPanel(0,true,false)) {
        mBubbleFlowDraggable.getChildAt(0).setLayoutParams(currentParams);
      }
    }
    if (mBubbleFlowDraggable.isExpanded()) {
      mBubbleFlowDraggable.setVisibility(View.VISIBLE);
    }
  }
 catch (  NullPointerException exc) {
  }
  mBubbleFlowDraggable.collapse(time,mOnBubbleFlowCollapseFinishedListener);
}",0.9610007358351728
104926,"boolean isExpanded(){
  return mIsExpanded;
}","public boolean isExpanded(){
  return mIsExpanded;
}",0.9278350515463918
104927,"void setTabAsActive(){
  if (mUrlTextView.getText().toString().equals(getContext().getString(R.string.empty_bubble_page))) {
    mTitleTextView.performClick();
  }
}","void setTabAsActive(){
  if (mUrlTextView.getText().toString().equals(getContext().getString(R.string.empty_bubble_page))) {
    mTitleTextView.performClick();
  }
 else {
    mWebRenderer.getView().requestFocus();
  }
}",0.8571428571428571
104928,"public TabView openUrl(final String urlAsString,long urlLoadStartTime,final boolean setAsCurrentTab,String openedFromAppName){
  Analytics.trackOpenUrl(openedFromAppName);
  if (wasUrlRecentlyLoaded(urlAsString,urlLoadStartTime) && !urlAsString.equals(mContext.getString(R.string.empty_bubble_page))) {
    Toast.makeText(mContext,R.string.duplicate_link_will_not_be_loaded,Toast.LENGTH_SHORT).show();
    return null;
  }
  URL url;
  try {
    url=new URL(urlAsString);
  }
 catch (  MalformedURLException e) {
    Toast.makeText(mContext,mContext.getString(R.string.unsupported_scheme),Toast.LENGTH_SHORT).show();
    if (getActiveTabCount() == 0 && Prompt.isShowing() == false) {
      finish();
    }
    return null;
  }
  if (Settings.get().redirectUrlToBrowser(url)) {
    Intent intent=new Intent(Intent.ACTION_VIEW);
    intent.setData(Uri.parse(urlAsString));
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_SINGLE_TOP);
    if (MainApplication.openInBrowser(mContext,intent,false)) {
      if (getActiveTabCount() == 0 && Prompt.isShowing() == false) {
        finish();
      }
      String title=String.format(mContext.getString(R.string.link_redirected),Settings.get().getDefaultBrowserLabel());
      MainApplication.saveUrlInHistory(mContext,null,urlAsString,title);
      return null;
    }
  }
  boolean showAppPicker=false;
  PackageManager packageManager=mContext.getPackageManager();
  final List<ResolveInfo> resolveInfos=Settings.get().getAppsThatHandleUrl(url.toString(),packageManager);
  ResolveInfo defaultAppResolveInfo=Settings.get().getDefaultAppForUrl(url,resolveInfos);
  if (resolveInfos != null && resolveInfos.size() > 0) {
    if (defaultAppResolveInfo != null) {
      if (handleResolveInfo(defaultAppResolveInfo,urlAsString,urlLoadStartTime)) {
        return null;
      }
    }
 else     if (resolveInfos.size() == 1) {
      if (handleResolveInfo(resolveInfos.get(0),urlAsString,urlLoadStartTime)) {
        return null;
      }
    }
 else {
      for (      ResolveInfo info : resolveInfos) {
        if (info.activityInfo.packageName.startsWith(""String_Node_Str"")) {
          showAppPicker=false;
          break;
        }
 else {
          showAppPicker=true;
        }
      }
    }
  }
  boolean openedFromItself=false;
  if (null != openedFromAppName && (openedFromAppName.equals(Analytics.OPENED_URL_FROM_NEW_TAB) || openedFromAppName.equals(Analytics.OPENED_URL_FROM_HISTORY))) {
    showAppPicker=true;
    openedFromItself=true;
  }
  mCanAutoDisplayLink=true;
  final TabView result=openUrlInTab(urlAsString,urlLoadStartTime,setAsCurrentTab,showAppPicker);
  if (!openedFromItself && showAppPicker && MainApplication.sShowingAppPickerDialog == false) {
    AlertDialog dialog=ActionItem.getActionItemPickerAlert(mContext,resolveInfos,R.string.pick_default_app,new ActionItem.OnActionItemDefaultSelectedListener(){
      @Override public void onSelected(      ActionItem actionItem,      boolean always){
        boolean loaded=false;
        for (        ResolveInfo resolveInfo : resolveInfos) {
          if (resolveInfo.activityInfo.packageName.equals(actionItem.mPackageName) && resolveInfo.activityInfo.name.equals(actionItem.mActivityClassName)) {
            if (always) {
              Settings.get().setDefaultApp(urlAsString,resolveInfo);
            }
            if (resolveInfo.activityInfo.packageName.equals(mAppPackageName)) {
              break;
            }
            loaded=MainApplication.loadIntent(mContext,actionItem.mPackageName,actionItem.mActivityClassName,urlAsString,-1,true);
            break;
          }
        }
        if (loaded) {
          Settings.get().addRedirectToApp(urlAsString);
          closeTab(result,contentViewShowing(),false);
          if (getActiveTabCount() == 0 && Prompt.isShowing() == false) {
            finish();
          }
          if (Build.VERSION.SDK_INT > Build.VERSION_CODES.KITKAT) {
            MainController.get().switchToBubbleView();
          }
        }
      }
    }
);
    dialog.setOnDismissListener(new DialogInterface.OnDismissListener(){
      @Override public void onDismiss(      DialogInterface dialog){
        MainApplication.sShowingAppPickerDialog=false;
      }
    }
);
    dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
    Util.showThemedDialog(dialog);
    MainApplication.sShowingAppPickerDialog=true;
  }
  return result;
}","public TabView openUrl(final String urlAsString,long urlLoadStartTime,final boolean setAsCurrentTab,String openedFromAppName){
  Analytics.trackOpenUrl(openedFromAppName);
  if (wasUrlRecentlyLoaded(urlAsString,urlLoadStartTime) && !urlAsString.equals(mContext.getString(R.string.empty_bubble_page))) {
    Toast.makeText(mContext,R.string.duplicate_link_will_not_be_loaded,Toast.LENGTH_SHORT).show();
    return null;
  }
  URL url;
  try {
    url=new URL(urlAsString);
  }
 catch (  MalformedURLException e) {
    Toast.makeText(mContext,mContext.getString(R.string.unsupported_scheme),Toast.LENGTH_SHORT).show();
    if (getActiveTabCount() == 0 && Prompt.isShowing() == false) {
      finish();
    }
    return null;
  }
  if (Settings.get().redirectUrlToBrowser(url)) {
    Intent intent=new Intent(Intent.ACTION_VIEW);
    intent.setData(Uri.parse(urlAsString));
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_SINGLE_TOP);
    if (MainApplication.openInBrowser(mContext,intent,false)) {
      if (getActiveTabCount() == 0 && Prompt.isShowing() == false) {
        finish();
      }
      String title=String.format(mContext.getString(R.string.link_redirected),Settings.get().getDefaultBrowserLabel());
      MainApplication.saveUrlInHistory(mContext,null,urlAsString,title);
      return null;
    }
  }
  boolean showAppPicker=false;
  PackageManager packageManager=mContext.getPackageManager();
  final List<ResolveInfo> resolveInfos=Settings.get().getAppsThatHandleUrl(url.toString(),packageManager);
  ResolveInfo defaultAppResolveInfo=Settings.get().getDefaultAppForUrl(url,resolveInfos);
  if (resolveInfos != null && resolveInfos.size() > 0) {
    if (defaultAppResolveInfo != null) {
      if (handleResolveInfo(defaultAppResolveInfo,urlAsString,urlLoadStartTime)) {
        return null;
      }
    }
 else     if (resolveInfos.size() == 1) {
      if (handleResolveInfo(resolveInfos.get(0),urlAsString,urlLoadStartTime)) {
        return null;
      }
    }
 else {
      for (      ResolveInfo info : resolveInfos) {
        if (info.activityInfo.packageName.startsWith(""String_Node_Str"")) {
          showAppPicker=false;
          break;
        }
 else {
          showAppPicker=true;
        }
      }
    }
  }
  boolean openedFromItself=false;
  if (null != openedFromAppName && (openedFromAppName.equals(Analytics.OPENED_URL_FROM_NEW_TAB) || openedFromAppName.equals(Analytics.OPENED_URL_FROM_HISTORY))) {
    showAppPicker=true;
    openedFromItself=true;
  }
  mCanAutoDisplayLink=true;
  final TabView result=openUrlInTab(urlAsString,urlLoadStartTime,setAsCurrentTab,showAppPicker);
  if (!openedFromItself && showAppPicker && MainApplication.sShowingAppPickerDialog == false && 0 != resolveInfos.size()) {
    AlertDialog dialog=ActionItem.getActionItemPickerAlert(mContext,resolveInfos,R.string.pick_default_app,new ActionItem.OnActionItemDefaultSelectedListener(){
      @Override public void onSelected(      ActionItem actionItem,      boolean always){
        boolean loaded=false;
        for (        ResolveInfo resolveInfo : resolveInfos) {
          if (resolveInfo.activityInfo.packageName.equals(actionItem.mPackageName) && resolveInfo.activityInfo.name.equals(actionItem.mActivityClassName)) {
            if (always) {
              Settings.get().setDefaultApp(urlAsString,resolveInfo);
            }
            if (resolveInfo.activityInfo.packageName.equals(mAppPackageName)) {
              break;
            }
            loaded=MainApplication.loadIntent(mContext,actionItem.mPackageName,actionItem.mActivityClassName,urlAsString,-1,true);
            break;
          }
        }
        if (loaded) {
          Settings.get().addRedirectToApp(urlAsString);
          closeTab(result,contentViewShowing(),false);
          if (getActiveTabCount() == 0 && Prompt.isShowing() == false) {
            finish();
          }
          if (Build.VERSION.SDK_INT > Build.VERSION_CODES.KITKAT) {
            MainController.get().switchToBubbleView();
          }
        }
      }
    }
);
    dialog.setOnDismissListener(new DialogInterface.OnDismissListener(){
      @Override public void onDismiss(      DialogInterface dialog){
        MainApplication.sShowingAppPickerDialog=false;
      }
    }
);
    dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
    Util.showThemedDialog(dialog);
    MainApplication.sShowingAppPickerDialog=true;
  }
  return result;
}",0.9968743022996204
104929,"@Override public void onClick(View v){
  if (v.getTag() instanceof ContentView.AppForUrl) {
    ContentView.AppForUrl appForUrl=(ContentView.AppForUrl)v.getTag();
    if (MainApplication.loadIntent(getContext(),appForUrl.mResolveInfo.activityInfo.packageName,appForUrl.mResolveInfo.activityInfo.name,appForUrl.mUrl.toString(),-1,true)) {
      if (mOnOpenInAppClickListener != null) {
        mOnOpenInAppClickListener.onAppOpened();
      }
    }
  }
 else {
    if (mAppsForUrl != null && mAppsForUrl.size() > 1) {
      ArrayList<ResolveInfo> resolveInfos=new ArrayList<ResolveInfo>();
      for (      ContentView.AppForUrl item : mAppsForUrl) {
        resolveInfos.add(item.mResolveInfo);
      }
      AlertDialog dialog=ActionItem.getActionItemPickerAlert(getContext(),resolveInfos,R.string.pick_default_app,new ActionItem.OnActionItemDefaultSelectedListener(){
        @Override public void onSelected(        ActionItem actionItem,        boolean always){
          ContentView.AppForUrl appForUrl=getAppForUrl(actionItem.mPackageName,actionItem.mActivityClassName);
          if (appForUrl != null) {
            if (always) {
              Settings.get().setDefaultApp(appForUrl.mUrl.toString(),appForUrl.mResolveInfo);
            }
            if (MainApplication.loadIntent(getContext(),appForUrl.mResolveInfo.activityInfo.packageName,appForUrl.mResolveInfo.activityInfo.name,appForUrl.mUrl.toString(),-1,true)) {
              if (mOnOpenInAppClickListener != null) {
                mOnOpenInAppClickListener.onAppOpened();
              }
            }
          }
        }
      }
);
      dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
      Util.showThemedDialog(dialog);
    }
  }
}","@Override public void onClick(View v){
  if (v.getTag() instanceof ContentView.AppForUrl) {
    ContentView.AppForUrl appForUrl=(ContentView.AppForUrl)v.getTag();
    if (MainApplication.loadIntent(getContext(),appForUrl.mResolveInfo.activityInfo.packageName,appForUrl.mResolveInfo.activityInfo.name,appForUrl.mUrl.toString(),-1,true)) {
      if (mOnOpenInAppClickListener != null) {
        mOnOpenInAppClickListener.onAppOpened();
      }
    }
  }
 else {
    if (mAppsForUrl != null && mAppsForUrl.size() > 1) {
      ArrayList<ResolveInfo> resolveInfos=new ArrayList<ResolveInfo>();
      for (      ContentView.AppForUrl item : mAppsForUrl) {
        resolveInfos.add(item.mResolveInfo);
      }
      if (0 != resolveInfos.size()) {
        AlertDialog dialog=ActionItem.getActionItemPickerAlert(getContext(),resolveInfos,R.string.pick_default_app,new ActionItem.OnActionItemDefaultSelectedListener(){
          @Override public void onSelected(          ActionItem actionItem,          boolean always){
            ContentView.AppForUrl appForUrl=getAppForUrl(actionItem.mPackageName,actionItem.mActivityClassName);
            if (appForUrl != null) {
              if (always) {
                Settings.get().setDefaultApp(appForUrl.mUrl.toString(),appForUrl.mResolveInfo);
              }
              if (MainApplication.loadIntent(getContext(),appForUrl.mResolveInfo.activityInfo.packageName,appForUrl.mResolveInfo.activityInfo.name,appForUrl.mUrl.toString(),-1,true)) {
                if (mOnOpenInAppClickListener != null) {
                  mOnOpenInAppClickListener.onAppOpened();
                }
              }
            }
          }
        }
);
        dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
        Util.showThemedDialog(dialog);
      }
    }
  }
}",0.9763246899661782
104930,"void onPageLoadComplete(String urlAsString){
  mPageFinishedLoading=true;
  URL currentUrl=mWebRenderer.getUrl();
  boolean equalUrl=currentUrl.toString().equals(urlAsString);
  if (!equalUrl) {
    try {
      URL url=new URL(urlAsString);
      if (url.getProtocol().equals(currentUrl.getProtocol()) && url.getHost().equals(currentUrl.getHost()) && url.getPath().equals(currentUrl.getPath())) {
        equalUrl=true;
      }
    }
 catch (    MalformedURLException e) {
    }
  }
  mWebRenderer.runPageInspector();
  if (equalUrl) {
    updateAppsForUrl(currentUrl);
    configureOpenInAppButton();
    configureOpenEmbedButton();
    configureArticleModeButton();
    mEventHandler.onPageLoaded(false);
    Log.e(TAG,""String_Node_Str"" + urlAsString);
    String title=MainApplication.sTitleHashMap != null ? MainApplication.sTitleHashMap.get(urlAsString) : ""String_Node_Str"";
    if (TextUtils.isEmpty(title)) {
      if (mTitleTextView.getText() != null) {
        String currentTitle=mTitleTextView.getText().toString();
        if (currentTitle.equals(mLoadingString) == false) {
          title=currentTitle;
        }
      }
      if (title == null) {
        mTitleTextView.setText(null);
      }
    }
    if (!currentUrl.toString().equals(getContext().getString(R.string.empty_bubble_page))) {
      mAdapter.addUrlToAutoSuggestion(currentUrl.toString());
      MainApplication.saveUrlInHistory(getContext(),null,currentUrl.toString(),currentUrl.getHost(),title);
    }
 else {
      mTitleTextView.performClick();
    }
    postDelayed(mDelayedAutoContentDisplayLinkLoadedRunnable,Constant.AUTO_CONTENT_DISPLAY_DELAY);
    mWebRenderer.onPageLoadComplete();
  }
  mPageFinishedIgnoredUrl=null;
}","void onPageLoadComplete(String urlAsString){
  mPageFinishedLoading=true;
  URL currentUrl=mWebRenderer.getUrl();
  boolean equalUrl=currentUrl.toString().equals(urlAsString);
  if (!equalUrl) {
    try {
      URL url=new URL(urlAsString);
      if (url.getProtocol().equals(currentUrl.getProtocol()) && url.getHost().equals(currentUrl.getHost()) && url.getPath().equals(currentUrl.getPath())) {
        equalUrl=true;
      }
    }
 catch (    MalformedURLException e) {
    }
  }
  mWebRenderer.runPageInspector();
  if (equalUrl) {
    updateAppsForUrl(currentUrl);
    configureOpenInAppButton();
    configureOpenEmbedButton();
    configureArticleModeButton();
    mEventHandler.onPageLoaded(false);
    Log.e(TAG,""String_Node_Str"" + urlAsString);
    String title=MainApplication.sTitleHashMap != null ? MainApplication.sTitleHashMap.get(urlAsString) : ""String_Node_Str"";
    if (TextUtils.isEmpty(title)) {
      if (mTitleTextView.getText() != null) {
        String currentTitle=mTitleTextView.getText().toString();
        if (currentTitle.equals(mLoadingString) == false) {
          title=currentTitle;
        }
      }
      if (title == null) {
        mTitleTextView.setText(null);
      }
    }
    if (!currentUrl.toString().equals(getContext().getString(R.string.empty_bubble_page))) {
      mAdapter.addUrlToAutoSuggestion(currentUrl.toString());
      MainApplication.saveUrlInHistory(getContext(),null,currentUrl.toString(),currentUrl.getHost(),title);
    }
 else {
      mTitleTextView.performClick();
    }
    postDelayed(mDelayedAutoContentDisplayLinkLoadedRunnable,Constant.AUTO_CONTENT_DISPLAY_DELAY);
    mWebRenderer.onPageLoadComplete();
    mWebRenderer.getView().requestFocus();
  }
  mPageFinishedIgnoredUrl=null;
}",0.9875758451314648
104931,"public TabView openUrl(final String urlAsString,long urlLoadStartTime,final boolean setAsCurrentTab,String openedFromAppName){
  Analytics.trackOpenUrl(openedFromAppName);
  if (wasUrlRecentlyLoaded(urlAsString,urlLoadStartTime) && !urlAsString.equals(mContext.getString(R.string.empty_bubble_page))) {
    Toast.makeText(mContext,R.string.duplicate_link_will_not_be_loaded,Toast.LENGTH_SHORT).show();
    return null;
  }
  URL url;
  try {
    url=new URL(urlAsString);
  }
 catch (  MalformedURLException e) {
    Toast.makeText(mContext,mContext.getString(R.string.unsupported_scheme),Toast.LENGTH_SHORT).show();
    if (getActiveTabCount() == 0 && Prompt.isShowing() == false) {
      finish();
    }
    return null;
  }
  if (Settings.get().redirectUrlToBrowser(url)) {
    Intent intent=new Intent(Intent.ACTION_VIEW);
    intent.setData(Uri.parse(urlAsString));
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_SINGLE_TOP);
    if (MainApplication.openInBrowser(mContext,intent,false)) {
      if (getActiveTabCount() == 0 && Prompt.isShowing() == false) {
        finish();
      }
      String title=String.format(mContext.getString(R.string.link_redirected),Settings.get().getDefaultBrowserLabel());
      MainApplication.saveUrlInHistory(mContext,null,urlAsString,title);
      return null;
    }
  }
  boolean showAppPicker=false;
  PackageManager packageManager=mContext.getPackageManager();
  final List<ResolveInfo> resolveInfos=Settings.get().getAppsThatHandleUrl(url.toString(),packageManager);
  ResolveInfo defaultAppResolveInfo=Settings.get().getDefaultAppForUrl(url,resolveInfos);
  if (resolveInfos != null && resolveInfos.size() > 0) {
    if (defaultAppResolveInfo != null) {
      if (handleResolveInfo(defaultAppResolveInfo,urlAsString,urlLoadStartTime)) {
        return null;
      }
    }
 else     if (resolveInfos.size() == 1) {
      if (handleResolveInfo(resolveInfos.get(0),urlAsString,urlLoadStartTime)) {
        return null;
      }
    }
 else {
      for (      ResolveInfo info : resolveInfos) {
        if (info.activityInfo.packageName.startsWith(""String_Node_Str"")) {
          showAppPicker=false;
          break;
        }
 else {
          showAppPicker=true;
        }
      }
    }
  }
  mCanAutoDisplayLink=true;
  final TabView result=openUrlInTab(urlAsString,urlLoadStartTime,setAsCurrentTab,showAppPicker);
  if (showAppPicker && MainApplication.sShowingAppPickerDialog == false) {
    AlertDialog dialog=ActionItem.getActionItemPickerAlert(mContext,resolveInfos,R.string.pick_default_app,new ActionItem.OnActionItemDefaultSelectedListener(){
      @Override public void onSelected(      ActionItem actionItem,      boolean always){
        boolean loaded=false;
        for (        ResolveInfo resolveInfo : resolveInfos) {
          if (resolveInfo.activityInfo.packageName.equals(actionItem.mPackageName) && resolveInfo.activityInfo.name.equals(actionItem.mActivityClassName)) {
            if (always) {
              Settings.get().setDefaultApp(urlAsString,resolveInfo);
            }
            if (resolveInfo.activityInfo.packageName.equals(mAppPackageName)) {
              break;
            }
            loaded=MainApplication.loadIntent(mContext,actionItem.mPackageName,actionItem.mActivityClassName,urlAsString,-1,true);
            break;
          }
        }
        if (loaded) {
          Settings.get().addRedirectToApp(urlAsString);
          closeTab(result,contentViewShowing(),false);
          if (getActiveTabCount() == 0 && Prompt.isShowing() == false) {
            finish();
          }
          if (Build.VERSION.SDK_INT > Build.VERSION_CODES.KITKAT) {
            MainController.get().switchToBubbleView();
          }
        }
      }
    }
);
    dialog.setOnDismissListener(new DialogInterface.OnDismissListener(){
      @Override public void onDismiss(      DialogInterface dialog){
        MainApplication.sShowingAppPickerDialog=false;
      }
    }
);
    dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
    Util.showThemedDialog(dialog);
    MainApplication.sShowingAppPickerDialog=true;
  }
  return result;
}","public TabView openUrl(final String urlAsString,long urlLoadStartTime,final boolean setAsCurrentTab,String openedFromAppName){
  Analytics.trackOpenUrl(openedFromAppName);
  if (wasUrlRecentlyLoaded(urlAsString,urlLoadStartTime) && !urlAsString.equals(mContext.getString(R.string.empty_bubble_page))) {
    Toast.makeText(mContext,R.string.duplicate_link_will_not_be_loaded,Toast.LENGTH_SHORT).show();
    return null;
  }
  URL url;
  try {
    url=new URL(urlAsString);
  }
 catch (  MalformedURLException e) {
    Toast.makeText(mContext,mContext.getString(R.string.unsupported_scheme),Toast.LENGTH_SHORT).show();
    if (getActiveTabCount() == 0 && Prompt.isShowing() == false) {
      finish();
    }
    return null;
  }
  if (Settings.get().redirectUrlToBrowser(url)) {
    Intent intent=new Intent(Intent.ACTION_VIEW);
    intent.setData(Uri.parse(urlAsString));
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_SINGLE_TOP);
    if (MainApplication.openInBrowser(mContext,intent,false)) {
      if (getActiveTabCount() == 0 && Prompt.isShowing() == false) {
        finish();
      }
      String title=String.format(mContext.getString(R.string.link_redirected),Settings.get().getDefaultBrowserLabel());
      MainApplication.saveUrlInHistory(mContext,null,urlAsString,title);
      return null;
    }
  }
  boolean showAppPicker=false;
  PackageManager packageManager=mContext.getPackageManager();
  final List<ResolveInfo> resolveInfos=Settings.get().getAppsThatHandleUrl(url.toString(),packageManager);
  ResolveInfo defaultAppResolveInfo=Settings.get().getDefaultAppForUrl(url,resolveInfos);
  if (resolveInfos != null && resolveInfos.size() > 0) {
    if (defaultAppResolveInfo != null) {
      if (handleResolveInfo(defaultAppResolveInfo,urlAsString,urlLoadStartTime)) {
        return null;
      }
    }
 else     if (resolveInfos.size() == 1) {
      if (handleResolveInfo(resolveInfos.get(0),urlAsString,urlLoadStartTime)) {
        return null;
      }
    }
 else {
      for (      ResolveInfo info : resolveInfos) {
        if (info.activityInfo.packageName.startsWith(""String_Node_Str"")) {
          showAppPicker=false;
          break;
        }
 else {
          showAppPicker=true;
        }
      }
    }
  }
  boolean openedFromItself=false;
  if (openedFromAppName.equals(Analytics.OPENED_URL_FROM_NEW_TAB) || openedFromAppName.equals(Analytics.OPENED_URL_FROM_HISTORY)) {
    showAppPicker=true;
    openedFromItself=true;
  }
  mCanAutoDisplayLink=true;
  final TabView result=openUrlInTab(urlAsString,urlLoadStartTime,setAsCurrentTab,showAppPicker);
  if (!openedFromItself && showAppPicker && MainApplication.sShowingAppPickerDialog == false) {
    AlertDialog dialog=ActionItem.getActionItemPickerAlert(mContext,resolveInfos,R.string.pick_default_app,new ActionItem.OnActionItemDefaultSelectedListener(){
      @Override public void onSelected(      ActionItem actionItem,      boolean always){
        boolean loaded=false;
        for (        ResolveInfo resolveInfo : resolveInfos) {
          if (resolveInfo.activityInfo.packageName.equals(actionItem.mPackageName) && resolveInfo.activityInfo.name.equals(actionItem.mActivityClassName)) {
            if (always) {
              Settings.get().setDefaultApp(urlAsString,resolveInfo);
            }
            if (resolveInfo.activityInfo.packageName.equals(mAppPackageName)) {
              break;
            }
            loaded=MainApplication.loadIntent(mContext,actionItem.mPackageName,actionItem.mActivityClassName,urlAsString,-1,true);
            break;
          }
        }
        if (loaded) {
          Settings.get().addRedirectToApp(urlAsString);
          closeTab(result,contentViewShowing(),false);
          if (getActiveTabCount() == 0 && Prompt.isShowing() == false) {
            finish();
          }
          if (Build.VERSION.SDK_INT > Build.VERSION_CODES.KITKAT) {
            MainController.get().switchToBubbleView();
          }
        }
      }
    }
);
    dialog.setOnDismissListener(new DialogInterface.OnDismissListener(){
      @Override public void onDismiss(      DialogInterface dialog){
        MainApplication.sShowingAppPickerDialog=false;
      }
    }
);
    dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
    Util.showThemedDialog(dialog);
    MainApplication.sShowingAppPickerDialog=true;
  }
  return result;
}",0.9719452817064688
104932,"void setPreferenceIcon(Preference preference,Drawable drawable){
  if (drawable instanceof BitmapDrawable) {
    Bitmap bitmap=((BitmapDrawable)drawable).getBitmap();
    ActivityManager activityManager=(ActivityManager)getActivity().getSystemService(Context.ACTIVITY_SERVICE);
    int iconSize=(int)(activityManager.getLauncherLargeIconSize() * .67f);
    int w=bitmap.getWidth();
    int h=bitmap.getHeight();
    if (w == h) {
      if (w > iconSize) {
        Bitmap b=Bitmap.createScaledBitmap(bitmap,iconSize,iconSize,true);
        drawable=new BitmapDrawable(getResources(),b);
      }
 else       if (h < iconSize) {
        Bitmap b=Bitmap.createScaledBitmap(bitmap,iconSize,iconSize,true);
        drawable=new BitmapDrawable(getResources(),b);
      }
    }
  }
  preference.setIcon(drawable);
}","void setPreferenceIcon(Preference preference,Drawable drawable){
  if (drawable instanceof BitmapDrawable) {
    Bitmap bitmap=((BitmapDrawable)drawable).getBitmap();
    ActivityManager activityManager=(ActivityManager)getActivity().getSystemService(Context.ACTIVITY_SERVICE);
    int iconSize=(int)(activityManager.getLauncherLargeIconSize() * .67f);
    int w=bitmap.getWidth();
    int h=bitmap.getHeight();
    int largest=Math.max(w,h);
    if (largest > 0) {
      if (largest > iconSize) {
        Bitmap b=Bitmap.createScaledBitmap(bitmap,iconSize,iconSize,true);
        drawable=new BitmapDrawable(getResources(),b);
      }
 else       if (largest < iconSize) {
        Bitmap b=Bitmap.createScaledBitmap(bitmap,iconSize,iconSize,true);
        drawable=new BitmapDrawable(getResources(),b);
      }
    }
  }
  preference.setIcon(drawable);
}",0.9590854392298436
104933,"void onPageLoadComplete(String urlAsString){
  mPageFinishedLoading=true;
  URL currentUrl=mWebRenderer.getUrl();
  boolean equalUrl=currentUrl.toString().equals(urlAsString);
  if (!equalUrl) {
    try {
      URL url=new URL(urlAsString);
      if (url.getProtocol().equals(currentUrl.getProtocol()) && url.getHost().equals(currentUrl.getHost()) && url.getPath().equals(currentUrl.getPath())) {
        equalUrl=true;
      }
    }
 catch (    MalformedURLException e) {
    }
  }
  boolean fetchPageHtml=(Settings.get().getArticleModeEnabled() || Settings.get().getArticleModeOnWearEnabled()) && ArticleContent.tryForArticleContent(currentUrl);
  Log.d(""String_Node_Str"",""String_Node_Str"" + fetchPageHtml);
  mWebRenderer.runPageInspector(fetchPageHtml);
  if (equalUrl) {
    updateAppsForUrl(currentUrl);
    configureOpenInAppButton();
    configureOpenEmbedButton();
    configureArticleModeButton();
    mEventHandler.onPageLoaded(false);
    Log.e(TAG,""String_Node_Str"" + urlAsString);
    String title=MainApplication.sTitleHashMap != null ? MainApplication.sTitleHashMap.get(urlAsString) : ""String_Node_Str"";
    MainApplication.saveUrlInHistory(getContext(),null,currentUrl.toString(),currentUrl.getHost(),title);
    if (title == null) {
      mTitleTextView.setText(null);
    }
    postDelayed(mDelayedAutoContentDisplayLinkLoadedRunnable,Constant.AUTO_CONTENT_DISPLAY_DELAY);
    mWebRenderer.onPageLoadComplete();
  }
  mPageFinishedIgnoredUrl=null;
}","void onPageLoadComplete(String urlAsString){
  mPageFinishedLoading=true;
  URL currentUrl=mWebRenderer.getUrl();
  boolean equalUrl=currentUrl.toString().equals(urlAsString);
  if (!equalUrl) {
    try {
      URL url=new URL(urlAsString);
      if (url.getProtocol().equals(currentUrl.getProtocol()) && url.getHost().equals(currentUrl.getHost()) && url.getPath().equals(currentUrl.getPath())) {
        equalUrl=true;
      }
    }
 catch (    MalformedURLException e) {
    }
  }
  boolean fetchPageHtml=(Settings.get().getArticleModeEnabled() || Settings.get().getArticleModeOnWearEnabled()) && ArticleContent.tryForArticleContent(currentUrl);
  Log.d(""String_Node_Str"",""String_Node_Str"" + fetchPageHtml);
  mWebRenderer.runPageInspector(fetchPageHtml);
  if (equalUrl) {
    updateAppsForUrl(currentUrl);
    configureOpenInAppButton();
    configureOpenEmbedButton();
    configureArticleModeButton();
    mEventHandler.onPageLoaded(false);
    Log.e(TAG,""String_Node_Str"" + urlAsString);
    String title=MainApplication.sTitleHashMap != null ? MainApplication.sTitleHashMap.get(urlAsString) : ""String_Node_Str"";
    if (TextUtils.isEmpty(title)) {
      if (mTitleTextView.getText() != null) {
        String currentTitle=mTitleTextView.getText().toString();
        if (currentTitle.equals(mLoadingString) == false) {
          title=currentTitle;
        }
      }
      if (title == null) {
        mTitleTextView.setText(null);
      }
    }
    MainApplication.saveUrlInHistory(getContext(),null,currentUrl.toString(),currentUrl.getHost(),title);
    postDelayed(mDelayedAutoContentDisplayLinkLoadedRunnable,Constant.AUTO_CONTENT_DISPLAY_DELAY);
    mWebRenderer.onPageLoadComplete();
  }
  mPageFinishedIgnoredUrl=null;
}",0.8504527005931939
104934,"public ContentView(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
}","public ContentView(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  mLoadingString=getResources().getString(R.string.loading);
}",0.7715355805243446
104935,"void updateUrlTitleAndText(String urlAsString){
  String title=MainApplication.sTitleHashMap != null ? MainApplication.sTitleHashMap.get(urlAsString) : null;
  if (title == null) {
    title=getResources().getString(R.string.loading);
  }
  mTitleTextView.setText(title);
  if (urlAsString.equals(Constant.NEW_TAB_URL)) {
    mUrlTextView.setText(null);
  }
 else   if (urlAsString.equals(Constant.WELCOME_MESSAGE_URL)) {
    mUrlTextView.setText(Constant.WELCOME_MESSAGE_DISPLAY_URL);
  }
 else {
    mUrlTextView.setText(urlAsString.replace(""String_Node_Str"",""String_Node_Str""));
  }
}","void updateUrlTitleAndText(String urlAsString){
  String title=MainApplication.sTitleHashMap != null ? MainApplication.sTitleHashMap.get(urlAsString) : null;
  if (title == null) {
    title=mLoadingString;
  }
  mTitleTextView.setText(title);
  if (urlAsString.equals(Constant.NEW_TAB_URL)) {
    mUrlTextView.setText(null);
  }
 else   if (urlAsString.equals(Constant.WELCOME_MESSAGE_URL)) {
    mUrlTextView.setText(Constant.WELCOME_MESSAGE_DISPLAY_URL);
  }
 else {
    mUrlTextView.setText(urlAsString.replace(""String_Node_Str"",""String_Node_Str""));
  }
}",0.961605584642234
104936,"public static void openAppStore(Context context,String url){
  PackageManager manager=context.getPackageManager();
  Intent intent=new Intent();
  intent.setAction(Intent.ACTION_VIEW);
  intent.setData(Uri.parse(url));
  List<ResolveInfo> infos=manager.queryIntentActivities(intent,PackageManager.GET_RESOLVED_FILTER);
  for (  ResolveInfo info : infos) {
    IntentFilter filter=info.filter;
    if (filter != null && filter.hasAction(Intent.ACTION_VIEW) && filter.hasCategory(Intent.CATEGORY_BROWSABLE)) {
      if (info.activityInfo.packageName.equals(BuildConfig.STORE_PACKAGE)) {
        MainApplication.loadIntent(context,info.activityInfo.packageName,info.activityInfo.name,BuildConfig.STORE_PRO_URL,-1,true);
        return;
      }
    }
  }
}","public static void openAppStore(Context context,String url){
  PackageManager manager=context.getPackageManager();
  Intent intent=new Intent();
  intent.setAction(Intent.ACTION_VIEW);
  intent.setData(Uri.parse(url));
  List<ResolveInfo> infos=manager.queryIntentActivities(intent,PackageManager.GET_RESOLVED_FILTER);
  for (  ResolveInfo info : infos) {
    IntentFilter filter=info.filter;
    if (filter != null && filter.hasAction(Intent.ACTION_VIEW) && filter.hasCategory(Intent.CATEGORY_BROWSABLE)) {
      if (info.activityInfo.packageName.equals(BuildConfig.STORE_PACKAGE)) {
        MainApplication.loadIntent(context,info.activityInfo.packageName,info.activityInfo.name,url,-1,true);
        return;
      }
    }
  }
}",0.98110661268556
104937,"public ProgressImageView(Context context){
  super(context);
  mRotationAnimation=new RotateAnim(0,360,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f);
  mRotationAnimation.setInterpolator(new LinearInterpolator());
  mRotationAnimation.setRepeatCount(Animation.INFINITE);
  mRotationAnimation.setDuration(1000);
}","public ProgressImageView(Context context){
  super(context);
  mRotationAnimation=new RotateAnim(0,359,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f);
  mRotationAnimation.setInterpolator(new LinearInterpolator());
  mRotationAnimation.setRepeatCount(Animation.INFINITE);
  mRotationAnimation.setDuration(1000);
}",0.9939577039274924
104938,"public static void checkRestoreCurrentTabs(Context context){
  Vector<String> urls=Settings.get().loadCurrentTabs();
  if (urls.size() > 0) {
    MainApplication.restoreLinks(context,urls.toArray(new String[urls.size()]));
  }
}","public static void checkRestoreCurrentTabs(Context context){
  if (MainController.get() == null) {
    Vector<String> urls=Settings.get().loadCurrentTabs();
    if (urls.size() > 0) {
      MainApplication.restoreLinks(context,urls.toArray(new String[urls.size()]));
    }
  }
}",0.9011857707509882
104939,"@Override public boolean onInterceptTouchEvent(MotionEvent event){
  final int action=event.getAction();
  if ((action == MotionEvent.ACTION_MOVE) && mInterceptingTouch && mTouchInterceptor != null) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
    if (mActiveTouchPointerId == INVALID_POINTER) {
      break;
    }
  final int pointerIndex=event.findPointerIndex(mActiveTouchPointerId);
if (pointerIndex == -1) {
  Log.e(TAG,""String_Node_Str"" + mActiveTouchPointerId + ""String_Node_Str"");
  break;
}
final int y=(int)event.getY(pointerIndex);
final int yDiff=(int)Math.abs(y - mLastMotionY);
if (yDiff > 0) {
mLastMotionY=y;
if (mTouchInterceptor != null) {
mInterceptingTouch=true;
}
}
case MotionEvent.ACTION_DOWN:
mLastMotionY=(int)event.getY();
mActiveTouchPointerId=event.getPointerId(0);
break;
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
if (!mInterceptingTouch) {
final float bubblePeriod=(float)Constant.BUBBLE_ANIM_TIME / 1000.f;
final float contentPeriod=bubblePeriod * 0.666667f;
MainController.get().expandBubbleFlow((long)(contentPeriod * 1000));
}
mActiveTouchPointerId=INVALID_POINTER;
mInterceptingTouch=false;
break;
}
if (super.onInterceptTouchEvent(event)) {
return true;
}
return mInterceptingTouch;
}","@Override public boolean onInterceptTouchEvent(MotionEvent event){
  final int action=event.getAction();
  if ((action == MotionEvent.ACTION_MOVE) && mInterceptingTouch && mTouchInterceptor != null) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
    if (mActiveTouchPointerId == INVALID_POINTER) {
      break;
    }
  final int pointerIndex=event.findPointerIndex(mActiveTouchPointerId);
if (pointerIndex == -1) {
  Log.e(TAG,""String_Node_Str"" + mActiveTouchPointerId + ""String_Node_Str"");
  break;
}
final int y=(int)event.getY(pointerIndex);
final int yDiff=Math.abs(y - mLastMotionY);
if (yDiff > 0) {
mLastMotionY=y;
if (mTouchInterceptor != null) {
mInterceptingTouch=true;
}
}
case MotionEvent.ACTION_DOWN:
mLastMotionY=(int)event.getY();
mActiveTouchPointerId=event.getPointerId(0);
break;
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
if (!mInterceptingTouch) {
final float bubblePeriod=(float)Constant.BUBBLE_ANIM_TIME / 1000.f;
final float contentPeriod=bubblePeriod * 0.666667f;
MainController.get().expandBubbleFlow((long)(contentPeriod * 1000));
}
mActiveTouchPointerId=INVALID_POINTER;
mInterceptingTouch=false;
break;
}
if (super.onInterceptTouchEvent(event)) {
return true;
}
return mInterceptingTouch;
}",0.9980582524271844
104940,"public boolean closeTab(TabView tabView,Config.BubbleAction action,boolean animateOff){
  SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(mContext);
  boolean debug=prefs.getBoolean(""String_Node_Str"",false);
  if (debug) {
    Toast.makeText(mContext,""String_Node_Str"",400).show();
  }
 else {
    mBubbleFlowDraggable.closeTab(tabView,animateOff,action,tabView.getTotalTrackedLoadTime());
    int activeTabCount=getActiveTabCount();
    showBadge(activeTabCount > 1 ? true : false);
    if (activeTabCount == 0) {
      hideBubbleDraggable();
      scheduleUpdate();
    }
  }
  return getActiveTabCount() > 0;
}","public boolean closeTab(TabView tabView,Config.BubbleAction action,boolean animateOff){
  SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(mContext);
  boolean debug=prefs.getBoolean(""String_Node_Str"",false);
  if (debug) {
    Toast.makeText(mContext,""String_Node_Str"",Toast.LENGTH_SHORT).show();
  }
 else {
    mBubbleFlowDraggable.closeTab(tabView,animateOff,action,tabView.getTotalTrackedLoadTime());
    int activeTabCount=getActiveTabCount();
    showBadge(activeTabCount > 1 ? true : false);
    if (activeTabCount == 0) {
      hideBubbleDraggable();
      scheduleUpdate();
    }
  }
  return getActiveTabCount() > 0;
}",0.983657587548638
104941,"public void setImitator(BubbleView bubbleView){
  mImitator=bubbleView;
  if (mImitator != null) {
    String tag=(String)mFavicon.getTag();
    Drawable drawable=mFavicon.getDrawable();
    if (tag != null && drawable != null) {
      mImitator.setFavicon(((BitmapDrawable)drawable).getBitmap(),tag);
    }
 else {
      setFallbackFavicon();
    }
    mImitator.mProgressIndicator.setProgress(mProgressIndicator.isIndicatorShowing(),mProgressIndicator.getProgress(),mUrl);
  }
}","public void setImitator(BubbleView bubbleView){
  mImitator=bubbleView;
  if (mImitator != null) {
    String tag=(String)mFavicon.getTag();
    Drawable drawable=mFavicon.getDrawable();
    if (tag != null && drawable != null) {
      mImitator.setFavicon(((BitmapDrawable)drawable).getBitmap(),tag);
    }
 else {
      mImitator.setFallbackFavicon();
    }
    mImitator.mProgressIndicator.setProgress(mProgressIndicator.isIndicatorShowing(),mProgressIndicator.getProgress(),mUrl);
  }
}",0.9896907216494846
104942,"@Override public void update(float dt){
  if (mFlickActive && mCurrentSnapTarget == null) {
    int x=mDraggableHelper.getXPos();
    int y=mDraggableHelper.getYPos();
    Circle bubbleCircle=new Circle(x + Config.mBubbleWidth * 0.5f,y + Config.mBubbleHeight * 0.5f,Config.mBubbleWidth * 0.5f);
    BubbleTargetView tv=mCanvasView.getSnapTarget(bubbleCircle);
    if (tv != null) {
      mCurrentSnapTarget=tv;
      mTimeOnSnapTarget=0.0f;
      mCurrentSnapTarget.beginSnapping();
      Circle c=tv.GetDefaultCircle();
      int xt=(int)(c.mX - Config.mBubbleWidth * 0.5f);
      int yt=(int)(c.mY - Config.mBubbleHeight * 0.5f);
      mDraggableHelper.cancelAnimation();
      onAnimComplete();
      setTargetPos(xt,yt,0.3f,DraggableHelper.AnimationType.LargeOvershoot,new DraggableHelper.AnimationEventListener(){
        @Override public void onAnimationComplete(){
          MainApplication.postEvent(getContext(),mEndBubbleDragEvent);
          onAnimComplete();
          mFlickActive=false;
          Config.BubbleAction action=mCurrentSnapTarget.getAction();
          mCurrentSnapTarget.endSnapping();
          mCurrentSnapTarget=null;
          doSnapAction(action);
        }
        @Override public void onCancel(){
          onAnimComplete();
        }
      }
);
    }
  }
  if (mTouchDown) {
    if (mCurrentSnapTarget != null) {
      mTimeOnSnapTarget+=dt;
    }
    MainController.get().scheduleUpdate();
  }
  mDraggableHelper.update(dt);
  int x=mDraggableHelper.getXPos();
  int y=mDraggableHelper.getYPos();
  mDraggableBubbleMovedEvent.mX=x;
  mDraggableBubbleMovedEvent.mY=y;
  MainApplication.postEvent(getContext(),mDraggableBubbleMovedEvent);
  if (mOnUpdateListener != null) {
    mOnUpdateListener.onUpdate(this,dt);
  }
}","@Override public void update(float dt){
  if (mFlickActive && mCurrentSnapTarget == null) {
    int x=mDraggableHelper.getXPos();
    int y=mDraggableHelper.getYPos();
    Circle bubbleCircle=new Circle(x + Config.mBubbleWidth * 0.5f,y + Config.mBubbleHeight * 0.5f,Config.mBubbleWidth * 0.5f);
    BubbleTargetView tv=mCanvasView.getSnapTarget(bubbleCircle);
    if (tv != null) {
      mCurrentSnapTarget=tv;
      mTimeOnSnapTarget=0.0f;
      mCurrentSnapTarget.beginSnapping();
      Circle c=tv.GetDefaultCircle();
      int xt=(int)(c.mX - Config.mBubbleWidth * 0.5f);
      int yt=(int)(c.mY - Config.mBubbleHeight * 0.5f);
      mDraggableHelper.cancelAnimation();
      setTargetPos(xt,yt,0.3f,DraggableHelper.AnimationType.LargeOvershoot,new DraggableHelper.AnimationEventListener(){
        @Override public void onAnimationComplete(){
          MainApplication.postEvent(getContext(),mEndBubbleDragEvent);
          onAnimComplete();
          mFlickActive=false;
          Config.BubbleAction action=mCurrentSnapTarget.getAction();
          mCurrentSnapTarget.endSnapping();
          mCurrentSnapTarget=null;
          doSnapAction(action);
        }
        @Override public void onCancel(){
          onAnimComplete();
        }
      }
);
    }
  }
  if (mTouchDown) {
    if (mCurrentSnapTarget != null) {
      mTimeOnSnapTarget+=dt;
    }
    MainController.get().scheduleUpdate();
  }
  mDraggableHelper.update(dt);
  int x=mDraggableHelper.getXPos();
  int y=mDraggableHelper.getYPos();
  mDraggableBubbleMovedEvent.mX=x;
  mDraggableBubbleMovedEvent.mY=y;
  MainApplication.postEvent(getContext(),mDraggableBubbleMovedEvent);
  if (mOnUpdateListener != null) {
    mOnUpdateListener.onUpdate(this,dt);
  }
}",0.993119266055046
104943,"@Override public void onAnimationComplete(){
  MainApplication.postEvent(getContext(),mEndBubbleDragEvent);
  MainController mainController=MainController.get();
  if (mCurrentSnapTarget.getAction() == Config.BubbleAction.Destroy) {
    mainController.destroyAllBubbles();
    mMode=Mode.BubbleView;
  }
 else {
    if (mainController.destroyCurrentBubble(mCurrentSnapTarget.getAction())) {
      doAnimateToBubbleView();
    }
 else {
      mMode=Mode.BubbleView;
    }
  }
  onAnimComplete();
  mFlickActive=false;
  mCurrentSnapTarget.endSnapping();
  mCurrentSnapTarget=null;
}","@Override public void onAnimationComplete(){
  MainApplication.postEvent(getContext(),mEndBubbleDragEvent);
  MainController mainController=MainController.get();
  onAnimComplete();
  mFlickActive=false;
  Config.BubbleAction action=mCurrentSnapTarget.getAction();
  mCurrentSnapTarget.endSnapping();
  mCurrentSnapTarget=null;
  if (action == Config.BubbleAction.Destroy) {
    mainController.destroyAllBubbles();
    mMode=Mode.BubbleView;
  }
 else {
    if (mainController.destroyCurrentBubble(action)) {
      doAnimateToBubbleView();
    }
 else {
      mMode=Mode.BubbleView;
    }
  }
}",0.6451063829787234
104944,"@Override public void update(float dt){
  if (mFlickActive && mCurrentSnapTarget == null) {
    int x=mDraggableHelper.getXPos();
    int y=mDraggableHelper.getYPos();
    Circle bubbleCircle=new Circle(x + Config.mBubbleWidth * 0.5f,y + Config.mBubbleHeight * 0.5f,Config.mBubbleWidth * 0.5f);
    BubbleTargetView tv=mCanvasView.getSnapTarget(bubbleCircle);
    if (tv != null) {
      mCurrentSnapTarget=tv;
      mCurrentSnapTarget.beginSnapping();
      Circle c=tv.GetDefaultCircle();
      int xt=(int)(c.mX - Config.mBubbleWidth * 0.5f);
      int yt=(int)(c.mY - Config.mBubbleHeight * 0.5f);
      mDraggableHelper.forceClearAnim();
      onAnimComplete();
      setTargetPos(xt,yt,0.3f,DraggableHelper.AnimationType.LargeOvershoot,new DraggableHelper.AnimationEventListener(){
        @Override public void onAnimationComplete(){
          MainApplication.postEvent(getContext(),mEndBubbleDragEvent);
          MainController mainController=MainController.get();
          if (mCurrentSnapTarget.getAction() == Config.BubbleAction.Destroy) {
            mainController.destroyAllBubbles();
            mMode=Mode.BubbleView;
          }
 else {
            if (mainController.destroyCurrentBubble(mCurrentSnapTarget.getAction())) {
              doAnimateToBubbleView();
            }
 else {
              mMode=Mode.BubbleView;
            }
          }
          onAnimComplete();
          mFlickActive=false;
          mCurrentSnapTarget.endSnapping();
          mCurrentSnapTarget=null;
        }
      }
);
    }
  }
  mDraggableHelper.update(dt);
  int x=mDraggableHelper.getXPos();
  int y=mDraggableHelper.getYPos();
  mDraggableBubbleMovedEvent.mX=x;
  mDraggableBubbleMovedEvent.mY=y;
  MainApplication.postEvent(getContext(),mDraggableBubbleMovedEvent);
  if (mOnUpdateListener != null) {
    mOnUpdateListener.onUpdate(this,dt);
  }
}","@Override public void update(float dt){
  if (mFlickActive && mCurrentSnapTarget == null) {
    int x=mDraggableHelper.getXPos();
    int y=mDraggableHelper.getYPos();
    Circle bubbleCircle=new Circle(x + Config.mBubbleWidth * 0.5f,y + Config.mBubbleHeight * 0.5f,Config.mBubbleWidth * 0.5f);
    BubbleTargetView tv=mCanvasView.getSnapTarget(bubbleCircle);
    if (tv != null) {
      mCurrentSnapTarget=tv;
      mCurrentSnapTarget.beginSnapping();
      Circle c=tv.GetDefaultCircle();
      int xt=(int)(c.mX - Config.mBubbleWidth * 0.5f);
      int yt=(int)(c.mY - Config.mBubbleHeight * 0.5f);
      mDraggableHelper.forceClearAnim();
      onAnimComplete();
      setTargetPos(xt,yt,0.3f,DraggableHelper.AnimationType.LargeOvershoot,new DraggableHelper.AnimationEventListener(){
        @Override public void onAnimationComplete(){
          MainApplication.postEvent(getContext(),mEndBubbleDragEvent);
          MainController mainController=MainController.get();
          onAnimComplete();
          mFlickActive=false;
          Config.BubbleAction action=mCurrentSnapTarget.getAction();
          mCurrentSnapTarget.endSnapping();
          mCurrentSnapTarget=null;
          if (action == Config.BubbleAction.Destroy) {
            mainController.destroyAllBubbles();
            mMode=Mode.BubbleView;
          }
 else {
            if (mainController.destroyCurrentBubble(action)) {
              doAnimateToBubbleView();
            }
 else {
              mMode=Mode.BubbleView;
            }
          }
        }
      }
);
    }
  }
  mDraggableHelper.update(dt);
  int x=mDraggableHelper.getXPos();
  int y=mDraggableHelper.getYPos();
  mDraggableBubbleMovedEvent.mX=x;
  mDraggableBubbleMovedEvent.mY=y;
  MainApplication.postEvent(getContext(),mDraggableBubbleMovedEvent);
  if (mOnUpdateListener != null) {
    mOnUpdateListener.onUpdate(this,dt);
  }
}",0.8638673442096817
104945,"private void doAnimateToBubbleView(){
  if (mMode == Mode.BubbleView)   return;
  mTouchDown=false;
  mMode=Mode.BubbleView;
  if (MainController.get().getBubbleCount() == 0) {
    throw new RuntimeException(""String_Node_Str"");
  }
  float bubblePeriod=(float)Constant.BUBBLE_ANIM_TIME / 1000.f;
  float contentPeriod=bubblePeriod * 0.666667f;
  MainController mainController=MainController.get();
  setVisibility(View.VISIBLE);
  int xp=Config.BUBBLE_HOME_X;
  int yp=Config.BUBBLE_HOME_Y;
  setTargetPos(xp,yp,bubblePeriod,DraggableHelper.AnimationType.SmallOvershoot,new DraggableHelper.AnimationEventListener(){
    @Override public void onAnimationComplete(){
      MainApplication.postEvent(getContext(),mEndCollapseTransitionEvent);
      onAnimComplete();
    }
  }
);
  mainController.endAppPolling();
  mainController.collapseBubbleFlow((long)(contentPeriod * 1000));
  mBeginCollapseTransitionEvent.mPeriod=contentPeriod;
  MainApplication.postEvent(getContext(),mBeginCollapseTransitionEvent);
}","private void doAnimateToBubbleView(){
  if (mMode == Mode.BubbleView && mAnimActive)   return;
  mTouchDown=false;
  mMode=Mode.BubbleView;
  if (MainController.get().getBubbleCount() == 0) {
    throw new RuntimeException(""String_Node_Str"");
  }
  float bubblePeriod=(float)Constant.BUBBLE_ANIM_TIME / 1000.f;
  float contentPeriod=bubblePeriod * 0.666667f;
  MainController mainController=MainController.get();
  setVisibility(View.VISIBLE);
  int xp=Config.BUBBLE_HOME_X;
  int yp=Config.BUBBLE_HOME_Y;
  setTargetPos(xp,yp,bubblePeriod,DraggableHelper.AnimationType.SmallOvershoot,new DraggableHelper.AnimationEventListener(){
    @Override public void onAnimationComplete(){
      MainApplication.postEvent(getContext(),mEndCollapseTransitionEvent);
      onAnimComplete();
    }
  }
);
  mainController.endAppPolling();
  mainController.collapseBubbleFlow((long)(contentPeriod * 1000));
  mBeginCollapseTransitionEvent.mPeriod=contentPeriod;
  MainApplication.postEvent(getContext(),mBeginCollapseTransitionEvent);
}",0.992607195662888
104946,"@Override public void onPageFinished(WebView webView,String urlAsString){
  super.onPageFinished(webView,urlAsString);
  URL url=null;
  try {
    url=new URL(urlAsString);
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
  }
  if (isValidUrl(url)) {
    updateAppsForUrl(urlAsString);
    configureOpenInAppButton();
    configureOpenEmbedButton();
    mTitleTextView.setText(webView.getTitle());
    mUrlTextView.setText(urlAsString.replace(""String_Node_Str"",""String_Node_Str""));
    if (--mLoadCount == 0) {
      mUrl=urlAsString;
      mCurrentLoadedUrl=mUrl;
      PageLoadInfo pageLoadInfo=new PageLoadInfo();
      pageLoadInfo.bmp=webView.getFavicon();
      pageLoadInfo.url=urlAsString;
      pageLoadInfo.mHost=url.getHost();
      pageLoadInfo.title=webView.getTitle();
      mEventHandler.onPageLoaded(pageLoadInfo);
      Log.d(TAG,""String_Node_Str"" + urlAsString);
      if (mStartTime > -1) {
        Log.d(""String_Node_Str"",""String_Node_Str"" + ((System.currentTimeMillis() - mStartTime) / 1000) + ""String_Node_Str"");
        mStartTime=-1;
      }
      if (Settings.get().checkForYouTubeEmbeds()) {
        webView.loadUrl(JS_EMBED);
        Log.d(TAG,""String_Node_Str"");
      }
    }
  }
}","@Override public void onPageFinished(WebView webView,String urlAsString){
  super.onPageFinished(webView,urlAsString);
  mPageFinishedLoading=true;
  URL url=null;
  try {
    url=new URL(urlAsString);
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
  }
  if (isValidUrl(url)) {
    updateAppsForUrl(urlAsString);
    configureOpenInAppButton();
    configureOpenEmbedButton();
    mTitleTextView.setText(webView.getTitle());
    mUrlTextView.setText(urlAsString.replace(""String_Node_Str"",""String_Node_Str""));
    if (--mLoadCount == 0) {
      mUrl=urlAsString;
      mCurrentLoadedUrl=mUrl;
      PageLoadInfo pageLoadInfo=new PageLoadInfo();
      pageLoadInfo.bmp=webView.getFavicon();
      pageLoadInfo.url=urlAsString;
      pageLoadInfo.mHost=url.getHost();
      pageLoadInfo.title=webView.getTitle();
      mEventHandler.onPageLoaded(pageLoadInfo);
      Log.d(TAG,""String_Node_Str"" + urlAsString);
      if (mStartTime > -1) {
        Log.d(""String_Node_Str"",""String_Node_Str"" + ((System.currentTimeMillis() - mStartTime) / 1000) + ""String_Node_Str"");
        mStartTime=-1;
      }
      if (Settings.get().checkForYouTubeEmbeds()) {
        webView.loadUrl(JS_EMBED);
        Log.d(TAG,""String_Node_Str"");
      }
    }
  }
}",0.9883205799436166
104947,"@Override public void onReceivedIcon(WebView webView,Bitmap bitmap){
  super.onReceivedIcon(webView,bitmap);
  mEventHandler.onReceivedIcon(bitmap);
}","@Override public void onReceivedIcon(WebView webView,Bitmap bitmap){
  super.onReceivedIcon(webView,bitmap);
  if (mPageFinishedLoading) {
    mEventHandler.onReceivedIcon(bitmap);
  }
}",0.8928571428571429
104948,"@Override public void onPageStarted(WebView view,String url,Bitmap favIcon){
  if (isValidUrl(url)) {
    mLoadCount=Math.max(mLoadCount,1);
  }
  if (mShareButton.getVisibility() == GONE) {
    mShareButton.setVisibility(VISIBLE);
  }
}","@Override public void onPageStarted(WebView view,String url,Bitmap favIcon){
  mPageFinishedLoading=false;
  if (isValidUrl(url)) {
    mLoadCount=Math.max(mLoadCount,1);
  }
  if (mShareButton.getVisibility() == GONE) {
    mShareButton.setVisibility(VISIBLE);
  }
}",0.9404761904761904
104949,"void configure(String url,long startTime,EventHandler eh){
  mPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mPaint.setColor(getResources().getColor(R.color.content_toolbar_background));
  try {
    mTempUrl=new URL(url);
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
  }
  mHeaderHeight=getResources().getDimensionPixelSize(R.dimen.toolbar_header);
  mWebView=(WebView)findViewById(R.id.webView);
  mToolbarLayout=(LinearLayout)findViewById(R.id.content_toolbar);
  mTitleTextView=(CondensedTextView)findViewById(R.id.title_text);
  mUrlTextView=(CondensedTextView)findViewById(R.id.url_text);
  View textContainer=findViewById(R.id.content_text_container);
  textContainer.setOnTouchListener(new OnSwipeTouchListener(){
    public void onSwipeRight(){
      MainController.get().showPreviousBubble();
    }
    public void onSwipeLeft(){
      MainController.get().showNextBubble();
    }
  }
);
  mShareButton=(ContentViewButton)findViewById(R.id.share_button);
  mShareButton.setImageDrawable(getResources().getDrawable(R.drawable.ic_action_share));
  mShareButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      showSelectShareMethod(mUrl,true);
    }
  }
);
  mOpenInAppButton=(OpenInAppButton)findViewById(R.id.open_in_app_button);
  mOpenInAppButton.setOnOpenInAppClickListener(new OpenInAppButton.OnOpenInAppClickListener(){
    @Override public void onAppOpened(){
      mEventHandler.onDestroyBubble();
    }
  }
);
  mOpenEmbedButton=(OpenEmbedButton)findViewById(R.id.open_embed_button);
  mOpenEmbedButton.setOnOpenEmbedClickListener(new OpenEmbedButton.OnOpenEmbedClickListener(){
    @Override public void onYouTubeEmbedOpened(){
    }
  }
);
  mReloadButton=(ContentViewButton)findViewById(R.id.reload_button);
  mReloadButton.setImageDrawable(getResources().getDrawable(R.drawable.ic_action_reload));
  mReloadButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      mReloadButton.setVisibility(GONE);
      mWebView.reload();
    }
  }
);
  mOverflowButton=(ContentViewButton)mToolbarLayout.findViewById(R.id.overflow_button);
  mOverflowButton.setImageDrawable(getResources().getDrawable(R.drawable.ic_action_overflow_round));
  mOverflowButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      mOverflowPopupMenu=new PopupMenu(mContext,mOverflowButton);
      Resources resources=mContext.getResources();
      mOverflowPopupMenu.getMenu().add(Menu.NONE,R.id.item_upgrade_to_pro,Menu.NONE,resources.getString(R.string.action_upgrade_to_pro));
      mOverflowPopupMenu.getMenu().add(Menu.NONE,R.id.item_reload_page,Menu.NONE,resources.getString(R.string.action_reload_page));
      String defaultBrowserLabel=Settings.get().getDefaultBrowserLabel();
      if (defaultBrowserLabel != null) {
        mOverflowPopupMenu.getMenu().add(Menu.NONE,R.id.item_open_in_browser,Menu.NONE,String.format(resources.getString(R.string.action_open_in_browser),defaultBrowserLabel));
      }
      mOverflowPopupMenu.getMenu().add(Menu.NONE,R.id.item_settings,Menu.NONE,resources.getString(R.string.action_settings));
      mOverflowPopupMenu.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener(){
        @Override public boolean onMenuItemClick(        MenuItem item){
switch (item.getItemId()) {
case R.id.item_upgrade_to_pro:
{
              Intent intent=Config.getStoreIntent(mContext,Config.STORE_PRO_URL);
              if (intent != null) {
                mContext.startActivity(intent);
                mEventHandler.onMinimizeBubbles();
              }
              break;
            }
case R.id.item_reload_page:
{
            if (mYouTubeEmbedHelper != null) {
              mYouTubeEmbedHelper.clear();
            }
            mEventHandler.onPageLoading(mUrl);
            mWebView.stopLoading();
            mWebView.reload();
            updateAppsForUrl(mUrl);
            configureOpenInAppButton();
            configureOpenEmbedButton();
            Log.d(TAG,""String_Node_Str"" + mUrl);
            mStartTime=System.currentTimeMillis();
            mTitleTextView.setText(R.string.loading);
            mUrlTextView.setText(mUrl.replace(""String_Node_Str"",""String_Node_Str""));
            break;
          }
case R.id.item_open_in_browser:
{
          openInBrowser(mUrl);
          break;
        }
case R.id.item_settings:
{
        Intent intent=new Intent(mContext,SettingsActivity.class);
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_SINGLE_TOP);
        mContext.startActivity(intent);
        mEventHandler.onMinimizeBubbles();
        break;
      }
  }
  mOverflowPopupMenu=null;
  return false;
}
}
);
mOverflowPopupMenu.setOnDismissListener(new PopupMenu.OnDismissListener(){
@Override public void onDismiss(PopupMenu menu){
  if (mOverflowPopupMenu == menu) {
    mOverflowPopupMenu=null;
  }
}
}
);
mOverflowPopupMenu.show();
}
}
);
mContext=getContext();
mEventHandler=eh;
mUrl=url;
WebSettings ws=mWebView.getSettings();
ws.setJavaScriptEnabled(true);
ws.setSupportZoom(true);
ws.setBuiltInZoomControls(true);
ws.setLoadWithOverviewMode(true);
ws.setUseWideViewPort(true);
mWebView.setLongClickable(true);
mWebView.setOnLongClickListener(new OnLongClickListener(){
@Override public boolean onLongClick(View v){
WebView.HitTestResult hitTestResult=mWebView.getHitTestResult();
Log.d(TAG,""String_Node_Str"" + hitTestResult.getType());
switch (hitTestResult.getType()) {
case WebView.HitTestResult.SRC_ANCHOR_TYPE:
case WebView.HitTestResult.SRC_IMAGE_ANCHOR_TYPE:
{
  final String url=hitTestResult.getExtra();
  if (url == null) {
    return false;
  }
  onUrlLongClick(url);
  return true;
}
case WebView.HitTestResult.UNKNOWN_TYPE:
default :
String defaultBrowserLabel=Settings.get().getDefaultBrowserLabel();
String message;
if (defaultBrowserLabel != null) {
message=String.format(getResources().getString(R.string.long_press_unsupported_default_browser),defaultBrowserLabel);
}
 else {
message=getResources().getString(R.string.long_press_unsupported_no_default_browser);
}
Toast.makeText(mContext,message,Toast.LENGTH_LONG).show();
return false;
}
}
}
);
mWebView.setWebChromeClient(new WebChromeClient(){
@Override public void onReceivedTitle(WebView webView,String title){
super.onReceivedTitle(webView,title);
mTitleTextView.setText(title);
}
@Override public void onReceivedIcon(WebView webView,Bitmap bitmap){
super.onReceivedIcon(webView,bitmap);
mEventHandler.onReceivedIcon(bitmap);
}
@Override public void onProgressChanged(WebView webView,int progress){
mEventHandler.onProgressChanged(progress);
if (progress >= 60) {
if (mCheckForEmbedsCount == 0) {
mCheckForEmbedsCount=1;
if (mYouTubeEmbedHelper != null) {
mYouTubeEmbedHelper.clear();
}
if (Settings.get().checkForYouTubeEmbeds()) {
Log.d(TAG,""String_Node_Str"" + progress + ""String_Node_Str""+ mCheckForEmbedsCount);
webView.loadUrl(JS_EMBED);
}
}
 else if (mCheckForEmbedsCount == 1 && progress >= 80) {
mCheckForEmbedsCount=2;
if (Settings.get().checkForYouTubeEmbeds()) {
Log.d(TAG,""String_Node_Str"" + progress + ""String_Node_Str""+ mCheckForEmbedsCount);
webView.loadUrl(JS_EMBED);
}
}
}
}
}
);
mWebView.setWebViewClient(new WebViewClient(){
@Override public boolean shouldOverrideUrlLoading(WebView wView,String url){
if (mLoadCount == 0) {
if (mCurrentLoadedUrl != null && !mLoadingPrev) {
mUrlHistory.push(mCurrentLoadedUrl);
}
mCurrentLoadedUrl=null;
mLoadingPrev=false;
}
if (isValidUrl(url)) {
++mLoadCount;
}
if (mYouTubeEmbedHelper != null) {
mYouTubeEmbedHelper.clear();
}
List<ResolveInfo> resolveInfos=Settings.get().getAppsThatHandleUrl(url);
updateAppsForUrl(resolveInfos,url);
if (Settings.get().redirectUrlToBrowser(url)) {
if (openInBrowser(url)) {
String title=String.format(mContext.getString(R.string.link_redirected),Settings.get().getDefaultBrowserLabel());
MainApplication.saveUrlInHistory(mContext,null,url,title);
return false;
}
}
if (Settings.get().getAutoContentDisplayAppRedirect() && resolveInfos != null && resolveInfos.size() > 0) {
ResolveInfo resolveInfo=resolveInfos.get(0);
if (resolveInfo != Settings.get().mLinkBubbleEntryActivityResolveInfo) {
if (MainApplication.loadResolveInfoIntent(mContext,resolveInfo,url,mStartTime)) {
String title=String.format(mContext.getString(R.string.link_loaded_with_app),resolveInfo.loadLabel(mContext.getPackageManager()));
MainApplication.saveUrlInHistory(mContext,resolveInfo,url,title);
mEventHandler.onDestroyBubble();
return false;
}
}
}
configureOpenInAppButton();
configureOpenEmbedButton();
Log.d(TAG,""String_Node_Str"" + url);
mWebView.loadUrl(url);
mEventHandler.onPageLoading(url);
mTitleTextView.setText(R.string.loading);
mUrlTextView.setText(url.replace(""String_Node_Str"",""String_Node_Str""));
return true;
}
@Override public void onReceivedError(WebView view,int errorCode,String description,String failingUrl){
mEventHandler.onPageLoaded(null);
mReloadButton.setVisibility(VISIBLE);
mShareButton.setVisibility(GONE);
}
@Override public void onReceivedSslError(WebView view,SslErrorHandler handler,SslError error){
handler.proceed();
}
@Override public void onPageStarted(WebView view,String url,Bitmap favIcon){
if (isValidUrl(url)) {
mLoadCount=Math.max(mLoadCount,1);
}
if (mShareButton.getVisibility() == GONE) {
mShareButton.setVisibility(VISIBLE);
}
}
@Override public void onPageFinished(WebView webView,String urlAsString){
super.onPageFinished(webView,urlAsString);
URL url=null;
try {
url=new URL(urlAsString);
}
 catch (MalformedURLException e) {
e.printStackTrace();
}
if (isValidUrl(url)) {
updateAppsForUrl(urlAsString);
configureOpenInAppButton();
configureOpenEmbedButton();
mTitleTextView.setText(webView.getTitle());
mUrlTextView.setText(urlAsString.replace(""String_Node_Str"",""String_Node_Str""));
if (--mLoadCount == 0) {
mUrl=urlAsString;
mCurrentLoadedUrl=mUrl;
PageLoadInfo pageLoadInfo=new PageLoadInfo();
pageLoadInfo.bmp=webView.getFavicon();
pageLoadInfo.url=urlAsString;
pageLoadInfo.mHost=url.getHost();
pageLoadInfo.title=webView.getTitle();
mEventHandler.onPageLoaded(pageLoadInfo);
Log.d(TAG,""String_Node_Str"" + urlAsString);
if (mStartTime > -1) {
Log.d(""String_Node_Str"",""String_Node_Str"" + ((System.currentTimeMillis() - mStartTime) / 1000) + ""String_Node_Str"");
mStartTime=-1;
}
if (Settings.get().checkForYouTubeEmbeds()) {
webView.loadUrl(JS_EMBED);
Log.d(TAG,""String_Node_Str"");
}
}
}
}
}
);
mWebView.setOnKeyListener(new OnKeyListener(){
@Override public boolean onKey(View v,int keyCode,KeyEvent event){
if (event.getAction() == KeyEvent.ACTION_DOWN) {
WebView webView=(WebView)v;
switch (keyCode) {
case KeyEvent.KEYCODE_BACK:
{
if (mUrlHistory.size() == 0) {
mEventHandler.onDestroyBubble();
}
 else {
webView.stopLoading();
String urlBefore=webView.getUrl();
String prevUrl=mUrlHistory.pop();
mLoadingPrev=true;
webView.loadUrl(prevUrl);
updateAppsForUrl(webView.getUrl());
if (mYouTubeEmbedHelper != null) {
mYouTubeEmbedHelper.clear();
}
Log.d(TAG,""String_Node_Str"" + urlBefore + ""String_Node_Str""+ webView.getUrl());
configureOpenInAppButton();
configureOpenEmbedButton();
return true;
}
break;
}
}
}
return false;
}
}
);
mWebView.setDownloadListener(new DownloadListener(){
@Override public void onDownloadStart(String url,String userAgent,String contentDisposition,String mimetype,long contentLength){
openInBrowser(url);
mEventHandler.onDestroyBubble();
}
}
);
if (Settings.get().checkForYouTubeEmbeds()) {
mJSEmbedHandler=new JSEmbedHandler();
mWebView.addJavascriptInterface(mJSEmbedHandler,JS_VARIABLE);
}
updateIncognitoMode(Settings.get().isIncognitoMode());
updateAppsForUrl(url);
configureOpenInAppButton();
configureOpenEmbedButton();
Log.d(TAG,""String_Node_Str"" + url);
mStartTime=startTime;
mWebView.loadUrl(url);
mEventHandler.onPageLoading(url);
mTitleTextView.setText(R.string.loading);
mUrlTextView.setText(url.replace(""String_Node_Str"",""String_Node_Str""));
}","void configure(String url,long startTime,EventHandler eh){
  mPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mPaint.setColor(getResources().getColor(R.color.content_toolbar_background));
  try {
    mTempUrl=new URL(url);
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
  }
  mHeaderHeight=getResources().getDimensionPixelSize(R.dimen.toolbar_header);
  mWebView=(WebView)findViewById(R.id.webView);
  mToolbarLayout=(LinearLayout)findViewById(R.id.content_toolbar);
  mTitleTextView=(CondensedTextView)findViewById(R.id.title_text);
  mUrlTextView=(CondensedTextView)findViewById(R.id.url_text);
  View textContainer=findViewById(R.id.content_text_container);
  textContainer.setOnTouchListener(new OnSwipeTouchListener(){
    public void onSwipeRight(){
      MainController.get().showPreviousBubble();
    }
    public void onSwipeLeft(){
      MainController.get().showNextBubble();
    }
  }
);
  mShareButton=(ContentViewButton)findViewById(R.id.share_button);
  mShareButton.setImageDrawable(getResources().getDrawable(R.drawable.ic_action_share));
  mShareButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      showSelectShareMethod(mUrl,true);
    }
  }
);
  mOpenInAppButton=(OpenInAppButton)findViewById(R.id.open_in_app_button);
  mOpenInAppButton.setOnOpenInAppClickListener(new OpenInAppButton.OnOpenInAppClickListener(){
    @Override public void onAppOpened(){
      mEventHandler.onDestroyBubble();
    }
  }
);
  mOpenEmbedButton=(OpenEmbedButton)findViewById(R.id.open_embed_button);
  mOpenEmbedButton.setOnOpenEmbedClickListener(new OpenEmbedButton.OnOpenEmbedClickListener(){
    @Override public void onYouTubeEmbedOpened(){
    }
  }
);
  mReloadButton=(ContentViewButton)findViewById(R.id.reload_button);
  mReloadButton.setImageDrawable(getResources().getDrawable(R.drawable.ic_action_reload));
  mReloadButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      mReloadButton.setVisibility(GONE);
      mWebView.reload();
    }
  }
);
  mOverflowButton=(ContentViewButton)mToolbarLayout.findViewById(R.id.overflow_button);
  mOverflowButton.setImageDrawable(getResources().getDrawable(R.drawable.ic_action_overflow_round));
  mOverflowButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      mOverflowPopupMenu=new PopupMenu(mContext,mOverflowButton);
      Resources resources=mContext.getResources();
      mOverflowPopupMenu.getMenu().add(Menu.NONE,R.id.item_upgrade_to_pro,Menu.NONE,resources.getString(R.string.action_upgrade_to_pro));
      mOverflowPopupMenu.getMenu().add(Menu.NONE,R.id.item_reload_page,Menu.NONE,resources.getString(R.string.action_reload_page));
      String defaultBrowserLabel=Settings.get().getDefaultBrowserLabel();
      if (defaultBrowserLabel != null) {
        mOverflowPopupMenu.getMenu().add(Menu.NONE,R.id.item_open_in_browser,Menu.NONE,String.format(resources.getString(R.string.action_open_in_browser),defaultBrowserLabel));
      }
      mOverflowPopupMenu.getMenu().add(Menu.NONE,R.id.item_settings,Menu.NONE,resources.getString(R.string.action_settings));
      mOverflowPopupMenu.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener(){
        @Override public boolean onMenuItemClick(        MenuItem item){
switch (item.getItemId()) {
case R.id.item_upgrade_to_pro:
{
              Intent intent=Config.getStoreIntent(mContext,Config.STORE_PRO_URL);
              if (intent != null) {
                mContext.startActivity(intent);
                mEventHandler.onMinimizeBubbles();
              }
              break;
            }
case R.id.item_reload_page:
{
            if (mYouTubeEmbedHelper != null) {
              mYouTubeEmbedHelper.clear();
            }
            mEventHandler.onPageLoading(mUrl);
            mWebView.stopLoading();
            mWebView.reload();
            updateAppsForUrl(mUrl);
            configureOpenInAppButton();
            configureOpenEmbedButton();
            Log.d(TAG,""String_Node_Str"" + mUrl);
            mStartTime=System.currentTimeMillis();
            mTitleTextView.setText(R.string.loading);
            mUrlTextView.setText(mUrl.replace(""String_Node_Str"",""String_Node_Str""));
            break;
          }
case R.id.item_open_in_browser:
{
          openInBrowser(mUrl);
          break;
        }
case R.id.item_settings:
{
        Intent intent=new Intent(mContext,SettingsActivity.class);
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_SINGLE_TOP);
        mContext.startActivity(intent);
        mEventHandler.onMinimizeBubbles();
        break;
      }
  }
  mOverflowPopupMenu=null;
  return false;
}
}
);
mOverflowPopupMenu.setOnDismissListener(new PopupMenu.OnDismissListener(){
@Override public void onDismiss(PopupMenu menu){
  if (mOverflowPopupMenu == menu) {
    mOverflowPopupMenu=null;
  }
}
}
);
mOverflowPopupMenu.show();
}
}
);
mContext=getContext();
mEventHandler=eh;
mUrl=url;
mPageFinishedLoading=false;
WebSettings ws=mWebView.getSettings();
ws.setJavaScriptEnabled(true);
ws.setSupportZoom(true);
ws.setBuiltInZoomControls(true);
ws.setLoadWithOverviewMode(true);
ws.setUseWideViewPort(true);
mWebView.setLongClickable(true);
mWebView.setOnLongClickListener(new OnLongClickListener(){
@Override public boolean onLongClick(View v){
WebView.HitTestResult hitTestResult=mWebView.getHitTestResult();
Log.d(TAG,""String_Node_Str"" + hitTestResult.getType());
switch (hitTestResult.getType()) {
case WebView.HitTestResult.SRC_ANCHOR_TYPE:
case WebView.HitTestResult.SRC_IMAGE_ANCHOR_TYPE:
{
  final String url=hitTestResult.getExtra();
  if (url == null) {
    return false;
  }
  onUrlLongClick(url);
  return true;
}
case WebView.HitTestResult.UNKNOWN_TYPE:
default :
String defaultBrowserLabel=Settings.get().getDefaultBrowserLabel();
String message;
if (defaultBrowserLabel != null) {
message=String.format(getResources().getString(R.string.long_press_unsupported_default_browser),defaultBrowserLabel);
}
 else {
message=getResources().getString(R.string.long_press_unsupported_no_default_browser);
}
Toast.makeText(mContext,message,Toast.LENGTH_LONG).show();
return false;
}
}
}
);
mWebView.setWebChromeClient(new WebChromeClient(){
@Override public void onReceivedTitle(WebView webView,String title){
super.onReceivedTitle(webView,title);
mTitleTextView.setText(title);
}
@Override public void onReceivedIcon(WebView webView,Bitmap bitmap){
super.onReceivedIcon(webView,bitmap);
if (mPageFinishedLoading) {
mEventHandler.onReceivedIcon(bitmap);
}
}
@Override public void onProgressChanged(WebView webView,int progress){
mEventHandler.onProgressChanged(progress);
if (progress >= 60) {
if (mCheckForEmbedsCount == 0) {
mCheckForEmbedsCount=1;
if (mYouTubeEmbedHelper != null) {
mYouTubeEmbedHelper.clear();
}
if (Settings.get().checkForYouTubeEmbeds()) {
Log.d(TAG,""String_Node_Str"" + progress + ""String_Node_Str""+ mCheckForEmbedsCount);
webView.loadUrl(JS_EMBED);
}
}
 else if (mCheckForEmbedsCount == 1 && progress >= 80) {
mCheckForEmbedsCount=2;
if (Settings.get().checkForYouTubeEmbeds()) {
Log.d(TAG,""String_Node_Str"" + progress + ""String_Node_Str""+ mCheckForEmbedsCount);
webView.loadUrl(JS_EMBED);
}
}
}
}
}
);
mWebView.setWebViewClient(new WebViewClient(){
@Override public boolean shouldOverrideUrlLoading(WebView wView,String url){
if (mLoadCount == 0) {
if (mCurrentLoadedUrl != null && !mLoadingPrev) {
mUrlHistory.push(mCurrentLoadedUrl);
}
mCurrentLoadedUrl=null;
mLoadingPrev=false;
}
if (isValidUrl(url)) {
++mLoadCount;
}
if (mYouTubeEmbedHelper != null) {
mYouTubeEmbedHelper.clear();
}
List<ResolveInfo> resolveInfos=Settings.get().getAppsThatHandleUrl(url);
updateAppsForUrl(resolveInfos,url);
if (Settings.get().redirectUrlToBrowser(url)) {
if (openInBrowser(url)) {
String title=String.format(mContext.getString(R.string.link_redirected),Settings.get().getDefaultBrowserLabel());
MainApplication.saveUrlInHistory(mContext,null,url,title);
return false;
}
}
if (Settings.get().getAutoContentDisplayAppRedirect() && resolveInfos != null && resolveInfos.size() > 0) {
ResolveInfo resolveInfo=resolveInfos.get(0);
if (resolveInfo != Settings.get().mLinkBubbleEntryActivityResolveInfo) {
if (MainApplication.loadResolveInfoIntent(mContext,resolveInfo,url,mStartTime)) {
String title=String.format(mContext.getString(R.string.link_loaded_with_app),resolveInfo.loadLabel(mContext.getPackageManager()));
MainApplication.saveUrlInHistory(mContext,resolveInfo,url,title);
mEventHandler.onDestroyBubble();
return false;
}
}
}
configureOpenInAppButton();
configureOpenEmbedButton();
Log.d(TAG,""String_Node_Str"" + url);
mWebView.loadUrl(url);
mEventHandler.onPageLoading(url);
mTitleTextView.setText(R.string.loading);
mUrlTextView.setText(url.replace(""String_Node_Str"",""String_Node_Str""));
return true;
}
@Override public void onReceivedError(WebView view,int errorCode,String description,String failingUrl){
mEventHandler.onPageLoaded(null);
mReloadButton.setVisibility(VISIBLE);
mShareButton.setVisibility(GONE);
}
@Override public void onReceivedSslError(WebView view,SslErrorHandler handler,SslError error){
handler.proceed();
}
@Override public void onPageStarted(WebView view,String url,Bitmap favIcon){
mPageFinishedLoading=false;
if (isValidUrl(url)) {
mLoadCount=Math.max(mLoadCount,1);
}
if (mShareButton.getVisibility() == GONE) {
mShareButton.setVisibility(VISIBLE);
}
}
@Override public void onPageFinished(WebView webView,String urlAsString){
super.onPageFinished(webView,urlAsString);
mPageFinishedLoading=true;
URL url=null;
try {
url=new URL(urlAsString);
}
 catch (MalformedURLException e) {
e.printStackTrace();
}
if (isValidUrl(url)) {
updateAppsForUrl(urlAsString);
configureOpenInAppButton();
configureOpenEmbedButton();
mTitleTextView.setText(webView.getTitle());
mUrlTextView.setText(urlAsString.replace(""String_Node_Str"",""String_Node_Str""));
if (--mLoadCount == 0) {
mUrl=urlAsString;
mCurrentLoadedUrl=mUrl;
PageLoadInfo pageLoadInfo=new PageLoadInfo();
pageLoadInfo.bmp=webView.getFavicon();
pageLoadInfo.url=urlAsString;
pageLoadInfo.mHost=url.getHost();
pageLoadInfo.title=webView.getTitle();
mEventHandler.onPageLoaded(pageLoadInfo);
Log.d(TAG,""String_Node_Str"" + urlAsString);
if (mStartTime > -1) {
Log.d(""String_Node_Str"",""String_Node_Str"" + ((System.currentTimeMillis() - mStartTime) / 1000) + ""String_Node_Str"");
mStartTime=-1;
}
if (Settings.get().checkForYouTubeEmbeds()) {
webView.loadUrl(JS_EMBED);
Log.d(TAG,""String_Node_Str"");
}
}
}
}
}
);
mWebView.setOnKeyListener(new OnKeyListener(){
@Override public boolean onKey(View v,int keyCode,KeyEvent event){
if (event.getAction() == KeyEvent.ACTION_DOWN) {
WebView webView=(WebView)v;
switch (keyCode) {
case KeyEvent.KEYCODE_BACK:
{
if (mUrlHistory.size() == 0) {
mEventHandler.onDestroyBubble();
}
 else {
webView.stopLoading();
String urlBefore=webView.getUrl();
String prevUrl=mUrlHistory.pop();
mLoadingPrev=true;
webView.loadUrl(prevUrl);
updateAppsForUrl(webView.getUrl());
if (mYouTubeEmbedHelper != null) {
mYouTubeEmbedHelper.clear();
}
Log.d(TAG,""String_Node_Str"" + urlBefore + ""String_Node_Str""+ webView.getUrl());
configureOpenInAppButton();
configureOpenEmbedButton();
return true;
}
break;
}
}
}
return false;
}
}
);
mWebView.setDownloadListener(new DownloadListener(){
@Override public void onDownloadStart(String url,String userAgent,String contentDisposition,String mimetype,long contentLength){
openInBrowser(url);
mEventHandler.onDestroyBubble();
}
}
);
if (Settings.get().checkForYouTubeEmbeds()) {
mJSEmbedHandler=new JSEmbedHandler();
mWebView.addJavascriptInterface(mJSEmbedHandler,JS_VARIABLE);
}
updateIncognitoMode(Settings.get().isIncognitoMode());
updateAppsForUrl(url);
configureOpenInAppButton();
configureOpenEmbedButton();
Log.d(TAG,""String_Node_Str"" + url);
mStartTime=startTime;
mWebView.loadUrl(url);
mEventHandler.onPageLoading(url);
mTitleTextView.setText(R.string.loading);
mUrlTextView.setText(url.replace(""String_Node_Str"",""String_Node_Str""));
}",0.995294607536956
104950,"@Override protected void openUrlInBubble(String url,long startTime){
  if (mDraggables.size() < Config.MAX_BUBBLES) {
    int x, targetX, y, targetY;
    float time;
    int bubbleIndex=mDraggables.size();
    if (mCurrentState == STATE_ContentView) {
      x=(int)Config.getContentViewX(bubbleIndex,getBubbleCount() + 1);
      y=(int)-Config.mBubbleHeight;
      targetX=x;
      targetY=Config.mContentViewBubbleY;
      time=0.4f;
    }
 else {
      if (bubbleIndex == 0) {
        x=(int)(Config.mBubbleSnapLeftX - Config.mBubbleWidth);
        y=Config.BUBBLE_HOME_Y;
        targetX=Config.BUBBLE_HOME_X;
        targetY=y;
        time=0.4f;
      }
 else {
        x=Config.BUBBLE_HOME_X;
        y=Config.BUBBLE_HOME_Y;
        targetX=x;
        targetY=y;
        time=0.0f;
      }
    }
    Draggable draggable=null;
    BubbleLegacyView bubble;
    try {
      LayoutInflater inflater=LayoutInflater.from(mContext);
      bubble=(BubbleLegacyView)inflater.inflate(R.layout.view_bubble_legacy,null);
      draggable=bubble;
      bubble.configure(url,x,y,targetX,targetY,time,startTime,new BubbleLegacyView.EventHandler(){
        @Override public void onMotionEvent_Touch(        BubbleLegacyView sender,        DraggableHelper.TouchEvent e){
          mCurrentState.onTouchActionDown(sender,e);
        }
        @Override public void onMotionEvent_Move(        BubbleLegacyView sender,        DraggableHelper.MoveEvent e){
          mCurrentState.onTouchActionMove(sender,e);
        }
        @Override public void onMotionEvent_Release(        BubbleLegacyView sender,        DraggableHelper.ReleaseEvent e){
          mCurrentState.onTouchActionRelease(sender,e);
        }
        @Override public void onDestroyDraggable(        Draggable sender){
          if (mDraggables.size() > 1) {
            BubbleLegacyView bubbleView=sender.getBubbleLegacyView();
            int bubbleIndex=bubbleView.getBubbleIndex();
            destroyBubble(sender,Config.BubbleAction.Destroy);
            int nextBubbleIndex=Util.clamp(0,bubbleIndex,mDraggables.size() - 1);
            Draggable nextBubble=mDraggables.get(nextBubbleIndex);
            STATE_ContentView.setActiveBubble(nextBubble);
          }
 else {
            STATE_KillBubble.init(sender);
            switchState(STATE_KillBubble);
          }
        }
        @Override public void onMinimizeBubbles(){
          if (mCurrentState != null && mCurrentState instanceof State_AnimateToBubbleView == false) {
            switchState(STATE_AnimateToBubbleView);
          }
        }
      }
);
    }
 catch (    MalformedURLException e) {
      return;
    }
    mCurrentState.onNewDraggable(draggable);
    mDraggables.add(draggable);
    mBubbles.add(bubble);
    ++mBubblesLoaded;
    for (int i=0; i < mBubbles.size(); ++i) {
      mBubbles.get(i).setBubbleIndex(i);
    }
    Settings.get().saveCurrentBubblesLegacy(mBubbles);
    mBadgeView.attach(bubble);
    mBadgeView.setBubbleCount(mBubbles.size());
    int draggableCount=mDraggables.size();
    if (mCurrentState == STATE_ContentView) {
      draggable.getDraggableView().setVisibility(View.VISIBLE);
      for (int i=0; i < draggableCount; ++i) {
        Draggable draggableItem=mDraggables.get(i);
        if (draggableItem != bubble) {
          draggableItem.getDraggableHelper().setTargetPos((int)Config.getContentViewX(draggableItem.getBubbleLegacyView().getBubbleIndex(),getBubbleCount()),draggableItem.getDraggableHelper().getYPos(),0.2f,false);
        }
      }
    }
 else {
      mFrontDraggable=bubble;
      for (int i=0; i < draggableCount; ++i) {
        Draggable draggableItem=mDraggables.get(i);
        int vis=View.VISIBLE;
        if (draggableItem != mFrontDraggable) {
          vis=View.GONE;
        }
        draggableItem.getDraggableView().setVisibility(vis);
      }
    }
  }
}","@Override protected void openUrlInBubble(String url,long startTime){
  if (mDraggables.size() < Config.MAX_BUBBLES) {
    int x, targetX, y, targetY;
    float time;
    int bubbleIndex=mDraggables.size();
    if (mCurrentState == STATE_ContentView) {
      x=(int)Config.getContentViewX(bubbleIndex,getBubbleCount() + 1);
      y=(int)-Config.mBubbleHeight;
      targetX=x;
      targetY=Config.mContentViewBubbleY;
      time=0.4f;
    }
 else {
      if (bubbleIndex == 0) {
        x=(int)(Config.mBubbleSnapLeftX - Config.mBubbleWidth);
        y=Config.BUBBLE_HOME_Y;
        targetX=Config.BUBBLE_HOME_X;
        targetY=y;
        time=0.4f;
      }
 else {
        x=Config.BUBBLE_HOME_X;
        y=Config.BUBBLE_HOME_Y;
        targetX=x;
        targetY=y;
        time=0.0f;
      }
    }
    Draggable draggable=null;
    BubbleLegacyView bubble;
    try {
      LayoutInflater inflater=LayoutInflater.from(mContext);
      bubble=(BubbleLegacyView)inflater.inflate(R.layout.view_bubble_legacy,null);
      draggable=bubble;
      bubble.configure(url,x,y,targetX,targetY,time,startTime,new BubbleLegacyView.EventHandler(){
        @Override public void onMotionEvent_Touch(        BubbleLegacyView sender,        DraggableHelper.TouchEvent e){
          mCurrentState.onTouchActionDown(sender,e);
        }
        @Override public void onMotionEvent_Move(        BubbleLegacyView sender,        DraggableHelper.MoveEvent e){
          mCurrentState.onTouchActionMove(sender,e);
        }
        @Override public void onMotionEvent_Release(        BubbleLegacyView sender,        DraggableHelper.ReleaseEvent e){
          mCurrentState.onTouchActionRelease(sender,e);
        }
        @Override public void onDestroyDraggable(        Draggable sender){
          if (mDraggables.size() > 1) {
            BubbleLegacyView bubbleView=sender.getBubbleLegacyView();
            int bubbleIndex=bubbleView.getBubbleIndex();
            destroyBubble(sender,Config.BubbleAction.Destroy);
            int nextBubbleIndex=Util.clamp(0,bubbleIndex,mDraggables.size() - 1);
            Draggable nextBubble=mDraggables.get(nextBubbleIndex);
            if (mCurrentState == STATE_ContentView) {
              STATE_ContentView.setActiveBubble(nextBubble);
            }
          }
 else {
            STATE_KillBubble.init(sender);
            switchState(STATE_KillBubble);
          }
        }
        @Override public void onMinimizeBubbles(){
          if (mCurrentState != null && mCurrentState instanceof State_AnimateToBubbleView == false) {
            switchState(STATE_AnimateToBubbleView);
          }
        }
      }
);
    }
 catch (    MalformedURLException e) {
      return;
    }
    mCurrentState.onNewDraggable(draggable);
    mDraggables.add(draggable);
    mBubbles.add(bubble);
    ++mBubblesLoaded;
    for (int i=0; i < mBubbles.size(); ++i) {
      mBubbles.get(i).setBubbleIndex(i);
    }
    Settings.get().saveCurrentBubblesLegacy(mBubbles);
    mBadgeView.attach(bubble);
    mBadgeView.setBubbleCount(mBubbles.size());
    int draggableCount=mDraggables.size();
    if (mCurrentState == STATE_ContentView) {
      draggable.getDraggableView().setVisibility(View.VISIBLE);
      for (int i=0; i < draggableCount; ++i) {
        Draggable draggableItem=mDraggables.get(i);
        if (draggableItem != bubble) {
          draggableItem.getDraggableHelper().setTargetPos((int)Config.getContentViewX(draggableItem.getBubbleLegacyView().getBubbleIndex(),getBubbleCount()),draggableItem.getDraggableHelper().getYPos(),0.2f,false);
        }
      }
    }
 else {
      mFrontDraggable=bubble;
      for (int i=0; i < draggableCount; ++i) {
        Draggable draggableItem=mDraggables.get(i);
        int vis=View.VISIBLE;
        if (draggableItem != mFrontDraggable) {
          vis=View.GONE;
        }
        draggableItem.getDraggableView().setVisibility(vis);
      }
    }
  }
}",0.9909956264471316
104951,"@Override public void onDestroyDraggable(Draggable sender){
  if (mDraggables.size() > 1) {
    BubbleLegacyView bubbleView=sender.getBubbleLegacyView();
    int bubbleIndex=bubbleView.getBubbleIndex();
    destroyBubble(sender,Config.BubbleAction.Destroy);
    int nextBubbleIndex=Util.clamp(0,bubbleIndex,mDraggables.size() - 1);
    Draggable nextBubble=mDraggables.get(nextBubbleIndex);
    STATE_ContentView.setActiveBubble(nextBubble);
  }
 else {
    STATE_KillBubble.init(sender);
    switchState(STATE_KillBubble);
  }
}","@Override public void onDestroyDraggable(Draggable sender){
  if (mDraggables.size() > 1) {
    BubbleLegacyView bubbleView=sender.getBubbleLegacyView();
    int bubbleIndex=bubbleView.getBubbleIndex();
    destroyBubble(sender,Config.BubbleAction.Destroy);
    int nextBubbleIndex=Util.clamp(0,bubbleIndex,mDraggables.size() - 1);
    Draggable nextBubble=mDraggables.get(nextBubbleIndex);
    if (mCurrentState == STATE_ContentView) {
      STATE_ContentView.setActiveBubble(nextBubble);
    }
  }
 else {
    STATE_KillBubble.init(sender);
    switchState(STATE_KillBubble);
  }
}",0.9442446043165468
104952,"public BadgeView(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
}","public BadgeView(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  mAnimState=AnimState.None;
}",0.8744588744588745
104953,"public void show(){
  if (getVisibility() == View.VISIBLE) {
    return;
  }
  setAlpha(0f);
  setVisibility(View.VISIBLE);
  setScaleX(0.33f);
  setScaleY(0.33f);
  animate().alpha(1f).scaleX(1f).scaleY(1f).setDuration(667).setInterpolator(new AnticipateOvershootInterpolator()).setListener(mShowListener).start();
  if (mBubble != null) {
    FrameLayout.LayoutParams lp=(FrameLayout.LayoutParams)getLayoutParams();
    int x=mBubble.getXPos();
    if (x > Config.mScreenCenterX) {
      lp.gravity=Gravity.TOP | Gravity.LEFT;
    }
 else {
      lp.gravity=Gravity.TOP | Gravity.RIGHT;
    }
  }
}","public void show(){
  if (getVisibility() != View.VISIBLE) {
    setAlpha(0f);
    setVisibility(View.VISIBLE);
    setScaleX(0.33f);
    setScaleY(0.33f);
  }
 else   if (mAnimState == AnimState.Hiding) {
    animate().cancel();
    setVisibility(View.VISIBLE);
  }
  animate().alpha(1f).scaleX(1f).scaleY(1f).setDuration(667).setInterpolator(new AnticipateOvershootInterpolator()).setListener(mShowListener).start();
  if (mBubble != null) {
    FrameLayout.LayoutParams lp=(FrameLayout.LayoutParams)getLayoutParams();
    int x=mBubble.getXPos();
    if (x > Config.mScreenCenterX) {
      lp.gravity=Gravity.TOP | Gravity.LEFT;
    }
 else {
      lp.gravity=Gravity.TOP | Gravity.RIGHT;
    }
  }
}",0.7674597083653109
104954,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  mSmoothInterpolator=new AccelerateDecelerateInterpolator();
  mHeaderHeight=getResources().getDimensionPixelSize(R.dimen.header_height);
  mMinHeaderTranslation=-mHeaderHeight + getActionBarHeight();
  setContentView(R.layout.activity_home);
  mListView=(ListView)findViewById(R.id.listview);
  mHeader=findViewById(R.id.header);
  mHeaderPicture=(KenBurnsView)findViewById(R.id.header_picture);
  mHeaderPicture.setResourceIds(R.drawable.picture0,R.drawable.picture1);
  mHeaderLogo=(ImageView)findViewById(R.id.header_logo);
  mActionBarTitleColor=getResources().getColor(R.color.actionbar_title_color);
  mSpannableString=new SpannableString(getString(R.string.home_activity_label));
  mAlphaForegroundColorSpan=new AlphaForegroundColorSpan(mActionBarTitleColor);
  setupActionBar();
  mPlaceHolderView=getLayoutInflater().inflate(R.layout.view_home_header,mListView,false);
  mListView.addHeaderView(mPlaceHolderView);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  mSmoothInterpolator=new AccelerateDecelerateInterpolator();
  mHeaderHeight=getResources().getDimensionPixelSize(R.dimen.header_height);
  mMinHeaderTranslation=-mHeaderHeight + getActionBarHeight();
  setContentView(R.layout.activity_home);
  mListView=(ListView)findViewById(R.id.listview);
  mHeader=findViewById(R.id.header);
  mHeaderPicture=(KenBurnsView)findViewById(R.id.header_picture);
  mHeaderPicture.setResourceIds(R.drawable.picture0,R.drawable.picture1);
  mHeaderLogo=(ImageView)findViewById(R.id.header_logo);
  mActionBarTitleColor=getResources().getColor(R.color.actionbar_title_color);
  mSpannableString=new SpannableString(getString(R.string.home_activity_label));
  mAlphaForegroundColorSpan=new AlphaForegroundColorSpan(mActionBarTitleColor);
  setupActionBar();
  mPlaceHolderView=getLayoutInflater().inflate(R.layout.view_home_header,mListView,false);
  mListView.addHeaderView(mPlaceHolderView);
  if (Settings.get().debugAutoLoadUrl()) {
    MainApplication.openLink(this,""String_Node_Str"",false);
  }
}",0.950440018527096
104955,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  MainApplication app=(MainApplication)getActivity().getApplicationContext();
  Bus bus=app.getBus();
  bus.register(this);
  addPreferencesFromResource(R.xml.prefs);
  CheckBoxPreference autoLoadContentPreference=(CheckBoxPreference)findPreference(Settings.PREFERENCE_AUTO_LOAD_CONTENT);
  autoLoadContentPreference.setChecked(Settings.get().autoLoadContent());
  Preference incognitoButton=findPreference(""String_Node_Str"");
  if (incognitoButton != null) {
    incognitoButton.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener(){
      @Override public boolean onPreferenceChange(      Preference preference,      Object newValue){
        MainApplication app=(MainApplication)getActivity().getApplication();
        Bus bus=app.getBus();
        bus.post(new IncognitoModeChangedEvent((Boolean)newValue));
        return true;
      }
    }
);
  }
  Preference loadUrlButton=findPreference(""String_Node_Str"");
  if (loadUrlButton != null) {
    loadUrlButton.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener(){
      @Override public boolean onPreferenceClick(      Preference preference){
        MainApplication.openLink(getActivity(),""String_Node_Str"",true);
        return true;
      }
    }
);
  }
  final Preference leftConsumeBubblePreference=findPreference(Settings.PREFERENCE_LEFT_CONSUME_BUBBLE);
  leftConsumeBubblePreference.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener(){
    @Override public boolean onPreferenceClick(    Preference preference){
      AlertDialog alertDialog=ActionItem.getConfigureBubbleAlert(getActivity(),new ActionItem.OnActionItemSelectedListener(){
        @Override public void onSelected(        ActionItem actionItem){
          Settings.get().setConsumeBubble(Config.BubbleAction.ConsumeLeft,actionItem.mType,actionItem.getLabel(),actionItem.mPackageName,actionItem.mActivityClassName);
          leftConsumeBubblePreference.setSummary(Settings.get().getConsumeBubbleLabel(Config.BubbleAction.ConsumeLeft));
        }
      }
);
      alertDialog.show();
      return true;
    }
  }
);
  leftConsumeBubblePreference.setSummary(Settings.get().getConsumeBubbleLabel(Config.BubbleAction.ConsumeLeft));
  final Preference rightConsumeBubblePreference=findPreference(Settings.PREFERENCE_RIGHT_CONSUME_BUBBLE);
  rightConsumeBubblePreference.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener(){
    @Override public boolean onPreferenceClick(    Preference preference){
      AlertDialog alertDialog=ActionItem.getConfigureBubbleAlert(getActivity(),new ActionItem.OnActionItemSelectedListener(){
        @Override public void onSelected(        ActionItem actionItem){
          Settings.get().setConsumeBubble(Config.BubbleAction.ConsumeRight,actionItem.mType,actionItem.getLabel(),actionItem.mPackageName,actionItem.mActivityClassName);
          rightConsumeBubblePreference.setSummary(Settings.get().getConsumeBubbleLabel(Config.BubbleAction.ConsumeRight));
        }
      }
);
      alertDialog.show();
      return true;
    }
  }
);
  rightConsumeBubblePreference.setSummary(Settings.get().getConsumeBubbleLabel(Config.BubbleAction.ConsumeRight));
  Preference defaultBrowserPreference=findPreference(Settings.PREFERENCE_DEFAULT_BROWSER);
  defaultBrowserPreference.setTitle(Settings.get().getDefaultBrowserLabel());
  Drawable defaultBrowserIcon=Settings.get().getDefaultBrowserIcon(getActivity());
  if (defaultBrowserIcon != null) {
    defaultBrowserPreference.setIcon(defaultBrowserIcon);
  }
  defaultBrowserPreference.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener(){
    @Override public boolean onPreferenceClick(    final Preference preference){
      AlertDialog alertDialog=ActionItem.getDefaultBrowserAlert(getActivity(),new ActionItem.OnActionItemSelectedListener(){
        @Override public void onSelected(        ActionItem actionItem){
          Settings.get().setDefaultBrowser(actionItem.getLabel(),actionItem.mPackageName);
          preference.setTitle(Settings.get().getDefaultBrowserLabel());
          Drawable defaultBrowserIcon=Settings.get().getDefaultBrowserIcon(getActivity());
          if (defaultBrowserIcon != null) {
            preference.setIcon(defaultBrowserIcon);
          }
        }
      }
);
      alertDialog.show();
      return true;
    }
  }
);
  configureDefaultAppsList();
  SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(getActivity());
  if (prefs.getBoolean(""String_Node_Str"",true)) {
    MainApplication.openLink(getActivity(),""String_Node_Str"",false);
  }
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  MainApplication app=(MainApplication)getActivity().getApplicationContext();
  Bus bus=app.getBus();
  bus.register(this);
  addPreferencesFromResource(R.xml.prefs);
  CheckBoxPreference autoLoadContentPreference=(CheckBoxPreference)findPreference(Settings.PREFERENCE_AUTO_LOAD_CONTENT);
  autoLoadContentPreference.setChecked(Settings.get().autoLoadContent());
  Preference incognitoButton=findPreference(""String_Node_Str"");
  if (incognitoButton != null) {
    incognitoButton.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener(){
      @Override public boolean onPreferenceChange(      Preference preference,      Object newValue){
        MainApplication app=(MainApplication)getActivity().getApplication();
        Bus bus=app.getBus();
        bus.post(new IncognitoModeChangedEvent((Boolean)newValue));
        return true;
      }
    }
);
  }
  final Preference leftConsumeBubblePreference=findPreference(Settings.PREFERENCE_LEFT_CONSUME_BUBBLE);
  leftConsumeBubblePreference.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener(){
    @Override public boolean onPreferenceClick(    Preference preference){
      AlertDialog alertDialog=ActionItem.getConfigureBubbleAlert(getActivity(),new ActionItem.OnActionItemSelectedListener(){
        @Override public void onSelected(        ActionItem actionItem){
          Settings.get().setConsumeBubble(Config.BubbleAction.ConsumeLeft,actionItem.mType,actionItem.getLabel(),actionItem.mPackageName,actionItem.mActivityClassName);
          leftConsumeBubblePreference.setSummary(Settings.get().getConsumeBubbleLabel(Config.BubbleAction.ConsumeLeft));
        }
      }
);
      alertDialog.show();
      return true;
    }
  }
);
  leftConsumeBubblePreference.setSummary(Settings.get().getConsumeBubbleLabel(Config.BubbleAction.ConsumeLeft));
  final Preference rightConsumeBubblePreference=findPreference(Settings.PREFERENCE_RIGHT_CONSUME_BUBBLE);
  rightConsumeBubblePreference.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener(){
    @Override public boolean onPreferenceClick(    Preference preference){
      AlertDialog alertDialog=ActionItem.getConfigureBubbleAlert(getActivity(),new ActionItem.OnActionItemSelectedListener(){
        @Override public void onSelected(        ActionItem actionItem){
          Settings.get().setConsumeBubble(Config.BubbleAction.ConsumeRight,actionItem.mType,actionItem.getLabel(),actionItem.mPackageName,actionItem.mActivityClassName);
          rightConsumeBubblePreference.setSummary(Settings.get().getConsumeBubbleLabel(Config.BubbleAction.ConsumeRight));
        }
      }
);
      alertDialog.show();
      return true;
    }
  }
);
  rightConsumeBubblePreference.setSummary(Settings.get().getConsumeBubbleLabel(Config.BubbleAction.ConsumeRight));
  Preference defaultBrowserPreference=findPreference(Settings.PREFERENCE_DEFAULT_BROWSER);
  defaultBrowserPreference.setTitle(Settings.get().getDefaultBrowserLabel());
  Drawable defaultBrowserIcon=Settings.get().getDefaultBrowserIcon(getActivity());
  if (defaultBrowserIcon != null) {
    defaultBrowserPreference.setIcon(defaultBrowserIcon);
  }
  defaultBrowserPreference.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener(){
    @Override public boolean onPreferenceClick(    final Preference preference){
      AlertDialog alertDialog=ActionItem.getDefaultBrowserAlert(getActivity(),new ActionItem.OnActionItemSelectedListener(){
        @Override public void onSelected(        ActionItem actionItem){
          Settings.get().setDefaultBrowser(actionItem.getLabel(),actionItem.mPackageName);
          preference.setTitle(Settings.get().getDefaultBrowserLabel());
          Drawable defaultBrowserIcon=Settings.get().getDefaultBrowserIcon(getActivity());
          if (defaultBrowserIcon != null) {
            preference.setIcon(defaultBrowserIcon);
          }
        }
      }
);
      alertDialog.show();
      return true;
    }
  }
);
  configureDefaultAppsList();
}",0.9331818181818182
104956,"@Override public boolean OnUpdate(float dt){
  if (mTouchBubble != null) {
    ++mTouchFrameCount;
    if (mTouchFrameCount == 6) {
      mCanvas.fadeInTargets();
    }
    mTouchBubble.doSnap(mCanvas,mTargetX,mTargetY);
    return true;
  }
  return false;
}","@Override public boolean OnUpdate(float dt){
  if (mTouchBubble != null) {
    ++mTouchFrameCount;
    if (mTouchFrameCount == 6) {
      mCanvas.fadeInTargets();
    }
    if (mDidMove) {
      mTouchBubble.doSnap(mCanvas,mTargetX,mTargetY);
    }
    return true;
  }
  return false;
}",0.8241758241758241
104957,"public CondensedTextView(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  if (sCustomTypeface == null) {
    sCustomTypeface=Typeface.createFromAsset(context.getAssets(),""String_Node_Str"");
  }
  setTypeface(sCustomTypeface);
}","public CondensedTextView(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  if (isInEditMode() == false) {
    if (sCustomTypeface == null) {
      sCustomTypeface=Typeface.createFromAsset(context.getAssets(),""String_Node_Str"");
    }
    setTypeface(sCustomTypeface);
  }
}",0.9211908931698776
104958,"@Override public void OnMotionEvent_Release(Bubble sender,Bubble.ReleaseEvent e){
  sender.clearTargetPos();
  if (mDidMove) {
    Canvas.TargetInfo ti=mTouchBubble.getTargetInfo(mCanvas,sender.getXPos(),sender.getYPos());
    if (ti.mAction == Config.BubbleAction.None) {
      float v=(float)Math.sqrt(e.vx * e.vx + e.vy * e.vy);
      float threshold=Config.dpToPx(900.0f);
      if (v > threshold) {
        MainController.STATE_Flick.init(sender,e.vx,e.vy,false);
        MainController.switchState(MainController.STATE_Flick);
      }
 else {
        MainController.STATE_SnapToEdge.init(sender);
        MainController.switchState(MainController.STATE_SnapToEdge);
      }
    }
 else {
      if (MainController.destroyBubble(mTouchBubble,ti.mAction)) {
        MainController.STATE_AnimateToContentView.init(MainController.getBubble(MainController.getBubbleCount() - 1));
        MainController.switchState(MainController.STATE_AnimateToContentView);
      }
 else {
        MainController.switchState(MainController.STATE_BubbleView);
      }
    }
  }
 else   if (mActiveBubble != sender) {
    mActiveBubble=sender;
    mCanvas.setContentView(mActiveBubble.getContentView());
    mCanvas.showContentView();
    mCanvas.setContentViewTranslation(0.0f);
  }
 else {
    MainController.switchState(MainController.STATE_AnimateToBubbleView);
  }
  mTouchBubble=null;
}","@Override public void OnMotionEvent_Release(Bubble sender,Bubble.ReleaseEvent e){
  sender.clearTargetPos();
  if (mDidMove) {
    Canvas.TargetInfo ti=mTouchBubble.getTargetInfo(mCanvas,sender.getXPos(),sender.getYPos());
    if (ti.mAction == Config.BubbleAction.None) {
      float v=(float)Math.sqrt(e.vx * e.vx + e.vy * e.vy);
      float threshold=Config.dpToPx(900.0f);
      if (v > threshold) {
        MainController.STATE_Flick.init(sender,e.vx,e.vy,true);
        MainController.switchState(MainController.STATE_Flick);
      }
 else {
        MainController.STATE_AnimateToContentView.init(mTouchBubble);
        MainController.switchState(MainController.STATE_AnimateToContentView);
      }
    }
 else {
      if (MainController.destroyBubble(mTouchBubble,ti.mAction)) {
        MainController.STATE_AnimateToContentView.init(MainController.getBubble(MainController.getBubbleCount() - 1));
        MainController.switchState(MainController.STATE_AnimateToContentView);
      }
 else {
        MainController.switchState(MainController.STATE_BubbleView);
      }
    }
  }
 else   if (mActiveBubble != sender) {
    mActiveBubble=sender;
    mCanvas.setContentView(mActiveBubble.getContentView());
    mCanvas.showContentView();
    mCanvas.setContentViewTranslation(0.0f);
  }
 else {
    MainController.switchState(MainController.STATE_AnimateToBubbleView);
  }
  mTouchBubble=null;
}",0.9650450450450452
104959,"@Override public boolean OnUpdate(float dt){
  if (mTargetInfo == null) {
    float tf=mTime / mPeriod;
    float f=(mLinear ? mLinearInterpolator.getInterpolation(tf) : mOvershootInterpolator.getInterpolation(tf));
    mTime+=dt;
    float x=mInitialX + (mTargetX - mInitialX) * f;
    float y=mInitialY + (mTargetY - mInitialY) * f;
    Canvas.TargetInfo ti=mBubble.getTargetInfo(mCanvas,(int)x,(int)y);
switch (ti.mAction) {
case Destroy:
case ConsumeRight:
case ConsumeLeft:
      ti.mTargetX=(int)(0.5f + ti.mTargetX - Config.mBubbleWidth * 0.5f);
    ti.mTargetY=(int)(0.5f + ti.mTargetY - Config.mBubbleHeight * 0.5f);
  mTargetInfo=ti;
mBubble.setTargetPos(ti.mTargetX,ti.mTargetY,0.2f,true);
break;
default :
{
Bubble b=mBubble;
if (mTime >= mPeriod) {
x=mTargetX;
y=mTargetY;
if (mContentViewActive) {
  MainController.STATE_AnimateToContentView.init(b);
  MainController.switchState(MainController.STATE_AnimateToContentView);
}
 else if (x == Config.mBubbleSnapLeftX || x == Config.mBubbleSnapRightX) {
  Config.BUBBLE_HOME_X=mBubble.getXPos();
  Config.BUBBLE_HOME_Y=mBubble.getYPos();
  MainController.switchState(MainController.STATE_BubbleView);
}
 else {
  MainController.STATE_SnapToEdge.init(b);
  MainController.switchState(MainController.STATE_SnapToEdge);
}
}
b.setExactPos((int)x,(int)y);
}
}
}
 else {
if (mBubble.getXPos() == mTargetInfo.mTargetX && mBubble.getYPos() == mTargetInfo.mTargetY) {
if (MainController.destroyBubble(mBubble,mTargetInfo.mAction)) {
if (mContentViewActive) MainController.switchState(MainController.STATE_AnimateToContentView);
 else MainController.switchState(MainController.STATE_AnimateToBubbleView);
}
 else {
if (mContentViewActive) MainController.switchState(MainController.STATE_ContentView);
 else MainController.switchState(MainController.STATE_BubbleView);
}
}
}
return true;
}","@Override public boolean OnUpdate(float dt){
  if (mTargetInfo == null) {
    float tf=mTime / mPeriod;
    float f=(mLinear ? mLinearInterpolator.getInterpolation(tf) : mOvershootInterpolator.getInterpolation(tf));
    mTime+=dt;
    float x=mInitialX + (mTargetX - mInitialX) * f;
    float y=mInitialY + (mTargetY - mInitialY) * f;
    Canvas.TargetInfo ti=mBubble.getTargetInfo(mCanvas,(int)x,(int)y);
switch (ti.mAction) {
case Destroy:
case ConsumeRight:
case ConsumeLeft:
      ti.mTargetX=(int)(0.5f + ti.mTargetX - Config.mBubbleWidth * 0.5f);
    ti.mTargetY=(int)(0.5f + ti.mTargetY - Config.mBubbleHeight * 0.5f);
  mTargetInfo=ti;
mBubble.setTargetPos(ti.mTargetX,ti.mTargetY,0.2f,true);
break;
default :
{
Bubble b=mBubble;
if (mTime >= mPeriod) {
x=mTargetX;
y=mTargetY;
if (mContentViewActive) {
  MainController.STATE_AnimateToContentView.init(b);
  MainController.switchState(MainController.STATE_AnimateToContentView);
}
 else if (x == Config.mBubbleSnapLeftX || x == Config.mBubbleSnapRightX) {
  Config.BUBBLE_HOME_X=mBubble.getXPos();
  Config.BUBBLE_HOME_Y=mBubble.getYPos();
  MainController.switchState(MainController.STATE_BubbleView);
}
 else {
  MainController.STATE_SnapToEdge.init(b);
  MainController.switchState(MainController.STATE_SnapToEdge);
}
}
b.setExactPos((int)x,(int)y);
}
}
}
 else {
if (mBubble.getXPos() == mTargetInfo.mTargetX && mBubble.getYPos() == mTargetInfo.mTargetY) {
if (MainController.destroyBubble(mBubble,mTargetInfo.mAction)) {
if (mContentViewActive) {
MainController.STATE_AnimateToContentView.init(MainController.getBubble(MainController.getBubbleCount() - 1));
MainController.switchState(MainController.STATE_AnimateToContentView);
}
 else {
MainController.switchState(MainController.STATE_AnimateToBubbleView);
}
}
 else {
if (mContentViewActive) MainController.switchState(MainController.STATE_ContentView);
 else MainController.switchState(MainController.STATE_BubbleView);
}
}
}
return true;
}",0.9465367395312088
104960,"@Override public void OnExitState(){
  MainController.setAllBubblePositions(mBubble);
  mBubble=null;
}","@Override public void OnExitState(){
  if (!mContentViewActive)   MainController.setAllBubblePositions(mBubble);
  mBubble=null;
}",0.8841201716738197
104961,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  PreferenceManager.setDefaultValues(this,R.xml.prefs,true);
  startService(new Intent(this,MainService.class));
  getBrowsers();
  Intent intent=getIntent();
  if (intent.getAction().equals(Intent.ACTION_VIEW)) {
    boolean openLink=false;
    SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(this);
    boolean enabled=prefs.getBoolean(""String_Node_Str"",true);
    if (enabled) {
      final ActivityManager activityManager=(ActivityManager)getSystemService(Context.ACTIVITY_SERVICE);
      List<ActivityManager.RecentTaskInfo> recentTasks=activityManager.getRecentTasks(16,ActivityManager.RECENT_WITH_EXCLUDED);
      if (recentTasks.size() > 0) {
        ActivityManager.RecentTaskInfo rt=recentTasks.get(0);
        Intent baseIntent=rt.baseIntent;
        ComponentName cn=baseIntent.getComponent();
        boolean isBlacklisted=false;
        for (        String packageName : mBrowsers) {
          if (cn.getPackageName().equals(packageName)) {
            isBlacklisted=true;
            break;
          }
        }
        if (!isBlacklisted) {
          openLink=true;
        }
      }
    }
    if (openLink) {
      mUrl=intent.getDataString();
      Intent serviceIntent=new Intent(this,MainService.class);
      bindService(serviceIntent,mConnection,Context.BIND_AUTO_CREATE);
    }
 else {
      loadInBrowser(this,intent);
    }
    finish();
  }
 else {
    setContentView(R.layout.activity_main);
  }
}","@Override protected void onCreate(Bundle savedInstanceState){
  sCurrentInstance=this;
  Intent intent=getIntent();
  boolean isActionView=intent.getAction().equals(Intent.ACTION_VIEW);
  if (isActionView == false) {
    setTheme(android.R.style.Theme_Holo_Light);
  }
  super.onCreate(savedInstanceState);
  PreferenceManager.setDefaultValues(this,R.xml.prefs,true);
  startService(new Intent(this,MainService.class));
  getBrowsers();
  if (isActionView) {
    boolean openLink=false;
    SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(this);
    boolean enabled=prefs.getBoolean(""String_Node_Str"",true);
    if (enabled) {
      final ActivityManager activityManager=(ActivityManager)getSystemService(Context.ACTIVITY_SERVICE);
      List<ActivityManager.RecentTaskInfo> recentTasks=activityManager.getRecentTasks(16,ActivityManager.RECENT_WITH_EXCLUDED);
      if (recentTasks.size() > 0) {
        ActivityManager.RecentTaskInfo rt=recentTasks.get(0);
        Intent baseIntent=rt.baseIntent;
        ComponentName cn=baseIntent.getComponent();
        boolean isBlacklisted=false;
        for (        String packageName : mBrowsers) {
          if (cn.getPackageName().equals(packageName)) {
            isBlacklisted=true;
            break;
          }
        }
        if (!isBlacklisted) {
          openLink=true;
        }
      }
    }
    if (openLink) {
      mUrl=intent.getDataString();
      Intent serviceIntent=new Intent(this,MainService.class);
      bindService(serviceIntent,mConnection,Context.BIND_AUTO_CREATE);
    }
 else {
      loadInBrowser(this,intent);
    }
    finish();
  }
 else {
    setContentView(R.layout.activity_main);
  }
}",0.8342080889163322
104962,"@Override protected void onStop(){
  super.onStop();
  try {
    unbindService(mConnection);
  }
 catch (  Exception e) {
  }
}","@Override protected void onStop(){
  super.onStop();
  try {
    unbindService(mConnection);
  }
 catch (  Exception e) {
  }
  delayedFinishIfCurrent();
}",0.900709219858156
104963,"public Canvas(Context context){
  super(context);
  mContext=context;
  mLayout=new RelativeLayout(context);
  mEnabled=true;
  applyAlpha();
  addView(mLayout,ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT);
  mTargets.add(new BubbleTarget(android.R.drawable.ic_delete,Config.BubbleAction.Destroy,0.5f,0.85f));
  if (Config.mTwitterIcon != null) {
    mTargets.add(new BubbleTarget(Config.mTwitterIcon,Config.BubbleAction.ConsumeRight,0.2f,0.2f));
  }
 else {
    mTargets.add(new BubbleTarget(Config.mBrowserIcon,Config.BubbleAction.ConsumeLeft,0.2f,0.2f));
  }
  mTargets.add(new BubbleTarget(Config.mBrowserIcon,Config.BubbleAction.ConsumeLeft,0.8f,0.2f));
  mWindowManager=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  mWindowManagerParams.gravity=Gravity.TOP | Gravity.LEFT;
  mWindowManagerParams.x=0;
  mWindowManagerParams.y=0;
  mWindowManagerParams.height=WindowManager.LayoutParams.MATCH_PARENT;
  mWindowManagerParams.width=WindowManager.LayoutParams.MATCH_PARENT;
  mWindowManagerParams.type=WindowManager.LayoutParams.TYPE_PHONE;
  mWindowManagerParams.flags=WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
  mWindowManagerParams.format=PixelFormat.TRANSPARENT;
  mWindowManager.addView(this,mWindowManagerParams);
}","public Canvas(Context context){
  super(context);
  mContext=context;
  mLayout=new RelativeLayout(context);
  mEnabled=true;
  applyAlpha();
  addView(mLayout,ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT);
  mTargets.add(new BubbleTarget(android.R.drawable.ic_delete,Config.BubbleAction.Destroy,0.5f,0.85f));
  if (Config.mTwitterIcon != null) {
    mTargets.add(new BubbleTarget(Config.mTwitterIcon,Config.BubbleAction.ConsumeLeft,0.2f,0.2f));
  }
 else {
    mTargets.add(new BubbleTarget(Config.mBrowserIcon,Config.BubbleAction.ConsumeRight,0.2f,0.2f));
  }
  mTargets.add(new BubbleTarget(Config.mBrowserIcon,Config.BubbleAction.ConsumeRight,0.8f,0.2f));
  mWindowManager=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  mWindowManagerParams.gravity=Gravity.TOP | Gravity.LEFT;
  mWindowManagerParams.x=0;
  mWindowManagerParams.y=0;
  mWindowManagerParams.height=WindowManager.LayoutParams.MATCH_PARENT;
  mWindowManagerParams.width=WindowManager.LayoutParams.MATCH_PARENT;
  mWindowManagerParams.type=WindowManager.LayoutParams.TYPE_PHONE;
  mWindowManagerParams.flags=WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
  mWindowManagerParams.format=PixelFormat.TRANSPARENT;
  mWindowManager.addView(this,mWindowManagerParams);
}",0.9140067592940292
104964,"private void doTargetAction(Config.BubbleAction action,String url){
switch (action) {
case ConsumeLeft:
{
      MainActivity.loadInBrowser(mContext,url,true);
    }
  break;
case ConsumeRight:
{
  Intent intent=new Intent(Intent.ACTION_SEND);
  intent.setType(""String_Node_Str"");
  intent.setClassName(""String_Node_Str"",""String_Node_Str"");
  intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
  intent.putExtra(Intent.EXTRA_TEXT,url);
  mContext.startActivity(intent);
}
break;
default :
break;
}
}","private void doTargetAction(Config.BubbleAction action,String url){
switch (action) {
case ConsumeRight:
{
      MainActivity.loadInBrowser(mContext,url,true);
    }
  break;
case ConsumeLeft:
{
  Intent intent=new Intent(Intent.ACTION_SEND);
  intent.setType(""String_Node_Str"");
  intent.setClassName(""String_Node_Str"",""String_Node_Str"");
  intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
  intent.putExtra(Intent.EXTRA_TEXT,url);
  mContext.startActivity(intent);
}
break;
default :
break;
}
}",0.8202020202020202
104965,"void setConsumeBubble(Config.BubbleAction bubbleType,String label,String packageName,String activityClassName){
  SharedPreferences.Editor editor=mSharedPreferences.edit();
switch (bubbleType) {
case ConsumeRight:
    editor.putString(PREFERENCE_LEFT_CONSUME_BUBBLE_LABEL,label);
  editor.putString(PREFERENCE_LEFT_CONSUME_BUBBLE_PACKAGE_NAME,packageName);
editor.putString(PREFERENCE_LEFT_CONSUME_BUBBLE_ACTIVITY_CLASS_NAME,activityClassName);
break;
case ConsumeLeft:
editor.putString(PREFERENCE_RIGHT_CONSUME_BUBBLE_LABEL,label);
editor.putString(PREFERENCE_RIGHT_CONSUME_BUBBLE_PACKAGE_NAME,packageName);
editor.putString(PREFERENCE_RIGHT_CONSUME_BUBBLE_ACTIVITY_CLASS_NAME,activityClassName);
break;
}
editor.commit();
}","void setConsumeBubble(Config.BubbleAction bubbleType,String label,String packageName,String activityClassName){
  SharedPreferences.Editor editor=mSharedPreferences.edit();
switch (bubbleType) {
case ConsumeLeft:
    editor.putString(PREFERENCE_LEFT_CONSUME_BUBBLE_LABEL,label);
  editor.putString(PREFERENCE_LEFT_CONSUME_BUBBLE_PACKAGE_NAME,packageName);
editor.putString(PREFERENCE_LEFT_CONSUME_BUBBLE_ACTIVITY_CLASS_NAME,activityClassName);
break;
case ConsumeRight:
editor.putString(PREFERENCE_RIGHT_CONSUME_BUBBLE_LABEL,label);
editor.putString(PREFERENCE_RIGHT_CONSUME_BUBBLE_PACKAGE_NAME,packageName);
editor.putString(PREFERENCE_RIGHT_CONSUME_BUBBLE_ACTIVITY_CLASS_NAME,activityClassName);
break;
}
editor.commit();
}",0.9903448275862068
104966,"String getConsumeBubbleLabel(Config.BubbleAction bubbleType){
switch (bubbleType) {
case ConsumeRight:
    return mSharedPreferences.getString(PREFERENCE_LEFT_CONSUME_BUBBLE_LABEL,null);
case ConsumeLeft:
  return mSharedPreferences.getString(PREFERENCE_RIGHT_CONSUME_BUBBLE_LABEL,null);
}
return null;
}","String getConsumeBubbleLabel(Config.BubbleAction bubbleType){
switch (bubbleType) {
case ConsumeLeft:
    return mSharedPreferences.getString(PREFERENCE_LEFT_CONSUME_BUBBLE_LABEL,null);
case ConsumeRight:
  return mSharedPreferences.getString(PREFERENCE_RIGHT_CONSUME_BUBBLE_LABEL,null);
}
return null;
}",0.9769736842105264
104967,"@Override public boolean onPreferenceClick(Preference preference){
  AlertDialog alertDialog=getConfigureBubbleAlert(Config.BubbleAction.ConsumeLeft,rightConsumeBubblePreference);
  alertDialog.show();
  return true;
}","@Override public boolean onPreferenceClick(Preference preference){
  AlertDialog alertDialog=getConfigureBubbleAlert(Config.BubbleAction.ConsumeRight,rightConsumeBubblePreference);
  alertDialog.show();
  return true;
}",0.9839816933638444
104968,"/** 
 * Creates a new music folder.
 * @param musicFolder The music folder to create.
 */
public void createMusicFolder(MusicFolder musicFolder){
  String sql=""String_Node_Str"" + INSERT_COLUMNS + ""String_Node_Str"";
  update(sql,musicFolder.getPath(),musicFolder.getName(),musicFolder.isEnabled(),musicFolder.getChanged());
  Integer id=queryForInt(""String_Node_Str"",0);
  update(""String_Node_Str"" + userDao.getUserTable(),id);
  LOG.info(""String_Node_Str"" + musicFolder.getPath());
}","/** 
 * Creates a new music folder.
 * @param musicFolder The music folder to create.
 */
public void createMusicFolder(MusicFolder musicFolder){
  String sql=""String_Node_Str"" + INSERT_COLUMNS + ""String_Node_Str"";
  update(sql,musicFolder.getPath().getPath(),musicFolder.getName(),musicFolder.isEnabled(),musicFolder.getChanged());
  Integer id=queryForInt(""String_Node_Str"",0);
  update(""String_Node_Str"" + userDao.getUserTable(),id);
  LOG.info(""String_Node_Str"" + musicFolder.getPath());
}",0.9897540983606558
104969,"/** 
 * Creates a new player.
 * @param player The player to create.
 */
public synchronized void createPlayer(Player player){
  int id=getJdbcTemplate().queryForObject(""String_Node_Str"",Integer.class) + 1;
  player.setId(String.valueOf(id));
  String sql=""String_Node_Str"" + COLUMNS + ""String_Node_Str""+ questionMarks(COLUMNS)+ ""String_Node_Str"";
  update(sql,player.getId(),player.getName(),player.getType(),player.getUsername(),player.getIpAddress(),player.isAutoControlEnabled(),player.isM3uBomEnabled(),player.getLastSeen(),CoverArtScheme.MEDIUM.name(),player.getTranscodeScheme().name(),player.isDynamicIp(),player.getTechnology().name(),player.getClientId());
  addPlaylist(player);
  LOG.info(""String_Node_Str"" + id + '.');
}","/** 
 * Creates a new player.
 * @param player The player to create.
 */
public synchronized void createPlayer(Player player){
  Integer existingMax=getJdbcTemplate().queryForObject(""String_Node_Str"",Integer.class);
  if (existingMax == null) {
    existingMax=0;
  }
  int id=existingMax + 1;
  player.setId(String.valueOf(id));
  String sql=""String_Node_Str"" + COLUMNS + ""String_Node_Str""+ questionMarks(COLUMNS)+ ""String_Node_Str"";
  update(sql,player.getId(),player.getName(),player.getType(),player.getUsername(),player.getIpAddress(),player.isAutoControlEnabled(),player.isM3uBomEnabled(),player.getLastSeen(),CoverArtScheme.MEDIUM.name(),player.getTranscodeScheme().name(),player.isDynamicIp(),player.getTechnology().name(),player.getClientId());
  addPlaylist(player);
  LOG.info(""String_Node_Str"" + id + '.');
}",0.936252414681262
104970,"/** 
 * Creates a new transcoding.
 * @param transcoding The transcoding to create.
 */
public synchronized void createTranscoding(Transcoding transcoding){
  int id=getJdbcTemplate().queryForObject(""String_Node_Str"",Integer.class);
  transcoding.setId(id);
  String sql=""String_Node_Str"" + COLUMNS + ""String_Node_Str""+ questionMarks(COLUMNS)+ ""String_Node_Str"";
  update(sql,transcoding.getId(),transcoding.getName(),transcoding.getSourceFormats(),transcoding.getTargetFormat(),transcoding.getStep1(),transcoding.getStep2(),transcoding.getStep3(),transcoding.isDefaultActive());
  LOG.info(""String_Node_Str"" + transcoding.getName());
}","/** 
 * Creates a new transcoding.
 * @param transcoding The transcoding to create.
 */
public synchronized void createTranscoding(Transcoding transcoding){
  Integer existingMax=getJdbcTemplate().queryForObject(""String_Node_Str"",Integer.class);
  if (existingMax == null) {
    existingMax=0;
  }
  transcoding.setId(existingMax + 1);
  String sql=""String_Node_Str"" + COLUMNS + ""String_Node_Str""+ questionMarks(COLUMNS)+ ""String_Node_Str"";
  update(sql,transcoding.getId(),transcoding.getName(),transcoding.getSourceFormats(),transcoding.getTargetFormat(),transcoding.getStep1(),transcoding.getStep2(),transcoding.getStep3(),transcoding.isDefaultActive());
  LOG.info(""String_Node_Str"" + transcoding.getName());
}",0.9303703703703704
104971,"/** 
 * Creates a new player.
 * @param player The player to create.
 */
public synchronized void createPlayer(Player player){
  int id=getJdbcTemplate().queryForObject(""String_Node_Str"",Integer.class) + 1;
  player.setId(String.valueOf(id));
  String sql=""String_Node_Str"" + COLUMNS + ""String_Node_Str""+ questionMarks(COLUMNS)+ ""String_Node_Str"";
  update(sql,player.getId(),player.getName(),player.getType(),player.getUsername(),player.getIpAddress(),player.isAutoControlEnabled(),player.getLastSeen(),CoverArtScheme.MEDIUM.name(),player.getTranscodeScheme().name(),player.isDynamicIp(),player.getTechnology().name(),player.getClientId());
  addPlaylist(player);
  LOG.info(""String_Node_Str"" + id + '.');
}","/** 
 * Creates a new player.
 * @param player The player to create.
 */
public synchronized void createPlayer(Player player){
  Integer existingMax=getJdbcTemplate().queryForObject(""String_Node_Str"",Integer.class);
  if (existingMax == null) {
    existingMax=0;
  }
  int id=existingMax + 1;
  player.setId(String.valueOf(id));
  String sql=""String_Node_Str"" + COLUMNS + ""String_Node_Str""+ questionMarks(COLUMNS)+ ""String_Node_Str"";
  update(sql,player.getId(),player.getName(),player.getType(),player.getUsername(),player.getIpAddress(),player.isAutoControlEnabled(),player.getLastSeen(),CoverArtScheme.MEDIUM.name(),player.getTranscodeScheme().name(),player.isDynamicIp(),player.getTechnology().name(),player.getClientId());
  addPlaylist(player);
  LOG.info(""String_Node_Str"" + id + '.');
}",0.934131736526946
104972,"/** 
 * Creates a new transcoding.
 * @param transcoding The transcoding to create.
 */
public synchronized void createTranscoding(Transcoding transcoding){
  int id=getJdbcTemplate().queryForObject(""String_Node_Str"",Integer.class);
  transcoding.setId(id);
  String sql=""String_Node_Str"" + COLUMNS + ""String_Node_Str""+ questionMarks(COLUMNS)+ ""String_Node_Str"";
  update(sql,transcoding.getId(),transcoding.getName(),transcoding.getSourceFormats(),transcoding.getTargetFormat(),transcoding.getStep1(),transcoding.getStep2(),transcoding.getStep3(),transcoding.isDefaultActive());
  LOG.info(""String_Node_Str"" + transcoding.getName());
}","/** 
 * Creates a new transcoding.
 * @param transcoding The transcoding to create.
 */
public synchronized void createTranscoding(Transcoding transcoding){
  Integer existingMax=getJdbcTemplate().queryForObject(""String_Node_Str"",Integer.class);
  if (existingMax == null) {
    existingMax=0;
  }
  transcoding.setId(existingMax + 1);
  String sql=""String_Node_Str"" + COLUMNS + ""String_Node_Str""+ questionMarks(COLUMNS)+ ""String_Node_Str"";
  update(sql,transcoding.getId(),transcoding.getName(),transcoding.getSourceFormats(),transcoding.getTargetFormat(),transcoding.getStep1(),transcoding.getStep2(),transcoding.getStep3(),transcoding.isDefaultActive());
  LOG.info(""String_Node_Str"" + transcoding.getName());
}",0.9303703703703704
104973,"/** 
 * {@inheritDoc}
 */
@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  super.onMeasure(widthMeasureSpec,heightMeasureSpec);
  int sizeWidth=MeasureSpec.getSize(widthMeasureSpec) - getPaddingLeft() - getPaddingRight();
  int sizeHeight=MeasureSpec.getSize(heightMeasureSpec);
  int modeWidth=MeasureSpec.getMode(widthMeasureSpec);
  int modeHeight=MeasureSpec.getMode(heightMeasureSpec);
  int width=0;
  int height=getPaddingTop() + getPaddingBottom();
  int lineWidth=0;
  int lineHeight=0;
  int childCount=getChildCount();
  for (int i=0; i < childCount; i++) {
    View child=getChildAt(i);
    if (child.getVisibility() == View.GONE) {
      if (i == childCount - 1) {
        width=Math.max(width,lineWidth);
        height+=lineHeight;
      }
      continue;
    }
    measureChildWithMargins(child,widthMeasureSpec,lineWidth,heightMeasureSpec,height);
    LayoutParams lp=(LayoutParams)child.getLayoutParams();
    int childWidthMode=MeasureSpec.AT_MOST;
    int childWidthSize=sizeWidth;
    int childHeightMode=MeasureSpec.AT_MOST;
    int childHeightSize=sizeHeight;
    if (lp.width == LayoutParams.MATCH_PARENT) {
      childWidthMode=MeasureSpec.EXACTLY;
      childWidthSize-=lp.leftMargin + lp.rightMargin;
    }
 else     if (lp.width >= 0) {
      childWidthMode=MeasureSpec.EXACTLY;
      childWidthSize=lp.width;
    }
    if (lp.height >= 0) {
      childHeightMode=MeasureSpec.EXACTLY;
      childHeightSize=lp.height;
    }
 else     if (modeHeight == MeasureSpec.UNSPECIFIED) {
      childHeightMode=MeasureSpec.UNSPECIFIED;
      childHeightSize=0;
    }
    child.measure(MeasureSpec.makeMeasureSpec(childWidthSize,childWidthMode),MeasureSpec.makeMeasureSpec(childHeightSize,childHeightMode));
    int childWidth=child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin;
    boolean lastChild=i == childCount - 1;
    if (lineWidth + childWidth > sizeWidth || lastChild) {
      width=Math.max(width,lineWidth);
      lineWidth=childWidth;
      height+=lineHeight;
      lineHeight=Math.max(lineHeight,child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
    }
 else {
      lineWidth+=childWidth;
      lineHeight=Math.max(lineHeight,child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
    }
  }
  width+=getPaddingLeft() + getPaddingRight();
  setMeasuredDimension((modeWidth == MeasureSpec.EXACTLY) ? sizeWidth : width,(modeHeight == MeasureSpec.EXACTLY) ? sizeHeight : height);
}","/** 
 * {@inheritDoc}
 */
@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  super.onMeasure(widthMeasureSpec,heightMeasureSpec);
  int sizeWidth=MeasureSpec.getSize(widthMeasureSpec) - getPaddingLeft() - getPaddingRight();
  int sizeHeight=MeasureSpec.getSize(heightMeasureSpec);
  int modeWidth=MeasureSpec.getMode(widthMeasureSpec);
  int modeHeight=MeasureSpec.getMode(heightMeasureSpec);
  int width=0;
  int height=getPaddingTop() + getPaddingBottom();
  int lineWidth=0;
  int lineHeight=0;
  int childCount=getChildCount();
  for (int i=0; i < childCount; i++) {
    View child=getChildAt(i);
    if (child.getVisibility() == View.GONE) {
      if (i == childCount - 1) {
        width=Math.max(width,lineWidth);
        height+=lineHeight;
      }
      continue;
    }
    measureChildWithMargins(child,widthMeasureSpec,lineWidth,heightMeasureSpec,height);
    LayoutParams lp=(LayoutParams)child.getLayoutParams();
    int childWidthMode=MeasureSpec.AT_MOST;
    int childWidthSize=sizeWidth;
    int childHeightMode=MeasureSpec.AT_MOST;
    int childHeightSize=sizeHeight;
    if (lp.width == LayoutParams.MATCH_PARENT) {
      childWidthMode=MeasureSpec.EXACTLY;
      childWidthSize-=lp.leftMargin + lp.rightMargin;
    }
 else     if (lp.width >= 0) {
      childWidthMode=MeasureSpec.EXACTLY;
      childWidthSize=lp.width;
    }
    if (lp.height >= 0) {
      childHeightMode=MeasureSpec.EXACTLY;
      childHeightSize=lp.height;
    }
 else     if (modeHeight == MeasureSpec.UNSPECIFIED) {
      childHeightMode=MeasureSpec.UNSPECIFIED;
      childHeightSize=0;
    }
    child.measure(MeasureSpec.makeMeasureSpec(childWidthSize,childWidthMode),MeasureSpec.makeMeasureSpec(childHeightSize,childHeightMode));
    int childWidth=child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin;
    if (lineWidth + childWidth > sizeWidth) {
      width=Math.max(width,lineWidth);
      lineWidth=childWidth;
      height+=lineHeight;
      lineHeight=child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin;
    }
 else {
      lineWidth+=childWidth;
      lineHeight=Math.max(lineHeight,child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
    }
    if (i == childCount - 1) {
      width=Math.max(width,lineWidth);
      height+=lineHeight;
    }
  }
  width+=getPaddingLeft() + getPaddingRight();
  setMeasuredDimension((modeWidth == MeasureSpec.EXACTLY) ? sizeWidth : width,(modeHeight == MeasureSpec.EXACTLY) ? sizeHeight : height);
}",0.8315513415372201
104974,"/** 
 * {@inheritDoc}
 */
@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  super.onMeasure(widthMeasureSpec,heightMeasureSpec);
  int sizeWidth=MeasureSpec.getSize(widthMeasureSpec) - getPaddingLeft() - getPaddingRight();
  int sizeHeight=MeasureSpec.getSize(heightMeasureSpec);
  int modeWidth=MeasureSpec.getMode(widthMeasureSpec);
  int modeHeight=MeasureSpec.getMode(heightMeasureSpec);
  int width=0;
  int height=getPaddingTop() + getPaddingBottom();
  int lineWidth=0;
  int lineHeight=0;
  int childCount=getChildCount();
  for (int i=0; i < childCount; i++) {
    View child=getChildAt(i);
    if (child.getVisibility() == View.GONE) {
      if (i == childCount - 1) {
        width=Math.max(width,lineWidth);
        height+=lineHeight;
      }
      continue;
    }
    measureChildWithMargins(child,widthMeasureSpec,lineWidth,heightMeasureSpec,height);
    LayoutParams lp=(LayoutParams)child.getLayoutParams();
    int childWidthMode=MeasureSpec.AT_MOST;
    int childWidthSize=sizeWidth;
    int childHeightMode=MeasureSpec.AT_MOST;
    int childHeightSize=sizeHeight;
    if (lp.width == LayoutParams.MATCH_PARENT) {
      childWidthMode=MeasureSpec.EXACTLY;
      childWidthSize-=lp.leftMargin + lp.rightMargin;
    }
 else     if (lp.width >= 0) {
      childWidthMode=MeasureSpec.EXACTLY;
      childWidthSize=lp.width;
    }
    if (lp.height >= 0) {
      childHeightMode=MeasureSpec.EXACTLY;
      childHeightSize=lp.height;
    }
 else     if (modeHeight == MeasureSpec.UNSPECIFIED) {
      childHeightMode=MeasureSpec.UNSPECIFIED;
      childHeightSize=0;
    }
    child.measure(MeasureSpec.makeMeasureSpec(childWidthSize,childWidthMode),MeasureSpec.makeMeasureSpec(childHeightSize,childHeightMode));
    int childWidth=child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin;
    if (lineWidth + childWidth > sizeWidth) {
      width=Math.max(width,lineWidth);
      lineWidth=childWidth;
      height+=lineHeight;
      lineHeight=Math.max(lineHeight,child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
    }
 else {
      lineWidth+=childWidth;
      lineHeight=Math.max(lineHeight,child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
    }
    if (i == childCount - 1) {
      width=Math.max(width,lineWidth);
      height+=lineHeight;
    }
  }
  width+=getPaddingLeft() + getPaddingRight();
  setMeasuredDimension((modeWidth == MeasureSpec.EXACTLY) ? sizeWidth : width,(modeHeight == MeasureSpec.EXACTLY) ? sizeHeight : height);
}","/** 
 * {@inheritDoc}
 */
@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  super.onMeasure(widthMeasureSpec,heightMeasureSpec);
  int sizeWidth=MeasureSpec.getSize(widthMeasureSpec) - getPaddingLeft() - getPaddingRight();
  int sizeHeight=MeasureSpec.getSize(heightMeasureSpec);
  int modeWidth=MeasureSpec.getMode(widthMeasureSpec);
  int modeHeight=MeasureSpec.getMode(heightMeasureSpec);
  int width=0;
  int height=getPaddingTop() + getPaddingBottom();
  int lineWidth=0;
  int lineHeight=0;
  int childCount=getChildCount();
  for (int i=0; i < childCount; i++) {
    View child=getChildAt(i);
    if (child.getVisibility() == View.GONE) {
      if (i == childCount - 1) {
        width=Math.max(width,lineWidth);
        height+=lineHeight;
      }
      continue;
    }
    measureChildWithMargins(child,widthMeasureSpec,lineWidth,heightMeasureSpec,height);
    LayoutParams lp=(LayoutParams)child.getLayoutParams();
    int childWidthMode=MeasureSpec.AT_MOST;
    int childWidthSize=sizeWidth;
    int childHeightMode=MeasureSpec.AT_MOST;
    int childHeightSize=sizeHeight;
    if (lp.width == LayoutParams.MATCH_PARENT) {
      childWidthMode=MeasureSpec.EXACTLY;
      childWidthSize-=lp.leftMargin + lp.rightMargin;
    }
 else     if (lp.width >= 0) {
      childWidthMode=MeasureSpec.EXACTLY;
      childWidthSize=lp.width;
    }
    if (lp.height >= 0) {
      childHeightMode=MeasureSpec.EXACTLY;
      childHeightSize=lp.height;
    }
 else     if (modeHeight == MeasureSpec.UNSPECIFIED) {
      childHeightMode=MeasureSpec.UNSPECIFIED;
      childHeightSize=0;
    }
    child.measure(MeasureSpec.makeMeasureSpec(childWidthSize,childWidthMode),MeasureSpec.makeMeasureSpec(childHeightSize,childHeightMode));
    int childWidth=child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin;
    boolean lastChild=i == childCount - 1;
    if (lineWidth + childWidth > sizeWidth || lastChild) {
      width=Math.max(width,lineWidth);
      lineWidth=childWidth;
      height+=lineHeight;
      lineHeight=Math.max(lineHeight,child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
    }
 else {
      lineWidth+=childWidth;
      lineHeight=Math.max(lineHeight,child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
    }
  }
  width+=getPaddingLeft() + getPaddingRight();
  setMeasuredDimension((modeWidth == MeasureSpec.EXACTLY) ? sizeWidth : width,(modeHeight == MeasureSpec.EXACTLY) ? sizeHeight : height);
}",0.9682603455202892
104975,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  super.onMeasure(widthMeasureSpec,heightMeasureSpec);
  int sizeWidth=MeasureSpec.getSize(widthMeasureSpec);
  int sizeHeight=MeasureSpec.getSize(heightMeasureSpec);
  int modeWidth=MeasureSpec.getMode(widthMeasureSpec);
  int modeHeight=MeasureSpec.getMode(heightMeasureSpec);
  int width=0;
  int height=0;
  int lineWidth=0;
  int lineHeight=0;
  int childCount=getChildCount();
  for (int i=0; i < childCount; i++) {
    View child=getChildAt(i);
    if (child.getVisibility() == View.GONE) {
      continue;
    }
    LayoutParams lp=(LayoutParams)child.getLayoutParams();
    int childWidthMode=MeasureSpec.AT_MOST;
    int childWidthSize=sizeWidth;
    int childHeightMode=MeasureSpec.AT_MOST;
    int childHeightSize=sizeHeight;
    if (lp.width == LayoutParams.MATCH_PARENT) {
      childWidthMode=MeasureSpec.EXACTLY;
      childWidthSize-=lp.leftMargin + lp.rightMargin;
    }
 else     if (lp.width >= 0) {
      childWidthMode=MeasureSpec.EXACTLY;
      childWidthSize=lp.width;
    }
    if (lp.height >= 0) {
      childHeightMode=MeasureSpec.EXACTLY;
      childHeightSize=lp.height;
    }
    child.measure(MeasureSpec.makeMeasureSpec(childWidthSize,childWidthMode),MeasureSpec.makeMeasureSpec(childHeightSize,childHeightMode));
    int childWidth=child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin;
    if (lineWidth + childWidth > sizeWidth) {
      width=Math.max(width,lineWidth);
      lineWidth=childWidth;
      height+=lineHeight;
      lineHeight=Math.max(lineHeight,child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
    }
 else {
      lineWidth+=childWidth;
      lineHeight=Math.max(lineHeight,child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
    }
    if (i == childCount - 1) {
      width=Math.max(width,lineWidth);
      height+=lineHeight;
    }
  }
  setMeasuredDimension((modeWidth == MeasureSpec.EXACTLY) ? sizeWidth : width,(modeHeight == MeasureSpec.EXACTLY) ? sizeHeight : height);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  super.onMeasure(widthMeasureSpec,heightMeasureSpec);
  int sizeWidth=MeasureSpec.getSize(widthMeasureSpec);
  int sizeHeight=MeasureSpec.getSize(heightMeasureSpec);
  int modeWidth=MeasureSpec.getMode(widthMeasureSpec);
  int modeHeight=MeasureSpec.getMode(heightMeasureSpec);
  int width=0;
  int height=0;
  int lineWidth=0;
  int lineHeight=0;
  int childCount=getChildCount();
  for (int i=0; i < childCount; i++) {
    View child=getChildAt(i);
    if (child.getVisibility() == View.GONE) {
      if (i == childCount - 1) {
        width=Math.max(width,lineWidth);
        height+=lineHeight;
      }
      continue;
    }
    LayoutParams lp=(LayoutParams)child.getLayoutParams();
    int childWidthMode=MeasureSpec.AT_MOST;
    int childWidthSize=sizeWidth;
    int childHeightMode=MeasureSpec.AT_MOST;
    int childHeightSize=sizeHeight;
    if (lp.width == LayoutParams.MATCH_PARENT) {
      childWidthMode=MeasureSpec.EXACTLY;
      childWidthSize-=lp.leftMargin + lp.rightMargin;
    }
 else     if (lp.width >= 0) {
      childWidthMode=MeasureSpec.EXACTLY;
      childWidthSize=lp.width;
    }
    if (lp.height >= 0) {
      childHeightMode=MeasureSpec.EXACTLY;
      childHeightSize=lp.height;
    }
    child.measure(MeasureSpec.makeMeasureSpec(childWidthSize,childWidthMode),MeasureSpec.makeMeasureSpec(childHeightSize,childHeightMode));
    int childWidth=child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin;
    if (lineWidth + childWidth > sizeWidth) {
      width=Math.max(width,lineWidth);
      lineWidth=childWidth;
      height+=lineHeight;
      lineHeight=Math.max(lineHeight,child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
    }
 else {
      lineWidth+=childWidth;
      lineHeight=Math.max(lineHeight,child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
    }
    if (i == childCount - 1) {
      width=Math.max(width,lineWidth);
      height+=lineHeight;
    }
  }
  setMeasuredDimension((modeWidth == MeasureSpec.EXACTLY) ? sizeWidth : width,(modeHeight == MeasureSpec.EXACTLY) ? sizeHeight : height);
}",0.9736716132120632
104976,"/** 
 * Expires the   {@link Channel}s of a specific <tt>Videobridge</tt> if they have been inactive for more than their advertised <tt>expire</tt> number of seconds.
 * @param videobridge the <tt>Videobridge</tt> which is to have its<tt>Channel</tt>s expired if they have been inactive for more than their advertised <tt>expire</tt> number of seconds
 */
private void expire(Videobridge videobridge){
  logger.info(""String_Node_Str"");
  for (  Conference conference : videobridge.getConferences()) {
    if (conference.shouldExpire()) {
      conference.safeExpire();
    }
 else {
      for (      Content content : conference.getContents()) {
        if (content.shouldExpire()) {
          content.safeExpire();
        }
 else {
          for (          Channel channel : content.getChannels()) {
            if (channel.shouldExpire()) {
              channel.safeExpire();
            }
          }
        }
      }
    }
  }
}","/** 
 * Expires the   {@link Channel}s of a specific <tt>Videobridge</tt> if they have been inactive for more than their advertised <tt>expire</tt> number of seconds.
 * @param videobridge the <tt>Videobridge</tt> which is to have its<tt>Channel</tt>s expired if they have been inactive for more than their advertised <tt>expire</tt> number of seconds
 */
private void expire(Videobridge videobridge){
  logger.info(""String_Node_Str"");
  for (  Conference conference : videobridge.getConferences()) {
    if (conference.shouldExpire()) {
      EXPIRE_EXECUTOR.execute(conference::safeExpire);
    }
 else {
      for (      Content content : conference.getContents()) {
        if (content.shouldExpire()) {
          EXPIRE_EXECUTOR.execute(content::safeExpire);
        }
 else {
          for (          Channel channel : content.getChannels()) {
            if (channel.shouldExpire()) {
              EXPIRE_EXECUTOR.execute(channel::safeExpire);
            }
          }
        }
      }
    }
  }
}",0.9042224510813596
104977,"/** 
 * Returns whether or not the stream represented by 'sourceQualityIndex' is desirable to switch to given the values of currentQualityIndex and targetQualityIndex.  In either case (downscale or upscale), 'sourceQualityIndex' will be desirable if it falls in between currentQualityIndex and targetQualityIndex, e.g.: currentQualityIndex = 1, sourceQualityIndex = 4, targetQualityIndex = 7 -> we're trying to upscale and sourceQualityIndex represents a quality higher than what we currently have (but not the final target) so forwarding it is a step in the right direction currentQualityIndex = 7, sourceQualityIndex = 4, targetQualityIndex = 1 -> we're trying to downscale and sourceQualityIndex represents a quality lower than what we currently have (but not the final target) so forwarding it is a step in the right direction
 * @param currentQualityIndex the index of the stream currently beingforwarded
 * @param sourceQualityIndex the index of the stream to which the incomingframe belongs
 * @param targetQualityIndex the index of the stream we want to forward
 * @return true if the stream represented by sourceQualityIndex representsa step closer (or all the way) to the targetQualityIndex
 */
private boolean shouldSwitchToStream(int currentQualityIndex,int sourceQualityIndex,int targetQualityIndex){
  if ((currentQualityIndex < sourceQualityIndex) && sourceQualityIndex <= targetQualityIndex) {
    return true;
  }
 else   if ((currentQualityIndex > sourceQualityIndex) && (sourceQualityIndex >= targetQualityIndex)) {
    return true;
  }
  return false;
}","/** 
 * Returns whether or not the stream represented by 'sourceQualityIndex' is desirable to switch to given the values of currentQualityIndex and targetQualityIndex.  In either case (downscale or upscale), 'sourceQualityIndex' will be desirable if it falls in between currentQualityIndex and targetQualityIndex, e.g.: currentQualityIndex = 1, sourceQualityIndex = 4, targetQualityIndex = 7 -> we're trying to upscale and sourceQualityIndex represents a quality higher than what we currently have (but not the final target) so forwarding it is a step in the right direction currentQualityIndex = 7, sourceQualityIndex = 4, targetQualityIndex = 1 -> we're trying to downscale and sourceQualityIndex represents a quality lower than what we currently have (but not the final target) so forwarding it is a step in the right direction
 * @param currentQualityIndex the index of the stream currently beingforwarded
 * @param sourceQualityIndex the index of the stream to which the incomingframe belongs
 * @param targetQualityIndex the index of the stream we want to forward
 * @return true if the stream represented by sourceQualityIndex representsa step closer (or all the way) to the targetQualityIndex
 */
private boolean shouldSwitchToStream(int currentQualityIndex,int sourceQualityIndex,int targetQualityIndex,RTPEncodingDesc[] encodings){
  if ((currentQualityIndex < sourceQualityIndex) && sourceQualityIndex <= targetQualityIndex) {
    return true;
  }
 else   if ((currentQualityIndex > sourceQualityIndex) && (sourceQualityIndex >= targetQualityIndex)) {
    return true;
  }
 else   if (encodings[targetQualityIndex].requires(sourceQualityIndex)) {
    return true;
  }
  return false;
}",0.9550321199143468
104978,"/** 
 * Computes a new bitrate allocation for every endpoint in the conference, and updates the state of this instance so that bitrate allocation is eventually met.
 * @param conferenceEndpoints the ordered list of {@link Endpoint}s participating in the multipoint conference with the dominant (speaker)  {@link Endpoint} at the beginning of the list i.e. the dominant speakerhistory. This parameter is optional but it can be used for performaance; if it's omitted it will be fetched from the {@link ConferenceSpeechActivity}.
 */
public void update(List<Endpoint> conferenceEndpoints){
  if (conferenceEndpoints == null) {
    conferenceEndpoints=dest.getConferenceSpeechActivity().getEndpoints();
  }
 else {
    conferenceEndpoints=new ArrayList<>(conferenceEndpoints);
  }
  long bweBps=Long.MAX_VALUE;
  EndpointBitrateAllocation[] allocations=allocate(bweBps,conferenceEndpoints);
  Set<String> oldForwardedEndpointIds=forwardedEndpointIds;
  Set<String> newForwardedEndpointIds=new HashSet<>();
  Set<String> endpointsEnteringLastNIds=new HashSet<>();
  Set<String> conferenceEndpointIds=new HashSet<>();
  if (!ArrayUtils.isNullOrEmpty(allocations)) {
    for (    EndpointBitrateAllocation allocation : allocations) {
      conferenceEndpointIds.add(allocation.endpointID);
      int ssrc=allocation.targetSSRC, targetIdx=allocation.targetIdx;
      SimulcastController ctrl=ssrcToBitrateController.get(ssrc);
      if (ctrl == null && allocation.track != null) {
        ctrl=new SimulcastController(allocation.track);
        RTPEncodingDesc[] rtpEncodings=allocation.track.getRTPEncodings();
synchronized (ssrcToBitrateController) {
          for (          RTPEncodingDesc rtpEncoding : rtpEncodings) {
            ssrcToBitrateController.put((int)rtpEncoding.getPrimarySSRC(),ctrl);
            if (rtpEncoding.getRTXSSRC() != -1) {
              ssrcToBitrateController.put((int)rtpEncoding.getRTXSSRC(),ctrl);
            }
          }
        }
        ctrl=ssrcToBitrateController.get(ssrc);
      }
      if (ctrl != null) {
        ctrl.update(targetIdx);
      }
      if (targetIdx > -1) {
        newForwardedEndpointIds.add(allocation.endpointID);
        if (!oldForwardedEndpointIds.contains(allocation.endpointID)) {
          endpointsEnteringLastNIds.add(allocation.endpointID);
        }
      }
    }
  }
 else {
    for (    SimulcastController simulcastController : ssrcToBitrateController.values()) {
      simulcastController.update(-1);
    }
  }
  if (!newForwardedEndpointIds.equals(oldForwardedEndpointIds)) {
    dest.sendLastNEndpointsChangeEventOnDataChannel(newForwardedEndpointIds,endpointsEnteringLastNIds,conferenceEndpointIds);
  }
  this.forwardedEndpointIds=newForwardedEndpointIds;
}","/** 
 * Computes a new bitrate allocation for every endpoint in the conference, and updates the state of this instance so that bitrate allocation is eventually met.
 * @param conferenceEndpoints the ordered list of {@link Endpoint}s participating in the multipoint conference with the dominant (speaker)  {@link Endpoint} at the beginning of the list i.e. the dominant speakerhistory. This parameter is optional but it can be used for performaance; if it's omitted it will be fetched from the {@link ConferenceSpeechActivity}.
 */
public void update(List<Endpoint> conferenceEndpoints){
  if (conferenceEndpoints == null) {
    conferenceEndpoints=dest.getConferenceSpeechActivity().getEndpoints();
  }
 else {
    conferenceEndpoints=new ArrayList<>(conferenceEndpoints);
  }
  long bweBps=Long.MAX_VALUE;
  EndpointBitrateAllocation[] allocations=allocate(bweBps,conferenceEndpoints);
  Set<String> oldForwardedEndpointIds=forwardedEndpointIds;
  Set<String> newForwardedEndpointIds=new HashSet<>();
  Set<String> endpointsEnteringLastNIds=new HashSet<>();
  Set<String> conferenceEndpointIds=new HashSet<>();
  if (!ArrayUtils.isNullOrEmpty(allocations)) {
    for (    EndpointBitrateAllocation allocation : allocations) {
      conferenceEndpointIds.add(allocation.endpointID);
      int ssrc=allocation.targetSSRC, targetIdx=allocation.targetIdx;
      SimulcastController ctrl;
synchronized (ssrcToBitrateController) {
        ctrl=ssrcToBitrateController.get(ssrc);
        if (ctrl == null && allocation.track != null) {
          ctrl=new SimulcastController(allocation.track);
          RTPEncodingDesc[] rtpEncodings=allocation.track.getRTPEncodings();
          for (          RTPEncodingDesc rtpEncoding : rtpEncodings) {
            ssrcToBitrateController.put((int)rtpEncoding.getPrimarySSRC(),ctrl);
            if (rtpEncoding.getRTXSSRC() != -1) {
              ssrcToBitrateController.put((int)rtpEncoding.getRTXSSRC(),ctrl);
            }
          }
        }
      }
      if (ctrl != null) {
        ctrl.update(targetIdx);
      }
      if (targetIdx > -1) {
        newForwardedEndpointIds.add(allocation.endpointID);
        if (!oldForwardedEndpointIds.contains(allocation.endpointID)) {
          endpointsEnteringLastNIds.add(allocation.endpointID);
        }
      }
    }
  }
 else {
    for (    SimulcastController simulcastController : ssrcToBitrateController.values()) {
      simulcastController.update(-1);
    }
  }
  if (!newForwardedEndpointIds.equals(oldForwardedEndpointIds)) {
    dest.sendLastNEndpointsChangeEventOnDataChannel(newForwardedEndpointIds,endpointsEnteringLastNIds,conferenceEndpointIds);
  }
  this.forwardedEndpointIds=newForwardedEndpointIds;
}",0.9724163295329166
104979,"/** 
 * Computes a new bitrate allocation for every endpoint in the conference, and updates the state of this instance so that bitrate allocation is eventually met.
 * @param conferenceEndpoints the ordered list of {@link Endpoint}s participating in the multipoint conference with the dominant (speaker)  {@link Endpoint} at the beginning of the list i.e. the dominant speakerhistory. This parameter is optional but it can be used for performaance; if it's omitted it will be fetched from the {@link ConferenceSpeechActivity}.
 */
public void update(List<Endpoint> conferenceEndpoints){
  if (conferenceEndpoints == null) {
    conferenceEndpoints=dest.getConferenceSpeechActivity().getEndpoints();
  }
 else {
    conferenceEndpoints=new ArrayList<>(conferenceEndpoints);
  }
  long bweBps=Long.MAX_VALUE;
  EndpointBitrateAllocation[] allocations=allocate(bweBps,conferenceEndpoints);
  List<String> newForwardedEndpoints=new ArrayList<>();
  if (!ArrayUtils.isNullOrEmpty(allocations)) {
    for (    EndpointBitrateAllocation allocation : allocations) {
      int ssrc=allocation.targetSSRC, targetIdx=allocation.targetIdx;
      SimulcastController ctrl=ssrcToBitrateController.get(ssrc);
      if (ctrl == null && allocation.track != null) {
        ctrl=new SimulcastController(allocation.track);
        RTPEncodingDesc[] rtpEncodings=allocation.track.getRTPEncodings();
        for (        RTPEncodingDesc rtpEncoding : rtpEncodings) {
          ssrcToBitrateController.put((int)rtpEncoding.getPrimarySSRC(),ctrl);
          if (rtpEncoding.getRTXSSRC() != -1) {
            ssrcToBitrateController.put((int)rtpEncoding.getRTXSSRC(),ctrl);
          }
        }
      }
      if (ctrl != null) {
        ctrl.update(targetIdx);
      }
      if (targetIdx > -1) {
        newForwardedEndpoints.add(allocation.endpointID);
      }
    }
  }
  this.forwardedEndpoints=newForwardedEndpoints;
}","/** 
 * Computes a new bitrate allocation for every endpoint in the conference, and updates the state of this instance so that bitrate allocation is eventually met.
 * @param conferenceEndpoints the ordered list of {@link Endpoint}s participating in the multipoint conference with the dominant (speaker)  {@link Endpoint} at the beginning of the list i.e. the dominant speakerhistory. This parameter is optional but it can be used for performaance; if it's omitted it will be fetched from the {@link ConferenceSpeechActivity}.
 */
public void update(List<Endpoint> conferenceEndpoints){
  if (conferenceEndpoints == null) {
    conferenceEndpoints=dest.getConferenceSpeechActivity().getEndpoints();
  }
 else {
    conferenceEndpoints=new ArrayList<>(conferenceEndpoints);
  }
  long bweBps=Long.MAX_VALUE;
  EndpointBitrateAllocation[] allocations=allocate(bweBps,conferenceEndpoints);
  Set<String> oldForwardedEndpointIds=forwardedEndpointIds;
  Set<String> newForwardedEndpointIds=new HashSet<>();
  Set<String> endpointsEnteringLastNIds=new HashSet<>();
  Set<String> conferenceEndpointIds=new HashSet<>();
  if (!ArrayUtils.isNullOrEmpty(allocations)) {
    for (    EndpointBitrateAllocation allocation : allocations) {
      conferenceEndpointIds.add(allocation.endpointID);
      int ssrc=allocation.targetSSRC, targetIdx=allocation.targetIdx;
      SimulcastController ctrl=ssrcToBitrateController.get(ssrc);
      if (ctrl == null && allocation.track != null) {
        ctrl=new SimulcastController(allocation.track);
        RTPEncodingDesc[] rtpEncodings=allocation.track.getRTPEncodings();
synchronized (ssrcToBitrateController) {
          for (          RTPEncodingDesc rtpEncoding : rtpEncodings) {
            ssrcToBitrateController.put((int)rtpEncoding.getPrimarySSRC(),ctrl);
            if (rtpEncoding.getRTXSSRC() != -1) {
              ssrcToBitrateController.put((int)rtpEncoding.getRTXSSRC(),ctrl);
            }
          }
        }
        ctrl=ssrcToBitrateController.get(ssrc);
      }
      if (ctrl != null) {
        ctrl.update(targetIdx);
      }
      if (targetIdx > -1) {
        newForwardedEndpointIds.add(allocation.endpointID);
        if (!oldForwardedEndpointIds.contains(allocation.endpointID)) {
          endpointsEnteringLastNIds.add(allocation.endpointID);
        }
      }
    }
  }
  if (!newForwardedEndpointIds.equals(oldForwardedEndpointIds)) {
    dest.sendLastNEndpointsChangeEventOnDataChannel(newForwardedEndpointIds,endpointsEnteringLastNIds,conferenceEndpointIds);
  }
  this.forwardedEndpointIds=newForwardedEndpointIds;
}",0.8252340615247437
104980,"/** 
 * {@inheritDoc}
 */
@Override public boolean setRtpEncodingParameters(List<SourcePacketExtension> sources,List<SourceGroupPacketExtension> sourceGroups){
  boolean changed=super.setRtpEncodingParameters(sources,sourceGroups);
  if (changed) {
    Channel[] peerChannels=getContent().getChannels();
    if (!ArrayUtils.isNullOrEmpty(peerChannels)) {
      for (int i=0; i < peerChannels.length; i++) {
        if (peerChannels[i] == this) {
          continue;
        }
        ((VideoChannel)peerChannels[i]).bitrateController.update(null);
      }
    }
  }
  return changed;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean setRtpEncodingParameters(List<SourcePacketExtension> sources,List<SourceGroupPacketExtension> sourceGroups){
  boolean changed=super.setRtpEncodingParameters(sources,sourceGroups);
  if (changed) {
    Channel[] peerChannels=getContent().getChannels();
    if (!ArrayUtils.isNullOrEmpty(peerChannels)) {
      for (      Channel peerChannel : peerChannels) {
        if (peerChannel == this) {
          continue;
        }
        ((VideoChannel)peerChannel).bitrateController.update(null);
      }
    }
  }
  return changed;
}",0.927038626609442
104981,"/** 
 * Sends a message with <tt>colibriClass</tt> <tt>LastNEndpointsChangeEvent</tt> to the <tt>Endpoint</tt> of this <tt>VideoChannel</tt> in order to notify it that the list/set of <tt>lastN</tt> has changed.
 * @param endpointsEnteringLastN the <tt>Endpoint</tt>s which are enteringthe list of <tt>Endpoint</tt>s defined by <tt>lastN</tt>
 */
public void sendLastNEndpointsChangeEventOnDataChannel(List<String> forwardedEndpoints,List<String> endpointsEnteringLastN,List<String> conferenceEndpoints){
  Endpoint thisEndpoint=getEndpoint();
  if (thisEndpoint == null)   return;
  if (endpointsEnteringLastN == null)   endpointsEnteringLastN=forwardedEndpoints;
  StringBuilder msg=new StringBuilder(""String_Node_Str"");
{
    msg.append(""String_Node_Str"");
    msg.append(getJsonString(forwardedEndpoints));
    msg.append(""String_Node_Str"");
    msg.append(getJsonString(endpointsEnteringLastN));
    msg.append(""String_Node_Str"");
    msg.append(getJsonString(conferenceEndpoints));
  }
  msg.append('}');
  try {
    thisEndpoint.sendMessageOnDataChannel(msg.toString());
  }
 catch (  IOException e) {
    logger.error(""String_Node_Str"",e);
  }
}","/** 
 * Sends a message with <tt>colibriClass</tt> <tt>LastNEndpointsChangeEvent</tt> to the <tt>Endpoint</tt> of this <tt>VideoChannel</tt> in order to notify it that the list/set of <tt>lastN</tt> has changed.
 * @param endpointsEnteringLastN the <tt>Endpoint</tt>s which are enteringthe list of <tt>Endpoint</tt>s defined by <tt>lastN</tt>
 */
public void sendLastNEndpointsChangeEventOnDataChannel(Collection<String> forwardedEndpoints,Collection<String> endpointsEnteringLastN,Collection<String> conferenceEndpoints){
  Endpoint thisEndpoint=getEndpoint();
  if (thisEndpoint == null)   return;
  if (endpointsEnteringLastN == null)   endpointsEnteringLastN=forwardedEndpoints;
  StringBuilder msg=new StringBuilder(""String_Node_Str"");
{
    msg.append(""String_Node_Str"");
    msg.append(getJsonString(forwardedEndpoints));
    msg.append(""String_Node_Str"");
    msg.append(getJsonString(endpointsEnteringLastN));
    msg.append(""String_Node_Str"");
    msg.append(getJsonString(conferenceEndpoints));
  }
  msg.append('}');
  try {
    thisEndpoint.sendMessageOnDataChannel(msg.toString());
  }
 catch (  IOException e) {
    logger.error(""String_Node_Str"",e);
  }
}",0.9320137693631668
104982,"/** 
 * Initializes a new <tt>VideoChannel</tt> instance which is to have a specific ID. The initialization is to be considered requested by a specific <tt>Content</tt>.
 * @param content the <tt>Content</tt> which is initializing the newinstance
 * @param id the ID of the new instance. It is expected to be unique withinthe list of <tt>Channel</tt>s listed in <tt>content</tt> while the new instance is listed there as well.
 * @param channelBundleId the ID of the channel-bundle this<tt>VideoChannel</tt> is to be a part of (or <tt>null</tt> if no it is not to be a part of a channel-bundle).
 * @param transportNamespace the namespace of transport used by thischannel. Can be either  {@link IceUdpTransportPacketExtension#NAMESPACE}or   {@link RawUdpTransportPacketExtension#NAMESPACE}.
 * @param initiator the value to use for the initiator field, or<tt>null</tt> to use the default value.
 * @throws Exception if an error occurs while initializing the new instance
 */
public VideoChannel(Content content,String id,String channelBundleId,String transportNamespace,Boolean initiator) throws Exception {
  super(content,id,channelBundleId,transportNamespace,initiator);
  logger=Logger.getLogger(classLogger,content.getConference().getLogger());
  ConfigurationService cfg=content.getConference().getVideobridge().getConfigurationService();
  this.lipSyncHack=cfg != null && cfg.getBoolean(ENABLE_LIPSYNC_HACK_PNAME,true) ? new LipSyncHack(this) : null;
  initializeTransformerEngine();
  if (cfg != null && cfg.getBoolean(LOG_OVERSENDING_STATS_PNAME,false)) {
    logOversendingStatsRunnable=createLogOversendingStatsRunnable();
    getRecurringExecutor().registerRecurringRunnable(logOversendingStatsRunnable);
  }
 else {
    logOversendingStatsRunnable=null;
  }
}","/** 
 * Initializes a new <tt>VideoChannel</tt> instance which is to have a specific ID. The initialization is to be considered requested by a specific <tt>Content</tt>.
 * @param content the <tt>Content</tt> which is initializing the newinstance
 * @param id the ID of the new instance. It is expected to be unique withinthe list of <tt>Channel</tt>s listed in <tt>content</tt> while the new instance is listed there as well.
 * @param channelBundleId the ID of the channel-bundle this<tt>VideoChannel</tt> is to be a part of (or <tt>null</tt> if no it is not to be a part of a channel-bundle).
 * @param transportNamespace the namespace of transport used by thischannel. Can be either  {@link IceUdpTransportPacketExtension#NAMESPACE}or   {@link RawUdpTransportPacketExtension#NAMESPACE}.
 * @param initiator the value to use for the initiator field, or<tt>null</tt> to use the default value.
 * @throws Exception if an error occurs while initializing the new instance
 */
VideoChannel(Content content,String id,String channelBundleId,String transportNamespace,Boolean initiator) throws Exception {
  super(content,id,channelBundleId,transportNamespace,initiator);
  logger=Logger.getLogger(classLogger,content.getConference().getLogger());
  ConfigurationService cfg=content.getConference().getVideobridge().getConfigurationService();
  this.lipSyncHack=cfg != null && cfg.getBoolean(ENABLE_LIPSYNC_HACK_PNAME,true) ? new LipSyncHack(this) : null;
  initializeTransformerEngine();
  if (cfg != null && cfg.getBoolean(LOG_OVERSENDING_STATS_PNAME,false)) {
    logOversendingStatsRunnable=createLogOversendingStatsRunnable();
    getRecurringExecutor().registerRecurringRunnable(logOversendingStatsRunnable);
  }
 else {
    logOversendingStatsRunnable=null;
  }
}",0.998020921685044
104983,"private String getJsonString(List<String> strings){
  JSONArray array=new JSONArray();
  if (strings != null && !strings.isEmpty()) {
    for (    String s : strings) {
      array.add(s);
    }
  }
  return array.toString();
}","private String getJsonString(Collection<String> strings){
  JSONArray array=new JSONArray();
  if (strings != null && !strings.isEmpty()) {
    for (    String s : strings) {
      array.add(s);
    }
  }
  return array.toString();
}",0.9695652173913044
104984,"/** 
 * {@inheritDoc}</p> Note, that we don't cache any instances that we create here, so this method should be called no more than once!
 */
@Override public StreamConnector getStreamConnector(Channel channel){
  if (!getChannels().contains(channel))   return null;
  MultiplexingDatagramSocket rtpSocket=iceStream.getComponent(Component.RTP).getSocket();
  MultiplexingDatagramSocket rtcpSocket;
  if (numComponents > 1 && !rtcpmux) {
    rtcpSocket=iceStream.getComponent(Component.RTCP).getSocket();
  }
 else {
    rtcpSocket=rtpSocket;
  }
  if (rtpSocket == null || rtcpSocket == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (channel instanceof SctpConnection) {
    try {
      DatagramSocket dtlsSocket=rtpSocket.getSocket(new DTLSDatagramFilter());
      return new DefaultStreamConnector(dtlsSocket,null);
    }
 catch (    SocketException se) {
      logger.warn(""String_Node_Str"" + se);
    }
  }
  if (!(channel instanceof RtpChannel))   return null;
  RtpChannel rtpChannel=(RtpChannel)channel;
  DatagramSocket channelRtpSocket, channelRtcpSocket;
  try {
    channelRtpSocket=rtpSocket.getSocket(rtpChannel.getDatagramFilter(false));
    channelRtcpSocket=rtcpSocket.getSocket(rtpChannel.getDatagramFilter(false));
  }
 catch (  SocketException se) {
    throw new RuntimeException(""String_Node_Str"",se);
  }
  return new DefaultStreamConnector(channelRtpSocket,channelRtcpSocket,rtcpmux);
}","/** 
 * {@inheritDoc}</p> Note, that we don't cache any instances that we create here, so this method should be called no more than once for each channel!
 */
@Override public StreamConnector getStreamConnector(Channel channel){
  if (!getChannels().contains(channel)) {
    return null;
  }
  MultiplexingDatagramSocket rtpSocket=iceStream.getComponent(Component.RTP).getSocket();
  MultiplexingDatagramSocket rtcpSocket;
  if (numComponents > 1 && !rtcpmux) {
    rtcpSocket=iceStream.getComponent(Component.RTCP).getSocket();
  }
 else {
    rtcpSocket=rtpSocket;
  }
  if (rtpSocket == null || rtcpSocket == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (channel instanceof SctpConnection) {
    try {
      DatagramSocket dtlsSocket=rtpSocket.getSocket(new DTLSDatagramFilter());
      return new DefaultStreamConnector(dtlsSocket,null);
    }
 catch (    SocketException se) {
      logger.warn(""String_Node_Str"" + se);
    }
  }
  if (!(channel instanceof RtpChannel))   return null;
  RtpChannel rtpChannel=(RtpChannel)channel;
  DatagramSocket channelRtpSocket, channelRtcpSocket;
  try {
    channelRtpSocket=rtpSocket.getSocket(rtpChannel.getDatagramFilter(false));
    channelRtcpSocket=rtcpSocket.getSocket(rtpChannel.getDatagramFilter(true));
  }
 catch (  SocketException se) {
    throw new RuntimeException(""String_Node_Str"",se);
  }
  return new DefaultStreamConnector(channelRtpSocket,channelRtcpSocket,rtcpmux);
}",0.9792817679558012
104985,"private void monitorEndpointActivity(Endpoint endpoint){
  String endpointId=endpoint.getID();
  long lastActivity=0;
  long mostRecentChannelCreated=0;
  List<RtpChannel> rtpChannels=endpoint.getChannels(null);
  for (  RtpChannel channel : rtpChannels) {
    long channelLastActivity=channel.getLastTransportActivityTime();
    if (channelLastActivity > lastActivity) {
      lastActivity=channelLastActivity;
    }
    long creationTimestamp=channel.getCreationTimestamp();
    if (creationTimestamp > mostRecentChannelCreated) {
      mostRecentChannelCreated=creationTimestamp;
    }
  }
  SctpConnection sctpConnection=endpoint.getSctpConnection();
  if (sctpConnection != null) {
    long lastSctpActivity=sctpConnection.getLastTransportActivityTime();
    if (lastSctpActivity > lastActivity) {
      lastActivity=lastSctpActivity;
    }
    long creationTimestamp=sctpConnection.getCreationTimestamp();
    if (creationTimestamp > mostRecentChannelCreated) {
      mostRecentChannelCreated=creationTimestamp;
    }
  }
  if (lastActivity == 0) {
    if (System.currentTimeMillis() - mostRecentChannelCreated > firstTransferTimeout) {
      logger.debug(endpointId + ""String_Node_Str"" + ""String_Node_Str"");
      lastActivity=mostRecentChannelCreated;
    }
 else {
      logger.debug(endpointId + ""String_Node_Str"");
      return;
    }
  }
  long noActivityForMs=System.currentTimeMillis() - lastActivity;
  boolean inactive=noActivityForMs > maxInactivityLimit;
  if (inactive && !inactiveEndpoints.contains(endpoint)) {
    logger.debug(endpointId + ""String_Node_Str"");
    inactiveEndpoints.add(endpoint);
    sendEndpointConnectionStatus(endpoint,false,null);
  }
 else   if (!inactive && inactiveEndpoints.contains(endpoint)) {
    logger.debug(endpointId + ""String_Node_Str"");
    inactiveEndpoints.remove(endpoint);
    sendEndpointConnectionStatus(endpoint,true,null);
  }
  if (inactive && logger.isDebugEnabled()) {
    logger.debug(String.format(""String_Node_Str"",endpointId,(((double)noActivityForMs) / 1000d)));
  }
}","private void monitorEndpointActivity(Endpoint endpoint){
  String endpointId=endpoint.getID();
  long lastActivity=0;
  long mostRecentChannelCreated=0;
  List<RtpChannel> rtpChannels=endpoint.getChannels(null);
  for (  RtpChannel channel : rtpChannels) {
    long channelLastActivity=channel.getLastTransportActivityTime();
    if (channelLastActivity > lastActivity) {
      lastActivity=channelLastActivity;
    }
    long creationTimestamp=channel.getCreationTimestamp();
    if (creationTimestamp > mostRecentChannelCreated) {
      mostRecentChannelCreated=creationTimestamp;
    }
  }
  SctpConnection sctpConnection=endpoint.getSctpConnection();
  if (sctpConnection != null) {
    long lastSctpActivity=sctpConnection.getLastTransportActivityTime();
    if (lastSctpActivity > lastActivity) {
      lastActivity=lastSctpActivity;
    }
    long creationTimestamp=sctpConnection.getCreationTimestamp();
    if (creationTimestamp > mostRecentChannelCreated) {
      mostRecentChannelCreated=creationTimestamp;
    }
  }
  if (lastActivity == 0) {
    if (System.currentTimeMillis() - mostRecentChannelCreated > firstTransferTimeout) {
      if (logger.isDebugEnabled())       logger.debug(endpointId + ""String_Node_Str"" + ""String_Node_Str"");
      lastActivity=mostRecentChannelCreated;
    }
 else {
      if (logger.isDebugEnabled())       logger.debug(endpointId + ""String_Node_Str"");
      return;
    }
  }
  long noActivityForMs=System.currentTimeMillis() - lastActivity;
  boolean inactive=noActivityForMs > maxInactivityLimit;
  if (inactive && !inactiveEndpoints.contains(endpoint)) {
    logger.debug(endpointId + ""String_Node_Str"");
    inactiveEndpoints.add(endpoint);
    sendEndpointConnectionStatus(endpoint,false,null);
  }
 else   if (!inactive && inactiveEndpoints.contains(endpoint)) {
    logger.debug(endpointId + ""String_Node_Str"");
    inactiveEndpoints.remove(endpoint);
    sendEndpointConnectionStatus(endpoint,true,null);
  }
  if (inactive && logger.isDebugEnabled()) {
    logger.debug(String.format(""String_Node_Str"",endpointId,(((double)noActivityForMs) / 1000d)));
  }
}",0.9826506024096384
104986,"/** 
 * Handles a <tt>ColibriConferenceIQ</tt> stanza which represents a request.
 * @param conferenceIQ the <tt>ColibriConferenceIQ</tt> stanza representsthe request to handle
 * @param options
 * @return an <tt>org.jivesoftware.smack.packet.IQ</tt> stanza whichrepresents the response to the specified request or <tt>null</tt> to reply with <tt>feature-not-implemented</tt>
 * @throws Exception to reply with <tt>internal-server-error</tt> to thespecified request
 */
public IQ handleColibriConferenceIQ(ColibriConferenceIQ conferenceIQ,int options) throws Exception {
  String focus=conferenceIQ.getFrom();
  Conference conference;
  if ((options & OPTION_ALLOW_ANY_FOCUS) > 0) {
    options|=OPTION_ALLOW_NO_FOCUS;
    focus=null;
  }
  if (focus == null && (options & OPTION_ALLOW_NO_FOCUS) == 0) {
    return IQUtils.createError(conferenceIQ,XMPPError.Condition.not_authorized);
  }
 else   if (authorizedSourcePattern != null && (focus == null || !authorizedSourcePattern.matcher(focus).matches())) {
    return IQUtils.createError(conferenceIQ,XMPPError.Condition.not_authorized);
  }
 else {
    String id=conferenceIQ.getID();
    if (id == null) {
      if (isShutdownInProgress()) {
        return ColibriConferenceIQ.createGracefulShutdownErrorResponse(conferenceIQ);
      }
 else {
        conference=createConference(focus,conferenceIQ.getName());
        if (conference == null) {
          return IQUtils.createError(conferenceIQ,XMPPError.Condition.interna_server_error,""String_Node_Str"");
        }
      }
    }
 else {
      conference=getConference(id,focus);
      if (conference == null) {
        return IQUtils.createError(conferenceIQ,XMPPError.Condition.bad_request,""String_Node_Str"" + id);
      }
    }
    conference.setLastKnownFocus(conferenceIQ.getFrom());
  }
  ColibriConferenceIQ responseConferenceIQ=new ColibriConferenceIQ();
  conference.describeShallow(responseConferenceIQ);
  responseConferenceIQ.setGracefulShutdown(isShutdownInProgress());
  ColibriConferenceIQ.Recording recordingIQ=conferenceIQ.getRecording();
  if (recordingIQ != null) {
    String tokenIQ=recordingIQ.getToken();
    if (tokenIQ != null) {
      String tokenConfig=getConfigurationService().getString(Videobridge.MEDIA_RECORDING_TOKEN_PNAME);
      if (tokenIQ.equals(tokenConfig)) {
        ColibriConferenceIQ.Recording.State recState=recordingIQ.getState();
        boolean recording=conference.setRecording(ColibriConferenceIQ.Recording.State.ON.equals(recState) || ColibriConferenceIQ.Recording.State.PENDING.equals(recState));
        ColibriConferenceIQ.Recording responseRecordingIq=new ColibriConferenceIQ.Recording(recState);
        if (recording) {
          responseRecordingIq.setDirectory(conference.getRecordingDirectory());
        }
        responseConferenceIQ.setRecording(responseRecordingIq);
      }
    }
  }
  for (  ColibriConferenceIQ.Content contentIQ : conferenceIQ.getContents()) {
    String contentName=contentIQ.getName();
    Content content=conference.getOrCreateContent(contentName);
    if (content == null) {
      return IQUtils.createError(conferenceIQ,XMPPError.Condition.interna_server_error,""String_Node_Str"" + contentName);
    }
    ColibriConferenceIQ.Content responseContentIQ=new ColibriConferenceIQ.Content(content.getName());
    responseConferenceIQ.addContent(responseContentIQ);
    for (    ColibriConferenceIQ.Channel channelIQ : contentIQ.getChannels()) {
      String channelID=channelIQ.getID();
      int channelExpire=channelIQ.getExpire();
      String channelBundleId=channelIQ.getChannelBundleId();
      RtpChannel channel;
      boolean channelCreated=false;
      String transportNamespace=channelIQ.getTransport() != null ? channelIQ.getTransport().getNamespace() : null;
      if (channelID == null) {
        if (channelExpire == 0) {
          return IQUtils.createError(conferenceIQ,XMPPError.Condition.bad_request,""String_Node_Str"");
        }
        channel=content.createRtpChannel(channelBundleId,transportNamespace,channelIQ.isInitiator(),channelIQ.getRTPLevelRelayType());
        if (channel == null) {
          return IQUtils.createError(conferenceIQ,XMPPError.Condition.interna_server_error,""String_Node_Str"");
        }
        channelCreated=true;
      }
 else {
        channel=(RtpChannel)content.getChannel(channelID);
        if (channel == null) {
          return IQUtils.createError(conferenceIQ,XMPPError.Condition.bad_request,""String_Node_Str"" + channelID);
        }
      }
      if (channelExpire != ColibriConferenceIQ.Channel.EXPIRE_NOT_SPECIFIED) {
        if (channelExpire < 0) {
          return IQUtils.createError(conferenceIQ,XMPPError.Condition.bad_request,""String_Node_Str"" + channelExpire);
        }
        channel.setExpire(channelExpire);
        if ((channelExpire == 0) && channel.isExpired())         continue;
      }
      if (channelCreated && channel instanceof VideoChannel) {
        VideoChannel videoChannel=(VideoChannel)channel;
        Integer receiveSimulcastLayer=channelIQ.getReceivingSimulcastLayer();
        videoChannel.setReceiveSimulcastLayer(receiveSimulcastLayer);
      }
      String endpoint=channelIQ.getEndpoint();
      if (endpoint != null)       channel.setEndpoint(endpoint);
      Integer lastN=channelIQ.getLastN();
      if (lastN != null)       channel.setLastN(lastN);
      Boolean adaptiveLastN=channelIQ.getAdaptiveLastN();
      if (adaptiveLastN != null)       channel.setAdaptiveLastN(adaptiveLastN);
      Boolean adaptiveSimulcast=channelIQ.getAdaptiveSimulcast();
      if (adaptiveSimulcast != null)       channel.setAdaptiveSimulcast(adaptiveSimulcast);
      Integer packetDelay=channelIQ.getPacketDelay();
      if (packetDelay != null) {
        channel.setPacketDelay(packetDelay);
      }
      Boolean initiator=channelIQ.isInitiator();
      if (initiator != null)       channel.setInitiator(initiator);
      channel.setPayloadTypes(channelIQ.getPayloadTypes());
      channel.setRtpHeaderExtensions(channelIQ.getRtpHeaderExtensions());
      channel.setDirection(channelIQ.getDirection());
      channel.setSources(channelIQ.getSources());
      channel.setSourceGroups(channelIQ.getSourceGroups());
      if (channel instanceof VideoChannel) {
        SimulcastMode simulcastMode=channelIQ.getSimulcastMode();
        if (simulcastMode != null) {
          ((VideoChannel)channel).setSimulcastMode(simulcastMode);
        }
      }
      if (channelBundleId != null) {
        TransportManager transportManager=conference.getTransportManager(channelBundleId,true);
        transportManager.addChannel(channel);
      }
      channel.setTransport(channelIQ.getTransport());
      ColibriConferenceIQ.Channel responseChannelIQ=new ColibriConferenceIQ.Channel();
      channel.describe(responseChannelIQ);
      responseContentIQ.addChannel(responseChannelIQ);
      EventAdmin eventAdmin;
      if (channelCreated && (eventAdmin=getEventAdmin()) != null) {
        eventAdmin.sendEvent(EventFactory.channelCreated(channel));
      }
      content.fireChannelChanged(channel);
    }
    for (    ColibriConferenceIQ.SctpConnection sctpConnIq : contentIQ.getSctpConnections()) {
      String id=sctpConnIq.getID();
      String endpointID=sctpConnIq.getEndpoint();
      SctpConnection sctpConn;
      int expire=sctpConnIq.getExpire();
      String channelBundleId=sctpConnIq.getChannelBundleId();
      if (id == null) {
        if (expire == 0) {
          return IQUtils.createError(conferenceIQ,XMPPError.Condition.bad_request,""String_Node_Str"");
        }
        if (endpointID == null) {
          return IQUtils.createError(conferenceIQ,XMPPError.Condition.bad_request,""String_Node_Str"" + ""String_Node_Str"");
        }
        Endpoint endpoint=conference.getOrCreateEndpoint(endpointID);
        if (endpoint == null) {
          return IQUtils.createError(conferenceIQ,XMPPError.Condition.interna_server_error,""String_Node_Str"" + endpointID);
        }
 else {
          int sctpPort=sctpConnIq.getPort();
          sctpConn=content.createSctpConnection(endpoint,sctpPort,channelBundleId,sctpConnIq.isInitiator());
          if (sctpConn == null) {
            return IQUtils.createError(conferenceIQ,XMPPError.Condition.interna_server_error,""String_Node_Str"");
          }
        }
      }
 else {
        sctpConn=content.getSctpConnection(id);
        if (sctpConn == null && expire == 0) {
          continue;
        }
 else         if (sctpConn == null) {
          return IQUtils.createError(conferenceIQ,XMPPError.Condition.bad_request,""String_Node_Str"" + id);
        }
        if (expire != ColibriConferenceIQ.Channel.EXPIRE_NOT_SPECIFIED) {
          if (expire < 0) {
            return IQUtils.createError(conferenceIQ,XMPPError.Condition.bad_request,""String_Node_Str"" + expire);
          }
          if (expire == 0 && sctpConn.isExpired())           continue;
          sctpConn.setExpire(expire);
        }
        if (endpointID != null)         sctpConn.setEndpoint(endpointID);
      }
      Boolean initiator=sctpConnIq.isInitiator();
      if (initiator != null)       sctpConn.setInitiator(initiator);
      sctpConn.setTransport(sctpConnIq.getTransport());
      if (channelBundleId != null) {
        TransportManager transportManager=conference.getTransportManager(channelBundleId,true);
        transportManager.addChannel(sctpConn);
      }
      ColibriConferenceIQ.SctpConnection responseSctpIq=new ColibriConferenceIQ.SctpConnection();
      sctpConn.describe(responseSctpIq);
      responseContentIQ.addSctpConnection(responseSctpIq);
    }
  }
  for (  ColibriConferenceIQ.ChannelBundle channelBundleIq : conferenceIQ.getChannelBundles()) {
    TransportManager transportManager=conference.getTransportManager(channelBundleIq.getId());
    IceUdpTransportPacketExtension transportIq=channelBundleIq.getTransport();
    if (transportManager != null && transportIq != null) {
      transportManager.startConnectivityEstablishment(transportIq);
    }
  }
  for (  ColibriConferenceIQ.Endpoint colibriEndpoint : conferenceIQ.getEndpoints()) {
    conference.updateEndpoint(colibriEndpoint);
  }
  conference.describeChannelBundles(responseConferenceIQ);
  responseConferenceIQ.setType(org.jivesoftware.smack.packet.IQ.Type.RESULT);
  return responseConferenceIQ;
}","/** 
 * Handles a <tt>ColibriConferenceIQ</tt> stanza which represents a request.
 * @param conferenceIQ the <tt>ColibriConferenceIQ</tt> stanza representsthe request to handle
 * @param options
 * @return an <tt>org.jivesoftware.smack.packet.IQ</tt> stanza whichrepresents the response to the specified request or <tt>null</tt> to reply with <tt>feature-not-implemented</tt>
 * @throws Exception to reply with <tt>internal-server-error</tt> to thespecified request
 */
public IQ handleColibriConferenceIQ(ColibriConferenceIQ conferenceIQ,int options) throws Exception {
  String focus=conferenceIQ.getFrom();
  Conference conference;
  if ((options & OPTION_ALLOW_ANY_FOCUS) > 0) {
    options|=OPTION_ALLOW_NO_FOCUS;
    focus=null;
  }
  if (focus == null && (options & OPTION_ALLOW_NO_FOCUS) == 0) {
    return IQUtils.createError(conferenceIQ,XMPPError.Condition.not_authorized);
  }
 else   if (authorizedSourcePattern != null && (focus == null || !authorizedSourcePattern.matcher(focus).matches())) {
    return IQUtils.createError(conferenceIQ,XMPPError.Condition.not_authorized);
  }
 else {
    String id=conferenceIQ.getID();
    if (id == null) {
      if (isShutdownInProgress()) {
        return ColibriConferenceIQ.createGracefulShutdownErrorResponse(conferenceIQ);
      }
 else {
        conference=createConference(focus,conferenceIQ.getName());
        if (conference == null) {
          return IQUtils.createError(conferenceIQ,XMPPError.Condition.interna_server_error,""String_Node_Str"");
        }
      }
    }
 else {
      conference=getConference(id,focus);
      if (conference == null) {
        return IQUtils.createError(conferenceIQ,XMPPError.Condition.bad_request,""String_Node_Str"" + id);
      }
    }
    conference.setLastKnownFocus(conferenceIQ.getFrom());
  }
  ColibriConferenceIQ responseConferenceIQ=new ColibriConferenceIQ();
  conference.describeShallow(responseConferenceIQ);
  responseConferenceIQ.setGracefulShutdown(isShutdownInProgress());
  ColibriConferenceIQ.Recording recordingIQ=conferenceIQ.getRecording();
  if (recordingIQ != null) {
    String tokenIQ=recordingIQ.getToken();
    if (tokenIQ != null) {
      String tokenConfig=getConfigurationService().getString(Videobridge.MEDIA_RECORDING_TOKEN_PNAME);
      if (tokenIQ.equals(tokenConfig)) {
        ColibriConferenceIQ.Recording.State recState=recordingIQ.getState();
        boolean recording=conference.setRecording(ColibriConferenceIQ.Recording.State.ON.equals(recState) || ColibriConferenceIQ.Recording.State.PENDING.equals(recState));
        ColibriConferenceIQ.Recording responseRecordingIq=new ColibriConferenceIQ.Recording(recState);
        if (recording) {
          responseRecordingIq.setDirectory(conference.getRecordingDirectory());
        }
        responseConferenceIQ.setRecording(responseRecordingIq);
      }
    }
  }
  for (  ColibriConferenceIQ.Content contentIQ : conferenceIQ.getContents()) {
    String contentName=contentIQ.getName();
    Content content=conference.getOrCreateContent(contentName);
    if (content == null) {
      return IQUtils.createError(conferenceIQ,XMPPError.Condition.interna_server_error,""String_Node_Str"" + contentName);
    }
    ColibriConferenceIQ.Content responseContentIQ=new ColibriConferenceIQ.Content(content.getName());
    responseConferenceIQ.addContent(responseContentIQ);
    for (    ColibriConferenceIQ.Channel channelIQ : contentIQ.getChannels()) {
      String channelID=channelIQ.getID();
      int channelExpire=channelIQ.getExpire();
      String channelBundleId=channelIQ.getChannelBundleId();
      RtpChannel channel;
      boolean channelCreated=false;
      String transportNamespace=channelIQ.getTransport() != null ? channelIQ.getTransport().getNamespace() : null;
      if (channelID == null) {
        if (channelExpire == 0) {
          return IQUtils.createError(conferenceIQ,XMPPError.Condition.bad_request,""String_Node_Str"");
        }
        channel=content.createRtpChannel(channelBundleId,transportNamespace,channelIQ.isInitiator(),channelIQ.getRTPLevelRelayType());
        if (channel == null) {
          return IQUtils.createError(conferenceIQ,XMPPError.Condition.interna_server_error,""String_Node_Str"");
        }
        channelCreated=true;
      }
 else {
        channel=(RtpChannel)content.getChannel(channelID);
        if (channel == null) {
          if (channelExpire == 0) {
            continue;
          }
 else {
            return IQUtils.createError(conferenceIQ,XMPPError.Condition.bad_request,""String_Node_Str"" + channelID);
          }
        }
      }
      if (channelExpire != ColibriConferenceIQ.Channel.EXPIRE_NOT_SPECIFIED) {
        if (channelExpire < 0) {
          return IQUtils.createError(conferenceIQ,XMPPError.Condition.bad_request,""String_Node_Str"" + channelExpire);
        }
        channel.setExpire(channelExpire);
        if ((channelExpire == 0) && channel.isExpired())         continue;
      }
      if (channelCreated && channel instanceof VideoChannel) {
        VideoChannel videoChannel=(VideoChannel)channel;
        Integer receiveSimulcastLayer=channelIQ.getReceivingSimulcastLayer();
        videoChannel.setReceiveSimulcastLayer(receiveSimulcastLayer);
      }
      String endpoint=channelIQ.getEndpoint();
      if (endpoint != null)       channel.setEndpoint(endpoint);
      Integer lastN=channelIQ.getLastN();
      if (lastN != null)       channel.setLastN(lastN);
      Boolean adaptiveLastN=channelIQ.getAdaptiveLastN();
      if (adaptiveLastN != null)       channel.setAdaptiveLastN(adaptiveLastN);
      Boolean adaptiveSimulcast=channelIQ.getAdaptiveSimulcast();
      if (adaptiveSimulcast != null)       channel.setAdaptiveSimulcast(adaptiveSimulcast);
      Integer packetDelay=channelIQ.getPacketDelay();
      if (packetDelay != null) {
        channel.setPacketDelay(packetDelay);
      }
      Boolean initiator=channelIQ.isInitiator();
      if (initiator != null)       channel.setInitiator(initiator);
      channel.setPayloadTypes(channelIQ.getPayloadTypes());
      channel.setRtpHeaderExtensions(channelIQ.getRtpHeaderExtensions());
      channel.setDirection(channelIQ.getDirection());
      channel.setSources(channelIQ.getSources());
      channel.setSourceGroups(channelIQ.getSourceGroups());
      if (channel instanceof VideoChannel) {
        SimulcastMode simulcastMode=channelIQ.getSimulcastMode();
        if (simulcastMode != null) {
          ((VideoChannel)channel).setSimulcastMode(simulcastMode);
        }
      }
      if (channelBundleId != null) {
        TransportManager transportManager=conference.getTransportManager(channelBundleId,true);
        transportManager.addChannel(channel);
      }
      channel.setTransport(channelIQ.getTransport());
      ColibriConferenceIQ.Channel responseChannelIQ=new ColibriConferenceIQ.Channel();
      channel.describe(responseChannelIQ);
      responseContentIQ.addChannel(responseChannelIQ);
      EventAdmin eventAdmin;
      if (channelCreated && (eventAdmin=getEventAdmin()) != null) {
        eventAdmin.sendEvent(EventFactory.channelCreated(channel));
      }
      content.fireChannelChanged(channel);
    }
    for (    ColibriConferenceIQ.SctpConnection sctpConnIq : contentIQ.getSctpConnections()) {
      String id=sctpConnIq.getID();
      String endpointID=sctpConnIq.getEndpoint();
      SctpConnection sctpConn;
      int expire=sctpConnIq.getExpire();
      String channelBundleId=sctpConnIq.getChannelBundleId();
      if (id == null) {
        if (expire == 0) {
          return IQUtils.createError(conferenceIQ,XMPPError.Condition.bad_request,""String_Node_Str"");
        }
        if (endpointID == null) {
          return IQUtils.createError(conferenceIQ,XMPPError.Condition.bad_request,""String_Node_Str"" + ""String_Node_Str"");
        }
        Endpoint endpoint=conference.getOrCreateEndpoint(endpointID);
        if (endpoint == null) {
          return IQUtils.createError(conferenceIQ,XMPPError.Condition.interna_server_error,""String_Node_Str"" + endpointID);
        }
 else {
          int sctpPort=sctpConnIq.getPort();
          sctpConn=content.createSctpConnection(endpoint,sctpPort,channelBundleId,sctpConnIq.isInitiator());
          if (sctpConn == null) {
            return IQUtils.createError(conferenceIQ,XMPPError.Condition.interna_server_error,""String_Node_Str"");
          }
        }
      }
 else {
        sctpConn=content.getSctpConnection(id);
        if (sctpConn == null && expire == 0) {
          continue;
        }
 else         if (sctpConn == null) {
          return IQUtils.createError(conferenceIQ,XMPPError.Condition.bad_request,""String_Node_Str"" + id);
        }
        if (expire != ColibriConferenceIQ.Channel.EXPIRE_NOT_SPECIFIED) {
          if (expire < 0) {
            return IQUtils.createError(conferenceIQ,XMPPError.Condition.bad_request,""String_Node_Str"" + expire);
          }
          if (expire == 0 && sctpConn.isExpired())           continue;
          sctpConn.setExpire(expire);
        }
        if (endpointID != null)         sctpConn.setEndpoint(endpointID);
      }
      Boolean initiator=sctpConnIq.isInitiator();
      if (initiator != null)       sctpConn.setInitiator(initiator);
      sctpConn.setTransport(sctpConnIq.getTransport());
      if (channelBundleId != null) {
        TransportManager transportManager=conference.getTransportManager(channelBundleId,true);
        transportManager.addChannel(sctpConn);
      }
      ColibriConferenceIQ.SctpConnection responseSctpIq=new ColibriConferenceIQ.SctpConnection();
      sctpConn.describe(responseSctpIq);
      responseContentIQ.addSctpConnection(responseSctpIq);
    }
  }
  for (  ColibriConferenceIQ.ChannelBundle channelBundleIq : conferenceIQ.getChannelBundles()) {
    TransportManager transportManager=conference.getTransportManager(channelBundleIq.getId());
    IceUdpTransportPacketExtension transportIq=channelBundleIq.getTransport();
    if (transportManager != null && transportIq != null) {
      transportManager.startConnectivityEstablishment(transportIq);
    }
  }
  for (  ColibriConferenceIQ.Endpoint colibriEndpoint : conferenceIQ.getEndpoints()) {
    conference.updateEndpoint(colibriEndpoint);
  }
  conference.describeChannelBundles(responseConferenceIQ);
  responseConferenceIQ.setType(org.jivesoftware.smack.packet.IQ.Type.RESULT);
  return responseConferenceIQ;
}",0.9955508269658574
104987,"private org.jivesoftware.smack.packet.IQ handleIQRequest(org.jivesoftware.smack.packet.IQ request) throws Exception {
  if (request instanceof org.jivesoftware.smackx.packet.Version) {
    return handleVersionIQ((org.jivesoftware.smackx.packet.Version)request);
  }
  Videobridge videobridge=getVideobridge();
  if (videobridge == null) {
    return null;
  }
  org.jivesoftware.smack.packet.IQ response;
  if (request instanceof ColibriConferenceIQ) {
    response=videobridge.handleColibriConferenceIQ((ColibriConferenceIQ)request);
  }
 else   if (request instanceof HealthCheckIQ) {
    response=videobridge.handleHealthCheckIQ((HealthCheckIQ)request);
  }
 else   if (request instanceof ShutdownIQ) {
    response=videobridge.handleShutdownIQ((ShutdownIQ)request);
  }
 else {
    response=null;
  }
  return response;
}","private org.jivesoftware.smack.packet.IQ handleIQRequest(org.jivesoftware.smack.packet.IQ request) throws Exception {
  if (request instanceof org.jivesoftware.smackx.packet.Version) {
    return handleVersionIQ((org.jivesoftware.smackx.packet.Version)request);
  }
  Videobridge videobridge=getVideobridge();
  if (videobridge == null) {
    return IQUtils.createError(request,XMPPError.Condition.interna_server_error,""String_Node_Str"");
  }
  org.jivesoftware.smack.packet.IQ response;
  if (request instanceof ColibriConferenceIQ) {
    response=videobridge.handleColibriConferenceIQ((ColibriConferenceIQ)request);
  }
 else   if (request instanceof HealthCheckIQ) {
    response=videobridge.handleHealthCheckIQ((HealthCheckIQ)request);
  }
 else   if (request instanceof ShutdownIQ) {
    response=videobridge.handleShutdownIQ((ShutdownIQ)request);
  }
 else {
    response=null;
  }
  return response;
}",0.9474899019042125
104988,"/** 
 * Expires this <tt>Channel</tt>. Releases the resources acquired by this instance throughout its life time and prepares it to be garbage collected.
 */
public void expire(){
synchronized (this) {
    if (expired)     return;
 else     expired=true;
  }
  Content content=getContent();
  Conference conference=content.getConference();
  EventAdmin eventAdmin=conference.getEventAdmin();
  if (eventAdmin != null)   eventAdmin.sendEvent(EventFactory.channelExpired(this));
  try {
    content.expireChannel(this);
  }
  finally {
    try {
      closeStream();
    }
 catch (    Throwable t) {
      logger.warn(""String_Node_Str"" + getID() + ""String_Node_Str""+ content.getName()+ ""String_Node_Str""+ conference.getID()+ ""String_Node_Str"",t);
      if (t instanceof ThreadDeath)       throw (ThreadDeath)t;
    }
    try {
synchronized (transportManagerSyncRoot) {
        if (transportManager != null)         transportManager.close(this);
      }
    }
 catch (    Throwable t) {
      logger.warn(""String_Node_Str"" + ""String_Node_Str"" + getID() + ""String_Node_Str""+ content.getName()+ ""String_Node_Str""+ conference.getID()+ ""String_Node_Str"",t);
      if (t instanceof ThreadDeath)       throw (ThreadDeath)t;
    }
    try {
      onEndpointChanged(getEndpoint(),null);
    }
 catch (    Throwable t) {
      if (t instanceof ThreadDeath)       throw (ThreadDeath)t;
    }
    Videobridge videobridge=conference.getVideobridge();
    if (logger.isInfoEnabled()) {
      logger.info(""String_Node_Str"" + getID() + ""String_Node_Str""+ content.getName()+ ""String_Node_Str""+ conference.getID()+ ""String_Node_Str""+ videobridge.getConferenceCountString());
    }
  }
}","/** 
 * Expires this <tt>Channel</tt>. Releases the resources acquired by this instance throughout its life time and prepares it to be garbage collected.
 * @return {@code true} if the channel was expired as a result of thiscall, and  {@code false} if the channel was already expired.
 */
public boolean expire(){
synchronized (this) {
    if (expired)     return false;
 else     expired=true;
  }
  Content content=getContent();
  Conference conference=content.getConference();
  EventAdmin eventAdmin=conference.getEventAdmin();
  if (eventAdmin != null)   eventAdmin.sendEvent(EventFactory.channelExpired(this));
  try {
    content.expireChannel(this);
  }
  finally {
    try {
      closeStream();
    }
 catch (    Throwable t) {
      logger.warn(""String_Node_Str"" + getID() + ""String_Node_Str""+ content.getName()+ ""String_Node_Str""+ conference.getID()+ ""String_Node_Str"",t);
      if (t instanceof ThreadDeath)       throw (ThreadDeath)t;
    }
    try {
synchronized (transportManagerSyncRoot) {
        if (transportManager != null)         transportManager.close(this);
      }
    }
 catch (    Throwable t) {
      logger.warn(""String_Node_Str"" + ""String_Node_Str"" + getID() + ""String_Node_Str""+ content.getName()+ ""String_Node_Str""+ conference.getID()+ ""String_Node_Str"",t);
      if (t instanceof ThreadDeath)       throw (ThreadDeath)t;
    }
    try {
      onEndpointChanged(getEndpoint(),null);
    }
 catch (    Throwable t) {
      if (t instanceof ThreadDeath)       throw (ThreadDeath)t;
    }
    Videobridge videobridge=conference.getVideobridge();
    if (logger.isInfoEnabled()) {
      logger.info(""String_Node_Str"" + getID() + ""String_Node_Str""+ content.getName()+ ""String_Node_Str""+ conference.getID()+ ""String_Node_Str""+ videobridge.getConferenceCountString());
    }
  }
  return true;
}",0.9532549469457988
104989,"/** 
 * Closes   {@link #transformEngine}. Normally this would be done by  {@link #stream} when it is being closed, but we have observed cases (e.g.when running health checks) where it doesn't happen, and since {@link #transformEngine} is part of this {@code RtpChannel}, the latter assumes the responsibility of releasing its resources.
 */
@Override public void expire(){
  if (getContent().getConference().includeInStatistics()) {
    Conference.Statistics conferenceStatistics=getContent().getConference().getStatistics();
    conferenceStatistics.totalChannels.incrementAndGet();
    long lastPayloadActivityTime=getLastPayloadActivityTime();
    long lastTransportActivityTime=getLastTransportActivityTime();
    if (lastTransportActivityTime == 0) {
      conferenceStatistics.totalNoTransportChannels.incrementAndGet();
    }
    if (lastPayloadActivityTime == 0) {
      conferenceStatistics.totalNoPayloadChannels.incrementAndGet();
    }
  }
  TransformEngine transformEngine=this.transformEngine;
  if (transformEngine != null) {
    PacketTransformer t=transformEngine.getRTPTransformer();
    if (t != null) {
      t.close();
    }
    t=transformEngine.getRTCPTransformer();
    if (t != null) {
      t.close();
    }
  }
  super.expire();
}","/** 
 * Closes   {@link #transformEngine}. Normally this would be done by  {@link #stream} when it is being closed, but we have observed cases (e.g.when running health checks) where it doesn't happen, and since {@link #transformEngine} is part of this {@code RtpChannel}, the latter assumes the responsibility of releasing its resources.
 */
@Override public boolean expire(){
  if (!super.expire()) {
    return false;
  }
  if (getContent().getConference().includeInStatistics()) {
    Conference.Statistics conferenceStatistics=getContent().getConference().getStatistics();
    conferenceStatistics.totalChannels.incrementAndGet();
    long lastPayloadActivityTime=getLastPayloadActivityTime();
    long lastTransportActivityTime=getLastTransportActivityTime();
    if (lastTransportActivityTime == 0) {
      conferenceStatistics.totalNoTransportChannels.incrementAndGet();
    }
    if (lastPayloadActivityTime == 0) {
      conferenceStatistics.totalNoPayloadChannels.incrementAndGet();
    }
  }
  TransformEngine transformEngine=this.transformEngine;
  if (transformEngine != null) {
    PacketTransformer t=transformEngine.getRTPTransformer();
    if (t != null) {
      t.close();
    }
    t=transformEngine.getRTCPTransformer();
    if (t != null) {
      t.close();
    }
  }
  return true;
}",0.9683964104564964
104990,"/** 
 * {@inheritDoc}
 */
@Override public void expire(){
  try {
    eventDispatcher.shutdown();
  }
  finally {
    super.expire();
  }
}","/** 
 * {@inheritDoc}
 */
@Override public boolean expire(){
  if (!super.expire()) {
    return false;
  }
  eventDispatcher.shutdown();
  return true;
}",0.6825938566552902
104991,"/** 
 * {@inheritDoc}Closes the   {@link LastNController} before expiring the channel.
 */
@Override public void expire(){
  if (lastNController != null) {
    lastNController.close();
  }
  super.expire();
}","/** 
 * {@inheritDoc}Closes the   {@link LastNController} before expiring the channel.
 */
@Override public boolean expire(){
  if (!super.expire()) {
    return false;
  }
  if (lastNController != null) {
    lastNController.close();
  }
  return true;
}",0.8207343412526998
104992,"/** 
 * {@inheritDoc}
 */
@Override public void run(){
synchronized (injectState) {
    if (!injectState.active || injectState.numOfKeyframesSent++ >= MAX_KEY_FRAMES) {
      scheduledFuture.cancel(true);
      return;
    }
    MediaStream mediaStream=injectState.target.get();
    if (mediaStream == null || !mediaStream.isStarted()) {
      logger.debug(""String_Node_Str"" + ""String_Node_Str"");
      return;
    }
    try {
      byte[] buf=KEY_FRAME_BUFFER.clone();
      RawPacket keyframe=new RawPacket(buf,0,buf.length);
      long timestamp=injectState.numOfKeyframesSent * 3000;
      keyframe.setSSRC(injectState.ssrc.intValue());
      keyframe.setSequenceNumber(injectState.numOfKeyframesSent);
      keyframe.setTimestamp(timestamp);
      logger.debug(""String_Node_Str"" + injectState.ssrc + ""String_Node_Str""+ injectState.numOfKeyframesSent+ ""String_Node_Str""+ timestamp);
      mediaStream.injectPacket(keyframe,true,null);
    }
 catch (    TransmissionFailedException e) {
      injectState.numOfKeyframesSent--;
      logger.error(e);
    }
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void run(){
synchronized (injectState) {
    if (!injectState.active || injectState.numOfKeyframesSent >= MAX_KEY_FRAMES) {
      scheduledFuture.cancel(true);
      return;
    }
    MediaStream mediaStream=injectState.target.get();
    if (mediaStream == null || !mediaStream.isStarted()) {
      logger.debug(""String_Node_Str"" + ""String_Node_Str"");
      return;
    }
    try {
      injectState.numOfKeyframesSent++;
      byte[] buf=KEY_FRAME_BUFFER.clone();
      RawPacket keyframe=new RawPacket(buf,0,buf.length);
      long timestamp=injectState.numOfKeyframesSent * 3000;
      keyframe.setSSRC(injectState.ssrc.intValue());
      keyframe.setSequenceNumber(injectState.numOfKeyframesSent);
      keyframe.setTimestamp(timestamp);
      logger.debug(""String_Node_Str"" + injectState.ssrc + ""String_Node_Str""+ injectState.numOfKeyframesSent+ ""String_Node_Str""+ timestamp);
      mediaStream.injectPacket(keyframe,true,null);
    }
 catch (    TransmissionFailedException e) {
      injectState.numOfKeyframesSent--;
      logger.error(e);
    }
  }
}",0.9806094182825484
104993,"/** 
 * {@inheritDoc}
 */
@Override public void receive(SimulcastStream simStream){
  if (simStream == null) {
    this.state=new State(null,null);
    return;
  }
  State oldState=this.state;
  SimulcastStream current=oldState.getCurrent();
  SimulcastStream next=oldState.getNext();
  if (current == simStream || next == simStream) {
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"" + simStream.getOrder() + ""String_Node_Str"");
    }
    return;
  }
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"" + simStream.getOrder() + ""String_Node_Str""+ getSimulcastSender().getSimulcastReceiver().getSimulcastEngine().getVideoChannel().getEndpoint().getID()+ ""String_Node_Str"");
  }
  simStream.askForKeyframe();
  if (current == null) {
    this.state=new State(new WeakReference<>(simStream),oldState.weakNext);
  }
 else {
    this.state=new State(oldState.weakCurrent,new WeakReference<>(simStream));
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void receive(SimulcastStream simStream){
  if (simStream == null) {
    this.state=new State(null,null);
    return;
  }
  State oldState=this.state;
  SimulcastStream current=oldState.getCurrent();
  SimulcastStream next=oldState.getNext();
  if (current == simStream) {
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"" + simStream.getOrder() + ""String_Node_Str""+ getSimulcastSender().getSimulcastReceiver().getSimulcastEngine().getVideoChannel().getEndpoint().getID()+ ""String_Node_Str"");
    }
    if (next != null) {
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"" + simStream.getOrder() + ""String_Node_Str""+ getSimulcastSender().getSimulcastReceiver().getSimulcastEngine().getVideoChannel().getEndpoint().getID()+ ""String_Node_Str"");
      }
      this.state=new State(new WeakReference<>(simStream),null);
    }
    return;
  }
  if (next == simStream) {
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"" + simStream.getOrder() + ""String_Node_Str""+ getSimulcastSender().getSimulcastReceiver().getSimulcastEngine().getVideoChannel().getEndpoint().getID()+ ""String_Node_Str"");
    }
    return;
  }
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"" + simStream.getOrder() + ""String_Node_Str""+ getSimulcastSender().getSimulcastReceiver().getSimulcastEngine().getVideoChannel().getEndpoint().getID()+ ""String_Node_Str"");
  }
  simStream.askForKeyframe();
  if (current == null) {
    this.state=new State(new WeakReference<>(simStream),oldState.weakNext);
  }
 else {
    this.state=new State(oldState.weakCurrent,new WeakReference<>(simStream));
  }
}",0.6117021276595744
104994,"/** 
 * Creates a   {@code RawPacket} which represents the original packetencapsulated in  {@code pkt} using the RTX format.
 * @param pkt the packet from which to extract a media packet.
 * @return the extracted media packet.
 */
private RawPacket createMediaPacket(RawPacket pkt){
  RawPacket mediaPacket=null;
  long rtxSsrc=pkt.getSSRCAsLong();
  RtpChannel sourceChannel=channel.getContent().findChannelByFidSsrc(rtxSsrc);
  if (sourceChannel != null) {
    long mediaSsrc=sourceChannel.getFidPairedSsrc(rtxSsrc);
    if (mediaSsrc != -1) {
      byte apt=sourceChannel.getRtxAssociatedPayloadType();
      if (apt != -1) {
        mediaPacket=new RawPacket(pkt.getBuffer().clone(),pkt.getOffset(),pkt.getLength());
        byte[] buf=mediaPacket.getBuffer();
        int off=mediaPacket.getOffset();
        System.arraycopy(buf,off,buf,off + 2,mediaPacket.getHeaderLength());
        mediaPacket.setOffset(off + 2);
        mediaPacket.setLength(pkt.getLength() - 2);
        mediaPacket.setSSRC((int)mediaSsrc);
        mediaPacket.setSequenceNumber(pkt.getOriginalSequenceNumber());
        mediaPacket.setPayloadType(apt);
      }
    }
  }
  return mediaPacket;
}","/** 
 * Creates a   {@code RawPacket} which represents the original packetencapsulated in  {@code pkt} using the RTX format.
 * @param pkt the packet from which to extract a media packet.
 * @return the extracted media packet.
 */
private RawPacket createMediaPacket(RawPacket pkt){
  RawPacket mediaPacket=null;
  long rtxSsrc=pkt.getSSRCAsLong();
  RtpChannel sourceChannel=channel.getContent().findChannelByFidSsrc(rtxSsrc);
  if (sourceChannel != null) {
    long mediaSsrc=sourceChannel.getFidPairedSsrc(rtxSsrc);
    if (mediaSsrc != -1) {
      byte apt=sourceChannel.getRtxAssociatedPayloadType();
      if (apt != -1) {
        mediaPacket=new RawPacket(pkt.getBuffer().clone(),pkt.getOffset(),pkt.getLength());
        byte[] buf=mediaPacket.getBuffer();
        int off=mediaPacket.getOffset();
        System.arraycopy(buf,off,buf,off + 2,mediaPacket.getHeaderLength());
        mediaPacket.setOffset(off + 2);
        mediaPacket.setLength(pkt.getLength() - 2);
        mediaPacket.setSSRC((int)mediaSsrc);
        mediaPacket.setSequenceNumber(pkt.getOriginalSequenceNumber());
        mediaPacket.setPayloadType(apt);
      }
 else {
        logger.warn(""String_Node_Str"" + ""String_Node_Str"" + rtxSsrc + ""String_Node_Str""+ mediaSsrc);
      }
    }
  }
  return mediaPacket;
}",0.9363083164300204
104995,"/** 
 * Encapsulates   {@code pkt} in the RTX format, using {@code rtxSsrc} as itsSSRC, and transmits it to  {@link #channel} by injecting it in the{@code MediaStream}.
 * @param pkt the packet to transmit.
 * @param rtxSsrc the SSRC for the RTX stream.
 * @return {@code true} if the packet was successfully retransmitted,{@code false} otherwise.
 */
private boolean encapsulateInRtxAndTransmit(RawPacket pkt,long rtxSsrc){
  byte[] buf=pkt.getBuffer();
  int len=pkt.getLength();
  int off=pkt.getOffset();
  byte[] newBuf=buf;
  if (buf.length < len + 2) {
    newBuf=new byte[len + 2];
  }
  int osn=pkt.getSequenceNumber();
  int headerLength=pkt.getHeaderLength();
  int payloadLength=len - headerLength;
  System.arraycopy(buf,off,newBuf,0,headerLength);
  newBuf[headerLength]=(byte)((osn >> 8) & 0xff);
  newBuf[headerLength + 1]=(byte)(osn & 0xff);
  System.arraycopy(buf,off + headerLength,newBuf,headerLength + 2,payloadLength);
  MediaStream mediaStream=channel.getStream();
  if (mediaStream != null) {
    pkt.setSSRC((int)rtxSsrc);
    pkt.setSequenceNumber(getNextRtxSequenceNumber(rtxSsrc));
    try {
      mediaStream.injectPacket(pkt,true,null);
    }
 catch (    TransmissionFailedException tfe) {
      logger.warn(""String_Node_Str"");
      return false;
    }
  }
  return true;
}","/** 
 * Encapsulates   {@code pkt} in the RTX format, using {@code rtxSsrc} as itsSSRC, and transmits it to  {@link #channel} by injecting it in the{@code MediaStream}.
 * @param pkt the packet to transmit.
 * @param rtxSsrc the SSRC for the RTX stream.
 * @param after the {@code TransformEngine} in the chain of{@code TransformEngine}s of the associated   {@code MediaStream} afterwhich the injection of  {@code pkt} is to begin
 * @return {@code true} if the packet was successfully retransmitted,{@code false} otherwise.
 */
private boolean encapsulateInRtxAndTransmit(RawPacket pkt,long rtxSsrc,TransformEngine after){
  byte[] buf=pkt.getBuffer();
  int len=pkt.getLength();
  int off=pkt.getOffset();
  byte[] newBuf=new byte[len + 2];
  RawPacket rtxPkt=new RawPacket(newBuf,0,len + 2);
  int osn=pkt.getSequenceNumber();
  int headerLength=pkt.getHeaderLength();
  int payloadLength=pkt.getPayloadLength();
  System.arraycopy(buf,off,newBuf,0,headerLength);
  newBuf[headerLength]=(byte)((osn >> 8) & 0xff);
  newBuf[headerLength + 1]=(byte)(osn & 0xff);
  System.arraycopy(buf,off + headerLength,newBuf,headerLength + 2,payloadLength);
  MediaStream mediaStream=channel.getStream();
  if (mediaStream != null) {
    rtxPkt.setSSRC((int)rtxSsrc);
    rtxPkt.setSequenceNumber(getNextRtxSequenceNumber(rtxSsrc));
    try {
      mediaStream.injectPacket(rtxPkt,true,after);
    }
 catch (    TransmissionFailedException tfe) {
      logger.warn(""String_Node_Str"");
      return false;
    }
  }
  return true;
}",0.7814381863266029
104996,"/** 
 * Retransmits a packet to   {@link #channel}. If the destination supports the RTX format, the packet will be encapsulated in RTX, otherwise, the packet will be retransmitted as-is.
 * @param pkt the packet to retransmit.
 * @param after the {@code TransformEngine} in the chain of{@code TransformEngine}s of the associated   {@code MediaStream} afterwhich the injection of  {@code pkt} is to begin
 * @return {@code true} if the packet was successfully retransmitted,{@code false} otherwise.
 */
public boolean retransmit(RawPacket pkt,TransformEngine after){
  boolean destinationSupportsRtx=channel.getRtxPayloadType() != -1;
  boolean retransmitPlain;
  if (destinationSupportsRtx) {
    long rtxSsrc=getPairedSsrc(pkt.getSSRCAsLong());
    if (rtxSsrc == -1) {
      logger.warn(""String_Node_Str"" + ""String_Node_Str"" + pkt.getSSRCAsLong());
      retransmitPlain=true;
    }
 else {
      retransmitPlain=!encapsulateInRtxAndTransmit(pkt,rtxSsrc);
    }
  }
 else {
    retransmitPlain=true;
  }
  if (retransmitPlain) {
    MediaStream mediaStream=channel.getStream();
    if (mediaStream != null) {
      try {
        mediaStream.injectPacket(pkt,true,after);
      }
 catch (      TransmissionFailedException tfe) {
        logger.warn(""String_Node_Str"");
        return false;
      }
    }
  }
  return true;
}","/** 
 * Retransmits a packet to   {@link #channel}. If the destination supports the RTX format, the packet will be encapsulated in RTX, otherwise, the packet will be retransmitted as-is.
 * @param pkt the packet to retransmit.
 * @param after the {@code TransformEngine} in the chain of{@code TransformEngine}s of the associated   {@code MediaStream} afterwhich the injection of  {@code pkt} is to begin
 * @return {@code true} if the packet was successfully retransmitted,{@code false} otherwise.
 */
public boolean retransmit(RawPacket pkt,TransformEngine after){
  boolean destinationSupportsRtx=channel.getRtxPayloadType() != -1;
  boolean retransmitPlain;
  if (destinationSupportsRtx) {
    long rtxSsrc=getPairedSsrc(pkt.getSSRCAsLong());
    if (rtxSsrc == -1) {
      logger.warn(""String_Node_Str"" + ""String_Node_Str"" + pkt.getSSRCAsLong());
      retransmitPlain=true;
    }
 else {
      retransmitPlain=!encapsulateInRtxAndTransmit(pkt,rtxSsrc,after);
    }
  }
 else {
    retransmitPlain=true;
  }
  if (retransmitPlain) {
    MediaStream mediaStream=channel.getStream();
    if (mediaStream != null) {
      try {
        mediaStream.injectPacket(pkt,true,after);
      }
 catch (      TransmissionFailedException tfe) {
        logger.warn(""String_Node_Str"");
        return false;
      }
    }
  }
  return true;
}",0.9977426636568848
104997,"/** 
 * {@inheritDoc}
 */
@Override public boolean accept(RawPacket pkt){
  if (pkt == null) {
    return false;
  }
  State oldState=this.state;
  SimulcastStream next=oldState.getNext();
  if (next != null && next.matches(pkt) && next.isKeyFrame(pkt)) {
    int lastReceivedSeq=next.getLastPktSequenceNumber();
    int diff=RTPUtils.sequenceNumberDiff(pkt.getSequenceNumber(),lastReceivedSeq);
    if (diff >= 0) {
      this.state=new State(new WeakReference<>(next),null);
      return true;
    }
 else {
      logger.warn(""String_Node_Str"" + ""String_Node_Str"" + pkt.getSequenceNumber() + ""String_Node_Str""+ lastReceivedSeq+ ""String_Node_Str""+ pkt.getSSRCAsLong());
      next.askForKeyframe();
    }
  }
  SimulcastStream current=oldState.getCurrent();
  return current != null && current.matches(pkt);
}","/** 
 * {@inheritDoc}
 */
@Override public boolean accept(RawPacket pkt){
  if (pkt == null) {
    return false;
  }
  State oldState=this.state;
  SimulcastStream next=oldState.getNext();
  Long pktSSRC=pkt.getSSRCAsLong();
  Integer pktSequenceNumber=pkt.getSequenceNumber();
  int diff=1;
  if (lastPktSequenceNumbers.containsKey(pktSSRC)) {
    int lastReceivedSeq=lastPktSequenceNumbers.get(pktSSRC);
    diff=RTPUtils.sequenceNumberDiff(pkt.getSequenceNumber(),lastReceivedSeq);
  }
  boolean accept=false;
  if (next != null && next.matches(pkt) && next.isKeyFrame(pkt)) {
    if (diff >= 0) {
      this.state=new State(new WeakReference<>(next),null);
      accept=true;
    }
 else {
      logger.warn(""String_Node_Str"" + ""String_Node_Str"" + pkt.getSequenceNumber() + ""String_Node_Str""+ diff+ ""String_Node_Str""+ pkt.getSSRCAsLong());
      next.askForKeyframe();
    }
  }
 else {
    SimulcastStream current=oldState.getCurrent();
    accept=current != null && current.matches(pkt);
  }
  if (diff >= 0) {
    lastPktSequenceNumbers.put(pktSSRC,pktSequenceNumber);
  }
  return accept;
}",0.7389937106918238
104998,"/** 
 * Starts   {@link #stream} if it has not been started yet and if the state ofthis <tt>Channel</tt> meets the prerequisites to invoke {@link MediaStream#start()}. For example, <tt>MediaStream</tt> may be started only after a <tt>StreamConnector</tt> has been set on it and this <tt>Channel</tt> may be able to provide a <tt>StreamConnector</tt> only after the transport manager has completed the connectivity establishment.
 * @throws IOException if anything goes wrong while starting <tt>stream</tt>
 */
@Override protected void maybeStartStream() throws IOException {
synchronized (streamSyncRoot) {
    if (stream == null)     return;
  }
  StreamConnector connector=getStreamConnector();
  if (connector == null)   return;
 else   stream.setConnector(connector);
  MediaStreamTarget streamTarget=createStreamTarget();
  if (streamTarget != null) {
    InetSocketAddress dataAddr=streamTarget.getDataAddress();
    if (dataAddr != null) {
      this.streamTarget.setDataHostAddress(dataAddr.getAddress());
      this.streamTarget.setDataPort(dataAddr.getPort());
    }
    InetSocketAddress ctrlAddr=streamTarget.getControlAddress();
    if (ctrlAddr != null) {
      this.streamTarget.setControlHostAddress(ctrlAddr.getAddress());
      this.streamTarget.setControlPort(ctrlAddr.getPort());
    }
    if (dataAddr != null)     stream.setTarget(streamTarget);
  }
  Content content=getContent();
  if (!stream.isStarted()) {
    if (RTPLevelRelayType.MIXER.equals(getRTPLevelRelayType()))     stream.setSSRCFactory(new SSRCFactoryImpl(initialLocalSSRC));
synchronized (streamSyncRoot) {
      stream.start();
    }
    Videobridge videobridge=getContent().getConference().getVideobridge();
    EventAdmin eventAdmin=videobridge.getEventAdmin();
    if (eventAdmin != null && streamTarget != null) {
      eventAdmin.sendEvent(EventFactory.streamStarted(this));
    }
  }
  if (logger.isTraceEnabled()) {
    logger.trace(""String_Node_Str"" + getID() + ""String_Node_Str""+ content.getName()+ ""String_Node_Str""+ content.getConference().getID()+ ""String_Node_Str""+ stream.getDirection()+ ""String_Node_Str"");
  }
  touch();
}","/** 
 * Starts   {@link #stream} if it has not been started yet and if the state ofthis <tt>Channel</tt> meets the prerequisites to invoke {@link MediaStream#start()}. For example, <tt>MediaStream</tt> may be started only after a <tt>StreamConnector</tt> has been set on it and this <tt>Channel</tt> may be able to provide a <tt>StreamConnector</tt> only after the transport manager has completed the connectivity establishment.
 * @throws IOException if anything goes wrong while starting <tt>stream</tt>
 */
@Override protected void maybeStartStream() throws IOException {
synchronized (streamSyncRoot) {
    if (stream == null)     return;
  }
  MediaStreamTarget streamTarget=createStreamTarget();
  StreamConnector connector=getStreamConnector();
  if (streamTarget == null) {
    logger.info(""String_Node_Str"");
    return;
  }
  if (connector == null) {
    logger.info(""String_Node_Str"");
    return;
  }
  InetSocketAddress dataAddr=streamTarget.getDataAddress();
  if (dataAddr == null) {
    logger.info(""String_Node_Str"");
    return;
  }
  this.streamTarget.setDataHostAddress(dataAddr.getAddress());
  this.streamTarget.setDataPort(dataAddr.getPort());
  InetSocketAddress ctrlAddr=streamTarget.getControlAddress();
  if (ctrlAddr != null) {
    this.streamTarget.setControlHostAddress(ctrlAddr.getAddress());
    this.streamTarget.setControlPort(ctrlAddr.getPort());
  }
  stream.setTarget(streamTarget);
  stream.setConnector(connector);
  Content content=getContent();
  if (!stream.isStarted()) {
    if (RTPLevelRelayType.MIXER.equals(getRTPLevelRelayType()))     stream.setSSRCFactory(new SSRCFactoryImpl(initialLocalSSRC));
synchronized (streamSyncRoot) {
      stream.start();
    }
    Videobridge videobridge=getContent().getConference().getVideobridge();
    EventAdmin eventAdmin=videobridge.getEventAdmin();
    if (eventAdmin != null) {
      eventAdmin.sendEvent(EventFactory.streamStarted(this));
    }
  }
  if (logger.isTraceEnabled()) {
    logger.trace(""String_Node_Str"" + getID() + ""String_Node_Str""+ content.getName()+ ""String_Node_Str""+ content.getConference().getID()+ ""String_Node_Str""+ stream.getDirection()+ ""String_Node_Str"");
  }
  touch();
}",0.713821892393321
104999,"/** 
 * Handles a <tt>ColibriConferenceIQ</tt> stanza which represents a request.
 * @param conferenceIQ the <tt>ColibriConferenceIQ</tt> stanza representsthe request to handle
 * @param options
 * @return an <tt>org.jivesoftware.smack.packet.IQ</tt> stanza whichrepresents the response to the specified request or <tt>null</tt> to reply with <tt>feature-not-implemented</tt>
 * @throws Exception to reply with <tt>internal-server-error</tt> to thespecified request
 */
public IQ handleColibriConferenceIQ(ColibriConferenceIQ conferenceIQ,int options) throws Exception {
  String focus=conferenceIQ.getFrom();
  Conference conference;
  if ((options & OPTION_ALLOW_ANY_FOCUS) > 0) {
    options|=OPTION_ALLOW_NO_FOCUS;
    focus=null;
  }
  if (focus == null && (options & OPTION_ALLOW_NO_FOCUS) == 0) {
    return IQ.createErrorResponse(conferenceIQ,new XMPPError(XMPPError.Condition.not_authorized));
  }
 else   if (authorizedSourcePattern != null && (focus == null || !authorizedSourcePattern.matcher(focus).matches())) {
    return IQ.createErrorResponse(conferenceIQ,new XMPPError(XMPPError.Condition.not_authorized));
  }
 else {
    String id=conferenceIQ.getID();
    if (id == null) {
      if (!isShutdownInProgress()) {
        conference=createConference(focus);
      }
 else {
        return ColibriConferenceIQ.createGracefulShutdownErrorResponse(conferenceIQ);
      }
    }
 else {
      conference=getConference(id,focus);
    }
    if (conference != null)     conference.setLastKnownFocus(conferenceIQ.getFrom());
  }
  ColibriConferenceIQ responseConferenceIQ;
  if (conference == null) {
    responseConferenceIQ=null;
  }
 else {
    String name=conferenceIQ.getName();
    if (name != null)     conference.setName(name);
    responseConferenceIQ=new ColibriConferenceIQ();
    conference.describeShallow(responseConferenceIQ);
    responseConferenceIQ.setGracefulShutdown(isShutdownInProgress());
    ColibriConferenceIQ.Recording recordingIQ=conferenceIQ.getRecording();
    if (recordingIQ != null) {
      String tokenIQ=recordingIQ.getToken();
      if (tokenIQ != null) {
        String tokenConfig=getConfigurationService().getString(Videobridge.MEDIA_RECORDING_TOKEN_PNAME);
        if (tokenIQ.equals(tokenConfig)) {
          ColibriConferenceIQ.Recording.State recState=recordingIQ.getState();
          boolean recording=conference.setRecording(ColibriConferenceIQ.Recording.State.ON.equals(recState) || ColibriConferenceIQ.Recording.State.PENDING.equals(recState));
          ColibriConferenceIQ.Recording responseRecordingIq=new ColibriConferenceIQ.Recording(recState);
          if (recording) {
            responseRecordingIq.setDirectory(conference.getRecordingDirectory());
          }
          responseConferenceIQ.setRecording(responseRecordingIq);
        }
      }
    }
    for (    ColibriConferenceIQ.Content contentIQ : conferenceIQ.getContents()) {
      Content content=conference.getOrCreateContent(contentIQ.getName());
      if (content == null) {
        responseConferenceIQ=null;
      }
 else {
        ColibriConferenceIQ.Content responseContentIQ=new ColibriConferenceIQ.Content(content.getName());
        responseConferenceIQ.addContent(responseContentIQ);
        for (        ColibriConferenceIQ.Channel channelIQ : contentIQ.getChannels()) {
          String channelID=channelIQ.getID();
          int channelExpire=channelIQ.getExpire();
          String channelBundleId=channelIQ.getChannelBundleId();
          RtpChannel channel=null;
          boolean channelCreated=false;
          String transportNamespace=channelIQ.getTransport() != null ? channelIQ.getTransport().getNamespace() : null;
          if (channelID == null) {
            if (channelExpire != 0) {
              channel=content.createRtpChannel(channelBundleId,transportNamespace,channelIQ.isInitiator(),channelIQ.getRTPLevelRelayType());
              if (channel instanceof VideoChannel) {
                VideoChannel videoChannel=(VideoChannel)channel;
                videoChannel.setReceiveSimulcastLayer(channelIQ.getReceivingSimulcastLayer());
              }
              channelCreated=true;
            }
          }
 else {
            channel=(RtpChannel)content.getChannel(channelID);
          }
          if (channel == null) {
            responseConferenceIQ=null;
          }
 else {
            if (channelExpire != ColibriConferenceIQ.Channel.EXPIRE_NOT_SPECIFIED) {
              channel.setExpire(channelExpire);
              if ((channelExpire == 0) && channel.isExpired())               continue;
            }
            String endpoint=channelIQ.getEndpoint();
            if (endpoint != null)             channel.setEndpoint(endpoint);
            Integer lastN=channelIQ.getLastN();
            if (lastN != null)             channel.setLastN(lastN);
            Boolean adaptiveLastN=channelIQ.getAdaptiveLastN();
            if (adaptiveLastN != null)             channel.setAdaptiveLastN(adaptiveLastN);
            Boolean adaptiveSimulcast=channelIQ.getAdaptiveSimulcast();
            if (adaptiveSimulcast != null)             channel.setAdaptiveSimulcast(adaptiveSimulcast);
            Boolean initiator=channelIQ.isInitiator();
            if (initiator != null)             channel.setInitiator(initiator);
            channel.setPayloadTypes(channelIQ.getPayloadTypes());
            channel.setRtpHeaderExtensions(channelIQ.getRtpHeaderExtensions());
            channel.setDirection(channelIQ.getDirection());
            channel.setSources(channelIQ.getSources());
            channel.setSourceGroups(channelIQ.getSourceGroups());
            if (channel instanceof VideoChannel) {
              SimulcastMode simulcastMode=channelIQ.getSimulcastMode();
              if (simulcastMode != null) {
                ((VideoChannel)channel).setSimulcastMode(simulcastMode);
              }
            }
            if (channelBundleId != null) {
              TransportManager transportManager=conference.getTransportManager(channelBundleId,true);
              transportManager.addChannel(channel);
            }
            channel.setTransport(channelIQ.getTransport());
            ColibriConferenceIQ.Channel responseChannelIQ=new ColibriConferenceIQ.Channel();
            channel.describe(responseChannelIQ);
            responseContentIQ.addChannel(responseChannelIQ);
            EventAdmin eventAdmin;
            if (channelCreated && (eventAdmin=getEventAdmin()) != null) {
              eventAdmin.sendEvent(EventFactory.channelCreated(channel));
            }
            content.fireChannelChanged(channel);
          }
          if (responseConferenceIQ == null)           break;
        }
        for (        ColibriConferenceIQ.SctpConnection sctpConnIq : contentIQ.getSctpConnections()) {
          String id=sctpConnIq.getID();
          String endpointID=sctpConnIq.getEndpoint();
          SctpConnection sctpConn;
          int expire=sctpConnIq.getExpire();
          String channelBundleId=sctpConnIq.getChannelBundleId();
          if (id == null) {
            Endpoint endpoint=(endpointID == null) ? null : conference.getOrCreateEndpoint(endpointID);
            sctpConn=content.getSctpConnection(endpoint);
            if (sctpConn == null) {
              if (expire == 0)               continue;
              int sctpPort=sctpConnIq.getPort();
              sctpConn=content.createSctpConnection(endpoint,sctpPort,channelBundleId,sctpConnIq.isInitiator());
            }
          }
 else {
            sctpConn=content.getSctpConnection(id);
            if (sctpConn == null && expire == 0)             continue;
            if (endpointID != null)             sctpConn.setEndpoint(endpointID);
          }
          if (expire != ColibriConferenceIQ.Channel.EXPIRE_NOT_SPECIFIED) {
            sctpConn.setExpire(expire);
          }
          if (sctpConn.isExpired())           continue;
          Boolean initiator=sctpConnIq.isInitiator();
          if (initiator != null)           sctpConn.setInitiator(initiator);
          sctpConn.setTransport(sctpConnIq.getTransport());
          if (channelBundleId != null) {
            TransportManager transportManager=conference.getTransportManager(channelBundleId,true);
            transportManager.addChannel(sctpConn);
          }
          ColibriConferenceIQ.SctpConnection responseSctpIq=new ColibriConferenceIQ.SctpConnection();
          sctpConn.describe(responseSctpIq);
          responseContentIQ.addSctpConnection(responseSctpIq);
        }
      }
      if (responseConferenceIQ == null)       break;
    }
    for (    ColibriConferenceIQ.ChannelBundle channelBundleIq : conferenceIQ.getChannelBundles()) {
      TransportManager transportManager=conference.getTransportManager(channelBundleIq.getId());
      IceUdpTransportPacketExtension transportIq=channelBundleIq.getTransport();
      if (transportManager != null && transportIq != null) {
        transportManager.startConnectivityEstablishment(transportIq);
      }
    }
  }
  if (conference != null) {
    for (    ColibriConferenceIQ.Endpoint colibriEndpoint : conferenceIQ.getEndpoints()) {
      conference.updateEndpoint(colibriEndpoint);
    }
    if (responseConferenceIQ != null)     conference.describeChannelBundles(responseConferenceIQ);
  }
  if (responseConferenceIQ != null) {
    responseConferenceIQ.setType(org.jivesoftware.smack.packet.IQ.Type.RESULT);
  }
  return responseConferenceIQ;
}","/** 
 * Handles a <tt>ColibriConferenceIQ</tt> stanza which represents a request.
 * @param conferenceIQ the <tt>ColibriConferenceIQ</tt> stanza representsthe request to handle
 * @param options
 * @return an <tt>org.jivesoftware.smack.packet.IQ</tt> stanza whichrepresents the response to the specified request or <tt>null</tt> to reply with <tt>feature-not-implemented</tt>
 * @throws Exception to reply with <tt>internal-server-error</tt> to thespecified request
 */
public IQ handleColibriConferenceIQ(ColibriConferenceIQ conferenceIQ,int options) throws Exception {
  String focus=conferenceIQ.getFrom();
  Conference conference;
  if ((options & OPTION_ALLOW_ANY_FOCUS) > 0) {
    options|=OPTION_ALLOW_NO_FOCUS;
    focus=null;
  }
  if (focus == null && (options & OPTION_ALLOW_NO_FOCUS) == 0) {
    return IQ.createErrorResponse(conferenceIQ,new XMPPError(XMPPError.Condition.not_authorized));
  }
 else   if (authorizedSourcePattern != null && (focus == null || !authorizedSourcePattern.matcher(focus).matches())) {
    return IQ.createErrorResponse(conferenceIQ,new XMPPError(XMPPError.Condition.not_authorized));
  }
 else {
    String id=conferenceIQ.getID();
    if (id == null) {
      if (!isShutdownInProgress()) {
        conference=createConference(focus);
      }
 else {
        return ColibriConferenceIQ.createGracefulShutdownErrorResponse(conferenceIQ);
      }
    }
 else {
      conference=getConference(id,focus);
    }
    if (conference != null)     conference.setLastKnownFocus(conferenceIQ.getFrom());
  }
  ColibriConferenceIQ responseConferenceIQ;
  if (conference == null) {
    responseConferenceIQ=null;
  }
 else {
    String name=conferenceIQ.getName();
    if (name != null)     conference.setName(name);
    responseConferenceIQ=new ColibriConferenceIQ();
    conference.describeShallow(responseConferenceIQ);
    responseConferenceIQ.setGracefulShutdown(isShutdownInProgress());
    ColibriConferenceIQ.Recording recordingIQ=conferenceIQ.getRecording();
    if (recordingIQ != null) {
      String tokenIQ=recordingIQ.getToken();
      if (tokenIQ != null) {
        String tokenConfig=getConfigurationService().getString(Videobridge.MEDIA_RECORDING_TOKEN_PNAME);
        if (tokenIQ.equals(tokenConfig)) {
          ColibriConferenceIQ.Recording.State recState=recordingIQ.getState();
          boolean recording=conference.setRecording(ColibriConferenceIQ.Recording.State.ON.equals(recState) || ColibriConferenceIQ.Recording.State.PENDING.equals(recState));
          ColibriConferenceIQ.Recording responseRecordingIq=new ColibriConferenceIQ.Recording(recState);
          if (recording) {
            responseRecordingIq.setDirectory(conference.getRecordingDirectory());
          }
          responseConferenceIQ.setRecording(responseRecordingIq);
        }
      }
    }
    for (    ColibriConferenceIQ.Content contentIQ : conferenceIQ.getContents()) {
      Content content=conference.getOrCreateContent(contentIQ.getName());
      if (content == null) {
        responseConferenceIQ=null;
      }
 else {
        ColibriConferenceIQ.Content responseContentIQ=new ColibriConferenceIQ.Content(content.getName());
        responseConferenceIQ.addContent(responseContentIQ);
        for (        ColibriConferenceIQ.Channel channelIQ : contentIQ.getChannels()) {
          String channelID=channelIQ.getID();
          int channelExpire=channelIQ.getExpire();
          String channelBundleId=channelIQ.getChannelBundleId();
          RtpChannel channel=null;
          boolean channelCreated=false;
          String transportNamespace=channelIQ.getTransport() != null ? channelIQ.getTransport().getNamespace() : null;
          if (channelID == null) {
            if (channelExpire != 0) {
              channel=content.createRtpChannel(channelBundleId,transportNamespace,channelIQ.isInitiator(),channelIQ.getRTPLevelRelayType());
              if (channel instanceof VideoChannel) {
                VideoChannel videoChannel=(VideoChannel)channel;
                Integer receiveSimulcastLayer=channelIQ.getReceivingSimulcastLayer();
                videoChannel.setReceiveSimulcastLayer(receiveSimulcastLayer);
              }
              channelCreated=true;
            }
          }
 else {
            channel=(RtpChannel)content.getChannel(channelID);
          }
          if (channel == null) {
            responseConferenceIQ=null;
          }
 else {
            if (channelExpire != ColibriConferenceIQ.Channel.EXPIRE_NOT_SPECIFIED) {
              channel.setExpire(channelExpire);
              if ((channelExpire == 0) && channel.isExpired())               continue;
            }
            String endpoint=channelIQ.getEndpoint();
            if (endpoint != null)             channel.setEndpoint(endpoint);
            Integer lastN=channelIQ.getLastN();
            if (lastN != null)             channel.setLastN(lastN);
            Boolean adaptiveLastN=channelIQ.getAdaptiveLastN();
            if (adaptiveLastN != null)             channel.setAdaptiveLastN(adaptiveLastN);
            Boolean adaptiveSimulcast=channelIQ.getAdaptiveSimulcast();
            if (adaptiveSimulcast != null)             channel.setAdaptiveSimulcast(adaptiveSimulcast);
            Boolean initiator=channelIQ.isInitiator();
            if (initiator != null)             channel.setInitiator(initiator);
            channel.setPayloadTypes(channelIQ.getPayloadTypes());
            channel.setRtpHeaderExtensions(channelIQ.getRtpHeaderExtensions());
            channel.setDirection(channelIQ.getDirection());
            channel.setSources(channelIQ.getSources());
            channel.setSourceGroups(channelIQ.getSourceGroups());
            if (channel instanceof VideoChannel) {
              SimulcastMode simulcastMode=channelIQ.getSimulcastMode();
              if (simulcastMode != null) {
                ((VideoChannel)channel).setSimulcastMode(simulcastMode);
              }
            }
            if (channelBundleId != null) {
              TransportManager transportManager=conference.getTransportManager(channelBundleId,true);
              transportManager.addChannel(channel);
            }
            channel.setTransport(channelIQ.getTransport());
            ColibriConferenceIQ.Channel responseChannelIQ=new ColibriConferenceIQ.Channel();
            channel.describe(responseChannelIQ);
            responseContentIQ.addChannel(responseChannelIQ);
            EventAdmin eventAdmin;
            if (channelCreated && (eventAdmin=getEventAdmin()) != null) {
              eventAdmin.sendEvent(EventFactory.channelCreated(channel));
            }
            content.fireChannelChanged(channel);
          }
          if (responseConferenceIQ == null)           break;
        }
        for (        ColibriConferenceIQ.SctpConnection sctpConnIq : contentIQ.getSctpConnections()) {
          String id=sctpConnIq.getID();
          String endpointID=sctpConnIq.getEndpoint();
          SctpConnection sctpConn;
          int expire=sctpConnIq.getExpire();
          String channelBundleId=sctpConnIq.getChannelBundleId();
          if (id == null) {
            Endpoint endpoint=(endpointID == null) ? null : conference.getOrCreateEndpoint(endpointID);
            sctpConn=content.getSctpConnection(endpoint);
            if (sctpConn == null) {
              if (expire == 0)               continue;
              int sctpPort=sctpConnIq.getPort();
              sctpConn=content.createSctpConnection(endpoint,sctpPort,channelBundleId,sctpConnIq.isInitiator());
            }
          }
 else {
            sctpConn=content.getSctpConnection(id);
            if (sctpConn == null && expire == 0)             continue;
            if (endpointID != null)             sctpConn.setEndpoint(endpointID);
          }
          if (expire != ColibriConferenceIQ.Channel.EXPIRE_NOT_SPECIFIED) {
            sctpConn.setExpire(expire);
          }
          if (sctpConn.isExpired())           continue;
          Boolean initiator=sctpConnIq.isInitiator();
          if (initiator != null)           sctpConn.setInitiator(initiator);
          sctpConn.setTransport(sctpConnIq.getTransport());
          if (channelBundleId != null) {
            TransportManager transportManager=conference.getTransportManager(channelBundleId,true);
            transportManager.addChannel(sctpConn);
          }
          ColibriConferenceIQ.SctpConnection responseSctpIq=new ColibriConferenceIQ.SctpConnection();
          sctpConn.describe(responseSctpIq);
          responseContentIQ.addSctpConnection(responseSctpIq);
        }
      }
      if (responseConferenceIQ == null)       break;
    }
    for (    ColibriConferenceIQ.ChannelBundle channelBundleIq : conferenceIQ.getChannelBundles()) {
      TransportManager transportManager=conference.getTransportManager(channelBundleIq.getId());
      IceUdpTransportPacketExtension transportIq=channelBundleIq.getTransport();
      if (transportManager != null && transportIq != null) {
        transportManager.startConnectivityEstablishment(transportIq);
      }
    }
  }
  if (conference != null) {
    for (    ColibriConferenceIQ.Endpoint colibriEndpoint : conferenceIQ.getEndpoints()) {
      conference.updateEndpoint(colibriEndpoint);
    }
    if (responseConferenceIQ != null)     conference.describeChannelBundles(responseConferenceIQ);
  }
  if (responseConferenceIQ != null) {
    responseConferenceIQ.setType(org.jivesoftware.smack.packet.IQ.Type.RESULT);
  }
  return responseConferenceIQ;
}",0.9933076882542023
105000,"/** 
 * Notifies this instance about a change in the simulcast mode of the sending <tt>VideoChannel</tt>. We keep this in a separate method for readability and re-usability.
 * @param newMode
 * @param oldMode
 */
private void sendModeChanged(SimulcastMode newMode,SimulcastMode oldMode){
  if (newMode == null) {
    sendMode=null;
  }
 else   if (newMode == SimulcastMode.REWRITING) {
    sendMode=new RewritingSendMode(this);
  }
 else   if (newMode == SimulcastMode.SWITCHING) {
    sendMode=new SwitchingSendMode(this);
  }
  react(false);
}","/** 
 * Notifies this instance about a change in the simulcast mode of the sending <tt>VideoChannel</tt>. We keep this in a separate method for readability and re-usability.
 * @param newMode
 * @param oldMode
 */
private void sendModeChanged(SimulcastMode newMode,SimulcastMode oldMode){
  if (newMode == null) {
    sendMode=null;
    return;
  }
 else   if (newMode == SimulcastMode.REWRITING) {
    sendMode=new RewritingSendMode(this);
  }
 else   if (newMode == SimulcastMode.SWITCHING) {
    sendMode=new SwitchingSendMode(this);
  }
  this.sendMode.receive(targetOrder);
}",0.950266429840142
