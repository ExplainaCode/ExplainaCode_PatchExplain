record_number,buggy_code,fixed_code,code_similarity
85001,"@Override public void parse(IParserManager pm,IToken token) throws SyntaxError {
  int type=token.type();
  if (this.isInMode(NAME)) {
    if (type == Symbols.OPEN_PARENTHESIS) {
      TupleType tupleType=new TupleType();
      pm.pushParser(new TypeListParser(tupleType));
      this.type=tupleType;
      this.mode=TUPLE_END;
      return;
    }
    if (type == Symbols.OPEN_SQUARE_BRACKET) {
      this.arrayDimensions++;
      this.arrayDimensions2++;
      return;
    }
    if (type == Symbols.ARROW_OPERATOR) {
      LambdaType lt=new LambdaType();
      this.type=lt;
      pm.pushParser(new TypeParser(lt));
      this.mode=LAMBDA_END;
      return;
    }
    if (type == Keywords.VAR) {
      this.type=Types.UNKNOWN;
      this.mode=ARRAY_END;
      return;
    }
    if (ParserUtil.isIdentifier(type)) {
      if (token.next().type() == Symbols.OPEN_SQUARE_BRACKET) {
        this.type=new GenericType(token,token.nameValue());
        this.mode=GENERICS;
        return;
      }
      this.type=new Type(token,token.nameValue());
      this.mode=ARRAY_END;
      return;
    }
    if (type == Symbols.WILDCARD) {
      this.type=new WildcardType(token.raw());
      this.mode=WILDCARD_TYPE;
      return;
    }
    if (ParserUtil.isTerminator(type)) {
      pm.popParser(true);
      return;
    }
    throw new SyntaxError(token,""String_Node_Str"" + token);
  }
  if (this.isInMode(TUPLE_END)) {
    this.end();
    pm.popParser();
    if (type == Symbols.CLOSE_PARENTHESIS) {
      if (token.next().type() == Symbols.ARROW_OPERATOR) {
        TupleType tupleType=(TupleType)this.type;
        this.type=new LambdaType(tupleType);
        this.mode=LAMBDA_TYPE;
        return;
      }
      this.type.expandPosition(token);
      return;
    }
    throw new SyntaxError(token,""String_Node_Str"");
  }
  if (this.isInMode(LAMBDA_TYPE)) {
    pm.pushParser(new TypeParser((LambdaType)this.type));
    this.mode=LAMBDA_END;
    return;
  }
  if (this.isInMode(LAMBDA_END)) {
    this.type.expandPosition(token.prev());
    this.end();
    pm.popParser(true);
    return;
  }
  if (this.isInMode(ARRAY_END)) {
    if (this.arrayDimensions2 > 0) {
      if (type == Symbols.CLOSE_SQUARE_BRACKET) {
        this.arrayDimensions2--;
        if (this.arrayDimensions2 == 0) {
          this.type.expandPosition(token);
          this.end();
          pm.popParser();
          return;
        }
      }
      this.type.expandPosition(token.prev());
      this.end();
      pm.popParser(true);
      throw new SyntaxError(token.prev(),""String_Node_Str"");
    }
    this.type.expandPosition(token.prev());
    this.end();
    pm.popParser(true);
    return;
  }
  if (this.isInMode(GENERICS)) {
    if (type == Symbols.OPEN_SQUARE_BRACKET) {
      pm.pushParser(new TypeListParser((GenericType)this.type));
      this.mode=GENERICS_END;
      return;
    }
    if (this.arrayDimensions2 > 0) {
      this.type.expandPosition(token.prev());
      this.end();
      pm.popParser(true);
      throw new SyntaxError(token.prev(),""String_Node_Str"");
    }
    this.type.expandPosition(token.prev());
    this.end();
    pm.popParser(true);
    return;
  }
  if (this.isInMode(WILDCARD_TYPE)) {
    Name name=token.nameValue();
    if (this.boundMode == 0) {
      if (name == Name.lteq) {
        pm.pushParser(new TypeParser(this));
        this.boundMode=LOWER;
        return;
      }
      if (name == Name.gteq) {
        pm.pushParser(new TypeParser(this));
        this.boundMode=UPPER;
        return;
      }
    }
 else     if (this.boundMode == UPPER) {
      if (name == Name.amp) {
        pm.pushParser(new TypeParser(this));
        return;
      }
    }
    this.end();
    pm.popParser(true);
    return;
  }
  if (this.isInMode(GENERICS_END)) {
    this.end();
    pm.popParser();
    if (type == Symbols.CLOSE_SQUARE_BRACKET) {
      return;
    }
    throw new SyntaxError(token,""String_Node_Str"",true);
  }
}","@Override public void parse(IParserManager pm,IToken token) throws SyntaxError {
  int type=token.type();
  if (this.mode == NAME) {
    if (type == Symbols.OPEN_PARENTHESIS) {
      TupleType tupleType=new TupleType();
      pm.pushParser(new TypeListParser(tupleType));
      this.type=tupleType;
      this.mode=TUPLE_END;
      return;
    }
    if (type == Symbols.OPEN_SQUARE_BRACKET) {
      this.mode=ARRAY_END;
      ArrayType at=new ArrayType();
      this.type=at;
      pm.pushParser(new TypeParser(at));
      return;
    }
    if (type == Symbols.ARROW_OPERATOR) {
      LambdaType lt=new LambdaType();
      this.type=lt;
      pm.pushParser(new TypeParser(lt));
      this.mode=LAMBDA_END;
      return;
    }
    if (type == Keywords.VAR) {
      this.type=Types.UNKNOWN;
      this.mode=ARRAY_END;
      return;
    }
    if (ParserUtil.isIdentifier(type)) {
      if (token.next().type() == Symbols.OPEN_SQUARE_BRACKET) {
        this.type=new GenericType(token,token.nameValue());
        this.mode=GENERICS;
        return;
      }
      this.type=new Type(token.raw(),token.nameValue());
      this.typed.setType(this.type);
      pm.popParser();
      return;
    }
    if (type == Symbols.WILDCARD) {
      this.type=new WildcardType(token.raw());
      this.mode=WILDCARD_TYPE;
      return;
    }
    if (ParserUtil.isTerminator(type)) {
      pm.popParser(true);
      return;
    }
    throw new SyntaxError(token,""String_Node_Str"" + token);
  }
  if (this.mode == TUPLE_END) {
    this.typed.setType(this.type);
    pm.popParser();
    if (type == Symbols.CLOSE_PARENTHESIS) {
      if (token.next().type() == Symbols.ARROW_OPERATOR) {
        TupleType tupleType=(TupleType)this.type;
        this.type=new LambdaType(tupleType);
        this.mode=LAMBDA_TYPE;
        return;
      }
      this.type.expandPosition(token);
      return;
    }
    throw new SyntaxError(token,""String_Node_Str"");
  }
  if (this.mode == LAMBDA_TYPE) {
    pm.pushParser(new TypeParser((LambdaType)this.type));
    this.mode=LAMBDA_END;
    return;
  }
  if (this.mode == LAMBDA_END) {
    this.type.expandPosition(token.prev());
    this.typed.setType(this.type);
    pm.popParser(true);
    return;
  }
  if (this.mode == ARRAY_END) {
    this.type.expandPosition(token);
    this.typed.setType(this.type);
    pm.popParser();
    if (type == Symbols.CLOSE_SQUARE_BRACKET) {
      return;
    }
    throw new SyntaxError(token,""String_Node_Str"",true);
  }
  if (this.mode == GENERICS) {
    if (type == Symbols.OPEN_SQUARE_BRACKET) {
      pm.pushParser(new TypeListParser((GenericType)this.type));
      this.mode=GENERICS_END;
      return;
    }
    this.type.expandPosition(token.prev());
    this.typed.setType(this.type);
    pm.popParser(true);
    return;
  }
  if (this.mode == WILDCARD_TYPE) {
    Name name=token.nameValue();
    if (this.boundMode == 0) {
      if (name == Name.lteq) {
        pm.pushParser(new TypeParser(this));
        this.boundMode=LOWER;
        return;
      }
      if (name == Name.gteq) {
        pm.pushParser(new TypeParser(this));
        this.boundMode=UPPER;
        return;
      }
    }
 else     if (this.boundMode == UPPER) {
      if (name == Name.amp) {
        pm.pushParser(new TypeParser(this));
        return;
      }
    }
    this.typed.setType(this.type);
    pm.popParser(true);
    return;
  }
  if (this.mode == GENERICS_END) {
    this.typed.setType(this.type);
    pm.popParser();
    if (type == Symbols.CLOSE_SQUARE_BRACKET) {
      return;
    }
    throw new SyntaxError(token,""String_Node_Str"",true);
  }
}",0.8026613439787093
85002,"@Override public int getTypeMatch(IType type){
  if (!type.isArrayType()) {
    return type.getTheClass().getAnnotation(ARRAY_CONVERTIBLE) != null ? 2 : 0;
  }
  if (this.valueCount == 0) {
    return 3;
  }
  IType type1=type.getElementType();
  int total=0;
  for (int i=0; i < this.valueCount; i++) {
    int m=this.values[i].getTypeMatch(type1);
    if (m == 0) {
      return 0;
    }
    total+=m;
  }
  return total / this.valueCount;
}","@Override public int getTypeMatch(IType type){
  if (!type.isArrayType()) {
    IClass iclass=type.getTheClass();
    return iclass == Types.OBJECT_CLASS || iclass.getAnnotation(ARRAY_CONVERTIBLE) != null ? 2 : 0;
  }
  if (this.valueCount == 0) {
    return 3;
  }
  IType type1=type.getElementType();
  int total=0;
  for (int i=0; i < this.valueCount; i++) {
    int m=this.values[i].getTypeMatch(type1);
    if (m == 0) {
      return 0;
    }
    total+=m;
  }
  return total / this.valueCount;
}",0.923728813559322
85003,"@Override public IValue withType(IType type){
  if (!type.isArrayType()) {
    if (type.getTheClass().getAnnotation(ARRAY_CONVERTIBLE) != null) {
      return new LiteralExpression(type,this);
    }
    return null;
  }
  IType type1=type.getElementType();
  for (int i=0; i < this.valueCount; i++) {
    if (!this.values[i].isType(type1)) {
      return null;
    }
  }
  this.elementType=type1;
  this.requiredType=type;
  return this;
}","@Override public IValue withType(IType type){
  if (!type.isArrayType()) {
    IClass iclass=type.getTheClass();
    if (iclass == Types.OBJECT_CLASS) {
      return this;
    }
    if (iclass.getAnnotation(ARRAY_CONVERTIBLE) != null) {
      return new LiteralExpression(type,this);
    }
    return null;
  }
  IType type1=type.getElementType();
  for (int i=0; i < this.valueCount; i++) {
    if (!this.values[i].isType(type1)) {
      return null;
    }
  }
  this.elementType=type1;
  this.requiredType=type;
  return this;
}",0.8710010319917441
85004,"@Override public boolean isType(IType type){
  if (!type.isArrayType()) {
    return type.getTheClass().getAnnotation(ARRAY_CONVERTIBLE) != null;
  }
  if (this.valueCount == 0) {
    return true;
  }
  IType type1=type.getElementType();
  for (int i=0; i < this.valueCount; i++) {
    if (!this.values[i].isType(type1)) {
      return false;
    }
  }
  return true;
}","@Override public boolean isType(IType type){
  if (!type.isArrayType()) {
    IClass iclass=type.getTheClass();
    return iclass == Types.OBJECT_CLASS || iclass.getAnnotation(ARRAY_CONVERTIBLE) != null;
  }
  if (this.valueCount == 0) {
    return true;
  }
  IType type1=type.getElementType();
  for (int i=0; i < this.valueCount; i++) {
    if (!this.values[i].isType(type1)) {
      return false;
    }
  }
  return true;
}",0.9095477386934674
85005,"@Override public boolean isSuperTypeOf(IType type){
  int arrayDims=type.getArrayDimensions();
  if (arrayDims == 0) {
    return false;
  }
  int thisDims=this.getArrayDimensions();
  if (arrayDims > thisDims) {
    return this.type.getTheClass() == Types.OBJECT_CLASS;
  }
  return this.type.isSuperTypeOf(type);
}","@Override public boolean isSuperTypeOf(IType type){
  int arrayDims=type.getArrayDimensions();
  if (arrayDims == 0) {
    return false;
  }
  int thisDims=this.getArrayDimensions();
  if (arrayDims > thisDims) {
    return this.type.getTheClass() == Types.OBJECT_CLASS;
  }
  return this.type.isSuperTypeOf(type.getElementType());
}",0.9738058551617874
85006,"@Override public void addStaticImport(HeaderComponent component){
  int index=this.staticImportCount++;
  if (index >= this.staticImports.length) {
    HeaderComponent[] temp=new HeaderComponent[index];
    System.arraycopy(this.staticImports,0,temp,0,this.staticImports.length);
    this.staticImports=temp;
  }
  this.staticImports[index]=component;
}","@Override public void addStaticImport(HeaderComponent component){
  int index=this.staticImportCount++;
  if (index >= this.staticImports.length) {
    HeaderComponent[] temp=new HeaderComponent[index + 1];
    System.arraycopy(this.staticImports,0,temp,0,this.staticImports.length);
    this.staticImports=temp;
  }
  this.staticImports[index]=component;
}",0.9943661971830986
85007,"@Override public void addImport(HeaderComponent component){
  int index=this.importCount++;
  if (index >= this.imports.length) {
    HeaderComponent[] temp=new HeaderComponent[index];
    System.arraycopy(this.imports,0,temp,0,this.imports.length);
    this.imports=temp;
  }
  this.imports[index]=component;
}","@Override public void addImport(HeaderComponent component){
  int index=this.importCount++;
  if (index >= this.imports.length) {
    HeaderComponent[] temp=new HeaderComponent[index + 1];
    System.arraycopy(this.imports,0,temp,0,this.imports.length);
    this.imports=temp;
  }
  this.imports[index]=component;
}",0.9936102236421726
85008,"@Override public void writeExpression(MethodWriter writer){
  if (this.type.isArrayType()) {
    int len=this.arguments.size();
    if (len == 1) {
      this.arguments.getFirstValue().writeExpression(writer);
      this.type.setArrayDimensions(0);
      writer.writeTypeInsn(Opcodes.ANEWARRAY,this.type.getInternalName());
      this.type.setArrayDimensions(1);
      return;
    }
    ArgumentList paramList=(ArgumentList)this.arguments;
    for (int i=0; i < len; i++) {
      paramList.getValue(i).writeExpression(writer);
    }
    writer.writeNewArray(this.type,len);
    return;
  }
  this.constructor.writeCall(writer,this.arguments,null);
}","@Override public void writeExpression(MethodWriter writer){
  if (this.type.isArrayType()) {
    int len=this.arguments.size();
    if (len == 1) {
      this.arguments.getFirstValue().writeExpression(writer);
      writer.writeNewArray(this.type,1);
      return;
    }
    ArgumentList paramList=(ArgumentList)this.arguments;
    for (int i=0; i < len; i++) {
      paramList.getValue(i).writeExpression(writer);
    }
    writer.writeNewArray(this.type,len);
    return;
  }
  this.constructor.writeCall(writer,this.arguments,null);
}",0.863406408094435
85009,"@Override public void write(ClassWriter writer){
  boolean instance=this.thisClass != null;
  int modifiers=instance ? Modifiers.PRIVATE | Modifiers.SYNTHETIC : Modifiers.PRIVATE | Modifiers.STATIC | Modifiers.SYNTHETIC;
  MethodWriter mw=new MethodWriterImpl(writer,writer.visitMethod(modifiers,this.getName(),this.getLambdaDescriptor(),null,null));
  if (instance) {
    mw.setInstanceMethod();
  }
  int index=0;
  for (int i=0; i < this.capturedFieldCount; i++) {
    CaptureVariable capture=this.capturedFields[i];
    capture.index=index;
    index=mw.registerParameter(index,capture.variable.getName().qualified,capture.variable.getType(),0);
  }
  index=0;
  for (int i=0; i < this.parameterCount; i++) {
    IParameter param=this.parameters[i];
    index=mw.registerParameter(index,param.getName().qualified,param.getType(),0);
    param.setIndex(index);
  }
  mw.begin();
  this.value.writeExpression(mw);
  mw.end(this.returnType);
}","@Override public void write(ClassWriter writer){
  boolean instance=this.thisClass != null;
  int modifiers=instance ? Modifiers.PRIVATE | Modifiers.SYNTHETIC : Modifiers.PRIVATE | Modifiers.STATIC | Modifiers.SYNTHETIC;
  MethodWriter mw=new MethodWriterImpl(writer,writer.visitMethod(modifiers,this.getName(),this.getLambdaDescriptor(),null,null));
  if (instance) {
    mw.setInstanceMethod();
  }
  int index=0;
  for (int i=0; i < this.capturedFieldCount; i++) {
    CaptureVariable capture=this.capturedFields[i];
    capture.index=index;
    index=mw.registerParameter(index,capture.variable.getName().qualified,capture.variable.getType(),0);
  }
  for (int i=0; i < this.parameterCount; i++) {
    IParameter param=this.parameters[i];
    param.setIndex(index);
    index=mw.registerParameter(index,param.getName().qualified,param.getType(),0);
  }
  mw.begin();
  this.value.writeExpression(mw);
  mw.end(this.returnType);
}",0.9643047416089504
85010,"public static IToken tokenize(String code){
  int len=code.length();
  StringBuilder buf=new StringBuilder(20);
  IToken first=new InferredSemicolon(0,0);
  IToken prev=first;
  int start=0;
  int lineNumber=1;
  char l=0;
  char c=0;
  int type=0;
  int subtype=0;
  boolean addToken=false;
  boolean reparse=true;
  boolean string=false;
  for (int i=0; i < len; ++i, l=c) {
    c=code.charAt(i);
    if (type == 0) {
      start=i;
      if (c == '\n') {
        lineNumber++;
        continue;
      }
      if (c <= ' ') {
        continue;
      }
      if (string && c == '}') {
        type=STRING_2;
        subtype=STRING_PART;
        continue;
      }
      int m=getMode(c,code,i);
      type=m & 0xFFFF;
      subtype=m & 0xFFFF0000;
    }
switch (type) {
case IDENTIFIER:
      if (subtype == MOD_DOTS) {
        if (c == '.') {
          buf.append(c);
        }
 else {
          addToken=true;
          reparse=true;
        }
      }
 else       if (c == '_' || c == '$') {
        subtype=MOD_SYMBOL | MOD_LETTER;
        buf.append(c);
      }
 else {
        boolean letter=(subtype & MOD_LETTER) != 0;
        boolean symbol=(subtype & MOD_SYMBOL) != 0;
        if (letter) {
          if (isIdentifierPart(c)) {
            subtype=MOD_LETTER;
            buf.append(c);
            continue;
          }
        }
        if (symbol) {
          if (isIdentifierSymbol(c)) {
            subtype=MOD_SYMBOL;
            buf.append(c);
            continue;
          }
        }
        addToken=true;
      }
    break;
case SYMBOL:
  buf.append(c);
addToken=true;
reparse=false;
break;
case BRACKET:
buf.append(c);
addToken=true;
reparse=false;
break;
case COMMENT:
if (subtype == MOD_LINE) {
if (c == '\n') {
type=0;
continue;
}
}
 else if (subtype == MOD_BLOCK) {
if (l == '*' && c == '/') {
type=0;
continue;
}
}
break;
case INT:
case LONG:
if (c == '.') {
type=FLOAT;
buf.append('.');
}
 else if (c == 'l' || c == 'L') {
type=LONG;
addToken=true;
reparse=false;
}
 else if (subtype == MOD_DEC) {
if (isDigit(c)) {
buf.append(c);
}
 else if (c == 'f' || c == 'F') {
type=FLOAT;
addToken=true;
reparse=false;
}
 else if (c == 'd' || c == 'D') {
type=DOUBLE;
addToken=true;
reparse=false;
}
 else {
addToken=true;
}
}
 else if (subtype == MOD_BIN) {
if (c == 'b' || isBinDigit(c)) {
buf.append(c);
}
 else {
addToken=true;
}
}
 else if (subtype == MOD_OCT) {
if (isOctDigit(c)) {
buf.append(c);
}
 else {
addToken=true;
}
}
 else if (subtype == MOD_HEX) {
if (c == 'x' || isHexDigit(c)) {
buf.append(c);
}
 else {
addToken=true;
}
}
break;
case FLOAT:
case DOUBLE:
if (c == 'x') {
subtype=MOD_HEX;
buf.append(c);
}
 else if (c == 'f' || c == 'F') {
addToken=true;
reparse=false;
}
 else if (c == 'd' || c == 'D') {
type=DOUBLE;
addToken=true;
reparse=false;
}
 else if (isDigit(c) || c == '.' || c == 'e') {
buf.append(c);
}
 else {
addToken=true;
}
break;
case STRING:
if (c == '""' && buf.length() > 0) {
buf.append('""');
addToken=true;
reparse=false;
}
 else if (c == '\\' && appendEscape(buf,code.charAt(i + 1))) {
i++;
continue;
}
 else if (c != '\t') {
buf.append(c);
}
break;
case STRING_2:
if (c == '""' && (buf.length() > 1 || string)) {
if (!string && buf.charAt(0) == '@') {
subtype=STRING_2;
}
 else {
subtype=STRING_END;
}
string=false;
addToken=true;
reparse=false;
break;
}
 else if (c == '\\' && appendEscape(buf,code.charAt(i + 1))) {
i++;
continue;
}
 else if (c == '$' && code.charAt(i + 1) == '{') {
i+=2;
if (buf.charAt(0) == '@') {
subtype=STRING_START;
}
 else {
subtype=STRING_PART;
}
addToken=true;
string=true;
}
 else if (c != '\t') {
buf.append(c);
}
break;
case CHAR:
if (c == '\'' && buf.length() > 0) {
buf.append('\'');
addToken=true;
reparse=false;
}
 else if (c == '\\' && appendEscape(buf,code.charAt(i + 1))) {
i++;
continue;
}
 else if (c != '\t') {
buf.append(c);
}
break;
}
if (addToken) {
prev=addToken(prev,buf,type | subtype,lineNumber,start);
addToken=false;
type=0;
if (reparse) {
i--;
}
 else {
reparse=true;
}
}
}
if (buf.length() > 0) {
addToken(prev,buf,type | subtype,lineNumber,start);
}
return first.getNext();
}","public static IToken tokenize(String code){
  int len=code.length();
  StringBuilder buf=new StringBuilder(20);
  IToken first=new InferredSemicolon(0,0);
  IToken prev=first;
  int start=0;
  int lineNumber=1;
  char l=0;
  char c=0;
  int type=0;
  int subtype=0;
  boolean addToken=false;
  boolean reparse=true;
  boolean string=false;
  for (int i=0; i < len; ++i, l=c) {
    c=code.charAt(i);
    if (type == 0) {
      start=i;
      if (c == '\n') {
        lineNumber++;
        continue;
      }
      if (c <= ' ') {
        continue;
      }
      if (string && c == '}') {
        type=STRING_2;
        subtype=STRING_PART;
        continue;
      }
      int m=getMode(c,code,i);
      type=m & 0xFFFF;
      subtype=m & 0xFFFF0000;
    }
switch (type) {
case IDENTIFIER:
      if (subtype == MOD_DOTS) {
        if (c == '.') {
          buf.append(c);
        }
 else {
          addToken=true;
          reparse=true;
        }
      }
 else       if (c == '_' || c == '$') {
        subtype=MOD_SYMBOL | MOD_LETTER;
        buf.append(c);
      }
 else {
        boolean letter=(subtype & MOD_LETTER) != 0;
        boolean symbol=(subtype & MOD_SYMBOL) != 0;
        if (letter) {
          if (isIdentifierPart(c)) {
            subtype=MOD_LETTER;
            buf.append(c);
            continue;
          }
        }
        if (symbol) {
          if (isIdentifierSymbol(c)) {
            subtype=MOD_SYMBOL;
            buf.append(c);
            continue;
          }
        }
        addToken=true;
      }
    break;
case SYMBOL:
  buf.append(c);
addToken=true;
reparse=false;
break;
case BRACKET:
buf.append(c);
addToken=true;
reparse=false;
break;
case COMMENT:
if (subtype == MOD_LINE) {
if (c == '\n') {
type=0;
lineNumber++;
continue;
}
}
 else if (subtype == MOD_BLOCK) {
if (c == '\n') {
lineNumber++;
}
 else if (l == '*' && c == '/') {
type=0;
continue;
}
}
break;
case INT:
case LONG:
if (c == '.') {
type=FLOAT;
buf.append('.');
}
 else if (c == 'l' || c == 'L') {
type=LONG;
addToken=true;
reparse=false;
}
 else if (subtype == MOD_DEC) {
if (isDigit(c)) {
buf.append(c);
}
 else if (c == 'f' || c == 'F') {
type=FLOAT;
addToken=true;
reparse=false;
}
 else if (c == 'd' || c == 'D') {
type=DOUBLE;
addToken=true;
reparse=false;
}
 else {
addToken=true;
}
}
 else if (subtype == MOD_BIN) {
if (c == 'b' || isBinDigit(c)) {
buf.append(c);
}
 else {
addToken=true;
}
}
 else if (subtype == MOD_OCT) {
if (isOctDigit(c)) {
buf.append(c);
}
 else {
addToken=true;
}
}
 else if (subtype == MOD_HEX) {
if (c == 'x' || isHexDigit(c)) {
buf.append(c);
}
 else {
addToken=true;
}
}
break;
case FLOAT:
case DOUBLE:
if (c == 'x') {
subtype=MOD_HEX;
buf.append(c);
}
 else if (c == 'f' || c == 'F') {
addToken=true;
reparse=false;
}
 else if (c == 'd' || c == 'D') {
type=DOUBLE;
addToken=true;
reparse=false;
}
 else if (isDigit(c) || c == '.' || c == 'e') {
buf.append(c);
}
 else {
addToken=true;
}
break;
case STRING:
if (c == '""' && buf.length() > 0) {
buf.append('""');
addToken=true;
reparse=false;
}
 else if (c == '\\' && appendEscape(buf,code.charAt(i + 1))) {
i++;
continue;
}
 else if (c != '\t') {
buf.append(c);
}
break;
case STRING_2:
if (c == '""' && (buf.length() > 1 || string)) {
if (!string && buf.charAt(0) == '@') {
subtype=STRING_2;
}
 else {
subtype=STRING_END;
}
string=false;
addToken=true;
reparse=false;
break;
}
 else if (c == '\\' && appendEscape(buf,code.charAt(i + 1))) {
i++;
continue;
}
 else if (c == '$' && code.charAt(i + 1) == '{') {
i+=2;
if (buf.charAt(0) == '@') {
subtype=STRING_START;
}
 else {
subtype=STRING_PART;
}
addToken=true;
string=true;
}
 else if (c != '\t') {
buf.append(c);
}
break;
case CHAR:
if (c == '\'' && buf.length() > 0) {
buf.append('\'');
addToken=true;
reparse=false;
}
 else if (c == '\\' && appendEscape(buf,code.charAt(i + 1))) {
i++;
continue;
}
 else if (c != '\t') {
buf.append(c);
}
break;
}
if (addToken) {
prev=addToken(prev,buf,type | subtype,lineNumber,start);
addToken=false;
type=0;
if (reparse) {
i--;
}
 else {
reparse=true;
}
}
}
if (buf.length() > 0) {
addToken(prev,buf,type | subtype,lineNumber,start);
}
return first.getNext();
}",0.9935609281982748
85011,"@Override public IMethod getFunctionalMethod(){
  IMethod m;
  if (this.body != null) {
    m=this.body.getFunctionalMethod();
    if (m != null) {
      return m;
    }
  }
  return null;
}","@Override public IMethod getFunctionalMethod(){
  if ((this.modifiers & Modifiers.ABSTRACT | Modifiers.INTERFACE_CLASS) == 0) {
    return null;
  }
  IMethod m;
  if (this.body != null) {
    m=this.body.getFunctionalMethod();
    if (m != null) {
      return m;
    }
  }
  if (this.superType != null) {
    m=this.superType.getFunctionalMethod();
    if (m != null) {
      return m;
    }
  }
  for (int i=0; i < this.interfaceCount; i++) {
    m=this.interfaces[i].getFunctionalMethod();
    if (m != null) {
      return m;
    }
  }
  return null;
}",0.4712182061579651
85012,"@Override public IValue withType(IType type){
  return this.isType(type) ? this : null;
}","@Override public IValue withType(IType type){
  if (this.isType(type)) {
    this.type=type;
    return this;
  }
  return null;
}",0.7397260273972602
85013,"@Override public void checkTypes(MarkerList markers,IContext context){
  this.context=context;
  if (this.method != null) {
    if (this.method.hasTypeVariables()) {
      for (int i=0; i < this.parameterCount; i++) {
        IParameter param=this.parameters[i];
        param.setType(param.getType().getConcreteType(this.type));
      }
      this.returnType=this.method.getType().getConcreteType(this.type);
    }
 else {
      this.returnType=this.method.getType();
    }
    this.value=this.value.resolve(markers,this);
    IValue value1=this.value.withType(this.returnType);
    if (value1 == null) {
      Marker marker=markers.create(this.value.getPosition(),""String_Node_Str"");
      marker.addInfo(""String_Node_Str"" + this.returnType);
      marker.addInfo(""String_Node_Str"" + this.value.getType());
    }
 else {
      this.value=value1;
    }
  }
 else {
    markers.add(this.position,""String_Node_Str"");
  }
  this.value.checkTypes(markers,this);
  this.context=null;
}","@Override public void checkTypes(MarkerList markers,IContext context){
  this.context=context;
  if (this.method != null) {
    if (this.method.hasTypeVariables()) {
      for (int i=0; i < this.parameterCount; i++) {
        IParameter param=this.parameters[i];
        IType type=param.getType();
        if (type == null) {
          type=this.method.getParameter(i).getType();
        }
        param.setType(type.getConcreteType(this.type));
      }
      this.returnType=this.method.getType().getConcreteType(this.type);
    }
 else {
      this.returnType=this.method.getType();
    }
    this.value=this.value.resolve(markers,this);
    IValue value1=this.value.withType(this.returnType);
    if (value1 == null) {
      Marker marker=markers.create(this.value.getPosition(),""String_Node_Str"");
      marker.addInfo(""String_Node_Str"" + this.returnType);
      marker.addInfo(""String_Node_Str"" + this.value.getType());
    }
 else {
      this.value=value1;
    }
  }
 else {
    markers.add(this.position,""String_Node_Str"");
  }
  this.value.checkTypes(markers,this);
  this.context=null;
}",0.915824915824916
85014,"@Override public boolean isType(IType type){
  IClass iclass=type.getTheClass();
  if (iclass == null) {
    return false;
  }
  IMethod method=iclass.getFunctionalMethod();
  if (method == null) {
    return false;
  }
  if (this.parameterCount != method.parameterCount()) {
    return false;
  }
  for (int i=0; i < this.parameterCount; i++) {
    IParameter lambdaParam=this.parameters[i];
    IParameter param=method.getParameter(i);
    IType paramType=lambdaParam.getType();
    if (paramType == null) {
      lambdaParam.setType(param.getType());
      continue;
    }
    if (!param.getType().equals(paramType)) {
      return false;
    }
  }
  this.type=type;
  this.method=method;
  return true;
}","@Override public boolean isType(IType type){
  if (this.type != null && type.isSuperTypeOf(this.type)) {
    return true;
  }
  IClass iclass=type.getTheClass();
  if (iclass == null) {
    return false;
  }
  IMethod method=iclass.getFunctionalMethod();
  if (method == null) {
    return false;
  }
  if (this.parameterCount != method.parameterCount()) {
    return false;
  }
  for (int i=0; i < this.parameterCount; i++) {
    IParameter lambdaParam=this.parameters[i];
    IParameter param=method.getParameter(i);
    IType paramType=lambdaParam.getType();
    if (paramType == null) {
      continue;
    }
    if (!param.getType().equals(paramType)) {
      return false;
    }
  }
  this.type=type;
  this.method=method;
  return true;
}",0.7529249827942188
85015,"private void resolveSuperTypes(){
  this.superTypesResolved=true;
  if (this.superType != null) {
    this.superType=this.superType.resolve(null,Package.rootPackage);
  }
  for (int i=0; i < this.interfaceCount; i++) {
    this.interfaces[i]=this.interfaces[i].resolve(null,Package.rootPackage);
  }
  if (this.metadata == null) {
    this.metadata=IClass.getClassMetadata(this,this.modifiers);
  }
  this.metadata.resolve(null,Package.rootPackage);
}","private void resolveSuperTypes(){
  this.superTypesResolved=true;
  if (this.superType != null) {
    this.superType=this.superType.resolve(null,this);
  }
  for (int i=0; i < this.interfaceCount; i++) {
    this.interfaces[i]=this.interfaces[i].resolve(null,this);
  }
  if (this.metadata == null) {
    this.metadata=IClass.getClassMetadata(this,this.modifiers);
  }
  this.metadata.resolve(null,Package.rootPackage);
}",0.3853211009174312
85016,"private static IType readType(String desc,int start,int end){
  int array=0;
  while (desc.charAt(start) == '[') {
    array++;
    start++;
  }
switch (desc.charAt(start)) {
case 'V':
    return Types.VOID.getArrayType(array);
case 'Z':
  return Types.BOOLEAN.getArrayType(array);
case 'B':
return Types.BYTE.getArrayType(array);
case 'S':
return Types.SHORT.getArrayType(array);
case 'C':
return Types.CHAR.getArrayType(array);
case 'I':
return Types.INT.getArrayType(array);
case 'J':
return Types.LONG.getArrayType(array);
case 'F':
return Types.FLOAT.getArrayType(array);
case 'D':
return Types.DOUBLE.getArrayType(array);
case 'T':
{
String s=desc.substring(start + 1,end - 1);
return new Type(s,Name.getQualified(s));
}
case 'L':
return readReferenceType(desc,start + 1,end - 1);
}
return null;
}","private static IType readType(String desc,int start,int end){
  int array=0;
  while (desc.charAt(start) == '[') {
    array++;
    start++;
  }
switch (desc.charAt(start)) {
case 'V':
    return Types.VOID.getArrayType(array);
case 'Z':
  return Types.BOOLEAN.getArrayType(array);
case 'B':
return Types.BYTE.getArrayType(array);
case 'S':
return Types.SHORT.getArrayType(array);
case 'C':
return Types.CHAR.getArrayType(array);
case 'I':
return Types.INT.getArrayType(array);
case 'J':
return Types.LONG.getArrayType(array);
case 'F':
return Types.FLOAT.getArrayType(array);
case 'D':
return Types.DOUBLE.getArrayType(array);
case 'T':
{
String s=desc.substring(start + 1,end);
return new Type(s,Name.getQualified(s));
}
case 'L':
return readReferenceType(desc,start + 1,end);
}
return null;
}",0.9949937421777222
85017,"public static IToken tokenize(String code){
  int len=code.length();
  StringBuilder buf=new StringBuilder(20);
  IToken first=new InferredSemicolon(0,0);
  IToken prev=first;
  int start=0;
  int lineNumber=1;
  char l=0;
  char c=0;
  int type=0;
  int subtype=0;
  boolean addToken=false;
  boolean reparse=true;
  boolean string=false;
  for (int i=0; i < len; ++i, l=c) {
    c=code.charAt(i);
    if (type == 0) {
      start=i;
      if (c == '\n') {
        lineNumber++;
        continue;
      }
      if (c <= ' ') {
        continue;
      }
      if (string && c == '}') {
        type=STRING_2;
        subtype=STRING_PART;
        continue;
      }
      int m=getMode(c,code,i);
      type=m & 0xFFFF;
      subtype=m & 0xFFFF0000;
    }
switch (type) {
case IDENTIFIER:
      if (subtype == MOD_DOTS) {
        if (c == '.') {
          buf.append(c);
        }
 else {
          addToken=true;
          reparse=true;
        }
      }
 else       if (c == '_' || c == '$') {
        subtype=MOD_SYMBOL | MOD_LETTER;
        buf.append(c);
      }
 else {
        boolean letter=(subtype & MOD_LETTER) != 0;
        boolean symbol=(subtype & MOD_SYMBOL) != 0;
        if (letter) {
          if (isIdentifierPart(c)) {
            subtype=MOD_LETTER;
            buf.append(c);
            continue;
          }
        }
        if (symbol) {
          if (isIdentifierSymbol(c)) {
            subtype=MOD_SYMBOL;
            buf.append(c);
            continue;
          }
        }
        addToken=true;
      }
    break;
case SYMBOL:
  buf.append(c);
addToken=true;
reparse=false;
break;
case BRACKET:
buf.append(c);
addToken=true;
reparse=false;
break;
case COMMENT:
if (subtype == MOD_LINE) {
if (c == '\n') {
type=0;
lineNumber++;
continue;
}
}
 else if (subtype == MOD_BLOCK) {
if (c == '\n') {
lineNumber++;
}
 else if (l == '*' && c == '/') {
type=0;
continue;
}
}
break;
case INT:
case LONG:
if (c == '.') {
type=FLOAT;
buf.append('.');
}
 else if (c == 'l' || c == 'L') {
type=LONG;
addToken=true;
reparse=false;
}
 else if (subtype == MOD_DEC) {
if (isDigit(c)) {
buf.append(c);
}
 else if (c == 'f' || c == 'F') {
type=FLOAT;
addToken=true;
reparse=false;
}
 else if (c == 'd' || c == 'D') {
type=DOUBLE;
addToken=true;
reparse=false;
}
 else {
addToken=true;
}
}
 else if (subtype == MOD_BIN) {
if (c == 'b' || isBinDigit(c)) {
buf.append(c);
}
 else {
addToken=true;
}
}
 else if (subtype == MOD_OCT) {
if (isOctDigit(c)) {
buf.append(c);
}
 else {
addToken=true;
}
}
 else if (subtype == MOD_HEX) {
if (c == 'x' || isHexDigit(c)) {
buf.append(c);
}
 else {
addToken=true;
}
}
break;
case FLOAT:
case DOUBLE:
if (c == 'x') {
subtype=MOD_HEX;
buf.append(c);
}
 else if (c == 'f' || c == 'F') {
addToken=true;
reparse=false;
}
 else if (c == 'd' || c == 'D') {
type=DOUBLE;
addToken=true;
reparse=false;
}
 else if (isDigit(c) || c == '.' || c == 'e') {
buf.append(c);
}
 else {
addToken=true;
}
break;
case STRING:
if (c == '""' && buf.length() > 0) {
buf.append('""');
addToken=true;
reparse=false;
}
 else if (c == '\\' && appendEscape(buf,code.charAt(i + 1))) {
i++;
continue;
}
 else if (c != '\t') {
buf.append(c);
}
break;
case STRING_2:
if (c == '""' && (buf.length() > 1 || string)) {
if (!string && buf.charAt(0) == '@') {
subtype=STRING_2;
}
 else {
subtype=STRING_END;
}
string=false;
addToken=true;
reparse=false;
break;
}
 else if (c == '\\' && appendEscape(buf,code.charAt(i + 1))) {
i++;
continue;
}
 else if (c == '$' && code.charAt(i + 1) == '{') {
i+=2;
if (buf.charAt(0) == '@') {
subtype=STRING_START;
}
 else {
subtype=STRING_PART;
}
addToken=true;
string=true;
}
 else if (c != '\t') {
buf.append(c);
}
break;
case CHAR:
if (c == '\'' && buf.length() > 0) {
buf.append('\'');
addToken=true;
reparse=false;
}
 else if (c == '\\' && appendEscape(buf,code.charAt(i + 1))) {
i++;
continue;
}
 else if (c != '\t') {
buf.append(c);
}
break;
}
if (addToken) {
prev=addToken(prev,buf,type | subtype,lineNumber,start);
addToken=false;
type=0;
if (reparse) {
i--;
}
 else {
reparse=true;
}
}
}
if (buf.length() > 0) {
addToken(prev,buf,type | subtype,lineNumber,start);
}
return first.getNext();
}","public static IToken tokenize(String code){
  int len=code.length();
  StringBuilder buf=new StringBuilder(20);
  IToken first=new InferredSemicolon(0,0);
  IToken prev=first;
  int start=0;
  int lineNumber=1;
  char l=0;
  char c=0;
  int type=0;
  int subtype=0;
  boolean addToken=false;
  boolean reparse=true;
  boolean string=false;
  for (int i=0; i < len; ++i, l=c) {
    c=code.charAt(i);
    if (type == 0) {
      start=i;
      if (c == '\n') {
        lineNumber++;
        continue;
      }
      if (c <= ' ') {
        continue;
      }
      if (string && c == '}') {
        type=STRING_2;
        subtype=STRING_PART;
        continue;
      }
      int m=getMode(c,code,i);
      type=m & 0xFFFF;
      subtype=m & 0xFFFF0000;
    }
switch (type) {
case IDENTIFIER:
      if (subtype == MOD_DOTS) {
        if (c == '.') {
          buf.append(c);
        }
 else {
          addToken=true;
          reparse=true;
        }
      }
 else       if (c == '_' || c == '$') {
        subtype=MOD_SYMBOL | MOD_LETTER;
        buf.append(c);
      }
 else {
        boolean letter=(subtype & MOD_LETTER) != 0;
        boolean symbol=(subtype & MOD_SYMBOL) != 0;
        if (letter) {
          if (isIdentifierPart(c)) {
            subtype=MOD_LETTER;
            buf.append(c);
            continue;
          }
        }
        if (symbol) {
          if (isIdentifierSymbol(c)) {
            subtype=MOD_SYMBOL;
            buf.append(c);
            continue;
          }
        }
        addToken=true;
      }
    break;
case SYMBOL:
  buf.append(c);
addToken=true;
reparse=false;
break;
case BRACKET:
buf.append(c);
addToken=true;
reparse=false;
break;
case COMMENT:
if (subtype == MOD_LINE) {
if (c == '\n') {
type=0;
lineNumber++;
continue;
}
}
 else if (subtype == MOD_BLOCK) {
if (c == '\n') {
lineNumber++;
}
 else if (l == '*' && c == '/') {
type=0;
continue;
}
}
break;
case INT:
case LONG:
if (c == '.') {
type=FLOAT;
buf.append('.');
}
 else if (c == 'l' || c == 'L') {
type=LONG;
addToken=true;
reparse=false;
}
 else if (subtype == MOD_DEC) {
if (isDigit(c)) {
buf.append(c);
}
 else if (c == 'f' || c == 'F') {
type=FLOAT;
addToken=true;
reparse=false;
}
 else if (c == 'd' || c == 'D') {
type=DOUBLE;
addToken=true;
reparse=false;
}
 else {
addToken=true;
}
}
 else if (subtype == MOD_BIN) {
if (c == 'b' || isBinDigit(c)) {
buf.append(c);
}
 else {
addToken=true;
}
}
 else if (subtype == MOD_OCT) {
if (isOctDigit(c)) {
buf.append(c);
}
 else {
addToken=true;
}
}
 else if (subtype == MOD_HEX) {
if (c == 'x' || isHexDigit(c)) {
buf.append(c);
}
 else {
addToken=true;
}
}
break;
case FLOAT:
case DOUBLE:
if (c == 'x') {
subtype=MOD_HEX;
buf.append(c);
}
 else if (c == 'f' || c == 'F') {
addToken=true;
reparse=false;
}
 else if (c == 'd' || c == 'D') {
type=DOUBLE;
addToken=true;
reparse=false;
}
 else if (isDigit(c) || c == '.' || c == 'e') {
buf.append(c);
}
 else {
addToken=true;
}
break;
case STRING:
if (c == '""' && buf.length() > 0) {
buf.append('""');
addToken=true;
reparse=false;
}
 else if (c == '\\' && appendEscape(buf,code.charAt(i + 1))) {
i++;
continue;
}
 else if (c != '\t') {
buf.append(c);
}
break;
case STRING_2:
if (c == '""' && (buf.length() > 1 || string)) {
if (!string && buf.charAt(0) == '@') {
subtype=STRING_2;
}
 else {
subtype=STRING_END;
}
string=false;
addToken=true;
reparse=false;
break;
}
 else if (c == '\\' && appendEscape(buf,code.charAt(i + 1))) {
i++;
continue;
}
 else if (c == '$' && code.charAt(i + 1) == '{') {
i+=2;
if (buf.length() == 0 || buf.charAt(0) == '}') {
subtype=STRING_PART;
}
 else {
subtype=STRING_START;
}
addToken=true;
string=true;
}
 else if (c != '\t') {
buf.append(c);
}
break;
case CHAR:
if (c == '\'' && buf.length() > 0) {
buf.append('\'');
addToken=true;
reparse=false;
}
 else if (c == '\\' && appendEscape(buf,code.charAt(i + 1))) {
i++;
continue;
}
 else if (c != '\t') {
buf.append(c);
}
break;
}
if (addToken) {
prev=addToken(prev,buf,type | subtype,lineNumber,start);
addToken=false;
type=0;
if (reparse) {
i--;
}
 else {
reparse=true;
}
}
}
if (buf.length() > 0) {
addToken(prev,buf,type | subtype,lineNumber,start);
}
return first.getNext();
}",0.9888019265502708
85018,"@Override public void parse(IParserManager pm,IToken token) throws SyntaxError {
  int type=token.type();
  if (this.mode == 0) {
    if (this.value != null) {
      this.field.setValue(this.value);
    }
    pm.popParser(true);
    return;
  }
switch (type) {
case Symbols.SEMICOLON:
case Symbols.COMMA:
case Tokens.STRING_PART:
case Tokens.STRING_END:
    if (this.value != null) {
      this.field.setValue(this.value);
    }
  pm.popParser(true);
return;
}
if (this.mode == VALUE) {
if (type == Symbols.OPEN_PARENTHESIS) {
this.mode=TUPLE_END;
Tuple tv=new Tuple(token);
this.value=tv;
int nextType=token.next().type();
if (nextType != Symbols.CLOSE_PARENTHESIS) {
  pm.pushParser(new ExpressionListParser(tv));
}
return;
}
if (type == Symbols.OPEN_SQUARE_BRACKET) {
this.mode=ARRAY_END;
Array vl=new Array(token);
this.value=vl;
int nextType=token.next().type();
if (nextType != Symbols.CLOSE_SQUARE_BRACKET) {
  pm.pushParser(new ExpressionListParser(vl));
}
return;
}
if (type == Symbols.OPEN_CURLY_BRACKET) {
this.mode=LIST_END;
StatementList sl=new StatementList(token);
this.value=sl;
int nextType=token.next().type();
if (nextType != Symbols.CLOSE_CURLY_BRACKET) {
  pm.pushParser(new StatementListParser(sl));
}
return;
}
if (type == Tokens.SYMBOL_IDENTIFIER) {
if (token.nameValue() == Name.at && token.next().type() == Symbols.OPEN_CURLY_BRACKET) {
  Bytecode bc=new Bytecode(token);
  pm.skip();
  pm.pushParser(new BytecodeParser(bc));
  this.mode=BYTECODE_END;
  this.value=bc;
  return;
}
this.getAccess(pm,token.nameValue(),token,type);
return;
}
if ((type & Tokens.IDENTIFIER) != 0) {
this.getAccess(pm,token.nameValue(),token,type);
return;
}
if (this.parseKeyword(pm,token,type)) {
return;
}
this.mode=ACCESS;
}
if (this.mode == PATTERN_IF) {
this.mode=PATTERN_END;
if (type == Keywords.IF) {
pm.pushParser(new ExpressionParser(this));
return;
}
}
if (this.mode == PATTERN_END) {
if (type == Symbols.COLON) {
this.field.setValue(this.value);
pm.popParser();
if (token.next().type() != Keywords.CASE) {
  pm.pushParser(new ExpressionParser((IValued)this.value));
}
return;
}
throw new SyntaxError(token,""String_Node_Str"");
}
if (type == Symbols.COLON) {
if (this.value != null) {
this.field.setValue(this.value);
}
pm.popParser(true);
return;
}
if (this.mode == ARRAY_END) {
this.field.setValue(this.value);
this.value.expandPosition(token);
if (type == Symbols.CLOSE_SQUARE_BRACKET) {
this.mode=ACCESS;
return;
}
pm.popParser(true);
throw new SyntaxError(token,""String_Node_Str"");
}
if (this.mode == LIST_END) {
this.field.setValue(this.value);
this.value.expandPosition(token);
if (type == Symbols.CLOSE_CURLY_BRACKET) {
if (token.next().type() == Symbols.DOT) {
  this.mode=ACCESS_2;
  this.dotless=false;
  pm.skip();
  return;
}
pm.popParser();
return;
}
pm.popParser(true);
throw new SyntaxError(token,""String_Node_Str"");
}
if (this.mode == TUPLE_END) {
this.mode=ACCESS | LAMBDA;
if (type == Symbols.CLOSE_PARENTHESIS) {
this.value.expandPosition(token);
return;
}
throw new SyntaxError(token,""String_Node_Str"",true);
}
if (this.mode == PARAMETERS) {
this.mode=PARAMETERS_END;
if (type == Symbols.OPEN_PARENTHESIS) {
ICall call=(ICall)this.value;
call.setArguments(this.getArguments(pm,token.next()));
return;
}
throw new SyntaxError(token,""String_Node_Str"",true);
}
if (this.mode == PARAMETERS_END) {
this.mode=ACCESS;
this.value.expandPosition(token);
if (type == Symbols.CLOSE_PARENTHESIS) {
return;
}
throw new SyntaxError(token,""String_Node_Str"",true);
}
if (this.mode == CONSTRUCTOR_END) {
this.mode=ACCESS;
if (token.next().type() == Symbols.OPEN_CURLY_BRACKET) {
ClassConstructor cc=((ConstructorCall)this.value).toClassConstructor();
pm.skip();
pm.pushParser(new ClassBodyParser(cc.getNestedClass()));
this.value=cc;
this.mode=LIST_END;
return;
}
this.value.expandPosition(token);
if (type == Symbols.CLOSE_PARENTHESIS) {
return;
}
throw new SyntaxError(token,""String_Node_Str"",true);
}
if (this.mode == GENERICS) {
this.mode=GENERICS_END;
if (type == Symbols.OPEN_SQUARE_BRACKET) {
pm.pushParser(new TypeListParser((ITypeList)this.value));
return;
}
throw new SyntaxError(token,""String_Node_Str"");
}
if (this.mode == GENERICS_END) {
this.mode=ACCESS;
if (type == Symbols.CLOSE_SQUARE_BRACKET) {
return;
}
throw new SyntaxError(token,""String_Node_Str"");
}
if (this.mode == FUNCTION_POINTER) {
pm.popParser();
if (ParserUtil.isIdentifier(type)) {
FunctionPointer fl=new FunctionPointer(token.raw(),token.nameValue());
fl.instance=this.value;
this.field.setValue(fl);
return;
}
throw new SyntaxError(token,""String_Node_Str"");
}
if (this.mode == BYTECODE_END) {
this.field.setValue(this.value);
pm.popParser();
this.value.expandPosition(token);
if (type == Symbols.CLOSE_CURLY_BRACKET) {
return;
}
throw new SyntaxError(token,""String_Node_Str"",true);
}
if (ParserUtil.isCloseBracket(type)) {
if (this.value != null) {
this.field.setValue(this.value);
}
pm.popParser(true);
return;
}
if (this.isInMode(LAMBDA)) {
if (type == Symbols.ARROW_OPERATOR) {
LambdaExpression lv=getLambdaValue(this.value);
if (lv != null) {
  lv.expandPosition(token);
  this.field.setValue(lv);
  pm.popParser();
  pm.pushParser(new ExpressionParser(lv));
  return;
}
throw new SyntaxError(token,""String_Node_Str"");
}
}
if (this.isInMode(ACCESS)) {
if (type == Symbols.DOT) {
this.mode=ACCESS_2;
this.dotless=false;
return;
}
if (type == Symbols.HASH) {
this.mode=FUNCTION_POINTER;
return;
}
this.dotless=true;
this.mode=ACCESS_2;
if (type == Keywords.ELSE) {
this.field.setValue(this.value);
pm.popParser(true);
return;
}
if (type == Symbols.EQUALS) {
this.getAssign(pm,token);
return;
}
if (type == Symbols.OPEN_PARENTHESIS) {
IToken prev=token.prev();
IToken next=token.next();
IArguments args;
args=this.getArguments(pm,next);
int prevType=prev.type();
if (ParserUtil.isIdentifier(prevType)) {
  MethodCall mc=new MethodCall(prev,null,prev.nameValue());
  mc.arguments=args;
  this.value=mc;
}
 else if (prevType == Symbols.CLOSE_SQUARE_BRACKET) {
  MethodCall mc;
  if (this.value.getValueType() == IValue.FIELD_ACCESS) {
    mc=((FieldAccess)this.value).toMethodCall(null);
  }
 else {
    mc=(MethodCall)this.value;
  }
  mc.arguments=args;
  this.value=mc;
}
 else {
  ApplyMethodCall amc=new ApplyMethodCall(this.value.getPosition());
  amc.instance=this.value;
  amc.arguments=args;
  this.value=amc;
}
this.mode=PARAMETERS_END;
return;
}
}
if (this.isInMode(ACCESS_2)) {
if (ParserUtil.isIdentifier(type)) {
Name name=token.nameValue();
if (this.prefix) {
  this.field.setValue(this.value);
  pm.popParser(true);
  return;
}
if (this.dotless && this.operator != null) {
  Operator operator=pm.getOperator(name);
  int p=this.operator.precedence;
  if (p > operator.precedence) {
    this.field.setValue(this.value);
    pm.popParser(true);
    return;
  }
  if (p == operator.precedence) {
switch (operator.type) {
case Operator.INFIX_LEFT:
      this.field.setValue(this.value);
    pm.popParser(true);
  return;
case Operator.INFIX_NONE:
throw new SyntaxError(token,""String_Node_Str"" + name + ""String_Node_Str"");
case Operator.INFIX_RIGHT:
}
}
}
this.getAccess(pm,name,token,type);
return;
}
if (ParserUtil.isTerminator(type)) {
this.field.setValue(this.value);
pm.popParser(true);
return;
}
IToken prev=token.prev();
if (ParserUtil.isIdentifier(prev.type())) {
this.value=null;
pm.reparse();
this.getAccess(pm,prev.nameValue(),prev,type);
return;
}
if (this.value != null) {
ApplyMethodCall call=new ApplyMethodCall(token.raw());
call.instance=this.value;
SingleArgument sa=new SingleArgument();
call.arguments=sa;
this.value=call;
this.mode=0;
pm.pushParser(new ExpressionParser(sa),true);
return;
}
throw new SyntaxError(token,""String_Node_Str"" + token);
}
if (this.isInMode(CONSTRUCTOR)) {
ConstructorCall cc=(ConstructorCall)this.value;
if (type == Symbols.OPEN_CURLY_BRACKET) {
ClassConstructor cc2=cc.toClassConstructor();
pm.pushParser(new ClassBodyParser(cc2.getNestedClass()));
this.mode=LIST_END;
this.value=cc2;
return;
}
if (type == Symbols.OPEN_PARENTHESIS) {
ArgumentList list=new ArgumentList();
cc.arguments=list;
pm.pushParser(new ExpressionListParser(list));
this.mode=CONSTRUCTOR_END;
return;
}
SingleArgument sa=new SingleArgument();
cc.arguments=sa;
pm.pushParser(new ExpressionParser(sa),true);
this.mode=0;
return;
}
if (this.value != null) {
this.value.expandPosition(token);
this.field.setValue(this.value);
pm.popParser(true);
return;
}
throw new SyntaxError(token,""String_Node_Str"" + token);
}","@Override public void parse(IParserManager pm,IToken token) throws SyntaxError {
  int type=token.type();
  if (this.mode == 0) {
    if (this.value != null) {
      this.field.setValue(this.value);
    }
    pm.popParser(true);
    return;
  }
switch (type) {
case Symbols.SEMICOLON:
case Symbols.COMMA:
case Tokens.STRING_PART:
case Tokens.STRING_END:
    if (this.value != null) {
      this.field.setValue(this.value);
    }
  pm.popParser(true);
return;
}
if (this.mode == VALUE) {
if (type == Symbols.OPEN_PARENTHESIS) {
this.mode=TUPLE_END;
Tuple tv=new Tuple(token);
this.value=tv;
int nextType=token.next().type();
if (nextType != Symbols.CLOSE_PARENTHESIS) {
  pm.pushParser(new ExpressionListParser(tv));
}
return;
}
if (type == Symbols.OPEN_SQUARE_BRACKET) {
this.mode=ARRAY_END;
Array vl=new Array(token);
this.value=vl;
int nextType=token.next().type();
if (nextType != Symbols.CLOSE_SQUARE_BRACKET) {
  pm.pushParser(new ExpressionListParser(vl));
}
return;
}
if (type == Symbols.OPEN_CURLY_BRACKET) {
this.mode=LIST_END;
StatementList sl=new StatementList(token);
this.value=sl;
int nextType=token.next().type();
if (nextType != Symbols.CLOSE_CURLY_BRACKET) {
  pm.pushParser(new StatementListParser(sl));
}
return;
}
if (type == Tokens.SYMBOL_IDENTIFIER) {
if (token.nameValue() == Name.at && token.next().type() == Symbols.OPEN_CURLY_BRACKET) {
  Bytecode bc=new Bytecode(token);
  pm.skip();
  pm.pushParser(new BytecodeParser(bc));
  this.mode=BYTECODE_END;
  this.value=bc;
  return;
}
this.getAccess(pm,token.nameValue(),token,type);
return;
}
if ((type & Tokens.IDENTIFIER) != 0) {
this.getAccess(pm,token.nameValue(),token,type);
return;
}
if (this.parseKeyword(pm,token,type)) {
return;
}
this.mode=ACCESS;
}
if (this.mode == PATTERN_IF) {
this.mode=PATTERN_END;
if (type == Keywords.IF) {
pm.pushParser(new ExpressionParser(this));
return;
}
}
if (this.mode == PATTERN_END) {
if (type == Symbols.COLON) {
this.field.setValue(this.value);
pm.popParser();
if (token.next().type() != Keywords.CASE) {
  pm.pushParser(new ExpressionParser((IValued)this.value));
}
return;
}
throw new SyntaxError(token,""String_Node_Str"");
}
if (type == Symbols.COLON) {
if (this.value != null) {
this.field.setValue(this.value);
}
pm.popParser(true);
return;
}
if (this.mode == ARRAY_END) {
this.value.expandPosition(token);
if (type == Symbols.CLOSE_SQUARE_BRACKET) {
this.mode=ACCESS;
return;
}
this.field.setValue(this.value);
pm.popParser();
throw new SyntaxError(token,""String_Node_Str"");
}
if (this.mode == LIST_END) {
this.field.setValue(this.value);
this.value.expandPosition(token);
if (type == Symbols.CLOSE_CURLY_BRACKET) {
if (token.next().type() == Symbols.DOT) {
  this.mode=ACCESS_2;
  this.dotless=false;
  pm.skip();
  return;
}
pm.popParser();
return;
}
pm.popParser(true);
throw new SyntaxError(token,""String_Node_Str"");
}
if (this.mode == TUPLE_END) {
this.mode=ACCESS | LAMBDA;
if (type == Symbols.CLOSE_PARENTHESIS) {
this.value.expandPosition(token);
return;
}
throw new SyntaxError(token,""String_Node_Str"",true);
}
if (this.mode == PARAMETERS) {
this.mode=PARAMETERS_END;
if (type == Symbols.OPEN_PARENTHESIS) {
ICall call=(ICall)this.value;
call.setArguments(this.getArguments(pm,token.next()));
return;
}
throw new SyntaxError(token,""String_Node_Str"",true);
}
if (this.mode == PARAMETERS_END) {
this.mode=ACCESS;
this.value.expandPosition(token);
if (type == Symbols.CLOSE_PARENTHESIS) {
return;
}
throw new SyntaxError(token,""String_Node_Str"",true);
}
if (this.mode == CONSTRUCTOR_END) {
this.mode=ACCESS;
if (token.next().type() == Symbols.OPEN_CURLY_BRACKET) {
ClassConstructor cc=((ConstructorCall)this.value).toClassConstructor();
pm.skip();
pm.pushParser(new ClassBodyParser(cc.getNestedClass()));
this.value=cc;
this.mode=LIST_END;
return;
}
this.value.expandPosition(token);
if (type == Symbols.CLOSE_PARENTHESIS) {
return;
}
throw new SyntaxError(token,""String_Node_Str"",true);
}
if (this.mode == GENERICS) {
this.mode=GENERICS_END;
if (type == Symbols.OPEN_SQUARE_BRACKET) {
pm.pushParser(new TypeListParser((ITypeList)this.value));
return;
}
throw new SyntaxError(token,""String_Node_Str"");
}
if (this.mode == GENERICS_END) {
this.mode=ACCESS;
if (type == Symbols.CLOSE_SQUARE_BRACKET) {
return;
}
throw new SyntaxError(token,""String_Node_Str"");
}
if (this.mode == FUNCTION_POINTER) {
pm.popParser();
if (ParserUtil.isIdentifier(type)) {
FunctionPointer fl=new FunctionPointer(token.raw(),token.nameValue());
fl.instance=this.value;
this.field.setValue(fl);
return;
}
throw new SyntaxError(token,""String_Node_Str"");
}
if (this.mode == BYTECODE_END) {
this.field.setValue(this.value);
pm.popParser();
this.value.expandPosition(token);
if (type == Symbols.CLOSE_CURLY_BRACKET) {
return;
}
throw new SyntaxError(token,""String_Node_Str"",true);
}
if (ParserUtil.isCloseBracket(type)) {
if (this.value != null) {
this.field.setValue(this.value);
}
pm.popParser(true);
return;
}
if (this.isInMode(LAMBDA)) {
if (type == Symbols.ARROW_OPERATOR) {
LambdaExpression lv=getLambdaValue(this.value);
if (lv != null) {
  lv.expandPosition(token);
  this.field.setValue(lv);
  pm.popParser();
  pm.pushParser(new ExpressionParser(lv));
  return;
}
throw new SyntaxError(token,""String_Node_Str"");
}
}
if (this.isInMode(ACCESS)) {
if (type == Symbols.DOT) {
this.mode=ACCESS_2;
this.dotless=false;
return;
}
if (type == Symbols.HASH) {
this.mode=FUNCTION_POINTER;
return;
}
this.dotless=true;
this.mode=ACCESS_2;
if (type == Keywords.ELSE) {
this.field.setValue(this.value);
pm.popParser(true);
return;
}
if (type == Symbols.EQUALS) {
this.getAssign(pm,token);
return;
}
if (type == Symbols.OPEN_PARENTHESIS) {
IToken prev=token.prev();
IToken next=token.next();
IArguments args;
args=this.getArguments(pm,next);
int prevType=prev.type();
if (ParserUtil.isIdentifier(prevType)) {
  MethodCall mc=new MethodCall(prev,null,prev.nameValue());
  mc.arguments=args;
  this.value=mc;
}
 else if (prevType == Symbols.CLOSE_SQUARE_BRACKET) {
  MethodCall mc;
  if (this.value.getValueType() == IValue.FIELD_ACCESS) {
    mc=((FieldAccess)this.value).toMethodCall(null);
  }
 else {
    mc=(MethodCall)this.value;
  }
  mc.arguments=args;
  this.value=mc;
}
 else {
  ApplyMethodCall amc=new ApplyMethodCall(this.value.getPosition());
  amc.instance=this.value;
  amc.arguments=args;
  this.value=amc;
}
this.mode=PARAMETERS_END;
return;
}
}
if (this.isInMode(ACCESS_2)) {
if (ParserUtil.isIdentifier(type)) {
Name name=token.nameValue();
if (this.prefix) {
  this.field.setValue(this.value);
  pm.popParser(true);
  return;
}
if (this.dotless && this.operator != null) {
  Operator operator=pm.getOperator(name);
  int p=this.operator.precedence;
  if (p > operator.precedence) {
    this.field.setValue(this.value);
    pm.popParser(true);
    return;
  }
  if (p == operator.precedence) {
switch (operator.type) {
case Operator.INFIX_LEFT:
      this.field.setValue(this.value);
    pm.popParser(true);
  return;
case Operator.INFIX_NONE:
throw new SyntaxError(token,""String_Node_Str"" + name + ""String_Node_Str"");
case Operator.INFIX_RIGHT:
}
}
}
this.getAccess(pm,name,token,type);
return;
}
if (ParserUtil.isTerminator(type)) {
this.field.setValue(this.value);
pm.popParser(true);
return;
}
IToken prev=token.prev();
if (ParserUtil.isIdentifier(prev.type())) {
this.value=null;
pm.reparse();
this.getAccess(pm,prev.nameValue(),prev,type);
return;
}
if (this.value != null) {
ApplyMethodCall call=new ApplyMethodCall(token.raw());
call.instance=this.value;
SingleArgument sa=new SingleArgument();
call.arguments=sa;
this.value=call;
this.mode=0;
pm.pushParser(new ExpressionParser(sa),true);
return;
}
throw new SyntaxError(token,""String_Node_Str"" + token);
}
if (this.isInMode(CONSTRUCTOR)) {
ConstructorCall cc=(ConstructorCall)this.value;
if (type == Symbols.OPEN_CURLY_BRACKET) {
ClassConstructor cc2=cc.toClassConstructor();
pm.pushParser(new ClassBodyParser(cc2.getNestedClass()));
this.mode=LIST_END;
this.value=cc2;
return;
}
if (type == Symbols.OPEN_PARENTHESIS) {
ArgumentList list=new ArgumentList();
cc.arguments=list;
pm.pushParser(new ExpressionListParser(list));
this.mode=CONSTRUCTOR_END;
return;
}
SingleArgument sa=new SingleArgument();
cc.arguments=sa;
pm.pushParser(new ExpressionParser(sa),true);
this.mode=0;
return;
}
if (this.value != null) {
this.value.expandPosition(token);
this.field.setValue(this.value);
pm.popParser(true);
return;
}
throw new SyntaxError(token,""String_Node_Str"" + token);
}",0.994314143567875
85019,"@Override public IMethod getFunctionalMethod(){
  IMethod m;
  if (this.body != null) {
    m=this.body.getFunctionalMethod();
    if (m != null) {
      return m;
    }
  }
  m=this.superType.getFunctionalMethod();
  if (m != null) {
    return m;
  }
  for (int i=0; i < this.interfaceCount; i++) {
    m=this.interfaces[i].getFunctionalMethod();
    if (m != null) {
      return m;
    }
  }
  return null;
}","@Override public IMethod getFunctionalMethod(){
  IMethod m;
  if (this.body != null) {
    m=this.body.getFunctionalMethod();
    if (m != null) {
      return m;
    }
  }
  return null;
}",0.6312292358803987
85020,"@Override public void checkTypes(MarkerList markers,IContext context){
  IMethod match=IContext.resolveMethod(markers,this.type,null,Name.apply,this.argument);
  if (match == null) {
    IValue value=this.argument.getFirstValue();
    markers.add(value.getPosition(),""String_Node_Str"",value.getType().toString(),this.type.toString());
  }
 else {
    this.method=match;
  }
  this.argument.checkTypes(markers,context);
}","@Override public void checkTypes(MarkerList markers,IContext context){
  IMethod match=IContext.resolveMethod(markers,this.type,null,Name.apply,this.argument);
  if (match == null) {
    IValue value=this.argument.getFirstValue();
    markers.add(value.getPosition(),""String_Node_Str"",value.getType().toString(),this.type.toString());
  }
 else {
    this.method=match;
  }
  match.checkArguments(markers,null,this.argument,null);
  this.argument.checkTypes(markers,context);
}",0.9364548494983278
85021,"@Override public void addType(IType type){
  int index=this.upperBoundCount++;
  if (index >= this.upperBounds.length) {
    IType[] temp=new IType[this.upperBoundCount];
    System.arraycopy(this.upperBounds,0,temp,0,this.upperBounds.length);
    this.upperBounds=temp;
  }
  this.upperBounds[index]=type;
}","@Override public void addType(IType type){
  int index=this.upperBoundCount++;
  if (index >= this.upperBounds.length) {
    IType[] temp=new IType[this.upperBoundCount];
    System.arraycopy(this.upperBounds,0,temp,0,index);
    this.upperBounds=temp;
  }
  this.upperBounds[index]=type;
}",0.9531772575250836
85022,"@Override public void addUpperBound(IType bound){
  int index=this.upperBoundCount++;
  if (index >= this.upperBounds.length) {
    IType[] temp=new IType[this.upperBoundCount];
    System.arraycopy(this.upperBounds,0,temp,0,this.upperBounds.length);
    this.upperBounds=temp;
  }
  this.upperBounds[index]=bound;
}","@Override public void addUpperBound(IType bound){
  int index=this.upperBoundCount++;
  if (index >= this.upperBounds.length) {
    IType[] temp=new IType[this.upperBoundCount];
    System.arraycopy(this.upperBounds,0,temp,0,index);
    this.upperBounds=temp;
  }
  this.upperBounds[index]=bound;
}",0.9543973941368078
85023,"@Override public IType getSuperType(){
  return null;
}","@Override public IType getSuperType(){
  return this.arrayDimensions > 0 ? Types.OBJECT : null;
}",0.7236842105263158
85024,"@Override public IType getConcreteType(ITypeContext context){
  IType t=context.resolveType(this.typeVar);
  if (t != null) {
    if (this.arrayDimensions > 0) {
      return t.getArrayType(this.arrayDimensions);
    }
    if (t.isPrimitive()) {
      return t.getReferenceType();
    }
    return t;
  }
  return this;
}","@Override public IType getConcreteType(ITypeContext context){
  if (context == null) {
    return this;
  }
  IType t=context.resolveType(this.typeVar);
  if (t != null) {
    if (this.arrayDimensions > 0) {
      return t.getArrayType(this.arrayDimensions);
    }
    if (t.isPrimitive()) {
      return t.getReferenceType();
    }
    return t;
  }
  return this;
}",0.9331395348837208
85025,"public TypeVariableType(ITypeVariable typeVar){
  this.typeVar=typeVar;
}","public TypeVariableType(ITypeVariable typeVar,int arrayDimensions){
  this.typeVar=typeVar;
  this.arrayDimensions=arrayDimensions;
}",0.7087378640776699
85026,"@Override public int getArrayDimensions(){
  return 0;
}","@Override public int getArrayDimensions(){
  return this.arrayDimensions;
}",0.8396946564885496
85027,"@Override public void setArrayDimensions(int dimensions){
}","@Override public void setArrayDimensions(int dimensions){
  this.arrayDimensions=dimensions;
}",0.7712418300653595
85028,"@Override public boolean isArrayType(){
  return false;
}","@Override public boolean isArrayType(){
  return this.arrayDimensions > 0;
}",0.8120300751879699
85029,"@Override public void toString(String prefix,StringBuilder buffer){
  buffer.append(this.typeVar.getName());
}","@Override public void toString(String prefix,StringBuilder buffer){
  for (int i=0; i < this.arrayDimensions; i++) {
    buffer.append('[');
  }
  buffer.append(this.typeVar.getName());
  for (int i=0; i < this.arrayDimensions; i++) {
    buffer.append(']');
  }
}",0.5080213903743316
85030,"public default int getArrayStoreOpcode(){
  return Opcodes.ASTORE;
}","public default int getArrayStoreOpcode(){
  return Opcodes.AASTORE;
}",0.9927007299270072
85031,"@Override public IType resolve(MarkerList markers,IContext context){
  if (this.theClass != null) {
    return this;
  }
  IClass iclass;
  IType t=resolvePrimitive(this.name);
  if (t != null) {
    if (this.arrayDimensions == 0) {
      return t;
    }
    return t.getArrayType(this.arrayDimensions);
  }
 else   if (this.internalName != null) {
    iclass=Package.rootPackage.resolveInternalClass(this.internalName);
  }
 else {
    ITypeVariable typeVar=context.resolveTypeVariable(this.name);
    if (typeVar != null) {
      return new TypeVariableType(typeVar);
    }
    iclass=context.resolveClass(this.name);
  }
  if (iclass != null) {
    this.theClass=iclass;
    this.internalName=iclass.getInternalName();
    return this;
  }
  if (markers != null) {
    markers.add(this.position,""String_Node_Str"",this.toString());
  }
  return this;
}","@Override public IType resolve(MarkerList markers,IContext context){
  if (this.theClass != null) {
    return this;
  }
  IClass iclass;
  IType t=resolvePrimitive(this.name);
  if (t != null) {
    if (this.arrayDimensions == 0) {
      return t;
    }
    return t.getArrayType(this.arrayDimensions);
  }
 else   if (this.internalName != null) {
    iclass=Package.rootPackage.resolveInternalClass(this.internalName);
  }
 else {
    ITypeVariable typeVar=context.resolveTypeVariable(this.name);
    if (typeVar != null) {
      return new TypeVariableType(typeVar,this.arrayDimensions);
    }
    iclass=context.resolveClass(this.name);
  }
  if (iclass != null) {
    this.theClass=iclass;
    this.internalName=iclass.getInternalName();
    return this;
  }
  if (markers != null) {
    markers.add(this.position,""String_Node_Str"",this.toString());
  }
  return this;
}",0.9878542510121456
85032,"private static IType readType(String desc,int start,int end){
  int array=0;
  while (desc.charAt(start) == '[') {
    array++;
    start++;
  }
switch (desc.charAt(start)) {
case 'V':
    return Types.VOID.getArrayType(array);
case 'Z':
  return Types.BOOLEAN.getArrayType(array);
case 'B':
return Types.BYTE.getArrayType(array);
case 'S':
return Types.SHORT.getArrayType(array);
case 'C':
return Types.CHAR.getArrayType(array);
case 'I':
return Types.INT.getArrayType(array);
case 'J':
return Types.LONG.getArrayType(array);
case 'F':
return Types.FLOAT.getArrayType(array);
case 'D':
return Types.DOUBLE.getArrayType(array);
case 'L':
return readReferenceType(desc,start + 1,end - 1);
}
return null;
}","private static IType readType(String desc,int start,int end){
  int array=0;
  while (desc.charAt(start) == '[') {
    array++;
    start++;
  }
switch (desc.charAt(start)) {
case 'V':
    return Types.VOID.getArrayType(array);
case 'Z':
  return Types.BOOLEAN.getArrayType(array);
case 'B':
return Types.BYTE.getArrayType(array);
case 'S':
return Types.SHORT.getArrayType(array);
case 'C':
return Types.CHAR.getArrayType(array);
case 'I':
return Types.INT.getArrayType(array);
case 'J':
return Types.LONG.getArrayType(array);
case 'F':
return Types.FLOAT.getArrayType(array);
case 'D':
return Types.DOUBLE.getArrayType(array);
case 'T':
{
String s=desc.substring(start + 1,end - 1);
return new Type(s,Name.getQualified(s));
}
case 'L':
return readReferenceType(desc,start + 1,end - 1);
}
return null;
}",0.8891838088918381
85033,"@Override public IType resolve(MarkerList markers,IContext context){
  if (this.theClass != null) {
    return this;
  }
  IClass iclass;
  IType t=resolvePrimitive(this.name);
  if (t != null) {
    if (this.arrayDimensions == 0) {
      return t;
    }
    return t.getArrayType(this.arrayDimensions);
  }
 else   if (this.internalName != null) {
    iclass=Package.rootPackage.resolveInternalClass(this.internalName);
  }
 else {
    ITypeVariable typeVar=context.resolveTypeVariable(this.name);
    if (typeVar != null) {
      return new TypeVariableType(typeVar,this.arrayDimensions);
    }
    iclass=context.resolveClass(this.name);
  }
  if (iclass != null) {
    this.theClass=iclass;
    this.internalName=iclass.getInternalName();
    return this;
  }
  if (markers != null) {
    markers.add(this.position,""String_Node_Str"",this.toString());
  }
  return this;
}","@Override public IType resolve(MarkerList markers,IContext context){
  if (this.theClass != null) {
    return this;
  }
  IClass iclass;
  IType t=resolvePrimitive(this.name);
  if (t != null) {
    if (this.arrayDimensions == 0) {
      return t;
    }
    return t.getArrayType(this.arrayDimensions);
  }
  if (this.internalName != null) {
    iclass=Package.rootPackage.resolveInternalClass(this.internalName);
  }
 else {
    ITypeVariable typeVar=context.resolveTypeVariable(this.name);
    if (typeVar != null) {
      return new TypeVariableType(typeVar,this.arrayDimensions);
    }
    iclass=context.resolveClass(this.name);
  }
  if (iclass != null) {
    this.theClass=iclass;
    this.internalName=iclass.getInternalName();
    return this;
  }
  if (markers != null) {
    markers.add(this.position,""String_Node_Str"",this.toString());
  }
  return this;
}",0.9965596330275228
85034,"private static IType readType(String desc,int start,int end){
  int array=0;
  while (desc.charAt(start) == '[') {
    array++;
    start++;
  }
switch (desc.charAt(start)) {
case 'V':
    return Types.VOID.getArrayType(array);
case 'Z':
  return Types.BOOLEAN.getArrayType(array);
case 'B':
return Types.BYTE.getArrayType(array);
case 'S':
return Types.SHORT.getArrayType(array);
case 'C':
return Types.CHAR.getArrayType(array);
case 'I':
return Types.INT.getArrayType(array);
case 'J':
return Types.LONG.getArrayType(array);
case 'F':
return Types.FLOAT.getArrayType(array);
case 'D':
return Types.DOUBLE.getArrayType(array);
case 'T':
{
String s=desc.substring(start + 1,end);
return new Type(s,Name.getQualified(s));
}
case 'L':
return readReferenceType(desc,start + 1,end);
}
return null;
}","private static IType readType(String desc,int start,int end){
  int array=0;
  while (desc.charAt(start) == '[') {
    array++;
    start++;
  }
switch (desc.charAt(start)) {
case 'V':
    return Types.VOID.getArrayType(array);
case 'Z':
  return Types.BOOLEAN.getArrayType(array);
case 'B':
return Types.BYTE.getArrayType(array);
case 'S':
return Types.SHORT.getArrayType(array);
case 'C':
return Types.CHAR.getArrayType(array);
case 'I':
return Types.INT.getArrayType(array);
case 'J':
return Types.LONG.getArrayType(array);
case 'F':
return Types.FLOAT.getArrayType(array);
case 'D':
return Types.DOUBLE.getArrayType(array);
case 'T':
{
String s=desc.substring(start + 1,end);
return new Type(Name.getQualified(s));
}
case 'L':
return readReferenceType(desc,start + 1,end);
}
return null;
}",0.9987405541561712
85035,"@Override public ImmutableMap<K,V> $plus$plus(Map<? extends K,? extends V> map){
  return ((ImmutableMap<K,V>)map.immutable()).$plus(this.key,this.value);
}","@Override public ImmutableMap<K,V> $plus$plus(Map<? extends K,? extends V> map){
  int index=1;
  Tuple2<? extends K,? extends V>[] tuples=new Tuple2[1 + map.size()];
  tuples[0]=new Tuple2(this.key,this.value);
  for (  Tuple2<? extends K,? extends V> entry : map) {
    tuples[index++]=entry;
  }
  return new TupleMap(tuples,index);
}",0.4705882352941176
85036,"public HeaderComponent(ICodePosition position,boolean isStatic){
  this.position=position;
}","public HeaderComponent(ICodePosition position,boolean isStatic){
  this.position=position;
  this.isStatic=isStatic;
}",0.8761904761904762
85037,"@Override public void resolveTypes(MarkerList markers,IContext context,boolean using){
  if (using) {
    if (!(context instanceof IClass)) {
      markers.add(this.position,""String_Node_Str"");
      return;
    }
    this.theClass=(CodeClass)context;
    return;
  }
  this.thePackage=(Package)context;
}","@Override public void resolveTypes(MarkerList markers,IContext context,boolean using){
  if (using) {
    if (!(context instanceof IClass)) {
      markers.add(this.position,""String_Node_Str"");
      return;
    }
    this.theClass=(CodeClass)context;
    return;
  }
  if (!(context instanceof Package)) {
    markers.add(this.position,""String_Node_Str"");
    return;
  }
  this.thePackage=(Package)context;
}",0.8307692307692308
85038,"@Override public void writeStatement(MethodWriter writer){
  this.write(writer,false);
}","@Override public void writeStatement(MethodWriter writer){
  org.objectweb.asm.Label tryStart=new org.objectweb.asm.Label();
  org.objectweb.asm.Label tryEnd=new org.objectweb.asm.Label();
  org.objectweb.asm.Label endLabel=new org.objectweb.asm.Label();
  writer.writeLabel(tryStart);
  if (this.action != null) {
    this.action.writeStatement(writer);
    writer.writeJumpInsn(Opcodes.GOTO,endLabel);
  }
  writer.writeLabel(tryEnd);
  for (int i=0; i < this.catchBlockCount; i++) {
    CatchBlock block=this.catchBlocks[i];
    org.objectweb.asm.Label handlerLabel=new org.objectweb.asm.Label();
    if (block.variable != null) {
      int localCount=writer.registerLocal();
      writer.writeLabel(handlerLabel);
      writer.writeVarInsn(Opcodes.ASTORE,localCount);
      block.variable.index=localCount;
      block.action.writeStatement(writer);
      writer.resetLocals(localCount);
    }
 else {
      writer.writeLabel(handlerLabel);
      writer.writeInsn(Opcodes.POP);
      block.action.writeStatement(writer);
    }
    writer.writeTryCatchBlock(tryStart,tryEnd,handlerLabel,block.type.getInternalName());
    writer.writeJumpInsn(Opcodes.GOTO,endLabel);
  }
  if (this.finallyBlock != null) {
    org.objectweb.asm.Label finallyLabel=new org.objectweb.asm.Label();
    writer.writeLabel(finallyLabel);
    writer.writeInsn(Opcodes.POP);
    writer.writeLabel(endLabel);
    this.finallyBlock.writeStatement(writer);
    writer.writeFinallyBlock(tryStart,tryEnd,finallyLabel);
  }
 else {
    writer.writeLabel(endLabel);
  }
}",0.0846625766871165
85039,"@Override public void writeExpression(MethodWriter writer){
  if (this.finallyBlock == null) {
    IType type1=this.action.getType();
    for (int i=0; i < this.catchBlockCount; i++) {
      writer.getClassWriter().addCommonType(type1,this.catchBlocks[i].action.getType(),this.commonType);
    }
  }
  this.write(writer,true);
}","@Override public void writeExpression(MethodWriter writer){
  this.commonType.writeDefaultValue(writer);
}",0.4331797235023041
85040,"private static void findUnits(File source,File output,Package pack){
  if (source.isDirectory()) {
    String name=source.getName();
    for (    String s : source.list()) {
      findUnits(new CodeFile(source,s),new File(output,s),pack == null ? Package.rootPackage : pack.createSubPackage(name));
    }
    return;
  }
  String fileName=source.getPath();
  if (!config.compileFile(fileName)) {
    return;
  }
  if (fileName.endsWith(""String_Node_Str"") || fileName.endsWith(""String_Node_Str"")) {
    return;
  }
  files.add(output);
  if (fileName.endsWith(""String_Node_Str"")) {
    DWTFile dwt=new DWTFile(pack,(CodeFile)source,output);
    units.add(dwt);
    return;
  }
  if (fileName.endsWith(""String_Node_Str"")) {
    DyvilUnit unit=new DyvilUnit(pack,(CodeFile)source,output);
    pack.addCompilationUnit(unit);
    units.add(unit);
    return;
  }
  if (fileName.endsWith(""String_Node_Str"")) {
    DyvilHeader header=new DyvilHeader(pack,(CodeFile)source,output);
    pack.addCompilationUnit(header);
    units.add(0,header);
    return;
  }
}","private static void findUnits(File source,File output,Package pack){
  if (source.isDirectory()) {
    String name=source.getName();
    for (    String s : source.list()) {
      findUnits(new CodeFile(source,s),new File(output,s),pack == null ? Package.rootPackage : pack.createSubPackage(name));
    }
    return;
  }
  String fileName=source.getPath();
  if (!config.compileFile(fileName)) {
    return;
  }
  if (fileName.endsWith(""String_Node_Str"") || fileName.endsWith(""String_Node_Str"")) {
    return;
  }
  files.add(output);
  if (fileName.endsWith(""String_Node_Str"")) {
    DWTFile dwt=new DWTFile(pack,(CodeFile)source,output);
    units.add(dwt);
    return;
  }
  if (fileName.endsWith(""String_Node_Str"") || fileName.endsWith(""String_Node_Str"")) {
    DyvilUnit unit=new DyvilUnit(pack,(CodeFile)source,output);
    pack.addCompilationUnit(unit);
    units.add(unit);
    return;
  }
  if (fileName.endsWith(""String_Node_Str"")) {
    DyvilHeader header=new DyvilHeader(pack,(CodeFile)source,output);
    pack.addCompilationUnit(header);
    units.add(0,header);
    return;
  }
}",0.9813606710158436
85041,"@Override public void addResolveError(MarkerList markers){
  Marker marker;
  if (this.arguments.isEmpty()) {
    marker=markers.create(this.position,""String_Node_Str"",this.name.unqualified);
  }
 else {
    marker=markers.create(this.position,""String_Node_Str"",this.name.unqualified);
  }
  marker.addInfo(""String_Node_Str"" + this.name.qualified);
  if (this.instance != null) {
    marker.addInfo(""String_Node_Str"" + this.instance.getType());
  }
  StringBuilder builder=new StringBuilder(""String_Node_Str"");
  Util.typesToString(""String_Node_Str"",this.arguments,""String_Node_Str"",builder);
  marker.addInfo(builder.append('}').toString());
}","@Override public void addResolveError(MarkerList markers){
  Marker marker;
  if (this.arguments.isEmpty()) {
    marker=markers.create(this.position,""String_Node_Str"",this.name.unqualified);
  }
 else {
    marker=markers.create(this.position,""String_Node_Str"",this.name.unqualified);
  }
  marker.addInfo(""String_Node_Str"" + this.name.qualified);
  if (this.instance != null) {
    marker.addInfo(""String_Node_Str"" + this.instance.getType());
  }
  StringBuilder builder=new StringBuilder(""String_Node_Str"");
  Util.typesToString(""String_Node_Str"",this.arguments,""String_Node_Str"",builder);
  marker.addInfo(builder.toString());
}",0.9702194357366772
85042,"@Override public boolean addRawAnnotation(String type){
  if (""String_Node_Str"".equals(type)) {
    this.modifiers|=Modifiers.SEALED;
    return false;
  }
  if (""String_Node_Str"".equals(type)) {
    this.modifiers|=Modifiers.DEPRECATED;
    return false;
  }
  if (""String_Node_Str"".equals(type)) {
    this.modifiers|=Modifiers.FUNCTIONAL;
    return false;
  }
  return true;
}","@Override public boolean addRawAnnotation(String type){
switch (type) {
case ""String_Node_Str"":
    this.modifiers|=Modifiers.SEALED;
  return false;
case ""String_Node_Str"":
this.modifiers|=Modifiers.STRICT;
return false;
case ""String_Node_Str"":
this.modifiers|=Modifiers.DEPRECATED;
return false;
case ""String_Node_Str"":
this.modifiers|=Modifiers.FUNCTIONAL;
return false;
}
return true;
}",0.5116883116883116
85043,"@Override public boolean addRawAnnotation(String type){
  if (""String_Node_Str"".equals(type)) {
    this.modifiers|=Modifiers.LAZY;
    return false;
  }
  if (""String_Node_Str"".equals(type)) {
    this.modifiers|=Modifiers.SEALED;
    return false;
  }
  if (""String_Node_Str"".equals(type)) {
    this.modifiers|=Modifiers.DEPRECATED;
    return false;
  }
  return true;
}","@Override public boolean addRawAnnotation(String type){
switch (type) {
case ""String_Node_Str"":
    this.modifiers|=Modifiers.LAZY;
  return false;
case ""String_Node_Str"":
this.modifiers|=Modifiers.SEALED;
return false;
case ""String_Node_Str"":
this.modifiers|=Modifiers.TRANSIENT;
return false;
case ""String_Node_Str"":
this.modifiers|=Modifiers.VOLATILE;
return false;
case ""String_Node_Str"":
this.modifiers|=Modifiers.DEPRECATED;
return false;
}
return true;
}",0.4574850299401197
85044,"@Override public boolean addRawAnnotation(String type){
switch (type) {
case ""String_Node_Str"":
    this.modifiers|=Modifiers.INLINE;
  return false;
case ""String_Node_Str"":
this.modifiers|=Modifiers.INFIX;
return false;
case ""String_Node_Str"":
this.modifiers|=Modifiers.PREFIX;
return false;
case ""String_Node_Str"":
this.modifiers|=Modifiers.SEALED;
return false;
case ""String_Node_Str"":
this.modifiers|=Modifiers.DEPRECATED;
return false;
case ""String_Node_Str"":
this.modifiers|=Modifiers.OVERRIDE;
return false;
}
return true;
}","@Override public boolean addRawAnnotation(String type){
switch (type) {
case ""String_Node_Str"":
    this.modifiers|=Modifiers.INLINE;
  return false;
case ""String_Node_Str"":
this.modifiers|=Modifiers.INFIX;
return false;
case ""String_Node_Str"":
this.modifiers|=Modifiers.PREFIX;
return false;
case ""String_Node_Str"":
this.modifiers|=Modifiers.SEALED;
return false;
case ""String_Node_Str"":
this.modifiers|=Modifiers.NATIVE;
return false;
case ""String_Node_Str"":
this.modifiers|=Modifiers.STRICT;
return false;
case ""String_Node_Str"":
this.modifiers|=Modifiers.DEPRECATED;
return false;
case ""String_Node_Str"":
this.modifiers|=Modifiers.OVERRIDE;
return false;
}
return true;
}",0.8805970149253731
85045,"public static IValue resolve(MarkerList markers,IContext context,IAccess access){
  LinkedList<IAccess> chain=getCallChain(markers,context,access);
  ListIterator<IAccess> iterator=chain.listIterator();
  IAccess prev=null;
  IAccess curr=null;
  IValue alternate=null;
  boolean backwards=false;
  while (iterator.hasNext()) {
    prev=curr;
    curr=iterator.next();
    if (alternate != null) {
      curr.setValue(alternate);
      alternate=null;
    }
    if (!curr.resolve(context,markers)) {
      alternate=curr.resolve2(context);
      if (alternate instanceof IAccess) {
        curr=(IAccess)alternate;
        iterator.set(curr);
      }
 else       if (alternate != null) {
        if (!iterator.hasNext()) {
          return alternate;
        }
        iterator.remove();
        iterator.next().setValue(alternate);
        iterator.previous();
      }
 else {
        backwards=true;
        break;
      }
    }
  }
  if (!backwards) {
    return chain.getLast();
  }
 else   if (chain.size() == 1) {
    access.addResolveError(markers);
    return access;
  }
  IAccess next=null;
  curr=access;
  prev=null;
  while (curr != null) {
    IValue value=curr.getValue();
    if (value instanceof IAccess) {
      prev=(IAccess)value;
    }
 else {
      prev=null;
    }
    if (next != null && (!curr.isResolved() || !next.isResolved())) {
      next.setValue(null);
      if (next.resolve(context,markers)) {
        alternate=curr.resolve3(context,next);
        if (alternate instanceof IAccess) {
          if (next.getValue() == curr) {
            next.setValue(alternate);
          }
          next=(IAccess)alternate;
          curr=prev;
          if (iterator.hasNext()) {
            iterator.next();
            iterator.remove();
            iterator.previous();
            iterator.set(next);
          }
 else {
            iterator.set(next);
          }
        }
 else {
          next.setValue(curr);
          curr.addResolveError(markers);
        }
      }
 else {
        next.setValue(curr);
        curr.addResolveError(markers);
      }
    }
    next=curr;
    curr=prev;
  }
  return chain.getLast();
}","public static IValue resolve(MarkerList markers,IContext context,IAccess access){
  LinkedList<IAccess> chain=getCallChain(markers,context,access);
  ListIterator<IAccess> iterator=chain.listIterator();
  IAccess prev=null;
  IAccess curr=null;
  IValue alternate=null;
  boolean backwards=false;
  while (iterator.hasNext()) {
    prev=curr;
    curr=iterator.next();
    if (alternate != null) {
      curr.setValue(alternate);
      alternate=null;
    }
    if (!curr.resolve(context,markers)) {
      alternate=curr.resolve2(context);
      if (alternate instanceof IAccess) {
        curr=(IAccess)alternate;
        iterator.set(curr);
      }
 else       if (alternate != null) {
        if (!iterator.hasNext()) {
          return alternate;
        }
        iterator.remove();
        iterator.next().setValue(alternate);
        iterator.previous();
      }
 else {
        backwards=true;
        break;
      }
    }
  }
  if (!backwards) {
    return chain.getLast();
  }
 else   if (chain.size() == 1) {
    access.addResolveError(markers);
    return access;
  }
  IAccess next=null;
  curr=access;
  prev=null;
  while (curr != null) {
    IValue value=curr.getValue();
    if (value instanceof IAccess) {
      prev=(IAccess)value;
    }
 else {
      prev=null;
    }
    if (next != null && (!curr.isResolved() || !next.isResolved())) {
      next.setValue(null);
      if (next.resolve(context,markers)) {
        alternate=curr.resolve3(context,next);
        if (alternate instanceof IAccess) {
          if (next.getValue() == curr) {
            next.setValue(alternate);
          }
          next=(IAccess)alternate;
          curr=prev;
          if (iterator.hasNext()) {
            iterator.next();
            iterator.remove();
            iterator.previous();
            iterator.set(next);
          }
 else {
            iterator.set(next);
          }
        }
 else {
          next.setValue(curr);
          next.addResolveError(markers);
        }
      }
 else {
        next.setValue(curr);
        next.addResolveError(markers);
      }
    }
    next=curr;
    curr=prev;
  }
  return chain.getLast();
}",0.9962790697674418
85046,"@Override public IValue resolve(MarkerList markers,IContext context){
  int args=this.arguments.size();
  if (this.instance != null) {
    this.instance.resolve(markers,context);
  }
  if (args == 1 && this.name == Name.match) {
    MatchExpression me=Operators.getMatchExpression(this.instance,this.arguments.getFirstValue());
    if (me != null) {
      me.position=this.position;
      return me.resolve(markers,context);
    }
  }
  this.arguments.resolve(markers,context);
  if (args == 1) {
    IValue argument=this.arguments.getFirstValue();
    IValue op;
    if (this.instance != null) {
      op=Operators.get(this.instance,this.name,argument);
    }
 else {
      op=Operators.get(this.name,argument);
    }
    if (op != null) {
      op.setPosition(this.position);
      return op;
    }
  }
  IMethod method=ICall.resolveMethod(markers,context,this.instance,this.name,this.arguments);
  if (method != null) {
    this.method=method;
    return this;
  }
  if (args == 1 && this.instance != null) {
    String qualified=this.name.qualified;
    if (qualified.endsWith(""String_Node_Str"")) {
      String unqualified=this.name.unqualified;
      Name name=Name.get(qualified.substring(0,qualified.length() - 3),unqualified.substring(0,unqualified.length() - 1));
      IMethod method1=IContext.resolveMethod(markers,this.instance.getType(),null,name,this.arguments);
      if (method1 != null) {
        CompoundCall call=new CompoundCall(this.position);
        call.method=method1;
        call.instance=this.instance;
        call.arguments=this.arguments;
        call.name=name;
        return call;
      }
    }
  }
  if (args == 0) {
    IField field=ICall.resolveField(context,this.instance,this.name);
    if (field != null) {
      FieldAccess access=new FieldAccess(this.position);
      access.field=field;
      access.instance=this.instance;
      access.name=this.name;
      access.dotless=this.dotless;
      return access;
    }
  }
 else   if (this.instance == null) {
    IValue apply=this.resolveApply(markers,context);
    if (apply != null) {
      return apply;
    }
  }
  Marker marker;
  if (this.arguments.isEmpty()) {
    marker=markers.create(this.position,""String_Node_Str"",this.name.unqualified);
  }
 else {
    marker=markers.create(this.position,""String_Node_Str"",this.name.unqualified);
  }
  marker.addInfo(""String_Node_Str"" + this.name.qualified);
  if (this.instance != null) {
    marker.addInfo(""String_Node_Str"" + this.instance.getType());
  }
  StringBuilder builder=new StringBuilder(""String_Node_Str"");
  Util.typesToString(""String_Node_Str"",this.arguments,""String_Node_Str"",builder);
  marker.addInfo(builder.toString());
  return this;
}","@Override public IValue resolve(MarkerList markers,IContext context){
  int args=this.arguments.size();
  if (this.instance != null) {
    this.instance=this.instance.resolve(markers,context);
  }
  if (args == 1 && this.name == Name.match) {
    MatchExpression me=Operators.getMatchExpression(this.instance,this.arguments.getFirstValue());
    if (me != null) {
      me.position=this.position;
      return me.resolve(markers,context);
    }
  }
  this.arguments.resolve(markers,context);
  if (args == 1) {
    IValue argument=this.arguments.getFirstValue();
    IValue op;
    if (this.instance != null) {
      op=Operators.get(this.instance,this.name,argument);
    }
 else {
      op=Operators.get(this.name,argument);
    }
    if (op != null) {
      op.setPosition(this.position);
      return op;
    }
  }
  IMethod method=ICall.resolveMethod(markers,context,this.instance,this.name,this.arguments);
  if (method != null) {
    this.method=method;
    return this;
  }
  if (args == 1 && this.instance != null) {
    String qualified=this.name.qualified;
    if (qualified.endsWith(""String_Node_Str"")) {
      String unqualified=this.name.unqualified;
      Name name=Name.get(qualified.substring(0,qualified.length() - 3),unqualified.substring(0,unqualified.length() - 1));
      IMethod method1=IContext.resolveMethod(markers,this.instance.getType(),null,name,this.arguments);
      if (method1 != null) {
        CompoundCall call=new CompoundCall(this.position);
        call.method=method1;
        call.instance=this.instance;
        call.arguments=this.arguments;
        call.name=name;
        return call;
      }
    }
  }
  if (args == 0) {
    IField field=ICall.resolveField(context,this.instance,this.name);
    if (field != null) {
      FieldAccess access=new FieldAccess(this.position);
      access.field=field;
      access.instance=this.instance;
      access.name=this.name;
      access.dotless=this.dotless;
      return access;
    }
  }
 else   if (this.instance == null) {
    IValue apply=this.resolveApply(markers,context);
    if (apply != null) {
      return apply;
    }
  }
  Marker marker;
  if (this.arguments.isEmpty()) {
    marker=markers.create(this.position,""String_Node_Str"",this.name.unqualified);
  }
 else {
    marker=markers.create(this.position,""String_Node_Str"",this.name.unqualified);
  }
  marker.addInfo(""String_Node_Str"" + this.name.qualified);
  if (this.instance != null) {
    marker.addInfo(""String_Node_Str"" + this.instance.getType());
  }
  StringBuilder builder=new StringBuilder(""String_Node_Str"");
  Util.typesToString(""String_Node_Str"",this.arguments,""String_Node_Str"",builder);
  marker.addInfo(builder.toString());
  return this;
}",0.9974102848686645
85047,"@Override public void writeInvJump(MethodWriter writer,Label dest,IValue instance,IArguments arguments){
  if ((this.modifiers & Modifiers.STATIC) != 0) {
    if (instance != null && instance.getValueType() == IValue.CLASS_ACCESS) {
      instance=null;
    }
    if (this.intrinsicOpcodes != null) {
      this.writeInvIntrinsic(writer,dest,instance,arguments);
      return;
    }
  }
 else   if (this.intrinsicOpcodes != null && instance.isPrimitive()) {
    this.writeInvIntrinsic(writer,dest,instance,arguments);
    return;
  }
  if ((this.modifiers & INLINABLE) != 0 && writer.inlineOffset() < INLINE_TRESHOLD) {
  }
  this.writeInvoke(writer,instance,arguments);
  writer.writeJumpInsn(IFNE,dest);
}","@Override public void writeInvJump(MethodWriter writer,Label dest,IValue instance,IArguments arguments){
  if ((this.modifiers & Modifiers.STATIC) != 0) {
    if (instance != null && instance.getValueType() == IValue.CLASS_ACCESS) {
      instance=null;
    }
    if (this.intrinsicOpcodes != null) {
      this.writeInvIntrinsic(writer,dest,instance,arguments);
      return;
    }
  }
 else   if (this.intrinsicOpcodes != null && (instance == null || instance.isPrimitive())) {
    this.writeInvIntrinsic(writer,dest,instance,arguments);
    return;
  }
  if ((this.modifiers & INLINABLE) != 0 && writer.inlineOffset() < INLINE_TRESHOLD) {
  }
  this.writeInvoke(writer,instance,arguments);
  writer.writeJumpInsn(IFNE,dest);
}",0.9846796657381616
85048,"@Override public void writeJump(MethodWriter writer,Label dest,IValue instance,IArguments arguments){
  if ((this.modifiers & Modifiers.STATIC) != 0) {
    if (instance != null && instance.getValueType() == IValue.CLASS_ACCESS) {
      instance=null;
    }
    if (this.intrinsicOpcodes != null) {
      this.writeIntrinsic(writer,dest,instance,arguments);
      return;
    }
  }
 else   if (this.intrinsicOpcodes != null && instance.isPrimitive()) {
    this.writeIntrinsic(writer,dest,instance,arguments);
    return;
  }
  if ((this.modifiers & INLINABLE) != 0 && writer.inlineOffset() < INLINE_TRESHOLD) {
  }
  this.writeInvoke(writer,instance,arguments);
  writer.writeJumpInsn(IFEQ,dest);
}","@Override public void writeJump(MethodWriter writer,Label dest,IValue instance,IArguments arguments){
  if ((this.modifiers & Modifiers.STATIC) != 0) {
    if (instance != null && instance.getValueType() == IValue.CLASS_ACCESS) {
      instance=null;
    }
    if (this.intrinsicOpcodes != null) {
      this.writeIntrinsic(writer,dest,instance,arguments);
      return;
    }
  }
 else   if (this.intrinsicOpcodes != null && (instance == null || instance.isPrimitive())) {
    this.writeIntrinsic(writer,dest,instance,arguments);
    return;
  }
  if ((this.modifiers & INLINABLE) != 0 && writer.inlineOffset() < INLINE_TRESHOLD) {
  }
  this.writeInvoke(writer,instance,arguments);
  writer.writeJumpInsn(IFEQ,dest);
}",0.9844851904090268
85049,"@Override public void writeCall(MethodWriter writer,IValue instance,IArguments arguments,IType type){
  if ((this.modifiers & Modifiers.STATIC) != 0) {
    if (instance != null && instance.getValueType() == IValue.CLASS_ACCESS) {
      instance=null;
    }
    if (this.intrinsicOpcodes != null) {
      this.writeIntrinsic(writer,instance,arguments);
      return;
    }
  }
 else   if (this.intrinsicOpcodes != null && instance.isPrimitive()) {
    this.writeIntrinsic(writer,instance,arguments);
    return;
  }
  if ((this.modifiers & INLINABLE) != 0 && writer.inlineOffset() < INLINE_TRESHOLD) {
  }
  this.writeInvoke(writer,instance,arguments);
  if (type == Types.VOID) {
    if (this.type != Types.VOID) {
      writer.writeInsn(Opcodes.POP);
    }
    return;
  }
  if (type != null) {
    if (type != this.type && !type.isSuperTypeOf(this.type)) {
      writer.writeTypeInsn(Opcodes.CHECKCAST,this.type.getInternalName());
    }
  }
}","@Override public void writeCall(MethodWriter writer,IValue instance,IArguments arguments,IType type){
  if ((this.modifiers & Modifiers.STATIC) != 0) {
    if (instance != null && instance.getValueType() == IValue.CLASS_ACCESS) {
      instance=null;
    }
    if (this.intrinsicOpcodes != null) {
      this.writeIntrinsic(writer,instance,arguments);
      return;
    }
  }
 else   if (this.intrinsicOpcodes != null && (instance == null || instance.isPrimitive())) {
    this.writeIntrinsic(writer,instance,arguments);
    return;
  }
  if ((this.modifiers & INLINABLE) != 0 && writer.inlineOffset() < INLINE_TRESHOLD) {
  }
  this.writeInvoke(writer,instance,arguments);
  if (type == Types.VOID) {
    if (this.type != Types.VOID) {
      writer.writeInsn(Opcodes.POP);
    }
    return;
  }
  if (type != null) {
    if (type != this.type && !type.isSuperTypeOf(this.type)) {
      writer.writeTypeInsn(Opcodes.CHECKCAST,this.type.getInternalName());
    }
  }
}",0.9884937238493724
85050,"public static IToken tokenize(String code){
  int len=code.length();
  StringBuilder buf=new StringBuilder(20);
  IToken first=new InferredSemicolon(0,0);
  IToken prev=first;
  int start=0;
  int lineNumber=1;
  char l=0;
  char c=0;
  int type=0;
  int subtype=0;
  boolean addToken=false;
  boolean reparse=true;
  boolean string=false;
  for (int i=0; i < len; ++i, l=c) {
    c=code.charAt(i);
    if (type == 0) {
      start=i;
      if (c == '\n') {
        lineNumber++;
        continue;
      }
      if (c <= ' ') {
        continue;
      }
      if (string && l == '}') {
        type=STRING_START;
        subtype=STRING_PART;
      }
 else {
        int m=getMode(c,code,i);
        type=m & 0xFFFF;
        subtype=m & 0xFFFF0000;
      }
    }
switch (type) {
case IDENTIFIER:
      if (subtype == MOD_DOTS) {
        if (c == '.') {
          buf.append(c);
        }
 else {
          addToken=true;
          reparse=true;
        }
      }
 else       if (c == '_' || c == '$') {
        subtype=MOD_SYMBOL | MOD_LETTER;
        buf.append(c);
      }
 else {
        boolean letter=(subtype & MOD_LETTER) != 0;
        boolean symbol=(subtype & MOD_SYMBOL) != 0;
        if (letter) {
          if (isIdentifierPart(c)) {
            subtype=MOD_LETTER;
            buf.append(c);
            continue;
          }
        }
        if (symbol) {
          if (isIdentifierSymbol(c)) {
            subtype=MOD_SYMBOL;
            buf.append(c);
            continue;
          }
        }
        addToken=true;
      }
    break;
case SYMBOL:
  buf.append(c);
addToken=true;
reparse=false;
break;
case BRACKET:
buf.append(c);
addToken=true;
reparse=false;
break;
case COMMENT:
if (subtype == MOD_LINE) {
if (c == '\n') {
type=0;
continue;
}
}
 else if (subtype == MOD_BLOCK) {
if (l == '*' && c == '/') {
type=0;
continue;
}
}
break;
case INT:
case LONG:
if (c == '.') {
type=FLOAT;
buf.append('.');
}
 else if (c == 'l' || c == 'L') {
type=LONG;
addToken=true;
reparse=false;
}
 else if (subtype == MOD_DEC) {
if (isDigit(c)) {
buf.append(c);
}
 else if (c == 'f' || c == 'F') {
type=FLOAT;
addToken=true;
reparse=false;
}
 else if (c == 'd' || c == 'D') {
type=DOUBLE;
addToken=true;
reparse=false;
}
 else {
addToken=true;
}
}
 else if (subtype == MOD_BIN) {
if (c == 'b' || isBinDigit(c)) {
buf.append(c);
}
 else {
addToken=true;
}
}
 else if (subtype == MOD_OCT) {
if (isOctDigit(c)) {
buf.append(c);
}
 else {
addToken=true;
}
}
 else if (subtype == MOD_HEX) {
if (c == 'x' || isHexDigit(c)) {
buf.append(c);
}
 else {
addToken=true;
}
}
break;
case FLOAT:
case DOUBLE:
if (c == 'x') {
subtype=MOD_HEX;
buf.append(c);
}
 else if (c == 'f' || c == 'F') {
addToken=true;
reparse=false;
}
 else if (c == 'd' || c == 'D') {
type=DOUBLE;
addToken=true;
reparse=false;
}
 else if (isDigit(c) || c == '.' || c == 'e') {
buf.append(c);
}
 else {
addToken=true;
}
break;
case STRING:
if (c == '""' && buf.length() > 0) {
buf.append('""');
addToken=true;
reparse=false;
}
 else if (c == '\\' && appendEscape(buf,code.charAt(i + 1))) {
i++;
continue;
}
 else {
buf.append(c);
}
break;
case STRING_START:
if (c == '""' && (buf.length() > 1 || string)) {
buf.append('""');
subtype=STRING_END;
string=false;
addToken=true;
reparse=false;
break;
}
 else if (c == '\\' && appendEscape(buf,code.charAt(i + 1))) {
i++;
continue;
}
 else if (c == '$' && code.charAt(i + 1) == '{') {
i+=2;
buf.append(""String_Node_Str"");
addToken=true;
string=true;
}
 else {
buf.append(c);
}
break;
case CHAR:
if (c == '\'' && buf.length() > 0) {
buf.append('\'');
addToken=true;
reparse=false;
}
 else if (c == '\\' && appendEscape(buf,code.charAt(i + 1))) {
i++;
continue;
}
 else {
buf.append(c);
}
break;
}
if (addToken) {
prev=addToken(prev,buf,type | subtype,lineNumber,start);
addToken=false;
type=0;
if (reparse) {
i--;
}
 else {
reparse=true;
}
}
}
if (buf.length() > 0) {
addToken(prev,buf,type | subtype,lineNumber,start);
}
return first.getNext();
}","public static IToken tokenize(String code){
  int len=code.length();
  StringBuilder buf=new StringBuilder(20);
  IToken first=new InferredSemicolon(0,0);
  IToken prev=first;
  int start=0;
  int lineNumber=1;
  char l=0;
  char c=0;
  int type=0;
  int subtype=0;
  boolean addToken=false;
  boolean reparse=true;
  boolean string=false;
  for (int i=0; i < len; ++i, l=c) {
    c=code.charAt(i);
    if (type == 0) {
      start=i;
      if (c == '\n') {
        lineNumber++;
        continue;
      }
      if (c <= ' ') {
        continue;
      }
      if (string && c == '}') {
        type=STRING_START;
        subtype=STRING_PART;
        continue;
      }
      int m=getMode(c,code,i);
      type=m & 0xFFFF;
      subtype=m & 0xFFFF0000;
    }
switch (type) {
case IDENTIFIER:
      if (subtype == MOD_DOTS) {
        if (c == '.') {
          buf.append(c);
        }
 else {
          addToken=true;
          reparse=true;
        }
      }
 else       if (c == '_' || c == '$') {
        subtype=MOD_SYMBOL | MOD_LETTER;
        buf.append(c);
      }
 else {
        boolean letter=(subtype & MOD_LETTER) != 0;
        boolean symbol=(subtype & MOD_SYMBOL) != 0;
        if (letter) {
          if (isIdentifierPart(c)) {
            subtype=MOD_LETTER;
            buf.append(c);
            continue;
          }
        }
        if (symbol) {
          if (isIdentifierSymbol(c)) {
            subtype=MOD_SYMBOL;
            buf.append(c);
            continue;
          }
        }
        addToken=true;
      }
    break;
case SYMBOL:
  buf.append(c);
addToken=true;
reparse=false;
break;
case BRACKET:
buf.append(c);
addToken=true;
reparse=false;
break;
case COMMENT:
if (subtype == MOD_LINE) {
if (c == '\n') {
type=0;
continue;
}
}
 else if (subtype == MOD_BLOCK) {
if (l == '*' && c == '/') {
type=0;
continue;
}
}
break;
case INT:
case LONG:
if (c == '.') {
type=FLOAT;
buf.append('.');
}
 else if (c == 'l' || c == 'L') {
type=LONG;
addToken=true;
reparse=false;
}
 else if (subtype == MOD_DEC) {
if (isDigit(c)) {
buf.append(c);
}
 else if (c == 'f' || c == 'F') {
type=FLOAT;
addToken=true;
reparse=false;
}
 else if (c == 'd' || c == 'D') {
type=DOUBLE;
addToken=true;
reparse=false;
}
 else {
addToken=true;
}
}
 else if (subtype == MOD_BIN) {
if (c == 'b' || isBinDigit(c)) {
buf.append(c);
}
 else {
addToken=true;
}
}
 else if (subtype == MOD_OCT) {
if (isOctDigit(c)) {
buf.append(c);
}
 else {
addToken=true;
}
}
 else if (subtype == MOD_HEX) {
if (c == 'x' || isHexDigit(c)) {
buf.append(c);
}
 else {
addToken=true;
}
}
break;
case FLOAT:
case DOUBLE:
if (c == 'x') {
subtype=MOD_HEX;
buf.append(c);
}
 else if (c == 'f' || c == 'F') {
addToken=true;
reparse=false;
}
 else if (c == 'd' || c == 'D') {
type=DOUBLE;
addToken=true;
reparse=false;
}
 else if (isDigit(c) || c == '.' || c == 'e') {
buf.append(c);
}
 else {
addToken=true;
}
break;
case STRING:
if (c == '""' && buf.length() > 0) {
buf.append('""');
addToken=true;
reparse=false;
}
 else if (c == '\\' && appendEscape(buf,code.charAt(i + 1))) {
i++;
continue;
}
 else if (c != '\t') {
buf.append(c);
}
break;
case STRING_START:
if (c == '""' && (buf.length() > 1 || string)) {
subtype=STRING_END;
string=false;
addToken=true;
reparse=false;
break;
}
 else if (c == '\\' && appendEscape(buf,code.charAt(i + 1))) {
i++;
continue;
}
 else if (c == '$' && code.charAt(i + 1) == '{') {
i+=2;
addToken=true;
string=true;
}
 else if (c != '\t') {
buf.append(c);
}
break;
case CHAR:
if (c == '\'' && buf.length() > 0) {
buf.append('\'');
addToken=true;
reparse=false;
}
 else if (c == '\\' && appendEscape(buf,code.charAt(i + 1))) {
i++;
continue;
}
 else if (c != '\t') {
buf.append(c);
}
break;
}
if (addToken) {
prev=addToken(prev,buf,type | subtype,lineNumber,start);
addToken=false;
type=0;
if (reparse) {
i--;
}
 else {
reparse=true;
}
}
}
if (buf.length() > 0) {
addToken(prev,buf,type | subtype,lineNumber,start);
}
return first.getNext();
}",0.9748005571736102
85051,"@Override public void parse(IParserManager pm,IToken token) throws SyntaxError {
  int type=token.type();
switch (type) {
case Tokens.STRING_START:
case Tokens.STRING_PART:
    this.value.addString(token.stringValue());
  pm.pushParser(new ExpressionParser(this));
return;
case Tokens.STRING_END:
this.value.addString(token.stringValue());
pm.popParser();
return;
}
throw new SyntaxError(token,""String_Node_Str"");
}","@Override public void parse(IParserManager pm,IToken token) throws SyntaxError {
  int type=token.type();
switch (type) {
case Tokens.STRING_START:
case Tokens.STRING_PART:
{
      int nextType=token.next().type();
      if (nextType == Tokens.STRING_PART || nextType == Tokens.STRING_END) {
        throw new SyntaxError(token.next(),""String_Node_Str"");
      }
      this.value.addString(token.stringValue());
      pm.pushParser(new ExpressionParser(this));
      return;
    }
case Tokens.STRING_END:
  this.value.addString(token.stringValue());
pm.popParser();
return;
}
throw new SyntaxError(token,""String_Node_Str"");
}",0.7846153846153846
85052,"@Override public void toString(String prefix,StringBuilder buffer){
  buffer.append(Formatting.Statements.forStart);
  if (this.type != 0) {
    this.variable.type.toString(prefix,buffer);
    buffer.append(' ').append(this.variable.name).append(Formatting.Statements.forEachSeperator);
    this.variable.value.toString(prefix,buffer);
  }
 else {
    if (this.variable != null) {
      this.variable.toString(prefix,buffer);
    }
    buffer.append(';');
    if (this.condition != null) {
      buffer.append(' ');
      this.condition.toString(prefix,buffer);
    }
    buffer.append(';');
    if (this.update != null) {
      buffer.append(' ');
      this.update.toString(prefix,buffer);
    }
  }
  buffer.append(Formatting.Statements.forEnd);
  if (this.then != null) {
    if (this.then.isStatement()) {
      buffer.append('\n').append(prefix);
      this.then.toString(prefix,buffer);
    }
 else {
      buffer.append(' ');
      this.then.toString(prefix,buffer);
    }
  }
}","@Override public void toString(String prefix,StringBuilder buffer){
  buffer.append(Formatting.Statements.forStart);
  if (this.type != 0) {
    this.variable.type.toString(prefix,buffer);
    buffer.append(' ').append(this.variable.name).append(Formatting.Statements.forEachSeperator);
    this.variable.value.toString(prefix,buffer);
  }
 else {
    if (this.variable != null) {
      this.variable.toString(prefix,buffer);
    }
    buffer.append(';');
    if (this.condition != null) {
      buffer.append(' ');
      this.condition.toString(prefix,buffer);
    }
    buffer.append(';');
    if (this.update != null) {
      buffer.append(' ');
      this.update.toString(prefix,buffer);
    }
  }
  buffer.append(Formatting.Statements.forEnd);
  if (this.then != null) {
    this.then.toString(prefix,buffer);
  }
}",0.9080841638981174
85053,"@Override public void toString(String prefix,StringBuilder buffer){
  if (this.valueCount == 0) {
    buffer.append(Formatting.Expression.emptyExpression);
  }
 else {
    buffer.append('\n').append(prefix).append('{').append('\n');
    String prefix1=prefix + Formatting.Method.indent;
    IValue prev=null;
    for (int i=0; i < this.valueCount; i++) {
      IValue value=this.values[i];
      buffer.append(prefix1);
      if (prev != null) {
        ICodePosition pos=value.getPosition();
        if (pos != null && pos.endLine() - prev.getPosition().startLine() > 0) {
          buffer.append('\n').append(prefix1);
        }
      }
      if (this.labels != null) {
        Label l=this.labels[i];
        if (l != null) {
          buffer.append(l.name).append(Formatting.Expression.labelSeperator);
        }
      }
      value.toString(prefix1,buffer);
      buffer.append(""String_Node_Str"");
      prev=value;
    }
    buffer.append(prefix).append('}');
  }
}","@Override public void toString(String prefix,StringBuilder buffer){
  if (this.valueCount == 0) {
    buffer.append(Formatting.Expression.emptyExpression);
  }
 else {
    buffer.append('\n').append(prefix).append('{').append('\n');
    String prefix1=prefix + Formatting.Method.indent;
    IValue prev=null;
    for (int i=0; i < this.valueCount; i++) {
      IValue value=this.values[i];
      buffer.append(prefix1);
      if (prev != null) {
        ICodePosition pos=value.getPosition();
        if (pos != null && pos.endLine() - prev.getPosition().startLine() > 1) {
          buffer.append('\n').append(prefix1);
        }
      }
      if (this.labels != null) {
        Label l=this.labels[i];
        if (l != null) {
          buffer.append(l.name).append(Formatting.Expression.labelSeperator);
        }
      }
      value.toString(prefix1,buffer);
      buffer.append(""String_Node_Str"");
      prev=value;
    }
    buffer.append(prefix).append('}');
  }
}",0.9989701338825951
85054,"@Override public void resolveTypes(MarkerList markers,IContext context){
  this.lock.resolveTypes(markers,context);
  this.block.resolveTypes(markers,context);
}","@Override public void resolveTypes(MarkerList markers,IContext context){
  this.lock.resolveTypes(markers,context);
  if (this.block.isStatement()) {
    ((IStatement)this.block).setParent(this);
  }
  this.block.resolveTypes(markers,context);
}",0.7931034482758621
85055,"private void write(MethodWriter writer,boolean expression){
  int localCount=writer.registerLocal();
  this.lock.writeExpression(writer);
  writer.writeInsn(Opcodes.DUP);
  writer.writeVarInsn(Opcodes.ASTORE,localCount);
  writer.writeInsn(Opcodes.MONITORENTER);
  org.objectweb.asm.Label start=new org.objectweb.asm.Label();
  org.objectweb.asm.Label end=new org.objectweb.asm.Label();
  org.objectweb.asm.Label handlerStart=new org.objectweb.asm.Label();
  org.objectweb.asm.Label throwLabel=new org.objectweb.asm.Label();
  org.objectweb.asm.Label handlerEnd=new org.objectweb.asm.Label();
  writer.writeLabel(start);
  if (expression) {
    this.block.writeExpression(writer);
  }
 else {
    this.block.writeStatement(writer);
  }
  writer.writeVarInsn(Opcodes.ALOAD,localCount);
  writer.writeInsn(Opcodes.MONITOREXIT);
  writer.writeLabel(end);
  writer.writeJumpInsn(Opcodes.GOTO,handlerEnd);
  writer.writeLabel(handlerStart);
  writer.writeVarInsn(Opcodes.ALOAD,localCount);
  writer.writeInsn(Opcodes.MONITOREXIT);
  writer.writeLabel(throwLabel);
  writer.writeInsn(Opcodes.ATHROW);
  if (expression) {
    this.block.getType().writeDefaultValue(writer);
  }
  writer.resetLocals(localCount);
  writer.writeLabel(handlerEnd);
  writer.writeFinallyBlock(start,end,handlerStart);
  writer.writeFinallyBlock(handlerStart,throwLabel,handlerStart);
}","private void write(MethodWriter writer,boolean expression){
  org.objectweb.asm.Label start=new org.objectweb.asm.Label();
  org.objectweb.asm.Label end=new org.objectweb.asm.Label();
  org.objectweb.asm.Label handlerStart=new org.objectweb.asm.Label();
  org.objectweb.asm.Label throwLabel=new org.objectweb.asm.Label();
  org.objectweb.asm.Label handlerEnd=new org.objectweb.asm.Label();
  this.lock.writeExpression(writer);
  writer.writeInsn(Opcodes.DUP);
  int varIndex=writer.startSync();
  writer.writeVarInsn(Opcodes.ASTORE,varIndex);
  writer.writeInsn(Opcodes.MONITORENTER);
  writer.writeLabel(start);
  if (expression) {
    this.block.writeExpression(writer);
  }
 else {
    this.block.writeStatement(writer);
  }
  writer.endSync();
  writer.writeVarInsn(Opcodes.ALOAD,varIndex);
  writer.writeInsn(Opcodes.MONITOREXIT);
  writer.writeLabel(end);
  writer.writeJumpInsn(Opcodes.GOTO,handlerEnd);
  writer.writeLabel(handlerStart);
  writer.writeVarInsn(Opcodes.ALOAD,varIndex);
  writer.writeInsn(Opcodes.MONITOREXIT);
  writer.writeLabel(throwLabel);
  writer.writeInsn(Opcodes.ATHROW);
  if (expression) {
    this.block.getType().writeDefaultValue(writer);
  }
  writer.resetLocals(varIndex);
  writer.writeLabel(handlerEnd);
  writer.writeFinallyBlock(start,end,handlerStart);
  writer.writeFinallyBlock(handlerStart,throwLabel,handlerStart);
}",0.7029411764705882
85056,"@Override public void tokenize(){
  this.tokens=Dlex.tokenIterator(this.inputFile.getCode());
}","@Override public void tokenize(){
  this.tokens=Dlex.tokenIterator(this.inputFile.getCode());
  this.tokens.inferSemicolons();
}",0.852017937219731
85057,"@Override public void parse(){
  ParserManager manager=new ParserManager(new DyvilHeaderParser(this));
  manager.semicolonInference=true;
  manager.operators=this.operators;
  manager.parse(this.markers,this.tokens);
  this.tokens=null;
}","@Override public void parse(){
  ParserManager manager=new ParserManager(new DyvilHeaderParser(this));
  manager.operators=this.operators;
  manager.parse(this.markers,this.tokens);
  this.tokens=null;
}",0.5487528344671202
85058,"@Override public void parse(){
  ParserManager manager=new ParserManager(new DyvilUnitParser(this));
  manager.semicolonInference=true;
  manager.operators=this.operators;
  manager.parse(this.markers,this.tokens);
  this.tokens=null;
}","@Override public void parse(){
  ParserManager manager=new ParserManager(new DyvilUnitParser(this));
  manager.operators=this.operators;
  manager.parse(this.markers,this.tokens);
  this.tokens=null;
}",0.5446224256292906
85059,"private static int getMode(char c,String code,int i){
switch (c) {
case '""':
    return STRING;
case '\'':
  return CHAR;
case '/':
char n=code.charAt(i + 1);
if (n == '*') {
return BLOCK_COMMENT;
}
 else if (n == '/') {
return LINE_COMMENT;
}
 else {
return IDENTIFIER | MOD_SYMBOL;
}
case '@':
n=code.charAt(i + 1);
if (n == '""') {
return STRING_START;
}
return IDENTIFIER | MOD_SYMBOL;
case '0':
n=code.charAt(i + 1);
if (n == 'b') {
return INT | MOD_BIN;
}
 else if (n == 'x') {
return INT | MOD_HEX;
}
 else if (isDigit(n)) {
return INT | MOD_OCT;
}
return INT;
case '(':
return Symbols.OPEN_PARENTHESIS;
case ')':
return Symbols.CLOSE_PARENTHESIS;
case '[':
return Symbols.OPEN_SQUARE_BRACKET;
case ']':
return Symbols.CLOSE_SQUARE_BRACKET;
case '{':
return Symbols.OPEN_CURLY_BRACKET;
case '}':
return Symbols.CLOSE_CURLY_BRACKET;
case '.':
n=code.charAt(i + 1);
if (n == '.') {
return IDENTIFIER | MOD_DOTS;
}
return Symbols.DOT;
case ';':
return Symbols.SEMICOLON;
case ',':
return Symbols.COMMA;
}
if (isDigit(c)) {
return INT;
}
 else if (isIdentifierSymbol(c)) {
return IDENTIFIER | MOD_SYMBOL;
}
 else if (isIdentifierPart(c)) {
return IDENTIFIER | MOD_LETTER;
}
return 0;
}","private static int getMode(char c,String code,int i){
switch (c) {
case '""':
    return STRING;
case '\'':
  return CHAR;
case '/':
char n=code.charAt(i + 1);
if (n == '*') {
return BLOCK_COMMENT;
}
 else if (n == '/') {
return LINE_COMMENT;
}
 else {
return IDENTIFIER | MOD_SYMBOL;
}
case '@':
n=code.charAt(i + 1);
if (n == '""') {
return STRING_2;
}
return IDENTIFIER | MOD_SYMBOL;
case '0':
n=code.charAt(i + 1);
if (n == 'b') {
return INT | MOD_BIN;
}
 else if (n == 'x') {
return INT | MOD_HEX;
}
 else if (isDigit(n)) {
return INT | MOD_OCT;
}
return INT;
case '(':
return Symbols.OPEN_PARENTHESIS;
case ')':
return Symbols.CLOSE_PARENTHESIS;
case '[':
return Symbols.OPEN_SQUARE_BRACKET;
case ']':
return Symbols.CLOSE_SQUARE_BRACKET;
case '{':
return Symbols.OPEN_CURLY_BRACKET;
case '}':
return Symbols.CLOSE_CURLY_BRACKET;
case '.':
n=code.charAt(i + 1);
if (n == '.') {
return IDENTIFIER | MOD_DOTS;
}
return Symbols.DOT;
case ';':
return Symbols.SEMICOLON;
case ',':
return Symbols.COMMA;
}
if (isDigit(c)) {
return INT;
}
 else if (isIdentifierSymbol(c)) {
return IDENTIFIER | MOD_SYMBOL;
}
 else if (isIdentifierPart(c)) {
return IDENTIFIER | MOD_LETTER;
}
return 0;
}",0.9974683544303796
85060,"public static IToken tokenize(String code){
  int len=code.length();
  StringBuilder buf=new StringBuilder(20);
  IToken first=new InferredSemicolon(0,0);
  IToken prev=first;
  int start=0;
  int lineNumber=1;
  char l=0;
  char c=0;
  int type=0;
  int subtype=0;
  boolean addToken=false;
  boolean reparse=true;
  boolean string=false;
  for (int i=0; i < len; ++i, l=c) {
    c=code.charAt(i);
    if (type == 0) {
      start=i;
      if (c == '\n') {
        lineNumber++;
        continue;
      }
      if (c <= ' ') {
        continue;
      }
      if (string && c == '}') {
        type=STRING_START;
        subtype=STRING_PART;
        continue;
      }
      int m=getMode(c,code,i);
      type=m & 0xFFFF;
      subtype=m & 0xFFFF0000;
    }
switch (type) {
case IDENTIFIER:
      if (subtype == MOD_DOTS) {
        if (c == '.') {
          buf.append(c);
        }
 else {
          addToken=true;
          reparse=true;
        }
      }
 else       if (c == '_' || c == '$') {
        subtype=MOD_SYMBOL | MOD_LETTER;
        buf.append(c);
      }
 else {
        boolean letter=(subtype & MOD_LETTER) != 0;
        boolean symbol=(subtype & MOD_SYMBOL) != 0;
        if (letter) {
          if (isIdentifierPart(c)) {
            subtype=MOD_LETTER;
            buf.append(c);
            continue;
          }
        }
        if (symbol) {
          if (isIdentifierSymbol(c)) {
            subtype=MOD_SYMBOL;
            buf.append(c);
            continue;
          }
        }
        addToken=true;
      }
    break;
case SYMBOL:
  buf.append(c);
addToken=true;
reparse=false;
break;
case BRACKET:
buf.append(c);
addToken=true;
reparse=false;
break;
case COMMENT:
if (subtype == MOD_LINE) {
if (c == '\n') {
type=0;
continue;
}
}
 else if (subtype == MOD_BLOCK) {
if (l == '*' && c == '/') {
type=0;
continue;
}
}
break;
case INT:
case LONG:
if (c == '.') {
type=FLOAT;
buf.append('.');
}
 else if (c == 'l' || c == 'L') {
type=LONG;
addToken=true;
reparse=false;
}
 else if (subtype == MOD_DEC) {
if (isDigit(c)) {
buf.append(c);
}
 else if (c == 'f' || c == 'F') {
type=FLOAT;
addToken=true;
reparse=false;
}
 else if (c == 'd' || c == 'D') {
type=DOUBLE;
addToken=true;
reparse=false;
}
 else {
addToken=true;
}
}
 else if (subtype == MOD_BIN) {
if (c == 'b' || isBinDigit(c)) {
buf.append(c);
}
 else {
addToken=true;
}
}
 else if (subtype == MOD_OCT) {
if (isOctDigit(c)) {
buf.append(c);
}
 else {
addToken=true;
}
}
 else if (subtype == MOD_HEX) {
if (c == 'x' || isHexDigit(c)) {
buf.append(c);
}
 else {
addToken=true;
}
}
break;
case FLOAT:
case DOUBLE:
if (c == 'x') {
subtype=MOD_HEX;
buf.append(c);
}
 else if (c == 'f' || c == 'F') {
addToken=true;
reparse=false;
}
 else if (c == 'd' || c == 'D') {
type=DOUBLE;
addToken=true;
reparse=false;
}
 else if (isDigit(c) || c == '.' || c == 'e') {
buf.append(c);
}
 else {
addToken=true;
}
break;
case STRING:
if (c == '""' && buf.length() > 0) {
buf.append('""');
addToken=true;
reparse=false;
}
 else if (c == '\\' && appendEscape(buf,code.charAt(i + 1))) {
i++;
continue;
}
 else if (c != '\t') {
buf.append(c);
}
break;
case STRING_START:
if (c == '""' && (buf.length() > 1 || string)) {
subtype=STRING_END;
string=false;
addToken=true;
reparse=false;
break;
}
 else if (c == '\\' && appendEscape(buf,code.charAt(i + 1))) {
i++;
continue;
}
 else if (c == '$' && code.charAt(i + 1) == '{') {
i+=2;
addToken=true;
string=true;
}
 else if (c != '\t') {
buf.append(c);
}
break;
case CHAR:
if (c == '\'' && buf.length() > 0) {
buf.append('\'');
addToken=true;
reparse=false;
}
 else if (c == '\\' && appendEscape(buf,code.charAt(i + 1))) {
i++;
continue;
}
 else if (c != '\t') {
buf.append(c);
}
break;
}
if (addToken) {
prev=addToken(prev,buf,type | subtype,lineNumber,start);
addToken=false;
type=0;
if (reparse) {
i--;
}
 else {
reparse=true;
}
}
}
if (buf.length() > 0) {
addToken(prev,buf,type | subtype,lineNumber,start);
}
return first.getNext();
}","public static IToken tokenize(String code){
  int len=code.length();
  StringBuilder buf=new StringBuilder(20);
  IToken first=new InferredSemicolon(0,0);
  IToken prev=first;
  int start=0;
  int lineNumber=1;
  char l=0;
  char c=0;
  int type=0;
  int subtype=0;
  boolean addToken=false;
  boolean reparse=true;
  boolean string=false;
  for (int i=0; i < len; ++i, l=c) {
    c=code.charAt(i);
    if (type == 0) {
      start=i;
      if (c == '\n') {
        lineNumber++;
        continue;
      }
      if (c <= ' ') {
        continue;
      }
      if (string && c == '}') {
        type=STRING_2;
        subtype=STRING_PART;
        continue;
      }
      int m=getMode(c,code,i);
      type=m & 0xFFFF;
      subtype=m & 0xFFFF0000;
    }
switch (type) {
case IDENTIFIER:
      if (subtype == MOD_DOTS) {
        if (c == '.') {
          buf.append(c);
        }
 else {
          addToken=true;
          reparse=true;
        }
      }
 else       if (c == '_' || c == '$') {
        subtype=MOD_SYMBOL | MOD_LETTER;
        buf.append(c);
      }
 else {
        boolean letter=(subtype & MOD_LETTER) != 0;
        boolean symbol=(subtype & MOD_SYMBOL) != 0;
        if (letter) {
          if (isIdentifierPart(c)) {
            subtype=MOD_LETTER;
            buf.append(c);
            continue;
          }
        }
        if (symbol) {
          if (isIdentifierSymbol(c)) {
            subtype=MOD_SYMBOL;
            buf.append(c);
            continue;
          }
        }
        addToken=true;
      }
    break;
case SYMBOL:
  buf.append(c);
addToken=true;
reparse=false;
break;
case BRACKET:
buf.append(c);
addToken=true;
reparse=false;
break;
case COMMENT:
if (subtype == MOD_LINE) {
if (c == '\n') {
type=0;
continue;
}
}
 else if (subtype == MOD_BLOCK) {
if (l == '*' && c == '/') {
type=0;
continue;
}
}
break;
case INT:
case LONG:
if (c == '.') {
type=FLOAT;
buf.append('.');
}
 else if (c == 'l' || c == 'L') {
type=LONG;
addToken=true;
reparse=false;
}
 else if (subtype == MOD_DEC) {
if (isDigit(c)) {
buf.append(c);
}
 else if (c == 'f' || c == 'F') {
type=FLOAT;
addToken=true;
reparse=false;
}
 else if (c == 'd' || c == 'D') {
type=DOUBLE;
addToken=true;
reparse=false;
}
 else {
addToken=true;
}
}
 else if (subtype == MOD_BIN) {
if (c == 'b' || isBinDigit(c)) {
buf.append(c);
}
 else {
addToken=true;
}
}
 else if (subtype == MOD_OCT) {
if (isOctDigit(c)) {
buf.append(c);
}
 else {
addToken=true;
}
}
 else if (subtype == MOD_HEX) {
if (c == 'x' || isHexDigit(c)) {
buf.append(c);
}
 else {
addToken=true;
}
}
break;
case FLOAT:
case DOUBLE:
if (c == 'x') {
subtype=MOD_HEX;
buf.append(c);
}
 else if (c == 'f' || c == 'F') {
addToken=true;
reparse=false;
}
 else if (c == 'd' || c == 'D') {
type=DOUBLE;
addToken=true;
reparse=false;
}
 else if (isDigit(c) || c == '.' || c == 'e') {
buf.append(c);
}
 else {
addToken=true;
}
break;
case STRING:
if (c == '""' && buf.length() > 0) {
buf.append('""');
addToken=true;
reparse=false;
}
 else if (c == '\\' && appendEscape(buf,code.charAt(i + 1))) {
i++;
continue;
}
 else if (c != '\t') {
buf.append(c);
}
break;
case STRING_2:
if (c == '""' && (buf.length() > 1 || string)) {
if (!string && buf.charAt(0) == '@') {
subtype=STRING_2;
}
 else {
subtype=STRING_END;
}
string=false;
addToken=true;
reparse=false;
break;
}
 else if (c == '\\' && appendEscape(buf,code.charAt(i + 1))) {
i++;
continue;
}
 else if (c == '$' && code.charAt(i + 1) == '{') {
i+=2;
if (buf.charAt(0) == '@') {
subtype=STRING_START;
}
 else {
subtype=STRING_PART;
}
addToken=true;
string=true;
}
 else if (c != '\t') {
buf.append(c);
}
break;
case CHAR:
if (c == '\'' && buf.length() > 0) {
buf.append('\'');
addToken=true;
reparse=false;
}
 else if (c == '\\' && appendEscape(buf,code.charAt(i + 1))) {
i++;
continue;
}
 else if (c != '\t') {
buf.append(c);
}
break;
}
if (addToken) {
prev=addToken(prev,buf,type | subtype,lineNumber,start);
addToken=false;
type=0;
if (reparse) {
i--;
}
 else {
reparse=true;
}
}
}
if (buf.length() > 0) {
addToken(prev,buf,type | subtype,lineNumber,start);
}
return first.getNext();
}",0.9795867562857854
85061,"public final void parse(MarkerList markers,TokenIterator tokens){
  this.tokens=tokens;
  IToken token=null;
  IToken prev=null;
  while (tokens.hasNext()) {
    token=tokens.next();
    if (!this.retainToken(token,prev)) {
      tokens.remove();
    }
    prev=token;
  }
  tokens.reset();
  while (tokens.hasNext()) {
    token=tokens.next();
    token.setPrev(prev);
    prev=token;
  }
  tokens.reset();
  while (true) {
    if (this.reparse) {
      this.reparse=false;
    }
 else {
      token=tokens.next();
      if (token == null) {
        break;
      }
    }
    if (this.skip > 0) {
      this.skip--;
      continue;
    }
    try {
      this.parser.parse(this,token);
    }
 catch (    SyntaxError ex) {
{
        if (ex.reparse) {
          this.reparse=true;
        }
        markers.add(ex);
      }
    }
catch (    Exception ex) {
{
        DyvilCompiler.logger.throwing(""String_Node_Str"",""String_Node_Str"",ex);
        markers.add(new SyntaxError(token,""String_Node_Str"" + token + ""String_Node_Str""+ ex.getMessage()));
      }
    }
    if (this.parser == null) {
      break;
    }
    if (DyvilCompiler.parseStack) {
      System.out.println(token + ""String_Node_Str"" + this.parser.name+ ""String_Node_Str""+ this.parser.mode);
    }
  }
}","public final void parse(MarkerList markers,TokenIterator tokens){
  this.tokens=tokens;
  IToken token=null;
  while (true) {
    if (this.reparse) {
      this.reparse=false;
    }
 else {
      token=tokens.next();
      if (token == null) {
        break;
      }
    }
    if (this.skip > 0) {
      this.skip--;
      continue;
    }
    try {
      this.parser.parse(this,token);
    }
 catch (    SyntaxError ex) {
{
        if (ex.reparse) {
          this.reparse=true;
        }
        markers.add(ex);
      }
    }
catch (    Exception ex) {
{
        DyvilCompiler.logger.throwing(""String_Node_Str"",""String_Node_Str"",ex);
        markers.add(new SyntaxError(token,""String_Node_Str"" + token + ""String_Node_Str""+ ex.getMessage()));
      }
    }
    if (this.parser == null) {
      break;
    }
    if (DyvilCompiler.parseStack) {
      System.out.println(token + ""String_Node_Str"" + this.parser.name+ ""String_Node_Str""+ this.parser.mode);
    }
  }
}",0.8657386618769646
85062,"@Override public IValue resolve(MarkerList markers,IContext context){
  Name name=this.type.getName();
  FieldMatch f=context.resolveField(name);
  if (f != null) {
    FieldAccess access=new FieldAccess(this.position);
    access.name=name;
    access.field=f.theField;
    return access;
  }
  IMethod m=IContext.resolveMethod(markers,context,null,name,EmptyArguments.INSTANCE);
  if (m != null) {
    MethodCall call=new MethodCall(this.position);
    call.name=name;
    call.method=m;
    call.dotless=true;
    if (this.type.isGenericType()) {
      GenericType generic=(GenericType)this.type;
      call.generics=generic.generics;
      call.genericCount=generic.genericCount;
    }
    call.arguments=EmptyArguments.INSTANCE;
    return call;
  }
  if (!this.type.isResolved()) {
    markers.add(this.position,this.type.isArrayType() ? ""String_Node_Str"" : ""String_Node_Str"",this.type.toString());
  }
  return this;
}","@Override public IValue resolve(MarkerList markers,IContext context){
  Name name=this.type.getName();
  IField f=context.resolveField(name);
  if (f != null) {
    FieldAccess access=new FieldAccess(this.position);
    access.name=name;
    access.field=f;
    return access;
  }
  IMethod m=IContext.resolveMethod(markers,context,null,name,EmptyArguments.INSTANCE);
  if (m != null) {
    MethodCall call=new MethodCall(this.position);
    call.name=name;
    call.method=m;
    call.dotless=true;
    if (this.type.isGenericType()) {
      GenericType generic=(GenericType)this.type;
      call.generics=generic.generics;
      call.genericCount=generic.genericCount;
    }
    call.arguments=EmptyArguments.INSTANCE;
    return call;
  }
  if (!this.type.isResolved()) {
    markers.add(this.position,this.type.isArrayType() ? ""String_Node_Str"" : ""String_Node_Str"",this.type.toString());
  }
  return this;
}",0.9918345127925966
85063,"public static IField resolveField(IContext context,ITyped instance,Name name){
  FieldMatch match;
  if (instance != null) {
    IType type=instance.getType();
    if (type != null) {
      match=type.resolveField(name);
      if (match != null) {
        return match.theField;
      }
    }
  }
  match=context.resolveField(name);
  if (match != null) {
    return match.theField;
  }
  return null;
}","public static IField resolveField(IContext context,ITyped instance,Name name){
  IField match;
  if (instance != null) {
    IType type=instance.getType();
    if (type != null) {
      match=type.resolveField(name);
      if (match != null) {
        return match;
      }
    }
  }
  match=context.resolveField(name);
  if (match != null) {
    return match;
  }
  return null;
}",0.8112244897959183
85064,"@Override public IValue resolve2(IContext context){
  if (this.replacement != null) {
    return this.replacement;
  }
  if (this.arguments.isEmpty()) {
    IField field=IAccess.resolveField(context,this.instance,this.name);
    if (field != null) {
      FieldAccess access=new FieldAccess(this.position);
      access.field=field;
      access.instance=this.instance;
      access.name=this.name;
      access.dotless=this.dotless;
      return access;
    }
  }
 else   if (this.instance == null) {
    IValue instance;
    IType type=null;
    IMethod method=null;
    FieldMatch field=context.resolveField(this.name);
    if (field == null) {
      type=new Type(this.position,this.name).resolve(null,context);
      if (!type.isResolved()) {
        return null;
      }
      IMethod match=IContext.resolveMethod(null,type,null,Name.apply,this.arguments);
      if (match == null) {
        return null;
      }
      method=match;
      instance=new ClassAccess(this.position,type);
    }
 else {
      FieldAccess access=new FieldAccess(this.position);
      access.field=field.theField;
      access.name=this.name;
      access.dotless=this.dotless;
      IMethod match=IContext.resolveMethod(null,field.theField.getType(),access,Name.apply,this.arguments);
      if (match == null) {
        return null;
      }
      method=match;
      instance=access;
    }
    ApplyMethodCall call=new ApplyMethodCall(this.position);
    call.method=method;
    call.instance=instance;
    call.arguments=this.arguments;
    return call;
  }
  return null;
}","@Override public IValue resolve2(IContext context){
  if (this.replacement != null) {
    return this.replacement;
  }
  if (this.arguments.isEmpty()) {
    IField field=IAccess.resolveField(context,this.instance,this.name);
    if (field != null) {
      FieldAccess access=new FieldAccess(this.position);
      access.field=field;
      access.instance=this.instance;
      access.name=this.name;
      access.dotless=this.dotless;
      return access;
    }
  }
 else   if (this.instance == null) {
    IValue instance;
    IType type=null;
    IMethod method=null;
    IField field=context.resolveField(this.name);
    if (field == null) {
      type=new Type(this.position,this.name).resolve(null,context);
      if (!type.isResolved()) {
        return null;
      }
      IMethod match=IContext.resolveMethod(null,type,null,Name.apply,this.arguments);
      if (match == null) {
        return null;
      }
      method=match;
      instance=new ClassAccess(this.position,type);
    }
 else {
      FieldAccess access=new FieldAccess(this.position);
      access.field=field;
      access.name=this.name;
      access.dotless=this.dotless;
      IMethod match=IContext.resolveMethod(null,field.getType(),access,Name.apply,this.arguments);
      if (match == null) {
        return null;
      }
      method=match;
      instance=access;
    }
    ApplyMethodCall call=new ApplyMethodCall(this.position);
    call.method=method;
    call.instance=instance;
    call.arguments=this.arguments;
    return call;
  }
  return null;
}",0.992248062015504
85065,"@Override public FieldMatch resolveField(Name name){
  for (int i=0; i < this.parameterCount; i++) {
    IParameter param=this.parameters[i];
    if (param.getName() == name) {
      return new FieldMatch(param,1);
    }
  }
  if (this.body != null) {
    IField field=this.body.getProperty(name);
    if (field != null) {
      return new FieldMatch(field,1);
    }
    field=this.body.getField(name);
    if (field != null) {
      return new FieldMatch(field,1);
    }
  }
  FieldMatch match=this.metadata.resolveField(name);
  if (match != null) {
    return match;
  }
  if (this.superType != null) {
    match=this.superType.resolveField(name);
    if (match != null) {
      return match;
    }
  }
  if (this.unit != null && this.unit.hasStaticImports()) {
    match=this.unit.resolveField(name);
    if (match != null) {
      return match;
    }
  }
  return null;
}","@Override public IField resolveField(Name name){
  for (int i=0; i < this.parameterCount; i++) {
    IParameter param=this.parameters[i];
    if (param.getName() == name) {
      return param;
    }
  }
  if (this.body != null) {
    IField field=this.body.getProperty(name);
    if (field != null) {
      return field;
    }
    field=this.body.getField(name);
    if (field != null) {
      return field;
    }
  }
  IField match=this.metadata.resolveField(name);
  if (match != null) {
    return match;
  }
  if (this.superType != null) {
    match=this.superType.resolveField(name);
    if (match != null) {
      return match;
    }
  }
  if (this.unit != null && this.unit.hasStaticImports()) {
    match=this.unit.resolveField(name);
    if (match != null) {
      return match;
    }
  }
  return null;
}",0.8355029585798817
85066,"public default FieldMatch resolveField(Name name){
  return null;
}","public default IField resolveField(Name name){
  return null;
}",0.953846153846154
85067,"@Override public FieldMatch resolveField(Name name){
  return null;
}","@Override public IField resolveField(Name name){
  return null;
}",0.9552238805970148
85068,"@Override public FieldMatch resolveField(Name name){
  return null;
}","@Override public IField resolveField(Name name){
  return null;
}",0.9552238805970148
85069,"@Override public FieldMatch resolveField(Name name){
  IField field=this.body.getProperty(name);
  if (field != null) {
    return new FieldMatch(field,1);
  }
  field=this.body.getField(name);
  if (field != null) {
    return new FieldMatch(field,1);
  }
  FieldMatch match;
  if (!this.superTypesResolved) {
    this.resolveSuperTypes();
  }
  if (this.superType != null) {
    match=this.superType.resolveField(name);
    if (match != null) {
      return match;
    }
  }
  return null;
}","@Override public IField resolveField(Name name){
  IField field=this.body.getProperty(name);
  if (field != null) {
    return field;
  }
  field=this.body.getField(name);
  if (field != null) {
    return field;
  }
  if (!this.superTypesResolved) {
    this.resolveSuperTypes();
  }
  if (this.superType != null) {
    IField match=this.superType.resolveField(name);
    if (match != null) {
      return match;
    }
  }
  return null;
}",0.1157556270096463
85070,"@Override public FieldMatch resolveField(Name name){
  if (name == this.name) {
    return new FieldMatch(this.setterParameter,1);
  }
  return this.theClass.resolveField(name);
}","@Override public IField resolveField(Name name){
  if (name == this.name) {
    return this.setterParameter;
  }
  return this.theClass.resolveField(name);
}",0.9285714285714286
85071,"@Override public FieldMatch resolveField(Name name){
  return null;
}","@Override public IField resolveField(Name name){
  return null;
}",0.9552238805970148
85072,"@Override public FieldMatch resolveField(Name name){
  if (this.arrayDimensions > 0 || this.upperBoundCount == 0) {
    return null;
  }
  for (int i=0; i < this.upperBoundCount; i++) {
    FieldMatch f=this.upperBounds[i].resolveField(name);
    if (f != null) {
      return f;
    }
  }
  return null;
}","@Override public IField resolveField(Name name){
  if (this.arrayDimensions > 0 || this.upperBoundCount == 0) {
    return null;
  }
  for (int i=0; i < this.upperBoundCount; i++) {
    IField f=this.upperBounds[i].resolveField(name);
    if (f != null) {
      return f;
    }
  }
  return null;
}",0.9470198675496688
85073,"@Override public FieldMatch resolveField(Name name){
  return this.last.resolveField(name);
}","@Override public IField resolveField(Name name){
  return this.last.resolveField(name);
}",0.967032967032967
85074,"@Override public FieldMatch resolveField(Name name){
  for (  IImport i : this.children) {
    FieldMatch match=i.resolveField(name);
    if (match != null) {
      return match;
    }
  }
  return null;
}","@Override public IField resolveField(Name name){
  for (  IImport i : this.children) {
    IField match=i.resolveField(name);
    if (match != null) {
      return match;
    }
  }
  return null;
}",0.9701492537313432
85075,"@Override public FieldMatch resolveField(Name name){
  return this.theClass.resolveField(name);
}","@Override public IField resolveField(Name name){
  return this.theClass.resolveField(name);
}",0.968421052631579
85076,"@Override public void toString(String prefix,StringBuilder buffer){
  if (this.instance != null) {
    this.instance.toString(prefix,buffer);
  }
  if (Formatting.Method.convertQualifiedNames) {
    buffer.append(this.name.qualified).append(""String_Node_Str"");
  }
 else {
    buffer.append(this.name.unqualified).append('=');
  }
  this.arguments.toString(prefix,buffer);
}","@Override public void toString(String prefix,StringBuilder buffer){
  if (this.instance != null) {
    this.instance.toString(prefix,buffer);
    buffer.append(' ');
  }
  if (Formatting.Method.convertQualifiedNames) {
    buffer.append(this.name.qualified).append(""String_Node_Str"");
  }
 else {
    buffer.append(this.name.unqualified).append('=');
  }
  this.arguments.toString(prefix,buffer);
}",0.9689119170984456
85077,"public InvokeDynamicInstruction(String name,String type,Handle bsm,Object[] bsmArguments){
  this.name=name;
  this.type=type;
  this.bsm=bsm;
  this.bsmArguments=bsmArguments;
}","public InvokeDynamicInstruction(String name,String type,Handle bsm,Object[] bsmArguments){
  this.name=name;
  this.type=type;
  this.bsm=bsm;
  this.bsmArguments=bsmArguments;
  this.type=type.substring(type.lastIndexOf(')') + 1);
  this.args=Type.getArgumentsAndReturnSizes(type) >> 2;
}",0.7623126338329764
85078,"@Override public void write(MethodWriter writer){
}","@Override public void write(MethodWriter writer){
  writer.writeInvokeDynamic(this.name,this.type,this.args,this.returnType,this.bsm,this.bsmArguments);
}",0.4975609756097561
85079,"@Override public void write(MethodWriter writer){
}","@Override public void write(MethodWriter writer){
  int len=this.handlers.length;
  org.objectweb.asm.Label[] labels=new org.objectweb.asm.Label[len];
  for (int i=0; i < len; i++) {
    labels[i]=this.handlers[i].target;
  }
  writer.writeLookupSwitch(this.defaultHandler.target,this.keys,labels);
}",0.2905982905982906
85080,"@Override public void write(MethodWriter writer){
}","@Override public void write(MethodWriter writer){
  int len=this.handlers.length;
  org.objectweb.asm.Label[] labels=new org.objectweb.asm.Label[len];
  for (int i=0; i < len; i++) {
    labels[i]=this.handlers[i].target;
  }
  writer.writeTableSwitch(this.defaultHandler.target,this.start,this.end,labels);
}",0.2833333333333333
85081,"@Override public void toString(String prefix,StringBuilder buffer){
  if (this.instance != null) {
    this.instance.toString(""String_Node_Str"",buffer);
    buffer.append('.');
  }
  buffer.append(this.name);
  if (this.value != null) {
    buffer.append(Formatting.Field.keyValueSeperator);
    Formatting.appendValue(this.value,prefix,buffer);
  }
}","@Override public void toString(String prefix,StringBuilder buffer){
  if (this.instance != null) {
    this.instance.toString(""String_Node_Str"",buffer);
    buffer.append('.');
  }
  buffer.append(this.name);
  if (this.value != null) {
    buffer.append(Formatting.Field.keyValueSeperator);
    this.value.toString(prefix,buffer);
  }
}",0.9505813953488372
85082,"@Override public void toString(String prefix,StringBuilder buffer){
  if (this.instance != null) {
    this.instance.toString(prefix,buffer);
  }
  if (this.arguments instanceof ArgumentList) {
    buffer.append(Formatting.Method.parametersStart);
    int len=this.arguments.size() - 1;
    this.arguments.getValue(0,null).toString(prefix,buffer);
    for (int i=1; i < len; i++) {
      buffer.append(Formatting.Method.parameterSeperator);
      this.arguments.getValue(i,null).toString(prefix,buffer);
    }
    buffer.append(Formatting.Method.parametersEnd);
    buffer.append(Formatting.Field.keyValueSeperator);
    Formatting.appendValue(this.arguments.getValue(len,null),prefix,buffer);
  }
 else {
    this.arguments.toString(prefix,buffer);
  }
}","@Override public void toString(String prefix,StringBuilder buffer){
  if (this.instance != null) {
    this.instance.toString(prefix,buffer);
  }
  if (this.arguments instanceof ArgumentList) {
    buffer.append(Formatting.Method.parametersStart);
    int len=this.arguments.size() - 1;
    this.arguments.getValue(0,null).toString(prefix,buffer);
    for (int i=1; i < len; i++) {
      buffer.append(Formatting.Method.parameterSeperator);
      this.arguments.getValue(i,null).toString(prefix,buffer);
    }
    buffer.append(Formatting.Method.parametersEnd);
    buffer.append(Formatting.Field.keyValueSeperator);
    this.arguments.getValue(len,null).toString(prefix,buffer);
  }
 else {
    this.arguments.toString(prefix,buffer);
  }
}",0.9411764705882352
85083,"public void setDesc(String desc){
  this.desc=desc;
}","public void setDesc(String desc){
  this.desc=ClassFormat.userToExtended(desc);
}",0.7910447761194029
85084,"@Override public void write(MethodWriter writer){
  String s=ClassFormat.userToExtended(this.desc);
  writer.writeFieldInsn(this.opcode,this.owner,this.fieldName,s);
}","@Override public void write(MethodWriter writer){
  writer.writeFieldInsn(this.opcode,this.owner,this.fieldName,this.desc);
}",0.8013698630136986
85085,"@Override public void toString(String prefix,StringBuilder buffer){
  super.toString(prefix,buffer);
  buffer.append(ModifierTypes.FIELD.toString(this.modifiers));
  this.type.toString(""String_Node_Str"",buffer);
  buffer.append(' ');
  buffer.append(this.name);
  IValue value=this.value;
  if (value != null) {
    buffer.append(Formatting.Field.keyValueSeperator);
    Formatting.appendValue(value,prefix,buffer);
  }
  buffer.append(';');
}","@Override public void toString(String prefix,StringBuilder buffer){
  super.toString(prefix,buffer);
  buffer.append(ModifierTypes.FIELD.toString(this.modifiers));
  this.type.toString(""String_Node_Str"",buffer);
  buffer.append(' ');
  buffer.append(this.name);
  if (this.value != null) {
    buffer.append(Formatting.Field.keyValueSeperator);
    this.value.toString(prefix,buffer);
  }
  buffer.append(';');
}",0.9192982456140352
85086,"@Override public void toString(String prefix,StringBuilder buffer){
  this.type.toString(""String_Node_Str"",buffer);
  buffer.append(' ').append(this.name);
  if (this.value != null) {
    buffer.append(Formatting.Field.keyValueSeperator);
    Formatting.appendValue(this.value,prefix,buffer);
  }
}","@Override public void toString(String prefix,StringBuilder buffer){
  this.type.toString(""String_Node_Str"",buffer);
  buffer.append(' ').append(this.name);
  if (this.value != null) {
    buffer.append(Formatting.Field.keyValueSeperator);
    this.value.toString(prefix,buffer);
  }
}",0.9072164948453608
85087,"@Override public void toString(String prefix,StringBuilder buffer){
  super.toString(prefix,buffer);
  buffer.append(ModifierTypes.METHOD.toString(this.modifiers));
  buffer.append(""String_Node_Str"");
  buffer.append(Formatting.Method.parametersStart);
  Util.astToString(prefix,this.parameters,this.parameterCount,Formatting.Method.parameterSeperator,buffer);
  buffer.append(Formatting.Method.parametersEnd);
  if (this.exceptionCount > 0) {
    buffer.append(Formatting.Method.signatureThrowsSeperator);
    Util.astToString(prefix,this.exceptions,this.exceptionCount,Formatting.Method.throwsSeperator,buffer);
  }
  IValue value=this.getValue();
  if (value != null) {
    buffer.append(Formatting.Method.signatureBodySeperator);
    Formatting.appendValue(value,prefix,buffer);
  }
  buffer.append(';');
}","@Override public void toString(String prefix,StringBuilder buffer){
  super.toString(prefix,buffer);
  buffer.append(ModifierTypes.METHOD.toString(this.modifiers));
  buffer.append(""String_Node_Str"");
  buffer.append(Formatting.Method.parametersStart);
  Util.astToString(prefix,this.parameters,this.parameterCount,Formatting.Method.parameterSeperator,buffer);
  buffer.append(Formatting.Method.parametersEnd);
  if (this.exceptionCount > 0) {
    buffer.append(Formatting.Method.signatureThrowsSeperator);
    Util.astToString(prefix,this.exceptions,this.exceptionCount,Formatting.Method.throwsSeperator,buffer);
  }
  if (this.value != null) {
    buffer.append(Formatting.Method.signatureBodySeperator);
    this.value.toString(prefix,buffer);
  }
  buffer.append(';');
}",0.9457070707070708
85088,"@Override public void writeInvJump(MethodWriter writer,Label dest,IValue instance,IArguments arguments){
  if (instance != null && (this.modifiers & Modifiers.STATIC) != 0 && instance.getValueType() == IValue.CLASS_ACCESS) {
    instance=null;
  }
  if (this.intrinsicOpcodes != null && (instance == null || instance.isPrimitive())) {
    this.writeInvIntrinsic(writer,dest,instance,arguments);
    return;
  }
  this.writeInvoke(writer,instance,arguments);
  writer.writeJumpInsn(IFNE,dest);
}","@Override public void writeInvJump(MethodWriter writer,Label dest,IValue instance,IArguments arguments){
  if (instance != null && (this.modifiers & Modifiers.STATIC) != 0 && instance.getValueType() == IValue.CLASS_ACCESS) {
    instance=null;
  }
  if (this.intrinsicOpcodes != null && (instance == null || instance.isPrimitive())) {
    this.writeInvIntrinsic(writer,dest,instance,arguments);
    return;
  }
  if ((this.modifiers & INLINABLE) != 0 && writer.inlineOffset() == 0) {
    Label inlineEnd=new Label();
    this.writeInlineArguments(writer,instance,arguments,writer.startInline(inlineEnd));
    this.value.writeInvJump(writer,dest);
    writer.endInline(inlineEnd);
    return;
  }
  this.writeInvoke(writer,instance,arguments);
  writer.writeJumpInsn(IFNE,dest);
}",0.7761194029850746
85089,"@Override public void writeJump(MethodWriter writer,Label dest,IValue instance,IArguments arguments){
  if (instance != null && (this.modifiers & Modifiers.STATIC) != 0 && instance.getValueType() == IValue.CLASS_ACCESS) {
    instance=null;
  }
  if (this.intrinsicOpcodes != null && (instance == null || instance.isPrimitive())) {
    this.writeIntrinsic(writer,dest,instance,arguments);
    return;
  }
  this.writeInvoke(writer,instance,arguments);
  writer.writeJumpInsn(IFEQ,dest);
}","@Override public void writeJump(MethodWriter writer,Label dest,IValue instance,IArguments arguments){
  if (instance != null && (this.modifiers & Modifiers.STATIC) != 0 && instance.getValueType() == IValue.CLASS_ACCESS) {
    instance=null;
  }
  if (this.intrinsicOpcodes != null && (instance == null || instance.isPrimitive())) {
    this.writeIntrinsic(writer,dest,instance,arguments);
    return;
  }
  if ((this.modifiers & INLINABLE) != 0 && writer.inlineOffset() == 0) {
    Label inlineEnd=new Label();
    this.writeInlineArguments(writer,instance,arguments,writer.startInline(inlineEnd));
    this.value.writeJump(writer,dest);
    writer.endInline(inlineEnd);
    return;
  }
  this.writeInvoke(writer,instance,arguments);
  writer.writeJumpInsn(IFEQ,dest);
}",0.7758346581875993
85090,"private void writeInlineArguments(MethodWriter writer,IArguments arguments,int localCount){
  if ((this.modifiers & Modifiers.INFIX) == Modifiers.INFIX) {
    int len=this.parameterCount;
    if ((this.modifiers & Modifiers.VARARGS) != 0) {
      len--;
      IParameter param;
      for (int i=1, j=0; i < len; i++, j++) {
        param=this.parameters[i];
        arguments.writeValue(j,param.getName(),param.getValue(),writer);
        param.setIndex(writer.registerLocal());
        param.writeSet(writer,null,null);
      }
      param=this.parameters[len];
      arguments.writeVarargsValue(len - 1,param.getName(),param.getType(),writer);
      param.setIndex(writer.registerLocal());
      param.writeSet(writer,null,null);
      return;
    }
    for (int i=1, j=0; i < this.parameterCount; i++, j++) {
      IParameter param=this.parameters[i];
      arguments.writeValue(j,param.getName(),param.getValue(),writer);
      param.setIndex(writer.registerLocal());
      param.writeSet(writer,null,null);
    }
    return;
  }
  if ((this.modifiers & Modifiers.PREFIX) == Modifiers.PREFIX) {
    arguments.writeValue(0,Name._this,null,writer);
    return;
  }
  if ((this.modifiers & Modifiers.VARARGS) != 0) {
    int len=this.parameterCount - 1;
    IParameter param;
    for (int i=0; i < len; i++) {
      param=this.parameters[i];
      arguments.writeValue(i,param.getName(),param.getValue(),writer);
      param.setIndex(writer.registerLocal());
      param.writeSet(writer,null,null);
    }
    param=this.parameters[len];
    arguments.writeVarargsValue(len,param.getName(),param.getType(),writer);
    param.setIndex(writer.registerLocal());
    param.writeSet(writer,null,null);
    return;
  }
  for (int i=0; i < this.parameterCount; i++) {
    IParameter param=this.parameters[i];
    arguments.writeValue(i,param.getName(),param.getValue(),writer);
    param.setIndex(writer.registerLocal());
    param.writeSet(writer,null,null);
  }
}","private void writeInlineArguments(MethodWriter writer,IValue instance,IArguments arguments,int localCount){
  if (instance != null) {
    instance.writeExpression(writer);
    writer.writeVarInsn(instance.getType().getStoreOpcode(),localCount);
  }
  if ((this.modifiers & Modifiers.INFIX) == Modifiers.INFIX) {
    int len=this.parameterCount;
    if ((this.modifiers & Modifiers.VARARGS) != 0) {
      len--;
      IParameter param;
      for (int i=1, j=0; i < len; i++, j++) {
        param=this.parameters[i];
        arguments.writeValue(j,param.getName(),param.getValue(),writer);
        param.setIndex(writer.registerLocal());
        param.writeSet(writer,null,null);
      }
      param=this.parameters[len];
      arguments.writeVarargsValue(len - 1,param.getName(),param.getType(),writer);
      param.setIndex(writer.registerLocal());
      param.writeSet(writer,null,null);
      return;
    }
    for (int i=1, j=0; i < this.parameterCount; i++, j++) {
      IParameter param=this.parameters[i];
      arguments.writeValue(j,param.getName(),param.getValue(),writer);
      param.setIndex(writer.registerLocal());
      param.writeSet(writer,null,null);
    }
    return;
  }
  if ((this.modifiers & Modifiers.PREFIX) == Modifiers.PREFIX) {
    arguments.writeValue(0,Name._this,null,writer);
    writer.writeVarInsn(Opcodes.ASTORE,localCount);
    return;
  }
  if ((this.modifiers & Modifiers.VARARGS) != 0) {
    int len=this.parameterCount - 1;
    IParameter param;
    for (int i=0; i < len; i++) {
      param=this.parameters[i];
      arguments.writeValue(i,param.getName(),param.getValue(),writer);
      param.setIndex(writer.registerLocal());
      param.writeSet(writer,null,null);
    }
    param=this.parameters[len];
    arguments.writeVarargsValue(len,param.getName(),param.getType(),writer);
    param.setIndex(writer.registerLocal());
    param.writeSet(writer,null,null);
    return;
  }
  for (int i=0; i < this.parameterCount; i++) {
    IParameter param=this.parameters[i];
    arguments.writeValue(i,param.getName(),param.getValue(),writer);
    param.setIndex(writer.registerLocal());
    param.writeSet(writer,null,null);
  }
}",0.9493333333333334
85091,"@Override public void writeCall(MethodWriter writer,IValue instance,IArguments arguments,IType type){
  if (instance != null && (this.modifiers & Modifiers.STATIC) != 0 && instance.getValueType() == IValue.CLASS_ACCESS) {
    instance=null;
  }
  if (this.intrinsicOpcodes != null && (instance == null || instance.isPrimitive())) {
    if (this.type.getTheClass() == Types.BOOLEAN_CLASS) {
      Label ifEnd=new Label();
      Label elseEnd=new Label();
      this.writeIntrinsic(writer,ifEnd,instance,arguments);
      writer.writeLDC(0);
      writer.writeJumpInsn(Opcodes.GOTO,elseEnd);
      writer.writeLabel(ifEnd);
      writer.writeLDC(1);
      writer.writeLabel(elseEnd);
      return;
    }
    this.writeIntrinsic(writer,instance,arguments);
    return;
  }
  if ((this.modifiers & Modifiers.INLINE) != 0) {
    this.writeInline(writer,instance,arguments);
    return;
  }
  this.writeInvoke(writer,instance,arguments);
  if (type == Types.VOID) {
    if (this.type != Types.VOID) {
      writer.writeInsn(Opcodes.POP);
    }
    return;
  }
  if (type != null) {
    if (type != this.type && !type.isSuperTypeOf(this.type)) {
      writer.writeTypeInsn(Opcodes.CHECKCAST,this.type.getInternalName());
    }
  }
}","@Override public void writeCall(MethodWriter writer,IValue instance,IArguments arguments,IType type){
  if (instance != null && (this.modifiers & Modifiers.STATIC) != 0 && instance.getValueType() == IValue.CLASS_ACCESS) {
    instance=null;
  }
  if (this.intrinsicOpcodes != null && (instance == null || instance.isPrimitive())) {
    if (this.type.getTheClass() == Types.BOOLEAN_CLASS) {
      Label ifEnd=new Label();
      Label elseEnd=new Label();
      this.writeIntrinsic(writer,ifEnd,instance,arguments);
      writer.writeLDC(0);
      writer.writeJumpInsn(Opcodes.GOTO,elseEnd);
      writer.writeLabel(ifEnd);
      writer.writeLDC(1);
      writer.writeLabel(elseEnd);
      return;
    }
    this.writeIntrinsic(writer,instance,arguments);
    return;
  }
  if ((this.modifiers & INLINABLE) != 0 && writer.inlineOffset() == 0) {
    Label inlineEnd=new Label();
    this.writeInlineArguments(writer,instance,arguments,writer.startInline(inlineEnd));
    this.value.writeExpression(writer);
    writer.endInline(inlineEnd);
    return;
  }
  this.writeInvoke(writer,instance,arguments);
  if (type == Types.VOID) {
    if (this.type != Types.VOID) {
      writer.writeInsn(Opcodes.POP);
    }
    return;
  }
  if (type != null) {
    if (type != this.type && !type.isSuperTypeOf(this.type)) {
      writer.writeTypeInsn(Opcodes.CHECKCAST,this.type.getInternalName());
    }
  }
}",0.8823529411764706
85092,"@Override public void toString(String prefix,StringBuilder buffer){
  super.toString(prefix,buffer);
  buffer.append(ModifierTypes.METHOD.toString(this.modifiers));
  if (this.type != null) {
    this.type.toString(""String_Node_Str"",buffer);
    buffer.append(' ');
  }
  buffer.append(this.name);
  if (this.genericCount > 0) {
    buffer.append('[');
    Util.astToString(prefix,this.generics,this.genericCount,Formatting.Type.genericSeperator,buffer);
    buffer.append(']');
  }
  buffer.append(Formatting.Method.parametersStart);
  Util.astToString(prefix,this.parameters,this.parameterCount,Formatting.Method.parameterSeperator,buffer);
  buffer.append(Formatting.Method.parametersEnd);
  if (this.exceptionCount > 0) {
    buffer.append(Formatting.Method.signatureThrowsSeperator);
    Util.astToString(prefix,this.exceptions,this.exceptionCount,Formatting.Method.throwsSeperator,buffer);
  }
  IValue value=this.getValue();
  if (value != null) {
    buffer.append(Formatting.Method.signatureBodySeperator);
    Formatting.appendValue(value,prefix,buffer);
  }
  buffer.append(';');
}","@Override public void toString(String prefix,StringBuilder buffer){
  super.toString(prefix,buffer);
  buffer.append(ModifierTypes.METHOD.toString(this.modifiers));
  if (this.type != null) {
    this.type.toString(""String_Node_Str"",buffer);
    buffer.append(' ');
  }
  buffer.append(this.name);
  if (this.genericCount > 0) {
    buffer.append('[');
    Util.astToString(prefix,this.generics,this.genericCount,Formatting.Type.genericSeperator,buffer);
    buffer.append(']');
  }
  buffer.append(Formatting.Method.parametersStart);
  Util.astToString(prefix,this.parameters,this.parameterCount,Formatting.Method.parameterSeperator,buffer);
  buffer.append(Formatting.Method.parametersEnd);
  if (this.exceptionCount > 0) {
    buffer.append(Formatting.Method.signatureThrowsSeperator);
    Util.astToString(prefix,this.exceptions,this.exceptionCount,Formatting.Method.throwsSeperator,buffer);
  }
  if (this.value != null) {
    buffer.append(Formatting.Method.signatureBodySeperator);
    this.value.toString(prefix,buffer);
  }
  buffer.append(';');
}",0.9599627560521417
85093,"@Override public boolean isType(IType type){
  if (type == Types.VOID || type == Types.UNKNOWN) {
    return true;
  }
  if (this.commonType != null) {
    return type.isSuperTypeOf(this.commonType);
  }
  if (this.then != null) {
    if (this.elseThen != null) {
      if (this.then.isType(type) && this.elseThen.isType(type)) {
        this.commonType=type;
        return true;
      }
    }
 else {
      return this.then.isType(type);
    }
  }
  return false;
}","@Override public boolean isType(IType type){
  if (type == Types.VOID) {
    return true;
  }
  if (this.then != null && !this.then.isType(type)) {
    return false;
  }
  if (this.elseThen != null && !this.elseThen.isType(type)) {
    return false;
  }
  return true;
}",0.2306648575305291
85094,"@Override public void toString(String prefix,StringBuilder buffer){
  buffer.append(Formatting.Statements.ifStart);
  if (this.condition != null) {
    this.condition.toString(prefix,buffer);
  }
  buffer.append(Formatting.Statements.ifEnd);
  if (this.then != null) {
    Formatting.appendValue(this.then,prefix,buffer);
    if (this.elseThen != null) {
      if (this.then.isStatement()) {
        buffer.append('\n').append(prefix);
      }
 else {
        buffer.append(' ');
      }
      buffer.append(Formatting.Statements.ifElse);
      Formatting.appendValue(this.elseThen,prefix,buffer);
    }
  }
}","@Override public void toString(String prefix,StringBuilder buffer){
  buffer.append(Formatting.Statements.ifStart);
  if (this.condition != null) {
    this.condition.toString(prefix,buffer);
  }
  buffer.append(Formatting.Statements.ifEnd);
  if (this.then != null) {
    this.then.toString(prefix,buffer);
    if (this.elseThen != null) {
      if (this.then.isStatement()) {
        buffer.append('\n').append(prefix);
      }
 else {
        buffer.append(' ');
      }
      buffer.append(Formatting.Statements.ifElse);
      this.elseThen.toString(prefix,buffer);
    }
  }
}",0.9277310924369748
85095,"@Override public void writeStatement(MethodWriter writer){
  for (int i=0; i < this.instructionCount; i++) {
    if (this.labels != null && i < this.labels.length) {
      Label l=this.labels[i];
      if (l != null) {
        writer.writeLabel(l.target);
      }
    }
    this.instructions[i].write(writer);
  }
}","@Override public void writeStatement(MethodWriter writer){
  if (this.labels == null) {
    for (int i=0; i < this.instructionCount; i++) {
      this.instructions[i].write(writer);
    }
    return;
  }
  for (int i=0; i < this.labels.length; i++) {
    Label l=this.labels[i];
    if (l != null) {
      l.target=new org.objectweb.asm.Label();
    }
  }
  for (int i=0; i < this.instructionCount; i++) {
    if (i < this.labels.length) {
      Label l=this.labels[i];
      if (l != null) {
        writer.writeLabel(l.target);
      }
    }
    this.instructions[i].write(writer);
  }
}",0.6570796460176991
85096,"@Override public void write(MethodWriter writer){
  writer.writeIINC(this.index,this.value);
}","@Override public void write(MethodWriter writer){
  writer.writeIINC(this.index + writer.inlineOffset(),this.value);
}",0.8867924528301887
85097,"@Override public void write(MethodWriter writer){
  writer.writeVarInsn(this.opcode,this.index);
}","@Override public void write(MethodWriter writer){
  writer.writeVarInsn(this.opcode,this.index + writer.inlineOffset());
}",0.8909090909090909
85098,"private void writeInlineArguments(MethodWriter writer,IArguments arguments,int localCount){
  if ((this.modifiers & Modifiers.INFIX) == Modifiers.INFIX) {
    int len=this.parameterCount;
    if ((this.modifiers & Modifiers.VARARGS) != 0) {
      len--;
      IParameter param;
      for (int i=1, j=0; i < len; i++, j++) {
        param=this.parameters[i];
        arguments.writeValue(j,param.getName(),param.getValue(),writer);
        writer.writeVarInsn(param.getType().getStoreOpcode(),i + localCount);
      }
      param=this.parameters[len];
      arguments.writeVarargsValue(len - 1,param.getName(),param.getType(),writer);
      writer.writeVarInsn(param.getType().getStoreOpcode(),len + localCount);
      return;
    }
    for (int i=1, j=0; i < this.parameterCount; i++, j++) {
      IParameter param=this.parameters[i];
      arguments.writeValue(j,param.getName(),param.getValue(),writer);
      writer.writeVarInsn(param.getType().getStoreOpcode(),i + localCount);
    }
    return;
  }
  if ((this.modifiers & Modifiers.PREFIX) == Modifiers.PREFIX) {
    arguments.writeValue(0,Name._this,null,writer);
    writer.writeVarInsn(this.getThisType().getStoreOpcode(),localCount);
    return;
  }
  if ((this.modifiers & Modifiers.VARARGS) != 0) {
    int len=this.parameterCount - 1;
    IParameter param;
    for (int i=0; i < len; i++) {
      param=this.parameters[i];
      arguments.writeValue(i,param.getName(),param.getValue(),writer);
      writer.writeVarInsn(param.getType().getStoreOpcode(),len + localCount);
    }
    param=this.parameters[len];
    arguments.writeVarargsValue(len,param.getName(),param.getType(),writer);
    writer.writeVarInsn(param.getType().getStoreOpcode(),len + localCount);
    return;
  }
  for (int i=0; i < this.parameterCount; i++) {
    IParameter param=this.parameters[i];
    arguments.writeValue(i,param.getName(),param.getValue(),writer);
    writer.writeVarInsn(param.getType().getStoreOpcode(),i + localCount);
  }
}","private void writeInlineArguments(MethodWriter writer,IArguments arguments,int localCount){
  if ((this.modifiers & Modifiers.INFIX) == Modifiers.INFIX) {
    int len=this.parameterCount;
    if ((this.modifiers & Modifiers.VARARGS) != 0) {
      len--;
      IParameter param;
      for (int i=1, j=0; i < len; i++, j++) {
        param=this.parameters[i];
        arguments.writeValue(j,param.getName(),param.getValue(),writer);
        param.setIndex(writer.registerLocal());
        param.writeSet(writer,null,null);
      }
      param=this.parameters[len];
      arguments.writeVarargsValue(len - 1,param.getName(),param.getType(),writer);
      param.setIndex(writer.registerLocal());
      param.writeSet(writer,null,null);
      return;
    }
    for (int i=1, j=0; i < this.parameterCount; i++, j++) {
      IParameter param=this.parameters[i];
      arguments.writeValue(j,param.getName(),param.getValue(),writer);
      param.setIndex(writer.registerLocal());
      param.writeSet(writer,null,null);
    }
    return;
  }
  if ((this.modifiers & Modifiers.PREFIX) == Modifiers.PREFIX) {
    arguments.writeValue(0,Name._this,null,writer);
    return;
  }
  if ((this.modifiers & Modifiers.VARARGS) != 0) {
    int len=this.parameterCount - 1;
    IParameter param;
    for (int i=0; i < len; i++) {
      param=this.parameters[i];
      arguments.writeValue(i,param.getName(),param.getValue(),writer);
      param.setIndex(writer.registerLocal());
      param.writeSet(writer,null,null);
    }
    param=this.parameters[len];
    arguments.writeVarargsValue(len,param.getName(),param.getType(),writer);
    param.setIndex(writer.registerLocal());
    param.writeSet(writer,null,null);
    return;
  }
  for (int i=0; i < this.parameterCount; i++) {
    IParameter param=this.parameters[i];
    arguments.writeValue(i,param.getName(),param.getValue(),writer);
    param.setIndex(writer.registerLocal());
    param.writeSet(writer,null,null);
  }
}",0.6593853187706376
85099,"private void writeInline(MethodWriter writer,IValue instance,IArguments arguments){
  Label inlineEnd=new Label();
  int localCount=writer.registerLocal();
  writer.startInline(inlineEnd);
  if (instance != null) {
    instance.writeExpression(writer);
    writer.writeVarInsn(instance.getType().getStoreOpcode(),localCount);
  }
  this.writeInlineArguments(writer,arguments,localCount);
  this.value.writeExpression(writer);
  writer.endInline(inlineEnd);
  writer.resetLocals(localCount);
}","private void writeInline(MethodWriter writer,IValue instance,IArguments arguments){
  Label inlineEnd=new Label();
  int localCount=writer.startInline(inlineEnd);
  if (instance != null) {
    instance.writeExpression(writer);
    writer.writeVarInsn(instance.getType().getStoreOpcode(),localCount);
  }
  this.writeInlineArguments(writer,arguments,localCount);
  this.value.writeExpression(writer);
  writer.endInline(inlineEnd);
}",0.935064935064935
85100,"@Override public void writeSet(MethodWriter writer,IValue instance,IValue value){
  value.writeExpression(writer);
  writer.writeVarInsn(this.type.getStoreOpcode(),this.index);
}","@Override public void writeSet(MethodWriter writer,IValue instance,IValue value){
  if (value != null) {
    value.writeExpression(writer);
  }
  writer.writeVarInsn(this.type.getStoreOpcode(),this.index);
}",0.9246753246753248
85101,"@Override public void writeStatement(MethodWriter writer){
  if (this.action == null) {
    this.condition.writeStatement(writer);
  }
  org.objectweb.asm.Label startLabel=new org.objectweb.asm.Label();
  writer.writeLabel(startLabel);
  this.action.writeStatement(writer);
  writer.writeLabel(this.conditionLabel.target);
  this.condition.writeJump(writer,startLabel);
  writer.writeLabel(this.endLabel.target);
}","@Override public void writeStatement(MethodWriter writer){
  if (this.action == null) {
    this.condition.writeStatement(writer);
  }
  org.objectweb.asm.Label startLabel=this.startLabel.target=new org.objectweb.asm.Label();
  org.objectweb.asm.Label conditionLabel=this.conditionLabel.target=new org.objectweb.asm.Label();
  org.objectweb.asm.Label endLabel=this.endLabel.target=new org.objectweb.asm.Label();
  writer.writeLabel(startLabel);
  this.action.writeStatement(writer);
  writer.writeLabel(conditionLabel);
  this.condition.writeJump(writer,startLabel);
  writer.writeLabel(endLabel);
}",0.7265547877591313
85102,"public DoStatement(ICodePosition position){
  this.position=position;
  this.conditionLabel=new Label($doCondition);
  this.endLabel=new Label($doEnd);
}","public DoStatement(ICodePosition position){
  this.position=position;
  this.startLabel=new Label($doStart);
  this.conditionLabel=new Label($doCondition);
  this.endLabel=new Label($doEnd);
}",0.8869565217391304
85103,"@Override public void writeStatement(MethodWriter writer){
  org.objectweb.asm.Label startLabel=this.startLabel.target;
  org.objectweb.asm.Label updateLabel=this.updateLabel.target;
  org.objectweb.asm.Label endLabel=this.endLabel.target;
  Variable var=this.variable;
  if (this.type == DEFAULT) {
    int locals=writer.registerLocal();
    if (var != null) {
      var.value.writeExpression(writer);
      var.index=locals;
      writer.writeVarInsn(var.type.getStoreOpcode(),var.index);
    }
    writer.writeLabel(startLabel);
    if (this.condition != null) {
      this.condition.writeInvJump(writer,endLabel);
    }
    if (this.then != null) {
      this.then.writeStatement(writer);
    }
    writer.writeLabel(updateLabel);
    if (this.update != null) {
      this.update.writeStatement(writer);
    }
    writer.writeJumpInsn(Opcodes.GOTO,startLabel);
    writer.resetLocals(locals);
    writer.writeLabel(endLabel);
    if (var != null) {
      writer.writeLocal(var.name.qualified,var.type,startLabel,endLabel,var.index);
    }
    return;
  }
  if (this.type == ARRAY) {
    int locals=writer.registerLocal();
    Variable arrayVar=this.var3;
    Variable indexVar=this.var1;
    Variable lengthVar=this.var2;
    org.objectweb.asm.Label scopeLabel=new org.objectweb.asm.Label();
    writer.writeLabel(scopeLabel);
    var.value.writeExpression(writer);
    var.index=locals + 1;
    indexVar.index=locals + 2;
    lengthVar.index=locals + 3;
    arrayVar.index=locals + 4;
    writer.writeInsn(Opcodes.DUP);
    arrayVar.writeSet(writer,null,null);
    writer.writeInsn(Opcodes.ARRAYLENGTH);
    lengthVar.writeSet(writer,null,null);
    writer.writeLDC(0);
    indexVar.writeSet(writer,null,null);
    writer.writeJumpInsn(Opcodes.GOTO,updateLabel);
    writer.writeLabel(startLabel);
    arrayVar.writeGet(writer,null);
    indexVar.writeGet(writer,null);
    writer.writeInsn(arrayVar.type.getArrayLoadOpcode());
    var.writeSet(writer,null,null);
    if (this.then != null) {
      this.then.writeStatement(writer);
    }
    writer.writeIINC(indexVar.index,1);
    writer.writeLabel(updateLabel);
    indexVar.writeGet(writer,null);
    lengthVar.writeGet(writer,null);
    writer.writeJumpInsn(Opcodes.IF_ICMPLT,startLabel);
    writer.resetLocals(locals);
    writer.writeLabel(endLabel);
    writer.writeLocal(var.name.qualified,var.type,scopeLabel,endLabel,var.index);
    writer.writeLocal(""String_Node_Str"",""String_Node_Str"",null,scopeLabel,endLabel,indexVar.index);
    writer.writeLocal(""String_Node_Str"",""String_Node_Str"",null,scopeLabel,endLabel,lengthVar.index);
    writer.writeLocal(""String_Node_Str"",arrayVar.type,scopeLabel,endLabel,arrayVar.index);
    return;
  }
}","@Override public void writeStatement(MethodWriter writer){
  org.objectweb.asm.Label startLabel=this.startLabel.target=new org.objectweb.asm.Label();
  org.objectweb.asm.Label updateLabel=this.updateLabel.target=new org.objectweb.asm.Label();
  org.objectweb.asm.Label endLabel=this.endLabel.target=new org.objectweb.asm.Label();
  Variable var=this.variable;
  if (this.type == DEFAULT) {
    int locals=writer.registerLocal();
    if (var != null) {
      var.value.writeExpression(writer);
      var.index=locals;
      writer.writeVarInsn(var.type.getStoreOpcode(),var.index);
    }
    writer.writeLabel(startLabel);
    if (this.condition != null) {
      this.condition.writeInvJump(writer,endLabel);
    }
    if (this.then != null) {
      this.then.writeStatement(writer);
    }
    writer.writeLabel(updateLabel);
    if (this.update != null) {
      this.update.writeStatement(writer);
    }
    writer.writeJumpInsn(Opcodes.GOTO,startLabel);
    writer.resetLocals(locals);
    writer.writeLabel(endLabel);
    if (var != null) {
      writer.writeLocal(var.name.qualified,var.type,startLabel,endLabel,var.index);
    }
    return;
  }
  if (this.type == ARRAY) {
    int locals=writer.registerLocal();
    Variable arrayVar=this.var3;
    Variable indexVar=this.var1;
    Variable lengthVar=this.var2;
    org.objectweb.asm.Label scopeLabel=new org.objectweb.asm.Label();
    writer.writeLabel(scopeLabel);
    var.value.writeExpression(writer);
    var.index=locals + 1;
    indexVar.index=locals + 2;
    lengthVar.index=locals + 3;
    arrayVar.index=locals + 4;
    writer.writeInsn(Opcodes.DUP);
    arrayVar.writeSet(writer,null,null);
    writer.writeInsn(Opcodes.ARRAYLENGTH);
    lengthVar.writeSet(writer,null,null);
    writer.writeLDC(0);
    indexVar.writeSet(writer,null,null);
    writer.writeJumpInsn(Opcodes.GOTO,updateLabel);
    writer.writeLabel(startLabel);
    arrayVar.writeGet(writer,null);
    indexVar.writeGet(writer,null);
    writer.writeInsn(arrayVar.type.getArrayLoadOpcode());
    var.writeSet(writer,null,null);
    if (this.then != null) {
      this.then.writeStatement(writer);
    }
    writer.writeIINC(indexVar.index,1);
    writer.writeLabel(updateLabel);
    indexVar.writeGet(writer,null);
    lengthVar.writeGet(writer,null);
    writer.writeJumpInsn(Opcodes.IF_ICMPLT,startLabel);
    writer.resetLocals(locals);
    writer.writeLabel(endLabel);
    writer.writeLocal(var.name.qualified,var.type,scopeLabel,endLabel,var.index);
    writer.writeLocal(""String_Node_Str"",""String_Node_Str"",null,scopeLabel,endLabel,indexVar.index);
    writer.writeLocal(""String_Node_Str"",""String_Node_Str"",null,scopeLabel,endLabel,lengthVar.index);
    writer.writeLocal(""String_Node_Str"",arrayVar.type,scopeLabel,endLabel,arrayVar.index);
    return;
  }
}",0.9814545454545456
85104,"public Label(org.objectweb.asm.Label target,Name name){
  this.target=target;
  this.name=name;
}","public Label(Name name,IValue value){
  this.name=name;
  this.value=value;
}",0.5057471264367817
85105,"@Override public void writeStatement(MethodWriter writer){
  if (this.action == null) {
    this.condition.writeStatement(writer);
  }
  writer.writeLabel(this.startLabel.target);
  this.condition.writeInvJump(writer,this.endLabel.target);
  this.action.writeStatement(writer);
  writer.writeJumpInsn(Opcodes.GOTO,this.startLabel.target);
  writer.writeLabel(this.endLabel.target);
}","@Override public void writeStatement(MethodWriter writer){
  if (this.action == null) {
    this.condition.writeStatement(writer);
  }
  org.objectweb.asm.Label startLabel=this.startLabel.target=new org.objectweb.asm.Label();
  org.objectweb.asm.Label endLabel=this.endLabel.target=new org.objectweb.asm.Label();
  writer.writeLabel(startLabel);
  this.condition.writeInvJump(writer,endLabel);
  this.action.writeStatement(writer);
  writer.writeJumpInsn(Opcodes.GOTO,startLabel);
  writer.writeLabel(endLabel);
}",0.5803571428571429
85106,public void startInline(Label end);,public int startInline(Label end);,0.927536231884058
85107,"@Override public void startInline(Label end){
  this.inlineEnd=end;
}","@Override public int startInline(Label end){
  this.inlineEnd=end;
  this.inlineOffset+=this.localIndex;
  return this.localIndex;
}",0.6567164179104478
85108,"@Override public void writeLabel(Label label){
  this.mv.visitLabel(label);
}","@Override public void writeLabel(Label label){
  if (this.hasReturn && this.inlineEnd != null) {
    this.writeInlineReturn();
  }
  this.hasReturn=false;
  this.mv.visitLabel(label);
}",0.5877862595419847
85109,"@Override public void endInline(Label end){
  this.mv.visitLabel(end);
  this.inlineEnd=null;
  this.hasReturn=false;
}","@Override public void endInline(Label end){
  this.mv.visitLabel(end);
  this.inlineEnd=null;
  this.inlineOffset=this.localIndex;
  this.hasReturn=false;
}",0.8654545454545455
85110,"@Override public IValue resolve(MarkerList markers,IContext context){
  if (this.instance != null) {
    this.instance.resolve(markers,context);
  }
  this.arguments.resolve(markers,context);
  IMethod method=IAccess.resolveMethod(context,this.instance,this.name,this.arguments);
  if (method != null) {
    this.method=method;
    return this;
  }
  Marker marker=markers.create(this.position,""String_Node_Str"",this.name.unqualified);
  marker.addInfo(""String_Node_Str"" + this.name.unqualified);
  marker.addInfo(""String_Node_Str"" + this.instance.getType());
  StringBuilder builder=new StringBuilder(""String_Node_Str"");
  Util.typesToString(""String_Node_Str"",this.arguments,""String_Node_Str"",builder);
  marker.addInfo(builder.append('}').toString());
  return this;
}","@Override public IValue resolve(MarkerList markers,IContext context){
  if (this.instance != null) {
    this.instance.resolve(markers,context);
  }
  this.arguments.resolve(markers,context);
  IMethod method=IAccess.resolveMethod(context,this.instance,this.name,this.arguments);
  if (method != null) {
    this.method=method;
    return this;
  }
  Marker marker=markers.create(this.position,""String_Node_Str"",this.name.unqualified);
  marker.addInfo(""String_Node_Str"" + this.name.unqualified);
  marker.addInfo(""String_Node_Str"" + this.instance.getType());
  StringBuilder builder=new StringBuilder(""String_Node_Str"");
  Util.typesToString(""String_Node_Str"",this.arguments,""String_Node_Str"",builder);
  marker.addInfo(builder.toString());
  return this;
}",0.9554973821989527
85111,"@Override public void writeStatement(MethodWriter writer){
  this.variable.value.writeExpression(writer);
  this.variable.writeSet(writer,null,null);
}","@Override public void writeStatement(MethodWriter writer){
  this.variable.value.writeExpression(writer);
  this.variable.index=writer.registerLocal();
  this.variable.writeSet(writer,null,null);
}",0.867816091954023
85112,"@Override public void writeExpression(MethodWriter writer){
  this.variable.value.writeExpression(writer);
  writer.writeInsn(Opcodes.DUP);
  this.variable.writeSet(writer,null,null);
}","@Override public void writeExpression(MethodWriter writer){
}",0.4959349593495935
85113,"@Override public void writeSet(MethodWriter writer,IValue instance,IValue value){
  if (value != null) {
    value.writeExpression(writer);
  }
  if (this.index == -1) {
    writer.writeVarInsn(this.type.getStoreOpcode(),this.index=writer.registerLocal());
  }
 else {
    writer.writeVarInsn(this.type.getStoreOpcode(),this.index);
  }
}","@Override public void writeSet(MethodWriter writer,IValue instance,IValue value){
  if (value != null) {
    value.writeExpression(writer);
  }
  writer.writeVarInsn(this.type.getStoreOpcode(),this.index);
}",0.5908256880733945
85114,"private void writeInlineArguments(MethodWriter writer,IArguments arguments){
  if ((this.modifiers & Modifiers.INFIX) == Modifiers.INFIX) {
    int len=this.parameterCount;
    if ((this.modifiers & Modifiers.VARARGS) != 0) {
      len--;
      IParameter param;
      for (int i=1, j=0; i < len; i++, j++) {
        param=this.parameters[i];
        arguments.writeValue(j,param.getName(),param.getValue(),writer);
        writer.writeVarInsn(param.getType().getStoreOpcode(),i);
      }
      param=this.parameters[len];
      arguments.writeVarargsValue(len - 1,param.getName(),param.getType(),writer);
      writer.writeVarInsn(param.getType().getStoreOpcode(),len);
      return;
    }
    for (int i=1, j=0; i < this.parameterCount; i++, j++) {
      IParameter param=this.parameters[i];
      arguments.writeValue(j,param.getName(),param.getValue(),writer);
      writer.writeVarInsn(param.getType().getStoreOpcode(),i);
    }
    return;
  }
  if ((this.modifiers & Modifiers.PREFIX) == Modifiers.PREFIX) {
    arguments.writeValue(0,Name._this,null,writer);
    writer.writeVarInsn(this.getThisType().getStoreOpcode(),0);
    return;
  }
  if ((this.modifiers & Modifiers.VARARGS) != 0) {
    int len=this.parameterCount - 1;
    IParameter param;
    for (int i=0; i < len; i++) {
      param=this.parameters[i];
      arguments.writeValue(i,param.getName(),param.getValue(),writer);
      writer.writeVarInsn(param.getType().getStoreOpcode(),len);
    }
    param=this.parameters[len];
    arguments.writeVarargsValue(len,param.getName(),param.getType(),writer);
    writer.writeVarInsn(param.getType().getStoreOpcode(),len);
    return;
  }
  for (int i=0; i < this.parameterCount; i++) {
    IParameter param=this.parameters[i];
    arguments.writeValue(i,param.getName(),param.getValue(),writer);
    writer.writeVarInsn(param.getType().getStoreOpcode(),i);
  }
}","private void writeInlineArguments(MethodWriter writer,IArguments arguments,int localCount){
  if ((this.modifiers & Modifiers.INFIX) == Modifiers.INFIX) {
    int len=this.parameterCount;
    if ((this.modifiers & Modifiers.VARARGS) != 0) {
      len--;
      IParameter param;
      for (int i=1, j=0; i < len; i++, j++) {
        param=this.parameters[i];
        arguments.writeValue(j,param.getName(),param.getValue(),writer);
        writer.writeVarInsn(param.getType().getStoreOpcode(),i + localCount);
      }
      param=this.parameters[len];
      arguments.writeVarargsValue(len - 1,param.getName(),param.getType(),writer);
      writer.writeVarInsn(param.getType().getStoreOpcode(),len + localCount);
      return;
    }
    for (int i=1, j=0; i < this.parameterCount; i++, j++) {
      IParameter param=this.parameters[i];
      arguments.writeValue(j,param.getName(),param.getValue(),writer);
      writer.writeVarInsn(param.getType().getStoreOpcode(),i + localCount);
    }
    return;
  }
  if ((this.modifiers & Modifiers.PREFIX) == Modifiers.PREFIX) {
    arguments.writeValue(0,Name._this,null,writer);
    writer.writeVarInsn(this.getThisType().getStoreOpcode(),localCount);
    return;
  }
  if ((this.modifiers & Modifiers.VARARGS) != 0) {
    int len=this.parameterCount - 1;
    IParameter param;
    for (int i=0; i < len; i++) {
      param=this.parameters[i];
      arguments.writeValue(i,param.getName(),param.getValue(),writer);
      writer.writeVarInsn(param.getType().getStoreOpcode(),len + localCount);
    }
    param=this.parameters[len];
    arguments.writeVarargsValue(len,param.getName(),param.getType(),writer);
    writer.writeVarInsn(param.getType().getStoreOpcode(),len + localCount);
    return;
  }
  for (int i=0; i < this.parameterCount; i++) {
    IParameter param=this.parameters[i];
    arguments.writeValue(i,param.getName(),param.getValue(),writer);
    writer.writeVarInsn(param.getType().getStoreOpcode(),i + localCount);
  }
}",0.9730290456431536
85115,"@Override public void write(ClassWriter writer){
  int modifiers=this.modifiers & 0xFFFF;
  if (this.value == null) {
    modifiers|=Modifiers.ABSTRACT;
  }
  MethodWriter mw=new MethodWriterImpl(writer,writer.visitMethod(modifiers,this.name.qualified,this.getDescriptor(),this.getSignature(),this.getExceptions()));
  if ((this.modifiers & Modifiers.STATIC) == 0) {
    mw.setInstanceMethod();
  }
  for (int i=0; i < this.annotationCount; i++) {
    this.annotations[i].write(mw);
  }
  if ((this.modifiers & Modifiers.INLINE) == Modifiers.INLINE) {
    mw.addAnnotation(""String_Node_Str"",false);
  }
  if ((this.modifiers & Modifiers.INFIX) == Modifiers.INFIX) {
    mw.addAnnotation(""String_Node_Str"",false);
  }
  if ((this.modifiers & Modifiers.PREFIX) == Modifiers.PREFIX) {
    mw.addAnnotation(""String_Node_Str"",false);
  }
  if ((this.modifiers & Modifiers.DEPRECATED) == Modifiers.DEPRECATED) {
    mw.addAnnotation(""String_Node_Str"",true);
  }
  if ((this.modifiers & Modifiers.SEALED) == Modifiers.SEALED) {
    mw.addAnnotation(""String_Node_Str"",false);
  }
  for (int i=0; i < this.parameterCount; i++) {
    this.parameters[i].write(mw);
  }
  Label start=new Label();
  Label end=new Label();
  if (this.value != null) {
    if (this.value instanceof StatementList) {
      ((StatementList)this.value).topLevel=true;
    }
    mw.begin();
    mw.writeLabel(start);
    if (this.type == Types.VOID) {
      this.value.writeStatement(mw);
    }
 else {
      this.value.writeExpression(mw);
    }
    mw.writeLabel(end);
    mw.end(this.type);
  }
  if ((this.modifiers & Modifiers.STATIC) == 0) {
    mw.writeLocal(""String_Node_Str"",this.theClass.getType(),start,end,0);
  }
  for (int i=0; i < this.parameterCount; i++) {
    IParameter param=this.parameters[i];
    mw.writeLocal(param.getName().qualified,param.getType(),start,end,param.getIndex());
  }
}","@Override public void write(ClassWriter writer){
  int modifiers=this.modifiers & 0xFFFF;
  if (this.value == null) {
    modifiers|=Modifiers.ABSTRACT;
  }
  MethodWriter mw=new MethodWriterImpl(writer,writer.visitMethod(modifiers,this.name.qualified,this.getDescriptor(),this.getSignature(),this.getExceptions()));
  if ((this.modifiers & Modifiers.STATIC) == 0) {
    mw.setInstanceMethod();
  }
  for (int i=0; i < this.annotationCount; i++) {
    this.annotations[i].write(mw);
  }
  if ((this.modifiers & Modifiers.INLINE) == Modifiers.INLINE) {
    mw.addAnnotation(""String_Node_Str"",false);
  }
  if ((this.modifiers & Modifiers.INFIX) == Modifiers.INFIX) {
    mw.addAnnotation(""String_Node_Str"",false);
  }
  if ((this.modifiers & Modifiers.PREFIX) == Modifiers.PREFIX) {
    mw.addAnnotation(""String_Node_Str"",false);
  }
  if ((this.modifiers & Modifiers.DEPRECATED) == Modifiers.DEPRECATED) {
    mw.addAnnotation(""String_Node_Str"",true);
  }
  if ((this.modifiers & Modifiers.SEALED) == Modifiers.SEALED) {
    mw.addAnnotation(""String_Node_Str"",false);
  }
  for (int i=0; i < this.parameterCount; i++) {
    this.parameters[i].write(mw);
  }
  Label start=new Label();
  Label end=new Label();
  if (this.value != null) {
    mw.begin();
    mw.writeLabel(start);
    this.value.writeExpression(mw);
    mw.writeLabel(end);
    mw.end(this.type);
  }
  if ((this.modifiers & Modifiers.STATIC) == 0) {
    mw.writeLocal(""String_Node_Str"",this.theClass.getType(),start,end,0);
  }
  for (int i=0; i < this.parameterCount; i++) {
    IParameter param=this.parameters[i];
    mw.writeLocal(param.getName().qualified,param.getType(),start,end,param.getIndex());
  }
}",0.9251126126126126
85116,"private void writeInline(MethodWriter writer,IValue instance,IArguments arguments){
  Label inlineEnd=new Label();
  writer.startInline(inlineEnd);
  if (instance != null) {
    instance.writeExpression(writer);
    writer.writeVarInsn(instance.getType().getStoreOpcode(),0);
  }
  this.writeInlineArguments(writer,arguments);
  this.value.writeExpression(writer);
  writer.endInline(inlineEnd);
}","private void writeInline(MethodWriter writer,IValue instance,IArguments arguments){
  Label inlineEnd=new Label();
  int localCount=writer.registerLocal();
  writer.startInline(inlineEnd);
  if (instance != null) {
    instance.writeExpression(writer);
    writer.writeVarInsn(instance.getType().getStoreOpcode(),localCount);
  }
  this.writeInlineArguments(writer,arguments,localCount);
  this.value.writeExpression(writer);
  writer.endInline(inlineEnd);
  writer.resetLocals(localCount);
}",0.890888638920135
85117,"@Override public void writeStatement(MethodWriter writer){
  org.objectweb.asm.Label start=new org.objectweb.asm.Label();
  org.objectweb.asm.Label end=new org.objectweb.asm.Label();
  writer.writeLabel(start);
  int count=writer.registerLocal();
  if (this.labels == null) {
    for (int i=0; i < this.valueCount; i++) {
      this.values[i].writeStatement(writer);
    }
  }
 else {
    for (int i=0; i < this.valueCount; i++) {
      Label l=this.labels[i];
      if (l != null) {
        writer.writeLabel(l.target);
      }
      this.values[i].writeStatement(writer);
    }
  }
  if (!this.topLevel) {
    writer.resetLocals(count);
  }
  writer.writeLabel(end);
  if (this.variables == null) {
    return;
  }
  for (  Entry<Name,Variable> entry : this.variables.entrySet()) {
    Variable var=entry.getValue();
    writer.writeLocal(var.name.qualified,var.type.getExtendedName(),var.type.getSignature(),start,end,var.index);
  }
}","@Override public void writeStatement(MethodWriter writer){
  org.objectweb.asm.Label start=new org.objectweb.asm.Label();
  org.objectweb.asm.Label end=new org.objectweb.asm.Label();
  writer.writeLabel(start);
  int count=writer.registerLocal();
  if (this.labels == null) {
    for (int i=0; i < this.valueCount; i++) {
      this.values[i].writeStatement(writer);
    }
  }
 else {
    for (int i=0; i < this.valueCount; i++) {
      Label l=this.labels[i];
      if (l != null) {
        writer.writeLabel(l.target);
      }
      this.values[i].writeStatement(writer);
    }
  }
  writer.resetLocals(count);
  writer.writeLabel(end);
  if (this.variables == null) {
    return;
  }
  for (  Entry<Name,Variable> entry : this.variables.entrySet()) {
    Variable var=entry.getValue();
    writer.writeLocal(var.name.qualified,var.type.getExtendedName(),var.type.getSignature(),start,end,var.index);
  }
}",0.9837486457204768
85118,"@Override public void writeExpression(MethodWriter writer){
  if (this.requiredType == Types.VOID) {
    this.writeStatement(writer);
    return;
  }
  org.objectweb.asm.Label start=new org.objectweb.asm.Label();
  org.objectweb.asm.Label end=new org.objectweb.asm.Label();
  writer.writeLabel(start);
  int count=writer.registerLocal();
  int len=this.valueCount - 1;
  if (this.labels == null) {
    for (int i=0; i < len; i++) {
      this.values[i].writeStatement(writer);
    }
    this.values[len].writeExpression(writer);
  }
 else {
    for (int i=0; i < len; i++) {
      Label l=this.labels[i];
      if (l != null) {
        writer.writeLabel(l.target);
      }
      this.values[i].writeStatement(writer);
    }
    Label l=this.labels[len];
    if (l != null) {
      writer.writeLabel(l.target);
    }
    this.values[len].writeExpression(writer);
  }
  if (!(this.context instanceof IMethod)) {
    writer.resetLocals(count);
  }
  writer.writeLabel(end);
  if (this.variables == null) {
    return;
  }
  for (  Entry<Name,Variable> entry : this.variables.entrySet()) {
    Variable var=entry.getValue();
    writer.writeLocal(var.name.qualified,var.type.getExtendedName(),var.type.getSignature(),start,end,var.index);
  }
}","@Override public void writeExpression(MethodWriter writer){
  if (this.requiredType == Types.VOID) {
    this.writeStatement(writer);
    return;
  }
  org.objectweb.asm.Label start=new org.objectweb.asm.Label();
  org.objectweb.asm.Label end=new org.objectweb.asm.Label();
  writer.writeLabel(start);
  int count=writer.registerLocal();
  int len=this.valueCount - 1;
  if (this.labels == null) {
    for (int i=0; i < len; i++) {
      this.values[i].writeStatement(writer);
    }
    this.values[len].writeExpression(writer);
  }
 else {
    for (int i=0; i < len; i++) {
      Label l=this.labels[i];
      if (l != null) {
        writer.writeLabel(l.target);
      }
      this.values[i].writeStatement(writer);
    }
    Label l=this.labels[len];
    if (l != null) {
      writer.writeLabel(l.target);
    }
    this.values[len].writeExpression(writer);
  }
  writer.resetLocals(count);
  writer.writeLabel(end);
  if (this.variables == null) {
    return;
  }
  for (  Entry<Name,Variable> entry : this.variables.entrySet()) {
    Variable var=entry.getValue();
    writer.writeLocal(var.name.qualified,var.type.getExtendedName(),var.type.getSignature(),start,end,var.index);
  }
}",0.959670781893004
85119,"public static void saveClass(File file,IClass iclass){
  createFile(file);
  try (OutputStream os=new BufferedOutputStream(new FileOutputStream(file))){
    org.objectweb.asm.ClassWriter writer=new org.objectweb.asm.ClassWriter(DyvilCompiler.asmVersion | org.objectweb.asm.ClassWriter.COMPUTE_FRAMES);
    iclass.write(writer);
    writer.visitEnd();
    byte[] bytes=writer.toByteArray();
    os.write(bytes,0,bytes.length);
  }
 catch (  Exception ex) {
    DyvilCompiler.logger.throwing(""String_Node_Str"",""String_Node_Str"",ex);
  }
}","public static void saveClass(File file,IClass iclass){
  createFile(file);
  try (OutputStream os=new BufferedOutputStream(new FileOutputStream(file))){
    int ver=DyvilCompiler.asmVersion | org.objectweb.asm.ClassWriter.COMPUTE_FRAMES;
    org.objectweb.asm.ClassWriter writer=new org.objectweb.asm.ClassWriter(ver);
    iclass.write(writer);
    writer.visitEnd();
    byte[] bytes=writer.toByteArray();
    os.write(bytes,0,bytes.length);
  }
 catch (  Throwable ex) {
    DyvilCompiler.logger.throwing(""String_Node_Str"",""String_Node_Str"",ex);
  }
}",0.8429752066115702
85120,"@Override public void writeInsn(int opcode){
  if (this.hasReturn && this.inlineEnd != null) {
    this.writeInlineReturn();
  }
  this.hasReturn=false;
  if (opcode > 255) {
    this.visitSpecialInsn(opcode);
    return;
  }
  this.mv.visitInsn(opcode);
}","@Override public void writeInsn(int opcode){
  if (this.hasReturn && this.inlineEnd != null) {
    this.writeInlineReturn();
  }
  this.hasReturn=false;
  if (opcode > 255) {
    this.visitSpecialInsn(opcode);
    return;
  }
  if (opcode >= IRETURN && opcode <= RETURN) {
    this.hasReturn=true;
    if (this.inlineEnd != null) {
      return;
    }
  }
  this.mv.visitInsn(opcode);
}",0.7975077881619937
85121,"@Override public AnnotationVisitor visitAnnotation(String type,boolean visible){
  String packName=ClassFormat.extendedToPackage(type);
  if (packName.equals(""String_Node_Str"")) {
    this.method.addModifier(Modifiers.INLINE);
    this.inline=true;
  }
  if (this.method.addRawAnnotation(packName)) {
    Annotation annotation=new Annotation(new dyvil.tools.compiler.ast.type.Type(packName));
    return new AnnotationVisitorImpl(this.method,annotation);
  }
  return null;
}","@Override public AnnotationVisitor visitAnnotation(String type,boolean visible){
  String packName=ClassFormat.extendedToPackage(type);
  if (""String_Node_Str"".equals(packName)) {
    this.method.addModifier(Modifiers.INLINE);
    this.inline=true;
  }
  if (this.method.addRawAnnotation(packName)) {
    Annotation annotation=new Annotation(new dyvil.tools.compiler.ast.type.Type(packName));
    return new AnnotationVisitorImpl(this.method,annotation);
  }
  return null;
}",0.9663157894736842
85122,"@Override public void parse(IParserManager pm,IToken token) throws SyntaxError {
  int type=token.type();
  if (type == Symbols.CLOSE_CURLY_BRACKET) {
    pm.popParser(true);
    return;
  }
  if (this.mode == EXPRESSION) {
    if (ParserUtil.isIdentifier(type) && token.next().type() == Symbols.COLON) {
      this.label=token.nameValue();
      pm.skip();
      return;
    }
    this.firstToken=token;
    this.parser=this.typeParser=new TypeParser(this);
    this.pm=pm;
    this.mode=TYPE;
  }
  if (this.mode == TYPE) {
    if (ParserUtil.isIdentifier(type) && token.next().type() == Symbols.EQUALS) {
      if (this.type == null) {
        this.typeParser.end();
      }
      if (this.type != null) {
        FieldInitializer fi=new FieldInitializer(token.raw(),token.nameValue(),this.type);
        pm.pushParser(new ExpressionParser(fi));
        this.statementList.addValue(fi);
      }
 else {
        FieldAssign fa=new FieldAssign(token.raw(),null,token.nameValue());
        pm.pushParser(new ExpressionParser(fa));
        this.statementList.addValue(fa);
      }
      this.reset();
      this.mode=SEPARATOR;
      pm.skip();
      return;
    }
 else     if (this.typeParser == null) {
      pm.jump(this.firstToken);
      this.reset();
      pm.pushParser(new ExpressionParser(this));
      this.mode=SEPARATOR;
      return;
    }
    if (type == Symbols.SEMICOLON && token.isInferred()) {
      return;
    }
    try {
      this.parser.parse(this,token);
    }
 catch (    Throwable ex) {
      pm.jump(this.firstToken);
      this.reset();
      pm.pushParser(new ExpressionParser(this));
      this.mode=SEPARATOR;
    }
    return;
  }
  if (this.mode == SEPARATOR) {
    if (type == Symbols.SEMICOLON) {
      this.mode=EXPRESSION;
      return;
    }
    if (ParserUtil.isCloseBracket(type)) {
      pm.popParser(true);
      return;
    }
    if (token.prev().type() == Symbols.CLOSE_CURLY_BRACKET) {
      this.mode=EXPRESSION;
      pm.reparse();
      return;
    }
    throw new SyntaxError(token,""String_Node_Str"");
  }
}","@Override public void parse(IParserManager pm,IToken token) throws SyntaxError {
  int type=token.type();
  if (type == Symbols.CLOSE_CURLY_BRACKET) {
    pm.popParser(true);
    return;
  }
  if (this.mode == EXPRESSION) {
    if (ParserUtil.isIdentifier(type) && token.next().type() == Symbols.COLON) {
      this.label=token.nameValue();
      pm.skip();
      return;
    }
    this.firstToken=token;
    this.parser=this.typeParser=new TypeParser(this);
    this.pm=pm;
    this.mode=TYPE;
  }
  if (this.mode == TYPE) {
    if (ParserUtil.isIdentifier(type) && token.next().type() == Symbols.EQUALS) {
      if (this.type == null) {
        this.typeParser.end();
      }
      if (this.type != null) {
        FieldInitializer fi=new FieldInitializer(token.raw(),token.nameValue(),this.type);
        pm.pushParser(new ExpressionParser(fi));
        this.statementList.addValue(fi);
      }
 else {
        FieldAssign fa=new FieldAssign(token.raw(),null,token.nameValue());
        pm.pushParser(new ExpressionParser(fa));
        this.statementList.addValue(fa);
      }
      this.reset();
      this.mode=SEPARATOR;
      pm.skip();
      return;
    }
 else     if (this.typeParser == null) {
      pm.jump(this.firstToken);
      this.reset();
      pm.pushParser(new ExpressionParser(this));
      this.mode=SEPARATOR;
      return;
    }
    try {
      this.parser.parse(this,token);
    }
 catch (    Throwable ex) {
      pm.jump(this.firstToken);
      this.reset();
      pm.pushParser(new ExpressionParser(this));
      this.mode=SEPARATOR;
    }
    return;
  }
  if (this.mode == SEPARATOR) {
    if (type == Symbols.SEMICOLON) {
      this.mode=EXPRESSION;
      return;
    }
    if (ParserUtil.isCloseBracket(type)) {
      pm.popParser(true);
      return;
    }
    if (token.prev().type() == Symbols.CLOSE_CURLY_BRACKET) {
      this.mode=EXPRESSION;
      pm.reparse();
      return;
    }
    throw new SyntaxError(token,""String_Node_Str"");
  }
}",0.9804116042648152
85123,"@Override public void resolveTypes(){
  for (  Import i : this.imports) {
    i.resolveTypes(this.markers);
  }
  for (  Import i : this.staticImports) {
    i.resolveTypes(this.markers);
  }
  for (  IClass i : this.classes) {
    i.resolveTypes(this.markers,Package.rootPackage);
  }
}","@Override public void resolveTypes(){
  for (  Import i : this.imports) {
    i.resolveTypes(this.markers);
  }
  for (  Import i : this.staticImports) {
    i.resolveTypes(this.markers);
  }
  for (  IClass i : this.classes) {
    i.resolveTypes(this.markers,this);
  }
}",0.958855098389982
85124,"@Override public void visitLocalVariable(String name,String desc,String signature,Label start,Label end,int index){
  if (this.method.hasModifier(Modifiers.STATIC)) {
    if (index != 0 && index <= this.method.parameterCount()) {
      this.method.getParameter(index - 1).setName(Name.getQualified(name));
    }
  }
 else   if (index < this.method.parameterCount()) {
    this.method.getParameter(index).setName(Name.getQualified(name));
  }
}","@Override public void visitLocalVariable(String name,String desc,String signature,Label start,Label end,int index){
  if (this.method.hasModifier(Modifiers.STATIC)) {
    if (index < this.method.parameterCount()) {
      this.method.getParameter(index).setName(Name.getQualified(name));
    }
  }
 else   if (index != 0 && index <= this.method.parameterCount()) {
    this.method.getParameter(index - 1).setName(Name.getQualified(name));
  }
}",0.6975169300225733
85125,"@Override public void parse(IParserManager pm,IToken token) throws SyntaxError {
  int type=token.type();
  if (this.mode == KEY) {
    if (ParserUtil.isIdentifier(type)) {
      this.mode=EQUALS;
      this.key=token.nameValue();
      return;
    }
    throw new SyntaxError(token,""String_Node_Str"");
  }
  if (this.mode == EQUALS) {
    if (type == Tokens.EQUALS) {
      this.mode=VALUE;
      return;
    }
    throw new SyntaxError(token,""String_Node_Str"");
  }
 else   if (this.mode == VALUE) {
    if (type == Symbols.OPEN_SQUARE_BRACKET) {
      this.mode=ARRAY;
      return;
    }
    this.setProperty(this.key,token);
    this.mode=KEY;
    this.key=null;
    return;
  }
 else   if (this.mode == ARRAY) {
    if (type == Symbols.CLOSE_SQUARE_BRACKET) {
      this.mode=KEY;
      this.key=null;
      return;
    }
    this.setProperty(this.key,token);
    return;
  }
}","@Override public void parse(IParserManager pm,IToken token) throws SyntaxError {
  int type=token.type();
  if (this.mode == KEY) {
    if (ParserUtil.isIdentifier(type)) {
      this.mode=EQUALS;
      this.key=token.nameValue();
      return;
    }
    throw new SyntaxError(token,""String_Node_Str"");
  }
  if (this.mode == EQUALS) {
    if (type == Symbols.EQUALS) {
      this.mode=VALUE;
      return;
    }
    throw new SyntaxError(token,""String_Node_Str"");
  }
 else   if (this.mode == VALUE) {
    if (type == Symbols.OPEN_SQUARE_BRACKET) {
      this.mode=ARRAY;
      return;
    }
    this.setProperty(this.key,token);
    this.mode=KEY;
    this.key=null;
    return;
  }
 else   if (this.mode == ARRAY) {
    if (type == Symbols.CLOSE_SQUARE_BRACKET) {
      this.mode=KEY;
      this.key=null;
      return;
    }
    this.setProperty(this.key,token);
    return;
  }
}",0.9937747594793436
85126,"private static int getMode(char c,String code,int i){
switch (c) {
case '""':
    return STRING;
case '\'':
  return CHAR;
case '/':
char n=code.charAt(i + 1);
if (n == '*') {
return BLOCK_COMMENT;
}
 else if (n == '/') {
return LINE_COMMENT;
}
 else {
return IDENTIFIER | MOD_SYMBOL;
}
case '@':
n=code.charAt(i + 1);
if (n == '""') {
return STRING_2;
}
return IDENTIFIER | MOD_SYMBOL;
case '0':
n=code.charAt(i + 1);
if (n == 'b') {
return INT | MOD_BIN;
}
 else if (n == 'x') {
return INT | MOD_HEX;
}
 else if (isDigit(n)) {
return INT | MOD_OCT;
}
return INT;
case '(':
return Symbols.OPEN_PARENTHESIS;
case ')':
return Symbols.CLOSE_PARENTHESIS;
case '[':
return Symbols.OPEN_SQUARE_BRACKET;
case ']':
return Symbols.CLOSE_SQUARE_BRACKET;
case '{':
return Symbols.OPEN_CURLY_BRACKET;
case '}':
return Symbols.CLOSE_CURLY_BRACKET;
case '.':
n=code.charAt(i + 1);
if (n == '.') {
return IDENTIFIER | MOD_DOTS;
}
return DOT;
case ';':
return SEMICOLON;
case ',':
return COMMA;
}
if (isDigit(c)) {
return INT;
}
 else if (isIdentifierSymbol(c)) {
return IDENTIFIER | MOD_SYMBOL;
}
 else if (isIdentifierPart(c)) {
return IDENTIFIER | MOD_LETTER;
}
return 0;
}","private static int getMode(char c,String code,int i){
switch (c) {
case '""':
    return STRING;
case '\'':
  return CHAR;
case '/':
char n=code.charAt(i + 1);
if (n == '*') {
return BLOCK_COMMENT;
}
 else if (n == '/') {
return LINE_COMMENT;
}
 else {
return IDENTIFIER | MOD_SYMBOL;
}
case '@':
n=code.charAt(i + 1);
if (n == '""') {
return STRING_2;
}
return IDENTIFIER | MOD_SYMBOL;
case '0':
n=code.charAt(i + 1);
if (n == 'b') {
return INT | MOD_BIN;
}
 else if (n == 'x') {
return INT | MOD_HEX;
}
 else if (isDigit(n)) {
return INT | MOD_OCT;
}
return INT;
case '(':
return Symbols.OPEN_PARENTHESIS;
case ')':
return Symbols.CLOSE_PARENTHESIS;
case '[':
return Symbols.OPEN_SQUARE_BRACKET;
case ']':
return Symbols.CLOSE_SQUARE_BRACKET;
case '{':
return Symbols.OPEN_CURLY_BRACKET;
case '}':
return Symbols.CLOSE_CURLY_BRACKET;
case '.':
n=code.charAt(i + 1);
if (n == '.') {
return IDENTIFIER | MOD_DOTS;
}
return Symbols.DOT;
case ';':
return Symbols.SEMICOLON;
case ',':
return Symbols.COMMA;
}
if (isDigit(c)) {
return INT;
}
 else if (isIdentifierSymbol(c)) {
return IDENTIFIER | MOD_SYMBOL;
}
 else if (isIdentifierPart(c)) {
return IDENTIFIER | MOD_LETTER;
}
return 0;
}",0.8932536293766012
85127,"@Override public int type(){
  return Tokens.SEMICOLON;
}","@Override public int type(){
  return Symbols.SEMICOLON;
}",0.9217391304347826
85128,"@Override public int endIndex(){
  return this.type == Tokens.ARROW_OPERATOR ? this.start + 2 : this.start + 1;
}","@Override public int endIndex(){
  return this.type == Symbols.ARROW_OPERATOR ? this.start + 2 : this.start + 1;
}",0.960352422907489
85129,"/** 
 * Returns true if the given   {@link IToken} {@code token} should be parsed.If not, it gets removed from the Token Chain.
 * @param value the value of the token
 * @param token the token
 * @return true, if the token should be parsed or removed from the tokenstream
 */
public boolean retainToken(IToken token,IToken prev){
  if (!this.semicolonInference) {
    return true;
  }
  if (prev == null) {
    return true;
  }
  int prevLN=prev.endLine();
  if (prevLN == token.startLine()) {
    return true;
  }
  int type=token.type();
  if (type != Symbols.OPEN_SQUARE_BRACKET && (type & (Tokens.SYMBOL | Tokens.KEYWORD | Tokens.IDENTIFIER)) == 0) {
    return true;
  }
  int type1=prev.type();
  if (ParserUtil.isSeperator(type1)) {
    return true;
  }
  int prevEnd=prev.endIndex();
  IToken semicolon=new InferredSemicolon(prevLN,prevEnd);
  semicolon.setNext(token);
  prev.setNext(semicolon);
  return true;
}","/** 
 * Returns true if the given   {@link IToken} {@code token} should be parsed.If not, it gets removed from the Token Chain.
 * @param value the value of the token
 * @param token the token
 * @return true, if the token should be parsed or removed from the tokenstream
 */
public boolean retainToken(IToken token,IToken prev){
  if (!this.semicolonInference) {
    return true;
  }
  if (prev == null) {
    return true;
  }
  int prevLN=prev.endLine();
  if (prevLN == token.startLine()) {
    return true;
  }
  int type=token.type();
  if ((type & (Tokens.SYMBOL | Tokens.KEYWORD | Tokens.IDENTIFIER| Tokens.BRACKET)) == 0) {
    return true;
  }
  if (type == Symbols.OPEN_CURLY_BRACKET) {
    return true;
  }
  int type1=prev.type();
  if (ParserUtil.isSeperator(type1)) {
    return true;
  }
  int prevEnd=prev.endIndex();
  IToken semicolon=new InferredSemicolon(prevLN,prevEnd);
  semicolon.setNext(token);
  prev.setNext(semicolon);
  return true;
}",0.8980891719745223
85130,"@Override public void parse(IParserManager pm,IToken token) throws SyntaxError {
  int type=token.type();
  if (this.mode == NAME) {
    if (ParserUtil.isIdentifier(type)) {
      Name name=token.nameValue();
      this.annotation.name=name;
      this.annotation.type=new AnnotationType(token,name);
      this.mode=PARAMETERS_START;
      return;
    }
    throw new SyntaxError(token,""String_Node_Str"");
  }
  if (this.mode == PARAMETERS_START) {
    if (type == Symbols.OPEN_PARENTHESIS) {
      IToken next=token.next();
      if (ParserUtil.isIdentifier(next.type()) && next.next().type() == Tokens.COLON) {
        ArgumentMap map=new ArgumentMap();
        this.annotation.arguments=map;
        pm.pushParser(new ExpressionMapParser(map));
      }
 else {
        ArgumentList list=new ArgumentList();
        this.annotation.arguments=list;
        pm.pushParser(new ExpressionListParser(list));
      }
      this.mode=PARAMETERS_END;
      return;
    }
    if (!ParserUtil.isIdentifier(type) && !ParserUtil.isTerminator2(type)) {
      SingleArgument arg=new SingleArgument();
      this.annotation.arguments=arg;
      pm.popParser();
      pm.pushParser(new ExpressionParser(arg),true);
      return;
    }
    pm.popParser(true);
    return;
  }
  if (this.mode == PARAMETERS_END) {
    if (type == Symbols.CLOSE_PARENTHESIS) {
      pm.popParser();
      return;
    }
    throw new SyntaxError(token,""String_Node_Str"");
  }
}","@Override public void parse(IParserManager pm,IToken token) throws SyntaxError {
  int type=token.type();
  if (this.mode == NAME) {
    if (ParserUtil.isIdentifier(type)) {
      Name name=token.nameValue();
      this.annotation.name=name;
      this.annotation.type=new AnnotationType(token,name);
      this.mode=PARAMETERS_START;
      return;
    }
    throw new SyntaxError(token,""String_Node_Str"");
  }
  if (this.mode == PARAMETERS_START) {
    if (type == Symbols.OPEN_PARENTHESIS) {
      IToken next=token.next();
      if (ParserUtil.isIdentifier(next.type()) && next.next().type() == Symbols.COLON) {
        ArgumentMap map=new ArgumentMap();
        this.annotation.arguments=map;
        pm.pushParser(new ExpressionMapParser(map));
      }
 else {
        ArgumentList list=new ArgumentList();
        this.annotation.arguments=list;
        pm.pushParser(new ExpressionListParser(list));
      }
      this.mode=PARAMETERS_END;
      return;
    }
    if (!ParserUtil.isIdentifier(type) && !ParserUtil.isTerminator2(type)) {
      SingleArgument arg=new SingleArgument();
      this.annotation.arguments=arg;
      pm.popParser();
      pm.pushParser(new ExpressionParser(arg),true);
      return;
    }
    pm.popParser(true);
    return;
  }
  if (this.mode == PARAMETERS_END) {
    if (type == Symbols.CLOSE_PARENTHESIS) {
      pm.popParser();
      return;
    }
    throw new SyntaxError(token,""String_Node_Str"");
  }
}",0.9961898164184274
85131,"@Override public void parse(IParserManager pm,IToken token) throws SyntaxError {
  int type=token.type();
  if (type == Tokens.SEMICOLON) {
    return;
  }
  if (type == Symbols.CLOSE_CURLY_BRACKET) {
    pm.popParser(true);
    return;
  }
  if (this.mode == INSTRUCTION) {
    IInstruction insn=null;
    if (type == Keywords.GOTO) {
      IToken next=token.next();
      if (!ParserUtil.isIdentifier(next.type())) {
        throw new SyntaxError(token,""String_Node_Str"");
      }
      pm.skip();
      insn=new JumpInstruction(Opcodes.GOTO,new Label(next.nameValue()));
    }
    if (ParserUtil.isIdentifier(type)) {
      Name name=token.nameValue();
      if (token.next().type() == Tokens.COLON) {
        pm.skip();
        this.label=name;
        return;
      }
      int opcode=Opcodes.parseOpcode(name.qualified);
      if (opcode == -1) {
        throw new SyntaxError(token,""String_Node_Str"" + name + ""String_Node_Str"");
      }
      insn=handleOpcode(pm,token,opcode);
    }
    if (insn != null) {
      if (this.label != null) {
        this.bytecode.addInstruction(insn,new Label(this.label));
        this.label=null;
        return;
      }
      this.bytecode.addInstruction(insn);
      return;
    }
    throw new SyntaxError(token,""String_Node_Str"");
  }
}","@Override public void parse(IParserManager pm,IToken token) throws SyntaxError {
  int type=token.type();
  if (type == Symbols.SEMICOLON) {
    return;
  }
  if (type == Symbols.CLOSE_CURLY_BRACKET) {
    pm.popParser(true);
    return;
  }
  if (this.mode == INSTRUCTION) {
    IInstruction insn=null;
    if (type == Keywords.GOTO) {
      IToken next=token.next();
      if (!ParserUtil.isIdentifier(next.type())) {
        throw new SyntaxError(token,""String_Node_Str"");
      }
      pm.skip();
      insn=new JumpInstruction(Opcodes.GOTO,new Label(next.nameValue()));
    }
    if (ParserUtil.isIdentifier(type)) {
      Name name=token.nameValue();
      if (token.next().type() == Symbols.COLON) {
        pm.skip();
        this.label=name;
        return;
      }
      int opcode=Opcodes.parseOpcode(name.qualified);
      if (opcode == -1) {
        throw new SyntaxError(token,""String_Node_Str"" + name + ""String_Node_Str"");
      }
      insn=handleOpcode(pm,token,opcode);
    }
    if (insn != null) {
      if (this.label != null) {
        this.bytecode.addInstruction(insn,new Label(this.label));
        this.label=null;
        return;
      }
      this.bytecode.addInstruction(insn);
      return;
    }
    throw new SyntaxError(token,""String_Node_Str"");
  }
}",0.9914263445050664
85132,"@Override public void parse(IParserManager pm,IToken token) throws SyntaxError {
  int type=token.type();
  if (type == Tokens.SEMICOLON) {
    pm.popParser(true);
    return;
  }
  if (this.mode == OWNER) {
    pm.pushParser(new InternalTypeParser(this),true);
    this.mode=DOT;
    return;
  }
  if (this.mode == DOT) {
    if (type != Tokens.DOT) {
      throw new SyntaxError(token,""String_Node_Str"");
    }
    this.mode=COLON;
    IToken next=token.next();
    if (!ParserUtil.isIdentifier(next.type())) {
      throw new SyntaxError(next,""String_Node_Str"");
    }
    pm.skip();
    this.fieldInstruction.setFieldName(next.nameValue().qualified);
    return;
  }
  if (this.mode == COLON) {
    if (type != Tokens.COLON) {
      throw new SyntaxError(token,""String_Node_Str"");
    }
    pm.pushParser(new InternalTypeParser(this));
    return;
  }
}","@Override public void parse(IParserManager pm,IToken token) throws SyntaxError {
  int type=token.type();
  if (type == Symbols.SEMICOLON) {
    pm.popParser(true);
    return;
  }
  if (this.mode == OWNER) {
    pm.pushParser(new InternalTypeParser(this),true);
    this.mode=DOT;
    return;
  }
  if (this.mode == DOT) {
    if (type != Symbols.DOT) {
      throw new SyntaxError(token,""String_Node_Str"");
    }
    this.mode=COLON;
    IToken next=token.next();
    if (!ParserUtil.isIdentifier(next.type())) {
      throw new SyntaxError(next,""String_Node_Str"");
    }
    pm.skip();
    this.fieldInstruction.setFieldName(next.nameValue().qualified);
    return;
  }
  if (this.mode == COLON) {
    if (type != Symbols.COLON) {
      throw new SyntaxError(token,""String_Node_Str"");
    }
    pm.pushParser(new InternalTypeParser(this));
    return;
  }
}",0.9807804309842748
85133,"@Override public void parse(IParserManager pm,IToken token) throws SyntaxError {
  int type=token.type();
  if (type == Tokens.SEMICOLON) {
    pm.popParser(true);
    return;
  }
  if (this.mode == OWNER) {
    if (type == Keywords.INTERFACE) {
      this.methodInstruction.setInterface(true);
    }
    pm.pushParser(new InternalTypeParser(this),true);
    this.mode=DOT;
    return;
  }
  if (this.mode == DOT) {
    if (type != Tokens.DOT) {
      throw new SyntaxError(token,""String_Node_Str"");
    }
    this.mode=PARAMETERS;
    IToken next=token.next();
    if (!ParserUtil.isIdentifier(next.type())) {
      throw new SyntaxError(next,""String_Node_Str"");
    }
    pm.skip();
    this.methodInstruction.setMethodName(next.nameValue().qualified);
    return;
  }
  if (this.mode == PARAMETERS) {
    if (type == Symbols.OPEN_PARENTHESIS) {
      pm.pushParser(new InternalTypeParser(this));
      this.mode=PARAMETERS_END;
      return;
    }
    throw new SyntaxError(token,""String_Node_Str"");
  }
  if (this.mode == PARAMETERS_END) {
    if (type == Tokens.COMMA) {
      pm.pushParser(new InternalTypeParser(this));
      return;
    }
    if (type == Symbols.CLOSE_PARENTHESIS) {
      this.mode=COLON;
      return;
    }
    throw new SyntaxError(token,""String_Node_Str"");
  }
  if (this.mode == COLON) {
    if (type != Tokens.COLON) {
      throw new SyntaxError(token,""String_Node_Str"");
    }
    pm.pushParser(new InternalTypeParser(this));
    return;
  }
}","@Override public void parse(IParserManager pm,IToken token) throws SyntaxError {
  int type=token.type();
  if (type == Symbols.SEMICOLON) {
    pm.popParser(true);
    return;
  }
  if (this.mode == OWNER) {
    if (type == Keywords.INTERFACE) {
      this.methodInstruction.setInterface(true);
    }
    pm.pushParser(new InternalTypeParser(this),true);
    this.mode=DOT;
    return;
  }
  if (this.mode == DOT) {
    if (type != Symbols.DOT) {
      throw new SyntaxError(token,""String_Node_Str"");
    }
    this.mode=PARAMETERS;
    IToken next=token.next();
    if (!ParserUtil.isIdentifier(next.type())) {
      throw new SyntaxError(next,""String_Node_Str"");
    }
    pm.skip();
    this.methodInstruction.setMethodName(next.nameValue().qualified);
    return;
  }
  if (this.mode == PARAMETERS) {
    if (type == Symbols.OPEN_PARENTHESIS) {
      pm.pushParser(new InternalTypeParser(this));
      this.mode=PARAMETERS_END;
      return;
    }
    throw new SyntaxError(token,""String_Node_Str"");
  }
  if (this.mode == PARAMETERS_END) {
    if (type == Symbols.COMMA) {
      pm.pushParser(new InternalTypeParser(this));
      return;
    }
    if (type == Symbols.CLOSE_PARENTHESIS) {
      this.mode=COLON;
      return;
    }
    throw new SyntaxError(token,""String_Node_Str"");
  }
  if (this.mode == COLON) {
    if (type != Symbols.COLON) {
      throw new SyntaxError(token,""String_Node_Str"");
    }
    pm.pushParser(new InternalTypeParser(this));
    return;
  }
}",0.9851250845165652
85134,"@Override public void parse(IParserManager pm,IToken token) throws SyntaxError {
  int type=token.type();
  if (type == Symbols.CLOSE_CURLY_BRACKET) {
    pm.popParser(true);
    return;
  }
  if (this.isInMode(TYPE)) {
    if (type == Tokens.SEMICOLON) {
      if (token.isInferred()) {
        return;
      }
      this.reset();
      return;
    }
    if (type == Keywords.NEW) {
      Constructor c=new Constructor(this.theClass);
      this.body.addConstructor(c);
      c.position=token.raw();
      c.modifiers=this.modifiers;
      c.setAnnotations(this.annotations,this.annotationCount);
      this.method=c;
      this.mode=PARAMETERS;
      return;
    }
    int i=0;
    if ((i=ModifierTypes.MEMBER.parse(type)) != -1) {
      this.modifiers|=i;
      return;
    }
    if ((i=ModifierTypes.CLASS_TYPE.parse(type)) != -1) {
      CodeClass codeClass=new CodeClass(null,this.theClass.getUnit(),this.modifiers);
      codeClass.setAnnotations(this.getAnnotations(),this.annotationCount);
      codeClass.setOuterClass(this.theClass);
      codeClass.setModifiers(this.modifiers);
      this.theClass.getBody().addClass(codeClass);
      ClassDeclarationParser parser=new ClassDeclarationParser(codeClass);
      pm.pushParser(parser,true);
      this.reset();
      return;
    }
    if (token.nameValue() == Name.at) {
      Annotation annotation=new Annotation(token.raw());
      this.addAnnotation(annotation);
      pm.pushParser(new AnnotationParser(annotation));
      return;
    }
    pm.pushParser(new TypeParser(this),true);
    this.mode=NAME;
    return;
  }
  if (this.isInMode(NAME)) {
    if (!ParserUtil.isIdentifier(type)) {
      this.reset();
      throw new SyntaxError(token,""String_Node_Str"");
    }
    IToken next=token.next();
    type=next.type();
    if (type == Tokens.SEMICOLON) {
      Field f=new Field(this.theClass,token.nameValue(),this.type);
      f.position=token.raw();
      f.modifiers=this.modifiers;
      f.setAnnotations(this.getAnnotations(),this.annotationCount);
      this.body.addField(f);
      pm.skip();
      this.reset();
      return;
    }
    if (type == Symbols.OPEN_PARENTHESIS) {
      this.mode=PARAMETERS;
      Method m=new Method(this.theClass,token.nameValue(),this.type);
      m.modifiers=this.modifiers;
      m.position=token.raw();
      m.setAnnotations(this.getAnnotations(),this.annotationCount);
      this.method=m;
      this.body.addMethod(m);
      return;
    }
    if (type == Symbols.OPEN_CURLY_BRACKET) {
      Property p=new Property(this.theClass,token.nameValue(),this.type);
      p.position=token.raw();
      p.modifiers=this.modifiers;
      p.setAnnotations(this.getAnnotations(),this.annotationCount);
      this.body.addProperty(p);
      pm.skip();
      pm.pushParser(new PropertyParser(this.theClass,p));
      this.reset();
      return;
    }
    if (type == Tokens.EQUALS) {
      Field f=new Field(this.theClass,token.nameValue(),this.type);
      f.position=token.raw();
      f.modifiers=this.modifiers;
      f.setAnnotations(this.getAnnotations(),this.annotationCount);
      this.body.addField(f);
      pm.skip();
      pm.pushParser(new ExpressionParser(f));
      this.reset();
      return;
    }
    if (type == Symbols.OPEN_SQUARE_BRACKET) {
      Method m=new Method(this.theClass,token.nameValue(),this.type);
      m.modifiers=this.modifiers;
      m.position=token.raw();
      m.setAnnotations(this.getAnnotations(),this.annotationCount);
      this.method=m;
      this.body.addMethod(m);
      this.mode=GENERICS_END;
      pm.skip();
      pm.pushParser(new TypeVariableListParser(m));
      return;
    }
    return;
  }
  if (this.isInMode(GENERICS_END)) {
    this.mode=PARAMETERS;
    if (type == Symbols.CLOSE_SQUARE_BRACKET) {
      return;
    }
    throw new SyntaxError(token,""String_Node_Str"",true);
  }
  if (this.isInMode(PARAMETERS)) {
    this.mode=PARAMETERS_END;
    if (type == Symbols.OPEN_PARENTHESIS) {
      pm.pushParser(new ParameterListParser(this.method));
      return;
    }
    throw new SyntaxError(token,""String_Node_Str"",true);
  }
  if (this.isInMode(PARAMETERS_END)) {
    this.mode=METHOD_END;
    if (type == Symbols.CLOSE_PARENTHESIS) {
      return;
    }
    throw new SyntaxError(token,""String_Node_Str"",true);
  }
  if (this.isInMode(METHOD_END)) {
    if (type == Tokens.SEMICOLON) {
      this.reset();
      return;
    }
    if (type == Symbols.OPEN_CURLY_BRACKET) {
      pm.pushParser(new ExpressionParser(this.method),true);
      return;
    }
    if (type == Tokens.EQUALS) {
      pm.pushParser(new ExpressionParser(this.method));
      return;
    }
    if (type == Keywords.THROWS) {
      pm.pushParser(new ExceptionListParser(this.method));
      return;
    }
  }
}","@Override public void parse(IParserManager pm,IToken token) throws SyntaxError {
  int type=token.type();
  if (type == Symbols.CLOSE_CURLY_BRACKET) {
    pm.popParser(true);
    return;
  }
  if (this.isInMode(TYPE)) {
    if (type == Symbols.SEMICOLON) {
      if (token.isInferred()) {
        return;
      }
      this.reset();
      return;
    }
    if (type == Keywords.NEW) {
      Constructor c=new Constructor(this.theClass);
      this.body.addConstructor(c);
      c.position=token.raw();
      c.modifiers=this.modifiers;
      c.setAnnotations(this.annotations,this.annotationCount);
      this.method=c;
      this.mode=PARAMETERS;
      return;
    }
    int i=0;
    if ((i=ModifierTypes.MEMBER.parse(type)) != -1) {
      this.modifiers|=i;
      return;
    }
    if ((i=ModifierTypes.CLASS_TYPE.parse(type)) != -1) {
      CodeClass codeClass=new CodeClass(null,this.theClass.getUnit(),this.modifiers);
      codeClass.setAnnotations(this.getAnnotations(),this.annotationCount);
      codeClass.setOuterClass(this.theClass);
      codeClass.setModifiers(this.modifiers);
      this.theClass.getBody().addClass(codeClass);
      ClassDeclarationParser parser=new ClassDeclarationParser(codeClass);
      pm.pushParser(parser,true);
      this.reset();
      return;
    }
    if (token.nameValue() == Name.at) {
      Annotation annotation=new Annotation(token.raw());
      this.addAnnotation(annotation);
      pm.pushParser(new AnnotationParser(annotation));
      return;
    }
    pm.pushParser(new TypeParser(this),true);
    this.mode=NAME;
    return;
  }
  if (this.isInMode(NAME)) {
    if (!ParserUtil.isIdentifier(type)) {
      this.reset();
      throw new SyntaxError(token,""String_Node_Str"");
    }
    IToken next=token.next();
    type=next.type();
    if (type == Symbols.SEMICOLON) {
      Field f=new Field(this.theClass,token.nameValue(),this.type);
      f.position=token.raw();
      f.modifiers=this.modifiers;
      f.setAnnotations(this.getAnnotations(),this.annotationCount);
      this.body.addField(f);
      pm.skip();
      this.reset();
      return;
    }
    if (type == Symbols.OPEN_PARENTHESIS) {
      this.mode=PARAMETERS;
      Method m=new Method(this.theClass,token.nameValue(),this.type);
      m.modifiers=this.modifiers;
      m.position=token.raw();
      m.setAnnotations(this.getAnnotations(),this.annotationCount);
      this.method=m;
      this.body.addMethod(m);
      return;
    }
    if (type == Symbols.OPEN_CURLY_BRACKET) {
      Property p=new Property(this.theClass,token.nameValue(),this.type);
      p.position=token.raw();
      p.modifiers=this.modifiers;
      p.setAnnotations(this.getAnnotations(),this.annotationCount);
      this.body.addProperty(p);
      pm.skip();
      pm.pushParser(new PropertyParser(this.theClass,p));
      this.reset();
      return;
    }
    if (type == Symbols.EQUALS) {
      Field f=new Field(this.theClass,token.nameValue(),this.type);
      f.position=token.raw();
      f.modifiers=this.modifiers;
      f.setAnnotations(this.getAnnotations(),this.annotationCount);
      this.body.addField(f);
      pm.skip();
      pm.pushParser(new ExpressionParser(f));
      this.reset();
      return;
    }
    if (type == Symbols.OPEN_SQUARE_BRACKET) {
      Method m=new Method(this.theClass,token.nameValue(),this.type);
      m.modifiers=this.modifiers;
      m.position=token.raw();
      m.setAnnotations(this.getAnnotations(),this.annotationCount);
      this.method=m;
      this.body.addMethod(m);
      this.mode=GENERICS_END;
      pm.skip();
      pm.pushParser(new TypeVariableListParser(m));
      return;
    }
    return;
  }
  if (this.isInMode(GENERICS_END)) {
    this.mode=PARAMETERS;
    if (type == Symbols.CLOSE_SQUARE_BRACKET) {
      return;
    }
    throw new SyntaxError(token,""String_Node_Str"",true);
  }
  if (this.isInMode(PARAMETERS)) {
    this.mode=PARAMETERS_END;
    if (type == Symbols.OPEN_PARENTHESIS) {
      pm.pushParser(new ParameterListParser(this.method));
      return;
    }
    throw new SyntaxError(token,""String_Node_Str"",true);
  }
  if (this.isInMode(PARAMETERS_END)) {
    this.mode=METHOD_END;
    if (type == Symbols.CLOSE_PARENTHESIS) {
      return;
    }
    throw new SyntaxError(token,""String_Node_Str"",true);
  }
  if (this.isInMode(METHOD_END)) {
    if (type == Symbols.SEMICOLON) {
      this.reset();
      return;
    }
    if (type == Symbols.OPEN_CURLY_BRACKET) {
      pm.pushParser(new ExpressionParser(this.method),true);
      return;
    }
    if (type == Symbols.EQUALS) {
      pm.pushParser(new ExpressionParser(this.method));
      return;
    }
    if (type == Keywords.THROWS) {
      pm.pushParser(new ExceptionListParser(this.method));
      return;
    }
  }
}",0.9942135718043136
85135,"@Override public void parse(IParserManager jcp,IToken token) throws SyntaxError {
  int type=token.type();
  if (this.isInMode(PACKAGE)) {
    if (type == Keywords.PACKAGE) {
      this.mode=IMPORT | CLASS;
      PackageDecl pack=new PackageDecl(token.raw());
      this.unit.setPackageDeclaration(pack);
      jcp.pushParser(new PackageParser(pack));
      return;
    }
  }
  if (this.isInMode(IMPORT)) {
    if (type == Keywords.IMPORT) {
      this.mode=IMPORT | CLASS;
      Import i=new Import(token.raw());
      this.unit.addImport(i);
      jcp.pushParser(new ImportParser(null,i));
      return;
    }
    if (type == Keywords.USING) {
      this.mode=IMPORT | CLASS;
      Import i=new Import(token.raw());
      i.isStatic=true;
      this.unit.addStaticImport(i);
      jcp.pushParser(new ImportParser(null,i));
      return;
    }
  }
  if (this.isInMode(CLASS)) {
    if (token.type() == Tokens.SEMICOLON) {
      return;
    }
    CodeClass c=new CodeClass(null,this.unit);
    this.unit.addClass(c);
    jcp.pushParser(new ClassDeclarationParser(c),true);
    return;
  }
  throw new SyntaxError(token,""String_Node_Str"");
}","@Override public void parse(IParserManager jcp,IToken token) throws SyntaxError {
  int type=token.type();
  if (this.isInMode(PACKAGE)) {
    if (type == Keywords.PACKAGE) {
      this.mode=IMPORT | CLASS;
      PackageDecl pack=new PackageDecl(token.raw());
      this.unit.setPackageDeclaration(pack);
      jcp.pushParser(new PackageParser(pack));
      return;
    }
  }
  if (this.isInMode(IMPORT)) {
    if (type == Keywords.IMPORT) {
      this.mode=IMPORT | CLASS;
      Import i=new Import(token.raw());
      this.unit.addImport(i);
      jcp.pushParser(new ImportParser(null,i));
      return;
    }
    if (type == Keywords.USING) {
      this.mode=IMPORT | CLASS;
      Import i=new Import(token.raw());
      i.isStatic=true;
      this.unit.addStaticImport(i);
      jcp.pushParser(new ImportParser(null,i));
      return;
    }
  }
  if (this.isInMode(CLASS)) {
    if (token.type() == Symbols.SEMICOLON) {
      return;
    }
    CodeClass c=new CodeClass(null,this.unit);
    this.unit.addClass(c);
    jcp.pushParser(new ClassDeclarationParser(c),true);
    return;
  }
  throw new SyntaxError(token,""String_Node_Str"");
}",0.9951775537045155
85136,"@Override public void parse(IParserManager pm,IToken token) throws SyntaxError {
  int type=token.type();
  if (type == Tokens.SEMICOLON) {
    this.mode=0;
    return;
  }
  if (type == Symbols.CLOSE_CURLY_BRACKET) {
    pm.popParser();
    return;
  }
  if (this.mode == 0) {
    if (type == Keywords.GET) {
      this.mode=GET;
      return;
    }
    if (type == Keywords.SET) {
      this.mode=SET;
      return;
    }
    throw new SyntaxError(token,""String_Node_Str"",false);
  }
  if (this.mode > 0) {
    if (type == Tokens.COLON) {
      pm.pushParser(new ExpressionParser(this));
      return;
    }
    throw new SyntaxError(token,""String_Node_Str"");
  }
}","@Override public void parse(IParserManager pm,IToken token) throws SyntaxError {
  int type=token.type();
  if (type == Symbols.SEMICOLON) {
    this.mode=0;
    return;
  }
  if (type == Symbols.CLOSE_CURLY_BRACKET) {
    pm.popParser();
    return;
  }
  if (this.mode == 0) {
    if (type == Keywords.GET) {
      this.mode=GET;
      return;
    }
    if (type == Keywords.SET) {
      this.mode=SET;
      return;
    }
    throw new SyntaxError(token,""String_Node_Str"",false);
  }
  if (this.mode > 0) {
    if (type == Symbols.COLON) {
      pm.pushParser(new ExpressionParser(this));
      return;
    }
    throw new SyntaxError(token,""String_Node_Str"");
  }
}",0.9835329341317364
85137,"@Override public void parse(IParserManager pm,IToken token) throws SyntaxError {
  int type=token.type();
  if (type == Symbols.CLOSE_SQUARE_BRACKET) {
    pm.popParser(true);
    return;
  }
  if (this.mode == 0) {
    this.mode=1;
    pm.pushParser(new DWTValueParser(this),true);
    return;
  }
  if (this.mode == 1) {
    if (type == Tokens.COMMA) {
      this.mode=0;
      return;
    }
    pm.pushParser(new DWTValueParser(this),true);
    return;
  }
}","@Override public void parse(IParserManager pm,IToken token) throws SyntaxError {
  int type=token.type();
  if (type == Symbols.CLOSE_SQUARE_BRACKET) {
    pm.popParser(true);
    return;
  }
  if (this.mode == 0) {
    this.mode=1;
    pm.pushParser(new DWTValueParser(this),true);
    return;
  }
  if (this.mode == 1) {
    if (type == Symbols.COMMA) {
      this.mode=0;
      return;
    }
    pm.pushParser(new DWTValueParser(this),true);
    return;
  }
}",0.9880823401950164
85138,"@Override public void parse(IParserManager pm,IToken token) throws SyntaxError {
  int type=token.type();
  if (this.mode == NAME) {
    this.mode=BODY;
    if (ParserUtil.isIdentifier(type)) {
      this.node.setPosition(token.raw());
      this.node.name=token.nameValue();
      return;
    }
    throw new SyntaxError(token,""String_Node_Str"");
  }
  if (this.mode == BODY) {
    if (type == Symbols.OPEN_CURLY_BRACKET) {
      this.mode=PROPERTY_NAME;
      return;
    }
    throw new SyntaxError(token,""String_Node_Str"");
  }
  if (type == Symbols.CLOSE_CURLY_BRACKET) {
    pm.popParser();
    return;
  }
  if (this.mode == PROPERTY_NAME) {
    if (ParserUtil.isIdentifier(type)) {
      this.mode=EQUALS;
      this.name=token.nameValue().qualified;
      return;
    }
    this.mode=PROPERTY_NAME;
    throw new SyntaxError(token,""String_Node_Str"");
  }
  if (this.mode == EQUALS) {
    if (type == Tokens.EQUALS || type == Tokens.COLON) {
      pm.pushParser(new DWTValueParser(this));
      return;
    }
    this.mode=PROPERTY_NAME;
    throw new SyntaxError(token,""String_Node_Str"");
  }
  if (this.mode == BODY_END) {
    throw new SyntaxError(token,""String_Node_Str"");
  }
}","@Override public void parse(IParserManager pm,IToken token) throws SyntaxError {
  int type=token.type();
  if (this.mode == NAME) {
    this.mode=BODY;
    if (ParserUtil.isIdentifier(type)) {
      this.node.setPosition(token.raw());
      this.node.name=token.nameValue();
      return;
    }
    throw new SyntaxError(token,""String_Node_Str"");
  }
  if (this.mode == BODY) {
    if (type == Symbols.OPEN_CURLY_BRACKET) {
      this.mode=PROPERTY_NAME;
      return;
    }
    throw new SyntaxError(token,""String_Node_Str"");
  }
  if (type == Symbols.CLOSE_CURLY_BRACKET) {
    pm.popParser();
    return;
  }
  if (this.mode == PROPERTY_NAME) {
    if (ParserUtil.isIdentifier(type)) {
      this.mode=EQUALS;
      this.name=token.nameValue().qualified;
      return;
    }
    this.mode=PROPERTY_NAME;
    throw new SyntaxError(token,""String_Node_Str"");
  }
  if (this.mode == EQUALS) {
    if (type == Symbols.EQUALS || type == Symbols.COLON) {
      pm.pushParser(new DWTValueParser(this));
      return;
    }
    this.mode=PROPERTY_NAME;
    throw new SyntaxError(token,""String_Node_Str"");
  }
  if (this.mode == BODY_END) {
    throw new SyntaxError(token,""String_Node_Str"");
  }
}",0.9907640638119228
85139,"@Override public void checkTypes(MarkerList markers,IContext context){
  if (this.instance != null) {
    this.instance.checkTypes(markers,context);
    if (this.field != null && this.field.hasModifier(Modifiers.STATIC) && this.instance.getValueType() != CLASS_ACCESS) {
      markers.add(this.position,""String_Node_Str"",this.name);
      this.instance=null;
      return;
    }
  }
 else   if (this.field.isField()) {
    markers.add(this.position,""String_Node_Str"",this.name);
    this.instance=new ThisValue(this.position,this.field.getTheClass().getType());
  }
}","@Override public void checkTypes(MarkerList markers,IContext context){
  if (this.instance != null) {
    this.instance.checkTypes(markers,context);
    if (this.field != null && this.field.hasModifier(Modifiers.STATIC) && this.instance.getValueType() != CLASS_ACCESS) {
      markers.add(this.position,""String_Node_Str"",this.name);
      this.instance=null;
      return;
    }
  }
 else   if (this.field != null && this.field.isField()) {
    markers.add(this.position,""String_Node_Str"",this.name);
    this.instance=new ThisValue(this.position,this.field.getTheClass().getType());
  }
}",0.980968858131488
85140,"@Override public void writeStatement(MethodWriter writer){
  this.variable.writeSet(writer,null,this.variable.value);
}","@Override public void writeStatement(MethodWriter writer){
  this.variable.value.writeExpression(writer);
  this.variable.index=writer.registerLocal(this.variable.type);
  this.variable.writeSet(writer,null,null);
}",0.5988023952095808
85141,"@Override public boolean resolve(IContext context,MarkerList markers){
  int len=this.arguments.size();
  if (len == 1) {
    IValue argument=this.arguments.getFirstValue();
    IValue operator;
    if (this.instance != null) {
      if (""String_Node_Str"".equals(this.name)) {
        MatchExpression me=Operators.getMatchExpression(this.instance,argument);
        if (me != null) {
          me.resolve(markers,context);
          me.position=this.position;
          this.replacement=me;
          return false;
        }
      }
      argument=argument.resolve(markers,context);
      operator=Operators.get(this.instance,this.name,argument);
    }
 else {
      argument=argument.resolve(markers,context);
      operator=Operators.get(this.name,argument);
    }
    if (operator != null) {
      operator.setPosition(this.position);
      this.replacement=operator;
      return false;
    }
    this.arguments.setFirstValue(argument);
  }
 else {
    this.arguments.resolve(markers,context);
  }
  IMethod method=IAccess.resolveMethod(context,this.instance,this.qualifiedName,this.arguments);
  if (method != null) {
    this.method=method;
    return true;
  }
  if (len == 1 && this.instance != null && this.qualifiedName.endsWith(""String_Node_Str"")) {
    String s=this.qualifiedName.substring(0,this.qualifiedName.length() - 3);
    MethodMatch method1=this.instance.getType().resolveMethod(null,s,this.arguments);
    if (method1 != null) {
      AssignMethodCall call=new AssignMethodCall(this.position);
      call.method=method1.theMethod;
      call.instance=this.instance;
      call.arguments=this.arguments;
      call.name=this.name.substring(0,this.name.length() - 1);
      call.qualifiedName=s;
      call.dotless=this.dotless;
      this.replacement=call;
    }
  }
  return false;
}","@Override public boolean resolve(IContext context,MarkerList markers){
  IValue op=this.resolveOperator(markers,context);
  if (op != null) {
    this.replacement=op;
    return false;
  }
  IMethod method=IAccess.resolveMethod(context,this.instance,this.qualifiedName,this.arguments);
  if (method != null) {
    this.method=method;
    return true;
  }
  if (this.arguments.size() == 1 && this.instance != null && this.qualifiedName.endsWith(""String_Node_Str"")) {
    String s=this.qualifiedName.substring(0,this.qualifiedName.length() - 3);
    MethodMatch method1=this.instance.getType().resolveMethod(null,s,this.arguments);
    if (method1 != null) {
      AssignMethodCall call=new AssignMethodCall(this.position);
      call.method=method1.theMethod;
      call.instance=this.instance;
      call.arguments=this.arguments;
      call.name=this.name.substring(0,this.name.length() - 1);
      call.qualifiedName=s;
      call.dotless=this.dotless;
      this.replacement=call;
    }
  }
  return false;
}",0.6389776357827476
85142,"@Override public void writeStatement(MethodWriter writer,int varIndex,Label elseLabel){
  int locals=writer.localCount();
  this.pattern.writeJump(writer,varIndex,elseLabel);
  if (this.condition != null) {
    this.condition.writeInvJump(writer,elseLabel);
  }
  this.value.writeStatement(writer);
  writer.removeLocals(writer.localCount() - locals);
}","@Override public void writeStatement(MethodWriter writer,int varIndex,Label elseLabel){
  int locals=writer.localCount();
  this.pattern.writeJump(writer,varIndex,elseLabel);
  if (this.condition != null) {
    this.condition.writeInvJump(writer,elseLabel);
  }
  this.value.writeStatement(writer);
  writer.resetLocals(locals);
}",0.9370424597364568
85143,"@Override public void writeStatement(MethodWriter writer){
  IType type=this.value.getType();
  int var=writer.registerLocal(type);
  this.value.writeExpression(writer);
  writer.writeVarInsn(type.getStoreOpcode(),var);
  Label elseLabel=new Label();
  Label endLabel=new Label();
  for (int i=0; i < this.caseCount; ) {
    this.cases[i].writeStatement(writer,var,elseLabel);
    writer.writeJumpInsn(Opcodes.GOTO,endLabel);
    writer.writeFrameLabel(elseLabel);
    if (++i < this.caseCount) {
      elseLabel=new Label();
    }
  }
  writer.writeFrameLabel(elseLabel);
  this.writeError(writer,type,type.getLoadOpcode(),var);
  writer.removeLocals(1);
  writer.writeFrameLabel(endLabel);
}","@Override public void writeStatement(MethodWriter writer){
  int locals=writer.localCount();
  IType type=this.value.getType();
  int var=writer.registerLocal(type);
  this.value.writeExpression(writer);
  writer.writeVarInsn(type.getStoreOpcode(),var);
  Label elseLabel=new Label();
  Label endLabel=new Label();
  for (int i=0; i < this.caseCount; ) {
    this.cases[i].writeStatement(writer,var,elseLabel);
    writer.writeJumpInsn(Opcodes.GOTO,endLabel);
    writer.writeFrameLabel(elseLabel);
    if (++i < this.caseCount) {
      elseLabel=new Label();
    }
  }
  writer.writeFrameLabel(elseLabel);
  this.writeError(writer,type,type.getLoadOpcode(),var);
  writer.resetLocals(locals);
  writer.writeFrameLabel(endLabel);
}",0.928370786516854
85144,"@Override public IValue resolve(MarkerList markers,IContext context){
  IType type=this.value.getType();
  this.value=this.value.resolve(markers,context);
  for (int i=0; i < this.caseCount; i++) {
    ICase c=this.cases[i];
    if (this.exhaustive) {
      markers.add(c.getPosition(),""String_Node_Str"");
    }
    IPattern pattern=c.getPattern();
    if (pattern.getPatternType() == IPattern.WILDCARD) {
      if (c.getCondition() == null) {
        this.exhaustive=true;
      }
    }
 else     if (!pattern.isType(type)) {
      Marker marker=markers.create(pattern.getPosition(),""String_Node_Str"");
      marker.addInfo(""String_Node_Str"" + pattern.getType());
      marker.addInfo(""String_Node_Str"" + type);
    }
    this.cases[i]=c.resolve(markers,context);
  }
  if (type == Type.BOOLEAN && this.caseCount >= 2) {
    this.exhaustive=true;
  }
  return this;
}","@Override public IValue resolve(MarkerList markers,IContext context){
  IType type=this.value.getType();
  this.value=this.value.resolve(markers,context);
  for (int i=0; i < this.caseCount; i++) {
    this.cases[i]=this.cases[i].resolve(markers,context);
  }
  if (type == Type.BOOLEAN && this.caseCount >= 2) {
    this.exhaustive=true;
  }
  return this;
}",0.5835370823145885
85145,"@Override public void writeExpression(MethodWriter writer){
  IType type=this.value.getType();
  int var=writer.registerLocal(type);
  this.value.writeExpression(writer);
  writer.writeVarInsn(type.getStoreOpcode(),var);
  Label elseLabel=new Label();
  Label endLabel=new Label();
  for (int i=0; i < this.caseCount; ) {
    this.cases[i].writeExpression(writer,var,elseLabel);
    writer.writeJumpInsn(Opcodes.GOTO,endLabel);
    writer.writeFrameLabel(elseLabel);
    if (++i < this.caseCount) {
      elseLabel=new Label();
    }
  }
  writer.writeFrameLabel(elseLabel);
  this.writeError(writer,type,type.getLoadOpcode(),var);
  writer.removeLocals(1);
  writer.writeFrameLabel(endLabel);
}","@Override public void writeExpression(MethodWriter writer){
  int locals=writer.localCount();
  IType type=this.value.getType();
  int var=writer.registerLocal(type);
  this.value.writeExpression(writer);
  writer.writeVarInsn(type.getStoreOpcode(),var);
  Label elseLabel=new Label();
  Label endLabel=new Label();
  for (int i=0; i < this.caseCount; ) {
    this.cases[i].writeExpression(writer,var,elseLabel);
    writer.writeJumpInsn(Opcodes.GOTO,endLabel);
    writer.writeFrameLabel(elseLabel);
    if (++i < this.caseCount) {
      elseLabel=new Label();
    }
  }
  writer.writeFrameLabel(elseLabel);
  this.writeError(writer,type,type.getLoadOpcode(),var);
  writer.resetLocals(locals);
  writer.writeFrameLabel(endLabel);
}",0.9285714285714286
85146,"@Override public void checkTypes(MarkerList markers,IContext context){
  this.value.checkTypes(markers,context);
  for (int i=0; i < this.caseCount; i++) {
    this.cases[i].checkTypes(markers,context);
  }
}","@Override public void checkTypes(MarkerList markers,IContext context){
  this.value.checkTypes(markers,context);
  for (int i=0; i < this.caseCount; i++) {
    ICase c=this.cases[i];
    if (this.exhaustive) {
      markers.add(c.getPosition(),""String_Node_Str"");
    }
    IPattern pattern=c.getPattern();
    if (pattern.getPatternType() == IPattern.WILDCARD) {
      if (c.getCondition() == null) {
        this.exhaustive=true;
      }
    }
 else     if (!pattern.isType(type)) {
      Marker marker=markers.create(pattern.getPosition(),""String_Node_Str"");
      marker.addInfo(""String_Node_Str"" + pattern.getType());
      marker.addInfo(""String_Node_Str"" + type);
    }
    this.cases[i].checkTypes(markers,context);
  }
}",0.4247598719316969
85147,"@Override public void writeStatement(MethodWriter writer){
  org.objectweb.asm.Label startLabel=this.startLabel.target;
  org.objectweb.asm.Label updateLabel=this.updateLabel.target;
  org.objectweb.asm.Label endLabel=this.endLabel.target;
  Variable var=this.variable;
  if (this.type == DEFAULT) {
    if (var != null) {
      var.value.writeExpression(writer);
      var.index=writer.registerLocal(var.type);
      writer.writeVarInsn(var.type.getStoreOpcode(),var.index);
    }
    writer.writeFrameLabel(startLabel);
    if (this.condition != null) {
      this.condition.writeInvJump(writer,endLabel);
    }
    if (this.then != null) {
      this.then.writeStatement(writer);
    }
    writer.writeLabel(updateLabel);
    if (this.update != null) {
      this.update.writeStatement(writer);
    }
    writer.writeJumpInsn(Opcodes.GOTO,startLabel);
    writer.removeLocals(1);
    writer.writeFrameLabel(endLabel);
    if (var != null) {
      writer.writeLocal(var.qualifiedName,var.type,startLabel,endLabel,var.index);
    }
    return;
  }
  if (this.type == ARRAY) {
    Variable arrayVar=this.var3;
    Variable indexVar=this.var1;
    Variable lengthVar=this.var2;
    org.objectweb.asm.Label scopeLabel=new org.objectweb.asm.Label();
    writer.writeLabel(scopeLabel);
    var.value.writeExpression(writer);
    var.index=writer.registerLocal(MethodWriter.TOP);
    indexVar.index=writer.registerLocal(MethodWriter.INT);
    lengthVar.index=writer.registerLocal(MethodWriter.INT);
    arrayVar.index=writer.registerLocal(arrayVar.type);
    writer.writeInsn(Opcodes.DUP);
    arrayVar.writeSet(writer,null,null);
    writer.writeInsn(Opcodes.ARRAYLENGTH);
    lengthVar.writeSet(writer,null,null);
    writer.writeLDC(0);
    indexVar.writeSet(writer,null,null);
    writer.writeJumpInsn(Opcodes.GOTO,updateLabel);
    writer.writeFrameLabel(startLabel);
    arrayVar.writeGet(writer,null);
    indexVar.writeGet(writer,null);
    writer.writeInsn(arrayVar.type.getArrayLoadOpcode());
    var.writeSet(writer,null,null);
    if (this.then != null) {
      this.then.writeStatement(writer);
    }
    writer.writeIINC(indexVar.index,1);
    writer.writeFrameLabel(updateLabel);
    indexVar.writeGet(writer,null);
    lengthVar.writeGet(writer,null);
    writer.writeJumpInsn(Opcodes.IF_ICMPLT,startLabel);
    writer.removeLocals(4);
    writer.writeFrameLabel(endLabel);
    writer.writeLocal(var.qualifiedName,var.type,scopeLabel,endLabel,var.index);
    writer.writeLocal(""String_Node_Str"",""String_Node_Str"",null,scopeLabel,endLabel,indexVar.index);
    writer.writeLocal(""String_Node_Str"",""String_Node_Str"",null,scopeLabel,endLabel,lengthVar.index);
    writer.writeLocal(""String_Node_Str"",arrayVar.type,scopeLabel,endLabel,arrayVar.index);
    return;
  }
}","@Override public void writeStatement(MethodWriter writer){
  org.objectweb.asm.Label startLabel=this.startLabel.target;
  org.objectweb.asm.Label updateLabel=this.updateLabel.target;
  org.objectweb.asm.Label endLabel=this.endLabel.target;
  Variable var=this.variable;
  if (this.type == DEFAULT) {
    int locals=writer.localCount();
    if (var != null) {
      var.value.writeExpression(writer);
      var.index=writer.registerLocal(var.type);
      writer.writeVarInsn(var.type.getStoreOpcode(),var.index);
    }
    writer.writeFrameLabel(startLabel);
    if (this.condition != null) {
      this.condition.writeInvJump(writer,endLabel);
    }
    if (this.then != null) {
      this.then.writeStatement(writer);
    }
    writer.writeLabel(updateLabel);
    if (this.update != null) {
      this.update.writeStatement(writer);
    }
    writer.writeJumpInsn(Opcodes.GOTO,startLabel);
    writer.resetLocals(locals);
    writer.writeFrameLabel(endLabel);
    if (var != null) {
      writer.writeLocal(var.qualifiedName,var.type,startLabel,endLabel,var.index);
    }
    return;
  }
  if (this.type == ARRAY) {
    int locals=writer.localCount();
    Variable arrayVar=this.var3;
    Variable indexVar=this.var1;
    Variable lengthVar=this.var2;
    org.objectweb.asm.Label scopeLabel=new org.objectweb.asm.Label();
    writer.writeLabel(scopeLabel);
    var.value.writeExpression(writer);
    var.index=writer.registerLocal(MethodWriter.TOP);
    indexVar.index=writer.registerLocal(MethodWriter.INT);
    lengthVar.index=writer.registerLocal(MethodWriter.INT);
    arrayVar.index=writer.registerLocal(arrayVar.type);
    writer.writeInsn(Opcodes.DUP);
    arrayVar.writeSet(writer,null,null);
    writer.writeInsn(Opcodes.ARRAYLENGTH);
    lengthVar.writeSet(writer,null,null);
    writer.writeLDC(0);
    indexVar.writeSet(writer,null,null);
    writer.writeJumpInsn(Opcodes.GOTO,updateLabel);
    writer.writeFrameLabel(startLabel);
    arrayVar.writeGet(writer,null);
    indexVar.writeGet(writer,null);
    writer.writeInsn(arrayVar.type.getArrayLoadOpcode());
    var.writeSet(writer,null,null);
    if (this.then != null) {
      this.then.writeStatement(writer);
    }
    writer.writeIINC(indexVar.index,1);
    writer.writeFrameLabel(updateLabel);
    indexVar.writeGet(writer,null);
    lengthVar.writeGet(writer,null);
    writer.writeJumpInsn(Opcodes.IF_ICMPLT,startLabel);
    writer.resetLocals(locals);
    writer.writeFrameLabel(endLabel);
    writer.writeLocal(var.qualifiedName,var.type,scopeLabel,endLabel,var.index);
    writer.writeLocal(""String_Node_Str"",""String_Node_Str"",null,scopeLabel,endLabel,indexVar.index);
    writer.writeLocal(""String_Node_Str"",""String_Node_Str"",null,scopeLabel,endLabel,lengthVar.index);
    writer.writeLocal(""String_Node_Str"",arrayVar.type,scopeLabel,endLabel,arrayVar.index);
    return;
  }
}",0.9772646536412078
85148,"@Override public void writeStatement(MethodWriter writer){
  org.objectweb.asm.Label start=new org.objectweb.asm.Label();
  org.objectweb.asm.Label end=new org.objectweb.asm.Label();
  writer.writeLabel(start);
  int count=0;
  for (  Entry<String,Variable> entry : this.variables.entrySet()) {
    Variable var=entry.getValue();
    var.index=writer.registerLocal(var.type);
    count++;
  }
  for (int i=0; i < this.valueCount; i++) {
    IValue v=this.values[i];
    if (this.labels != null) {
      Label l=this.labels[i];
      if (l != null) {
        writer.writeFrameLabel(l.target);
      }
    }
    v.writeStatement(writer);
  }
  if (count > 0 && (this.parent != null || !(this.context instanceof IMethod))) {
    writer.removeLocals(count);
    writer.writeFrameLabel(end);
  }
 else {
    writer.writeLabel(end);
  }
  for (  Entry<String,Variable> entry : this.variables.entrySet()) {
    Variable var=entry.getValue();
    writer.writeLocal(var.qualifiedName,var.type.getExtendedName(),var.type.getSignature(),start,end,var.index);
  }
}","@Override public void writeStatement(MethodWriter writer){
  org.objectweb.asm.Label start=new org.objectweb.asm.Label();
  org.objectweb.asm.Label end=new org.objectweb.asm.Label();
  writer.writeLabel(start);
  int count=writer.localCount();
  for (int i=0; i < this.valueCount; i++) {
    IValue v=this.values[i];
    if (this.labels != null) {
      Label l=this.labels[i];
      if (l != null) {
        writer.writeFrameLabel(l.target);
      }
    }
    v.writeStatement(writer);
  }
  writer.resetLocals(count);
  writer.writeLabel(end);
  for (  Entry<String,Variable> entry : this.variables.entrySet()) {
    Variable var=entry.getValue();
    writer.writeLocal(var.qualifiedName,var.type.getExtendedName(),var.type.getSignature(),start,end,var.index);
  }
}",0.4085667215815486
85149,"@Override public int registerLocal(Object type){
  int index=this.localIndex;
  if (type == LONG || type == DOUBLE) {
    this.ensureLocals(index + 2);
    this.locals[index]=type;
    this.locals[index + 1]=type;
    this.localIndex+=2;
  }
 else {
    this.ensureLocals(index + 1);
    this.locals[index]=type;
    this.localIndex++;
  }
  return index;
}","@Override public int registerLocal(Object type){
  int index=this.localIndex;
  if (type == LONG || type == DOUBLE) {
    this.ensureLocals(index + 2);
    this.locals[index]=type;
    this.locals[index + 1]=TOP;
    this.localIndex+=2;
  }
 else {
    this.ensureLocals(index + 1);
    this.locals[index]=type;
    this.localIndex++;
  }
  return index;
}",0.9901823281907434
85150,"@Override public void removeLocals(int count){
  for (int i=0; i < count; i++) {
    this.localCount--;
    Object o=this.locals[--this.localIndex];
    if (o == LONG || o == DOUBLE) {
      this.localIndex--;
    }
  }
}","@Override public void removeLocals(int count){
  this.localCount-=count;
  this.localIndex-=count;
}",0.5482866043613707
85151,"@Override public void parse(IParserManager pm,IToken token) throws SyntaxError {
  int type=token.type();
  if (ParserUtil.isCloseBracket(type)) {
    pm.popParser(true);
    return;
  }
  if (this.mode == 0) {
    if (token.next().type() == Tokens.COLON) {
      this.label=token.value();
      pm.skip();
      return;
    }
    this.mode=1;
    pm.pushParser(new ExpressionParser(this),true);
    return;
  }
  if (this.mode == 1) {
    if (type == Tokens.COMMA) {
      this.valueList.setArray(true);
      this.mode=0;
      return;
    }
    if (type == Tokens.SEMICOLON) {
      this.mode=0;
      return;
    }
    if (token.prev().type() == Tokens.CLOSE_CURLY_BRACKET) {
      pm.pushParser(new ExpressionParser(this),true);
      return;
    }
    throw new SyntaxError(token,""String_Node_Str"" + token.value() + ""String_Node_Str"");
  }
}","@Override public void parse(IParserManager pm,IToken token) throws SyntaxError {
  int type=token.type();
  if (ParserUtil.isCloseBracket(type)) {
    pm.popParser(true);
    return;
  }
  if (this.mode == 0) {
    if (token.next().type() == Tokens.COLON) {
      this.label=token.value();
      pm.skip();
      return;
    }
    this.mode=1;
    pm.pushParser(new ExpressionParser(this),true);
    return;
  }
  if (this.mode == 1) {
    if (type == Tokens.COMMA) {
      this.valueList.setArray(true);
      this.mode=0;
      return;
    }
    if (type == Tokens.SEMICOLON) {
      this.mode=0;
      return;
    }
    if (token.prev().type() == Tokens.CLOSE_CURLY_BRACKET) {
      pm.pushParser(new ExpressionParser(this),true);
      return;
    }
    throw new SyntaxError(token,""String_Node_Str"");
  }
}",0.9782870928829916
85152,"@Override public void parse(IParserManager pm,IToken token) throws SyntaxError {
  if (this.mode == -1) {
    pm.popParser(true);
    return;
  }
  int type=token.type();
  if (this.mode == IF) {
    this.mode=CONDITION_END;
    pm.pushParser(new ExpressionParser(this));
    if (type == Tokens.OPEN_PARENTHESIS) {
      return;
    }
    throw new SyntaxError(token,""String_Node_Str"",true);
  }
  if (this.mode == CONDITION_END) {
    this.mode=THEN;
    if (type == Tokens.CLOSE_PARENTHESIS) {
      return;
    }
    throw new SyntaxError(token,""String_Node_Str"",true);
  }
  if (ParserUtil.isTerminator(type)) {
    if (!token.isInferred()) {
      pm.popParser(true);
    }
    return;
  }
  if (this.mode == THEN) {
    pm.pushParser(new ExpressionParser(this),true);
    this.mode=ELSE;
    return;
  }
  if (this.mode == ELSE) {
    if (type == Tokens.ELSE) {
      pm.pushParser(new ExpressionParser(this));
      this.mode=-1;
      return;
    }
    pm.popParser(true);
  }
}","@Override public void parse(IParserManager pm,IToken token) throws SyntaxError {
  if (this.mode == -1) {
    pm.popParser(true);
    return;
  }
  int type=token.type();
  if (this.mode == IF) {
    this.mode=CONDITION_END;
    pm.pushParser(new ExpressionParser(this));
    if (type == Tokens.OPEN_PARENTHESIS) {
      return;
    }
    throw new SyntaxError(token,""String_Node_Str"",true);
  }
  if (this.mode == CONDITION_END) {
    this.mode=THEN;
    if (type == Tokens.CLOSE_PARENTHESIS) {
      return;
    }
    throw new SyntaxError(token,""String_Node_Str"",true);
  }
  if (ParserUtil.isTerminator(type)) {
    if (!token.isInferred()) {
      pm.popParser(true);
    }
    return;
  }
  if (this.mode == THEN) {
    pm.pushParser(new ExpressionParser(this),true);
    this.mode=ELSE;
    return;
  }
  if (this.mode == ELSE) {
    if (type == Tokens.ELSE) {
      pm.pushParser(new ExpressionParser(this));
      this.mode=-1;
      return;
    }
    pm.popParser(true);
    return;
  }
}",0.9909274193548387
85153,"@Override public void write(ClassWriter writer){
  int modifiers=this.modifiers & 0xFFFF;
  if (this.value == null) {
    modifiers|=Modifiers.ABSTRACT;
  }
  MethodWriter mw=new MethodWriterImpl(writer,writer.visitMethod(modifiers,this.qualifiedName,this.getDescriptor(),this.getSignature(),this.getExceptions()));
  if (this.isConstructor) {
    mw.setConstructor(this.type);
  }
  if ((this.modifiers & Modifiers.STATIC) == 0) {
    mw.setInstance(this.type);
  }
  for (int i=0; i < this.annotationCount; i++) {
    this.annotations[i].write(mw);
  }
  if ((this.modifiers & Modifiers.INLINE) == Modifiers.INLINE) {
    mw.addAnnotation(""String_Node_Str"",false);
  }
  if ((this.modifiers & Modifiers.INFIX) == Modifiers.INFIX) {
    mw.addAnnotation(""String_Node_Str"",false);
  }
  if ((this.modifiers & Modifiers.PREFIX) == Modifiers.PREFIX) {
    mw.addAnnotation(""String_Node_Str"",false);
  }
  if ((this.modifiers & Modifiers.DEPRECATED) == Modifiers.DEPRECATED) {
    mw.addAnnotation(""String_Node_Str"",true);
  }
  if ((this.modifiers & Modifiers.SEALED) == Modifiers.SEALED) {
    mw.addAnnotation(""String_Node_Str"",false);
  }
  for (int i=0; i < this.parameterCount; i++) {
    this.parameters[i].write(mw);
  }
  Label start=new Label();
  Label end=new Label();
  if (this.value != null) {
    mw.begin();
    mw.writeLabel(start);
    this.value.writeExpression(mw);
    mw.writeLabel(end);
    mw.end(this.isConstructor ? Type.VOID : this.type);
  }
  if ((this.modifiers & Modifiers.STATIC) == 0) {
    mw.writeLocal(""String_Node_Str"",this.theClass.getType(),start,end,0);
  }
  for (int i=0; i < this.parameterCount; i++) {
    Parameter param=this.parameters[i];
    mw.writeLocal(param.qualifiedName,param.type,start,end,param.index);
  }
}","@Override public void write(ClassWriter writer){
  int modifiers=this.modifiers & 0xFFFF;
  if (this.value == null) {
    modifiers|=Modifiers.ABSTRACT;
  }
  MethodWriter mw=new MethodWriterImpl(writer,writer.visitMethod(modifiers,this.qualifiedName,this.getDescriptor(),this.getSignature(),this.getExceptions()));
  if (this.isConstructor) {
    mw.setConstructor(this.type);
  }
  if ((this.modifiers & Modifiers.STATIC) == 0) {
    mw.setInstance(this.type);
  }
  for (int i=0; i < this.annotationCount; i++) {
    this.annotations[i].write(mw);
  }
  if ((this.modifiers & Modifiers.INLINE) == Modifiers.INLINE) {
    mw.addAnnotation(""String_Node_Str"",false);
  }
  if ((this.modifiers & Modifiers.INFIX) == Modifiers.INFIX) {
    mw.addAnnotation(""String_Node_Str"",false);
  }
  if ((this.modifiers & Modifiers.PREFIX) == Modifiers.PREFIX) {
    mw.addAnnotation(""String_Node_Str"",false);
  }
  if ((this.modifiers & Modifiers.DEPRECATED) == Modifiers.DEPRECATED) {
    mw.addAnnotation(""String_Node_Str"",true);
  }
  if ((this.modifiers & Modifiers.SEALED) == Modifiers.SEALED) {
    mw.addAnnotation(""String_Node_Str"",false);
  }
  for (int i=0; i < this.parameterCount; i++) {
    this.parameters[i].write(mw);
  }
  Label start=new Label();
  Label end=new Label();
  if (this.value != null) {
    mw.begin();
    mw.writeLabel(start);
    this.value.writeStatement(mw);
    mw.writeLabel(end);
    mw.end(this.isConstructor ? Type.VOID : this.type);
  }
  if ((this.modifiers & Modifiers.STATIC) == 0) {
    mw.writeLocal(""String_Node_Str"",this.theClass.getType(),start,end,0);
  }
  for (int i=0; i < this.parameterCount; i++) {
    Parameter param=this.parameters[i];
    mw.writeLocal(param.qualifiedName,param.type,start,end,param.index);
  }
}",0.9946068691456146
85154,"@Override public void check(MarkerList markers,IContext context){
  if ((this.modifiers & Modifiers.STATIC) == 0) {
    if (this.overrideMethod == null) {
      if ((this.modifiers & Modifiers.OVERRIDE) != 0) {
        markers.add(this.position,""String_Node_Str"",this.name);
      }
    }
 else     if (!this.isConstructor) {
      if ((this.modifiers & Modifiers.OVERRIDE) == 0) {
        markers.add(this.position,""String_Node_Str"",this.name);
      }
 else       if (this.overrideMethod.hasModifier(Modifiers.FINAL)) {
        markers.add(this.position,""String_Node_Str"",this.name);
      }
 else {
        IType type=this.overrideMethod.getType();
        if (type.isSuperTypeOf(this.type)) {
          Marker marker=markers.create(this.position,""String_Node_Str"",this.name);
          marker.addInfo(""String_Node_Str"" + this.type);
          marker.addInfo(""String_Node_Str"" + type);
        }
      }
    }
  }
  super.check(markers,context);
  for (int i=0; i < this.parameterCount; i++) {
    this.parameters[i].check(markers,context);
  }
  if (this.value != null) {
    if (this.isConstructor) {
      if (!this.value.isType(Type.VOID)) {
        Marker marker=markers.create(this.position,""String_Node_Str"");
        marker.addInfo(""String_Node_Str"" + this.value.getType());
      }
    }
    this.value.check(markers,context);
  }
 else   if (this.isStatic()) {
    markers.add(this.position,""String_Node_Str"",this.name);
  }
 else   if ((this.modifiers & Modifiers.ABSTRACT) == 0 && !this.theClass.isAbstract()) {
    markers.add(this.position,""String_Node_Str"",this.name);
  }
}","@Override public void check(MarkerList markers,IContext context){
  if ((this.modifiers & Modifiers.STATIC) == 0) {
    if (this.overrideMethod == null) {
      if ((this.modifiers & Modifiers.OVERRIDE) != 0) {
        markers.add(this.position,""String_Node_Str"",this.name);
      }
    }
 else     if (!this.isConstructor) {
      if ((this.modifiers & Modifiers.OVERRIDE) == 0) {
        markers.add(this.position,""String_Node_Str"",this.name);
      }
 else       if (this.overrideMethod.hasModifier(Modifiers.FINAL)) {
        markers.add(this.position,""String_Node_Str"",this.name);
      }
 else {
        IType type=this.overrideMethod.getType();
        if (type.isSuperTypeOf(this.type)) {
          Marker marker=markers.create(this.position,""String_Node_Str"",this.name);
          marker.addInfo(""String_Node_Str"" + this.type);
          marker.addInfo(""String_Node_Str"" + type);
        }
      }
    }
  }
  super.check(markers,context);
  for (int i=0; i < this.parameterCount; i++) {
    this.parameters[i].check(markers,context);
  }
  if (this.value != null) {
    this.value.check(markers,this);
  }
 else   if (this.isStatic()) {
    markers.add(this.position,""String_Node_Str"",this.name);
  }
 else   if ((this.modifiers & Modifiers.ABSTRACT) == 0 && !this.theClass.isAbstract()) {
    markers.add(this.position,""String_Node_Str"",this.name);
  }
}",0.9110585052417992
85155,"@Override public void checkTypes(MarkerList markers,IContext context){
  super.checkTypes(markers,context);
  for (int i=0; i < this.parameterCount; i++) {
    this.parameters[i].checkTypes(markers,context);
  }
  if (this.value != null) {
    IValue value1=this.value.withType(this.type);
    if (value1 == null) {
      Marker marker=markers.create(this.position,""String_Node_Str"",this.name);
      marker.addInfo(""String_Node_Str"" + this.type);
      marker.addInfo(""String_Node_Str"" + this.value.getType());
    }
 else {
      this.value=value1;
    }
    this.value.checkTypes(markers,context);
  }
 else   if ((this.modifiers & Modifiers.ABSTRACT) == 0) {
    this.modifiers|=Modifiers.ABSTRACT;
  }
}","@Override public void checkTypes(MarkerList markers,IContext context){
  super.checkTypes(markers,context);
  for (int i=0; i < this.parameterCount; i++) {
    this.parameters[i].checkTypes(markers,context);
  }
  if (this.value != null) {
    if (this.isConstructor) {
      IValue value1=this.value.withType(Type.VOID);
      if (value1 == null) {
        Marker marker=markers.create(this.position,""String_Node_Str"");
        marker.addInfo(""String_Node_Str"" + this.value.getType());
      }
 else {
        this.value=value1;
      }
    }
 else {
      IValue value1=this.value.withType(this.type);
      if (value1 == null) {
        Marker marker=markers.create(this.position,""String_Node_Str"",this.name);
        marker.addInfo(""String_Node_Str"" + this.type);
        marker.addInfo(""String_Node_Str"" + this.value.getType());
      }
 else {
        this.value=value1;
      }
    }
    this.value.checkTypes(markers,this);
  }
 else   if ((this.modifiers & Modifiers.ABSTRACT) == 0) {
    this.modifiers|=Modifiers.ABSTRACT;
  }
}",0.7429879793932456
85156,"@Override public void writeStatement(MethodWriter writer){
  org.objectweb.asm.Label start=new org.objectweb.asm.Label();
  org.objectweb.asm.Label end=new org.objectweb.asm.Label();
  writer.writeLabel(start);
  int count=writer.localCount();
  if (this.labels == null) {
    for (int i=0; i < this.valueCount; i++) {
      this.values[i].writeStatement(writer);
    }
  }
 else {
    for (int i=0; i < this.valueCount; i++) {
      Label l=this.labels[i];
      if (l != null) {
        writer.writeFrameLabel(l.target);
      }
      this.values[i].writeStatement(writer);
    }
  }
  writer.resetLocals(count);
  writer.writeLabel(end);
  for (  Entry<String,Variable> entry : this.variables.entrySet()) {
    Variable var=entry.getValue();
    writer.writeLocal(var.qualifiedName,var.type.getExtendedName(),var.type.getSignature(),start,end,var.index);
  }
}","@Override public void writeStatement(MethodWriter writer){
  org.objectweb.asm.Label start=new org.objectweb.asm.Label();
  org.objectweb.asm.Label end=new org.objectweb.asm.Label();
  writer.writeLabel(start);
  int count=writer.localCount();
  if (this.labels == null) {
    for (int i=0; i < this.valueCount; i++) {
      this.values[i].writeStatement(writer);
    }
  }
 else {
    for (int i=0; i < this.valueCount; i++) {
      Label l=this.labels[i];
      if (l != null) {
        writer.writeFrameLabel(l.target);
      }
      this.values[i].writeStatement(writer);
    }
  }
  if (!(this.context instanceof IMethod)) {
    writer.resetLocals(count);
  }
  writer.writeLabel(end);
  for (  Entry<String,Variable> entry : this.variables.entrySet()) {
    Variable var=entry.getValue();
    writer.writeLocal(var.qualifiedName,var.type.getExtendedName(),var.type.getSignature(),start,end,var.index);
  }
}",0.9718468468468467
85157,"@Override public void check(MarkerList markers,IContext context){
  this.context=context;
  for (int i=0; i < this.valueCount; i++) {
    this.values[i].check(markers,context);
  }
  this.context=null;
}","@Override public void check(MarkerList markers,IContext context){
  this.context=context;
  for (int i=0; i < this.valueCount; i++) {
    this.values[i].check(markers,context);
  }
}",0.9454545454545454
85158,"public default Object getFrameType(){
  StringBuilder buffer=new StringBuilder();
  this.appendExtendedName(buffer);
  return buffer.toString();
}","public default Object getFrameType(){
  return this.getInternalName();
}",0.5045871559633027
85159,"@Override public void appendExtendedName(StringBuilder buffer){
  for (int i=0; i < this.arrayDimensions; i++) {
    buffer.append('[');
  }
  buffer.append('L').append(this.getInternalName()).append(';');
}","@Override public void appendExtendedName(StringBuilder buffer){
  for (int i=0; i < this.arrayDimensions; i++) {
    buffer.append('[');
  }
  buffer.append('L').append(this.theClass == null ? ClassFormat.packageToInternal(this.qualifiedName) : this.theClass.getInternalName()).append(';');
}",0.8256513026052105
85160,"@Override public String getInternalName(){
  return this.theClass == null ? ClassFormat.packageToInternal(this.qualifiedName) : this.theClass.getInternalName();
}","@Override public String getInternalName(){
  if (this.arrayDimensions > 0) {
    StringBuilder buf=new StringBuilder();
    this.appendExtendedName(buf);
    return buf.toString();
  }
  return this.theClass == null ? ClassFormat.packageToInternal(this.qualifiedName) : this.theClass.getInternalName();
}",0.6952789699570815
85161,"private void processInsn(int opcode){
switch (opcode) {
case DUP:
{
      this.ensureStack(this.stackIndex + 1);
      this.stack[this.stackIndex]=this.stack[this.stackIndex - 1];
      this.stackIndex++;
      return;
    }
case DUP_X1:
{
    this.ensureStack(this.stackIndex + 1);
    this.stack[this.stackIndex]=this.stack[this.stackIndex - 2];
    this.stackIndex++;
    return;
  }
case DUP_X2:
{
  this.ensureStack(this.stackIndex + 1);
  this.stack[this.stackIndex]=this.stack[this.stackIndex - 3];
  this.stackIndex++;
  return;
}
case DUP2:
{
this.ensureStack(this.stackIndex + 2);
this.stack[this.stackIndex]=this.stack[this.stackIndex - 2];
this.stack[this.stackIndex + 1]=this.stack[this.stackIndex - 1];
this.stackIndex+=2;
return;
}
case DUP2_X1:
{
this.ensureStack(this.stackIndex + 2);
this.stack[this.stackIndex]=this.stack[this.stackIndex - 3];
this.stack[this.stackIndex + 1]=this.stack[this.stackIndex - 2];
this.stackIndex+=2;
return;
}
case DUP2_X2:
{
this.ensureStack(this.stackIndex + 2);
this.stack[this.stackIndex]=this.stack[this.stackIndex - 4];
this.stack[this.stackIndex + 1]=this.stack[this.stackIndex - 3];
this.stackIndex+=2;
return;
}
case SWAP:
{
Object o=this.stack[this.stackIndex];
this.stack[this.stackIndex]=this.stack[this.stackIndex - 1];
this.stack[this.stackIndex - 1]=o;
return;
}
case POP:
{
this.pop();
return;
}
case POP2:
{
this.pop();
this.pop();
return;
}
case ICONST_0:
case ICONST_1:
case ICONST_2:
case ICONST_3:
case ICONST_4:
case ICONST_5:
case ICONST_M1:
this.push(INT);
return;
case LCONST_0:
case LCONST_1:
this.push(LONG);
return;
case FCONST_0:
case FCONST_1:
case FCONST_2:
this.push(FLOAT);
return;
case DCONST_0:
case DCONST_1:
this.push(DOUBLE);
return;
case ACONST_NULL:
this.push(NULL);
return;
case ARRAYLENGTH:
this.set(INT);
return;
case RETURN:
this.clear();
this.hasReturn=true;
return;
case ATHROW:
this.clear();
this.visitFrame=true;
return;
case BALOAD:
case SALOAD:
case CALOAD:
case IALOAD:
this.pop();
this.pop();
this.push(INT);
return;
case LALOAD:
this.pop();
this.pop();
this.push(LONG);
return;
case FALOAD:
this.pop();
this.pop();
this.push(FLOAT);
return;
case DALOAD:
this.pop();
this.pop();
this.push(DOUBLE);
return;
case AALOAD:
this.pop();
this.pop();
this.push(TOP);
return;
case IADD:
case ISUB:
case IMUL:
case IDIV:
case IREM:
case ISHL:
case ISHR:
case IUSHR:
this.pop();
this.pop();
this.push(INT);
return;
case LADD:
case LSUB:
case LMUL:
case LDIV:
case LREM:
case LSHL:
case LSHR:
case LUSHR:
this.pop();
this.pop();
this.push(LONG);
return;
case FADD:
case FSUB:
case FMUL:
case FDIV:
case FREM:
this.pop();
this.pop();
this.push(FLOAT);
return;
case DADD:
case DSUB:
case DMUL:
case DDIV:
case DREM:
this.pop();
this.pop();
this.push(DOUBLE);
return;
case L2I:
case F2I:
case D2I:
this.set(INT);
return;
case I2L:
case F2L:
case D2L:
this.set(LONG);
return;
case I2F:
case L2F:
case D2F:
this.set(FLOAT);
return;
case LCMP:
case FCMPL:
case FCMPG:
case DCMPL:
case DCMPG:
this.pop();
this.pop();
this.push(INT);
return;
}
}","private void processInsn(int opcode){
switch (opcode) {
case DUP:
{
      this.ensureStack(this.stackIndex + 1);
      this.stack[this.stackIndex]=this.stack[this.stackIndex - 1];
      this.stackIndex++;
      return;
    }
case DUP_X1:
{
    this.ensureStack(this.stackIndex + 1);
    this.stack[this.stackIndex]=this.stack[this.stackIndex - 2];
    this.stackIndex++;
    return;
  }
case DUP_X2:
{
  this.ensureStack(this.stackIndex + 1);
  this.stack[this.stackIndex]=this.stack[this.stackIndex - 3];
  this.stackIndex++;
  return;
}
case DUP2:
{
this.ensureStack(this.stackIndex + 2);
this.stack[this.stackIndex]=this.stack[this.stackIndex - 2];
this.stack[this.stackIndex + 1]=this.stack[this.stackIndex - 1];
this.stackIndex+=2;
return;
}
case DUP2_X1:
{
this.ensureStack(this.stackIndex + 2);
this.stack[this.stackIndex]=this.stack[this.stackIndex - 3];
this.stack[this.stackIndex + 1]=this.stack[this.stackIndex - 2];
this.stackIndex+=2;
return;
}
case DUP2_X2:
{
this.ensureStack(this.stackIndex + 2);
this.stack[this.stackIndex]=this.stack[this.stackIndex - 4];
this.stack[this.stackIndex + 1]=this.stack[this.stackIndex - 3];
this.stackIndex+=2;
return;
}
case SWAP:
{
Object o=this.stack[this.stackIndex];
this.stack[this.stackIndex]=this.stack[this.stackIndex - 1];
this.stack[this.stackIndex - 1]=o;
return;
}
case POP:
{
this.pop();
return;
}
case POP2:
{
this.pop();
this.pop();
return;
}
case ICONST_0:
case ICONST_1:
case ICONST_2:
case ICONST_3:
case ICONST_4:
case ICONST_5:
case ICONST_M1:
this.push(INT);
return;
case LCONST_0:
case LCONST_1:
this.push(LONG);
return;
case FCONST_0:
case FCONST_1:
case FCONST_2:
this.push(FLOAT);
return;
case DCONST_0:
case DCONST_1:
this.push(DOUBLE);
return;
case ACONST_NULL:
this.push(NULL);
return;
case ARRAYLENGTH:
this.set(INT);
return;
case RETURN:
this.clear();
this.hasReturn=true;
return;
case ATHROW:
this.clear();
this.visitFrame=true;
return;
case BALOAD:
case SALOAD:
case CALOAD:
case IALOAD:
this.pop();
this.pop();
this.push(INT);
return;
case LALOAD:
this.pop();
this.pop();
this.push(LONG);
return;
case FALOAD:
this.pop();
this.pop();
this.push(FLOAT);
return;
case DALOAD:
this.pop();
this.pop();
this.push(DOUBLE);
return;
case AALOAD:
this.pop();
this.pop();
this.push(TOP);
return;
case IADD:
case ISUB:
case IMUL:
case IDIV:
case IREM:
case ISHL:
case ISHR:
case IUSHR:
case IAND:
case IOR:
case IXOR:
this.pop();
this.pop();
this.push(INT);
return;
case LADD:
case LSUB:
case LMUL:
case LDIV:
case LREM:
case LSHL:
case LSHR:
case LUSHR:
case LAND:
case LOR:
case LXOR:
this.pop();
this.pop();
this.push(LONG);
return;
case FADD:
case FSUB:
case FMUL:
case FDIV:
case FREM:
this.pop();
this.pop();
this.push(FLOAT);
return;
case DADD:
case DSUB:
case DMUL:
case DDIV:
case DREM:
this.pop();
this.pop();
this.push(DOUBLE);
return;
case L2I:
case F2I:
case D2I:
this.set(INT);
return;
case I2L:
case F2L:
case D2L:
this.set(LONG);
return;
case I2F:
case L2F:
case D2F:
this.set(FLOAT);
return;
case LCMP:
case FCMPL:
case FCMPG:
case DCMPL:
case DCMPG:
this.pop();
this.pop();
this.push(INT);
return;
}
}",0.9895322211318286
85162,"@Override public void resolveTypes(MarkerList markers,IContext context){
  if (this.lowerBound != null) {
    this.lowerBound=this.lowerBound.resolve(markers,context);
  }
  if (this.upperBoundCount > 0) {
    IType type=this.upperBounds[0];
    IClass iclass=type.getTheClass();
    if (iclass != null) {
      if (iclass.hasModifier(Modifiers.INTERFACE_CLASS)) {
        if (++this.upperBoundCount > this.upperBounds.length) {
          IType[] temp=new IType[this.upperBoundCount];
          temp[0]=Type.OBJECT;
          System.arraycopy(this.upperBounds,0,temp,1,this.upperBoundCount - 1);
          this.upperBounds=temp;
        }
 else {
          System.arraycopy(this.upperBounds,0,this.upperBounds,1,this.upperBoundCount - 1);
          this.upperBounds[0]=Type.OBJECT;
        }
      }
    }
    for (int i=1; i < this.upperBoundCount; i++) {
      type=this.upperBounds[i];
      iclass=type.getTheClass();
      if (iclass != null && !iclass.hasModifier(Modifiers.INTERFACE_CLASS)) {
        System.arraycopy(this.upperBounds,i + 1,this.upperBounds,i,this.upperBoundCount - i - 1);
        this.upperBoundCount--;
        i--;
      }
    }
  }
  this.captureClass=new CaptureClass(this,this.upperBounds,this.upperBoundCount,this.lowerBound);
}","@Override public void resolveTypes(MarkerList markers,IContext context){
  if (this.lowerBound != null) {
    this.lowerBound=this.lowerBound.resolve(markers,context);
  }
  if (this.upperBoundCount > 0) {
    IType type=this.upperBounds[0]=this.upperBounds[0].resolve(markers,context);
    IClass iclass=type.getTheClass();
    if (iclass != null) {
      if (iclass.hasModifier(Modifiers.INTERFACE_CLASS)) {
        if (++this.upperBoundCount > this.upperBounds.length) {
          IType[] temp=new IType[this.upperBoundCount];
          temp[0]=Type.OBJECT;
          System.arraycopy(this.upperBounds,0,temp,1,this.upperBoundCount - 1);
          this.upperBounds=temp;
        }
 else {
          System.arraycopy(this.upperBounds,0,this.upperBounds,1,this.upperBoundCount - 1);
          this.upperBounds[0]=Type.OBJECT;
        }
      }
    }
    for (int i=1; i < this.upperBoundCount; i++) {
      type=this.upperBounds[i]=this.upperBounds[i].resolve(markers,context);
      iclass=type.getTheClass();
      if (iclass != null && !iclass.hasModifier(Modifiers.INTERFACE_CLASS)) {
        System.arraycopy(this.upperBounds,i + 1,this.upperBounds,i,this.upperBoundCount - i - 1);
        this.upperBoundCount--;
        i--;
      }
    }
  }
  this.captureClass=new CaptureClass(this,this.upperBounds,this.upperBoundCount,this.lowerBound);
}",0.9655172413793104
85163,"@Override public void checkArguments(MarkerList markers,IValue instance,IArguments arguments,ITypeContext typeContext){
  int len=arguments.size();
  Parameter par;
  IType parType;
  if (instance != null && (this.modifiers & Modifiers.INFIX) == Modifiers.INFIX) {
    par=this.parameters[0];
    parType=par.getType(typeContext);
    IValue instance1=instance.withType(parType);
    if (instance1 == null) {
      Marker marker=markers.create(instance.getPosition(),""String_Node_Str"",par.name);
      marker.addInfo(""String_Node_Str"" + parType);
      marker.addInfo(""String_Node_Str"" + instance.getType());
    }
    if ((this.modifiers & Modifiers.VARARGS) != 0) {
      par=this.parameters[this.parameterCount - 1];
      arguments.checkVarargsValue(this.parameterCount - 2,par,markers,typeContext);
    }
    return;
  }
 else   if (instance == null && (this.modifiers & Modifiers.PREFIX) == Modifiers.PREFIX) {
    parType=this.theClass.getType();
    instance=arguments.getFirstValue();
    IValue instance1=instance.withType(parType);
    if (instance1 == null) {
      Marker marker=markers.create(instance.getPosition(),""String_Node_Str"",this.name);
      marker.addInfo(""String_Node_Str"" + parType);
      marker.addInfo(""String_Node_Str"" + instance.getType());
    }
    return;
  }
  if ((this.modifiers & Modifiers.VARARGS) != 0) {
    len=this.parameterCount - 1;
    par=this.parameters[len];
    arguments.checkVarargsValue(len,par,markers,typeContext);
    for (int i=0; i < len; i++) {
      par=this.parameters[i];
      arguments.checkValue(i,par,markers,typeContext);
    }
    return;
  }
  for (int i=0; i < this.parameterCount; i++) {
    par=this.parameters[i];
    arguments.checkValue(i,par,markers,typeContext);
  }
}","@Override public void checkArguments(MarkerList markers,IValue instance,IArguments arguments,ITypeContext typeContext){
  int len=arguments.size();
  IType parType;
  if (instance != null && (this.modifiers & Modifiers.INFIX) == Modifiers.INFIX) {
    Parameter par=this.parameters[0];
    parType=par.getType(typeContext);
    IValue instance1=instance.withType(parType);
    if (instance1 == null) {
      Marker marker=markers.create(instance.getPosition(),""String_Node_Str"",par.name);
      marker.addInfo(""String_Node_Str"" + parType);
      marker.addInfo(""String_Node_Str"" + instance.getType());
    }
    if ((this.modifiers & Modifiers.VARARGS) != 0) {
      arguments.checkVarargsValue(this.parameterCount - 2,this.parameters[this.parameterCount - 1],markers,typeContext);
      for (int i=0; i < this.parameterCount - 2; i++) {
        arguments.checkValue(i,this.parameters[i + 1],markers,typeContext);
      }
      return;
    }
    for (int i=0; i < this.parameterCount - 1; i++) {
      arguments.checkValue(i,this.parameters[i + 1],markers,typeContext);
    }
    return;
  }
 else   if (instance == null && (this.modifiers & Modifiers.PREFIX) == Modifiers.PREFIX) {
    parType=this.theClass.getType();
    instance=arguments.getFirstValue();
    IValue instance1=instance.withType(parType);
    if (instance1 == null) {
      Marker marker=markers.create(instance.getPosition(),""String_Node_Str"",this.name);
      marker.addInfo(""String_Node_Str"" + parType);
      marker.addInfo(""String_Node_Str"" + instance.getType());
    }
    return;
  }
  if ((this.modifiers & Modifiers.VARARGS) != 0) {
    len=this.parameterCount - 1;
    arguments.checkVarargsValue(len,this.parameters[len],markers,typeContext);
    for (int i=0; i < len; i++) {
      arguments.checkValue(i,this.parameters[i],markers,typeContext);
    }
    return;
  }
  for (int i=0; i < this.parameterCount; i++) {
    arguments.checkValue(i,this.parameters[i],markers,typeContext);
  }
}",0.8458434221146085
85164,"@Override public IType resolve(MarkerList markers,IContext context){
  if (this.theClass != null) {
    return this;
  }
  IClass iclass;
  if (this.fullName != null) {
    iclass=Package.rootPackage.resolveClass(this.fullName);
  }
 else {
    iclass=context.resolveClass(this.qualifiedName);
  }
  if (iclass != null) {
    this.theClass=iclass;
    this.fullName=iclass.getFullName();
    if (iclass instanceof CaptureClass) {
      return new WildcardType(this.position,this.arrayDimensions,(CaptureClass)iclass);
    }
    if (this.generics == null) {
      return this;
    }
    int varCount=this.theClass.genericCount();
    if (varCount == 0) {
      if (this.genericCount != 0 && markers != null) {
        markers.add(this.position,""String_Node_Str"",this.qualifiedName);
      }
      return this;
    }
    if (varCount != this.genericCount && markers != null) {
      markers.add(this.position,""String_Node_Str"");
      return this;
    }
    for (int i=0; i < this.genericCount; i++) {
      IType t1=this.generics[i];
      IType t2=t1.resolve(markers,context);
      if (t1 != t2) {
        this.generics[i]=t2;
      }
      if (markers != null) {
        ITypeVariable var=this.theClass.getTypeVariable(i);
        if (!var.isSuperTypeOf(t2)) {
          Marker marker=markers.create(t2.getPosition(),""String_Node_Str"",var.getQualifiedName());
          marker.addInfo(""String_Node_Str"" + t2);
          marker.addInfo(""String_Node_Str"" + var);
        }
      }
    }
    return this;
  }
  if (markers != null) {
    markers.add(this.position,""String_Node_Str"",this.toString());
  }
  return this;
}","@Override public IType resolve(MarkerList markers,IContext context){
  if (this.theClass != null) {
    return this;
  }
  IClass iclass;
  if (this.fullName != null) {
    iclass=Package.rootPackage.resolveClass(this.fullName);
  }
 else {
    iclass=context.resolveClass(this.qualifiedName);
  }
  if (iclass != null) {
    this.theClass=iclass;
    this.fullName=iclass.getFullName();
    if (iclass instanceof CaptureClass) {
      return new WildcardType(this.position,this.arrayDimensions,(CaptureClass)iclass);
    }
    if (this.generics == null) {
      return this;
    }
    int varCount=this.theClass.genericCount();
    if (varCount == 0) {
      if (this.genericCount != 0 && markers != null) {
        markers.add(this.position,""String_Node_Str"",this.qualifiedName);
      }
      return this;
    }
    if (varCount != this.genericCount && markers != null) {
      markers.add(this.position,""String_Node_Str"");
      return this;
    }
    if (markers == null) {
      for (int i=0; i < this.genericCount; i++) {
        this.generics[i]=this.generics[i].resolve(markers,context);
      }
      return this;
    }
    for (int i=0; i < this.genericCount; i++) {
      IType t1=this.generics[i];
      IType t2=this.generics[i]=t1.resolve(markers,context);
      ITypeVariable var=this.theClass.getTypeVariable(i);
      if (!var.isSuperTypeOf(t2)) {
        Marker marker=markers.create(t2.getPosition(),""String_Node_Str"",var.getQualifiedName());
        marker.addInfo(""String_Node_Str"" + t2);
        marker.addInfo(""String_Node_Str"" + var);
      }
    }
    return this;
  }
  if (markers != null) {
    markers.add(this.position,""String_Node_Str"",this.toString());
  }
  return this;
}",0.9088721804511278
85165,"@Override public void write(ClassWriter writer){
  boolean instance=this.thisType != null;
  int modifiers=instance ? Modifiers.PRIVATE | Modifiers.SYNTHETIC : Modifiers.PRIVATE | Modifiers.STATIC | Modifiers.SYNTHETIC;
  MethodWriter mw=new MethodWriterImpl(writer,writer.visitMethod(modifiers,this.getName(),this.getLambdaDescriptor(),null,null));
  int[] prevIndex=null;
  if (instance) {
    mw.registerLocal(this.thisType);
  }
  if (this.capturedFieldCount > 0) {
    prevIndex=new int[this.capturedFieldCount];
    for (int i=0; i < this.capturedFieldCount; i++) {
      IVariable var=this.capturedFields[i];
      prevIndex[i]=var.getIndex();
      var.setIndex(mw.registerParameter(var.getQualifiedName(),var.getType()));
    }
  }
  for (int i=0; i < this.parameterCount; i++) {
    LambdaParameter param=this.parameters[i];
    param.index=mw.registerParameter(param.qualifiedName,param.type);
  }
  mw.begin();
  this.value.writeExpression(mw);
  mw.end(this.method.getType());
  for (int i=0; i < this.parameterCount; i++) {
    IVariable var=this.capturedFields[i];
    var.setIndex(prevIndex[i]);
  }
}","@Override public void write(ClassWriter writer){
  boolean instance=this.thisType != null;
  int modifiers=instance ? Modifiers.PRIVATE | Modifiers.SYNTHETIC : Modifiers.PRIVATE | Modifiers.STATIC | Modifiers.SYNTHETIC;
  MethodWriter mw=new MethodWriterImpl(writer,writer.visitMethod(modifiers,this.getName(),this.getLambdaDescriptor(),null,null));
  int[] prevIndex=null;
  if (instance) {
    mw.registerLocal(this.thisType);
  }
  if (this.capturedFieldCount > 0) {
    prevIndex=new int[this.capturedFieldCount];
    for (int i=0; i < this.capturedFieldCount; i++) {
      IVariable var=this.capturedFields[i];
      prevIndex[i]=var.getIndex();
      var.setIndex(mw.registerParameter(var.getQualifiedName(),var.getType()));
    }
  }
  for (int i=0; i < this.parameterCount; i++) {
    LambdaParameter param=this.parameters[i];
    param.index=mw.registerParameter(param.qualifiedName,param.type);
  }
  mw.begin();
  this.value.writeExpression(mw);
  mw.end(this.method.getType());
  for (int i=0; i < this.capturedFieldCount; i++) {
    IVariable var=this.capturedFields[i];
    var.setIndex(prevIndex[i]);
  }
}",0.9901697944593388
85166,"@Override public boolean processAnnotation(Annotation annotation){
  String name=annotation.type.fullName;
  if (""String_Node_Str"".equals(name)) {
    this.modifiers|=Modifiers.BYREF;
    return true;
  }
  return false;
}","@Override public boolean processAnnotation(Annotation annotation){
  String name=annotation.type.fullName;
  if (""String_Node_Str"".equals(name)) {
    this.modifiers|=Modifiers.VAR;
    return true;
  }
  if (""String_Node_Str"".equals(name)) {
    this.modifiers|=Modifiers.LAZY;
    return true;
  }
  return false;
}",0.8089053803339518
85167,"public void write(MethodWriter writer){
  this.index=writer.registerParameter(this.name,this.type);
  if ((this.modifiers & Modifiers.BYREF) != 0) {
    writer.addParameterAnnotation(this.index,""String_Node_Str"",true);
  }
  for (  Annotation a : this.annotations) {
    a.write(writer,this.index);
  }
}","public void write(MethodWriter writer){
  this.index=writer.registerParameter(this.name,this.type);
  if ((this.modifiers & Modifiers.VAR) != 0) {
    writer.addParameterAnnotation(this.index,""String_Node_Str"",true);
  }
  for (  Annotation a : this.annotations) {
    a.write(writer,this.index);
  }
}",0.99009900990099
85168,"@Override public IValue resolve(List<Marker> markers,IContext context){
  if (this.isArray) {
    IValue[] values=new IValue[this.valueCount];
    System.arraycopy(this.values,0,values,0,this.valueCount);
    return new ValueList(this.position,values,this.requiredType,this.elementType).resolve(markers,context);
  }
  this.context=context;
  for (int i=0; i < this.valueCount; i++) {
    IValue v1=this.values[i];
    IValue v2=v1.resolve(markers,this);
    if (v1 != v2) {
      this.values[i]=v2;
    }
    if (v2.getValueType() == IValue.VARIABLE) {
      FieldInitializer fi=(FieldInitializer)v2;
      Variable var=fi.variable;
      this.variables.put(var.qualifiedName,var);
    }
  }
  return this;
}","@Override public IValue resolve(List<Marker> markers,IContext context){
  if (this.isArray) {
    IValue[] values=new IValue[this.valueCount];
    System.arraycopy(this.values,0,values,0,this.valueCount);
    return new ValueList(this.position,values,this.requiredType,this.elementType).resolve(markers,context);
  }
  this.context=context;
  for (int i=0; i < this.valueCount; i++) {
    IValue v1=this.values[i];
    IValue v2=v1.resolve(markers,this);
    if (v1 != v2) {
      this.values[i]=v2;
    }
    if (v2.getValueType() == IValue.VARIABLE) {
      FieldInitializer fi=(FieldInitializer)v2;
      Variable var=fi.variable;
      this.variables.put(var.qualifiedName,var);
    }
  }
  this.context=null;
  return this;
}",0.985406532314107
85169,"@Override public void check(List<Marker> markers,IContext context){
  if (this.isArray) {
    super.check(markers,context);
  }
 else {
    IType type=this.requiredType;
    for (int i=0; i < this.valueCount; i++) {
      IValue v=this.values[i];
      v.check(markers,this);
      if (v.getValueType() == RETURN && v.withType(type) == null) {
        Marker marker=Markers.create(v.getPosition(),""String_Node_Str"");
        marker.addInfo(""String_Node_Str"" + type);
        marker.addInfo(""String_Node_Str"" + v.getType());
        markers.add(marker);
      }
    }
  }
}","@Override public void check(List<Marker> markers,IContext context){
  if (this.isArray) {
    super.check(markers,context);
  }
 else {
    this.context=context;
    IType type=this.requiredType;
    for (int i=0; i < this.valueCount; i++) {
      IValue v=this.values[i];
      v.check(markers,this);
      if (v.getValueType() == RETURN && v.withType(type) == null) {
        Marker marker=Markers.create(v.getPosition(),""String_Node_Str"");
        marker.addInfo(""String_Node_Str"" + type);
        marker.addInfo(""String_Node_Str"" + v.getType());
        markers.add(marker);
      }
    }
    this.context=null;
  }
}",0.958927074601844
85170,"@Override public void resolveTypes(List<Marker> markers,IContext context){
  if (this.isArray) {
    for (int i=0; i < this.valueCount; i++) {
      this.values[i].resolveTypes(markers,context);
    }
    return;
  }
  this.context=context;
  for (int i=0; i < this.valueCount; i++) {
    IValue v=this.values[i];
    if (v.isStatement()) {
      ((IStatement)v).setParent(this);
    }
    v.resolveTypes(markers,this);
  }
}","@Override public void resolveTypes(List<Marker> markers,IContext context){
  if (this.isArray) {
    for (int i=0; i < this.valueCount; i++) {
      this.values[i].resolveTypes(markers,context);
    }
    return;
  }
  this.context=context;
  for (int i=0; i < this.valueCount; i++) {
    IValue v=this.values[i];
    if (v.isStatement()) {
      ((IStatement)v).setParent(this);
    }
    v.resolveTypes(markers,this);
  }
  this.context=null;
}",0.9758897818599312
85171,"@Override public int getSignatureMatch(String name,IValue instance,IArguments arguments){
  if (name == null) {
    return 1;
  }
  if (!name.equals(this.qualifiedName)) {
    return 0;
  }
  if (arguments == null) {
    return 1;
  }
  int pOff=0;
  int match=1;
  int len=arguments.size();
  int mods=this.modifiers & Modifiers.INFIX;
  if (instance != null && mods == Modifiers.INFIX) {
    if (len != this.parameterCount - 1) {
      return 0;
    }
    IType t2=this.parameters[0].type;
    int m=instance.getTypeMatch(t2);
    if (m == 0) {
      return 0;
    }
    match+=m;
    pOff=1;
  }
 else   if (mods == Modifiers.STATIC && instance != null && instance.getValueType() != IValue.CLASS_ACCESS) {
    return 0;
  }
 else   if ((this.modifiers & Modifiers.VARARGS) != 0) {
    int parCount=this.parameterCount - 1;
    if (len <= parCount) {
      return 0;
    }
    int m;
    Parameter varParam=this.parameters[parCount];
    varParam.index=parCount;
    for (int i=0; i < parCount; i++) {
      Parameter par=this.parameters[i + pOff];
      par.index=i + pOff;
      m=arguments.getTypeMatch(par);
      if (m == 0) {
        return 0;
      }
      match+=m;
    }
    for (int i=parCount; i < len; i++) {
      m=arguments.getVarargsTypeMatch(varParam);
      if (m == 0) {
        return 0;
      }
      match+=m;
    }
    return match;
  }
 else   if (len > this.parameterCount) {
    return 0;
  }
  for (int i=0; i < this.parameterCount; i++) {
    Parameter par=this.parameters[i + pOff];
    par.index=i;
    int m=arguments.getTypeMatch(par);
    if (m == 0) {
      return 0;
    }
    match+=m;
  }
  return match;
}","@Override public int getSignatureMatch(String name,IValue instance,IArguments arguments){
  if (name != null && !name.equals(this.qualifiedName)) {
    return 0;
  }
  if (arguments == null) {
    return 1;
  }
  int pOff=0;
  int match=1;
  int len=arguments.size();
  int mods=this.modifiers & Modifiers.INFIX;
  if (instance != null && mods == Modifiers.INFIX) {
    if (len != this.parameterCount - 1) {
      return 0;
    }
    IType t2=this.parameters[0].type;
    int m=instance.getTypeMatch(t2);
    if (m == 0) {
      return 0;
    }
    match+=m;
    pOff=1;
  }
 else   if (mods == Modifiers.STATIC && instance != null && instance.getValueType() != IValue.CLASS_ACCESS) {
    return 0;
  }
 else   if ((this.modifiers & Modifiers.VARARGS) != 0) {
    int parCount=this.parameterCount - 1;
    if (len <= parCount) {
      return 0;
    }
    int m;
    Parameter varParam=this.parameters[parCount];
    varParam.index=parCount;
    for (int i=0; i < parCount; i++) {
      Parameter par=this.parameters[i + pOff];
      par.index=i + pOff;
      m=arguments.getTypeMatch(par);
      if (m == 0) {
        return 0;
      }
      match+=m;
    }
    for (int i=parCount; i < len; i++) {
      m=arguments.getVarargsTypeMatch(varParam);
      if (m == 0) {
        return 0;
      }
      match+=m;
    }
    return match;
  }
 else   if (len > this.parameterCount) {
    return 0;
  }
  for (int i=0; i < this.parameterCount; i++) {
    Parameter par=this.parameters[i + pOff];
    par.index=i;
    int m=arguments.getTypeMatch(par);
    if (m == 0) {
      return 0;
    }
    match+=m;
  }
  return match;
}",0.9859154929577464
85172,"@Override public void write(ClassWriter writer){
  this.name=""String_Node_Str"" + this.index;
  this.desc=this.getLambdaDescriptor();
  boolean instance=this.thisType != null;
  int modifiers=instance ? Modifiers.PRIVATE | Modifiers.SYNTHETIC : Modifiers.PRIVATE | Modifiers.STATIC | Modifiers.SYNTHETIC;
  MethodWriter mw=new MethodWriter(writer,writer.visitMethod(modifiers,this.name,this.desc,null,null));
  int[] prevIndex=null;
  if (instance) {
    mw.addLocal(this.thisType);
  }
  if (this.capturedFieldCount > 0) {
    prevIndex=new int[this.capturedFieldCount];
    for (int i=0; i < this.capturedFieldCount; i++) {
      IVariable var=this.capturedFields[i];
      prevIndex[i]=var.getIndex();
      var.setIndex(mw.visitParameter(var.getQualifiedName(),var.getType()));
    }
  }
  for (int i=0; i < this.parameterCount; i++) {
    LambdaParameter param=this.parameters[i];
    param.index=mw.visitParameter(param.qualifiedName,param.type);
  }
  mw.visitCode();
  this.value.writeExpression(mw);
  mw.visitEnd(this.method.getType());
  for (int i=0; i < this.parameterCount; i++) {
    IVariable var=this.capturedFields[i];
    var.setIndex(prevIndex[i]);
  }
}","@Override public void write(ClassWriter writer){
  boolean instance=this.thisType != null;
  int modifiers=instance ? Modifiers.PRIVATE | Modifiers.SYNTHETIC : Modifiers.PRIVATE | Modifiers.STATIC | Modifiers.SYNTHETIC;
  MethodWriter mw=new MethodWriter(writer,writer.visitMethod(modifiers,this.name,this.desc,null,null));
  int[] prevIndex=null;
  if (instance) {
    mw.addLocal(this.thisType);
  }
  if (this.capturedFieldCount > 0) {
    prevIndex=new int[this.capturedFieldCount];
    for (int i=0; i < this.capturedFieldCount; i++) {
      IVariable var=this.capturedFields[i];
      prevIndex[i]=var.getIndex();
      var.setIndex(mw.visitParameter(var.getQualifiedName(),var.getType()));
    }
  }
  for (int i=0; i < this.parameterCount; i++) {
    LambdaParameter param=this.parameters[i];
    param.index=mw.visitParameter(param.qualifiedName,param.type);
  }
  mw.visitCode();
  this.value.writeExpression(mw);
  mw.visitEnd(this.method.getType());
  for (int i=0; i < this.parameterCount; i++) {
    IVariable var=this.capturedFields[i];
    var.setIndex(prevIndex[i]);
  }
}",0.9628647214854112
85173,"@Override public void check(List<Marker> markers,IContext context){
  if (this.method != null) {
    if (this.method.hasTypeVariables()) {
      this.returnType=this.method.getType(this);
      for (int i=0; i < this.parameterCount; i++) {
        LambdaParameter param=this.parameters[i];
        param.baseType=method.getParameter(i).type;
        param.type=param.type.getConcreteType(this);
      }
    }
 else {
      this.returnType=this.method.getType();
    }
  }
 else {
    markers.add(Markers.create(this.position,""String_Node_Str""));
  }
  this.context=context;
  this.value=this.value.resolve(markers,this);
  this.value.check(markers,context);
}","@Override public void check(List<Marker> markers,IContext context){
  if (this.method != null) {
    if (this.method.hasTypeVariables()) {
      this.returnType=this.method.getType(this);
      for (int i=0; i < this.parameterCount; i++) {
        LambdaParameter param=this.parameters[i];
        param.baseType=method.getParameter(i).type;
        param.type=param.type.getConcreteType(this);
      }
    }
 else {
      this.returnType=this.method.getType();
    }
  }
 else {
    markers.add(Markers.create(this.position,""String_Node_Str""));
  }
  this.context=context;
  this.value=this.value.resolve(markers,this);
  this.value.check(markers,context);
  this.name=""String_Node_Str"" + this.index;
  this.desc=this.getLambdaDescriptor();
}",0.9400855920114124
85174,"@Override public void writeStatement(MethodWriter writer){
  for (  IValue v : this.values) {
    v.writeStatement(writer);
  }
}","@Override public void writeStatement(MethodWriter writer){
  for (int i=0; i < this.valueCount; i++) {
    this.values[i].writeStatement(writer);
  }
}",0.8285714285714286
85175,"@Override public void check(List<Marker> markers,IContext context){
  for (  IValue v : this.values) {
    v.check(markers,context);
  }
}","@Override public void check(List<Marker> markers,IContext context){
  for (int i=0; i < this.valueCount; i++) {
    this.values[i].check(markers,context);
  }
}",0.8389261744966443
85176,"@Override public void writeExpression(MethodWriter writer){
  TupleType t=this.tupleType;
  writer.visitTypeInsn(Opcodes.NEW,t);
  writer.visitInsn(Opcodes.DUP);
  for (  IValue v : this.values) {
    v.writeExpression(writer);
  }
  String owner=t.getInternalName();
  String desc=t.getConstructorDescriptor();
  writer.visitMethodInsn(Opcodes.INVOKESPECIAL,owner,""String_Node_Str"",desc,false,this.valueCount + 1,t);
}","@Override public void writeExpression(MethodWriter writer){
  TupleType t=this.tupleType;
  writer.visitTypeInsn(Opcodes.NEW,t);
  writer.visitInsn(Opcodes.DUP);
  for (int i=0; i < this.valueCount; i++) {
    this.values[i].writeExpression(writer);
  }
  String owner=t.getInternalName();
  String desc=t.getConstructorDescriptor();
  writer.visitMethodInsn(Opcodes.INVOKESPECIAL,owner,""String_Node_Str"",desc,false,this.valueCount + 1,t);
}",0.916279069767442
85177,"@Override public void resolveTypes(List<Marker> markers,IContext context){
  TupleType type=new TupleType();
  for (  IValue v : this.values) {
    v.resolveTypes(markers,context);
    type.addType(v.getType());
  }
  type.getTheClass();
  this.tupleType=type;
}","@Override public void resolveTypes(List<Marker> markers,IContext context){
  TupleType type=new TupleType();
  for (int i=0; i < this.valueCount; i++) {
    IValue v=this.values[i];
    v.resolveTypes(markers,context);
    type.addType(v.getType());
  }
  type.getTheClass();
  this.tupleType=type;
}",0.9110320284697508
85178,"@Override public IClass resolveClass(String name){
  if (!this.typesResolved) {
    this.resolveTypes(null,Package.rootPackage);
  }
  if (this.generics != null) {
    for (    ITypeVariable var : this.generics) {
      if (var.isName(name)) {
        return var.getCaptureClass();
      }
    }
  }
  IClass clazz=this.body.getClass(name);
  if (clazz != null) {
    return clazz;
  }
  return null;
}","@Override public IClass resolveClass(String name){
  if (!this.typesResolved) {
    this.resolveTypes(null,Package.rootPackage);
  }
  for (int i=0; i < this.genericCount; i++) {
    ITypeVariable var=this.generics[i];
    if (var.isName(name)) {
      return var.getCaptureClass();
    }
  }
  IClass clazz=this.body.getClass(name);
  if (clazz != null) {
    return clazz;
  }
  return null;
}",0.7653701380175659
85179,"@Override public void resolveTypes(List<Marker> markers,IContext context){
  this.typesResolved=true;
  if (this.generics != null) {
    GenericType type=new GenericType(this);
    for (    ITypeVariable v : this.generics) {
      v.resolveTypes(markers,context);
      type.addType(new WildcardType(null,0,v.getCaptureClass()));
    }
    this.type=type;
  }
  if (this.superType != null) {
    if (this.superType.isName(""String_Node_Str"")) {
      this.superType=null;
    }
 else {
      this.superType=this.superType.resolve(markers,context);
    }
  }
  for (ListIterator<IType> iterator=this.interfaces.listIterator(); iterator.hasNext(); ) {
    IType i1=iterator.next();
    IType i2=i1.resolve(markers,context);
    if (i1 != i2) {
      iterator.set(i2);
    }
  }
  for (int i=0; i < this.annotationCount; i++) {
    this.annotations[i].resolveTypes(markers,context);
  }
  this.body.resolveTypes(markers,this);
  if (this.outerType != null) {
    this.outerClass=this.outerType.resolve(markers,context).getTheClass();
  }
  if (this.innerTypes != null) {
    for (    IType t : this.innerTypes) {
      IClass iclass=t.resolve(markers,context).getTheClass();
      this.body.addClass(iclass);
    }
    this.innerTypes=null;
  }
}","@Override public void resolveTypes(List<Marker> markers,IContext context){
  this.typesResolved=true;
  if (this.genericCount > 0) {
    GenericType type=new GenericType(this);
    for (int i=0; i < this.genericCount; i++) {
      ITypeVariable var=this.generics[i];
      var.resolveTypes(markers,context);
      type.addType(new WildcardType(null,0,var.getCaptureClass()));
    }
    this.type=type;
  }
  if (this.superType != null) {
    if (this.superType.isName(""String_Node_Str"")) {
      this.superType=null;
    }
 else {
      this.superType=this.superType.resolve(markers,context);
    }
  }
  for (ListIterator<IType> iterator=this.interfaces.listIterator(); iterator.hasNext(); ) {
    IType i1=iterator.next();
    IType i2=i1.resolve(markers,context);
    if (i1 != i2) {
      iterator.set(i2);
    }
  }
  for (int i=0; i < this.annotationCount; i++) {
    this.annotations[i].resolveTypes(markers,context);
  }
  this.body.resolveTypes(markers,this);
  if (this.outerType != null) {
    this.outerClass=this.outerType.resolve(markers,context).getTheClass();
  }
  if (this.innerTypes != null) {
    for (    IType t : this.innerTypes) {
      IClass iclass=t.resolve(markers,context).getTheClass();
      this.body.addClass(iclass);
    }
    this.innerTypes=null;
  }
}",0.9636363636363636
85180,"@Override public int getSignatureMatch(String name,IValue instance,IArguments arguments){
  if (name == null) {
    return 1;
  }
  if (!name.equals(this.qualifiedName)) {
    return 0;
  }
  if (arguments == null) {
    return 1;
  }
  int pOff=0;
  int match=1;
  int len=arguments.size();
  int mods=this.modifiers & Modifiers.INFIX;
  if (instance != null && mods == Modifiers.INFIX) {
    if (len != this.parameterCount - 1) {
      return 0;
    }
    IType t2=this.parameters[0].type;
    int m=instance.getTypeMatch(t2);
    if (m == 0) {
      return 0;
    }
    match+=m;
    pOff=1;
  }
 else   if (mods == Modifiers.STATIC && instance != null && instance.getValueType() != IValue.CLASS_ACCESS) {
    return 0;
  }
 else   if ((this.modifiers & Modifiers.VARARGS) != 0) {
    int parCount=this.parameterCount - 1;
    if (len <= parCount) {
      return 0;
    }
    int m;
    Parameter varParam=this.parameters[parCount];
    varParam.index=parCount;
    for (int i=0; i < parCount; i++) {
      Parameter par=this.parameters[i + pOff];
      par.index=i + pOff;
      m=arguments.getTypeMatch(par);
      if (m == 0) {
        return 0;
      }
      match+=m;
    }
    for (int i=parCount; i < len; i++) {
      m=arguments.getVarargsTypeMatch(varParam);
      if (m == 0) {
        return 0;
      }
      match+=m;
    }
    return match;
  }
 else   if (len > this.parameterCount) {
    return 0;
  }
  for (int i=0; i < len; i++) {
    Parameter par=this.parameters[i + pOff];
    par.index=i;
    int m=arguments.getTypeMatch(par);
    if (m == 0) {
      return 0;
    }
    match+=m;
  }
  return match;
}","@Override public int getSignatureMatch(String name,IValue instance,IArguments arguments){
  if (name == null) {
    return 1;
  }
  if (!name.equals(this.qualifiedName)) {
    return 0;
  }
  if (arguments == null) {
    return 1;
  }
  int pOff=0;
  int match=1;
  int len=arguments.size();
  int mods=this.modifiers & Modifiers.INFIX;
  if (instance != null && mods == Modifiers.INFIX) {
    if (len != this.parameterCount - 1) {
      return 0;
    }
    IType t2=this.parameters[0].type;
    int m=instance.getTypeMatch(t2);
    if (m == 0) {
      return 0;
    }
    match+=m;
    pOff=1;
  }
 else   if (mods == Modifiers.STATIC && instance != null && instance.getValueType() != IValue.CLASS_ACCESS) {
    return 0;
  }
 else   if ((this.modifiers & Modifiers.VARARGS) != 0) {
    int parCount=this.parameterCount - 1;
    if (len <= parCount) {
      return 0;
    }
    int m;
    Parameter varParam=this.parameters[parCount];
    varParam.index=parCount;
    for (int i=0; i < parCount; i++) {
      Parameter par=this.parameters[i + pOff];
      par.index=i + pOff;
      m=arguments.getTypeMatch(par);
      if (m == 0) {
        return 0;
      }
      match+=m;
    }
    for (int i=parCount; i < len; i++) {
      m=arguments.getVarargsTypeMatch(varParam);
      if (m == 0) {
        return 0;
      }
      match+=m;
    }
    return match;
  }
 else   if (len > this.parameterCount) {
    return 0;
  }
  for (int i=0; i < this.parameterCount; i++) {
    Parameter par=this.parameters[i + pOff];
    par.index=i;
    int m=arguments.getTypeMatch(par);
    if (m == 0) {
      return 0;
    }
    match+=m;
  }
  return match;
}",0.9932803909590716
85181,"@Override public void checkArguments(List<Marker> markers,IValue instance,IArguments arguments,ITypeContext typeContext){
  int pOff=0;
  int len=arguments.size();
  Parameter par;
  IType parType;
  if (instance != null && (this.modifiers & Modifiers.INFIX) == Modifiers.INFIX) {
    par=this.parameters[0];
    parType=par.getType(typeContext);
    IValue instance1=instance.withType(parType);
    if (instance1 == null) {
      Marker marker=Markers.create(instance.getPosition(),""String_Node_Str"",par.name);
      marker.addInfo(""String_Node_Str"" + parType);
      marker.addInfo(""String_Node_Str"" + instance.getType());
      markers.add(marker);
    }
    pOff=1;
  }
 else   if (instance == null && (this.modifiers & Modifiers.PREFIX) == Modifiers.PREFIX) {
    parType=this.theClass.getType();
    instance=arguments.getFirstValue();
    IValue instance1=instance.withType(parType);
    if (instance1 == null) {
      Marker marker=Markers.create(instance.getPosition(),""String_Node_Str"",this.name);
      marker.addInfo(""String_Node_Str"" + parType);
      marker.addInfo(""String_Node_Str"" + instance.getType());
      markers.add(marker);
    }
    return;
  }
  if ((this.modifiers & Modifiers.VARARGS) != 0) {
    len=this.parameterCount - 1;
    par=this.parameters[len];
    par.index=len;
    arguments.checkVarargsValue(markers,par,typeContext);
  }
  for (int i=0; i < len; i++) {
    par=this.parameters[i + pOff];
    par.index=i;
    arguments.checkValue(markers,par,typeContext);
  }
}","@Override public void checkArguments(List<Marker> markers,IValue instance,IArguments arguments,ITypeContext typeContext){
  int pOff=0;
  int len=arguments.size();
  Parameter par;
  IType parType;
  if (instance != null && (this.modifiers & Modifiers.INFIX) == Modifiers.INFIX) {
    par=this.parameters[0];
    parType=par.getType(typeContext);
    IValue instance1=instance.withType(parType);
    if (instance1 == null) {
      Marker marker=Markers.create(instance.getPosition(),""String_Node_Str"",par.name);
      marker.addInfo(""String_Node_Str"" + parType);
      marker.addInfo(""String_Node_Str"" + instance.getType());
      markers.add(marker);
    }
    pOff=1;
  }
 else   if (instance == null && (this.modifiers & Modifiers.PREFIX) == Modifiers.PREFIX) {
    parType=this.theClass.getType();
    instance=arguments.getFirstValue();
    IValue instance1=instance.withType(parType);
    if (instance1 == null) {
      Marker marker=Markers.create(instance.getPosition(),""String_Node_Str"",this.name);
      marker.addInfo(""String_Node_Str"" + parType);
      marker.addInfo(""String_Node_Str"" + instance.getType());
      markers.add(marker);
    }
    return;
  }
  if ((this.modifiers & Modifiers.VARARGS) != 0) {
    len=this.parameterCount - 1;
    par=this.parameters[len];
    par.index=len;
    arguments.checkVarargsValue(markers,par,typeContext);
  }
  for (int i=0; i < this.parameterCount; i++) {
    par=this.parameters[i + pOff];
    par.index=i;
    arguments.checkValue(markers,par,typeContext);
  }
}",0.992729676140119
85182,"@Override public int getTypeMatch(Parameter param){
  if (param.index > this.size) {
    return 0;
  }
  return this.values[param.index].getTypeMatch(param.type);
}","@Override public int getTypeMatch(Parameter param){
  if (param.index >= this.size) {
    return param.defaultValue != null ? 3 : 0;
  }
  return this.values[param.index].getTypeMatch(param.type);
}",0.9060773480662984
85183,"@Override public void writeValue(Parameter param,MethodWriter writer){
  if (param.varargs) {
    IType type=param.type.getElementType();
    int len=this.size - param.index;
    int opcode=type.getArrayStoreOpcode();
    writer.visitLdcInsn(len);
    writer.visitTypeInsn(Opcodes.ANEWARRAY,type);
    for (int i=0; i < len; i++) {
      writer.visitInsn(Opcodes.DUP);
      IValue value=this.values[param.index + i];
      writer.visitLdcInsn(i);
      value.writeExpression(writer);
      writer.visitInsn(opcode);
    }
    return;
  }
  this.values[param.index].writeExpression(writer);
}","@Override public void writeValue(Parameter param,MethodWriter writer){
  if (param.varargs) {
    IType type=param.type.getElementType();
    int len=this.size - param.index;
    int opcode=type.getArrayStoreOpcode();
    writer.visitLdcInsn(len);
    writer.visitTypeInsn(Opcodes.ANEWARRAY,type);
    for (int i=0; i < len; i++) {
      writer.visitInsn(Opcodes.DUP);
      IValue value=this.values[param.index + i];
      writer.visitLdcInsn(i);
      value.writeExpression(writer);
      writer.visitInsn(opcode);
    }
    return;
  }
  if (param.index < this.size) {
    this.values[param.index].writeExpression(writer);
    return;
  }
  param.defaultValue.writeExpression(writer);
}",0.9242779078844652
85184,"@Override public Iterator<IValue> iterator(){
  return new ArrayIterator(this.values);
}","@Override public Iterator<IValue> iterator(){
  return new ArrayIterator(this.values,this.size);
}",0.946236559139785
85185,"@Override public int getTypeMatch(Parameter param){
  return param.index == 0 ? this.value.getTypeMatch(param.type) : 0;
}","@Override public int getTypeMatch(Parameter param){
  if (param.index == 0) {
    return this.value.getTypeMatch(param.type);
  }
  return param.defaultValue != null ? 3 : 0;
}",0.7718120805369127
85186,"@Override public void writeValue(Parameter param,MethodWriter writer){
  if (param.index == 0) {
    this.value.writeExpression(writer);
  }
}","@Override public void writeValue(Parameter param,MethodWriter writer){
  if (param.index == 0) {
    this.value.writeExpression(writer);
    return;
  }
  param.defaultValue.writeExpression(writer);
}",0.8304093567251462
85187,"public static void typesToString(String prefix,Iterable<? extends ITyped> list,String seperator,StringBuilder buffer){
  Iterator<? extends ITyped> iterator=list.iterator();
  while (true) {
    IType type=iterator.next().getType();
    if (type == null) {
      buffer.append(""String_Node_Str"");
    }
 else {
      type.toString(prefix,buffer);
    }
    if (iterator.hasNext()) {
      buffer.append(seperator);
    }
 else {
      break;
    }
  }
}","public static void typesToString(String prefix,Iterable<? extends ITyped> list,String seperator,StringBuilder buffer){
  Iterator<? extends ITyped> iterator=list.iterator();
  if (!iterator.hasNext()) {
    return;
  }
  while (true) {
    IType type=iterator.next().getType();
    if (type == null) {
      buffer.append(""String_Node_Str"");
    }
 else {
      type.toString(prefix,buffer);
    }
    if (iterator.hasNext()) {
      buffer.append(seperator);
    }
 else {
      break;
    }
  }
}",0.9526813880126184
85188,"@Override public boolean parse(ParserManager pm,IToken token) throws SyntaxError {
  if (this.mode == NAME) {
    this.annotation=new Annotation(token.raw(),token.value().substring(1));
    this.mode=PARAMETERS_START;
    if (!token.next().isType(Tokens.OPEN_PARENTHESIS)) {
      this.annotatable.addAnnotation(this.annotation);
      pm.popParser();
    }
    return true;
  }
  if (this.isInMode(PARAMETERS_START)) {
    if (token.isType(Tokens.OPEN_PARENTHESIS)) {
      pm.pushParser(new ExpressionMapParser(this.annotation));
      this.mode=PARAMETERS_END;
      return true;
    }
  }
  if (this.isInMode(PARAMETERS_END)) {
    if (token.isType(Tokens.CLOSE_PARENTHESIS)) {
      this.annotation.expandPosition(token);
      this.annotatable.addAnnotation(this.annotation);
      pm.popParser();
      return true;
    }
  }
  return false;
}","@Override public boolean parse(ParserManager pm,IToken token) throws SyntaxError {
  int type=token.type();
  if (this.mode == NAME) {
    if (ParserUtil.isIdentifier(type)) {
      this.annotation=new Annotation(token.raw(),token.value().substring(1));
      this.mode=PARAMETERS_START;
      if (token.next().type() != Tokens.OPEN_PARENTHESIS) {
        this.annotatable.addAnnotation(this.annotation);
        pm.popParser();
      }
      return true;
    }
    throw new SyntaxError(token,""String_Node_Str"");
  }
  if (this.mode == PARAMETERS_START) {
    if (type == Tokens.OPEN_PARENTHESIS) {
      pm.pushParser(new ExpressionMapParser(this.annotation));
      this.mode=PARAMETERS_END;
      return true;
    }
    throw new SyntaxError(token,""String_Node_Str"");
  }
  if (this.mode == PARAMETERS_END) {
    if (type == Tokens.CLOSE_PARENTHESIS) {
      this.annotation.expandPosition(token);
      this.annotatable.addAnnotation(this.annotation);
      pm.popParser();
      return true;
    }
    throw new SyntaxError(token,""String_Node_Str"");
  }
  return false;
}",0.7628437986507525
85189,"@Override public boolean parse(ParserManager pm,IToken token) throws SyntaxError {
  if (this.isInMode(LABEL)) {
    if (token.next().isType(Tokens.COLON)) {
      this.label=token.value();
      pm.skip();
      return true;
    }
  }
  int type=token.type();
  if (this.isInMode(INSTRUCTION)) {
    if (ParserUtil.isIdentifier(type)) {
      String name=token.value();
      Instruction insn=Instruction.parse(name);
      if (insn == null) {
        this.mode=INSTRUCTION | LABEL;
        throw new SyntaxError(token,""String_Node_Str"" + name + ""String_Node_Str"");
      }
      if (this.label != null) {
        this.bytecode.addInstruction(insn,this.label);
        this.label=null;
      }
 else {
        this.bytecode.addInstruction(insn);
      }
      insn.setPosition(token);
      this.instruction=insn;
      this.mode=ARGUMENTS;
      return true;
    }
  }
  if (this.isInMode(ARGUMENTS)) {
    if (type == Tokens.SEMICOLON) {
      this.mode=INSTRUCTION | LABEL;
      return true;
    }
    if (type == Tokens.COMMA) {
      return true;
    }
    if (!ParserUtil.isTerminator(type)) {
      if (this.instruction == null) {
        throw new SyntaxError(token,""String_Node_Str"" + token.value() + ""String_Node_Str"");
      }
 else       if (!this.instruction.addArgument(token.object())) {
        throw new SyntaxError(token,""String_Node_Str"" + token.value() + ""String_Node_Str""+ this.instruction.getName());
      }
      return true;
    }
  }
  pm.popParser(true);
  return true;
}","@Override public boolean parse(ParserManager pm,IToken token) throws SyntaxError {
  if (this.isInMode(LABEL)) {
    if (token.next().type() == Tokens.COLON) {
      this.label=token.value();
      pm.skip();
      return true;
    }
  }
  int type=token.type();
  if (this.isInMode(INSTRUCTION)) {
    if (ParserUtil.isIdentifier(type)) {
      String name=token.value();
      Instruction insn=Instruction.parse(name);
      if (insn == null) {
        this.mode=INSTRUCTION | LABEL;
        throw new SyntaxError(token,""String_Node_Str"" + name + ""String_Node_Str"");
      }
      if (this.label != null) {
        this.bytecode.addInstruction(insn,this.label);
        this.label=null;
      }
 else {
        this.bytecode.addInstruction(insn);
      }
      insn.setPosition(token);
      this.instruction=insn;
      this.mode=ARGUMENTS;
      return true;
    }
  }
  if (this.isInMode(ARGUMENTS)) {
    if (type == Tokens.SEMICOLON) {
      this.mode=INSTRUCTION | LABEL;
      return true;
    }
    if (type == Tokens.COMMA) {
      return true;
    }
    if (!ParserUtil.isTerminator(type)) {
      if (this.instruction == null) {
        throw new SyntaxError(token,""String_Node_Str"" + token.value() + ""String_Node_Str"");
      }
 else       if (!this.instruction.addArgument(token.object())) {
        throw new SyntaxError(token,""String_Node_Str"" + token.value() + ""String_Node_Str""+ this.instruction.getName());
      }
      return true;
    }
  }
  pm.popParser(true);
  return true;
}",0.9966688874083944
85190,"@Override public boolean parse(ParserManager pm,IToken token) throws SyntaxError {
  int type=token.type();
  if (type == Tokens.SEMICOLON) {
    this.reset();
    return true;
  }
  String value=token.value();
  if (this.isInMode(BODY_END)) {
    if (type == Tokens.CLOSE_CURLY_BRACKET) {
      pm.popParser(true);
      return true;
    }
  }
  if (this.isInMode(TYPE)) {
    int i=0;
    if ((i=Modifiers.MEMBER.parse(value)) != -1) {
      if ((this.modifiers & i) != 0) {
        throw new SyntaxError(token,""String_Node_Str"" + value + ""String_Node_Str"");
      }
      this.modifiers|=i;
      return true;
    }
    if ((i=Modifiers.CLASS_TYPE.parse(value)) != -1) {
      CodeClass codeClass=new CodeClass(null,this.theClass.getUnit(),this.modifiers,this.annotations);
      this.theClass.getBody().addClass(codeClass);
      codeClass.setOuterClass(this.theClass);
      ClassDeclParser parser=new ClassDeclParser(codeClass);
      pm.pushParser(parser);
      this.modifiers=0;
      this.annotations=new ArrayList();
      return true;
    }
    if (value.charAt(0) == '@') {
      pm.pushParser(new AnnotationParser(this),true);
      return true;
    }
    pm.pushParser(new TypeParser(this),true);
    this.mode=NAME;
    return true;
  }
  if (this.isInMode(NAME)) {
    if (ParserUtil.isIdentifier(type) || type == Tokens.NEW) {
      IToken next=token.next();
      type=next.type();
      if (type == Tokens.SEMICOLON) {
        Field f=new Field(this.theClass,value,this.type,this.modifiers,this.annotations);
        f.setPosition(token.raw());
        this.body.addField(f);
        pm.skip();
        this.reset();
        return true;
      }
      if (type == Tokens.OPEN_PARENTHESIS) {
        this.mode=PARAMETERS;
        this.method=new Method(this.theClass,value,this.type,this.modifiers,this.annotations);
        this.method.setPosition(token.raw());
        this.body.addMethod(this.method);
        return true;
      }
      if (type == Tokens.OPEN_CURLY_BRACKET) {
        this.mode=PROPERTY_END;
        Property property=new Property(this.theClass,value,this.type,this.modifiers,this.annotations);
        property.setPosition(token.raw());
        this.body.addProperty(property);
        pm.skip();
        pm.pushParser(new PropertyParser(this.theClass,property));
        return true;
      }
      if (type == Tokens.EQUALS) {
        Field field=new Field(this.theClass,value,this.type,this.modifiers,this.annotations);
        field.setPosition(token.raw());
        this.body.addField(field);
        pm.skip();
        pm.pushParser(new ExpressionParser(field));
        this.reset();
        return true;
      }
      if (type == Tokens.OPEN_SQUARE_BRACKET) {
        this.mode=GENERICS_END;
        this.method=new Method(this.theClass,value,this.type,this.modifiers,this.annotations);
        this.method.setPosition(token.raw());
        this.method.setGeneric();
        this.body.addMethod(this.method);
        pm.skip();
        pm.pushParser(new TypeVariableListParser(this.method));
        return true;
      }
    }
    return false;
  }
  if (this.isInMode(PROPERTY_END)) {
    if (type == Tokens.CLOSE_CURLY_BRACKET) {
      this.reset();
      return true;
    }
    return false;
  }
  if (this.isInMode(GENERICS_END)) {
    if (type == Tokens.CLOSE_SQUARE_BRACKET) {
      this.mode=PARAMETERS;
      return true;
    }
    return false;
  }
  if (this.isInMode(PARAMETERS)) {
    if (type == Tokens.OPEN_PARENTHESIS) {
      pm.pushParser(new ParameterListParser(this.method));
      this.mode=PARAMETERS_END;
      return true;
    }
    return false;
  }
  if (this.isInMode(PARAMETERS_END)) {
    if (type == Tokens.CLOSE_PARENTHESIS) {
      this.mode=METHOD_END;
      return true;
    }
    return false;
  }
  if (this.isInMode(METHOD_END)) {
    if (type == Tokens.OPEN_CURLY_BRACKET) {
      pm.pushParser(new ExpressionParser(this.method),true);
      return true;
    }
    if (type == Tokens.EQUALS) {
      pm.pushParser(new ExpressionParser(this.method));
      return true;
    }
    if (""String_Node_Str"".equals(value)) {
      pm.pushParser(new ThrowsDeclParser(this.method));
      return true;
    }
  }
  if (token.prev().isType(Tokens.CLOSE_CURLY_BRACKET)) {
    this.reset();
    pm.reparse();
    return true;
  }
  return false;
}","@Override public boolean parse(ParserManager pm,IToken token) throws SyntaxError {
  int type=token.type();
  if (type == Tokens.SEMICOLON) {
    this.reset();
    return true;
  }
  String value=token.value();
  if (this.isInMode(BODY_END)) {
    if (type == Tokens.CLOSE_CURLY_BRACKET) {
      pm.popParser(true);
      return true;
    }
  }
  if (this.isInMode(TYPE)) {
    int i=0;
    if ((i=Modifiers.MEMBER.parse(value)) != -1) {
      if ((this.modifiers & i) != 0) {
        throw new SyntaxError(token,""String_Node_Str"" + value + ""String_Node_Str"");
      }
      this.modifiers|=i;
      return true;
    }
    if ((i=Modifiers.CLASS_TYPE.parse(value)) != -1) {
      CodeClass codeClass=new CodeClass(null,this.theClass.getUnit(),this.modifiers,this.annotations);
      this.theClass.getBody().addClass(codeClass);
      codeClass.setOuterClass(this.theClass);
      ClassDeclParser parser=new ClassDeclParser(codeClass);
      pm.pushParser(parser);
      this.modifiers=0;
      this.annotations=new ArrayList();
      return true;
    }
    if (value.charAt(0) == '@') {
      pm.pushParser(new AnnotationParser(this),true);
      return true;
    }
    pm.pushParser(new TypeParser(this),true);
    this.mode=NAME;
    return true;
  }
  if (this.isInMode(NAME)) {
    if (ParserUtil.isIdentifier(type) || type == Tokens.NEW) {
      IToken next=token.next();
      type=next.type();
      if (type == Tokens.SEMICOLON) {
        Field f=new Field(this.theClass,value,this.type,this.modifiers,this.annotations);
        f.setPosition(token.raw());
        this.body.addField(f);
        pm.skip();
        this.reset();
        return true;
      }
      if (type == Tokens.OPEN_PARENTHESIS) {
        this.mode=PARAMETERS;
        this.method=new Method(this.theClass,value,this.type,this.modifiers,this.annotations);
        this.method.setPosition(token.raw());
        this.body.addMethod(this.method);
        return true;
      }
      if (type == Tokens.OPEN_CURLY_BRACKET) {
        this.mode=PROPERTY_END;
        Property property=new Property(this.theClass,value,this.type,this.modifiers,this.annotations);
        property.setPosition(token.raw());
        this.body.addProperty(property);
        pm.skip();
        pm.pushParser(new PropertyParser(this.theClass,property));
        return true;
      }
      if (type == Tokens.EQUALS) {
        Field field=new Field(this.theClass,value,this.type,this.modifiers,this.annotations);
        field.setPosition(token.raw());
        this.body.addField(field);
        pm.skip();
        pm.pushParser(new ExpressionParser(field));
        this.reset();
        return true;
      }
      if (type == Tokens.OPEN_SQUARE_BRACKET) {
        this.mode=GENERICS_END;
        this.method=new Method(this.theClass,value,this.type,this.modifiers,this.annotations);
        this.method.setPosition(token.raw());
        this.method.setGeneric();
        this.body.addMethod(this.method);
        pm.skip();
        pm.pushParser(new TypeVariableListParser(this.method));
        return true;
      }
    }
    return false;
  }
  if (this.isInMode(PROPERTY_END)) {
    if (type == Tokens.CLOSE_CURLY_BRACKET) {
      this.reset();
      return true;
    }
    return false;
  }
  if (this.isInMode(GENERICS_END)) {
    if (type == Tokens.CLOSE_SQUARE_BRACKET) {
      this.mode=PARAMETERS;
      return true;
    }
    return false;
  }
  if (this.isInMode(PARAMETERS)) {
    if (type == Tokens.OPEN_PARENTHESIS) {
      pm.pushParser(new ParameterListParser(this.method));
      this.mode=PARAMETERS_END;
      return true;
    }
    return false;
  }
  if (this.isInMode(PARAMETERS_END)) {
    if (type == Tokens.CLOSE_PARENTHESIS) {
      this.mode=METHOD_END;
      return true;
    }
    return false;
  }
  if (this.isInMode(METHOD_END)) {
    if (type == Tokens.OPEN_CURLY_BRACKET) {
      pm.pushParser(new ExpressionParser(this.method),true);
      return true;
    }
    if (type == Tokens.EQUALS) {
      pm.pushParser(new ExpressionParser(this.method));
      return true;
    }
    if (""String_Node_Str"".equals(value)) {
      pm.pushParser(new ThrowsDeclParser(this.method));
      return true;
    }
  }
  if (token.prev().type() == Tokens.CLOSE_CURLY_BRACKET) {
    this.reset();
    pm.reparse();
    return true;
  }
  return false;
}",0.9988425925925926
85191,"@Override public boolean parse(ParserManager pm,IToken token) throws SyntaxError {
  String value=token.value();
  if (this.isInMode(MODIFIERS)) {
    int i=0;
    if ((i=Modifiers.CLASS.parse(value)) != -1) {
      if (this.theClass.addModifier(i)) {
        throw new SyntaxError(token,""String_Node_Str"" + value + ""String_Node_Str"");
      }
      return true;
    }
 else     if ((i=Modifiers.CLASS_TYPE.parse(value)) != -1) {
      this.theClass.addModifier(i);
      this.mode=NAME;
      return true;
    }
 else     if (value.charAt(0) == '@') {
      pm.pushParser(new AnnotationParser(this.theClass),true);
      return true;
    }
  }
  int type=token.type();
  if (this.isInMode(NAME)) {
    if (ParserUtil.isIdentifier(type)) {
      this.theClass.setPosition(token.raw());
      this.theClass.setName(value);
      this.mode=GENERICS | EXTENDS | IMPLEMENTS| BODY;
      return true;
    }
    return false;
  }
  if (this.isInMode(GENERICS)) {
    if (type == Tokens.OPEN_SQUARE_BRACKET) {
      pm.pushParser(new TypeVariableListParser(this.theClass));
      this.theClass.setGeneric();
      this.mode=GENERICS_END;
      return true;
    }
  }
  if (this.isInMode(GENERICS_END)) {
    if (type == Tokens.CLOSE_SQUARE_BRACKET) {
      this.mode=EXTENDS | IMPLEMENTS | BODY;
      return true;
    }
    return false;
  }
  if (this.isInMode(EXTENDS)) {
    if (""String_Node_Str"".equals(value)) {
      pm.pushParser(new TypeParser(this));
      this.mode=IMPLEMENTS | BODY;
      return true;
    }
  }
  if (this.isInMode(IMPLEMENTS)) {
    if (""String_Node_Str"".equals(value)) {
      pm.pushParser(new TypeListParser(this));
      this.mode=BODY;
      return true;
    }
  }
  if (this.isInMode(BODY)) {
    if (type == Tokens.OPEN_CURLY_BRACKET) {
      pm.pushParser(new ClassBodyParser(this.theClass));
      this.mode=BODY_END;
      return true;
    }
    if (ParserUtil.isTerminator(type)) {
      this.theClass.expandPosition(token);
      pm.popParser();
      return true;
    }
    return false;
  }
  if (this.isInMode(BODY_END)) {
    if (token.isType(Tokens.CLOSE_CURLY_BRACKET)) {
      this.theClass.expandPosition(token);
      pm.popParser();
      return true;
    }
    return false;
  }
  return false;
}","@Override public boolean parse(ParserManager pm,IToken token) throws SyntaxError {
  String value=token.value();
  if (this.isInMode(MODIFIERS)) {
    int i=0;
    if ((i=Modifiers.CLASS.parse(value)) != -1) {
      if (this.theClass.addModifier(i)) {
        throw new SyntaxError(token,""String_Node_Str"" + value + ""String_Node_Str"");
      }
      return true;
    }
 else     if ((i=Modifiers.CLASS_TYPE.parse(value)) != -1) {
      this.theClass.addModifier(i);
      this.mode=NAME;
      return true;
    }
 else     if (value.charAt(0) == '@') {
      pm.pushParser(new AnnotationParser(this.theClass),true);
      return true;
    }
  }
  int type=token.type();
  if (this.isInMode(NAME)) {
    if (ParserUtil.isIdentifier(type)) {
      this.theClass.setPosition(token.raw());
      this.theClass.setName(value);
      this.mode=GENERICS | EXTENDS | IMPLEMENTS| BODY;
      return true;
    }
    throw new SyntaxError(token,""String_Node_Str"");
  }
  if (this.isInMode(GENERICS)) {
    if (type == Tokens.OPEN_SQUARE_BRACKET) {
      pm.pushParser(new TypeVariableListParser(this.theClass));
      this.theClass.setGeneric();
      this.mode=GENERICS_END;
      return true;
    }
  }
  if (this.isInMode(GENERICS_END)) {
    if (type == Tokens.CLOSE_SQUARE_BRACKET) {
      this.mode=EXTENDS | IMPLEMENTS | BODY;
      return true;
    }
    return false;
  }
  if (this.isInMode(EXTENDS)) {
    if (""String_Node_Str"".equals(value)) {
      pm.pushParser(new TypeParser(this));
      this.mode=IMPLEMENTS | BODY;
      return true;
    }
  }
  if (this.isInMode(IMPLEMENTS)) {
    if (""String_Node_Str"".equals(value)) {
      pm.pushParser(new TypeListParser(this));
      this.mode=BODY;
      return true;
    }
  }
  if (this.isInMode(BODY)) {
    if (type == Tokens.OPEN_CURLY_BRACKET) {
      pm.pushParser(new ClassBodyParser(this.theClass));
      this.mode=BODY_END;
      return true;
    }
    if (ParserUtil.isTerminator(type)) {
      this.theClass.expandPosition(token);
      pm.popParser();
      return true;
    }
    throw new SyntaxError(token,""String_Node_Str"");
  }
  if (this.isInMode(BODY_END)) {
    if (type == Tokens.CLOSE_CURLY_BRACKET) {
      this.theClass.expandPosition(token);
      pm.popParser();
      return true;
    }
    throw new SyntaxError(token,""String_Node_Str"");
  }
  return false;
}",0.958969882147534
85192,"@Override public boolean parse(ParserManager jcp,IToken token) throws SyntaxError {
  String value=token.value();
  if (this.isInMode(PACKAGE)) {
    if (""String_Node_Str"".equals(value)) {
      this.mode=IMPORT | CLASS;
      jcp.pushParser(new PackageParser(this.unit));
      return true;
    }
  }
  if (this.isInMode(IMPORT)) {
    if (""String_Node_Str"".equals(value)) {
      this.mode=IMPORT | CLASS;
      Import i=new Import(token.raw());
      this.unit.addImport(i);
      jcp.pushParser(new ImportParser(null,i));
      return true;
    }
    if (""String_Node_Str"".equals(value)) {
      this.mode=IMPORT | CLASS;
      Import i=new Import(token.raw());
      i.isStatic=true;
      this.unit.addStaticImport(i);
      jcp.pushParser(new ImportParser(null,i));
      return true;
    }
  }
  if (this.isInMode(CLASS)) {
    if (token.isType(Tokens.SEMICOLON)) {
      return true;
    }
    jcp.pushParser(new ClassDeclParser(this.unit),true);
    return true;
  }
  return false;
}","@Override public boolean parse(ParserManager jcp,IToken token) throws SyntaxError {
  String value=token.value();
  if (this.isInMode(PACKAGE)) {
    if (""String_Node_Str"".equals(value)) {
      this.mode=IMPORT | CLASS;
      jcp.pushParser(new PackageParser(this.unit));
      return true;
    }
  }
  if (this.isInMode(IMPORT)) {
    if (""String_Node_Str"".equals(value)) {
      this.mode=IMPORT | CLASS;
      Import i=new Import(token.raw());
      this.unit.addImport(i);
      jcp.pushParser(new ImportParser(null,i));
      return true;
    }
    if (""String_Node_Str"".equals(value)) {
      this.mode=IMPORT | CLASS;
      Import i=new Import(token.raw());
      i.isStatic=true;
      this.unit.addStaticImport(i);
      jcp.pushParser(new ImportParser(null,i));
      return true;
    }
  }
  if (this.isInMode(CLASS)) {
    if (token.type() == Tokens.SEMICOLON) {
      return true;
    }
    jcp.pushParser(new ClassDeclParser(this.unit),true);
    return true;
  }
  return false;
}",0.9949748743718592
85193,"@Override public boolean parse(ParserManager pm,IToken token) throws SyntaxError {
  int type=token.type();
  if (this.mode == VALUE) {
    if (ParserUtil.isIdentifier(type)) {
      if (token.next().isType(Tokens.OPEN_CURLY_BRACKET)) {
        DWTNode node=new DWTNode(token.raw(),token.value());
        this.valued.setValue(node);
        pm.popParser();
        pm.pushParser(new DWTParser(node),true);
        return true;
      }
      this.valued.setValue(new DWTReference(token.raw(),token.value()));
      pm.popParser();
      return true;
    }
    if (type == Tokens.OPEN_SQUARE_BRACKET) {
      ValueList list=new DWTList(token);
      this.mode=LIST_END;
      this.valued.setValue(list);
      pm.pushParser(new DWTListParser(list));
      return true;
    }
    IValue primitive=parsePrimitive(token,type);
    if (primitive != null) {
      this.valued.setValue(primitive);
      pm.popParser();
      return true;
    }
    throw new SyntaxError(token,""String_Node_Str"");
  }
  if (this.mode == LIST_END) {
    if (type == Tokens.CLOSE_SQUARE_BRACKET) {
      pm.popParser();
      return true;
    }
  }
  return false;
}","@Override public boolean parse(ParserManager pm,IToken token) throws SyntaxError {
  int type=token.type();
  if (this.mode == VALUE) {
    if (ParserUtil.isIdentifier(type)) {
      if (token.next().type() == Tokens.OPEN_CURLY_BRACKET) {
        DWTNode node=new DWTNode(token.raw(),token.value());
        this.valued.setValue(node);
        pm.popParser();
        pm.pushParser(new DWTParser(node),true);
        return true;
      }
      this.valued.setValue(new DWTReference(token.raw(),token.value()));
      pm.popParser();
      return true;
    }
    if (type == Tokens.OPEN_SQUARE_BRACKET) {
      ValueList list=new DWTList(token);
      this.mode=LIST_END;
      this.valued.setValue(list);
      pm.pushParser(new DWTListParser(list));
      return true;
    }
    IValue primitive=parsePrimitive(token,type);
    if (primitive != null) {
      this.valued.setValue(primitive);
      pm.popParser();
      return true;
    }
    throw new SyntaxError(token,""String_Node_Str"");
  }
  if (this.mode == LIST_END) {
    if (type == Tokens.CLOSE_SQUARE_BRACKET) {
      pm.popParser();
      return true;
    }
  }
  return false;
}",0.995617879053462
85194,"@Override public boolean parse(ParserManager pm,IToken token) throws SyntaxError {
  int type=token.type();
  if (ParserUtil.isCloseBracket(type)) {
    pm.popParser(true);
    return true;
  }
  if (this.mode == 0) {
    if (token.next().isType(Tokens.COLON)) {
      this.label=token.value();
      pm.skip();
      return true;
    }
    this.mode=1;
    pm.pushParser(new ExpressionParser(this),true);
    return true;
  }
  if (this.mode == 1) {
    if (type == Tokens.COMMA) {
      this.valueList.setArray(true);
      this.mode=0;
      return true;
    }
    if (type == Tokens.SEMICOLON) {
      this.mode=0;
      return true;
    }
    if (token.prev().isType(Tokens.CLOSE_CURLY_BRACKET)) {
      pm.pushParser(new ExpressionParser(this),true);
      return true;
    }
  }
  return false;
}","@Override public boolean parse(ParserManager pm,IToken token) throws SyntaxError {
  int type=token.type();
  if (ParserUtil.isCloseBracket(type)) {
    pm.popParser(true);
    return true;
  }
  if (this.mode == 0) {
    if (token.next().type() == Tokens.COLON) {
      this.label=token.value();
      pm.skip();
      return true;
    }
    this.mode=1;
    pm.pushParser(new ExpressionParser(this),true);
    return true;
  }
  if (this.mode == 1) {
    if (type == Tokens.COMMA) {
      this.valueList.setArray(true);
      this.mode=0;
      return true;
    }
    if (type == Tokens.SEMICOLON) {
      this.mode=0;
      return true;
    }
    if (token.prev().type() == Tokens.CLOSE_CURLY_BRACKET) {
      pm.pushParser(new ExpressionParser(this),true);
      return true;
    }
  }
  return false;
}",0.9875776397515528
85195,"@Override public boolean parse(ParserManager pm,IToken token) throws SyntaxError {
  int type=token.type();
  if (ParserUtil.isCloseBracket(type)) {
    pm.popParser(true);
    return true;
  }
  if (this.mode == NAME) {
    if (token.next().isType(Tokens.EQUALS)) {
      this.key=token.value();
      pm.skip();
      return true;
    }
    this.mode=VALUE;
  }
  if (this.mode == VALUE) {
    this.mode=SEPERATOR;
    pm.pushTryParser(new ExpressionParser(this),token,true);
    return true;
  }
  if (this.mode == SEPERATOR) {
    if (type == Tokens.COMMA) {
      this.mode=NAME | VALUE;
      return true;
    }
  }
  return false;
}","@Override public boolean parse(ParserManager pm,IToken token) throws SyntaxError {
  int type=token.type();
  if (ParserUtil.isCloseBracket(type)) {
    pm.popParser(true);
    return true;
  }
  if (this.mode == NAME) {
    if (token.next().type() == Tokens.EQUALS) {
      this.key=token.value();
      pm.skip();
      return true;
    }
    this.mode=VALUE;
  }
  if (this.mode == VALUE) {
    this.mode=SEPERATOR;
    pm.pushTryParser(new ExpressionParser(this),token,true);
    return true;
  }
  if (this.mode == SEPERATOR) {
    if (type == Tokens.COMMA) {
      this.mode=NAME | VALUE;
      return true;
    }
  }
  return false;
}",0.9859375
85196,"public boolean parseKeyword(ParserManager pm,IToken token,int type) throws SyntaxError {
switch (type) {
case Tokens.WILDCARD:
    return true;
case Tokens.NULL:
  this.value=new NullValue(token.raw());
this.mode=ACCESS;
return true;
case Tokens.TRUE:
this.value=new BooleanValue(token.raw(),true);
this.mode=ACCESS;
return true;
case Tokens.FALSE:
this.value=new BooleanValue(token.raw(),false);
this.mode=ACCESS;
return true;
case Tokens.THIS:
this.value=new ThisValue(token.raw());
this.mode=ACCESS;
return true;
case Tokens.SUPER:
this.value=new SuperValue(token.raw());
this.mode=ACCESS;
return true;
case Tokens.NEW:
{
ConstructorCall call=new ConstructorCall(token);
this.mode=CONSTRUCTOR;
this.value=call;
pm.pushParser(new TypeParser(this));
return true;
}
case Tokens.RETURN:
{
ReturnStatement rs=new ReturnStatement(token.raw());
this.value=rs;
pm.pushParser(new ExpressionParser(rs));
return true;
}
case Tokens.IF:
{
IfStatement is=new IfStatement(token.raw());
this.value=is;
pm.pushParser(new IfStatementParser(is));
this.mode=0;
return true;
}
case Tokens.ELSE:
pm.popParser(true);
return true;
case Tokens.WHILE:
{
WhileStatement statement=new WhileStatement(token);
this.value=statement;
pm.pushParser(new WhileStatementParser(statement));
this.mode=0;
return true;
}
case Tokens.DO:
{
DoStatement statement=new DoStatement(token);
this.value=statement;
pm.pushParser(new DoStatementParser(statement));
this.mode=0;
return true;
}
case Tokens.FOR:
{
ForStatement statement=new ForStatement(token);
this.value=statement;
pm.pushParser(new ForStatementParser(statement));
this.mode=0;
return true;
}
case Tokens.BREAK:
{
BreakStatement statement=new BreakStatement(token);
this.value=statement;
IToken next=token.next();
if (next.isType(Tokens.TYPE_IDENTIFIER)) {
statement.setName(next.value());
pm.skip();
}
this.mode=0;
return true;
}
case Tokens.CONTINUE:
{
ContinueStatement statement=new ContinueStatement(token);
this.value=statement;
IToken next=token.next();
if (next.isType(Tokens.TYPE_IDENTIFIER)) {
statement.setName(next.value());
pm.skip();
}
this.mode=0;
return true;
}
case Tokens.GOTO:
{
GoToStatement statement=new GoToStatement(token);
this.value=statement;
IToken next=token.next();
if (next.isType(Tokens.TYPE_IDENTIFIER)) {
statement.setName(next.value());
pm.skip();
}
this.mode=0;
return true;
}
case Tokens.SWITCH:
return true;
case Tokens.CASE:
return true;
default :
return false;
}
}","public boolean parseKeyword(ParserManager pm,IToken token,int type) throws SyntaxError {
switch (type) {
case Tokens.WILDCARD:
    return true;
case Tokens.NULL:
  this.value=new NullValue(token.raw());
this.mode=ACCESS;
return true;
case Tokens.TRUE:
this.value=new BooleanValue(token.raw(),true);
this.mode=ACCESS;
return true;
case Tokens.FALSE:
this.value=new BooleanValue(token.raw(),false);
this.mode=ACCESS;
return true;
case Tokens.THIS:
this.value=new ThisValue(token.raw());
this.mode=ACCESS;
return true;
case Tokens.SUPER:
this.value=new SuperValue(token.raw());
this.mode=ACCESS;
return true;
case Tokens.NEW:
{
ConstructorCall call=new ConstructorCall(token);
this.mode=CONSTRUCTOR;
this.value=call;
pm.pushParser(new TypeParser(this));
return true;
}
case Tokens.RETURN:
{
ReturnStatement rs=new ReturnStatement(token.raw());
this.value=rs;
pm.pushParser(new ExpressionParser(rs));
return true;
}
case Tokens.IF:
{
IfStatement is=new IfStatement(token.raw());
this.value=is;
pm.pushParser(new IfStatementParser(is));
this.mode=0;
return true;
}
case Tokens.ELSE:
pm.popParser(true);
return true;
case Tokens.WHILE:
{
WhileStatement statement=new WhileStatement(token);
this.value=statement;
pm.pushParser(new WhileStatementParser(statement));
this.mode=0;
return true;
}
case Tokens.DO:
{
DoStatement statement=new DoStatement(token);
this.value=statement;
pm.pushParser(new DoStatementParser(statement));
this.mode=0;
return true;
}
case Tokens.FOR:
{
ForStatement statement=new ForStatement(token);
this.value=statement;
pm.pushParser(new ForStatementParser(statement));
this.mode=0;
return true;
}
case Tokens.BREAK:
{
BreakStatement statement=new BreakStatement(token);
this.value=statement;
IToken next=token.next();
if (ParserUtil.isIdentifier(next.type())) {
statement.setName(next.value());
pm.skip();
}
this.mode=0;
return true;
}
case Tokens.CONTINUE:
{
ContinueStatement statement=new ContinueStatement(token);
this.value=statement;
IToken next=token.next();
if (ParserUtil.isIdentifier(next.type())) {
statement.setName(next.value());
pm.skip();
}
this.mode=0;
return true;
}
case Tokens.GOTO:
{
GoToStatement statement=new GoToStatement(token);
this.value=statement;
IToken next=token.next();
if (ParserUtil.isIdentifier(next.type())) {
statement.setName(next.value());
pm.skip();
}
this.mode=0;
return true;
}
case Tokens.SWITCH:
return true;
case Tokens.CASE:
return true;
default :
return false;
}
}",0.9684990735021618
85197,"@Override public boolean parse(ParserManager pm,IToken token) throws SyntaxError {
  int type=token.type();
  if (this.mode == 0 || type == Tokens.SEMICOLON) {
    pm.popParser(true);
    return true;
  }
  if (this.isInMode(VALUE)) {
    if (type == Tokens.OPEN_PARENTHESIS) {
      this.mode=TUPLE_END;
      this.value=new TupleValue(token);
      if (!token.next().isType(Tokens.CLOSE_PARENTHESIS)) {
        pm.pushParser(new ExpressionListParser((IValueList)this.value));
      }
      return true;
    }
    if (type == Tokens.OPEN_SQUARE_BRACKET) {
      this.mode=ACCESS | VARIABLE | LAMBDA;
      pm.pushParser(new TypeParser(this),true);
      return true;
    }
    if (type == Tokens.OPEN_CURLY_BRACKET) {
      this.mode=LIST_END;
      this.value=new StatementList(token);
      if (!token.next().isType(Tokens.CLOSE_CURLY_BRACKET)) {
        pm.pushParser(new ExpressionListParser((IValueList)this.value));
      }
      return true;
    }
    if ((type & Tokens.TYPE_SYMBOL_ID) == Tokens.TYPE_SYMBOL_ID) {
      this.prefix=true;
      return this.getAccess(pm,token.value(),token,type);
    }
    if (type == Tokens.ARROW_OPERATOR) {
      this.mode=ACCESS | VARIABLE;
      pm.pushParser(new TypeParser(this),true);
      return true;
    }
    if (ParserUtil.isIdentifier(type)) {
      this.mode=ACCESS | VARIABLE | LAMBDA;
      pm.pushParser(new TypeParser(this),true);
      return true;
    }
    if (this.parsePrimitive(token,type)) {
      this.mode=ACCESS;
      return true;
    }
    if (this.parseKeyword(pm,token,type)) {
      return true;
    }
    this.mode=ACCESS;
  }
  if (this.isInMode(LIST_END)) {
    if (type == Tokens.CLOSE_CURLY_BRACKET) {
      this.value.expandPosition(token);
      if (token.next().equals(""String_Node_Str"")) {
        this.mode=ACCESS_2;
        this.dotless=false;
        pm.skip();
        return true;
      }
      pm.popParser();
      return true;
    }
    return false;
  }
  if (this.isInMode(TUPLE_END)) {
    if (type == Tokens.CLOSE_PARENTHESIS) {
      this.value.expandPosition(token);
      this.mode=ACCESS | VARIABLE | LAMBDA;
      return true;
    }
    return false;
  }
  if (this.isInMode(BYTECODE)) {
    if (type == Tokens.OPEN_CURLY_BRACKET) {
      Bytecode bc=new Bytecode(token);
      pm.pushParser(new BytecodeParser(bc));
      this.value=bc;
      this.mode=BYTECODE_END;
      return true;
    }
    return false;
  }
  if (this.isInMode(BYTECODE_END)) {
    if (type == Tokens.CLOSE_CURLY_BRACKET) {
      this.value.expandPosition(token);
      pm.popParser();
      return true;
    }
    return false;
  }
  if (this.isInMode(LAMBDA)) {
    if (type == Tokens.ARROW_OPERATOR) {
      LambdaValue lv=getLambdaValue(this.value);
      if (lv != null) {
        lv.expandPosition(token);
        this.value=lv;
        pm.popParser();
        pm.pushParser(new ExpressionParser(lv));
        return true;
      }
      if (this.value.getValueType() == IValue.TUPLE) {
        TupleType tt=getTupleType((TupleValue)this.value);
        if (tt != null) {
          LambdaType lt=new LambdaType(tt);
          pm.pushParser(new TypeParser(lt));
          this.value=new ClassAccess(null,lt);
          this.mode=VARIABLE;
          return true;
        }
      }
      return false;
    }
  }
  if (this.isInMode(VARIABLE)) {
    if (ParserUtil.isIdentifier(type) && token.next().isType(Tokens.EQUALS)) {
      ICodePosition pos=token.raw();
      IType itype;
      int i=this.value.getValueType();
      if (i == IValue.CLASS_ACCESS) {
        itype=((ClassAccess)this.value).type;
      }
 else       if (i == IValue.TUPLE) {
        itype=getTupleType((TupleValue)this.value);
      }
 else {
        return false;
      }
      String name=token.value();
      FieldInitializer access=new FieldInitializer(pos,name,itype);
      this.value=access;
      pm.skip();
      pm.pushParser(new ExpressionParser(access));
      return true;
    }
  }
  if (this.isInMode(ACCESS)) {
    if (type == Tokens.DOT) {
      this.mode=ACCESS_2;
      this.dotless=false;
      return true;
    }
    this.dotless=true;
    this.mode=ACCESS_2;
    if (type == Tokens.ELSE) {
      pm.popParser(true);
      return true;
    }
    if (type == Tokens.EQUALS) {
      return this.getAssign(pm);
    }
    if (type == Tokens.OPEN_PARENTHESIS) {
      IToken prev=token.prev();
      if (prev.isType(Tokens.TYPE_IDENTIFIER)) {
        this.value=new MethodCall(prev,null,prev.value());
        this.mode=PARAMETERS;
      }
 else {
        this.value=new ApplyMethodCall(this.value.getPosition(),this.value);
        this.mode=PARAMETERS;
      }
    }
  }
  if (this.isInMode(ACCESS_2)) {
    if (ParserUtil.isIdentifier(type)) {
      this.prefix=false;
      String name=token.value();
      if (this.precedence != 0 && this.dotless) {
        int p=Operators.index(name);
        if (p != 0 && this.precedence >= p) {
          pm.popParser(true);
          return true;
        }
      }
      return this.getAccess(pm,name,token,type);
    }
 else     if (ParserUtil.isTerminator(type)) {
      pm.popParser(true);
      return true;
    }
    IToken prev=token.prev();
    if (prev.isType(Tokens.TYPE_IDENTIFIER)) {
      this.value=null;
      pm.reparse();
      return this.getAccess(pm,prev.value(),prev,type);
    }
 else {
      ApplyMethodCall call=new ApplyMethodCall(token.raw(),this.value);
      this.value=call;
      this.mode=0;
      pm.pushParser(new ExpressionParser(this),true);
      return true;
    }
  }
  if (this.isInMode(CONSTRUCTOR)) {
    if (type == Tokens.OPEN_PARENTHESIS) {
      pm.pushParser(new ExpressionListParser((IValueList)this.value));
      this.mode=PARAMETERS_END;
      return true;
    }
    if (type == Tokens.OPEN_CURLY_BRACKET) {
      SpecialConstructor pc=new SpecialConstructor(token,(ConstructorCall)this.value);
      pm.pushParser(new ExpressionListParser(pc.list));
      this.value=pc;
      this.mode=LIST_END;
      return true;
    }
    pm.pushParser(new ExpressionParser(this),true);
    ((ConstructorCall)this.value).isSugarCall=true;
    this.mode=0;
    return true;
  }
  if (this.isInMode(PARAMETERS)) {
    if (type == Tokens.OPEN_PARENTHESIS) {
      pm.pushParser(new ExpressionListParser((IValueList)this.value));
      this.mode=PARAMETERS_END;
      return true;
    }
    return false;
  }
  if (this.isInMode(PARAMETERS_END)) {
    if (type == Tokens.CLOSE_PARENTHESIS) {
      this.value.expandPosition(token);
      this.mode=ACCESS;
      return true;
    }
    return false;
  }
  if (this.value != null) {
    this.value.expandPosition(token);
    pm.popParser(true);
    return true;
  }
  return false;
}","@Override public boolean parse(ParserManager pm,IToken token) throws SyntaxError {
  int type=token.type();
  if (this.mode == 0 || type == Tokens.SEMICOLON) {
    pm.popParser(true);
    return true;
  }
  if (this.isInMode(VALUE)) {
    if (type == Tokens.OPEN_PARENTHESIS) {
      this.mode=TUPLE_END;
      this.value=new TupleValue(token);
      int nextType=token.next().type();
      if (nextType != Tokens.CLOSE_PARENTHESIS) {
        pm.pushParser(new ExpressionListParser((IValueList)this.value));
      }
      return true;
    }
    if (type == Tokens.OPEN_SQUARE_BRACKET) {
      this.mode=ACCESS | VARIABLE | LAMBDA;
      pm.pushParser(new TypeParser(this),true);
      return true;
    }
    if (type == Tokens.OPEN_CURLY_BRACKET) {
      this.mode=LIST_END;
      this.value=new StatementList(token);
      int nextType=token.next().type();
      if (nextType != Tokens.CLOSE_CURLY_BRACKET) {
        pm.pushParser(new ExpressionListParser((IValueList)this.value));
      }
      return true;
    }
    if ((type & Tokens.TYPE_SYMBOL_ID) == Tokens.TYPE_SYMBOL_ID) {
      this.prefix=true;
      return this.getAccess(pm,token.value(),token,type);
    }
    if (type == Tokens.ARROW_OPERATOR) {
      this.mode=ACCESS | VARIABLE;
      pm.pushParser(new TypeParser(this),true);
      return true;
    }
    if (ParserUtil.isIdentifier(type)) {
      this.mode=ACCESS | VARIABLE | LAMBDA;
      pm.pushParser(new TypeParser(this),true);
      return true;
    }
    if (this.parsePrimitive(token,type)) {
      this.mode=ACCESS;
      return true;
    }
    if (this.parseKeyword(pm,token,type)) {
      return true;
    }
    this.mode=ACCESS;
  }
  if (this.isInMode(LIST_END)) {
    if (type == Tokens.CLOSE_CURLY_BRACKET) {
      this.value.expandPosition(token);
      if (token.next().equals(""String_Node_Str"")) {
        this.mode=ACCESS_2;
        this.dotless=false;
        pm.skip();
        return true;
      }
      pm.popParser();
      return true;
    }
    return false;
  }
  if (this.isInMode(TUPLE_END)) {
    if (type == Tokens.CLOSE_PARENTHESIS) {
      this.value.expandPosition(token);
      this.mode=ACCESS | VARIABLE | LAMBDA;
      return true;
    }
    return false;
  }
  if (this.isInMode(PARAMETERS)) {
    if (type == Tokens.OPEN_PARENTHESIS) {
      pm.pushParser(new ExpressionListParser((IValueList)this.value));
      this.mode=PARAMETERS_END;
      return true;
    }
    return false;
  }
  if (this.isInMode(PARAMETERS_END)) {
    if (type == Tokens.CLOSE_PARENTHESIS) {
      this.value.expandPosition(token);
      this.mode=ACCESS;
      return true;
    }
    return false;
  }
  if (this.isInMode(BYTECODE)) {
    if (type == Tokens.OPEN_CURLY_BRACKET) {
      Bytecode bc=new Bytecode(token);
      pm.pushParser(new BytecodeParser(bc));
      this.value=bc;
      this.mode=BYTECODE_END;
      return true;
    }
    return false;
  }
  if (this.isInMode(BYTECODE_END)) {
    if (type == Tokens.CLOSE_CURLY_BRACKET) {
      this.value.expandPosition(token);
      pm.popParser();
      return true;
    }
    return false;
  }
  if (ParserUtil.isCloseBracket(type)) {
    pm.popParser(true);
    return true;
  }
  if (this.isInMode(LAMBDA)) {
    if (type == Tokens.ARROW_OPERATOR) {
      LambdaValue lv=getLambdaValue(this.value);
      if (lv != null) {
        lv.expandPosition(token);
        this.value=lv;
        pm.popParser();
        pm.pushParser(new ExpressionParser(lv));
        return true;
      }
      if (this.value.getValueType() == IValue.TUPLE) {
        TupleType tt=getTupleType((TupleValue)this.value);
        if (tt != null) {
          LambdaType lt=new LambdaType(tt);
          pm.pushParser(new TypeParser(lt));
          this.value=new ClassAccess(null,lt);
          this.mode=VARIABLE;
          return true;
        }
      }
      return false;
    }
  }
  if (this.isInMode(VARIABLE)) {
    if (ParserUtil.isIdentifier(type) && token.next().type() == Tokens.EQUALS) {
      ICodePosition pos=token.raw();
      IType itype;
      int i=this.value.getValueType();
      if (i == IValue.CLASS_ACCESS) {
        itype=((ClassAccess)this.value).type;
      }
 else       if (i == IValue.TUPLE) {
        itype=getTupleType((TupleValue)this.value);
      }
 else {
        return false;
      }
      String name=token.value();
      FieldInitializer access=new FieldInitializer(pos,name,itype);
      this.value=access;
      pm.skip();
      pm.pushParser(new ExpressionParser(access));
      return true;
    }
  }
  if (this.isInMode(ACCESS)) {
    if (type == Tokens.DOT) {
      this.mode=ACCESS_2;
      this.dotless=false;
      return true;
    }
    this.dotless=true;
    this.mode=ACCESS_2;
    if (type == Tokens.ELSE) {
      pm.popParser(true);
      return true;
    }
    if (type == Tokens.EQUALS) {
      return this.getAssign(pm);
    }
    if (type == Tokens.OPEN_PARENTHESIS) {
      IToken prev=token.prev();
      if (ParserUtil.isIdentifier(prev.type())) {
        this.value=new MethodCall(prev,null,prev.value());
        this.mode=PARAMETERS;
      }
 else {
        this.value=new ApplyMethodCall(this.value.getPosition(),this.value);
        this.mode=PARAMETERS;
      }
    }
  }
  if (this.isInMode(ACCESS_2)) {
    if (ParserUtil.isIdentifier(type)) {
      this.prefix=false;
      String name=token.value();
      if (this.precedence != 0 && this.dotless) {
        int p=Operators.index(name);
        if (p != 0 && this.precedence >= p) {
          pm.popParser(true);
          return true;
        }
      }
      return this.getAccess(pm,name,token,type);
    }
 else     if (ParserUtil.isTerminator(type)) {
      pm.popParser(true);
      return true;
    }
    IToken prev=token.prev();
    if (ParserUtil.isIdentifier(prev.type())) {
      this.value=null;
      pm.reparse();
      return this.getAccess(pm,prev.value(),prev,type);
    }
 else {
      ApplyMethodCall call=new ApplyMethodCall(token.raw(),this.value);
      this.value=call;
      this.mode=0;
      pm.pushParser(new ExpressionParser(this),true);
      return true;
    }
  }
  if (this.isInMode(CONSTRUCTOR)) {
    if (type == Tokens.OPEN_PARENTHESIS) {
      pm.pushParser(new ExpressionListParser((IValueList)this.value));
      this.mode=PARAMETERS_END;
      return true;
    }
    if (type == Tokens.OPEN_CURLY_BRACKET) {
      SpecialConstructor pc=new SpecialConstructor(token,(ConstructorCall)this.value);
      pm.pushParser(new ExpressionListParser(pc.list));
      this.value=pc;
      this.mode=LIST_END;
      return true;
    }
    pm.pushParser(new ExpressionParser(this),true);
    ((ConstructorCall)this.value).isSugarCall=true;
    this.mode=0;
    return true;
  }
  if (this.value != null) {
    this.value.expandPosition(token);
    pm.popParser(true);
    return true;
  }
  return false;
}",0.8969041623463191
85198,"@Override public boolean parse(ParserManager pm,IToken token) throws SyntaxError {
  int type=token.type();
  if (type == Tokens.SEMICOLON) {
    pm.popParser();
    return true;
  }
  if (type == Tokens.COMMA) {
    pm.popParser(true);
    return true;
  }
  if (this.isInMode(IMPORT)) {
    if (type == Tokens.OPEN_CURLY_BRACKET) {
      MultiImport mi=new MultiImport(token,this.parent);
      this.container.addImport(mi);
      this.parent=mi;
      this.container=mi;
      if (!token.next().isType(Tokens.CLOSE_CURLY_BRACKET)) {
        pm.pushParser(new ImportListParser(mi,mi));
        this.mode=MULTIIMPORT;
        return true;
      }
      this.mode=0;
      pm.skip();
      return true;
    }
    if (type == Tokens.WILDCARD) {
      PackageImport pi=new PackageImport(token.raw(),this.parent);
      this.container.addImport(pi);
      this.mode=0;
      return true;
    }
    if (ParserUtil.isIdentifier(type)) {
      SimpleImport si=new SimpleImport(token.raw(),this.parent,token.value());
      this.container.addImport(si);
      this.parent=si;
      this.container=si;
      this.mode=DOT | ALIAS;
      return true;
    }
  }
  if (this.isInMode(DOT)) {
    if (type == Tokens.DOT) {
      this.mode=IMPORT;
      return true;
    }
  }
  if (this.isInMode(ALIAS)) {
    if (type == Tokens.ARROW_OPERATOR) {
      IToken next=token.next();
      if (next.isType(Tokens.TYPE_IDENTIFIER)) {
        ((SimpleImport)this.parent).setAlias(next.value());
        pm.skip();
        return true;
      }
 else {
        this.mode=DOT | IMPORT;
        throw new SyntaxError(next,""String_Node_Str"");
      }
    }
  }
  if (this.isInMode(MULTIIMPORT)) {
    if (type == Tokens.CLOSE_CURLY_BRACKET) {
      this.container.expandPosition(token);
      this.mode=0;
      return true;
    }
  }
  pm.popParser(true);
  return true;
}","@Override public boolean parse(ParserManager pm,IToken token) throws SyntaxError {
  int type=token.type();
  if (type == Tokens.SEMICOLON) {
    pm.popParser();
    return true;
  }
  if (type == Tokens.COMMA) {
    pm.popParser(true);
    return true;
  }
  if (this.isInMode(IMPORT)) {
    if (type == Tokens.OPEN_CURLY_BRACKET) {
      MultiImport mi=new MultiImport(token,this.parent);
      this.container.addImport(mi);
      this.parent=mi;
      this.container=mi;
      if (token.next().type() != Tokens.CLOSE_CURLY_BRACKET) {
        pm.pushParser(new ImportListParser(mi,mi));
        this.mode=MULTIIMPORT;
        return true;
      }
      this.mode=0;
      pm.skip();
      return true;
    }
    if (type == Tokens.WILDCARD) {
      PackageImport pi=new PackageImport(token.raw(),this.parent);
      this.container.addImport(pi);
      this.mode=0;
      return true;
    }
    if (ParserUtil.isIdentifier(type)) {
      SimpleImport si=new SimpleImport(token.raw(),this.parent,token.value());
      this.container.addImport(si);
      this.parent=si;
      this.container=si;
      this.mode=DOT | ALIAS;
      return true;
    }
  }
  if (this.isInMode(DOT)) {
    if (type == Tokens.DOT) {
      this.mode=IMPORT;
      return true;
    }
  }
  if (this.isInMode(ALIAS)) {
    if (type == Tokens.ARROW_OPERATOR) {
      IToken next=token.next();
      if (next.type() == Tokens.TYPE_IDENTIFIER) {
        ((SimpleImport)this.parent).setAlias(next.value());
        pm.skip();
        return true;
      }
      this.mode=DOT | IMPORT;
      throw new SyntaxError(next,""String_Node_Str"");
    }
  }
  if (this.isInMode(MULTIIMPORT)) {
    if (type == Tokens.CLOSE_CURLY_BRACKET) {
      this.container.expandPosition(token);
      this.mode=0;
      return true;
    }
  }
  pm.popParser(true);
  return true;
}",0.9801576515357434
85199,"@Override public void check(List<Marker> markers,IContext context){
  if (this.instance != null) {
    this.instance.check(markers,context);
  }
  for (  IValue v : this.arguments) {
    v.check(markers,context);
  }
  if (this.method != null) {
    if (this.method.hasTypeVariables()) {
      this.typeArguments=this.method.getTypeMap(this.instance,this.arguments,this.generics);
    }
    this.method.checkArguments(markers,this.instance,this.arguments,this.typeArguments);
    if (this.method.hasModifier(Modifiers.DEPRECATED)) {
      markers.add(Markers.create(this.position,""String_Node_Str"",this.name));
    }
    byte access=context.getAccessibility(this.method);
    if (access == IContext.STATIC) {
      markers.add(Markers.create(this.position,""String_Node_Str"",this.name));
    }
 else     if (access == IContext.SEALED) {
      markers.add(Markers.create(this.position,""String_Node_Str"",this.name));
    }
 else     if ((access & IContext.READ_ACCESS) == 0) {
      markers.add(Markers.create(this.position,""String_Node_Str"",this.name));
    }
  }
}","@Override public void check(List<Marker> markers,IContext context){
  if (this.instance != null) {
    this.instance.check(markers,context);
  }
  for (  IValue v : this.arguments) {
    v.check(markers,context);
  }
  if (this.method != null) {
    if (this.typeArguments == null && this.method.hasTypeVariables()) {
      this.typeArguments=this.method.getTypeMap(this.instance,this.arguments,this.generics);
    }
    this.method.checkArguments(markers,this.instance,this.arguments,this.typeArguments);
    if (this.method.hasModifier(Modifiers.DEPRECATED)) {
      markers.add(Markers.create(this.position,""String_Node_Str"",this.name));
    }
    byte access=context.getAccessibility(this.method);
    if (access == IContext.STATIC) {
      markers.add(Markers.create(this.position,""String_Node_Str"",this.name));
    }
 else     if (access == IContext.SEALED) {
      markers.add(Markers.create(this.position,""String_Node_Str"",this.name));
    }
 else     if ((access & IContext.READ_ACCESS) == 0) {
      markers.add(Markers.create(this.position,""String_Node_Str"",this.name));
    }
  }
}",0.9860853432282004
85200,"@Override public boolean isType(IType type){
  if (type == Type.NONE || type == Type.VOID) {
    return true;
  }
  if (this.method == null) {
    return false;
  }
  if (this.type == null) {
    this.type=this.typeArguments != null ? this.method.getType(this.typeArguments) : this.method.getType();
  }
  return Type.isSuperType(type,this.type);
}","@Override public boolean isType(IType type){
  if (type == Type.NONE || type == Type.VOID) {
    return true;
  }
  if (this.method == null) {
    return false;
  }
  return Type.isSuperType(type,this.getType());
}",0.6298932384341637
85201,"@Override public IType getType(){
  if (this.method == null) {
    return Type.NONE;
  }
  if (this.type == null) {
    this.type=this.typeArguments != null ? this.method.getType(this.typeArguments) : this.method.getType();
  }
  return this.type;
}","@Override public IType getType(){
  if (this.method == null) {
    return Type.NONE;
  }
  if (this.type == null) {
    if (this.method.hasTypeVariables()) {
      if (this.typeArguments == null) {
        this.typeArguments=this.method.getTypeMap(this.instance,this.arguments,this.generics);
      }
      return this.type=this.method.getType(this.typeArguments);
    }
    return this.type=this.method.getType();
  }
  return this.type;
}",0.6560232220609579
85202,"@Override public void check(List<Marker> markers,IContext context){
  if (this.annotations != null) {
    for (    Annotation a : this.annotations) {
      a.check(markers,context);
    }
  }
  this.value.check(markers,context);
  IValue value1=this.value.withType(this.type);
  if (value1 == null) {
    Marker marker=Markers.create(this.value.getPosition(),""String_Node_Str"",this.name);
    marker.addInfo(""String_Node_Str"" + this.type);
    marker.addInfo(""String_Node_Str"" + this.value.getType());
    markers.add(marker);
  }
 else {
    this.value=value1;
  }
}","@Override public void check(List<Marker> markers,IContext context){
  if (this.annotations != null) {
    for (    Annotation a : this.annotations) {
      a.check(markers,context);
    }
  }
  IValue value1=this.value.withType(this.type);
  if (value1 == null) {
    Marker marker=Markers.create(this.value.getPosition(),""String_Node_Str"",this.name);
    marker.addInfo(""String_Node_Str"" + this.type);
    marker.addInfo(""String_Node_Str"" + this.value.getType());
    markers.add(marker);
  }
 else {
    this.value=value1;
  }
  this.value.check(markers,context);
}",0.9347442680776014
85203,"@Override public Map<String,IType> getTypeMap(IValue instance,List<IValue> arguments,List<IType> typeArguments){
  Map<String,IType> map=new HashMap();
  if (typeArguments != null) {
    int len=Math.min(generics.size(),typeArguments.size());
    for (int i=0; i < len; i++) {
      ITypeVariable var=generics.get(i);
      IType type=typeArguments.get(i);
      map.put(var.getQualifiedName(),type);
    }
  }
  int len=arguments.size();
  int mods=this.modifiers & Modifiers.INFIX;
  if (instance != null && mods == Modifiers.INFIX) {
    instance.addGenerics(this.parameters.get(0).type,map);
    len--;
    for (int i=0; i < len; i++) {
      Parameter par=this.parameters.get(i + 1);
      IValue v=arguments.get(i);
      v.addGenerics(par.type,map);
    }
    return map;
  }
  if (instance == null && len == 1 && (this.modifiers & Modifiers.PREFIX) != 0) {
    arguments.get(0).addGenerics(this.parameters.get(0).type,map);
    return map;
  }
  if (instance != null) {
    instance.addGenerics(this.theClass.getThisType(),map);
  }
  for (int i=0; i < len; i++) {
    Parameter par=this.parameters.get(i);
    IValue v=arguments.get(i);
    v.addGenerics(par.type,map);
  }
  return map;
}","@Override public Map<String,IType> getTypeMap(IValue instance,List<IValue> arguments,List<IType> typeArguments){
  Map<String,IType> map=new HashMap();
  if (typeArguments != null) {
    int len=Math.min(generics.size(),typeArguments.size());
    for (int i=0; i < len; i++) {
      ITypeVariable var=generics.get(i);
      IType type=typeArguments.get(i);
      map.put(var.getQualifiedName(),type);
    }
  }
  int len=arguments.size();
  int mods=this.modifiers & Modifiers.INFIX;
  if (instance != null && mods == Modifiers.INFIX) {
    instance.addTypeVariables(this.parameters.get(0).type,map);
    len--;
    for (int i=0; i < len; i++) {
      Parameter par=this.parameters.get(i + 1);
      IValue v=arguments.get(i);
      v.addTypeVariables(par.type,map);
    }
    return map;
  }
  if (instance == null && len == 1 && (this.modifiers & Modifiers.PREFIX) != 0) {
    arguments.get(0).addTypeVariables(this.parameters.get(0).type,map);
    return map;
  }
  if (instance != null) {
    instance.addTypeVariables(this.theClass.getThisType(),map);
  }
  for (int i=0; i < len; i++) {
    Parameter par=this.parameters.get(i);
    IValue v=arguments.get(i);
    v.addTypeVariables(par.type,map);
  }
  return map;
}",0.8872366790582404
85204,"@Override public IType resolve(List<Marker> markers,IContext context){
  if (this.theClass != null) {
    return this;
  }
  IClass iclass;
  if (this.fullName != null) {
    iclass=Package.rootPackage.resolveClass(this.fullName);
  }
 else {
    iclass=context.resolveClass(this.qualifiedName);
  }
  if (iclass != null) {
    this.theClass=iclass;
    this.fullName=iclass.getFullName();
    if (iclass instanceof CaptureClass) {
      return new WildcardType(this.position,this.arrayDimensions,(CaptureClass)iclass);
    }
    if (markers == null || this.generics == null) {
      return this;
    }
    List<ITypeVariable> variables=iclass.getTypeVariables();
    int len=this.generics.size();
    if (variables == null) {
      if (len != 0) {
        markers.add(Markers.create(this.position,""String_Node_Str"",this.qualifiedName));
      }
      return this;
    }
    if (variables.size() != len) {
      markers.add(Markers.create(this.position,""String_Node_Str""));
      return this;
    }
    for (int i=0; i < len; i++) {
      IType t1=this.generics.get(i);
      IType t2=t1.resolve(markers,context);
      if (t1 != t2) {
        this.generics.set(i,t2);
      }
      ITypeVariable var=variables.get(i);
      if (!var.isSuperTypeOf(t2)) {
        Marker marker=Markers.create(t1.getPosition(),""String_Node_Str"",var.getQualifiedName());
        marker.addInfo(""String_Node_Str"" + t2);
        marker.addInfo(""String_Node_Str"" + var);
        markers.add(marker);
      }
    }
    return this;
  }
  if (markers != null) {
    markers.add(Markers.create(this.position,""String_Node_Str"",this.toString()));
  }
  return this;
}","@Override public IType resolve(List<Marker> markers,IContext context){
  if (this.theClass != null) {
    return this;
  }
  IClass iclass;
  if (this.fullName != null) {
    iclass=Package.rootPackage.resolveClass(this.fullName);
  }
 else {
    iclass=context.resolveClass(this.qualifiedName);
  }
  if (iclass != null) {
    this.theClass=iclass;
    this.fullName=iclass.getFullName();
    if (iclass instanceof CaptureClass) {
      return new WildcardType(this.position,this.arrayDimensions,(CaptureClass)iclass);
    }
    if (this.generics == null) {
      return this;
    }
    List<ITypeVariable> variables=iclass.getTypeVariables();
    int len=this.generics.size();
    if (variables == null) {
      if (len != 0 && markers != null) {
        markers.add(Markers.create(this.position,""String_Node_Str"",this.qualifiedName));
      }
      return this;
    }
    if (variables.size() != len && markers != null) {
      markers.add(Markers.create(this.position,""String_Node_Str""));
      return this;
    }
    for (int i=0; i < len; i++) {
      IType t1=this.generics.get(i);
      IType t2=t1.resolve(markers,context);
      if (t1 != t2) {
        this.generics.set(i,t2);
      }
      if (markers != null) {
        ITypeVariable var=variables.get(i);
        if (!var.isSuperTypeOf(t2)) {
          Marker marker=Markers.create(t1.getPosition(),""String_Node_Str"",var.getQualifiedName());
          marker.addInfo(""String_Node_Str"" + t2);
          marker.addInfo(""String_Node_Str"" + var);
          markers.add(marker);
        }
      }
    }
    return this;
  }
  if (markers != null) {
    markers.add(Markers.create(this.position,""String_Node_Str"",this.toString()));
  }
  return this;
}",0.955820895522388
85205,"@Override public void addTypeVariables(Map<String,IType> types){
  List<ITypeVariable> variables=this.theClass.getTypeVariables();
  if (variables != null) {
    int len=Math.min(this.generics.size(),variables.size());
    for (int i=0; i < len; i++) {
      ITypeVariable var=variables.get(i);
      IType type=this.generics.get(i);
      types.put(var.getQualifiedName(),type);
    }
  }
}","@Override public void addTypeVariables(IType type,Map<String,IType> typeVariables){
  if (type instanceof ITypeVariable) {
    if (type.isSuperTypeOf(this)) {
      if (this.arrayDimensions > 0) {
        typeVariables.put(type.getQualifiedName(),this.getArrayType(this.arrayDimensions - type.getArrayDimensions()));
      }
 else {
        typeVariables.put(type.getQualifiedName(),this);
      }
    }
  }
 else   if (type instanceof GenericType) {
    List<IType> types=((GenericType)type).generics;
    int len=Math.min(this.generics.size(),types.size());
    for (int i=0; i < len; i++) {
      IType t1=types.get(i);
      IType t2=this.generics.get(i);
      System.out.println(t1 + ""String_Node_Str"" + t2);
      t1.addTypeVariables(t2,typeVariables);
      t2.addTypeVariables(t1,typeVariables);
    }
  }
}",0.3463131731565865
85206,"public default void addTypeVariables(Map<String,IType> typeVariables){
}","public default void addTypeVariables(IType type,Map<String,IType> typeVariables){
}",0.9290322580645162
85207,"public static void findUnits(File source,File output,Package pack){
  if (!source.exists()) {
    logger.warning(source.getPath() + ""String_Node_Str"");
    return;
  }
 else   if (source.isDirectory()) {
    String name=source.getName();
    for (    String s : source.list()) {
      findUnits(new CodeFile(source,s),new File(output,s),pack.createSubPackage(name));
    }
    return;
  }
 else {
    String fileName=source.getPath();
    if (!config.compileFile(fileName)) {
      return;
    }
    if (fileName.endsWith(""String_Node_Str"") || fileName.endsWith(""String_Node_Str"")) {
      return;
    }
 else     if (fileName.endsWith(""String_Node_Str"")) {
      CompilationUnit unit=new CompilationUnit(pack,(CodeFile)source,output);
      output=unit.outputFile;
      pack.addCompilationUnit(unit);
      units.add(unit);
    }
    files.add(output);
  }
}","public static void findUnits(File source,File output,Package pack){
  if (source.isDirectory()) {
    String name=source.getName();
    for (    String s : source.list()) {
      findUnits(new CodeFile(source,s),new File(output,s),pack.createSubPackage(name));
    }
    return;
  }
  String fileName=source.getPath();
  if (!config.compileFile(fileName)) {
    return;
  }
  if (fileName.endsWith(""String_Node_Str"") || fileName.endsWith(""String_Node_Str"")) {
    return;
  }
 else   if (fileName.endsWith(""String_Node_Str"")) {
    CompilationUnit unit=new CompilationUnit(pack,(CodeFile)source,output);
    output=unit.outputFile;
    pack.addCompilationUnit(unit);
    units.add(unit);
  }
  files.add(output);
}",0.7509529860228716
85208,"@Override public int getSignatureMatch(String name,IValue instance,List<IValue> arguments){
  if (name == null) {
    return 1;
  }
  if (!name.equals(this.qualifiedName)) {
    return 0;
  }
  if (arguments == null) {
    return 1;
  }
  int pOff=0;
  int match=1;
  int len=arguments.size();
  List<Parameter> params=this.parameters;
  if (instance != null && (this.modifiers & Modifiers.INFIX) == Modifiers.INFIX) {
    if (len != params.size() - 1) {
      return 0;
    }
    IType t2=params.get(0).type;
    int m=instance.getTypeMatch(t2);
    if (m == 0) {
      return 0;
    }
    match+=m;
    pOff=1;
  }
 else   if ((this.modifiers & Modifiers.VARARGS) != 0) {
    int parCount=this.parameters.size() - 1;
    if (len <= parCount) {
      return 0;
    }
    Parameter varParam=params.get(parCount);
    for (int i=0; i < len; i++) {
      Parameter par=(i > parCount ? varParam : params.get(i + pOff));
      IType t1=par.type;
      IValue argument=arguments.get(i);
      int m=argument.getTypeMatch(t1);
      if (m != 0) {
        return match + m;
      }
      m=argument.getTypeMatch(t1.getElementType());
      if (m == 0) {
        return 0;
      }
      match+=m;
    }
    return match;
  }
 else   if (len != this.parameters.size()) {
    return 0;
  }
  for (int i=0; i < len; i++) {
    IType t1=params.get(i + pOff).type;
    IValue argument=arguments.get(i);
    int m=argument.getTypeMatch(t1);
    if (m == 0) {
      return 0;
    }
    match+=m;
  }
  return match;
}","@Override public int getSignatureMatch(String name,IValue instance,List<IValue> arguments){
  if (name == null) {
    return 1;
  }
  if (!name.equals(this.qualifiedName)) {
    return 0;
  }
  if (arguments == null) {
    return 1;
  }
  int pOff=0;
  int match=1;
  int len=arguments.size();
  List<Parameter> params=this.parameters;
  int mods=(this.modifiers & Modifiers.INFIX);
  if (instance != null && mods == Modifiers.INFIX) {
    if (len != params.size() - 1) {
      return 0;
    }
    IType t2=params.get(0).type;
    int m=instance.getTypeMatch(t2);
    if (m == 0) {
      return 0;
    }
    match+=m;
    pOff=1;
  }
 else   if (mods == Modifiers.STATIC && instance != null && instance.getValueType() != IValue.CLASS_ACCESS) {
    return 0;
  }
 else   if ((this.modifiers & Modifiers.VARARGS) != 0) {
    int parCount=this.parameters.size() - 1;
    if (len <= parCount) {
      return 0;
    }
    Parameter varParam=params.get(parCount);
    for (int i=0; i < len; i++) {
      Parameter par=(i > parCount ? varParam : params.get(i + pOff));
      IType t1=par.type;
      IValue argument=arguments.get(i);
      int m=argument.getTypeMatch(t1);
      if (m != 0) {
        return match + m;
      }
      m=argument.getTypeMatch(t1.getElementType());
      if (m == 0) {
        return 0;
      }
      match+=m;
    }
    return match;
  }
 else   if (len != this.parameters.size()) {
    return 0;
  }
  for (int i=0; i < len; i++) {
    IType t1=params.get(i + pOff).type;
    IValue argument=arguments.get(i);
    int m=argument.getTypeMatch(t1);
    if (m == 0) {
      return 0;
    }
    match+=m;
  }
  return match;
}",0.9393458240711337
85209,"public static IClass loadClass(BytecodeClass bclass,InputStream is,boolean decompile){
  try {
    jdk.internal.org.objectweb.asm.ClassReader reader=new jdk.internal.org.objectweb.asm.ClassReader(is);
    ClassReader visitor=new ClassReader(bclass);
    reader.accept(visitor,0);
    return bclass;
  }
 catch (  IOException ex) {
    ex.printStackTrace();
  }
  return null;
}","public static IClass loadClass(BytecodeClass bclass,InputStream is,boolean decompile){
  try {
    jdk.internal.org.objectweb.asm.ClassReader reader=new jdk.internal.org.objectweb.asm.ClassReader(is);
    ClassReader visitor=new ClassReader(bclass);
    reader.accept(visitor,0);
    return bclass;
  }
 catch (  IOException ex) {
    DyvilCompiler.logger.throwing(""String_Node_Str"",""String_Node_Str"",ex);
  }
  return null;
}",0.8966376089663761
85210,"public static void saveClass(File file,IClass iclass){
  createFile(file);
  try (OutputStream os=new BufferedOutputStream(new FileOutputStream(file))){
    jdk.internal.org.objectweb.asm.ClassWriter writer=new jdk.internal.org.objectweb.asm.ClassWriter(Opcodes.ASM5);
    iclass.write(writer);
    writer.visitEnd();
    byte[] bytes=writer.toByteArray();
    os.write(bytes,0,bytes.length);
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    DyvilCompiler.logger.throwing(""String_Node_Str"",""String_Node_Str"",ex);
  }
}","public static void saveClass(File file,IClass iclass){
  createFile(file);
  try (OutputStream os=new BufferedOutputStream(new FileOutputStream(file))){
    jdk.internal.org.objectweb.asm.ClassWriter writer=new jdk.internal.org.objectweb.asm.ClassWriter(Opcodes.ASM5);
    iclass.write(writer);
    writer.visitEnd();
    byte[] bytes=writer.toByteArray();
    os.write(bytes,0,bytes.length);
  }
 catch (  Exception ex) {
    DyvilCompiler.logger.throwing(""String_Node_Str"",""String_Node_Str"",ex);
  }
}",0.9748062015503876
85211,"public void load(){
  try {
    this.code=new String(Files.readAllBytes(this.toPath()));
  }
 catch (  IOException ex) {
    ex.printStackTrace();
  }
}","public void load(){
  try {
    this.code=new String(Files.readAllBytes(this.toPath()),StandardCharsets.UTF_8);
  }
 catch (  IOException ex) {
    DyvilCompiler.logger.throwing(""String_Node_Str"",""String_Node_Str"",ex);
  }
}",0.7180851063829787
85212,"protected void parseToken(Parser parser,IToken token) throws SyntaxError {
  boolean parsed;
  try {
    parsed=parser.parse(this,token);
  }
 catch (  SyntaxError error) {
    throw error;
  }
catch (  Exception ex) {
    String message=ex.getMessage();
    if (message == null) {
      message=ex.getClass().getName();
    }
    ex.printStackTrace();
    throw new SyntaxError(token,""String_Node_Str"" + token.getText() + ""String_Node_Str""+ message);
  }
  if (!parsed) {
    throw new SyntaxError(token,""String_Node_Str"" + token.getText() + ""String_Node_Str"");
  }
}","protected void parseToken(Parser parser,IToken token) throws SyntaxError {
  boolean parsed;
  try {
    parsed=parser.parse(this,token);
  }
 catch (  SyntaxError error) {
    throw error;
  }
catch (  Exception ex) {
    String message=ex.getMessage();
    if (message == null) {
      message=ex.getClass().getName();
    }
    DyvilCompiler.logger.throwing(""String_Node_Str"",""String_Node_Str"",ex);
    throw new SyntaxError(token,""String_Node_Str"" + token.getText() + ""String_Node_Str""+ message);
  }
  if (!parsed) {
    throw new SyntaxError(token,""String_Node_Str"" + token.getText() + ""String_Node_Str"");
  }
}",0.7223628691983123
85213,"public final void parse(CodeFile file,TokenIterator tokens){
  IToken token=null;
  this.tokens=tokens;
  this.file=file;
  try {
    IToken prev=null;
    while (tokens.hasNext()) {
      token=tokens.next();
      if (!this.retainToken((Token)token,prev)) {
        tokens.remove();
      }
      prev=token;
    }
    int index=0;
    tokens.reset();
    while (tokens.hasNext()) {
      token=tokens.next();
      token.setIndex(index);
      token.setPrev(prev);
      index++;
      prev=token;
    }
    tokens.reset();
    while (tokens.hasNext()) {
      token=this.currentToken=tokens.next();
      if (this.skip > 0) {
        this.skip--;
        continue;
      }
      Parser parser=this.currentParser;
      try {
        this.parseToken(parser,token);
      }
 catch (      SyntaxError ex) {
        if (this.jumpBackToken != null) {
          tokens.jump(this.jumpBackToken);
          this.popParser();
          this.jumpBackToken=null;
        }
 else {
          this.file.markers.add(ex);
        }
      }
      if (DyvilCompiler.parseStack) {
        System.out.println(token + ""String_Node_Str"" + parser.name+ ""String_Node_Str""+ parser.mode);
      }
    }
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
}","public final void parse(CodeFile file,TokenIterator tokens){
  IToken token=null;
  this.tokens=tokens;
  this.file=file;
  try {
    IToken prev=null;
    while (tokens.hasNext()) {
      token=tokens.next();
      if (!this.retainToken((Token)token,prev)) {
        tokens.remove();
      }
      prev=token;
    }
    int index=0;
    tokens.reset();
    while (tokens.hasNext()) {
      token=tokens.next();
      token.setIndex(index);
      token.setPrev(prev);
      index++;
      prev=token;
    }
    tokens.reset();
    while (tokens.hasNext()) {
      token=this.currentToken=tokens.next();
      if (this.skip > 0) {
        this.skip--;
        continue;
      }
      Parser parser=this.currentParser;
      try {
        this.parseToken(parser,token);
      }
 catch (      SyntaxError ex) {
        if (this.jumpBackToken != null) {
          tokens.jump(this.jumpBackToken);
          this.popParser();
          this.jumpBackToken=null;
        }
 else {
          this.file.markers.add(ex);
        }
      }
      if (DyvilCompiler.parseStack) {
        System.out.println(token + ""String_Node_Str"" + parser.name+ ""String_Node_Str""+ parser.mode);
      }
    }
  }
 catch (  Exception ex) {
    DyvilCompiler.logger.throwing(""String_Node_Str"",""String_Node_Str"",ex);
  }
}",0.967258382642998
85214,"@Override public void writeExpression(MethodWriter writer){
  this.method.writeCall(writer,this.instance,this.arguments);
  if (this.type != null && this.type != this.method.getType()) {
    writer.visitTypeInsn(Opcodes.CHECKCAST,this.type);
  }
}","@Override public void writeExpression(MethodWriter writer){
  this.method.writeCall(writer,this.instance,this.arguments);
  if (this.type != null) {
    IType methodType=this.method.getType();
    if (this.type != methodType && !Type.isSuperType(this.type,methodType)) {
      writer.visitTypeInsn(Opcodes.CHECKCAST,this.type);
    }
  }
}",0.7337883959044369
85215,"@Override public void resolveTypes(List<Marker> markers,IContext context){
  this.typesResolved=true;
  if (this.generics != null) {
    for (    ITypeVariable v : this.generics) {
      v.resolveTypes(markers,context);
    }
  }
  if (this.superType != null) {
    if (this.superType.isName(""String_Node_Str"")) {
      this.superType=null;
    }
 else {
      this.superType=this.superType.resolve(markers,context);
    }
  }
  for (ListIterator<IType> iterator=this.interfaces.listIterator(); iterator.hasNext(); ) {
    IType i1=iterator.next();
    IType i2=i1.resolve(markers,context);
    if (i1 != i2) {
      iterator.set(i2);
    }
  }
  if (this.annotations != null) {
    for (    Annotation a : this.annotations) {
      a.resolveTypes(markers,context);
    }
  }
  this.body.resolveTypes(markers,this);
  if (this.outerType != null) {
    this.outerClass=this.outerType.resolve(markers,context).getTheClass();
  }
  if (this.innerTypes != null) {
    for (    IType t : this.innerTypes) {
      IClass iclass=t.resolve(markers,context).getTheClass();
      this.body.addClass(iclass);
    }
    this.innerTypes=null;
  }
}","@Override public void resolveTypes(List<Marker> markers,IContext context){
  this.typesResolved=true;
  if (this.generics != null) {
    GenericType type=new GenericType(this);
    for (    ITypeVariable v : this.generics) {
      v.resolveTypes(markers,context);
      type.addType(new WildcardType(null,0,v.getCaptureClass()));
    }
    this.type=type;
  }
  if (this.superType != null) {
    if (this.superType.isName(""String_Node_Str"")) {
      this.superType=null;
    }
 else {
      this.superType=this.superType.resolve(markers,context);
    }
  }
  for (ListIterator<IType> iterator=this.interfaces.listIterator(); iterator.hasNext(); ) {
    IType i1=iterator.next();
    IType i2=i1.resolve(markers,context);
    if (i1 != i2) {
      iterator.set(i2);
    }
  }
  if (this.annotations != null) {
    for (    Annotation a : this.annotations) {
      a.resolveTypes(markers,context);
    }
  }
  this.body.resolveTypes(markers,this);
  if (this.outerType != null) {
    this.outerClass=this.outerType.resolve(markers,context).getTheClass();
  }
  if (this.innerTypes != null) {
    for (    IType t : this.innerTypes) {
      IClass iclass=t.resolve(markers,context).getTheClass();
      this.body.addClass(iclass);
    }
    this.innerTypes=null;
  }
}",0.9458333333333332
85216,"@Override public void resolveTypes(List<Marker> markers,IContext context){
  if (this.generics != null) {
    for (    ITypeVariable v : this.generics) {
      v.resolveTypes(markers,context);
    }
  }
  if (this.superType != null) {
    if (this.superType.isName(""String_Node_Str"")) {
      this.superType=null;
    }
 else {
      this.superType=this.superType.resolve(markers,context);
    }
  }
  for (ListIterator<IType> iterator=this.interfaces.listIterator(); iterator.hasNext(); ) {
    IType i1=iterator.next();
    IType i2=i1.resolve(markers,context);
    if (i1 != i2) {
      iterator.set(i2);
    }
  }
  if (this.annotations != null) {
    for (    Annotation a : this.annotations) {
      a.resolveTypes(markers,this);
    }
  }
  if (this.body != null) {
    this.body.resolveTypes(markers,this);
    for (    IMethod m : this.body.methods) {
      if (m.isName(""String_Node_Str"")) {
        return;
      }
    }
  }
  Method constructor=new Method(this);
  constructor.setName(""String_Node_Str"",""String_Node_Str"");
  constructor.setType(Type.VOID);
  constructor.setModifiers(Modifiers.PUBLIC | Modifiers.SYNTHETIC);
  this.constructor=constructor;
  if (this.superType != null) {
    MethodMatch match=this.superType.resolveConstructor(Util.EMPTY_VALUES);
    if (match != null) {
      this.superConstructor=match.theMethod;
    }
  }
}","@Override public void resolveTypes(List<Marker> markers,IContext context){
  if (this.generics != null) {
    GenericType type=new GenericType(this);
    for (    ITypeVariable v : this.generics) {
      v.resolveTypes(markers,context);
      type.addType(new WildcardType(null,0,v.getCaptureClass()));
    }
    this.type=type;
  }
  if (this.superType != null) {
    if (this.superType.isName(""String_Node_Str"")) {
      this.superType=null;
    }
 else {
      this.superType=this.superType.resolve(markers,context);
    }
  }
  for (ListIterator<IType> iterator=this.interfaces.listIterator(); iterator.hasNext(); ) {
    IType i1=iterator.next();
    IType i2=i1.resolve(markers,context);
    if (i1 != i2) {
      iterator.set(i2);
    }
  }
  if (this.annotations != null) {
    for (    Annotation a : this.annotations) {
      a.resolveTypes(markers,this);
    }
  }
  if (this.body != null) {
    this.body.resolveTypes(markers,this);
    for (    IMethod m : this.body.methods) {
      if (m.isName(""String_Node_Str"")) {
        return;
      }
    }
  }
  Method constructor=new Method(this);
  constructor.setName(""String_Node_Str"",""String_Node_Str"");
  constructor.setType(Type.VOID);
  constructor.setModifiers(Modifiers.PUBLIC | Modifiers.SYNTHETIC);
  this.constructor=constructor;
  if (this.superType != null) {
    MethodMatch match=this.superType.resolveConstructor(Util.EMPTY_VALUES);
    if (match != null) {
      this.superConstructor=match.theMethod;
    }
  }
}",0.954321855235418
85217,"@Override public Type getThisType(){
  return new Type(this);
}","@Override public Type getThisType(){
  return this.type;
}",0.8760330578512396
85218,public IClass getCaptureClass();,public CaptureClass getCaptureClass();,0.8857142857142857
85219,"@Override public IClass getCaptureClass(){
  return this.captureClass;
}","@Override public CaptureClass getCaptureClass(){
  return this.captureClass;
}",0.9466666666666668
85220,"@Override public IType getConcreteType(Map<String,IType> typeVariables){
  if (this.name != null) {
    IType t=typeVariables.get(this.name);
    if (t != null) {
      if (this.arrayDimensions > 0) {
        return t.getArrayType(this.arrayDimensions);
      }
      return t;
    }
  }
  return this;
}","@Override public IType getConcreteType(Map<String,IType> typeVariables){
  if (this.name != null) {
    IType t=typeVariables.get(this.name);
    if (t != null) {
      if (this.arrayDimensions > 0) {
        return t.getArrayType(this.arrayDimensions);
      }
      return t;
    }
  }
  WildcardType type=new WildcardType(this.position);
  if (this.lowerBound != null) {
    type.lowerBound=this.lowerBound.getConcreteType(typeVariables);
  }
  if (this.upperBound != null) {
    type.upperBound=this.upperBound.getConcreteType(typeVariables);
  }
  if (this.upperBounds != null) {
    int len=this.upperBounds.size();
    if (len > 0) {
      type.upperBounds=new ArrayList(len);
      for (int i=0; i < len; i++) {
        type.upperBounds.add(this.upperBounds.get(i).getConcreteType(typeVariables));
      }
    }
  }
  return type;
}",0.5087412587412588
85221,"@Override public void addTypeVariables(IType type,Map<String,IType> typeVariables){
  if (this.name != null && this.isSuperTypeOf(type)) {
    typeVariables.put(this.name,type);
  }
  if (this.upperBound != null) {
    this.upperBound.addTypeVariables(type,typeVariables);
  }
  for (  IType t : this.upperBounds) {
    t.addTypeVariables(type,typeVariables);
  }
}","@Override public void addTypeVariables(IType type,Map<String,IType> typeVariables){
  if (this.name != null) {
    typeVariables.put(this.name,type);
  }
  if (this.upperBound != null) {
    type.addTypeVariables(this.upperBound,typeVariables);
  }
  if (this.upperBounds != null) {
    for (    IType t : this.upperBounds) {
      type.addTypeVariables(t,typeVariables);
    }
  }
}",0.7620320855614974
85222,"@Override public String getInternalName(){
  return this.upperBound == null ? ""String_Node_Str"" : this.upperBound.getInternalName();
}","@Override public String getInternalName(){
  if (this.upperBound != null) {
    return this.upperBound.getInternalName();
  }
  if (this.upperBounds != null && !this.upperBounds.isEmpty()) {
    return this.upperBounds.get(0).getInternalName();
  }
  return ""String_Node_Str"";
}",0.3592233009708738
85223,"@Override public GenericType clone(){
  GenericType t=new GenericType();
  t.theClass=this.theClass;
  t.name=this.name;
  t.qualifiedName=this.qualifiedName;
  t.fullName=this.fullName;
  t.arrayDimensions=this.arrayDimensions;
  t.generics=new ArrayList(this.generics);
  return t;
}","@Override public GenericType clone(){
  GenericType t=new GenericType();
  t.theClass=this.theClass;
  t.name=this.name;
  t.qualifiedName=this.qualifiedName;
  t.fullName=this.fullName;
  t.arrayDimensions=this.arrayDimensions;
  if (this.generics != null) {
    t.generics=new ArrayList(this.generics);
  }
  return t;
}",0.9028006589785832
85224,"@Override public IType getConcreteType(Map<String,IType> typeVariables){
  IType t=super.getConcreteType(typeVariables);
  if (t != this) {
    return t;
  }
  GenericType copy=this.clone();
  int len=this.generics.size();
  for (int i=0; i < len; i++) {
    IType t1=this.generics.get(i);
    copy.generics.set(i,t1.getConcreteType(typeVariables));
  }
  return copy;
}","@Override public IType getConcreteType(Map<String,IType> typeVariables){
  IType t=super.getConcreteType(typeVariables);
  if (t != this) {
    return t;
  }
  GenericType copy=this.clone();
  if (this.generics != null) {
    int len=this.generics.size();
    for (int i=0; i < len; i++) {
      IType t1=this.generics.get(i);
      copy.generics.set(i,t1.getConcreteType(typeVariables));
    }
  }
  return copy;
}",0.9248407643312102
85225,"@Override public void addTypeVariables(IType type,Map<String,IType> typeVariables){
  if (type instanceof ITypeVariable) {
    if (type.isSuperTypeOf(this)) {
      if (this.arrayDimensions > 0) {
        typeVariables.put(type.getQualifiedName(),this.getArrayType(this.arrayDimensions - type.getArrayDimensions()));
      }
 else {
        typeVariables.put(type.getQualifiedName(),this);
      }
    }
  }
  if (this.generics != null) {
    if (type instanceof GenericType) {
      List<IType> types=((GenericType)type).generics;
      int len=Math.min(this.generics.size(),types.size());
      for (int i=0; i < len; i++) {
        IType t1=types.get(i);
        IType t2=this.generics.get(i);
        t1.addTypeVariables(t2,typeVariables);
        t2.addTypeVariables(t1,typeVariables);
      }
    }
    List<ITypeVariable> variables=this.theClass.getTypeVariables();
    if (variables != null) {
      int len=Math.min(this.generics.size(),variables.size());
      for (int i=0; i < len; i++) {
        ITypeVariable var=variables.get(i);
        IType type1=this.generics.get(i);
        typeVariables.put(var.getQualifiedName(),type);
      }
    }
  }
}","@Override public void addTypeVariables(IType type,Map<String,IType> typeVariables){
  if (this.generics != null) {
    if (type instanceof GenericType) {
      List<IType> types=((GenericType)type).generics;
      int len=Math.min(this.generics.size(),types.size());
      for (int i=0; i < len; i++) {
        IType t1=types.get(i);
        IType t2=this.generics.get(i);
        if (!t2.equals(t1) && !t1.equals(t2)) {
          return;
        }
        t2.addTypeVariables(t1,typeVariables);
      }
      return;
    }
  }
  if (type instanceof ITypeVariable) {
    type.addTypeVariables(this,typeVariables);
  }
}",0.2043795620437956
85226,"public boolean equals(IType type){
  if (this.arrayDimensions != type.getArrayDimensions()) {
    return false;
  }
  return this.classEquals(type);
}","@Override public boolean equals(IType type){
  if (this.arrayDimensions != type.getArrayDimensions()) {
    return false;
  }
  return this.theClass == type.getTheClass();
}",0.8792569659442725
85227,"public default void addTypeVariables(IType type,Map<String,IType> typeVariables){
  IType t=this.getType();
  type.addTypeVariables(t,typeVariables);
}","public default void addTypeVariables(IType type,Map<String,IType> typeVariables){
  IType t=this.getType();
  if (type.equals(t)) {
    type.addTypeVariables(t,typeVariables);
  }
}",0.9096385542168676
85228,"@Override public void check(List<Marker> markers,IContext context){
  if (this.value.getValueType() == IValue.THIS) {
    markers.add(new SyntaxError(this.position,""String_Node_Str""));
  }
  if (this.field == null) {
    return;
  }
  IType type=this.field.getType();
  IValue value1=this.value.withType(type);
  if (value1 == null) {
    Marker marker=Markers.create(this.value.getPosition(),""String_Node_Str"",this.name);
    marker.addInfo(""String_Node_Str"" + type);
    IType vtype=this.value.getType();
    marker.addInfo(""String_Node_Str"" + (vtype == null ? ""String_Node_Str"" : vtype));
    markers.add(marker);
  }
 else {
    this.value=value1;
  }
  if (this.field.hasModifier(Modifiers.FINAL)) {
    markers.add(Markers.create(this.position,""String_Node_Str"",this.name));
  }
  if (this.field.hasModifier(Modifiers.DEPRECATED)) {
    markers.add(Markers.create(this.position,""String_Node_Str"",this.name));
  }
  byte access=context.getAccessibility(this.field);
  if (access == IContext.STATIC) {
    markers.add(Markers.create(this.position,""String_Node_Str"",this.name));
  }
 else   if (access == IContext.SEALED) {
    markers.add(Markers.create(this.position,""String_Node_Str"",this.name));
  }
 else   if ((access & IContext.WRITE_ACCESS) == 0) {
    markers.add(Markers.create(this.position,""String_Node_Str"",this.name));
  }
}","@Override public void check(List<Marker> markers,IContext context){
  if (this.value.getValueType() == IValue.THIS) {
    markers.add(new SyntaxError(this.position,""String_Node_Str""));
  }
  if (this.field == null) {
    return;
  }
  IType type=this.field.getType();
  IValue value1=this.value.withType(type);
  if (value1 == null) {
    Marker marker=Markers.create(this.value.getPosition(),""String_Node_Str"",this.name);
    marker.addInfo(""String_Node_Str"" + type);
    IType vtype=this.value.getType();
    marker.addInfo(""String_Node_Str"" + (vtype == null ? ""String_Node_Str"" : vtype));
    markers.add(marker);
  }
 else {
    this.value=value1;
  }
  value1.check(markers,context);
  if (this.field.hasModifier(Modifiers.FINAL)) {
    markers.add(Markers.create(this.position,""String_Node_Str"",this.name));
  }
  if (this.field.hasModifier(Modifiers.DEPRECATED)) {
    markers.add(Markers.create(this.position,""String_Node_Str"",this.name));
  }
  byte access=context.getAccessibility(this.field);
  if (access == IContext.STATIC) {
    markers.add(Markers.create(this.position,""String_Node_Str"",this.name));
  }
 else   if (access == IContext.SEALED) {
    markers.add(Markers.create(this.position,""String_Node_Str"",this.name));
  }
 else   if ((access & IContext.WRITE_ACCESS) == 0) {
    markers.add(Markers.create(this.position,""String_Node_Str"",this.name));
  }
}",0.9878453038674032
85229,"@Override public IType getConcreteType(Map<String,IType> typeVariables){
  if (this.name != null) {
    IType t=typeVariables.get(this.name);
    if (t != null) {
      if (this.arrayDimensions > 0) {
        return t.getArrayType(this.arrayDimensions);
      }
      return t;
    }
  }
  WildcardType type=new WildcardType(this.position);
  if (this.lowerBound != null) {
    type.lowerBound=this.lowerBound.getConcreteType(typeVariables);
  }
  if (this.upperBound != null) {
    type.upperBound=this.upperBound.getConcreteType(typeVariables);
  }
  if (this.upperBounds != null) {
    int len=this.upperBounds.size();
    if (len > 0) {
      type.upperBounds=new ArrayList(len);
      for (int i=0; i < len; i++) {
        type.upperBounds.add(this.upperBounds.get(i).getConcreteType(typeVariables));
      }
    }
  }
  return type;
}","@Override public IType getConcreteType(Map<String,IType> typeVariables){
  if (this.name != null) {
    IType t=typeVariables.get(this.name);
    if (t != null) {
      if (this.arrayDimensions > 0) {
        return t.getArrayType(this.arrayDimensions);
      }
      return t;
    }
    return this;
  }
  WildcardType type=new WildcardType(this.position);
  if (this.lowerBound != null) {
    type.lowerBound=this.lowerBound.getConcreteType(typeVariables);
  }
  if (this.upperBound != null) {
    type.upperBound=this.upperBound.getConcreteType(typeVariables);
  }
  if (this.upperBounds != null) {
    int len=this.upperBounds.size();
    if (len > 0) {
      type.upperBounds=new ArrayList(len);
      for (int i=0; i < len; i++) {
        type.upperBounds.add(this.upperBounds.get(i).getConcreteType(typeVariables));
      }
    }
  }
  return type;
}",0.9899823217442546
85230,"private void writeInvoke(MethodWriter writer,IValue instance,List<IValue> arguments){
  int args=0;
  if (instance != null) {
    instance.writeExpression(writer);
    args=1;
  }
  for (  IValue arg : arguments) {
    arg.writeExpression(writer);
    args++;
  }
  int opcode;
  int modifiers=this.modifiers;
  if ((modifiers & Modifiers.STATIC) != 0) {
    opcode=Opcodes.INVOKESTATIC;
  }
 else   if (this.theClass.hasModifier(Modifiers.INTERFACE_CLASS) && (modifiers & Modifiers.ABSTRACT) != 0) {
    opcode=Opcodes.INVOKEINTERFACE;
  }
 else   if ((modifiers & Modifiers.PRIVATE) == Modifiers.PRIVATE) {
    opcode=Opcodes.INVOKESPECIAL;
  }
 else   if (instance != null && instance.getValueType() == IValue.SUPER) {
    opcode=Opcodes.INVOKESPECIAL;
  }
 else {
    opcode=Opcodes.INVOKEVIRTUAL;
  }
  String owner=this.theClass.getInternalName();
  String name=this.qualifiedName;
  String desc=this.getDescriptor();
  IType type=this.type;
  writer.visitMethodInsn(opcode,owner,name,desc,this.theClass.hasModifier(Modifiers.INTERFACE_CLASS),args,type);
}","private void writeInvoke(MethodWriter writer,IValue instance,List<IValue> arguments){
  int args=0;
  if (instance != null) {
    instance.writeExpression(writer);
    args=1;
  }
  for (  IValue arg : arguments) {
    arg.writeExpression(writer);
    args++;
  }
  int opcode;
  int modifiers=this.modifiers;
  if ((modifiers & Modifiers.STATIC) != 0) {
    opcode=Opcodes.INVOKESTATIC;
  }
 else   if (this.theClass.hasModifier(Modifiers.INTERFACE_CLASS) && this.value == null) {
    opcode=Opcodes.INVOKEINTERFACE;
  }
 else   if ((modifiers & Modifiers.PRIVATE) == Modifiers.PRIVATE) {
    opcode=Opcodes.INVOKESPECIAL;
  }
 else   if (instance != null && instance.getValueType() == IValue.SUPER) {
    opcode=Opcodes.INVOKESPECIAL;
  }
 else {
    opcode=Opcodes.INVOKEVIRTUAL;
  }
  String owner=this.theClass.getInternalName();
  String name=this.qualifiedName;
  String desc=this.getDescriptor();
  IType type=this.type;
  writer.visitMethodInsn(opcode,owner,name,desc,this.theClass.hasModifier(Modifiers.INTERFACE_CLASS),args,type);
}",0.973871733966746
85231,"@Override public Map<String,IType> getTypeMap(IValue instance,List<IValue> arguments,List<IType> typeArguments){
  Map<String,IType> map=new HashMap();
  if (typeArguments != null) {
    int len=Math.min(generics.size(),typeArguments.size());
    for (int i=0; i < len; i++) {
      ITypeVariable var=generics.get(i);
      IType type=typeArguments.get(i);
      map.put(var.getQualifiedName(),type);
    }
  }
  int len=arguments.size();
  int mods=this.modifiers & Modifiers.INFIX;
  if (instance != null && mods == Modifiers.INFIX) {
    instance.addTypeVariables(this.parameters.get(0).type,map);
    for (int i=0; i < len; i++) {
      Parameter par=this.parameters.get(i + 1);
      IValue v=arguments.get(i);
      v.addTypeVariables(par.type,map);
    }
    return map;
  }
  if (instance == null && len == 1 && (this.modifiers & Modifiers.PREFIX) != 0) {
    arguments.get(0).addTypeVariables(this.parameters.get(0).type,map);
    return map;
  }
  if (instance != null) {
    instance.addTypeVariables(this.theClass.getThisType(),map);
  }
  for (int i=0; i < len; i++) {
    Parameter par=this.parameters.get(i);
    IValue v=arguments.get(i);
    v.addTypeVariables(par.type,map);
  }
  return map;
}","@Override public Map<String,IType> getTypeMap(IValue instance,List<IValue> arguments,List<IType> typeArguments){
  Map<String,IType> map=new HashMap();
  if (typeArguments != null) {
    int len=Math.min(generics.size(),typeArguments.size());
    for (int i=0; i < len; i++) {
      ITypeVariable var=generics.get(i);
      IType type=typeArguments.get(i);
      map.put(var.getQualifiedName(),type);
    }
  }
  int len=arguments.size();
  int mods=this.modifiers & Modifiers.INFIX;
  if (instance != null && mods == Modifiers.INFIX) {
    instance.addTypeVariables(this.parameters.get(0).type,map);
    for (int i=0; i < len; i++) {
      Parameter par=this.parameters.get(i + 1);
      IValue v=arguments.get(i);
      v.addTypeVariables(par.type,map);
    }
    return map;
  }
  if (instance == null && len == 1 && (this.modifiers & Modifiers.PREFIX) != 0) {
    arguments.get(0).addTypeVariables(this.parameters.get(0).type,map);
    return map;
  }
  if (instance != null) {
    instance.addTypeVariables(this.theClass.getThisType(),map);
  }
  len=Math.min(this.parameters.size(),len);
  for (int i=0; i < len; i++) {
    Parameter par=this.parameters.get(i);
    IValue v=arguments.get(i);
    v.addTypeVariables(par.type,map);
  }
  return map;
}",0.9821717990275528
85232,"@Override public boolean parse(){
  ParserManager manager=new ParserManager(new CompilationUnitParser(this));
  manager.semicolonInference=true;
  manager.parse(this.inputFile,this.tokens);
  this.tokens=null;
  int size=this.markers.size();
  if (size > 0) {
    StringBuilder buffer=new StringBuilder(""String_Node_Str"");
    buffer.append(this.inputFile).append(""String_Node_Str"").append(size).append(""String_Node_Str"");
    boolean error=false;
    for (    Marker marker : this.markers) {
      marker.log(buffer);
    }
    DyvilCompiler.logger.info(buffer.toString());
    DyvilCompiler.logger.warning(this.name + ""String_Node_Str"");
    return false;
  }
  return true;
}","@Override public boolean parse(){
  ParserManager manager=new ParserManager(new CompilationUnitParser(this));
  manager.semicolonInference=true;
  manager.parse(this.inputFile,this.tokens);
  this.tokens=null;
  int size=this.markers.size();
  if (size > 0) {
    StringBuilder buffer=new StringBuilder(""String_Node_Str"");
    buffer.append(this.inputFile).append(""String_Node_Str"").append(size).append(""String_Node_Str"");
    boolean error=false;
    for (    Marker marker : this.markers) {
      marker.log(buffer);
    }
    DyvilCompiler.logger.info(buffer.toString());
    DyvilCompiler.logger.warning(this.name + ""String_Node_Str"");
    if (DyvilCompiler.states.contains(CompilerState.PRINT)) {
      DyvilCompiler.logger.info(""String_Node_Str"" + this.toString());
    }
    return false;
  }
  return true;
}",0.8714859437751004
85233,"public static void initLogger(){
  try {
    logger.setUseParentHandlers(false);
    Formatter formatter=new Formatter(){
      @Override public String format(      LogRecord record){
        String message=record.getMessage();
        if (message == null || message.isEmpty()) {
          return ""String_Node_Str"";
        }
        Throwable thrown=record.getThrown();
        StringBuilder builder=new StringBuilder();
        builder.append('[').append(format.format(new Date(record.getMillis()))).append(""String_Node_Str"");
        builder.append(record.getLevel()).append(""String_Node_Str"").append(message).append('\n');
        if (thrown != null) {
          thrown.printStackTrace(new AppendableOutputStream(builder));
        }
        return builder.toString();
      }
    }
;
    StreamHandler ch=new StreamHandler(System.out,formatter);
    logger.addHandler(ch);
    if (logFile) {
      String path=new File(""String_Node_Str"").getAbsolutePath();
      FileHandler fh=new FileHandler(path,true);
      fh.setFormatter(formatter);
      logger.addHandler(fh);
    }
  }
 catch (  Exception ex) {
  }
}","public static void initLogger(){
  try {
    logger.setUseParentHandlers(false);
    logger.setLevel(Level.ALL);
    Formatter formatter=new Formatter(){
      @Override public String format(      LogRecord record){
        String message=record.getMessage();
        if (message == null || message.isEmpty()) {
          return ""String_Node_Str"";
        }
        Throwable thrown=record.getThrown();
        StringBuilder builder=new StringBuilder();
        builder.append('[').append(format.format(new Date(record.getMillis()))).append(""String_Node_Str"");
        builder.append(record.getLevel()).append(""String_Node_Str"").append(message).append('\n');
        if (thrown != null) {
          thrown.printStackTrace(new AppendableOutputStream(builder));
        }
        return builder.toString();
      }
    }
;
    StreamHandler ch=new StreamHandler(System.out,formatter);
    ch.setLevel(Level.ALL);
    logger.addHandler(ch);
    if (logFile) {
      String path=new File(""String_Node_Str"").getAbsolutePath();
      FileHandler fh=new FileHandler(path,true);
      fh.setLevel(Level.ALL);
      fh.setFormatter(formatter);
      logger.addHandler(fh);
    }
  }
 catch (  Exception ex) {
  }
}",0.961206896551724
85234,"@Override public void check(List<Marker> markers,IContext context){
  this.value.check(markers,context);
  if (this.type == Type.VOID) {
    markers.add(Markers.create(this.position,""String_Node_Str""));
  }
  boolean primitiveType=this.type.isPrimitive();
  IType type=this.value.getType();
  if (primitiveType) {
    if (!type.isPrimitive()) {
      markers.add(Markers.create(this.position,""String_Node_Str""));
    }
  }
 else   if (type.isPrimitive()) {
    markers.add(Markers.create(this.position,""String_Node_Str""));
  }
 else   if (this.value.isType(this.type)) {
    markers.add(Markers.create(this.position,""String_Node_Str""));
  }
}","@Override public void check(List<Marker> markers,IContext context){
  this.value.check(markers,context);
  if (this.type == Type.VOID) {
    markers.add(Markers.create(this.position,""String_Node_Str""));
  }
  boolean primitiveType=this.type.isPrimitive();
  boolean primitiveValue=this.value.isPrimitive();
  if (primitiveType) {
    if (!primitiveValue) {
      markers.add(Markers.create(this.position,""String_Node_Str""));
    }
  }
 else   if (primitiveValue) {
    markers.add(Markers.create(this.position,""String_Node_Str""));
  }
 else   if (this.value.isType(this.type)) {
    markers.add(Markers.create(this.position,""String_Node_Str""));
  }
}",0.4334365325077399
85235,"@Override public void writeExpression(MethodWriter writer){
  this.value.writeExpression(writer);
  if (this.type.isPrimitive()) {
    OpcodeUtil.writePrimitiveCast((PrimitiveType)this.value.getType(),(PrimitiveType)this.type,writer);
  }
 else {
    writer.visitTypeInsn(Opcodes.CHECKCAST,this.type);
  }
}","@Override public void writeExpression(MethodWriter writer){
  this.value.writeExpression(writer);
  if (this.type.isPrimitive()) {
    OpcodeUtil.writePrimitiveCast(this.value.getType(),(PrimitiveType)this.type,writer);
  }
 else {
    writer.visitTypeInsn(Opcodes.CHECKCAST,this.type);
  }
}",0.9749582637729548
85236,"public static void jar(List<File> files,File output,Manifest manifest){
  String outputDir=DyvilCompiler.config.outputDir.getAbsolutePath();
  int len=outputDir.length();
  if (!outputDir.endsWith(""String_Node_Str"")) {
    len++;
  }
  try (JarOutputStream jos=new JarOutputStream(new FileOutputStream(output),manifest)){
    for (    File file : files) {
      String name=file.getAbsolutePath().substring(len);
      createEntry(file,jos,name);
    }
    jos.flush();
  }
 catch (  Exception ex) {
    DyvilCompiler.logger.throwing(""String_Node_Str"",""String_Node_Str"",ex);
  }
}","public static void jar(List<File> files,File output,Manifest manifest){
  String outputDir=DyvilCompiler.config.outputDir.getAbsolutePath();
  int len=outputDir.length();
  if (!outputDir.endsWith(""String_Node_Str"")) {
    len++;
  }
  try (JarOutputStream jos=new JarOutputStream(new FileOutputStream(output),manifest)){
    for (    File file : files) {
      if (file.exists()) {
        String name=file.getAbsolutePath().substring(len);
        createEntry(file,jos,name);
      }
    }
    jos.flush();
  }
 catch (  Exception ex) {
    DyvilCompiler.logger.throwing(""String_Node_Str"",""String_Node_Str"",ex);
  }
}",0.9674728940783986
85237,"public static int index(String name){
switch (name) {
case ""String_Node_Str"":
    return 10;
case ""String_Node_Str"":
  return 20;
case ""String_Node_Str"":
return 30;
case ""String_Node_Str"":
return 40;
case ""String_Node_Str"":
return 50;
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
return 60;
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
return 70;
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
return 80;
case ""String_Node_Str"":
case ""String_Node_Str"":
return 90;
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
return 100;
case ""String_Node_Str"":
case ""String_Node_Str"":
return 200;
}
return 0;
}","public static int index(String name){
switch (name) {
case ""String_Node_Str"":
    return 10;
case ""String_Node_Str"":
  return 20;
case ""String_Node_Str"":
return 30;
case ""String_Node_Str"":
return 40;
case ""String_Node_Str"":
return 50;
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
return 60;
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
return 70;
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
return 80;
case ""String_Node_Str"":
case ""String_Node_Str"":
return 90;
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
return 100;
case ""String_Node_Str"":
case ""String_Node_Str"":
return 110;
case ""String_Node_Str"":
case ""String_Node_Str"":
return 200;
}
if (name.charAt(name.length() - 1) == '=') {
return 5;
}
return 0;
}",0.9150159744408946
85238,"public static void writePrimitiveCast(PrimitiveType value,PrimitiveType cast,MethodWriter writer){
switch (value.typecode) {
case Opcodes.T_BYTE:
case Opcodes.T_SHORT:
case Opcodes.T_BOOLEAN:
case Opcodes.T_CHAR:
case Opcodes.T_INT:
    writeIntCast(cast,writer);
  break;
case Opcodes.T_LONG:
writeLongCast(cast,writer);
break;
case Opcodes.T_FLOAT:
writeFloatCast(cast,writer);
break;
case Opcodes.T_DOUBLE:
writeDoubleCast(cast,writer);
break;
}
}","public static void writePrimitiveCast(IType value,PrimitiveType cast,MethodWriter writer){
  IClass iclass=value.getTheClass();
  if (iclass == Type.BYTE_CLASS || iclass == Type.SHORT_CLASS || iclass == Type.CHAR_CLASS || iclass == Type.INT_CLASS) {
    writeIntCast(cast,writer);
    return;
  }
  if (iclass == Type.LONG_CLASS) {
    writeLongCast(cast,writer);
    return;
  }
  if (iclass == Type.FLOAT_CLASS) {
    writeFloatCast(cast,writer);
    return;
  }
  if (iclass == Type.DOUBLE_CLASS) {
    writeDoubleCast(cast,writer);
    return;
  }
}",0.4685942173479561
85239,"public static @infix @inline <K,V>void $plus$eq(Map<K,V> map,K key,V value){
  map.put(key,value);
}","public static @infix @inline <K,V>void $plus$eq(Map<K,V> map,Tuple2<K,V> tuple){
  map.put(tuple._1,tuple._2);
}",0.8301886792452831
85240,"@Override public void addTypeVariables(IType type,Map<String,IType> typeVariables){
  if (type instanceof ITypeVariable) {
    if (type.isSuperTypeOf(this)) {
      if (this.arrayDimensions > 0) {
        typeVariables.put(type.getQualifiedName(),this.getArrayType(this.arrayDimensions - type.getArrayDimensions()));
      }
 else {
        typeVariables.put(type.getQualifiedName(),this);
      }
    }
  }
 else   if (type instanceof GenericType) {
    List<IType> types=((GenericType)type).generics;
    int len=Math.min(this.generics.size(),types.size());
    for (int i=0; i < len; i++) {
      IType t1=types.get(i);
      IType t2=this.generics.get(i);
      System.out.println(t1 + ""String_Node_Str"" + t2);
      t1.addTypeVariables(t2,typeVariables);
      t2.addTypeVariables(t1,typeVariables);
    }
  }
}","@Override public void addTypeVariables(IType type,Map<String,IType> typeVariables){
  if (type instanceof ITypeVariable) {
    if (type.isSuperTypeOf(this)) {
      if (this.arrayDimensions > 0) {
        typeVariables.put(type.getQualifiedName(),this.getArrayType(this.arrayDimensions - type.getArrayDimensions()));
      }
 else {
        typeVariables.put(type.getQualifiedName(),this);
      }
    }
  }
  if (this.generics != null) {
    if (type instanceof GenericType) {
      List<IType> types=((GenericType)type).generics;
      int len=Math.min(this.generics.size(),types.size());
      for (int i=0; i < len; i++) {
        IType t1=types.get(i);
        IType t2=this.generics.get(i);
        t1.addTypeVariables(t2,typeVariables);
        t2.addTypeVariables(t1,typeVariables);
      }
    }
    List<ITypeVariable> variables=this.theClass.getTypeVariables();
    if (variables != null) {
      int len=Math.min(this.generics.size(),variables.size());
      for (int i=0; i < len; i++) {
        ITypeVariable var=variables.get(i);
        IType type1=this.generics.get(i);
        typeVariables.put(var.getQualifiedName(),type);
      }
    }
  }
}",0.7492416582406471
85241,"@Override public void writeExpression(MethodWriter writer){
  int i=this.instance.getValueType();
  if (i == FIELD_ACCESS) {
    FieldAccess access=(FieldAccess)this.instance;
    IField f=access.field;
    if (this.writeIINC(writer,f)) {
      return;
    }
    IValue instance=access.instance;
    if (instance != null) {
      instance.writeExpression(writer);
      writer.visitInsn(Opcodes.DUP);
    }
    f.writeGet(writer,null);
    this.method.writeCall(writer,null,this.arguments);
    writer.visitInsn(Opcodes.DUP);
    f.writeSet(writer,null,null);
  }
 else   if (i == APPLY_METHOD_CALL) {
    ApplyMethodCall call=(ApplyMethodCall)this.instance;
    call.instance.writeExpression(writer);
    for (    IValue v : call.arguments) {
      v.writeExpression(writer);
    }
    writer.visitInsn(Opcodes.DUP2);
    call.method.writeCall(writer,null,Util.EMPTY_VALUES);
    this.method.writeCall(writer,null,this.arguments);
    writer.visitInsn(Opcodes.DUP_X2);
    this.updateMethod.writeCall(writer,null,Util.EMPTY_VALUES);
  }
}","@Override public void writeExpression(MethodWriter writer){
  int i=this.instance.getValueType();
  if (i == FIELD_ACCESS) {
    FieldAccess access=(FieldAccess)this.instance;
    IField f=access.field;
    if (this.writeIINC(writer,f)) {
      f.writeGet(writer,null);
      return;
    }
    IValue instance=access.instance;
    if (instance != null) {
      instance.writeExpression(writer);
      writer.visitInsn(Opcodes.DUP);
    }
    f.writeGet(writer,null);
    this.method.writeCall(writer,null,this.arguments);
    writer.visitInsn(Opcodes.DUP);
    f.writeSet(writer,null,null);
  }
 else   if (i == APPLY_METHOD_CALL) {
    ApplyMethodCall call=(ApplyMethodCall)this.instance;
    call.instance.writeExpression(writer);
    for (    IValue v : call.arguments) {
      v.writeExpression(writer);
    }
    writer.visitInsn(Opcodes.DUP2);
    call.method.writeCall(writer,null,Util.EMPTY_VALUES);
    this.method.writeCall(writer,null,this.arguments);
    writer.visitInsn(Opcodes.DUP_X2);
    this.updateMethod.writeCall(writer,null,Util.EMPTY_VALUES);
  }
}",0.9853010905642484
85242,"public default IValue withType(IType type){
  IType type1=this.getType();
  if (type1 == null) {
    return null;
  }
  boolean primitive=type1.isPrimitive();
  if (primitive != type.isPrimitive()) {
    if (!Type.isSuperType(type,type1)) {
      return null;
    }
    if (primitive) {
      return type1.box(this);
    }
 else {
      return type.unbox(this);
    }
  }
  if (Type.isSuperType(type,type1)) {
    return this;
  }
  return null;
}","public default IValue withType(IType type){
  IType type1=this.getType();
  if (type1 == null) {
    return null;
  }
  boolean primitive=this.isPrimitive();
  if (primitive != type.isPrimitive()) {
    if (!Type.isSuperType(type,type1)) {
      return null;
    }
    if (primitive) {
      return type1.box(this);
    }
 else {
      return type.unbox(this);
    }
  }
  if (Type.isSuperType(type,type1)) {
    return this;
  }
  return null;
}",0.992161254199328
85243,"@Override public void writeStatement(MethodWriter writer){
  Variable var=this.variable;
  if (this.type == DEFAULT) {
    if (var != null) {
      writer.addLocal(var.index,var.type);
      var.value.writeExpression(writer);
      var.writeSet(writer);
    }
    writer.visitLabel(this.startLabel);
    if (this.condition != null) {
      this.condition.writeJump(writer,this.endLabel);
    }
    if (this.then != null) {
      this.then.writeStatement(writer);
    }
    writer.visitLabel2(this.updateLabel);
    if (this.update != null) {
      this.update.writeStatement(writer);
    }
    writer.visitJumpInsn(Opcodes.GOTO,this.startLabel);
    writer.visitLabel(this.endLabel);
    if (var != null) {
      writer.visitLocalVariable(var.qualifiedName,var.type.getExtendedName(),var.type.getSignature(),this.startLabel,this.endLabel,var.index);
      writer.removeLocals(1);
    }
    return;
  }
  if (this.type == ARRAY) {
    Variable arrayVar=this.arrayVar;
    Variable indexVar=this.indexVar;
    Variable lengthVar=this.lengthVar;
    Label scopeLabel=new Label();
    writer.visitLabel2(scopeLabel);
    writer.addLocal(var.index,MethodWriter.TOP);
    writer.addLocal(indexVar.index,MethodWriter.INT);
    writer.addLocal(lengthVar.index,MethodWriter.INT);
    writer.addLocal(arrayVar.index,arrayVar.type);
    var.value.writeExpression(writer);
    writer.visitInsn(Opcodes.DUP);
    arrayVar.writeSet(writer);
    writer.visitInsn(Opcodes.ARRAYLENGTH);
    lengthVar.writeSet(writer);
    writer.visitLdcInsn(0);
    indexVar.writeSet(writer);
    writer.visitJumpInsn(Opcodes.GOTO,this.updateLabel);
    writer.visitLabel(this.startLabel);
    arrayVar.writeGet(writer);
    indexVar.writeGet(writer);
    writer.visitInsn(arrayVar.type.getArrayLoadOpcode());
    var.writeSet(writer);
    this.then.writeStatement(writer);
    writer.visitIincInsn(indexVar.index,1);
    writer.visitLabel(this.updateLabel);
    indexVar.writeGet(writer);
    lengthVar.writeGet(writer);
    writer.visitJumpInsn2(Opcodes.IF_ICMPLT,this.startLabel);
    writer.removeLocals(4);
    writer.visitLabel(this.endLabel);
    writer.visitLocalVariable(var.qualifiedName,var.type.getExtendedName(),var.type.getSignature(),scopeLabel,this.endLabel,var.index);
    writer.visitLocalVariable(""String_Node_Str"",""String_Node_Str"",null,scopeLabel,this.endLabel,indexVar.index);
    writer.visitLocalVariable(""String_Node_Str"",""String_Node_Str"",null,scopeLabel,this.endLabel,lengthVar.index);
    writer.visitLocalVariable(""String_Node_Str"",arrayVar.type.getExtendedName(),arrayVar.type.getSignature(),scopeLabel,this.endLabel,arrayVar.index);
    return;
  }
}","@Override public void writeStatement(MethodWriter writer){
  Variable var=this.variable;
  if (this.type == DEFAULT) {
    if (var != null) {
      writer.addLocal(var.index,var.type);
      var.value.writeExpression(writer);
      var.writeSet(writer);
    }
    writer.visitLabel(this.startLabel);
    if (this.condition != null) {
      this.condition.writeJump(writer,this.endLabel);
    }
    if (this.then != null) {
      this.then.writeStatement(writer);
    }
    writer.visitLabel(this.updateLabel,false);
    if (this.update != null) {
      this.update.writeStatement(writer);
    }
    writer.visitJumpInsn(Opcodes.GOTO,this.startLabel);
    writer.removeLocals(1);
    writer.visitLabel(this.endLabel,this.parent == null || this.parent.canVisitStack(this));
    if (var != null) {
      writer.visitLocalVariable(var.qualifiedName,var.type.getExtendedName(),var.type.getSignature(),this.startLabel,this.endLabel,var.index);
    }
    return;
  }
  if (this.type == ARRAY) {
    Variable arrayVar=this.arrayVar;
    Variable indexVar=this.indexVar;
    Variable lengthVar=this.lengthVar;
    Label scopeLabel=new Label();
    writer.visitLabel(scopeLabel,false);
    writer.addLocal(var.index,MethodWriter.TOP);
    writer.addLocal(indexVar.index,MethodWriter.INT);
    writer.addLocal(lengthVar.index,MethodWriter.INT);
    writer.addLocal(arrayVar.index,arrayVar.type);
    var.value.writeExpression(writer);
    writer.visitInsn(Opcodes.DUP);
    arrayVar.writeSet(writer);
    writer.visitInsn(Opcodes.ARRAYLENGTH);
    lengthVar.writeSet(writer);
    writer.visitLdcInsn(0);
    indexVar.writeSet(writer);
    writer.visitJumpInsn(Opcodes.GOTO,this.updateLabel);
    writer.visitLabel(this.startLabel);
    arrayVar.writeGet(writer);
    indexVar.writeGet(writer);
    writer.visitInsn(arrayVar.type.getArrayLoadOpcode());
    var.writeSet(writer);
    this.then.writeStatement(writer);
    writer.visitIincInsn(indexVar.index,1);
    writer.visitLabel(this.updateLabel);
    indexVar.writeGet(writer);
    lengthVar.writeGet(writer);
    writer.visitJumpInsn2(Opcodes.IF_ICMPLT,this.startLabel);
    writer.removeLocals(4);
    writer.visitLabel(this.endLabel);
    writer.visitLocalVariable(var.qualifiedName,var.type.getExtendedName(),var.type.getSignature(),scopeLabel,this.endLabel,var.index);
    writer.visitLocalVariable(""String_Node_Str"",""String_Node_Str"",null,scopeLabel,this.endLabel,indexVar.index);
    writer.visitLocalVariable(""String_Node_Str"",""String_Node_Str"",null,scopeLabel,this.endLabel,lengthVar.index);
    writer.visitLocalVariable(""String_Node_Str"",arrayVar.type.getExtendedName(),arrayVar.type.getSignature(),scopeLabel,this.endLabel,arrayVar.index);
    return;
  }
}",0.9632531244170864
85244,"@Override public void writeStatement(MethodWriter writer){
  if (this.elseThen != null) {
    this.condition.writeJump(writer,this.elseStart);
    this.then.writeStatement(writer);
    writer.visitJumpInsn(Opcodes.GOTO,this.elseEnd);
    writer.visitLabel(this.elseStart);
    this.elseThen.writeStatement(writer);
    writer.visitLabel(this.elseEnd);
  }
 else {
    this.condition.writeJump(writer,this.elseStart);
    this.then.writeStatement(writer);
    writer.visitLabel(this.elseStart);
  }
}","@Override public void writeStatement(MethodWriter writer){
  if (this.elseThen != null) {
    this.condition.writeJump(writer,this.elseStart);
    this.then.writeStatement(writer);
    writer.visitJumpInsn(Opcodes.GOTO,this.elseEnd);
    writer.visitLabel(this.elseStart);
    this.elseThen.writeStatement(writer);
    writer.visitLabel(this.elseEnd,this.parent == null || this.parent.canVisitStack(this));
  }
 else {
    this.condition.writeJump(writer,this.elseStart);
    this.then.writeStatement(writer);
    writer.visitLabel(this.elseStart,this.parent == null || this.parent.canVisitStack(this));
  }
}",0.90072202166065
85245,"@Override public void writeExpression(MethodWriter writer){
  this.condition.writeJump(writer,this.elseStart);
  this.then.writeExpression(writer);
  writer.pop();
  writer.visitJumpInsn(Opcodes.GOTO,this.elseEnd);
  writer.visitLabel(this.elseStart);
  if (this.elseThen == null) {
    this.commonType.writeDefaultValue(writer);
  }
 else {
    this.elseThen.writeExpression(writer);
  }
  writer.visitLabel(this.elseEnd);
}","@Override public void writeExpression(MethodWriter writer){
  this.condition.writeJump(writer,this.elseStart);
  this.then.writeExpression(writer);
  writer.pop();
  writer.visitJumpInsn(Opcodes.GOTO,this.elseEnd);
  writer.visitLabel(this.elseStart);
  if (this.elseThen == null) {
    this.commonType.writeDefaultValue(writer);
  }
 else {
    this.elseThen.writeExpression(writer);
  }
  writer.visitLabel(this.elseEnd,this.parent == null || this.parent.canVisitStack(this));
}",0.9392265193370166
85246,"@Override public void writeStatement(MethodWriter writer){
  writer.visitLabel2(this.start);
  for (  Entry<String,Variable> entry : this.variables.entrySet()) {
    Variable var=entry.getValue();
    writer.addLocal(var.index,var.type);
  }
  String label;
  for (  IValue v : this.values) {
    if (this.valueLabels != null && (label=this.valueLabels.get(v)) != null) {
      writer.visitLabel(this.labels.get(label));
    }
    v.writeStatement(writer);
  }
  writer.visitLabel2(this.end);
  int count=0;
  for (  Entry<String,Variable> entry : this.variables.entrySet()) {
    Variable var=entry.getValue();
    writer.visitLocalVariable(var.qualifiedName,var.type.getExtendedName(),var.type.getSignature(),this.start,this.end,var.index);
    count++;
  }
  writer.removeLocals(count);
}","@Override public void writeStatement(MethodWriter writer){
  writer.visitLabel(this.start,false);
  int count=0;
  for (  Entry<String,Variable> entry : this.variables.entrySet()) {
    Variable var=entry.getValue();
    writer.addLocal(var.index,var.type);
    count++;
  }
  String label;
  for (  IValue v : this.values) {
    if (this.valueLabels != null && (label=this.valueLabels.get(v)) != null) {
      writer.visitLabel(this.labels.get(label));
    }
    v.writeStatement(writer);
  }
  writer.removeLocals(count);
  writer.visitLabel(this.end,count > 0 && (this.parent == null || this.parent.canVisitStack(this)));
  for (  Entry<String,Variable> entry : this.variables.entrySet()) {
    Variable var=entry.getValue();
    writer.visitLocalVariable(var.qualifiedName,var.type.getExtendedName(),var.type.getSignature(),this.start,this.end,var.index);
  }
}",0.8466183574879227
85247,"@Override public void writeStatement(MethodWriter writer){
  if (this.then == null) {
    this.condition.writeStatement(writer);
  }
  writer.visitLabel(this.start);
  this.condition.writeJump(writer,this.end);
  this.then.writeStatement(writer);
  writer.visitJumpInsn(Opcodes.GOTO,this.start);
  writer.visitLabel(this.end);
}","@Override public void writeStatement(MethodWriter writer){
  if (this.then == null) {
    this.condition.writeStatement(writer);
  }
  writer.visitLabel(this.start);
  this.condition.writeJump(writer,this.end);
  this.then.writeStatement(writer);
  writer.visitJumpInsn(Opcodes.GOTO,this.start);
  writer.visitLabel(this.end,this.parent == null || this.parent.canVisitStack(this));
}",0.9226441631504922
85248,"@Override public void resolveTypes(List<Marker> markers,IContext context){
  this.condition.resolveTypes(markers,context);
  if (this.then.isStatement()) {
    ((IStatement)this.then).setParent(this);
    this.then.resolveTypes(markers,context);
  }
 else   if (this.then != null) {
    this.then.resolveTypes(markers,context);
  }
}","@Override public void resolveTypes(List<Marker> markers,IContext context){
  this.condition.resolveTypes(markers,context);
  if (this.then != null) {
    if (this.then.isStatement()) {
      ((IStatement)this.then).setParent(this);
      this.then.resolveTypes(markers,context);
    }
 else {
      this.then.resolveTypes(markers,context);
    }
  }
}",0.9005847953216374
85249,"private void processInsn(int opcode){
switch (opcode) {
case DUP:
    this.push(this.stack[this.stackIndex]);
  return;
case SWAP:
{
  this.stackChanged=true;
  Object o=this.stack[this.stackIndex];
  this.stack[this.stackIndex]=this.stack[this.stackIndex - 1];
  this.stack[this.stackIndex - 1]=o;
  return;
}
case POP:
this.pop();
return;
case ACONST_NULL:
this.push(NULL);
return;
case ARRAYLENGTH:
this.set(INTEGER);
return;
case RETURN:
this.hasReturn=true;
return;
case BALOAD:
case SALOAD:
case CALOAD:
case IALOAD:
this.pop();
this.pop();
this.push(INTEGER);
break;
case LALOAD:
this.pop();
this.pop();
this.push(LONG);
break;
case FALOAD:
this.pop();
this.pop();
this.push(FLOAT);
break;
case DALOAD:
this.pop();
this.pop();
this.push(DOUBLE);
break;
case AALOAD:
this.pop();
this.pop();
this.push(TOP);
case IADD:
case ISUB:
case IMUL:
case IDIV:
case IREM:
case ISHL:
case ISHR:
case IUSHR:
this.pop();
this.pop();
this.push(INTEGER);
return;
case LADD:
case LSUB:
case LMUL:
case LDIV:
case LREM:
case LSHL:
case LSHR:
case LUSHR:
this.pop();
this.pop();
this.push(LONG);
return;
case FADD:
case FSUB:
case FMUL:
case FDIV:
case FREM:
this.pop();
this.pop();
this.push(FLOAT);
return;
case DADD:
case DSUB:
case DMUL:
case DDIV:
case DREM:
this.pop();
this.pop();
this.push(DOUBLE);
return;
case L2I:
case F2I:
case D2I:
this.set(INTEGER);
case I2L:
case F2L:
case D2L:
this.set(LONG);
return;
case I2F:
case L2F:
case D2F:
this.set(FLOAT);
return;
case LCMP:
case FCMPL:
case FCMPG:
case DCMPL:
case DCMPG:
this.pop();
this.pop();
this.push(INTEGER);
return;
}
}","private void processInsn(int opcode){
switch (opcode) {
case DUP:
    this.push(this.stack[this.stackIndex]);
  return;
case SWAP:
{
  Object o=this.stack[this.stackIndex];
  this.stack[this.stackIndex]=this.stack[this.stackIndex - 1];
  this.stack[this.stackIndex - 1]=o;
  return;
}
case POP:
this.pop();
return;
case ACONST_NULL:
this.push(NULL);
return;
case ARRAYLENGTH:
this.set(INTEGER);
return;
case RETURN:
this.hasReturn=true;
return;
case BALOAD:
case SALOAD:
case CALOAD:
case IALOAD:
this.pop();
this.pop();
this.push(INTEGER);
break;
case LALOAD:
this.pop();
this.pop();
this.push(LONG);
break;
case FALOAD:
this.pop();
this.pop();
this.push(FLOAT);
break;
case DALOAD:
this.pop();
this.pop();
this.push(DOUBLE);
break;
case AALOAD:
this.pop();
this.pop();
this.push(TOP);
case IADD:
case ISUB:
case IMUL:
case IDIV:
case IREM:
case ISHL:
case ISHR:
case IUSHR:
this.pop();
this.pop();
this.push(INTEGER);
return;
case LADD:
case LSUB:
case LMUL:
case LDIV:
case LREM:
case LSHL:
case LSHR:
case LUSHR:
this.pop();
this.pop();
this.push(LONG);
return;
case FADD:
case FSUB:
case FMUL:
case FDIV:
case FREM:
this.pop();
this.pop();
this.push(FLOAT);
return;
case DADD:
case DSUB:
case DMUL:
case DDIV:
case DREM:
this.pop();
this.pop();
this.push(DOUBLE);
return;
case L2I:
case F2I:
case D2I:
this.set(INTEGER);
case I2L:
case F2L:
case D2L:
this.set(LONG);
return;
case I2F:
case L2F:
case D2F:
this.set(FLOAT);
return;
case LCMP:
case FCMPL:
case FCMPG:
case DCMPL:
case DCMPG:
this.pop();
this.pop();
this.push(INTEGER);
return;
}
}",0.9916773367477592
85250,"@Override public void visitJumpInsn(int opcode,Label label){
  if (opcode >= IFEQ && opcode <= IFLE) {
    this.visitFrame();
    this.pop();
  }
  if (opcode >= IF_ICMPEQ && opcode <= IF_ICMPLE) {
    this.visitFrame();
    this.stackIndex-=2;
    this.stackCount-=2;
  }
  this.stackChanged=true;
  this.mv.visitJumpInsn(opcode,label);
}","@Override public void visitJumpInsn(int opcode,Label label){
  if (opcode >= IFEQ && opcode <= IFLE) {
    this.visitFrame();
    this.pop();
  }
  if (opcode >= IF_ICMPEQ && opcode <= IF_ICMPLE) {
    this.visitFrame();
    this.stackIndex-=2;
    this.stackCount-=2;
  }
  this.mv.visitJumpInsn(opcode,label);
}",0.9601226993865032
85251,"public void pop(){
  this.stackChanged=true;
  this.stackIndex--;
  this.stackCount--;
}","public void pop(){
  this.stackIndex--;
  this.stackCount--;
}",0.8266666666666667
85252,"@Override public void visitLabel(Label label){
  if (this.stackChanged) {
    this.visitFrame();
    this.stackChanged=false;
  }
  this.mv.visitLabel(label);
}","public void visitLabel(Label label,boolean stack){
  if (stack) {
    this.visitFrame();
  }
  this.mv.visitLabel(label);
}",0.7703180212014135
85253,"public void push(IType type){
  Object frameType=type.getFrameType();
  if (frameType != null) {
    this.ensureStack(this.stackIndex + 1);
    this.stackChanged=true;
    this.stack[this.stackIndex++]=type;
  }
}","public void push(IType type){
  Object frameType=type.getFrameType();
  if (frameType != null) {
    this.ensureStack(this.stackIndex + 1);
    this.stack[this.stackIndex++]=type;
  }
}",0.9296482412060302
85254,"@Override public void visitInsn(int opcode){
  if (opcode > 255) {
    this.visitSpecialInsn(opcode);
    return;
  }
 else   if (opcode >= IASTORE && opcode <= SASTORE) {
    this.stackIndex-=3;
    this.stackCount-=3;
    this.stackChanged=true;
  }
 else   if (opcode >= IRETURN && opcode <= ARETURN) {
    this.pop();
  }
 else {
    this.processInsn(opcode);
  }
  this.mv.visitInsn(opcode);
}","@Override public void visitInsn(int opcode){
  if (opcode > 255) {
    this.visitSpecialInsn(opcode);
    return;
  }
 else   if (opcode >= IASTORE && opcode <= SASTORE) {
    this.stackIndex-=3;
    this.stackCount-=3;
  }
 else   if (opcode >= IRETURN && opcode <= ARETURN) {
    this.pop();
  }
 else {
    this.processInsn(opcode);
  }
  this.mv.visitInsn(opcode);
}",0.9635416666666666
85255,"public void visitJumpInsn2(int opcode,Label label){
  if (opcode >= IFEQ && opcode <= IFLE) {
    this.pop();
  }
  if (opcode >= IF_ICMPEQ && opcode <= IF_ICMPLE) {
    this.stackIndex-=2;
    this.stackCount-=2;
  }
  this.stackChanged=true;
  this.mv.visitJumpInsn(opcode,label);
}","public void visitJumpInsn2(int opcode,Label label){
  if (opcode >= IFEQ && opcode <= IFLE) {
    this.pop();
  }
  if (opcode >= IF_ICMPEQ && opcode <= IF_ICMPLE) {
    this.stackIndex-=2;
    this.stackCount-=2;
  }
  this.mv.visitJumpInsn(opcode,label);
}",0.9520295202952028
85256,"@Override public void writeStatement(MethodWriter writer){
  int i=this.instance.getValueType();
  if (i == FIELD_ACCESS) {
    FieldAccess access=(FieldAccess)this.instance;
    IField f=access.field;
    if (this.writeIINC(writer,f)) {
      return;
    }
    IValue instance=access.instance;
    if (instance != null) {
      instance.writeExpression(writer);
      writer.visitInsn(Opcodes.DUP);
    }
    f.writeGet(writer);
    this.method.writeCall(writer,null,this.arguments);
    f.writeSet(writer);
  }
 else   if (i == APPLY_METHOD_CALL) {
    ApplyMethodCall call=(ApplyMethodCall)this.instance;
    call.instance.writeExpression(writer);
    writer.visitInsn(Opcodes.DUP);
    call.method.writeCall(writer,null,call.arguments);
    this.method.writeCall(writer,null,this.arguments);
    this.updateMethod.writeCall(writer,null,call.arguments);
  }
}","@Override public void writeStatement(MethodWriter writer){
  int i=this.instance.getValueType();
  if (i == FIELD_ACCESS) {
    FieldAccess access=(FieldAccess)this.instance;
    IField f=access.field;
    if (this.writeIINC(writer,f)) {
      return;
    }
    IValue instance=access.instance;
    if (instance != null) {
      instance.writeExpression(writer);
      writer.visitInsn(Opcodes.DUP);
    }
    f.writeGet(writer);
    this.method.writeCall(writer,null,this.arguments);
    f.writeSet(writer);
  }
 else   if (i == APPLY_METHOD_CALL) {
    ApplyMethodCall call=(ApplyMethodCall)this.instance;
    call.instance.writeExpression(writer);
    for (    IValue v : call.arguments) {
      v.writeExpression(writer);
    }
    writer.visitInsn(Opcodes.DUP2);
    call.method.writeCall(writer,null,Util.EMPTY_VALUES);
    this.method.writeCall(writer,null,this.arguments);
    this.updateMethod.writeCall(writer,null,Util.EMPTY_VALUES);
  }
}",0.8642384105960265
85257,"@Override public void writeExpression(MethodWriter writer){
  int i=this.instance.getValueType();
  if (i == FIELD_ACCESS) {
    FieldAccess access=(FieldAccess)this.instance;
    IField f=access.field;
    if (this.writeIINC(writer,f)) {
      return;
    }
    IValue instance=access.instance;
    if (instance != null) {
      instance.writeExpression(writer);
      writer.visitInsn(Opcodes.DUP);
    }
    f.writeGet(writer);
    this.method.writeCall(writer,null,this.arguments);
    writer.visitInsn(Opcodes.DUP);
    writer.visitInsn(Opcodes.SWAP);
    f.writeSet(writer);
  }
 else   if (i == APPLY_METHOD_CALL) {
    ApplyMethodCall call=(ApplyMethodCall)this.instance;
    call.writeExpression(writer);
    writer.visitInsn(Opcodes.DUP);
    this.method.writeCall(writer,null,this.arguments);
    this.updateMethod.writeCall(writer,call,call.arguments);
  }
}","@Override public void writeExpression(MethodWriter writer){
  int i=this.instance.getValueType();
  if (i == FIELD_ACCESS) {
    FieldAccess access=(FieldAccess)this.instance;
    IField f=access.field;
    if (this.writeIINC(writer,f)) {
      return;
    }
    IValue instance=access.instance;
    if (instance != null) {
      instance.writeExpression(writer);
      writer.visitInsn(Opcodes.DUP);
    }
    f.writeGet(writer);
    this.method.writeCall(writer,null,this.arguments);
    writer.visitInsn(Opcodes.DUP);
    f.writeSet(writer);
  }
 else   if (i == APPLY_METHOD_CALL) {
    ApplyMethodCall call=(ApplyMethodCall)this.instance;
    call.instance.writeExpression(writer);
    for (    IValue v : call.arguments) {
      v.writeExpression(writer);
    }
    writer.visitInsn(Opcodes.DUP2);
    call.method.writeCall(writer,null,Util.EMPTY_VALUES);
    this.method.writeCall(writer,null,this.arguments);
    writer.visitInsn(Opcodes.DUP_X2);
    this.updateMethod.writeCall(writer,null,Util.EMPTY_VALUES);
  }
}",0.8521647307286166
85258,"@Override public Package resolvePackage(String name){
  return null;
}","@Override public Package resolvePackage(String name){
  return this.unit.resolvePackage(name);
}",0.8192771084337349
85259,"@Override public void writeStatement(MethodWriter writer){
  writer.visitLabel(this.start,false);
  int count=0;
  for (  Entry<String,Variable> entry : this.variables.entrySet()) {
    Variable var=entry.getValue();
    writer.addLocal(var.index,var.type);
    count++;
  }
  String label;
  for (  IValue v : this.values) {
    if (this.valueLabels != null && (label=this.valueLabels.get(v)) != null) {
      writer.visitLabel(this.labels.get(label));
    }
    v.writeStatement(writer);
  }
  writer.removeLocals(count);
  writer.visitLabel(this.end,count > 0 && (this.parent == null || this.parent.canVisitStack(this)));
  for (  Entry<String,Variable> entry : this.variables.entrySet()) {
    Variable var=entry.getValue();
    writer.visitLocalVariable(var.qualifiedName,var.type.getExtendedName(),var.type.getSignature(),this.start,this.end,var.index);
  }
}","@Override public void writeStatement(MethodWriter writer){
  writer.visitLabel(this.start,false);
  int count=0;
  for (  Entry<String,Variable> entry : this.variables.entrySet()) {
    Variable var=entry.getValue();
    writer.addLocal(var.index,var.type);
    count++;
  }
  String label;
  for (  IValue v : this.values) {
    if (this.valueLabels != null && (label=this.valueLabels.get(v)) != null) {
      writer.visitLabel(this.labels.get(label));
    }
    v.writeStatement(writer);
  }
  if (this.parent != null || !(this.context instanceof IMethod)) {
    writer.removeLocals(count);
    writer.visitLabel(this.end,count > 0 && (this.parent == null || this.parent.canVisitStack(this)));
  }
 else   if (!writer.hasReturn) {
    writer.visitInsn(this.requiredType.getReturnOpcode());
  }
  for (  Entry<String,Variable> entry : this.variables.entrySet()) {
    Variable var=entry.getValue();
    writer.visitLocalVariable(var.qualifiedName,var.type.getExtendedName(),var.type.getSignature(),this.start,this.end,var.index);
  }
}",0.9100473435034192
85260,"public void tokenize(){
  this.tokens=DyvilCompiler.parser.tokenize(this.inputFile);
}","public void tokenize(){
  Dlex lexer=new Dlex(this.inputFile);
  lexer.tokenize();
  this.tokens=lexer.iterator();
}",0.5148514851485149
85261,"private void processInsn(int opcode){
switch (opcode) {
case DUP:
    this.push(this.stack[this.stackIndex]);
  return;
case SWAP:
{
  Object o=this.stack[this.stackIndex];
  this.stack[this.stackIndex]=this.stack[this.stackIndex - 1];
  this.stack[this.stackIndex - 1]=o;
  return;
}
case POP:
this.pop();
return;
case ACONST_NULL:
this.push(NULL);
return;
case ARRAYLENGTH:
this.set(INTEGER);
return;
case RETURN:
this.hasReturn=true;
return;
case BALOAD:
case SALOAD:
case CALOAD:
case IALOAD:
this.pop();
this.pop();
this.push(INTEGER);
break;
case LALOAD:
this.pop();
this.pop();
this.push(LONG);
break;
case FALOAD:
this.pop();
this.pop();
this.push(FLOAT);
break;
case DALOAD:
this.pop();
this.pop();
this.push(DOUBLE);
break;
case AALOAD:
this.pop();
this.pop();
this.push(TOP);
case IADD:
case ISUB:
case IMUL:
case IDIV:
case IREM:
case ISHL:
case ISHR:
case IUSHR:
this.pop();
this.pop();
this.push(INTEGER);
return;
case LADD:
case LSUB:
case LMUL:
case LDIV:
case LREM:
case LSHL:
case LSHR:
case LUSHR:
this.pop();
this.pop();
this.push(LONG);
return;
case FADD:
case FSUB:
case FMUL:
case FDIV:
case FREM:
this.pop();
this.pop();
this.push(FLOAT);
return;
case DADD:
case DSUB:
case DMUL:
case DDIV:
case DREM:
this.pop();
this.pop();
this.push(DOUBLE);
return;
case L2I:
case F2I:
case D2I:
this.set(INTEGER);
case I2L:
case F2L:
case D2L:
this.set(LONG);
return;
case I2F:
case L2F:
case D2F:
this.set(FLOAT);
return;
case LCMP:
case FCMPL:
case FCMPG:
case DCMPL:
case DCMPG:
this.pop();
this.pop();
this.push(INTEGER);
return;
}
}","private void processInsn(int opcode){
switch (opcode) {
case DUP:
{
      this.ensureStack(this.stackIndex + 2);
      this.stack[this.stackIndex + 1]=this.stack[this.stackIndex];
      this.stackIndex++;
      return;
    }
case DUP_X1:
{
    this.ensureStack(this.stackIndex + 2);
    this.stack[this.stackIndex + 1]=this.stack[this.stackIndex - 1];
    this.stackIndex++;
    return;
  }
case DUP_X2:
{
  this.ensureStack(this.stackIndex + 2);
  this.stack[this.stackIndex + 1]=this.stack[this.stackIndex - 2];
  this.stackIndex++;
  return;
}
case DUP2:
{
this.ensureStack(this.stackIndex + 3);
this.stack[this.stackIndex + 1]=this.stack[this.stackIndex - 1];
this.stack[this.stackIndex + 2]=this.stack[this.stackIndex];
this.stackIndex+=2;
return;
}
case DUP2_X1:
{
this.ensureStack(this.stackIndex + 3);
this.stack[this.stackIndex + 1]=this.stack[this.stackIndex - 2];
this.stack[this.stackIndex + 2]=this.stack[this.stackIndex - 1];
this.stackIndex+=2;
return;
}
case DUP2_X2:
{
this.ensureStack(this.stackIndex + 3);
this.stack[this.stackIndex + 1]=this.stack[this.stackIndex - 3];
this.stack[this.stackIndex + 2]=this.stack[this.stackIndex - 2];
this.stackIndex+=2;
return;
}
case SWAP:
{
Object o=this.stack[this.stackIndex];
this.stack[this.stackIndex]=this.stack[this.stackIndex - 1];
this.stack[this.stackIndex - 1]=o;
return;
}
case POP:
{
this.stackIndex--;
this.stackCount--;
return;
}
case POP2:
{
this.stackIndex-=2;
this.stackCount-=2;
}
case ACONST_NULL:
this.push(NULL);
return;
case ARRAYLENGTH:
this.set(INTEGER);
return;
case RETURN:
this.hasReturn=true;
return;
case BALOAD:
case SALOAD:
case CALOAD:
case IALOAD:
this.pop();
this.pop();
this.push(INTEGER);
break;
case LALOAD:
this.pop();
this.pop();
this.push(LONG);
break;
case FALOAD:
this.pop();
this.pop();
this.push(FLOAT);
break;
case DALOAD:
this.pop();
this.pop();
this.push(DOUBLE);
break;
case AALOAD:
this.pop();
this.pop();
this.push(TOP);
case IADD:
case ISUB:
case IMUL:
case IDIV:
case IREM:
case ISHL:
case ISHR:
case IUSHR:
this.pop();
this.pop();
this.push(INTEGER);
return;
case LADD:
case LSUB:
case LMUL:
case LDIV:
case LREM:
case LSHL:
case LSHR:
case LUSHR:
this.pop();
this.pop();
this.push(LONG);
return;
case FADD:
case FSUB:
case FMUL:
case FDIV:
case FREM:
this.pop();
this.pop();
this.push(FLOAT);
return;
case DADD:
case DSUB:
case DMUL:
case DDIV:
case DREM:
this.pop();
this.pop();
this.push(DOUBLE);
return;
case L2I:
case F2I:
case D2I:
this.set(INTEGER);
case I2L:
case F2L:
case D2L:
this.set(LONG);
return;
case I2F:
case L2F:
case D2F:
this.set(FLOAT);
return;
case LCMP:
case FCMPL:
case FCMPG:
case DCMPL:
case DCMPG:
this.pop();
this.pop();
this.push(INTEGER);
return;
}
}",0.7056603773584905
85262,"public void push(IType type){
  Object frameType=type.getFrameType();
  if (frameType != null) {
    this.ensureStack(this.stackIndex + 1);
    this.stack[this.stackIndex++]=type;
  }
}","public void push(IType type){
  Object frameType=type.getFrameType();
  if (frameType != null) {
    this.ensureStack(this.stackIndex + 1);
    this.stack[this.stackIndex++]=frameType;
  }
}",0.9813333333333332
85263,"public final void parse(CodeFile file,TokenIterator tokens){
  IToken token=null;
  this.tokens=tokens;
  try {
    IToken prev=null;
    while (tokens.hasNext()) {
      token=tokens.next();
      if (!this.retainToken((Token)token,prev)) {
        tokens.remove();
      }
      prev=token;
    }
    int index=0;
    tokens.reset();
    while (tokens.hasNext()) {
      token=tokens.next();
      token.setIndex(index);
      token.setPrev(prev);
      index++;
      prev=token;
    }
    tokens.reset();
    while (tokens.hasNext()) {
      token=this.currentToken=tokens.next();
      if (this.skip > 0) {
        this.skip--;
        continue;
      }
      Parser parser=this.currentParser;
      try {
        this.parseToken(parser,token);
      }
 catch (      SyntaxError ex) {
        if (this.jumpBackToken != null) {
          tokens.jump(this.jumpBackToken);
          this.popParser();
          this.jumpBackToken=null;
        }
 else {
          this.file.markers.add(ex);
        }
      }
      if (DyvilCompiler.parseStack) {
        System.out.println(token + ""String_Node_Str"" + parser.name+ ""String_Node_Str""+ parser.mode);
      }
    }
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
}","public final void parse(CodeFile file,TokenIterator tokens){
  IToken token=null;
  this.tokens=tokens;
  this.file=file;
  try {
    IToken prev=null;
    while (tokens.hasNext()) {
      token=tokens.next();
      if (!this.retainToken((Token)token,prev)) {
        tokens.remove();
      }
      prev=token;
    }
    int index=0;
    tokens.reset();
    while (tokens.hasNext()) {
      token=tokens.next();
      token.setIndex(index);
      token.setPrev(prev);
      index++;
      prev=token;
    }
    tokens.reset();
    while (tokens.hasNext()) {
      token=this.currentToken=tokens.next();
      if (this.skip > 0) {
        this.skip--;
        continue;
      }
      Parser parser=this.currentParser;
      try {
        this.parseToken(parser,token);
      }
 catch (      SyntaxError ex) {
        if (this.jumpBackToken != null) {
          tokens.jump(this.jumpBackToken);
          this.popParser();
          this.jumpBackToken=null;
        }
 else {
          this.file.markers.add(ex);
        }
      }
      if (DyvilCompiler.parseStack) {
        System.out.println(token + ""String_Node_Str"" + parser.name+ ""String_Node_Str""+ parser.mode);
      }
    }
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
}",0.992706645056726
85264,"public void resolveTypes(List<Marker> markers,IContext context){
  this.type=this.type.resolve(context);
  if (!this.type.isResolved()) {
    markers.add(Markers.create(this.position,""String_Node_Str"",this.name));
  }
  for (  Entry<String,IValue> entry : this.parameters.entrySet()) {
    entry.getValue().resolveTypes(markers,context);
  }
}","public void resolveTypes(List<Marker> markers,IContext context){
  this.type=this.type.resolve(context);
  if (!this.type.isResolved() && markers != null) {
    markers.add(Markers.create(this.position,""String_Node_Str"",this.name));
  }
  for (  Entry<String,IValue> entry : this.parameters.entrySet()) {
    entry.getValue().resolveTypes(markers,context);
  }
}",0.9730496453900708
85265,"@Override public IClass resolveClass(String name){
  if (!this.typesResolved) {
    this.resolveTypes(null,Package.rootPackage);
  }
  IClass clazz=this.body.getClass(name);
  if (clazz != null) {
    return clazz;
  }
  return null;
}","@Override public IClass resolveClass(String name){
  if (!this.typesResolved) {
    this.resolveTypes(null,Package.rootPackage);
  }
  if (this.generics != null) {
    for (    ITypeVariable var : this.generics) {
      if (var.isName(name)) {
        return var.getTheClass();
      }
    }
  }
  IClass clazz=this.body.getClass(name);
  if (clazz != null) {
    return clazz;
  }
  return null;
}",0.7424960505529226
85266,"@Override public void resolveTypes(List<Marker> markers,IContext context){
  this.typesResolved=true;
  if (this.superType != null) {
    if (this.superType.isName(""String_Node_Str"")) {
      this.superType=null;
    }
 else {
      this.superType=this.superType.resolve(context);
    }
  }
  for (ListIterator<IType> iterator=this.interfaces.listIterator(); iterator.hasNext(); ) {
    IType i1=iterator.next();
    IType i2=i1.resolve(context);
    if (i1 != i2) {
      iterator.set(i2);
    }
  }
  for (  Annotation a : this.annotations) {
    a.resolveTypes(markers,Package.rootPackage);
  }
  this.body.resolveTypes(markers,Package.rootPackage);
  if (this.outerType != null) {
    this.outerClass=this.outerType.resolve(context).getTheClass();
  }
  if (this.innerTypes != null) {
    for (    IType t : this.innerTypes) {
      IClass iclass=t.resolve(context).getTheClass();
      this.body.addClass(iclass);
    }
    this.innerTypes=null;
  }
}","@Override public void resolveTypes(List<Marker> markers,IContext context){
  this.typesResolved=true;
  if (this.generics != null) {
    for (    ITypeVariable v : this.generics) {
      v.resolveTypes(markers,context);
    }
  }
  if (this.superType != null) {
    if (this.superType.isName(""String_Node_Str"")) {
      this.superType=null;
    }
 else {
      this.superType=this.superType.resolve(context);
    }
  }
  for (ListIterator<IType> iterator=this.interfaces.listIterator(); iterator.hasNext(); ) {
    IType i1=iterator.next();
    IType i2=i1.resolve(context);
    if (i1 != i2) {
      iterator.set(i2);
    }
  }
  if (this.annotations != null) {
    for (    Annotation a : this.annotations) {
      a.resolveTypes(markers,context);
    }
  }
  this.body.resolveTypes(markers,this);
  if (this.outerType != null) {
    this.outerClass=this.outerType.resolve(context).getTheClass();
  }
  if (this.innerTypes != null) {
    for (    IType t : this.innerTypes) {
      IClass iclass=t.resolve(context).getTheClass();
      this.body.addClass(iclass);
    }
    this.innerTypes=null;
  }
}",0.8538125303545411
85267,"@Override public void resolve(List<Marker> markers,IContext context){
  for (Iterator<Annotation> iterator=this.annotations.iterator(); iterator.hasNext(); ) {
    Annotation a=iterator.next();
    if (this.processAnnotation(a)) {
      iterator.remove();
      continue;
    }
    a.resolve(markers,context);
  }
  if ((this.modifiers & Modifiers.OBJECT_CLASS) != 0) {
    this.instanceField=new Field(this,""String_Node_Str"",this.getType(),Modifiers.PUBLIC | Modifiers.CONST | Modifiers.SYNTHETIC,Collections.EMPTY_LIST);
  }
  if (this.body != null) {
    this.body.resolve(markers,this);
  }
}","@Override public void resolve(List<Marker> markers,IContext context){
  if (this.annotations != null) {
    Iterator<Annotation> iterator=this.annotations.iterator();
    while (iterator.hasNext()) {
      Annotation a=iterator.next();
      if (this.processAnnotation(a)) {
        iterator.remove();
        continue;
      }
      a.resolve(markers,context);
    }
  }
  if ((this.modifiers & Modifiers.OBJECT_CLASS) != 0) {
    this.instanceField=new Field(this,""String_Node_Str"",this.getType(),Modifiers.PUBLIC | Modifiers.CONST | Modifiers.SYNTHETIC,Collections.EMPTY_LIST);
  }
  if (this.body != null) {
    this.body.resolve(markers,this);
  }
}",0.7904
85268,"@Override public void write(ClassWriter writer){
  String internalName=this.getInternalName();
  String signature=this.getSignature();
  String superClass=null;
  int interfaceCount=this.interfaces.size();
  String[] interfaces=new String[interfaceCount];
  if (this.superType != null) {
    superClass=this.superType.getInternalName();
  }
  for (int i=0; i < interfaceCount; i++) {
    IType type=this.interfaces.get(i);
    interfaces[i]=type.getInternalName();
  }
  writer.visit(Opcodes.V1_8,this.modifiers & 0xFFFF,internalName,signature,superClass,interfaces);
  if (this.outerClass != null) {
    writer.visitOuterClass(this.outerClass.getInternalName(),null,null);
  }
  if ((this.modifiers & Modifiers.OBJECT_CLASS) != 0) {
    writer.visitAnnotation(""String_Node_Str"",true);
  }
  if ((this.modifiers & Modifiers.SEALED) != 0) {
    writer.visitAnnotation(""String_Node_Str"",false);
  }
  if ((this.modifiers & Modifiers.DEPRECATED) != 0) {
    writer.visitAnnotation(""String_Node_Str"",true);
  }
  if ((this.modifiers & Modifiers.FUNCTIONAL) != 0) {
    writer.visitAnnotation(""String_Node_Str"",true);
  }
  for (  Annotation a : this.annotations) {
    a.write(writer);
  }
  if (this.outerClass != null) {
    this.writeInnerClassInfo(writer);
  }
  if (this.superType != null) {
    IClass iclass=this.superType.getTheClass();
    if (iclass != null) {
      iclass.writeInnerClassInfo(writer);
    }
  }
  for (int i=0; i < interfaceCount; i++) {
    IType type=this.interfaces.get(i);
    IClass iclass=type.getTheClass();
    if (iclass != null) {
      iclass.writeInnerClassInfo(writer);
    }
  }
  List<IField> fields;
  List<IMethod> methods;
  List<IProperty> properties;
  if (this.body != null) {
    fields=this.body.fields;
    methods=this.body.methods;
    properties=this.body.properties;
    for (    IClass iclass : this.body.classes) {
      iclass.writeInnerClassInfo(writer);
    }
  }
 else {
    fields=Collections.EMPTY_LIST;
    methods=Collections.EMPTY_LIST;
    properties=Collections.EMPTY_LIST;
  }
  ThisValue thisValue=new ThisValue(null,this.type);
  IField instanceField=this.instanceField;
  StatementList instanceFields=new StatementList(null);
  StatementList staticFields=new StatementList(null);
  boolean hasConstructor=false;
  for (  IField f : fields) {
    f.write(writer);
    if (f.hasModifier(Modifiers.LAZY)) {
      continue;
    }
    if (f.hasModifier(Modifiers.STATIC)) {
      FieldAssign assign=new FieldAssign(null);
      assign.qualifiedName=f.getQualifiedName();
      assign.value=f.getValue();
      assign.field=f;
      staticFields.addValue(assign);
    }
 else {
      FieldAssign assign=new FieldAssign(null);
      assign.qualifiedName=f.getQualifiedName();
      assign.instance=thisValue;
      assign.value=f.getValue();
      assign.field=f;
      instanceFields.addValue(assign);
    }
  }
  if (this.superConstructor != null) {
    MethodCall call=new MethodCall(null);
    call.instance=new SuperValue(null,this.superType);
    call.method=this.superConstructor;
    call.name=""String_Node_Str"";
    call.qualifiedName=""String_Node_Str"";
    call.arguments=Util.EMPTY_VALUES;
    instanceFields.getValues().add(0,call);
  }
  if (this.constructor != null) {
    this.constructor.setValue(instanceFields);
    this.constructor.write(writer);
  }
  for (  IProperty p : properties) {
    p.write(writer);
  }
  for (  IMethod m : methods) {
    String name=m.getName();
    m.write(writer);
  }
  if ((this.modifiers & Modifiers.CASE_CLASS) != 0) {
    MethodWriter mw=new MethodWriter(writer,writer.visitMethod(Modifiers.PUBLIC | Modifiers.SYNTHETIC,""String_Node_Str"",""String_Node_Str"",null,null));
    mw.visitParameter(""String_Node_Str"",""String_Node_Str"",0);
    mw.addLocal(1,this.type);
    mw.visitCode();
    CaseClasses.writeEquals(mw,this,fields);
    mw.visitEnd();
    mw=new MethodWriter(writer,writer.visitMethod(Modifiers.PUBLIC | Modifiers.SYNTHETIC,""String_Node_Str"",""String_Node_Str"",null,null));
    mw.addLocal(0,this.type);
    mw.visitCode();
    CaseClasses.writeHashCode(mw,this,fields);
    mw.visitEnd();
    mw=new MethodWriter(writer,writer.visitMethod(Modifiers.PUBLIC | Modifiers.SYNTHETIC,""String_Node_Str"",""String_Node_Str"",null,null));
    mw.addLocal(0,this.type);
    mw.visitCode();
    CaseClasses.writeToString(mw,this,fields);
    mw.visitEnd();
  }
  if (instanceField != null) {
    instanceField.write(writer);
    FieldAssign assign=new FieldAssign(null);
    assign.name=assign.qualifiedName=""String_Node_Str"";
    assign.field=instanceField;
    ConstructorCall call=new ConstructorCall(null);
    call.type=this.type;
    call.method=this.constructor;
    assign.value=call;
    staticFields.addValue(assign);
  }
  if (!staticFields.isEmpty()) {
    Method m=new Method(this);
    m.setQualifiedName(""String_Node_Str"");
    m.setType(Type.VOID);
    m.setModifiers(Modifiers.STATIC | Modifiers.MANDATED);
    m.setValue(staticFields);
    m.write(writer);
  }
}","@Override public void write(ClassWriter writer){
  String internalName=this.getInternalName();
  String signature=this.getSignature();
  String superClass=null;
  int interfaceCount=this.interfaces.size();
  String[] interfaces=new String[interfaceCount];
  if (this.superType != null) {
    superClass=this.superType.getInternalName();
  }
  for (int i=0; i < interfaceCount; i++) {
    IType type=this.interfaces.get(i);
    interfaces[i]=type.getInternalName();
  }
  writer.visit(Opcodes.V1_8,this.modifiers & 0xFFFF,internalName,signature,superClass,interfaces);
  if (this.outerClass != null) {
    writer.visitOuterClass(this.outerClass.getInternalName(),null,null);
  }
  if ((this.modifiers & Modifiers.OBJECT_CLASS) != 0) {
    writer.visitAnnotation(""String_Node_Str"",true);
  }
  if ((this.modifiers & Modifiers.SEALED) != 0) {
    writer.visitAnnotation(""String_Node_Str"",false);
  }
  if ((this.modifiers & Modifiers.DEPRECATED) != 0) {
    writer.visitAnnotation(""String_Node_Str"",true);
  }
  if ((this.modifiers & Modifiers.FUNCTIONAL) != 0) {
    writer.visitAnnotation(""String_Node_Str"",true);
  }
  if (this.annotations != null) {
    for (    Annotation a : this.annotations) {
      a.write(writer);
    }
  }
  if (this.outerClass != null) {
    this.writeInnerClassInfo(writer);
  }
  if (this.superType != null) {
    IClass iclass=this.superType.getTheClass();
    if (iclass != null) {
      iclass.writeInnerClassInfo(writer);
    }
  }
  for (int i=0; i < interfaceCount; i++) {
    IType type=this.interfaces.get(i);
    IClass iclass=type.getTheClass();
    if (iclass != null) {
      iclass.writeInnerClassInfo(writer);
    }
  }
  List<IField> fields;
  List<IMethod> methods;
  List<IProperty> properties;
  if (this.body != null) {
    fields=this.body.fields;
    methods=this.body.methods;
    properties=this.body.properties;
    for (    IClass iclass : this.body.classes) {
      iclass.writeInnerClassInfo(writer);
    }
  }
 else {
    fields=Collections.EMPTY_LIST;
    methods=Collections.EMPTY_LIST;
    properties=Collections.EMPTY_LIST;
  }
  ThisValue thisValue=new ThisValue(null,this.type);
  IField instanceField=this.instanceField;
  StatementList instanceFields=new StatementList(null);
  StatementList staticFields=new StatementList(null);
  boolean hasConstructor=false;
  for (  IField f : fields) {
    f.write(writer);
    if (f.hasModifier(Modifiers.LAZY)) {
      continue;
    }
    if (f.hasModifier(Modifiers.STATIC)) {
      FieldAssign assign=new FieldAssign(null);
      assign.qualifiedName=f.getQualifiedName();
      assign.value=f.getValue();
      assign.field=f;
      staticFields.addValue(assign);
    }
 else {
      FieldAssign assign=new FieldAssign(null);
      assign.qualifiedName=f.getQualifiedName();
      assign.instance=thisValue;
      assign.value=f.getValue();
      assign.field=f;
      instanceFields.addValue(assign);
    }
  }
  if (this.superConstructor != null) {
    MethodCall call=new MethodCall(null);
    call.instance=new SuperValue(null,this.superType);
    call.method=this.superConstructor;
    call.name=""String_Node_Str"";
    call.qualifiedName=""String_Node_Str"";
    call.arguments=Util.EMPTY_VALUES;
    instanceFields.getValues().add(0,call);
  }
  if (this.constructor != null) {
    this.constructor.setValue(instanceFields);
    this.constructor.write(writer);
  }
  for (  IProperty p : properties) {
    p.write(writer);
  }
  for (  IMethod m : methods) {
    String name=m.getName();
    m.write(writer);
  }
  if ((this.modifiers & Modifiers.CASE_CLASS) != 0) {
    MethodWriter mw=new MethodWriter(writer,writer.visitMethod(Modifiers.PUBLIC | Modifiers.SYNTHETIC,""String_Node_Str"",""String_Node_Str"",null,null));
    mw.visitParameter(""String_Node_Str"",""String_Node_Str"",0);
    mw.addLocal(1,this.type);
    mw.visitCode();
    CaseClasses.writeEquals(mw,this,fields);
    mw.visitEnd();
    mw=new MethodWriter(writer,writer.visitMethod(Modifiers.PUBLIC | Modifiers.SYNTHETIC,""String_Node_Str"",""String_Node_Str"",null,null));
    mw.addLocal(0,this.type);
    mw.visitCode();
    CaseClasses.writeHashCode(mw,this,fields);
    mw.visitEnd();
    mw=new MethodWriter(writer,writer.visitMethod(Modifiers.PUBLIC | Modifiers.SYNTHETIC,""String_Node_Str"",""String_Node_Str"",null,null));
    mw.addLocal(0,this.type);
    mw.visitCode();
    CaseClasses.writeToString(mw,this,fields);
    mw.visitEnd();
  }
  if (instanceField != null) {
    instanceField.write(writer);
    FieldAssign assign=new FieldAssign(null);
    assign.name=assign.qualifiedName=""String_Node_Str"";
    assign.field=instanceField;
    ConstructorCall call=new ConstructorCall(null);
    call.type=this.type;
    call.method=this.constructor;
    assign.value=call;
    staticFields.addValue(assign);
  }
  if (!staticFields.isEmpty()) {
    Method m=new Method(this);
    m.setQualifiedName(""String_Node_Str"");
    m.setType(Type.VOID);
    m.setModifiers(Modifiers.STATIC | Modifiers.MANDATED);
    m.setValue(staticFields);
    m.write(writer);
  }
}",0.9912263210368892
85269,"@Override public void check(List<Marker> markers,IContext context){
  if (this.superType != null) {
    IClass superClass=this.superType.getTheClass();
    if (superClass != null) {
      int modifiers=superClass.getModifiers();
      if ((modifiers & Modifiers.CLASS_TYPE_MODIFIERS) != 0) {
        markers.add(Markers.create(this.superType.getPosition(),""String_Node_Str"",Modifiers.CLASS_TYPE.toString(modifiers),superClass.getName()));
      }
 else       if ((modifiers & Modifiers.FINAL) != 0) {
        markers.add(Markers.create(this.superType.getPosition(),""String_Node_Str"",superClass.getName()));
      }
 else       if ((modifiers & Modifiers.DEPRECATED) != 0) {
        markers.add(Markers.create(this.superType.getPosition(),""String_Node_Str"",superClass.getName()));
      }
    }
  }
  if ((this.modifiers & Modifiers.OBJECT_CLASS) != 0) {
    IMethod m=this.body.getMethod(""String_Node_Str"");
    if (m != null) {
      markers.add(Markers.create(m.getPosition(),""String_Node_Str"",this.name));
    }
  }
  for (  IType t : this.interfaces) {
    IClass iclass=t.getTheClass();
    if (iclass != null) {
      int modifiers=iclass.getModifiers();
      if ((modifiers & Modifiers.CLASS_TYPE_MODIFIERS) != Modifiers.INTERFACE_CLASS) {
        markers.add(Markers.create(t.getPosition(),""String_Node_Str"",Modifiers.CLASS_TYPE.toString(modifiers),iclass.getName()));
      }
 else       if ((modifiers & Modifiers.DEPRECATED) != 0) {
        markers.add(Markers.create(t.getPosition(),""String_Node_Str"",iclass.getName()));
      }
    }
  }
  for (  Annotation a : this.annotations) {
    a.check(markers,context);
  }
  if (this.body != null) {
    this.body.check(markers,this);
  }
}","@Override public void check(List<Marker> markers,IContext context){
  if (this.superType != null) {
    IClass superClass=this.superType.getTheClass();
    if (superClass != null) {
      int modifiers=superClass.getModifiers();
      if ((modifiers & Modifiers.CLASS_TYPE_MODIFIERS) != 0) {
        markers.add(Markers.create(this.superType.getPosition(),""String_Node_Str"",Modifiers.CLASS_TYPE.toString(modifiers),superClass.getName()));
      }
 else       if ((modifiers & Modifiers.FINAL) != 0) {
        markers.add(Markers.create(this.superType.getPosition(),""String_Node_Str"",superClass.getName()));
      }
 else       if ((modifiers & Modifiers.DEPRECATED) != 0) {
        markers.add(Markers.create(this.superType.getPosition(),""String_Node_Str"",superClass.getName()));
      }
    }
  }
  if ((this.modifiers & Modifiers.OBJECT_CLASS) != 0) {
    IMethod m=this.body.getMethod(""String_Node_Str"");
    if (m != null) {
      markers.add(Markers.create(m.getPosition(),""String_Node_Str"",this.name));
    }
  }
  for (  IType t : this.interfaces) {
    IClass iclass=t.getTheClass();
    if (iclass != null) {
      int modifiers=iclass.getModifiers();
      if ((modifiers & Modifiers.CLASS_TYPE_MODIFIERS) != Modifiers.INTERFACE_CLASS) {
        markers.add(Markers.create(t.getPosition(),""String_Node_Str"",Modifiers.CLASS_TYPE.toString(modifiers),iclass.getName()));
      }
 else       if ((modifiers & Modifiers.DEPRECATED) != 0) {
        markers.add(Markers.create(t.getPosition(),""String_Node_Str"",iclass.getName()));
      }
    }
  }
  if (this.annotations != null) {
    for (    Annotation a : this.annotations) {
      a.check(markers,context);
    }
  }
  if (this.body != null) {
    this.body.check(markers,this);
  }
}",0.933720930232558
85270,"@Override public void addAnnotation(Annotation annotation){
  if (!this.processAnnotation(annotation)) {
    annotation.target=ElementType.TYPE;
    this.annotations.add(annotation);
  }
}","@Override public void addAnnotation(Annotation annotation){
  if (!this.processAnnotation(annotation)) {
    annotation.target=ElementType.TYPE;
    if (this.annotations == null) {
      this.annotations=new ArrayList(2);
    }
    this.annotations.add(annotation);
  }
}",0.6840958605664488
85271,"@Override public Annotation getAnnotation(IType type){
  for (  Annotation a : this.annotations) {
    if (a.type.classEquals(type)) {
      return a;
    }
  }
  return null;
}","@Override public Annotation getAnnotation(IType type){
  if (this.annotations == null) {
    return null;
  }
  for (  Annotation a : this.annotations) {
    if (a.type.classEquals(type)) {
      return a;
    }
  }
  return null;
}",0.8655256723716381
85272,"@Override public void resolveTypes(List<Marker> markers,IContext context){
  if (this.superType != null) {
    if (this.superType.isName(""String_Node_Str"")) {
      this.superType=null;
    }
 else {
      this.superType=this.superType.resolve(context);
    }
  }
  for (ListIterator<IType> iterator=this.interfaces.listIterator(); iterator.hasNext(); ) {
    IType i1=iterator.next();
    IType i2=i1.resolve(context);
    if (i1 != i2) {
      iterator.set(i2);
    }
  }
  if (this.generics != null) {
    for (    ITypeVariable v : this.generics) {
      v.resolveTypes(markers,context);
    }
  }
  for (  Annotation a : this.annotations) {
    a.resolveTypes(markers,this);
  }
  if (this.body != null) {
    this.body.resolveTypes(markers,this);
    for (    IMethod m : this.body.methods) {
      if (m.isName(""String_Node_Str"")) {
        return;
      }
    }
  }
  Method constructor=new Method(this);
  constructor.setName(""String_Node_Str"",""String_Node_Str"");
  constructor.setType(Type.VOID);
  constructor.setModifiers(Modifiers.PUBLIC | Modifiers.SYNTHETIC);
  this.constructor=constructor;
  if (this.superType != null) {
    MethodMatch match=this.superType.resolveConstructor(Util.EMPTY_VALUES);
    if (match != null) {
      this.superConstructor=match.theMethod;
    }
  }
}","@Override public void resolveTypes(List<Marker> markers,IContext context){
  if (this.generics != null) {
    for (    ITypeVariable v : this.generics) {
      v.resolveTypes(markers,context);
    }
  }
  if (this.superType != null) {
    if (this.superType.isName(""String_Node_Str"")) {
      this.superType=null;
    }
 else {
      this.superType=this.superType.resolve(context);
    }
  }
  for (ListIterator<IType> iterator=this.interfaces.listIterator(); iterator.hasNext(); ) {
    IType i1=iterator.next();
    IType i2=i1.resolve(context);
    if (i1 != i2) {
      iterator.set(i2);
    }
  }
  if (this.annotations != null) {
    for (    Annotation a : this.annotations) {
      a.resolveTypes(markers,this);
    }
  }
  if (this.body != null) {
    this.body.resolveTypes(markers,this);
    for (    IMethod m : this.body.methods) {
      if (m.isName(""String_Node_Str"")) {
        return;
      }
    }
  }
  Method constructor=new Method(this);
  constructor.setName(""String_Node_Str"",""String_Node_Str"");
  constructor.setType(Type.VOID);
  constructor.setModifiers(Modifiers.PUBLIC | Modifiers.SYNTHETIC);
  this.constructor=constructor;
  if (this.superType != null) {
    MethodMatch match=this.superType.resolveConstructor(Util.EMPTY_VALUES);
    if (match != null) {
      this.superConstructor=match.theMethod;
    }
  }
}",0.8673237300985596
85273,"@Override public void foldConstants(){
  for (  Annotation a : this.annotations) {
    a.foldConstants();
  }
  if (this.body != null) {
    this.body.foldConstants();
  }
}","@Override public void foldConstants(){
  if (this.annotations != null) {
    for (    Annotation a : this.annotations) {
      a.foldConstants();
    }
  }
  if (this.body != null) {
    this.body.foldConstants();
  }
}",0.4540816326530612
85274,"@Override public void toString(String prefix,StringBuilder buffer){
  for (  Annotation annotation : this.annotations) {
    buffer.append(prefix);
    annotation.toString(prefix,buffer);
    buffer.append('\n');
  }
  buffer.append(prefix).append(Modifiers.CLASS.toString(this.modifiers));
  buffer.append(Modifiers.CLASS_TYPE.toString(this.modifiers)).append(this.name);
  if (this.generics != null && !this.generics.isEmpty()) {
    buffer.append('[');
    Util.astToString(this.generics,Formatting.Type.genericSeperator,buffer);
    buffer.append(']');
  }
  if (this.superType == null) {
    buffer.append(""String_Node_Str"");
  }
 else   if (this.superType != Type.OBJECT) {
    buffer.append(""String_Node_Str"");
    this.superType.toString(""String_Node_Str"",buffer);
  }
  if (!this.interfaces.isEmpty()) {
    buffer.append(""String_Node_Str"");
    Util.astToString(this.interfaces,Formatting.Class.superClassesSeperator,buffer);
  }
  if (this.body != null) {
    buffer.append('\n');
    this.body.toString(prefix,buffer);
  }
 else {
    buffer.append(';');
  }
}","@Override public void toString(String prefix,StringBuilder buffer){
  if (this.annotations != null) {
    for (    Annotation annotation : this.annotations) {
      buffer.append(prefix);
      annotation.toString(prefix,buffer);
      buffer.append('\n');
    }
  }
  buffer.append(prefix).append(Modifiers.CLASS.toString(this.modifiers));
  buffer.append(Modifiers.CLASS_TYPE.toString(this.modifiers)).append(this.name);
  if (this.generics != null && !this.generics.isEmpty()) {
    buffer.append('[');
    Util.astToString(this.generics,Formatting.Type.genericSeperator,buffer);
    buffer.append(']');
  }
  if (this.superType == null) {
    buffer.append(""String_Node_Str"");
  }
 else   if (this.superType != Type.OBJECT) {
    buffer.append(""String_Node_Str"");
    this.superType.toString(""String_Node_Str"",buffer);
  }
  if (!this.interfaces.isEmpty()) {
    buffer.append(""String_Node_Str"");
    Util.astToString(this.interfaces,Formatting.Class.superClassesSeperator,buffer);
  }
  if (this.body != null) {
    buffer.append('\n');
    this.body.toString(prefix,buffer);
  }
 else {
    buffer.append(';');
  }
}",0.9726526891522334
85275,"@Override public void addAnnotation(Annotation annotation){
  if (!this.processAnnotation(annotation)) {
    annotation.target=ElementType.FIELD;
    this.annotations.add(annotation);
  }
}","@Override public void addAnnotation(Annotation annotation){
  if (!this.processAnnotation(annotation)) {
    annotation.target=ElementType.FIELD;
    if (this.annotations == null) {
      this.annotations=new ArrayList(2);
    }
    this.annotations.add(annotation);
  }
}",0.6854663774403471
85276,"@Override public void resolveTypes(List<Marker> markers,IContext context){
  for (  Annotation a : this.annotations) {
    a.resolveTypes(markers,context);
  }
  this.type=this.type.resolve(context);
  if (!this.type.isResolved()) {
    markers.add(Markers.create(this.type.getPosition(),""String_Node_Str"",this.type.toString()));
  }
  if (this.value != null) {
    this.value.resolveTypes(markers,context);
  }
}","@Override public void resolveTypes(List<Marker> markers,IContext context){
  this.type=this.type.resolve(context);
  if (!this.type.isResolved()) {
    markers.add(Markers.create(this.type.getPosition(),""String_Node_Str"",this.type.toString()));
  }
  if (this.annotations != null) {
    for (    Annotation a : this.annotations) {
      a.resolveTypes(markers,context);
    }
  }
  if (this.value != null) {
    this.value.resolveTypes(markers,context);
  }
}",0.7408256880733946
85277,"@Override public void write(ClassWriter writer){
  if ((this.modifiers & Modifiers.LAZY) == Modifiers.LAZY) {
    String desc=""String_Node_Str"" + this.getDescription();
    String signature=this.type.getSignature();
    if (signature != null) {
      signature=""String_Node_Str"" + signature;
    }
    MethodWriter mw=new MethodWriter(writer,writer.visitMethod(this.modifiers & Modifiers.METHOD_MODIFIERS,this.name,desc,signature,null));
    for (    Annotation a : this.annotations) {
      a.write(mw);
    }
    mw.visitAnnotation(""String_Node_Str"",false);
    mw.visitCode();
    this.value.writeExpression(mw);
    mw.visitEnd(this.type);
    return;
  }
  FieldVisitor fv=writer.visitField(this.modifiers & 0xFFFF,this.name,this.getDescription(),this.type.getSignature(),null);
  if ((this.modifiers & Modifiers.SEALED) != 0) {
    fv.visitAnnotation(""String_Node_Str"",false);
  }
  if ((this.modifiers & Modifiers.DEPRECATED) != 0) {
    fv.visitAnnotation(""String_Node_Str"",true);
  }
  for (  Annotation a : this.annotations) {
    a.write(fv);
  }
}","@Override public void write(ClassWriter writer){
  if ((this.modifiers & Modifiers.LAZY) == Modifiers.LAZY) {
    String desc=""String_Node_Str"" + this.getDescription();
    String signature=this.type.getSignature();
    if (signature != null) {
      signature=""String_Node_Str"" + signature;
    }
    MethodWriter mw=new MethodWriter(writer,writer.visitMethod(this.modifiers & Modifiers.METHOD_MODIFIERS,this.name,desc,signature,null));
    for (    Annotation a : this.annotations) {
      a.write(mw);
    }
    mw.visitAnnotation(""String_Node_Str"",false);
    mw.visitCode();
    this.value.writeExpression(mw);
    mw.visitEnd(this.type);
    return;
  }
  FieldVisitor fv=writer.visitField(this.modifiers & 0xFFFF,this.name,this.getDescription(),this.type.getSignature(),null);
  if ((this.modifiers & Modifiers.SEALED) != 0) {
    fv.visitAnnotation(""String_Node_Str"",false);
  }
  if ((this.modifiers & Modifiers.DEPRECATED) != 0) {
    fv.visitAnnotation(""String_Node_Str"",true);
  }
  if (this.annotations != null) {
    for (    Annotation a : this.annotations) {
      a.write(fv);
    }
  }
}",0.9621072088724584
85278,"@Override public void toString(String prefix,StringBuilder buffer){
  for (  Annotation a : this.annotations) {
    a.toString(prefix,buffer);
    buffer.append(' ');
  }
  this.type.toString(""String_Node_Str"",buffer);
  if (this.isVarargs()) {
    int len=buffer.length();
    buffer.replace(len - 2,len,""String_Node_Str"");
  }
  buffer.append(' ').append(this.name);
  if (this.defaultValue != null) {
    buffer.append(Formatting.Field.keyValueSeperator).append(' ');
    this.defaultValue.toString(prefix,buffer);
  }
}","@Override public void toString(String prefix,StringBuilder buffer){
  if (this.annotations != null) {
    for (    Annotation a : this.annotations) {
      a.toString(prefix,buffer);
      buffer.append(' ');
    }
  }
  this.type.toString(""String_Node_Str"",buffer);
  if (this.isVarargs()) {
    int len=buffer.length();
    buffer.replace(len - 2,len,""String_Node_Str"");
  }
  buffer.append(' ').append(this.name);
  if (this.defaultValue != null) {
    buffer.append(Formatting.Field.keyValueSeperator).append(' ');
    this.defaultValue.toString(prefix,buffer);
  }
}",0.946983546617916
85279,"@Override public void resolveTypes(List<Marker> markers,IContext context){
  this.type=this.type.resolve(context);
  if (!this.type.isResolved()) {
    markers.add(Markers.create(this.type.getPosition(),""String_Node_Str"",this.type.toString()));
  }
  for (  Annotation a : this.annotations) {
    a.resolveTypes(markers,context);
  }
  if (this.defaultValue != null) {
    this.defaultValue.resolveTypes(markers,context);
  }
}","@Override public void resolveTypes(List<Marker> markers,IContext context){
  this.type=this.type.resolve(context);
  if (!this.type.isResolved() && markers != null) {
    markers.add(Markers.create(this.type.getPosition(),""String_Node_Str"",this.type.toString()));
  }
  if (this.annotations != null) {
    for (    Annotation a : this.annotations) {
      a.resolveTypes(markers,context);
    }
  }
  if (this.defaultValue != null) {
    this.defaultValue.resolveTypes(markers,context);
  }
}",0.6985854189336235
85280,"@Override public void resolveTypes(List<Marker> markers,IContext context,boolean isStatic){
  if (isStatic && this.child == null) {
    FieldMatch field=context.resolveField(this.name);
    if (field != null) {
      this.field=field;
      return;
    }
    this.methods=new ArrayList();
    context.getMethodMatches(this.methods,null,this.name,null);
    if (!this.methods.isEmpty()) {
      Collections.sort(this.methods);
      return;
    }
    markers.add(Markers.create(this.position,""String_Node_Str"",this.name));
    return;
  }
  Package pack=context.resolvePackage(this.name);
  if (pack != null) {
    this.thePackage=pack;
    if (this.child != null) {
      this.child.resolveTypes(markers,pack,isStatic);
    }
    return;
  }
  IClass iclass=context.resolveClass(this.name);
  if (iclass != null) {
    this.theClass=iclass;
    if (this.child != null) {
      this.child.resolveTypes(markers,iclass,isStatic);
    }
    return;
  }
  markers.add(Markers.create(this.position,""String_Node_Str"",this.name));
}","@Override public void resolveTypes(List<Marker> markers,IContext context,boolean isStatic){
  if (isStatic && this.child == null) {
    if (!(context instanceof IClass)) {
      markers.add(Markers.create(this.position,""String_Node_Str""));
      return;
    }
    FieldMatch field=context.resolveField(this.name);
    if (field != null) {
      this.field=field;
      return;
    }
    this.methods=new ArrayList();
    context.getMethodMatches(this.methods,null,this.name,null);
    if (!this.methods.isEmpty()) {
      Collections.sort(this.methods);
      return;
    }
    markers.add(Markers.create(this.position,""String_Node_Str"",this.name));
    return;
  }
  Package pack=context.resolvePackage(this.name);
  if (pack != null) {
    this.thePackage=pack;
    if (this.child != null) {
      this.child.resolveTypes(markers,pack,isStatic);
    }
    return;
  }
  IClass iclass=context.resolveClass(this.name);
  if (iclass != null) {
    this.theClass=iclass;
    if (this.child != null) {
      this.child.resolveTypes(markers,iclass,isStatic);
    }
    return;
  }
  markers.add(Markers.create(this.position,""String_Node_Str"",this.name));
}",0.6681985294117647
85281,"@Override public int getTypeMatch(IType type){
  if (this.method == null) {
    return 0;
  }
  IType type1=this.method.getType();
  if (type.equals(type1)) {
    return 3;
  }
 else   if (type1.isSuperType(type)) {
    return 2;
  }
  return 0;
}","@Override public int getTypeMatch(IType type){
  if (this.method == null) {
    return 0;
  }
  IType type1=this.method.getType();
  if (type.equals(type1)) {
    return 3;
  }
 else   if (type.isSuperTypeOf(type1)) {
    return 2;
  }
  return 0;
}",0.9274193548387096
85282,"@Override public int getTypeMatch(IType type){
  if (this.type.equals(type)) {
    return 3;
  }
 else   if (this.type.isSuperType(type)) {
    return 2;
  }
  return 0;
}","@Override public int getTypeMatch(IType type){
  if (this.type.equals(type)) {
    return 3;
  }
 else   if (type.isSuperTypeOf(this.type)) {
    return 2;
  }
  return 0;
}",0.9651162790697676
85283,"@Override public void writeStatement(MethodWriter writer){
  int i=this.instance.getValueType();
  if (i == FIELD_ACCESS) {
    FieldAccess access=(FieldAccess)this.instance;
    IField f=access.field;
    if (this.writeIINC(writer,f)) {
      return;
    }
    IValue instance=access.instance;
    if (instance != null) {
      instance.writeExpression(writer);
      writer.visitInsn(Opcodes.DUP);
    }
    f.writeGet(writer);
    this.method.writeCall(writer,null,this.arguments);
    f.writeSet(writer);
  }
 else   if (i == APPLY_METHOD_CALL) {
    ApplyMethodCall call=(ApplyMethodCall)this.instance;
    call.instance.writeExpression(writer);
    for (    IValue v : call.arguments) {
      v.writeExpression(writer);
    }
    writer.visitInsn(Opcodes.DUP2);
    call.method.writeCall(writer,null,Util.EMPTY_VALUES);
    this.method.writeCall(writer,null,this.arguments);
    this.updateMethod.writeCall(writer,null,Util.EMPTY_VALUES);
  }
}","@Override public void writeStatement(MethodWriter writer){
  int i=this.instance.getValueType();
  if (i == FIELD_ACCESS) {
    FieldAccess access=(FieldAccess)this.instance;
    IField f=access.field;
    if (this.writeIINC(writer,f)) {
      return;
    }
    IValue instance=access.instance;
    if (instance != null) {
      instance.writeExpression(writer);
      writer.visitInsn(Opcodes.DUP);
    }
    f.writeGet(writer,null);
    this.method.writeCall(writer,null,this.arguments);
    f.writeSet(writer,null,null);
  }
 else   if (i == APPLY_METHOD_CALL) {
    ApplyMethodCall call=(ApplyMethodCall)this.instance;
    call.instance.writeExpression(writer);
    for (    IValue v : call.arguments) {
      v.writeExpression(writer);
    }
    writer.visitInsn(Opcodes.DUP2);
    call.method.writeCall(writer,null,Util.EMPTY_VALUES);
    this.method.writeCall(writer,null,this.arguments);
    this.updateMethod.writeCall(writer,null,Util.EMPTY_VALUES);
  }
}",0.9921671018276762
85284,"@Override public void writeExpression(MethodWriter writer){
  int i=this.instance.getValueType();
  if (i == FIELD_ACCESS) {
    FieldAccess access=(FieldAccess)this.instance;
    IField f=access.field;
    if (this.writeIINC(writer,f)) {
      return;
    }
    IValue instance=access.instance;
    if (instance != null) {
      instance.writeExpression(writer);
      writer.visitInsn(Opcodes.DUP);
    }
    f.writeGet(writer);
    this.method.writeCall(writer,null,this.arguments);
    writer.visitInsn(Opcodes.DUP);
    f.writeSet(writer);
  }
 else   if (i == APPLY_METHOD_CALL) {
    ApplyMethodCall call=(ApplyMethodCall)this.instance;
    call.instance.writeExpression(writer);
    for (    IValue v : call.arguments) {
      v.writeExpression(writer);
    }
    writer.visitInsn(Opcodes.DUP2);
    call.method.writeCall(writer,null,Util.EMPTY_VALUES);
    this.method.writeCall(writer,null,this.arguments);
    writer.visitInsn(Opcodes.DUP_X2);
    this.updateMethod.writeCall(writer,null,Util.EMPTY_VALUES);
  }
}","@Override public void writeExpression(MethodWriter writer){
  int i=this.instance.getValueType();
  if (i == FIELD_ACCESS) {
    FieldAccess access=(FieldAccess)this.instance;
    IField f=access.field;
    if (this.writeIINC(writer,f)) {
      return;
    }
    IValue instance=access.instance;
    if (instance != null) {
      instance.writeExpression(writer);
      writer.visitInsn(Opcodes.DUP);
    }
    f.writeGet(writer,null);
    this.method.writeCall(writer,null,this.arguments);
    writer.visitInsn(Opcodes.DUP);
    f.writeSet(writer,null,null);
  }
 else   if (i == APPLY_METHOD_CALL) {
    ApplyMethodCall call=(ApplyMethodCall)this.instance;
    call.instance.writeExpression(writer);
    for (    IValue v : call.arguments) {
      v.writeExpression(writer);
    }
    writer.visitInsn(Opcodes.DUP2);
    call.method.writeCall(writer,null,Util.EMPTY_VALUES);
    this.method.writeCall(writer,null,this.arguments);
    writer.visitInsn(Opcodes.DUP_X2);
    this.updateMethod.writeCall(writer,null,Util.EMPTY_VALUES);
  }
}",0.9927290353853612
85285,"@Override public int getTypeMatch(IType type){
  if (this.method == null) {
    return 0;
  }
  IType type1=this.method.getType();
  if (type.equals(type1)) {
    return 3;
  }
 else   if (type1.isSuperType(type)) {
    return 2;
  }
  return 0;
}","@Override public int getTypeMatch(IType type){
  if (this.method == null) {
    return 0;
  }
  IType type1=this.method.getType();
  if (type.equals(type1)) {
    return 3;
  }
 else   if (type.isSuperTypeOf(type1)) {
    return 2;
  }
  return 0;
}",0.9274193548387096
85286,"@Override public int getTypeMatch(IType type){
  if (this.type.equals(type)) {
    return 3;
  }
 else   if (this.type.isSuperType(type)) {
    return 2;
  }
  return 0;
}","@Override public int getTypeMatch(IType type){
  if (this.type.equals(type)) {
    return 3;
  }
 else   if (type.isSuperTypeOf(this.type)) {
    return 2;
  }
  return 0;
}",0.9651162790697676
85287,"@Override public void writeExpression(MethodWriter writer){
  IClass iclass=this.type.getTheClass();
  if (iclass != null) {
    IField field=iclass.getInstanceField();
    if (field != null) {
      field.writeGet(writer);
    }
  }
}","@Override public void writeExpression(MethodWriter writer){
  IClass iclass=this.type.getTheClass();
  if (iclass != null) {
    IField field=iclass.getInstanceField();
    if (field != null) {
      field.writeGet(writer,null);
    }
  }
}",0.9894736842105264
85288,"@Override public int getTypeMatch(IType type){
  if (this.type.equals(type)) {
    return 3;
  }
 else   if (this.type.isSuperType(type)) {
    return 2;
  }
  return 0;
}","@Override public int getTypeMatch(IType type){
  if (this.type.equals(type)) {
    return 3;
  }
 else   if (type.isSuperTypeOf(this.type)) {
    return 2;
  }
  return 0;
}",0.9651162790697676
85289,"@Override public void writeStatement(MethodWriter writer){
  if (this.instance != null) {
    this.instance.writeExpression(writer);
  }
  this.field.writeGet(writer);
  writer.visitInsn(this.field.getType().getReturnOpcode());
}","@Override public void writeStatement(MethodWriter writer){
  this.field.writeGet(writer,this.instance);
  writer.visitInsn(this.field.getType().getReturnOpcode());
}",0.766497461928934
85290,"@Override public boolean resolve(IContext context,List<Marker> markers){
  IField field=IAccess.resolveField(context,this.instance,this.qualifiedName);
  if (field != null) {
    if (field.isEnumConstant()) {
      EnumValue enumValue=new EnumValue(this.position);
      enumValue.name=this.name;
      enumValue.qualifiedName=this.qualifiedName;
      enumValue.type=field.getType();
      this.replacement=enumValue;
      return false;
    }
    this.field=field;
    return true;
  }
  return false;
}","@Override public boolean resolve(IContext context,List<Marker> markers){
  IField field=IAccess.resolveField(context,this.instance,this.qualifiedName);
  if (field != null) {
    if (field.isEnumConstant()) {
      EnumValue enumValue=new EnumValue(this.position);
      enumValue.name=this.name;
      enumValue.qualifiedName=this.qualifiedName;
      enumValue.type=field.getType();
      this.replacement=enumValue;
      return false;
    }
    if (this.instance != null && !(field instanceof Field)) {
      return false;
    }
    this.field=field;
    return true;
  }
  return false;
}",0.8306010928961749
85291,"@Override public void writeExpression(MethodWriter writer){
  if (this.instance != null) {
    this.instance.writeExpression(writer);
  }
  this.field.writeGet(writer);
}","@Override public void writeExpression(MethodWriter writer){
  this.field.writeGet(writer,this.instance);
}",0.6666666666666666
85292,"@Override public boolean isResolved(){
  return this.field != null;
}","@Override public boolean isResolved(){
  if (this.field == null) {
    return false;
  }
  if (this.instance != null && !(this.field instanceof Field)) {
    return false;
  }
  return true;
}",0.4827586206896552
85293,"@Override public int getTypeMatch(IType type){
  if (this.field == null) {
    return 0;
  }
  IType type1=this.field.getType();
  if (type.equals(type1)) {
    return 3;
  }
 else   if (type1.isSuperType(type)) {
    return 2;
  }
  return 0;
}","@Override public int getTypeMatch(IType type){
  if (this.field == null) {
    return 0;
  }
  IType type1=this.field.getType();
  if (type.equals(type1)) {
    return 3;
  }
 else   if (Type.isSuperType(type,type1)) {
    return 2;
  }
  return 0;
}",0.9212121212121211
85294,"@Override public void writeStatement(MethodWriter writer){
  if (this.value == null) {
    return;
  }
  if (this.instance != null) {
    this.instance.writeExpression(writer);
  }
  this.value.writeExpression(writer);
  this.field.writeSet(writer);
}","@Override public void writeStatement(MethodWriter writer){
  if (this.value == null) {
    return;
  }
  this.field.writeSet(writer,this.instance,this.value);
}",0.656934306569343
85295,"@Override public void writeExpression(MethodWriter writer){
  if (this.value == null) {
    return;
  }
  if (this.instance != null) {
    this.instance.writeExpression(writer);
  }
  this.value.writeExpression(writer);
  writer.visitInsn(Opcodes.DUP);
  this.field.writeSet(writer);
}","@Override public void writeExpression(MethodWriter writer){
  if (this.value == null) {
    return;
  }
  if (this.instance != null) {
    this.instance.writeExpression(writer);
  }
  this.value.writeExpression(writer);
  writer.visitInsn(Opcodes.DUP);
  this.field.writeSet(writer,null,null);
}",0.9827586206896552
85296,"@Override public void writeStatement(MethodWriter writer){
  this.variable.value.writeExpression(writer);
  this.variable.writeSet(writer);
}","@Override public void writeStatement(MethodWriter writer){
  this.variable.writeSet(writer,null,this.variable.value);
}",0.7230769230769231
85297,"@Override public int getTypeMatch(IType type){
  if (this.variable.type.equals(type)) {
    return 3;
  }
 else   if (this.variable.type.isSuperType(type)) {
    return 2;
  }
  return 0;
}","@Override public int getTypeMatch(IType type){
  if (this.variable.type.equals(type)) {
    return 3;
  }
 else   if (this.variable.type.isSuperTypeOf(type)) {
    return 2;
  }
  return 0;
}",0.9947368421052633
85298,"@Override public void writeExpression(MethodWriter writer){
  this.variable.value.writeExpression(writer);
  writer.visitInsn(Opcodes.DUP);
  this.variable.writeSet(writer);
}","@Override public void writeExpression(MethodWriter writer){
  this.variable.value.writeExpression(writer);
  writer.visitInsn(Opcodes.DUP);
  this.variable.writeSet(writer,null,null);
}",0.9722222222222222
85299,"@Override public IAccess resolve3(IContext context,IAccess next){
  return null;
}","@Override public IAccess resolve3(IContext context,IAccess next){
  List<IValue> list=new ArrayList(this.arguments);
  list.add(next);
  IMethod method=IAccess.resolveMethod(context,this.instance,this.qualifiedName,list);
  if (method != null) {
    this.arguments=list;
    this.method=method;
    return this;
  }
  return null;
}",0.3333333333333333
85300,"@Override public int getTypeMatch(IType type){
  if (this.method == null) {
    return 0;
  }
  IType type1=this.method.getType();
  if (type.equals(type1)) {
    return 3;
  }
 else   if (type1.isSuperType(type)) {
    return 2;
  }
  return 0;
}","@Override public int getTypeMatch(IType type){
  if (this.method == null) {
    return 0;
  }
  IType type1=this.method.getType();
  if (type.equals(type1)) {
    return 3;
  }
 else   if (Type.isSuperType(type,type1)) {
    return 2;
  }
  return 0;
}",0.9218436873747496
85301,"@Override public int getTypeMatch(IType type){
  if (this.type.equals(type)) {
    return 3;
  }
 else   if (this.type.isSuperType(type)) {
    return 2;
  }
  return 0;
}","@Override public int getTypeMatch(IType type){
  if (this.type.equals(type)) {
    return 3;
  }
 else   if (type.isSuperTypeOf(this.type)) {
    return 2;
  }
  return 0;
}",0.9651162790697676
85302,"@Override public int getTypeMatch(IType type){
  if (this.method == null) {
    return 0;
  }
  IType type1=this.method.getType();
  if (type.equals(type1)) {
    return 3;
  }
 else   if (type1.isSuperType(type)) {
    return 2;
  }
  return 0;
}","@Override public int getTypeMatch(IType type){
  if (this.method == null) {
    return 0;
  }
  IType type1=this.method.getType();
  if (type.equals(type1)) {
    return 3;
  }
 else   if (type.isSuperTypeOf(type1)) {
    return 2;
  }
  return 0;
}",0.9274193548387096
85303,"@Override public FieldMatch resolveField(String name){
  if (!this.typesResolved) {
    this.resolveTypes(null,Package.rootPackage);
  }
  return super.resolveField(name);
}","@Override public FieldMatch resolveField(String name){
  if (!this.typesResolved) {
    this.resolveTypes(null,Package.rootPackage);
  }
  IField field=this.body.getProperty(name);
  if (field != null) {
    return new FieldMatch(field,1);
  }
  field=this.body.getField(name);
  if (field != null) {
    return new FieldMatch(field,1);
  }
  if (this.instanceField != null && ""String_Node_Str"".equals(name)) {
    return new FieldMatch(this.instanceField,1);
  }
  FieldMatch match;
  if (this.superType != null && this != Type.PREDEF_CLASS) {
    match=this.superType.resolveField(name);
    if (match != null) {
      return match;
    }
  }
  return null;
}",0.3860911270983213
85304,"@Override public void getMethodMatches(List<MethodMatch> list,IValue instance,String name,List<IValue> arguments){
  if (!this.typesResolved) {
    this.resolveTypes(null,Package.rootPackage);
  }
  super.getMethodMatches(list,instance,name,arguments);
}","@Override public void getMethodMatches(List<MethodMatch> list,IValue instance,String name,List<IValue> arguments){
  if (!this.typesResolved) {
    this.resolveTypes(null,Package.rootPackage);
  }
  this.body.getMethodMatches(list,instance,name,arguments);
  if (!list.isEmpty()) {
    return;
  }
  if (this.superType != null) {
    this.superType.getMethodMatches(list,instance,name,arguments);
  }
  for (  IType i : this.interfaces) {
    i.getMethodMatches(list,instance,name,arguments);
  }
}",0.6622340425531915
85305,"@Override public void getConstructorMatches(List<MethodMatch> list,List<IValue> arguments){
  if (!this.typesResolved) {
    this.resolveTypes(null,Package.rootPackage);
  }
  super.getConstructorMatches(list,arguments);
}","@Override public void getConstructorMatches(List<MethodMatch> list,List<IValue> arguments){
  if (!this.typesResolved) {
    this.resolveTypes(null,Package.rootPackage);
  }
  this.body.getMethodMatches(list,null,""String_Node_Str"",arguments);
}",0.8154506437768241
85306,"@Override public boolean equals(IClass iclass){
  if (!iclass.isSuperType(this.superType)) {
    return false;
  }
  for (  IType i : this.interfaces) {
    if (!iclass.isSuperType(i)) {
      return false;
    }
  }
  return true;
}","@Override public boolean equals(IClass iclass){
  if (!iclass.isSubTypeOf(this.superType)) {
    return false;
  }
  for (  IType i : this.interfaces) {
    if (!iclass.isSubTypeOf(i)) {
      return false;
    }
  }
  return true;
}",0.9399141630901288
85307,"@Override public void writeJump(MethodWriter writer,Label dest){
  this.left.writeExpression(writer);
  writer.visitJumpInsn(Opcodes.IFEQ,dest);
  this.right.writeExpression(writer);
  writer.visitJumpInsn(Opcodes.IFEQ,dest);
}","@Override public void writeJump(MethodWriter writer,Label dest){
  this.left.writeExpression(writer);
  writer.visitJumpInsn2(Opcodes.IFEQ,dest);
  this.right.writeExpression(writer);
  writer.visitJumpInsn2(Opcodes.IFEQ,dest);
}",0.9956140350877192
85308,"@Override public void writeStatement(MethodWriter writer){
  if (this.then == null) {
    this.condition.writeStatement(writer);
  }
  writer.visitLabel(this.start);
  this.condition.writeJump(writer,this.end);
  this.then.writeStatement(writer);
  writer.visitJumpInsn(Opcodes.GOTO,this.start);
  writer.visitLabel(this.end);
}","@Override public void writeStatement(MethodWriter writer){
  if (this.then == null) {
    this.condition.writeStatement(writer);
  }
  writer.visitLabel(this.start);
  this.condition.writeJump(writer,this.end);
  this.then.writeStatement(writer);
  writer.visitJumpInsn(Opcodes.GOTO,this.start);
  writer.visitLabel(this.end);
  writer.visitInsn(Opcodes.NOP);
}",0.9521044992743106
85309,"private void processInsn(int opcode){
switch (opcode) {
case DUP:
    this.typeStack.push(this.typeStack.peek());
  return;
case SWAP:
{
  Object o1=this.typeStack.pop();
  Object o2=this.typeStack.pop();
  this.typeStack.push(o1);
  this.typeStack.push(o2);
  return;
}
case POP:
this.typeStack.pop();
return;
case ACONST_NULL:
this.push(NULL);
return;
case ARRAYLENGTH:
this.set(INTEGER);
return;
case RETURN:
this.hasReturn=true;
return;
case IADD:
case ISUB:
case IMUL:
case IDIV:
case IREM:
case ISHL:
case ISHR:
case IUSHR:
this.typeStack.pop();
this.typeStack.pop();
this.push(INTEGER);
return;
case LADD:
case LSUB:
case LMUL:
case LDIV:
case LREM:
case LSHL:
case LSHR:
case LUSHR:
this.typeStack.pop();
this.typeStack.pop();
this.push(LONG);
return;
case FADD:
case FSUB:
case FMUL:
case FDIV:
case FREM:
this.typeStack.pop();
this.typeStack.pop();
this.push(FLOAT);
return;
case DADD:
case DSUB:
case DMUL:
case DDIV:
case DREM:
this.typeStack.pop();
this.typeStack.pop();
this.push(DOUBLE);
return;
case L2I:
case F2I:
case D2I:
this.set(INTEGER);
case I2L:
case F2L:
case D2L:
this.set(LONG);
return;
case I2F:
case L2F:
case D2F:
this.set(FLOAT);
return;
case LCMP:
case FCMPL:
case FCMPG:
case DCMPL:
case DCMPG:
this.typeStack.pop();
this.typeStack.pop();
this.push(INTEGER);
return;
}
}","private void processInsn(int opcode){
switch (opcode) {
case DUP:
    this.typeStack.push(this.typeStack.peek());
  return;
case SWAP:
{
  Object o1=this.typeStack.pop();
  Object o2=this.typeStack.pop();
  this.typeStack.push(o1);
  this.typeStack.push(o2);
  return;
}
case POP:
this.typeStack.pop();
return;
case ACONST_NULL:
this.push(NULL);
return;
case ARRAYLENGTH:
this.set(INTEGER);
return;
case RETURN:
this.hasReturn=true;
return;
case BALOAD:
case SALOAD:
case CALOAD:
case IALOAD:
this.typeStack.pop();
this.typeStack.pop();
this.push(INTEGER);
break;
case LALOAD:
this.typeStack.pop();
this.typeStack.pop();
this.push(LONG);
break;
case FALOAD:
this.typeStack.pop();
this.typeStack.pop();
this.push(FLOAT);
break;
case DALOAD:
this.typeStack.pop();
this.typeStack.pop();
this.push(DOUBLE);
break;
case AALOAD:
this.typeStack.pop();
this.typeStack.pop();
this.push(TOP);
case IADD:
case ISUB:
case IMUL:
case IDIV:
case IREM:
case ISHL:
case ISHR:
case IUSHR:
this.typeStack.pop();
this.typeStack.pop();
this.push(INTEGER);
return;
case LADD:
case LSUB:
case LMUL:
case LDIV:
case LREM:
case LSHL:
case LSHR:
case LUSHR:
this.typeStack.pop();
this.typeStack.pop();
this.push(LONG);
return;
case FADD:
case FSUB:
case FMUL:
case FDIV:
case FREM:
this.typeStack.pop();
this.typeStack.pop();
this.push(FLOAT);
return;
case DADD:
case DSUB:
case DMUL:
case DDIV:
case DREM:
this.typeStack.pop();
this.typeStack.pop();
this.push(DOUBLE);
return;
case L2I:
case F2I:
case D2I:
this.set(INTEGER);
case I2L:
case F2L:
case D2L:
this.set(LONG);
return;
case I2F:
case L2F:
case D2F:
this.set(FLOAT);
return;
case LCMP:
case FCMPL:
case FCMPG:
case DCMPL:
case DCMPG:
this.typeStack.pop();
this.typeStack.pop();
this.push(INTEGER);
return;
}
}",0.4435695538057743
85310,"@Override public void visitInsn(int opcode){
  if (opcode > 255) {
    this.visitSpecialInsn(opcode);
    return;
  }
  if (opcode >= IALOAD && opcode <= SALOAD) {
    Object o=this.typeStack.pop();
    this.typeStack.pop();
    if (o instanceof String) {
      this.push(((String)o).substring(1));
    }
 else {
      this.push(TOP);
    }
  }
 else   if (opcode >= IASTORE && opcode <= SASTORE) {
    this.typeStack.pop();
    this.typeStack.pop();
    this.typeStack.pop();
  }
 else   if (opcode >= IRETURN && opcode <= ARETURN) {
    this.typeStack.pop();
  }
 else {
    this.processInsn(opcode);
  }
  this.mv.visitInsn(opcode);
}","@Override public void visitInsn(int opcode){
  if (opcode > 255) {
    this.visitSpecialInsn(opcode);
    return;
  }
 else   if (opcode >= IASTORE && opcode <= SASTORE) {
    this.typeStack.pop();
    this.typeStack.pop();
    this.typeStack.pop();
  }
 else   if (opcode >= IRETURN && opcode <= ARETURN) {
    this.typeStack.pop();
  }
 else {
    this.processInsn(opcode);
  }
  this.mv.visitInsn(opcode);
}",0.7831900668576887
85311,"@Override public void writeJump(MethodWriter writer,Label dest){
}","@Override public void writeJump(MethodWriter writer,Label dest){
  this.writeExpression(writer);
  writer.visitJumpInsn(Opcodes.IFEQ,dest);
}",0.6376811594202898
85312,"public static IValue resolve(List<Marker> markers,IContext context,IAccess access){
  LinkedList<IAccess> chain=getCallChain(markers,context,access);
  ListIterator<IAccess> iterator=chain.listIterator();
  IAccess prev=null;
  IAccess curr=null;
  IValue alternate=null;
  boolean backwards=false;
  while (iterator.hasNext()) {
    prev=curr;
    curr=iterator.next();
    if (alternate != null) {
      curr.setValue(alternate);
      alternate=null;
    }
    if (!curr.resolve(context,markers)) {
      alternate=curr.resolve2(context);
      if (alternate instanceof IAccess) {
        curr=(IAccess)alternate;
        iterator.set(curr);
      }
 else       if (alternate != null) {
        if (!iterator.hasNext()) {
          return alternate;
        }
 else {
          iterator.remove();
          iterator.next().setValue(alternate);
          iterator.previous();
        }
      }
 else {
        backwards=true;
        break;
      }
    }
  }
  if (!backwards) {
    return chain.getLast();
  }
 else   if (chain.size() == 1) {
    markers.add(access.getResolveError());
    return access;
  }
  IAccess next=null;
  curr=access;
  prev=null;
  while (curr != null) {
    IValue value=curr.getValue();
    if (value instanceof IAccess) {
      prev=(IAccess)value;
    }
 else {
      prev=null;
    }
    if (next != null && !curr.resolve(context,markers)) {
      next.setValue(null);
      if (next.resolve(context,markers)) {
        alternate=curr.resolve3(context,next);
        if (alternate instanceof IAccess) {
          if (next.getValue() == curr) {
            next.setValue(alternate);
          }
          next=(IAccess)alternate;
          curr=prev;
          iterator.next();
          iterator.remove();
          iterator.previous();
          iterator.set(next);
        }
 else {
          next.setValue(curr);
          markers.add(curr.getResolveError());
        }
      }
 else {
        markers.add(curr.getResolveError());
      }
    }
    next=curr;
    curr=prev;
  }
  return chain.getLast();
}","public static IValue resolve(List<Marker> markers,IContext context,IAccess access){
  LinkedList<IAccess> chain=getCallChain(markers,context,access);
  ListIterator<IAccess> iterator=chain.listIterator();
  IAccess prev=null;
  IAccess curr=null;
  IValue alternate=null;
  boolean backwards=false;
  while (iterator.hasNext()) {
    prev=curr;
    curr=iterator.next();
    if (alternate != null) {
      curr.setValue(alternate);
      alternate=null;
    }
    if (!curr.resolve(context,markers)) {
      alternate=curr.resolve2(context);
      if (alternate instanceof IAccess) {
        curr=(IAccess)alternate;
        iterator.set(curr);
      }
 else       if (alternate != null) {
        if (!iterator.hasNext()) {
          return alternate;
        }
 else {
          iterator.remove();
          iterator.next().setValue(alternate);
          iterator.previous();
        }
      }
 else {
        backwards=true;
        break;
      }
    }
  }
  if (!backwards) {
    return chain.getLast();
  }
 else   if (chain.size() == 1) {
    markers.add(access.getResolveError());
    return access;
  }
  IAccess next=null;
  curr=access;
  prev=null;
  while (curr != null) {
    IValue value=curr.getValue();
    if (value instanceof IAccess) {
      prev=(IAccess)value;
    }
 else {
      prev=null;
    }
    if (next != null && !curr.isResolved()) {
      next.setValue(null);
      if (next.resolve(context,markers)) {
        alternate=curr.resolve3(context,next);
        if (alternate instanceof IAccess) {
          if (next.getValue() == curr) {
            next.setValue(alternate);
          }
          next=(IAccess)alternate;
          curr=prev;
          iterator.next();
          iterator.remove();
          iterator.previous();
          iterator.set(next);
        }
 else {
          next.setValue(curr);
          markers.add(curr.getResolveError());
        }
      }
 else {
        markers.add(curr.getResolveError());
      }
    }
    next=curr;
    curr=prev;
  }
  return chain.getLast();
}",0.9686120647376164
85313,"@Override public void writeStatement(MethodWriter writer){
  Variable var=this.variable;
  if (this.type == DEFAULT) {
    if (var != null) {
      writer.addLocal(var.index,MethodWriter.TOP);
      var.value.writeExpression(writer);
      var.writeSet(writer);
    }
    writer.visitLabel(this.startLabel);
    if (this.condition != null) {
      this.condition.writeJump(writer,this.endLabel);
    }
    if (this.then != null) {
      this.then.writeStatement(writer);
    }
    writer.visitLabel(this.updateLabel);
    if (this.update != null) {
      this.update.writeStatement(writer);
    }
    writer.visitJumpInsn(Opcodes.GOTO,this.startLabel);
    writer.visitLabel(this.endLabel);
    if (var != null) {
      writer.visitLocalVariable(var.qualifiedName,var.type.getExtendedName(),var.type.getSignature(),this.startLabel,this.endLabel,var.index);
    }
    return;
  }
  if (this.type == ARRAY) {
    Variable arrayVar=this.arrayVar;
    Variable indexVar=this.indexVar;
    writer.addLocal(var.index,MethodWriter.TOP);
    writer.addLocal(indexVar.index,indexVar.type);
    writer.addLocal(this.lengthVar.index,this.lengthVar.type);
    writer.addLocal(arrayVar.index,arrayVar.type);
    var.value.writeExpression(writer);
    writer.visitInsn(Opcodes.DUP);
    arrayVar.writeSet(writer);
    writer.visitInsn(Opcodes.ARRAYLENGTH);
    this.lengthVar.writeSet(writer);
    writer.visitLdcInsn(0);
    indexVar.writeSet(writer);
    writer.visitJumpInsn(Opcodes.GOTO,this.updateLabel);
    writer.visitLabel(this.startLabel);
    arrayVar.writeGet(writer);
    indexVar.writeGet(writer);
    writer.visitInsn(arrayVar.type.getArrayLoadOpcode());
    var.writeSet(writer);
    this.then.writeStatement(writer);
    writer.visitIincInsn(indexVar.index,1);
    writer.visitLabel(this.updateLabel);
    indexVar.writeGet(writer);
    this.lengthVar.writeGet(writer);
    writer.visitJumpInsn(Opcodes.IF_ICMPLT,this.startLabel);
    writer.visitLabel(this.endLabel);
    writer.visitLocalVariable(var.qualifiedName,var.type.getExtendedName(),var.type.getSignature(),this.startLabel,this.endLabel,var.index);
    writer.visitLocalVariable(""String_Node_Str"",""String_Node_Str"",null,this.startLabel,this.endLabel,indexVar.index);
    writer.visitLocalVariable(""String_Node_Str"",""String_Node_Str"",null,this.startLabel,this.endLabel,this.lengthVar.index);
    writer.visitLocalVariable(""String_Node_Str"",arrayVar.type.getExtendedName(),arrayVar.type.getSignature(),this.startLabel,this.endLabel,arrayVar.index);
    return;
  }
}","@Override public void writeStatement(MethodWriter writer){
  Variable var=this.variable;
  if (this.type == DEFAULT) {
    if (var != null) {
      writer.addLocal(var.index,var.type);
      var.value.writeExpression(writer);
      var.writeSet(writer);
    }
    writer.visitLabel(this.startLabel);
    if (this.condition != null) {
      this.condition.writeJump(writer,this.endLabel);
    }
    if (this.then != null) {
      this.then.writeStatement(writer);
    }
    writer.visitLabel(this.updateLabel);
    if (this.update != null) {
      this.update.writeStatement(writer);
    }
    writer.visitJumpInsn(Opcodes.GOTO,this.startLabel);
    writer.visitLabel(this.endLabel);
    if (var != null) {
      writer.visitLocalVariable(var.qualifiedName,var.type.getExtendedName(),var.type.getSignature(),this.startLabel,this.endLabel,var.index);
    }
    return;
  }
  if (this.type == ARRAY) {
    Variable arrayVar=this.arrayVar;
    Variable indexVar=this.indexVar;
    writer.addLocal(var.index,MethodWriter.TOP);
    writer.addLocal(indexVar.index,indexVar.type);
    writer.addLocal(this.lengthVar.index,this.lengthVar.type);
    writer.addLocal(arrayVar.index,arrayVar.type);
    var.value.writeExpression(writer);
    writer.visitInsn(Opcodes.DUP);
    arrayVar.writeSet(writer);
    writer.visitInsn(Opcodes.ARRAYLENGTH);
    this.lengthVar.writeSet(writer);
    writer.visitLdcInsn(0);
    indexVar.writeSet(writer);
    writer.visitJumpInsn(Opcodes.GOTO,this.updateLabel);
    writer.visitLabel(this.startLabel);
    arrayVar.writeGet(writer);
    indexVar.writeGet(writer);
    writer.visitInsn(arrayVar.type.getArrayLoadOpcode());
    var.writeSet(writer);
    this.then.writeStatement(writer);
    writer.visitIincInsn(indexVar.index,1);
    writer.visitLabel(this.updateLabel);
    indexVar.writeGet(writer);
    this.lengthVar.writeGet(writer);
    writer.visitJumpInsn(Opcodes.IF_ICMPLT,this.startLabel);
    writer.visitLabel(this.endLabel);
    writer.visitLocalVariable(var.qualifiedName,var.type.getExtendedName(),var.type.getSignature(),this.startLabel,this.endLabel,var.index);
    writer.visitLocalVariable(""String_Node_Str"",""String_Node_Str"",null,this.startLabel,this.endLabel,indexVar.index);
    writer.visitLocalVariable(""String_Node_Str"",""String_Node_Str"",null,this.startLabel,this.endLabel,this.lengthVar.index);
    writer.visitLocalVariable(""String_Node_Str"",arrayVar.type.getExtendedName(),arrayVar.type.getSignature(),this.startLabel,this.endLabel,arrayVar.index);
    return;
  }
}",0.9952456418383518
85314,"@Override public void check(List<Marker> markers,IContext context){
  if (this.type != 0) {
    IType type=this.variable.type;
    IValue value=this.variable.value;
    value.check(markers,context);
    IType valueType=value.getType();
    int valueTypeDims=valueType.getArrayDimensions();
    if (valueTypeDims != 0) {
      this.type=ARRAY;
      if (!valueType.classEquals(type) || type.getArrayDimensions() != valueTypeDims - 1) {
        Marker marker=Markers.create(value.getPosition(),""String_Node_Str"");
        marker.addInfo(""String_Node_Str"" + valueType);
        marker.addInfo(""String_Node_Str"" + type);
        markers.add(marker);
      }
 else {
        Variable var=new Variable(null);
        var.type=Type.INT;
        var.name=""String_Node_Str"";
        var.qualifiedName=""String_Node_Str"";
        var.index=this.variable.index + 1;
        this.indexVar=var;
        var=new Variable(null);
        var.type=Type.INT;
        var.name=""String_Node_Str"";
        var.qualifiedName=""String_Node_Str"";
        var.index=this.variable.index + 2;
        this.lengthVar=var;
        var=new Variable(null);
        var.type=valueType;
        var.name=""String_Node_Str"";
        var.qualifiedName=""String_Node_Str"";
        var.index=this.variable.index + 3;
        this.arrayVar=var;
      }
    }
  }
 else {
    this.context=context;
    if (this.variable != null) {
      this.variable.check(markers,context);
    }
    if (this.condition != null) {
      this.condition.check(markers,this);
      if (!this.condition.requireType(Type.BOOLEAN)) {
        Marker marker=Markers.create(this.condition.getPosition(),""String_Node_Str"");
        marker.addInfo(""String_Node_Str"" + this.condition.getType());
        markers.add(marker);
      }
    }
    if (this.update != null) {
      this.update.check(markers,this);
    }
  }
  if (this.then != null) {
    this.then.check(markers,this);
  }
}","@Override public void check(List<Marker> markers,IContext context){
  if (this.type != 0) {
    IType type=this.variable.type;
    IValue value=this.variable.value;
    value.check(markers,context);
    IType valueType=value.getType();
    int valueTypeDims=valueType.getArrayDimensions();
    if (valueTypeDims != 0) {
      this.type=ARRAY;
      if (!valueType.classEquals(type) || type.getArrayDimensions() != valueTypeDims - 1) {
        Marker marker=Markers.create(value.getPosition(),""String_Node_Str"");
        marker.addInfo(""String_Node_Str"" + valueType);
        marker.addInfo(""String_Node_Str"" + type);
        markers.add(marker);
      }
 else       if (this.then == null) {
        markers.add(Markers.create(this.position,""String_Node_Str""));
      }
 else {
        Variable var=new Variable(null);
        var.type=Type.INT;
        var.name=""String_Node_Str"";
        var.qualifiedName=""String_Node_Str"";
        var.index=this.variable.index + 1;
        this.indexVar=var;
        var=new Variable(null);
        var.type=Type.INT;
        var.name=""String_Node_Str"";
        var.qualifiedName=""String_Node_Str"";
        var.index=this.variable.index + 2;
        this.lengthVar=var;
        var=new Variable(null);
        var.type=valueType;
        var.name=""String_Node_Str"";
        var.qualifiedName=""String_Node_Str"";
        var.index=this.variable.index + 3;
        this.arrayVar=var;
      }
    }
  }
 else {
    this.context=context;
    if (this.variable != null) {
      this.variable.check(markers,context);
    }
    if (this.condition != null) {
      this.condition.check(markers,this);
      if (!this.condition.requireType(Type.BOOLEAN)) {
        Marker marker=Markers.create(this.condition.getPosition(),""String_Node_Str"");
        marker.addInfo(""String_Node_Str"" + this.condition.getType());
        markers.add(marker);
      }
    }
    if (this.update != null) {
      this.update.check(markers,this);
    }
  }
  if (this.then != null) {
    this.then.check(markers,this);
  }
}",0.97084917617237
85315,"public void addLocal(int index,Object type){
  this.locals.add(type);
}","public void addLocal(int index,Object type){
  this.ensureLocals(index);
  this.locals[index]=type;
}",0.7674418604651163
85316,"public void visitParameter(String name,IType type,int index){
  this.locals.add(type.getFrameType());
  this.mv.visitParameter(name,index);
}","public void visitParameter(String name,IType type,int index){
  this.addLocal(index,type.getFrameType());
  this.mv.visitParameter(name,index);
}",0.944055944055944
85317,"private void visitFrame(){
  int len=this.typeStack.size();
  Object[] o=new Object[len];
  for (int i=0; i < len; i++) {
    o[i]=this.typeStack.get(i);
  }
  this.mv.visitFrame(F_NEW,this.locals.size(),this.locals.toArray(),len,o);
}","private void visitFrame(){
  int len=this.typeStack.size();
  Object[] o=new Object[len];
  for (int i=0; i < len; i++) {
    o[i]=this.typeStack.get(i);
  }
  this.mv.visitFrame(F_NEW,this.maxLocals,this.locals,len,o);
}",0.8771929824561403
85318,"public void visitEnd(IType type){
  if (!this.hasReturn) {
    this.mv.visitInsn(type.getReturnOpcode());
  }
  this.mv.visitMaxs(this.maxStack,this.locals.size());
  this.mv.visitEnd();
}","public void visitEnd(IType type){
  if (!this.hasReturn) {
    this.mv.visitInsn(type.getReturnOpcode());
  }
  this.mv.visitMaxs(this.maxStack,this.maxLocals);
  this.mv.visitEnd();
}",0.967741935483871
85319,"public void setConstructor(IType type){
  this.locals.add(UNINITIALIZED_THIS);
  this.push(UNINITIALIZED_THIS);
}","public void setConstructor(IType type){
  this.locals[0]=UNINITIALIZED_THIS;
  this.push(UNINITIALIZED_THIS);
}",0.9553571428571428
85320,"@Override public void writeStatement(MethodWriter writer){
  this.writeExpression(writer);
}","@Override public void writeStatement(MethodWriter writer){
  int opcode;
  int args=this.arguments.size();
  if (this.isCustom) {
    opcode=Opcodes.INVOKESTATIC;
  }
 else {
    opcode=Opcodes.INVOKESPECIAL;
    args++;
    writer.visitTypeInsn(Opcodes.NEW,this.type);
  }
  for (  IValue arg : this.arguments) {
    arg.writeExpression(writer);
  }
  String owner=this.method.getTheClass().getInternalName();
  String name=""String_Node_Str"";
  String desc=this.method.getDescriptor();
  writer.visitMethodInsn(opcode,owner,name,desc,false,args,null);
}",0.2724458204334365
85321,"@Override public boolean resolve(IContext context,List<Marker> markers){
  if (!this.type.isResolved()) {
    return false;
  }
  MethodMatch match=this.type.resolveMethod(null,""String_Node_Str"",this.arguments);
  if (match != null) {
    this.method=match.theMethod;
    this.isCustom=true;
    return true;
  }
  match=this.type.resolveMethod(null,""String_Node_Str"",this.arguments);
  if (match != null) {
    this.method=match.theMethod;
    return true;
  }
  return false;
}","@Override public boolean resolve(IContext context,List<Marker> markers){
  if (!this.type.isResolved()) {
    return false;
  }
  MethodMatch match=this.type.resolveMethod(null,""String_Node_Str"",this.arguments);
  if (match != null) {
    this.method=match.theMethod;
    return true;
  }
  return false;
}",0.7464968152866241
85322,"@Override public void writeExpression(MethodWriter writer){
  int opcode;
  int args=this.arguments.size();
  if (this.isCustom) {
    opcode=Opcodes.INVOKESTATIC;
  }
 else {
    opcode=Opcodes.INVOKESPECIAL;
    args++;
    writer.visitTypeInsn(Opcodes.NEW,this.type);
    writer.visitInsn(Opcodes.DUP,this.type);
  }
  for (  IValue arg : this.arguments) {
    arg.writeExpression(writer);
  }
  String owner=this.method.getTheClass().getInternalName();
  String name=this.method.getName();
  String desc=this.method.getDescriptor();
  writer.visitMethodInsn(opcode,owner,name,desc,false,args,null);
}","@Override public void writeExpression(MethodWriter writer){
  int opcode;
  int args=this.arguments.size();
  if (this.isCustom) {
    opcode=Opcodes.INVOKESTATIC;
  }
 else {
    opcode=Opcodes.INVOKESPECIAL;
    args++;
    writer.visitTypeInsn(Opcodes.NEW,this.type);
    writer.visitInsn(Opcodes.DUP,this.type);
  }
  for (  IValue arg : this.arguments) {
    arg.writeExpression(writer);
  }
  String owner=this.method.getTheClass().getInternalName();
  String name=""String_Node_Str"";
  String desc=this.method.getDescriptor();
  writer.visitMethodInsn(opcode,owner,name,desc,false,args,null);
}",0.9634551495016612
85323,"@Override public void toString(String prefix,StringBuilder buffer){
  if (this.instance != null) {
    this.instance.toString(""String_Node_Str"",buffer);
    if (this.dotless && !Formatting.Method.useJavaFormat) {
      buffer.append(Formatting.Method.dotlessSeperator);
    }
 else {
      buffer.append('.');
    }
  }
  if (Formatting.Method.convertQualifiedNames) {
    buffer.append(this.qualifiedName);
  }
 else {
    buffer.append(this.name);
  }
  if (this.isSugarCall && !Formatting.Method.useJavaFormat) {
    if (!this.arguments.isEmpty()) {
      buffer.append(Formatting.Method.sugarCallSeperator);
      this.arguments.get(0).toString(""String_Node_Str"",buffer);
    }
  }
 else {
    Util.parametersToString(this.arguments,buffer,true);
  }
}","@Override public void toString(String prefix,StringBuilder buffer){
  if (this.instance != null) {
    this.instance.toString(prefix,buffer);
    if (this.dotless && !Formatting.Method.useJavaFormat) {
      buffer.append(Formatting.Method.dotlessSeperator);
    }
 else {
      buffer.append('.');
    }
  }
  if (Formatting.Method.convertQualifiedNames) {
    buffer.append(this.qualifiedName);
  }
 else {
    buffer.append(this.name);
  }
  if (this.isSugarCall && !Formatting.Method.useJavaFormat) {
    if (!this.arguments.isEmpty()) {
      buffer.append(Formatting.Method.sugarCallSeperator);
      this.arguments.get(0).toString(prefix,buffer);
    }
  }
 else {
    Util.parametersToString(this.arguments,buffer,true);
  }
}",0.9691275167785236
85324,"@Override public void writeSet(MethodWriter writer){
  String owner=this.theClass.getInternalName();
  String name=this.name;
  String desc=this.type.getExtendedName();
  if ((this.modifiers & Modifiers.STATIC) == Modifiers.STATIC) {
    writer.visitPutStatic(owner,name,desc);
  }
 else {
    writer.visitPutStatic(owner,name,desc);
  }
}","@Override public void writeSet(MethodWriter writer){
  String owner=this.theClass.getInternalName();
  String name=this.name;
  String desc=this.type.getExtendedName();
  if ((this.modifiers & Modifiers.STATIC) == Modifiers.STATIC) {
    writer.visitPutStatic(owner,name,desc);
  }
 else {
    writer.visitPutField(owner,name,desc);
  }
}",0.983751846381093
85325,"@Override public String getDescriptor(){
  StringBuilder buf=new StringBuilder();
  buf.append('(');
  for (  Parameter par : this.parameters) {
    buf.append(par.type.getExtendedName());
  }
  buf.append(')');
  buf.append(this.type.getExtendedName());
  return buf.toString();
}","@Override public String getDescriptor(){
  StringBuilder buf=new StringBuilder();
  buf.append('(');
  for (  Parameter par : this.parameters) {
    buf.append(par.type.getExtendedName());
  }
  buf.append(')');
  buf.append(this.isConstructor ? ""String_Node_Str"" : this.type.getExtendedName());
  return buf.toString();
}",0.9320066334991708
85326,"@Override public void write(ClassWriter writer){
  int modifiers=this.modifiers & 0xFFFF;
  if (this.statement == null) {
    modifiers|=Modifiers.ABSTRACT;
  }
  MethodVisitor visitor=writer.visitMethod(modifiers,this.qualifiedName,this.getDescriptor(),this.getSignature(),this.getExceptions());
  MethodWriter mw=new MethodWriter(visitor);
  if (this.isConstructor) {
    mw.setConstructor(this.type);
  }
  for (  Annotation annotation : this.annotations) {
    annotation.write(mw);
  }
  if ((this.modifiers & Modifiers.INLINE) == Modifiers.INLINE) {
    mw.visitAnnotation(""String_Node_Str"",false);
  }
  if ((this.modifiers & Modifiers.IMPLICIT) == Modifiers.IMPLICIT) {
    mw.visitAnnotation(""String_Node_Str"",false);
  }
  if ((this.modifiers & Modifiers.PREFIX) == Modifiers.PREFIX) {
    mw.visitAnnotation(""String_Node_Str"",false);
  }
  if ((this.modifiers & Modifiers.SEALED) == Modifiers.SEALED) {
    mw.visitAnnotation(""String_Node_Str"",false);
  }
  for (  Parameter param : this.parameters) {
    param.write(mw);
  }
  if (this.statement != null) {
    mw.visitCode();
    this.statement.writeExpression(mw);
    mw.visitEnd(this.isConstructor ? Type.VOID : this.type);
  }
}","@Override public void write(ClassWriter writer){
  int modifiers=this.modifiers & 0xFFFF;
  if (this.statement == null) {
    modifiers|=Modifiers.ABSTRACT;
  }
  MethodVisitor visitor=writer.visitMethod(modifiers,this.qualifiedName,this.getDescriptor(),this.getSignature(),this.getExceptions());
  MethodWriter mw=new MethodWriter(visitor);
  if (this.isConstructor) {
    mw.setConstructor(this.type);
  }
  if ((this.modifiers & Modifiers.STATIC) == 0) {
    mw.setInstance(this.type);
  }
  for (  Annotation annotation : this.annotations) {
    annotation.write(mw);
  }
  if ((this.modifiers & Modifiers.INLINE) == Modifiers.INLINE) {
    mw.visitAnnotation(""String_Node_Str"",false);
  }
  if ((this.modifiers & Modifiers.IMPLICIT) == Modifiers.IMPLICIT) {
    mw.visitAnnotation(""String_Node_Str"",false);
  }
  if ((this.modifiers & Modifiers.PREFIX) == Modifiers.PREFIX) {
    mw.visitAnnotation(""String_Node_Str"",false);
  }
  if ((this.modifiers & Modifiers.SEALED) == Modifiers.SEALED) {
    mw.visitAnnotation(""String_Node_Str"",false);
  }
  for (  Parameter param : this.parameters) {
    param.write(mw);
  }
  if (this.statement != null) {
    mw.visitCode();
    this.statement.writeExpression(mw);
    mw.visitEnd(this.isConstructor ? Type.VOID : this.type);
  }
}",0.9656842955187728
85327,"public Method(IClass iclass,String name,IType type,int modifiers,List<Annotation> annotations){
  super(iclass,name,type,modifiers,annotations);
  if (name.equals(""String_Node_Str"")) {
    this.isConstructor=true;
  }
}","public Method(IClass iclass,String name,IType type,int modifiers,List<Annotation> annotations){
  super(iclass,name,type,modifiers,annotations);
  if (name.equals(""String_Node_Str"")) {
    this.isConstructor=true;
    this.qualifiedName=""String_Node_Str"";
  }
}",0.9125
85328,"@Override public default boolean isStatic(){
  return true;
}","@Override public default boolean isStatic(){
  return false;
}",0.943089430894309
85329,"@Override public void writeExpression(MethodWriter writer){
  writer.visitIntInsn(Opcodes.ALOAD,0);
}","@Override public void writeExpression(MethodWriter writer){
  writer.visitVarInsn(Opcodes.ALOAD,0,this.type);
}",0.9245283018867924
85330,"@Override public void resolve(List<Marker> markers,IContext context){
  if ((this.modifiers & Modifiers.STATIC) == 0) {
    IType t=this.theClass.getSuperType();
    if (t != null) {
      IClass iclass=t.getTheClass();
      if (iclass != null) {
        this.overrideMethod=iclass.getBody().getMethod(this.name,this.parameters);
      }
    }
  }
  Iterator<Annotation> iterator=this.annotations.iterator();
  while (iterator.hasNext()) {
    Annotation a=iterator.next();
    if (this.processAnnotation(a)) {
      iterator.remove();
      continue;
    }
    a.resolve(markers,context);
  }
  int index=this.hasModifier(Modifiers.STATIC) ? 0 : 1;
  for (  Parameter p : this.parameters) {
    p.index=index++;
    p.resolve(markers,context);
  }
  for (  Variable v : this.variables) {
    v.index=index++;
    v.resolve(markers,this);
  }
  if (this.statement != null) {
    this.statement=this.statement.resolve(markers,this);
  }
}","@Override public void resolve(List<Marker> markers,IContext context){
  if ((this.modifiers & Modifiers.STATIC) == 0) {
    IType t=this.theClass.getSuperType();
    if (t != null) {
      IClass iclass=t.getTheClass();
      if (iclass != null) {
        this.overrideMethod=iclass.getBody().getMethod(this.name,this.parameters);
      }
    }
  }
  Iterator<Annotation> iterator=this.annotations.iterator();
  while (iterator.hasNext()) {
    Annotation a=iterator.next();
    if (this.processAnnotation(a)) {
      iterator.remove();
      continue;
    }
    a.resolve(markers,context);
  }
  int index=this.hasModifier(Modifiers.STATIC) ? 0 : 1;
  for (  Parameter p : this.parameters) {
    p.index=index++;
    p.resolve(markers,context);
  }
  if (this.statement != null) {
    this.statement=this.statement.resolve(markers,this);
  }
}",0.8698092031425365
85331,"@Override public void write(ClassWriter writer){
  int modifiers=this.modifiers & 0xFFFF;
  if (this.statement == null) {
    modifiers|=Modifiers.ABSTRACT;
  }
  MethodVisitor visitor=writer.visitMethod(modifiers,this.qualifiedName,this.getDescriptor(),this.getSignature(),this.getExceptions());
  MethodWriter mw=new MethodWriter(visitor);
  if (this.isConstructor) {
    mw.setConstructor(this.type);
  }
  for (  Annotation annotation : this.annotations) {
    annotation.write(mw);
  }
  if ((this.modifiers & Modifiers.INLINE) == Modifiers.INLINE) {
    mw.visitAnnotation(""String_Node_Str"",false);
  }
  if ((this.modifiers & Modifiers.IMPLICIT) == Modifiers.IMPLICIT) {
    mw.visitAnnotation(""String_Node_Str"",false);
  }
  if ((this.modifiers & Modifiers.PREFIX) == Modifiers.PREFIX) {
    mw.visitAnnotation(""String_Node_Str"",false);
  }
  if ((this.modifiers & Modifiers.SEALED) == Modifiers.SEALED) {
    mw.visitAnnotation(""String_Node_Str"",false);
  }
  for (  Parameter param : this.parameters) {
    param.write(mw);
  }
  if (this.statement != null) {
    mw.visitCode();
    for (    Variable var : this.variables) {
      mw.visitLocalVariable(var.qualifiedName,var.type,var.start,var.end,var.index);
    }
    this.statement.writeExpression(mw);
    mw.visitEnd(this.isConstructor ? Type.VOID : this.type);
  }
}","@Override public void write(ClassWriter writer){
  int modifiers=this.modifiers & 0xFFFF;
  if (this.statement == null) {
    modifiers|=Modifiers.ABSTRACT;
  }
  MethodVisitor visitor=writer.visitMethod(modifiers,this.qualifiedName,this.getDescriptor(),this.getSignature(),this.getExceptions());
  MethodWriter mw=new MethodWriter(visitor);
  if (this.isConstructor) {
    mw.setConstructor(this.type);
  }
  for (  Annotation annotation : this.annotations) {
    annotation.write(mw);
  }
  if ((this.modifiers & Modifiers.INLINE) == Modifiers.INLINE) {
    mw.visitAnnotation(""String_Node_Str"",false);
  }
  if ((this.modifiers & Modifiers.IMPLICIT) == Modifiers.IMPLICIT) {
    mw.visitAnnotation(""String_Node_Str"",false);
  }
  if ((this.modifiers & Modifiers.PREFIX) == Modifiers.PREFIX) {
    mw.visitAnnotation(""String_Node_Str"",false);
  }
  if ((this.modifiers & Modifiers.SEALED) == Modifiers.SEALED) {
    mw.visitAnnotation(""String_Node_Str"",false);
  }
  for (  Parameter param : this.parameters) {
    param.write(mw);
  }
  if (this.statement != null) {
    mw.visitCode();
    this.statement.writeExpression(mw);
    mw.visitEnd(this.isConstructor ? Type.VOID : this.type);
  }
}",0.9458283906682484
85332,"@Override public void foldConstants(){
  for (  Annotation a : this.annotations) {
    a.foldConstants();
  }
  for (  Parameter p : this.parameters) {
    p.foldConstants();
  }
  for (  Variable v : this.variables) {
    v.foldConstants();
  }
  if (this.statement != null) {
    this.statement=this.statement.foldConstants();
  }
}","@Override public void foldConstants(){
  for (  Annotation a : this.annotations) {
    a.foldConstants();
  }
  for (  Parameter p : this.parameters) {
    p.foldConstants();
  }
  if (this.statement != null) {
    this.statement=this.statement.foldConstants();
  }
}",0.8885191347753744
85333,"@Override public void check(List<Marker> markers,IContext context){
  if ((this.modifiers & Modifiers.STATIC) == 0) {
    if (this.overrideMethod == null) {
      if ((this.modifiers & Modifiers.OVERRIDE) != 0) {
        markers.add(new SemanticError(this.position,""String_Node_Str"" + this.name + ""String_Node_Str""));
      }
    }
 else     if (!this.isConstructor) {
      if ((this.modifiers & Modifiers.OVERRIDE) == 0) {
        markers.add(new SemanticError(this.position,""String_Node_Str"" + this.name + ""String_Node_Str""));
      }
 else       if (this.overrideMethod.hasModifier(Modifiers.FINAL)) {
        markers.add(new SemanticError(this.position,""String_Node_Str"" + this.name + ""String_Node_Str""));
      }
 else {
        IType type=this.overrideMethod.getType();
        if (!Type.isSuperType(type,this.type)) {
          SemanticError error=new SemanticError(this.position,""String_Node_Str"" + this.name + ""String_Node_Str"");
          error.addInfo(""String_Node_Str"" + this.type);
          error.addInfo(""String_Node_Str"" + type);
          markers.add(error);
        }
      }
    }
  }
  for (  Annotation a : this.annotations) {
    a.check(markers,context);
  }
  for (  Parameter p : this.parameters) {
    p.check(markers,context);
  }
  for (  Variable v : this.variables) {
    v.check(markers,context);
  }
  if (this.statement != null) {
    if (this.isConstructor) {
      if (!this.statement.requireType(Type.VOID)) {
        SemanticError error=new SemanticError(this.position,""String_Node_Str"");
        error.addInfo(""String_Node_Str"" + this.statement.getType());
        markers.add(error);
      }
    }
 else     if (!this.statement.requireType(this.type)) {
      SemanticError error=new SemanticError(this.position,""String_Node_Str"" + this.name + ""String_Node_Str"");
      error.addInfo(""String_Node_Str"" + this.type);
      error.addInfo(""String_Node_Str"" + this.statement.getType());
      markers.add(error);
    }
    this.statement.check(markers,context);
  }
 else   if (this.isStatic()) {
    markers.add(new SemanticError(this.position,""String_Node_Str"" + this.name + ""String_Node_Str""));
  }
 else   if ((this.modifiers & Modifiers.ABSTRACT) == 0) {
    if (this.theClass.isAbstract()) {
      this.modifiers|=Modifiers.ABSTRACT;
    }
 else {
      markers.add(new SemanticError(this.position,""String_Node_Str"" + this.name + ""String_Node_Str""));
    }
  }
}","@Override public void check(List<Marker> markers,IContext context){
  if ((this.modifiers & Modifiers.STATIC) == 0) {
    if (this.overrideMethod == null) {
      if ((this.modifiers & Modifiers.OVERRIDE) != 0) {
        markers.add(new SemanticError(this.position,""String_Node_Str"" + this.name + ""String_Node_Str""));
      }
    }
 else     if (!this.isConstructor) {
      if ((this.modifiers & Modifiers.OVERRIDE) == 0) {
        markers.add(new SemanticError(this.position,""String_Node_Str"" + this.name + ""String_Node_Str""));
      }
 else       if (this.overrideMethod.hasModifier(Modifiers.FINAL)) {
        markers.add(new SemanticError(this.position,""String_Node_Str"" + this.name + ""String_Node_Str""));
      }
 else {
        IType type=this.overrideMethod.getType();
        if (!Type.isSuperType(type,this.type)) {
          SemanticError error=new SemanticError(this.position,""String_Node_Str"" + this.name + ""String_Node_Str"");
          error.addInfo(""String_Node_Str"" + this.type);
          error.addInfo(""String_Node_Str"" + type);
          markers.add(error);
        }
      }
    }
  }
  for (  Annotation a : this.annotations) {
    a.check(markers,context);
  }
  for (  Parameter p : this.parameters) {
    p.check(markers,context);
  }
  if (this.statement != null) {
    if (this.isConstructor) {
      if (!this.statement.requireType(Type.VOID)) {
        SemanticError error=new SemanticError(this.position,""String_Node_Str"");
        error.addInfo(""String_Node_Str"" + this.statement.getType());
        markers.add(error);
      }
    }
 else     if (!this.statement.requireType(this.type)) {
      SemanticError error=new SemanticError(this.position,""String_Node_Str"" + this.name + ""String_Node_Str"");
      error.addInfo(""String_Node_Str"" + this.type);
      error.addInfo(""String_Node_Str"" + this.statement.getType());
      markers.add(error);
    }
    this.statement.check(markers,context);
  }
 else   if (this.isStatic()) {
    markers.add(new SemanticError(this.position,""String_Node_Str"" + this.name + ""String_Node_Str""));
  }
 else   if ((this.modifiers & Modifiers.ABSTRACT) == 0) {
    if (this.theClass.isAbstract()) {
      this.modifiers|=Modifiers.ABSTRACT;
    }
 else {
      markers.add(new SemanticError(this.position,""String_Node_Str"" + this.name + ""String_Node_Str""));
    }
  }
}",0.984368398817068
85334,"@Override public void writeStatement(MethodWriter writer){
  if (this.isArray) {
    super.writeExpression(writer);
    return;
  }
  writer.visitLabel(this.start);
  for (  IValue v : this.values) {
    v.writeStatement(writer);
  }
  writer.visitLabel(this.end);
}","@Override public void writeStatement(MethodWriter writer){
  if (this.isArray) {
    super.writeExpression(writer);
    return;
  }
  writer.visitLabel(this.start);
  for (  IValue v : this.values) {
    v.writeStatement(writer);
  }
  writer.visitLabel(this.end);
  for (  Entry<String,Variable> entry : this.variables.entrySet()) {
    Variable var=entry.getValue();
    writer.visitLocalVariable(entry.getKey(),var.type,this.start,this.end,var.index);
  }
}",0.7327823691460055
85335,"@Override public void resolveTypes(List<Marker> markers,IContext context){
  this.context=context;
  IVariableList variableList=context instanceof IVariableList ? (IVariableList)context : null;
  for (  IValue v : this.values) {
    v.resolveTypes(markers,context);
    if (v.getValueType() != IValue.FIELD_ASSIGN) {
      continue;
    }
    FieldAssign assign=(FieldAssign)v;
    if (!assign.initializer) {
      continue;
    }
    Variable var=(Variable)assign.field;
    var.start=this.start;
    var.end=this.end;
    this.variables.put(assign.qualifiedName,var);
    if (variableList != null) {
      variableList.addVariable(var);
    }
  }
}","@Override public void resolveTypes(List<Marker> markers,IContext context){
  this.context=context;
  this.variableCount=context.getVariableCount();
  for (  IValue v : this.values) {
    if (v.getValueType() == IValue.FIELD_ASSIGN) {
      FieldAssign assign=(FieldAssign)v;
      if (assign.initializer) {
        Variable var=(Variable)assign.field;
        var.index=this.variableCount++;
        this.variables.put(assign.qualifiedName,var);
      }
    }
    v.resolveTypes(markers,this);
  }
}",0.288946910356832
85336,"@Override public void check(List<Marker> markers,IContext context){
  if (this.condition != null) {
    if (this.condition.requireType(Type.BOOLEAN)) {
      SemanticError error=new SemanticError(this.condition.getPosition(),""String_Node_Str"");
      error.addInfo(""String_Node_Str"" + this.condition.getType());
      markers.add(error);
    }
    this.condition.check(markers,context);
  }
 else {
    markers.add(new SyntaxError(this.position,""String_Node_Str""));
  }
  if (this.then != null) {
    this.then.check(markers,context);
  }
}","@Override public void check(List<Marker> markers,IContext context){
  if (this.condition != null) {
    if (!this.condition.requireType(Type.BOOLEAN)) {
      SemanticError error=new SemanticError(this.condition.getPosition(),""String_Node_Str"");
      error.addInfo(""String_Node_Str"" + this.condition.getType());
      markers.add(error);
    }
    this.condition.check(markers,context);
  }
 else {
    markers.add(new SyntaxError(this.position,""String_Node_Str""));
  }
  if (this.then != null) {
    this.then.check(markers,context);
  }
}",0.9990749306197964
85337,"public void log(Logger logger){
  StringBuilder buf=new StringBuilder();
  CodeFile file=this.position.getFile();
  String type=this.getMarkerType();
  String message=this.getMessage();
  String suggestion=this.getSuggestion();
  buf.append(file).append(':').append(this.position.getLineNumber()).append(""String_Node_Str"");
  buf.append(type);
  if (message != null) {
    buf.append(""String_Node_Str"").append(message);
  }
  if (suggestion != null) {
    buf.append(""String_Node_Str"").append(suggestion);
  }
  int prevNL=this.position.getPrevNewline();
  int nextNL=this.position.getNextNewline();
  String code=file.getCode();
  String line=code.substring(prevNL,nextNL);
  buf.append('\n').append(line).append('\n');
  for (int i=prevNL; i < this.position.getStart(); i++) {
    char c=code.charAt(i);
    if (c == '\t') {
      buf.append('\t');
    }
 else {
      buf.append(' ');
    }
  }
  buf.append('^');
  if (this.info != null) {
    buf.append('\n');
    for (    String s : this.info) {
      buf.append('\n').append(s);
    }
  }
  logger.info(buf.toString());
}","public void log(Logger logger){
  StringBuilder buf=new StringBuilder();
  CodeFile file=this.position.getFile();
  String type=this.getMarkerType();
  String message=this.getMessage();
  String suggestion=this.getSuggestion();
  buf.append(file).append(':').append(this.position.getLineNumber()).append(""String_Node_Str"");
  buf.append(type);
  if (message != null) {
    buf.append(""String_Node_Str"").append(message);
  }
  if (suggestion != null) {
    buf.append(""String_Node_Str"").append(suggestion);
  }
  int prevNL=this.position.getPrevNewline();
  int nextNL=this.position.getNextNewline();
  String code=file.getCode();
  String line=code.substring(prevNL,nextNL);
  buf.append('\n').append(line).append('\n');
  for (int i=prevNL; i < this.position.getStart(); i++) {
    char c=code.charAt(i);
    if (c == '\t') {
      buf.append('\t');
    }
 else {
      buf.append(' ');
    }
  }
  buf.append('^');
  if (this.info != null) {
    for (    String s : this.info) {
      buf.append(""String_Node_Str"").append(s);
    }
    buf.append('\n');
  }
  logger.info(buf.toString());
}",0.8963611239060341
85338,"public static void main(String[] args){
  for (int i=1; i < args.length; i++) {
    addStates(args[i]);
  }
  long now=System.nanoTime();
  initLogger();
  parser.parse(new CodeFile(args[0]),new ConfigParser(config));
  File sourceDir=config.sourceDir;
  File outputDir=config.outputDir;
  Package root=Package.rootPackage;
  int states=DyvilCompiler.states.size();
  int libs=config.libraries.size();
  logger.info(""String_Node_Str"" + sourceDir.getAbsolutePath() + ""String_Node_Str""+ outputDir.getAbsolutePath());
  if (debug) {
    logger.info(""String_Node_Str"" + states + (states == 1 ? ""String_Node_Str"" : ""String_Node_Str"")+ DyvilCompiler.states);
  }
  if (DyvilCompiler.states.contains(CompilerState.RESOLVE_TYPES)) {
    for (    Library library : config.libraries) {
      library.loadLibrary();
    }
    Type.init();
    Util.logProfile(now,libs,""String_Node_Str"" + libs + (libs == 1 ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
  }
  now=System.nanoTime();
  for (  String s : sourceDir.list()) {
    findUnits(new CodeFile(sourceDir,s),new File(outputDir,s),Package.rootPackage);
  }
  int units=root.units.size();
  int packages=root.subPackages.size();
  logger.info(""String_Node_Str"" + packages + (packages == 1 ? ""String_Node_Str"" : ""String_Node_Str"")+ units+ (units == 1 ? ""String_Node_Str"" : ""String_Node_Str""));
  logger.info(""String_Node_Str"");
  for (  CompilerState state : DyvilCompiler.states) {
    CompilerState.applyState(state,root.units);
  }
  logger.info(""String_Node_Str"");
  Util.logProfile(now,units,""String_Node_Str"");
}","public static void main(String[] args){
  for (int i=1; i < args.length; i++) {
    addStates(args[i]);
  }
  long now=System.nanoTime();
  initLogger();
  parser.parse(new CodeFile(args[0]),new ConfigParser(config));
  File sourceDir=config.sourceDir;
  File outputDir=config.outputDir;
  Package root=Package.rootPackage;
  int states=DyvilCompiler.states.size();
  int libs=config.libraries.size();
  logger.info(""String_Node_Str"" + sourceDir.getAbsolutePath() + ""String_Node_Str""+ outputDir.getAbsolutePath());
  if (debug) {
    logger.info(""String_Node_Str"" + states + (states == 1 ? ""String_Node_Str"" : ""String_Node_Str"")+ DyvilCompiler.states);
  }
  if (DyvilCompiler.states.contains(CompilerState.RESOLVE_TYPES)) {
    for (    Library library : config.libraries) {
      library.loadLibrary();
    }
    Package.init();
    Type.init();
    Util.logProfile(now,libs,""String_Node_Str"" + libs + (libs == 1 ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
  }
  now=System.nanoTime();
  for (  String s : sourceDir.list()) {
    findUnits(new CodeFile(sourceDir,s),new File(outputDir,s),Package.rootPackage);
  }
  int units=root.units.size();
  int packages=root.subPackages.size();
  logger.info(""String_Node_Str"" + packages + (packages == 1 ? ""String_Node_Str"" : ""String_Node_Str"")+ units+ (units == 1 ? ""String_Node_Str"" : ""String_Node_Str""));
  logger.info(""String_Node_Str"");
  for (  CompilerState state : DyvilCompiler.states) {
    CompilerState.applyState(state,root.units);
  }
  logger.info(""String_Node_Str"");
  Util.logProfile(now,units,""String_Node_Str"");
}",0.9936828806064436
85339,"@Override public void checkArguments(List<Marker> markers,IValue instance,List<IValue> arguments){
  int pOff=0;
  int len=arguments.size();
  List<Parameter> params=this.parameters;
  Parameter par;
  IType parType;
  if (instance != null && (this.modifiers & Modifiers.IMPLICIT) == Modifiers.IMPLICIT) {
    par=params.get(0);
    parType=par.type;
    if (!instance.requireType(parType)) {
      markers.add(new SemanticError(instance.getPosition(),""String_Node_Str"" + par.name + ""String_Node_Str""+ parType));
    }
    pOff=1;
  }
  for (int i=0; i < len; i++) {
    par=params.get(i + pOff);
    parType=par.type;
    IValue value=arguments.get(i);
    if (!value.requireType(parType)) {
      markers.add(new SemanticError(value.getPosition(),""String_Node_Str"" + par.name + ""String_Node_Str""+ parType));
    }
  }
}","@Override public void checkArguments(List<Marker> markers,IValue instance,List<IValue> arguments){
  int pOff=0;
  int len=arguments.size();
  List<Parameter> params=this.parameters;
  Parameter par;
  IType parType;
  if (instance != null && (this.modifiers & Modifiers.IMPLICIT) == Modifiers.IMPLICIT) {
    par=params.get(0);
    parType=par.type;
    if (!instance.requireType(parType)) {
      markers.add(new SemanticError(instance.getPosition(),""String_Node_Str"" + par.name + ""String_Node_Str""+ instance.getType()+ ""String_Node_Str""+ parType));
    }
    pOff=1;
  }
  for (int i=0; i < len; i++) {
    par=params.get(i + pOff);
    parType=par.type;
    IValue value=arguments.get(i);
    if (!value.requireType(parType)) {
      markers.add(new SemanticError(value.getPosition(),""String_Node_Str"" + par.name + ""String_Node_Str""+ value.getType()+ ""String_Node_Str""+ parType));
    }
  }
}",0.9563191613278976
85340,"@Override public Type resolve(IContext context){
  int len=this.types.size();
  for (int i=0; i < len; i++) {
    IType t1=this.types.get(i);
    IType t2=t1.resolve(context);
    if (t1 != t2) {
      this.types.set(i,t2);
    }
  }
  return this;
}","@Override public TupleType resolve(IContext context){
  this.getTheClass();
  int len=this.types.size();
  for (int i=0; i < len; i++) {
    IType t1=this.types.get(i);
    IType t2=t1.resolve(context);
    if (t1 != t2) {
      this.types.set(i,t2);
    }
  }
  return this;
}",0.9487666034155596
85341,"protected static Type resolvePrimitive(String name){
switch (name) {
case ""String_Node_Str"":
    return VOID;
case ""String_Node_Str"":
  return BOOLEAN;
case ""String_Node_Str"":
return CHAR;
case ""String_Node_Str"":
return BYTE;
case ""String_Node_Str"":
return SHORT;
case ""String_Node_Str"":
return INT;
case ""String_Node_Str"":
return LONG;
case ""String_Node_Str"":
return FLOAT;
case ""String_Node_Str"":
return DOUBLE;
case ""String_Node_Str"":
case ""String_Node_Str"":
return STRING;
}
return null;
}","protected static Type resolvePrimitive(String name){
switch (name) {
case ""String_Node_Str"":
    return VOID;
case ""String_Node_Str"":
  return BOOLEAN;
case ""String_Node_Str"":
return CHAR;
case ""String_Node_Str"":
return BYTE;
case ""String_Node_Str"":
return SHORT;
case ""String_Node_Str"":
return INT;
case ""String_Node_Str"":
return LONG;
case ""String_Node_Str"":
return FLOAT;
case ""String_Node_Str"":
return DOUBLE;
case ""String_Node_Str"":
case ""String_Node_Str"":
return STRING;
case ""String_Node_Str"":
case ""String_Node_Str"":
return ANY;
}
return null;
}",0.9426386233269598
85342,"@Override public void resolveTypes(List<Marker> markers,IContext context){
  this.getType();
}","@Override public void resolveTypes(List<Marker> markers,IContext context){
  TupleType type=new TupleType();
  for (  IValue v : this.values) {
    v.resolveTypes(markers,context);
    type.addType(v.getType());
  }
  type.getTheClass();
  this.tupleType=type;
}",0.5168539325842697
85343,"public static IAccess resolve(List<Marker> markers,IContext context,IAccess access){
  LinkedList<IAccess> chain=getCallChain(access);
  ListIterator<IAccess> iterator=chain.listIterator();
  IContext context1=context;
  IAccess prev=null;
  IAccess curr=null;
  boolean backwards=false;
  while (iterator.hasNext()) {
    prev=curr;
    curr=iterator.next();
    if (prev != null) {
      context1=prev.getType();
      curr.setValue(prev);
    }
 else {
      IValue value=curr.getValue();
      if (value != null) {
        context1=value.getType();
      }
    }
    if (context1 == null) {
      backwards=true;
      break;
    }
    if (!curr.resolve(context1,context)) {
      IAccess alternate=curr.resolve2(context1,context);
      if (alternate == null) {
        backwards=true;
      }
 else {
        curr=alternate;
        iterator.set(alternate);
      }
    }
  }
  if (!backwards) {
    return chain.getLast();
  }
 else   if (chain.size() == 1) {
    markers.add(access.getResolveError());
    return access;
  }
  IAccess next=null;
  curr=access;
  prev=null;
  while (true) {
    IValue value=curr.getValue();
    if (value instanceof IAccess) {
      prev=(IAccess)value;
    }
 else {
      break;
    }
    context1=value.getType();
    if (context1 == null) {
      context1=context;
    }
    if (!curr.resolve(context1,context)) {
      curr.setValue(null);
      if (curr.resolve(context,null)) {
        prev.addValue(curr);
        curr=null;
        iterator.remove();
      }
 else {
        curr.setValue(value);
        markers.add(curr.getResolveError());
      }
    }
    next=curr;
    curr=prev;
  }
  return chain.getLast();
}","public static IAccess resolve(List<Marker> markers,IContext context,IAccess access){
  LinkedList<IAccess> chain=getCallChain(markers,context,access);
  ListIterator<IAccess> iterator=chain.listIterator();
  IContext context1=context;
  IAccess prev=null;
  IAccess curr=null;
  boolean backwards=false;
  while (iterator.hasNext()) {
    prev=curr;
    curr=iterator.next();
    if (prev != null) {
      context1=prev.getType();
      curr.setValue(prev);
    }
 else {
      IValue value=curr.getValue();
      if (value != null) {
        context1=value.getType();
      }
    }
    if (context1 == null) {
      backwards=true;
      break;
    }
    if (!curr.resolve(context1,context)) {
      IAccess alternate=curr.resolve2(context1,context);
      if (alternate == null) {
        backwards=true;
      }
 else {
        curr=alternate;
        iterator.set(alternate);
      }
    }
  }
  if (!backwards) {
    return chain.getLast();
  }
 else   if (chain.size() == 1) {
    markers.add(access.getResolveError());
    return access;
  }
  IAccess next=null;
  curr=access;
  prev=null;
  while (true) {
    IValue value=curr.getValue();
    if (value instanceof IAccess) {
      prev=(IAccess)value;
    }
 else {
      break;
    }
    context1=value.getType();
    if (context1 == null) {
      context1=context;
    }
    if (!curr.resolve(context1,context)) {
      curr.setValue(null);
      if (curr.resolve(context,null)) {
        prev.addValue(curr);
        curr=null;
        iterator.remove();
      }
 else {
        curr.setValue(value);
        markers.add(curr.getResolveError());
      }
    }
    next=curr;
    curr=prev;
  }
  return chain.getLast();
}",0.9952267303102624
85344,"public static LinkedList<IAccess> getCallChain(IAccess iaccess){
  LinkedList<IAccess> list=new LinkedList();
  while (true) {
    list.addFirst(iaccess);
    IValue v=iaccess.getValue();
    if (v instanceof IAccess) {
      iaccess=(IAccess)v;
      continue;
    }
    break;
  }
  return list;
}","public static LinkedList<IAccess> getCallChain(List<Marker> markers,IContext context,IAccess iaccess){
  LinkedList<IAccess> list=new LinkedList();
  while (true) {
    list.addFirst(iaccess);
    IValue v=iaccess.getValue();
    if (v instanceof IAccess) {
      iaccess=(IAccess)v;
      continue;
    }
 else     if (v != null) {
      v.resolve(markers,context);
    }
    break;
  }
  return list;
}",0.8506401137980085
85345,public boolean resolve(IContext context);,"public boolean resolve(IContext context,List<Marker> markers);",0.7961165048543689
85346,"public default int getTypeMatch(IType type){
  IType t=this.getType();
  if (type.equals(t)) {
    return 3;
  }
 else   if (Type.isSuperType(type,t)) {
    return 2;
  }
 else   if (type.classEquals(Type.OBJECT)) {
    return 1;
  }
  return 0;
}","public default int getTypeMatch(IType type){
  IType t=this.getType();
  if (t == null) {
    return 0;
  }
  if (type.equals(t)) {
    return 3;
  }
 else   if (Type.isSuperType(type,t)) {
    return 2;
  }
 else   if (type.classEquals(Type.OBJECT)) {
    return 1;
  }
  return 0;
}",0.9303201506591338
85347,"@Override public boolean resolve(IContext context){
  return this.type.isResolved();
}","@Override public boolean resolve(IContext context,List<Marker> markers){
  return this.type.isResolved();
}",0.8911917098445595
85348,"@Override public boolean resolve(IContext context){
  if (!this.type.isResolved()) {
    return false;
  }
  MethodMatch match=this.type.resolveMethod(null,""String_Node_Str"",this.arguments);
  if (match != null) {
    this.method=match.theMethod;
    this.isCustom=true;
    return true;
  }
  match=this.type.resolveMethod(null,""String_Node_Str"",this.arguments);
  if (match != null) {
    this.method=match.theMethod;
    return true;
  }
  return false;
}","@Override public boolean resolve(IContext context,List<Marker> markers){
  if (!this.type.isResolved()) {
    return false;
  }
  MethodMatch match=this.type.resolveMethod(null,""String_Node_Str"",this.arguments);
  if (match != null) {
    this.method=match.theMethod;
    this.isCustom=true;
    return true;
  }
  match=this.type.resolveMethod(null,""String_Node_Str"",this.arguments);
  if (match != null) {
    this.method=match.theMethod;
    return true;
  }
  return false;
}",0.9775880469583778
85349,"@Override public boolean resolve(IContext context){
  IField field=IAccess.resolveField(context,this.instance,this.qualifiedName);
  if (field != null) {
    this.field=field;
    return true;
  }
  return false;
}","@Override public boolean resolve(IContext context,List<Marker> markers){
  IField field=IAccess.resolveField(context,this.instance,this.qualifiedName);
  if (field != null) {
    this.field=field;
    return true;
  }
  return false;
}",0.9532293986636972
85350,"@Override public IAccess resolve2(IContext context){
  if (this.isSugarCall) {
    if (this.arguments.isEmpty()) {
      IField field=IAccess.resolveField(context,this.instance,this.qualifiedName);
      if (field != null) {
        FieldAccess access=new FieldAccess(this.position);
        access.field=field;
        access.instance=this.instance;
        access.name=this.name;
        access.qualifiedName=this.qualifiedName;
        access.dotless=this.dotless;
        return access;
      }
    }
  }
 else   if (this.instance == null) {
    FieldMatch field=context.resolveField(this.qualifiedName);
    if (field != null) {
      FieldAccess access=new FieldAccess(this.position);
      access.field=field.theField;
      access.name=this.name;
      access.qualifiedName=this.qualifiedName;
      access.dotless=this.dotless;
      MethodCall call=new MethodCall(this.position,access,""String_Node_Str"");
      call.arguments=this.arguments;
      if (call.resolve(field.theField.getType())) {
        return call;
      }
    }
  }
  return null;
}","@Override public IAccess resolve2(IContext context){
  if (this.isSugarCall) {
    if (this.arguments.isEmpty()) {
      IField field=IAccess.resolveField(context,this.instance,this.qualifiedName);
      if (field != null) {
        FieldAccess access=new FieldAccess(this.position);
        access.field=field;
        access.instance=this.instance;
        access.name=this.name;
        access.qualifiedName=this.qualifiedName;
        access.dotless=this.dotless;
        return access;
      }
    }
  }
 else   if (this.instance == null) {
    FieldMatch field=context.resolveField(this.qualifiedName);
    if (field != null) {
      FieldAccess access=new FieldAccess(this.position);
      access.field=field.theField;
      access.name=this.name;
      access.qualifiedName=this.qualifiedName;
      access.dotless=this.dotless;
      MethodCall call=new MethodCall(this.position,access,""String_Node_Str"");
      call.arguments=this.arguments;
      if (call.resolve(field.theField.getType(),null)) {
        return call;
      }
    }
  }
  return null;
}",0.9976448422044276
85351,"@Override public boolean resolve(IContext context){
  IMethod method=IAccess.resolveMethod(context,this.instance,this.qualifiedName,this.arguments);
  if (method != null) {
    this.method=method;
    return true;
  }
  return false;
}","@Override public boolean resolve(IContext context,List<Marker> markers){
  int len=this.arguments.size();
  for (int i=0; i < len; i++) {
    IValue v1=this.arguments.get(i);
    IValue v2=v1.resolve(markers,context);
    if (v1 != v2) {
      this.arguments.set(i,v2);
    }
  }
  IMethod method=IAccess.resolveMethod(context,this.instance,this.qualifiedName,this.arguments);
  if (method != null) {
    this.method=method;
    return true;
  }
  return false;
}",0.673352435530086
85352,"private void generateTypes(){
  int len=this.values.size();
  if (len == 0) {
    this.elementType=Type.VOID;
    this.requiredType=Type.VOID;
    return;
  }
  IType t=this.values.get(0).getType();
  for (int i=1; i < len; i++) {
    IValue v=this.values.get(i);
    t=Type.findCommonSuperType(t,v.getType());
  }
  if (t != null) {
    this.elementType=t;
    this.requiredType=t.clone();
    this.requiredType.addArrayDimension();
  }
}","private void generateTypes(){
  int len=this.values.size();
  if (len == 0) {
    this.elementType=Type.VOID;
    this.requiredType=Type.VOID;
    return;
  }
  IType t=this.values.get(0).getType();
  for (int i=1; i < len; i++) {
    IValue v=this.values.get(i);
    IType t1=v.getType();
    if (t1 == null) {
      t=Type.VOID;
      break;
    }
    t=Type.findCommonSuperType(t,t1);
  }
  if (t != null) {
    this.elementType=t;
    this.requiredType=t.clone();
    this.requiredType.addArrayDimension();
  }
}",0.8963350785340314
85353,"@Override public boolean resolve(IContext context){
  IField field=IAccess.resolveField(context,this.instance,this.qualifiedName);
  if (field != null) {
    this.field=field;
    return true;
  }
  return false;
}","@Override public boolean resolve(IContext context,List<Marker> markers){
  IField field=IAccess.resolveField(context,this.instance,this.qualifiedName);
  if (field != null) {
    this.field=field;
    return true;
  }
  return false;
}",0.9532293986636972
85354,"public static IAccess resolve(List<Marker> markers,IContext context,IAccess access){
  LinkedList<IAccess> chain=getCallChain(markers,context,access);
  ListIterator<IAccess> iterator=chain.listIterator();
  IAccess prev=null;
  IAccess curr=null;
  IAccess alternate=null;
  boolean backwards=false;
  while (iterator.hasNext()) {
    prev=curr;
    curr=iterator.next();
    if (alternate != null) {
      curr.setValue(alternate);
      alternate=null;
    }
    if (!curr.resolve(context)) {
      alternate=curr.resolve2(context);
      if (alternate == null) {
        backwards=true;
      }
 else {
        curr=alternate;
        iterator.set(alternate);
      }
    }
  }
  if (!backwards) {
    return chain.getLast();
  }
 else   if (chain.size() == 1) {
    markers.add(access.getResolveError());
    return access;
  }
  IAccess next=null;
  curr=access;
  prev=null;
  while (true) {
    IValue value=curr.getValue();
    if (value instanceof IAccess) {
      prev=(IAccess)value;
    }
 else {
      break;
    }
    if (!curr.resolve(context)) {
      curr.setValue(null);
      if (curr.resolve(context)) {
        prev.addValue(curr);
        curr=null;
        iterator.remove();
      }
 else {
        curr.setValue(value);
        markers.add(curr.getResolveError());
      }
    }
    next=curr;
    curr=prev;
  }
  return chain.getLast();
}","public static IAccess resolve(List<Marker> markers,IContext context,IAccess access){
  LinkedList<IAccess> chain=getCallChain(markers,context,access);
  ListIterator<IAccess> iterator=chain.listIterator();
  IAccess prev=null;
  IAccess curr=null;
  IAccess alternate=null;
  boolean backwards=false;
  while (iterator.hasNext()) {
    prev=curr;
    curr=iterator.next();
    if (alternate != null) {
      curr.setValue(alternate);
      alternate=null;
    }
    if (!curr.resolve(context,markers)) {
      alternate=curr.resolve2(context);
      if (alternate == null) {
        backwards=true;
        break;
      }
 else {
        curr=alternate;
        iterator.set(alternate);
      }
    }
  }
  if (!backwards) {
    return chain.getLast();
  }
 else   if (chain.size() == 1) {
    markers.add(access.getResolveError());
    return access;
  }
  IAccess next=null;
  curr=access;
  prev=null;
  while (true) {
    IValue value=curr.getValue();
    if (value instanceof IAccess) {
      prev=(IAccess)value;
    }
 else {
      if (!curr.resolve(context,markers)) {
        markers.add(curr.getResolveError());
      }
      break;
    }
    if (!curr.resolve(context,null)) {
      curr.setValue(null);
      if (curr.resolve(context,markers)) {
        prev.addValue(curr);
        curr=null;
        iterator.remove();
      }
 else {
        curr.setValue(value);
        markers.add(curr.getResolveError());
      }
    }
    next=curr;
    curr=prev;
  }
  return chain.getLast();
}",0.9535776614310646
85355,"@Override public IClass resolveClass(String name){
  for (  ITypeVariable var : this.generics) {
    if (var.isName(name)) {
      return var.getTheClass();
    }
  }
  return this.unit.resolveClass(name);
}","@Override public IClass resolveClass(String name){
  if (this.generics != null) {
    for (    ITypeVariable var : this.generics) {
      if (var.isName(name)) {
        return var.getTheClass();
      }
    }
  }
  return this.unit.resolveClass(name);
}",0.8980477223427332
85356,"@Override public boolean resolve(IContext context,IContext context1){
  if (this.field != null) {
    return true;
  }
  FieldMatch f=context.resolveField(context1,this.qualifiedName);
  if (f != null) {
    this.field=f.theField;
    return true;
  }
  return false;
}","@Override public boolean resolve(IContext context,IContext context1){
  FieldMatch f=context.resolveField(context1,this.qualifiedName);
  if (f != null) {
    this.field=f.theField;
    return true;
  }
  return false;
}",0.4458077709611452
85357,"@Override public boolean resolve(IContext context,IContext context1){
  if (this.method != null) {
    return true;
  }
  IType[] types=this.getTypes();
  if (types == null) {
    return false;
  }
  MethodMatch match=context.resolveMethod(context1,this.qualifiedName,types);
  if (match != null) {
    this.method=match.theMethod;
    return true;
  }
  return false;
}","@Override public boolean resolve(IContext context,IContext context1){
  IType[] types=this.getTypes();
  if (types == null) {
    return false;
  }
  MethodMatch match=context.resolveMethod(context1,this.qualifiedName,types);
  if (match != null) {
    this.method=match.theMethod;
    return true;
  }
  return false;
}",0.927536231884058
85358,"@Override public void resolveTypes(List<Marker> markers,IContext context){
  this.context=context;
  IVariableList variableList=context instanceof IVariableList ? (IVariableList)context : null;
  for (  IValue v : this.values) {
    if (!(v instanceof FieldAssign)) {
      continue;
    }
    FieldAssign assign=(FieldAssign)v;
    if (!assign.initializer) {
      continue;
    }
    Variable var=(Variable)assign.field;
    var.start=this.start;
    var.end=this.end;
    this.variables.put(assign.qualifiedName,assign.field);
    if (variableList != null) {
      variableList.addVariable(var);
    }
  }
}","@Override public void resolveTypes(List<Marker> markers,IContext context){
  this.context=context;
  IVariableList variableList=context instanceof IVariableList ? (IVariableList)context : null;
  for (  IValue v : this.values) {
    v.resolveTypes(markers,context);
    if (!(v instanceof FieldAssign)) {
      continue;
    }
    FieldAssign assign=(FieldAssign)v;
    if (!assign.initializer) {
      continue;
    }
    Variable var=(Variable)assign.field;
    var.start=this.start;
    var.end=this.end;
    this.variables.put(assign.qualifiedName,assign.field);
    if (variableList != null) {
      variableList.addVariable(var);
    }
  }
}",0.9705648369132855
85359,"private Token addToken(Token prev,StringBuilder buf,int type,int line,int start,int end){
  String s=buf.toString();
  buf.delete(0,buf.length());
  return this.addToken(prev,s,type,line,start,end);
}","private Token addToken(Token prev,StringBuilder buf,int type,int line,int start){
  String s=buf.toString();
  int len=buf.length();
  buf.delete(0,len);
  return this.addToken(prev,s,type,line,start,len);
}",0.8108108108108109
85360,"public void tokenize(){
  String code=this.file.getCode();
  int len=code.length();
  StringBuilder buf=new StringBuilder(20);
  Token first=new Token(-1,""String_Node_Str"",(byte)0,null,null,0,-1,-1);
  Token prev=first;
  int start=0;
  int lineNumber=1;
  int i;
  char l=0;
  char c=0;
  int type=0;
  int subtype=0;
  boolean addToken=false;
  boolean reparse=true;
  for (i=0; i < len; ++i, l=c) {
    c=code.charAt(i);
    if (c == '\n') {
      lineNumber++;
    }
    if (type == 0) {
      start=i;
      if (isWhitespace(c)) {
        continue;
      }
      int m=getMode(c,code,i);
      type=m & 0xFFFF;
      subtype=m & 0xFFFF0000;
    }
    if (type == TYPE_IDENTIFIER) {
      if (subtype == MOD_DOTS) {
        if (c == '.') {
          buf.append(c);
        }
 else {
          addToken=true;
          reparse=true;
        }
      }
 else       if (c == '_' || c == '$' || c == '@') {
        subtype=MOD_SYMBOL | MOD_LETTER;
        buf.append(c);
      }
 else {
        boolean letter=(subtype & MOD_LETTER) != 0;
        boolean symbol=(subtype & MOD_SYMBOL) != 0;
        if (letter) {
          if (isIdentifierPart(c)) {
            subtype=MOD_LETTER;
            buf.append(c);
            continue;
          }
        }
        if (symbol) {
          if (isIdentifierSymbol(c)) {
            subtype=MOD_SYMBOL;
            buf.append(c);
            continue;
          }
        }
        addToken=true;
      }
    }
 else     if (type == TYPE_SYMBOL) {
      buf.append(c);
      addToken=true;
      reparse=false;
    }
 else     if (type == TYPE_BRACKET) {
      buf.append(c);
      addToken=true;
      reparse=false;
    }
 else     if (type == TYPE_COMMENT) {
      if (subtype == MOD_LINE) {
        if (c == '\n') {
          type=0;
          continue;
        }
      }
 else       if (subtype == MOD_BLOCK) {
        if (l == '*' && c == '/') {
          type=0;
          continue;
        }
      }
    }
 else     if (type == TYPE_INT || type == TYPE_LONG) {
      if (c == '.') {
        type=TYPE_FLOAT;
        buf.append('.');
      }
 else       if (c == 'l' || c == 'L') {
        type=TYPE_LONG;
        addToken=true;
        reparse=false;
      }
 else       if (subtype == MOD_DEC) {
        if (isDigit(c)) {
          buf.append(c);
        }
 else         if (c == 'f' || c == 'F') {
          type=TYPE_FLOAT;
          addToken=true;
          reparse=false;
        }
 else         if (c == 'd' || c == 'D') {
          type=TYPE_FLOAT;
          addToken=true;
          reparse=false;
        }
 else {
          addToken=true;
        }
      }
 else       if (subtype == MOD_BIN) {
        if (c == 'b' || isBinDigit(c)) {
          buf.append(c);
        }
 else {
          addToken=true;
        }
      }
 else       if (subtype == MOD_OCT) {
        if (isOctDigit(c)) {
          buf.append(c);
        }
 else {
          addToken=true;
        }
      }
 else       if (subtype == MOD_HEX) {
        if (c == 'x' || isHexDigit(c)) {
          buf.append(c);
        }
 else {
          addToken=true;
        }
      }
    }
 else     if (type == TYPE_FLOAT || type == TYPE_DOUBLE) {
      if (c == 'x') {
        subtype=MOD_HEX;
        buf.append(c);
      }
 else       if (c == 'f' || c == 'F') {
        addToken=true;
        reparse=false;
      }
 else       if (c == 'd' || c == 'D') {
        type=TYPE_DOUBLE;
        addToken=true;
        reparse=false;
      }
 else       if (isDigit(c) || c == '.' || c == 'e') {
        buf.append(c);
      }
 else {
        addToken=true;
      }
    }
 else     if (type == TYPE_STRING) {
      if (c == '""' && buf.length() > 0) {
        buf.append('""');
        addToken=true;
        reparse=false;
      }
 else {
        buf.append(c);
      }
    }
 else     if (type == TYPE_CHAR) {
      if (c == '\'' && buf.length() > 0) {
        buf.append('\'');
        addToken=true;
        reparse=false;
      }
 else {
        buf.append(c);
      }
    }
    if (addToken) {
      prev=this.addToken(prev,buf,type | subtype,lineNumber,start,i);
      addToken=false;
      type=0;
      if (reparse) {
        i--;
      }
 else {
        reparse=true;
      }
    }
  }
  if (buf.length() > 0) {
    this.addToken(prev,buf,type,lineNumber,start,i);
  }
  this.first=first.next();
}","public void tokenize(){
  String code=this.file.getCode();
  int len=code.length();
  StringBuilder buf=new StringBuilder(20);
  Token first=new Token(-1,""String_Node_Str"",(byte)0,null,null,0,-1,-1);
  Token prev=first;
  int start=0;
  int lineNumber=1;
  int i;
  char l=0;
  char c=0;
  int type=0;
  int subtype=0;
  boolean addToken=false;
  boolean reparse=true;
  for (i=0; i < len; ++i, l=c) {
    c=code.charAt(i);
    if (c == '\n') {
      lineNumber++;
    }
    if (type == 0) {
      start=i;
      if (isWhitespace(c)) {
        continue;
      }
      int m=getMode(c,code,i);
      type=m & 0xFFFF;
      subtype=m & 0xFFFF0000;
    }
    if (type == TYPE_IDENTIFIER) {
      if (subtype == MOD_DOTS) {
        if (c == '.') {
          buf.append(c);
        }
 else {
          addToken=true;
          reparse=true;
        }
      }
 else       if (c == '_' || c == '$' || c == '@') {
        subtype=MOD_SYMBOL | MOD_LETTER;
        buf.append(c);
      }
 else {
        boolean letter=(subtype & MOD_LETTER) != 0;
        boolean symbol=(subtype & MOD_SYMBOL) != 0;
        if (letter) {
          if (isIdentifierPart(c)) {
            subtype=MOD_LETTER;
            buf.append(c);
            continue;
          }
        }
        if (symbol) {
          if (isIdentifierSymbol(c)) {
            subtype=MOD_SYMBOL;
            buf.append(c);
            continue;
          }
        }
        addToken=true;
      }
    }
 else     if (type == TYPE_SYMBOL) {
      buf.append(c);
      addToken=true;
      reparse=false;
    }
 else     if (type == TYPE_BRACKET) {
      buf.append(c);
      addToken=true;
      reparse=false;
    }
 else     if (type == TYPE_COMMENT) {
      if (subtype == MOD_LINE) {
        if (c == '\n') {
          type=0;
          continue;
        }
      }
 else       if (subtype == MOD_BLOCK) {
        if (l == '*' && c == '/') {
          type=0;
          continue;
        }
      }
    }
 else     if (type == TYPE_INT || type == TYPE_LONG) {
      if (c == '.') {
        type=TYPE_FLOAT;
        buf.append('.');
      }
 else       if (c == 'l' || c == 'L') {
        type=TYPE_LONG;
        addToken=true;
        reparse=false;
      }
 else       if (subtype == MOD_DEC) {
        if (isDigit(c)) {
          buf.append(c);
        }
 else         if (c == 'f' || c == 'F') {
          type=TYPE_FLOAT;
          addToken=true;
          reparse=false;
        }
 else         if (c == 'd' || c == 'D') {
          type=TYPE_FLOAT;
          addToken=true;
          reparse=false;
        }
 else {
          addToken=true;
        }
      }
 else       if (subtype == MOD_BIN) {
        if (c == 'b' || isBinDigit(c)) {
          buf.append(c);
        }
 else {
          addToken=true;
        }
      }
 else       if (subtype == MOD_OCT) {
        if (isOctDigit(c)) {
          buf.append(c);
        }
 else {
          addToken=true;
        }
      }
 else       if (subtype == MOD_HEX) {
        if (c == 'x' || isHexDigit(c)) {
          buf.append(c);
        }
 else {
          addToken=true;
        }
      }
    }
 else     if (type == TYPE_FLOAT || type == TYPE_DOUBLE) {
      if (c == 'x') {
        subtype=MOD_HEX;
        buf.append(c);
      }
 else       if (c == 'f' || c == 'F') {
        addToken=true;
        reparse=false;
      }
 else       if (c == 'd' || c == 'D') {
        type=TYPE_DOUBLE;
        addToken=true;
        reparse=false;
      }
 else       if (isDigit(c) || c == '.' || c == 'e') {
        buf.append(c);
      }
 else {
        addToken=true;
      }
    }
 else     if (type == TYPE_STRING) {
      if (c == '""' && buf.length() > 0) {
        buf.append('""');
        addToken=true;
        reparse=false;
      }
 else {
        buf.append(c);
      }
    }
 else     if (type == TYPE_CHAR) {
      if (c == '\'' && buf.length() > 0) {
        buf.append('\'');
        addToken=true;
        reparse=false;
      }
 else {
        buf.append(c);
      }
    }
    if (addToken) {
      prev=this.addToken(prev,buf,type | subtype,lineNumber,start);
      addToken=false;
      type=0;
      if (reparse) {
        i--;
      }
 else {
        reparse=true;
      }
    }
  }
  if (buf.length() > 0) {
    this.addToken(prev,buf,type,lineNumber,start);
  }
  this.first=first.next();
}",0.999536822603057
85361,"@Override public void toString(String prefix,StringBuilder buffer){
  if (this.name == null) {
    buffer.append('_');
  }
 else {
    buffer.append(this.name);
  }
  if (this.lowerBound != null) {
    buffer.append(Formatting.Type.genericLowerBound);
    this.lowerBound.toString(prefix,buffer);
  }
 else {
    buffer.append(Formatting.Type.genericUpperBound);
    if (this.upperBound != null) {
      this.upperBound.toString(prefix,buffer);
      if (this.upperBounds != null) {
        buffer.append(Formatting.Type.genericBoundSeperator);
      }
    }
    if (this.upperBounds != null) {
      Util.astToString(this.upperBounds,Formatting.Type.genericBoundSeperator,buffer);
    }
  }
}","@Override public void toString(String prefix,StringBuilder buffer){
  if (this.name == null) {
    buffer.append('_');
  }
 else {
    buffer.append(this.name);
  }
  if (this.lowerBound != null) {
    buffer.append(Formatting.Type.genericLowerBound);
    this.lowerBound.toString(prefix,buffer);
  }
 else   if (this.upperBound != null || this.upperBounds != null) {
    buffer.append(Formatting.Type.genericUpperBound);
    if (this.upperBound != null) {
      this.upperBound.toString(prefix,buffer);
      if (this.upperBounds != null) {
        buffer.append(Formatting.Type.genericBoundSeperator);
      }
    }
    if (this.upperBounds != null) {
      Util.astToString(this.upperBounds,Formatting.Type.genericBoundSeperator,buffer);
    }
  }
}",0.9591695501730104
85362,"@Override public void resolveTypes(List<Marker> markers,IContext context){
  if (this.upperBounds != null) {
    for (ListIterator<IType> iterator=this.upperBounds.listIterator(); iterator.hasNext(); ) {
      IType t1=iterator.next();
      IType t2=t1.resolve(context);
      if (!t2.isResolved()) {
        markers.add(new SemanticError(t2.getPosition(),""String_Node_Str"" + t2 + ""String_Node_Str""));
        continue;
      }
      IClass iclass=t2.getTheClass();
      if (iclass != null && !iclass.hasModifier(Modifiers.INTERFACE_CLASS)) {
        if (this.upperBound != null) {
          markers.add(new SemanticError(t2.getPosition(),""String_Node_Str"" + this.name + ""String_Node_Str""));
        }
        iterator.remove();
        this.upperBound=t2;
        continue;
      }
      if (t1 != t2) {
        iterator.set(t2);
      }
    }
    if (this.upperBounds.isEmpty()) {
      this.upperBounds=null;
    }
    this.captureClass=new CaptureClass(this,this.upperBound,this.upperBounds);
  }
 else   if (this.lowerBound != null) {
    this.lowerBound=this.lowerBound.resolve(context);
    if (!this.lowerBound.isResolved()) {
      markers.add(new SemanticError(this.lowerBound.getPosition(),""String_Node_Str"" + this.lowerBound + ""String_Node_Str""));
    }
    this.captureClass=Type.OBJECT.theClass;
  }
}","@Override public void resolveTypes(List<Marker> markers,IContext context){
  if (this.upperBounds != null) {
    for (ListIterator<IType> iterator=this.upperBounds.listIterator(); iterator.hasNext(); ) {
      IType t1=iterator.next();
      IType t2=t1.resolve(context);
      if (!t2.isResolved()) {
        markers.add(new SemanticError(t2.getPosition(),""String_Node_Str"" + t2 + ""String_Node_Str""));
        continue;
      }
      IClass iclass=t2.getTheClass();
      if (iclass != null && !iclass.hasModifier(Modifiers.INTERFACE_CLASS)) {
        if (this.upperBound != null) {
          markers.add(new SemanticError(t2.getPosition(),""String_Node_Str"" + this.name + ""String_Node_Str""));
        }
        iterator.remove();
        this.upperBound=t2;
        continue;
      }
      if (t1 != t2) {
        iterator.set(t2);
      }
    }
    if (this.upperBounds.isEmpty()) {
      this.upperBounds=null;
    }
    this.captureClass=new CaptureClass(this,this.upperBound,this.upperBounds);
  }
 else   if (this.lowerBound != null) {
    this.lowerBound=this.lowerBound.resolve(context);
    if (!this.lowerBound.isResolved()) {
      markers.add(new SemanticError(this.lowerBound.getPosition(),""String_Node_Str"" + this.lowerBound + ""String_Node_Str""));
    }
  }
  this.captureClass=Type.OBJECT.theClass;
}",0.9977203647416414
85363,"public static IAccess resolve(List<Marker> markers,IContext context,IAccess access){
  LinkedList<IAccess> chain=getCallChain(access);
  ListIterator<IAccess> iterator=chain.listIterator();
  IContext context1=context;
  IAccess prev=null;
  IAccess curr=null;
  boolean backwards=false;
  while (iterator.hasNext()) {
    prev=curr;
    curr=iterator.next();
    if (prev != null) {
      context1=prev.getType();
      curr.setValue(prev);
    }
 else {
      IValue value=curr.getValue();
      if (value != null) {
        context1=value.getType();
      }
    }
    if (context1 == null) {
      backwards=true;
      break;
    }
    if (!curr.resolve(context1,context)) {
      IAccess alternate=curr.resolve2(context1,context);
      if (alternate == null) {
        markers.add(curr.getResolveError());
      }
 else {
        curr=alternate;
        iterator.set(alternate);
      }
    }
  }
  if (!backwards) {
    return chain.getLast();
  }
  IAccess next=curr;
  prev=iterator.previous();
  while (iterator.hasPrevious()) {
    next=curr;
    curr=prev;
    prev=iterator.previous();
    if (prev != null) {
      context1=prev.getType();
      curr.setValue(prev);
    }
 else {
      IValue value=curr.getValue();
      if (value != null) {
        context1=value.getType();
      }
    }
    if (context1 == null) {
      context1=context;
    }
    IAccess alternate=curr.resolve3(context1,next);
    if (alternate != null) {
      curr=alternate;
      iterator.set(alternate);
    }
    markers.add(curr.getResolveError());
  }
  return chain.getLast();
}","public static IAccess resolve(List<Marker> markers,IContext context,IAccess access){
  LinkedList<IAccess> chain=getCallChain(access);
  ListIterator<IAccess> iterator=chain.listIterator();
  IContext context1=context;
  IAccess prev=null;
  IAccess curr=null;
  boolean backwards=false;
  while (iterator.hasNext()) {
    prev=curr;
    curr=iterator.next();
    if (prev != null) {
      context1=prev.getType();
      curr.setValue(prev);
    }
 else {
      IValue value=curr.getValue();
      if (value != null) {
        context1=value.getType();
      }
    }
    if (context1 == null) {
      backwards=true;
      break;
    }
    if (!curr.resolve(context1,context)) {
      IAccess alternate=curr.resolve2(context1,context);
      if (alternate == null) {
        backwards=true;
      }
 else {
        curr=alternate;
        iterator.set(alternate);
      }
    }
  }
  if (!backwards) {
    return chain.getLast();
  }
 else   if (chain.size() == 1) {
    markers.add(access.getResolveError());
    return access;
  }
  IAccess next=null;
  curr=access;
  prev=null;
  while (true) {
    IValue value=curr.getValue();
    if (value instanceof IAccess) {
      prev=(IAccess)value;
    }
 else {
      break;
    }
    context1=value.getType();
    if (context1 == null) {
      context1=context;
    }
    if (!curr.resolve(context1,context)) {
      curr.setValue(null);
      if (curr.resolve(context,null)) {
        prev.addValue(curr);
        curr=null;
        iterator.remove();
      }
 else {
        curr.setValue(value);
        markers.add(curr.getResolveError());
      }
    }
    next=curr;
    curr=prev;
  }
  return chain.getLast();
}",0.5980271270036991
85364,"public static void main(String[] args){
  initLogger();
  parser.parse(new CodeFile(args[0]),new ConfigParser(config));
  for (  Library library : config.libraries) {
    library.loadLibrary();
  }
  Type.init();
  for (int i=1; i < args.length; i++) {
    addStates(args[i]);
  }
  run();
}","public static void main(String[] args){
  for (int i=1; i < args.length; i++) {
    addStates(args[i]);
  }
  initLogger();
  parser.parse(new CodeFile(args[0]),new ConfigParser(config));
  for (  Library library : config.libraries) {
    library.loadLibrary();
  }
  Type.init();
  run();
}",0.7422680412371134
85365,"@Override public boolean isSuperType(Type t){
  if (t.equals(this.superClass) || this.interfaces.contains(t)) {
    return true;
  }
 else   if (this.superClass.theClass != null) {
    return this.superClass.theClass.isSuperType(t);
  }
  return false;
}","@Override public boolean isSuperType(Type t){
  if (t.equals(this.superClass) || this.interfaces.contains(t)) {
    return true;
  }
 else   if (this.superClass != null && this.superClass.theClass != null) {
    return this.superClass.theClass.isSuperType(t);
  }
  return false;
}",0.9158878504672896
85366,"@Override public IAccess resolve2(IContext context,IContext context1){
  String name=this.type.name;
  FieldMatch f=context.resolveField(context1,name);
  if (f != null) {
    FieldAccess access=new FieldAccess(this.position,null,name);
    access.field=f.theField;
    return access;
  }
  MethodMatch m=context.resolveMethod(context1,name,Type.EMPTY_TYPES);
  if (m != null) {
    MethodCall call=new MethodCall(this.position,null,name);
    call.method=m.theMethod;
    return call;
  }
  return this;
}","@Override public IAccess resolve2(IContext context,IContext context1){
  String name=this.type.name;
  FieldMatch f=context.resolveField(context1,name);
  if (f != null) {
    FieldAccess access=new FieldAccess(this.position,null,name);
    access.field=f.theField;
    return access;
  }
  MethodMatch m=context.resolveMethod(context1,name,Type.EMPTY_TYPES);
  if (m != null) {
    MethodCall call=new MethodCall(this.position,null,name);
    call.method=m.theMethod;
    call.isSugarCall=true;
    return call;
  }
  return this;
}",0.9740134744947064
85367,"@Override public IValue applyState(CompilerState state,IContext context){
  if (state == CompilerState.RESOLVE_TYPES) {
    if (this.initializer) {
      this.field.applyState(state,context);
    }
  }
 else   if (state == CompilerState.RESOLVE) {
    this.value.applyState(state,context);
    return AccessResolver.resolve(context,this);
  }
 else   if (state == CompilerState.CHECK) {
    if (this.value instanceof ThisValue) {
      state.addMarker(new SyntaxError(this.position,""String_Node_Str""));
      this.value=null;
    }
  }
  if (this.value != null) {
    this.value=this.value.applyState(state,context);
  }
  return this;
}","@Override public IValue applyState(CompilerState state,IContext context){
  if (state == CompilerState.RESOLVE_TYPES) {
    if (this.initializer) {
      this.field.applyState(state,context);
    }
  }
 else   if (state == CompilerState.RESOLVE) {
    if (this.value != null) {
      this.value.applyState(state,context);
    }
    return AccessResolver.resolve(context,this);
  }
 else   if (state == CompilerState.CHECK) {
    if (this.value instanceof ThisValue) {
      state.addMarker(new SyntaxError(this.position,""String_Node_Str""));
      this.value=null;
    }
  }
  if (this.value != null) {
    this.value=this.value.applyState(state,context);
  }
  return this;
}",0.9710365853658536
85368,"@Override public IValue applyState(CompilerState state,IContext context){
  int len=this.values.size();
  if (state == CompilerState.FOLD_CONSTANTS) {
    if (len == 1) {
      return this.values.get(0);
    }
  }
 else   if (state == CompilerState.RESOLVE) {
    IVariableList variableList=context instanceof IVariableList ? (IVariableList)context : null;
    for (    IValue v : this.values) {
      v.applyState(state,context);
      if (!(v instanceof FieldAssign)) {
        continue;
      }
      FieldAssign assign=(FieldAssign)v;
      if (!assign.initializer) {
        continue;
      }
      Variable var=(Variable)assign.field;
      var.start=this.start;
      var.end=this.end;
      this.variables.put(assign.qualifiedName,assign.field);
      if (variableList != null) {
        variableList.addVariable((Variable)assign.field);
      }
    }
  }
  this.context=context;
  for (int i=0; i < len; i++) {
    IValue v=this.values.get(i);
    this.values.set(i,v.applyState(state,this));
  }
  return this;
}","@Override public IValue applyState(CompilerState state,IContext context){
  int len=this.values.size();
  if (state == CompilerState.FOLD_CONSTANTS) {
    if (len == 1) {
      return this.values.get(0);
    }
  }
 else   if (state == CompilerState.RESOLVE) {
    IVariableList variableList=context instanceof IVariableList ? (IVariableList)context : null;
    for (    IValue v : this.values) {
      v.applyState(state,this);
      if (!(v instanceof FieldAssign)) {
        continue;
      }
      FieldAssign assign=(FieldAssign)v;
      if (!assign.initializer) {
        continue;
      }
      Variable var=(Variable)assign.field;
      var.start=this.start;
      var.end=this.end;
      this.variables.put(assign.qualifiedName,assign.field);
      if (variableList != null) {
        variableList.addVariable((Variable)assign.field);
      }
    }
  }
  this.context=context;
  for (int i=0; i < len; i++) {
    IValue v=this.values.get(i);
    this.values.set(i,v.applyState(state,this));
  }
  return this;
}",0.994610485056345
85369,"@Override public void writeSet(MethodVisitor visitor){
  visitor.visitVarInsn(Opcodes.ASTORE,this.index);
}","@Override public void writeSet(MethodVisitor visitor){
  visitor.visitVarInsn(this.type.getStoreOpcode(),this.index);
}",0.8761061946902655
85370,"@Override public void writeGet(MethodVisitor visitor){
  visitor.visitVarInsn(Opcodes.ALOAD,this.index);
}","@Override public void writeGet(MethodVisitor visitor){
  visitor.visitVarInsn(this.type.getLoadOpcode(),this.index);
}",0.8839285714285714
85371,"@Override public void writeSet(MethodVisitor visitor){
  visitor.visitVarInsn(Opcodes.ASTORE,this.index);
}","@Override public void writeSet(MethodVisitor visitor){
  visitor.visitVarInsn(this.type.getStoreOpcode(),this.index);
}",0.8761061946902655
85372,"@Override public void writeGet(MethodVisitor visitor){
  visitor.visitVarInsn(Opcodes.ALOAD,this.index);
}","@Override public void writeGet(MethodVisitor visitor){
  visitor.visitVarInsn(this.type.getLoadOpcode(),this.index);
}",0.8839285714285714
85373,"@Override public MethodMatch resolveMethod(IContext context,String name,Type... argumentTypes){
  if (this.theClass == null || argumentTypes == null) {
    return null;
  }
  List<MethodMatch> list=new ArrayList();
  this.theClass.getMethodMatches(list,null,name,argumentTypes);
  if (list.isEmpty() && context != null) {
    Type t=context.getThisType();
    t.theClass.getMethodMatches(list,this,name,argumentTypes);
  }
  if (list.isEmpty()) {
    return null;
  }
  Collections.sort(list);
  return list.get(0);
}","@Override public MethodMatch resolveMethod(IContext context,String name,Type... argumentTypes){
  if (this.theClass == null) {
    return null;
  }
  List<MethodMatch> list=new ArrayList();
  this.theClass.getMethodMatches(list,null,name,argumentTypes);
  if (list.isEmpty() && context != null) {
    Type t=context.getThisType();
    t.theClass.getMethodMatches(list,this,name,argumentTypes);
  }
  if (list.isEmpty()) {
    return null;
  }
  Collections.sort(list);
  return list.get(0);
}",0.975222993062438
85374,"public void tokenize(){
  String code=this.file.getCode();
  int len=code.length();
  StringBuilder buf=new StringBuilder(20);
  Token first=new Token(-1,""String_Node_Str"",(byte)0,null,null,0,-1,-1);
  Token prev=first;
  int start=0;
  int lineNumber=1;
  int i;
  char l=0;
  char c=0;
  int type=0;
  int subtype=0;
  boolean addToken=false;
  boolean reparse=true;
  for (i=0; i < len; ++i, l=c) {
    c=code.charAt(i);
    if (c == '\n') {
      lineNumber++;
    }
    if (type == 0) {
      start=i;
      if (isWhitespace(c)) {
        continue;
      }
      int m=getMode(c,code,i);
      type=m & 0xFFFF;
      subtype=m & 0xFFFF0000;
    }
    if (type == TYPE_IDENTIFIER) {
      if (subtype == MOD_DOTS) {
        if (c == '.') {
          buf.append(c);
        }
      }
 else {
        boolean letter=(subtype & MOD_LETTER) != 0;
        boolean symbol=(subtype & MOD_SYMBOL) != 0;
        if (letter) {
          if (c == '_') {
            subtype|=MOD_SYMBOL;
            buf.append(c);
          }
 else           if (isIdentifierPart(c)) {
            subtype=MOD_LETTER;
            buf.append(c);
          }
 else           if (!symbol) {
            addToken=true;
          }
        }
        if (symbol) {
          if (c == '_') {
            subtype|=MOD_LETTER;
            buf.append(c);
          }
 else           if (isIdentifierSymbol(c)) {
            subtype=MOD_SYMBOL;
            buf.append(c);
          }
 else           if (!letter) {
            addToken=true;
          }
        }
      }
    }
 else     if (type == TYPE_SYMBOL) {
      buf.append(c);
      addToken=true;
      reparse=false;
    }
 else     if (type == TYPE_BRACKET) {
      buf.append(c);
      addToken=true;
      reparse=false;
    }
 else     if (type == TYPE_COMMENT) {
      if (subtype == MOD_LINE) {
        if (c == '\n') {
          type=0;
          continue;
        }
      }
 else       if (subtype == MOD_BLOCK) {
        if (l == '*' && c == '/') {
          type=0;
          continue;
        }
      }
    }
 else     if (type == TYPE_INT || type == TYPE_LONG) {
      if (c == '.') {
        type=TYPE_FLOAT;
        buf.append('.');
      }
 else       if (c == 'l' || c == 'L') {
        type=TYPE_LONG;
        addToken=true;
        reparse=false;
      }
 else       if (subtype == MOD_DEC) {
        if (isDigit(c)) {
          buf.append(c);
        }
 else         if (c == 'f' || c == 'F') {
          type=TYPE_FLOAT;
          addToken=true;
          reparse=false;
        }
 else         if (c == 'd' || c == 'D') {
          type=TYPE_FLOAT;
          addToken=true;
          reparse=false;
        }
 else {
          addToken=true;
        }
      }
 else       if (subtype == MOD_BIN) {
        if (c == 'b' || isBinDigit(c)) {
          buf.append(c);
        }
 else {
          addToken=true;
        }
      }
 else       if (subtype == MOD_OCT) {
        if (isOctDigit(c)) {
          buf.append(c);
        }
 else {
          addToken=true;
        }
      }
 else       if (subtype == MOD_HEX) {
        if (c == 'x' || isHexDigit(c)) {
          buf.append(c);
        }
 else {
          addToken=true;
        }
      }
    }
 else     if (type == TYPE_FLOAT || type == TYPE_DOUBLE) {
      if (c == 'x') {
        subtype=MOD_HEX;
        buf.append(c);
      }
 else       if (c == 'f' || c == 'F') {
        addToken=true;
        reparse=false;
      }
 else       if (c == 'd' || c == 'D') {
        type=TYPE_DOUBLE;
        addToken=true;
        reparse=false;
      }
 else       if (isDigit(c) || c == '.' || c == 'e') {
        buf.append(c);
      }
 else {
        addToken=true;
      }
    }
 else     if (type == TYPE_STRING) {
      if (c == '""' && buf.length() > 0) {
        buf.append('""');
        addToken=true;
        reparse=false;
      }
 else {
        buf.append(c);
      }
    }
 else     if (type == TYPE_CHAR) {
      if (c == '\'' && buf.length() > 0) {
        buf.append('\'');
        addToken=true;
        reparse=false;
      }
 else {
        buf.append(c);
      }
    }
    if (addToken) {
      prev=this.addToken(prev,buf,type | subtype,lineNumber,start,i);
      addToken=false;
      type=0;
      if (reparse) {
        i--;
      }
 else {
        reparse=true;
      }
    }
  }
  if (buf.length() > 0) {
    this.addToken(prev,buf,type,lineNumber,start,i);
  }
  this.first=first.next();
}","public void tokenize(){
  String code=this.file.getCode();
  int len=code.length();
  StringBuilder buf=new StringBuilder(20);
  Token first=new Token(-1,""String_Node_Str"",(byte)0,null,null,0,-1,-1);
  Token prev=first;
  int start=0;
  int lineNumber=1;
  int i;
  char l=0;
  char c=0;
  int type=0;
  int subtype=0;
  boolean addToken=false;
  boolean reparse=true;
  for (i=0; i < len; ++i, l=c) {
    c=code.charAt(i);
    if (c == '\n') {
      lineNumber++;
    }
    if (type == 0) {
      start=i;
      if (isWhitespace(c)) {
        continue;
      }
      int m=getMode(c,code,i);
      type=m & 0xFFFF;
      subtype=m & 0xFFFF0000;
    }
    if (type == TYPE_IDENTIFIER) {
      if (subtype == MOD_DOTS) {
        if (c == '.') {
          buf.append(c);
        }
      }
 else {
        boolean letter=(subtype & MOD_LETTER) != 0;
        boolean symbol=(subtype & MOD_SYMBOL) != 0;
        if (letter) {
          if (c == '_' || c == '$' || c == '@') {
            subtype|=MOD_SYMBOL;
            buf.append(c);
          }
 else           if (isIdentifierPart(c)) {
            subtype=MOD_LETTER;
            buf.append(c);
          }
 else           if (!symbol) {
            addToken=true;
          }
        }
        if (symbol) {
          if (c == '_' || c == '$' || c == '@') {
            subtype|=MOD_LETTER;
            buf.append(c);
          }
 else           if (isIdentifierSymbol(c)) {
            subtype=MOD_SYMBOL;
            buf.append(c);
          }
 else           if (!letter) {
            addToken=true;
          }
        }
      }
    }
 else     if (type == TYPE_SYMBOL) {
      buf.append(c);
      addToken=true;
      reparse=false;
    }
 else     if (type == TYPE_BRACKET) {
      buf.append(c);
      addToken=true;
      reparse=false;
    }
 else     if (type == TYPE_COMMENT) {
      if (subtype == MOD_LINE) {
        if (c == '\n') {
          type=0;
          continue;
        }
      }
 else       if (subtype == MOD_BLOCK) {
        if (l == '*' && c == '/') {
          type=0;
          continue;
        }
      }
    }
 else     if (type == TYPE_INT || type == TYPE_LONG) {
      if (c == '.') {
        type=TYPE_FLOAT;
        buf.append('.');
      }
 else       if (c == 'l' || c == 'L') {
        type=TYPE_LONG;
        addToken=true;
        reparse=false;
      }
 else       if (subtype == MOD_DEC) {
        if (isDigit(c)) {
          buf.append(c);
        }
 else         if (c == 'f' || c == 'F') {
          type=TYPE_FLOAT;
          addToken=true;
          reparse=false;
        }
 else         if (c == 'd' || c == 'D') {
          type=TYPE_FLOAT;
          addToken=true;
          reparse=false;
        }
 else {
          addToken=true;
        }
      }
 else       if (subtype == MOD_BIN) {
        if (c == 'b' || isBinDigit(c)) {
          buf.append(c);
        }
 else {
          addToken=true;
        }
      }
 else       if (subtype == MOD_OCT) {
        if (isOctDigit(c)) {
          buf.append(c);
        }
 else {
          addToken=true;
        }
      }
 else       if (subtype == MOD_HEX) {
        if (c == 'x' || isHexDigit(c)) {
          buf.append(c);
        }
 else {
          addToken=true;
        }
      }
    }
 else     if (type == TYPE_FLOAT || type == TYPE_DOUBLE) {
      if (c == 'x') {
        subtype=MOD_HEX;
        buf.append(c);
      }
 else       if (c == 'f' || c == 'F') {
        addToken=true;
        reparse=false;
      }
 else       if (c == 'd' || c == 'D') {
        type=TYPE_DOUBLE;
        addToken=true;
        reparse=false;
      }
 else       if (isDigit(c) || c == '.' || c == 'e') {
        buf.append(c);
      }
 else {
        addToken=true;
      }
    }
 else     if (type == TYPE_STRING) {
      if (c == '""' && buf.length() > 0) {
        buf.append('""');
        addToken=true;
        reparse=false;
      }
 else {
        buf.append(c);
      }
    }
 else     if (type == TYPE_CHAR) {
      if (c == '\'' && buf.length() > 0) {
        buf.append('\'');
        addToken=true;
        reparse=false;
      }
 else {
        buf.append(c);
      }
    }
    if (addToken) {
      prev=this.addToken(prev,buf,type | subtype,lineNumber,start,i);
      addToken=false;
      type=0;
      if (reparse) {
        i--;
      }
 else {
        reparse=true;
      }
    }
  }
  if (buf.length() > 0) {
    this.addToken(prev,buf,type,lineNumber,start,i);
  }
  this.first=first.next();
}",0.9945872801082544
85375,"@Override public boolean parse(ParserManager pm,String value,IToken token) throws SyntaxError {
  if (this.mode == 0 || ""String_Node_Str"".equals(value) || ""String_Node_Str"".equals(value) && !this.isInMode(PARAMETERS_2) && !this.isInMode(TUPLE_END)) {
    pm.popParser(true);
    return true;
  }
  if (this.isInMode(VALUE)) {
    if (this.parsePrimitive(value,token)) {
      this.mode=ACCESS;
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      this.mode=ACCESS;
      this.value=new ThisValue(token,this.context.getThisType());
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      this.mode=ACCESS;
      this.value=new SuperValue(token,this.context.getThisType());
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      ReturnStatement statement=new ReturnStatement(token);
      this.value=statement;
      pm.pushParser(new ExpressionParser(this.context,statement));
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      IfStatement statement=new IfStatement(token);
      this.value=statement;
      pm.pushParser(new IfStatementParser(this.context,statement));
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      this.mode=TUPLE_END;
      this.value=new TupleValue();
      if (!token.next().equals(""String_Node_Str"")) {
        pm.pushParser(new ExpressionListParser(this.context,(IValueList)this.value));
      }
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      this.mode=VALUE_2;
      this.value=new StatementList(token);
      if (!token.next().equals(""String_Node_Str"")) {
        pm.pushParser(new ExpressionListParser(this.context,(IValueList)this.value));
      }
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      ConstructorCall call=new ConstructorCall(token);
      this.mode=PARAMETERS;
      this.value=call;
      pm.pushParser(new TypeParser(this.context,call));
      return true;
    }
 else     if ((token.isType(IToken.TYPE_IDENTIFIER) || token.equals(""String_Node_Str"")) && !token.next().isType(IToken.TYPE_OPEN_BRACKET)) {
      this.mode=ACCESS | VARIABLE;
      pm.pushParser(new TypeParser(this.context,this),true);
      return true;
    }
    this.mode=ACCESS;
  }
  if (this.isInMode(VALUE_2)) {
    if (""String_Node_Str"".equals(value)) {
      this.value.expandPosition(token);
      this.mode=ACCESS;
      return true;
    }
  }
  if (this.isInMode(TUPLE_END)) {
    if (""String_Node_Str"".equals(value)) {
      this.value.expandPosition(token);
      this.mode=ACCESS;
      return true;
    }
  }
  if (this.isInMode(VARIABLE)) {
    if (token.isType(IToken.TYPE_IDENTIFIER)) {
      IToken next=token.next();
      boolean flag=next.equals(""String_Node_Str"");
      if (flag || next.equals(""String_Node_Str"")) {
        ICodePosition pos=token.raw();
        Type type=((ClassAccess)this.value).getType();
        FieldAssign access=new FieldAssign(pos,value,null);
        access.field=new Variable(pos,value,type);
        access.initializer=true;
        this.value=access;
        if (flag) {
          pm.skip();
          pm.pushParser(new ExpressionParser(this.context,access));
        }
        return true;
      }
    }
  }
  if (this.isInMode(ACCESS)) {
    if (""String_Node_Str"".equals(value)) {
      this.mode=DOT_ACCESS;
      return true;
    }
    if (""String_Node_Str"".equals(value)) {
      String name=null;
      IValue instance=null;
      if (this.value instanceof ClassAccess) {
        name=((ClassAccess)this.value).getName();
      }
 else       if (this.value instanceof FieldAccess) {
        FieldAccess fa=(FieldAccess)this.value;
        name=fa.getName();
        instance=fa.getValue();
      }
 else {
        return false;
      }
      FieldAssign assign=new FieldAssign(this.value.getPosition(),name,instance);
      this.value=assign;
      pm.pushParser(new ExpressionParser(this.context,assign));
      return true;
    }
    if (this.lazy && this.value != null) {
      pm.popParser(true);
      return true;
    }
    this.mode=DOT_ACCESS;
  }
  if (this.isInMode(DOT_ACCESS)) {
    if (token.isType(IToken.TYPE_IDENTIFIER)) {
      IToken next=token.next();
      if (next.isType(IToken.TYPE_OPEN_BRACKET)) {
        MethodCall call=new MethodCall(token,this.value,value);
        this.value=call;
        this.mode=PARAMETERS;
        return true;
      }
 else       if (!next.isType(IToken.TYPE_IDENTIFIER) && !next.isType(IToken.TYPE_CLOSE_BRACKET) && !next.isType(IToken.TYPE_SYMBOL)) {
        MethodCall call=new MethodCall(token,this.value,value);
        call.setSugar(true);
        this.value=call;
        ExpressionParser parser=new ExpressionParser(this.context,this);
        parser.lazy=true;
        pm.pushParser(parser);
        return true;
      }
 else {
        FieldAccess access=new FieldAccess(token,this.value,value);
        this.value=access;
        this.mode=ACCESS;
        return true;
      }
    }
  }
  if (this.isInMode(PARAMETERS)) {
    if (""String_Node_Str"".equals(value)) {
      pm.pushParser(new ExpressionListParser(this.context,(IValueList)this.value));
      this.mode=PARAMETERS_2;
      return true;
    }
  }
  if (this.isInMode(PARAMETERS_2)) {
    if (""String_Node_Str"".equals(value)) {
      this.value.expandPosition(token);
      this.mode=ACCESS;
      return true;
    }
  }
  if (this.value != null) {
    this.value.expandPosition(token);
    pm.popParser(true);
    return true;
  }
  return false;
}","@Override public boolean parse(ParserManager pm,String value,IToken token) throws SyntaxError {
  if (this.mode == 0 || ""String_Node_Str"".equals(value) || ""String_Node_Str"".equals(value) && !this.isInMode(PARAMETERS_2) && !this.isInMode(TUPLE_END)) {
    pm.popParser(true);
    return true;
  }
  if (this.isInMode(VALUE)) {
    if (this.parsePrimitive(value,token)) {
      this.mode=ACCESS;
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      this.mode=ACCESS;
      this.value=new ThisValue(token,this.context.getThisType());
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      this.mode=ACCESS;
      this.value=new SuperValue(token,this.context.getThisType());
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      ReturnStatement statement=new ReturnStatement(token);
      this.value=statement;
      pm.pushParser(new ExpressionParser(this.context,statement));
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      IfStatement statement=new IfStatement(token);
      this.value=statement;
      pm.pushParser(new IfStatementParser(this.context,statement));
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      this.mode=TUPLE_END;
      this.value=new TupleValue();
      if (!token.next().equals(""String_Node_Str"")) {
        pm.pushParser(new ExpressionListParser(this.context,(IValueList)this.value));
      }
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      this.mode=VALUE_2;
      this.value=new StatementList(token);
      if (!token.next().equals(""String_Node_Str"")) {
        pm.pushParser(new ExpressionListParser(this.context,(IValueList)this.value));
      }
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      ConstructorCall call=new ConstructorCall(token);
      this.mode=PARAMETERS;
      this.value=call;
      pm.pushParser(new TypeParser(this.context,call));
      return true;
    }
 else     if ((token.isType(IToken.TYPE_IDENTIFIER) || token.equals(""String_Node_Str"")) && !token.next().isType(IToken.TYPE_OPEN_BRACKET)) {
      this.mode=ACCESS | VARIABLE;
      pm.pushParser(new TypeParser(this.context,this),true);
      return true;
    }
    this.mode=ACCESS;
  }
  if (this.isInMode(VALUE_2)) {
    if (""String_Node_Str"".equals(value)) {
      this.value.expandPosition(token);
      this.mode=ACCESS;
      return true;
    }
  }
  if (this.isInMode(TUPLE_END)) {
    if (""String_Node_Str"".equals(value)) {
      this.value.expandPosition(token);
      this.mode=ACCESS;
      return true;
    }
  }
  if (this.isInMode(VARIABLE)) {
    if (token.isType(IToken.TYPE_IDENTIFIER)) {
      if (token.next().equals(""String_Node_Str"")) {
        ICodePosition pos=token.raw();
        Type type=((ClassAccess)this.value).getType();
        FieldAssign access=new FieldAssign(pos,value,null);
        access.field=new Variable(pos,value,type);
        access.initializer=true;
        this.value=access;
        pm.skip();
        pm.pushParser(new ExpressionParser(this.context,access));
        return true;
      }
    }
  }
  if (this.isInMode(ACCESS)) {
    if (""String_Node_Str"".equals(value)) {
      this.mode=DOT_ACCESS;
      return true;
    }
    if (""String_Node_Str"".equals(value)) {
      String name=null;
      IValue instance=null;
      if (this.value instanceof ClassAccess) {
        name=((ClassAccess)this.value).getName();
      }
 else       if (this.value instanceof FieldAccess) {
        FieldAccess fa=(FieldAccess)this.value;
        name=fa.getName();
        instance=fa.getValue();
      }
 else {
        return false;
      }
      FieldAssign assign=new FieldAssign(this.value.getPosition(),name,instance);
      this.value=assign;
      pm.pushParser(new ExpressionParser(this.context,assign));
      return true;
    }
    if (this.lazy && this.value != null) {
      pm.popParser(true);
      return true;
    }
    this.mode=DOT_ACCESS;
  }
  if (this.isInMode(DOT_ACCESS)) {
    if (token.isType(IToken.TYPE_IDENTIFIER)) {
      IToken next=token.next();
      if (next.isType(IToken.TYPE_OPEN_BRACKET)) {
        MethodCall call=new MethodCall(token,this.value,value);
        this.value=call;
        this.mode=PARAMETERS;
        return true;
      }
 else       if (!next.isType(IToken.TYPE_IDENTIFIER) && !next.isType(IToken.TYPE_CLOSE_BRACKET) && !next.isType(IToken.TYPE_SYMBOL)) {
        MethodCall call=new MethodCall(token,this.value,value);
        call.setSugar(true);
        this.value=call;
        ExpressionParser parser=new ExpressionParser(this.context,this);
        parser.lazy=true;
        pm.pushParser(parser);
        return true;
      }
 else {
        FieldAccess access=new FieldAccess(token,this.value,value);
        this.value=access;
        this.mode=ACCESS;
        return true;
      }
    }
  }
  if (this.isInMode(PARAMETERS)) {
    if (""String_Node_Str"".equals(value)) {
      pm.pushParser(new ExpressionListParser(this.context,(IValueList)this.value));
      this.mode=PARAMETERS_2;
      return true;
    }
  }
  if (this.isInMode(PARAMETERS_2)) {
    if (""String_Node_Str"".equals(value)) {
      this.value.expandPosition(token);
      this.mode=ACCESS;
      return true;
    }
  }
  if (this.value != null) {
    this.value.expandPosition(token);
    pm.popParser(true);
    return true;
  }
  return false;
}",0.9878704970360236
85376,"@Override public default void setTypes(List<Type> types){
  int index=0;
  for (  Type type : types) {
    this.addParameter(new Parameter(""String_Node_Str"" + index,type,0));
  }
}","@Override public default void setTypes(List<Type> types){
  int index=0;
  for (  Type type : types) {
    this.addParameter(new Parameter(index,""String_Node_Str"" + index,type,0));
    index++;
  }
}",0.949868073878628
85377,"@Override public default void addType(Type type){
  int index=this.getParameters().size();
  this.addParameter(new Parameter(""String_Node_Str"" + index,type,0));
}","@Override public default void addType(Type type){
  int index=this.getParameters().size();
  this.addParameter(new Parameter(index,""String_Node_Str"" + index,type,0));
}",0.9818181818181818
85378,"public default void addParameter(Parameter parameter){
  this.getParameters().add(parameter);
}","public default void addParameter(Parameter parameter){
  List<Parameter> parameters=this.getParameters();
  parameter.index=parameters.size();
  parameters.add(parameter);
}",0.7089552238805971
85379,"@Override public void write(MethodVisitor visitor){
  if (this.instance != null) {
    this.instance.write(visitor);
  }
  int opcode;
  if (this.field.hasModifier(Modifiers.STATIC)) {
    opcode=Opcodes.GETSTATIC;
  }
 else {
    opcode=Opcodes.GETFIELD;
  }
  String owner=this.field.getTheClass().getInternalName();
  String name=this.field.getName();
  String desc=this.field.getDescription();
  visitor.visitFieldInsn(opcode,owner,name,desc);
}","@Override public void write(MethodVisitor visitor){
  if (this.instance != null) {
    this.instance.write(visitor);
  }
  if (this.field instanceof Parameter) {
    visitor.visitIntInsn(Opcodes.ALOAD,((Parameter)this.field).index);
    return;
  }
  int opcode;
  if (this.field.hasModifier(Modifiers.STATIC)) {
    opcode=Opcodes.GETSTATIC;
  }
 else {
    opcode=Opcodes.GETFIELD;
  }
  String owner=this.field.getTheClass().getInternalName();
  String name=this.field.getName();
  String desc=this.field.getDescription();
  visitor.visitFieldInsn(opcode,owner,name,desc);
}",0.8752436647173489
85380,"@Override public int getSignatureMatch(String name,Type type,Type... argumentTypes){
  if (name.equals(this.name)) {
    int pOff=0;
    int match=1;
    int len=argumentTypes.length;
    List<Parameter> parameters=this.parameters;
    if (type != null && (this.modifiers & Modifiers.IMPLICIT) != 0) {
      if (len != parameters.size() - 1) {
        return 0;
      }
      Type t2=parameters.get(0).type;
      if (type.equals(t2)) {
        match+=2;
      }
 else       if (Type.isSuperType(type,t2)) {
        match+=1;
      }
 else {
        return 0;
      }
      pOff=1;
    }
 else     if (len != argumentTypes.length) {
      return 0;
    }
    for (int i=0; i < len; i++) {
      Type t1=parameters.get(i + pOff).type;
      Type t2=argumentTypes[i];
      if (t1.equals(t2)) {
        match+=2;
      }
 else       if (Type.isSuperType(t1,t2)) {
        match+=1;
      }
 else {
        return 0;
      }
    }
    return match;
  }
  return 0;
}","@Override public int getSignatureMatch(String name,Type type,Type... argumentTypes){
  if (name.equals(this.name)) {
    int pOff=0;
    int match=1;
    int len=argumentTypes.length;
    List<Parameter> parameters=this.parameters;
    if (type != null && (this.modifiers & Modifiers.IMPLICIT) != 0) {
      if (len != parameters.size() - 1) {
        return 0;
      }
      Type t2=parameters.get(0).type;
      if (type.equals(t2)) {
        match+=2;
      }
 else       if (Type.isSuperType(type,t2)) {
        match+=1;
      }
 else {
        return 0;
      }
      pOff=1;
    }
 else     if (len != this.parameters.size()) {
      return 0;
    }
    for (int i=0; i < len; i++) {
      Type t1=parameters.get(i + pOff).type;
      Type t2=argumentTypes[i];
      if (t1.equals(t2)) {
        match+=2;
      }
 else       if (Type.isSuperType(t1,t2)) {
        match+=1;
      }
 else {
        return 0;
      }
    }
    return match;
  }
  return 0;
}",0.9782157676348548
85381,"public Parameter(String name,Type type,int modifiers,char seperator){
  super(null,name,type,modifiers);
  this.seperator=seperator;
}","public Parameter(int index,String name,Type type,int modifiers,char seperator){
  super(null,name,type,modifiers);
  this.index=index;
  this.seperator=seperator;
}",0.8993288590604027
85382,"@Override public boolean parse(ParserManager pm,String value,IToken token) throws SyntaxError {
  if (this.mode == 0 || ""String_Node_Str"".equals(value) || ""String_Node_Str"".equals(value) && !this.isInMode(PARAMETERS_2)) {
    pm.popParser(true);
    return true;
  }
  if (this.isInMode(VALUE)) {
    if (this.parsePrimitive(value,token)) {
      this.mode=ACCESS;
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      this.mode=ACCESS;
      this.value=new ThisValue(token,this.context.getThisType());
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      this.mode=ACCESS;
      this.value=new SuperValue(token,this.context.getThisType());
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      this.mode=TUPLE_END;
      this.value=new TupleValue();
      if (!token.next().equals(""String_Node_Str"")) {
        pm.pushParser(new ExpressionListParser(this.context,(IValueList)this.value));
      }
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      this.mode=VALUE_2;
      this.value=new StatementList(token);
      if (!token.next().equals(""String_Node_Str"")) {
        pm.pushParser(new ExpressionListParser(this.context,(IValueList)this.value,true));
      }
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      ConstructorCall call=new ConstructorCall(token);
      this.mode=PARAMETERS;
      this.value=call;
      pm.pushParser(new TypeParser(this.context,call));
      return true;
    }
 else     if (token.isType(IToken.TYPE_IDENTIFIER) && !token.next().isType(Token.TYPE_OPEN_BRACKET)) {
      this.mode=ACCESS;
      pm.pushParser(new TypeParser(this.context,this),true);
      return true;
    }
    this.mode=ACCESS;
  }
  if (this.isInMode(VALUE_2)) {
    if (""String_Node_Str"".equals(value)) {
      this.value.expandPosition(token);
      this.mode=ACCESS;
      return true;
    }
  }
  if (this.isInMode(TUPLE_END)) {
    if (""String_Node_Str"".equals(value)) {
      this.value.expandPosition(token);
      this.mode=ACCESS;
      return true;
    }
  }
  if (this.isInMode(STATEMENT)) {
    if (""String_Node_Str"".equals(value)) {
      ReturnStatement statement=new ReturnStatement(token);
      this.value=statement;
      pm.pushParser(new ExpressionParser(this.context,statement));
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      IfStatement statement=new IfStatement(token);
      this.value=statement;
      pm.pushParser(new IfStatementParser(this.context,statement));
      return true;
    }
  }
  if (this.isInMode(ACCESS)) {
    if (""String_Node_Str"".equals(value)) {
      this.mode=DOT_ACCESS;
      return true;
    }
    if (this.lazy && this.value != null) {
      pm.popParser(true);
      return true;
    }
    this.mode=DOT_ACCESS;
  }
  if (this.isInMode(DOT_ACCESS)) {
    if (token.isType(IToken.TYPE_IDENTIFIER)) {
      IToken next=token.next();
      if (next.isType(IToken.TYPE_OPEN_BRACKET)) {
        MethodCall call=new MethodCall(token,this.value,value);
        this.value=call;
        this.mode=PARAMETERS;
        return true;
      }
 else       if (!next.isType(IToken.TYPE_IDENTIFIER) && !next.isType(IToken.TYPE_CLOSE_BRACKET)) {
        MethodCall call=new MethodCall(token,this.value,value);
        call.setSugar(true);
        this.value=call;
        ExpressionParser parser=new ExpressionParser(this.context,call);
        parser.lazy=true;
        pm.pushParser(parser);
        return true;
      }
 else {
        FieldAccess access=new FieldAccess(token,this.value,value);
        this.value=access;
        this.mode=ACCESS;
        return true;
      }
    }
  }
  if (this.isInMode(PARAMETERS)) {
    if (""String_Node_Str"".equals(value)) {
      pm.pushParser(new ExpressionListParser(this.context,(IValueList)this.value));
      this.mode=PARAMETERS_2;
      return true;
    }
  }
  if (this.isInMode(PARAMETERS_2)) {
    if (""String_Node_Str"".equals(value)) {
      this.value.expandPosition(token);
      this.mode=ACCESS;
      return true;
    }
  }
  if (this.value != null) {
    this.value.expandPosition(token);
    pm.popParser(true);
    return true;
  }
  return false;
}","@Override public boolean parse(ParserManager pm,String value,IToken token) throws SyntaxError {
  if (this.mode == 0 || ""String_Node_Str"".equals(value) || ""String_Node_Str"".equals(value) && !this.isInMode(PARAMETERS_2)) {
    pm.popParser(true);
    return true;
  }
  if (this.isInMode(VALUE)) {
    if (this.parsePrimitive(value,token)) {
      this.mode=ACCESS;
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      this.mode=ACCESS;
      this.value=new ThisValue(token,this.context.getThisType());
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      this.mode=ACCESS;
      this.value=new SuperValue(token,this.context.getThisType());
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      this.mode=TUPLE_END;
      this.value=new TupleValue();
      if (!token.next().equals(""String_Node_Str"")) {
        pm.pushParser(new ExpressionListParser(this.context,(IValueList)this.value));
      }
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      this.mode=VALUE_2;
      this.value=new StatementList(token);
      if (!token.next().equals(""String_Node_Str"")) {
        pm.pushParser(new ExpressionListParser(this.context,(IValueList)this.value,true));
      }
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      ConstructorCall call=new ConstructorCall(token);
      this.mode=PARAMETERS;
      this.value=call;
      pm.pushParser(new TypeParser(this.context,call));
      return true;
    }
 else     if (token.isType(IToken.TYPE_IDENTIFIER) && !token.next().isType(Token.TYPE_OPEN_BRACKET)) {
      this.mode=ACCESS;
      pm.pushParser(new TypeParser(this.context,this),true);
      return true;
    }
    this.mode=ACCESS;
  }
  if (this.isInMode(VALUE_2)) {
    if (""String_Node_Str"".equals(value)) {
      this.value.expandPosition(token);
      this.mode=ACCESS;
      return true;
    }
  }
  if (this.isInMode(TUPLE_END)) {
    if (""String_Node_Str"".equals(value)) {
      this.value.expandPosition(token);
      this.mode=ACCESS;
      return true;
    }
  }
  if (this.isInMode(STATEMENT)) {
    if (""String_Node_Str"".equals(value)) {
      ReturnStatement statement=new ReturnStatement(token);
      this.value=statement;
      pm.pushParser(new ExpressionParser(this.context,statement));
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      IfStatement statement=new IfStatement(token);
      this.value=statement;
      pm.pushParser(new IfStatementParser(this.context,statement));
      return true;
    }
  }
  if (this.isInMode(ACCESS)) {
    if (""String_Node_Str"".equals(value)) {
      this.mode=DOT_ACCESS;
      return true;
    }
    if (this.lazy && this.value != null) {
      pm.popParser(true);
      return true;
    }
    this.mode=DOT_ACCESS;
  }
  if (this.isInMode(DOT_ACCESS)) {
    if (token.isType(IToken.TYPE_IDENTIFIER)) {
      IToken next=token.next();
      if (next.isType(IToken.TYPE_OPEN_BRACKET)) {
        MethodCall call=new MethodCall(token,this.value,value);
        this.value=call;
        this.mode=PARAMETERS;
        return true;
      }
 else       if (!next.isType(IToken.TYPE_IDENTIFIER) && !next.isType(IToken.TYPE_CLOSE_BRACKET) && !next.isType(IToken.TYPE_SYMBOL)) {
        MethodCall call=new MethodCall(token,this.value,value);
        call.setSugar(true);
        this.value=call;
        ExpressionParser parser=new ExpressionParser(this.context,call);
        parser.lazy=true;
        pm.pushParser(parser);
        return true;
      }
 else {
        FieldAccess access=new FieldAccess(token,this.value,value);
        this.value=access;
        this.mode=ACCESS;
        return true;
      }
    }
  }
  if (this.isInMode(PARAMETERS)) {
    if (""String_Node_Str"".equals(value)) {
      pm.pushParser(new ExpressionListParser(this.context,(IValueList)this.value));
      this.mode=PARAMETERS_2;
      return true;
    }
  }
  if (this.isInMode(PARAMETERS_2)) {
    if (""String_Node_Str"".equals(value)) {
      this.value.expandPosition(token);
      this.mode=ACCESS;
      return true;
    }
  }
  if (this.value != null) {
    this.value.expandPosition(token);
    pm.popParser(true);
    return true;
  }
  return false;
}",0.99575571799104
85383,"public static IAccess resolve(IContext context,IAccess access){
  List<Marker> markers=CompilerState.RESOLVE.file.markers;
  LinkedList<IAccess> chain=getCallChain(access);
  IAccess a=null;
  ListIterator<IAccess> iterator=chain.listIterator();
  while (iterator.hasNext()) {
    IContext context1=context;
    IAccess iaccess=iterator.next();
    if (a != null) {
      context1=a.getType();
    }
 else {
      IValue value=iaccess.getValue();
      if (value != null) {
        context1=value.getType();
      }
    }
    if (!iaccess.resolve(context1,context)) {
      IAccess iaccess2=iaccess.resolve2(context1,context);
      if (iaccess2 == iaccess) {
        markers.add(iaccess.getResolveError());
        return access;
      }
      a=iaccess2;
      continue;
    }
    a=iaccess;
  }
  return access;
}","public static IAccess resolve(IContext context,IAccess access){
  List<Marker> markers=CompilerState.RESOLVE.file.markers;
  LinkedList<IAccess> chain=getCallChain(access);
  IAccess a=null;
  ListIterator<IAccess> iterator=chain.listIterator();
  while (iterator.hasNext()) {
    IContext context1=context;
    IAccess iaccess=iterator.next();
    if (a != null) {
      context1=a.getType();
      iaccess.setValue(a);
    }
 else {
      IValue value=iaccess.getValue();
      if (value != null) {
        context1=value.getType();
      }
    }
    if (!iaccess.resolve(context1,context)) {
      IAccess iaccess2=iaccess.resolve2(context1,context);
      if (iaccess2 == iaccess) {
        markers.add(iaccess.getResolveError());
        return access;
      }
      a=iaccess2;
      continue;
    }
    a=iaccess;
  }
  return a;
}",0.9806529625151148
85384,"@Override public IAccess applyState(CompilerState state,IContext context){
  super.applyState(state,context);
  this.arguments.replaceAll(v -> v.applyState(state,context));
  if (state == CompilerState.RESOLVE) {
    return AccessResolver.resolve(context,this);
  }
 else   if (this.instance != null) {
    this.instance=this.instance.applyState(state,context);
  }
  return this;
}","@Override public IAccess applyState(CompilerState state,IContext context){
  if (state == CompilerState.RESOLVE) {
    return AccessResolver.resolve(context,this);
  }
 else {
    super.applyState(state,context);
    if (this.instance != null) {
      this.instance=this.instance.applyState(state,context);
    }
    this.arguments.replaceAll(v -> v.applyState(state,context));
    return this;
  }
}",0.6982097186700768
85385,"@Override public void setValue(IValue value){
  if (this.isSugarCall) {
    this.arguments.add(value);
  }
 else {
    this.instance=value;
  }
}","@Override public void setValue(IValue value){
  this.instance=value;
}",0.6511627906976745
85386,"@Override public int getSignatureMatch(String name,Type type,Type... argumentTypes){
  if (name.equals(this.name)) {
    int pOff=0;
    int match=1;
    int len=argumentTypes.length;
    List<Parameter> parameters=this.parameters;
    if (type != null && (this.modifiers & Modifiers.IMPLICIT) != 0) {
      if (len != parameters.size() - 1) {
        return 0;
      }
      Type t2=parameters.get(0).type;
      if (type.equals(t2)) {
        match+=2;
      }
 else       if (Type.isSuperType(type,t2)) {
        match+=1;
      }
 else {
        return 0;
      }
      pOff=1;
    }
 else     if (len != this.parameters.size()) {
      return 0;
    }
    for (int i=0; i < len; i++) {
      Type t1=parameters.get(i + pOff).type;
      Type t2=argumentTypes[i];
      if (t1.equals(t2)) {
        match+=2;
      }
 else       if (Type.isSuperType(t1,t2)) {
        match+=1;
      }
 else {
        return 0;
      }
    }
    return match;
  }
  return 0;
}","@Override public int getSignatureMatch(String name,Type type,Type... argumentTypes){
  if (name.equals(this.qualifiedName)) {
    int pOff=0;
    int match=1;
    int len=argumentTypes.length;
    List<Parameter> parameters=this.parameters;
    if (type != null && (this.modifiers & Modifiers.IMPLICIT) != 0) {
      if (len != parameters.size() - 1) {
        return 0;
      }
      Type t2=parameters.get(0).type;
      if (type.equals(t2)) {
        match+=2;
      }
 else       if (Type.isSuperType(type,t2)) {
        match+=1;
      }
 else {
        return 0;
      }
      pOff=1;
    }
 else     if (len != this.parameters.size()) {
      return 0;
    }
    for (int i=0; i < len; i++) {
      Type t1=parameters.get(i + pOff).type;
      Type t2=argumentTypes[i];
      if (t1.equals(t2)) {
        match+=2;
      }
 else       if (Type.isSuperType(t1,t2)) {
        match+=1;
      }
 else {
        return 0;
      }
    }
    return match;
  }
  return 0;
}",0.9943269726663228
85387,"@Override public boolean parse(ParserManager pm,String value,IToken token) throws SyntaxError {
  if (this.mode == 0 || ""String_Node_Str"".equals(value) || ""String_Node_Str"".equals(value) && !this.isInMode(PARAMETERS_2)) {
    pm.popParser(true);
    return true;
  }
  if (this.isInMode(VALUE)) {
    if (this.parsePrimitive(value,token)) {
      this.mode=ACCESS;
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      this.mode=ACCESS;
      this.value=new ThisValue(token,this.context.getThisType());
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      this.mode=ACCESS;
      this.value=new SuperValue(token,this.context.getThisType());
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      this.mode=TUPLE_END;
      this.value=new TupleValue();
      if (!token.next().equals(""String_Node_Str"")) {
        pm.pushParser(new ExpressionListParser(this.context,(IValueList)this.value));
      }
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      this.mode=VALUE_2;
      this.value=new StatementList(token);
      if (!token.next().equals(""String_Node_Str"")) {
        pm.pushParser(new ExpressionListParser(this.context,(IValueList)this.value,true));
      }
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      ConstructorCall call=new ConstructorCall(token);
      this.mode=PARAMETERS;
      this.value=call;
      pm.pushParser(new TypeParser(this.context,call));
      return true;
    }
 else     if (token.isType(IToken.TYPE_IDENTIFIER) && !token.next().isType(Token.TYPE_OPEN_BRACKET)) {
      this.mode=ACCESS;
      pm.pushParser(new TypeParser(this.context,this),true);
      return true;
    }
    this.mode=ACCESS;
  }
  if (this.isInMode(VALUE_2)) {
    if (""String_Node_Str"".equals(value)) {
      this.value.expandPosition(token);
      this.mode=ACCESS;
      return true;
    }
  }
  if (this.isInMode(TUPLE_END)) {
    if (""String_Node_Str"".equals(value)) {
      this.value.expandPosition(token);
      this.mode=ACCESS;
      return true;
    }
  }
  if (this.isInMode(STATEMENT)) {
    if (""String_Node_Str"".equals(value)) {
      ReturnStatement statement=new ReturnStatement(token);
      this.value=statement;
      pm.pushParser(new ExpressionParser(this.context,statement));
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      IfStatement statement=new IfStatement(token);
      this.value=statement;
      pm.pushParser(new IfStatementParser(this.context,statement));
      return true;
    }
  }
  if (this.isInMode(ACCESS)) {
    if (""String_Node_Str"".equals(value)) {
      this.mode=DOT_ACCESS;
      return true;
    }
    if (this.lazy && this.value != null) {
      pm.popParser(true);
      return true;
    }
    this.mode=DOT_ACCESS;
  }
  if (this.isInMode(DOT_ACCESS)) {
    if (token.isType(IToken.TYPE_IDENTIFIER)) {
      IToken next=token.next();
      if (next.isType(IToken.TYPE_OPEN_BRACKET)) {
        MethodCall call=new MethodCall(token,this.value,value);
        this.value=call;
        this.mode=PARAMETERS;
        return true;
      }
 else       if (!next.isType(IToken.TYPE_IDENTIFIER) && !next.isType(IToken.TYPE_CLOSE_BRACKET) && !next.isType(IToken.TYPE_SYMBOL)) {
        MethodCall call=new MethodCall(token,this.value,value);
        call.setSugar(true);
        this.value=call;
        ExpressionParser parser=new ExpressionParser(this.context,call);
        parser.lazy=true;
        pm.pushParser(parser);
        return true;
      }
 else {
        FieldAccess access=new FieldAccess(token,this.value,value);
        this.value=access;
        this.mode=ACCESS;
        return true;
      }
    }
  }
  if (this.isInMode(PARAMETERS)) {
    if (""String_Node_Str"".equals(value)) {
      pm.pushParser(new ExpressionListParser(this.context,(IValueList)this.value));
      this.mode=PARAMETERS_2;
      return true;
    }
  }
  if (this.isInMode(PARAMETERS_2)) {
    if (""String_Node_Str"".equals(value)) {
      this.value.expandPosition(token);
      this.mode=ACCESS;
      return true;
    }
  }
  if (this.value != null) {
    this.value.expandPosition(token);
    pm.popParser(true);
    return true;
  }
  return false;
}","@Override public boolean parse(ParserManager pm,String value,IToken token) throws SyntaxError {
  if (this.mode == 0 || ""String_Node_Str"".equals(value) || ""String_Node_Str"".equals(value) && !this.isInMode(PARAMETERS_2)) {
    pm.popParser(true);
    return true;
  }
  if (this.isInMode(VALUE)) {
    if (this.parsePrimitive(value,token)) {
      this.mode=ACCESS;
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      this.mode=ACCESS;
      this.value=new ThisValue(token,this.context.getThisType());
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      this.mode=ACCESS;
      this.value=new SuperValue(token,this.context.getThisType());
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      this.mode=TUPLE_END;
      this.value=new TupleValue();
      if (!token.next().equals(""String_Node_Str"")) {
        pm.pushParser(new ExpressionListParser(this.context,(IValueList)this.value));
      }
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      this.mode=VALUE_2;
      this.value=new StatementList(token);
      if (!token.next().equals(""String_Node_Str"")) {
        pm.pushParser(new ExpressionListParser(this.context,(IValueList)this.value,true));
      }
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      ConstructorCall call=new ConstructorCall(token);
      this.mode=PARAMETERS;
      this.value=call;
      pm.pushParser(new TypeParser(this.context,call));
      return true;
    }
 else     if (token.isType(IToken.TYPE_IDENTIFIER) && !token.next().isType(Token.TYPE_OPEN_BRACKET)) {
      this.mode=ACCESS;
      pm.pushParser(new TypeParser(this.context,this),true);
      return true;
    }
    this.mode=ACCESS;
  }
  if (this.isInMode(VALUE_2)) {
    if (""String_Node_Str"".equals(value)) {
      this.value.expandPosition(token);
      this.mode=ACCESS;
      return true;
    }
  }
  if (this.isInMode(TUPLE_END)) {
    if (""String_Node_Str"".equals(value)) {
      this.value.expandPosition(token);
      this.mode=ACCESS;
      return true;
    }
  }
  if (this.isInMode(STATEMENT)) {
    if (""String_Node_Str"".equals(value)) {
      ReturnStatement statement=new ReturnStatement(token);
      this.value=statement;
      pm.pushParser(new ExpressionParser(this.context,statement));
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      IfStatement statement=new IfStatement(token);
      this.value=statement;
      pm.pushParser(new IfStatementParser(this.context,statement));
      return true;
    }
  }
  if (this.isInMode(ACCESS)) {
    if (""String_Node_Str"".equals(value)) {
      this.mode=DOT_ACCESS;
      return true;
    }
    if (this.lazy && this.value != null) {
      pm.popParser(true);
      return true;
    }
    this.mode=DOT_ACCESS;
  }
  if (this.isInMode(DOT_ACCESS)) {
    if (token.isType(IToken.TYPE_IDENTIFIER)) {
      IToken next=token.next();
      if (next.isType(IToken.TYPE_OPEN_BRACKET)) {
        MethodCall call=new MethodCall(token,this.value,value);
        this.value=call;
        this.mode=PARAMETERS;
        return true;
      }
 else       if (!next.isType(IToken.TYPE_IDENTIFIER) && !next.isType(IToken.TYPE_CLOSE_BRACKET) && !next.isType(IToken.TYPE_SYMBOL)) {
        MethodCall call=new MethodCall(token,this.value,value);
        call.setSugar(true);
        this.value=call;
        ExpressionParser parser=new ExpressionParser(this.context,this);
        parser.lazy=true;
        pm.pushParser(parser);
        return true;
      }
 else {
        FieldAccess access=new FieldAccess(token,this.value,value);
        this.value=access;
        this.mode=ACCESS;
        return true;
      }
    }
  }
  if (this.isInMode(PARAMETERS)) {
    if (""String_Node_Str"".equals(value)) {
      pm.pushParser(new ExpressionListParser(this.context,(IValueList)this.value));
      this.mode=PARAMETERS_2;
      return true;
    }
  }
  if (this.isInMode(PARAMETERS_2)) {
    if (""String_Node_Str"".equals(value)) {
      this.value.expandPosition(token);
      this.mode=ACCESS;
      return true;
    }
  }
  if (this.value != null) {
    this.value.expandPosition(token);
    pm.popParser(true);
    return true;
  }
  return false;
}",0.9990608123972764
85388,"@Override public boolean parse(ParserManager pm,String value,IToken token) throws SyntaxError {
  if (this.mode == 0) {
    pm.popParser(true);
    return true;
  }
  if (this.isInMode(VALUE)) {
    if (this.parsePrimitive(value,token)) {
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      this.value=new ThisValue(token,this.context.getThisType());
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      this.mode=TUPLE_END;
      this.value=new TupleValue();
      if (!token.next().equals(""String_Node_Str"")) {
        pm.pushParser(new ExpressionListParser(this.context,(IValueList)this.value));
      }
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      this.mode=VALUE_2;
      this.value=new StatementList(token);
      if (!token.next().equals(""String_Node_Str"")) {
        pm.pushParser(new ExpressionListParser(this.context,(IValueList)this.value,true));
      }
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      ConstructorCall call=new ConstructorCall(token);
      this.mode=PARAMETERS;
      this.value=call;
      pm.pushParser(new TypeParser(this.context,call));
      return true;
    }
 else     if (token.isType(Token.TYPE_IDENTIFIER)) {
      pm.pushParser(new TypeParser(this.context,this),true);
      this.mode=ACCESS;
      return true;
    }
    this.mode=ACCESS;
  }
  if (this.isInMode(VALUE_2)) {
    if (""String_Node_Str"".equals(value)) {
      this.value.expandPosition(token);
      this.mode=ACCESS;
      return true;
    }
  }
  if (this.isInMode(TUPLE_END)) {
    if (""String_Node_Str"".equals(value)) {
      this.value.expandPosition(token);
      this.mode=ACCESS;
      return true;
    }
  }
  if (this.isInMode(STATEMENT)) {
    if (""String_Node_Str"".equals(value)) {
      ReturnStatement statement=new ReturnStatement(token);
      this.value=statement;
      pm.pushParser(new ExpressionParser(this.context,statement));
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      IfStatement statement=new IfStatement(token);
      this.value=statement;
      pm.pushParser(new IfStatementParser(this.context,statement));
      return true;
    }
  }
  if (this.isInMode(ACCESS)) {
    if (""String_Node_Str"".equals(value)) {
      this.mode=DOT_ACCESS;
      return true;
    }
 else     if (token.next().equals(""String_Node_Str"")) {
      this.mode=DOT_ACCESS;
    }
 else     if (token.isType(Token.TYPE_IDENTIFIER)) {
      this.mode=SUGARACCESS;
    }
  }
  if (this.isInMode(DOT_ACCESS)) {
    if (token.next().equals(""String_Node_Str"")) {
      MethodCall call=new MethodCall(token,this.value,value);
      this.value=call;
      this.mode=PARAMETERS;
      return true;
    }
 else {
      FieldAccess access=new FieldAccess(token,this.value,value);
      this.value=access;
      this.mode=VALUE;
      return true;
    }
  }
  if (this.isInMode(SUGARACCESS)) {
    MethodCall call=new MethodCall(token,this.value,value);
    call.setSugarCall(true);
    this.value=call;
    this.mode=0;
    pm.pushTryParser(new ExpressionParser(this.context,call),token.next());
    return true;
  }
  if (this.isInMode(PARAMETERS)) {
    if (""String_Node_Str"".equals(value)) {
      pm.pushParser(new ExpressionListParser(this.context,(IValueList)this.value));
      this.mode=PARAMETERS_2;
      return true;
    }
  }
  if (this.isInMode(PARAMETERS_2)) {
    if (""String_Node_Str"".equals(value)) {
      this.value.expandPosition(token);
      this.mode=ACCESS;
      return true;
    }
  }
  if (this.value != null) {
    this.value.expandPosition(token);
    pm.popParser(true);
    return true;
  }
  return false;
}","@Override public boolean parse(ParserManager pm,String value,IToken token) throws SyntaxError {
  if (this.mode == 0) {
    pm.popParser(true);
    return true;
  }
  if (this.isInMode(VALUE)) {
    if (this.parsePrimitive(value,token)) {
      this.mode=ACCESS;
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      this.mode=ACCESS;
      this.value=new ThisValue(token,this.context.getThisType());
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      this.mode=TUPLE_END;
      this.value=new TupleValue();
      if (!token.next().equals(""String_Node_Str"")) {
        pm.pushParser(new ExpressionListParser(this.context,(IValueList)this.value));
      }
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      this.mode=VALUE_2;
      this.value=new StatementList(token);
      if (!token.next().equals(""String_Node_Str"")) {
        pm.pushParser(new ExpressionListParser(this.context,(IValueList)this.value,true));
      }
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      ConstructorCall call=new ConstructorCall(token);
      this.mode=PARAMETERS;
      this.value=call;
      pm.pushParser(new TypeParser(this.context,call));
      return true;
    }
 else     if (token.isType(Token.TYPE_IDENTIFIER)) {
      this.mode=ACCESS;
      pm.pushParser(new TypeParser(this.context,this),true);
      return true;
    }
    this.mode=ACCESS;
  }
  if (this.isInMode(VALUE_2)) {
    if (""String_Node_Str"".equals(value)) {
      this.value.expandPosition(token);
      this.mode=ACCESS;
      return true;
    }
  }
  if (this.isInMode(TUPLE_END)) {
    if (""String_Node_Str"".equals(value)) {
      this.value.expandPosition(token);
      this.mode=ACCESS;
      return true;
    }
  }
  if (this.isInMode(STATEMENT)) {
    if (""String_Node_Str"".equals(value)) {
      ReturnStatement statement=new ReturnStatement(token);
      this.value=statement;
      pm.pushParser(new ExpressionParser(this.context,statement));
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      IfStatement statement=new IfStatement(token);
      this.value=statement;
      pm.pushParser(new IfStatementParser(this.context,statement));
      return true;
    }
  }
  if (this.isInMode(ACCESS)) {
    if (""String_Node_Str"".equals(value)) {
      this.mode=DOT_ACCESS;
      return true;
    }
 else     if (token.next().equals(""String_Node_Str"")) {
      this.mode=DOT_ACCESS;
    }
 else     if (token.isType(Token.TYPE_IDENTIFIER)) {
      this.mode=SUGARACCESS;
    }
  }
  if (this.isInMode(DOT_ACCESS)) {
    if (token.next().equals(""String_Node_Str"")) {
      MethodCall call=new MethodCall(token,this.value,value);
      this.value=call;
      this.mode=PARAMETERS;
      return true;
    }
 else {
      FieldAccess access=new FieldAccess(token,this.value,value);
      this.value=access;
      this.mode=VALUE;
      return true;
    }
  }
  if (this.isInMode(SUGARACCESS)) {
    MethodCall call=new MethodCall(token,this.value,value);
    call.setSugarCall(true);
    this.value=call;
    this.mode=0;
    pm.pushTryParser(new ExpressionParser(this.context,call),token.next());
    return true;
  }
  if (this.isInMode(PARAMETERS)) {
    if (""String_Node_Str"".equals(value)) {
      pm.pushParser(new ExpressionListParser(this.context,(IValueList)this.value));
      this.mode=PARAMETERS_2;
      return true;
    }
  }
  if (this.isInMode(PARAMETERS_2)) {
    if (""String_Node_Str"".equals(value)) {
      this.value.expandPosition(token);
      this.mode=ACCESS;
      return true;
    }
  }
  if (this.value != null) {
    this.value.expandPosition(token);
    pm.popParser(true);
    return true;
  }
  return false;
}",0.9771259418729816
85389,"@Override public Type getType(){
  return Type.CLASS;
}","@Override public Type getType(){
  return this.type;
}",0.8807339449541285
85390,"@Override public CompilationUnit applyState(CompilerState state,IContext context){
  if (state == CompilerState.TOKENIZE) {
    this.tokens=Dyvilc.parser.tokenize(this.getFile());
    return this;
  }
 else   if (state == CompilerState.PARSE) {
    Dyvilc.parser.pushParser(new CompilationUnitParser(this));
    Dyvilc.parser.parse(this.getFile(),this.tokens);
    this.tokens=null;
    return this;
  }
 else   if (state == CompilerState.DEBUG) {
    List<Marker> markers=this.getFile().markers;
    int size=markers.size();
    if (size > 0) {
      System.out.println(""String_Node_Str"" + this.name + ""String_Node_Str""+ size);
      for (      Marker marker : this.getFile().markers) {
        marker.print(System.err);
      }
    }
    return this;
  }
 else   if (state == CompilerState.RESOLVE_TYPES) {
switch (this.pack.check(this.packageDecl)) {
case 0:
      break;
case 1:
    state.addMarker(new SemanticError(new CodePosition((CodeFile)this.position,1,0,1),""String_Node_Str"",""String_Node_Str"" + this.pack.name + ""String_Node_Str""));
  break;
case 2:
state.addMarker(new SemanticError(this.packageDecl.getPosition(),""String_Node_Str"",""String_Node_Str"" + this.pack.name + ""String_Node_Str""));
break;
case 3:
state.addMarker(new SemanticError(this.packageDecl.getPosition(),""String_Node_Str"",""String_Node_Str""));
break;
}
for (IImport i : this.imports) {
i.applyState(state,this);
}
}
this.classes.replaceAll(c -> c.applyState(state,this));
return this;
}","@Override public CompilationUnit applyState(CompilerState state,IContext context){
  if (state == CompilerState.TOKENIZE) {
    this.tokens=Dyvilc.parser.tokenize(this.getFile());
    return this;
  }
 else   if (state == CompilerState.PARSE) {
    Dyvilc.parser.pushParser(new CompilationUnitParser(this));
    Dyvilc.parser.parse(this.getFile(),this.tokens);
    this.tokens=null;
    return this;
  }
 else   if (state == CompilerState.DEBUG) {
synchronized (this) {
      List<Marker> markers=this.getFile().markers;
      int size=markers.size();
      if (size > 0) {
        System.out.println(""String_Node_Str"" + this.name + ""String_Node_Str""+ size);
        for (        Marker marker : this.getFile().markers) {
          marker.print(System.err);
        }
      }
    }
    return this;
  }
 else   if (state == CompilerState.RESOLVE_TYPES) {
switch (this.pack.check(this.packageDecl)) {
case 0:
      break;
case 1:
    state.addMarker(new SemanticError(new CodePosition((CodeFile)this.position,1,0,1),""String_Node_Str"",""String_Node_Str"" + this.pack.name + ""String_Node_Str""));
  break;
case 2:
state.addMarker(new SemanticError(this.packageDecl.getPosition(),""String_Node_Str"",""String_Node_Str"" + this.pack.name + ""String_Node_Str""));
break;
case 3:
state.addMarker(new SemanticError(this.packageDecl.getPosition(),""String_Node_Str"",""String_Node_Str""));
break;
}
for (IImport i : this.imports) {
i.applyState(state,this);
}
}
this.classes.replaceAll(c -> c.applyState(state,this));
return this;
}",0.98453261600538
85391,"@Override public ClassAccess applyState(CompilerState state,IContext context){
  this.type=this.type.applyState(state,context);
  return this;
}","@Override public IValue applyState(CompilerState state,IContext context){
  if (state == CompilerState.RESOLVE_TYPES) {
    this.type=this.type.resolve(context);
  }
 else   if (state == CompilerState.RESOLVE) {
    if (!this.type.isResolved()) {
      String name=this.type.name;
      IField field=context.resolveField(name);
      if (field != null) {
        FieldAccess access=new FieldAccess(this.position,null,name);
        access.field=field;
        return access;
      }
      IMethod method=context.resolveMethod(name,Type.EMPTY_TYPES);
      if (method != null) {
        MethodCall call=new MethodCall(this.position,null,name);
        call.method=method;
        return call;
      }
      state.addMarker(new SemanticError(this.position,""String_Node_Str"" + name + ""String_Node_Str""));
    }
  }
  return this;
}",0.2078189300411522
85392,"@Override public FieldAccess applyState(CompilerState state,IContext context){
  if (this.instance != null) {
    this.instance=this.instance.applyState(state,context);
  }
  if (state == CompilerState.RESOLVE) {
    if (this.instance != null) {
      context=this.instance.getType();
    }
    this.field=context.resolveField(this.name);
    if (this.field == null) {
      state.addMarker(new SemanticError(this.position,""String_Node_Str"" + this.name + ""String_Node_Str""));
    }
 else     if (this.field.hasModifier(Modifiers.STATIC) && this.instance instanceof ThisValue) {
      state.addMarker(new Warning(this.position,""String_Node_Str"" + this.name + ""String_Node_Str""));
      this.instance=null;
    }
  }
  return this;
}","@Override public IValue applyState(CompilerState state,IContext context){
  if (this.instance != null) {
    this.instance=this.instance.applyState(state,context);
  }
  if (state == CompilerState.RESOLVE) {
    if (this.instance != null) {
      context=this.instance.getType();
    }
    this.field=context.resolveField(this.name);
    if (this.field == null) {
      IMethod method=context.resolveMethod(this.name,Type.EMPTY_TYPES);
      if (method != null) {
        MethodCall call=new MethodCall(this.position,this.instance,this.name);
        call.method=method;
        call.isSugarCall=true;
        return call;
      }
      state.addMarker(new SemanticError(this.position,""String_Node_Str"" + this.name + ""String_Node_Str""));
    }
 else     if (this.field.hasModifier(Modifiers.STATIC) && this.instance instanceof ThisValue) {
      state.addMarker(new Warning(this.position,""String_Node_Str"" + this.name + ""String_Node_Str""));
      this.instance=null;
    }
  }
  return this;
}",0.8352668213457076
85393,"@Override public Type getType(){
  return this.descriptor.getType();
}","@Override public Type getType(){
  return this.method.getType();
}",0.8970588235294118
85394,"@Override public IValue applyState(CompilerState state,IContext context){
  if (this.instance != null) {
    this.instance=this.instance.applyState(state,context);
  }
  super.applyState(state,context);
  if (state == CompilerState.RESOLVE) {
    if (this.instance != null) {
      context=this.instance.getType();
    }
    try {
      this.descriptor=context.resolveMethod(this.name,this.getTypes());
    }
 catch (    Exception ex) {
    }
    if (this.descriptor == null) {
      IField field=context.resolveField(this.name);
      if (field != null) {
        FieldAccess fieldAccess=new FieldAccess(this.position,this.instance,this.name);
        fieldAccess.field=field;
        fieldAccess.isSugarAccess=this.isSugarCall;
        return fieldAccess;
      }
      state.addMarker(new SemanticError(this.position,""String_Node_Str"" + this.name + ""String_Node_Str""));
    }
  }
  return this;
}","@Override public IValue applyState(CompilerState state,IContext context){
  if (this.instance != null) {
    this.instance=this.instance.applyState(state,context);
  }
  super.applyState(state,context);
  if (state == CompilerState.RESOLVE) {
    if (this.instance != null) {
      context=this.instance.getType();
    }
    try {
      this.method=context.resolveMethod(this.name,this.getTypes());
    }
 catch (    Exception ex) {
    }
    if (this.method == null) {
      IField field=context.resolveField(this.name);
      if (field != null) {
        FieldAccess fieldAccess=new FieldAccess(this.position,this.instance,this.name);
        fieldAccess.field=field;
        fieldAccess.isSugarAccess=this.isSugarCall;
        return fieldAccess;
      }
      state.addMarker(new SemanticError(this.position,""String_Node_Str"" + this.name + ""String_Node_Str""));
    }
  }
  return this;
}",0.982122905027933
85395,"@Override public Type applyState(CompilerState state,IContext context){
  if (this.position == null) {
    return this;
  }
  if (state == CompilerState.RESOLVE_TYPES) {
    if (this.theClass == null) {
switch (this.name) {
case ""String_Node_Str"":
        return VOID;
case ""String_Node_Str"":
      return INT;
case ""String_Node_Str"":
    return LONG;
case ""String_Node_Str"":
  return FLOAT;
case ""String_Node_Str"":
return DOUBLE;
case ""String_Node_Str"":
return CHAR;
case ""String_Node_Str"":
return BOOL;
}
this.theClass=context.resolveClass(this.name);
if (this.theClass == null) {
state.addMarker(new SemanticError(this.position,""String_Node_Str"" + this.name + ""String_Node_Str""));
}
}
}
return this;
}","@Override public Type applyState(CompilerState state,IContext context){
  if (this.position == null) {
    return this;
  }
  if (state == CompilerState.RESOLVE_TYPES) {
    Type type=this.resolve(context);
    if (!type.isResolved()) {
      state.addMarker(new SemanticError(this.position,""String_Node_Str"" + this.name + ""String_Node_Str""));
    }
    return type;
  }
  return this;
}",0.5279560036663611
85396,"/** 
 * Parses the given   {@link IToken} {@code token}. You can override this method to sort out comments.
 * @see Parser#parse(ParserManager,String,IToken)
 * @param value the value of the token
 * @param token the token
 * @throws SyntaxError syntax errors
 */
public void parseToken(String value,IToken token) throws SyntaxError {
  boolean parsed;
  try {
    parsed=this.currentParser.parse(this,value,token);
  }
 catch (  SyntaxError error) {
    throw error;
  }
catch (  Exception ex) {
    throw new SyntaxError(""String_Node_Str"" + value + ""String_Node_Str""+ ex.getMessage());
  }
  if (!parsed) {
    throw new SyntaxError(""String_Node_Str"" + value + ""String_Node_Str"",""String_Node_Str"");
  }
}","/** 
 * Parses the given   {@link IToken} {@code token}. You can override this method to sort out comments.
 * @see Parser#parse(ParserManager,String,IToken)
 * @param value the value of the token
 * @param token the token
 * @throws SyntaxError syntax errors
 */
public void parseToken(String value,IToken token) throws SyntaxError {
  boolean parsed;
  try {
    parsed=this.currentParser.parse(this,value,token);
  }
 catch (  SyntaxError error) {
    throw error;
  }
catch (  Exception ex) {
    String message=ex.getMessage();
    if (message == null) {
      message=ex.getClass().getName();
    }
    throw new SyntaxError(""String_Node_Str"" + value + ""String_Node_Str""+ message);
  }
  if (!parsed) {
    throw new SyntaxError(""String_Node_Str"" + value + ""String_Node_Str"",""String_Node_Str"");
  }
}",0.914021164021164
85397,"@Override public boolean parse(ParserManager pm,String value,IToken token) throws SyntaxError {
  int i=0;
  if (this.isInMode(TYPE)) {
    if ((i=Modifiers.parseModifier(value)) != -1) {
      this.field.addModifier(i);
      this.method.addModifier(i);
      return true;
    }
 else     if (token.isType(Token.TYPE_IDENTIFIER)) {
      if (token.next().equals(""String_Node_Str"")) {
        this.mode=FIELD;
        this.field.setName(value);
        this.classBody.addVariable(field);
        return true;
      }
 else       if (token.next().equals(""String_Node_Str"")) {
        this.mode=FIELD;
        this.field.setName(value);
        this.classBody.addVariable(this.field);
        this.reset();
        return true;
      }
 else       if (token.next().isType(Token.TYPE_BRACKET)) {
        this.mode=METHOD;
        this.method.setName(value);
        this.classBody.addMethod(this.method);
        return true;
      }
    }
 else     if (""String_Node_Str"".equals(value)) {
      this.reset();
      return true;
    }
    pm.pushParser(new TypeParser(this),token);
    return true;
  }
  if (this.isInMode(FIELD)) {
    if (""String_Node_Str"".equals(value)) {
      pm.pushParser(new ExpressionParser(this.theClass,this.field));
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      this.reset();
      return true;
    }
  }
  if (this.isInMode(METHOD)) {
    if (""String_Node_Str"".equals(value)) {
      pm.pushParser(new ParameterListParser(this.method));
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      this.mode=POST_METHOD;
      return true;
    }
  }
  if (this.isInMode(POST_METHOD)) {
    if (""String_Node_Str"".equals(value)) {
      pm.pushParser(new ThrowsDeclParser(this.method));
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      pm.pushParser(new ExpressionParser(this.method,this.method,true));
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      this.reset();
      return true;
    }
  }
  return false;
}","@Override public boolean parse(ParserManager pm,String value,IToken token) throws SyntaxError {
  int i=0;
  if (""String_Node_Str"".equals(value)) {
    pm.popParser(token);
    return true;
  }
  if (this.isInMode(TYPE)) {
    if ((i=Modifiers.parseModifier(value)) != -1) {
      this.field.addModifier(i);
      this.method.addModifier(i);
      return true;
    }
 else     if (token.isType(Token.TYPE_IDENTIFIER)) {
      if (token.next().equals(""String_Node_Str"")) {
        this.mode=FIELD;
        this.field.setName(value);
        this.classBody.addVariable(field);
        return true;
      }
 else       if (token.next().equals(""String_Node_Str"")) {
        this.mode=FIELD;
        this.field.setName(value);
        this.classBody.addVariable(this.field);
        this.reset();
        return true;
      }
 else       if (token.next().isType(Token.TYPE_BRACKET)) {
        this.mode=METHOD;
        this.method.setName(value);
        this.classBody.addMethod(this.method);
        return true;
      }
    }
 else     if (""String_Node_Str"".equals(value)) {
      this.reset();
      return true;
    }
    pm.pushParser(new TypeParser(this),token);
    return true;
  }
  if (this.isInMode(FIELD)) {
    if (""String_Node_Str"".equals(value)) {
      pm.pushParser(new ExpressionParser(this.theClass,this.field));
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      this.reset();
      return true;
    }
  }
  if (this.isInMode(METHOD)) {
    if (""String_Node_Str"".equals(value)) {
      pm.pushParser(new ParameterListParser(this.method));
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      this.mode=POST_METHOD;
      return true;
    }
  }
  if (this.isInMode(POST_METHOD)) {
    if (""String_Node_Str"".equals(value)) {
      pm.pushParser(new ThrowsDeclParser(this.method));
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      pm.pushParser(new ExpressionParser(this.method,this.method,true));
      return true;
    }
 else     if (""String_Node_Str"".equals(value)) {
      this.reset();
      return true;
    }
  }
  return false;
}",0.9792313201241346
85398,"@Override public boolean parse(ParserManager jcp,String value,IToken token) throws SyntaxError {
  if (this.isInMode(MODIFIERS)) {
    int i=0;
    if ((i=Modifiers.parseClassModifier(value)) != -1) {
      this.modifiers|=i;
      return true;
    }
 else     if ((i=Classes.parse(value)) != -1) {
      this.theClassDecl=AbstractClass.create(i);
      this.theClassDecl.setModifiers(this.modifiers);
      this.unit.addClass(this.theClassDecl);
      this.modifiers=0;
      this.mode=NAME;
      return true;
    }
  }
  if (this.isInMode(NAME)) {
    if (token.isType(Token.TYPE_IDENTIFIER)) {
      this.theClassDecl.setName(value);
      this.mode=EXTENDS | BODY;
      return true;
    }
  }
  if (this.isInMode(EXTENDS)) {
    if (""String_Node_Str"".equals(value)) {
      this.mode=SUPERCLASSES;
      return true;
    }
  }
  if (this.isInMode(SUPERCLASSES)) {
    if (token.isType(Token.TYPE_IDENTIFIER)) {
      this.theClassDecl.addSuperClass(this.unit.resolveClass(value));
      return true;
    }
  }
  if (this.isInMode(BODY)) {
    if (""String_Node_Str"".equals(value)) {
      jcp.pushParser(new ClassBodyParser(this.theClassDecl));
      this.mode=BODY_END;
      return true;
    }
  }
  if (this.isInMode(BODY_END)) {
    if (""String_Node_Str"".equals(value)) {
      jcp.popParser();
      this.mode=0;
      return true;
    }
  }
  return false;
}","@Override public boolean parse(ParserManager jcp,String value,IToken token) throws SyntaxError {
  if (this.isInMode(MODIFIERS)) {
    int i=0;
    if ((i=Modifiers.parseClassModifier(value)) != -1) {
      this.modifiers|=i;
      return true;
    }
 else     if ((i=Classes.parse(value)) != -1) {
      this.theClassDecl=AbstractClass.create(i);
      this.theClassDecl.setModifiers(this.modifiers);
      this.unit.addClass(this.theClassDecl);
      this.modifiers=0;
      this.mode=NAME;
      return true;
    }
  }
  if (this.isInMode(NAME)) {
    if (token.isType(Token.TYPE_IDENTIFIER)) {
      this.theClassDecl.setName(value);
      this.mode=EXTENDS | BODY;
      return true;
    }
  }
  if (this.isInMode(EXTENDS)) {
    if (""String_Node_Str"".equals(value)) {
      this.mode=SUPERCLASSES;
      return true;
    }
  }
  if (this.isInMode(SUPERCLASSES)) {
    if (token.isType(Token.TYPE_IDENTIFIER)) {
      this.theClassDecl.addSuperClass(this.unit.resolveClass(value));
      return true;
    }
  }
  if (this.isInMode(BODY)) {
    if (""String_Node_Str"".equals(value)) {
      jcp.pushParser(new ClassBodyParser(this.theClassDecl));
      this.mode=BODY_END;
      return true;
    }
  }
  if (this.isInMode(BODY_END)) {
    if (""String_Node_Str"".equals(value)) {
      jcp.popParser();
      return true;
    }
  }
  return false;
}",0.9930121368150056
85399,"@Override public void toString(String prefix,StringBuilder buffer){
  this.packageDecl.toString(""String_Node_Str"",buffer);
  buffer.append('\n');
  if (Formatting.Package.newLine) {
    buffer.append('\n');
  }
  for (  IImport iimport : this.imports) {
    iimport.toString(""String_Node_Str"",buffer);
    buffer.append('\n');
  }
  if (Formatting.Import.newLine) {
    buffer.append('\n');
  }
  for (  IClass iclass : this.classes) {
    iclass.toString(""String_Node_Str"",buffer);
    if (Formatting.Class.newLine) {
      buffer.append('\n');
    }
  }
}","@Override public void toString(String prefix,StringBuilder buffer){
  this.packageDecl.toString(""String_Node_Str"",buffer);
  buffer.append('\n');
  if (Formatting.Package.newLine) {
    buffer.append('\n');
  }
  if (!this.imports.isEmpty()) {
    for (    IImport iimport : this.imports) {
      iimport.toString(""String_Node_Str"",buffer);
      buffer.append('\n');
    }
    if (Formatting.Import.newLine) {
      buffer.append('\n');
    }
  }
  for (  IClass iclass : this.classes) {
    iclass.toString(""String_Node_Str"",buffer);
    if (Formatting.Class.newLine) {
      buffer.append('\n');
    }
  }
}",0.9460154241645244
85400,"@Override public Field applyState(CompilerState state){
  this.value=this.value.applyState(state);
  return this;
}","@Override public Field applyState(CompilerState state){
  if (this.value != null) {
    this.value=this.value.applyState(state);
  }
  return this;
}",0.8712121212121212
85401,public List<Parameter> getParameters();,"public Map<String,Parameter> getParameters();",0.8333333333333334
85402,"public Map<String,Parameter> getParameters(){
  return this.parameters;
}","@Override public Map<String,Parameter> getParameters(){
  return this.parameters;
}",0.935897435897436
85403,"public List<ThrowsDecl> getThrowsDecl(){
  return this.throwsDecl;
}","public List<ThrowsDecl> getThrowsDecl(){
  return this.throwsDeclarations;
}",0.9444444444444444
85404,"@Override public boolean addThrowsDecl(ThrowsDecl throwsDecl){
  return this.throwsDecl.add(throwsDecl);
}","@Override public boolean addThrowsDecl(ThrowsDecl throwsDecl){
  return this.throwsDeclarations.add(throwsDecl);
}",0.9636363636363636
85405,"public void setException(String exception) throws SyntaxException {
  if (this.exception != null) {
    throw new SyntaxException(""String_Node_Str"",exception);
  }
  this.exception=exception;
}","public void setException(String exception){
  this.exception=exception;
}",0.5488721804511278
85406,"@Override public void parse(ParserManager jcp,String value,IToken token) throws SyntaxException {
switch (value) {
case ""String_Node_Str"":
    this.mode=NAME;
  this.theClassDecl=new dyvil.tools.compiler.ast.classes.Class();
return;
case ""String_Node_Str"":
this.mode=NAME;
this.theClassDecl=new Interface();
return;
case ""String_Node_Str"":
this.mode=NAME;
this.theClassDecl=new dyvil.tools.compiler.ast.classes.Enum();
return;
case ""String_Node_Str"":
this.mode=NAME;
this.theClassDecl=new AnnotationClass();
return;
case ""String_Node_Str"":
this.mode=SUPERCLASSES;
return;
case ""String_Node_Str"":
this.theClassDecl.setModifiers(this.modifiers);
jcp.pushParser(new ClassBodyParser());
return;
}
switch (this.mode) {
case NAME:
this.theClassDecl.setName(value);
case SUPERCLASSES:
this.theClassDecl.addSuperClass(value);
}
}","@Override public void parse(ParserManager jcp,String value,IToken token) throws SyntaxException {
switch (value) {
case ""String_Node_Str"":
    this.mode=NAME;
  this.theClassDecl=new dyvil.tools.compiler.ast.classes.Class();
return;
case ""String_Node_Str"":
this.mode=NAME;
this.theClassDecl=new Interface();
return;
case ""String_Node_Str"":
this.mode=NAME;
this.theClassDecl=new dyvil.tools.compiler.ast.classes.Enum();
return;
case ""String_Node_Str"":
this.mode=NAME;
this.theClassDecl=new AnnotationClass();
return;
case ""String_Node_Str"":
this.mode=SUPERCLASSES;
return;
case ""String_Node_Str"":
this.theClassDecl.setModifiers(this.modifiers);
jcp.pushParser(new ClassBodyParser(this.theClassDecl));
return;
}
switch (this.mode) {
case NAME:
this.theClassDecl.setName(value);
case SUPERCLASSES:
this.theClassDecl.addSuperClass(value);
}
}",0.9897528631705846
85407,"private static void createSetDefaultFunctions(List<String> r,DbOperations dbOps){
  for (  Table table : dbOps.getDatabase().getTables()) {
    if (!table.isStem()) {
      StringBuilder line=new StringBuilder();
      String rTableName=convertToRName(table.getName());
      List<String> argDefs=new ArrayList<String>();
      List<String> insertLines=new ArrayList<String>();
      for (      Field field : table.getFields()) {
        String rFieldName=field.getName().replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
        argDefs.add(rFieldName);
        insertLines.add(""String_Node_Str"" + rFieldName + ""String_Node_Str"");
        insertLines.add(""String_Node_Str"" + rFieldName + ""String_Node_Str""+ rFieldName);
        insertLines.add(""String_Node_Str"");
      }
      line.append(""String_Node_Str"" + rTableName + ""String_Node_Str"");
      line.append(StringUtilities.join(argDefs,""String_Node_Str""));
      line.append(""String_Node_Str"");
      r.add(line.toString());
      r.add(""String_Node_Str"" + rTableName + ""String_Node_Str"");
      r.addAll(insertLines);
      r.add(""String_Node_Str"" + rTableName + ""String_Node_Str"");
      r.add(""String_Node_Str"");
      r.add(""String_Node_Str"");
      r.add(""String_Node_Str"");
    }
  }
}","private static void createSetDefaultFunctions(List<String> r,DbOperations dbOps){
  for (  Table table : dbOps.getDatabase().getTables()) {
    if (!table.isStem()) {
      StringBuilder line=new StringBuilder();
      String rTableName=convertToRName(table.getName());
      List<String> argDefs=new ArrayList<String>();
      List<String> insertLines=new ArrayList<String>();
      for (      Field field : table.getFields()) {
        String rFieldName=convertToRName(field.getName());
        argDefs.add(rFieldName);
        insertLines.add(""String_Node_Str"" + rFieldName + ""String_Node_Str"");
        insertLines.add(""String_Node_Str"" + rFieldName + ""String_Node_Str""+ rFieldName);
        insertLines.add(""String_Node_Str"");
      }
      line.append(""String_Node_Str"" + rTableName + ""String_Node_Str"");
      line.append(StringUtilities.join(argDefs,""String_Node_Str""));
      line.append(""String_Node_Str"");
      r.add(line.toString());
      r.add(""String_Node_Str"" + rTableName + ""String_Node_Str"");
      r.addAll(insertLines);
      r.add(""String_Node_Str"" + rTableName + ""String_Node_Str"");
      r.add(""String_Node_Str"");
      r.add(""String_Node_Str"");
      r.add(""String_Node_Str"");
    }
  }
}",0.9561053471667996
85408,"private static String convertToRName(String name){
  name=name.replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
  return name;
}","public static String convertToRName(String name){
  name=name.replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
  return name;
}",0.8521303258145363
85409,"private static void createInitFunction(List<String> r,DbOperations dbOps){
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  for (  Table table : dbOps.getDatabase().getTables()) {
    String sqlTableName=dbOps.convertToSqlName(table.getName());
    r.add(""String_Node_Str"" + sqlTableName + ""String_Node_Str""+ dbOps.clearTable(sqlTableName)+ ""String_Node_Str"");
  }
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"" + dbOps.dropTableIfExists(""String_Node_Str"") + ""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"" + dbOps.createTestResults() + ""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  for (  Table table : dbOps.getDatabase().getTables()) {
    if (!table.isStem()) {
      String rTableName=convertToRName(table.getName());
      r.add(""String_Node_Str"");
      r.add(""String_Node_Str"");
      for (      Field field : table.getFields()) {
        String rFieldName=field.getName().replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
        String defaultValue;
        if (field.getValueCounts().length == 0)         defaultValue=""String_Node_Str"";
 else         defaultValue=field.getValueCounts()[0][0];
        if (!defaultValue.equals(""String_Node_Str"") && !defaultValue.equals(""String_Node_Str""))         r.add(""String_Node_Str"" + rFieldName + ""String_Node_Str""+ defaultValue+ ""String_Node_Str"");
      }
      r.add(""String_Node_Str"" + rTableName + ""String_Node_Str"");
    }
  }
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
}","private static void createInitFunction(List<String> r,DbOperations dbOps){
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  for (  Table table : dbOps.getDatabase().getTables()) {
    String sqlTableName=dbOps.convertToSqlName(table.getName());
    r.add(""String_Node_Str"" + sqlTableName + ""String_Node_Str""+ dbOps.clearTable(sqlTableName)+ ""String_Node_Str"");
  }
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"" + dbOps.dropTableIfExists(""String_Node_Str"") + ""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"" + dbOps.createTestResults() + ""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  for (  Table table : dbOps.getDatabase().getTables()) {
    if (!table.isStem()) {
      String rTableName=convertToRName(table.getName());
      r.add(""String_Node_Str"");
      r.add(""String_Node_Str"");
      for (      Field field : table.getFields()) {
        String rFieldName=convertToRName(field.getName());
        String defaultValue;
        if (field.getValueCounts().length == 0)         defaultValue=""String_Node_Str"";
 else         defaultValue=field.getValueCounts()[0][0];
        if (!defaultValue.equals(""String_Node_Str"") && !defaultValue.equals(""String_Node_Str""))         r.add(""String_Node_Str"" + rFieldName + ""String_Node_Str""+ defaultValue+ ""String_Node_Str"");
      }
      r.add(""String_Node_Str"" + rTableName + ""String_Node_Str"");
    }
  }
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
}",0.968499427262314
85410,"private static void createAddFunctions(List<String> r,DbOperations dbOps){
  for (  Table table : dbOps.getDatabase().getTables()) {
    if (!table.isStem()) {
      StringBuilder line=new StringBuilder();
      String rTableName=convertToRName(table.getName());
      List<String> argDefs=new ArrayList<String>();
      for (      Field field : table.getFields()) {
        String rFieldName=field.getName().replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
        argDefs.add(rFieldName);
      }
      List<String> insertLines=dbOps.getInsertValues(table);
      line.append(""String_Node_Str"" + rTableName + ""String_Node_Str"");
      line.append(StringUtilities.join(argDefs,""String_Node_Str""));
      line.append(""String_Node_Str"");
      r.add(line.toString());
      r.add(""String_Node_Str"" + rTableName + ""String_Node_Str"");
      r.add(""String_Node_Str"");
      r.add(""String_Node_Str"");
      r.addAll(insertLines);
      r.add(""String_Node_Str"");
      r.add(""String_Node_Str"");
      r.add(""String_Node_Str"");
      r.add(""String_Node_Str"");
      r.add(""String_Node_Str"");
      r.add(""String_Node_Str"");
      r.add(""String_Node_Str"" + table + ""String_Node_Str"");
      r.add(""String_Node_Str"");
      r.add(dbOps.getInsertStatement(table));
      r.add(""String_Node_Str"" + table + ""String_Node_Str"");
      r.add(""String_Node_Str"");
      r.add(""String_Node_Str"");
      r.add(""String_Node_Str"");
    }
  }
}","private static void createAddFunctions(List<String> r,DbOperations dbOps){
  for (  Table table : dbOps.getDatabase().getTables()) {
    if (!table.isStem()) {
      StringBuilder line=new StringBuilder();
      String rTableName=convertToRName(table.getName());
      List<String> argDefs=new ArrayList<String>();
      for (      Field field : table.getFields()) {
        String rFieldName=convertToRName(field.getName());
        argDefs.add(rFieldName);
      }
      List<String> insertLines=dbOps.getInsertValues(table);
      line.append(""String_Node_Str"" + rTableName + ""String_Node_Str"");
      line.append(StringUtilities.join(argDefs,""String_Node_Str""));
      line.append(""String_Node_Str"");
      r.add(line.toString());
      r.add(""String_Node_Str"" + rTableName + ""String_Node_Str"");
      r.add(""String_Node_Str"");
      r.add(""String_Node_Str"");
      r.addAll(insertLines);
      r.add(""String_Node_Str"");
      r.add(""String_Node_Str"");
      r.add(""String_Node_Str"");
      r.add(""String_Node_Str"");
      r.add(""String_Node_Str"");
      r.add(""String_Node_Str"");
      r.add(""String_Node_Str"" + table + ""String_Node_Str"");
      r.add(""String_Node_Str"");
      r.add(dbOps.getInsertStatement(table));
      r.add(""String_Node_Str"" + table + ""String_Node_Str"");
      r.add(""String_Node_Str"");
      r.add(""String_Node_Str"");
      r.add(""String_Node_Str"");
    }
  }
}",0.9615384615384616
85411,"private static void createGenerateInsertSqlFunction(List<String> r,DbOperations dbOps){
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  String tableFooter=dbOps.getTableFooter();
  if (tableFooter != null && !tableFooter.isEmpty()) {
    r.add(""String_Node_Str"");
    r.add(""String_Node_Str"" + dbOps.dropTableIfExists() + ""String_Node_Str"");
    r.add(""String_Node_Str"" + tableFooter + ""String_Node_Str"");
  }
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
}","private static void createGenerateInsertSqlFunction(List<String> r,DbOperations dbOps){
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  String tableFooter=dbOps.getTableFooter();
  if (tableFooter != null && !tableFooter.isEmpty()) {
    r.add(""String_Node_Str"");
    r.add(""String_Node_Str"" + dbOps.dropTableIfExists() + ""String_Node_Str"");
    r.add(""String_Node_Str"" + tableFooter + ""String_Node_Str"");
  }
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
  r.add(""String_Node_Str"");
}",0.7460701330108828
85412,"@Override public List<String> getInsertValues(Table table){
  List<String> result=new ArrayList<String>();
  for (  Field field : table.getFields()) {
    String rFieldName=field.getName().replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
    result.add(""String_Node_Str"" + rFieldName + ""String_Node_Str"");
    result.add(""String_Node_Str"" + rFieldName + ""String_Node_Str""+ rFieldName);
    result.add(""String_Node_Str"" + rFieldName + ""String_Node_Str""+ rFieldName+ ""String_Node_Str"");
    result.add(""String_Node_Str"");
    result.add(""String_Node_Str"" + rFieldName + ""String_Node_Str""+ rFieldName+ ""String_Node_Str"");
    result.add(""String_Node_Str"" + rFieldName + ""String_Node_Str"");
    result.add(""String_Node_Str"");
  }
  return result;
}","@Override public List<String> getInsertValues(Table table){
  List<String> result=new ArrayList<String>();
  for (  Field field : table.getFields()) {
    String rFieldName=ETLTestFrameWorkGenerator.convertToRName(field.getName());
    result.add(""String_Node_Str"" + rFieldName + ""String_Node_Str"");
    result.add(""String_Node_Str"" + rFieldName + ""String_Node_Str""+ rFieldName);
    result.add(""String_Node_Str"" + rFieldName + ""String_Node_Str""+ rFieldName+ ""String_Node_Str"");
    result.add(""String_Node_Str"");
    result.add(""String_Node_Str"" + rFieldName + ""String_Node_Str""+ rFieldName+ ""String_Node_Str"");
    result.add(""String_Node_Str"" + rFieldName + ""String_Node_Str"");
    result.add(""String_Node_Str"");
  }
  return result;
}",0.9111111111111112
85413,"@Override public List<String> getInsertValues(Table table){
  List<String> result=new ArrayList<String>();
  for (  Field field : table.getFields()) {
    String rFieldName=field.getName().replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
    String sqlFieldName=this.convertToSqlName(field.getName());
    result.add(""String_Node_Str"" + rFieldName + ""String_Node_Str"");
    result.add(""String_Node_Str"" + rFieldName + ""String_Node_Str""+ rFieldName);
    result.add(""String_Node_Str"");
    result.add(""String_Node_Str"" + rFieldName + ""String_Node_Str"");
    result.add(""String_Node_Str"" + sqlFieldName + ""String_Node_Str"");
    result.add(""String_Node_Str"" + rFieldName + ""String_Node_Str"");
    result.add(""String_Node_Str"");
    result.add(""String_Node_Str"");
  }
  return result;
}","@Override public List<String> getInsertValues(Table table){
  List<String> result=new ArrayList<String>();
  for (  Field field : table.getFields()) {
    String rFieldName=ETLTestFrameWorkGenerator.convertToRName(field.getName());
    String sqlFieldName=this.convertToSqlName(field.getName());
    result.add(""String_Node_Str"" + rFieldName + ""String_Node_Str"");
    result.add(""String_Node_Str"" + rFieldName + ""String_Node_Str""+ rFieldName);
    result.add(""String_Node_Str"");
    result.add(""String_Node_Str"" + rFieldName + ""String_Node_Str"");
    result.add(""String_Node_Str"" + sqlFieldName + ""String_Node_Str"");
    result.add(""String_Node_Str"" + rFieldName + ""String_Node_Str"");
    result.add(""String_Node_Str"");
    result.add(""String_Node_Str"");
  }
  return result;
}",0.4788557213930348
85414,"private void LabeledRectangleClicked(MouseEvent event,List<LabeledRectangle> components){
  int startIndex=0;
  int endIndex=0;
  for (  LabeledRectangle component : components) {
    if (component.contains(event.getPoint())) {
      if (event.isControlDown()) {
        component.toggleSelected();
      }
 else       if (event.isShiftDown()) {
        startIndex=Math.min(components.indexOf(lastSelectedRectangle),components.indexOf(component));
        endIndex=Math.max(components.indexOf(lastSelectedRectangle),components.indexOf(component));
        if (startIndex >= 0 && endIndex >= 0) {
          for (int i=startIndex; i <= endIndex; i++) {
            components.get(i).setSelected(true);
          }
        }
 else {
          component.toggleSelected();
        }
      }
 else {
        component.setSelected(true);
      }
      if (component.isSelected()) {
        lastSelectedRectangle=component;
      }
 else {
        lastSelectedRectangle=null;
      }
      detailsListener.showDetails(component.getItem());
      repaint();
      break;
    }
  }
}","private void LabeledRectangleClicked(MouseEvent event,List<LabeledRectangle> components){
  int startIndex=0;
  int endIndex=0;
  for (  LabeledRectangle component : components) {
    if (component.contains(event.getPoint())) {
      if ((event.getModifiers() & shortcutMask) == shortcutMask) {
        component.toggleSelected();
      }
 else       if (event.isShiftDown()) {
        startIndex=Math.min(components.indexOf(lastSelectedRectangle),components.indexOf(component));
        endIndex=Math.max(components.indexOf(lastSelectedRectangle),components.indexOf(component));
        if (startIndex >= 0 && endIndex >= 0) {
          for (int i=startIndex; i <= endIndex; i++) {
            components.get(i).setSelected(true);
          }
        }
 else {
          component.toggleSelected();
        }
      }
 else {
        component.setSelected(true);
      }
      if (component.isSelected()) {
        lastSelectedRectangle=component;
      }
 else {
        lastSelectedRectangle=null;
      }
      detailsListener.showDetails(component.getItem());
      repaint();
      break;
    }
  }
}",0.9715335169880625
85415,"@Override public void mouseClicked(MouseEvent event){
  Hashtable<HighlightStatus,List<Arrow>> currentArrowStatus=new Hashtable<HighlightStatus,List<Arrow>>();
  for (  HighlightStatus status : HighlightStatus.values()) {
    currentArrowStatus.put(status,arrowsByStatus(status));
  }
  if (selectedArrow != null) {
    selectedArrow.setSelected(false);
    detailsListener.showDetails(null);
    selectedArrow=null;
  }
  if (!event.isShiftDown() && !event.isControlDown()) {
    for (    LabeledRectangle component : cdmComponents) {
      component.setSelected(false);
    }
    for (    LabeledRectangle component : sourceComponents) {
      component.setSelected(false);
    }
  }
  if (event.getX() > sourceX && event.getX() < sourceX + ITEM_WIDTH) {
    LabeledRectangleClicked(event,getVisibleSourceComponents());
  }
 else   if (event.getX() > cdmX && event.getX() < cdmX + ITEM_WIDTH) {
    LabeledRectangleClicked(event,getVisibleTargetComponents());
  }
 else   if (event.getX() > sourceX + ITEM_WIDTH && event.getX() < cdmX) {
    Arrow clickedArrow=null;
    for (    HighlightStatus status : HighlightStatus.values()) {
      for (      Arrow arrow : currentArrowStatus.get(status)) {
        if (arrow.contains(event.getPoint())) {
          clickedArrow=arrow;
          break;
        }
      }
      if (clickedArrow != null) {
        break;
      }
    }
    if (clickedArrow != null) {
      if (event.getClickCount() == 2) {
        zoomArrow=clickedArrow;
        if (slaveMappingPanel != null) {
          slaveMappingPanel.setMapping(ObjectExchange.etl.getFieldToFieldMapping((Table)zoomArrow.getSource().getItem(),(Table)zoomArrow.getTarget().getItem()));
          new AnimateThread(true).start();
          slaveMappingPanel.filterComponents(""String_Node_Str"",false);
          slaveMappingPanel.filterComponents(""String_Node_Str"",true);
        }
      }
 else {
        if (!clickedArrow.isSelected()) {
          clickedArrow.setSelected(true);
          selectedArrow=clickedArrow;
          detailsListener.showDetails(mapping.getSourceToTargetMap(selectedArrow.getSource().getItem(),selectedArrow.getTarget().getItem()));
        }
        repaint();
      }
    }
 else {
      detailsListener.showDetails(null);
    }
  }
 else {
    detailsListener.showDetails(null);
  }
}","@Override public void mouseClicked(MouseEvent event){
  Hashtable<HighlightStatus,List<Arrow>> currentArrowStatus=new Hashtable<HighlightStatus,List<Arrow>>();
  for (  HighlightStatus status : HighlightStatus.values()) {
    currentArrowStatus.put(status,arrowsByStatus(status));
  }
  if (selectedArrow != null) {
    selectedArrow.setSelected(false);
    detailsListener.showDetails(null);
    selectedArrow=null;
  }
  if (!event.isShiftDown() && !((event.getModifiers() & shortcutMask) == shortcutMask)) {
    for (    LabeledRectangle component : cdmComponents) {
      component.setSelected(false);
    }
    for (    LabeledRectangle component : sourceComponents) {
      component.setSelected(false);
    }
  }
  if (event.getX() > sourceX && event.getX() < sourceX + ITEM_WIDTH) {
    LabeledRectangleClicked(event,getVisibleSourceComponents());
  }
 else   if (event.getX() > cdmX && event.getX() < cdmX + ITEM_WIDTH) {
    LabeledRectangleClicked(event,getVisibleTargetComponents());
  }
 else   if (event.getX() > sourceX + ITEM_WIDTH && event.getX() < cdmX) {
    lastSelectedRectangle=null;
    Arrow clickedArrow=null;
    for (    HighlightStatus status : HighlightStatus.values()) {
      for (      Arrow arrow : currentArrowStatus.get(status)) {
        if (arrow.contains(event.getPoint())) {
          clickedArrow=arrow;
          break;
        }
      }
      if (clickedArrow != null) {
        break;
      }
    }
    if (clickedArrow != null) {
      if (event.getClickCount() == 2) {
        zoomArrow=clickedArrow;
        if (slaveMappingPanel != null) {
          slaveMappingPanel.setMapping(ObjectExchange.etl.getFieldToFieldMapping((Table)zoomArrow.getSource().getItem(),(Table)zoomArrow.getTarget().getItem()));
          new AnimateThread(true).start();
          slaveMappingPanel.filterComponents(""String_Node_Str"",false);
          slaveMappingPanel.filterComponents(""String_Node_Str"",true);
        }
      }
 else {
        if (!clickedArrow.isSelected()) {
          clickedArrow.setSelected(true);
          selectedArrow=clickedArrow;
          detailsListener.showDetails(mapping.getSourceToTargetMap(selectedArrow.getSource().getItem(),selectedArrow.getTarget().getItem()));
        }
        repaint();
      }
    }
 else {
      detailsListener.showDetails(null);
    }
  }
 else {
    lastSelectedRectangle=null;
    detailsListener.showDetails(null);
  }
}",0.9733050847457628
85416,"private void doSetTargetCustom(String fileName){
  ETL etl=new ETL(ObjectExchange.etl.getSourceDatabase(),Database.generateModelFromCSV(fileName));
  etl.copyETLMappings(ObjectExchange.etl);
  tableMappingPanel.setMapping(etl.getTableToTableMapping());
  ObjectExchange.etl=etl;
}","private void doSetTargetCustom(String fileName){
  if (fileName != null) {
    File file=new File(fileName);
    InputStream stream;
    try {
      stream=new FileInputStream(file);
      ETL etl=new ETL(ObjectExchange.etl.getSourceDatabase(),Database.generateModelFromCSV(stream,file.getName()));
      etl.copyETLMappings(ObjectExchange.etl);
      tableMappingPanel.setMapping(etl.getTableToTableMapping());
      ObjectExchange.etl=etl;
    }
 catch (    IOException e) {
    }
  }
}",0.7083333333333334
85417,"private JMenuBar createMenuBar(){
  JMenuBar menuBar=new JMenuBar();
  JMenu fileMenu=new JMenu(""String_Node_Str"");
  menuBar.add(fileMenu);
  JMenuItem openItem=new JMenuItem(""String_Node_Str"");
  openItem.addActionListener(this);
  openItem.setActionCommand(ACTION_CMD_OPEN_ETL_SPECS);
  openItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_O,InputEvent.CTRL_MASK));
  fileMenu.add(openItem);
  JMenuItem openScanReportItem=new JMenuItem(""String_Node_Str"");
  openScanReportItem.addActionListener(this);
  openScanReportItem.setActionCommand(ACTION_CMD_OPEN_SCAN_REPORT);
  fileMenu.add(openScanReportItem);
  JMenuItem saveItem=new JMenuItem(""String_Node_Str"");
  saveItem.addActionListener(this);
  saveItem.setActionCommand(ACTION_CMD_SAVE);
  saveItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_S,InputEvent.CTRL_MASK));
  fileMenu.add(saveItem);
  JMenuItem saveAsItem=new JMenuItem(""String_Node_Str"");
  saveAsItem.addActionListener(this);
  saveAsItem.setActionCommand(ACTION_CMD_SAVE_AS);
  fileMenu.add(saveAsItem);
  JMenuItem generateDocItem=new JMenuItem(""String_Node_Str"");
  generateDocItem.addActionListener(this);
  generateDocItem.setActionCommand(ACTION_CMD_GENERATE_ETL_DOCUMENT);
  fileMenu.add(generateDocItem);
  JMenu editMenu=new JMenu(""String_Node_Str"");
  menuBar.add(editMenu);
  JMenuItem discardCounts=new JMenuItem(ACTION_CMD_DISCARD_COUNTS);
  discardCounts.addActionListener(this);
  discardCounts.setActionCommand(ACTION_CMD_DISCARD_COUNTS);
  editMenu.add(discardCounts);
  JMenuItem filter=new JMenuItem(ACTION_CMD_FILTER);
  filter.addActionListener(this);
  filter.setActionCommand(ACTION_CMD_FILTER);
  filter.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F,ActionEvent.CTRL_MASK));
  editMenu.add(filter);
  JMenuItem makeMappings=new JMenuItem(ACTION_CMD_MAKE_MAPPING);
  makeMappings.addActionListener(this);
  makeMappings.setActionCommand(ACTION_CMD_MAKE_MAPPING);
  makeMappings.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_M,ActionEvent.CTRL_MASK));
  editMenu.add(makeMappings);
  JMenuItem removeMappings=new JMenuItem(ACTION_CMD_REMOVE_MAPPING);
  removeMappings.addActionListener(this);
  removeMappings.setActionCommand(ACTION_CMD_REMOVE_MAPPING);
  removeMappings.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_R,ActionEvent.CTRL_MASK));
  editMenu.add(removeMappings);
  JMenu setTarget=new JMenu(""String_Node_Str"");
  JMenuItem targetCDMV4=new JMenuItem(ACTION_CMD_SET_TARGET_V4);
  targetCDMV4.addActionListener(this);
  targetCDMV4.setActionCommand(ACTION_CMD_SET_TARGET_V4);
  setTarget.add(targetCDMV4);
  editMenu.add(setTarget);
  JMenuItem targetCDMV5=new JMenuItem(ACTION_CMD_SET_TARGET_V5);
  targetCDMV5.addActionListener(this);
  targetCDMV5.setActionCommand(ACTION_CMD_SET_TARGET_V5);
  setTarget.add(targetCDMV5);
  editMenu.add(setTarget);
  return menuBar;
}","private JMenuBar createMenuBar(){
  JMenuBar menuBar=new JMenuBar();
  JMenu fileMenu=new JMenu(""String_Node_Str"");
  int menuShortcutMask=Toolkit.getDefaultToolkit().getMenuShortcutKeyMask();
  menuBar.add(fileMenu);
  JMenuItem openItem=new JMenuItem(""String_Node_Str"");
  openItem.addActionListener(this);
  openItem.setActionCommand(ACTION_CMD_OPEN_ETL_SPECS);
  openItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_O,menuShortcutMask));
  fileMenu.add(openItem);
  JMenuItem openScanReportItem=new JMenuItem(""String_Node_Str"");
  openScanReportItem.addActionListener(this);
  openScanReportItem.setActionCommand(ACTION_CMD_OPEN_SCAN_REPORT);
  fileMenu.add(openScanReportItem);
  JMenuItem saveItem=new JMenuItem(""String_Node_Str"");
  saveItem.addActionListener(this);
  saveItem.setActionCommand(ACTION_CMD_SAVE);
  saveItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_S,menuShortcutMask));
  fileMenu.add(saveItem);
  JMenuItem saveAsItem=new JMenuItem(""String_Node_Str"");
  saveAsItem.addActionListener(this);
  saveAsItem.setActionCommand(ACTION_CMD_SAVE_AS);
  fileMenu.add(saveAsItem);
  JMenuItem generateDocItem=new JMenuItem(""String_Node_Str"");
  generateDocItem.addActionListener(this);
  generateDocItem.setActionCommand(ACTION_CMD_GENERATE_ETL_DOCUMENT);
  fileMenu.add(generateDocItem);
  JMenu editMenu=new JMenu(""String_Node_Str"");
  menuBar.add(editMenu);
  JMenuItem discardCounts=new JMenuItem(ACTION_CMD_DISCARD_COUNTS);
  discardCounts.addActionListener(this);
  discardCounts.setActionCommand(ACTION_CMD_DISCARD_COUNTS);
  editMenu.add(discardCounts);
  JMenuItem filter=new JMenuItem(ACTION_CMD_FILTER);
  filter.addActionListener(this);
  filter.setActionCommand(ACTION_CMD_FILTER);
  filter.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F,menuShortcutMask));
  editMenu.add(filter);
  JMenuItem makeMappings=new JMenuItem(ACTION_CMD_MAKE_MAPPING);
  makeMappings.addActionListener(this);
  makeMappings.setActionCommand(ACTION_CMD_MAKE_MAPPING);
  makeMappings.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_M,menuShortcutMask));
  editMenu.add(makeMappings);
  JMenuItem removeMappings=new JMenuItem(ACTION_CMD_REMOVE_MAPPING);
  removeMappings.addActionListener(this);
  removeMappings.setActionCommand(ACTION_CMD_REMOVE_MAPPING);
  removeMappings.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_R,menuShortcutMask));
  editMenu.add(removeMappings);
  JMenu setTarget=new JMenu(""String_Node_Str"");
  JMenuItem targetCDMV4=new JMenuItem(ACTION_CMD_SET_TARGET_V4);
  targetCDMV4.addActionListener(this);
  targetCDMV4.setActionCommand(ACTION_CMD_SET_TARGET_V4);
  setTarget.add(targetCDMV4);
  editMenu.add(setTarget);
  JMenuItem targetCDMV5=new JMenuItem(ACTION_CMD_SET_TARGET_V5);
  targetCDMV5.addActionListener(this);
  targetCDMV5.setActionCommand(ACTION_CMD_SET_TARGET_V5);
  setTarget.add(targetCDMV5);
  editMenu.add(setTarget);
  return menuBar;
}",0.9548611111111112
85418,"private void doSetTargetCustom(String fileName){
  ETL etl=new ETL(ObjectExchange.etl.getSourceDatabase(),Database.generateModelFromCSV(fileName));
  etl.copyETLMappings(ObjectExchange.etl);
  tableMappingPanel.setMapping(etl.getTableToTableMapping());
  ObjectExchange.etl=etl;
}","private void doSetTargetCustom(String fileName){
  if (fileName != null) {
    File file=new File(fileName);
    InputStream stream;
    try {
      stream=new FileInputStream(file);
      ETL etl=new ETL(ObjectExchange.etl.getSourceDatabase(),Database.generateModelFromCSV(stream,file.getName()));
      etl.copyETLMappings(ObjectExchange.etl);
      tableMappingPanel.setMapping(etl.getTableToTableMapping());
      ObjectExchange.etl=etl;
    }
 catch (    IOException e) {
    }
  }
}",0.7083333333333334
85419,"public Arrow(LabeledRectangle source,LabeledRectangle target){
  this.source=source;
  this.target=target;
}","public Arrow(LabeledRectangle source,LabeledRectangle target,ItemToItemMap itemToItemMap){
  this.source=source;
  this.target=target;
  this.itemToItemMap=itemToItemMap;
}",0.7714285714285715
85420,"public HighlightStatus getHighlightStatus(){
  if (isSelected()) {
    return HighlightStatus.IS_SELECTED;
  }
 else   if (isSourceSelected() && isTargetSelected()) {
    return HighlightStatus.BOTH_SELECTED;
  }
 else   if (isSourceSelected()) {
    return HighlightStatus.SOURCE_SELECTED;
  }
 else   if (isTargetSelected()) {
    return HighlightStatus.TARGET_SELECTED;
  }
 else   if (isCompleted()) {
    return HighlightStatus.IS_COMPLETED;
  }
 else {
    return HighlightStatus.NONE_SELECTED;
  }
}","public HighlightStatus getHighlightStatus(){
  if (isSelected()) {
    return HighlightStatus.IS_SELECTED;
  }
 else   if (isSourceSelected() && isTargetSelected()) {
    return HighlightStatus.BOTH_SELECTED;
  }
 else   if (isSourceSelected()) {
    return HighlightStatus.SOURCE_SELECTED;
  }
 else   if (isTargetSelected()) {
    return HighlightStatus.TARGET_SELECTED;
  }
 else   if (isCompleted() && getHideCompleted()) {
    return HighlightStatus.IS_COMPLETED;
  }
 else {
    return HighlightStatus.NONE_SELECTED;
  }
}",0.9787234042553192
85421,"public boolean isCompleted(){
  return isCompleted;
}","public boolean isCompleted(){
  if (getItemToItemMap() != null) {
    return (!getItemToItemMap().getComment().equals(""String_Node_Str"")) || (!getItemToItemMap().getLogic().equals(""String_Node_Str""));
  }
 else {
    return false;
  }
}",0.2698961937716263
85422,"private void makeMapSourceToTarget(LabeledRectangle source,LabeledRectangle target){
  boolean isNew=true;
  for (  Arrow other : arrows) {
    if (source == other.getSource() && target == other.getTarget()) {
      isNew=false;
    }
  }
  if (isNew) {
    Arrow arrow=new Arrow(source);
    arrow.setTarget(target);
    arrows.add(arrow);
    mapping.addSourceToTargetMap(source.getItem(),target.getItem());
  }
  repaint();
}","private void makeMapSourceToTarget(LabeledRectangle source,LabeledRectangle target){
  boolean isNew=true;
  for (  Arrow other : arrows) {
    if (source == other.getSource() && target == other.getTarget()) {
      isNew=false;
    }
  }
  if (isNew) {
    Arrow arrow=new Arrow(source);
    arrow.setTarget(target);
    mapping.addSourceToTargetMap(source.getItem(),target.getItem());
    arrow.setItemToItemMap(mapping.getSourceToTargetMap(source.getItem(),target.getItem()));
    arrow.setHideCompleted(hiding);
    arrows.add(arrow);
  }
  repaint();
}",0.8223350253807107
85423,"@Override public void mouseClicked(MouseEvent event){
  Hashtable<HighlightStatus,List<Arrow>> currentArrowStatus=new Hashtable<HighlightStatus,List<Arrow>>();
  for (  HighlightStatus status : HighlightStatus.values()) {
    currentArrowStatus.put(status,arrowsByStatus(status));
  }
  if (selectedArrow != null) {
    selectedArrow.setSelected(false);
    detailsListener.showDetails(null);
    selectedArrow=null;
  }
  if (!event.isShiftDown() && !event.isControlDown()) {
    for (    LabeledRectangle component : cdmComponents) {
      component.setSelected(false);
    }
    for (    LabeledRectangle component : sourceComponents) {
      component.setSelected(false);
    }
  }
  if (event.getX() > sourceX && event.getX() < sourceX + ITEM_WIDTH) {
    LabeledRectangleClicked(event,getVisibleSourceComponents());
  }
 else   if (event.getX() > cdmX && event.getX() < cdmX + ITEM_WIDTH) {
    LabeledRectangleClicked(event,getVisibleTargetComponents());
  }
 else   if (event.getX() > sourceX + ITEM_WIDTH && event.getX() < cdmX) {
    Arrow clickedArrow=null;
    for (    HighlightStatus status : HighlightStatus.values()) {
      for (      Arrow arrow : currentArrowStatus.get(status)) {
        if (arrow.contains(event.getPoint())) {
          clickedArrow=arrow;
          break;
        }
      }
      if (clickedArrow != null) {
        break;
      }
    }
    if (clickedArrow != null) {
      if (event.getClickCount() == 2) {
        zoomArrow=clickedArrow;
        if (slaveMappingPanel != null) {
          slaveMappingPanel.setMapping(ObjectExchange.etl.getFieldToFieldMapping((Table)zoomArrow.getSource().getItem(),(Table)zoomArrow.getTarget().getItem()));
          new AnimateThread(true).start();
          slaveMappingPanel.filterComponents(""String_Node_Str"",false);
          slaveMappingPanel.filterComponents(""String_Node_Str"",true);
        }
      }
 else {
        if (!clickedArrow.isSelected()) {
          clickedArrow.setSelected(true);
          selectedArrow=clickedArrow;
          detailsListener.showDetails(mapping.getSourceToTargetMap(selectedArrow.getSource().getItem(),selectedArrow.getTarget().getItem()));
        }
        repaint();
      }
    }
 else {
      detailsListener.showDetails(null);
    }
  }
 else {
    detailsListener.showDetails(null);
  }
}","@Override public void mouseClicked(MouseEvent event){
  Hashtable<HighlightStatus,List<Arrow>> currentArrowStatus=new Hashtable<HighlightStatus,List<Arrow>>();
  for (  HighlightStatus status : HighlightStatus.values()) {
    currentArrowStatus.put(status,arrowsByStatus(status));
  }
  if (selectedArrow != null) {
    selectedArrow.setSelected(false);
    detailsListener.showDetails(null);
    selectedArrow=null;
  }
  if (!event.isShiftDown() && !event.isControlDown()) {
    for (    LabeledRectangle component : cdmComponents) {
      component.setSelected(false);
    }
    for (    LabeledRectangle component : sourceComponents) {
      component.setSelected(false);
    }
  }
  if (event.getX() > sourceX && event.getX() < sourceX + ITEM_WIDTH) {
    LabeledRectangleClicked(event,getVisibleSourceComponents());
  }
 else   if (event.getX() > cdmX && event.getX() < cdmX + ITEM_WIDTH) {
    LabeledRectangleClicked(event,getVisibleTargetComponents());
  }
 else   if (event.getX() > sourceX + ITEM_WIDTH && event.getX() < cdmX) {
    Arrow clickedArrow=null;
    for (    HighlightStatus status : HighlightStatus.values()) {
      for (      Arrow arrow : currentArrowStatus.get(status)) {
        if (arrow.contains(event.getPoint())) {
          clickedArrow=arrow;
          break;
        }
      }
      if (clickedArrow != null) {
        break;
      }
    }
    if (clickedArrow != null) {
      if (event.getClickCount() == 2) {
        zoomArrow=clickedArrow;
        if (slaveMappingPanel != null) {
          slaveMappingPanel.setMapping(ObjectExchange.etl.getFieldToFieldMapping((Table)zoomArrow.getSource().getItem(),(Table)zoomArrow.getTarget().getItem()));
          new AnimateThread(true).start();
          slaveMappingPanel.filterComponents(""String_Node_Str"",false);
          slaveMappingPanel.filterComponents(""String_Node_Str"",true);
          if (hiding) {
            slaveMappingPanel.hideCompleted();
          }
        }
      }
 else {
        if (!clickedArrow.isSelected()) {
          clickedArrow.setSelected(true);
          selectedArrow=clickedArrow;
          detailsListener.showDetails(mapping.getSourceToTargetMap(selectedArrow.getSource().getItem(),selectedArrow.getTarget().getItem()));
        }
        repaint();
      }
    }
 else {
      detailsListener.showDetails(null);
    }
  }
 else {
    detailsListener.showDetails(null);
  }
}",0.9823591923485654
85424,"private void renderModel(){
  sourceComponents.clear();
  cdmComponents.clear();
  arrows.clear();
  for (  MappableItem item : mapping.getSourceItems())   if (!showOnlyConnectedItems || isConnected(item)) {
    LabeledRectangle component=new LabeledRectangle(0,400,ITEM_WIDTH,ITEM_HEIGHT,item,new Color(255,128,0));
    sourceComponents.add(component);
  }
  for (  MappableItem item : mapping.getTargetItems())   if (!showOnlyConnectedItems || isConnected(item)) {
    LabeledRectangle component=new LabeledRectangle(0,400,ITEM_WIDTH,ITEM_HEIGHT,item,new Color(128,128,255));
    cdmComponents.add(component);
  }
  for (  ItemToItemMap map : mapping.getSourceToTargetMaps()) {
    Arrow component=new Arrow(getComponentWithItem(map.getSourceItem(),sourceComponents),getComponentWithItem(map.getTargetItem(),cdmComponents));
    if (!showCommented && (!(map.getComment().equals(""String_Node_Str"")) || !(map.getLogic().equals(""String_Node_Str""))))     component.setCompleted(true);
    arrows.add(component);
  }
  layoutItems();
  repaint();
}","private void renderModel(){
  sourceComponents.clear();
  cdmComponents.clear();
  arrows.clear();
  for (  MappableItem item : mapping.getSourceItems())   if (!showOnlyConnectedItems || isConnected(item)) {
    LabeledRectangle component=new LabeledRectangle(0,400,ITEM_WIDTH,ITEM_HEIGHT,item,new Color(255,128,0));
    sourceComponents.add(component);
  }
  for (  MappableItem item : mapping.getTargetItems())   if (!showOnlyConnectedItems || isConnected(item)) {
    LabeledRectangle component=new LabeledRectangle(0,400,ITEM_WIDTH,ITEM_HEIGHT,item,new Color(128,128,255));
    cdmComponents.add(component);
  }
  for (  ItemToItemMap map : mapping.getSourceToTargetMaps()) {
    Arrow component=new Arrow(getComponentWithItem(map.getSourceItem(),sourceComponents),getComponentWithItem(map.getTargetItem(),cdmComponents),map);
    arrows.add(component);
  }
  layoutItems();
  repaint();
}",0.8524251805985552
85425,"public void itemStateChanged(ItemEvent e){
  if (hideCommented.isSelected()) {
    doHideCommented();
  }
 else {
    doShowCommented();
  }
}","public void itemStateChanged(ItemEvent e){
  if (hideCompleted.isSelected())   doHideCompleted();
 else   doShowCompleted();
}",0.8955223880597015
85426,"private JMenuBar createMenuBar(){
  JMenuBar menuBar=new JMenuBar();
  JMenu fileMenu=new JMenu(""String_Node_Str"");
  int menuShortcutMask=Toolkit.getDefaultToolkit().getMenuShortcutKeyMask();
  menuBar.add(fileMenu);
  JMenuItem openItem=new JMenuItem(""String_Node_Str"");
  openItem.addActionListener(this);
  openItem.setActionCommand(ACTION_CMD_OPEN_ETL_SPECS);
  openItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_O,menuShortcutMask));
  fileMenu.add(openItem);
  JMenuItem openScanReportItem=new JMenuItem(""String_Node_Str"");
  openScanReportItem.addActionListener(this);
  openScanReportItem.setActionCommand(ACTION_CMD_OPEN_SCAN_REPORT);
  fileMenu.add(openScanReportItem);
  JMenuItem saveItem=new JMenuItem(""String_Node_Str"");
  saveItem.addActionListener(this);
  saveItem.setActionCommand(ACTION_CMD_SAVE);
  saveItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_S,menuShortcutMask));
  fileMenu.add(saveItem);
  JMenuItem saveAsItem=new JMenuItem(""String_Node_Str"");
  saveAsItem.addActionListener(this);
  saveAsItem.setActionCommand(ACTION_CMD_SAVE_AS);
  fileMenu.add(saveAsItem);
  JMenuItem generateDocItem=new JMenuItem(""String_Node_Str"");
  generateDocItem.addActionListener(this);
  generateDocItem.setActionCommand(ACTION_CMD_GENERATE_ETL_DOCUMENT);
  fileMenu.add(generateDocItem);
  JMenu editMenu=new JMenu(""String_Node_Str"");
  menuBar.add(editMenu);
  JMenuItem discardCounts=new JMenuItem(ACTION_CMD_DISCARD_COUNTS);
  discardCounts.addActionListener(this);
  discardCounts.setActionCommand(ACTION_CMD_DISCARD_COUNTS);
  editMenu.add(discardCounts);
  JMenuItem filter=new JMenuItem(ACTION_CMD_FILTER);
  filter.addActionListener(this);
  filter.setActionCommand(ACTION_CMD_FILTER);
  filter.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F,menuShortcutMask));
  editMenu.add(filter);
  JMenuItem makeMappings=new JMenuItem(ACTION_CMD_MAKE_MAPPING);
  makeMappings.addActionListener(this);
  makeMappings.setActionCommand(ACTION_CMD_MAKE_MAPPING);
  makeMappings.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_M,menuShortcutMask));
  editMenu.add(makeMappings);
  JMenuItem removeMappings=new JMenuItem(ACTION_CMD_REMOVE_MAPPING);
  removeMappings.addActionListener(this);
  removeMappings.setActionCommand(ACTION_CMD_REMOVE_MAPPING);
  removeMappings.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_R,menuShortcutMask));
  editMenu.add(removeMappings);
  JMenu setTarget=new JMenu(""String_Node_Str"");
  JMenuItem targetCDMV4=new JMenuItem(ACTION_CMD_SET_TARGET_V4);
  targetCDMV4.addActionListener(this);
  targetCDMV4.setActionCommand(ACTION_CMD_SET_TARGET_V4);
  setTarget.add(targetCDMV4);
  JMenuItem targetCDMV5=new JMenuItem(ACTION_CMD_SET_TARGET_V5);
  targetCDMV5.addActionListener(this);
  targetCDMV5.setActionCommand(ACTION_CMD_SET_TARGET_V5);
  setTarget.add(targetCDMV5);
  JMenuItem loadTarget=new JMenuItem(ACTION_CMD_SET_TARGET_CUSTOM);
  loadTarget.addActionListener(this);
  loadTarget.setActionCommand(ACTION_CMD_SET_TARGET_CUSTOM);
  setTarget.add(loadTarget);
  editMenu.add(setTarget);
  final JCheckBoxMenuItem hideCommented=new JCheckBoxMenuItem(ACTION_CMD_HIDE_COMMENTED);
  hideCommented.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent e){
      if (hideCommented.isSelected()) {
        doHideCommented();
      }
 else {
        doShowCommented();
      }
    }
  }
);
  editMenu.add(hideCommented);
  return menuBar;
}","private JMenuBar createMenuBar(){
  JMenuBar menuBar=new JMenuBar();
  JMenu fileMenu=new JMenu(""String_Node_Str"");
  int menuShortcutMask=Toolkit.getDefaultToolkit().getMenuShortcutKeyMask();
  menuBar.add(fileMenu);
  JMenuItem openItem=new JMenuItem(""String_Node_Str"");
  openItem.addActionListener(this);
  openItem.setActionCommand(ACTION_CMD_OPEN_ETL_SPECS);
  openItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_O,menuShortcutMask));
  fileMenu.add(openItem);
  JMenuItem openScanReportItem=new JMenuItem(""String_Node_Str"");
  openScanReportItem.addActionListener(this);
  openScanReportItem.setActionCommand(ACTION_CMD_OPEN_SCAN_REPORT);
  fileMenu.add(openScanReportItem);
  JMenuItem saveItem=new JMenuItem(""String_Node_Str"");
  saveItem.addActionListener(this);
  saveItem.setActionCommand(ACTION_CMD_SAVE);
  saveItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_S,menuShortcutMask));
  fileMenu.add(saveItem);
  JMenuItem saveAsItem=new JMenuItem(""String_Node_Str"");
  saveAsItem.addActionListener(this);
  saveAsItem.setActionCommand(ACTION_CMD_SAVE_AS);
  fileMenu.add(saveAsItem);
  JMenuItem generateDocItem=new JMenuItem(""String_Node_Str"");
  generateDocItem.addActionListener(this);
  generateDocItem.setActionCommand(ACTION_CMD_GENERATE_ETL_DOCUMENT);
  fileMenu.add(generateDocItem);
  JMenu editMenu=new JMenu(""String_Node_Str"");
  menuBar.add(editMenu);
  JMenuItem discardCounts=new JMenuItem(ACTION_CMD_DISCARD_COUNTS);
  discardCounts.addActionListener(this);
  discardCounts.setActionCommand(ACTION_CMD_DISCARD_COUNTS);
  editMenu.add(discardCounts);
  JMenuItem filter=new JMenuItem(ACTION_CMD_FILTER);
  filter.addActionListener(this);
  filter.setActionCommand(ACTION_CMD_FILTER);
  filter.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F,menuShortcutMask));
  editMenu.add(filter);
  JMenuItem makeMappings=new JMenuItem(ACTION_CMD_MAKE_MAPPING);
  makeMappings.addActionListener(this);
  makeMappings.setActionCommand(ACTION_CMD_MAKE_MAPPING);
  makeMappings.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_M,menuShortcutMask));
  editMenu.add(makeMappings);
  JMenuItem removeMappings=new JMenuItem(ACTION_CMD_REMOVE_MAPPING);
  removeMappings.addActionListener(this);
  removeMappings.setActionCommand(ACTION_CMD_REMOVE_MAPPING);
  removeMappings.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_R,menuShortcutMask));
  editMenu.add(removeMappings);
  JMenu setTarget=new JMenu(""String_Node_Str"");
  JMenuItem targetCDMV4=new JMenuItem(ACTION_CMD_SET_TARGET_V4);
  targetCDMV4.addActionListener(this);
  targetCDMV4.setActionCommand(ACTION_CMD_SET_TARGET_V4);
  setTarget.add(targetCDMV4);
  JMenuItem targetCDMV5=new JMenuItem(ACTION_CMD_SET_TARGET_V5);
  targetCDMV5.addActionListener(this);
  targetCDMV5.setActionCommand(ACTION_CMD_SET_TARGET_V5);
  setTarget.add(targetCDMV5);
  JMenuItem loadTarget=new JMenuItem(ACTION_CMD_SET_TARGET_CUSTOM);
  loadTarget.addActionListener(this);
  loadTarget.setActionCommand(ACTION_CMD_SET_TARGET_CUSTOM);
  setTarget.add(loadTarget);
  editMenu.add(setTarget);
  final JCheckBoxMenuItem hideCompleted=new JCheckBoxMenuItem(ACTION_CMD_HIDE_COMPLETED);
  hideCompleted.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent e){
      if (hideCompleted.isSelected())       doHideCompleted();
 else       doShowCompleted();
    }
  }
);
  editMenu.add(hideCompleted);
  return menuBar;
}",0.960807253582919
85427,"@Override public void actionPerformed(ActionEvent event){
switch (event.getActionCommand()) {
case ACTION_CMD_SAVE:
    String filename=ObjectExchange.etl.getFilename();
  doSave((filename == null || !filename.toLowerCase().endsWith(""String_Node_Str"")) ? chooseSavePath(FILE_FILTER_GZ) : filename);
break;
case ACTION_CMD_SAVE_AS:
doSave(chooseSavePath(FILE_FILTER_GZ));
break;
case ACTION_CMD_OPEN_ETL_SPECS:
doOpenSpecs(chooseOpenPath(FILE_FILTER_GZ));
break;
case ACTION_CMD_OPEN_SCAN_REPORT:
doOpenScanReport(chooseOpenPath());
break;
case ACTION_CMD_GENERATE_ETL_DOCUMENT:
doGenerateEtlDoc(chooseSavePath(FILE_FILTER_DOCX));
break;
case ACTION_CMD_DISCARD_COUNTS:
doDiscardCounts();
break;
case ACTION_CMD_FILTER:
doOpenFilterDialog();
case ACTION_CMD_MAKE_MAPPING:
doMakeMappings();
break;
case ACTION_CMD_REMOVE_MAPPING:
doRemoveMappings();
break;
}
}","@Override public void actionPerformed(ActionEvent event){
switch (event.getActionCommand()) {
case ACTION_CMD_SAVE:
    String filename=ObjectExchange.etl.getFilename();
  doSave((filename == null || !filename.toLowerCase().endsWith(""String_Node_Str"")) ? chooseSavePath(FILE_FILTER_GZ) : filename);
break;
case ACTION_CMD_SAVE_AS:
doSave(chooseSavePath(FILE_FILTER_GZ));
break;
case ACTION_CMD_OPEN_ETL_SPECS:
doOpenSpecs(chooseOpenPath(FILE_FILTER_GZ));
break;
case ACTION_CMD_OPEN_SCAN_REPORT:
doOpenScanReport(chooseOpenPath());
break;
case ACTION_CMD_GENERATE_ETL_DOCUMENT:
doGenerateEtlDoc(chooseSavePath(FILE_FILTER_DOCX));
break;
case ACTION_CMD_DISCARD_COUNTS:
doDiscardCounts();
break;
case ACTION_CMD_FILTER:
doOpenFilterDialog();
break;
case ACTION_CMD_MAKE_MAPPING:
doMakeMappings();
break;
case ACTION_CMD_REMOVE_MAPPING:
doRemoveMappings();
break;
}
}",0.995937318630296
85428,"private void layoutItems(){
  if (minimized) {
    for (    LabeledRectangle targetComponent : getVisibleTargetComponents()) {
      targetComponent.setLocation(targetX,targetComponent.getY());
    }
  }
 else {
    setLabeledRectanglesLocation(getVisibleSourceComponents(),sourceX);
    setLabeledRectanglesLocation(getVisibleTargetComponents(),targetX);
  }
}","private void layoutItems(){
  if (minimized) {
    for (    LabeledRectangle targetComponent : getVisibleTargetComponents()) {
      targetComponent.setLocation(cdmX,targetComponent.getY());
    }
  }
 else {
    setLabeledRectanglesLocation(getVisibleSourceComponents(),sourceX);
    setLabeledRectanglesLocation(getVisibleTargetComponents(),cdmX);
  }
}",0.9748603351955308
85429,"public void paint(Graphics g){
  Image offscreen=createVolatileImage(getWidth(),getHeight());
  Graphics2D g2d;
  if (offscreen == null) {
    g2d=(Graphics2D)g;
  }
 else {
    g2d=(Graphics2D)offscreen.getGraphics();
  }
  g2d.setBackground(Color.WHITE);
  g2d.clearRect(0,0,getWidth(),getHeight());
  RenderingHints rh=new RenderingHints(RenderingHints.KEY_TEXT_ANTIALIASING,RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
  g2d.setRenderingHints(rh);
  addLabel(g2d,this.getSourceDbName(),sourceX + ITEM_WIDTH / 2,HEADER_TOP_MARGIN + HEADER_HEIGHT / 2);
  addLabel(g2d,this.getTargetDbName(),targetX + ITEM_WIDTH / 2,HEADER_TOP_MARGIN + HEADER_HEIGHT / 2);
  if (showingArrowStarts && dragRectangle == null) {
    for (    LabeledRectangle item : getVisibleSourceComponents())     Arrow.drawArrowHead(g2d,Math.round(item.getX() + item.getWidth() + Arrow.headThickness),item.getY() + item.getHeight() / 2);
  }
  for (  LabeledRectangle component : getVisibleSourceComponents())   if (component != dragRectangle)   component.paint(g2d);
  for (  LabeledRectangle component : getVisibleTargetComponents())   if (component != dragRectangle)   component.paint(g2d);
  for (int i=HighlightStatus.values().length - 1; i >= 0; i--) {
    HighlightStatus status=HighlightStatus.values()[i];
    for (    Arrow arrow : arrowsByStatus(status)) {
      if (arrow != dragArrow) {
        arrow.paint(g2d);
      }
    }
  }
  if (dragRectangle != null)   dragRectangle.paint(g2d);
  if (dragArrow != null)   dragArrow.paint(g2d);
  if (offscreen != null)   g.drawImage(offscreen,0,0,this);
}","public void paint(Graphics g){
  Image offscreen=createVolatileImage(getWidth(),getHeight());
  Graphics2D g2d;
  if (offscreen == null) {
    g2d=(Graphics2D)g;
  }
 else {
    g2d=(Graphics2D)offscreen.getGraphics();
  }
  g2d.setBackground(Color.WHITE);
  g2d.clearRect(0,0,getWidth(),getHeight());
  RenderingHints rh=new RenderingHints(RenderingHints.KEY_TEXT_ANTIALIASING,RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
  g2d.setRenderingHints(rh);
  addLabel(g2d,this.getSourceDbName(),sourceX + ITEM_WIDTH / 2,HEADER_TOP_MARGIN + HEADER_HEIGHT / 2);
  addLabel(g2d,this.getTargetDbName(),cdmX + ITEM_WIDTH / 2,HEADER_TOP_MARGIN + HEADER_HEIGHT / 2);
  if (showingArrowStarts && dragRectangle == null) {
    for (    LabeledRectangle item : getVisibleSourceComponents())     Arrow.drawArrowHead(g2d,Math.round(item.getX() + item.getWidth() + Arrow.headThickness),item.getY() + item.getHeight() / 2);
  }
  for (  LabeledRectangle component : getVisibleSourceComponents())   if (component != dragRectangle)   component.paint(g2d);
  for (  LabeledRectangle component : getVisibleTargetComponents())   if (component != dragRectangle)   component.paint(g2d);
  for (int i=HighlightStatus.values().length - 1; i >= 0; i--) {
    HighlightStatus status=HighlightStatus.values()[i];
    for (    Arrow arrow : arrowsByStatus(status)) {
      if (arrow != dragArrow) {
        arrow.paint(g2d);
      }
    }
  }
  if (dragRectangle != null)   dragRectangle.paint(g2d);
  if (dragArrow != null)   dragArrow.paint(g2d);
  if (offscreen != null)   g.drawImage(offscreen,0,0,this);
}",0.9971419498253412
85430,"public void run(){
  if (minimizing) {
    LabeledRectangle sourceComponent=zoomArrow.getSource();
    LabeledRectangle targetComponent=zoomArrow.getTarget();
    for (    LabeledRectangle component : sourceComponents)     if (component != sourceComponent)     component.setVisible(false);
    for (    LabeledRectangle component : targetComponents)     if (component != targetComponent)     component.setVisible(false);
    for (    Arrow component : arrows)     if (component != zoomArrow)     component.setVisible(false);
    minimized=true;
    Path heightPath=new Path(getHeight(),HEADER_TOP_MARGIN + HEADER_HEIGHT + MARGIN+ ITEM_HEIGHT+ BORDER_HEIGHT);
    Path sourcePath=new Path(sourceComponent.getY(),HEADER_TOP_MARGIN + HEADER_HEIGHT);
    Path targetPath=new Path(targetComponent.getY(),HEADER_TOP_MARGIN + HEADER_HEIGHT);
    for (int i=0; i < nSteps; i++) {
      maxHeight=heightPath.getValue(i);
      sourceComponent.setLocation(sourceX,sourcePath.getValue(i));
      targetComponent.setLocation(targetX,targetPath.getValue(i));
      for (      ResizeListener resizeListener : resizeListeners)       resizeListener.notifyResized(maxHeight,false,false);
      try {
        sleep(20);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
    maxHeight=heightPath.getEnd();
    sourceComponent.setLocation(sourceX,sourcePath.getEnd());
    targetComponent.setLocation(targetX,targetPath.getEnd());
    for (    ResizeListener resizeListener : resizeListeners)     resizeListener.notifyResized(maxHeight,true,false);
  }
 else {
  }
}","public void run(){
  if (minimizing) {
    LabeledRectangle sourceComponent=zoomArrow.getSource();
    LabeledRectangle targetComponent=zoomArrow.getTarget();
    for (    LabeledRectangle component : sourceComponents)     if (component != sourceComponent)     component.setVisible(false);
    for (    LabeledRectangle component : cdmComponents)     if (component != targetComponent)     component.setVisible(false);
    for (    Arrow component : arrows)     if (component != zoomArrow)     component.setVisible(false);
    minimized=true;
    Path heightPath=new Path(getHeight(),HEADER_TOP_MARGIN + HEADER_HEIGHT + MARGIN+ ITEM_HEIGHT+ BORDER_HEIGHT);
    Path sourcePath=new Path(sourceComponent.getY(),HEADER_TOP_MARGIN + HEADER_HEIGHT);
    Path targetPath=new Path(targetComponent.getY(),HEADER_TOP_MARGIN + HEADER_HEIGHT);
    for (int i=0; i < nSteps; i++) {
      maxHeight=heightPath.getValue(i);
      sourceComponent.setLocation(sourceX,sourcePath.getValue(i));
      targetComponent.setLocation(cdmX,targetPath.getValue(i));
      for (      ResizeListener resizeListener : resizeListeners)       resizeListener.notifyResized(maxHeight,false,false);
      try {
        sleep(20);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
    maxHeight=heightPath.getEnd();
    sourceComponent.setLocation(sourceX,sourcePath.getEnd());
    targetComponent.setLocation(cdmX,targetPath.getEnd());
    for (    ResizeListener resizeListener : resizeListeners)     resizeListener.notifyResized(maxHeight,true,false);
  }
 else {
  }
}",0.9914691943127962
85431,"public void filterComponents(String searchTerm,boolean filterTarget){
  List<LabeledRectangle> components;
  if (filterTarget == true) {
    components=targetComponents;
    lastTargetFilter=searchTerm;
  }
 else {
    components=sourceComponents;
    lastSourceFilter=searchTerm;
  }
  for (  LabeledRectangle c : components) {
    c.filter(searchTerm);
  }
  layoutItems();
  repaint();
}","public void filterComponents(String searchTerm,boolean filterTarget){
  List<LabeledRectangle> components;
  if (filterTarget == true) {
    components=cdmComponents;
    lastTargetFilter=searchTerm;
  }
 else {
    components=sourceComponents;
    lastSourceFilter=searchTerm;
  }
  for (  LabeledRectangle c : components) {
    c.filter(searchTerm);
  }
  layoutItems();
  repaint();
}",0.9884169884169884
85432,"@Override public void mousePressed(MouseEvent event){
  if (minimized) {
    maximize();
    return;
  }
  if (event.getX() > sourceX + ITEM_WIDTH && event.getX() < sourceX + ITEM_WIDTH + ARROW_START_WIDTH) {
    for (    LabeledRectangle item : getVisibleSourceComponents()) {
      if (event.getY() >= item.getY() && event.getY() <= item.getY() + item.getHeight()) {
        dragArrow=new Arrow(item);
        dragArrow.setTargetPoint(new Point(item.getX() + item.getWidth() + Arrow.headThickness,item.getY() + item.getHeight() / 2));
        showingArrowStarts=false;
        repaint();
        break;
      }
    }
  }
 else   if (event.getX() > targetX - ARROW_START_WIDTH && event.getX() < targetX && dragArrow == null) {
    for (    Arrow arrow : arrows) {
      if (event.getY() >= arrow.getTarget().getY() && event.getY() <= arrow.getTarget().getY() + arrow.getTarget().getHeight() && arrow.isSourceAndTargetVisible()) {
        dragArrow=arrow;
        dragArrowPreviousTarget=dragArrow.getTarget();
        dragArrow.setTarget(null);
        break;
      }
    }
    if (dragArrow != null) {
      arrows.remove(dragArrow);
    }
    repaint();
  }
 else {
    for (    LabeledRectangle item : getVisibleSourceComponents()) {
      if (item.contains(event.getPoint())) {
        dragRectangle=item;
        dragOffsetY=event.getY() - item.getY();
        break;
      }
    }
    for (    LabeledRectangle item : getVisibleTargetComponents()) {
      if (item.contains(event.getPoint())) {
        dragRectangle=item;
        dragOffsetY=event.getY() - item.getY();
        break;
      }
    }
  }
}","@Override public void mousePressed(MouseEvent event){
  if (minimized) {
    maximize();
    return;
  }
  if (event.getX() > sourceX + ITEM_WIDTH && event.getX() < sourceX + ITEM_WIDTH + ARROW_START_WIDTH) {
    for (    LabeledRectangle item : getVisibleSourceComponents()) {
      if (event.getY() >= item.getY() && event.getY() <= item.getY() + item.getHeight()) {
        dragArrow=new Arrow(item);
        dragArrow.setTargetPoint(new Point(item.getX() + item.getWidth() + Arrow.headThickness,item.getY() + item.getHeight() / 2));
        showingArrowStarts=false;
        repaint();
        break;
      }
    }
  }
 else   if (event.getX() > cdmX - ARROW_START_WIDTH && event.getX() < cdmX && dragArrow == null) {
    for (    Arrow arrow : arrows) {
      if (event.getY() >= arrow.getTarget().getY() && event.getY() <= arrow.getTarget().getY() + arrow.getTarget().getHeight() && arrow.isSourceAndTargetVisible()) {
        dragArrow=arrow;
        dragArrowPreviousTarget=dragArrow.getTarget();
        dragArrow.setTarget(null);
        break;
      }
    }
    if (dragArrow != null) {
      arrows.remove(dragArrow);
    }
    repaint();
  }
 else {
    for (    LabeledRectangle item : getVisibleSourceComponents()) {
      if (item.contains(event.getPoint())) {
        dragRectangle=item;
        dragOffsetY=event.getY() - item.getY();
        break;
      }
    }
    for (    LabeledRectangle item : getVisibleTargetComponents()) {
      if (item.contains(event.getPoint())) {
        dragRectangle=item;
        dragOffsetY=event.getY() - item.getY();
        break;
      }
    }
  }
}",0.9944064636420136
85433,"public List<LabeledRectangle> getVisibleTargetComponents(){
  return getVisibleRectangles(targetComponents);
}","public List<LabeledRectangle> getVisibleTargetComponents(){
  return getVisibleRectangles(cdmComponents);
}",0.9585253456221198
85434,"public Dimension getMinimumSize(){
  Dimension dimension=new Dimension();
  dimension.width=2 * (ITEM_WIDTH + MARGIN) + MIN_SPACE_BETWEEN_COLUMNS;
  dimension.height=Math.min(HEADER_HEIGHT + HEADER_TOP_MARGIN + Math.max(sourceComponents.size(),targetComponents.size()) * (ITEM_HEIGHT + MARGIN),maxHeight);
  return dimension;
}","public Dimension getMinimumSize(){
  Dimension dimension=new Dimension();
  dimension.width=2 * (ITEM_WIDTH + MARGIN) + MIN_SPACE_BETWEEN_COLUMNS;
  dimension.height=Math.min(HEADER_HEIGHT + HEADER_TOP_MARGIN + Math.max(sourceComponents.size(),cdmComponents.size()) * (ITEM_HEIGHT + MARGIN),maxHeight);
  return dimension;
}",0.9861751152073732
85435,"@Override public void mouseClicked(MouseEvent event){
  Hashtable<HighlightStatus,List<Arrow>> currentArrowStatus=new Hashtable<HighlightStatus,List<Arrow>>();
  for (  HighlightStatus status : HighlightStatus.values()) {
    currentArrowStatus.put(status,arrowsByStatus(status));
  }
  if (selectedArrow != null) {
    selectedArrow.setSelected(false);
    detailsListener.showDetails(null);
    selectedArrow=null;
  }
  if (!event.isShiftDown() && !event.isControlDown()) {
    for (    LabeledRectangle component : targetComponents) {
      component.setSelected(false);
    }
    for (    LabeledRectangle component : sourceComponents) {
      component.setSelected(false);
    }
  }
  if (event.getX() > sourceX && event.getX() < sourceX + ITEM_WIDTH) {
    LabeledRectangleClicked(event,getVisibleSourceComponents());
  }
 else   if (event.getX() > targetX && event.getX() < targetX + ITEM_WIDTH) {
    LabeledRectangleClicked(event,getVisibleTargetComponents());
  }
 else   if (event.getX() > sourceX + ITEM_WIDTH && event.getX() < targetX) {
    Arrow clickedArrow=null;
    for (    HighlightStatus status : HighlightStatus.values()) {
      for (      Arrow arrow : currentArrowStatus.get(status)) {
        if (arrow.contains(event.getPoint())) {
          clickedArrow=arrow;
          break;
        }
      }
      if (clickedArrow != null) {
        break;
      }
    }
    if (clickedArrow != null) {
      if (event.getClickCount() == 2) {
        zoomArrow=clickedArrow;
        if (slaveMappingPanel != null) {
          slaveMappingPanel.setMapping(ObjectExchange.etl.getFieldToFieldMapping((Table)zoomArrow.getSource().getItem(),(Table)zoomArrow.getTarget().getItem()));
          new AnimateThread(true).start();
          slaveMappingPanel.filterComponents(""String_Node_Str"",false);
          slaveMappingPanel.filterComponents(""String_Node_Str"",true);
        }
      }
 else {
        if (!clickedArrow.isSelected()) {
          clickedArrow.setSelected(true);
          selectedArrow=clickedArrow;
          detailsListener.showDetails(mapping.getSourceToTargetMap(selectedArrow.getSource().getItem(),selectedArrow.getTarget().getItem()));
        }
        repaint();
      }
    }
 else {
      detailsListener.showDetails(null);
    }
  }
 else {
    detailsListener.showDetails(null);
  }
}","@Override public void mouseClicked(MouseEvent event){
  Hashtable<HighlightStatus,List<Arrow>> currentArrowStatus=new Hashtable<HighlightStatus,List<Arrow>>();
  for (  HighlightStatus status : HighlightStatus.values()) {
    currentArrowStatus.put(status,arrowsByStatus(status));
  }
  if (selectedArrow != null) {
    selectedArrow.setSelected(false);
    detailsListener.showDetails(null);
    selectedArrow=null;
  }
  if (!event.isShiftDown() && !event.isControlDown()) {
    for (    LabeledRectangle component : cdmComponents) {
      component.setSelected(false);
    }
    for (    LabeledRectangle component : sourceComponents) {
      component.setSelected(false);
    }
  }
  if (event.getX() > sourceX && event.getX() < sourceX + ITEM_WIDTH) {
    LabeledRectangleClicked(event,getVisibleSourceComponents());
  }
 else   if (event.getX() > cdmX && event.getX() < cdmX + ITEM_WIDTH) {
    LabeledRectangleClicked(event,getVisibleTargetComponents());
  }
 else   if (event.getX() > sourceX + ITEM_WIDTH && event.getX() < cdmX) {
    Arrow clickedArrow=null;
    for (    HighlightStatus status : HighlightStatus.values()) {
      for (      Arrow arrow : currentArrowStatus.get(status)) {
        if (arrow.contains(event.getPoint())) {
          clickedArrow=arrow;
          break;
        }
      }
      if (clickedArrow != null) {
        break;
      }
    }
    if (clickedArrow != null) {
      if (event.getClickCount() == 2) {
        zoomArrow=clickedArrow;
        if (slaveMappingPanel != null) {
          slaveMappingPanel.setMapping(ObjectExchange.etl.getFieldToFieldMapping((Table)zoomArrow.getSource().getItem(),(Table)zoomArrow.getTarget().getItem()));
          new AnimateThread(true).start();
          slaveMappingPanel.filterComponents(""String_Node_Str"",false);
          slaveMappingPanel.filterComponents(""String_Node_Str"",true);
        }
      }
 else {
        if (!clickedArrow.isSelected()) {
          clickedArrow.setSelected(true);
          selectedArrow=clickedArrow;
          detailsListener.showDetails(mapping.getSourceToTargetMap(selectedArrow.getSource().getItem(),selectedArrow.getTarget().getItem()));
        }
        repaint();
      }
    }
 else {
      detailsListener.showDetails(null);
    }
  }
 else {
    detailsListener.showDetails(null);
  }
}",0.9922313336210618
85436,"public void makeMapSelectedSourceAndTarget(){
  for (  LabeledRectangle source : getSelectedRectangles(sourceComponents)) {
    for (    LabeledRectangle target : getSelectedRectangles(targetComponents)) {
      makeMapSourceToTarget(source,target);
    }
  }
}","public void makeMapSelectedSourceAndTarget(){
  for (  LabeledRectangle source : getSelectedRectangles(sourceComponents)) {
    for (    LabeledRectangle target : getSelectedRectangles(cdmComponents)) {
      makeMapSourceToTarget(source,target);
    }
  }
}",0.9826589595375722
85437,"private void renderModel(){
  sourceComponents.clear();
  targetComponents.clear();
  arrows.clear();
  for (  MappableItem item : mapping.getSourceItems())   if (!showOnlyConnectedItems || isConnected(item)) {
    LabeledRectangle component=new LabeledRectangle(0,400,ITEM_WIDTH,ITEM_HEIGHT,item,new Color(255,128,0));
    sourceComponents.add(component);
  }
  for (  MappableItem item : mapping.getTargetItems())   if (!showOnlyConnectedItems || isConnected(item)) {
    LabeledRectangle component=new LabeledRectangle(0,400,ITEM_WIDTH,ITEM_HEIGHT,item,new Color(128,128,255));
    targetComponents.add(component);
  }
  for (  ItemToItemMap map : mapping.getSourceToTargetMaps()) {
    Arrow component=new Arrow(getComponentWithItem(map.getSourceItem(),sourceComponents),getComponentWithItem(map.getTargetItem(),targetComponents));
    arrows.add(component);
  }
  layoutItems();
  repaint();
}","private void renderModel(){
  sourceComponents.clear();
  cdmComponents.clear();
  arrows.clear();
  for (  MappableItem item : mapping.getSourceItems())   if (!showOnlyConnectedItems || isConnected(item)) {
    LabeledRectangle component=new LabeledRectangle(0,400,ITEM_WIDTH,ITEM_HEIGHT,item,new Color(255,128,0));
    sourceComponents.add(component);
  }
  for (  MappableItem item : mapping.getTargetItems())   if (!showOnlyConnectedItems || isConnected(item)) {
    LabeledRectangle component=new LabeledRectangle(0,400,ITEM_WIDTH,ITEM_HEIGHT,item,new Color(128,128,255));
    cdmComponents.add(component);
  }
  for (  ItemToItemMap map : mapping.getSourceToTargetMaps()) {
    Arrow component=new Arrow(getComponentWithItem(map.getSourceItem(),sourceComponents),getComponentWithItem(map.getTargetItem(),cdmComponents));
    arrows.add(component);
  }
  layoutItems();
  repaint();
}",0.9848908785674314
85438,"@Override public void mouseReleased(MouseEvent event){
  if (dragRectangle != null) {
    if (!isSorted(sourceComponents,new YComparator())) {
      Collections.sort(sourceComponents,new YComparator());
      mapping.setSourceItems(getItemsList(sourceComponents));
    }
    if (!isSorted(targetComponents,new YComparator())) {
      Collections.sort(targetComponents,new YComparator());
      mapping.setTargetItems(getItemsList(targetComponents));
    }
    dragRectangle=null;
    layoutItems();
  }
 else   if (dragArrow != null) {
    if (event.getX() > targetX - ARROW_START_WIDTH && event.getX() < targetX + ITEM_WIDTH)     for (    LabeledRectangle component : getVisibleRectangles(targetComponents)) {
      if (component.contains(event.getPoint(),ARROW_START_WIDTH,0)) {
        dragArrow.setTarget(component);
        if (dragArrow.getTarget() == dragArrowPreviousTarget) {
          arrows.add(dragArrow);
          break;
        }
        makeMapSourceToTarget(dragArrow.getSource(),dragArrow.getTarget());
        break;
      }
    }
    if (dragArrowPreviousTarget != null && dragArrow.getTarget() != dragArrowPreviousTarget) {
      mapping.removeSourceToTargetMap(dragArrow.getSource().getItem(),dragArrowPreviousTarget.getItem());
    }
    dragArrowPreviousTarget=null;
    dragArrow=null;
  }
  repaint();
}","@Override public void mouseReleased(MouseEvent event){
  if (dragRectangle != null) {
    if (!isSorted(sourceComponents,new YComparator())) {
      Collections.sort(sourceComponents,new YComparator());
      mapping.setSourceItems(getItemsList(sourceComponents));
    }
    if (!isSorted(cdmComponents,new YComparator())) {
      Collections.sort(cdmComponents,new YComparator());
      mapping.setTargetItems(getItemsList(cdmComponents));
    }
    dragRectangle=null;
    layoutItems();
  }
 else   if (dragArrow != null) {
    if (event.getX() > cdmX - ARROW_START_WIDTH && event.getX() < cdmX + ITEM_WIDTH)     for (    LabeledRectangle component : getVisibleRectangles(cdmComponents)) {
      if (component.contains(event.getPoint(),ARROW_START_WIDTH,0)) {
        dragArrow.setTarget(component);
        if (dragArrow.getTarget() == dragArrowPreviousTarget) {
          arrows.add(dragArrow);
          break;
        }
        makeMapSourceToTarget(dragArrow.getSource(),dragArrow.getTarget());
        break;
      }
    }
    if (dragArrowPreviousTarget != null && dragArrow.getTarget() != dragArrowPreviousTarget) {
      mapping.removeSourceToTargetMap(dragArrow.getSource().getItem(),dragArrowPreviousTarget.getItem());
    }
    dragArrowPreviousTarget=null;
    dragArrow=null;
  }
  repaint();
}",0.9795454545454544
85439,"public void setSize(int width,int height){
  sourceX=MARGIN;
  targetX=width - MARGIN - ITEM_WIDTH;
  layoutItems();
  super.setSize(width,height);
}","public void setSize(int width,int height){
  sourceX=MARGIN;
  cdmX=width - MARGIN - ITEM_WIDTH;
  layoutItems();
  super.setSize(width,height);
}",0.9694915254237289
85440,"public void removeMapSelectedSourceAndTarget(){
  for (  LabeledRectangle source : getSelectedRectangles(sourceComponents)) {
    for (    LabeledRectangle target : getSelectedRectangles(targetComponents)) {
      removeMapSourceToTarget(source,target);
    }
  }
}","public void removeMapSelectedSourceAndTarget(){
  for (  LabeledRectangle source : getSelectedRectangles(sourceComponents)) {
    for (    LabeledRectangle target : getSelectedRectangles(cdmComponents)) {
      removeMapSourceToTarget(source,target);
    }
  }
}",0.98292220113852
85441,"public Mapping<Table> getTableToTableMapping(){
  return new Mapping<Table>(sourceDb.getTables(),targetDb.getTables(),tableToTableMaps);
}","public Mapping<Table> getTableToTableMapping(){
  return new Mapping<Table>(sourceDb.getTables(),cdmDb.getTables(),tableToTableMaps);
}",0.967032967032967
85442,"public Database getTargetDatabase(){
  return targetDb;
}","public Database getTargetDatabase(){
  return cdmDb;
}",0.918918918918919
85443,"public void setTargetDatabase(Database targetDb){
  this.targetDb=targetDb;
}","public void setTargetDatabase(Database targetDb){
  this.cdmDb=targetDb;
}",0.9403973509933776
85444,"public ItemToItemMap(MappableItem sourceItem,MappableItem targetItem){
  this.sourceItem=sourceItem;
  this.targetItem=targetItem;
}","public ItemToItemMap(MappableItem sourceItem,MappableItem cdmItem){
  this.sourceItem=sourceItem;
  this.cdmItem=cdmItem;
}",0.8941176470588236
85445,"public MappableItem getTargetItem(){
  return targetItem;
}","public MappableItem getTargetItem(){
  return cdmItem;
}",0.9217391304347826
85446,"public int hashCode(){
  return (sourceItem.toString() + ""String_Node_Str"" + targetItem.toString()).hashCode();
}","public int hashCode(){
  return (sourceItem.toString() + ""String_Node_Str"" + cdmItem.toString()).hashCode();
}",0.9596412556053812
85447,"public void setTargetItem(MappableItem targetItem){
  this.targetItem=targetItem;
}","public void setTargetItem(MappableItem cdmItem){
  this.cdmItem=cdmItem;
}",0.8280254777070064
85448,"public boolean equals(Object other){
  if (other instanceof ItemToItemMap) {
    return (((ItemToItemMap)other).sourceItem.equals(sourceItem) && ((ItemToItemMap)other).targetItem.equals(targetItem));
  }
 else   return false;
}","public boolean equals(Object other){
  if (other instanceof ItemToItemMap) {
    return (((ItemToItemMap)other).sourceItem.equals(sourceItem) && ((ItemToItemMap)other).cdmItem.equals(cdmItem));
  }
 else   return false;
}",0.9598214285714286
85449,"public List<ItemToItemMap> getSourceToTargetMaps(){
  return sourceToTargetMaps;
}","public List<ItemToItemMap> getSourceToTargetMaps(){
  return sourceToCdmMaps;
}",0.9440993788819876
85450,"public void removeSourceToTargetMap(MappableItem sourceItem,MappableItem targetItem){
  Iterator<ItemToItemMap> iterator=sourceToTargetMaps.iterator();
  while (iterator.hasNext()) {
    ItemToItemMap sourceToTargetMap=iterator.next();
    if (sourceToTargetMap.getSourceItem().equals(sourceItem) && sourceToTargetMap.getTargetItem().equals(targetItem))     iterator.remove();
  }
}","public void removeSourceToTargetMap(MappableItem sourceItem,MappableItem targetItem){
  Iterator<ItemToItemMap> iterator=sourceToCdmMaps.iterator();
  while (iterator.hasNext()) {
    ItemToItemMap sourceToTargetMap=iterator.next();
    if (sourceToTargetMap.getSourceItem().equals(sourceItem) && sourceToTargetMap.getTargetItem().equals(targetItem))     iterator.remove();
  }
}",0.988173455978975
85451,"public void addSourceToTargetMap(MappableItem sourceItem,MappableItem targetItem){
  sourceToTargetMaps.add(new ItemToItemMap(sourceItem,targetItem));
}","public void addSourceToTargetMap(MappableItem sourceItem,MappableItem targetItem){
  sourceToCdmMaps.add(new ItemToItemMap(sourceItem,targetItem));
}",0.9700996677740864
85452,"@SuppressWarnings(""String_Node_Str"") public void setTargetItems(List<? extends MappableItem> targetItems){
  this.targetItems.clear();
  for (  MappableItem item : targetItems)   this.targetItems.add((T)item);
}","@SuppressWarnings(""String_Node_Str"") public void setTargetItems(List<? extends MappableItem> targetItems){
  this.cdmItems.clear();
  for (  MappableItem item : targetItems)   this.cdmItems.add((T)item);
}",0.9567307692307692
85453,"public ItemToItemMap getSourceToTargetMap(MappableItem sourceItem,MappableItem targetItem){
  Iterator<ItemToItemMap> iterator=sourceToTargetMaps.iterator();
  while (iterator.hasNext()) {
    ItemToItemMap sourceToTargetMap=iterator.next();
    if (sourceToTargetMap.getSourceItem().equals(sourceItem) && sourceToTargetMap.getTargetItem().equals(targetItem))     return sourceToTargetMap;
  }
  return null;
}","public ItemToItemMap getSourceToTargetMap(MappableItem sourceItem,MappableItem targetItem){
  Iterator<ItemToItemMap> iterator=sourceToCdmMaps.iterator();
  while (iterator.hasNext()) {
    ItemToItemMap sourceToTargetMap=iterator.next();
    if (sourceToTargetMap.getSourceItem().equals(sourceItem) && sourceToTargetMap.getTargetItem().equals(targetItem))     return sourceToTargetMap;
  }
  return null;
}",0.988984088127295
85454,"public List<MappableItem> getTargetItems(){
  List<MappableItem> list=new ArrayList<MappableItem>();
  for (  MappableItem item : targetItems)   list.add(item);
  return list;
}","public List<MappableItem> getTargetItems(){
  List<MappableItem> list=new ArrayList<MappableItem>();
  for (  MappableItem item : cdmItems)   list.add(item);
  return list;
}",0.9743589743589745
85455,"public Mapping(List<T> sourceItems,List<T> targetItems,List<ItemToItemMap> sourceToTargetMaps){
  this.sourceItems=sourceItems;
  this.targetItems=targetItems;
  this.sourceToTargetMaps=sourceToTargetMaps;
}","public Mapping(List<T> sourceItems,List<T> targetItems,List<ItemToItemMap> sourceToTargetMaps){
  this.sourceItems=sourceItems;
  this.cdmItems=targetItems;
  this.sourceToCdmMaps=sourceToTargetMaps;
}",0.9558823529411764
85456,"private void layoutItems(){
  if (minimized) {
    for (    LabeledRectangle targetComponent : getVisibleTargetComponents()) {
      targetComponent.setLocation(targetX,targetComponent.getY());
    }
  }
 else {
    setLabeledRectanglesLocation(getVisibleSourceComponents(),sourceX);
    setLabeledRectanglesLocation(getVisibleTargetComponents(),targetX);
  }
}","private void layoutItems(){
  if (minimized) {
    for (    LabeledRectangle targetComponent : getVisibleTargetComponents()) {
      targetComponent.setLocation(cdmX,targetComponent.getY());
    }
  }
 else {
    setLabeledRectanglesLocation(getVisibleSourceComponents(),sourceX);
    setLabeledRectanglesLocation(getVisibleTargetComponents(),cdmX);
  }
}",0.9748603351955308
85457,"public void paint(Graphics g){
  Image offscreen=createVolatileImage(getWidth(),getHeight());
  Graphics2D g2d;
  if (offscreen == null) {
    g2d=(Graphics2D)g;
  }
 else {
    g2d=(Graphics2D)offscreen.getGraphics();
  }
  g2d.setBackground(Color.WHITE);
  g2d.clearRect(0,0,getWidth(),getHeight());
  RenderingHints rh=new RenderingHints(RenderingHints.KEY_TEXT_ANTIALIASING,RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
  g2d.setRenderingHints(rh);
  addLabel(g2d,this.getSourceDbName(),sourceX + ITEM_WIDTH / 2,HEADER_TOP_MARGIN + HEADER_HEIGHT / 2);
  addLabel(g2d,this.getTargetDbName(),targetX + ITEM_WIDTH / 2,HEADER_TOP_MARGIN + HEADER_HEIGHT / 2);
  if (showingArrowStarts && dragRectangle == null) {
    for (    LabeledRectangle item : getVisibleSourceComponents())     Arrow.drawArrowHead(g2d,Math.round(item.getX() + item.getWidth() + Arrow.headThickness),item.getY() + item.getHeight() / 2);
  }
  for (  LabeledRectangle component : getVisibleSourceComponents())   if (component != dragRectangle)   component.paint(g2d);
  for (  LabeledRectangle component : getVisibleTargetComponents())   if (component != dragRectangle)   component.paint(g2d);
  for (int i=HighlightStatus.values().length - 1; i >= 0; i--) {
    HighlightStatus status=HighlightStatus.values()[i];
    for (    Arrow arrow : arrowsByStatus(status)) {
      if (arrow != dragArrow) {
        arrow.paint(g2d);
      }
    }
  }
  if (dragRectangle != null)   dragRectangle.paint(g2d);
  if (dragArrow != null)   dragArrow.paint(g2d);
  if (offscreen != null)   g.drawImage(offscreen,0,0,this);
}","public void paint(Graphics g){
  Image offscreen=createVolatileImage(getWidth(),getHeight());
  Graphics2D g2d;
  if (offscreen == null) {
    g2d=(Graphics2D)g;
  }
 else {
    g2d=(Graphics2D)offscreen.getGraphics();
  }
  g2d.setBackground(Color.WHITE);
  g2d.clearRect(0,0,getWidth(),getHeight());
  RenderingHints rh=new RenderingHints(RenderingHints.KEY_TEXT_ANTIALIASING,RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
  g2d.setRenderingHints(rh);
  addLabel(g2d,this.getSourceDbName(),sourceX + ITEM_WIDTH / 2,HEADER_TOP_MARGIN + HEADER_HEIGHT / 2);
  addLabel(g2d,this.getTargetDbName(),cdmX + ITEM_WIDTH / 2,HEADER_TOP_MARGIN + HEADER_HEIGHT / 2);
  if (showingArrowStarts && dragRectangle == null) {
    for (    LabeledRectangle item : getVisibleSourceComponents())     Arrow.drawArrowHead(g2d,Math.round(item.getX() + item.getWidth() + Arrow.headThickness),item.getY() + item.getHeight() / 2);
  }
  for (  LabeledRectangle component : getVisibleSourceComponents())   if (component != dragRectangle)   component.paint(g2d);
  for (  LabeledRectangle component : getVisibleTargetComponents())   if (component != dragRectangle)   component.paint(g2d);
  for (int i=HighlightStatus.values().length - 1; i >= 0; i--) {
    HighlightStatus status=HighlightStatus.values()[i];
    for (    Arrow arrow : arrowsByStatus(status)) {
      if (arrow != dragArrow) {
        arrow.paint(g2d);
      }
    }
  }
  if (dragRectangle != null)   dragRectangle.paint(g2d);
  if (dragArrow != null)   dragArrow.paint(g2d);
  if (offscreen != null)   g.drawImage(offscreen,0,0,this);
}",0.9971419498253412
85458,"public void run(){
  if (minimizing) {
    LabeledRectangle sourceComponent=zoomArrow.getSource();
    LabeledRectangle targetComponent=zoomArrow.getTarget();
    for (    LabeledRectangle component : sourceComponents)     if (component != sourceComponent)     component.setVisible(false);
    for (    LabeledRectangle component : targetComponents)     if (component != targetComponent)     component.setVisible(false);
    for (    Arrow component : arrows)     if (component != zoomArrow)     component.setVisible(false);
    minimized=true;
    Path heightPath=new Path(getHeight(),HEADER_TOP_MARGIN + HEADER_HEIGHT + MARGIN+ ITEM_HEIGHT+ BORDER_HEIGHT);
    Path sourcePath=new Path(sourceComponent.getY(),HEADER_TOP_MARGIN + HEADER_HEIGHT);
    Path targetPath=new Path(targetComponent.getY(),HEADER_TOP_MARGIN + HEADER_HEIGHT);
    for (int i=0; i < nSteps; i++) {
      maxHeight=heightPath.getValue(i);
      sourceComponent.setLocation(sourceX,sourcePath.getValue(i));
      targetComponent.setLocation(targetX,targetPath.getValue(i));
      for (      ResizeListener resizeListener : resizeListeners)       resizeListener.notifyResized(maxHeight,false,false);
      try {
        sleep(20);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
    maxHeight=heightPath.getEnd();
    sourceComponent.setLocation(sourceX,sourcePath.getEnd());
    targetComponent.setLocation(targetX,targetPath.getEnd());
    for (    ResizeListener resizeListener : resizeListeners)     resizeListener.notifyResized(maxHeight,true,false);
  }
 else {
  }
}","public void run(){
  if (minimizing) {
    LabeledRectangle sourceComponent=zoomArrow.getSource();
    LabeledRectangle targetComponent=zoomArrow.getTarget();
    for (    LabeledRectangle component : sourceComponents)     if (component != sourceComponent)     component.setVisible(false);
    for (    LabeledRectangle component : cdmComponents)     if (component != targetComponent)     component.setVisible(false);
    for (    Arrow component : arrows)     if (component != zoomArrow)     component.setVisible(false);
    minimized=true;
    Path heightPath=new Path(getHeight(),HEADER_TOP_MARGIN + HEADER_HEIGHT + MARGIN+ ITEM_HEIGHT+ BORDER_HEIGHT);
    Path sourcePath=new Path(sourceComponent.getY(),HEADER_TOP_MARGIN + HEADER_HEIGHT);
    Path targetPath=new Path(targetComponent.getY(),HEADER_TOP_MARGIN + HEADER_HEIGHT);
    for (int i=0; i < nSteps; i++) {
      maxHeight=heightPath.getValue(i);
      sourceComponent.setLocation(sourceX,sourcePath.getValue(i));
      targetComponent.setLocation(cdmX,targetPath.getValue(i));
      for (      ResizeListener resizeListener : resizeListeners)       resizeListener.notifyResized(maxHeight,false,false);
      try {
        sleep(20);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
    maxHeight=heightPath.getEnd();
    sourceComponent.setLocation(sourceX,sourcePath.getEnd());
    targetComponent.setLocation(cdmX,targetPath.getEnd());
    for (    ResizeListener resizeListener : resizeListeners)     resizeListener.notifyResized(maxHeight,true,false);
  }
 else {
  }
}",0.9914691943127962
85459,"public void filterComponents(String searchTerm,boolean filterTarget){
  List<LabeledRectangle> components;
  if (filterTarget == true) {
    components=targetComponents;
    lastTargetFilter=searchTerm;
  }
 else {
    components=sourceComponents;
    lastSourceFilter=searchTerm;
  }
  for (  LabeledRectangle c : components) {
    c.filter(searchTerm);
  }
  layoutItems();
  repaint();
}","public void filterComponents(String searchTerm,boolean filterTarget){
  List<LabeledRectangle> components;
  if (filterTarget == true) {
    components=cdmComponents;
    lastTargetFilter=searchTerm;
  }
 else {
    components=sourceComponents;
    lastSourceFilter=searchTerm;
  }
  for (  LabeledRectangle c : components) {
    c.filter(searchTerm);
  }
  layoutItems();
  repaint();
}",0.9884169884169884
85460,"@Override public void mousePressed(MouseEvent event){
  if (minimized) {
    maximize();
    return;
  }
  if (event.getX() > sourceX + ITEM_WIDTH && event.getX() < sourceX + ITEM_WIDTH + ARROW_START_WIDTH) {
    for (    LabeledRectangle item : getVisibleSourceComponents()) {
      if (event.getY() >= item.getY() && event.getY() <= item.getY() + item.getHeight()) {
        dragArrow=new Arrow(item);
        dragArrow.setTargetPoint(new Point(item.getX() + item.getWidth() + Arrow.headThickness,item.getY() + item.getHeight() / 2));
        showingArrowStarts=false;
        repaint();
        break;
      }
    }
  }
 else   if (event.getX() > targetX - ARROW_START_WIDTH && event.getX() < targetX && dragArrow == null) {
    for (    Arrow arrow : arrows) {
      if (event.getY() >= arrow.getTarget().getY() && event.getY() <= arrow.getTarget().getY() + arrow.getTarget().getHeight() && arrow.isSourceAndTargetVisible()) {
        dragArrow=arrow;
        dragArrowPreviousTarget=dragArrow.getTarget();
        dragArrow.setTarget(null);
        break;
      }
    }
    if (dragArrow != null) {
      arrows.remove(dragArrow);
    }
    repaint();
  }
 else {
    for (    LabeledRectangle item : getVisibleSourceComponents()) {
      if (item.contains(event.getPoint())) {
        dragRectangle=item;
        dragOffsetY=event.getY() - item.getY();
        break;
      }
    }
    for (    LabeledRectangle item : getVisibleTargetComponents()) {
      if (item.contains(event.getPoint())) {
        dragRectangle=item;
        dragOffsetY=event.getY() - item.getY();
        break;
      }
    }
  }
}","@Override public void mousePressed(MouseEvent event){
  if (minimized) {
    maximize();
    return;
  }
  if (event.getX() > sourceX + ITEM_WIDTH && event.getX() < sourceX + ITEM_WIDTH + ARROW_START_WIDTH) {
    for (    LabeledRectangle item : getVisibleSourceComponents()) {
      if (event.getY() >= item.getY() && event.getY() <= item.getY() + item.getHeight()) {
        dragArrow=new Arrow(item);
        dragArrow.setTargetPoint(new Point(item.getX() + item.getWidth() + Arrow.headThickness,item.getY() + item.getHeight() / 2));
        showingArrowStarts=false;
        repaint();
        break;
      }
    }
  }
 else   if (event.getX() > cdmX - ARROW_START_WIDTH && event.getX() < cdmX && dragArrow == null) {
    for (    Arrow arrow : arrows) {
      if (event.getY() >= arrow.getTarget().getY() && event.getY() <= arrow.getTarget().getY() + arrow.getTarget().getHeight() && arrow.isSourceAndTargetVisible()) {
        dragArrow=arrow;
        dragArrowPreviousTarget=dragArrow.getTarget();
        dragArrow.setTarget(null);
        break;
      }
    }
    if (dragArrow != null) {
      arrows.remove(dragArrow);
    }
    repaint();
  }
 else {
    for (    LabeledRectangle item : getVisibleSourceComponents()) {
      if (item.contains(event.getPoint())) {
        dragRectangle=item;
        dragOffsetY=event.getY() - item.getY();
        break;
      }
    }
    for (    LabeledRectangle item : getVisibleTargetComponents()) {
      if (item.contains(event.getPoint())) {
        dragRectangle=item;
        dragOffsetY=event.getY() - item.getY();
        break;
      }
    }
  }
}",0.9944064636420136
85461,"public List<LabeledRectangle> getVisibleTargetComponents(){
  return getVisibleRectangles(targetComponents);
}","public List<LabeledRectangle> getVisibleTargetComponents(){
  return getVisibleRectangles(cdmComponents);
}",0.9585253456221198
85462,"public Dimension getMinimumSize(){
  Dimension dimension=new Dimension();
  dimension.width=2 * (ITEM_WIDTH + MARGIN) + MIN_SPACE_BETWEEN_COLUMNS;
  dimension.height=Math.min(HEADER_HEIGHT + HEADER_TOP_MARGIN + Math.max(sourceComponents.size(),targetComponents.size()) * (ITEM_HEIGHT + MARGIN),maxHeight);
  return dimension;
}","public Dimension getMinimumSize(){
  Dimension dimension=new Dimension();
  dimension.width=2 * (ITEM_WIDTH + MARGIN) + MIN_SPACE_BETWEEN_COLUMNS;
  dimension.height=Math.min(HEADER_HEIGHT + HEADER_TOP_MARGIN + Math.max(sourceComponents.size(),cdmComponents.size()) * (ITEM_HEIGHT + MARGIN),maxHeight);
  return dimension;
}",0.9861751152073732
85463,"@Override public void mouseClicked(MouseEvent event){
  Hashtable<HighlightStatus,List<Arrow>> currentArrowStatus=new Hashtable<HighlightStatus,List<Arrow>>();
  for (  HighlightStatus status : HighlightStatus.values()) {
    currentArrowStatus.put(status,arrowsByStatus(status));
  }
  if (selectedArrow != null) {
    selectedArrow.setSelected(false);
    detailsListener.showDetails(null);
    selectedArrow=null;
  }
  if (!event.isShiftDown() && !event.isControlDown()) {
    for (    LabeledRectangle component : targetComponents) {
      component.setSelected(false);
    }
    for (    LabeledRectangle component : sourceComponents) {
      component.setSelected(false);
    }
  }
  if (event.getX() > sourceX && event.getX() < sourceX + ITEM_WIDTH) {
    LabeledRectangleClicked(event,getVisibleSourceComponents());
  }
 else   if (event.getX() > targetX && event.getX() < targetX + ITEM_WIDTH) {
    LabeledRectangleClicked(event,getVisibleTargetComponents());
  }
 else   if (event.getX() > sourceX + ITEM_WIDTH && event.getX() < targetX) {
    Arrow clickedArrow=null;
    for (    HighlightStatus status : HighlightStatus.values()) {
      for (      Arrow arrow : currentArrowStatus.get(status)) {
        if (arrow.contains(event.getPoint())) {
          clickedArrow=arrow;
          break;
        }
      }
      if (clickedArrow != null) {
        break;
      }
    }
    if (clickedArrow != null) {
      if (event.getClickCount() == 2) {
        zoomArrow=clickedArrow;
        if (slaveMappingPanel != null) {
          slaveMappingPanel.setMapping(ObjectExchange.etl.getFieldToFieldMapping((Table)zoomArrow.getSource().getItem(),(Table)zoomArrow.getTarget().getItem()));
          new AnimateThread(true).start();
          slaveMappingPanel.filterComponents(""String_Node_Str"",false);
          slaveMappingPanel.filterComponents(""String_Node_Str"",true);
        }
      }
 else {
        if (!clickedArrow.isSelected()) {
          clickedArrow.setSelected(true);
          selectedArrow=clickedArrow;
          detailsListener.showDetails(mapping.getSourceToTargetMap(selectedArrow.getSource().getItem(),selectedArrow.getTarget().getItem()));
        }
        repaint();
      }
    }
 else {
      detailsListener.showDetails(null);
    }
  }
 else {
    detailsListener.showDetails(null);
  }
}","@Override public void mouseClicked(MouseEvent event){
  Hashtable<HighlightStatus,List<Arrow>> currentArrowStatus=new Hashtable<HighlightStatus,List<Arrow>>();
  for (  HighlightStatus status : HighlightStatus.values()) {
    currentArrowStatus.put(status,arrowsByStatus(status));
  }
  if (selectedArrow != null) {
    selectedArrow.setSelected(false);
    detailsListener.showDetails(null);
    selectedArrow=null;
  }
  if (!event.isShiftDown() && !event.isControlDown()) {
    for (    LabeledRectangle component : cdmComponents) {
      component.setSelected(false);
    }
    for (    LabeledRectangle component : sourceComponents) {
      component.setSelected(false);
    }
  }
  if (event.getX() > sourceX && event.getX() < sourceX + ITEM_WIDTH) {
    LabeledRectangleClicked(event,getVisibleSourceComponents());
  }
 else   if (event.getX() > cdmX && event.getX() < cdmX + ITEM_WIDTH) {
    LabeledRectangleClicked(event,getVisibleTargetComponents());
  }
 else   if (event.getX() > sourceX + ITEM_WIDTH && event.getX() < cdmX) {
    Arrow clickedArrow=null;
    for (    HighlightStatus status : HighlightStatus.values()) {
      for (      Arrow arrow : currentArrowStatus.get(status)) {
        if (arrow.contains(event.getPoint())) {
          clickedArrow=arrow;
          break;
        }
      }
      if (clickedArrow != null) {
        break;
      }
    }
    if (clickedArrow != null) {
      if (event.getClickCount() == 2) {
        zoomArrow=clickedArrow;
        if (slaveMappingPanel != null) {
          slaveMappingPanel.setMapping(ObjectExchange.etl.getFieldToFieldMapping((Table)zoomArrow.getSource().getItem(),(Table)zoomArrow.getTarget().getItem()));
          new AnimateThread(true).start();
          slaveMappingPanel.filterComponents(""String_Node_Str"",false);
          slaveMappingPanel.filterComponents(""String_Node_Str"",true);
        }
      }
 else {
        if (!clickedArrow.isSelected()) {
          clickedArrow.setSelected(true);
          selectedArrow=clickedArrow;
          detailsListener.showDetails(mapping.getSourceToTargetMap(selectedArrow.getSource().getItem(),selectedArrow.getTarget().getItem()));
        }
        repaint();
      }
    }
 else {
      detailsListener.showDetails(null);
    }
  }
 else {
    detailsListener.showDetails(null);
  }
}",0.9922313336210618
85464,"public void makeMapSelectedSourceAndTarget(){
  for (  LabeledRectangle source : getSelectedRectangles(sourceComponents)) {
    for (    LabeledRectangle target : getSelectedRectangles(targetComponents)) {
      makeMapSourceToTarget(source,target);
    }
  }
}","public void makeMapSelectedSourceAndTarget(){
  for (  LabeledRectangle source : getSelectedRectangles(sourceComponents)) {
    for (    LabeledRectangle target : getSelectedRectangles(cdmComponents)) {
      makeMapSourceToTarget(source,target);
    }
  }
}",0.9826589595375722
85465,"private void renderModel(){
  sourceComponents.clear();
  targetComponents.clear();
  arrows.clear();
  for (  MappableItem item : mapping.getSourceItems())   if (!showOnlyConnectedItems || isConnected(item)) {
    LabeledRectangle component=new LabeledRectangle(0,400,ITEM_WIDTH,ITEM_HEIGHT,item,new Color(255,128,0));
    sourceComponents.add(component);
  }
  for (  MappableItem item : mapping.getTargetItems())   if (!showOnlyConnectedItems || isConnected(item)) {
    LabeledRectangle component=new LabeledRectangle(0,400,ITEM_WIDTH,ITEM_HEIGHT,item,new Color(128,128,255));
    targetComponents.add(component);
  }
  for (  ItemToItemMap map : mapping.getSourceToTargetMaps()) {
    Arrow component=new Arrow(getComponentWithItem(map.getSourceItem(),sourceComponents),getComponentWithItem(map.getTargetItem(),targetComponents));
    arrows.add(component);
  }
  layoutItems();
  repaint();
}","private void renderModel(){
  sourceComponents.clear();
  cdmComponents.clear();
  arrows.clear();
  for (  MappableItem item : mapping.getSourceItems())   if (!showOnlyConnectedItems || isConnected(item)) {
    LabeledRectangle component=new LabeledRectangle(0,400,ITEM_WIDTH,ITEM_HEIGHT,item,new Color(255,128,0));
    sourceComponents.add(component);
  }
  for (  MappableItem item : mapping.getTargetItems())   if (!showOnlyConnectedItems || isConnected(item)) {
    LabeledRectangle component=new LabeledRectangle(0,400,ITEM_WIDTH,ITEM_HEIGHT,item,new Color(128,128,255));
    cdmComponents.add(component);
  }
  for (  ItemToItemMap map : mapping.getSourceToTargetMaps()) {
    Arrow component=new Arrow(getComponentWithItem(map.getSourceItem(),sourceComponents),getComponentWithItem(map.getTargetItem(),cdmComponents));
    arrows.add(component);
  }
  layoutItems();
  repaint();
}",0.9848908785674314
85466,"@Override public void mouseReleased(MouseEvent event){
  if (dragRectangle != null) {
    if (!isSorted(sourceComponents,new YComparator())) {
      Collections.sort(sourceComponents,new YComparator());
      mapping.setSourceItems(getItemsList(sourceComponents));
    }
    if (!isSorted(targetComponents,new YComparator())) {
      Collections.sort(targetComponents,new YComparator());
      mapping.setTargetItems(getItemsList(targetComponents));
    }
    dragRectangle=null;
    layoutItems();
  }
 else   if (dragArrow != null) {
    if (event.getX() > targetX - ARROW_START_WIDTH && event.getX() < targetX + ITEM_WIDTH)     for (    LabeledRectangle component : getVisibleRectangles(targetComponents)) {
      if (component.contains(event.getPoint(),ARROW_START_WIDTH,0)) {
        dragArrow.setTarget(component);
        if (dragArrow.getTarget() == dragArrowPreviousTarget) {
          arrows.add(dragArrow);
          break;
        }
        makeMapSourceToTarget(dragArrow.getSource(),dragArrow.getTarget());
        break;
      }
    }
    if (dragArrowPreviousTarget != null && dragArrow.getTarget() != dragArrowPreviousTarget) {
      mapping.removeSourceToTargetMap(dragArrow.getSource().getItem(),dragArrowPreviousTarget.getItem());
    }
    dragArrowPreviousTarget=null;
    dragArrow=null;
  }
  repaint();
}","@Override public void mouseReleased(MouseEvent event){
  if (dragRectangle != null) {
    if (!isSorted(sourceComponents,new YComparator())) {
      Collections.sort(sourceComponents,new YComparator());
      mapping.setSourceItems(getItemsList(sourceComponents));
    }
    if (!isSorted(cdmComponents,new YComparator())) {
      Collections.sort(cdmComponents,new YComparator());
      mapping.setTargetItems(getItemsList(cdmComponents));
    }
    dragRectangle=null;
    layoutItems();
  }
 else   if (dragArrow != null) {
    if (event.getX() > cdmX - ARROW_START_WIDTH && event.getX() < cdmX + ITEM_WIDTH)     for (    LabeledRectangle component : getVisibleRectangles(cdmComponents)) {
      if (component.contains(event.getPoint(),ARROW_START_WIDTH,0)) {
        dragArrow.setTarget(component);
        if (dragArrow.getTarget() == dragArrowPreviousTarget) {
          arrows.add(dragArrow);
          break;
        }
        makeMapSourceToTarget(dragArrow.getSource(),dragArrow.getTarget());
        break;
      }
    }
    if (dragArrowPreviousTarget != null && dragArrow.getTarget() != dragArrowPreviousTarget) {
      mapping.removeSourceToTargetMap(dragArrow.getSource().getItem(),dragArrowPreviousTarget.getItem());
    }
    dragArrowPreviousTarget=null;
    dragArrow=null;
  }
  repaint();
}",0.9795454545454544
85467,"public void setSize(int width,int height){
  sourceX=MARGIN;
  targetX=width - MARGIN - ITEM_WIDTH;
  layoutItems();
  super.setSize(width,height);
}","public void setSize(int width,int height){
  sourceX=MARGIN;
  cdmX=width - MARGIN - ITEM_WIDTH;
  layoutItems();
  super.setSize(width,height);
}",0.9694915254237289
85468,"public void removeMapSelectedSourceAndTarget(){
  for (  LabeledRectangle source : getSelectedRectangles(sourceComponents)) {
    for (    LabeledRectangle target : getSelectedRectangles(targetComponents)) {
      removeMapSourceToTarget(source,target);
    }
  }
}","public void removeMapSelectedSourceAndTarget(){
  for (  LabeledRectangle source : getSelectedRectangles(sourceComponents)) {
    for (    LabeledRectangle target : getSelectedRectangles(cdmComponents)) {
      removeMapSourceToTarget(source,target);
    }
  }
}",0.98292220113852
85469,"public Mapping<Table> getTableToTableMapping(){
  return new Mapping<Table>(sourceDb.getTables(),targetDb.getTables(),tableToTableMaps);
}","public Mapping<Table> getTableToTableMapping(){
  return new Mapping<Table>(sourceDb.getTables(),cdmDb.getTables(),tableToTableMaps);
}",0.967032967032967
85470,"public Database getTargetDatabase(){
  return targetDb;
}","public Database getTargetDatabase(){
  return cdmDb;
}",0.918918918918919
85471,"public void setTargetDatabase(Database targetDb){
  this.targetDb=targetDb;
}","public void setTargetDatabase(Database targetDb){
  this.cdmDb=targetDb;
}",0.9403973509933776
85472,"public ItemToItemMap(MappableItem sourceItem,MappableItem targetItem){
  this.sourceItem=sourceItem;
  this.targetItem=targetItem;
}","public ItemToItemMap(MappableItem sourceItem,MappableItem cdmItem){
  this.sourceItem=sourceItem;
  this.cdmItem=cdmItem;
}",0.8941176470588236
85473,"public MappableItem getTargetItem(){
  return targetItem;
}","public MappableItem getTargetItem(){
  return cdmItem;
}",0.9217391304347826
85474,"public int hashCode(){
  return (sourceItem.toString() + ""String_Node_Str"" + targetItem.toString()).hashCode();
}","public int hashCode(){
  return (sourceItem.toString() + ""String_Node_Str"" + cdmItem.toString()).hashCode();
}",0.9596412556053812
85475,"public void setTargetItem(MappableItem targetItem){
  this.targetItem=targetItem;
}","public void setTargetItem(MappableItem cdmItem){
  this.cdmItem=cdmItem;
}",0.8280254777070064
85476,"public boolean equals(Object other){
  if (other instanceof ItemToItemMap) {
    return (((ItemToItemMap)other).sourceItem.equals(sourceItem) && ((ItemToItemMap)other).targetItem.equals(targetItem));
  }
 else   return false;
}","public boolean equals(Object other){
  if (other instanceof ItemToItemMap) {
    return (((ItemToItemMap)other).sourceItem.equals(sourceItem) && ((ItemToItemMap)other).cdmItem.equals(cdmItem));
  }
 else   return false;
}",0.9598214285714286
85477,"public List<ItemToItemMap> getSourceToTargetMaps(){
  return sourceToTargetMaps;
}","public List<ItemToItemMap> getSourceToTargetMaps(){
  return sourceToCdmMaps;
}",0.9440993788819876
85478,"public void removeSourceToTargetMap(MappableItem sourceItem,MappableItem targetItem){
  Iterator<ItemToItemMap> iterator=sourceToTargetMaps.iterator();
  while (iterator.hasNext()) {
    ItemToItemMap sourceToTargetMap=iterator.next();
    if (sourceToTargetMap.getSourceItem().equals(sourceItem) && sourceToTargetMap.getTargetItem().equals(targetItem))     iterator.remove();
  }
}","public void removeSourceToTargetMap(MappableItem sourceItem,MappableItem targetItem){
  Iterator<ItemToItemMap> iterator=sourceToCdmMaps.iterator();
  while (iterator.hasNext()) {
    ItemToItemMap sourceToTargetMap=iterator.next();
    if (sourceToTargetMap.getSourceItem().equals(sourceItem) && sourceToTargetMap.getTargetItem().equals(targetItem))     iterator.remove();
  }
}",0.988173455978975
85479,"public void addSourceToTargetMap(MappableItem sourceItem,MappableItem targetItem){
  sourceToTargetMaps.add(new ItemToItemMap(sourceItem,targetItem));
}","public void addSourceToTargetMap(MappableItem sourceItem,MappableItem targetItem){
  sourceToCdmMaps.add(new ItemToItemMap(sourceItem,targetItem));
}",0.9700996677740864
85480,"@SuppressWarnings(""String_Node_Str"") public void setTargetItems(List<? extends MappableItem> targetItems){
  this.targetItems.clear();
  for (  MappableItem item : targetItems)   this.targetItems.add((T)item);
}","@SuppressWarnings(""String_Node_Str"") public void setTargetItems(List<? extends MappableItem> targetItems){
  this.cdmItems.clear();
  for (  MappableItem item : targetItems)   this.cdmItems.add((T)item);
}",0.9567307692307692
85481,"public ItemToItemMap getSourceToTargetMap(MappableItem sourceItem,MappableItem targetItem){
  Iterator<ItemToItemMap> iterator=sourceToTargetMaps.iterator();
  while (iterator.hasNext()) {
    ItemToItemMap sourceToTargetMap=iterator.next();
    if (sourceToTargetMap.getSourceItem().equals(sourceItem) && sourceToTargetMap.getTargetItem().equals(targetItem))     return sourceToTargetMap;
  }
  return null;
}","public ItemToItemMap getSourceToTargetMap(MappableItem sourceItem,MappableItem targetItem){
  Iterator<ItemToItemMap> iterator=sourceToCdmMaps.iterator();
  while (iterator.hasNext()) {
    ItemToItemMap sourceToTargetMap=iterator.next();
    if (sourceToTargetMap.getSourceItem().equals(sourceItem) && sourceToTargetMap.getTargetItem().equals(targetItem))     return sourceToTargetMap;
  }
  return null;
}",0.988984088127295
85482,"public List<MappableItem> getTargetItems(){
  List<MappableItem> list=new ArrayList<MappableItem>();
  for (  MappableItem item : targetItems)   list.add(item);
  return list;
}","public List<MappableItem> getTargetItems(){
  List<MappableItem> list=new ArrayList<MappableItem>();
  for (  MappableItem item : cdmItems)   list.add(item);
  return list;
}",0.9743589743589745
85483,"public Mapping(List<T> sourceItems,List<T> targetItems,List<ItemToItemMap> sourceToTargetMaps){
  this.sourceItems=sourceItems;
  this.targetItems=targetItems;
  this.sourceToTargetMaps=sourceToTargetMaps;
}","public Mapping(List<T> sourceItems,List<T> targetItems,List<ItemToItemMap> sourceToTargetMaps){
  this.sourceItems=sourceItems;
  this.cdmItems=targetItems;
  this.sourceToCdmMaps=sourceToTargetMaps;
}",0.9558823529411764
85484,"private static void addSourceTablesAppendix(CustomXWPFDocument document,ETL etl){
  XWPFParagraph paragraph=document.createParagraph();
  XWPFRun run=paragraph.createRun();
  run.addBreak(BreakType.PAGE);
  run.setText(""String_Node_Str"");
  run.setFontSize(18);
  for (  Table sourceTable : etl.getSourceDatabase().getTables()) {
    paragraph=document.createParagraph();
    run=paragraph.createRun();
    run.setText(""String_Node_Str"" + sourceTable.getName());
    run.setFontSize(14);
    if (!sourceTable.getComment().equals(""String_Node_Str"")) {
      paragraph=document.createParagraph();
      run=paragraph.createRun();
      run.setText(sourceTable.getComment());
    }
    XWPFTable table=document.createTable(sourceTable.getFields().size() + 1,4);
    XWPFTableRow header=table.getRow(0);
    setTextAndHeaderShading(header.getCell(0),""String_Node_Str"");
    setTextAndHeaderShading(header.getCell(1),""String_Node_Str"");
    setTextAndHeaderShading(header.getCell(2),""String_Node_Str"");
    setTextAndHeaderShading(header.getCell(3),""String_Node_Str"");
    int rowNr=1;
    for (    Field sourceField : sourceTable.getFields()) {
      XWPFTableRow row=table.getRow(rowNr++);
      row.getCell(0).setText(sourceField.getName());
      row.getCell(1).setText(sourceField.getType());
      if (sourceField.getValueCounts() != null)       row.getCell(2).setText(sourceField.getValueCounts()[0][0]);
      row.getCell(3).setText(sourceField.getComment());
    }
  }
  run.setFontSize(18);
}","private static void addSourceTablesAppendix(CustomXWPFDocument document,ETL etl){
  XWPFParagraph paragraph=document.createParagraph();
  XWPFRun run=paragraph.createRun();
  run.addBreak(BreakType.PAGE);
  run.setText(""String_Node_Str"");
  run.setFontSize(18);
  for (  Table sourceTable : etl.getSourceDatabase().getTables()) {
    paragraph=document.createParagraph();
    run=paragraph.createRun();
    run.setText(""String_Node_Str"" + sourceTable.getName());
    run.setFontSize(14);
    if (!sourceTable.getComment().equals(""String_Node_Str"")) {
      paragraph=document.createParagraph();
      run=paragraph.createRun();
      run.setText(sourceTable.getComment());
    }
    XWPFTable table=document.createTable(sourceTable.getFields().size() + 1,4);
    XWPFTableRow header=table.getRow(0);
    setTextAndHeaderShading(header.getCell(0),""String_Node_Str"");
    setTextAndHeaderShading(header.getCell(1),""String_Node_Str"");
    setTextAndHeaderShading(header.getCell(2),""String_Node_Str"");
    setTextAndHeaderShading(header.getCell(3),""String_Node_Str"");
    int rowNr=1;
    for (    Field sourceField : sourceTable.getFields()) {
      XWPFTableRow row=table.getRow(rowNr++);
      row.getCell(0).setText(sourceField.getName());
      row.getCell(1).setText(sourceField.getType());
      if (sourceField.getValueCounts() != null && sourceField.getValueCounts().length != 0)       row.getCell(2).setText(sourceField.getValueCounts()[0][0]);
      row.getCell(3).setText(sourceField.getComment());
    }
  }
  run.setFontSize(18);
}",0.9855167873601052
85485,"public void buildMap(){
  for (int i=1; i < raw.size(); i+=2) {
    byte[] k=raw.get(i);
    byte[] v=raw.get(i + 1);
    keys.add(k);
    items.put(k,v);
  }
}","public void buildMap(){
  for (int i=1; i < raw.size() + 1; i+=2) {
    byte[] k=raw.get(i);
    byte[] v=raw.get(i + 1);
    keys.add(k);
    items.put(k,v);
  }
}",0.9876543209876544
85486,"public void buildMap(){
  for (int i=1; i < raw.size() + 1; i+=2) {
    byte[] k=raw.get(i);
    byte[] v=raw.get(i + 1);
    keys.add(k);
    items.put(k,v);
  }
}","public void buildMap(){
  for (int i=1; i + 1 < raw.size(); i+=2) {
    byte[] k=raw.get(i);
    byte[] v=raw.get(i + 1);
    keys.add(k);
    items.put(k,v);
  }
}",0.975609756097561
85487,"public static void main(String[] args) throws Exception {
  SSDB ssdb=null;
  Response resp;
  byte[] b;
  ssdb=new SSDB(""String_Node_Str"",8888);
  resp=ssdb.request(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  for (int i=1; i < resp.raw.size(); i+=2) {
    String s=new String(resp.raw.get(i));
    System.out.println(s);
  }
  System.out.println(""String_Node_Str"");
  ssdb.set(""String_Node_Str"",""String_Node_Str"");
  b=ssdb.get(""String_Node_Str"");
  System.out.println(new String(b));
  ssdb.del(""String_Node_Str"");
  b=ssdb.get(""String_Node_Str"");
  System.out.println(b);
  ssdb.incr(""String_Node_Str"",10);
  resp=ssdb.scan(""String_Node_Str"",""String_Node_Str"",10);
  resp.print();
  resp=ssdb.rscan(""String_Node_Str"",""String_Node_Str"",10);
  resp.print();
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  ssdb.hset(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  b=ssdb.hget(""String_Node_Str"",""String_Node_Str"");
  System.out.println(new String(b));
  ssdb.hdel(""String_Node_Str"",""String_Node_Str"");
  b=ssdb.hget(""String_Node_Str"",""String_Node_Str"");
  System.out.println(b);
  ssdb.hincr(""String_Node_Str"",""String_Node_Str"",10);
  resp=ssdb.hscan(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",10);
  resp.print();
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  Long d;
  ssdb.zset(""String_Node_Str"",""String_Node_Str"",123);
  d=ssdb.zget(""String_Node_Str"",""String_Node_Str"");
  System.out.println(d);
  ssdb.zdel(""String_Node_Str"",""String_Node_Str"");
  d=ssdb.zget(""String_Node_Str"",""String_Node_Str"");
  System.out.println(d);
  ssdb.zincr(""String_Node_Str"",""String_Node_Str"",10);
  resp=ssdb.zscan(""String_Node_Str"",""String_Node_Str"",null,null,10);
  resp.print();
  System.out.println(""String_Node_Str"");
  ssdb.multi_set(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  resp=ssdb.multi_get(""String_Node_Str"",""String_Node_Str"");
  resp.print();
  System.out.println(""String_Node_Str"");
  ssdb.close();
}","public static void main(String[] args) throws Exception {
  SSDB ssdb=null;
  Response resp;
  byte[] b;
  ssdb=new SSDB(""String_Node_Str"",8888);
  System.out.println(""String_Node_Str"");
  resp=ssdb.request(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  for (int i=1; i < resp.raw.size(); i+=2) {
    String s=new String(resp.raw.get(i));
    System.out.println(s);
  }
  System.out.println(""String_Node_Str"");
  ssdb.set(""String_Node_Str"",""String_Node_Str"");
  b=ssdb.get(""String_Node_Str"");
  System.out.println(new String(b));
  ssdb.del(""String_Node_Str"");
  b=ssdb.get(""String_Node_Str"");
  System.out.println(b);
  ssdb.incr(""String_Node_Str"",10);
  resp=ssdb.scan(""String_Node_Str"",""String_Node_Str"",10);
  resp.print();
  resp=ssdb.rscan(""String_Node_Str"",""String_Node_Str"",10);
  resp.print();
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  ssdb.hset(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  b=ssdb.hget(""String_Node_Str"",""String_Node_Str"");
  System.out.println(new String(b));
  ssdb.hdel(""String_Node_Str"",""String_Node_Str"");
  b=ssdb.hget(""String_Node_Str"",""String_Node_Str"");
  System.out.println(b);
  ssdb.hincr(""String_Node_Str"",""String_Node_Str"",10);
  resp=ssdb.hscan(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",10);
  resp.print();
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  Long d;
  ssdb.zset(""String_Node_Str"",""String_Node_Str"",123);
  d=ssdb.zget(""String_Node_Str"",""String_Node_Str"");
  System.out.println(d);
  ssdb.zdel(""String_Node_Str"",""String_Node_Str"");
  d=ssdb.zget(""String_Node_Str"",""String_Node_Str"");
  System.out.println(d);
  ssdb.zincr(""String_Node_Str"",""String_Node_Str"",10);
  resp=ssdb.zscan(""String_Node_Str"",""String_Node_Str"",null,null,10);
  resp.print();
  System.out.println(""String_Node_Str"");
  ssdb.multi_set(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  resp=ssdb.multi_get(""String_Node_Str"",""String_Node_Str"");
  resp.print();
  System.out.println(""String_Node_Str"");
  ssdb.close();
}",0.9900557846228476
85488,"public static void main(String[] args) throws Exception {
  String k=""String_Node_Str"";
  String v=""String_Node_Str"";
  int i=0;
  while (true) {
    SSDB ssdb=null;
    try {
      ssdb=new SSDB(""String_Node_Str"",8888,5000);
      ssdb.set(k,v);
      ssdb.close();
    }
 catch (    Exception e) {
      if (ssdb != null) {
        ssdb.close();
      }
      continue;
    }
 finally {
      if (ssdb != null) {
        ssdb.close();
      }
    }
    if (ssdb != null) {
      ssdb.close();
    }
    if (++i % 1000 == 1) {
      System.out.println(""String_Node_Str"");
      System.in.read();
    }
  }
}","public static void main(String[] args) throws Exception {
  String s=""String_Node_Str"";
  s+=s;
  s+=s;
  byte[] bytes=s.getBytes();
  Link link=new Link();
  link.testRead(bytes);
  for (int i=0; i < bytes.length; i++) {
    byte[] bs={bytes[i]};
    link.testRead(bs);
  }
}",0.255656108597285
85489,"private List<byte[]> parse(){
  ArrayList<byte[]> list=new ArrayList<byte[]>();
  byte[] buf=input.buf;
  int idx=0;
  while (true) {
    int pos=input.memchr('\n',idx);
    if (pos == -1) {
      break;
    }
    if (pos == idx || (pos == idx + 1 && buf[idx] == '\r')) {
      if (list.isEmpty()) {
        idx+=1;
        continue;
      }
 else {
        input.decr(idx + 1);
        return list;
      }
    }
    String str=new String(buf,input.data + idx,pos - idx);
    int len=Integer.parseInt(str);
    idx=pos + 1;
    if (idx + len >= input.size) {
      break;
    }
    byte[] data=Arrays.copyOfRange(buf,input.data + idx,input.data + idx + len);
    idx+=len + 1;
    list.add(data);
  }
  return null;
}","private List<byte[]> parse() throws Exception {
  ArrayList<byte[]> list=new ArrayList<byte[]>();
  int idx=0;
  while (idx < input.size && (input.chatAt(idx) == '\r' || input.chatAt(idx) == '\n')) {
    idx++;
  }
  while (idx < input.size) {
    int data_idx=input.memchr('\n',idx);
    if (data_idx == -1) {
      break;
    }
    data_idx+=1;
    int head_len=data_idx - idx;
    if (head_len == 1 || (head_len == 2 && input.chatAt(idx) == '\r')) {
      input.decr(data_idx);
      return list;
    }
    String str=new String(input.copyOfRange(idx,data_idx));
    str=str.trim();
    int size;
    try {
      size=Integer.parseInt(str,10);
    }
 catch (    Exception e) {
      throw new Exception(""String_Node_Str"");
    }
    idx=data_idx + size;
    int left=input.size - idx;
    if (left >= 1 && input.chatAt(idx) == '\n') {
      idx+=1;
    }
 else     if (left >= 2 && input.chatAt(idx) == '\r' && input.chatAt(idx + 1) == '\n') {
      idx+=2;
    }
 else     if (left >= 2) {
      throw new Exception(""String_Node_Str"");
    }
 else {
      break;
    }
    byte[] data=input.copyOfRange(data_idx,data_idx + size);
    list.add(data);
  }
  return null;
}",0.2558139534883721
85490,"private void send(MemoryStream buf) throws Exception {
  OutputStream os=sock.getOutputStream();
  os.write(buf.buf,buf.data,buf.size);
  os.flush();
}","private void send(MemoryStream buf) throws Exception {
  OutputStream os=sock.getOutputStream();
  os.write(buf.toArray());
  os.flush();
}",0.903448275862069
85491,"@Override public void onPictureTaken(byte[] data,Camera camera){
  mTakenPhotoView.setImageBitmap(PhotoUtils.bitmapFromRawBytes(data,mTakenPhotoView.getWidth(),mTakenPhotoView.getHeight()));
}","@Override public void onPictureTaken(byte[] data,Camera camera){
  showPicture(PictureUtils.bitmapFromRawBytes(data,mPictureView.getWidth(),mPictureView.getHeight()));
}",0.8033240997229917
85492,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_basic_picture_taking);
  mPreviewSurfaceView=(SurfaceView)findViewById(R.id.preview_surface);
  mErrorTextView=(TextView)findViewById(R.id.error_text);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_basic_picture_taking);
  mPreviewSurface=(SurfaceView)findViewById(R.id.preview_surface);
  mErrorTextView=(TextView)findViewById(R.id.error_text);
  mPictureView=(ImageView)findViewById(R.id.picture_taken);
  mCaptureButton=(ImageButton)findViewById(R.id.capture_button);
  mCaptureButton.setOnClickListener(this);
  mHidePictureDelay=getResources().getInteger(R.integer.picture_taken_show_duration);
  mHandler=new Handler(Looper.getMainLooper());
}",0.6498855835240275
85493,"/** 
 * Starts the camera preview using our already-created surface.
 */
private void startPreview(){
  try {
    mCamera.setPreviewDisplay(mSurfaceHolder);
    mCamera.startPreview();
  }
 catch (  IOException e) {
    showError(R.string.error_preview_not_started);
  }
}","/** 
 * Starts the camera preview using our already-created surface or shows an error message if there was a problem starting the preview.
 */
private void startPreview(){
  try {
    mCamera.setPreviewDisplay(mSurfaceHolder);
    mCamera.startPreview();
  }
 catch (  IOException e) {
    showError(R.string.error_preview_not_started);
  }
}",0.8859934853420195
85494,"/** 
 * Open the first back-facing camera and grab a   {@link android.hardware.Camera} instance.
 * @return A {@link android.hardware.Camera} instance for setting up the device camera andtaking pictures.
 */
private Camera openCamera(){
  return Camera.open();
}","/** 
 * Open the first back-facing camera and grab a   {@link android.hardware.Camera} instance.
 */
private void openCamera(){
  if (mCamera == null) {
    mCamera=Camera.open();
  }
}",0.6487695749440716
85495,"@Override protected void onPause(){
  super.onPause();
  if (mSurfaceHolder != null) {
    mSurfaceHolder.removeCallback(this);
  }
  closeCamera();
}","@Override protected void onPause(){
  super.onPause();
  if (mSurfaceHolder != null) {
    mSurfaceHolder.removeCallback(this);
  }
  closeCamera();
  mHandler.removeCallbacks(mHidePictureRunnable);
  hidePictureTaken();
}",0.8064516129032258
85496,"@Override protected void onResume(){
  super.onResume();
  if (hasCamera()) {
    mCamera=openCamera();
    mSurfaceHolder=mPreviewSurfaceView != null ? mPreviewSurfaceView.getHolder() : null;
    if (mSurfaceHolder != null) {
      mSurfaceHolder.addCallback(this);
      if (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {
        mSurfaceHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
      }
      hideError();
    }
 else {
      showError(R.string.error_preview_surface_view_does_not_exist);
    }
  }
}","@Override protected void onResume(){
  super.onResume();
  if (hasCamera()) {
    openCamera();
    mSurfaceHolder=mPreviewSurface != null ? mPreviewSurface.getHolder() : null;
    if (mSurfaceHolder != null) {
      mSurfaceHolder.addCallback(this);
      if (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {
        mSurfaceHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
      }
      hideError();
    }
 else {
      showError(R.string.error_preview_surface_view_does_not_exist);
    }
  }
}",0.9346153846153846
85497,"/** 
 * Hides the error message text and show the camera preview.
 */
private void hideError(){
  mErrorTextView.setVisibility(View.GONE);
  mPreviewSurfaceView.setVisibility(View.VISIBLE);
}","/** 
 * Hides the error message text and show the camera preview.
 */
private void hideError(){
  mErrorTextView.setVisibility(View.GONE);
  mPreviewSurface.setVisibility(View.VISIBLE);
}",0.9894179894179894
85498,"/** 
 * Show an error message text and hide the camera preview.
 * @param errorResourceId A resource ID for the error string resource.
 */
private void showError(int errorResourceId){
  mErrorTextView.setText(errorResourceId);
  mErrorTextView.setVisibility(View.VISIBLE);
  mPreviewSurfaceView.setVisibility(View.GONE);
}","/** 
 * Show an error message text and hide the camera preview.
 * @param errorResourceId A resource ID for the error string resource.
 */
private void showError(int errorResourceId){
  mErrorTextView.setText(errorResourceId);
  mErrorTextView.setVisibility(View.VISIBLE);
  mPreviewSurface.setVisibility(View.GONE);
}",0.99375
85499,"@Override public void surfaceCreated(SurfaceHolder holder){
  startPreview();
}","@Override public void surfaceCreated(SurfaceHolder holder){
  openCamera();
  startPreview();
}",0.9080459770114944
85500,"@SuppressWarnings(""String_Node_Str"") public static void main(final String[] args) throws ParseException, DataDefenderException, AnonymizerException, IOException, SAXException, TikaException, java.text.ParseException {
  final long startTime=System.currentTimeMillis();
  final ApplicationLock al=new ApplicationLock(""String_Node_Str"");
  if (al.isAppActive()) {
    log.error(""String_Node_Str"");
    System.exit(1);
  }
  log.info(""String_Node_Str"" + Arrays.toString(args));
  final Options options=createOptions();
  final CommandLine line=getCommandLine(options,args);
  @SuppressWarnings(""String_Node_Str"") List<String> unparsedArgs=line.getArgList();
  if (line.hasOption(""String_Node_Str"") || args.length == 0 || unparsedArgs.size() < 1) {
    help(options);
    return;
  }
  if (line.hasOption(""String_Node_Str"")) {
    LogManager.getRootLogger().setLevel(Level.DEBUG);
  }
 else {
    LogManager.getRootLogger().setLevel(Level.INFO);
  }
  final String cmd=unparsedArgs.get(0);
  unparsedArgs=unparsedArgs.subList(1,unparsedArgs.size());
  List<String> errors=new ArrayList();
  if (""String_Node_Str"".equals(cmd)) {
    errors=PropertyCheck.check(cmd,' ');
    if (errors.size() > 0) {
      displayErrors(errors);
      return;
    }
    final String fileDiscoveryPropertyFile=line.getOptionValue('F',""String_Node_Str"");
    final Properties fileDiscoveryProperties=loadProperties(fileDiscoveryPropertyFile);
    final FileDiscoverer discoverer=new FileDiscoverer();
    discoverer.discover(fileDiscoveryProperties);
    return;
  }
  errors=PropertyCheck.checkDtabaseProperties();
  if (errors.size() > 0) {
    displayErrors(errors);
    return;
  }
  final Properties props=loadProperties(line.getOptionValue('P',""String_Node_Str""));
  try (final IDBFactory dbFactory=IDBFactory.get(props)){
switch (cmd) {
case ""String_Node_Str"":
      errors=PropertyCheck.check(cmd,' ');
    if (errors.size() > 0) {
      displayErrors(errors);
      return;
    }
  final String anonymizerPropertyFile=line.getOptionValue('A',""String_Node_Str"");
final Properties anonymizerProperties=loadProperties(anonymizerPropertyFile);
final IAnonymizer anonymizer=new DatabaseAnonymizer();
anonymizer.anonymize(dbFactory,anonymizerProperties,getTableNames(unparsedArgs,anonymizerProperties));
break;
case ""String_Node_Str"":
errors=PropertyCheck.check(cmd,' ');
if (errors.size() > 0) {
displayErrors(errors);
return;
}
final IGenerator generator=new DataGenerator();
final String generatorPropertyFile=line.getOptionValue('A',""String_Node_Str"");
final Properties generatorProperties=loadProperties(generatorPropertyFile);
generator.generate(dbFactory,generatorProperties);
break;
case ""String_Node_Str"":
if (line.hasOption('c')) {
errors=PropertyCheck.check(cmd,'c');
if (errors.size() > 0) {
displayErrors(errors);
return;
}
final String columnPropertyFile=line.getOptionValue('C',""String_Node_Str"");
final Properties columnProperties=loadProperties(columnPropertyFile);
final ColumnDiscoverer discoverer=new ColumnDiscoverer();
discoverer.discover(dbFactory,columnProperties,getTableNames(unparsedArgs,columnProperties));
log.debug(""String_Node_Str"" + line.getOptionValue('R',""String_Node_Str""));
if (line.hasOption('r')) {
discoverer.createRequirement(line.getOptionValue('R',""String_Node_Str""));
}
}
 else if (line.hasOption('d')) {
errors=PropertyCheck.check(cmd,'d');
if (errors.size() > 0) {
displayErrors(errors);
return;
}
final String datadiscoveryPropertyFile=line.getOptionValue('D',""String_Node_Str"");
final Properties dataDiscoveryProperties=loadProperties(datadiscoveryPropertyFile);
final DatabaseDiscoverer discoverer=new DatabaseDiscoverer();
discoverer.discover(dbFactory,dataDiscoveryProperties,getTableNames(unparsedArgs,dataDiscoveryProperties));
if (line.hasOption('r')) {
discoverer.createRequirement(line.getOptionValue('R',""String_Node_Str""));
}
}
break;
default :
help(options);
break;
}
}
 final long endTime=System.currentTimeMillis();
final NumberFormat formatter=new DecimalFormat(""String_Node_Str"");
log.info(""String_Node_Str"" + formatter.format((endTime - startTime) / 1000d) + ""String_Node_Str"");
log.info(""String_Node_Str"");
}","@SuppressWarnings(""String_Node_Str"") public static void main(final String[] args) throws ParseException, DataDefenderException, AnonymizerException, IOException, SAXException, TikaException, java.text.ParseException {
  final long startTime=System.currentTimeMillis();
  final ApplicationLock al=new ApplicationLock(""String_Node_Str"");
  if (al.isAppActive()) {
    log.error(""String_Node_Str"");
    System.exit(1);
  }
  log.info(""String_Node_Str"" + Arrays.toString(args));
  final Options options=createOptions();
  final CommandLine line=getCommandLine(options,args);
  @SuppressWarnings(""String_Node_Str"") List<String> unparsedArgs=line.getArgList();
  if (line.hasOption(""String_Node_Str"") || args.length == 0 || unparsedArgs.size() < 1) {
    help(options);
    return;
  }
  if (line.hasOption(""String_Node_Str"")) {
    LogManager.getRootLogger().setLevel(Level.DEBUG);
  }
 else {
    LogManager.getRootLogger().setLevel(Level.INFO);
  }
  final String cmd=unparsedArgs.get(0);
  unparsedArgs=unparsedArgs.subList(1,unparsedArgs.size());
  List<String> errors=new ArrayList();
  if (""String_Node_Str"".equals(cmd)) {
    errors=PropertyCheck.check(cmd,' ');
    if (errors.size() > 0) {
      displayErrors(errors);
      return;
    }
    final String fileDiscoveryPropertyFile=line.getOptionValue('F',""String_Node_Str"");
    final Properties fileDiscoveryProperties=loadProperties(fileDiscoveryPropertyFile);
    final FileDiscoverer discoverer=new FileDiscoverer();
    discoverer.discover(fileDiscoveryProperties);
    return;
  }
  errors=PropertyCheck.checkDtabaseProperties();
  if (errors.size() > 0) {
    displayErrors(errors);
    return;
  }
  final Properties props=loadProperties(line.getOptionValue('P',""String_Node_Str""));
  try (final IDBFactory dbFactory=IDBFactory.get(props)){
switch (cmd) {
case ""String_Node_Str"":
      errors=PropertyCheck.check(cmd,' ');
    if (errors.size() > 0) {
      displayErrors(errors);
      return;
    }
  final String anonymizerPropertyFile=line.getOptionValue('A',""String_Node_Str"");
final Properties anonymizerProperties=loadProperties(anonymizerPropertyFile);
final IAnonymizer anonymizer=new DatabaseAnonymizer();
anonymizer.anonymize(dbFactory,anonymizerProperties,getTableNames(unparsedArgs,anonymizerProperties));
break;
case ""String_Node_Str"":
errors=PropertyCheck.check(cmd,' ');
if (errors.size() > 0) {
displayErrors(errors);
return;
}
final IGenerator generator=new DataGenerator();
final String generatorPropertyFile=line.getOptionValue('A',""String_Node_Str"");
final Properties generatorProperties=loadProperties(generatorPropertyFile);
generator.generate(dbFactory,generatorProperties);
break;
case ""String_Node_Str"":
if (line.hasOption('c')) {
errors=PropertyCheck.check(cmd,'c');
if (errors.size() > 0) {
displayErrors(errors);
return;
}
final String columnPropertyFile=line.getOptionValue('C',""String_Node_Str"");
final Properties columnProperties=loadProperties(columnPropertyFile);
final ColumnDiscoverer discoverer=new ColumnDiscoverer();
discoverer.discover(dbFactory,columnProperties,getTableNames(unparsedArgs,columnProperties));
if (line.hasOption('r')) {
discoverer.createRequirement(""String_Node_Str"");
}
}
 else if (line.hasOption('d')) {
errors=PropertyCheck.check(cmd,'d');
if (errors.size() > 0) {
displayErrors(errors);
return;
}
final String datadiscoveryPropertyFile=line.getOptionValue('D',""String_Node_Str"");
final Properties dataDiscoveryProperties=loadProperties(datadiscoveryPropertyFile);
final DatabaseDiscoverer discoverer=new DatabaseDiscoverer();
discoverer.discover(dbFactory,dataDiscoveryProperties,getTableNames(unparsedArgs,dataDiscoveryProperties));
if (line.hasOption('r')) {
discoverer.createRequirement(""String_Node_Str"");
}
}
break;
default :
help(options);
break;
}
}
 final long endTime=System.currentTimeMillis();
final NumberFormat formatter=new DecimalFormat(""String_Node_Str"");
log.info(""String_Node_Str"" + formatter.format((endTime - startTime) / 1000d) + ""String_Node_Str"");
log.info(""String_Node_Str"");
}",0.9847094801223242
85501,"/** 
 * Creates options for the command line
 * @return Options
 */
private static Options createOptions(){
  final Options options=new Options();
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",false,""String_Node_Str"");
  return options;
}","/** 
 * Creates options for the command line
 * @return Options
 */
private static Options createOptions(){
  final Options options=new Options();
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",false,""String_Node_Str"");
  return options;
}",0.8127490039840638
85502,"/** 
 * Calls the anonymization function for the given Column, and returns its anonymized value.
 * @param dbConn
 * @param row
 * @param column
 * @return
 * @throws NoSuchMethodException
 * @throws SecurityException
 * @throws IllegalAccessException
 * @throws IllegalArgumentException
 * @throws InvocationTargetException 
 */
private Object callAnonymizingFunctionWithoutParameters(final Connection dbConn,final Column column) throws SQLException, NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
  final String function=column.getFunction();
  if (function == null || function.equals(""String_Node_Str"")) {
    log.warn(""String_Node_Str"" + column + ""String_Node_Str"");
    return ""String_Node_Str"";
  }
  try {
    final String className=Utils.getClassName(function);
    final String methodName=Utils.getMethodName(function);
    final Class<?> clazz=Class.forName(className);
    final CoreFunctions instance=(CoreFunctions)Class.forName(className).newInstance();
    instance.setDatabaseConnection(dbConn);
    final Method[] methods=clazz.getMethods();
    Method selectedMethod=null;
    Object returnType=null;
    methodLoop:     for (    final Method m : methods) {
      if (m.getName().equals(methodName)) {
        log.debug(""String_Node_Str"" + m.getName());
        selectedMethod=m;
        returnType=m.getReturnType();
        break;
      }
    }
    if (selectedMethod == null) {
      final StringBuilder s=new StringBuilder(""String_Node_Str"");
      s.append(methodName).append(""String_Node_Str"").append(className);
      throw new NoSuchMethodException(s.toString());
    }
    log.debug(""String_Node_Str"" + methodName);
    final Object anonymizedValue=selectedMethod.invoke(instance);
    log.debug(""String_Node_Str"" + anonymizedValue);
    if (anonymizedValue == null) {
      return null;
    }
    log.debug(returnType.toString());
    if (returnType == String.class) {
      return anonymizedValue.toString();
    }
 else     if (returnType == java.sql.Date.class) {
      return anonymizedValue;
    }
 else     if (returnType.toString().equals(""String_Node_Str"")) {
      return anonymizedValue;
    }
  }
 catch (  AnonymizerException|InstantiationException|ClassNotFoundException ex) {
    log.error(ex.toString());
  }
  return ""String_Node_Str"";
}","/** 
 * Calls the anonymization function for the given Column, and returns its anonymized value.
 * @param dbConn
 * @param row
 * @param column
 * @return
 * @throws NoSuchMethodException
 * @throws SecurityException
 * @throws IllegalAccessException
 * @throws IllegalArgumentException
 * @throws InvocationTargetException 
 */
private Object callAnonymizingFunctionWithoutParameters(final Connection dbConn,final Column column) throws SQLException, NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
  final String function=column.getFunction();
  if (function == null || function.equals(""String_Node_Str"")) {
    log.warn(""String_Node_Str"" + column + ""String_Node_Str"");
    return ""String_Node_Str"";
  }
  try {
    final String className=Utils.getClassName(function);
    final String methodName=Utils.getMethodName(function);
    final Class<?> clazz=Class.forName(className);
    final CoreFunctions instance=(CoreFunctions)Class.forName(className).newInstance();
    instance.setDatabaseConnection(dbConn);
    final Method[] methods=clazz.getMethods();
    Method selectedMethod=null;
    Object returnType=null;
    methodLoop:     for (    final Method m : methods) {
      if (m.getName().equals(methodName)) {
        log.debug(""String_Node_Str"" + m.getName());
        selectedMethod=m;
        returnType=m.getReturnType();
        break;
      }
    }
    if (selectedMethod == null) {
      final StringBuilder s=new StringBuilder(""String_Node_Str"");
      s.append(methodName).append(""String_Node_Str"").append(className);
      throw new NoSuchMethodException(s.toString());
    }
    log.info(""String_Node_Str"" + methodName);
    final Object anonymizedValue=selectedMethod.invoke(instance);
    log.info(""String_Node_Str"" + anonymizedValue);
    if (anonymizedValue == null) {
      return null;
    }
    log.debug(returnType);
    if (returnType == String.class) {
      return anonymizedValue.toString();
    }
 else     if (returnType == java.sql.Date.class) {
      return anonymizedValue;
    }
 else     if (returnType.equals(""String_Node_Str"")) {
      return anonymizedValue;
    }
  }
 catch (  AnonymizerException|InstantiationException|ClassNotFoundException ex) {
    log.error(ex.toString());
  }
  return ""String_Node_Str"";
}",0.991460290350128
85503,"/** 
 * Calls the anonymization function for the given Column, and returns its anonymized value.
 * @param dbConn
 * @param row
 * @param column
 * @return
 * @throws NoSuchMethodException
 * @throws SecurityException
 * @throws IllegalAccessException
 * @throws IllegalArgumentException
 * @throws InvocationTargetException 
 */
private Object callAnonymizingFunctionWithParameters(final Connection dbConn,final ResultSet row,final Column column,String vendor) throws SQLException, NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
  final String function=column.getFunction();
  if (function == null || function.equals(""String_Node_Str"")) {
    log.warn(""String_Node_Str"" + column + ""String_Node_Str"");
    return ""String_Node_Str"";
  }
  try {
    final String className=Utils.getClassName(function);
    final String methodName=Utils.getMethodName(function);
    final Class<?> clazz=Class.forName(className);
    final CoreFunctions instance=(CoreFunctions)Class.forName(className).newInstance();
    instance.setDatabaseConnection(dbConn);
    instance.setVendor(vendor);
    final List<Parameter> parms=column.getParameters();
    final Map<String,Object> paramValues=new HashMap<>(parms.size());
    final String columnValue=row.getString(column.getName());
    for (    final Parameter param : parms) {
      if (param.getValue().equals(""String_Node_Str"")) {
        paramValues.put(param.getName(),columnValue);
      }
 else       if (param.getValue().equals(""String_Node_Str"") && param.getType().equals(""String_Node_Str"")) {
        paramValues.put(param.getName(),row);
      }
 else {
        paramValues.put(param.getName(),param.getTypeValue());
      }
    }
    final List<Object> fnArguments=new ArrayList<>(parms.size());
    final Method[] methods=clazz.getMethods();
    Method selectedMethod=null;
    methodLoop:     for (    final Method m : methods) {
      if (m.getName().equals(methodName) && m.getReturnType() == String.class) {
        log.debug(""String_Node_Str"" + m.getName());
        log.debug(""String_Node_Str"" + paramValues);
        final java.lang.reflect.Parameter[] mParams=m.getParameters();
        fnArguments.clear();
        for (        final java.lang.reflect.Parameter par : mParams) {
          log.debug(""String_Node_Str"" + par.getName());
          if (!paramValues.containsKey(par.getName())) {
            continue methodLoop;
          }
          final Object value=paramValues.get(par.getName());
          Class<?> fnParamType=par.getType();
          final Class<?> confParamType=(value == null) ? fnParamType : value.getClass();
          if (fnParamType.isPrimitive() && value == null) {
            continue methodLoop;
          }
          if (ClassUtils.isPrimitiveWrapper(confParamType)) {
            if (!ClassUtils.isPrimitiveOrWrapper(fnParamType)) {
              continue methodLoop;
            }
            fnParamType=ClassUtils.primitiveToWrapper(fnParamType);
          }
          if (!fnParamType.equals(confParamType)) {
            continue methodLoop;
          }
          fnArguments.add(value);
        }
        if (fnArguments.size() != mParams.length || fnArguments.size() < paramValues.size()) {
          continue;
        }
        selectedMethod=m;
        break;
      }
    }
    if (selectedMethod == null) {
      final StringBuilder s=new StringBuilder(""String_Node_Str"");
      s.append(methodName).append(""String_Node_Str"");
      String comma=""String_Node_Str"";
      for (      final Parameter p : parms) {
        s.append(comma).append(p.getType()).append(' ').append(p.getName());
        comma=""String_Node_Str"";
      }
      s.append(""String_Node_Str"").append(className);
      throw new NoSuchMethodException(s.toString());
    }
    log.debug(""String_Node_Str"" + methodName + ""String_Node_Str""+ Arrays.toString(fnArguments.toArray()));
    final Object anonymizedValue=selectedMethod.invoke(instance,fnArguments.toArray());
    if (anonymizedValue == null) {
      return null;
    }
    return anonymizedValue.toString();
  }
 catch (  AnonymizerException|InstantiationException|ClassNotFoundException ex) {
    log.error(ex.toString());
  }
  return ""String_Node_Str"";
}","/** 
 * Calls the anonymization function for the given Column, and returns its anonymized value.
 * @param dbConn
 * @param row
 * @param column
 * @return
 * @throws NoSuchMethodException
 * @throws SecurityException
 * @throws IllegalAccessException
 * @throws IllegalArgumentException
 * @throws InvocationTargetException 
 */
private Object callAnonymizingFunctionWithParameters(final Connection dbConn,final ResultSet row,final Column column,String vendor) throws SQLException, NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
  final String function=column.getFunction();
  if (function == null || function.equals(""String_Node_Str"")) {
    log.warn(""String_Node_Str"" + column + ""String_Node_Str"");
    return ""String_Node_Str"";
  }
  try {
    final String className=Utils.getClassName(function);
    final String methodName=Utils.getMethodName(function);
    final Class<?> clazz=Class.forName(className);
    final CoreFunctions instance=(CoreFunctions)Class.forName(className).newInstance();
    instance.setDatabaseConnection(dbConn);
    instance.setVendor(vendor);
    final List<Parameter> parms=column.getParameters();
    final Map<String,Object> paramValues=new HashMap<>(parms.size());
    final String columnValue=row.getString(column.getName());
    for (    final Parameter param : parms) {
      if (param.getValue().equals(""String_Node_Str"")) {
        paramValues.put(param.getName(),columnValue);
      }
 else       if (param.getValue().equals(""String_Node_Str"") && param.getType().equals(""String_Node_Str"")) {
        paramValues.put(param.getName(),row);
      }
 else {
        paramValues.put(param.getName(),param.getTypeValue());
      }
    }
    final List<Object> fnArguments=new ArrayList<>(parms.size());
    final Method[] methods=clazz.getMethods();
    Method selectedMethod=null;
    methodLoop:     for (    final Method m : methods) {
      if (m.getName().equals(methodName) && m.getReturnType() == String.class) {
        log.info(""String_Node_Str"" + m.getName());
        log.info(""String_Node_Str"" + paramValues);
        final java.lang.reflect.Parameter[] mParams=m.getParameters();
        fnArguments.clear();
        for (        final java.lang.reflect.Parameter par : mParams) {
          log.debug(""String_Node_Str"" + par.getName());
          if (!paramValues.containsKey(par.getName())) {
            continue methodLoop;
          }
          final Object value=paramValues.get(par.getName());
          Class<?> fnParamType=par.getType();
          final Class<?> confParamType=(value == null) ? fnParamType : value.getClass();
          if (fnParamType.isPrimitive() && value == null) {
            continue methodLoop;
          }
          if (ClassUtils.isPrimitiveWrapper(confParamType)) {
            if (!ClassUtils.isPrimitiveOrWrapper(fnParamType)) {
              continue methodLoop;
            }
            fnParamType=ClassUtils.primitiveToWrapper(fnParamType);
          }
          if (!fnParamType.equals(confParamType)) {
            continue methodLoop;
          }
          fnArguments.add(value);
        }
        if (fnArguments.size() != mParams.length || fnArguments.size() < paramValues.size()) {
          continue;
        }
        selectedMethod=m;
        break;
      }
    }
    if (selectedMethod == null) {
      final StringBuilder s=new StringBuilder(""String_Node_Str"");
      s.append(methodName).append(""String_Node_Str"");
      String comma=""String_Node_Str"";
      for (      final Parameter p : parms) {
        s.append(comma).append(p.getType()).append(' ').append(p.getName());
        comma=""String_Node_Str"";
      }
      s.append(""String_Node_Str"").append(className);
      throw new NoSuchMethodException(s.toString());
    }
    log.info(""String_Node_Str"" + methodName + ""String_Node_Str""+ Arrays.toString(fnArguments.toArray()));
    final Object anonymizedValue=selectedMethod.invoke(instance,fnArguments.toArray());
    if (anonymizedValue == null) {
      return null;
    }
    return anonymizedValue.toString();
  }
 catch (  AnonymizerException|InstantiationException|ClassNotFoundException ex) {
    log.error(ex.toString());
  }
  return ""String_Node_Str"";
}",0.9968239030702272
85504,"/** 
 * Anonymizes a row of columns. Sets query parameters on the passed updateStmt - this includes the key values - and calls anonymization functions for the columns.
 * @param updateStmt
 * @param tableColumns
 * @param keyNames
 * @param db
 * @param row
 * @param columnMetaData
 * @throws SQLException
 * @throws NoSuchMethodException
 * @throws SecurityException
 * @throws IllegalAccessException
 * @throws IllegalArgumentException
 * @throws InvocationTargetException 
 */
private void anonymizeRow(final PreparedStatement updateStmt,final Collection<Column> tableColumns,final Collection<String> keyNames,final Connection db,final ResultSet row,final List<MatchMetaData> columnMetaData,final String vendor) throws SQLException, NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, AnonymizerException {
  int fieldIndex=0;
  final Map<String,Integer> columnIndexes=new HashMap<>(tableColumns.size());
  final Set<String> anonymized=new HashSet<>(tableColumns.size());
  for (  final Column column : tableColumns) {
    final String columnName=column.getName();
    if (anonymized.contains(columnName)) {
      continue;
    }
    if (!columnIndexes.containsKey(columnName)) {
      final int columnIndex=++fieldIndex;
      columnIndexes.put(columnName,columnIndex);
    }
    if (isExcludedColumn(row,column)) {
      final String columnValue=row.getString(columnName);
      updateStmt.setString(columnIndexes.get(columnName),columnValue);
      log.debug(""String_Node_Str"" + columnName + ""String_Node_Str""+ columnValue);
      continue;
    }
    anonymized.add(columnName);
    final Object colValue=callAnonymizingFunctionFor(db,row,column,vendor);
    log.debug(""String_Node_Str"" + colValue);
    if (colValue == null) {
      updateStmt.setNull(columnIndexes.get(columnName),Types.NULL);
    }
 else     if (colValue.getClass() == java.sql.Date.class) {
      updateStmt.setDate(columnIndexes.get(columnName),CommonUtils.stringToDate(colValue.toString(),""String_Node_Str""));
    }
 else     if (colValue.getClass() == java.lang.Integer.class) {
      updateStmt.setInt(columnIndexes.get(columnName),(int)colValue);
    }
 else {
      updateStmt.setString(columnIndexes.get(columnName),getTruncatedColumnValue((String)colValue,columnIndexes.get(columnName),columnMetaData));
    }
  }
  int whereIndex=fieldIndex;
  for (  final String key : keyNames) {
    updateStmt.setString(++whereIndex,row.getString(key));
  }
  updateStmt.addBatch();
}","/** 
 * Anonymizes a row of columns. Sets query parameters on the passed updateStmt - this includes the key values - and calls anonymization functions for the columns.
 * @param updateStmt
 * @param tableColumns
 * @param keyNames
 * @param db
 * @param row
 * @param columnMetaData
 * @throws SQLException
 * @throws NoSuchMethodException
 * @throws SecurityException
 * @throws IllegalAccessException
 * @throws IllegalArgumentException
 * @throws InvocationTargetException 
 */
private void anonymizeRow(final PreparedStatement updateStmt,final Collection<Column> tableColumns,final Collection<String> keyNames,final Connection db,final ResultSet row,final List<MatchMetaData> columnMetaData,final String vendor) throws SQLException, NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, AnonymizerException {
  int fieldIndex=0;
  final Map<String,Integer> columnIndexes=new HashMap<>(tableColumns.size());
  final Set<String> anonymized=new HashSet<>(tableColumns.size());
  for (  final Column column : tableColumns) {
    final String columnName=column.getName();
    if (anonymized.contains(columnName)) {
      continue;
    }
    if (!columnIndexes.containsKey(columnName)) {
      final int columnIndex=++fieldIndex;
      columnIndexes.put(columnName,columnIndex);
    }
    if (isExcludedColumn(row,column)) {
      final String columnValue=row.getString(columnName);
      updateStmt.setString(columnIndexes.get(columnName),columnValue);
      log.debug(""String_Node_Str"" + columnName + ""String_Node_Str""+ columnValue);
      continue;
    }
    anonymized.add(columnName);
    final Object colValue=callAnonymizingFunctionFor(db,row,column,vendor);
    log.info(""String_Node_Str"" + colValue);
    log.info(""String_Node_Str"" + colValue.getClass());
    if (colValue == null) {
      updateStmt.setNull(columnIndexes.get(columnName),Types.NULL);
    }
 else     if (colValue.getClass() == java.sql.Date.class) {
      updateStmt.setDate(columnIndexes.get(columnName),CommonUtils.stringToDate(colValue.toString(),""String_Node_Str""));
    }
 else     if (colValue.getClass() == java.lang.Integer.class) {
      updateStmt.setInt(columnIndexes.get(columnName),(int)colValue);
    }
 else {
      log.info(""String_Node_Str"");
      updateStmt.setString(columnIndexes.get(columnName),getTruncatedColumnValue((String)colValue,columnIndexes.get(columnName),columnMetaData));
      log.info(""String_Node_Str"");
    }
  }
  int whereIndex=fieldIndex - 1;
  log.info(""String_Node_Str"");
  log.info(keyNames.toString());
  log.info(whereIndex);
  log.info(updateStmt.toString());
  for (  final String key : keyNames) {
    updateStmt.setString(++whereIndex,row.getString(key));
  }
  log.info(""String_Node_Str"");
  log.info(updateStmt);
  updateStmt.addBatch();
}",0.9410007468259896
85505,"/** 
 * Anonymization function for a single table. Sets up queries, loops over columns and anonymizes columns for the passed Table.
 * @param table 
 */
private void anonymizeTable(final int batchSize,final IDBFactory dbFactory,final Table table) throws AnonymizerException {
  log.info(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
  final List<Column> tableColumns=table.getColumns();
  final Set<String> colNames=new LinkedHashSet<>(tableColumns.size());
  final List<String> keyNames=new LinkedList<>();
  fillColumnNames(table,colNames);
  fillPrimaryKeyNamesList(table,keyNames);
  PreparedStatement selectStmt=null;
  PreparedStatement updateStmt=null;
  ResultSet rs=null;
  final Connection updateCon=dbFactory.getUpdateConnection();
  try {
    selectStmt=getSelectQueryStatement(dbFactory,table,keyNames,colNames);
    rs=selectStmt.executeQuery();
    final List<MatchMetaData> columnMetaData=dbFactory.fetchMetaData().getMetaDataForRs(rs);
    final String updateString=getUpdateQuery(table,colNames,keyNames);
    updateStmt=updateCon.prepareStatement(updateString);
    int batchCounter=0;
    int rowCount=0;
    while (rs.next()) {
      anonymizeRow(updateStmt,tableColumns,keyNames,updateCon,rs,columnMetaData,dbFactory.getVendorName());
      batchCounter++;
      if (batchCounter == batchSize) {
        updateStmt.executeBatch();
        updateCon.commit();
        batchCounter=0;
      }
      rowCount++;
    }
    log.debug(""String_Node_Str"" + rowCount);
    updateStmt.executeBatch();
    log.debug(""String_Node_Str"");
    updateCon.commit();
    log.debug(""String_Node_Str"");
    selectStmt.close();
    updateStmt.close();
    rs.close();
    log.debug(""String_Node_Str"");
  }
 catch (  SQLException|NoSuchMethodException|SecurityException|IllegalAccessException|IllegalArgumentException|InvocationTargetException ex) {
    log.error(ex.toString());
    if (ex.getCause() != null) {
      log.error(ex.getCause().toString());
    }
    try {
      if (selectStmt != null) {
        selectStmt.close();
      }
      if (updateStmt != null) {
        updateStmt.close();
      }
      if (rs != null) {
        rs.close();
      }
    }
 catch (    SQLException sqlex) {
      log.error(sqlex.toString());
    }
  }
 finally {
    try {
      if (selectStmt != null) {
        selectStmt.close();
      }
      if (updateStmt != null) {
        updateStmt.close();
      }
      if (rs != null) {
        rs.close();
      }
    }
 catch (    SQLException sqlex) {
      log.error(sqlex.toString());
    }
  }
  log.info(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
  log.info(""String_Node_Str"");
}","/** 
 * Anonymization function for a single table. Sets up queries, loops over columns and anonymizes columns for the passed Table.
 * @param table 
 */
private void anonymizeTable(final int batchSize,final IDBFactory dbFactory,final Table table) throws AnonymizerException {
  log.info(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
  final List<Column> tableColumns=table.getColumns();
  final Set<String> colNames=new LinkedHashSet<>(tableColumns.size());
  final List<String> keyNames=new LinkedList<>();
  fillColumnNames(table,colNames);
  fillPrimaryKeyNamesList(table,keyNames);
  PreparedStatement selectStmt=null;
  PreparedStatement updateStmt=null;
  ResultSet rs=null;
  final Connection updateCon=dbFactory.getUpdateConnection();
  try {
    selectStmt=getSelectQueryStatement(dbFactory,table,keyNames,colNames);
    rs=selectStmt.executeQuery();
    final List<MatchMetaData> columnMetaData=dbFactory.fetchMetaData().getMetaDataForRs(rs);
    final String updateString=getUpdateQuery(table,colNames,keyNames);
    updateStmt=updateCon.prepareStatement(updateString);
    int batchCounter=0;
    int rowCount=0;
    while (rs.next()) {
      anonymizeRow(updateStmt,tableColumns,keyNames,updateCon,rs,columnMetaData,dbFactory.getVendorName());
      log.info(updateStmt);
      batchCounter++;
      if (batchCounter == batchSize) {
        updateStmt.executeBatch();
        updateCon.commit();
        batchCounter=0;
      }
      rowCount++;
    }
    log.debug(""String_Node_Str"" + rowCount);
    updateStmt.executeBatch();
    log.debug(""String_Node_Str"");
    updateCon.commit();
    log.debug(""String_Node_Str"");
    selectStmt.close();
    updateStmt.close();
    rs.close();
    log.debug(""String_Node_Str"");
  }
 catch (  SQLException|NoSuchMethodException|SecurityException|IllegalAccessException|IllegalArgumentException|InvocationTargetException ex) {
    log.error(ex.toString());
    if (ex.getCause() != null) {
      log.error(ex.getCause().toString());
    }
    try {
      if (selectStmt != null) {
        selectStmt.close();
      }
      if (updateStmt != null) {
        updateStmt.close();
      }
      if (rs != null) {
        rs.close();
      }
    }
 catch (    SQLException sqlex) {
      log.error(sqlex.toString());
    }
  }
 finally {
    try {
      if (selectStmt != null) {
        selectStmt.close();
      }
      if (updateStmt != null) {
        updateStmt.close();
      }
      if (rs != null) {
        rs.close();
      }
    }
 catch (    SQLException sqlex) {
      log.error(sqlex.toString());
    }
  }
  log.info(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
  log.info(""String_Node_Str"");
}",0.994748687171793
85506,"/** 
 * Create a requirement from sorted (by (schema.)table) List of matching columns.
 * @param matches
 * @return
 */
public static Requirement create(final List<MatchMetaData> matches){
  final Map<String,Table> tables=new HashMap<>();
  final Map<String,List<Column>> columns=new HashMap<>();
  Column column;
  for (  final MatchMetaData match : matches) {
    final StringBuilder sb=new StringBuilder();
    if (match.getSchemaName() != null && !match.getSchemaName().equals(""String_Node_Str"")) {
      sb.append(match.getSchemaName()).append('.').append(match.getTableName());
    }
 else {
      sb.append(match.getTableName());
    }
    final String tableName=sb.toString();
    Table table=tables.get(tableName);
    if (table == null) {
      table=new Table();
      table.setName(tableName);
      final List<String> pks=match.getPkeys();
      if (pks.size() == 1) {
        table.setPkey(pks.get(0));
      }
 else {
        final List<Key> keys=pks.stream().map(pkName -> {
          Key key=new Key();
          key.setName(pkName);
          return key;
        }
).collect(Collectors.toList());
        table.setPrimaryKeys(keys);
      }
      tables.put(tableName,table);
      columns.put(tableName,new ArrayList<>());
    }
    column=new Column();
    column.setName(match.getColumnName());
    column.setReturnType(match.getColumnType());
    addDefaultParam(column);
    columns.get(tableName).add(column);
  }
  for (  final Entry<String,List<Column>> entry : columns.entrySet()) {
    tables.get(entry.getKey()).setColumns(entry.getValue());
  }
  final Requirement req=new Requirement();
  req.setClient(""String_Node_Str"");
  req.setVersion(""String_Node_Str"");
  req.setTables(new ArrayList<>(tables.values()));
  return req;
}","/** 
 * Create a requirement from sorted (by (schema.)table) List of matching columns.
 * @param matches
 * @return
 */
public static Requirement create(final List<MatchMetaData> matches){
  final Map<String,Table> tables=new HashMap<>();
  final Map<String,List<Column>> columns=new HashMap<>();
  Column column;
  for (  final MatchMetaData match : matches) {
    final StringBuilder sb=new StringBuilder();
    if (match.getSchemaName() != null && !match.getSchemaName().equals(""String_Node_Str"")) {
      sb.append(match.getSchemaName()).append('.').append(match.getTableName());
    }
 else {
      sb.append(match.getTableName());
    }
    final String tableName=sb.toString();
    Table table=tables.get(tableName);
    if (table == null) {
      table=new Table();
      table.setName(tableName);
      final List<String> pks=match.getPkeys();
      if (pks.size() == 1) {
        table.setPkey(pks.get(0));
      }
 else {
        final List<Key> keys=pks.stream().map(pkName -> {
          Key key=new Key();
          key.setName(pkName);
          return key;
        }
).collect(Collectors.toList());
        table.setPrimaryKeys(keys);
      }
      tables.put(tableName,table);
      columns.put(tableName,new ArrayList<>());
    }
    column=new Column();
    column.setName(match.getColumnName());
    String columnType=match.getColumnType();
    if (""String_Node_Str"".equals(columnType) || ""String_Node_Str"".equals(columnType)) {
      column.setReturnType(""String_Node_Str"");
    }
 else {
      column.setReturnType(match.getColumnType());
    }
    addDefaultParam(table.getName(),column);
    columns.get(tableName).add(column);
  }
  for (  final Entry<String,List<Column>> entry : columns.entrySet()) {
    tables.get(entry.getKey()).setColumns(entry.getValue());
  }
  final Requirement req=new Requirement();
  req.setClient(""String_Node_Str"");
  req.setVersion(""String_Node_Str"");
  req.setTables(new ArrayList<>(tables.values()));
  return req;
}",0.9415862808145766
85507,"private static void addDefaultParam(final Column column){
  column.setFunction(""String_Node_Str"");
  final List<Parameter> params=new ArrayList<>();
  final Parameter param=new Parameter();
  param.setName(""String_Node_Str"");
  param.setValue(""String_Node_Str"");
  param.setType(""String_Node_Str"");
  params.add(param);
  column.setParameters(params);
}","private static void addDefaultParam(final String table,final Column column){
  column.setFunction(""String_Node_Str"");
  final List<Parameter> params=new ArrayList<>();
  final Parameter param=new Parameter();
  param.setName(""String_Node_Str"");
  param.setValue(table + ""String_Node_Str"" + column.getName()+ ""String_Node_Str"");
  param.setType(column.getReturnType());
  params.add(param);
  column.setParameters(params);
}",0.865979381443299
85508,"public List<MatchMetaData> discover(final IDBFactory factory,final Properties columnProperties,final Set<String> tables) throws DatabaseAnonymizerException {
  log.info(""String_Node_Str"");
  final IMetaData metaData=factory.fetchMetaData();
  final List<MatchMetaData> map=metaData.getMetaData();
  List<MatchMetaData> uniqueMatches=null;
  @SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) final List<String> suspList=new ArrayList(columnProperties.keySet());
  suspList.remove(""String_Node_Str"");
  matches=new ArrayList<>();
  for (  final String suspStr : suspList) {
    final Pattern p=compile(suspStr);
    for (    final MatchMetaData data : map) {
      final String tableName=data.getTableName();
      final String columnName=data.getColumnName();
      if (!tables.isEmpty() && !tables.contains(tableName.toLowerCase(Locale.ENGLISH))) {
        continue;
      }
      if (p.matcher(columnName.toLowerCase(Locale.ENGLISH)).matches()) {
        log.debug(data.toVerboseStr());
        matches.add(data);
      }
    }
  }
  log.info(""String_Node_Str"");
  if (matches != null && !matches.isEmpty()) {
    uniqueMatches=new ArrayList<>(new LinkedHashSet<>(matches));
    log.info(""String_Node_Str"");
    log.info(""String_Node_Str"");
    log.info(""String_Node_Str"");
    uniqueMatches.sort(MatchMetaData.compare());
    final Score score=new Score();
    for (    final MatchMetaData entry : uniqueMatches) {
      final int rowCount=ReportUtil.rowCount(factory,entry.getTableName());
      final List<String> sampleDataList=ReportUtil.sampleData(factory,entry.getTableName(),entry.getColumnName());
      log.info(""String_Node_Str"" + entry);
      log.info(CommonUtils.fixedLengthString('=',entry.toString().length() + 30));
      log.info(""String_Node_Str"" + rowCount);
      log.info(""String_Node_Str"" + score.columnScore(rowCount));
      log.info(""String_Node_Str"");
      log.info(CommonUtils.fixedLengthString('-',11));
      for (      final String sampleData : sampleDataList) {
        log.info(sampleData);
      }
      log.info(""String_Node_Str"");
    }
    log.info(""String_Node_Str"" + score.dataStoreScore());
  }
 else {
    log.info(""String_Node_Str"");
  }
  return uniqueMatches;
}","public List<MatchMetaData> discover(final IDBFactory factory,final Properties columnProperties,final Set<String> tables) throws DatabaseAnonymizerException {
  log.info(""String_Node_Str"");
  final IMetaData metaData=factory.fetchMetaData();
  final List<MatchMetaData> map=metaData.getMetaData();
  List<MatchMetaData> uniqueMatches=null;
  @SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) final List<String> suspList=new ArrayList(columnProperties.keySet());
  suspList.remove(""String_Node_Str"");
  matches=new ArrayList<>();
  for (  final String suspStr : suspList) {
    final Pattern p=compile(suspStr);
    for (    final MatchMetaData data : map) {
      final String tableName=data.getTableName();
      final String columnName=data.getColumnName();
      if (!tables.isEmpty() && !tables.contains(tableName.toLowerCase(Locale.ENGLISH))) {
        continue;
      }
      if (p.matcher(columnName.toLowerCase(Locale.ENGLISH)).matches()) {
        log.debug(data.toVerboseStr());
        matches.add(data);
      }
    }
  }
  log.info(""String_Node_Str"");
  if (matches != null && !matches.isEmpty()) {
    uniqueMatches=new ArrayList<>(new LinkedHashSet<>(matches));
    log.info(""String_Node_Str"");
    log.info(""String_Node_Str"");
    log.info(""String_Node_Str"");
    uniqueMatches.sort(MatchMetaData.compare());
    final Score score=new Score();
    for (    final MatchMetaData entry : uniqueMatches) {
      final int rowCount=ReportUtil.rowCount(factory,entry.getTableName());
      final List<String> sampleDataList=ReportUtil.sampleData(factory,entry.getTableName(),entry.getColumnName());
      log.info(""String_Node_Str"" + entry);
      log.info(CommonUtils.fixedLengthString('=',entry.toString().length() + 30));
      log.info(""String_Node_Str"" + rowCount);
      log.info(""String_Node_Str"" + score.columnScore(rowCount));
      log.info(""String_Node_Str"");
      log.info(CommonUtils.fixedLengthString('-',11));
      for (      final String sampleData : sampleDataList) {
        log.info(sampleData);
      }
      log.info(""String_Node_Str"");
    }
    log.info(""String_Node_Str"" + score.dataStoreScore());
  }
 else {
    log.info(""String_Node_Str"");
  }
  log.info(""String_Node_Str"" + uniqueMatches.toString());
  return uniqueMatches;
}",0.9843958983504236
85509,"@SuppressWarnings(""String_Node_Str"") public static void main(final String[] args) throws ParseException, DataDefenderException, AnonymizerException, IOException, SAXException, TikaException, java.text.ParseException {
  final long startTime=System.currentTimeMillis();
  final ApplicationLock al=new ApplicationLock(""String_Node_Str"");
  if (al.isAppActive()) {
    log.error(""String_Node_Str"");
    System.exit(1);
  }
  log.info(""String_Node_Str"" + Arrays.toString(args));
  final Options options=createOptions();
  final CommandLine line=getCommandLine(options,args);
  @SuppressWarnings(""String_Node_Str"") List<String> unparsedArgs=line.getArgList();
  if (line.hasOption(""String_Node_Str"") || args.length == 0 || unparsedArgs.size() < 1) {
    help(options);
    return;
  }
  if (line.hasOption(""String_Node_Str"")) {
    LogManager.getRootLogger().setLevel(Level.DEBUG);
  }
 else {
    LogManager.getRootLogger().setLevel(Level.INFO);
  }
  final String cmd=unparsedArgs.get(0);
  unparsedArgs=unparsedArgs.subList(1,unparsedArgs.size());
  List errors=new ArrayList();
  if (""String_Node_Str"".equals(cmd)) {
    errors=PropertyCheck.check(cmd,' ');
    if (errors.size() > 0) {
      displayErrors(errors);
      return;
    }
    final String fileDiscoveryPropertyFile=line.getOptionValue('F',""String_Node_Str"");
    final Properties fileDiscoveryProperties=loadProperties(fileDiscoveryPropertyFile);
    final FileDiscoverer discoverer=new FileDiscoverer();
    discoverer.discover(fileDiscoveryProperties);
    return;
  }
  errors=PropertyCheck.checkDtabaseProperties();
  if (errors.size() > 0) {
    displayErrors(errors);
    return;
  }
  final Properties props=loadProperties(line.getOptionValue('P',""String_Node_Str""));
  try (final IDBFactory dbFactory=IDBFactory.get(props)){
switch (cmd) {
case ""String_Node_Str"":
      errors=PropertyCheck.check(cmd,' ');
    if (errors.size() > 0) {
      displayErrors(errors);
      return;
    }
  final String anonymizerPropertyFile=line.getOptionValue('A',""String_Node_Str"");
final Properties anonymizerProperties=loadProperties(anonymizerPropertyFile);
final IAnonymizer anonymizer=new DatabaseAnonymizer();
anonymizer.anonymize(dbFactory,anonymizerProperties,getTableNames(unparsedArgs,anonymizerProperties));
break;
case ""String_Node_Str"":
errors=PropertyCheck.check(cmd,' ');
if (errors.size() > 0) {
displayErrors(errors);
return;
}
final IGenerator generator=new DataGenerator();
final String generatorPropertyFile=line.getOptionValue('A',""String_Node_Str"");
final Properties generatorProperties=loadProperties(generatorPropertyFile);
generator.generate(dbFactory,generatorProperties);
break;
case ""String_Node_Str"":
if (line.hasOption('c')) {
errors=PropertyCheck.check(cmd,'c');
if (errors.size() > 0) {
displayErrors(errors);
return;
}
final String columnPropertyFile=line.getOptionValue('C',""String_Node_Str"");
final Properties columnProperties=loadProperties(columnPropertyFile);
final ColumnDiscoverer discoverer=new ColumnDiscoverer();
discoverer.discover(dbFactory,columnProperties,getTableNames(unparsedArgs,columnProperties));
if (line.hasOption('r')) {
discoverer.createRequirement(line.getOptionValue('R',""String_Node_Str""));
}
}
 else if (line.hasOption('d')) {
errors=PropertyCheck.check(cmd,'d');
if (errors.size() > 0) {
displayErrors(errors);
return;
}
final String datadiscoveryPropertyFile=line.getOptionValue('D',""String_Node_Str"");
final Properties dataDiscoveryProperties=loadProperties(datadiscoveryPropertyFile);
final DatabaseDiscoverer discoverer=new DatabaseDiscoverer();
discoverer.discover(dbFactory,dataDiscoveryProperties,getTableNames(unparsedArgs,dataDiscoveryProperties));
if (line.hasOption('r')) {
discoverer.createRequirement(line.getOptionValue('R',""String_Node_Str""));
}
}
break;
default :
help(options);
break;
}
}
 final long endTime=System.currentTimeMillis();
final NumberFormat formatter=new DecimalFormat(""String_Node_Str"");
log.info(""String_Node_Str"" + formatter.format((endTime - startTime) / 1000d) + ""String_Node_Str"");
log.info(""String_Node_Str"");
}","@SuppressWarnings(""String_Node_Str"") public static void main(final String[] args) throws ParseException, DataDefenderException, AnonymizerException, IOException, SAXException, TikaException, java.text.ParseException {
  final long startTime=System.currentTimeMillis();
  final ApplicationLock al=new ApplicationLock(""String_Node_Str"");
  if (al.isAppActive()) {
    log.error(""String_Node_Str"");
    System.exit(1);
  }
  log.info(""String_Node_Str"" + Arrays.toString(args));
  final Options options=createOptions();
  final CommandLine line=getCommandLine(options,args);
  @SuppressWarnings(""String_Node_Str"") List<String> unparsedArgs=line.getArgList();
  if (line.hasOption(""String_Node_Str"") || args.length == 0 || unparsedArgs.size() < 1) {
    help(options);
    return;
  }
  if (line.hasOption(""String_Node_Str"")) {
    LogManager.getRootLogger().setLevel(Level.DEBUG);
  }
 else {
    LogManager.getRootLogger().setLevel(Level.INFO);
  }
  final String cmd=unparsedArgs.get(0);
  unparsedArgs=unparsedArgs.subList(1,unparsedArgs.size());
  List errors=new ArrayList();
  if (""String_Node_Str"".equals(cmd)) {
    errors=PropertyCheck.check(cmd,' ');
    if (errors.size() > 0) {
      displayErrors(errors);
      return;
    }
    final String fileDiscoveryPropertyFile=line.getOptionValue('F',""String_Node_Str"");
    final Properties fileDiscoveryProperties=loadProperties(fileDiscoveryPropertyFile);
    final FileDiscoverer discoverer=new FileDiscoverer();
    discoverer.discover(fileDiscoveryProperties);
    return;
  }
  errors=PropertyCheck.checkDtabaseProperties();
  if (errors.size() > 0) {
    displayErrors(errors);
    return;
  }
  final Properties props=loadProperties(line.getOptionValue('P',""String_Node_Str""));
  try (final IDBFactory dbFactory=IDBFactory.get(props)){
switch (cmd) {
case ""String_Node_Str"":
      errors=PropertyCheck.check(cmd,' ');
    if (errors.size() > 0) {
      displayErrors(errors);
      return;
    }
  final String anonymizerPropertyFile=line.getOptionValue('A',""String_Node_Str"");
final Properties anonymizerProperties=loadProperties(anonymizerPropertyFile);
final IAnonymizer anonymizer=new DatabaseAnonymizer();
anonymizer.anonymize(dbFactory,anonymizerProperties,getTableNames(unparsedArgs,anonymizerProperties));
break;
case ""String_Node_Str"":
errors=PropertyCheck.check(cmd,' ');
if (errors.size() > 0) {
displayErrors(errors);
return;
}
final IGenerator generator=new DataGenerator();
final String generatorPropertyFile=line.getOptionValue('A',""String_Node_Str"");
final Properties generatorProperties=loadProperties(generatorPropertyFile);
generator.generate(dbFactory,generatorProperties);
break;
case ""String_Node_Str"":
if (line.hasOption('c')) {
errors=PropertyCheck.check(cmd,'c');
if (errors.size() > 0) {
displayErrors(errors);
return;
}
final String columnPropertyFile=line.getOptionValue('C',""String_Node_Str"");
final Properties columnProperties=loadProperties(columnPropertyFile);
final ColumnDiscoverer discoverer=new ColumnDiscoverer();
discoverer.discover(dbFactory,columnProperties,getTableNames(unparsedArgs,columnProperties));
log.info(""String_Node_Str"" + line.getOptionValue('R',""String_Node_Str""));
if (line.hasOption('r')) {
discoverer.createRequirement(line.getOptionValue('R',""String_Node_Str""));
}
}
 else if (line.hasOption('d')) {
errors=PropertyCheck.check(cmd,'d');
if (errors.size() > 0) {
displayErrors(errors);
return;
}
final String datadiscoveryPropertyFile=line.getOptionValue('D',""String_Node_Str"");
final Properties dataDiscoveryProperties=loadProperties(datadiscoveryPropertyFile);
final DatabaseDiscoverer discoverer=new DatabaseDiscoverer();
discoverer.discover(dbFactory,dataDiscoveryProperties,getTableNames(unparsedArgs,dataDiscoveryProperties));
if (line.hasOption('r')) {
discoverer.createRequirement(line.getOptionValue('R',""String_Node_Str""));
}
}
break;
default :
help(options);
break;
}
}
 final long endTime=System.currentTimeMillis();
final NumberFormat formatter=new DecimalFormat(""String_Node_Str"");
log.info(""String_Node_Str"" + formatter.format((endTime - startTime) / 1000d) + ""String_Node_Str"");
log.info(""String_Node_Str"");
}",0.9773391812865496
85510,"@SuppressWarnings(""String_Node_Str"") public List<MatchMetaData> discover(final IDBFactory factory,final Properties dataDiscoveryProperties,final Set<String> tables) throws AnonymizerException, ParseException {
  log.info(""String_Node_Str"");
  final double probabilityThreshold=parseDouble(dataDiscoveryProperties.getProperty(""String_Node_Str""));
  String calculate_score=dataDiscoveryProperties.getProperty(""String_Node_Str"");
  if (CommonUtils.isEmptyString(calculate_score)) {
    calculate_score=""String_Node_Str"";
  }
  log.info(""String_Node_Str"" + probabilityThreshold + ""String_Node_Str"");
  final String models=dataDiscoveryProperties.getProperty(""String_Node_Str"");
  modelList=models.split(""String_Node_Str"");
  log.info(""String_Node_Str"" + Arrays.toString(modelList) + ""String_Node_Str"");
  List<MatchMetaData> finalList=new ArrayList<>();
  for (  final String model : modelList) {
    log.info(""String_Node_Str"");
    log.info(""String_Node_Str"" + model);
    log.info(""String_Node_Str"");
    final Model modelPerson=createModel(dataDiscoveryProperties,model);
    matches=discoverAgainstSingleModel(factory,dataDiscoveryProperties,tables,modelPerson,probabilityThreshold);
    finalList=ListUtils.union(finalList,matches);
  }
  final DecimalFormat decimalFormat=new DecimalFormat(""String_Node_Str"");
  log.info(""String_Node_Str"");
  log.info(String.format(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  final Score score=new Score();
  int highRiskColumns=0;
  int rowCount=0;
  for (  final MatchMetaData data : finalList) {
    if (calculate_score.equals(""String_Node_Str"")) {
      log.debug(""String_Node_Str"");
      rowCount=ReportUtil.rowCount(factory,data.getTableName());
    }
    log.info(""String_Node_Str"" + data.toString());
    log.info(CommonUtils.fixedLengthString('=',data.toString().length() + 30));
    log.info(""String_Node_Str"" + decimalFormat.format(data.getAverageProbability()));
    log.info(""String_Node_Str"" + data.getModel());
    if (calculate_score.equals(""String_Node_Str"")) {
      log.info(""String_Node_Str"" + rowCount);
      log.info(""String_Node_Str"" + score.columnScore(rowCount));
    }
 else {
      log.info(""String_Node_Str"");
      log.info(""String_Node_Str"");
    }
    log.info(""String_Node_Str"");
    log.info(CommonUtils.fixedLengthString('-',11));
    final List<Probability> probabilityList=data.getProbabilityList();
    Collections.sort(probabilityList,Comparator.comparingDouble(Probability::getProbabilityValue).reversed());
    int y=0;
    if (data.getProbabilityList().size() >= 5) {
      y=5;
    }
 else {
      y=data.getProbabilityList().size();
    }
    for (int i=0; i < y; i++) {
      final Probability p=data.getProbabilityList().get(i);
      log.info(p.getSentence() + ""String_Node_Str"" + p.getProbabilityValue());
    }
    log.info(""String_Node_Str"");
    if (calculate_score.equals(""String_Node_Str"")) {
      if (score.columnScore(rowCount).equals(""String_Node_Str"")) {
        highRiskColumns++;
      }
    }
  }
  if (calculate_score.equals(""String_Node_Str"")) {
    log.info(""String_Node_Str"" + score.dataStoreScore());
    log.info(""String_Node_Str"");
    if (finalList != null && finalList.size() > 0) {
      log.info(""String_Node_Str"");
      final int threshold_count=Integer.valueOf(dataDiscoveryProperties.getProperty(""String_Node_Str""));
      if (finalList.size() > threshold_count) {
        log.info(""String_Node_Str"" + finalList.size() + ""String_Node_Str""+ threshold_count+ ""String_Node_Str"");
      }
 else {
        log.info(""String_Node_Str"" + finalList.size() + ""String_Node_Str""+ threshold_count+ ""String_Node_Str"");
      }
      final int threshold_highrisk=Integer.valueOf(dataDiscoveryProperties.getProperty(""String_Node_Str""));
      if (highRiskColumns > threshold_highrisk) {
        log.info(""String_Node_Str"" + highRiskColumns + ""String_Node_Str""+ threshold_highrisk+ ""String_Node_Str"");
      }
 else {
        log.info(""String_Node_Str"" + highRiskColumns + ""String_Node_Str""+ threshold_highrisk+ ""String_Node_Str"");
      }
    }
  }
 else {
    log.info(""String_Node_Str"");
  }
  return matches;
}","@SuppressWarnings(""String_Node_Str"") public List<MatchMetaData> discover(final IDBFactory factory,final Properties dataDiscoveryProperties,final Set<String> tables) throws AnonymizerException, ParseException {
  log.info(""String_Node_Str"");
  final double probabilityThreshold=parseDouble(dataDiscoveryProperties.getProperty(""String_Node_Str""));
  String calculate_score=dataDiscoveryProperties.getProperty(""String_Node_Str"");
  if (CommonUtils.isEmptyString(calculate_score)) {
    calculate_score=""String_Node_Str"";
  }
  log.info(""String_Node_Str"" + probabilityThreshold + ""String_Node_Str"");
  final String models=dataDiscoveryProperties.getProperty(""String_Node_Str"");
  modelList=models.split(""String_Node_Str"");
  log.info(""String_Node_Str"" + Arrays.toString(modelList) + ""String_Node_Str"");
  List<MatchMetaData> finalList=new ArrayList<>();
  for (  final String model : modelList) {
    log.info(""String_Node_Str"");
    log.info(""String_Node_Str"" + model);
    log.info(""String_Node_Str"");
    final Model modelPerson=createModel(dataDiscoveryProperties,model);
    matches=discoverAgainstSingleModel(factory,dataDiscoveryProperties,tables,modelPerson,probabilityThreshold);
    finalList=ListUtils.union(finalList,matches);
  }
  final DecimalFormat decimalFormat=new DecimalFormat(""String_Node_Str"");
  log.info(""String_Node_Str"");
  log.info(String.format(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  final Score score=new Score();
  int highRiskColumns=0;
  int rowCount=0;
  for (  final MatchMetaData data : finalList) {
    if (calculate_score.equals(""String_Node_Str"")) {
      log.debug(""String_Node_Str"");
      rowCount=ReportUtil.rowCount(factory,data.getTableName());
    }
    log.info(""String_Node_Str"" + data.toString());
    log.info(CommonUtils.fixedLengthString('=',data.toString().length() + 30));
    log.info(""String_Node_Str"" + decimalFormat.format(data.getAverageProbability()));
    log.info(""String_Node_Str"" + data.getModel());
    if (calculate_score.equals(""String_Node_Str"")) {
      log.info(""String_Node_Str"" + rowCount);
      log.info(""String_Node_Str"" + score.columnScore(rowCount));
    }
 else {
      log.info(""String_Node_Str"");
      log.info(""String_Node_Str"");
    }
    log.info(""String_Node_Str"");
    log.info(CommonUtils.fixedLengthString('-',11));
    final List<Probability> probabilityList=data.getProbabilityList();
    Collections.sort(probabilityList,Comparator.comparingDouble(Probability::getProbabilityValue).reversed());
    int y=0;
    if (data.getProbabilityList().size() >= 5) {
      y=5;
    }
 else {
      y=data.getProbabilityList().size();
    }
    for (int i=0; i < y; i++) {
      final Probability p=data.getProbabilityList().get(i);
      log.info(p.getSentence() + ""String_Node_Str"" + p.getProbabilityValue());
    }
    log.info(""String_Node_Str"");
    if (calculate_score.equals(""String_Node_Str"")) {
      if (score.columnScore(rowCount).equals(""String_Node_Str"")) {
        highRiskColumns++;
      }
    }
  }
  if (calculate_score.equals(""String_Node_Str"")) {
    log.info(""String_Node_Str"" + score.dataStoreScore());
    log.info(""String_Node_Str"");
    if (finalList != null && finalList.size() > 0) {
      log.info(""String_Node_Str"");
      final int threshold_count=Integer.valueOf(dataDiscoveryProperties.getProperty(""String_Node_Str""));
      if (finalList.size() > threshold_count) {
        log.info(""String_Node_Str"" + finalList.size() + ""String_Node_Str""+ threshold_count+ ""String_Node_Str"");
      }
 else {
        log.info(""String_Node_Str"" + finalList.size() + ""String_Node_Str""+ threshold_count+ ""String_Node_Str"");
      }
      final int threshold_highrisk=Integer.valueOf(dataDiscoveryProperties.getProperty(""String_Node_Str""));
      if (highRiskColumns > threshold_highrisk) {
        log.info(""String_Node_Str"" + highRiskColumns + ""String_Node_Str""+ threshold_highrisk+ ""String_Node_Str"");
      }
 else {
        log.info(""String_Node_Str"" + highRiskColumns + ""String_Node_Str""+ threshold_highrisk+ ""String_Node_Str"");
      }
    }
  }
 else {
    log.info(""String_Node_Str"");
  }
  log.info(""String_Node_Str"" + matches.toString());
  return matches;
}",0.9937917860553964
85511,"private List<MatchMetaData> discoverAgainstSingleModel(final IDBFactory factory,final Properties dataDiscoveryProperties,final Set<String> tables,final Model model,final double probabilityThreshold) throws AnonymizerException, ParseException {
  final IMetaData metaData=factory.fetchMetaData();
  final List<MatchMetaData> map=metaData.getMetaData();
  matches=new ArrayList<>();
  MatchMetaData specialCaseData=null;
  boolean specialCase=false;
  final String extentionList=dataDiscoveryProperties.getProperty(""String_Node_Str"");
  String[] specialCaseFunctions=null;
  if (!CommonUtils.isEmptyString(extentionList)) {
    specialCaseFunctions=extentionList.split(""String_Node_Str"");
    if (specialCaseFunctions != null && specialCaseFunctions.length > 0) {
      specialCase=true;
    }
  }
  final ISQLBuilder sqlBuilder=factory.createSQLBuilder();
  List<Probability> probabilityList;
  for (  final MatchMetaData data : map) {
    final String tableName=data.getTableName();
    final String columnName=data.getColumnName();
    log.debug(data.getColumnType());
    probabilityList=new ArrayList<>();
    log.info(""String_Node_Str"" + tableName + ""String_Node_Str""+ columnName+ ""String_Node_Str"");
    if (!tables.isEmpty() && !tables.contains(tableName.toLowerCase(Locale.ENGLISH))) {
      log.debug(""String_Node_Str"");
      continue;
    }
    final String tableNamePattern=dataDiscoveryProperties.getProperty(""String_Node_Str"");
    if (!CommonUtils.isEmptyString(tableNamePattern)) {
      final Pattern p=compile(tableNamePattern);
      if (!p.matcher(tableName).matches()) {
        continue;
      }
    }
    final String table=sqlBuilder.prefixSchema(tableName);
    final int limit=Integer.parseInt(dataDiscoveryProperties.getProperty(""String_Node_Str""));
    final String query=sqlBuilder.buildSelectWithLimit(""String_Node_Str"" + columnName + ""String_Node_Str""+ ""String_Node_Str""+ table+ ""String_Node_Str""+ columnName+ ""String_Node_Str"",limit);
    log.debug(""String_Node_Str"" + query);
    try (Statement stmt=factory.getConnection().createStatement();ResultSet resultSet=stmt.executeQuery(query)){
      while (resultSet.next()) {
        if (data.getColumnType().equals(""String_Node_Str"") || data.getColumnType().equals(""String_Node_Str"")) {
          continue;
        }
        if (model.getName().equals(""String_Node_Str"") && data.getColumnType().contains(""String_Node_Str"")) {
          continue;
        }
        final String sentence=resultSet.getString(1);
        if (specialCase) {
          try {
            for (int i=0; i < specialCaseFunctions.length; i++) {
              if (sentence != null && !sentence.equals(""String_Node_Str"")) {
                specialCaseData=(MatchMetaData)callExtention(specialCaseFunctions[i],data,sentence);
              }
            }
          }
 catch (          NoSuchMethodException|IllegalAccessException|InvocationTargetException e) {
            log.error(e.toString());
          }
        }
        if (sentence != null && !sentence.isEmpty()) {
          String processingValue=""String_Node_Str"";
          if (data.getColumnType().equals(""String_Node_Str"") || data.getColumnType().equals(""String_Node_Str"") || data.getColumnType().equals(""String_Node_Str"")) {
            final DateFormat originalFormat=new SimpleDateFormat(sentence,Locale.ENGLISH);
            final DateFormat targetFormat=new SimpleDateFormat(""String_Node_Str"",Locale.ENGLISH);
            final java.util.Date date=originalFormat.parse(sentence);
            processingValue=targetFormat.format(date);
          }
 else {
            processingValue=sentence;
          }
          final String tokens[]=model.getTokenizer().tokenize(processingValue);
          final Span nameSpans[]=model.getNameFinder().find(tokens);
          final double[] spanProbs=model.getNameFinder().probs(nameSpans);
          for (int i=0; i < nameSpans.length; i++) {
            final String span=nameSpans[i].toString();
            if (span.length() > 2) {
              log.debug(""String_Node_Str"" + span);
              log.debug(""String_Node_Str"" + tokens[nameSpans[i].getStart()]);
              log.debug(""String_Node_Str"" + spanProbs[i]);
              probabilityList.add(new Probability(tokens[nameSpans[i].getStart()],spanProbs[i]));
            }
          }
          model.getNameFinder().clearAdaptiveData();
        }
      }
    }
 catch (    SQLException sqle) {
      log.error(sqle.toString());
    }
    final double averageProbability=calculateAverage(probabilityList);
    if ((averageProbability >= probabilityThreshold)) {
      data.setAverageProbability(averageProbability);
      data.setModel(model.getName());
      data.setProbabilityList(probabilityList);
      matches.add(data);
    }
    if (specialCase && specialCaseData != null) {
      matches.add(specialCaseData);
      specialCaseData=null;
    }
  }
  return matches;
}","private List<MatchMetaData> discoverAgainstSingleModel(final IDBFactory factory,final Properties dataDiscoveryProperties,final Set<String> tables,final Model model,final double probabilityThreshold) throws AnonymizerException, ParseException {
  final IMetaData metaData=factory.fetchMetaData();
  final List<MatchMetaData> map=metaData.getMetaData();
  matches=new ArrayList<>();
  MatchMetaData specialCaseData=null;
  List<MatchMetaData> specialCaseDataList=new ArrayList();
  boolean specialCase=false;
  final String extentionList=dataDiscoveryProperties.getProperty(""String_Node_Str"");
  String[] specialCaseFunctions=null;
  if (!CommonUtils.isEmptyString(extentionList)) {
    specialCaseFunctions=extentionList.split(""String_Node_Str"");
    if (specialCaseFunctions != null && specialCaseFunctions.length > 0) {
      specialCase=true;
    }
  }
  final ISQLBuilder sqlBuilder=factory.createSQLBuilder();
  List<Probability> probabilityList;
  for (  final MatchMetaData data : map) {
    final String tableName=data.getTableName();
    final String columnName=data.getColumnName();
    log.debug(data.getColumnType());
    probabilityList=new ArrayList<>();
    log.info(""String_Node_Str"" + tableName + ""String_Node_Str""+ columnName+ ""String_Node_Str"");
    if (!tables.isEmpty() && !tables.contains(tableName.toLowerCase(Locale.ENGLISH))) {
      log.debug(""String_Node_Str"");
      continue;
    }
    final String tableNamePattern=dataDiscoveryProperties.getProperty(""String_Node_Str"");
    if (!CommonUtils.isEmptyString(tableNamePattern)) {
      final Pattern p=compile(tableNamePattern);
      if (!p.matcher(tableName).matches()) {
        continue;
      }
    }
    final String table=sqlBuilder.prefixSchema(tableName);
    final int limit=Integer.parseInt(dataDiscoveryProperties.getProperty(""String_Node_Str""));
    final String query=sqlBuilder.buildSelectWithLimit(""String_Node_Str"" + columnName + ""String_Node_Str""+ ""String_Node_Str""+ table+ ""String_Node_Str""+ columnName+ ""String_Node_Str"",limit);
    log.debug(""String_Node_Str"" + query);
    try (Statement stmt=factory.getConnection().createStatement();ResultSet resultSet=stmt.executeQuery(query)){
      while (resultSet.next()) {
        if (data.getColumnType().equals(""String_Node_Str"") || data.getColumnType().equals(""String_Node_Str"")) {
          continue;
        }
        if (model.getName().equals(""String_Node_Str"") && data.getColumnType().contains(""String_Node_Str"")) {
          continue;
        }
        final String sentence=resultSet.getString(1);
        if (specialCase) {
          try {
            for (int i=0; i < specialCaseFunctions.length; i++) {
              if (sentence != null && !sentence.equals(""String_Node_Str"")) {
                specialCaseData=(MatchMetaData)callExtention(specialCaseFunctions[i],data,sentence);
                if (specialCaseData != null) {
                  log.info(""String_Node_Str"" + specialCaseData.toString());
                  specialCaseDataList.add(specialCaseData);
                }
              }
            }
          }
 catch (          NoSuchMethodException|IllegalAccessException|InvocationTargetException e) {
            log.error(e.toString());
          }
        }
        if (sentence != null && !sentence.isEmpty()) {
          String processingValue=""String_Node_Str"";
          if (data.getColumnType().equals(""String_Node_Str"") || data.getColumnType().equals(""String_Node_Str"") || data.getColumnType().equals(""String_Node_Str"")) {
            final DateFormat originalFormat=new SimpleDateFormat(sentence,Locale.ENGLISH);
            final DateFormat targetFormat=new SimpleDateFormat(""String_Node_Str"",Locale.ENGLISH);
            final java.util.Date date=originalFormat.parse(sentence);
            processingValue=targetFormat.format(date);
          }
 else {
            processingValue=sentence;
          }
          final String tokens[]=model.getTokenizer().tokenize(processingValue);
          final Span nameSpans[]=model.getNameFinder().find(tokens);
          final double[] spanProbs=model.getNameFinder().probs(nameSpans);
          for (int i=0; i < nameSpans.length; i++) {
            final String span=nameSpans[i].toString();
            if (span.length() > 2) {
              log.debug(""String_Node_Str"" + span);
              log.debug(""String_Node_Str"" + tokens[nameSpans[i].getStart()]);
              log.debug(""String_Node_Str"" + spanProbs[i]);
              probabilityList.add(new Probability(tokens[nameSpans[i].getStart()],spanProbs[i]));
            }
          }
          model.getNameFinder().clearAdaptiveData();
        }
      }
    }
 catch (    SQLException sqle) {
      log.error(sqle.toString());
    }
    final double averageProbability=calculateAverage(probabilityList);
    if ((averageProbability >= probabilityThreshold)) {
      data.setAverageProbability(averageProbability);
      data.setModel(model.getName());
      data.setProbabilityList(probabilityList);
      matches.add(data);
    }
  }
  if (specialCaseDataList != null && !specialCaseDataList.isEmpty()) {
    log.info(""String_Node_Str"" + specialCaseDataList.toString());
    for (    MatchMetaData specialData : specialCaseDataList) {
      matches.add(specialData);
    }
  }
  return matches;
}",0.9539247470281952
85512,"/** 
 * Generates random 9-digit student number 
 * @param data
 * @param text
 * @return String
 */
public static MatchMetaData isPHITerm(final MatchMetaData data,final String text){
  if (CommonUtils.isEmptyString(text)) {
    return null;
  }
  if (data.getColumnType().equals(""String_Node_Str"") && phiList.contains(text.trim().toUpperCase(Locale.ENGLISH))) {
    log.info(""String_Node_Str"" + text);
    data.setModel(""String_Node_Str"");
    data.setAverageProbability(1);
    return data;
  }
  return null;
}","/** 
 * Generates random 9-digit student number 
 * @param data
 * @param text
 * @return String
 */
public static MatchMetaData isPHITerm(final MatchMetaData data,final String text){
  if (CommonUtils.isEmptyString(text)) {
    return null;
  }
  if (data.getColumnType().equals(""String_Node_Str"") && phiList.contains(text.trim().toLowerCase(Locale.ENGLISH))) {
    log.info(""String_Node_Str"" + text);
    data.setModel(""String_Node_Str"");
    data.setAverageProbability(100);
    List<Probability> probabilityList=new ArrayList();
    probabilityList.add(new Probability(text,1.00));
    data.setProbabilityList(probabilityList);
    return data;
  }
  return null;
}",0.8629441624365483
85513,"@SuppressWarnings(""String_Node_Str"") public List<MatchMetaData> discover(final IDBFactory factory,final Properties dataDiscoveryProperties,final Set<String> tables) throws AnonymizerException, ParseException {
  log.info(""String_Node_Str"");
  final double probabilityThreshold=parseDouble(dataDiscoveryProperties.getProperty(""String_Node_Str""));
  final String calculate_score=dataDiscoveryProperties.getProperty(""String_Node_Str"");
  log.info(""String_Node_Str"" + probabilityThreshold + ""String_Node_Str"");
  final String models=dataDiscoveryProperties.getProperty(""String_Node_Str"");
  modelList=models.split(""String_Node_Str"");
  log.info(""String_Node_Str"" + Arrays.toString(modelList) + ""String_Node_Str"");
  List<MatchMetaData> finalList=new ArrayList<>();
  for (  final String model : modelList) {
    log.info(""String_Node_Str"");
    log.info(""String_Node_Str"" + model);
    log.info(""String_Node_Str"");
    final Model modelPerson=createModel(dataDiscoveryProperties,model);
    matches=discoverAgainstSingleModel(factory,dataDiscoveryProperties,tables,modelPerson,probabilityThreshold);
    finalList=ListUtils.union(finalList,matches);
  }
  final DecimalFormat decimalFormat=new DecimalFormat(""String_Node_Str"");
  log.info(""String_Node_Str"");
  log.info(String.format(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  final Score score=new Score();
  int highRiskColumns=0;
  int rowCount=0;
  for (  final MatchMetaData data : finalList) {
    if (calculate_score.equals(""String_Node_Str"")) {
      log.debug(""String_Node_Str"");
      rowCount=ReportUtil.rowCount(factory,data.getTableName());
    }
    log.info(""String_Node_Str"" + data.toString());
    log.info(CommonUtils.fixedLengthString('=',data.toString().length() + 30));
    log.info(""String_Node_Str"" + decimalFormat.format(data.getAverageProbability()));
    log.info(""String_Node_Str"" + data.getModel());
    if (calculate_score.equals(""String_Node_Str"")) {
      log.info(""String_Node_Str"" + rowCount);
      log.info(""String_Node_Str"" + score.columnScore(rowCount));
    }
 else {
      log.info(""String_Node_Str"");
      log.info(""String_Node_Str"");
    }
    log.info(""String_Node_Str"");
    log.info(CommonUtils.fixedLengthString('-',11));
    final List<Probability> probabilityList=data.getProbabilityList();
    Collections.sort(probabilityList,Comparator.comparingDouble(Probability::getProbabilityValue).reversed());
    int y=0;
    if (data.getProbabilityList().size() >= 5) {
      y=5;
    }
 else {
      y=data.getProbabilityList().size();
    }
    for (int i=0; i < y; i++) {
      final Probability p=data.getProbabilityList().get(i);
      log.info(p.getSentence() + ""String_Node_Str"" + p.getProbabilityValue());
    }
    log.info(""String_Node_Str"");
    if (calculate_score.equals(""String_Node_Str"")) {
      if (score.columnScore(rowCount).equals(""String_Node_Str"")) {
        highRiskColumns++;
      }
    }
  }
  if (calculate_score.equals(""String_Node_Str"")) {
    log.info(""String_Node_Str"" + score.dataStoreScore());
    log.info(""String_Node_Str"");
    if (finalList != null && finalList.size() > 0) {
      log.info(""String_Node_Str"");
      final int threshold_count=Integer.valueOf(dataDiscoveryProperties.getProperty(""String_Node_Str""));
      if (finalList.size() > threshold_count) {
        log.info(""String_Node_Str"" + finalList.size() + ""String_Node_Str""+ threshold_count+ ""String_Node_Str"");
      }
 else {
        log.info(""String_Node_Str"" + finalList.size() + ""String_Node_Str""+ threshold_count+ ""String_Node_Str"");
      }
      final int threshold_highrisk=Integer.valueOf(dataDiscoveryProperties.getProperty(""String_Node_Str""));
      if (highRiskColumns > threshold_highrisk) {
        log.info(""String_Node_Str"" + highRiskColumns + ""String_Node_Str""+ threshold_highrisk+ ""String_Node_Str"");
      }
 else {
        log.info(""String_Node_Str"" + highRiskColumns + ""String_Node_Str""+ threshold_highrisk+ ""String_Node_Str"");
      }
    }
  }
 else {
    log.info(""String_Node_Str"");
  }
  return matches;
}","@SuppressWarnings(""String_Node_Str"") public List<MatchMetaData> discover(final IDBFactory factory,final Properties dataDiscoveryProperties,final Set<String> tables) throws AnonymizerException, ParseException {
  log.info(""String_Node_Str"");
  final double probabilityThreshold=parseDouble(dataDiscoveryProperties.getProperty(""String_Node_Str""));
  String calculate_score=dataDiscoveryProperties.getProperty(""String_Node_Str"");
  if (CommonUtils.isEmptyString(calculate_score)) {
    calculate_score=""String_Node_Str"";
  }
  log.info(""String_Node_Str"" + probabilityThreshold + ""String_Node_Str"");
  final String models=dataDiscoveryProperties.getProperty(""String_Node_Str"");
  modelList=models.split(""String_Node_Str"");
  log.info(""String_Node_Str"" + Arrays.toString(modelList) + ""String_Node_Str"");
  List<MatchMetaData> finalList=new ArrayList<>();
  for (  final String model : modelList) {
    log.info(""String_Node_Str"");
    log.info(""String_Node_Str"" + model);
    log.info(""String_Node_Str"");
    final Model modelPerson=createModel(dataDiscoveryProperties,model);
    matches=discoverAgainstSingleModel(factory,dataDiscoveryProperties,tables,modelPerson,probabilityThreshold);
    finalList=ListUtils.union(finalList,matches);
  }
  final DecimalFormat decimalFormat=new DecimalFormat(""String_Node_Str"");
  log.info(""String_Node_Str"");
  log.info(String.format(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  final Score score=new Score();
  int highRiskColumns=0;
  int rowCount=0;
  for (  final MatchMetaData data : finalList) {
    if (calculate_score.equals(""String_Node_Str"")) {
      log.debug(""String_Node_Str"");
      rowCount=ReportUtil.rowCount(factory,data.getTableName());
    }
    log.info(""String_Node_Str"" + data.toString());
    log.info(CommonUtils.fixedLengthString('=',data.toString().length() + 30));
    log.info(""String_Node_Str"" + decimalFormat.format(data.getAverageProbability()));
    log.info(""String_Node_Str"" + data.getModel());
    if (calculate_score.equals(""String_Node_Str"")) {
      log.info(""String_Node_Str"" + rowCount);
      log.info(""String_Node_Str"" + score.columnScore(rowCount));
    }
 else {
      log.info(""String_Node_Str"");
      log.info(""String_Node_Str"");
    }
    log.info(""String_Node_Str"");
    log.info(CommonUtils.fixedLengthString('-',11));
    final List<Probability> probabilityList=data.getProbabilityList();
    Collections.sort(probabilityList,Comparator.comparingDouble(Probability::getProbabilityValue).reversed());
    int y=0;
    if (data.getProbabilityList().size() >= 5) {
      y=5;
    }
 else {
      y=data.getProbabilityList().size();
    }
    for (int i=0; i < y; i++) {
      final Probability p=data.getProbabilityList().get(i);
      log.info(p.getSentence() + ""String_Node_Str"" + p.getProbabilityValue());
    }
    log.info(""String_Node_Str"");
    if (calculate_score.equals(""String_Node_Str"")) {
      if (score.columnScore(rowCount).equals(""String_Node_Str"")) {
        highRiskColumns++;
      }
    }
  }
  if (calculate_score.equals(""String_Node_Str"")) {
    log.info(""String_Node_Str"" + score.dataStoreScore());
    log.info(""String_Node_Str"");
    if (finalList != null && finalList.size() > 0) {
      log.info(""String_Node_Str"");
      final int threshold_count=Integer.valueOf(dataDiscoveryProperties.getProperty(""String_Node_Str""));
      if (finalList.size() > threshold_count) {
        log.info(""String_Node_Str"" + finalList.size() + ""String_Node_Str""+ threshold_count+ ""String_Node_Str"");
      }
 else {
        log.info(""String_Node_Str"" + finalList.size() + ""String_Node_Str""+ threshold_count+ ""String_Node_Str"");
      }
      final int threshold_highrisk=Integer.valueOf(dataDiscoveryProperties.getProperty(""String_Node_Str""));
      if (highRiskColumns > threshold_highrisk) {
        log.info(""String_Node_Str"" + highRiskColumns + ""String_Node_Str""+ threshold_highrisk+ ""String_Node_Str"");
      }
 else {
        log.info(""String_Node_Str"" + highRiskColumns + ""String_Node_Str""+ threshold_highrisk+ ""String_Node_Str"");
      }
    }
  }
 else {
    log.info(""String_Node_Str"");
  }
  return matches;
}",0.9877352762598663
85514,"private List<MatchMetaData> discoverAgainstSingleModel(final IDBFactory factory,final Properties dataDiscoveryProperties,final Set<String> tables,final Model model,final double probabilityThreshold) throws AnonymizerException, ParseException {
  final IMetaData metaData=factory.fetchMetaData();
  final List<MatchMetaData> map=metaData.getMetaData();
  matches=new ArrayList<>();
  MatchMetaData specialCaseData=null;
  boolean specialCase=false;
  final String[] specialCaseFunctions=dataDiscoveryProperties.getProperty(""String_Node_Str"").split(""String_Node_Str"");
  if (specialCaseFunctions != null && specialCaseFunctions.length > 0) {
    specialCase=true;
  }
  final ISQLBuilder sqlBuilder=factory.createSQLBuilder();
  List<Probability> probabilityList;
  for (  final MatchMetaData data : map) {
    final String tableName=data.getTableName();
    final String columnName=data.getColumnName();
    log.debug(data.getColumnType());
    probabilityList=new ArrayList<>();
    log.info(""String_Node_Str"" + tableName + ""String_Node_Str""+ columnName+ ""String_Node_Str"");
    if (!tables.isEmpty() && !tables.contains(tableName.toLowerCase(Locale.ENGLISH))) {
      log.debug(""String_Node_Str"");
      continue;
    }
    final String tableNamePattern=dataDiscoveryProperties.getProperty(""String_Node_Str"");
    if (!CommonUtils.isEmptyString(tableNamePattern)) {
      final Pattern p=compile(tableNamePattern);
      if (!p.matcher(tableName).matches()) {
        continue;
      }
    }
    final String table=sqlBuilder.prefixSchema(tableName);
    final int limit=Integer.parseInt(dataDiscoveryProperties.getProperty(""String_Node_Str""));
    final String query=sqlBuilder.buildSelectWithLimit(""String_Node_Str"" + columnName + ""String_Node_Str""+ ""String_Node_Str""+ table+ ""String_Node_Str""+ columnName+ ""String_Node_Str"",limit);
    log.info(""String_Node_Str"" + query);
    try (Statement stmt=factory.getConnection().createStatement();ResultSet resultSet=stmt.executeQuery(query)){
      while (resultSet.next()) {
        if (data.getColumnType().equals(""String_Node_Str"") || data.getColumnType().equals(""String_Node_Str"")) {
          continue;
        }
        if (model.getName().equals(""String_Node_Str"") && data.getColumnType().contains(""String_Node_Str"")) {
          continue;
        }
        final String sentence=resultSet.getString(1);
        if (specialCase) {
          try {
            for (int i=0; i < specialCaseFunctions.length; i++) {
              if (sentence != null && !sentence.equals(""String_Node_Str"")) {
                specialCaseData=(MatchMetaData)callExtention(specialCaseFunctions[i],data,sentence);
              }
            }
          }
 catch (          NoSuchMethodException|IllegalAccessException|InvocationTargetException e) {
            log.error(e.toString());
          }
        }
        if (sentence != null && !sentence.isEmpty()) {
          String processingValue=""String_Node_Str"";
          if (data.getColumnType().equals(""String_Node_Str"") || data.getColumnType().equals(""String_Node_Str"") || data.getColumnType().equals(""String_Node_Str"")) {
            final DateFormat originalFormat=new SimpleDateFormat(sentence,Locale.ENGLISH);
            final DateFormat targetFormat=new SimpleDateFormat(""String_Node_Str"",Locale.ENGLISH);
            final java.util.Date date=originalFormat.parse(sentence);
            processingValue=targetFormat.format(date);
          }
 else {
            processingValue=sentence;
          }
          final String tokens[]=model.getTokenizer().tokenize(processingValue);
          final Span nameSpans[]=model.getNameFinder().find(tokens);
          final double[] spanProbs=model.getNameFinder().probs(nameSpans);
          for (int i=0; i < nameSpans.length; i++) {
            log.debug(""String_Node_Str"" + nameSpans[i].toString());
            log.debug(""String_Node_Str"" + tokens[nameSpans[i].getStart()]);
            log.debug(""String_Node_Str"" + spanProbs[i]);
            probabilityList.add(new Probability(tokens[nameSpans[i].getStart()],spanProbs[i]));
          }
          model.getNameFinder().clearAdaptiveData();
        }
      }
    }
 catch (    SQLException sqle) {
      log.error(sqle.toString());
    }
    final double averageProbability=calculateAverage(probabilityList);
    if ((averageProbability >= probabilityThreshold)) {
      data.setAverageProbability(averageProbability);
      data.setModel(model.getName());
      data.setProbabilityList(probabilityList);
      matches.add(data);
    }
    if (specialCase && specialCaseData != null) {
      matches.add(specialCaseData);
      specialCaseData=null;
    }
  }
  return matches;
}","private List<MatchMetaData> discoverAgainstSingleModel(final IDBFactory factory,final Properties dataDiscoveryProperties,final Set<String> tables,final Model model,final double probabilityThreshold) throws AnonymizerException, ParseException {
  final IMetaData metaData=factory.fetchMetaData();
  final List<MatchMetaData> map=metaData.getMetaData();
  matches=new ArrayList<>();
  MatchMetaData specialCaseData=null;
  boolean specialCase=false;
  String extentionList=dataDiscoveryProperties.getProperty(""String_Node_Str"");
  String[] specialCaseFunctions=null;
  if (!CommonUtils.isEmptyString(extentionList)) {
    specialCaseFunctions=extentionList.split(""String_Node_Str"");
    if (specialCaseFunctions != null && specialCaseFunctions.length > 0) {
      specialCase=true;
    }
  }
  final ISQLBuilder sqlBuilder=factory.createSQLBuilder();
  List<Probability> probabilityList;
  for (  final MatchMetaData data : map) {
    final String tableName=data.getTableName();
    final String columnName=data.getColumnName();
    log.debug(data.getColumnType());
    probabilityList=new ArrayList<>();
    log.info(""String_Node_Str"" + tableName + ""String_Node_Str""+ columnName+ ""String_Node_Str"");
    if (!tables.isEmpty() && !tables.contains(tableName.toLowerCase(Locale.ENGLISH))) {
      log.debug(""String_Node_Str"");
      continue;
    }
    final String tableNamePattern=dataDiscoveryProperties.getProperty(""String_Node_Str"");
    if (!CommonUtils.isEmptyString(tableNamePattern)) {
      final Pattern p=compile(tableNamePattern);
      if (!p.matcher(tableName).matches()) {
        continue;
      }
    }
    final String table=sqlBuilder.prefixSchema(tableName);
    final int limit=Integer.parseInt(dataDiscoveryProperties.getProperty(""String_Node_Str""));
    final String query=sqlBuilder.buildSelectWithLimit(""String_Node_Str"" + columnName + ""String_Node_Str""+ ""String_Node_Str""+ table+ ""String_Node_Str""+ columnName+ ""String_Node_Str"",limit);
    log.info(""String_Node_Str"" + query);
    try (Statement stmt=factory.getConnection().createStatement();ResultSet resultSet=stmt.executeQuery(query)){
      while (resultSet.next()) {
        if (data.getColumnType().equals(""String_Node_Str"") || data.getColumnType().equals(""String_Node_Str"")) {
          continue;
        }
        if (model.getName().equals(""String_Node_Str"") && data.getColumnType().contains(""String_Node_Str"")) {
          continue;
        }
        final String sentence=resultSet.getString(1);
        if (specialCase) {
          try {
            for (int i=0; i < specialCaseFunctions.length; i++) {
              if (sentence != null && !sentence.equals(""String_Node_Str"")) {
                specialCaseData=(MatchMetaData)callExtention(specialCaseFunctions[i],data,sentence);
              }
            }
          }
 catch (          NoSuchMethodException|IllegalAccessException|InvocationTargetException e) {
            log.error(e.toString());
          }
        }
        if (sentence != null && !sentence.isEmpty()) {
          String processingValue=""String_Node_Str"";
          if (data.getColumnType().equals(""String_Node_Str"") || data.getColumnType().equals(""String_Node_Str"") || data.getColumnType().equals(""String_Node_Str"")) {
            final DateFormat originalFormat=new SimpleDateFormat(sentence,Locale.ENGLISH);
            final DateFormat targetFormat=new SimpleDateFormat(""String_Node_Str"",Locale.ENGLISH);
            final java.util.Date date=originalFormat.parse(sentence);
            processingValue=targetFormat.format(date);
          }
 else {
            processingValue=sentence;
          }
          final String tokens[]=model.getTokenizer().tokenize(processingValue);
          final Span nameSpans[]=model.getNameFinder().find(tokens);
          final double[] spanProbs=model.getNameFinder().probs(nameSpans);
          for (int i=0; i < nameSpans.length; i++) {
            log.debug(""String_Node_Str"" + nameSpans[i].toString());
            log.debug(""String_Node_Str"" + tokens[nameSpans[i].getStart()]);
            log.debug(""String_Node_Str"" + spanProbs[i]);
            probabilityList.add(new Probability(tokens[nameSpans[i].getStart()],spanProbs[i]));
          }
          model.getNameFinder().clearAdaptiveData();
        }
      }
    }
 catch (    SQLException sqle) {
      log.error(sqle.toString());
    }
    final double averageProbability=calculateAverage(probabilityList);
    if ((averageProbability >= probabilityThreshold)) {
      data.setAverageProbability(averageProbability);
      data.setModel(model.getName());
      data.setProbabilityList(probabilityList);
      matches.add(data);
    }
    if (specialCase && specialCaseData != null) {
      matches.add(specialCaseData);
      specialCaseData=null;
    }
  }
  return matches;
}",0.9689480354879596
85515,"public static int rowCount(final IDBFactory factory,final String tableName){
  final ISQLBuilder sqlBuilder=factory.createSQLBuilder();
  final String table=sqlBuilder.prefixSchema(tableName);
  final String queryCount=sqlBuilder.buildSelectWithLimit(""String_Node_Str"" + ""String_Node_Str"" + table,0);
  log.debug(""String_Node_Str"" + queryCount);
  int rowCount=0;
  try (Statement stmt=factory.getConnection().createStatement();ResultSet resultSet=stmt.executeQuery(queryCount)){
    resultSet.next();
    rowCount=resultSet.getInt(1);
  }
 catch (  SQLException sqle) {
    log.error(sqle.toString());
  }
  return rowCount;
}","public static int rowCount(final IDBFactory factory,final String tableName){
  final ISQLBuilder sqlBuilder=factory.createSQLBuilder();
  final int limit=100;
  final String table=sqlBuilder.prefixSchema(tableName);
  final String queryCount=sqlBuilder.buildSelectWithLimit(""String_Node_Str"" + ""String_Node_Str"" + table,limit);
  log.debug(""String_Node_Str"" + queryCount);
  int rowCount=0;
  try (Statement stmt=factory.getConnection().createStatement();ResultSet resultSet=stmt.executeQuery(queryCount)){
    resultSet.next();
    rowCount=resultSet.getInt(1);
  }
 catch (  SQLException sqle) {
    log.error(sqle.toString());
  }
  return rowCount;
}",0.9773614363778298
85516,"/** 
 * Creates the SELECT query for key and update columns.
 * @param tableName
 * @param keys
 * @param columns
 * @return 
 */
private PreparedStatement getSelectQueryStatement(final IDBFactory dbFactory,final Table table,final Collection<String> keys,final Collection<String> columns) throws SQLException {
  final List<String> params=new LinkedList<>();
  final StringBuilder query=new StringBuilder(""String_Node_Str"");
  query.append(StringUtils.join(keys,""String_Node_Str"")).append(""String_Node_Str"").append(StringUtils.join(columns,""String_Node_Str"")).append(""String_Node_Str"").append(table.getName());
  final List<Exclude> exclusions=table.getExclusions();
  if (exclusions != null) {
    String separator=""String_Node_Str"";
    for (    final Exclude exc : exclusions) {
      final String eq=exc.getEqualsValue();
      final String lk=exc.getLikeValue();
      final boolean nl=exc.isExcludeNulls();
      final String col=exc.getName();
      if (col != null && col.length() != 0) {
        if (eq != null) {
          query.append(separator).append(""String_Node_Str"").append(col).append(""String_Node_Str"").append(col).append(""String_Node_Str"");
          params.add(eq);
          separator=""String_Node_Str"";
        }
        if (lk != null && lk.length() != 0) {
          query.append(separator).append(""String_Node_Str"").append(col).append(""String_Node_Str"").append(col).append(""String_Node_Str"");
          params.add(lk);
          separator=""String_Node_Str"";
        }
        if (nl) {
          query.append(separator).append(col).append(""String_Node_Str"");
          separator=""String_Node_Str"";
        }
      }
    }
    if (query.indexOf(""String_Node_Str"") != -1) {
      separator=""String_Node_Str"";
    }
    for (    final Exclude exc : exclusions) {
      final String neq=exc.getNotEqualsValue();
      final String nlk=exc.getNotLikeValue();
      final String col=exc.getName();
      if (neq != null) {
        query.append(separator).append(col).append(""String_Node_Str"");
        separator=""String_Node_Str"";
      }
      if (nlk != null && nlk.length() != 0) {
        query.append(separator).append(col).append(""String_Node_Str"");
        separator=""String_Node_Str"";
      }
    }
    if (query.indexOf(""String_Node_Str"") != -1) {
      query.append(""String_Node_Str"");
    }
  }
  final PreparedStatement stmt=dbFactory.getConnection().prepareStatement(query.toString());
  if (dbFactory.getVendorName().equalsIgnoreCase(""String_Node_Str"")) {
    stmt.setFetchSize(Integer.MIN_VALUE);
  }
  int paramIndex=1;
  for (  String param : params) {
    stmt.setString(paramIndex,param);
    ++paramIndex;
  }
  log.debug(""String_Node_Str"" + query.toString());
  if (params.size() > 0) {
    log.debug(""String_Node_Str"" + StringUtils.join(params,','));
  }
  return stmt;
}","/** 
 * Creates the SELECT query for key and update columns.
 * @param tableName
 * @param keys
 * @param columns
 * @return 
 */
private PreparedStatement getSelectQueryStatement(final IDBFactory dbFactory,final Table table,final Collection<String> keys,final Collection<String> columns) throws SQLException {
  final List<String> params=new LinkedList<>();
  final StringBuilder query=new StringBuilder(""String_Node_Str"");
  query.append(StringUtils.join(keys,""String_Node_Str"")).append(""String_Node_Str"").append(StringUtils.join(columns,""String_Node_Str"")).append(""String_Node_Str"").append(table.getName());
  final List<Exclude> exclusions=table.getExclusions();
  if (exclusions != null) {
    String separator=""String_Node_Str"";
    for (    final Exclude exc : exclusions) {
      final String eq=exc.getEqualsValue();
      final String lk=exc.getLikeValue();
      final boolean nl=exc.isExcludeNulls();
      final String col=exc.getName();
      if (col != null && col.length() != 0) {
        if (eq != null) {
          query.append(separator).append(""String_Node_Str"").append(col).append(""String_Node_Str"").append(col).append(""String_Node_Str"");
          params.add(eq);
          separator=""String_Node_Str"";
        }
        if (lk != null && lk.length() != 0) {
          query.append(separator).append(""String_Node_Str"").append(col).append(""String_Node_Str"").append(col).append(""String_Node_Str"");
          params.add(lk);
          separator=""String_Node_Str"";
        }
        if (nl) {
          query.append(separator).append(col).append(""String_Node_Str"");
          separator=""String_Node_Str"";
        }
      }
    }
    if (query.indexOf(""String_Node_Str"") != -1) {
      separator=""String_Node_Str"";
    }
    for (    final Exclude exc : exclusions) {
      final String neq=exc.getNotEqualsValue();
      final String nlk=exc.getNotLikeValue();
      final String col=exc.getName();
      if (neq != null) {
        query.append(separator).append(col).append(""String_Node_Str"");
        separator=""String_Node_Str"";
      }
      if (nlk != null && nlk.length() != 0) {
        query.append(separator).append(col).append(""String_Node_Str"");
        separator=""String_Node_Str"";
      }
    }
    if (query.indexOf(""String_Node_Str"") != -1) {
      query.append(""String_Node_Str"");
    }
  }
  final PreparedStatement stmt=dbFactory.getConnection().prepareStatement(query.toString(),ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_UPDATABLE);
  if (dbFactory.getVendorName().equalsIgnoreCase(""String_Node_Str"")) {
    stmt.setFetchSize(Integer.MIN_VALUE);
  }
  int paramIndex=1;
  for (  String param : params) {
    stmt.setString(paramIndex,param);
    ++paramIndex;
  }
  log.debug(""String_Node_Str"" + query.toString());
  if (params.size() > 0) {
    log.debug(""String_Node_Str"" + StringUtils.join(params,','));
  }
  return stmt;
}",0.9903151963373832
85517,"/** 
 * Calls the anonymization function for the given Column, and returns its anonymized value.
 * @param dbConn
 * @param row
 * @param column
 * @return
 * @throws NoSuchMethodException
 * @throws SecurityException
 * @throws IllegalAccessException
 * @throws IllegalArgumentException
 * @throws InvocationTargetException 
 */
private Object callAnonymizingFunctionWithoutParameters(final Connection dbConn,final Column column) throws SQLException, NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
  final String function=column.getFunction();
  if (function == null || function.equals(""String_Node_Str"")) {
    log.warn(""String_Node_Str"" + column + ""String_Node_Str"");
    return ""String_Node_Str"";
  }
  try {
    final String className=Utils.getClassName(function);
    final String methodName=Utils.getMethodName(function);
    final Class<?> clazz=Class.forName(className);
    final CoreFunctions instance=(CoreFunctions)Class.forName(className).newInstance();
    instance.setDatabaseConnection(dbConn);
    final Method[] methods=clazz.getMethods();
    Method selectedMethod=null;
    Object returnType=null;
    methodLoop:     for (    final Method m : methods) {
      if (m.getName().equals(methodName)) {
        log.debug(""String_Node_Str"" + m.getName());
        selectedMethod=m;
        returnType=m.getReturnType();
        break;
      }
    }
    if (selectedMethod == null) {
      final StringBuilder s=new StringBuilder(""String_Node_Str"");
      s.append(methodName).append(""String_Node_Str"").append(className);
      throw new NoSuchMethodException(s.toString());
    }
    log.debug(""String_Node_Str"" + methodName);
    final Object anonymizedValue=selectedMethod.invoke(instance);
    if (anonymizedValue == null) {
      return null;
    }
    if (returnType == String.class) {
      return anonymizedValue.toString();
    }
 else     if (returnType == java.sql.Date.class) {
      return anonymizedValue;
    }
  }
 catch (  AnonymizerException|InstantiationException|ClassNotFoundException ex) {
    log.error(ex.toString());
  }
  return ""String_Node_Str"";
}","/** 
 * Calls the anonymization function for the given Column, and returns its anonymized value.
 * @param dbConn
 * @param row
 * @param column
 * @return
 * @throws NoSuchMethodException
 * @throws SecurityException
 * @throws IllegalAccessException
 * @throws IllegalArgumentException
 * @throws InvocationTargetException 
 */
private Object callAnonymizingFunctionWithoutParameters(final Connection dbConn,final Column column) throws SQLException, NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
  final String function=column.getFunction();
  if (function == null || function.equals(""String_Node_Str"")) {
    log.warn(""String_Node_Str"" + column + ""String_Node_Str"");
    return ""String_Node_Str"";
  }
  try {
    final String className=Utils.getClassName(function);
    final String methodName=Utils.getMethodName(function);
    final Class<?> clazz=Class.forName(className);
    final CoreFunctions instance=(CoreFunctions)Class.forName(className).newInstance();
    instance.setDatabaseConnection(dbConn);
    final Method[] methods=clazz.getMethods();
    Method selectedMethod=null;
    Object returnType=null;
    methodLoop:     for (    final Method m : methods) {
      if (m.getName().equals(methodName)) {
        log.debug(""String_Node_Str"" + m.getName());
        selectedMethod=m;
        returnType=m.getReturnType();
        break;
      }
    }
    if (selectedMethod == null) {
      final StringBuilder s=new StringBuilder(""String_Node_Str"");
      s.append(methodName).append(""String_Node_Str"").append(className);
      throw new NoSuchMethodException(s.toString());
    }
    log.debug(""String_Node_Str"" + methodName);
    final Object anonymizedValue=selectedMethod.invoke(instance);
    log.info(""String_Node_Str"" + anonymizedValue);
    if (anonymizedValue == null) {
      return null;
    }
    log.info(returnType.toString());
    if (returnType == String.class) {
      return anonymizedValue.toString();
    }
 else     if (returnType == java.sql.Date.class) {
      return anonymizedValue;
    }
 else     if (returnType.toString().equals(""String_Node_Str"")) {
      return anonymizedValue;
    }
  }
 catch (  AnonymizerException|InstantiationException|ClassNotFoundException ex) {
    log.error(ex.toString());
  }
  return ""String_Node_Str"";
}",0.956810631229236
85518,"/** 
 * Creates the UPDATE query for a single row of results.
 * @param table
 * @param columns
 * @param keys
 * @param updatableKeys
 * @return the SQL statement
 */
private String getUpdateQuery(final Table table,final Collection<String> updateColumns,final Collection<String> keys){
  final StringBuilder sql=new StringBuilder();
  sql.append(""String_Node_Str"").append(table.getName()).append(""String_Node_Str"").append(StringUtils.join(updateColumns,""String_Node_Str"")).append(""String_Node_Str"").append(""String_Node_Str"").append(StringUtils.join(keys,""String_Node_Str"")).append(""String_Node_Str"");
  return sql.toString();
}","/** 
 * Creates the UPDATE query for a single row of results.
 * @param table
 * @param columns
 * @param keys
 * @param updatableKeys
 * @return the SQL statement
 */
private String getUpdateQuery(final Table table,final Collection<String> updateColumns,final Collection<String> keys){
  final StringBuilder sql=new StringBuilder();
  sql.append(""String_Node_Str"").append(table.getName()).append(""String_Node_Str"").append(StringUtils.join(updateColumns,""String_Node_Str"")).append(""String_Node_Str"").append(""String_Node_Str"").append(StringUtils.join(keys,""String_Node_Str"")).append(""String_Node_Str"");
  log.info(sql.toString());
  return sql.toString();
}",0.9672897196261684
85519,"/** 
 * Anonymizes a row of columns. Sets query parameters on the passed updateStmt - this includes the key values - and calls anonymization functions for the columns.
 * @param updateStmt
 * @param tableColumns
 * @param keyNames
 * @param db
 * @param row
 * @param columnMetaData
 * @throws SQLException
 * @throws NoSuchMethodException
 * @throws SecurityException
 * @throws IllegalAccessException
 * @throws IllegalArgumentException
 * @throws InvocationTargetException 
 */
private void anonymizeRow(final PreparedStatement updateStmt,final Collection<Column> tableColumns,final Collection<String> keyNames,final Connection db,final ResultSet row,final List<MatchMetaData> columnMetaData) throws SQLException, NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, AnonymizerException {
  int fieldIndex=0;
  final Map<String,Integer> columnIndexes=new HashMap<>(tableColumns.size());
  final Set<String> anonymized=new HashSet<>(tableColumns.size());
  for (  final Column column : tableColumns) {
    final String columnName=column.getName();
    if (anonymized.contains(columnName)) {
      continue;
    }
    if (!columnIndexes.containsKey(columnName)) {
      final int columnIndex=++fieldIndex;
      columnIndexes.put(columnName,columnIndex);
    }
    if (isExcludedColumn(row,column)) {
      final String columnValue=row.getString(columnName);
      updateStmt.setString(columnIndexes.get(columnName),columnValue);
      log.debug(""String_Node_Str"" + columnName + ""String_Node_Str""+ columnValue);
      continue;
    }
    anonymized.add(columnName);
    final Object colValue=callAnonymizingFunctionFor(db,row,column);
    if (colValue == null) {
      updateStmt.setNull(columnIndexes.get(columnName),Types.NULL);
    }
 else     if (colValue.getClass() == java.sql.Date.class) {
      updateStmt.setDate(columnIndexes.get(columnName),CommonUtils.stringToDate(colValue.toString(),""String_Node_Str""));
    }
 else {
      updateStmt.setString(columnIndexes.get(columnName),getTruncatedColumnValue((String)colValue,columnIndexes.get(columnName),columnMetaData));
    }
  }
  int whereIndex=fieldIndex;
  for (  final String key : keyNames) {
    updateStmt.setString(++whereIndex,row.getString(key));
  }
  updateStmt.addBatch();
}","/** 
 * Anonymizes a row of columns. Sets query parameters on the passed updateStmt - this includes the key values - and calls anonymization functions for the columns.
 * @param updateStmt
 * @param tableColumns
 * @param keyNames
 * @param db
 * @param row
 * @param columnMetaData
 * @throws SQLException
 * @throws NoSuchMethodException
 * @throws SecurityException
 * @throws IllegalAccessException
 * @throws IllegalArgumentException
 * @throws InvocationTargetException 
 */
private void anonymizeRow(final PreparedStatement updateStmt,final Collection<Column> tableColumns,final Collection<String> keyNames,final Connection db,final ResultSet row,final List<MatchMetaData> columnMetaData) throws SQLException, NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, AnonymizerException {
  int fieldIndex=0;
  final Map<String,Integer> columnIndexes=new HashMap<>(tableColumns.size());
  final Set<String> anonymized=new HashSet<>(tableColumns.size());
  for (  final Column column : tableColumns) {
    final String columnName=column.getName();
    if (anonymized.contains(columnName)) {
      continue;
    }
    if (!columnIndexes.containsKey(columnName)) {
      final int columnIndex=++fieldIndex;
      columnIndexes.put(columnName,columnIndex);
    }
    if (isExcludedColumn(row,column)) {
      final String columnValue=row.getString(columnName);
      updateStmt.setString(columnIndexes.get(columnName),columnValue);
      log.debug(""String_Node_Str"" + columnName + ""String_Node_Str""+ columnValue);
      continue;
    }
    anonymized.add(columnName);
    final Object colValue=callAnonymizingFunctionFor(db,row,column);
    log.info(""String_Node_Str"" + colValue);
    log.info(""String_Node_Str"" + colValue.getClass());
    if (colValue == null) {
      updateStmt.setNull(columnIndexes.get(columnName),Types.NULL);
    }
 else     if (colValue.getClass() == java.sql.Date.class) {
      updateStmt.setDate(columnIndexes.get(columnName),CommonUtils.stringToDate(colValue.toString(),""String_Node_Str""));
    }
 else     if (colValue.getClass() == java.lang.Integer.class) {
      updateStmt.setInt(columnIndexes.get(columnName),(int)colValue);
    }
 else {
      updateStmt.setString(columnIndexes.get(columnName),getTruncatedColumnValue((String)colValue,columnIndexes.get(columnName),columnMetaData));
    }
  }
  int whereIndex=fieldIndex;
  for (  final String key : keyNames) {
    updateStmt.setString(++whereIndex,row.getString(key));
  }
  updateStmt.addBatch();
}",0.9508735868448098
85520,"/** 
 * Anonymization function for a single table. Sets up queries, loops over columns and anonymizes columns for the passed Table.
 * @param table 
 */
private void anonymizeTable(final int batchSize,final IDBFactory dbFactory,final Table table) throws AnonymizerException {
  log.info(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
  final List<Column> tableColumns=table.getColumns();
  final Set<String> colNames=new LinkedHashSet<>(tableColumns.size());
  final List<String> keyNames=new LinkedList<>();
  fillColumnNames(table,colNames);
  fillPrimaryKeyNamesList(table,keyNames);
  PreparedStatement selectStmt=null;
  PreparedStatement updateStmt=null;
  ResultSet rs=null;
  final Connection updateCon=dbFactory.getUpdateConnection();
  try {
    selectStmt=getSelectQueryStatement(dbFactory,table,keyNames,colNames);
    rs=selectStmt.executeQuery();
    final List<MatchMetaData> columnMetaData=dbFactory.fetchMetaData().getMetaDataForRs(rs);
    final String updateString=getUpdateQuery(table,colNames,keyNames);
    updateStmt=updateCon.prepareStatement(updateString);
    log.debug(""String_Node_Str"" + updateString);
    int batchCounter=0;
    int rowCount=0;
    while (rs.next()) {
      anonymizeRow(updateStmt,tableColumns,keyNames,updateCon,rs,columnMetaData);
      batchCounter++;
      if (batchCounter == batchSize) {
        updateStmt.executeBatch();
        updateCon.commit();
        batchCounter=0;
      }
      rowCount++;
    }
    log.debug(""String_Node_Str"" + rowCount);
    updateStmt.executeBatch();
    updateCon.commit();
    selectStmt.close();
    updateStmt.close();
    rs.close();
  }
 catch (  SQLException|NoSuchMethodException|SecurityException|IllegalAccessException|IllegalArgumentException|InvocationTargetException ex) {
    log.error(ex.toString());
    if (ex.getCause() != null) {
      log.error(ex.getCause().toString());
    }
    try {
      if (selectStmt != null) {
        selectStmt.close();
      }
      if (updateStmt != null) {
        updateStmt.close();
      }
      if (rs != null) {
        rs.close();
      }
    }
 catch (    SQLException sqlex) {
      log.error(sqlex.toString());
    }
  }
  log.info(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
  log.info(""String_Node_Str"");
}","/** 
 * Anonymization function for a single table. Sets up queries, loops over columns and anonymizes columns for the passed Table.
 * @param table 
 */
private void anonymizeTable(final int batchSize,final IDBFactory dbFactory,final Table table) throws AnonymizerException {
  log.info(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
  final List<Column> tableColumns=table.getColumns();
  final Set<String> colNames=new LinkedHashSet<>(tableColumns.size());
  final List<String> keyNames=new LinkedList<>();
  fillColumnNames(table,colNames);
  fillPrimaryKeyNamesList(table,keyNames);
  PreparedStatement selectStmt=null;
  PreparedStatement updateStmt=null;
  ResultSet rs=null;
  final Connection updateCon=dbFactory.getUpdateConnection();
  try {
    selectStmt=getSelectQueryStatement(dbFactory,table,keyNames,colNames);
    rs=selectStmt.executeQuery();
    final List<MatchMetaData> columnMetaData=dbFactory.fetchMetaData().getMetaDataForRs(rs);
    final String updateString=getUpdateQuery(table,colNames,keyNames);
    updateStmt=updateCon.prepareStatement(updateString);
    int batchCounter=0;
    int rowCount=0;
    while (rs.next()) {
      anonymizeRow(updateStmt,tableColumns,keyNames,updateCon,rs,columnMetaData);
      batchCounter++;
      if (batchCounter == batchSize) {
        updateStmt.executeBatch();
        updateCon.commit();
        batchCounter=0;
      }
      rowCount++;
    }
    log.debug(""String_Node_Str"" + rowCount);
    updateStmt.executeBatch();
    updateCon.commit();
    selectStmt.close();
    updateStmt.close();
    rs.close();
  }
 catch (  SQLException|NoSuchMethodException|SecurityException|IllegalAccessException|IllegalArgumentException|InvocationTargetException ex) {
    log.error(ex.toString());
    if (ex.getCause() != null) {
      log.error(ex.getCause().toString());
    }
    try {
      if (selectStmt != null) {
        selectStmt.close();
      }
      if (updateStmt != null) {
        updateStmt.close();
      }
      if (rs != null) {
        rs.close();
      }
    }
 catch (    SQLException sqlex) {
      log.error(sqlex.toString());
    }
  }
  log.info(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
  log.info(""String_Node_Str"");
}",0.9891328454202706
85521,"private List<FileMatchMetaData> discoverAgainstSingleModel(final Properties fileDiscoveryProperties,final Model model,final double probabilityThreshold) throws AnonymizerException, IOException, SAXException, TikaException {
  fileMatches=new ArrayList<>();
  String[] directoryList=null;
  final String directories=fileDiscoveryProperties.getProperty(""String_Node_Str"");
  directoryList=directories.split(""String_Node_Str"");
  File node;
  Metadata metadata;
  List<Double> probabilityList;
  for (  final String directory : directoryList) {
    node=new File(directory);
    if (node.isDirectory()) {
      final String[] files=node.list();
      for (      final String file : files) {
        log.info(""String_Node_Str"" + directory + ""String_Node_Str""+ file);
        final BodyContentHandler handler=new BodyContentHandler();
        final AutoDetectParser parser=new AutoDetectParser();
        metadata=new Metadata();
        String handlerString=""String_Node_Str"";
        try (InputStream stream=new FileInputStream(directory + ""String_Node_Str"" + file)){
          if (stream != null) {
            parser.parse(stream,handler,metadata);
            handlerString=handler.toString();
          }
        }
         log.info(""String_Node_Str"" + handlerString);
        final String tokens[]=model.getTokenizer().tokenize(handler.toString());
        final Span nameSpans[]=model.getNameFinder().find(tokens);
        final double[] spanProbs=model.getNameFinder().probs(nameSpans);
        probabilityList=new ArrayList<>();
        for (int i=0; i < nameSpans.length; i++) {
          log.info(""String_Node_Str"" + nameSpans[i].toString());
          log.info(""String_Node_Str"" + tokens[nameSpans[i].getStart()]);
          log.info(""String_Node_Str"" + spanProbs[i]);
          probabilityList.add(spanProbs[i]);
        }
        model.getNameFinder().clearAdaptiveData();
        final double averageProbability=calculateAverage(probabilityList);
        if ((averageProbability >= probabilityThreshold)) {
          final FileMatchMetaData result=new FileMatchMetaData(directory,file);
          result.setAverageProbability(averageProbability);
          result.setModel(model.getName());
          fileMatches.add(result);
        }
      }
    }
  }
  return fileMatches;
}","private List<FileMatchMetaData> discoverAgainstSingleModel(final Properties fileDiscoveryProperties,final Model model,final double probabilityThreshold) throws AnonymizerException, IOException, SAXException, TikaException {
  fileMatches=new ArrayList<>();
  String[] directoryList=null;
  final String directories=fileDiscoveryProperties.getProperty(""String_Node_Str"");
  directoryList=directories.split(""String_Node_Str"");
  File node;
  Metadata metadata;
  List<Double> probabilityList;
  for (  final String directory : directoryList) {
    node=new File(directory);
    if (node.isDirectory()) {
      final String[] files=node.list();
      for (      final String file : files) {
        log.info(""String_Node_Str"" + directory + ""String_Node_Str""+ file);
        final BodyContentHandler handler=new BodyContentHandler();
        final AutoDetectParser parser=new AutoDetectParser();
        metadata=new Metadata();
        String handlerString=""String_Node_Str"";
        try (InputStream stream=new FileInputStream(directory + ""String_Node_Str"" + file)){
          if (stream != null) {
            parser.parse(stream,handler,metadata);
            handlerString=handler.toString();
          }
        }
         log.debug(""String_Node_Str"" + handlerString);
        final String tokens[]=model.getTokenizer().tokenize(handler.toString());
        final Span nameSpans[]=model.getNameFinder().find(tokens);
        final double[] spanProbs=model.getNameFinder().probs(nameSpans);
        probabilityList=new ArrayList<>();
        for (int i=0; i < nameSpans.length; i++) {
          log.info(""String_Node_Str"" + nameSpans[i].toString());
          log.info(""String_Node_Str"" + tokens[nameSpans[i].getStart()]);
          log.info(""String_Node_Str"" + spanProbs[i]);
          probabilityList.add(spanProbs[i]);
        }
        model.getNameFinder().clearAdaptiveData();
        final double averageProbability=calculateAverage(probabilityList);
        if ((averageProbability >= probabilityThreshold)) {
          final FileMatchMetaData result=new FileMatchMetaData(directory,file);
          result.setAverageProbability(averageProbability);
          result.setModel(model.getName());
          fileMatches.add(result);
        }
      }
    }
  }
  return fileMatches;
}",0.9980336464933364
85522,"@Override public List<MatchMetaData> getMetaData(){
  List<MatchMetaData> map=new ArrayList<>();
  try {
    DatabaseMetaData md=connection.getMetaData();
    String schemaName=databaseProperties.getProperty(""String_Node_Str"");
    String skipEmptyTables=databaseProperties.getProperty(""String_Node_Str"");
    List<String> excludeTablesList=new ArrayList<>();
    String excludeTables=databaseProperties.getProperty(""String_Node_Str"");
    if (excludeTables != null && !""String_Node_Str"".equals(excludeTables)) {
      String[] tempArr=excludeTables.split(""String_Node_Str"");
      excludeTablesList=Arrays.asList(tempArr);
    }
    log.info(""String_Node_Str"" + schemaName);
    try (ResultSet tableRS=getTableRS(md)){
      while (tableRS.next()) {
        String tableName=tableRS.getString(3);
        log.debug(tableName);
        if (excludeTablesList.contains(tableName)) {
          log.info(""String_Node_Str"" + tableName);
          continue;
        }
        if ((skipEmptyTables != null && skipEmptyTables.equals(""String_Node_Str"")) && (getRowNumber(tableName) == 0)) {
          log.info(""String_Node_Str"" + tableName);
          continue;
        }
        log.info(""String_Node_Str"" + tableName);
        List<String> pkeys=new ArrayList<>();
        try (ResultSet pkRS=getPKRS(md,tableName)){
          while (pkRS.next()) {
            String pkey=pkRS.getString(4);
            log.debug(""String_Node_Str"" + pkey);
            pkeys.add(pkey);
          }
        }
         try (ResultSet columnRS=getColumnRS(md,tableName)){
          while (columnRS.next()) {
            String columnName=getColumnName(columnRS);
            String colType=getColumnType(columnRS);
            map.add(new MatchMetaData(schemaName,tableName,pkeys,columnName,colType));
          }
        }
       }
    }
   }
 catch (  SQLException e) {
    log.error(e.toString());
  }
  return map;
}","@Override public List<MatchMetaData> getMetaData(){
  List<MatchMetaData> map=new ArrayList<>();
  try {
    DatabaseMetaData md=connection.getMetaData();
    String schemaName=databaseProperties.getProperty(""String_Node_Str"");
    String skipEmptyTables=databaseProperties.getProperty(""String_Node_Str"");
    List<String> excludeTablesList=new ArrayList<>();
    String excludeTables=databaseProperties.getProperty(""String_Node_Str"");
    if (excludeTables != null && !""String_Node_Str"".equals(excludeTables)) {
      String[] tempArr=excludeTables.split(""String_Node_Str"");
      excludeTablesList=Arrays.asList(tempArr);
    }
    log.info(""String_Node_Str"" + schemaName);
    try (ResultSet tableRS=getTableRS(md)){
      while (tableRS.next()) {
        String tableName=tableRS.getString(3);
        log.debug(tableName);
        if (excludeTablesList.contains(tableName)) {
          log.info(""String_Node_Str"" + tableName);
          continue;
        }
        String schemaTableName=null;
        if (schemaName != null && !schemaName.equals(""String_Node_Str"")) {
          schemaTableName=schemaName + ""String_Node_Str"" + tableName;
        }
        if ((skipEmptyTables != null && skipEmptyTables.equals(""String_Node_Str"")) && (getRowNumber(schemaTableName) == 0)) {
          log.info(""String_Node_Str"" + tableName);
          continue;
        }
        log.info(""String_Node_Str"" + tableName);
        List<String> pkeys=new ArrayList<>();
        try (ResultSet pkRS=getPKRS(md,tableName)){
          while (pkRS.next()) {
            String pkey=pkRS.getString(4);
            log.debug(""String_Node_Str"" + pkey);
            pkeys.add(pkey);
          }
        }
         try (ResultSet columnRS=getColumnRS(md,tableName)){
          while (columnRS.next()) {
            String columnName=getColumnName(columnRS);
            String colType=getColumnType(columnRS);
            map.add(new MatchMetaData(schemaName,tableName,pkeys,columnName,colType));
          }
        }
       }
    }
   }
 catch (  SQLException e) {
    log.error(e.toString());
  }
  return map;
}",0.9282488710486704
85523,"@Override protected ResultSet getTableRS(DatabaseMetaData md) throws SQLException {
  return md.getTables(null,null,""String_Node_Str"",null);
}","@Override protected ResultSet getTableRS(DatabaseMetaData md) throws SQLException {
  return md.getTables(null,null,""String_Node_Str"",new String[]{""String_Node_Str""});
}",0.8938906752411575
85524,"@Test public void testHappyPath() throws DatabaseAnonymizerException, SQLException {
  when(mockConnection.getMetaData()).thenReturn(mockMetaData);
  when(mockMetaData.getTables(null,null,""String_Node_Str"",null)).thenReturn(mockTableRS);
  when(mockMetaData.getPrimaryKeys(null,null,table)).thenReturn(mockPKRS);
  when(mockMetaData.getColumns(null,null,table,null)).thenReturn(mockColumnRS);
  when(mockTableRS.getString(3)).thenReturn(table);
  when(mockTableRS.next()).thenReturn(true).thenReturn(false);
  when(mockPKRS.getString(4)).thenReturn(""String_Node_Str"");
  when(mockPKRS.next()).thenReturn(true).thenReturn(false);
  when(mockColumnRS.next()).thenReturn(true).thenReturn(false);
  when(mockColumnRS.getString(""String_Node_Str"")).thenReturn(""String_Node_Str"");
  when(mockColumnRS.getString(6)).thenReturn(""String_Node_Str"");
  MetaData metaData=new TestMSQLMetaData(testProperties);
  List<MatchMetaData> result=metaData.getMetaData();
  assertEquals(1,result.size());
  assertEquals(table,result.get(0).getTableName());
  assertEquals(Arrays.asList(""String_Node_Str""),result.get(0).getPkeys());
  assertEquals(""String_Node_Str"",result.get(0).getColumnName());
  assertEquals(""String_Node_Str"",result.get(0).getColumnType());
  verify(mockTableRS,times(1)).close();
  verify(mockColumnRS,times(1)).close();
}","@Test public void testHappyPath() throws DatabaseAnonymizerException, SQLException {
}",0.1221590909090909
85525,"public static void main(String[] args) throws ParseException, AnonymizerException {
  int x=1 + 1;
  ApplicationLock al=new ApplicationLock(""String_Node_Str"");
  if (al.isAppActive()) {
    log.error(""String_Node_Str"");
    System.exit(1);
  }
  log.info(""String_Node_Str"" + Arrays.toString(args));
  final Options options=createOptions();
  final CommandLine line=getCommandLine(options,args);
  @SuppressWarnings(""String_Node_Str"") List<String> unparsedArgs=line.getArgList();
  if (line.hasOption(""String_Node_Str"") || args.length == 0 || unparsedArgs.size() < 1) {
    help(options);
    return;
  }
  if (line.hasOption(""String_Node_Str"")) {
    LogManager.getRootLogger().setLevel(Level.DEBUG);
  }
 else {
    LogManager.getRootLogger().setLevel(Level.INFO);
  }
  String databasePropertyFile=line.getOptionValue('P',""String_Node_Str"");
  Properties props=loadProperties(databasePropertyFile);
  try (IDBFactory dbFactory=IDBFactory.get(props)){
    String cmd=unparsedArgs.get(0);
    unparsedArgs=unparsedArgs.subList(1,unparsedArgs.size());
switch (cmd) {
case ""String_Node_Str"":
      String anonymizerPropertyFile=line.getOptionValue('A',""String_Node_Str"");
    Properties anonymizerProperties=loadProperties(anonymizerPropertyFile);
  IAnonymizer anonymizer=new DatabaseAnonymizer();
anonymizer.anonymize(dbFactory,anonymizerProperties,getTableNames(unparsedArgs,anonymizerProperties));
break;
case ""String_Node_Str"":
IGenerator generator=new DataGenerator();
String generatorPropertyFile=line.getOptionValue('A',""String_Node_Str"");
Properties generatorProperties=loadProperties(generatorPropertyFile);
generator.generate(dbFactory,generatorProperties);
break;
case ""String_Node_Str"":
IDiscoverer discoverer=null;
if (line.hasOption('c')) {
String columnPropertyFile=line.getOptionValue('C',""String_Node_Str"");
Properties columnProperties=loadProperties(columnPropertyFile);
discoverer=new ColumnDiscoverer();
discoverer.discover(dbFactory,columnProperties,getTableNames(unparsedArgs,columnProperties));
}
 else if (line.hasOption('d')) {
String datadiscoveryPropertyFile=line.getOptionValue('D',""String_Node_Str"");
Properties dataDiscoveryProperties=loadProperties(datadiscoveryPropertyFile);
discoverer=new DataDiscoverer();
discoverer.discover(dbFactory,dataDiscoveryProperties,getTableNames(unparsedArgs,dataDiscoveryProperties));
}
if (line.hasOption('r')) {
String requirementFileName=line.getOptionValue('R',""String_Node_Str"");
discoverer.createRequirement(requirementFileName);
}
break;
default :
help(options);
break;
}
}
 }","public static void main(String[] args) throws ParseException, AnonymizerException {
  ApplicationLock al=new ApplicationLock(""String_Node_Str"");
  if (al.isAppActive()) {
    log.error(""String_Node_Str"");
    System.exit(1);
  }
  log.info(""String_Node_Str"" + Arrays.toString(args));
  final Options options=createOptions();
  final CommandLine line=getCommandLine(options,args);
  @SuppressWarnings(""String_Node_Str"") List<String> unparsedArgs=line.getArgList();
  if (line.hasOption(""String_Node_Str"") || args.length == 0 || unparsedArgs.size() < 1) {
    help(options);
    return;
  }
  if (line.hasOption(""String_Node_Str"")) {
    LogManager.getRootLogger().setLevel(Level.DEBUG);
  }
 else {
    LogManager.getRootLogger().setLevel(Level.INFO);
  }
  String databasePropertyFile=line.getOptionValue('P',""String_Node_Str"");
  Properties props=loadProperties(databasePropertyFile);
  try (IDBFactory dbFactory=IDBFactory.get(props)){
    String cmd=unparsedArgs.get(0);
    unparsedArgs=unparsedArgs.subList(1,unparsedArgs.size());
switch (cmd) {
case ""String_Node_Str"":
      String anonymizerPropertyFile=line.getOptionValue('A',""String_Node_Str"");
    Properties anonymizerProperties=loadProperties(anonymizerPropertyFile);
  IAnonymizer anonymizer=new DatabaseAnonymizer();
anonymizer.anonymize(dbFactory,anonymizerProperties,getTableNames(unparsedArgs,anonymizerProperties));
break;
case ""String_Node_Str"":
IGenerator generator=new DataGenerator();
String generatorPropertyFile=line.getOptionValue('A',""String_Node_Str"");
Properties generatorProperties=loadProperties(generatorPropertyFile);
generator.generate(dbFactory,generatorProperties);
break;
case ""String_Node_Str"":
IDiscoverer discoverer=null;
if (line.hasOption('c')) {
String columnPropertyFile=line.getOptionValue('C',""String_Node_Str"");
Properties columnProperties=loadProperties(columnPropertyFile);
discoverer=new ColumnDiscoverer();
discoverer.discover(dbFactory,columnProperties,getTableNames(unparsedArgs,columnProperties));
}
 else if (line.hasOption('d')) {
String datadiscoveryPropertyFile=line.getOptionValue('D',""String_Node_Str"");
Properties dataDiscoveryProperties=loadProperties(datadiscoveryPropertyFile);
discoverer=new DataDiscoverer();
discoverer.discover(dbFactory,dataDiscoveryProperties,getTableNames(unparsedArgs,dataDiscoveryProperties));
}
if (line.hasOption('r')) {
String requirementFileName=line.getOptionValue('R',""String_Node_Str"");
discoverer.createRequirement(requirementFileName);
}
break;
default :
help(options);
break;
}
}
 }",0.9970454993106164
85526,"/** 
 * Calls the anonymization function for the given Column, and returns its anonymized value.
 * @param dbConn
 * @param row
 * @param column
 * @return
 * @throws NoSuchMethodException
 * @throws SecurityException
 * @throws IllegalAccessException
 * @throws IllegalArgumentException
 * @throws InvocationTargetException 
 */
private Object callAnonymizingFunctionWithoutParameters(Connection dbConn,ResultSet row,Column column) throws SQLException, NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
  String columnValue=row.getString(column.getName());
  String function=column.getFunction();
  if (function == null || function.equals(""String_Node_Str"")) {
    log.warn(""String_Node_Str"" + column + ""String_Node_Str"");
    return ""String_Node_Str"";
  }
  try {
    String className=Utils.getClassName(function);
    String methodName=Utils.getMethodName(function);
    Class<?> clazz=Class.forName(className);
    CoreFunctions instance=(CoreFunctions)Class.forName(className).newInstance();
    instance.setDatabaseConnection(dbConn);
    Method[] methods=clazz.getMethods();
    Method selectedMethod=null;
    Object returnType=null;
    methodLoop:     for (    Method m : methods) {
      if (m.getName().equals(methodName)) {
        log.debug(""String_Node_Str"" + m.getName());
        selectedMethod=m;
        returnType=m.getReturnType();
        break;
      }
    }
    if (selectedMethod == null) {
      StringBuilder s=new StringBuilder(""String_Node_Str"");
      s.append(methodName).append(""String_Node_Str"").append(className);
      throw new NoSuchMethodException(s.toString());
    }
    log.debug(""String_Node_Str"" + methodName);
    Object anonymizedValue=selectedMethod.invoke(instance);
    if (anonymizedValue == null) {
      return null;
    }
    if (returnType == String.class) {
      return anonymizedValue.toString();
    }
 else     if (returnType == java.sql.Date.class) {
      return anonymizedValue;
    }
  }
 catch (  InstantiationException|ClassNotFoundException ex) {
    log.error(ex.toString());
  }
  return ""String_Node_Str"";
}","/** 
 * Calls the anonymization function for the given Column, and returns its anonymized value.
 * @param dbConn
 * @param row
 * @param column
 * @return
 * @throws NoSuchMethodException
 * @throws SecurityException
 * @throws IllegalAccessException
 * @throws IllegalArgumentException
 * @throws InvocationTargetException 
 */
private Object callAnonymizingFunctionWithoutParameters(Connection dbConn,ResultSet row,Column column) throws SQLException, NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
}",0.4227941176470588
85527,"/** 
 * Anonymization function for a single table. Sets up queries, loops over columns and anonymizes columns for the passed Table.
 * @param table 
 */
private void anonymizeTable(int batchSize,Connection db,Table table) throws AnonymizerException {
  log.info(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
  List<Column> tableColumns=table.getColumns();
  Set<String> colNames=new LinkedHashSet<>(tableColumns.size());
  List<String> keyNames=new LinkedList<>();
  fillColumnNames(table,colNames);
  fillPrimaryKeyNamesList(table,keyNames);
  PreparedStatement selectStmt=null;
  PreparedStatement updateStmt=null;
  ResultSet rs=null;
  try {
    db.setAutoCommit(false);
    selectStmt=getSelectQueryStatement(db,table,keyNames,colNames);
    rs=selectStmt.executeQuery();
    String updateString=getUpdateQuery(table,colNames,keyNames);
    updateStmt=db.prepareStatement(updateString);
    log.debug(""String_Node_Str"" + updateString);
    int batchCounter=0, rowCount=0;
    while (rs.next()) {
      anonymizeRow(updateStmt,tableColumns,keyNames,db,rs);
      batchCounter++;
      if (batchCounter == batchSize) {
        updateStmt.executeBatch();
        db.commit();
        batchCounter=0;
      }
      rowCount++;
    }
    log.debug(""String_Node_Str"" + rowCount);
    updateStmt.executeBatch();
    db.commit();
    selectStmt.close();
    updateStmt.close();
    rs.close();
  }
 catch (  SQLException|NoSuchMethodException|SecurityException|IllegalAccessException|IllegalArgumentException|InvocationTargetException ex) {
    log.error(ex.toString());
    if (ex.getCause() != null) {
      log.error(ex.getCause().toString());
    }
    try {
      if (selectStmt != null) {
        selectStmt.close();
      }
      if (updateStmt != null) {
        updateStmt.close();
      }
      if (rs != null) {
        rs.close();
      }
    }
 catch (    SQLException sqlex) {
      log.error(sqlex.toString());
    }
  }
  log.info(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
  log.info(""String_Node_Str"");
}","/** 
 * Anonymization function for a single table. Sets up queries, loops over columns and anonymizes columns for the passed Table.
 * @param table 
 */
private void anonymizeTable(int batchSize,Connection db,Table table) throws AnonymizerException {
  log.info(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
  List<Column> tableColumns=table.getColumns();
  Set<String> colNames=new LinkedHashSet<>(tableColumns.size());
  List<String> keyNames=new LinkedList<>();
  fillColumnNames(table,colNames);
  fillPrimaryKeyNamesList(table,keyNames);
  PreparedStatement selectStmt=null;
  PreparedStatement updateStmt=null;
  ResultSet rs=null;
  try {
    db.setAutoCommit(false);
    selectStmt=getSelectQueryStatement(db,table,keyNames,colNames);
    rs=selectStmt.executeQuery();
    String updateString=getUpdateQuery(table,colNames,keyNames);
    updateStmt=db.prepareStatement(updateString);
    log.debug(""String_Node_Str"" + updateString);
    int batchCounter=0;
    int rowCount=0;
    while (rs.next()) {
      anonymizeRow(updateStmt,tableColumns,keyNames,db,rs);
      batchCounter++;
      if (batchCounter == batchSize) {
        updateStmt.executeBatch();
        db.commit();
        batchCounter=0;
      }
      rowCount++;
    }
    log.debug(""String_Node_Str"" + rowCount);
    updateStmt.executeBatch();
    db.commit();
    selectStmt.close();
    updateStmt.close();
    rs.close();
  }
 catch (  SQLException|NoSuchMethodException|SecurityException|IllegalAccessException|IllegalArgumentException|InvocationTargetException ex) {
    log.error(ex.toString());
    if (ex.getCause() != null) {
      log.error(ex.getCause().toString());
    }
    try {
      if (selectStmt != null) {
        selectStmt.close();
      }
      if (updateStmt != null) {
        updateStmt.close();
      }
      if (rs != null) {
        rs.close();
      }
    }
 catch (    SQLException sqlex) {
      log.error(sqlex.toString());
    }
  }
  log.info(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
  log.info(""String_Node_Str"");
}",0.997560975609756
85528,"/** 
 * Calls the anonymization function for the given Column, and returns its anonymized value.
 * @param dbConn
 * @param row
 * @param column
 * @return
 * @throws NoSuchMethodException
 * @throws SecurityException
 * @throws IllegalAccessException
 * @throws IllegalArgumentException
 * @throws InvocationTargetException 
 */
private Object callAnonymizingFunctionWithoutParameters(Connection dbConn,ResultSet row,Column column) throws SQLException, NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
}","/** 
 * Calls the anonymization function for the given Column, and returns its anonymized value.
 * @param dbConn
 * @param row
 * @param column
 * @return
 * @throws NoSuchMethodException
 * @throws SecurityException
 * @throws IllegalAccessException
 * @throws IllegalArgumentException
 * @throws InvocationTargetException 
 */
private Object callAnonymizingFunctionWithoutParameters(Connection dbConn,ResultSet row,Column column) throws SQLException, NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
  String function=column.getFunction();
  if (function == null || function.equals(""String_Node_Str"")) {
    log.warn(""String_Node_Str"" + column + ""String_Node_Str"");
    return ""String_Node_Str"";
  }
  try {
    String className=Utils.getClassName(function);
    String methodName=Utils.getMethodName(function);
    Class<?> clazz=Class.forName(className);
    CoreFunctions instance=(CoreFunctions)Class.forName(className).newInstance();
    instance.setDatabaseConnection(dbConn);
    Method[] methods=clazz.getMethods();
    Method selectedMethod=null;
    Object returnType=null;
    methodLoop:     for (    Method m : methods) {
      if (m.getName().equals(methodName)) {
        log.debug(""String_Node_Str"" + m.getName());
        selectedMethod=m;
        returnType=m.getReturnType();
        break;
      }
    }
    if (selectedMethod == null) {
      StringBuilder s=new StringBuilder(""String_Node_Str"");
      s.append(methodName).append(""String_Node_Str"").append(className);
      throw new NoSuchMethodException(s.toString());
    }
    log.debug(""String_Node_Str"" + methodName);
    Object anonymizedValue=selectedMethod.invoke(instance);
    if (anonymizedValue == null) {
      return null;
    }
    if (returnType == String.class) {
      return anonymizedValue.toString();
    }
 else     if (returnType == java.sql.Date.class) {
      return anonymizedValue;
    }
  }
 catch (  InstantiationException|ClassNotFoundException ex) {
    log.error(ex.toString());
  }
  return ""String_Node_Str"";
}",0.4313578394598649
85529,"/** 
 * Calls the anonymization function for the given Column, and returns its anonymized value.
 * @param dbConn
 * @param row
 * @param column
 * @return
 * @throws NoSuchMethodException
 * @throws SecurityException
 * @throws IllegalAccessException
 * @throws IllegalArgumentException
 * @throws InvocationTargetException 
 */
private String callAnonymizingFunctionFor(Connection dbConn,ResultSet row,Column column) throws SQLException, NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
  String columnValue=row.getString(column.getName());
  String function=column.getFunction();
  if (function == null || function.equals(""String_Node_Str"")) {
    log.warn(""String_Node_Str"" + column + ""String_Node_Str"");
    return ""String_Node_Str"";
  }
  try {
    String className=Utils.getClassName(function);
    String methodName=Utils.getMethodName(function);
    Class<?> clazz=Class.forName(className);
    CoreFunctions instance=(CoreFunctions)Class.forName(className).newInstance();
    instance.setDatabaseConnection(dbConn);
    List<Parameter> parms=column.getParameters();
    Map<String,Object> paramValues=new HashMap<>(parms.size());
    for (    Parameter param : parms) {
      if (param.getValue().equals(""String_Node_Str"")) {
        paramValues.put(param.getName(),columnValue);
      }
 else       if (param.getValue().equals(""String_Node_Str"") && param.getType().equals(""String_Node_Str"")) {
        paramValues.put(param.getName(),row);
      }
 else {
        paramValues.put(param.getName(),param.getTypeValue());
      }
    }
    List<Object> fnArguments=new ArrayList<>(parms.size());
    Method[] methods=clazz.getMethods();
    Method selectedMethod=null;
    methodLoop:     for (    Method m : methods) {
      if (m.getName().equals(methodName) && m.getReturnType() == String.class) {
        log.debug(""String_Node_Str"" + m.getName());
        log.debug(""String_Node_Str"" + paramValues);
        java.lang.reflect.Parameter[] mParams=m.getParameters();
        fnArguments.clear();
        for (        java.lang.reflect.Parameter par : mParams) {
          log.debug(""String_Node_Str"" + par.getName());
          if (!paramValues.containsKey(par.getName())) {
            continue methodLoop;
          }
          Object value=paramValues.get(par.getName());
          Class<?> fnParamType=par.getType();
          Class<?> confParamType=(value == null) ? fnParamType : value.getClass();
          if (fnParamType.isPrimitive() && value == null) {
            continue methodLoop;
          }
          if (ClassUtils.isPrimitiveWrapper(confParamType)) {
            if (!ClassUtils.isPrimitiveOrWrapper(fnParamType)) {
              continue methodLoop;
            }
            fnParamType=ClassUtils.primitiveToWrapper(fnParamType);
          }
          if (fnParamType != confParamType) {
            continue methodLoop;
          }
          fnArguments.add(value);
        }
        if (fnArguments.size() != mParams.length || fnArguments.size() < paramValues.size()) {
          continue;
        }
        selectedMethod=m;
        break;
      }
    }
    if (selectedMethod == null) {
      StringBuilder s=new StringBuilder(""String_Node_Str"");
      s.append(methodName).append(""String_Node_Str"");
      String comma=""String_Node_Str"";
      for (      Parameter p : parms) {
        s.append(comma).append(p.getType()).append(""String_Node_Str"").append(p.getName());
        comma=""String_Node_Str"";
      }
      s.append(""String_Node_Str"").append(className);
      throw new NoSuchMethodException(s.toString());
    }
    log.debug(""String_Node_Str"" + methodName + ""String_Node_Str""+ Arrays.toString(fnArguments.toArray()));
    Object anonymizedValue=selectedMethod.invoke(instance,fnArguments.toArray());
    if (anonymizedValue == null) {
      return null;
    }
    return anonymizedValue.toString();
  }
 catch (  InstantiationException|ClassNotFoundException ex) {
    log.error(ex.toString());
  }
  return ""String_Node_Str"";
}","/** 
 * Calls the anonymization function for the given Column, and returns its anonymized value.
 * @param dbConn
 * @param row
 * @param column
 * @return anonymized value
 * @throws NoSuchMethodException
 * @throws SecurityException
 * @throws IllegalAccessException
 * @throws IllegalArgumentException
 * @throws InvocationTargetException 
 */
private String callAnonymizingFunctionFor(Connection dbConn,ResultSet row,Column column) throws SQLException, NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
  List<Parameter> parms=column.getParameters();
  if (parms != null) {
    return callAnonymizingFunctionWithParameters(dbConn,row,column);
  }
 else {
    return callAnonymizingFunctionWithoutParameters(dbConn,row,column);
  }
}",0.2582904222451081
85530,"@Override public List<MatchMetaData> discover(IDBFactory factory,Properties dataDiscoveryProperties,Set<String> tables) throws AnonymizerException {
  log.info(""String_Node_Str"");
  double probabilityThreshold=parseDouble(dataDiscoveryProperties.getProperty(""String_Node_Str""));
  log.info(""String_Node_Str"" + probabilityThreshold);
  List<MatchMetaData> finalList=new ArrayList<>();
  for (  String model : modelList) {
    log.info(""String_Node_Str"" + model);
    Model modelPerson=createModel(dataDiscoveryProperties,model);
    matches=discoverAgainstSingleModel(factory,dataDiscoveryProperties,tables,modelPerson,probabilityThreshold);
    finalList.removeAll(matches);
    finalList.addAll(matches);
  }
  DecimalFormat decimalFormat=new DecimalFormat(""String_Node_Str"");
  for (  MatchMetaData data : finalList) {
    String probability=decimalFormat.format(data.getAverageProbability());
    String result=String.format(""String_Node_Str"",data.getTableName(),data.getColumnName(),probability,data.getModel());
    log.info(result);
  }
  return matches;
}","@Override public List<MatchMetaData> discover(IDBFactory factory,Properties dataDiscoveryProperties,Set<String> tables) throws AnonymizerException {
  log.info(""String_Node_Str"");
  double probabilityThreshold=parseDouble(dataDiscoveryProperties.getProperty(""String_Node_Str""));
  log.info(""String_Node_Str"" + probabilityThreshold);
  List<MatchMetaData> finalList=new ArrayList<>();
  for (  String model : modelList) {
    log.info(""String_Node_Str"");
    log.info(""String_Node_Str"" + model);
    log.info(""String_Node_Str"");
    Model modelPerson=createModel(dataDiscoveryProperties,model);
    matches=discoverAgainstSingleModel(factory,dataDiscoveryProperties,tables,modelPerson,probabilityThreshold);
    finalList=ListUtils.union(finalList,matches);
  }
  DecimalFormat decimalFormat=new DecimalFormat(""String_Node_Str"");
  log.info(""String_Node_Str"");
  log.info(String.format(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  for (  MatchMetaData data : finalList) {
    String probability=decimalFormat.format(data.getAverageProbability());
    String result=String.format(""String_Node_Str"",data.getTableName(),data.getColumnName(),probability,data.getModel());
    log.info(result);
  }
  return matches;
}",0.8846487424111015
85531,"private List<MatchMetaData> discoverAgainstSingleModel(IDBFactory factory,Properties dataDiscoveryProperties,Set<String> tables,Model model,double probabilityThreshold) throws AnonymizerException {
  IMetaData metaData=factory.fetchMetaData();
  List<MatchMetaData> map=metaData.getMetaData();
  log.info(""String_Node_Str"");
  log.info(String.format(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  matches=new ArrayList<>();
  ISQLBuilder sqlBuilder=factory.createSQLBuilder();
  for (  MatchMetaData data : map) {
    if (SQLToJavaMapping.isString(data.getColumnType())) {
      String tableName=data.getTableName();
      String columnName=data.getColumnName();
      List<Double> probabilityList=new ArrayList<>();
      log.debug(""String_Node_Str"" + tableName + ""String_Node_Str"");
      if (!tables.isEmpty() && !tables.contains(tableName.toLowerCase())) {
        log.debug(""String_Node_Str"");
        continue;
      }
      String tableNamePattern=dataDiscoveryProperties.getProperty(""String_Node_Str"");
      if (!CommonUtils.isEmptyString(tableNamePattern)) {
        Pattern p=compile(tableNamePattern);
        if (!p.matcher(tableName).matches()) {
          continue;
        }
      }
      String table=sqlBuilder.prefixSchema(tableName);
      int limit=Integer.parseInt(dataDiscoveryProperties.getProperty(""String_Node_Str""));
      String query=sqlBuilder.buildSelectWithLimit(""String_Node_Str"" + columnName + ""String_Node_Str""+ table+ ""String_Node_Str""+ columnName+ ""String_Node_Str"",limit);
      log.debug(""String_Node_Str"" + query);
      try (Statement stmt=factory.getConnection().createStatement();ResultSet resultSet=stmt.executeQuery(query)){
        while (resultSet.next()) {
          String sentence=resultSet.getString(1);
          if (sentence != null && !sentence.isEmpty()) {
            String tokens[]=model.getTokenizer().tokenize(sentence);
            Span nameSpans[]=model.getNameFinder().find(tokens);
            double[] spanProbs=model.getNameFinder().probs(nameSpans);
            for (int i=0; i < nameSpans.length; i++) {
              probabilityList.add(spanProbs[i]);
            }
            model.getNameFinder().clearAdaptiveData();
          }
        }
      }
 catch (      SQLException sqle) {
        log.error(sqle.toString());
      }
      double averageProbability=calculateAverage(probabilityList);
      if ((averageProbability >= probabilityThreshold)) {
        data.setAverageProbability(averageProbability);
        data.setModel(model.getName());
        matches.add(data);
      }
    }
  }
  return matches;
}","private List<MatchMetaData> discoverAgainstSingleModel(IDBFactory factory,Properties dataDiscoveryProperties,Set<String> tables,Model model,double probabilityThreshold) throws AnonymizerException {
  IMetaData metaData=factory.fetchMetaData();
  List<MatchMetaData> map=metaData.getMetaData();
  matches=new ArrayList<>();
  ISQLBuilder sqlBuilder=factory.createSQLBuilder();
  for (  MatchMetaData data : map) {
    if (SQLToJavaMapping.isString(data.getColumnType())) {
      String tableName=data.getTableName();
      String columnName=data.getColumnName();
      List<Double> probabilityList=new ArrayList<>();
      log.debug(""String_Node_Str"" + tableName + ""String_Node_Str"");
      if (!tables.isEmpty() && !tables.contains(tableName.toLowerCase())) {
        log.debug(""String_Node_Str"");
        continue;
      }
      String tableNamePattern=dataDiscoveryProperties.getProperty(""String_Node_Str"");
      if (!CommonUtils.isEmptyString(tableNamePattern)) {
        Pattern p=compile(tableNamePattern);
        if (!p.matcher(tableName).matches()) {
          continue;
        }
      }
      String table=sqlBuilder.prefixSchema(tableName);
      int limit=Integer.parseInt(dataDiscoveryProperties.getProperty(""String_Node_Str""));
      String query=sqlBuilder.buildSelectWithLimit(""String_Node_Str"" + columnName + ""String_Node_Str""+ table+ ""String_Node_Str""+ columnName+ ""String_Node_Str"",limit);
      log.debug(""String_Node_Str"" + query);
      try (Statement stmt=factory.getConnection().createStatement();ResultSet resultSet=stmt.executeQuery(query)){
        while (resultSet.next()) {
          String sentence=resultSet.getString(1);
          if (sentence != null && !sentence.isEmpty()) {
            String tokens[]=model.getTokenizer().tokenize(sentence);
            Span nameSpans[]=model.getNameFinder().find(tokens);
            double[] spanProbs=model.getNameFinder().probs(nameSpans);
            for (int i=0; i < nameSpans.length; i++) {
              probabilityList.add(spanProbs[i]);
            }
            model.getNameFinder().clearAdaptiveData();
          }
        }
      }
 catch (      SQLException sqle) {
        log.error(sqle.toString());
      }
      double averageProbability=calculateAverage(probabilityList);
      if ((averageProbability >= probabilityThreshold)) {
        data.setAverageProbability(averageProbability);
        data.setModel(model.getName());
        matches.add(data);
      }
    }
  }
  return matches;
}",0.9742986070237396
85532,"@Override public List<MatchMetaData> discover(IDBFactory factory,Properties dataDiscoveryProperties,Set<String> tables) throws AnonymizerException {
  log.info(""String_Node_Str"");
  double probabilityThreshold=parseDouble(dataDiscoveryProperties.getProperty(""String_Node_Str""));
  IMetaData metaData=factory.fetchMetaData();
  List<MatchMetaData> map=metaData.getMetaData();
  InputStream modelInToken=null;
  InputStream modelIn=null;
  TokenizerModel modelToken=null;
  Tokenizer tokenizer=null;
  TokenNameFinderModel model=null;
  NameFinderME nameFinder=null;
  try {
    modelInToken=new FileInputStream(dataDiscoveryProperties.getProperty(""String_Node_Str""));
    modelIn=new FileInputStream(dataDiscoveryProperties.getProperty(""String_Node_Str""));
    modelToken=new TokenizerModel(modelInToken);
    tokenizer=new TokenizerME(modelToken);
    model=new TokenNameFinderModel(modelIn);
    nameFinder=new NameFinderME(model);
    modelInToken.close();
    modelIn.close();
  }
 catch (  FileNotFoundException ex) {
    log.error(ex.toString());
    try {
      if (modelInToken != null) {
        modelInToken.close();
      }
      if (modelIn != null) {
        modelIn.close();
      }
    }
 catch (    IOException ioe) {
      log.error(ioe.toString());
    }
  }
catch (  IOException ex) {
    log.error(ex.toString());
  }
  ISQLBuilder sqlBuilder=factory.createSQLBuilder();
  log.info(""String_Node_Str"");
  log.info(String.format(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  DecimalFormat decimalFormat=new DecimalFormat(""String_Node_Str"");
  matches=new ArrayList<>();
  for (  MatchMetaData data : map) {
    if (SQLToJavaMapping.isString(data.getColumnType())) {
      String tableName=data.getTableName();
      String columnName=data.getColumnName();
      List<Double> probabilityList=new ArrayList<>();
      if (!tables.isEmpty() && !tables.contains(tableName.toLowerCase())) {
        continue;
      }
      String tableNamePattern=dataDiscoveryProperties.getProperty(""String_Node_Str"");
      if (!CommonUtils.isEmptyString(tableNamePattern)) {
        Pattern p=compile(tableNamePattern);
        if (!p.matcher(tableName).matches()) {
          continue;
        }
      }
      String table=sqlBuilder.prefixSchema(tableName);
      int limit=Integer.parseInt(dataDiscoveryProperties.getProperty(""String_Node_Str""));
      String query=sqlBuilder.buildSelectWithLimit(""String_Node_Str"" + columnName + ""String_Node_Str""+ table+ ""String_Node_Str""+ columnName+ ""String_Node_Str"",limit);
      try (Statement stmt=factory.getConnection().createStatement();ResultSet resultSet=stmt.executeQuery(query)){
        while (resultSet.next()) {
          String sentence=resultSet.getString(1);
          if (sentence != null && !sentence.isEmpty()) {
            String tokens[]=tokenizer.tokenize(sentence);
            Span nameSpans[]=nameFinder.find(tokens);
            double[] spanProbs=nameFinder.probs(nameSpans);
            for (int i=0; i < nameSpans.length; i++) {
              probabilityList.add(spanProbs[i]);
            }
          }
        }
      }
 catch (      SQLException sqle) {
        log.error(sqle.toString());
      }
      double averageProbability=calculateAverage(probabilityList);
      if ((averageProbability >= probabilityThreshold) && (averageProbability <= 0.99)) {
        String probability=decimalFormat.format(averageProbability);
        String result=String.format(""String_Node_Str"",tableName,columnName,probability);
        log.info(result);
        matches.add(data);
      }
    }
  }
  return matches;
}","@Override public List<MatchMetaData> discover(IDBFactory factory,Properties dataDiscoveryProperties,Set<String> tables) throws AnonymizerException {
  log.info(""String_Node_Str"");
  double probabilityThreshold=parseDouble(dataDiscoveryProperties.getProperty(""String_Node_Str""));
  IMetaData metaData=factory.fetchMetaData();
  List<MatchMetaData> map=metaData.getMetaData();
  InputStream modelInToken=null;
  InputStream modelIn=null;
  TokenizerModel modelToken=null;
  Tokenizer tokenizer=null;
  TokenNameFinderModel model=null;
  NameFinderME nameFinder=null;
  try {
    modelInToken=new FileInputStream(dataDiscoveryProperties.getProperty(""String_Node_Str""));
    modelIn=new FileInputStream(dataDiscoveryProperties.getProperty(""String_Node_Str""));
    modelToken=new TokenizerModel(modelInToken);
    tokenizer=new TokenizerME(modelToken);
    model=new TokenNameFinderModel(modelIn);
    nameFinder=new NameFinderME(model);
    modelInToken.close();
    modelIn.close();
  }
 catch (  FileNotFoundException ex) {
    log.error(ex.toString());
    try {
      if (modelInToken != null) {
        modelInToken.close();
      }
      if (modelIn != null) {
        modelIn.close();
      }
    }
 catch (    IOException ioe) {
      log.error(ioe.toString());
    }
  }
catch (  IOException ex) {
    log.error(ex.toString());
  }
  ISQLBuilder sqlBuilder=factory.createSQLBuilder();
  log.info(""String_Node_Str"");
  log.info(String.format(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  DecimalFormat decimalFormat=new DecimalFormat(""String_Node_Str"");
  matches=new ArrayList<>();
  for (  MatchMetaData data : map) {
    if (SQLToJavaMapping.isString(data.getColumnType())) {
      String tableName=data.getTableName();
      String columnName=data.getColumnName();
      List<Double> probabilityList=new ArrayList<>();
      log.debug(""String_Node_Str"" + tableName + ""String_Node_Str"");
      if (!tables.isEmpty() && !tables.contains(tableName.toLowerCase())) {
        log.debug(""String_Node_Str"");
        continue;
      }
      String tableNamePattern=dataDiscoveryProperties.getProperty(""String_Node_Str"");
      if (!CommonUtils.isEmptyString(tableNamePattern)) {
        Pattern p=compile(tableNamePattern);
        if (!p.matcher(tableName).matches()) {
          continue;
        }
      }
      String table=sqlBuilder.prefixSchema(tableName);
      int limit=Integer.parseInt(dataDiscoveryProperties.getProperty(""String_Node_Str""));
      String query=sqlBuilder.buildSelectWithLimit(""String_Node_Str"" + columnName + ""String_Node_Str""+ table+ ""String_Node_Str""+ columnName+ ""String_Node_Str"",limit);
      log.debug(""String_Node_Str"" + query);
      try (Statement stmt=factory.getConnection().createStatement();ResultSet resultSet=stmt.executeQuery(query)){
        while (resultSet.next()) {
          String sentence=resultSet.getString(1);
          if (sentence != null && !sentence.isEmpty()) {
            String tokens[]=tokenizer.tokenize(sentence);
            Span nameSpans[]=nameFinder.find(tokens);
            double[] spanProbs=nameFinder.probs(nameSpans);
            for (int i=0; i < nameSpans.length; i++) {
              probabilityList.add(spanProbs[i]);
            }
          }
        }
      }
 catch (      SQLException sqle) {
        log.error(sqle.toString());
      }
      double averageProbability=calculateAverage(probabilityList);
      if ((averageProbability >= probabilityThreshold) && (averageProbability <= 0.99)) {
        String probability=decimalFormat.format(averageProbability);
        String result=String.format(""String_Node_Str"",tableName,columnName,probability);
        log.info(result);
        matches.add(data);
      }
    }
  }
  return matches;
}",0.9796306355241716
85533,"public static boolean isString(final String type){
  return STRING.equals(JAVA_TYPES.get(type.toUpperCase()));
}","public static boolean isString(final String type){
  return STRING.equals(JAVA_TYPES.get(type.toUpperCase())) || CHAR.equals(JAVA_TYPES.get(type.toUpperCase()));
}",0.8145454545454546
85534,"@Override public void discover(Properties databaseProperties,Properties columnProperties,Collection<String> tables) throws DatabaseAnonymizerException {
  log.info(""String_Node_Str"");
  IMetaData metaData=MetaDataFactory.fetchMetaData(databaseProperties);
  List<ColumnMetaData> map=metaData.getMetaData();
  List<String> suspList=new ArrayList(columnProperties.keySet());
  ArrayList<String> matches=new ArrayList<>();
  for (  String s : suspList) {
    Pattern p=compile(s);
    for (    ColumnMetaData pair : map) {
      String tableName=pair.getTableName();
      String columnName=pair.getColumnName();
      if (!tables.isEmpty() && !tables.contains(tableName.toLowerCase())) {
        continue;
      }
      if (p.matcher(columnName).matches()) {
        matches.add(tableName + ""String_Node_Str"" + columnName);
      }
    }
  }
  log.info(""String_Node_Str"");
  log.info(""String_Node_Str"");
  log.info(""String_Node_Str"");
  Collections.sort(matches);
  for (  String entry : matches) {
    log.info(entry);
  }
}","@Override public void discover(Properties databaseProperties,Properties columnProperties,Collection<String> tables) throws DatabaseAnonymizerException {
  log.info(""String_Node_Str"");
  IMetaData metaData=MetaDataFactory.fetchMetaData(databaseProperties);
  List<ColumnMetaData> map=metaData.getMetaData();
  List<String> suspList=new ArrayList(columnProperties.keySet());
  ArrayList<String> matches=new ArrayList<>();
  for (  String s : suspList) {
    Pattern p=compile(s);
    for (    ColumnMetaData pair : map) {
      String tableName=pair.getTableName();
      String columnName=pair.getColumnName();
      if (!tables.isEmpty() && !tables.contains(tableName.toLowerCase())) {
        continue;
      }
      if (p.matcher(columnName.toLowerCase()).matches()) {
        matches.add(tableName + ""String_Node_Str"" + columnName);
      }
    }
  }
  log.info(""String_Node_Str"");
  log.info(""String_Node_Str"");
  log.info(""String_Node_Str"");
  Collections.sort(matches);
  for (  String entry : matches) {
    log.info(entry);
  }
}",0.9932038834951455
85535,"@Override public void discover(Properties databaseProperties,Properties dataDiscoveryProperties,Collection<String> tables) throws AnonymizerException {
  log.info(""String_Node_Str"");
  double probabilityThreshold=parseDouble(dataDiscoveryProperties.getProperty(""String_Node_Str""));
  IMetaData metaData=MetaDataFactory.fetchMetaData(databaseProperties);
  List<ColumnMetaData> map=metaData.getMetaData();
  InputStream modelInToken=null;
  InputStream modelIn=null;
  TokenizerModel modelToken=null;
  Tokenizer tokenizer=null;
  TokenNameFinderModel model=null;
  NameFinderME nameFinder=null;
  try {
    firstAndLastNames=CommonUtils.readStreamOfLines(dataDiscoveryProperties.getProperty(""String_Node_Str""));
    modelInToken=new FileInputStream(dataDiscoveryProperties.getProperty(""String_Node_Str""));
    modelIn=new FileInputStream(dataDiscoveryProperties.getProperty(""String_Node_Str""));
    modelToken=new TokenizerModel(modelInToken);
    tokenizer=new TokenizerME(modelToken);
    model=new TokenNameFinderModel(modelIn);
    nameFinder=new NameFinderME(model);
    modelInToken.close();
    modelIn.close();
  }
 catch (  FileNotFoundException ex) {
    log.error(ex.toString());
    try {
      if (modelInToken != null) {
        modelInToken.close();
      }
      if (modelIn != null) {
        modelIn.close();
      }
    }
 catch (    IOException ioe) {
      log.error(ioe.toString());
    }
  }
catch (  IOException ex) {
    log.error(ex.toString());
  }
  IDBConnection dbConnection=DBConnectionFactory.createDBConnection(databaseProperties);
  Connection connection=dbConnection.connect(databaseProperties);
  String schema=databaseProperties.getProperty(""String_Node_Str"");
  log.info(""String_Node_Str"");
  Formatter formatter=new Formatter();
  log.info(formatter.format(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  for (  ColumnMetaData pair : map) {
    if (SQLToJavaMapping.isString(pair.getColumnType())) {
      String tableName=pair.getTableName();
      String columnName=pair.getColumnName();
      List<Double> probabilityList=new ArrayList<>();
      if (!tables.isEmpty() && !tables.contains(tableName.toLowerCase())) {
        continue;
      }
      Statement stmt=null;
      ResultSet resultSet=null;
      try {
        stmt=connection.createStatement();
        String table=tableName;
        if (schema != null && !schema.equals(""String_Node_Str"")) {
          table=schema + ""String_Node_Str"" + tableName;
        }
        int limit=Integer.parseInt(dataDiscoveryProperties.getProperty(""String_Node_Str""));
        ISQLBuilder sqlBuilder=SQLBuilderFactory.createSQLBuilder(databaseProperties);
        String query=sqlBuilder.buildSelectWithLimit(""String_Node_Str"" + columnName + ""String_Node_Str""+ table+ ""String_Node_Str""+ columnName+ ""String_Node_Str"",limit);
        resultSet=stmt.executeQuery(query);
        while (resultSet.next()) {
          String sentence=resultSet.getString(1);
          if (sentence != null && !sentence.isEmpty()) {
            String tokens[]=tokenizer.tokenize(sentence);
            Span nameSpans[]=nameFinder.find(tokens);
            double[] spanProbs=nameFinder.probs(nameSpans);
            for (int i=0; i < nameSpans.length; i++) {
              probabilityList.add(spanProbs[i]);
            }
            if (firstAndLastNames.contains(sentence.toUpperCase())) {
              probabilityList.add(0.95);
            }
          }
        }
        resultSet.close();
        stmt.close();
      }
 catch (      SQLException sqle) {
        try {
          if (stmt != null) {
            stmt.close();
          }
          if (resultSet != null) {
            resultSet.close();
          }
        }
 catch (        SQLException sql) {
          log.error(sql.toString());
        }
        log.error(sqle.toString());
      }
      double averageProbability=calculateAverage(probabilityList);
      if ((averageProbability >= probabilityThreshold) && (averageProbability <= 0.99)) {
        formatter=new Formatter();
        log.info(formatter.format(""String_Node_Str"",tableName,columnName,averageProbability));
      }
    }
  }
}","@Override public void discover(Properties databaseProperties,Properties dataDiscoveryProperties,Collection<String> tables) throws AnonymizerException {
  log.info(""String_Node_Str"");
  double probabilityThreshold=parseDouble(dataDiscoveryProperties.getProperty(""String_Node_Str""));
  IMetaData metaData=MetaDataFactory.fetchMetaData(databaseProperties);
  List<ColumnMetaData> map=metaData.getMetaData();
  InputStream modelInToken=null;
  InputStream modelIn=null;
  TokenizerModel modelToken=null;
  Tokenizer tokenizer=null;
  TokenNameFinderModel model=null;
  NameFinderME nameFinder=null;
  try {
    firstAndLastNames=CommonUtils.readStreamOfLines(dataDiscoveryProperties.getProperty(""String_Node_Str""));
    modelInToken=new FileInputStream(dataDiscoveryProperties.getProperty(""String_Node_Str""));
    modelIn=new FileInputStream(dataDiscoveryProperties.getProperty(""String_Node_Str""));
    modelToken=new TokenizerModel(modelInToken);
    tokenizer=new TokenizerME(modelToken);
    model=new TokenNameFinderModel(modelIn);
    nameFinder=new NameFinderME(model);
    modelInToken.close();
    modelIn.close();
  }
 catch (  FileNotFoundException ex) {
    log.error(ex.toString());
    try {
      if (modelInToken != null) {
        modelInToken.close();
      }
      if (modelIn != null) {
        modelIn.close();
      }
    }
 catch (    IOException ioe) {
      log.error(ioe.toString());
    }
  }
catch (  IOException ex) {
    log.error(ex.toString());
  }
  IDBConnection dbConnection=DBConnectionFactory.createDBConnection(databaseProperties);
  Connection connection=dbConnection.connect(databaseProperties);
  String schema=databaseProperties.getProperty(""String_Node_Str"");
  log.info(""String_Node_Str"");
  Formatter formatter=new Formatter();
  log.info(formatter.format(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  for (  ColumnMetaData pair : map) {
    if (SQLToJavaMapping.isString(pair.getColumnType())) {
      String tableName=pair.getTableName();
      String columnName=pair.getColumnName();
      List<Double> probabilityList=new ArrayList<>();
      if (!tables.isEmpty() && !tables.contains(tableName.toLowerCase())) {
        continue;
      }
      String tableNamePattern=dataDiscoveryProperties.getProperty(""String_Node_Str"");
      if (!CommonUtils.isEmptyString(tableNamePattern)) {
        Pattern p=compile(tableNamePattern);
        if (!p.matcher(tableName).matches()) {
          continue;
        }
      }
      Statement stmt=null;
      ResultSet resultSet=null;
      try {
        stmt=connection.createStatement();
        String table=tableName;
        if (schema != null && !schema.equals(""String_Node_Str"")) {
          table=schema + ""String_Node_Str"" + tableName;
        }
        int limit=Integer.parseInt(dataDiscoveryProperties.getProperty(""String_Node_Str""));
        ISQLBuilder sqlBuilder=SQLBuilderFactory.createSQLBuilder(databaseProperties);
        String query=sqlBuilder.buildSelectWithLimit(""String_Node_Str"" + columnName + ""String_Node_Str""+ table+ ""String_Node_Str""+ columnName+ ""String_Node_Str"",limit);
        resultSet=stmt.executeQuery(query);
        while (resultSet.next()) {
          String sentence=resultSet.getString(1);
          if (sentence != null && !sentence.isEmpty()) {
            String tokens[]=tokenizer.tokenize(sentence);
            Span nameSpans[]=nameFinder.find(tokens);
            double[] spanProbs=nameFinder.probs(nameSpans);
            for (int i=0; i < nameSpans.length; i++) {
              probabilityList.add(spanProbs[i]);
            }
            if (firstAndLastNames.contains(sentence.toUpperCase())) {
              probabilityList.add(0.95);
            }
          }
        }
        resultSet.close();
        stmt.close();
      }
 catch (      SQLException sqle) {
        try {
          if (stmt != null) {
            stmt.close();
          }
          if (resultSet != null) {
            resultSet.close();
          }
        }
 catch (        SQLException sql) {
          log.error(sql.toString());
        }
        log.error(sqle.toString());
      }
      double averageProbability=calculateAverage(probabilityList);
      if ((averageProbability >= probabilityThreshold) && (averageProbability <= 0.99)) {
        formatter=new Formatter();
        String probability=new DecimalFormat(""String_Node_Str"").format(averageProbability);
        log.info(formatter.format(""String_Node_Str"",tableName,columnName,probability));
      }
    }
  }
}",0.952172409819062
85536,"@Override public List<ColumnMetaData> getMetaData(){
  List<ColumnMetaData> map=new ArrayList();
  String schema=databaseProperties.getProperty(""String_Node_Str"");
  IDBConnection dbConnection;
  Connection connection=null;
  try {
    dbConnection=DBConnectionFactory.createDBConnection(databaseProperties);
    connection=dbConnection.connect(databaseProperties);
  }
 catch (  DatabaseAnonymizerException ex) {
    log.info(ex.toString());
  }
  ResultSet rs=null;
  try {
    DatabaseMetaData md=connection.getMetaData();
    log.info(""String_Node_Str"" + schema);
    rs=md.getTables(null,schema,null,new String[]{""String_Node_Str""});
    while (rs.next()) {
      String tableName=rs.getString(3);
      log.info(""String_Node_Str"" + tableName);
      ResultSet resultSet=null;
      resultSet=md.getColumns(null,schema,tableName,null);
      while (resultSet.next()) {
        String columnName=resultSet.getString(""String_Node_Str"");
        String columnType=resultSet.getString(""String_Node_Str"");
        if (this.columnType != null) {
          if (SQLToJavaMapping.isString(resultSet.getInt(5))) {
            columnType=""String_Node_Str"";
          }
        }
        map.add(new ColumnMetaData(tableName,columnName,columnType));
      }
    }
    rs.close();
    connection.close();
  }
 catch (  SQLException e) {
    if (connection != null) {
      try {
        connection.close();
      }
 catch (      SQLException sqle) {
        log.error(sqle.toString());
      }
    }
    if (rs != null) {
      try {
        rs.close();
      }
 catch (      SQLException sql) {
        log.error(sql.toString());
      }
    }
    log.error(e.toString());
  }
  return map;
}","@Override public List<ColumnMetaData> getMetaData(){
  List<ColumnMetaData> map=new ArrayList();
  String schema=databaseProperties.getProperty(""String_Node_Str"");
  IDBConnection dbConnection;
  Connection connection=null;
  try {
    dbConnection=DBConnectionFactory.createDBConnection(databaseProperties);
    connection=dbConnection.connect(databaseProperties);
  }
 catch (  DatabaseAnonymizerException ex) {
    log.info(ex.toString());
  }
  ResultSet rs=null;
  try {
    DatabaseMetaData md=connection.getMetaData();
    log.info(""String_Node_Str"" + schema);
    rs=md.getTables(null,schema,null,new String[]{""String_Node_Str""});
    while (rs.next()) {
      String tableName=rs.getString(3);
      log.info(""String_Node_Str"" + tableName);
      ResultSet resultSet=null;
      resultSet=md.getColumns(null,schema,tableName,null);
      while (resultSet.next()) {
        String columnName=resultSet.getString(""String_Node_Str"");
        String colType=resultSet.getString(""String_Node_Str"");
        if (this.columnType != null) {
          if (SQLToJavaMapping.isString(resultSet.getInt(5))) {
            colType=""String_Node_Str"";
          }
        }
        map.add(new ColumnMetaData(tableName,columnName,colType));
      }
    }
    rs.close();
    connection.close();
  }
 catch (  SQLException e) {
    if (connection != null) {
      try {
        connection.close();
      }
 catch (      SQLException sqle) {
        log.error(sqle.toString());
      }
    }
    if (rs != null) {
      try {
        rs.close();
      }
 catch (      SQLException sql) {
        log.error(sql.toString());
      }
    }
    log.error(e.toString());
  }
  return map;
}",0.9973222255281168
85537,"public static void main(String[] args) throws ParseException, AnonymizerException {
  if (args.length == 0) {
    log.info(""String_Node_Str"");
    log.info(""String_Node_Str"");
    return;
  }
  final Options options=createOptions();
  final CommandLine line=getCommandLine(options,args);
  if (line.hasOption(""String_Node_Str"")) {
    help(options);
    return;
  }
  String databasePropertyFile=""String_Node_Str"";
  Properties props=null;
  if (line.hasOption(""String_Node_Str"")) {
    databasePropertyFile=line.getOptionValues(""String_Node_Str"")[0];
    try {
      props=loadProperties(databasePropertyFile);
    }
 catch (    IOException ioe) {
      throw new AnonymizerException(""String_Node_Str"" + databasePropertyFile,ioe);
    }
  }
  if (props == null) {
    throw new AnonymizerException(""String_Node_Str"");
  }
  String anonymizePropertyFile=""String_Node_Str"";
  if (line.hasOption(""String_Node_Str"")) {
    anonymizePropertyFile=line.getOptionValue(""String_Node_Str"");
  }
  Properties anonymizerProperties=null;
  try {
    anonymizerProperties=loadProperties(anonymizePropertyFile);
  }
 catch (  IOException ioe) {
    throw new AnonymizerException(""String_Node_Str"" + databasePropertyFile,ioe);
  }
  if (anonymizerProperties == null) {
    throw new AnonymizerException(""String_Node_Str"");
  }
  if (line.hasOption(""String_Node_Str"")) {
    IAnonymizer anonymizer=new DatabaseAnonymizer();
    anonymizer.anonymize(databasePropertyFile,anonymizePropertyFile);
  }
}","public static void main(String[] args) throws ParseException, AnonymizerException {
  if (args.length == 0) {
    log.info(""String_Node_Str"");
    log.info(""String_Node_Str"");
    return;
  }
  final Options options=createOptions();
  final CommandLine line=getCommandLine(options,args);
  if (line.hasOption(""String_Node_Str"")) {
    help(options);
    return;
  }
  String databasePropertyFile=""String_Node_Str"";
  Properties props=null;
  if (line.hasOption(""String_Node_Str"")) {
    databasePropertyFile=line.getOptionValues(""String_Node_Str"")[0];
    try {
      props=loadProperties(databasePropertyFile);
    }
 catch (    IOException ioe) {
      throw new AnonymizerException(""String_Node_Str"" + databasePropertyFile,ioe);
    }
  }
  if (props == null) {
    throw new AnonymizerException(""String_Node_Str"");
  }
  String anonymizerPropertyFile=""String_Node_Str"";
  if (line.hasOption(""String_Node_Str"")) {
    anonymizerPropertyFile=line.getOptionValue(""String_Node_Str"");
  }
  Properties anonymizerProperties=null;
  try {
    anonymizerProperties=loadProperties(anonymizerPropertyFile);
  }
 catch (  IOException ioe) {
    throw new AnonymizerException(""String_Node_Str"" + anonymizerPropertyFile,ioe);
  }
  if (anonymizerProperties == null) {
    throw new AnonymizerException(""String_Node_Str"");
  }
  if (line.hasOption(""String_Node_Str"")) {
    IAnonymizer anonymizer=new DatabaseAnonymizer();
    anonymizer.anonymize(props,anonymizerProperties);
  }
}",0.9766497461928934
85538,"/** 
 * Creates options for the command line
 * @return Options
 */
@SuppressWarnings(""String_Node_Str"") private static Options createOptions(){
  final Options options=new Options();
  options.addOption(""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  return options;
}","/** 
 * Creates options for the command line
 * @return Options
 */
@SuppressWarnings(""String_Node_Str"") private static Options createOptions(){
  final Options options=new Options();
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  return options;
}",0.9826923076923076
85539,"@Override public void anonymize(String databasePropertyFile,String anonymizerPropertyFile) throws DatabaseAnonymizerException {
  log.info(""String_Node_Str"");
  Properties dbProperties=null;
  dbProperties=loadPropertiesFromClassPath(databasePropertyFile);
  if (dbProperties == null) {
    throw new DatabaseAnonymizerException(""String_Node_Str"");
  }
  IDBConnection dbConnection=DBConnectionFactory.createDBConnection(dbProperties);
  Connection connection=dbConnection.connect(dbProperties);
  Properties props=null;
  try {
    props=loadProperties(anonymizerPropertyFile);
  }
 catch (  IOException uex) {
    if (connection != null) {
      try {
        connection.close();
      }
 catch (      SQLException sql) {
        log.error(sql.toString());
      }
    }
    log.error(uex.toString());
  }
  if (props == null) {
    throw new DatabaseAnonymizerException(""String_Node_Str"");
  }
  String requirementFile=props.getProperty(""String_Node_Str"");
  int batchSize=parseInt(props.getProperty(""String_Node_Str""));
  Requirement requirement=null;
  try {
    JAXBContext jc=newInstance(Requirement.class);
    Unmarshaller unmarshaller=jc.createUnmarshaller();
    requirement=(Requirement)unmarshaller.unmarshal(new File(requirementFile));
  }
 catch (  JAXBException je) {
    log.error(je.toString());
    throw new DatabaseAnonymizerException(je.toString(),je);
  }
  init();
  log.info(""String_Node_Str"" + requirement.getClient() + ""String_Node_Str""+ requirement.getVersion());
  for (  Table table : requirement.getTables()) {
    log.info(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
    PreparedStatement pstmt=null;
    Statement stmt=null;
    ResultSet rs=null;
    StringBuilder sql=new StringBuilder(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
    int batchCounter=0;
    for (    Column column : table.getColumns()) {
      sql.append(column.getName()).append(""String_Node_Str"");
    }
    if (sql.length() > 0) {
      sql.setLength(sql.length() - 1);
    }
    sql.append(""String_Node_Str"").append(table.getPKey()).append(""String_Node_Str"");
    final String updateString=sql.toString();
    try {
      stmt=connection.createStatement();
      rs=stmt.executeQuery(String.format(""String_Node_Str"",table.getName()));
      pstmt=connection.prepareStatement(updateString);
      while (rs.next()) {
        int id=rs.getInt(""String_Node_Str"");
        int index=0;
        for (        Column column : table.getColumns()) {
          String function=column.getFunction();
          if (function == null || function.equals(""String_Node_Str"")) {
            log.warn(""String_Node_Str"" + column + ""String_Node_Str"");
          }
 else {
            try {
              Class clazz=Functions.class;
              if (column.getParameters() == null) {
                Method method=clazz.getMethod(function,null);
                pstmt.setString(++index,method.invoke(null).toString());
              }
 else {
                for (                Parameter parameter : column.getParameters()) {
                  Method method=clazz.getMethod(function,String.class);
                  String result=method.invoke(null,parameter.getValue()).toString();
                  pstmt.setString(++index,result);
                }
              }
            }
 catch (            NoSuchMethodException|SecurityException|IllegalAccessException|IllegalArgumentException|InvocationTargetException ex) {
              log.error(ex.toString());
              try {
                stmt.close();
                if (pstmt != null) {
                  pstmt.close();
                }
                rs.close();
              }
 catch (              SQLException sqlex) {
                log.error(sqlex.toString());
              }
            }
          }
        }
        pstmt.setInt(++index,id);
        pstmt.addBatch();
        batchCounter++;
        if (batchCounter == batchSize) {
          pstmt.executeBatch();
          connection.commit();
          batchCounter=0;
        }
      }
      pstmt.executeBatch();
      connection.commit();
      stmt.close();
      pstmt.close();
      rs.close();
    }
 catch (    SQLException sqle) {
      log.error(sqle.toString());
      try {
        if (stmt != null) {
          stmt.close();
        }
        if (pstmt != null) {
          pstmt.close();
        }
        if (rs != null) {
          rs.close();
        }
      }
 catch (      SQLException sqlex) {
        log.error(sqlex.toString());
      }
    }
    log.info(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
    log.info(""String_Node_Str"");
  }
}","@Override public void anonymize(Properties databaseProperties,Properties anonymizerProperties) throws DatabaseAnonymizerException {
  log.info(""String_Node_Str"");
  IDBConnection dbConnection=DBConnectionFactory.createDBConnection(databaseProperties);
  Connection connection=dbConnection.connect(databaseProperties);
  String requirementFile=anonymizerProperties.getProperty(""String_Node_Str"");
  int batchSize=parseInt(anonymizerProperties.getProperty(""String_Node_Str""));
  Requirement requirement=null;
  try {
    JAXBContext jc=newInstance(Requirement.class);
    Unmarshaller unmarshaller=jc.createUnmarshaller();
    requirement=(Requirement)unmarshaller.unmarshal(new File(requirementFile));
  }
 catch (  JAXBException je) {
    log.error(je.toString());
    throw new DatabaseAnonymizerException(je.toString(),je);
  }
  init();
  log.info(""String_Node_Str"" + requirement.getClient() + ""String_Node_Str""+ requirement.getVersion());
  for (  Table table : requirement.getTables()) {
    log.info(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
    PreparedStatement pstmt=null;
    Statement stmt=null;
    ResultSet rs=null;
    StringBuilder sql=new StringBuilder(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
    int batchCounter=0;
    for (    Column column : table.getColumns()) {
      sql.append(column.getName()).append(""String_Node_Str"");
    }
    if (sql.length() > 0) {
      sql.setLength(sql.length() - 1);
    }
    sql.append(""String_Node_Str"").append(table.getPKey()).append(""String_Node_Str"");
    final String updateString=sql.toString();
    try {
      stmt=connection.createStatement();
      rs=stmt.executeQuery(String.format(""String_Node_Str"",table.getName()));
      pstmt=connection.prepareStatement(updateString);
      while (rs.next()) {
        int id=rs.getInt(""String_Node_Str"");
        int index=0;
        for (        Column column : table.getColumns()) {
          String function=column.getFunction();
          if (function == null || function.equals(""String_Node_Str"")) {
            log.warn(""String_Node_Str"" + column + ""String_Node_Str"");
          }
 else {
            try {
              Class clazz=Functions.class;
              if (column.getParameters() == null) {
                Method method=clazz.getMethod(function,null);
                pstmt.setString(++index,method.invoke(null).toString());
              }
 else {
                for (                Parameter parameter : column.getParameters()) {
                  Method method=clazz.getMethod(function,String.class);
                  String result=method.invoke(null,parameter.getValue()).toString();
                  pstmt.setString(++index,result);
                }
              }
            }
 catch (            NoSuchMethodException|SecurityException|IllegalAccessException|IllegalArgumentException|InvocationTargetException ex) {
              log.error(ex.toString());
              try {
                stmt.close();
                if (pstmt != null) {
                  pstmt.close();
                }
                rs.close();
              }
 catch (              SQLException sqlex) {
                log.error(sqlex.toString());
              }
            }
          }
        }
        pstmt.setInt(++index,id);
        pstmt.addBatch();
        batchCounter++;
        if (batchCounter == batchSize) {
          pstmt.executeBatch();
          connection.commit();
          batchCounter=0;
        }
      }
      pstmt.executeBatch();
      connection.commit();
      stmt.close();
      pstmt.close();
      rs.close();
    }
 catch (    SQLException sqle) {
      log.error(sqle.toString());
      try {
        if (stmt != null) {
          stmt.close();
        }
        if (pstmt != null) {
          pstmt.close();
        }
        if (rs != null) {
          rs.close();
        }
      }
 catch (      SQLException sqlex) {
        log.error(sqlex.toString());
      }
    }
    log.info(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
    log.info(""String_Node_Str"");
  }
}",0.9092164307904728
85540,"/** 
 * Anonymizes data.
 * @param propertyFile
 * @param String propertyFile
 * @throws com.strider.dataanonymizer.database.DatabaseAnonymizerException
 */
void anonymize(String propertyFile,String anonymizerPropertFile) throws DatabaseAnonymizerException ;","/** 
 * Anonymizes data.
 * @param propertyFile
 * @param String propertyFile
 * @throws com.strider.dataanonymizer.database.DatabaseAnonymizerException
 */
void anonymize(Properties databaseProperties,Properties anonymizerProperties) throws DatabaseAnonymizerException ;",0.7977315689981096
85541,"/** 
 * Establishes database connection
 * @param propertyFile
 * @return Connection
 * @throws DatabaseAnonymizerException 
 */
@Override public Connection connect(Properties properties) throws DatabaseAnonymizerException {
  String driver=properties.getProperty(""String_Node_Str"");
  String database=properties.getProperty(""String_Node_Str"");
  String url=properties.getProperty(""String_Node_Str"");
  String userName=properties.getProperty(""String_Node_Str"");
  String password=properties.getProperty(""String_Node_Str"");
  log.debug(""String_Node_Str"" + driver);
  log.debug(""String_Node_Str"" + database);
  log.debug(""String_Node_Str"" + url);
  log.debug(""String_Node_Str"" + userName);
  try {
    forName(driver);
  }
 catch (  ClassNotFoundException cnfe) {
    log.error(cnfe.toString());
    throw new DatabaseAnonymizerException(cnfe.toString(),cnfe);
  }
  Connection conn=null;
  try {
    conn=getConnection(url,userName,password);
  }
 catch (  SQLException sqle) {
    log.error(sqle.toString());
    if (conn != null) {
      try {
        conn.close();
      }
 catch (      SQLException sql) {
        log.error(sql.toString());
      }
    }
    throw new DatabaseAnonymizerException(sqle.toString(),sqle);
  }
  return conn;
}","/** 
 * Establishes database connection
 * @param properties
 * @return Connection
 * @throws DatabaseAnonymizerException 
 */
@Override public Connection connect(Properties properties) throws DatabaseAnonymizerException {
  String driver=properties.getProperty(""String_Node_Str"");
  String database=properties.getProperty(""String_Node_Str"");
  String url=properties.getProperty(""String_Node_Str"");
  String userName=properties.getProperty(""String_Node_Str"");
  String password=properties.getProperty(""String_Node_Str"");
  log.debug(""String_Node_Str"" + driver);
  log.debug(""String_Node_Str"" + database);
  log.debug(""String_Node_Str"" + url);
  log.debug(""String_Node_Str"" + userName);
  try {
    forName(driver);
  }
 catch (  ClassNotFoundException cnfe) {
    log.error(cnfe.toString());
    throw new DatabaseAnonymizerException(cnfe.toString(),cnfe);
  }
  Connection conn=null;
  try {
    conn=getConnection(url,userName,password);
    conn.setAutoCommit(false);
  }
 catch (  SQLException sqle) {
    log.error(sqle.toString());
    if (conn != null) {
      try {
        conn.close();
      }
 catch (      SQLException sql) {
        log.error(sql.toString());
      }
    }
    throw new DatabaseAnonymizerException(sqle.toString(),sqle);
  }
  return conn;
}",0.984493041749503
85542,"public static String randomStringFromFile(String fileName) throws IOException {
  if (STRING_LIST.isEmpty()) {
    try (BufferedReader br=new BufferedReader(new FileReader(fileName))){
      for (String line; (line=br.readLine()) != null; ) {
        STRING_LIST.add(line);
      }
    }
   }
  int rand=nextIntInRange(0,STRING_LIST.size() - 1);
  return STRING_LIST.get(rand);
}","public static String randomStringFromFile(String fileName) throws IOException {
  log.info(fileName);
  if (STRING_LIST.isEmpty()) {
    try (BufferedReader br=new BufferedReader(new FileReader(fileName))){
      for (String line; (line=br.readLine()) != null; ) {
        STRING_LIST.add(line);
      }
    }
   }
  int rand=nextIntInRange(0,STRING_LIST.size() - 1);
  return STRING_LIST.get(rand);
}",0.9717948717948718
85543,"public void discover(String databasePropertyFile) throws DatabaseAnonymizerException {
  this.discover(databasePropertyFile,""String_Node_Str"");
}","@Override public void discover(Properties databaseProperties,Properties columnProperties) throws DatabaseAnonymizerException {
  log.info(""String_Node_Str"");
  IDBConnection dbConnection=DBConnectionFactory.createDBConnection(databaseProperties);
  Connection connection=dbConnection.connect(databaseProperties);
  ResultSet rs=null;
  List<ColumnMetaData> map=new ArrayList<>();
  try {
    DatabaseMetaData md=connection.getMetaData();
    rs=md.getTables(null,null,""String_Node_Str"",null);
    while (rs.next()) {
      String tableName=rs.getString(3);
      ResultSet resultSet=md.getColumns(null,null,tableName,null);
      while (resultSet.next()) {
        String columnName=resultSet.getString(""String_Node_Str"");
        String columnType=resultSet.getString(""String_Node_Str"");
        map.add(new ColumnMetaData(tableName,columnName,columnType));
      }
    }
    rs.close();
    connection.close();
  }
 catch (  SQLException e) {
    if (connection != null) {
      try {
        connection.close();
      }
 catch (      SQLException sqle) {
        log.error(sqle.toString());
      }
    }
    if (rs != null) {
      try {
        rs.close();
      }
 catch (      SQLException sql) {
        log.error(sql.toString());
      }
    }
    log.error(e.toString());
  }
  Configuration columnsConfiguration=null;
  try {
    columnsConfiguration=new PropertiesConfiguration(""String_Node_Str"");
  }
 catch (  ConfigurationException ex) {
    log.error(ColumnDiscoverer.class);
  }
  Iterator<String> iterator=columnsConfiguration.getKeys();
  List<String> suspList=toList(iterator);
  ArrayList<String> matches=new ArrayList<>();
  for (  String s : suspList) {
    Pattern p=compile(s);
    for (    ColumnMetaData pair : map) {
      String tableName=pair.getTableName();
      String columnName=pair.getColumnName();
      if (p.matcher(columnName).matches()) {
        matches.add(tableName + ""String_Node_Str"" + columnName);
      }
    }
  }
  log.info(""String_Node_Str"");
  log.info(""String_Node_Str"");
  log.info(""String_Node_Str"");
  for (  String entry : matches) {
    log.info(entry);
  }
}",0.0963748894783377
85544,"@Override public void discover(String databasePropertyFile,String columnPropertyFile){
  return;
}","@Override public void discover(Properties databaseProperties,Properties dataDiscoveryProperties) throws AnonymizerException {
  double probabilityThreshold=parseDouble(dataDiscoveryProperties.getProperty(""String_Node_Str""));
  log.info(""String_Node_Str"");
  IDBConnection dbConnection=DBConnectionFactory.createDBConnection(databaseProperties);
  Connection connection=dbConnection.connect(databaseProperties);
  List<ColumnMetaData> map=new ArrayList<>();
  try {
    DatabaseMetaData md=connection.getMetaData();
    ResultSet rs=md.getTables(null,null,""String_Node_Str"",null);
    while (rs.next()) {
      String tableName=rs.getString(3);
      ResultSet resultSet=md.getColumns(null,null,tableName,null);
      while (resultSet.next()) {
        String columnName=resultSet.getString(""String_Node_Str"");
        if (resultSet.getInt(5) == java.sql.Types.VARCHAR) {
          ColumnMetaData columnMetaData=new ColumnMetaData(tableName,columnName,""String_Node_Str"");
          map.add(columnMetaData);
        }
      }
    }
    rs.close();
  }
 catch (  SQLException e) {
    log.error(e);
  }
  InputStream modelInToken=null;
  InputStream modelIn=null;
  TokenizerModel modelToken=null;
  Tokenizer tokenizer=null;
  TokenNameFinderModel model=null;
  NameFinderME nameFinder=null;
  try {
    modelInToken=new FileInputStream(dataDiscoveryProperties.getProperty(""String_Node_Str""));
    modelIn=new FileInputStream(dataDiscoveryProperties.getProperty(""String_Node_Str""));
    modelToken=new TokenizerModel(modelInToken);
    tokenizer=new TokenizerME(modelToken);
    model=new TokenNameFinderModel(modelIn);
    nameFinder=new NameFinderME(model);
    modelInToken.close();
    modelIn.close();
  }
 catch (  FileNotFoundException ex) {
    log.error(ex.toString());
    try {
      if (modelInToken != null) {
        modelInToken.close();
      }
      if (modelIn != null) {
        modelIn.close();
      }
    }
 catch (    IOException ioe) {
      log.error(ioe.toString());
    }
  }
catch (  IOException ex) {
    log.error(ex.toString());
  }
  log.info(""String_Node_Str"");
  log.info(""String_Node_Str"");
  for (  ColumnMetaData pair : map) {
    if (pair.getColumnType().equals(""String_Node_Str"")) {
      String tableName=pair.getTableName();
      String columnName=pair.getColumnName();
      List<Double> probabilityList=new ArrayList<>();
      Statement stmt=null;
      ResultSet rs=null;
      try {
        stmt=connection.createStatement();
        rs=stmt.executeQuery(new StringBuilder(""String_Node_Str"").append(columnName).append(""String_Node_Str"").append(tableName).toString());
        while (rs.next()) {
          String sentence=rs.getString(1);
          if (sentence != null && !sentence.isEmpty()) {
            String tokens[]=tokenizer.tokenize(sentence);
            Span nameSpans[]=nameFinder.find(tokens);
            double[] spanProbs=nameFinder.probs(nameSpans);
            for (int i=0; i < nameSpans.length; i++) {
              probabilityList.add(spanProbs[i]);
            }
          }
        }
        rs.close();
        stmt.close();
      }
 catch (      SQLException sqle) {
        try {
          if (stmt != null) {
            stmt.close();
          }
          if (rs != null) {
            rs.close();
          }
        }
 catch (        SQLException sql) {
          log.error(sql.toString());
        }
        log.error(sqle.toString());
      }
      double averageProbability=calculateAverage(probabilityList);
      if ((averageProbability >= probabilityThreshold) && (averageProbability <= 0.90)) {
        log.info(""String_Node_Str"" + tableName + ""String_Node_Str""+ columnName+ ""String_Node_Str""+ averageProbability);
      }
    }
  }
}",0.0304062909567496
85545,"@Override public void anonymize(String databasePropertyFile,String anonymizerPropertyFile) throws DatabaseAnonymizerException {
  log.info(""String_Node_Str"");
  IDBConnection dbConnection=DBConnectionFactory.createDBConnection(databasePropertyFile);
  Connection connection=dbConnection.connect(databasePropertyFile);
  Properties props=null;
  try {
    props=loadProperties(anonymizerPropertyFile);
  }
 catch (  IOException uex) {
    if (connection != null) {
      try {
        connection.close();
      }
 catch (      SQLException sql) {
        log.error(sql.toString());
      }
    }
    log.error(uex.toString());
  }
  if (props == null) {
    throw new DatabaseAnonymizerException(""String_Node_Str"");
  }
  String requirementFile=props.getProperty(""String_Node_Str"");
  int batchSize=parseInt(props.getProperty(""String_Node_Str""));
  Requirement requirement=null;
  try {
    JAXBContext jc=newInstance(Requirement.class);
    Unmarshaller unmarshaller=jc.createUnmarshaller();
    requirement=(Requirement)unmarshaller.unmarshal(new File(requirementFile));
  }
 catch (  JAXBException je) {
    log.error(je.toString());
    throw new DatabaseAnonymizerException(je.toString(),je);
  }
  init();
  log.info(""String_Node_Str"" + requirement.getClient() + ""String_Node_Str""+ requirement.getVersion());
  for (  Table table : requirement.getTables()) {
    log.info(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
    PreparedStatement pstmt=null;
    Statement stmt=null;
    ResultSet rs=null;
    StringBuilder sql=new StringBuilder(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
    int batchCounter=0;
    for (    Column column : table.getColumns()) {
      sql.append(column.getName()).append(""String_Node_Str"");
    }
    if (sql.length() > 0) {
      sql.setLength(sql.length() - 1);
    }
    sql.append(""String_Node_Str"").append(table.getPKey()).append(""String_Node_Str"");
    final String updateString=sql.toString();
    try {
      stmt=connection.createStatement();
      rs=stmt.executeQuery(String.format(""String_Node_Str"",table.getName()));
      pstmt=connection.prepareStatement(updateString);
      while (rs.next()) {
        int id=rs.getInt(""String_Node_Str"");
        int index=0;
        for (        Column column : table.getColumns()) {
          String function=column.getFunction();
          if (function == null || function.equals(""String_Node_Str"")) {
            log.warn(""String_Node_Str"" + column + ""String_Node_Str"");
          }
 else {
            try {
              Class clazz=Functions.class;
              if (column.getParameters() == null) {
                Method method=clazz.getMethod(function,null);
                pstmt.setString(++index,method.invoke(null).toString());
              }
 else {
                for (                Parameter parameter : column.getParameters()) {
                  Method method=clazz.getMethod(function,String.class);
                  String result=method.invoke(null,parameter.getValue()).toString();
                  pstmt.setString(++index,result);
                }
              }
            }
 catch (            NoSuchMethodException|SecurityException|IllegalAccessException|IllegalArgumentException|InvocationTargetException ex) {
              log.error(ex.toString());
              try {
                stmt.close();
                if (pstmt != null) {
                  pstmt.close();
                }
                rs.close();
              }
 catch (              SQLException sqlex) {
                log.error(sqlex.toString());
              }
            }
          }
        }
        pstmt.setInt(++index,id);
        pstmt.addBatch();
        batchCounter++;
        if (batchCounter == batchSize) {
          pstmt.executeBatch();
          connection.commit();
          batchCounter=0;
        }
      }
      pstmt.executeBatch();
      connection.commit();
      stmt.close();
      pstmt.close();
      rs.close();
    }
 catch (    SQLException sqle) {
      log.error(sqle.toString());
      try {
        if (stmt != null) {
          stmt.close();
        }
        if (pstmt != null) {
          pstmt.close();
        }
        if (rs != null) {
          rs.close();
        }
      }
 catch (      SQLException sqlex) {
        log.error(sqlex.toString());
      }
    }
    log.info(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
    log.info(""String_Node_Str"");
  }
}","@Override public void anonymize(String databasePropertyFile,String anonymizerPropertyFile) throws DatabaseAnonymizerException {
  log.info(""String_Node_Str"");
  Properties dbProperties=null;
  dbProperties=loadPropertiesFromClassPath(databasePropertyFile);
  if (dbProperties == null) {
    throw new DatabaseAnonymizerException(""String_Node_Str"");
  }
  IDBConnection dbConnection=DBConnectionFactory.createDBConnection(dbProperties);
  Connection connection=dbConnection.connect(dbProperties);
  Properties props=null;
  try {
    props=loadProperties(anonymizerPropertyFile);
  }
 catch (  IOException uex) {
    if (connection != null) {
      try {
        connection.close();
      }
 catch (      SQLException sql) {
        log.error(sql.toString());
      }
    }
    log.error(uex.toString());
  }
  if (props == null) {
    throw new DatabaseAnonymizerException(""String_Node_Str"");
  }
  String requirementFile=props.getProperty(""String_Node_Str"");
  int batchSize=parseInt(props.getProperty(""String_Node_Str""));
  Requirement requirement=null;
  try {
    JAXBContext jc=newInstance(Requirement.class);
    Unmarshaller unmarshaller=jc.createUnmarshaller();
    requirement=(Requirement)unmarshaller.unmarshal(new File(requirementFile));
  }
 catch (  JAXBException je) {
    log.error(je.toString());
    throw new DatabaseAnonymizerException(je.toString(),je);
  }
  init();
  log.info(""String_Node_Str"" + requirement.getClient() + ""String_Node_Str""+ requirement.getVersion());
  for (  Table table : requirement.getTables()) {
    log.info(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
    PreparedStatement pstmt=null;
    Statement stmt=null;
    ResultSet rs=null;
    StringBuilder sql=new StringBuilder(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
    int batchCounter=0;
    for (    Column column : table.getColumns()) {
      sql.append(column.getName()).append(""String_Node_Str"");
    }
    if (sql.length() > 0) {
      sql.setLength(sql.length() - 1);
    }
    sql.append(""String_Node_Str"").append(table.getPKey()).append(""String_Node_Str"");
    final String updateString=sql.toString();
    try {
      stmt=connection.createStatement();
      rs=stmt.executeQuery(String.format(""String_Node_Str"",table.getName()));
      pstmt=connection.prepareStatement(updateString);
      while (rs.next()) {
        int id=rs.getInt(""String_Node_Str"");
        int index=0;
        for (        Column column : table.getColumns()) {
          String function=column.getFunction();
          if (function == null || function.equals(""String_Node_Str"")) {
            log.warn(""String_Node_Str"" + column + ""String_Node_Str"");
          }
 else {
            try {
              Class clazz=Functions.class;
              if (column.getParameters() == null) {
                Method method=clazz.getMethod(function,null);
                pstmt.setString(++index,method.invoke(null).toString());
              }
 else {
                for (                Parameter parameter : column.getParameters()) {
                  Method method=clazz.getMethod(function,String.class);
                  String result=method.invoke(null,parameter.getValue()).toString();
                  pstmt.setString(++index,result);
                }
              }
            }
 catch (            NoSuchMethodException|SecurityException|IllegalAccessException|IllegalArgumentException|InvocationTargetException ex) {
              log.error(ex.toString());
              try {
                stmt.close();
                if (pstmt != null) {
                  pstmt.close();
                }
                rs.close();
              }
 catch (              SQLException sqlex) {
                log.error(sqlex.toString());
              }
            }
          }
        }
        pstmt.setInt(++index,id);
        pstmt.addBatch();
        batchCounter++;
        if (batchCounter == batchSize) {
          pstmt.executeBatch();
          connection.commit();
          batchCounter=0;
        }
      }
      pstmt.executeBatch();
      connection.commit();
      stmt.close();
      pstmt.close();
      rs.close();
    }
 catch (    SQLException sqle) {
      log.error(sqle.toString());
      try {
        if (stmt != null) {
          stmt.close();
        }
        if (pstmt != null) {
          pstmt.close();
        }
        if (rs != null) {
          rs.close();
        }
      }
 catch (      SQLException sqlex) {
        log.error(sqlex.toString());
      }
    }
    log.info(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
    log.info(""String_Node_Str"");
  }
}",0.9755020966674024
85546,"public static void main(String[] args) throws AnonymizerException {
  final Options options=createOptions();
  CommandLine line=null;
  try {
    line=getCommandLine(options,args);
  }
 catch (  ParseException pe) {
    log.error(pe.toString());
  }
  if (line == null || line.hasOption(""String_Node_Str"")) {
    help(options);
  }
 else   if (line.hasOption(""String_Node_Str"")) {
    log.info(""String_Node_Str"");
    String databasePropertyFile=""String_Node_Str"";
    if (line.hasOption(""String_Node_Str"")) {
      databasePropertyFile=line.getOptionValue(""String_Node_Str"");
    }
    Properties dbProperties=null;
    dbProperties=loadPropertiesFromClassPath(databasePropertyFile);
    if (dbProperties == null) {
      throw new AnonymizerException(""String_Node_Str"");
    }
    String columnPropertyFile=""String_Node_Str"";
    if (line.hasOption(""String_Node_Str"")) {
      columnPropertyFile=line.getOptionValue(""String_Node_Str"");
    }
    Properties columnProperties=null;
    columnProperties=loadPropertiesFromClassPath(columnPropertyFile);
    if (columnProperties == null) {
      throw new AnonymizerException(""String_Node_Str"");
    }
    IDiscoverer discoverer=new ColumnDiscoverer();
    discoverer.discover(databasePropertyFile,columnPropertyFile);
  }
 else   if (line.hasOption(""String_Node_Str"")) {
    log.info(""String_Node_Str"");
    String databasePropertyFile=""String_Node_Str"";
    if (line.hasOption(""String_Node_Str"")) {
      databasePropertyFile=line.getOptionValue(""String_Node_Str"");
    }
    Properties dbProperties=null;
    dbProperties=loadPropertiesFromClassPath(databasePropertyFile);
    if (dbProperties == null) {
      throw new AnonymizerException(""String_Node_Str"");
    }
    IDiscoverer discoverer=new DataDiscoverer();
    discoverer.discover(databasePropertyFile);
  }
 else {
    help(options);
  }
}","public static void main(String[] args) throws AnonymizerException {
  final Options options=createOptions();
  CommandLine line=null;
  try {
    line=getCommandLine(options,args);
  }
 catch (  ParseException pe) {
    log.error(pe.toString());
  }
  if (line == null || line.hasOption(""String_Node_Str"")) {
    help(options);
  }
 else   if (line.hasOption(""String_Node_Str"")) {
    log.info(""String_Node_Str"");
    String databasePropertyFile=""String_Node_Str"";
    if (line.hasOption(""String_Node_Str"")) {
      databasePropertyFile=line.getOptionValue(""String_Node_Str"");
    }
    Properties dbProperties=null;
    dbProperties=loadPropertiesFromClassPath(databasePropertyFile);
    if (dbProperties == null) {
      throw new AnonymizerException(""String_Node_Str"");
    }
    String columnPropertyFile=""String_Node_Str"";
    if (line.hasOption(""String_Node_Str"")) {
      columnPropertyFile=line.getOptionValue(""String_Node_Str"");
    }
    Properties columnProperties=null;
    columnProperties=loadPropertiesFromClassPath(columnPropertyFile);
    if (columnProperties == null) {
      throw new AnonymizerException(""String_Node_Str"");
    }
    IDiscoverer discoverer=new ColumnDiscoverer();
    discoverer.discover(dbProperties,columnProperties);
  }
 else   if (line.hasOption(""String_Node_Str"")) {
    log.info(""String_Node_Str"");
    String databasePropertyFile=""String_Node_Str"";
    if (line.hasOption(""String_Node_Str"")) {
      databasePropertyFile=line.getOptionValue(""String_Node_Str"");
    }
    Properties dbProperties=null;
    dbProperties=loadPropertiesFromClassPath(databasePropertyFile);
    if (dbProperties == null) {
      throw new AnonymizerException(""String_Node_Str"");
    }
    String datadiscoveryPropertyFile=""String_Node_Str"";
    if (line.hasOption(""String_Node_Str"")) {
      datadiscoveryPropertyFile=line.getOptionValue(""String_Node_Str"");
    }
    Properties dataDiscoveryProperties=null;
    dataDiscoveryProperties=loadPropertiesFromClassPath(datadiscoveryPropertyFile);
    if (dataDiscoveryProperties == null) {
      throw new AnonymizerException(""String_Node_Str"");
    }
    IDiscoverer discoverer=new DataDiscoverer();
    discoverer.discover(dbProperties,dataDiscoveryProperties);
  }
 else {
    help(options);
  }
}",0.8783685360524399
85547,"private static Options createOptions(){
  final Options options=new Options();
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  return options;
}","private static Options createOptions(){
  final Options options=new Options();
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  return options;
}",0.9258920402561756
85548,"/** 
 * Discovers data or data containers with data which can be be the subject  for data anonymization.
 * @param databasePropertyFile
 * @param columnPropertyFile
 * @throws com.strider.dataanonymizer.AnonymizerException
 */
void discover(String databasePropertyFile,String columnPropertyFile) throws AnonymizerException ;","/** 
 * Discovers data or data containers with data which can be be the subject  for data anonymization.
 * @param databaseProperties
 * @param properties
 * @throws com.strider.dataanonymizer.AnonymizerException
 */
void discover(Properties databaseProperties,Properties properties) throws AnonymizerException ;",0.8270440251572327
85549,"public static IDBConnection createDBConnection(final String databasePropertyFile) throws DatabaseAnonymizerException {
  if ((databasePropertyFile == null) || databasePropertyFile.isEmpty()) {
    log.error(""String_Node_Str"");
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Properties props=new Properties();
  InputStream is=null;
  try {
    is=new FileInputStream(databasePropertyFile);
    props.load(is);
    is.close();
  }
 catch (  IOException ex) {
    if (is != null) {
      try {
        is.close();
      }
 catch (      IOException ioe) {
        log.error(ioe.toString());
      }
    }
    log.error(ex.toString());
  }
  String database=props.getProperty(""String_Node_Str"");
  if (database.equalsIgnoreCase(""String_Node_Str"")) {
    return new MySQLDBConnection();
  }
  throw new IllegalArgumentException(""String_Node_Str"" + database + ""String_Node_Str"");
}","public static IDBConnection createDBConnection(final Properties databaseProperties) throws DatabaseAnonymizerException {
  String database=databaseProperties.getProperty(""String_Node_Str"");
  if (database.equalsIgnoreCase(""String_Node_Str"")) {
    return new MySQLDBConnection();
  }
  throw new IllegalArgumentException(""String_Node_Str"" + database + ""String_Node_Str"");
}",0.5260663507109005
85550,Connection connect(final String propertyFile) throws DatabaseAnonymizerException ;,Connection connect(final Properties properties) throws DatabaseAnonymizerException ;,0.9036144578313252
85551,"/** 
 * Establishes database connection
 * @param propertyFile
 * @return Connection
 * @throws DatabaseAnonymizerException 
 */
@Override public Connection connect(String propertyFile) throws DatabaseAnonymizerException {
  Configuration configuration=null;
  try {
    configuration=new PropertiesConfiguration(propertyFile);
  }
 catch (  ConfigurationException ex) {
    log.error(ColumnDiscoverer.class);
  }
  String driver=configuration.getString(""String_Node_Str"");
  String database=configuration.getString(""String_Node_Str"");
  String url=configuration.getString(""String_Node_Str"");
  String userName=configuration.getString(""String_Node_Str"");
  String password=configuration.getString(""String_Node_Str"");
  log.debug(""String_Node_Str"" + driver);
  log.debug(""String_Node_Str"" + database);
  log.debug(""String_Node_Str"" + url);
  log.debug(""String_Node_Str"" + userName);
  try {
    forName(driver);
  }
 catch (  ClassNotFoundException cnfe) {
    log.error(cnfe.toString());
    throw new DatabaseAnonymizerException(cnfe.toString(),cnfe);
  }
  Connection conn=null;
  try {
    conn=getConnection(url,userName,password);
  }
 catch (  SQLException sqle) {
    log.error(sqle.toString());
    if (conn != null) {
      try {
        conn.close();
      }
 catch (      SQLException sql) {
        log.error(sql.toString());
      }
    }
    throw new DatabaseAnonymizerException(sqle.toString(),sqle);
  }
  return conn;
}","/** 
 * Establishes database connection
 * @param propertyFile
 * @return Connection
 * @throws DatabaseAnonymizerException 
 */
@Override public Connection connect(Properties properties) throws DatabaseAnonymizerException {
  String driver=properties.getProperty(""String_Node_Str"");
  String database=properties.getProperty(""String_Node_Str"");
  String url=properties.getProperty(""String_Node_Str"");
  String userName=properties.getProperty(""String_Node_Str"");
  String password=properties.getProperty(""String_Node_Str"");
  log.debug(""String_Node_Str"" + driver);
  log.debug(""String_Node_Str"" + database);
  log.debug(""String_Node_Str"" + url);
  log.debug(""String_Node_Str"" + userName);
  try {
    forName(driver);
  }
 catch (  ClassNotFoundException cnfe) {
    log.error(cnfe.toString());
    throw new DatabaseAnonymizerException(cnfe.toString(),cnfe);
  }
  Connection conn=null;
  try {
    conn=getConnection(url,userName,password);
  }
 catch (  SQLException sqle) {
    log.error(sqle.toString());
    if (conn != null) {
      try {
        conn.close();
      }
 catch (      SQLException sql) {
        log.error(sql.toString());
      }
    }
    throw new DatabaseAnonymizerException(sqle.toString(),sqle);
  }
  return conn;
}",0.7156716417910448
85552,"@Override public void anonymize(Properties databaseProperties,Properties anonymizerProperties) throws DatabaseAnonymizerException {
  log.info(""String_Node_Str"");
  IDBConnection dbConnection=DBConnectionFactory.createDBConnection(databaseProperties);
  Connection connection=dbConnection.connect(databaseProperties);
  String requirementFile=anonymizerProperties.getProperty(""String_Node_Str"");
  int batchSize=parseInt(anonymizerProperties.getProperty(""String_Node_Str""));
  Requirement requirement=null;
  try {
    JAXBContext jc=newInstance(Requirement.class);
    Unmarshaller unmarshaller=jc.createUnmarshaller();
    requirement=(Requirement)unmarshaller.unmarshal(new File(requirementFile));
  }
 catch (  JAXBException je) {
    log.error(je.toString());
    throw new DatabaseAnonymizerException(je.toString(),je);
  }
  init();
  log.info(""String_Node_Str"" + requirement.getClient() + ""String_Node_Str""+ requirement.getVersion());
  for (  Table table : requirement.getTables()) {
    log.info(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
    PreparedStatement pstmt=null;
    Statement stmt=null;
    ResultSet rs=null;
    StringBuilder sql=new StringBuilder(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
    int batchCounter=0;
    for (    Column column : table.getColumns()) {
      sql.append(column.getName()).append(""String_Node_Str"");
    }
    if (sql.length() > 0) {
      sql.setLength(sql.length() - 1);
    }
    sql.append(""String_Node_Str"").append(table.getPKey()).append(""String_Node_Str"");
    final String updateString=sql.toString();
    try {
      stmt=connection.createStatement();
      rs=stmt.executeQuery(String.format(""String_Node_Str"",table.getName()));
      pstmt=connection.prepareStatement(updateString);
      while (rs.next()) {
        int id=rs.getInt(""String_Node_Str"");
        int index=0;
        for (        Column column : table.getColumns()) {
          String function=column.getFunction();
          if (function == null || function.equals(""String_Node_Str"")) {
            log.warn(""String_Node_Str"" + column + ""String_Node_Str"");
          }
 else {
            try {
              Class clazz=Functions.class;
              if (column.getParameters() == null) {
                Method method=clazz.getMethod(function,null);
                pstmt.setString(++index,method.invoke(null).toString());
              }
 else {
                for (                Parameter parameter : column.getParameters()) {
                  Method method=clazz.getMethod(function,String.class);
                  String result=method.invoke(null,parameter.getValue()).toString();
                  pstmt.setString(++index,result);
                }
              }
            }
 catch (            NoSuchMethodException|SecurityException|IllegalAccessException|IllegalArgumentException|InvocationTargetException ex) {
              log.error(ex.toString());
              try {
                stmt.close();
                if (pstmt != null) {
                  pstmt.close();
                }
                rs.close();
              }
 catch (              SQLException sqlex) {
                log.error(sqlex.toString());
              }
            }
          }
        }
        pstmt.setInt(++index,id);
        pstmt.addBatch();
        batchCounter++;
        if (batchCounter == batchSize) {
          pstmt.executeBatch();
          connection.commit();
          batchCounter=0;
        }
      }
      pstmt.executeBatch();
      connection.commit();
      stmt.close();
      pstmt.close();
      rs.close();
    }
 catch (    SQLException sqle) {
      log.error(sqle.toString());
      try {
        if (stmt != null) {
          stmt.close();
        }
        if (pstmt != null) {
          pstmt.close();
        }
        if (rs != null) {
          rs.close();
        }
      }
 catch (      SQLException sqlex) {
        log.error(sqlex.toString());
      }
    }
    log.info(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
    log.info(""String_Node_Str"");
  }
}","@Override public void anonymize(Properties databaseProperties,Properties anonymizerProperties) throws DatabaseAnonymizerException {
  log.info(""String_Node_Str"");
  IDBConnection dbConnection=DBConnectionFactory.createDBConnection(databaseProperties);
  Connection connection=dbConnection.connect(databaseProperties);
  String requirementFile=anonymizerProperties.getProperty(""String_Node_Str"");
  int batchSize=parseInt(anonymizerProperties.getProperty(""String_Node_Str""));
  Requirement requirement=null;
  try {
    JAXBContext jc=newInstance(Requirement.class);
    Unmarshaller unmarshaller=jc.createUnmarshaller();
    requirement=(Requirement)unmarshaller.unmarshal(new FileInputStream(new File(requirementFile)));
  }
 catch (  JAXBException je) {
    log.error(je.toString());
    throw new DatabaseAnonymizerException(je.toString(),je);
  }
catch (  FileNotFoundException ex) {
    java.util.logging.Logger.getLogger(DatabaseAnonymizer.class.getName()).log(Level.SEVERE,null,ex);
  }
  init();
  log.info(""String_Node_Str"" + requirement.getClient() + ""String_Node_Str""+ requirement.getVersion());
  for (  Table table : requirement.getTables()) {
    log.info(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
    PreparedStatement pstmt=null;
    Statement stmt=null;
    ResultSet rs=null;
    StringBuilder sql=new StringBuilder(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
    int batchCounter=0;
    for (    Column column : table.getColumns()) {
      sql.append(column.getName()).append(""String_Node_Str"");
    }
    if (sql.length() > 0) {
      sql.setLength(sql.length() - 1);
    }
    sql.append(""String_Node_Str"").append(table.getPKey()).append(""String_Node_Str"");
    final String updateString=sql.toString();
    try {
      stmt=connection.createStatement();
      rs=stmt.executeQuery(String.format(""String_Node_Str"",table.getName()));
      pstmt=connection.prepareStatement(updateString);
      while (rs.next()) {
        int id=rs.getInt(""String_Node_Str"");
        int index=0;
        for (        Column column : table.getColumns()) {
          String function=column.getFunction();
          if (function == null || function.equals(""String_Node_Str"")) {
            log.warn(""String_Node_Str"" + column + ""String_Node_Str"");
          }
 else {
            try {
              Class clazz=Functions.class;
              if (column.getParameters() == null) {
                Method method=clazz.getMethod(function,null);
                pstmt.setString(++index,method.invoke(null).toString());
              }
 else {
                for (                Parameter parameter : column.getParameters()) {
                  Method method=clazz.getMethod(function,String.class);
                  String result=method.invoke(null,parameter.getValue()).toString();
                  pstmt.setString(++index,result);
                }
              }
            }
 catch (            NoSuchMethodException|SecurityException|IllegalAccessException|IllegalArgumentException|InvocationTargetException ex) {
              ex.printStackTrace();
              log.error(ex.toString());
              try {
                stmt.close();
                if (pstmt != null) {
                  pstmt.close();
                }
                rs.close();
              }
 catch (              SQLException sqlex) {
                log.error(sqlex.toString());
              }
            }
          }
        }
        pstmt.setInt(++index,id);
        pstmt.addBatch();
        batchCounter++;
        if (batchCounter == batchSize) {
          pstmt.executeBatch();
          connection.commit();
          batchCounter=0;
        }
      }
      pstmt.executeBatch();
      connection.commit();
      stmt.close();
      pstmt.close();
      rs.close();
    }
 catch (    SQLException sqle) {
      log.error(sqle.toString());
      try {
        if (stmt != null) {
          stmt.close();
        }
        if (pstmt != null) {
          pstmt.close();
        }
        if (rs != null) {
          rs.close();
        }
      }
 catch (      SQLException sqlex) {
        log.error(sqlex.toString());
      }
    }
    log.info(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
    log.info(""String_Node_Str"");
  }
}",0.9760249340685688
85553,"public static String randomFirstName(String fileName) throws IOException {
  if (FIRST_NAME_LIST.isEmpty()) {
    try (BufferedReader br=new BufferedReader(new FileReader(fileName))){
      for (String line; (line=br.readLine()) != null; ) {
        FIRST_NAME_LIST.add(line);
      }
    }
   }
  int rand=nextIntInRange(0,FIRST_NAME_LIST.size() - 1);
  return FIRST_NAME_LIST.get(rand);
}","public static String randomFirstName(String fileName){
  if (FIRST_NAME_LIST.isEmpty()) {
    try (BufferedReader br=new BufferedReader(new FileReader(fileName))){
      for (String line; (line=br.readLine()) != null; ) {
        FIRST_NAME_LIST.add(line);
      }
    }
 catch (    FileNotFoundException ex) {
      log.error(ex.toString());
    }
catch (    IOException ex) {
      log.error(ex.toString());
    }
  }
  int rand=nextIntInRange(0,FIRST_NAME_LIST.size() - 1);
  return FIRST_NAME_LIST.get(rand);
}",0.8185840707964602
85554,"public static String randomStringFromFile(String fileName) throws IOException {
  log.info(fileName);
  if (STRING_LIST.isEmpty()) {
    try (BufferedReader br=new BufferedReader(new FileReader(fileName))){
      for (String line; (line=br.readLine()) != null; ) {
        STRING_LIST.add(line);
      }
    }
   }
  int rand=nextIntInRange(0,STRING_LIST.size() - 1);
  return STRING_LIST.get(rand);
}","public static String randomStringFromFile(String fileName) throws IOException {
  if (STRING_LIST.isEmpty()) {
    try (BufferedReader br=new BufferedReader(new FileReader(fileName))){
      for (String line; (line=br.readLine()) != null; ) {
        STRING_LIST.add(line);
      }
    }
   }
  int rand=nextIntInRange(0,STRING_LIST.size() - 1);
  return STRING_LIST.get(rand);
}",0.9717948717948718
85555,"@Override public void discover(Properties databaseProperties,Properties columnProperties) throws DatabaseAnonymizerException {
  log.info(""String_Node_Str"");
  IDBConnection dbConnection=DBConnectionFactory.createDBConnection(databaseProperties);
  Connection connection=dbConnection.connect(databaseProperties);
  ResultSet rs=null;
  List<ColumnMetaData> map=new ArrayList<>();
  try {
    DatabaseMetaData md=connection.getMetaData();
    rs=md.getTables(null,null,""String_Node_Str"",null);
    while (rs.next()) {
      String tableName=rs.getString(3);
      ResultSet resultSet=md.getColumns(null,null,tableName,null);
      while (resultSet.next()) {
        String columnName=resultSet.getString(""String_Node_Str"");
        String columnType=resultSet.getString(""String_Node_Str"");
        map.add(new ColumnMetaData(tableName,columnName,columnType));
      }
    }
    rs.close();
    connection.close();
  }
 catch (  SQLException e) {
    if (connection != null) {
      try {
        connection.close();
      }
 catch (      SQLException sqle) {
        log.error(sqle.toString());
      }
    }
    if (rs != null) {
      try {
        rs.close();
      }
 catch (      SQLException sql) {
        log.error(sql.toString());
      }
    }
    log.error(e.toString());
  }
  Configuration columnsConfiguration=null;
  try {
    columnsConfiguration=new PropertiesConfiguration(""String_Node_Str"");
  }
 catch (  ConfigurationException ex) {
    log.error(ColumnDiscoverer.class);
  }
  Iterator<String> iterator=columnsConfiguration.getKeys();
  List<String> suspList=toList(iterator);
  ArrayList<String> matches=new ArrayList<>();
  for (  String s : suspList) {
    Pattern p=compile(s);
    for (    ColumnMetaData pair : map) {
      String tableName=pair.getTableName();
      String columnName=pair.getColumnName();
      if (p.matcher(columnName).matches()) {
        matches.add(tableName + ""String_Node_Str"" + columnName);
      }
    }
  }
  log.info(""String_Node_Str"");
  log.info(""String_Node_Str"");
  log.info(""String_Node_Str"");
  for (  String entry : matches) {
    log.info(entry);
  }
}","@Override public void discover(Properties databaseProperties,Properties columnProperties) throws DatabaseAnonymizerException {
  log.info(""String_Node_Str"");
  IDBConnection dbConnection=DBConnectionFactory.createDBConnection(databaseProperties);
  Connection connection=dbConnection.connect(databaseProperties);
  ResultSet rs=null;
  List<ColumnMetaData> map=new ArrayList<>();
  try {
    DatabaseMetaData md=connection.getMetaData();
    if (databaseProperties.getProperty(""String_Node_Str"").equals(""String_Node_Str"")) {
      rs=md.getTables(null,null,null,new String[]{""String_Node_Str""});
    }
 else {
      rs=md.getTables(null,null,""String_Node_Str"",null);
    }
    while (rs.next()) {
      String tableName=rs.getString(3);
      ResultSet resultSet=null;
      if (databaseProperties.getProperty(""String_Node_Str"").equals(""String_Node_Str"")) {
        resultSet=md.getColumns(""String_Node_Str"",""String_Node_Str"",tableName,null);
      }
 else {
        resultSet=md.getColumns(null,null,tableName,null);
      }
      while (resultSet.next()) {
        String columnName=resultSet.getString(""String_Node_Str"");
        String columnType=resultSet.getString(""String_Node_Str"");
        map.add(new ColumnMetaData(tableName,columnName,columnType));
      }
    }
    rs.close();
    connection.close();
  }
 catch (  SQLException e) {
    if (connection != null) {
      try {
        connection.close();
      }
 catch (      SQLException sqle) {
        log.error(sqle.toString());
      }
    }
    if (rs != null) {
      try {
        rs.close();
      }
 catch (      SQLException sql) {
        log.error(sql.toString());
      }
    }
    log.error(e.toString());
  }
  Configuration columnsConfiguration=null;
  try {
    columnsConfiguration=new PropertiesConfiguration(""String_Node_Str"");
  }
 catch (  ConfigurationException ex) {
    log.error(ColumnDiscoverer.class);
  }
  Iterator<String> iterator=columnsConfiguration.getKeys();
  List<String> suspList=toList(iterator);
  ArrayList<String> matches=new ArrayList<>();
  for (  String s : suspList) {
    Pattern p=compile(s);
    for (    ColumnMetaData pair : map) {
      String tableName=pair.getTableName();
      String columnName=pair.getColumnName();
      if (p.matcher(columnName).matches()) {
        matches.add(tableName + ""String_Node_Str"" + columnName);
      }
    }
  }
  log.info(""String_Node_Str"");
  log.info(""String_Node_Str"");
  log.info(""String_Node_Str"");
  for (  String entry : matches) {
    log.info(entry);
  }
}",0.9003451251078516
85556,"@Override public void discover(Properties databaseProperties,Properties dataDiscoveryProperties) throws AnonymizerException {
  double probabilityThreshold=parseDouble(dataDiscoveryProperties.getProperty(""String_Node_Str""));
  log.info(""String_Node_Str"");
  IDBConnection dbConnection=DBConnectionFactory.createDBConnection(databaseProperties);
  Connection connection=dbConnection.connect(databaseProperties);
  List<ColumnMetaData> map=new ArrayList<>();
  try {
    DatabaseMetaData md=connection.getMetaData();
    ResultSet rs=md.getTables(null,null,""String_Node_Str"",null);
    while (rs.next()) {
      String tableName=rs.getString(3);
      ResultSet resultSet=md.getColumns(null,null,tableName,null);
      while (resultSet.next()) {
        String columnName=resultSet.getString(""String_Node_Str"");
        if (resultSet.getInt(5) == java.sql.Types.VARCHAR) {
          ColumnMetaData columnMetaData=new ColumnMetaData(tableName,columnName,""String_Node_Str"");
          map.add(columnMetaData);
        }
      }
    }
    rs.close();
  }
 catch (  SQLException e) {
    log.error(e);
  }
  InputStream modelInToken=null;
  InputStream modelIn=null;
  TokenizerModel modelToken=null;
  Tokenizer tokenizer=null;
  TokenNameFinderModel model=null;
  NameFinderME nameFinder=null;
  try {
    modelInToken=new FileInputStream(dataDiscoveryProperties.getProperty(""String_Node_Str""));
    modelIn=new FileInputStream(dataDiscoveryProperties.getProperty(""String_Node_Str""));
    modelToken=new TokenizerModel(modelInToken);
    tokenizer=new TokenizerME(modelToken);
    model=new TokenNameFinderModel(modelIn);
    nameFinder=new NameFinderME(model);
    modelInToken.close();
    modelIn.close();
  }
 catch (  FileNotFoundException ex) {
    log.error(ex.toString());
    try {
      if (modelInToken != null) {
        modelInToken.close();
      }
      if (modelIn != null) {
        modelIn.close();
      }
    }
 catch (    IOException ioe) {
      log.error(ioe.toString());
    }
  }
catch (  IOException ex) {
    log.error(ex.toString());
  }
  log.info(""String_Node_Str"");
  log.info(""String_Node_Str"");
  for (  ColumnMetaData pair : map) {
    if (pair.getColumnType().equals(""String_Node_Str"")) {
      String tableName=pair.getTableName();
      String columnName=pair.getColumnName();
      List<Double> probabilityList=new ArrayList<>();
      Statement stmt=null;
      ResultSet rs=null;
      try {
        stmt=connection.createStatement();
        rs=stmt.executeQuery(new StringBuilder(""String_Node_Str"").append(columnName).append(""String_Node_Str"").append(tableName).toString());
        while (rs.next()) {
          String sentence=rs.getString(1);
          if (sentence != null && !sentence.isEmpty()) {
            String tokens[]=tokenizer.tokenize(sentence);
            Span nameSpans[]=nameFinder.find(tokens);
            double[] spanProbs=nameFinder.probs(nameSpans);
            for (int i=0; i < nameSpans.length; i++) {
              probabilityList.add(spanProbs[i]);
            }
          }
        }
        rs.close();
        stmt.close();
      }
 catch (      SQLException sqle) {
        try {
          if (stmt != null) {
            stmt.close();
          }
          if (rs != null) {
            rs.close();
          }
        }
 catch (        SQLException sql) {
          log.error(sql.toString());
        }
        log.error(sqle.toString());
      }
      double averageProbability=calculateAverage(probabilityList);
      if ((averageProbability >= probabilityThreshold) && (averageProbability <= 0.90)) {
        log.info(""String_Node_Str"" + tableName + ""String_Node_Str""+ columnName+ ""String_Node_Str""+ averageProbability);
      }
    }
  }
}","@Override public void discover(Properties databaseProperties,Properties dataDiscoveryProperties) throws AnonymizerException {
  double probabilityThreshold=parseDouble(dataDiscoveryProperties.getProperty(""String_Node_Str""));
  log.info(""String_Node_Str"");
  IDBConnection dbConnection=DBConnectionFactory.createDBConnection(databaseProperties);
  Connection connection=dbConnection.connect(databaseProperties);
  ResultSet rs=null;
  List<ColumnMetaData> map=new ArrayList<>();
  try {
    DatabaseMetaData md=connection.getMetaData();
    if (databaseProperties.getProperty(""String_Node_Str"").equals(""String_Node_Str"")) {
      rs=md.getTables(null,null,null,new String[]{""String_Node_Str""});
    }
 else {
      rs=md.getTables(null,null,""String_Node_Str"",null);
    }
    while (rs.next()) {
      String tableName=rs.getString(3);
      ResultSet resultSet=null;
      if (databaseProperties.getProperty(""String_Node_Str"").equals(""String_Node_Str"")) {
        resultSet=md.getColumns(""String_Node_Str"",""String_Node_Str"",tableName,null);
      }
 else {
        resultSet=md.getColumns(null,null,tableName,null);
      }
      while (resultSet.next()) {
        String columnName=resultSet.getString(""String_Node_Str"");
        if (resultSet.getInt(5) == java.sql.Types.VARCHAR) {
          ColumnMetaData columnMetaData=new ColumnMetaData(tableName,columnName,""String_Node_Str"");
          map.add(columnMetaData);
        }
      }
    }
    rs.close();
  }
 catch (  SQLException e) {
    log.error(e);
  }
  InputStream modelInToken=null;
  InputStream modelIn=null;
  TokenizerModel modelToken=null;
  Tokenizer tokenizer=null;
  TokenNameFinderModel model=null;
  NameFinderME nameFinder=null;
  try {
    modelInToken=new FileInputStream(dataDiscoveryProperties.getProperty(""String_Node_Str""));
    modelIn=new FileInputStream(dataDiscoveryProperties.getProperty(""String_Node_Str""));
    modelToken=new TokenizerModel(modelInToken);
    tokenizer=new TokenizerME(modelToken);
    model=new TokenNameFinderModel(modelIn);
    nameFinder=new NameFinderME(model);
    modelInToken.close();
    modelIn.close();
  }
 catch (  FileNotFoundException ex) {
    log.error(ex.toString());
    try {
      if (modelInToken != null) {
        modelInToken.close();
      }
      if (modelIn != null) {
        modelIn.close();
      }
    }
 catch (    IOException ioe) {
      log.error(ioe.toString());
    }
  }
catch (  IOException ex) {
    log.error(ex.toString());
  }
  log.info(""String_Node_Str"");
  log.info(""String_Node_Str"");
  for (  ColumnMetaData pair : map) {
    if (pair.getColumnType().equals(""String_Node_Str"")) {
      String tableName=pair.getTableName();
      String columnName=pair.getColumnName();
      List<Double> probabilityList=new ArrayList<>();
      Statement stmt=null;
      ResultSet resultSet=null;
      try {
        stmt=connection.createStatement();
        resultSet=stmt.executeQuery(new StringBuilder(""String_Node_Str"").append(columnName).append(""String_Node_Str"").append(tableName).toString());
        while (resultSet.next()) {
          String sentence=resultSet.getString(1);
          if (sentence != null && !sentence.isEmpty()) {
            String tokens[]=tokenizer.tokenize(sentence);
            Span nameSpans[]=nameFinder.find(tokens);
            double[] spanProbs=nameFinder.probs(nameSpans);
            for (int i=0; i < nameSpans.length; i++) {
              probabilityList.add(spanProbs[i]);
            }
          }
        }
        resultSet.close();
        stmt.close();
      }
 catch (      SQLException sqle) {
        try {
          if (stmt != null) {
            stmt.close();
          }
          if (resultSet != null) {
            resultSet.close();
          }
        }
 catch (        SQLException sql) {
          log.error(sql.toString());
        }
        log.error(sqle.toString());
      }
      double averageProbability=calculateAverage(probabilityList);
      if ((averageProbability >= probabilityThreshold) && (averageProbability <= 0.90)) {
        log.info(""String_Node_Str"" + tableName + ""String_Node_Str""+ columnName+ ""String_Node_Str""+ averageProbability);
      }
    }
  }
}",0.934903748733536
85557,"/** 
 * Establishes database connection
 * @param properties
 * @return Connection
 * @throws DatabaseAnonymizerException 
 */
@Override public Connection connect(Properties properties) throws DatabaseAnonymizerException {
  String driver=properties.getProperty(""String_Node_Str"");
  String vendor=properties.getProperty(""String_Node_Str"");
  String url=properties.getProperty(""String_Node_Str"");
  String userName=properties.getProperty(""String_Node_Str"");
  String password=properties.getProperty(""String_Node_Str"");
  log.debug(""String_Node_Str"" + driver);
  log.debug(""String_Node_Str"" + vendor);
  log.debug(""String_Node_Str"" + url);
  log.debug(""String_Node_Str"" + userName);
  try {
    forName(driver);
  }
 catch (  ClassNotFoundException cnfe) {
    log.error(cnfe.toString());
    throw new DatabaseAnonymizerException(cnfe.toString(),cnfe);
  }
  StringBuilder sqlServerURL=new StringBuilder(url);
  sqlServerURL.append(""String_Node_Str"").append(userName).append(""String_Node_Str"").append(password);
  Connection conn=null;
  try {
    log.info(""String_Node_Str"" + sqlServerURL.toString());
    conn=getConnection(sqlServerURL.toString());
    conn.setAutoCommit(false);
  }
 catch (  SQLException sqle) {
    log.error(sqle.toString());
    if (conn != null) {
      try {
        conn.close();
      }
 catch (      SQLException sql) {
        log.error(sql.toString());
      }
    }
    throw new DatabaseAnonymizerException(sqle.toString(),sqle);
  }
  return conn;
}","/** 
 * Establishes database connection
 * @param properties
 * @return Connection
 * @throws DatabaseAnonymizerException 
 */
@Override public Connection connect(Properties properties) throws DatabaseAnonymizerException {
  String driver=properties.getProperty(""String_Node_Str"");
  String vendor=properties.getProperty(""String_Node_Str"");
  String url=properties.getProperty(""String_Node_Str"");
  String userName=properties.getProperty(""String_Node_Str"");
  String password=properties.getProperty(""String_Node_Str"");
  log.debug(""String_Node_Str"" + driver);
  log.debug(""String_Node_Str"" + vendor);
  log.debug(""String_Node_Str"" + url);
  log.debug(""String_Node_Str"" + userName);
  try {
    forName(driver);
  }
 catch (  ClassNotFoundException cnfe) {
    log.error(cnfe.toString());
    throw new DatabaseAnonymizerException(cnfe.toString(),cnfe);
  }
  StringBuilder sqlServerURL=new StringBuilder(url);
  sqlServerURL.append(""String_Node_Str"").append(userName).append(""String_Node_Str"").append(password);
  Connection conn=null;
  try {
    log.info(""String_Node_Str"" + url);
    conn=getConnection(sqlServerURL.toString());
    conn.setAutoCommit(false);
  }
 catch (  SQLException sqle) {
    log.error(sqle.toString());
    if (conn != null) {
      try {
        conn.close();
      }
 catch (      SQLException sql) {
        log.error(sql.toString());
      }
    }
    throw new DatabaseAnonymizerException(sqle.toString(),sqle);
  }
  return conn;
}",0.991180461329715
85558,"public static IDBConnection createDBConnection(final Properties databaseProperties) throws DatabaseAnonymizerException {
  String database=databaseProperties.getProperty(""String_Node_Str"");
  if (database.equalsIgnoreCase(""String_Node_Str"")) {
    return new MySQLDBConnection();
  }
 else   if (database.equalsIgnoreCase(""String_Node_Str"")) {
    return new MSSQLDBConnection();
  }
 else   if (database.equalsIgnoreCase(""String_Node_Str"")) {
    return new OracleDBConnection();
  }
  throw new IllegalArgumentException(""String_Node_Str"" + database + ""String_Node_Str"");
}","public static IDBConnection createDBConnection(final Properties databaseProperties) throws DatabaseAnonymizerException {
  String vendor=databaseProperties.getProperty(""String_Node_Str"");
  if (vendor.equalsIgnoreCase(""String_Node_Str"")) {
    return new MySQLDBConnection();
  }
 else   if (vendor.equalsIgnoreCase(""String_Node_Str"")) {
    return new MSSQLDBConnection();
  }
 else   if (vendor.equalsIgnoreCase(""String_Node_Str"")) {
    return new OracleDBConnection();
  }
  throw new IllegalArgumentException(""String_Node_Str"" + vendor + ""String_Node_Str"");
}",0.936731107205624
85559,"/** 
 * Establishes database connection
 * @param properties
 * @return Connection
 * @throws DatabaseAnonymizerException 
 */
@Override public Connection connect(Properties properties) throws DatabaseAnonymizerException {
  String driver=properties.getProperty(""String_Node_Str"");
  String database=properties.getProperty(""String_Node_Str"");
  String url=properties.getProperty(""String_Node_Str"");
  String userName=properties.getProperty(""String_Node_Str"");
  String password=properties.getProperty(""String_Node_Str"");
  log.debug(""String_Node_Str"" + driver);
  log.debug(""String_Node_Str"" + database);
  log.debug(""String_Node_Str"" + url);
  log.debug(""String_Node_Str"" + userName);
  try {
    forName(driver);
  }
 catch (  ClassNotFoundException cnfe) {
    log.error(cnfe.toString());
    throw new DatabaseAnonymizerException(cnfe.toString(),cnfe);
  }
  Connection conn=null;
  try {
    conn=getConnection(url,userName,password);
    conn.setAutoCommit(false);
  }
 catch (  SQLException sqle) {
    log.error(sqle.toString());
    if (conn != null) {
      try {
        conn.close();
      }
 catch (      SQLException sql) {
        log.error(sql.toString());
      }
    }
    throw new DatabaseAnonymizerException(sqle.toString(),sqle);
  }
  return conn;
}","/** 
 * Establishes database connection
 * @param properties
 * @return Connection
 * @throws DatabaseAnonymizerException 
 */
@Override public Connection connect(Properties properties) throws DatabaseAnonymizerException {
  String driver=properties.getProperty(""String_Node_Str"");
  String vendor=properties.getProperty(""String_Node_Str"");
  String url=properties.getProperty(""String_Node_Str"");
  String userName=properties.getProperty(""String_Node_Str"");
  String password=properties.getProperty(""String_Node_Str"");
  log.debug(""String_Node_Str"" + driver);
  log.debug(""String_Node_Str"" + vendor);
  log.debug(""String_Node_Str"" + url);
  log.debug(""String_Node_Str"" + userName);
  try {
    forName(driver);
  }
 catch (  ClassNotFoundException cnfe) {
    log.error(cnfe.toString());
    throw new DatabaseAnonymizerException(cnfe.toString(),cnfe);
  }
  StringBuilder sqlServerURL=new StringBuilder(url);
  sqlServerURL.append(""String_Node_Str"").append(userName).append(""String_Node_Str"").append(password);
  Connection conn=null;
  try {
    log.info(""String_Node_Str"" + sqlServerURL.toString());
    conn=getConnection(sqlServerURL.toString());
    conn.setAutoCommit(false);
  }
 catch (  SQLException sqle) {
    log.error(sqle.toString());
    if (conn != null) {
      try {
        conn.close();
      }
 catch (      SQLException sql) {
        log.error(sql.toString());
      }
    }
    throw new DatabaseAnonymizerException(sqle.toString(),sqle);
  }
  return conn;
}",0.7097242380261248
85560,"public void discover(String databasePropertyFile){
  discover(""String_Node_Str"");
}","public void discover(String databasePropertyFile){
  this.discover(""String_Node_Str"");
}",0.9707602339181286
85561,"@Override public void anonymize(String databasePropertyFile,String anonymizerPropertyFile) throws DatabaseAnonymizerException {
  Configuration configuration=null;
  try {
    configuration=new PropertiesConfiguration(databasePropertyFile);
  }
 catch (  ConfigurationException ex) {
    log.error(ex.toString());
    throw new DatabaseAnonymizerException(ex.toString());
  }
  String driver=configuration.getString(""String_Node_Str"");
  String database=configuration.getString(""String_Node_Str"");
  String url=configuration.getString(""String_Node_Str"");
  String userName=configuration.getString(""String_Node_Str"");
  String password=configuration.getString(""String_Node_Str"");
  log.debug(""String_Node_Str"" + driver);
  log.debug(""String_Node_Str"" + database);
  log.debug(""String_Node_Str"" + url);
  log.debug(""String_Node_Str"" + userName);
  log.info(""String_Node_Str"");
  Connection connection=null;
  try {
    forName(driver).newInstance();
    connection=getConnection(url,userName,password);
    connection.setAutoCommit(false);
  }
 catch (  InstantiationException|ClassNotFoundException|IllegalAccessException|SQLException ine) {
    log.error(ine.toString());
    throw new DatabaseAnonymizerException(ine.toString());
  }
  Properties props=null;
  try {
    props=loadProperties(anonymizerPropertyFile);
  }
 catch (  UnsupportedEncodingException uex) {
    log.error(uex.toString());
  }
catch (  IOException ex) {
    log.error(ex.toString());
  }
  if (props == null) {
    throw new DatabaseAnonymizerException(""String_Node_Str"");
  }
  String requirementFile=props.getProperty(""String_Node_Str"");
  int batchSize=parseInt(props.getProperty(""String_Node_Str""));
  Requirement requirement=null;
  try {
    JAXBContext jc=newInstance(Requirement.class);
    Unmarshaller unmarshaller=jc.createUnmarshaller();
    requirement=(Requirement)unmarshaller.unmarshal(new File(requirementFile));
  }
 catch (  JAXBException je) {
    log.error(je.toString());
    throw new DatabaseAnonymizerException(je.toString());
  }
  init();
  log.info(""String_Node_Str"" + requirement.getClient() + ""String_Node_Str""+ requirement.getVersion());
  for (  Table table : requirement.getTables()) {
    log.info(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
    PreparedStatement pstmt=null;
    Statement stmt=null;
    ResultSet rs=null;
    StringBuilder sql=new StringBuilder(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
    int batchCounter=0;
    for (    Column column : table.getColumns()) {
      sql.append(column.getName()).append(""String_Node_Str"");
    }
    if (sql.length() > 0) {
      sql.setLength(sql.length() - 1);
    }
    sql.append(""String_Node_Str"").append(table.getPKey()).append(""String_Node_Str"");
    String updateString=sql.toString();
    try {
      stmt=connection.createStatement();
      rs=stmt.executeQuery(""String_Node_Str"" + table.getName());
      pstmt=connection.prepareStatement(updateString);
      while (rs.next()) {
        int id=rs.getInt(""String_Node_Str"");
        int index=0;
        for (        Column column : table.getColumns()) {
          String function=column.getFunction();
          if (function == null || function.equals(""String_Node_Str"")) {
            log.warn(""String_Node_Str"" + column + ""String_Node_Str"");
          }
 else {
            try {
              Class clazz=Functions.class;
              if (column.getParameters() == null) {
                Method method=clazz.getMethod(function,null);
                pstmt.setString(++index,method.invoke(null).toString());
              }
 else {
                for (                Parameter parameter : column.getParameters()) {
                  Method method=clazz.getMethod(function,String.class);
                  String result=method.invoke(null,parameter.getValue()).toString();
                  pstmt.setString(++index,result);
                }
              }
            }
 catch (            NoSuchMethodException|SecurityException|IllegalAccessException|IllegalArgumentException|InvocationTargetException ex) {
              log.error(ex.toString());
            }
          }
        }
        pstmt.setInt(++index,id);
        pstmt.addBatch();
        batchCounter++;
        if (batchCounter == batchSize) {
          pstmt.executeBatch();
          connection.commit();
          batchCounter=0;
        }
      }
      pstmt.executeBatch();
      connection.commit();
    }
 catch (    SQLException sqle) {
      log.error(sqle.toString());
      try {
        if (stmt != null) {
          stmt.close();
        }
        if (pstmt != null) {
          pstmt.close();
        }
        if (rs != null) {
          rs.close();
        }
      }
 catch (      SQLException sqlex) {
        log.error(sqlex.toString());
      }
    }
    log.info(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
    log.info(""String_Node_Str"");
  }
}","@Override public void anonymize(String databasePropertyFile,String anonymizerPropertyFile) throws DatabaseAnonymizerException {
  Configuration configuration=null;
  try {
    configuration=new PropertiesConfiguration(databasePropertyFile);
  }
 catch (  ConfigurationException ex) {
    log.error(ex.toString());
    throw new DatabaseAnonymizerException(ex.toString());
  }
  String driver=configuration.getString(""String_Node_Str"");
  String database=configuration.getString(""String_Node_Str"");
  String url=configuration.getString(""String_Node_Str"");
  String userName=configuration.getString(""String_Node_Str"");
  String password=configuration.getString(""String_Node_Str"");
  log.debug(""String_Node_Str"" + driver);
  log.debug(""String_Node_Str"" + database);
  log.debug(""String_Node_Str"" + url);
  log.debug(""String_Node_Str"" + userName);
  log.info(""String_Node_Str"");
  Connection connection=null;
  try {
    forName(driver).newInstance();
    connection=getConnection(url,userName,password);
    connection.setAutoCommit(false);
  }
 catch (  InstantiationException|ClassNotFoundException|IllegalAccessException|SQLException ine) {
    log.error(ine.toString());
    throw new DatabaseAnonymizerException(ine.toString());
  }
  Properties props=null;
  try {
    props=loadProperties(anonymizerPropertyFile);
  }
 catch (  UnsupportedEncodingException uex) {
    log.error(uex.toString());
  }
catch (  IOException ex) {
    log.error(ex.toString());
  }
  if (props == null) {
    throw new DatabaseAnonymizerException(""String_Node_Str"");
  }
  String requirementFile=props.getProperty(""String_Node_Str"");
  int batchSize=parseInt(props.getProperty(""String_Node_Str""));
  Requirement requirement=null;
  try {
    JAXBContext jc=newInstance(Requirement.class);
    Unmarshaller unmarshaller=jc.createUnmarshaller();
    requirement=(Requirement)unmarshaller.unmarshal(new File(requirementFile));
  }
 catch (  JAXBException je) {
    log.error(je.toString());
    throw new DatabaseAnonymizerException(je.toString());
  }
  init();
  log.info(""String_Node_Str"" + requirement.getClient() + ""String_Node_Str""+ requirement.getVersion());
  for (  Table table : requirement.getTables()) {
    log.info(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
    PreparedStatement pstmt=null;
    Statement stmt=null;
    ResultSet rs=null;
    StringBuilder sql=new StringBuilder(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
    int batchCounter=0;
    for (    Column column : table.getColumns()) {
      sql.append(column.getName()).append(""String_Node_Str"");
    }
    if (sql.length() > 0) {
      sql.setLength(sql.length() - 1);
    }
    sql.append(""String_Node_Str"").append(table.getPKey()).append(""String_Node_Str"");
    final String updateString=sql.toString();
    try {
      stmt=connection.createStatement();
      final String selectStmt=""String_Node_Str"" + table.getName();
      rs=stmt.executeQuery(selectStmt);
      pstmt=connection.prepareStatement(updateString);
      while (rs.next()) {
        int id=rs.getInt(""String_Node_Str"");
        int index=0;
        for (        Column column : table.getColumns()) {
          String function=column.getFunction();
          if (function == null || function.equals(""String_Node_Str"")) {
            log.warn(""String_Node_Str"" + column + ""String_Node_Str"");
          }
 else {
            try {
              Class clazz=Functions.class;
              if (column.getParameters() == null) {
                Method method=clazz.getMethod(function,null);
                pstmt.setString(++index,method.invoke(null).toString());
              }
 else {
                for (                Parameter parameter : column.getParameters()) {
                  Method method=clazz.getMethod(function,String.class);
                  String result=method.invoke(null,parameter.getValue()).toString();
                  pstmt.setString(++index,result);
                }
              }
            }
 catch (            NoSuchMethodException|SecurityException|IllegalAccessException|IllegalArgumentException|InvocationTargetException ex) {
              log.error(ex.toString());
            }
          }
        }
        pstmt.setInt(++index,id);
        pstmt.addBatch();
        batchCounter++;
        if (batchCounter == batchSize) {
          pstmt.executeBatch();
          connection.commit();
          batchCounter=0;
        }
      }
      pstmt.executeBatch();
      connection.commit();
    }
 catch (    SQLException sqle) {
      log.error(sqle.toString());
      try {
        if (stmt != null) {
          stmt.close();
        }
        if (pstmt != null) {
          pstmt.close();
        }
        if (rs != null) {
          rs.close();
        }
      }
 catch (      SQLException sqlex) {
        log.error(sqlex.toString());
      }
    }
    log.info(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
    log.info(""String_Node_Str"");
  }
}",0.987631792376318
85562,"/** 
 * Discovers data or data containers with data which can be be the subject  for data anonymization.
 * @param databasePropertyFile
 * @param columnPropertyFile
 */
public void discover(String databasePropertyFile,String columnPropertyFile);","/** 
 * Discovers data or data containers with data which can be be the subject  for data anonymization.
 * @param databasePropertyFile
 * @param columnPropertyFile
 */
public void discover(String databasePropertyFile,String columnPropertyFile) throws AnonymizerException ;",0.945945945945946
85563,"@Override public void anonymize(String propertyFile){
  Configuration configuration=null;
  try {
    configuration=new PropertiesConfiguration(propertyFile);
  }
 catch (  ConfigurationException ex) {
    log.error(ColumnDiscoverer.class);
  }
  String driver=configuration.getString(""String_Node_Str"");
  String database=configuration.getString(""String_Node_Str"");
  String url=configuration.getString(""String_Node_Str"");
  String userName=configuration.getString(""String_Node_Str"");
  String password=configuration.getString(""String_Node_Str"");
  log.debug(""String_Node_Str"" + driver);
  log.debug(""String_Node_Str"" + database);
  log.debug(""String_Node_Str"" + url);
  log.debug(""String_Node_Str"" + userName);
  log.info(""String_Node_Str"");
  Connection connection=null;
  try {
    Class.forName(driver).newInstance();
    connection=DriverManager.getConnection(url,userName,password);
    connection.setAutoCommit(false);
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + e.toString(),e);
  }
  Requirement requirement=null;
  try {
    JAXBContext jc=JAXBContext.newInstance(Requirement.class);
    Unmarshaller unmarshaller=jc.createUnmarshaller();
    requirement=(Requirement)unmarshaller.unmarshal(new File(""String_Node_Str""));
  }
 catch (  JAXBException je) {
    log.error(je.toString());
  }
  Functions.init();
  log.info(""String_Node_Str"" + requirement.getClient() + ""String_Node_Str""+ requirement.getVersion());
  for (  Table table : requirement.getTables()) {
    log.info(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
    PreparedStatement pstmt=null;
    Statement stmt=null;
    ResultSet rs=null;
    StringBuilder sql=new StringBuilder(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
    int batchCounter=0;
    for (    Column column : table.getColumns()) {
      sql.append(column.getName() + ""String_Node_Str"");
    }
    if (sql.length() > 0) {
      sql.setLength(sql.length() - 1);
    }
    sql.append(""String_Node_Str"").append(table.getPKey()).append(""String_Node_Str"");
    String updateString=sql.toString();
    try {
      stmt=connection.createStatement();
      rs=stmt.executeQuery(""String_Node_Str"" + table.getName());
      pstmt=connection.prepareStatement(updateString);
      while (rs.next()) {
        int id=rs.getInt(""String_Node_Str"");
        int index=0;
        for (        Column column : table.getColumns()) {
          log.info(""String_Node_Str"" + column.getName() + ""String_Node_Str"");
          String function=column.getFunction();
          if (function == null || function.equals(""String_Node_Str"")) {
            log.warn(""String_Node_Str"" + column + ""String_Node_Str"");
          }
 else {
            try {
              if (column.getParameters().isEmpty()) {
                log.info(""String_Node_Str"" + function + ""String_Node_Str"");
                pstmt.setString(++index,Functions.class.getMethod(function,String.class).invoke(null).toString());
              }
 else {
                log.info(""String_Node_Str"" + function + ""String_Node_Str"");
                for (                Parameter parameter : column.getParameters()) {
                  log.info(""String_Node_Str"" + parameter.getName());
                  log.info(""String_Node_Str"" + parameter.getValue());
                  Class clazz=Functions.class;
                  Method method=clazz.getMethod(function,String.class);
                  String result=method.invoke(null,parameter.getValue()).toString();
                  log.info(result);
                  pstmt.setString(++index,result);
                }
              }
            }
 catch (            NoSuchMethodException|SecurityException|IllegalAccessException|IllegalArgumentException|InvocationTargetException ex) {
              java.util.logging.Logger.getLogger(DatabaseAnonymizer.class.getName()).log(Level.SEVERE,null,ex);
            }
          }
        }
        pstmt.setInt(++index,id);
        pstmt.addBatch();
        batchCounter++;
        if (batchCounter == 1000) {
          pstmt.executeBatch();
          connection.commit();
          batchCounter=0;
        }
      }
      pstmt.executeBatch();
      connection.commit();
    }
 catch (    SQLException sqle) {
      log.error(sqle.toString());
      try {
        if (stmt != null) {
          stmt.close();
        }
        if (pstmt != null) {
          pstmt.close();
        }
        if (rs != null) {
          rs.close();
        }
      }
 catch (      SQLException sqlex) {
        log.error(sqlex.toString());
      }
    }
    log.info(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
    log.info(""String_Node_Str"");
  }
}","@Override public void anonymize(String propertyFile){
  Configuration configuration=null;
  try {
    configuration=new PropertiesConfiguration(propertyFile);
  }
 catch (  ConfigurationException ex) {
    log.error(ColumnDiscoverer.class);
  }
  String driver=configuration.getString(""String_Node_Str"");
  String database=configuration.getString(""String_Node_Str"");
  String url=configuration.getString(""String_Node_Str"");
  String userName=configuration.getString(""String_Node_Str"");
  String password=configuration.getString(""String_Node_Str"");
  log.debug(""String_Node_Str"" + driver);
  log.debug(""String_Node_Str"" + database);
  log.debug(""String_Node_Str"" + url);
  log.debug(""String_Node_Str"" + userName);
  log.info(""String_Node_Str"");
  Connection connection=null;
  try {
    Class.forName(driver).newInstance();
    connection=DriverManager.getConnection(url,userName,password);
    connection.setAutoCommit(false);
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + e.toString(),e);
  }
  Requirement requirement=null;
  try {
    JAXBContext jc=JAXBContext.newInstance(Requirement.class);
    Unmarshaller unmarshaller=jc.createUnmarshaller();
    requirement=(Requirement)unmarshaller.unmarshal(new File(""String_Node_Str""));
  }
 catch (  JAXBException je) {
    log.error(je.toString());
  }
  Functions.init();
  log.info(""String_Node_Str"" + requirement.getClient() + ""String_Node_Str""+ requirement.getVersion());
  for (  Table table : requirement.getTables()) {
    log.info(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
    PreparedStatement pstmt=null;
    Statement stmt=null;
    ResultSet rs=null;
    StringBuilder sql=new StringBuilder(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
    int batchCounter=0;
    for (    Column column : table.getColumns()) {
      sql.append(column.getName() + ""String_Node_Str"");
    }
    if (sql.length() > 0) {
      sql.setLength(sql.length() - 1);
    }
    sql.append(""String_Node_Str"").append(table.getPKey()).append(""String_Node_Str"");
    String updateString=sql.toString();
    try {
      stmt=connection.createStatement();
      rs=stmt.executeQuery(""String_Node_Str"" + table.getName());
      pstmt=connection.prepareStatement(updateString);
      while (rs.next()) {
        int id=rs.getInt(""String_Node_Str"");
        int index=0;
        for (        Column column : table.getColumns()) {
          log.info(""String_Node_Str"" + column.getName() + ""String_Node_Str"");
          String function=column.getFunction();
          if (function == null || function.equals(""String_Node_Str"")) {
            log.warn(""String_Node_Str"" + column + ""String_Node_Str"");
          }
 else {
            try {
              if (column.getParameters() == null) {
                log.info(""String_Node_Str"" + function + ""String_Node_Str"");
                pstmt.setString(++index,Functions.class.getMethod(function,null).invoke(null).toString());
              }
 else {
                log.info(""String_Node_Str"" + function + ""String_Node_Str"");
                for (                Parameter parameter : column.getParameters()) {
                  log.info(""String_Node_Str"" + parameter.getName());
                  log.info(""String_Node_Str"" + parameter.getValue());
                  Class clazz=Functions.class;
                  Method method=clazz.getMethod(function,String.class);
                  String result=method.invoke(null,parameter.getValue()).toString();
                  log.info(result);
                  pstmt.setString(++index,result);
                }
              }
            }
 catch (            NoSuchMethodException|SecurityException|IllegalAccessException|IllegalArgumentException|InvocationTargetException ex) {
              java.util.logging.Logger.getLogger(DatabaseAnonymizer.class.getName()).log(Level.SEVERE,null,ex);
            }
          }
        }
        pstmt.setInt(++index,id);
        pstmt.addBatch();
        batchCounter++;
        if (batchCounter == 1000) {
          pstmt.executeBatch();
          connection.commit();
          batchCounter=0;
        }
      }
      pstmt.executeBatch();
      connection.commit();
    }
 catch (    SQLException sqle) {
      log.error(sqle.toString());
      try {
        if (stmt != null) {
          stmt.close();
        }
        if (pstmt != null) {
          pstmt.close();
        }
        if (rs != null) {
          rs.close();
        }
      }
 catch (      SQLException sqlex) {
        log.error(sqlex.toString());
      }
    }
    log.info(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
    log.info(""String_Node_Str"");
  }
}",0.9963456577815992
85564,"public List<Parameter> getParameters(){
  return Collections.unmodifiableList(this.paramters);
}","public List<Parameter> getParameters(){
  if (this.paramters != null) {
    return Collections.unmodifiableList(this.paramters);
  }
  return null;
}",0.7836734693877551
85565,"public String getName(){
  return this.name;
}","/** 
 * Getter method for name attribute
 * @return String
 */
public String getName(){
  return this.name;
}",0.5935483870967742
85566,"public String getReturnType(){
  return this.returnType;
}","/** 
 * Getter method for returnType attribute
 * @return String
 */
public String getReturnType(){
  return this.returnType;
}",0.6270270270270271
85567,"public String getFunction(){
  return this.function;
}","/** 
 * Getter method for function attribute
 * @return String
 */
public String getFunction(){
  return this.function;
}",0.6171428571428571
85568,"public List<Parameter> getParameters(){
  if (this.paramters != null) {
    return Collections.unmodifiableList(this.paramters);
  }
  return null;
}","/** 
 * Getter method for Parameters attribute
 * @return List
 */
public List<Parameter> getParameters(){
  if (this.paramters != null) {
    return Collections.unmodifiableList(this.paramters);
  }
  return null;
}",0.8164383561643835
85569,"public String getValue(){
  return this.value;
}","/** 
 * Getter method for value attribute
 * @return String
 */
public String getValue(){
  return this.value;
}",0.6
85570,"public String getName(){
  return this.name;
}","/** 
 * Getter method for name attribute
 * @return String
 */
public String getName(){
  return this.name;
}",0.5935483870967742
85571,"public String getType(){
  return this.type;
}","/** 
 * Getter method for type attribute
 * @return String
 */
public String getType(){
  return this.type;
}",0.5935483870967742
85572,"public String getVersion(){
  return this.version;
}","/** 
 * Getter method for version attribute
 * @return String
 */
public String getVersion(){
  return this.version;
}",0.611764705882353
85573,"public List<Table> getTables(){
  return Collections.unmodifiableList(this.tables);
}","/** 
 * Getter method for tables attribute
 * @return List
 */
public List<Table> getTables(){
  if (this.tables != null) {
    return Collections.unmodifiableList(this.tables);
  }
  return null;
}",0.6007067137809188
85574,"public String getClient(){
  return this.client;
}","/** 
 * Getter method for client attribute
 * @return String
 */
public String getClient(){
  return this.client;
}",0.6060606060606061
85575,"public String getName(){
  return this.name;
}","/** 
 * Getter method for name attribute
 * @return String
 */
public String getName(){
  return this.name;
}",0.5935483870967742
85576,"public String getPKey(){
  return this.pkey;
}","/** 
 * Getter method for PKey attribute
 * @return String
 */
public String getPKey(){
  return this.pkey;
}",0.5935483870967742
85577,"public List<Column> getColumns(){
  return Collections.unmodifiableList(this.columns);
}","/** 
 * Getter method for columns attribute
 * @return 
 */
public List<Column> getColumns(){
  if (this.columns != null) {
    return Collections.unmodifiableList(this.columns);
  }
  return null;
}",0.6132404181184669
85578,"boolean updateFromNewBroadcast(MasternodeBroadcast mnb){
  if (mnb.sigTime > sigTime) {
    pubkey2=mnb.pubkey2;
    sigTime=mnb.sigTime;
    sig=mnb.sig;
    protocolVersion=mnb.protocolVersion;
    address=mnb.address.duplicate();
    lastTimeChecked=0;
    int nDoS=0;
    if (mnb.lastPing == new MasternodePing(params) || (!mnb.lastPing.equals(new MasternodePing(params)) && mnb.lastPing.checkAndUpdate(false))) {
      lastPing=mnb.lastPing;
      params.masternodeManager.mapSeenMasternodePing.put(lastPing.getHash(),lastPing);
    }
    return true;
  }
  return false;
}","boolean updateFromNewBroadcast(MasternodeBroadcast mnb){
  if (mnb.sigTime > sigTime) {
    pubkey2=mnb.pubkey2;
    sigTime=mnb.sigTime;
    sig=mnb.sig;
    protocolVersion=mnb.protocolVersion;
    address=mnb.address.duplicate();
    lastTimeChecked=0;
    int nDoS=0;
    if (mnb.lastPing == new MasternodePing(params) || (!mnb.lastPing.equals(new MasternodePing(params)) && mnb.lastPing.checkAndUpdate(false))) {
      lastPing=mnb.lastPing;
      params.masternodeManager.updateMasternodePing(lastPing);
    }
    return true;
  }
  return false;
}",0.9664310954063604
85579,"void processMasternodePing(Peer peer,MasternodePing mnp){
  if (mapSeenMasternodePing.containsKey(mnp.getHash()))   return;
  mapSeenMasternodePing.put(mnp.getHash(),mnp);
  int nDoS=0;
  if (mnp.checkAndUpdate())   return;
  if (nDoS > 0) {
  }
 else {
    Masternode pmn=find(mnp.vin);
    if (pmn != null)     return;
  }
  askForMN(peer,mnp.vin);
}","void processMasternodePing(Peer peer,MasternodePing mnp){
  if (mapSeenMasternodePing.containsKey(mnp.getHash()))   return;
  lock.lock();
  try {
    mapSeenMasternodePing.put(mnp.getHash(),mnp);
  }
  finally {
    lock.unlock();
  }
  int nDoS=0;
  if (mnp.checkAndUpdate())   return;
  if (nDoS > 0) {
  }
 else {
    Masternode pmn=find(mnp.vin);
    if (pmn != null)     return;
  }
  askForMN(peer,mnp.vin);
}",0.9166666666666666
85580,"public int calculateMessageSizeInBytes(){
  int size=0;
  size+=VarInt.sizeOf(vMasternodes.size());
  for (  Masternode mn : vMasternodes) {
    size+=mn.calculateMessageSizeInBytes();
  }
  size+=VarInt.sizeOf(mAskedUsForMasternodeList.size());
  for (  NetAddress na : mAskedUsForMasternodeList.keySet()) {
    size+=na.MESSAGE_SIZE;
    size+=8;
  }
  return size;
}","public int calculateMessageSizeInBytes(){
  int size=0;
  lock.lock();
  try {
    size+=VarInt.sizeOf(vMasternodes.size());
    for (    Masternode mn : vMasternodes) {
      size+=mn.calculateMessageSizeInBytes();
    }
    size+=VarInt.sizeOf(mAskedUsForMasternodeList.size());
    for (    NetAddress na : mAskedUsForMasternodeList.keySet()) {
      size+=na.MESSAGE_SIZE;
      size+=8;
    }
    return size;
  }
  finally {
    lock.unlock();
  }
}",0.8956310679611651
85581,"void processMasternodeBroadcast(MasternodeBroadcast mnb){
  if (mapSeenMasternodeBroadcast.containsKey(mnb.getHash())) {
    params.masternodeSync.addedMasternodeList(mnb.getHash());
    return;
  }
  mapSeenMasternodeBroadcast.put(mnb.getHash(),mnb);
  int nDoS=0;
  if (!mnb.checkAndUpdate()) {
    return;
  }
  if (!DarkSendSigner.isVinAssociatedWithPubkey(params,mnb.vin,mnb.pubkey)) {
    log.info(""String_Node_Str"");
    return;
  }
  if (mnb.checkInputsAndAdd()) {
  }
 else {
    log.info(""String_Node_Str"" + mnb.address.toString());
  }
}","void processMasternodeBroadcast(MasternodeBroadcast mnb){
  lock.lock();
  try {
    if (mapSeenMasternodeBroadcast.containsKey(mnb.getHash())) {
      params.masternodeSync.addedMasternodeList(mnb.getHash());
      return;
    }
    mapSeenMasternodeBroadcast.put(mnb.getHash(),mnb);
  }
  finally {
    lock.unlock();
  }
  int nDoS=0;
  if (!mnb.checkAndUpdate()) {
    return;
  }
  if (!DarkSendSigner.isVinAssociatedWithPubkey(params,mnb.vin,mnb.pubkey)) {
    log.info(""String_Node_Str"");
    return;
  }
  if (mnb.checkInputsAndAdd()) {
  }
 else {
    log.info(""String_Node_Str"" + mnb.address.toString());
  }
}",0.9178082191780822
85582,"void processSyncStatusCount(SyncStatusCount ssc){
  if (RequestedMasternodeAssets >= MASTERNODE_SYNC_FINISHED)   return;
switch (ssc.itemId) {
case (MASTERNODE_SYNC_LIST):
    if (ssc.itemId != RequestedMasternodeAssets)     return;
  sumMasternodeList+=ssc.count;
countMasternodeList++;
break;
case (MASTERNODE_SYNC_MNW):
if (ssc.itemId != RequestedMasternodeAssets) return;
sumMasternodeWinner+=ssc.count;
countMasternodeWinner++;
break;
case (MASTERNODE_SYNC_BUDGET_PROP):
if (RequestedMasternodeAssets != MASTERNODE_SYNC_BUDGET) return;
sumBudgetItemProp+=ssc.count;
countBudgetItemProp++;
break;
case (MASTERNODE_SYNC_BUDGET_FIN):
if (RequestedMasternodeAssets != MASTERNODE_SYNC_BUDGET) return;
sumBudgetItemFin+=ssc.count;
countBudgetItemFin++;
break;
}
log.info(""String_Node_Str"",ssc.itemId,ssc.count);
}","void processSyncStatusCount(Peer peer,SyncStatusCount ssc){
  if (RequestedMasternodeAssets >= MASTERNODE_SYNC_FINISHED)   return;
switch (ssc.itemId) {
case (MASTERNODE_SYNC_LIST):
    if (ssc.itemId != RequestedMasternodeAssets)     return;
  sumMasternodeList+=ssc.count;
countMasternodeList++;
peer.setMasternodeListCount(ssc.count);
break;
case (MASTERNODE_SYNC_MNW):
if (ssc.itemId != RequestedMasternodeAssets) return;
sumMasternodeWinner+=ssc.count;
countMasternodeWinner++;
break;
case (MASTERNODE_SYNC_BUDGET_PROP):
if (RequestedMasternodeAssets != MASTERNODE_SYNC_BUDGET) return;
sumBudgetItemProp+=ssc.count;
countBudgetItemProp++;
break;
case (MASTERNODE_SYNC_BUDGET_FIN):
if (RequestedMasternodeAssets != MASTERNODE_SYNC_BUDGET) return;
sumBudgetItemFin+=ssc.count;
countBudgetItemFin++;
break;
}
log.info(""String_Node_Str"",ssc.itemId,ssc.count);
}",0.970131421744325
85583,"@Override protected void processMessage(Message m) throws Exception {
  if (startTime == 0)   startTime=Utils.currentTimeMillis();
 else {
    long current=Utils.currentTimeMillis();
    dataReceived+=m.getMessageSize();
    if (count % 50 == 0) {
      log.info(""String_Node_Str"" + (dataReceived / 1024 / 1024) + ""String_Node_Str""+ (current - startTime) / 1000 + ""String_Node_Str"" + (dataReceived / 1024) / (current - startTime) * 1000 + ""String_Node_Str"");
    }
    count++;
  }
  for (  ListenerRegistration<PeerEventListener> registration : eventListeners) {
    if (registration.executor == Threading.SAME_THREAD) {
      m=registration.listener.onPreMessageReceived(this,m);
      if (m == null)       break;
    }
  }
  if (m == null)   return;
  if (currentFilteredBlock != null && !(m instanceof Transaction)) {
    endFilteredBlock(currentFilteredBlock);
    currentFilteredBlock=null;
  }
  if (m instanceof Ping) {
    if (((Ping)m).hasNonce())     sendMessage(new Pong(((Ping)m).getNonce()));
  }
 else   if (m instanceof Pong) {
    processPong((Pong)m);
  }
 else   if (m instanceof NotFoundMessage) {
    processNotFoundMessage((NotFoundMessage)m);
  }
 else   if (m instanceof InventoryMessage) {
    processInv((InventoryMessage)m);
  }
 else   if (m instanceof Block) {
    processBlock((Block)m);
  }
 else   if (m instanceof FilteredBlock) {
    startFilteredBlock((FilteredBlock)m);
  }
 else   if (m instanceof TransactionLockRequest) {
    params.instantx.processTransactionLockRequest(this,(TransactionLockRequest)m);
    processTransaction((TransactionLockRequest)m);
  }
 else   if (m instanceof Transaction) {
    processTransaction((Transaction)m);
  }
 else   if (m instanceof GetDataMessage) {
    processGetData((GetDataMessage)m);
  }
 else   if (m instanceof AddressMessage) {
    processAddressMessage((AddressMessage)m);
  }
 else   if (m instanceof HeadersMessage) {
    processHeaders((HeadersMessage)m);
  }
 else   if (m instanceof AlertMessage) {
    processAlert((AlertMessage)m);
  }
 else   if (m instanceof VersionMessage) {
    processVersionMessage((VersionMessage)m);
  }
 else   if (m instanceof VersionAck) {
    if (vPeerVersionMessage == null) {
      throw new ProtocolException(""String_Node_Str"");
    }
    if (isAcked) {
      throw new ProtocolException(""String_Node_Str"");
    }
    isAcked=true;
    this.setTimeoutEnabled(false);
    for (    final ListenerRegistration<PeerEventListener> registration : eventListeners) {
      registration.executor.execute(new Runnable(){
        @Override public void run(){
          registration.listener.onPeerConnected(Peer.this,1);
        }
      }
);
    }
    final int version=vMinProtocolVersion;
    if (vPeerVersionMessage.clientVersion < version) {
      log.warn(""String_Node_Str"",vPeerVersionMessage.clientVersion,version);
      close();
    }
  }
 else   if (m instanceof UTXOsMessage) {
    processUTXOMessage((UTXOsMessage)m);
  }
 else   if (m instanceof RejectMessage) {
    log.error(""String_Node_Str"",this,getPeerVersionMessage().subVer,m);
  }
 else   if (m instanceof DarkSendQueue) {
  }
 else   if (m instanceof MasternodeBroadcast) {
    params.masternodeManager.processMasternodeBroadcast((MasternodeBroadcast)m);
  }
 else   if (m instanceof MasternodePing) {
    params.masternodeManager.processMasternodePing(this,(MasternodePing)m);
  }
 else   if (m instanceof SporkMessage) {
    params.sporkManager.processSpork(this,(SporkMessage)m);
  }
 else   if (m instanceof ConsensusVote) {
    params.instantx.processConsensusVoteMessage(this,(ConsensusVote)m);
  }
 else   if (m instanceof SyncStatusCount) {
    params.masternodeSync.processSyncStatusCount((SyncStatusCount)m);
  }
 else {
    log.warn(""String_Node_Str"",this,m);
  }
}","@Override protected void processMessage(Message m) throws Exception {
  if (startTime == 0)   startTime=Utils.currentTimeMillis();
 else {
    long current=Utils.currentTimeMillis();
    dataReceived+=m.getMessageSize();
    if (count % 50 == 0) {
      log.info(""String_Node_Str"" + (dataReceived / 1024 / 1024) + ""String_Node_Str""+ (current - startTime) / 1000 + ""String_Node_Str"" + (dataReceived / 1024) / (current - startTime) * 1000 + ""String_Node_Str"");
    }
    count++;
  }
  for (  ListenerRegistration<PeerEventListener> registration : eventListeners) {
    if (registration.executor == Threading.SAME_THREAD) {
      m=registration.listener.onPreMessageReceived(this,m);
      if (m == null)       break;
    }
  }
  if (m == null)   return;
  if (currentFilteredBlock != null && !(m instanceof Transaction)) {
    endFilteredBlock(currentFilteredBlock);
    currentFilteredBlock=null;
  }
  if (m instanceof Ping) {
    if (((Ping)m).hasNonce())     sendMessage(new Pong(((Ping)m).getNonce()));
  }
 else   if (m instanceof Pong) {
    processPong((Pong)m);
  }
 else   if (m instanceof NotFoundMessage) {
    processNotFoundMessage((NotFoundMessage)m);
  }
 else   if (m instanceof InventoryMessage) {
    processInv((InventoryMessage)m);
  }
 else   if (m instanceof Block) {
    processBlock((Block)m);
  }
 else   if (m instanceof FilteredBlock) {
    startFilteredBlock((FilteredBlock)m);
  }
 else   if (m instanceof TransactionLockRequest) {
    params.instantx.processTransactionLockRequest(this,(TransactionLockRequest)m);
    processTransaction((TransactionLockRequest)m);
  }
 else   if (m instanceof Transaction) {
    processTransaction((Transaction)m);
  }
 else   if (m instanceof GetDataMessage) {
    processGetData((GetDataMessage)m);
  }
 else   if (m instanceof AddressMessage) {
    processAddressMessage((AddressMessage)m);
  }
 else   if (m instanceof HeadersMessage) {
    processHeaders((HeadersMessage)m);
  }
 else   if (m instanceof AlertMessage) {
    processAlert((AlertMessage)m);
  }
 else   if (m instanceof VersionMessage) {
    processVersionMessage((VersionMessage)m);
  }
 else   if (m instanceof VersionAck) {
    if (vPeerVersionMessage == null) {
      throw new ProtocolException(""String_Node_Str"");
    }
    if (isAcked) {
      throw new ProtocolException(""String_Node_Str"");
    }
    isAcked=true;
    this.setTimeoutEnabled(false);
    for (    final ListenerRegistration<PeerEventListener> registration : eventListeners) {
      registration.executor.execute(new Runnable(){
        @Override public void run(){
          registration.listener.onPeerConnected(Peer.this,1);
        }
      }
);
    }
    final int version=vMinProtocolVersion;
    if (vPeerVersionMessage.clientVersion < version) {
      log.warn(""String_Node_Str"",vPeerVersionMessage.clientVersion,version);
      close();
    }
  }
 else   if (m instanceof UTXOsMessage) {
    processUTXOMessage((UTXOsMessage)m);
  }
 else   if (m instanceof RejectMessage) {
    log.error(""String_Node_Str"",this,getPeerVersionMessage().subVer,m);
  }
 else   if (m instanceof DarkSendQueue) {
  }
 else   if (m instanceof MasternodeBroadcast) {
    params.masternodeManager.processMasternodeBroadcast((MasternodeBroadcast)m);
  }
 else   if (m instanceof MasternodePing) {
    params.masternodeManager.processMasternodePing(this,(MasternodePing)m);
  }
 else   if (m instanceof SporkMessage) {
    params.sporkManager.processSpork(this,(SporkMessage)m);
  }
 else   if (m instanceof ConsensusVote) {
    params.instantx.processConsensusVoteMessage(this,(ConsensusVote)m);
  }
 else   if (m instanceof SyncStatusCount) {
    params.masternodeSync.processSyncStatusCount(this,(SyncStatusCount)m);
  }
 else {
    log.warn(""String_Node_Str"",this,m);
  }
}",0.9993357247243256
85584,"Sha256Hash calculateScore(int mod,Sha256Hash hash){
  BigInteger bi_aux=vin.getOutpoint().getHash().toBigInteger().add(BigInteger.valueOf(vin.getOutpoint().getIndex()));
  byte[] temp=new byte[32];
  System.arraycopy(bi_aux.toByteArray(),0,temp,0,32);
  Sha256Hash aux=Sha256Hash.wrap(temp);
  if (hash.equals(Sha256Hash.ZERO_HASH)) {
    log.info(""String_Node_Str"");
    return Sha256Hash.ZERO_HASH;
  }
  Sha256Hash hash2=Sha256Hash.twiceOf(hash.getBytes());
  try {
    UnsafeByteArrayOutputStream bos=new UnsafeByteArrayOutputStream();
    bos.write(hash.getBytes());
    bos.write(aux.getBytes());
    Sha256Hash hash3=Sha256Hash.twiceOf(bos.toByteArray());
    BigInteger bhash2=hash2.toBigInteger();
    BigInteger bhash3=hash3.toBigInteger();
    if (bhash3.compareTo(bhash2) > 0) {
      System.arraycopy(bhash3.subtract(bhash2).toByteArray(),0,temp,0,32);
      return Sha256Hash.wrap(temp);
    }
 else {
      System.arraycopy(bhash2.subtract(bhash3).toByteArray(),0,temp,0,32);
      return Sha256Hash.wrap(temp);
    }
  }
 catch (  IOException x) {
    return Sha256Hash.ZERO_HASH;
  }
}","static Sha256Hash calculateScore(TransactionInput vin,Sha256Hash hash){
  BigInteger bi_aux=vin.getOutpoint().getHash().toBigInteger().add(BigInteger.valueOf(vin.getOutpoint().getIndex()));
  byte[] temp=new byte[32];
  byte[] bi_bytes=bi_aux.toByteArray();
  int length=bi_bytes[0] == 0 ? java.lang.Math.min(bi_bytes.length - 1,32) : java.lang.Math.min(bi_bytes.length,32);
  System.arraycopy(bi_bytes,bi_bytes[0] == 0 ? 1 : 0,temp,0,length);
  Sha256Hash aux=Sha256Hash.wrap(temp);
  Sha256Hash hash2=Sha256Hash.wrapReversed(Sha256Hash.hashTwice(hash.getReversedBytes()));
  try {
    UnsafeByteArrayOutputStream bos=new UnsafeByteArrayOutputStream();
    bos.write(hash.getReversedBytes());
    bos.write(aux.getReversedBytes());
    Sha256Hash hash3=Sha256Hash.wrapReversed(Sha256Hash.hashTwice(bos.toByteArray()));
    BigInteger bhash2=hash2.toBigInteger();
    BigInteger bhash3=hash3.toBigInteger();
    if (bhash3.compareTo(bhash2) > 0) {
      byte[] subtraction=bhash3.subtract(bhash2).toByteArray();
      length=subtraction[0] == 0 ? java.lang.Math.min(subtraction.length - 1,32) : java.lang.Math.min(subtraction.length,32);
      System.arraycopy(subtraction,subtraction[0] == 0 ? 1 : 0,temp,0,length);
      return Sha256Hash.wrap(temp);
    }
 else {
      byte[] subtraction=bhash2.subtract(bhash3).toByteArray();
      length=subtraction[0] == 0 ? java.lang.Math.min(subtraction.length - 1,32) : java.lang.Math.min(subtraction.length,32);
      System.arraycopy(subtraction,subtraction[0] == 0 ? 1 : 0,temp,0,length);
      return Sha256Hash.wrap(temp);
    }
  }
 catch (  IOException x) {
    return Sha256Hash.ZERO_HASH;
  }
}",0.2102582757366315
85585,"public Sha256Hash getHash(){
  byte[] dataToHash=new byte[pubkey.getBytes().length + 8];
  Utils.uint32ToByteArrayLE(sigTime,dataToHash,0);
  System.arraycopy(pubkey.getBytes(),0,dataToHash,8,pubkey.getBytes().length);
  return Sha256Hash.twiceOf(dataToHash);
}","public Sha256Hash getHash(){
  byte[] dataToHash=new byte[pubkey.getBytes().length + 8];
  Utils.uint32ToByteArrayLE(sigTime,dataToHash,0);
  System.arraycopy(pubkey.getBytes(),0,dataToHash,8,pubkey.getBytes().length);
  try {
    UnsafeByteArrayOutputStream bos=new UnsafeByteArrayOutputStream(8 + pubkey.calculateMessageSizeInBytes());
    Utils.int64ToByteStreamLE(sigTime,bos);
    pubkey.bitcoinSerialize(bos);
    return Sha256Hash.wrapReversed(Sha256Hash.hashTwice((bos.toByteArray())));
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}",0.585247883917775
85586,"public void checkAndRemove(boolean forceExpiredRemoval){
  check();
  lock.lock();
  try {
    Iterator<Masternode> it=vMasternodes.iterator();
    while (it.hasNext()) {
      Masternode mn=it.next();
      if (mn.activeState == Masternode.MASTERNODE_REMOVE || mn.activeState == Masternode.MASTERNODE_VIN_SPENT || (forceExpiredRemoval && mn.activeState == Masternode.MASTERNODE_EXPIRED) || mn.protocolVersion < params.masternodePayments.getMinMasternodePaymentsProto()) {
        log.info(""String_Node_Str"",mn.address.toString(),size() - 1);
        Iterator<Map.Entry<Sha256Hash,MasternodeBroadcast>> it3=mapSeenMasternodeBroadcast.entrySet().iterator();
        while (it3.hasNext()) {
          Map.Entry<Sha256Hash,MasternodeBroadcast> mb=it3.next();
          if (mb.getValue().vin == mn.vin) {
            params.masternodeSync.mapSeenSyncMNB.remove(mb.getKey());
            it3.remove();
          }
        }
        Iterator<Map.Entry<TransactionOutPoint,Long>> it2=mWeAskedForMasternodeListEntry.entrySet().iterator();
        while (it2.hasNext()) {
          Map.Entry<TransactionOutPoint,Long> e=it2.next();
          if (e.getKey() == mn.vin.getOutpoint()) {
            it2.remove();
          }
        }
        it.remove();
      }
 else {
      }
    }
    Iterator<Map.Entry<NetAddress,Long>> it1=mAskedUsForMasternodeList.entrySet().iterator();
    while (it1.hasNext()) {
      Map.Entry<NetAddress,Long> e=it1.next();
      if (e.getValue() < Utils.currentTimeSeconds()) {
        it.remove();
      }
 else {
      }
    }
    it1=mWeAskedForMasternodeList.entrySet().iterator();
    while (it1.hasNext()) {
      Map.Entry<NetAddress,Long> e=it1.next();
      if (e.getValue() < Utils.currentTimeSeconds()) {
        it.remove();
      }
 else {
      }
    }
    Iterator<Map.Entry<TransactionOutPoint,Long>> it2=mWeAskedForMasternodeListEntry.entrySet().iterator();
    while (it2.hasNext()) {
      Map.Entry<TransactionOutPoint,Long> e=it2.next();
      if (e.getValue() < Utils.currentTimeSeconds()) {
        it2.remove();
      }
 else {
      }
    }
    Iterator<Map.Entry<Sha256Hash,MasternodeBroadcast>> it3=mapSeenMasternodeBroadcast.entrySet().iterator();
    while (it3.hasNext()) {
      Map.Entry<Sha256Hash,MasternodeBroadcast> mb=it3.next();
      if (mb.getValue().lastPing.sigTime < Utils.currentTimeSeconds() - (Masternode.MASTERNODE_REMOVAL_SECONDS * 2)) {
        params.masternodeSync.mapSeenSyncMNB.remove(mb.getValue().getHash());
        it3.remove();
      }
 else {
      }
    }
    Iterator<Map.Entry<Sha256Hash,MasternodePing>> it4=mapSeenMasternodePing.entrySet().iterator();
    while (it4.hasNext()) {
      Map.Entry<Sha256Hash,MasternodePing> mp=it4.next();
      if (mp.getValue().sigTime < Utils.currentTimeSeconds() - (Masternode.MASTERNODE_REMOVAL_SECONDS * 2)) {
        it4.remove();
      }
 else {
      }
    }
  }
  finally {
    lock.unlock();
  }
}","public void checkAndRemove(boolean forceExpiredRemoval){
  check();
  lock.lock();
  try {
    Iterator<Masternode> it=vMasternodes.iterator();
    while (it.hasNext()) {
      Masternode mn=it.next();
      if (mn.activeState == Masternode.MASTERNODE_REMOVE || mn.activeState == Masternode.MASTERNODE_VIN_SPENT || (forceExpiredRemoval && mn.activeState == Masternode.MASTERNODE_EXPIRED) || mn.protocolVersion < params.masternodePayments.getMinMasternodePaymentsProto()) {
        log.info(""String_Node_Str"",mn.address.toString(),size() - 1);
        Iterator<Map.Entry<Sha256Hash,MasternodeBroadcast>> it3=mapSeenMasternodeBroadcast.entrySet().iterator();
        while (it3.hasNext()) {
          Map.Entry<Sha256Hash,MasternodeBroadcast> mb=it3.next();
          if (mb.getValue().vin == mn.vin) {
            params.masternodeSync.mapSeenSyncMNB.remove(mb.getKey());
            it3.remove();
          }
        }
        Iterator<Map.Entry<TransactionOutPoint,Long>> it2=mWeAskedForMasternodeListEntry.entrySet().iterator();
        while (it2.hasNext()) {
          Map.Entry<TransactionOutPoint,Long> e=it2.next();
          if (e.getKey() == mn.vin.getOutpoint()) {
            it2.remove();
          }
        }
        it.remove();
      }
 else {
      }
    }
    Iterator<Map.Entry<NetAddress,Long>> it1=mAskedUsForMasternodeList.entrySet().iterator();
    while (it1.hasNext()) {
      Map.Entry<NetAddress,Long> e=it1.next();
      if (e.getValue() < Utils.currentTimeSeconds()) {
        it1.remove();
      }
 else {
      }
    }
    it1=mWeAskedForMasternodeList.entrySet().iterator();
    while (it1.hasNext()) {
      Map.Entry<NetAddress,Long> e=it1.next();
      if (e.getValue() < Utils.currentTimeSeconds()) {
        it1.remove();
      }
 else {
      }
    }
    Iterator<Map.Entry<TransactionOutPoint,Long>> it2=mWeAskedForMasternodeListEntry.entrySet().iterator();
    while (it2.hasNext()) {
      Map.Entry<TransactionOutPoint,Long> e=it2.next();
      if (e.getValue() < Utils.currentTimeSeconds()) {
        it2.remove();
      }
 else {
      }
    }
    Iterator<Map.Entry<Sha256Hash,MasternodeBroadcast>> it3=mapSeenMasternodeBroadcast.entrySet().iterator();
    while (it3.hasNext()) {
      Map.Entry<Sha256Hash,MasternodeBroadcast> mb=it3.next();
      if (mb.getValue().lastPing.sigTime < Utils.currentTimeSeconds() - (Masternode.MASTERNODE_REMOVAL_SECONDS * 2)) {
        params.masternodeSync.mapSeenSyncMNB.remove(mb.getValue().getHash());
        it3.remove();
      }
 else {
      }
    }
    Iterator<Map.Entry<Sha256Hash,MasternodePing>> it4=mapSeenMasternodePing.entrySet().iterator();
    while (it4.hasNext()) {
      Map.Entry<Sha256Hash,MasternodePing> mp=it4.next();
      if (mp.getValue().sigTime < Utils.currentTimeSeconds() - (Masternode.MASTERNODE_REMOVAL_SECONDS * 2)) {
        it4.remove();
      }
 else {
      }
    }
  }
  finally {
    lock.unlock();
  }
}",0.9996581196581196
85587,"void processMasternodePing(Peer peer,MasternodePing mnp){
  log.info(""String_Node_Str"" + mnp.vin.toString());
  if (mapSeenMasternodePing.containsKey(mnp.getHash()))   return;
  mapSeenMasternodePing.put(mnp.getHash(),mnp);
  int nDoS=0;
  if (mnp.checkAndUpdate())   return;
  if (nDoS > 0) {
  }
 else {
    Masternode pmn=find(mnp.vin);
    if (pmn != null)     return;
  }
  askForMN(peer,mnp.vin);
}","void processMasternodePing(Peer peer,MasternodePing mnp){
  if (mapSeenMasternodePing.containsKey(mnp.getHash()))   return;
  mapSeenMasternodePing.put(mnp.getHash(),mnp);
  int nDoS=0;
  if (mnp.checkAndUpdate())   return;
  if (nDoS > 0) {
  }
 else {
    Masternode pmn=find(mnp.vin);
    if (pmn != null)     return;
  }
  askForMN(peer,mnp.vin);
}",0.9312169312169312
85588,"public int countEnabled(int protocolVersion){
  int i=0;
  protocolVersion=protocolVersion == -1 ? params.masternodePayments.getMinMasternodePaymentsProto() : protocolVersion;
  for (  Masternode mn : vMasternodes) {
    mn.check();
    if (mn.protocolVersion < protocolVersion || !mn.isEnabled())     continue;
    i++;
  }
  return i;
}","public int countEnabled(int protocolVersion){
  int i=0;
  protocolVersion=protocolVersion == -1 ? params.masternodePayments.getMinMasternodePaymentsProto() : protocolVersion;
  lock.lock();
  try {
    for (    Masternode mn : vMasternodes) {
      mn.check();
      if (mn.protocolVersion < protocolVersion || !mn.isEnabled())       continue;
      i++;
    }
  }
  finally {
    lock.unlock();
  }
  return i;
}",0.875
85589,"void processMasternodeBroadcast(MasternodeBroadcast mnb){
  if (mapSeenMasternodeBroadcast.containsKey(mnb.getHash())) {
    params.masternodeSync.addedMasternodeList(mnb.getHash());
    return;
  }
  mapSeenMasternodeBroadcast.put(mnb.getHash(),mnb);
  int nDoS=0;
  if (!mnb.checkAndUpdate()) {
    return;
  }
  if (!DarkSendSigner.isVinAssociatedWithPubkey(params,mnb.vin,mnb.pubkey)) {
    log.info(""String_Node_Str"");
    return;
  }
  if (mnb.checkInputsAndAdd()) {
    params.masternodeSync.addedMasternodeList(mnb.getHash());
  }
 else {
    log.info(""String_Node_Str"" + mnb.address.toString());
  }
}","void processMasternodeBroadcast(MasternodeBroadcast mnb){
  if (mapSeenMasternodeBroadcast.containsKey(mnb.getHash())) {
    params.masternodeSync.addedMasternodeList(mnb.getHash());
    return;
  }
  mapSeenMasternodeBroadcast.put(mnb.getHash(),mnb);
  int nDoS=0;
  if (!mnb.checkAndUpdate()) {
    return;
  }
  if (!DarkSendSigner.isVinAssociatedWithPubkey(params,mnb.vin,mnb.pubkey)) {
    log.info(""String_Node_Str"");
    return;
  }
  if (mnb.checkInputsAndAdd()) {
  }
 else {
    log.info(""String_Node_Str"" + mnb.address.toString());
  }
}",0.9464594127806564
85590,"public Sha256Hash getHash(){
  try {
    ByteArrayOutputStream bos=new UnsafeByteArrayOutputStream(vchSig.getBytes().length + 8);
    bos.write(vchSig.getBytes());
    Utils.int64ToByteStreamLE(sigTime,bos);
    return Sha256Hash.twiceOf(bos.toByteArray());
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","public Sha256Hash getHash(){
  try {
    UnsafeByteArrayOutputStream bos=new UnsafeByteArrayOutputStream(vchSig.calculateMessageSizeInBytes() + 8);
    vin.bitcoinSerialize(bos);
    Utils.int64ToByteStreamLE(sigTime,bos);
    return Sha256Hash.wrapReversed(Sha256Hash.hashTwice(bos.toByteArray()));
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}",0.8028571428571428
85591,"/** 
 * Clean up the wallet. Currently, it only removes risky pending transaction from the wallet and only if their outputs have not been spent.
 */
public void cleanup(){
  lock.lock();
  try {
    boolean dirty=false;
    for (Iterator<Transaction> i=pending.values().iterator(); i.hasNext(); ) {
      Transaction tx=i.next();
      if (isTransactionRisky(tx,null) && !acceptRiskyTransactions) {
        log.debug(""String_Node_Str"",tx.getHashAsString());
        if (!tx.isAnyOutputSpent()) {
          for (          TransactionInput input : tx.getInputs()) {
            TransactionOutput output=input.getConnectedOutput();
            if (output == null)             continue;
            myUnspents.add(output);
            input.disconnect();
          }
          for (          TransactionOutput output : tx.getOutputs())           myUnspents.remove(output);
          i.remove();
          transactions.remove(tx.getHash());
          dirty=true;
          log.info(""String_Node_Str"",tx.getHashAsString());
        }
 else {
          log.info(""String_Node_Str"",tx.getHashAsString());
        }
      }
    }
    if (dirty) {
      isConsistentOrThrow();
      saveLater();
      if (log.isInfoEnabled())       log.info(""String_Node_Str"",getBalance(BalanceType.ESTIMATED).toFriendlyString());
    }
  }
  finally {
    lock.unlock();
  }
}","/** 
 * Clean up the wallet. Currently, it only removes risky pending transaction from the wallet and only if their outputs have not been spent.
 */
public void cleanup(){
  lock.lock();
  try {
    boolean dirty=false;
    for (Iterator<Transaction> i=pending.values().iterator(); i.hasNext(); ) {
      Transaction tx=i.next();
      if (isTransactionRisky(tx,null) && !acceptRiskyTransactions) {
        log.debug(""String_Node_Str"",tx.getHashAsString());
        if (!tx.isAnyOutputSpent()) {
          for (          TransactionInput input : tx.getInputs()) {
            TransactionOutput output=input.getConnectedOutput();
            if (output == null)             continue;
            if (output.isMineOrWatched(this))             checkState(myUnspents.add(output));
            input.disconnect();
          }
          for (          TransactionOutput output : tx.getOutputs())           myUnspents.remove(output);
          i.remove();
          transactions.remove(tx.getHash());
          dirty=true;
          log.info(""String_Node_Str"",tx.getHashAsString());
        }
 else {
          log.info(""String_Node_Str"",tx.getHashAsString());
        }
      }
    }
    if (dirty) {
      isConsistentOrThrow();
      saveLater();
      if (log.isInfoEnabled())       log.info(""String_Node_Str"",getBalance(BalanceType.ESTIMATED).toFriendlyString());
    }
  }
  finally {
    lock.unlock();
  }
}",0.9789702683103698
85592,"/** 
 * Convenience for connecting only to peers that can serve specific services. It will configure suitable peer discoveries.
 * @param services Required services as a bitmask, e.g. {@link VersionMessage#NODE_NETWORK}.
 */
public void setRequiredServices(long requiredServices){
  lock.lock();
  try {
    this.requiredServices=requiredServices;
    peerDiscoverers.clear();
    peerDiscoverers.add(MultiplexingDiscovery.forServices(params,requiredServices));
  }
  finally {
    lock.unlock();
  }
}","/** 
 * Convenience for connecting only to peers that can serve specific services. It will configure suitable peer discoveries.
 * @param requiredServices Required services as a bitmask, e.g. {@link VersionMessage#NODE_NETWORK}.
 */
public void setRequiredServices(long requiredServices){
  lock.lock();
  try {
    this.requiredServices=requiredServices;
    peerDiscoverers.clear();
    addPeerDiscovery(MultiplexingDiscovery.forServices(params,requiredServices));
  }
  finally {
    lock.unlock();
  }
}",0.977205153617443
85593,"/** 
 * Generates a new deterministic key from the given seed, which can be any arbitrary byte array. However resist the temptation to use a string as the seed - any key derived from a password is likely to be weak and easily broken by attackers (this is not theoretical, people have had money stolen that way). This method checks that the given seed is at least 64 bits long.
 * @throws HDDerivationException if generated master key is invalid (private key 0 or >= n).
 * @throws IllegalArgumentException if the seed is less than 8 bytes and could be brute forced.
 */
public static DeterministicKey createMasterPrivateKey(byte[] seed) throws HDDerivationException {
  checkArgument(seed.length > 8,""String_Node_Str"");
  byte[] i=HDUtils.hmacSha512(MASTER_HMAC_SHA512,seed);
  checkState(i.length == 64,i.length);
  byte[] il=Arrays.copyOfRange(i,0,32);
  byte[] ir=Arrays.copyOfRange(i,32,64);
  Arrays.fill(i,(byte)0);
  DeterministicKey masterPrivKey=createMasterPrivKeyFromBytes(il,ir);
  Arrays.fill(il,(byte)0);
  Arrays.fill(ir,(byte)0);
  masterPrivKey.setCreationTimeSeconds(Utils.currentTimeSeconds());
  return masterPrivKey;
}","/** 
 * Generates a new deterministic key from the given seed, which can be any arbitrary byte array. However resist the temptation to use a string as the seed - any key derived from a password is likely to be weak and easily broken by attackers (this is not theoretical, people have had money stolen that way). This method checks that the given seed is at least 64 bits long.
 * @throws HDDerivationException if generated master key is invalid (private key 0 or >= n).
 * @throws IllegalArgumentException if the seed is less than 8 bytes and could be brute forced.
 */
public static DeterministicKey createMasterPrivateKey(byte[] seed) throws HDDerivationException {
  checkArgument(seed.length > 8,""String_Node_Str"");
  byte[] i=HDUtils.hmacSha512(HDUtils.createHmacSha512Digest(""String_Node_Str"".getBytes()),seed);
  checkState(i.length == 64,i.length);
  byte[] il=Arrays.copyOfRange(i,0,32);
  byte[] ir=Arrays.copyOfRange(i,32,64);
  Arrays.fill(i,(byte)0);
  DeterministicKey masterPrivKey=createMasterPrivKeyFromBytes(il,ir);
  Arrays.fill(il,(byte)0);
  Arrays.fill(ir,(byte)0);
  masterPrivKey.setCreationTimeSeconds(Utils.currentTimeSeconds());
  return masterPrivKey;
}",0.9698275862068966
85594,"@Override public int hashCode(){
  if (bits != null)   return Arrays.hashCode(bits);
 else   return get().hashCode();
}","@Override public int hashCode(){
  return Arrays.hashCode(getCanonicalEncoding());
}",0.6600985221674877
85595,"@Override public boolean equals(Object o){
  if (this == o)   return true;
  if (o == null || getClass() != o.getClass())   return false;
  LazyECPoint point1=(LazyECPoint)o;
  if (bits != null && point1.bits != null)   return Arrays.equals(bits,point1.bits);
 else   return get().equals(point1.get());
}","@Override public boolean equals(Object o){
  return this == o || o != null && getClass() == o.getClass() && Arrays.equals(getCanonicalEncoding(),((LazyECPoint)o).getCanonicalEncoding());
}",0.5203252032520326
85596,"@Override public int hashCode(){
  return Objects.hashCode(bytes,version,compressed);
}","@Override public int hashCode(){
  return Objects.hashCode(version,compressed,Arrays.hashCode(bytes));
}",0.8481675392670157
85597,"@Override public int hashCode(){
  int result=(int)(sequence ^ (sequence >>> 32));
  result=31 * result + outpoint.hashCode();
  result=31 * result + (scriptBytes != null ? Arrays.hashCode(scriptBytes) : 0);
  result=31 * result + (scriptSig != null ? scriptSig.hashCode() : 0);
  return result;
}","@Override public int hashCode(){
  int result=(int)(sequence ^ (sequence >>> 32));
  result=31 * result + outpoint.hashCode();
  result=31 * result + (scriptBytes != null ? Arrays.hashCode(scriptBytes) : 0);
  return result;
}",0.864244741873805
85598,"@Override public boolean equals(Object o){
  if (this == o)   return true;
  if (o == null || getClass() != o.getClass())   return false;
  TransactionInput input=(TransactionInput)o;
  if (sequence != input.sequence)   return false;
  if (!outpoint.equals(input.outpoint))   return false;
  if (!Arrays.equals(scriptBytes,input.scriptBytes))   return false;
  if (scriptSig != null ? !scriptSig.equals(input.scriptSig) : input.scriptSig != null)   return false;
  if (parent != input.parent)   return false;
  return true;
}","@Override public boolean equals(Object o){
  if (this == o)   return true;
  if (o == null || getClass() != o.getClass())   return false;
  TransactionInput input=(TransactionInput)o;
  if (sequence != input.sequence)   return false;
  if (!outpoint.equals(input.outpoint))   return false;
  if (!Arrays.equals(scriptBytes,input.scriptBytes))   return false;
  if (parent != input.parent)   return false;
  return true;
}",0.8773784355179705
85599,"@Override public int hashCode(){
  return 31 * hash.hashCode() + (int)(index ^ (index >>> 32));
}","@Override public int hashCode(){
  return 31 * getHash().hashCode() + (int)(getIndex() ^ (getIndex() >>> 32));
}",0.8995215311004785
85600,"@Override public int hashCode(){
  int result=(int)(value ^ (value >>> 32));
  result=31 * result + Arrays.hashCode(scriptBytes);
  if (parent != null)   result*=parent.getHash().hashCode() + getIndex();
  return result;
}","@Override public int hashCode(){
  int result=(int)(value ^ (value >>> 32));
  result=31 * result + Arrays.hashCode(scriptBytes);
  if (parent != null)   result*=parent.getHash().hashCode();
  return result;
}",0.9698375870069604
85601,"/** 
 * Prepares the wallet for a blockchain replay. Removes all transactions (as they would get in the way of the replay) and makes the wallet think it has never seen a block.   {@link WalletEventListener#onWalletChanged()} willbe fired.
 */
public void reset(){
  lock.lock();
  try {
    clearTransactions();
    lastBlockSeenHash=null;
    lastBlockSeenHeight=-1;
    lastBlockSeenTimeSecs=0;
    saveLater();
    maybeQueueOnWalletChanged();
  }
  finally {
    lock.unlock();
  }
}","/** 
 * Prepares the wallet for a blockchain replay. Removes all transactions (as they would get in the way of the replay) and makes the wallet think it has never seen a block.   {@link WalletEventListener#onWalletChanged} willbe fired.
 */
public void reset(){
  lock.lock();
  try {
    clearTransactions();
    lastBlockSeenHash=null;
    lastBlockSeenHeight=-1;
    lastBlockSeenTimeSecs=0;
    saveLater();
    maybeQueueOnWalletChanged();
  }
  finally {
    lock.unlock();
  }
}",0.9979423868312756
85602,"/** 
 * <p>Gets a future which returns this when the channel is successfully opened, or throws an exception if there is an error before the channel has reached the open state.</p> <p>After this future completes successfully, you may call  {@link PaymentChannelClientConnection#incrementPayment(Coin)} or {@link PaymentChannelClientConnection#incrementPayment(Coin,com.google.protobuf.ByteString)} to begin paying the server.</p>
 */
public ListenableFuture<PaymentChannelClientConnection> getChannelOpenFuture(){
  return channelOpenFuture;
}","/** 
 * <p>Gets a future which returns this when the channel is successfully opened, or throws an exception if there is an error before the channel has reached the open state.</p> <p>After this future completes successfully, you may call  {@link PaymentChannelClientConnection#incrementPayment(Coin)} or{@link PaymentChannelClientConnection#incrementPayment(Coin,com.google.protobuf.ByteString,KeyParameter)} tobegin paying the server.</p>
 */
public ListenableFuture<PaymentChannelClientConnection> getChannelOpenFuture(){
  return channelOpenFuture;
}",0.9863013698630136
85603,"/** 
 * Returns the loaded protocol buffer from the given byte stream. You normally want  {@link Wallet#loadFromFile(java.io.File)} instead - this method is designed for low level work involving thewallet file format itself.
 */
public static Protos.Wallet parseToProto(InputStream input) throws IOException {
  CodedInputStream codedInput=CodedInputStream.newInstance(input);
  codedInput.setSizeLimit(WALLET_SIZE_LIMIT);
  return Protos.Wallet.parseFrom(codedInput);
}","/** 
 * Returns the loaded protocol buffer from the given byte stream. You normally want  {@link Wallet#loadFromFile(java.io.File,WalletExtension)} instead - this method is designed for low levelwork involving the wallet file format itself.
 */
public static Protos.Wallet parseToProto(InputStream input) throws IOException {
  CodedInputStream codedInput=CodedInputStream.newInstance(input);
  codedInput.setSizeLimit(WALLET_SIZE_LIMIT);
  return Protos.Wallet.parseFrom(codedInput);
}",0.9811715481171548
85604,"/** 
 * Return the number of fractional decimal places to be displayed when formatting the given number of monetory units of the denomination indicated by the given decimal scale value, where 0 = coin, 3 = millicoin, and so on.
 * @param unitCount      the number of monetary units to be formatted
 * @param scale          the denomination of those units as the decimal-place shift from coins
 * @param minDecimals    the minimum number of fractional decimal places
 * @param fractiongroups the sizes of option fractional decimal-place groups
 */
private static int calculateFractionPlaces(BigDecimal unitCount,int scale,int minDecimals,List<Integer> fractionGroups){
  int places=minDecimals;
  for (  int group : fractionGroups) {
    places+=group;
  }
  int max=Math.min(places,offSatoshis(scale));
  places=Math.min(minDecimals,max);
  for (  int group : fractionGroups) {
    if (unitCount.setScale(places,HALF_UP).compareTo(unitCount.setScale(max,HALF_UP)) == 0)     break;
    places+=group;
    if (places > max)     places=max;
  }
  return places;
}","/** 
 * Return the number of fractional decimal places to be displayed when formatting the given number of monetory units of the denomination indicated by the given decimal scale value, where 0 = coin, 3 = millicoin, and so on.
 * @param unitCount      the number of monetary units to be formatted
 * @param scale          the denomination of those units as the decimal-place shift from coins
 * @param minDecimals    the minimum number of fractional decimal places
 * @param fractionGroups the sizes of option fractional decimal-place groups
 */
private static int calculateFractionPlaces(BigDecimal unitCount,int scale,int minDecimals,List<Integer> fractionGroups){
  int places=minDecimals;
  for (  int group : fractionGroups) {
    places+=group;
  }
  int max=Math.min(places,offSatoshis(scale));
  places=Math.min(minDecimals,max);
  for (  int group : fractionGroups) {
    if (unitCount.setScale(places,HALF_UP).compareTo(unitCount.setScale(max,HALF_UP)) == 0)     break;
    places+=group;
    if (places > max)     places=max;
  }
  return places;
}",0.9990566037735849
85605,"/** 
 * Return a representation of the pattern used by this instance for formatting and parsing.  The format is similar to, but not the same as the format recognized by the  {@link Builder.pattern()} and {@link Builder.localizedPattern()} methods.  The patternreturned by this method is localized, any currency signs expressed are literally, and optional fractional decimal places are shown grouped in parentheses. 
 */
public String pattern(){
synchronized (numberFormat) {
    StringBuilder groups=new StringBuilder();
    for (    int group : decimalGroups) {
      groups.append(""String_Node_Str"").append(Strings.repeat(""String_Node_Str"",group)).append(""String_Node_Str"");
    }
    DecimalFormatSymbols s=numberFormat.getDecimalFormatSymbols();
    String digit=String.valueOf(s.getDigit());
    String exp=s.getExponentSeparator();
    String groupSep=String.valueOf(s.getGroupingSeparator());
    String moneySep=String.valueOf(s.getMonetaryDecimalSeparator());
    String zero=String.valueOf(s.getZeroDigit());
    String boundary=String.valueOf(s.getPatternSeparator());
    String minus=String.valueOf(s.getMinusSign());
    String decSep=String.valueOf(s.getDecimalSeparator());
    String prefixAndNumber=""String_Node_Str"" + boundary + ""String_Node_Str""+ ""String_Node_Str""+ Matcher.quoteReplacement(digit + zero + groupSep+ decSep+ moneySep)+ ""String_Node_Str""+ ""String_Node_Str""+ Matcher.quoteReplacement(digit + zero + groupSep+ decSep+ moneySep+ exp)+ ""String_Node_Str"";
    return numberFormat.toLocalizedPattern().replaceAll(prefixAndNumber,""String_Node_Str"" + groups.toString()).replaceAll(""String_Node_Str"",Matcher.quoteReplacement(coinCode())).replaceAll(""String_Node_Str"",Matcher.quoteReplacement(coinSymbol()));
  }
}","/** 
 * Return a representation of the pattern used by this instance for formatting and parsing.  The format is similar to, but not the same as the format recognized by the  {@link Builder#pattern} and {@link Builder#localizedPattern} methods.  The patternreturned by this method is localized, any currency signs expressed are literally, and optional fractional decimal places are shown grouped in parentheses. 
 */
public String pattern(){
synchronized (numberFormat) {
    StringBuilder groups=new StringBuilder();
    for (    int group : decimalGroups) {
      groups.append(""String_Node_Str"").append(Strings.repeat(""String_Node_Str"",group)).append(""String_Node_Str"");
    }
    DecimalFormatSymbols s=numberFormat.getDecimalFormatSymbols();
    String digit=String.valueOf(s.getDigit());
    String exp=s.getExponentSeparator();
    String groupSep=String.valueOf(s.getGroupingSeparator());
    String moneySep=String.valueOf(s.getMonetaryDecimalSeparator());
    String zero=String.valueOf(s.getZeroDigit());
    String boundary=String.valueOf(s.getPatternSeparator());
    String minus=String.valueOf(s.getMinusSign());
    String decSep=String.valueOf(s.getDecimalSeparator());
    String prefixAndNumber=""String_Node_Str"" + boundary + ""String_Node_Str""+ ""String_Node_Str""+ Matcher.quoteReplacement(digit + zero + groupSep+ decSep+ moneySep)+ ""String_Node_Str""+ ""String_Node_Str""+ Matcher.quoteReplacement(digit + zero + groupSep+ decSep+ moneySep+ exp)+ ""String_Node_Str"";
    return numberFormat.toLocalizedPattern().replaceAll(prefixAndNumber,""String_Node_Str"" + groups.toString()).replaceAll(""String_Node_Str"",Matcher.quoteReplacement(coinCode())).replaceAll(""String_Node_Str"",Matcher.quoteReplacement(coinSymbol()));
  }
}",0.9936672423719056
85606,"/** 
 * Parse a human readable fiat value to a   {@link org.bitcoinj.core.Fiat} instance.
 * @throws NumberFormatException if the string cannot be parsed for some reason
 */
public Fiat parseFiat(String currencyCode,String str) throws NumberFormatException {
  return Fiat.valueOf(currencyCode,parseValue(str,Fiat.SMALLEST_UNIT_EXPONENT));
}","/** 
 * Parse a human readable fiat value to a   {@link org.bitcoinj.utils.Fiat} instance.
 * @throws NumberFormatException if the string cannot be parsed for some reason
 */
public Fiat parseFiat(String currencyCode,String str) throws NumberFormatException {
  return Fiat.valueOf(currencyCode,parseValue(str,Fiat.SMALLEST_UNIT_EXPONENT));
}",0.986822840409956
85607,"/** 
 * Uses the checksum in the last 4 bytes of the decoded data to verify the rest are correct. The checksum is removed from the returned data.
 * @throws AddressFormatException if the input is not base 58 or the checksum does not validate.
 */
public static byte[] decodeChecked(String input) throws AddressFormatException {
  byte tmp[]=decode(input);
  if (tmp.length < 4)   throw new AddressFormatException(""String_Node_Str"");
  byte[] bytes=copyOfRange(tmp,0,tmp.length - 4);
  byte[] checksum=copyOfRange(tmp,tmp.length - 4,tmp.length);
  tmp=Sha256Hash.hashTwice(bytes);
  byte[] hash=copyOfRange(tmp,0,4);
  if (!Arrays.equals(checksum,hash))   throw new AddressFormatException(""String_Node_Str"");
  return bytes;
}","/** 
 * Uses the checksum in the last 4 bytes of the decoded data to verify the rest are correct. The checksum is removed from the returned data.
 * @throws AddressFormatException if the input is not base 58 or the checksum does not validate.
 */
public static byte[] decodeChecked(String input) throws AddressFormatException {
  byte[] tmp=decode(input);
  if (tmp.length < 4)   throw new AddressFormatException(""String_Node_Str"");
  byte[] bytes=copyOfRange(tmp,0,tmp.length - 4);
  byte[] checksum=copyOfRange(tmp,tmp.length - 4,tmp.length);
  tmp=Sha256Hash.hashTwice(bytes);
  byte[] hash=copyOfRange(tmp,0,4);
  if (!Arrays.equals(checksum,hash))   throw new AddressFormatException(""String_Node_Str"");
  return bytes;
}",0.9944827586206896
85608,"/** 
 * Returns an immutable list of transactions held in this block, or null if this object represents just a header. 
 */
public @Nullable List<Transaction> getTransactions(){
  maybeParseTransactions();
  if (transactions == null)   return null;
 else   return ImmutableList.copyOf(transactions);
}","/** 
 * Returns an immutable list of transactions held in this block, or null if this object represents just a header. 
 */
@Nullable public List<Transaction> getTransactions(){
  maybeParseTransactions();
  return transactions == null ? null : ImmutableList.copyOf(transactions);
}",0.888507718696398
85609,"@Override final protected void bitcoinSerializeToStream(OutputStream stream) throws IOException {
}","@Override protected final void bitcoinSerializeToStream(OutputStream stream) throws IOException {
}",0.9393939393939394
85610,"/** 
 * <p>Returns true if this transaction is considered finalized and can be placed in a block. Non-finalized transactions won't be included by miners and can be replaced with newer versions using sequence numbers. This is useful in certain types of <a href=""http://en.bitcoin.it/wiki/Contracts"">contracts</a>, such as micropayment channels.</p> <p>Note that currently the replacement feature is disabled in the Satoshi client and will need to be re-activated before this functionality is useful.</p>
 */
public boolean isFinal(int height,long blockTimeSeconds){
  long time=getLockTime();
  if (time < (time < LOCKTIME_THRESHOLD ? height : blockTimeSeconds))   return true;
  if (!isTimeLocked())   return true;
  return false;
}","/** 
 * <p>Returns true if this transaction is considered finalized and can be placed in a block. Non-finalized transactions won't be included by miners and can be replaced with newer versions using sequence numbers. This is useful in certain types of <a href=""http://en.bitcoin.it/wiki/Contracts"">contracts</a>, such as micropayment channels.</p> <p>Note that currently the replacement feature is disabled in the Satoshi client and will need to be re-activated before this functionality is useful.</p>
 */
public boolean isFinal(int height,long blockTimeSeconds){
  long time=getLockTime();
  return time < (time < LOCKTIME_THRESHOLD ? height : blockTimeSeconds) || !isTimeLocked();
}",0.9513055751587862
85611,"/** 
 * Writes <code>len</code> bytes from the specified byte array starting at offset <code>off</code> to this byte array output stream.
 * @param b   the data.
 * @param off the start offset in the data.
 * @param len the number of bytes to write.
 */
@Override public void write(byte b[],int off,int len){
  if ((off < 0) || (off > b.length) || (len < 0)|| ((off + len) > b.length)|| ((off + len) < 0)) {
    throw new IndexOutOfBoundsException();
  }
 else   if (len == 0) {
    return;
  }
  int newcount=count + len;
  if (newcount > buf.length) {
    buf=Utils.copyOf(buf,Math.max(buf.length << 1,newcount));
  }
  System.arraycopy(b,off,buf,count,len);
  count=newcount;
}","/** 
 * Writes <code>len</code> bytes from the specified byte array starting at offset <code>off</code> to this byte array output stream.
 * @param b   the data.
 * @param off the start offset in the data.
 * @param len the number of bytes to write.
 */
@Override public void write(byte[] b,int off,int len){
  if ((off < 0) || (off > b.length) || (len < 0)|| ((off + len) > b.length)|| ((off + len) < 0)) {
    throw new IndexOutOfBoundsException();
  }
 else   if (len == 0) {
    return;
  }
  int newcount=count + len;
  if (newcount > buf.length) {
    buf=Utils.copyOf(buf,Math.max(buf.length << 1,newcount));
  }
  System.arraycopy(b,off,buf,count,len);
  count=newcount;
}",0.9970588235294118
85612,"/** 
 * Returns either a string that ""sums up"" the certificate for humans, in a similar manner to what you might see in a web browser, or null if one cannot be extracted. This will typically be the common name (CN) field, but can also be the org (O) field, org+location+country if withLocation is set, or the email address for S/MIME certificates.
 */
public static @Nullable String getDisplayNameFromCertificate(@Nonnull X509Certificate certificate,boolean withLocation) throws CertificateParsingException {
  X500Name name=new X500Name(certificate.getSubjectX500Principal().getName());
  String commonName=null, org=null, location=null, country=null;
  for (  RDN rdn : name.getRDNs()) {
    AttributeTypeAndValue pair=rdn.getFirst();
    String val=((ASN1String)pair.getValue()).getString();
    ASN1ObjectIdentifier type=pair.getType();
    if (type.equals(RFC4519Style.cn))     commonName=val;
 else     if (type.equals(RFC4519Style.o))     org=val;
 else     if (type.equals(RFC4519Style.l))     location=val;
 else     if (type.equals(RFC4519Style.c))     country=val;
  }
  final Collection<List<?>> subjectAlternativeNames=certificate.getSubjectAlternativeNames();
  String altName=null;
  if (subjectAlternativeNames != null)   for (  final List<?> subjectAlternativeName : subjectAlternativeNames)   if ((Integer)subjectAlternativeName.get(0) == 1)   altName=(String)subjectAlternativeName.get(1);
  if (org != null) {
    return withLocation ? Joiner.on(""String_Node_Str"").skipNulls().join(org,location,country) : org;
  }
 else   if (commonName != null) {
    return commonName;
  }
 else {
    return altName;
  }
}","/** 
 * Returns either a string that ""sums up"" the certificate for humans, in a similar manner to what you might see in a web browser, or null if one cannot be extracted. This will typically be the common name (CN) field, but can also be the org (O) field, org+location+country if withLocation is set, or the email address for S/MIME certificates.
 */
@Nullable public static String getDisplayNameFromCertificate(@Nonnull X509Certificate certificate,boolean withLocation) throws CertificateParsingException {
  X500Name name=new X500Name(certificate.getSubjectX500Principal().getName());
  String commonName=null, org=null, location=null, country=null;
  for (  RDN rdn : name.getRDNs()) {
    AttributeTypeAndValue pair=rdn.getFirst();
    String val=((ASN1String)pair.getValue()).getString();
    ASN1ObjectIdentifier type=pair.getType();
    if (type.equals(RFC4519Style.cn))     commonName=val;
 else     if (type.equals(RFC4519Style.o))     org=val;
 else     if (type.equals(RFC4519Style.l))     location=val;
 else     if (type.equals(RFC4519Style.c))     country=val;
  }
  final Collection<List<?>> subjectAlternativeNames=certificate.getSubjectAlternativeNames();
  String altName=null;
  if (subjectAlternativeNames != null)   for (  final List<?> subjectAlternativeName : subjectAlternativeNames)   if ((Integer)subjectAlternativeName.get(0) == 1)   altName=(String)subjectAlternativeName.get(1);
  if (org != null) {
    return withLocation ? Joiner.on(""String_Node_Str"").skipNulls().join(org,location,country) : org;
  }
 else   if (commonName != null) {
    return commonName;
  }
 else {
    return altName;
  }
}",0.9938612645794966
85613,"static ArrayList<InetSocketAddress> parseUserList(String[] userNames) throws UnknownHostException {
  ArrayList<InetSocketAddress> addresses=new ArrayList<InetSocketAddress>();
  for (  String user : userNames) {
    if (!user.startsWith(""String_Node_Str"")) {
      continue;
    }
    byte[] addressBytes;
    try {
      addressBytes=Base58.decodeChecked(user.substring(1));
    }
 catch (    AddressFormatException e) {
      log.warn(""String_Node_Str"" + user);
      continue;
    }
    if (addressBytes.length != 6) {
      continue;
    }
    byte[] ipBytes=new byte[]{addressBytes[0],addressBytes[1],addressBytes[2],addressBytes[3]};
    int port=Utils.readUint16BE(addressBytes,4);
    InetAddress ip;
    try {
      ip=InetAddress.getByAddress(ipBytes);
    }
 catch (    UnknownHostException e) {
      continue;
    }
    InetSocketAddress address=new InetSocketAddress(ip,port);
    addresses.add(address);
  }
  return addresses;
}","static ArrayList<InetSocketAddress> parseUserList(String[] userNames) throws UnknownHostException {
  ArrayList<InetSocketAddress> addresses=new ArrayList<InetSocketAddress>();
  for (  String user : userNames) {
    if (!user.startsWith(""String_Node_Str"")) {
      continue;
    }
    byte[] addressBytes;
    try {
      addressBytes=Base58.decodeChecked(user.substring(1));
    }
 catch (    AddressFormatException e) {
      log.warn(""String_Node_Str"" + user);
      continue;
    }
    if (addressBytes.length != 6) {
      continue;
    }
    byte[] ipBytes={addressBytes[0],addressBytes[1],addressBytes[2],addressBytes[3]};
    int port=Utils.readUint16BE(addressBytes,4);
    InetAddress ip;
    try {
      ip=InetAddress.getByAddress(ipBytes);
    }
 catch (    UnknownHostException e) {
      continue;
    }
    InetSocketAddress address=new InetSocketAddress(ip,port);
    addresses.add(address);
  }
  return addresses;
}",0.9946808510638298
85614,"/** 
 * Uses the provided PKI method to find the corresponding public key and verify the provided signature.
 * @param paymentRequest Payment request to verify.
 * @param trustStore KeyStore of trusted root certificate authorities.
 * @return verification data, or null if no PKI method was specified in the {@link Protos.PaymentRequest}.
 * @throws PaymentProtocolException if payment request could not be verified.
 */
public static @Nullable PkiVerificationData verifyPaymentRequestPki(Protos.PaymentRequest paymentRequest,KeyStore trustStore) throws PaymentProtocolException {
  List<X509Certificate> certs=null;
  try {
    final String pkiType=paymentRequest.getPkiType();
    if (pkiType.equals(""String_Node_Str""))     return null;
    String algorithm;
    if (pkiType.equals(""String_Node_Str""))     algorithm=""String_Node_Str"";
 else     if (pkiType.equals(""String_Node_Str""))     algorithm=""String_Node_Str"";
 else     throw new PaymentProtocolException.InvalidPkiType(""String_Node_Str"" + pkiType);
    Protos.X509Certificates protoCerts=Protos.X509Certificates.parseFrom(paymentRequest.getPkiData());
    if (protoCerts.getCertificateCount() == 0)     throw new PaymentProtocolException.InvalidPkiData(""String_Node_Str"");
    CertificateFactory certificateFactory=CertificateFactory.getInstance(""String_Node_Str"");
    certs=Lists.newArrayList();
    for (    ByteString bytes : protoCerts.getCertificateList())     certs.add((X509Certificate)certificateFactory.generateCertificate(bytes.newInput()));
    CertPath path=certificateFactory.generateCertPath(certs);
    PKIXParameters params=new PKIXParameters(trustStore);
    params.setRevocationEnabled(false);
    CertPathValidator validator=CertPathValidator.getInstance(""String_Node_Str"");
    PKIXCertPathValidatorResult result=(PKIXCertPathValidatorResult)validator.validate(path,params);
    PublicKey publicKey=result.getPublicKey();
    Signature signature=Signature.getInstance(algorithm);
    signature.initVerify(publicKey);
    Protos.PaymentRequest.Builder reqToCheck=paymentRequest.toBuilder();
    reqToCheck.setSignature(ByteString.EMPTY);
    signature.update(reqToCheck.build().toByteArray());
    if (!signature.verify(paymentRequest.getSignature().toByteArray()))     throw new PaymentProtocolException.PkiVerificationException(""String_Node_Str"");
    final X509Certificate cert=certs.get(0);
    String displayName=X509Utils.getDisplayNameFromCertificate(cert,true);
    if (displayName == null)     throw new PaymentProtocolException.PkiVerificationException(""String_Node_Str"");
    return new PkiVerificationData(displayName,publicKey,result.getTrustAnchor());
  }
 catch (  InvalidProtocolBufferException e) {
    throw new PaymentProtocolException.InvalidPkiData(e);
  }
catch (  CertificateException e) {
    throw new PaymentProtocolException.PkiVerificationException(e);
  }
catch (  NoSuchAlgorithmException e) {
    throw new RuntimeException(e);
  }
catch (  InvalidAlgorithmParameterException e) {
    throw new RuntimeException(e);
  }
catch (  CertPathValidatorException e) {
    throw new PaymentProtocolException.PkiVerificationException(e,certs);
  }
catch (  InvalidKeyException e) {
    throw new PaymentProtocolException.PkiVerificationException(e);
  }
catch (  SignatureException e) {
    throw new PaymentProtocolException.PkiVerificationException(e);
  }
catch (  KeyStoreException e) {
    throw new RuntimeException(e);
  }
}","/** 
 * Uses the provided PKI method to find the corresponding public key and verify the provided signature.
 * @param paymentRequest Payment request to verify.
 * @param trustStore KeyStore of trusted root certificate authorities.
 * @return verification data, or null if no PKI method was specified in the {@link Protos.PaymentRequest}.
 * @throws PaymentProtocolException if payment request could not be verified.
 */
@Nullable public static PkiVerificationData verifyPaymentRequestPki(Protos.PaymentRequest paymentRequest,KeyStore trustStore) throws PaymentProtocolException {
  List<X509Certificate> certs=null;
  try {
    final String pkiType=paymentRequest.getPkiType();
    if (pkiType.equals(""String_Node_Str""))     return null;
    String algorithm;
    if (pkiType.equals(""String_Node_Str""))     algorithm=""String_Node_Str"";
 else     if (pkiType.equals(""String_Node_Str""))     algorithm=""String_Node_Str"";
 else     throw new PaymentProtocolException.InvalidPkiType(""String_Node_Str"" + pkiType);
    Protos.X509Certificates protoCerts=Protos.X509Certificates.parseFrom(paymentRequest.getPkiData());
    if (protoCerts.getCertificateCount() == 0)     throw new PaymentProtocolException.InvalidPkiData(""String_Node_Str"");
    CertificateFactory certificateFactory=CertificateFactory.getInstance(""String_Node_Str"");
    certs=Lists.newArrayList();
    for (    ByteString bytes : protoCerts.getCertificateList())     certs.add((X509Certificate)certificateFactory.generateCertificate(bytes.newInput()));
    CertPath path=certificateFactory.generateCertPath(certs);
    PKIXParameters params=new PKIXParameters(trustStore);
    params.setRevocationEnabled(false);
    CertPathValidator validator=CertPathValidator.getInstance(""String_Node_Str"");
    PKIXCertPathValidatorResult result=(PKIXCertPathValidatorResult)validator.validate(path,params);
    PublicKey publicKey=result.getPublicKey();
    Signature signature=Signature.getInstance(algorithm);
    signature.initVerify(publicKey);
    Protos.PaymentRequest.Builder reqToCheck=paymentRequest.toBuilder();
    reqToCheck.setSignature(ByteString.EMPTY);
    signature.update(reqToCheck.build().toByteArray());
    if (!signature.verify(paymentRequest.getSignature().toByteArray()))     throw new PaymentProtocolException.PkiVerificationException(""String_Node_Str"");
    final X509Certificate cert=certs.get(0);
    String displayName=X509Utils.getDisplayNameFromCertificate(cert,true);
    if (displayName == null)     throw new PaymentProtocolException.PkiVerificationException(""String_Node_Str"");
    return new PkiVerificationData(displayName,publicKey,result.getTrustAnchor());
  }
 catch (  InvalidProtocolBufferException e) {
    throw new PaymentProtocolException.InvalidPkiData(e);
  }
catch (  CertificateException e) {
    throw new PaymentProtocolException.PkiVerificationException(e);
  }
catch (  NoSuchAlgorithmException e) {
    throw new RuntimeException(e);
  }
catch (  InvalidAlgorithmParameterException e) {
    throw new RuntimeException(e);
  }
catch (  CertPathValidatorException e) {
    throw new PaymentProtocolException.PkiVerificationException(e,certs);
  }
catch (  InvalidKeyException e) {
    throw new PaymentProtocolException.PkiVerificationException(e);
  }
catch (  SignatureException e) {
    throw new PaymentProtocolException.PkiVerificationException(e);
  }
catch (  KeyStoreException e) {
    throw new RuntimeException(e);
  }
}",0.9959219341683658
85615,"/** 
 * Generates a Payment message based on the information in the PaymentRequest. Provide transactions built by the wallet. If the PaymentRequest did not specify a payment_url, returns null.
 * @param txns list of transactions to be included with the Payment message.
 * @param refundAddr will be used by the merchant to send money back if there was a problem.
 * @param memo is a message to include in the payment message sent to the merchant.
 */
public @Nullable Protos.Payment getPayment(List<Transaction> txns,@Nullable Address refundAddr,@Nullable String memo) throws IOException, PaymentProtocolException.InvalidNetwork {
  if (paymentDetails.hasPaymentUrl()) {
    for (    Transaction tx : txns)     if (!tx.getParams().equals(params))     throw new PaymentProtocolException.InvalidNetwork(params.getPaymentProtocolId());
    return PaymentProtocol.createPaymentMessage(txns,totalValue,refundAddr,memo,getMerchantData());
  }
 else {
    return null;
  }
}","/** 
 * Generates a Payment message based on the information in the PaymentRequest. Provide transactions built by the wallet. If the PaymentRequest did not specify a payment_url, returns null.
 * @param txns list of transactions to be included with the Payment message.
 * @param refundAddr will be used by the merchant to send money back if there was a problem.
 * @param memo is a message to include in the payment message sent to the merchant.
 */
@Nullable public Protos.Payment getPayment(List<Transaction> txns,@Nullable Address refundAddr,@Nullable String memo) throws IOException, PaymentProtocolException.InvalidNetwork {
  if (paymentDetails.hasPaymentUrl()) {
    for (    Transaction tx : txns)     if (!tx.getParams().equals(params))     throw new PaymentProtocolException.InvalidNetwork(params.getPaymentProtocolId());
    return PaymentProtocol.createPaymentMessage(txns,totalValue,refundAddr,memo,getMerchantData());
  }
 else {
    return null;
  }
}",0.9927611168562565
85616,"/** 
 * Returns the payment url where the Payment message should be sent. Returns null if no payment url was provided in the PaymentRequest.
 */
public @Nullable String getPaymentUrl(){
  if (paymentDetails.hasPaymentUrl())   return paymentDetails.getPaymentUrl();
  return null;
}","/** 
 * Returns the payment url where the Payment message should be sent. Returns null if no payment url was provided in the PaymentRequest.
 */
@Nullable public String getPaymentUrl(){
  if (paymentDetails.hasPaymentUrl())   return paymentDetails.getPaymentUrl();
  return null;
}",0.9750889679715302
85617,"/** 
 * Calculate the balance for a coinbase, to-address, or p2sh address. <p>The balance   {@link org.bitcoinj.store.DatabaseFullPrunedBlockStore#getBalanceSelectSQL()} returnsthe balance (summed) as an number, then use calculateClientSide=false</p> <p>The balance  {@link org.bitcoinj.store.DatabaseFullPrunedBlockStore#getBalanceSelectSQL()} returnsthe all the openoutputs as stored in the DB (binary), then use calculateClientSide=true</p>
 * @param address The address to calculate the balance of
 * @return The balance of the address supplied.  If the address has not been seen, or there are no outputs open for thisaddress, the return value is 0.
 * @throws BlockStoreException If there is an error getting the balance.
 */
public BigInteger calculateBalanceForAddress(Address address) throws BlockStoreException {
  maybeConnect();
  PreparedStatement s=null;
  try {
    s=conn.get().prepareStatement(getBalanceSelectSQL());
    s.setString(1,address.toString());
    ResultSet rs=s.executeQuery();
    BigInteger balance=BigInteger.ZERO;
    while (rs.next()) {
      return BigInteger.valueOf(rs.getLong(1));
    }
    return balance;
  }
 catch (  SQLException ex) {
    throw new BlockStoreException(ex);
  }
 finally {
    if (s != null) {
      try {
        s.close();
      }
 catch (      SQLException e) {
        throw new BlockStoreException(""String_Node_Str"");
      }
    }
  }
}","/** 
 * Calculate the balance for a coinbase, to-address, or p2sh address. <p>The balance   {@link org.bitcoinj.store.DatabaseFullPrunedBlockStore#getBalanceSelectSQL()} returnsthe balance (summed) as an number, then use calculateClientSide=false</p> <p>The balance  {@link org.bitcoinj.store.DatabaseFullPrunedBlockStore#getBalanceSelectSQL()} returnsthe all the openoutputs as stored in the DB (binary), then use calculateClientSide=true</p>
 * @param address The address to calculate the balance of
 * @return The balance of the address supplied.  If the address has not been seen, or there are no outputs open for thisaddress, the return value is 0.
 * @throws BlockStoreException If there is an error getting the balance.
 */
public BigInteger calculateBalanceForAddress(Address address) throws BlockStoreException {
  maybeConnect();
  PreparedStatement s=null;
  try {
    s=conn.get().prepareStatement(getBalanceSelectSQL());
    s.setString(1,address.toString());
    ResultSet rs=s.executeQuery();
    BigInteger balance=BigInteger.ZERO;
    if (rs.next()) {
      return BigInteger.valueOf(rs.getLong(1));
    }
    return balance;
  }
 catch (  SQLException ex) {
    throw new BlockStoreException(ex);
  }
 finally {
    if (s != null) {
      try {
        s.close();
      }
 catch (      SQLException e) {
        throw new BlockStoreException(""String_Node_Str"");
      }
    }
  }
}",0.9975008925383791
85618,"/** 
 * Sets the number of fractional decimal places to be displayed on the given NumberFormat object to the value of the given integer.
 * @return The minimum and maximum fractional places settings that theformatter had before this change, as an ImmutableList. 
 */
private static ImmutableList<Integer> setFormatterDigits(DecimalFormat formatter,int min,int max){
  ImmutableList<Integer> ante=ImmutableList.<Integer>of(formatter.getMinimumFractionDigits(),formatter.getMaximumFractionDigits());
  formatter.setMinimumFractionDigits(min);
  formatter.setMaximumFractionDigits(max);
  return ante;
}","/** 
 * Sets the number of fractional decimal places to be displayed on the given NumberFormat object to the value of the given integer.
 * @return The minimum and maximum fractional places settings that theformatter had before this change, as an ImmutableList. 
 */
private static ImmutableList<Integer> setFormatterDigits(DecimalFormat formatter,int min,int max){
  ImmutableList<Integer> ante=ImmutableList.of(formatter.getMinimumFractionDigits(),formatter.getMaximumFractionDigits());
  formatter.setMinimumFractionDigits(min);
  formatter.setMaximumFractionDigits(max);
  return ante;
}",0.9924433249370276
85619,"private static List<Integer> boxAsList(int[] elements) throws IllegalArgumentException {
  List<Integer> list=new ArrayList<Integer>(elements.length);
  for (  int e : elements) {
    checkArgument(e > 0,""String_Node_Str"");
    list.add(e);
  }
  ;
  return list;
}","private static List<Integer> boxAsList(int[] elements) throws IllegalArgumentException {
  List<Integer> list=new ArrayList<Integer>(elements.length);
  for (  int e : elements) {
    checkArgument(e > 0,""String_Node_Str"");
    list.add(e);
  }
  return list;
}",0.9923954372623576
85620,"private @Nullable Result analyzeIsFinal(){
  if (tx.getConfidence().getSource() == TransactionConfidence.Source.SELF)   return Result.OK;
  if (wallet == null)   return null;
  final int height=wallet.getLastBlockSeenHeight();
  final long time=wallet.getLastBlockSeenTimeSecs();
  final int adjustedHeight=height + 1;
  if (!tx.isFinal(adjustedHeight,time)) {
    nonFinal=tx;
    return Result.NON_FINAL;
  }
  for (  Transaction dep : dependencies) {
    if (!dep.isFinal(adjustedHeight,time)) {
      nonFinal=dep;
      return Result.NON_FINAL;
    }
  }
  return Result.OK;
}","@Nullable private Result analyzeIsFinal(){
  if (tx.getConfidence().getSource() == TransactionConfidence.Source.SELF)   return Result.OK;
  if (wallet == null)   return null;
  final int height=wallet.getLastBlockSeenHeight();
  final long time=wallet.getLastBlockSeenTimeSecs();
  final int adjustedHeight=height + 1;
  if (!tx.isFinal(adjustedHeight,time)) {
    nonFinal=tx;
    return Result.NON_FINAL;
  }
  for (  Transaction dep : dependencies) {
    if (!dep.isFinal(adjustedHeight,time)) {
      nonFinal=dep;
      return Result.NON_FINAL;
    }
  }
  return Result.OK;
}",0.982788296041308
85621,"/** 
 * Get 1 header of the block number 1 (the first one is 0) in the chain
 */
@Test public void testHeaders1() throws Exception {
  BitcoinSerializer bs=new BitcoinSerializer(MainNetParams.get());
  String headersMessageBytesHex=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
  byte[] headersMessageBytes=HEX.decode(headersMessageBytesHex);
  HeadersMessage hm=(HeadersMessage)bs.deserialize(ByteBuffer.wrap(headersMessageBytes));
  Block block=hm.getBlockHeaders().get(0);
  String hash=block.getHashAsString();
  assertEquals(hash,""String_Node_Str"");
  assertNull(block.transactions);
  assertEquals(Utils.HEX.encode(block.getMerkleRoot().getBytes()),""String_Node_Str"");
  ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();
  bs.serialize(hm,byteArrayOutputStream);
  byte[] serializedBytes=byteArrayOutputStream.toByteArray();
  String serializedBytesHex=new String(HEX.encode(serializedBytes));
  assertEquals(headersMessageBytes.length,serializedBytes.length);
  assertEquals(true,Arrays.equals(headersMessageBytes,serializedBytes));
}","/** 
 * Get 1 header of the block number 1 (the first one is 0) in the chain
 */
@Test public void testHeaders1() throws Exception {
  BitcoinSerializer bs=new BitcoinSerializer(MainNetParams.get());
  String headersMessageBytesHex=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
  byte[] headersMessageBytes=HEX.decode(headersMessageBytesHex);
  HeadersMessage hm=(HeadersMessage)bs.deserialize(ByteBuffer.wrap(headersMessageBytes));
  Block block=hm.getBlockHeaders().get(0);
  String hash=block.getHashAsString();
  assertEquals(hash,""String_Node_Str"");
  assertNull(block.transactions);
  assertEquals(Utils.HEX.encode(block.getMerkleRoot().getBytes()),""String_Node_Str"");
  ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();
  bs.serialize(hm,byteArrayOutputStream);
  byte[] serializedBytes=byteArrayOutputStream.toByteArray();
  String serializedBytesHex=HEX.encode(serializedBytes);
  assertEquals(headersMessageBytes.length,serializedBytes.length);
  assertEquals(true,Arrays.equals(headersMessageBytes,serializedBytes));
}",0.9944954128440368
85622,"public RuleList getBlocksToTest(boolean runBarelyExpensiveTests,boolean runExpensiveTests,File blockStorageFile) throws ScriptException, ProtocolException, IOException {
  final FileOutputStream outStream=blockStorageFile != null ? new FileOutputStream(blockStorageFile) : null;
  final Script OP_TRUE_SCRIPT=new ScriptBuilder().op(OP_TRUE).build();
  final Script OP_NOP_SCRIPT=new ScriptBuilder().op(OP_NOP).build();
  List<Rule> blocks=new LinkedList<Rule>(){
    @Override public boolean add(    Rule element){
      if (outStream != null && element instanceof BlockAndValidity) {
        try {
          outStream.write((int)(params.getPacketMagic() >>> 24));
          outStream.write((int)(params.getPacketMagic() >>> 16));
          outStream.write((int)(params.getPacketMagic() >>> 8));
          outStream.write((int)(params.getPacketMagic() >>> 0));
          byte[] block=((BlockAndValidity)element).block.bitcoinSerialize();
          byte[] length=new byte[4];
          Utils.uint32ToByteArrayBE(block.length,length,0);
          outStream.write(Utils.reverseBytes(length));
          outStream.write(block);
          ((BlockAndValidity)element).block=null;
        }
 catch (        IOException e) {
          throw new RuntimeException(e);
        }
      }
      return super.add(element);
    }
  }
;
  RuleList ret=new RuleList(blocks,hashHeaderMap,10);
  Queue<TransactionOutPointWithValue> spendableOutputs=new LinkedList<TransactionOutPointWithValue>();
  int chainHeadHeight=1;
  Block chainHead=params.getGenesisBlock().createNextBlockWithCoinbase(coinbaseOutKeyPubKey);
  blocks.add(new BlockAndValidity(chainHead,true,false,chainHead.getHash(),1,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,chainHead.getTransactions().get(0).getHash()),FIFTY_COINS,chainHead.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  for (int i=1; i < params.getSpendableCoinbaseDepth(); i++) {
    chainHead=chainHead.createNextBlockWithCoinbase(coinbaseOutKeyPubKey);
    chainHeadHeight++;
    blocks.add(new BlockAndValidity(chainHead,true,false,chainHead.getHash(),i + 1,""String_Node_Str""));
    spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,chainHead.getTransactions().get(0).getHash()),FIFTY_COINS,chainHead.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  }
  NewBlock b1=createNextBlock(chainHead,chainHeadHeight + 1,spendableOutputs.poll(),null);
  blocks.add(new BlockAndValidity(b1,true,false,b1.getHash(),chainHeadHeight + 1,""String_Node_Str""));
  spendableOutputs.offer(b1.getCoinbaseOutput());
  TransactionOutPointWithValue out1=spendableOutputs.poll();
  checkState(out1 != null);
  NewBlock b2=createNextBlock(b1,chainHeadHeight + 2,out1,null);
  blocks.add(new BlockAndValidity(b2,true,false,b2.getHash(),chainHeadHeight + 2,""String_Node_Str""));
  blocks.add(new BlockAndValidity(b2,true,false,b2.getHash(),chainHeadHeight + 2,""String_Node_Str""));
  spendableOutputs.offer(b2.getCoinbaseOutput());
  NewBlock b3=createNextBlock(b1,chainHeadHeight + 2,out1,null);
  blocks.add(new BlockAndValidity(b3,true,false,b2.getHash(),chainHeadHeight + 2,""String_Node_Str""));
  blocks.add(new BlockAndValidity(b3,true,false,b2.getHash(),chainHeadHeight + 2,""String_Node_Str""));
  UTXORule utxo1;
{
    Transaction coinbase=b2.block.getTransactions().get(0);
    TransactionOutPoint outpoint=new TransactionOutPoint(params,0,coinbase.getHash());
    long[] heights=new long[]{chainHeadHeight + 2};
    UTXOsMessage result=new UTXOsMessage(params,ImmutableList.of(coinbase.getOutput(0)),heights,b2.getHash(),chainHeadHeight + 2);
    utxo1=new UTXORule(""String_Node_Str"",outpoint,result);
    blocks.add(utxo1);
  }
  TransactionOutPointWithValue out2=checkNotNull(spendableOutputs.poll());
  NewBlock b4=createNextBlock(b3,chainHeadHeight + 3,out2,null);
  blocks.add(new BlockAndValidity(b4,true,false,b4.getHash(),chainHeadHeight + 3,""String_Node_Str""));
{
    Transaction coinbase=b4.block.getTransactions().get(0);
    TransactionOutPoint outpoint=new TransactionOutPoint(params,0,coinbase.getHash());
    List<TransactionOutPoint> queries=ImmutableList.of(utxo1.query.get(0),outpoint);
    List<TransactionOutput> results=Lists.asList(null,coinbase.getOutput(0),new TransactionOutput[]{});
    long[] heights=new long[]{chainHeadHeight + 3};
    UTXOsMessage result=new UTXOsMessage(params,results,heights,b4.getHash(),chainHeadHeight + 3);
    UTXORule utxo2=new UTXORule(""String_Node_Str"",queries,result);
    blocks.add(utxo2);
  }
  NewBlock b5=createNextBlock(b2,chainHeadHeight + 3,out2,null);
  blocks.add(new BlockAndValidity(b5,true,false,b4.getHash(),chainHeadHeight + 3,""String_Node_Str""));
  spendableOutputs.offer(b5.getCoinbaseOutput());
  TransactionOutPointWithValue out3=spendableOutputs.poll();
  NewBlock b6=createNextBlock(b5,chainHeadHeight + 4,out3,null);
  blocks.add(new BlockAndValidity(b6,true,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  NewBlock b7=createNextBlock(b5,chainHeadHeight + 5,out2,null);
  blocks.add(new BlockAndValidity(b7,true,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  TransactionOutPointWithValue out4=spendableOutputs.poll();
  NewBlock b8=createNextBlock(b7,chainHeadHeight + 6,out4,null);
  blocks.add(new BlockAndValidity(b8,false,true,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  NewBlock b9=createNextBlock(b6,chainHeadHeight + 5,out4,SATOSHI);
  blocks.add(new BlockAndValidity(b9,false,true,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  NewBlock b10=createNextBlock(b5,chainHeadHeight + 4,out3,null);
  blocks.add(new BlockAndValidity(b10,true,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  NewBlock b11=createNextBlock(b10,chainHeadHeight + 5,out4,SATOSHI);
  blocks.add(new BlockAndValidity(b11,false,true,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  NewBlock b12=createNextBlock(b5,chainHeadHeight + 4,out3,null);
  spendableOutputs.offer(b12.getCoinbaseOutput());
  NewBlock b13=createNextBlock(b12,chainHeadHeight + 5,out4,null);
  blocks.add(new BlockAndValidity(b13,false,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  blocks.add(new BlockAndValidity(b13,false,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  spendableOutputs.offer(b13.getCoinbaseOutput());
  TransactionOutPointWithValue out5=spendableOutputs.poll();
  NewBlock b14=createNextBlock(b13,chainHeadHeight + 6,out5,SATOSHI);
  blocks.add(new BlockAndValidity(b14,false,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  blocks.add(new BlockAndValidity(b14,false,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  blocks.add(new BlockAndValidity(b12,false,true,b13.getHash(),chainHeadHeight + 5,""String_Node_Str""));
  NewBlock b15=createNextBlock(b13,chainHeadHeight + 6,out5,null);
{
    int sigOps=0;
    for (    Transaction tx : b15.block.getTransactions())     sigOps+=tx.getSigOpCount();
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,b15);
    b15.addTransaction(tx);
    sigOps=0;
    for (    Transaction tx2 : b15.block.getTransactions())     sigOps+=tx2.getSigOpCount();
    checkState(sigOps == Block.MAX_BLOCK_SIGOPS);
  }
  b15.solve();
  blocks.add(new BlockAndValidity(b15,true,false,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  spendableOutputs.offer(b15.getCoinbaseOutput());
  TransactionOutPointWithValue out6=spendableOutputs.poll();
  NewBlock b16=createNextBlock(b15,chainHeadHeight + 7,out6,null);
{
    int sigOps=0;
    for (    Transaction tx : b16.block.getTransactions()) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + 1];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,b16);
    b16.addTransaction(tx);
    sigOps=0;
    for (    Transaction tx2 : b16.block.getTransactions())     sigOps+=tx2.getSigOpCount();
    checkState(sigOps == Block.MAX_BLOCK_SIGOPS + 1);
  }
  b16.solve();
  blocks.add(new BlockAndValidity(b16,false,true,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  NewBlock b17=createNextBlock(b15,chainHeadHeight + 7,out6,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,new byte[]{}));
    addOnlyInputToTransaction(tx,b3);
    b17.addTransaction(tx);
  }
  b17.solve();
  blocks.add(new BlockAndValidity(b17,false,true,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  NewBlock b18=createNextBlock(b13,chainHeadHeight + 6,out5,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,new byte[]{}));
    addOnlyInputToTransaction(tx,b3);
    b18.addTransaction(tx);
  }
  b18.solve();
  blocks.add(new BlockAndValidity(b18,true,false,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  NewBlock b19=createNextBlock(b18,chainHeadHeight + 7,out6,null);
  blocks.add(new BlockAndValidity(b19,false,true,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  TransactionOutPointWithValue out7=spendableOutputs.poll();
  NewBlock b20=createNextBlock(b15.block,chainHeadHeight + 7,out7,null);
  blocks.add(new BlockAndValidity(b20,false,true,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  NewBlock b21=createNextBlock(b13,chainHeadHeight + 6,out6,null);
  blocks.add(new BlockAndValidity(b21.block,true,false,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  NewBlock b22=createNextBlock(b21,chainHeadHeight + 7,out5,null);
  blocks.add(new BlockAndValidity(b22.block,false,true,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  NewBlock b23=createNextBlock(b15,chainHeadHeight + 7,out6,null);
{
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIZE - b23.block.getMessageSize() - 65];
    Arrays.fill(outputScript,(byte)OP_FALSE);
    tx.addOutput(new TransactionOutput(params,tx,ZERO,outputScript));
    addOnlyInputToTransaction(tx,b23);
    b23.addTransaction(tx);
  }
  b23.solve();
  checkState(b23.block.getMessageSize() == Block.MAX_BLOCK_SIZE);
  blocks.add(new BlockAndValidity(b23,true,false,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  spendableOutputs.offer(b23.getCoinbaseOutput());
  NewBlock b24=createNextBlock(b15,chainHeadHeight + 7,out6,null);
{
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIZE - b24.block.getMessageSize() - 64];
    Arrays.fill(outputScript,(byte)OP_FALSE);
    tx.addOutput(new TransactionOutput(params,tx,ZERO,outputScript));
    addOnlyInputToTransaction(tx,b24);
    b24.addTransaction(tx);
  }
  b24.solve();
  checkState(b24.block.getMessageSize() == Block.MAX_BLOCK_SIZE + 1);
  blocks.add(new BlockAndValidity(b24,false,true,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  NewBlock b25=createNextBlock(b24,chainHeadHeight + 8,out7,null);
  blocks.add(new BlockAndValidity(b25,false,false,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  NewBlock b26=createNextBlock(b15,chainHeadHeight + 7,out6,null);
  b26.block.getTransactions().get(0).getInputs().get(0).setScriptBytes(new byte[]{0});
  b26.block.setMerkleRoot(null);
  b26.solve();
  blocks.add(new BlockAndValidity(b26,false,true,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  NewBlock b27=createNextBlock(b26,chainHeadHeight + 8,out7,null);
  blocks.add(new BlockAndValidity(b27,false,false,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  NewBlock b28=createNextBlock(b15,chainHeadHeight + 7,out6,null);
{
    byte[] coinbase=new byte[101];
    Arrays.fill(coinbase,(byte)0);
    b28.block.getTransactions().get(0).getInputs().get(0).setScriptBytes(coinbase);
  }
  b28.block.setMerkleRoot(null);
  b28.solve();
  blocks.add(new BlockAndValidity(b28,false,true,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  NewBlock b29=createNextBlock(b28,chainHeadHeight + 8,out7,null);
  blocks.add(new BlockAndValidity(b29,false,false,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  NewBlock b30=createNextBlock(b23,chainHeadHeight + 8,out7,null);
{
    byte[] coinbase=new byte[100];
    Arrays.fill(coinbase,(byte)0);
    b30.block.getTransactions().get(0).getInputs().get(0).setScriptBytes(coinbase);
  }
  b30.block.setMerkleRoot(null);
  b30.solve();
  blocks.add(new BlockAndValidity(b30,true,false,b30.getHash(),chainHeadHeight + 8,""String_Node_Str""));
  spendableOutputs.offer(b30.getCoinbaseOutput());
  TransactionOutPointWithValue out8=spendableOutputs.poll();
  NewBlock b31=createNextBlock(b30,chainHeadHeight + 9,out8,null);
{
    int sigOps=0;
    for (    Transaction tx : b31.block.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[(Block.MAX_BLOCK_SIGOPS - sigOps) / 20];
    Arrays.fill(outputScript,(byte)OP_CHECKMULTISIG);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,b31);
    b31.addTransaction(tx);
  }
  b31.solve();
  blocks.add(new BlockAndValidity(b31,true,false,b31.getHash(),chainHeadHeight + 9,""String_Node_Str""));
  spendableOutputs.offer(b31.getCoinbaseOutput());
  TransactionOutPointWithValue out9=spendableOutputs.poll();
  NewBlock b32=createNextBlock(b31,chainHeadHeight + 10,out9,null);
{
    int sigOps=0;
    for (    Transaction tx : b32.block.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[(Block.MAX_BLOCK_SIGOPS - sigOps) / 20 + (Block.MAX_BLOCK_SIGOPS - sigOps) % 20 + 1];
    Arrays.fill(outputScript,(byte)OP_CHECKMULTISIG);
    for (int i=0; i < (Block.MAX_BLOCK_SIGOPS - sigOps) % 20; i++)     outputScript[i]=(byte)OP_CHECKSIG;
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,b32);
    b32.addTransaction(tx);
  }
  b32.solve();
  blocks.add(new BlockAndValidity(b32,false,true,b31.getHash(),chainHeadHeight + 9,""String_Node_Str""));
  NewBlock b33=createNextBlock(b31,chainHeadHeight + 10,out9,null);
{
    int sigOps=0;
    for (    Transaction tx : b33.block.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[(Block.MAX_BLOCK_SIGOPS - sigOps) / 20];
    Arrays.fill(outputScript,(byte)OP_CHECKMULTISIGVERIFY);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,b33);
    b33.addTransaction(tx);
  }
  b33.solve();
  blocks.add(new BlockAndValidity(b33,true,false,b33.getHash(),chainHeadHeight + 10,""String_Node_Str""));
  spendableOutputs.offer(b33.getCoinbaseOutput());
  TransactionOutPointWithValue out10=spendableOutputs.poll();
  NewBlock b34=createNextBlock(b33,chainHeadHeight + 11,out10,null);
{
    int sigOps=0;
    for (    Transaction tx : b34.block.getTransactions()) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[(Block.MAX_BLOCK_SIGOPS - sigOps) / 20 + (Block.MAX_BLOCK_SIGOPS - sigOps) % 20 + 1];
    Arrays.fill(outputScript,(byte)OP_CHECKMULTISIGVERIFY);
    for (int i=0; i < (Block.MAX_BLOCK_SIGOPS - sigOps) % 20; i++)     outputScript[i]=(byte)OP_CHECKSIG;
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,b34);
    b34.addTransaction(tx);
  }
  b34.solve();
  blocks.add(new BlockAndValidity(b34,false,true,b33.getHash(),chainHeadHeight + 10,""String_Node_Str""));
  NewBlock b35=createNextBlock(b33,chainHeadHeight + 11,out10,null);
{
    int sigOps=0;
    for (    Transaction tx : b35.block.getTransactions()) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps];
    Arrays.fill(outputScript,(byte)OP_CHECKSIGVERIFY);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,b35);
    b35.addTransaction(tx);
  }
  b35.solve();
  blocks.add(new BlockAndValidity(b35,true,false,b35.getHash(),chainHeadHeight + 11,""String_Node_Str""));
  spendableOutputs.offer(b35.getCoinbaseOutput());
  TransactionOutPointWithValue out11=spendableOutputs.poll();
  NewBlock b36=createNextBlock(b35,chainHeadHeight + 12,out11,null);
{
    int sigOps=0;
    for (    Transaction tx : b36.block.getTransactions()) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + 1];
    Arrays.fill(outputScript,(byte)OP_CHECKSIGVERIFY);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,b36);
    b36.addTransaction(tx);
  }
  b36.solve();
  blocks.add(new BlockAndValidity(b36,false,true,b35.getHash(),chainHeadHeight + 11,""String_Node_Str""));
  NewBlock b37=createNextBlock(b35,chainHeadHeight + 12,out11,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,new byte[]{}));
    addOnlyInputToTransaction(tx,out11);
    b37.addTransaction(tx);
  }
  b37.solve();
  blocks.add(new BlockAndValidity(b37,false,true,b35.getHash(),chainHeadHeight + 11,""String_Node_Str""));
  NewBlock b38=createNextBlock(b35,chainHeadHeight + 12,out11,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,new byte[]{}));
    addOnlyInputToTransaction(tx,b37);
    b38.addTransaction(tx);
  }
  b38.solve();
  blocks.add(new BlockAndValidity(b38,false,true,b35.getHash(),chainHeadHeight + 11,""String_Node_Str""));
  byte[] b39p2shScriptPubKey;
  int b39numP2SHOutputs=0, b39sigOpsPerOutput=6;
  NewBlock b39=createNextBlock(b35,chainHeadHeight + 12,null,null);
{
    ByteArrayOutputStream p2shScriptPubKey=new UnsafeByteArrayOutputStream();
    try {
      Script.writeBytes(p2shScriptPubKey,coinbaseOutKeyPubKey);
      p2shScriptPubKey.write(OP_2DUP);
      p2shScriptPubKey.write(OP_CHECKSIGVERIFY);
      p2shScriptPubKey.write(OP_2DUP);
      p2shScriptPubKey.write(OP_CHECKSIGVERIFY);
      p2shScriptPubKey.write(OP_2DUP);
      p2shScriptPubKey.write(OP_CHECKSIGVERIFY);
      p2shScriptPubKey.write(OP_2DUP);
      p2shScriptPubKey.write(OP_CHECKSIGVERIFY);
      p2shScriptPubKey.write(OP_2DUP);
      p2shScriptPubKey.write(OP_CHECKSIGVERIFY);
      p2shScriptPubKey.write(OP_CHECKSIG);
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
    b39p2shScriptPubKey=p2shScriptPubKey.toByteArray();
    byte[] scriptHash=Utils.sha256hash160(b39p2shScriptPubKey);
    UnsafeByteArrayOutputStream scriptPubKey=new UnsafeByteArrayOutputStream(scriptHash.length + 3);
    scriptPubKey.write(OP_HASH160);
    try {
      Script.writeBytes(scriptPubKey,scriptHash);
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
    scriptPubKey.write(OP_EQUAL);
    Coin lastOutputValue=out11.value.subtract(SATOSHI);
    TransactionOutPoint lastOutPoint;
{
      Transaction tx=new Transaction(params);
      tx.addOutput(new TransactionOutput(params,tx,SATOSHI,scriptPubKey.toByteArray()));
      tx.addOutput(new TransactionOutput(params,tx,lastOutputValue,new byte[]{OP_1}));
      addOnlyInputToTransaction(tx,out11);
      lastOutPoint=new TransactionOutPoint(params,1,tx.getHash());
      b39.addTransaction(tx);
    }
    b39numP2SHOutputs++;
    while (b39.block.getMessageSize() < Block.MAX_BLOCK_SIZE) {
      Transaction tx=new Transaction(params);
      lastOutputValue=lastOutputValue.subtract(SATOSHI);
      tx.addOutput(new TransactionOutput(params,tx,SATOSHI,scriptPubKey.toByteArray()));
      tx.addOutput(new TransactionOutput(params,tx,lastOutputValue,new byte[]{OP_1}));
      tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},lastOutPoint));
      lastOutPoint=new TransactionOutPoint(params,1,tx.getHash());
      if (b39.block.getMessageSize() + tx.getMessageSize() < Block.MAX_BLOCK_SIZE) {
        b39.addTransaction(tx);
        b39numP2SHOutputs++;
      }
 else       break;
    }
  }
  b39.solve();
  blocks.add(new BlockAndValidity(b39,true,false,b39.getHash(),chainHeadHeight + 12,""String_Node_Str""));
  spendableOutputs.offer(b39.getCoinbaseOutput());
  TransactionOutPointWithValue out12=spendableOutputs.poll();
  NewBlock b40=createNextBlock(b39,chainHeadHeight + 13,out12,null);
{
    int sigOps=0;
    for (    Transaction tx : b40.block.getTransactions()) {
      sigOps+=tx.getSigOpCount();
    }
    int numTxes=(Block.MAX_BLOCK_SIGOPS - sigOps) / b39sigOpsPerOutput;
    checkState(numTxes <= b39numP2SHOutputs);
    TransactionOutPoint lastOutPoint=new TransactionOutPoint(params,1,b40.block.getTransactions().get(1).getHash());
    byte[] scriptSig=null;
    for (int i=1; i <= numTxes; i++) {
      Transaction tx=new Transaction(params);
      tx.addOutput(new TransactionOutput(params,tx,SATOSHI,new byte[]{OP_1}));
      tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},lastOutPoint));
      TransactionInput input=new TransactionInput(params,tx,new byte[]{},new TransactionOutPoint(params,0,b39.block.getTransactions().get(i).getHash()));
      tx.addInput(input);
      if (scriptSig == null) {
        Sha256Hash hash=tx.hashForSignature(1,b39p2shScriptPubKey,SigHash.SINGLE,false);
        try {
          ByteArrayOutputStream bos=new UnsafeByteArrayOutputStream(73);
          bos.write(coinbaseOutKey.sign(hash).encodeToDER());
          bos.write(SigHash.SINGLE.ordinal() + 1);
          byte[] signature=bos.toByteArray();
          ByteArrayOutputStream scriptSigBos=new UnsafeByteArrayOutputStream(signature.length + b39p2shScriptPubKey.length + 3);
          Script.writeBytes(scriptSigBos,new byte[]{(byte)OP_CHECKSIG});
          scriptSigBos.write(Script.createInputScript(signature));
          Script.writeBytes(scriptSigBos,b39p2shScriptPubKey);
          scriptSig=scriptSigBos.toByteArray();
        }
 catch (        IOException e) {
          throw new RuntimeException(e);
        }
      }
      input.setScriptBytes(scriptSig);
      lastOutPoint=new TransactionOutPoint(params,0,tx.getHash());
      b40.addTransaction(tx);
    }
    sigOps+=numTxes * b39sigOpsPerOutput;
    Transaction tx=new Transaction(params);
    tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},lastOutPoint));
    byte[] scriptPubKey=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + 1];
    Arrays.fill(scriptPubKey,(byte)OP_CHECKSIG);
    tx.addOutput(new TransactionOutput(params,tx,ZERO,scriptPubKey));
    b40.addTransaction(tx);
  }
  b40.solve();
  blocks.add(new BlockAndValidity(b40,false,true,b39.getHash(),chainHeadHeight + 12,""String_Node_Str""));
  NewBlock b41=null;
  if (runBarelyExpensiveTests) {
    b41=createNextBlock(b39,chainHeadHeight + 13,out12,null);
{
      int sigOps=0;
      for (      Transaction tx : b41.block.getTransactions()) {
        sigOps+=tx.getSigOpCount();
      }
      int numTxes=(Block.MAX_BLOCK_SIGOPS - sigOps) / b39sigOpsPerOutput;
      checkState(numTxes <= b39numP2SHOutputs);
      TransactionOutPoint lastOutPoint=new TransactionOutPoint(params,1,b41.block.getTransactions().get(1).getHash());
      byte[] scriptSig=null;
      for (int i=1; i <= numTxes; i++) {
        Transaction tx=new Transaction(params);
        tx.addOutput(new TransactionOutput(params,tx,Coin.SATOSHI,new byte[]{OP_1}));
        tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},lastOutPoint));
        TransactionInput input=new TransactionInput(params,tx,new byte[]{},new TransactionOutPoint(params,0,b39.block.getTransactions().get(i).getHash()));
        tx.addInput(input);
        if (scriptSig == null) {
          Sha256Hash hash=tx.hashForSignature(1,b39p2shScriptPubKey,SigHash.SINGLE,false);
          try {
            ByteArrayOutputStream bos=new UnsafeByteArrayOutputStream(73);
            bos.write(coinbaseOutKey.sign(hash).encodeToDER());
            bos.write(SigHash.SINGLE.ordinal() + 1);
            byte[] signature=bos.toByteArray();
            ByteArrayOutputStream scriptSigBos=new UnsafeByteArrayOutputStream(signature.length + b39p2shScriptPubKey.length + 3);
            Script.writeBytes(scriptSigBos,new byte[]{(byte)OP_CHECKSIG});
            scriptSigBos.write(Script.createInputScript(signature));
            Script.writeBytes(scriptSigBos,b39p2shScriptPubKey);
            scriptSig=scriptSigBos.toByteArray();
          }
 catch (          IOException e) {
            throw new RuntimeException(e);
          }
        }
        input.setScriptBytes(scriptSig);
        lastOutPoint=new TransactionOutPoint(params,0,tx.getHash());
        b41.addTransaction(tx);
      }
      sigOps+=numTxes * b39sigOpsPerOutput;
      Transaction tx=new Transaction(params);
      tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},lastOutPoint));
      byte[] scriptPubKey=new byte[Block.MAX_BLOCK_SIGOPS - sigOps];
      Arrays.fill(scriptPubKey,(byte)OP_CHECKSIG);
      tx.addOutput(new TransactionOutput(params,tx,ZERO,scriptPubKey));
      b41.addTransaction(tx);
    }
    b41.solve();
    blocks.add(new BlockAndValidity(b41,true,false,b41.getHash(),chainHeadHeight + 13,""String_Node_Str""));
  }
  NewBlock b42=createNextBlock(b39,chainHeadHeight + 13,out12,null);
  blocks.add(new BlockAndValidity(b42,true,false,b41 == null ? b42.getHash() : b41.getHash(),chainHeadHeight + 13,""String_Node_Str""));
  spendableOutputs.offer(b42.getCoinbaseOutput());
  TransactionOutPointWithValue out13=spendableOutputs.poll();
  NewBlock b43=createNextBlock(b42,chainHeadHeight + 14,out13,null);
  blocks.add(new BlockAndValidity(b43,true,false,b43.getHash(),chainHeadHeight + 14,""String_Node_Str""));
  spendableOutputs.offer(b43.getCoinbaseOutput());
  TransactionOutPointWithValue out14=spendableOutputs.poll();
  Block b44=new Block(params);
  byte[] outScriptBytes=ScriptBuilder.createOutputScript(ECKey.fromPublicOnly(coinbaseOutKeyPubKey)).getProgram();
{
    b44.setDifficultyTarget(b43.block.getDifficultyTarget());
    b44.addCoinbaseTransaction(coinbaseOutKeyPubKey,ZERO);
    Transaction t=new Transaction(params);
    t.addOutput(new TransactionOutput(params,t,ZERO,new byte[]{OP_PUSHDATA1 - 1}));
    t.addOutput(new TransactionOutput(params,t,SATOSHI,outScriptBytes));
    t.addOutput(new TransactionOutput(params,t,ZERO,new byte[]{OP_1}));
    addOnlyInputToTransaction(t,out14);
    b44.addTransaction(t);
    b44.setPrevBlockHash(b43.getHash());
    b44.setTime(b43.block.getTimeSeconds() + 1);
  }
  b44.solve();
  blocks.add(new BlockAndValidity(b44,true,false,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  TransactionOutPointWithValue out15=spendableOutputs.poll();
  Block b45=new Block(params);
{
    b45.setDifficultyTarget(b44.getDifficultyTarget());
    Transaction t=new Transaction(params);
    t.addOutput(new TransactionOutput(params,t,ZERO,new byte[]{OP_PUSHDATA1 - 1}));
    t.addOutput(new TransactionOutput(params,t,SATOSHI,outScriptBytes));
    t.addOutput(new TransactionOutput(params,t,ZERO,new byte[]{OP_1}));
    addOnlyInputToTransaction(t,out15);
    try {
      b45.addTransaction(t);
    }
 catch (    RuntimeException e) {
    }
    if (b45.getTransactions().size() > 0)     throw new RuntimeException(""String_Node_Str"");
    b45.addTransaction(t,false);
    b45.setPrevBlockHash(b44.getHash());
    b45.setTime(b44.getTimeSeconds() + 1);
  }
  b45.solve();
  blocks.add(new BlockAndValidity(b45,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b46=new Block(params);
{
    b46.transactions=new ArrayList<Transaction>();
    b46.setDifficultyTarget(b44.getDifficultyTarget());
    b46.setMerkleRoot(Sha256Hash.ZERO_HASH);
    b46.setPrevBlockHash(b44.getHash());
    b46.setTime(b44.getTimeSeconds() + 1);
  }
  b46.solve();
  blocks.add(new BlockAndValidity(b46,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  NewBlock b47=createNextBlock(b44,chainHeadHeight + 16,out15,null);
{
    try {
      BigInteger target=b47.block.getDifficultyTargetAsInteger();
      while (true) {
        BigInteger h=b47.getHash().toBigInteger();
        if (h.compareTo(target) > 0)         break;
        b47.block.setNonce(b47.block.getNonce() + 1);
      }
    }
 catch (    VerificationException e) {
      throw new RuntimeException(e);
    }
  }
  blocks.add(new BlockAndValidity(b47,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  NewBlock b48=createNextBlock(b44,chainHeadHeight + 16,out15,null);
  b48.block.setTime(Utils.currentTimeSeconds() + 60 * 60 * 3);
  b48.solve();
  blocks.add(new BlockAndValidity(b48,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  NewBlock b49=createNextBlock(b44,chainHeadHeight + 16,out15,null);
  byte[] b49MerkleHash=Sha256Hash.ZERO_HASH.getBytes().clone();
  b49MerkleHash[1]=(byte)0xDE;
  b49.block.setMerkleRoot(Sha256Hash.of(b49MerkleHash));
  b49.solve();
  blocks.add(new BlockAndValidity(b49,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  NewBlock b50=createNextBlock(b44,chainHeadHeight + 16,out15,null);
{
    long diffTarget=b44.getDifficultyTarget();
    diffTarget&=0xFFBFFFFF;
    b50.block.setDifficultyTarget(diffTarget);
  }
  b50.solve();
  blocks.add(new BlockAndValidity(b50,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  NewBlock b51=createNextBlock(b44,chainHeadHeight + 16,out15,null);
{
    Transaction coinbase=new Transaction(params);
    coinbase.addInput(new TransactionInput(params,coinbase,new byte[]{(byte)0xff,110,1}));
    coinbase.addOutput(new TransactionOutput(params,coinbase,SATOSHI,outScriptBytes));
    b51.block.addTransaction(coinbase,false);
  }
  b51.solve();
  blocks.add(new BlockAndValidity(b51,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  NewBlock b52=createNextBlock(b44,chainHeadHeight + 16,out15,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,new byte[]{}));
    addOnlyInputToTransaction(tx,b52);
    b52.addTransaction(tx);
    b52.addTransaction(tx);
  }
  b52.solve();
  blocks.add(new BlockAndValidity(b52,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  NewBlock b53=createNextBlock(b43,chainHeadHeight + 15,out14,null);
  blocks.add(new BlockAndValidity(b53,true,false,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  spendableOutputs.offer(b53.getCoinbaseOutput());
  NewBlock b54=createNextBlock(b53,chainHeadHeight + 16,out15,null);
  b54.block.setTime(b35.block.getTimeSeconds() - 1);
  b54.solve();
  blocks.add(new BlockAndValidity(b54,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  NewBlock b55=createNextBlock(b53,chainHeadHeight + 16,out15,null);
  b55.block.setTime(b35.block.getTimeSeconds());
  b55.solve();
  blocks.add(new BlockAndValidity(b55,true,false,b55.getHash(),chainHeadHeight + 16,""String_Node_Str""));
  spendableOutputs.offer(b55.getCoinbaseOutput());
  TransactionOutPointWithValue out16=spendableOutputs.poll();
  NewBlock b57=createNextBlock(b55,chainHeadHeight + 17,out16,null);
  Transaction b56txToDuplicate;
{
    b56txToDuplicate=new Transaction(params);
    b56txToDuplicate.addOutput(new TransactionOutput(params,b56txToDuplicate,SATOSHI,new byte[]{}));
    addOnlyInputToTransaction(b56txToDuplicate,b57);
    b57.addTransaction(b56txToDuplicate);
  }
  b57.solve();
  Block b56;
  try {
    b56=new Block(params,b57.block.bitcoinSerialize());
  }
 catch (  ProtocolException e) {
    throw new RuntimeException(e);
  }
  b56.addTransaction(b56txToDuplicate);
  checkState(b56.getHash().equals(b57.getHash()));
  blocks.add(new BlockAndValidity(b56,false,true,b55.getHash(),chainHeadHeight + 16,""String_Node_Str""));
  NewBlock b57p2=createNextBlock(b55,chainHeadHeight + 17,out16,null);
  Transaction b56p2txToDuplicate1, b56p2txToDuplicate2;
{
    Transaction tx1=new Transaction(params);
    tx1.addOutput(new TransactionOutput(params,tx1,SATOSHI,new byte[]{OP_TRUE}));
    addOnlyInputToTransaction(tx1,b57p2);
    b57p2.addTransaction(tx1);
    Transaction tx2=new Transaction(params);
    tx2.addOutput(new TransactionOutput(params,tx2,SATOSHI,new byte[]{OP_TRUE}));
    addOnlyInputToTransaction(tx2,new TransactionOutPointWithValue(new TransactionOutPoint(params,0,tx1.getHash()),SATOSHI,tx1.getOutputs().get(0).getScriptPubKey()));
    b57p2.addTransaction(tx2);
    b56p2txToDuplicate1=new Transaction(params);
    b56p2txToDuplicate1.addOutput(new TransactionOutput(params,b56p2txToDuplicate1,SATOSHI,new byte[]{OP_TRUE}));
    addOnlyInputToTransaction(b56p2txToDuplicate1,new TransactionOutPointWithValue(new TransactionOutPoint(params,0,tx2.getHash()),SATOSHI,tx2.getOutputs().get(0).getScriptPubKey()));
    b57p2.addTransaction(b56p2txToDuplicate1);
    b56p2txToDuplicate2=new Transaction(params);
    b56p2txToDuplicate2.addOutput(new TransactionOutput(params,b56p2txToDuplicate2,SATOSHI,new byte[]{}));
    addOnlyInputToTransaction(b56p2txToDuplicate2,new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b56p2txToDuplicate1.getHash()),SATOSHI,b56p2txToDuplicate1.getOutputs().get(0).getScriptPubKey()));
    b57p2.addTransaction(b56p2txToDuplicate2);
  }
  b57p2.solve();
  Block b56p2;
  try {
    b56p2=new Block(params,b57p2.block.bitcoinSerialize());
  }
 catch (  ProtocolException e) {
    throw new RuntimeException(e);
  }
  b56p2.addTransaction(b56p2txToDuplicate1);
  b56p2.addTransaction(b56p2txToDuplicate2);
  checkState(b56p2.getHash().equals(b57p2.getHash()));
  blocks.add(new BlockAndValidity(b56p2,false,true,b55.getHash(),chainHeadHeight + 16,""String_Node_Str""));
  blocks.add(new BlockAndValidity(b57p2,true,false,b57p2.getHash(),chainHeadHeight + 17,""String_Node_Str""));
  blocks.add(new BlockAndValidity(b57,true,false,b57p2.getHash(),chainHeadHeight + 17,""String_Node_Str""));
  spendableOutputs.offer(b57.getCoinbaseOutput());
  TransactionOutPointWithValue out17=spendableOutputs.poll();
  NewBlock b58=createNextBlock(b57,chainHeadHeight + 18,out17,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,ZERO,new byte[]{}));
    b58.getSpendableOutput().outpoint.setIndex(42);
    addOnlyInputToTransaction(tx,b58);
    b58.addTransaction(tx);
  }
  b58.solve();
  blocks.add(new BlockAndValidity(b58,false,true,b57p2.getHash(),chainHeadHeight + 17,""String_Node_Str""));
  NewBlock b59=createNextBlock(b57,chainHeadHeight + 18,out17,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,b59.getSpendableOutput().value.add(SATOSHI),new byte[]{}));
    addOnlyInputToTransaction(tx,b59);
    b59.addTransaction(tx);
  }
  b59.solve();
  blocks.add(new BlockAndValidity(b59,false,true,b57p2.getHash(),chainHeadHeight + 17,""String_Node_Str""));
  NewBlock b60=createNextBlock(b57,chainHeadHeight + 18,out17,null);
  blocks.add(new BlockAndValidity(b60,true,false,b60.getHash(),chainHeadHeight + 18,""String_Node_Str""));
  spendableOutputs.offer(b60.getCoinbaseOutput());
  TransactionOutPointWithValue out18=spendableOutputs.poll();
  NewBlock b61=createNextBlock(b60,chainHeadHeight + 19,out18,null);
{
    b61.block.getTransactions().get(0).getInput(0).setScriptBytes(b60.block.getTransactions().get(0).getInput(0).getScriptBytes());
    b61.block.unCache();
    checkState(b61.block.getTransactions().get(0).equals(b60.block.getTransactions().get(0)));
  }
  b61.solve();
  blocks.add(new BlockAndValidity(b61,false,true,b60.getHash(),chainHeadHeight + 18,""String_Node_Str""));
  NewBlock b62=createNextBlock(b60,chainHeadHeight + 19,null,null);
{
    Transaction tx=new Transaction(params);
    tx.setLockTime(0xffffffffL);
    tx.addOutput(ZERO,OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(tx,out18,0);
    b62.addTransaction(tx);
    checkState(!tx.isFinal(chainHeadHeight + 17,b62.block.getTimeSeconds()));
  }
  b62.solve();
  blocks.add(new BlockAndValidity(b62,false,true,b60.getHash(),chainHeadHeight + 18,""String_Node_Str""));
  NewBlock b63=createNextBlock(b60,chainHeadHeight + 19,null,null);
{
    b63.block.getTransactions().get(0).setLockTime(0xffffffffL);
    b63.block.getTransactions().get(0).getInputs().get(0).setSequenceNumber(0xDEADBEEF);
    checkState(!b63.block.getTransactions().get(0).isFinal(chainHeadHeight + 17,b63.block.getTimeSeconds()));
  }
  b63.solve();
  blocks.add(new BlockAndValidity(b63,false,true,b60.getHash(),chainHeadHeight + 18,""String_Node_Str""));
  Block b64;
  NewBlock b64Original;
{
    b64Original=createNextBlock(b60,chainHeadHeight + 19,out18,null);
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIZE - b64Original.block.getMessageSize() - 65];
    Arrays.fill(outputScript,(byte)OP_FALSE);
    tx.addOutput(new TransactionOutput(params,tx,ZERO,outputScript));
    addOnlyInputToTransaction(tx,b64Original);
    b64Original.addTransaction(tx);
    b64Original.solve();
    checkState(b64Original.block.getMessageSize() == Block.MAX_BLOCK_SIZE);
    UnsafeByteArrayOutputStream stream=new UnsafeByteArrayOutputStream(b64Original.block.getMessageSize() + 8);
    b64Original.block.writeHeader(stream);
    byte[] varIntBytes=new byte[9];
    varIntBytes[0]=(byte)255;
    Utils.uint32ToByteArrayLE((long)b64Original.block.getTransactions().size(),varIntBytes,1);
    Utils.uint32ToByteArrayLE(((long)b64Original.block.getTransactions().size()) >>> 32,varIntBytes,5);
    stream.write(varIntBytes);
    checkState(new VarInt(varIntBytes,0).value == b64Original.block.getTransactions().size());
    for (    Transaction transaction : b64Original.block.getTransactions())     transaction.bitcoinSerialize(stream);
    b64=new Block(params,stream.toByteArray(),false,true,stream.size());
    checkState(stream.size() == b64Original.block.getMessageSize() + 8);
    checkState(stream.size() == b64.getMessageSize());
    checkState(Arrays.equals(stream.toByteArray(),b64.bitcoinSerialize()));
    checkState(b64.getOptimalEncodingMessageSize() == b64Original.block.getMessageSize());
  }
  blocks.add(new BlockAndValidity(b64,true,false,b64.getHash(),chainHeadHeight + 19,""String_Node_Str""));
  spendableOutputs.offer(b64Original.getCoinbaseOutput());
  TransactionOutPointWithValue out19=spendableOutputs.poll();
  checkState(out19 != null);
  NewBlock b65=createNextBlock(b64,chainHeadHeight + 20,null,null);
{
    Transaction tx1=new Transaction(params);
    tx1.addOutput(out19.value,OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(tx1,out19,0);
    b65.addTransaction(tx1);
    Transaction tx2=new Transaction(params);
    tx2.addOutput(ZERO,OP_TRUE_SCRIPT);
    tx2.addInput(tx1.getHash(),0,OP_TRUE_SCRIPT);
    b65.addTransaction(tx2);
  }
  b65.solve();
  blocks.add(new BlockAndValidity(b65,true,false,b65.getHash(),chainHeadHeight + 20,""String_Node_Str""));
  spendableOutputs.offer(b65.getCoinbaseOutput());
  TransactionOutPointWithValue out20=spendableOutputs.poll();
  checkState(out20 != null);
  NewBlock b66=createNextBlock(b65,chainHeadHeight + 21,null,null);
{
    Transaction tx1=new Transaction(params);
    tx1.addOutput(out20.value,OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(tx1,out20,0);
    Transaction tx2=new Transaction(params);
    tx2.addOutput(ZERO,OP_TRUE_SCRIPT);
    tx2.addInput(tx1.getHash(),0,OP_NOP_SCRIPT);
    b66.addTransaction(tx2);
    b66.addTransaction(tx1);
  }
  b66.solve();
  blocks.add(new BlockAndValidity(b66,false,true,b65.getHash(),chainHeadHeight + 20,""String_Node_Str""));
  NewBlock b67=createNextBlock(b65,chainHeadHeight + 21,null,null);
{
    Transaction tx1=new Transaction(params);
    tx1.addOutput(out20.value,OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(tx1,out20,0);
    b67.addTransaction(tx1);
    Transaction tx2=new Transaction(params);
    tx2.addOutput(ZERO,OP_TRUE_SCRIPT);
    tx2.addInput(tx1.getHash(),0,OP_NOP_SCRIPT);
    b67.addTransaction(tx2);
    Transaction tx3=new Transaction(params);
    tx3.addOutput(out20.value,OP_TRUE_SCRIPT);
    tx3.addInput(tx1.getHash(),0,OP_NOP_SCRIPT);
    b67.addTransaction(tx3);
  }
  b67.solve();
  blocks.add(new BlockAndValidity(b67,false,true,b65.getHash(),chainHeadHeight + 20,""String_Node_Str""));
  NewBlock b68=createNextBlock(b65,chainHeadHeight + 21,null,SATOSHI.multiply(10));
{
    Transaction tx=new Transaction(params);
    tx.addOutput(out20.value.subtract(Coin.valueOf(9)),OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(tx,out20,0);
    b68.addTransaction(tx);
  }
  b68.solve();
  blocks.add(new BlockAndValidity(b68,false,true,b65.getHash(),chainHeadHeight + 20,""String_Node_Str""));
  NewBlock b69=createNextBlock(b65,chainHeadHeight + 21,null,SATOSHI.multiply(10));
{
    Transaction tx=new Transaction(params);
    tx.addOutput(out20.value.subtract(Coin.valueOf(10)),OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(tx,out20,0);
    b69.addTransaction(tx);
  }
  b69.solve();
  blocks.add(new BlockAndValidity(b69,true,false,b69.getHash(),chainHeadHeight + 21,""String_Node_Str""));
  spendableOutputs.offer(b69.getCoinbaseOutput());
  TransactionOutPointWithValue out21=spendableOutputs.poll();
  checkState(out21 != null);
  NewBlock b70=createNextBlock(b69,chainHeadHeight + 22,out21,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(ZERO,OP_TRUE_SCRIPT);
    tx.addInput(Sha256Hash.wrap(""String_Node_Str""),0,OP_NOP_SCRIPT);
    b70.addTransaction(tx);
  }
  b70.solve();
  blocks.add(new BlockAndValidity(b70,false,true,b69.getHash(),chainHeadHeight + 21,""String_Node_Str""));
  NewBlock b72=createNextBlock(b69,chainHeadHeight + 22,out21,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(ZERO,OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(tx,b72);
    b72.addTransaction(tx);
  }
  b72.solve();
  Block b71=new Block(params,b72.block.bitcoinSerialize());
  b71.addTransaction(b72.block.getTransactions().get(2));
  checkState(b71.getHash().equals(b72.getHash()));
  blocks.add(new BlockAndValidity(b71,false,true,b69.getHash(),chainHeadHeight + 21,""String_Node_Str""));
  blocks.add(new BlockAndValidity(b72,true,false,b72.getHash(),chainHeadHeight + 22,""String_Node_Str""));
  spendableOutputs.offer(b72.getCoinbaseOutput());
  TransactionOutPointWithValue out22=spendableOutputs.poll();
  checkState(out22 != null);
  NewBlock b73=createNextBlock(b72,chainHeadHeight + 23,out22,null);
{
    int sigOps=0;
    for (    Transaction tx : b73.block.getTransactions()) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + (int)Script.MAX_SCRIPT_ELEMENT_SIZE + 1 + 5 + 1];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps]=OP_PUSHDATA4;
    Utils.uint32ToByteArrayLE(Script.MAX_SCRIPT_ELEMENT_SIZE + 1,outputScript,Block.MAX_BLOCK_SIGOPS - sigOps + 1);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,b73);
    b73.addTransaction(tx);
  }
  b73.solve();
  blocks.add(new BlockAndValidity(b73,false,true,b72.getHash(),chainHeadHeight + 22,""String_Node_Str""));
  NewBlock b74=createNextBlock(b72,chainHeadHeight + 23,out22,null);
{
    int sigOps=0;
    for (    Transaction tx : b74.block.getTransactions()) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + (int)Script.MAX_SCRIPT_ELEMENT_SIZE + 42];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 1]=OP_PUSHDATA4;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 2]=(byte)0xfe;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 3]=(byte)0xff;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 4]=(byte)0xff;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 5]=(byte)0xff;
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,b74);
    b74.addTransaction(tx);
  }
  b74.solve();
  blocks.add(new BlockAndValidity(b74,false,true,b72.getHash(),chainHeadHeight + 22,""String_Node_Str""));
  NewBlock b75=createNextBlock(b72,chainHeadHeight + 23,out22,null);
{
    int sigOps=0;
    for (    Transaction tx : b75.block.getTransactions()) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + (int)Script.MAX_SCRIPT_ELEMENT_SIZE + 42];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps]=OP_PUSHDATA4;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 1]=(byte)0xff;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 2]=(byte)0xff;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 3]=(byte)0xff;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 4]=(byte)0xff;
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,b75);
    b75.addTransaction(tx);
  }
  b75.solve();
  blocks.add(new BlockAndValidity(b75,true,false,b75.getHash(),chainHeadHeight + 23,""String_Node_Str""));
  spendableOutputs.offer(b75.getCoinbaseOutput());
  TransactionOutPointWithValue out23=spendableOutputs.poll();
  checkState(out23 != null);
  NewBlock b76=createNextBlock(b75,chainHeadHeight + 24,out23,null);
{
    int sigOps=0;
    for (    Transaction tx : b76.block.getTransactions()) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + (int)Script.MAX_SCRIPT_ELEMENT_SIZE + 1 + 5];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps]=OP_PUSHDATA4;
    Utils.uint32ToByteArrayLE(Block.MAX_BLOCK_SIGOPS,outputScript,Block.MAX_BLOCK_SIGOPS - sigOps + 1);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,b76);
    b76.addTransaction(tx);
  }
  b76.solve();
  blocks.add(new BlockAndValidity(b76,true,false,b76.getHash(),chainHeadHeight + 24,""String_Node_Str""));
  spendableOutputs.offer(b76.getCoinbaseOutput());
  TransactionOutPointWithValue out24=checkNotNull(spendableOutputs.poll());
  TransactionOutPointWithValue out25=checkNotNull(spendableOutputs.poll());
  TransactionOutPointWithValue out26=checkNotNull(spendableOutputs.poll());
  TransactionOutPointWithValue out27=checkNotNull(spendableOutputs.poll());
  NewBlock b77=createNextBlock(b76,chainHeadHeight + 25,out24,null);
  blocks.add(new BlockAndValidity(b77,true,false,b77.getHash(),chainHeadHeight + 25,""String_Node_Str""));
  spendableOutputs.offer(b77.getCoinbaseOutput());
  NewBlock b78=createNextBlock(b77,chainHeadHeight + 26,out25,null);
  Transaction b78tx=new Transaction(params);
{
    b78tx.addOutput(ZERO,OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(b78tx,b77);
    b78.addTransaction(b78tx);
  }
  b78.solve();
  blocks.add(new BlockAndValidity(b78,true,false,b78.getHash(),chainHeadHeight + 26,""String_Node_Str""));
  NewBlock b79=createNextBlock(b78,chainHeadHeight + 27,out26,null);
  Transaction b79tx=new Transaction(params);
{
    b79tx.addOutput(ZERO,OP_TRUE_SCRIPT);
    b79tx.addInput(b78tx.getHash(),0,OP_NOP_SCRIPT);
    b79.addTransaction(b79tx);
  }
  b79.solve();
  blocks.add(new BlockAndValidity(b79,true,false,b79.getHash(),chainHeadHeight + 27,""String_Node_Str""));
  blocks.add(new MemoryPoolState(new HashSet<InventoryItem>(),""String_Node_Str""));
  NewBlock b80=createNextBlock(b77,chainHeadHeight + 26,out25,null);
  blocks.add(new BlockAndValidity(b80,true,false,b79.getHash(),chainHeadHeight + 27,""String_Node_Str""));
  spendableOutputs.offer(b80.getCoinbaseOutput());
  NewBlock b81=createNextBlock(b80,chainHeadHeight + 27,out26,null);
  blocks.add(new BlockAndValidity(b81,true,false,b79.getHash(),chainHeadHeight + 27,""String_Node_Str""));
  spendableOutputs.offer(b81.getCoinbaseOutput());
  NewBlock b82=createNextBlock(b81,chainHeadHeight + 28,out27,null);
  blocks.add(new BlockAndValidity(b82,true,false,b82.getHash(),chainHeadHeight + 28,""String_Node_Str""));
  spendableOutputs.offer(b82.getCoinbaseOutput());
  HashSet<InventoryItem> post82Mempool=new HashSet<InventoryItem>();
  post82Mempool.add(new InventoryItem(InventoryItem.Type.Transaction,b78tx.getHash()));
  post82Mempool.add(new InventoryItem(InventoryItem.Type.Transaction,b79tx.getHash()));
  blocks.add(new MemoryPoolState(post82Mempool,""String_Node_Str""));
{
    TransactionOutPoint outpoint=new TransactionOutPoint(params,0,b79tx.getHash());
    long[] heights=new long[]{UTXOsMessage.MEMPOOL_HEIGHT};
    UTXOsMessage result=new UTXOsMessage(params,ImmutableList.of(b79tx.getOutput(0)),heights,b82.getHash(),chainHeadHeight + 28);
    UTXORule utxo3=new UTXORule(""String_Node_Str"",outpoint,result);
    blocks.add(utxo3);
  }
  TransactionOutPointWithValue out28=spendableOutputs.poll();
  Preconditions.checkState(out28 != null);
  NewBlock b83=createNextBlock(b82,chainHeadHeight + 29,null,null);
{
    Transaction tx1=new Transaction(params);
    tx1.addOutput(new TransactionOutput(params,tx1,out28.value,new byte[]{OP_IF,(byte)OP_INVALIDOPCODE,OP_ELSE,OP_TRUE,OP_ENDIF}));
    addOnlyInputToTransaction(tx1,out28,0);
    b83.addTransaction(tx1);
    Transaction tx2=new Transaction(params);
    tx2.addOutput(new TransactionOutput(params,tx2,ZERO,new byte[]{OP_TRUE}));
    tx2.addInput(new TransactionInput(params,tx2,new byte[]{OP_FALSE},new TransactionOutPoint(params,0,tx1.getHash())));
    b83.addTransaction(tx2);
  }
  b83.solve();
  blocks.add(new BlockAndValidity(b83,true,false,b83.getHash(),chainHeadHeight + 29,""String_Node_Str""));
  spendableOutputs.offer(b83.getCoinbaseOutput());
  TransactionOutPointWithValue out29=spendableOutputs.poll();
  Preconditions.checkState(out29 != null);
  TransactionOutPointWithValue out30=spendableOutputs.poll();
  Preconditions.checkState(out30 != null);
  TransactionOutPointWithValue out31=spendableOutputs.poll();
  Preconditions.checkState(out31 != null);
  TransactionOutPointWithValue out32=spendableOutputs.poll();
  Preconditions.checkState(out32 != null);
  NewBlock b84=createNextBlock(b83,chainHeadHeight + 30,out29,null);
  Transaction b84tx1=new Transaction(params);
{
    b84tx1.addOutput(new TransactionOutput(params,b84tx1,ZERO,new byte[]{OP_RETURN}));
    b84tx1.addOutput(new TransactionOutput(params,b84tx1,ZERO,new byte[]{OP_TRUE}));
    b84tx1.addOutput(new TransactionOutput(params,b84tx1,ZERO,new byte[]{OP_TRUE}));
    b84tx1.addOutput(new TransactionOutput(params,b84tx1,ZERO,new byte[]{OP_TRUE}));
    b84tx1.addOutput(new TransactionOutput(params,b84tx1,ZERO,new byte[]{OP_TRUE}));
    addOnlyInputToTransaction(b84tx1,b84);
    b84.addTransaction(b84tx1);
    Transaction tx2=new Transaction(params);
    tx2.addOutput(new TransactionOutput(params,tx2,ZERO,new byte[]{OP_RETURN}));
    tx2.addOutput(new TransactionOutput(params,tx2,ZERO,new byte[]{OP_RETURN}));
    tx2.addInput(new TransactionInput(params,tx2,new byte[]{OP_TRUE},new TransactionOutPoint(params,1,b84tx1)));
    b84.addTransaction(tx2);
    Transaction tx3=new Transaction(params);
    tx3.addOutput(new TransactionOutput(params,tx3,ZERO,new byte[]{OP_RETURN}));
    tx3.addOutput(new TransactionOutput(params,tx3,ZERO,new byte[]{OP_TRUE}));
    tx3.addInput(new TransactionInput(params,tx3,new byte[]{OP_TRUE},new TransactionOutPoint(params,2,b84tx1)));
    b84.addTransaction(tx3);
    Transaction tx4=new Transaction(params);
    tx4.addOutput(new TransactionOutput(params,tx4,ZERO,new byte[]{OP_TRUE}));
    tx4.addOutput(new TransactionOutput(params,tx4,ZERO,new byte[]{OP_RETURN}));
    tx4.addInput(new TransactionInput(params,tx4,new byte[]{OP_TRUE},new TransactionOutPoint(params,3,b84tx1)));
    b84.addTransaction(tx4);
    Transaction tx5=new Transaction(params);
    tx5.addOutput(new TransactionOutput(params,tx5,ZERO,new byte[]{OP_RETURN}));
    tx5.addInput(new TransactionInput(params,tx5,new byte[]{OP_TRUE},new TransactionOutPoint(params,4,b84tx1)));
    b84.addTransaction(tx5);
  }
  b84.solve();
  blocks.add(new BlockAndValidity(b84,true,false,b84.getHash(),chainHeadHeight + 30,""String_Node_Str""));
  spendableOutputs.offer(b84.getCoinbaseOutput());
  NewBlock b85=createNextBlock(b83,chainHeadHeight + 30,out29,null);
  blocks.add(new BlockAndValidity(b85,true,false,b84.getHash(),chainHeadHeight + 30,""String_Node_Str""));
  NewBlock b86=createNextBlock(b85,chainHeadHeight + 31,out30,null);
  blocks.add(new BlockAndValidity(b86,true,false,b86.getHash(),chainHeadHeight + 31,""String_Node_Str""));
  NewBlock b87=createNextBlock(b84,chainHeadHeight + 31,out30,null);
  blocks.add(new BlockAndValidity(b87,true,false,b86.getHash(),chainHeadHeight + 31,""String_Node_Str""));
  spendableOutputs.offer(b87.getCoinbaseOutput());
  NewBlock b88=createNextBlock(b87,chainHeadHeight + 32,out31,null);
  blocks.add(new BlockAndValidity(b88,true,false,b88.getHash(),chainHeadHeight + 32,""String_Node_Str""));
  spendableOutputs.offer(b88.getCoinbaseOutput());
  NewBlock b89=createNextBlock(b88,chainHeadHeight + 33,out32,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,ZERO,new byte[]{OP_TRUE}));
    tx.addInput(new TransactionInput(params,tx,new byte[]{OP_TRUE},new TransactionOutPoint(params,0,b84tx1)));
    b89.addTransaction(tx);
    b89.solve();
  }
  blocks.add(new BlockAndValidity(b89,false,true,b88.getHash(),chainHeadHeight + 32,""String_Node_Str""));
  if (!runBarelyExpensiveTests) {
    if (outStream != null)     outStream.close();
    return ret;
  }
  NewBlock largeReorgFinal;
  int LARGE_REORG_SIZE=1008;
  int largeReorgLastHeight=chainHeadHeight + 33 + LARGE_REORG_SIZE+ 1;
{
    NewBlock nextBlock=b88;
    int nextHeight=chainHeadHeight + 33;
    TransactionOutPointWithValue largeReorgOutput=out32;
    for (int i=0; i < LARGE_REORG_SIZE; i++) {
      nextBlock=createNextBlock(nextBlock,nextHeight,largeReorgOutput,null);
      Transaction tx=new Transaction(params);
      byte[] outputScript=new byte[Block.MAX_BLOCK_SIZE - nextBlock.block.getMessageSize() - 65];
      Arrays.fill(outputScript,(byte)OP_FALSE);
      tx.addOutput(new TransactionOutput(params,tx,ZERO,outputScript));
      addOnlyInputToTransaction(tx,nextBlock);
      nextBlock.addTransaction(tx);
      nextBlock.solve();
      blocks.add(new BlockAndValidity(nextBlock,true,false,nextBlock.getHash(),nextHeight++,""String_Node_Str"" + i));
      spendableOutputs.offer(nextBlock.getCoinbaseOutput());
      largeReorgOutput=spendableOutputs.poll();
    }
    NewBlock reorgBase=b88;
    int reorgBaseHeight=chainHeadHeight + 33;
    for (int i=0; i < LARGE_REORG_SIZE; i++) {
      reorgBase=createNextBlock(reorgBase,reorgBaseHeight++,null,null);
      blocks.add(new BlockAndValidity(reorgBase,true,false,nextBlock.getHash(),nextHeight - 1,""String_Node_Str"" + i));
    }
    reorgBase=createNextBlock(reorgBase,reorgBaseHeight,null,null);
    blocks.add(new BlockAndValidity(reorgBase,true,false,reorgBase.getHash(),reorgBaseHeight,""String_Node_Str""));
    nextBlock=createNextBlock(nextBlock,nextHeight,null,null);
    blocks.add(new BlockAndValidity(nextBlock,true,false,reorgBase.getHash(),nextHeight++,""String_Node_Str""));
    spendableOutputs.offer(nextBlock.getCoinbaseOutput());
    nextBlock=createNextBlock(nextBlock,nextHeight,null,null);
    spendableOutputs.poll();
    blocks.add(new BlockAndValidity(nextBlock,true,false,nextBlock.getHash(),nextHeight++,""String_Node_Str""));
    spendableOutputs.offer(nextBlock.getCoinbaseOutput());
    largeReorgFinal=nextBlock;
  }
  ret.maximumReorgBlockCount=Math.max(ret.maximumReorgBlockCount,LARGE_REORG_SIZE + 2);
  NewBlock b1001=createNextBlock(largeReorgFinal,largeReorgLastHeight + 1,spendableOutputs.poll(),null);
  blocks.add(new BlockAndValidity(b1001,true,false,b1001.getHash(),largeReorgLastHeight + 1,""String_Node_Str""));
  spendableOutputs.offer(b1001.getCoinbaseOutput());
  int heightAfter1001=largeReorgLastHeight + 2;
  if (runExpensiveTests) {
    Preconditions.checkArgument(blockStorageFile != null);
    NewBlock lastBlock=b1001;
    TransactionOutPoint lastOutput=new TransactionOutPoint(params,1,b1001.block.getTransactions().get(1).getHash());
    int blockCountAfter1001;
    int nextHeight=heightAfter1001;
    List<Sha256Hash> hashesToSpend=new LinkedList<Sha256Hash>();
    final int TRANSACTION_CREATION_BLOCKS=100;
    for (blockCountAfter1001=0; blockCountAfter1001 < TRANSACTION_CREATION_BLOCKS; blockCountAfter1001++) {
      NewBlock block=createNextBlock(lastBlock,nextHeight++,null,null);
      while (block.block.getMessageSize() < Block.MAX_BLOCK_SIZE - 500) {
        Transaction tx=new Transaction(params);
        tx.addInput(lastOutput.getHash(),lastOutput.getIndex(),OP_NOP_SCRIPT);
        tx.addOutput(ZERO,OP_TRUE_SCRIPT);
        tx.addOutput(ZERO,OP_TRUE_SCRIPT);
        lastOutput=new TransactionOutPoint(params,1,tx.getHash());
        hashesToSpend.add(tx.getHash());
        block.addTransaction(tx);
      }
      block.solve();
      blocks.add(new BlockAndValidity(block,true,false,block.getHash(),nextHeight - 1,""String_Node_Str"" + blockCountAfter1001 + ""String_Node_Str""+ TRANSACTION_CREATION_BLOCKS).setSendOnce(true));
      lastBlock=block;
    }
    Iterator<Sha256Hash> hashes=hashesToSpend.iterator();
    for (int i=0; hashes.hasNext(); i++) {
      NewBlock block=createNextBlock(lastBlock,nextHeight++,null,null);
      while (block.block.getMessageSize() < Block.MAX_BLOCK_SIZE - 500 && hashes.hasNext()) {
        Transaction tx=new Transaction(params);
        tx.addInput(hashes.next(),0,OP_NOP_SCRIPT);
        tx.addOutput(ZERO,OP_TRUE_SCRIPT);
        block.addTransaction(tx);
      }
      block.solve();
      blocks.add(new BlockAndValidity(block,true,false,block.getHash(),nextHeight - 1,""String_Node_Str"" + i).setSendOnce(true));
      lastBlock=block;
      blockCountAfter1001++;
    }
    Sha256Hash firstHash=lastBlock.getHash();
    int height=nextHeight - 1;
    nextHeight=heightAfter1001;
    lastBlock=b1001;
    for (int i=0; i < blockCountAfter1001; i++) {
      NewBlock block=createNextBlock(lastBlock,nextHeight++,null,null);
      blocks.add(new BlockAndValidity(block,true,false,firstHash,height,""String_Node_Str"" + i + ""String_Node_Str""+ blockCountAfter1001));
      lastBlock=block;
    }
    NewBlock b1002=createNextBlock(lastBlock,nextHeight,null,null);
{
      Transaction tx=new Transaction(params);
      tx.addInput(hashesToSpend.get(0),0,OP_NOP_SCRIPT);
      tx.addOutput(ZERO,OP_TRUE_SCRIPT);
      b1002.addTransaction(tx);
    }
    b1002.solve();
    blocks.add(new BlockAndValidity(b1002,false,true,firstHash,height,""String_Node_Str""));
    NewBlock b1003=createNextBlock(lastBlock,nextHeight,null,null);
    blocks.add(new BlockAndValidity(b1003,true,false,b1003.getHash(),nextHeight,""String_Node_Str""));
    NewBlock b1004=createNextBlock(b1003,nextHeight + 1,null,null);
{
      Transaction tx=new Transaction(params);
      tx.addInput(hashesToSpend.get(0),0,OP_NOP_SCRIPT);
      tx.addOutput(ZERO,OP_TRUE_SCRIPT);
      b1004.addTransaction(tx);
    }
    b1004.solve();
    blocks.add(new BlockAndValidity(b1004,false,true,b1003.getHash(),nextHeight,""String_Node_Str""));
    ret.maximumReorgBlockCount=Math.max(ret.maximumReorgBlockCount,blockCountAfter1001);
  }
  if (outStream != null)   outStream.close();
  return ret;
}","public RuleList getBlocksToTest(boolean runBarelyExpensiveTests,boolean runExpensiveTests,File blockStorageFile) throws ScriptException, ProtocolException, IOException {
  final FileOutputStream outStream=blockStorageFile != null ? new FileOutputStream(blockStorageFile) : null;
  final Script OP_TRUE_SCRIPT=new ScriptBuilder().op(OP_TRUE).build();
  final Script OP_NOP_SCRIPT=new ScriptBuilder().op(OP_NOP).build();
  List<Rule> blocks=new LinkedList<Rule>(){
    @Override public boolean add(    Rule element){
      if (outStream != null && element instanceof BlockAndValidity) {
        try {
          outStream.write((int)(params.getPacketMagic() >>> 24));
          outStream.write((int)(params.getPacketMagic() >>> 16));
          outStream.write((int)(params.getPacketMagic() >>> 8));
          outStream.write((int)(params.getPacketMagic() >>> 0));
          byte[] block=((BlockAndValidity)element).block.bitcoinSerialize();
          byte[] length=new byte[4];
          Utils.uint32ToByteArrayBE(block.length,length,0);
          outStream.write(Utils.reverseBytes(length));
          outStream.write(block);
          ((BlockAndValidity)element).block=null;
        }
 catch (        IOException e) {
          throw new RuntimeException(e);
        }
      }
      return super.add(element);
    }
  }
;
  RuleList ret=new RuleList(blocks,hashHeaderMap,10);
  Queue<TransactionOutPointWithValue> spendableOutputs=new LinkedList<TransactionOutPointWithValue>();
  int chainHeadHeight=1;
  Block chainHead=params.getGenesisBlock().createNextBlockWithCoinbase(coinbaseOutKeyPubKey);
  blocks.add(new BlockAndValidity(chainHead,true,false,chainHead.getHash(),1,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,chainHead.getTransactions().get(0).getHash()),FIFTY_COINS,chainHead.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  for (int i=1; i < params.getSpendableCoinbaseDepth(); i++) {
    chainHead=chainHead.createNextBlockWithCoinbase(coinbaseOutKeyPubKey);
    chainHeadHeight++;
    blocks.add(new BlockAndValidity(chainHead,true,false,chainHead.getHash(),i + 1,""String_Node_Str""));
    spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,chainHead.getTransactions().get(0).getHash()),FIFTY_COINS,chainHead.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  }
  NewBlock b1=createNextBlock(chainHead,chainHeadHeight + 1,spendableOutputs.poll(),null);
  blocks.add(new BlockAndValidity(b1,true,false,b1.getHash(),chainHeadHeight + 1,""String_Node_Str""));
  spendableOutputs.offer(b1.getCoinbaseOutput());
  TransactionOutPointWithValue out1=spendableOutputs.poll();
  checkState(out1 != null);
  NewBlock b2=createNextBlock(b1,chainHeadHeight + 2,out1,null);
  blocks.add(new BlockAndValidity(b2,true,false,b2.getHash(),chainHeadHeight + 2,""String_Node_Str""));
  blocks.add(new BlockAndValidity(b2,true,false,b2.getHash(),chainHeadHeight + 2,""String_Node_Str""));
  spendableOutputs.offer(b2.getCoinbaseOutput());
  NewBlock b3=createNextBlock(b1,chainHeadHeight + 2,out1,null);
  blocks.add(new BlockAndValidity(b3,true,false,b2.getHash(),chainHeadHeight + 2,""String_Node_Str""));
  blocks.add(new BlockAndValidity(b3,true,false,b2.getHash(),chainHeadHeight + 2,""String_Node_Str""));
  UTXORule utxo1;
{
    Transaction coinbase=b2.block.getTransactions().get(0);
    TransactionOutPoint outpoint=new TransactionOutPoint(params,0,coinbase.getHash());
    long[] heights={chainHeadHeight + 2};
    UTXOsMessage result=new UTXOsMessage(params,ImmutableList.of(coinbase.getOutput(0)),heights,b2.getHash(),chainHeadHeight + 2);
    utxo1=new UTXORule(""String_Node_Str"",outpoint,result);
    blocks.add(utxo1);
  }
  TransactionOutPointWithValue out2=checkNotNull(spendableOutputs.poll());
  NewBlock b4=createNextBlock(b3,chainHeadHeight + 3,out2,null);
  blocks.add(new BlockAndValidity(b4,true,false,b4.getHash(),chainHeadHeight + 3,""String_Node_Str""));
{
    Transaction coinbase=b4.block.getTransactions().get(0);
    TransactionOutPoint outpoint=new TransactionOutPoint(params,0,coinbase.getHash());
    List<TransactionOutPoint> queries=ImmutableList.of(utxo1.query.get(0),outpoint);
    List<TransactionOutput> results=Lists.asList(null,coinbase.getOutput(0),new TransactionOutput[]{});
    long[] heights={chainHeadHeight + 3};
    UTXOsMessage result=new UTXOsMessage(params,results,heights,b4.getHash(),chainHeadHeight + 3);
    UTXORule utxo2=new UTXORule(""String_Node_Str"",queries,result);
    blocks.add(utxo2);
  }
  NewBlock b5=createNextBlock(b2,chainHeadHeight + 3,out2,null);
  blocks.add(new BlockAndValidity(b5,true,false,b4.getHash(),chainHeadHeight + 3,""String_Node_Str""));
  spendableOutputs.offer(b5.getCoinbaseOutput());
  TransactionOutPointWithValue out3=spendableOutputs.poll();
  NewBlock b6=createNextBlock(b5,chainHeadHeight + 4,out3,null);
  blocks.add(new BlockAndValidity(b6,true,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  NewBlock b7=createNextBlock(b5,chainHeadHeight + 5,out2,null);
  blocks.add(new BlockAndValidity(b7,true,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  TransactionOutPointWithValue out4=spendableOutputs.poll();
  NewBlock b8=createNextBlock(b7,chainHeadHeight + 6,out4,null);
  blocks.add(new BlockAndValidity(b8,false,true,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  NewBlock b9=createNextBlock(b6,chainHeadHeight + 5,out4,SATOSHI);
  blocks.add(new BlockAndValidity(b9,false,true,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  NewBlock b10=createNextBlock(b5,chainHeadHeight + 4,out3,null);
  blocks.add(new BlockAndValidity(b10,true,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  NewBlock b11=createNextBlock(b10,chainHeadHeight + 5,out4,SATOSHI);
  blocks.add(new BlockAndValidity(b11,false,true,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  NewBlock b12=createNextBlock(b5,chainHeadHeight + 4,out3,null);
  spendableOutputs.offer(b12.getCoinbaseOutput());
  NewBlock b13=createNextBlock(b12,chainHeadHeight + 5,out4,null);
  blocks.add(new BlockAndValidity(b13,false,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  blocks.add(new BlockAndValidity(b13,false,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  spendableOutputs.offer(b13.getCoinbaseOutput());
  TransactionOutPointWithValue out5=spendableOutputs.poll();
  NewBlock b14=createNextBlock(b13,chainHeadHeight + 6,out5,SATOSHI);
  blocks.add(new BlockAndValidity(b14,false,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  blocks.add(new BlockAndValidity(b14,false,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  blocks.add(new BlockAndValidity(b12,false,true,b13.getHash(),chainHeadHeight + 5,""String_Node_Str""));
  NewBlock b15=createNextBlock(b13,chainHeadHeight + 6,out5,null);
{
    int sigOps=0;
    for (    Transaction tx : b15.block.getTransactions())     sigOps+=tx.getSigOpCount();
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,b15);
    b15.addTransaction(tx);
    sigOps=0;
    for (    Transaction tx2 : b15.block.getTransactions())     sigOps+=tx2.getSigOpCount();
    checkState(sigOps == Block.MAX_BLOCK_SIGOPS);
  }
  b15.solve();
  blocks.add(new BlockAndValidity(b15,true,false,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  spendableOutputs.offer(b15.getCoinbaseOutput());
  TransactionOutPointWithValue out6=spendableOutputs.poll();
  NewBlock b16=createNextBlock(b15,chainHeadHeight + 7,out6,null);
{
    int sigOps=0;
    for (    Transaction tx : b16.block.getTransactions()) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + 1];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,b16);
    b16.addTransaction(tx);
    sigOps=0;
    for (    Transaction tx2 : b16.block.getTransactions())     sigOps+=tx2.getSigOpCount();
    checkState(sigOps == Block.MAX_BLOCK_SIGOPS + 1);
  }
  b16.solve();
  blocks.add(new BlockAndValidity(b16,false,true,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  NewBlock b17=createNextBlock(b15,chainHeadHeight + 7,out6,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,new byte[]{}));
    addOnlyInputToTransaction(tx,b3);
    b17.addTransaction(tx);
  }
  b17.solve();
  blocks.add(new BlockAndValidity(b17,false,true,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  NewBlock b18=createNextBlock(b13,chainHeadHeight + 6,out5,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,new byte[]{}));
    addOnlyInputToTransaction(tx,b3);
    b18.addTransaction(tx);
  }
  b18.solve();
  blocks.add(new BlockAndValidity(b18,true,false,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  NewBlock b19=createNextBlock(b18,chainHeadHeight + 7,out6,null);
  blocks.add(new BlockAndValidity(b19,false,true,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  TransactionOutPointWithValue out7=spendableOutputs.poll();
  NewBlock b20=createNextBlock(b15.block,chainHeadHeight + 7,out7,null);
  blocks.add(new BlockAndValidity(b20,false,true,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  NewBlock b21=createNextBlock(b13,chainHeadHeight + 6,out6,null);
  blocks.add(new BlockAndValidity(b21.block,true,false,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  NewBlock b22=createNextBlock(b21,chainHeadHeight + 7,out5,null);
  blocks.add(new BlockAndValidity(b22.block,false,true,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  NewBlock b23=createNextBlock(b15,chainHeadHeight + 7,out6,null);
{
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIZE - b23.block.getMessageSize() - 65];
    Arrays.fill(outputScript,(byte)OP_FALSE);
    tx.addOutput(new TransactionOutput(params,tx,ZERO,outputScript));
    addOnlyInputToTransaction(tx,b23);
    b23.addTransaction(tx);
  }
  b23.solve();
  checkState(b23.block.getMessageSize() == Block.MAX_BLOCK_SIZE);
  blocks.add(new BlockAndValidity(b23,true,false,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  spendableOutputs.offer(b23.getCoinbaseOutput());
  NewBlock b24=createNextBlock(b15,chainHeadHeight + 7,out6,null);
{
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIZE - b24.block.getMessageSize() - 64];
    Arrays.fill(outputScript,(byte)OP_FALSE);
    tx.addOutput(new TransactionOutput(params,tx,ZERO,outputScript));
    addOnlyInputToTransaction(tx,b24);
    b24.addTransaction(tx);
  }
  b24.solve();
  checkState(b24.block.getMessageSize() == Block.MAX_BLOCK_SIZE + 1);
  blocks.add(new BlockAndValidity(b24,false,true,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  NewBlock b25=createNextBlock(b24,chainHeadHeight + 8,out7,null);
  blocks.add(new BlockAndValidity(b25,false,false,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  NewBlock b26=createNextBlock(b15,chainHeadHeight + 7,out6,null);
  b26.block.getTransactions().get(0).getInputs().get(0).setScriptBytes(new byte[]{0});
  b26.block.setMerkleRoot(null);
  b26.solve();
  blocks.add(new BlockAndValidity(b26,false,true,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  NewBlock b27=createNextBlock(b26,chainHeadHeight + 8,out7,null);
  blocks.add(new BlockAndValidity(b27,false,false,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  NewBlock b28=createNextBlock(b15,chainHeadHeight + 7,out6,null);
{
    byte[] coinbase=new byte[101];
    Arrays.fill(coinbase,(byte)0);
    b28.block.getTransactions().get(0).getInputs().get(0).setScriptBytes(coinbase);
  }
  b28.block.setMerkleRoot(null);
  b28.solve();
  blocks.add(new BlockAndValidity(b28,false,true,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  NewBlock b29=createNextBlock(b28,chainHeadHeight + 8,out7,null);
  blocks.add(new BlockAndValidity(b29,false,false,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  NewBlock b30=createNextBlock(b23,chainHeadHeight + 8,out7,null);
{
    byte[] coinbase=new byte[100];
    Arrays.fill(coinbase,(byte)0);
    b30.block.getTransactions().get(0).getInputs().get(0).setScriptBytes(coinbase);
  }
  b30.block.setMerkleRoot(null);
  b30.solve();
  blocks.add(new BlockAndValidity(b30,true,false,b30.getHash(),chainHeadHeight + 8,""String_Node_Str""));
  spendableOutputs.offer(b30.getCoinbaseOutput());
  TransactionOutPointWithValue out8=spendableOutputs.poll();
  NewBlock b31=createNextBlock(b30,chainHeadHeight + 9,out8,null);
{
    int sigOps=0;
    for (    Transaction tx : b31.block.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[(Block.MAX_BLOCK_SIGOPS - sigOps) / 20];
    Arrays.fill(outputScript,(byte)OP_CHECKMULTISIG);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,b31);
    b31.addTransaction(tx);
  }
  b31.solve();
  blocks.add(new BlockAndValidity(b31,true,false,b31.getHash(),chainHeadHeight + 9,""String_Node_Str""));
  spendableOutputs.offer(b31.getCoinbaseOutput());
  TransactionOutPointWithValue out9=spendableOutputs.poll();
  NewBlock b32=createNextBlock(b31,chainHeadHeight + 10,out9,null);
{
    int sigOps=0;
    for (    Transaction tx : b32.block.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[(Block.MAX_BLOCK_SIGOPS - sigOps) / 20 + (Block.MAX_BLOCK_SIGOPS - sigOps) % 20 + 1];
    Arrays.fill(outputScript,(byte)OP_CHECKMULTISIG);
    for (int i=0; i < (Block.MAX_BLOCK_SIGOPS - sigOps) % 20; i++)     outputScript[i]=(byte)OP_CHECKSIG;
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,b32);
    b32.addTransaction(tx);
  }
  b32.solve();
  blocks.add(new BlockAndValidity(b32,false,true,b31.getHash(),chainHeadHeight + 9,""String_Node_Str""));
  NewBlock b33=createNextBlock(b31,chainHeadHeight + 10,out9,null);
{
    int sigOps=0;
    for (    Transaction tx : b33.block.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[(Block.MAX_BLOCK_SIGOPS - sigOps) / 20];
    Arrays.fill(outputScript,(byte)OP_CHECKMULTISIGVERIFY);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,b33);
    b33.addTransaction(tx);
  }
  b33.solve();
  blocks.add(new BlockAndValidity(b33,true,false,b33.getHash(),chainHeadHeight + 10,""String_Node_Str""));
  spendableOutputs.offer(b33.getCoinbaseOutput());
  TransactionOutPointWithValue out10=spendableOutputs.poll();
  NewBlock b34=createNextBlock(b33,chainHeadHeight + 11,out10,null);
{
    int sigOps=0;
    for (    Transaction tx : b34.block.getTransactions()) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[(Block.MAX_BLOCK_SIGOPS - sigOps) / 20 + (Block.MAX_BLOCK_SIGOPS - sigOps) % 20 + 1];
    Arrays.fill(outputScript,(byte)OP_CHECKMULTISIGVERIFY);
    for (int i=0; i < (Block.MAX_BLOCK_SIGOPS - sigOps) % 20; i++)     outputScript[i]=(byte)OP_CHECKSIG;
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,b34);
    b34.addTransaction(tx);
  }
  b34.solve();
  blocks.add(new BlockAndValidity(b34,false,true,b33.getHash(),chainHeadHeight + 10,""String_Node_Str""));
  NewBlock b35=createNextBlock(b33,chainHeadHeight + 11,out10,null);
{
    int sigOps=0;
    for (    Transaction tx : b35.block.getTransactions()) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps];
    Arrays.fill(outputScript,(byte)OP_CHECKSIGVERIFY);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,b35);
    b35.addTransaction(tx);
  }
  b35.solve();
  blocks.add(new BlockAndValidity(b35,true,false,b35.getHash(),chainHeadHeight + 11,""String_Node_Str""));
  spendableOutputs.offer(b35.getCoinbaseOutput());
  TransactionOutPointWithValue out11=spendableOutputs.poll();
  NewBlock b36=createNextBlock(b35,chainHeadHeight + 12,out11,null);
{
    int sigOps=0;
    for (    Transaction tx : b36.block.getTransactions()) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + 1];
    Arrays.fill(outputScript,(byte)OP_CHECKSIGVERIFY);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,b36);
    b36.addTransaction(tx);
  }
  b36.solve();
  blocks.add(new BlockAndValidity(b36,false,true,b35.getHash(),chainHeadHeight + 11,""String_Node_Str""));
  NewBlock b37=createNextBlock(b35,chainHeadHeight + 12,out11,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,new byte[]{}));
    addOnlyInputToTransaction(tx,out11);
    b37.addTransaction(tx);
  }
  b37.solve();
  blocks.add(new BlockAndValidity(b37,false,true,b35.getHash(),chainHeadHeight + 11,""String_Node_Str""));
  NewBlock b38=createNextBlock(b35,chainHeadHeight + 12,out11,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,new byte[]{}));
    addOnlyInputToTransaction(tx,b37);
    b38.addTransaction(tx);
  }
  b38.solve();
  blocks.add(new BlockAndValidity(b38,false,true,b35.getHash(),chainHeadHeight + 11,""String_Node_Str""));
  byte[] b39p2shScriptPubKey;
  int b39numP2SHOutputs=0, b39sigOpsPerOutput=6;
  NewBlock b39=createNextBlock(b35,chainHeadHeight + 12,null,null);
{
    ByteArrayOutputStream p2shScriptPubKey=new UnsafeByteArrayOutputStream();
    try {
      Script.writeBytes(p2shScriptPubKey,coinbaseOutKeyPubKey);
      p2shScriptPubKey.write(OP_2DUP);
      p2shScriptPubKey.write(OP_CHECKSIGVERIFY);
      p2shScriptPubKey.write(OP_2DUP);
      p2shScriptPubKey.write(OP_CHECKSIGVERIFY);
      p2shScriptPubKey.write(OP_2DUP);
      p2shScriptPubKey.write(OP_CHECKSIGVERIFY);
      p2shScriptPubKey.write(OP_2DUP);
      p2shScriptPubKey.write(OP_CHECKSIGVERIFY);
      p2shScriptPubKey.write(OP_2DUP);
      p2shScriptPubKey.write(OP_CHECKSIGVERIFY);
      p2shScriptPubKey.write(OP_CHECKSIG);
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
    b39p2shScriptPubKey=p2shScriptPubKey.toByteArray();
    byte[] scriptHash=Utils.sha256hash160(b39p2shScriptPubKey);
    UnsafeByteArrayOutputStream scriptPubKey=new UnsafeByteArrayOutputStream(scriptHash.length + 3);
    scriptPubKey.write(OP_HASH160);
    try {
      Script.writeBytes(scriptPubKey,scriptHash);
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
    scriptPubKey.write(OP_EQUAL);
    Coin lastOutputValue=out11.value.subtract(SATOSHI);
    TransactionOutPoint lastOutPoint;
{
      Transaction tx=new Transaction(params);
      tx.addOutput(new TransactionOutput(params,tx,SATOSHI,scriptPubKey.toByteArray()));
      tx.addOutput(new TransactionOutput(params,tx,lastOutputValue,new byte[]{OP_1}));
      addOnlyInputToTransaction(tx,out11);
      lastOutPoint=new TransactionOutPoint(params,1,tx.getHash());
      b39.addTransaction(tx);
    }
    b39numP2SHOutputs++;
    while (b39.block.getMessageSize() < Block.MAX_BLOCK_SIZE) {
      Transaction tx=new Transaction(params);
      lastOutputValue=lastOutputValue.subtract(SATOSHI);
      tx.addOutput(new TransactionOutput(params,tx,SATOSHI,scriptPubKey.toByteArray()));
      tx.addOutput(new TransactionOutput(params,tx,lastOutputValue,new byte[]{OP_1}));
      tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},lastOutPoint));
      lastOutPoint=new TransactionOutPoint(params,1,tx.getHash());
      if (b39.block.getMessageSize() + tx.getMessageSize() < Block.MAX_BLOCK_SIZE) {
        b39.addTransaction(tx);
        b39numP2SHOutputs++;
      }
 else       break;
    }
  }
  b39.solve();
  blocks.add(new BlockAndValidity(b39,true,false,b39.getHash(),chainHeadHeight + 12,""String_Node_Str""));
  spendableOutputs.offer(b39.getCoinbaseOutput());
  TransactionOutPointWithValue out12=spendableOutputs.poll();
  NewBlock b40=createNextBlock(b39,chainHeadHeight + 13,out12,null);
{
    int sigOps=0;
    for (    Transaction tx : b40.block.getTransactions()) {
      sigOps+=tx.getSigOpCount();
    }
    int numTxes=(Block.MAX_BLOCK_SIGOPS - sigOps) / b39sigOpsPerOutput;
    checkState(numTxes <= b39numP2SHOutputs);
    TransactionOutPoint lastOutPoint=new TransactionOutPoint(params,1,b40.block.getTransactions().get(1).getHash());
    byte[] scriptSig=null;
    for (int i=1; i <= numTxes; i++) {
      Transaction tx=new Transaction(params);
      tx.addOutput(new TransactionOutput(params,tx,SATOSHI,new byte[]{OP_1}));
      tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},lastOutPoint));
      TransactionInput input=new TransactionInput(params,tx,new byte[]{},new TransactionOutPoint(params,0,b39.block.getTransactions().get(i).getHash()));
      tx.addInput(input);
      if (scriptSig == null) {
        Sha256Hash hash=tx.hashForSignature(1,b39p2shScriptPubKey,SigHash.SINGLE,false);
        try {
          ByteArrayOutputStream bos=new UnsafeByteArrayOutputStream(73);
          bos.write(coinbaseOutKey.sign(hash).encodeToDER());
          bos.write(SigHash.SINGLE.ordinal() + 1);
          byte[] signature=bos.toByteArray();
          ByteArrayOutputStream scriptSigBos=new UnsafeByteArrayOutputStream(signature.length + b39p2shScriptPubKey.length + 3);
          Script.writeBytes(scriptSigBos,new byte[]{(byte)OP_CHECKSIG});
          scriptSigBos.write(Script.createInputScript(signature));
          Script.writeBytes(scriptSigBos,b39p2shScriptPubKey);
          scriptSig=scriptSigBos.toByteArray();
        }
 catch (        IOException e) {
          throw new RuntimeException(e);
        }
      }
      input.setScriptBytes(scriptSig);
      lastOutPoint=new TransactionOutPoint(params,0,tx.getHash());
      b40.addTransaction(tx);
    }
    sigOps+=numTxes * b39sigOpsPerOutput;
    Transaction tx=new Transaction(params);
    tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},lastOutPoint));
    byte[] scriptPubKey=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + 1];
    Arrays.fill(scriptPubKey,(byte)OP_CHECKSIG);
    tx.addOutput(new TransactionOutput(params,tx,ZERO,scriptPubKey));
    b40.addTransaction(tx);
  }
  b40.solve();
  blocks.add(new BlockAndValidity(b40,false,true,b39.getHash(),chainHeadHeight + 12,""String_Node_Str""));
  NewBlock b41=null;
  if (runBarelyExpensiveTests) {
    b41=createNextBlock(b39,chainHeadHeight + 13,out12,null);
{
      int sigOps=0;
      for (      Transaction tx : b41.block.getTransactions()) {
        sigOps+=tx.getSigOpCount();
      }
      int numTxes=(Block.MAX_BLOCK_SIGOPS - sigOps) / b39sigOpsPerOutput;
      checkState(numTxes <= b39numP2SHOutputs);
      TransactionOutPoint lastOutPoint=new TransactionOutPoint(params,1,b41.block.getTransactions().get(1).getHash());
      byte[] scriptSig=null;
      for (int i=1; i <= numTxes; i++) {
        Transaction tx=new Transaction(params);
        tx.addOutput(new TransactionOutput(params,tx,Coin.SATOSHI,new byte[]{OP_1}));
        tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},lastOutPoint));
        TransactionInput input=new TransactionInput(params,tx,new byte[]{},new TransactionOutPoint(params,0,b39.block.getTransactions().get(i).getHash()));
        tx.addInput(input);
        if (scriptSig == null) {
          Sha256Hash hash=tx.hashForSignature(1,b39p2shScriptPubKey,SigHash.SINGLE,false);
          try {
            ByteArrayOutputStream bos=new UnsafeByteArrayOutputStream(73);
            bos.write(coinbaseOutKey.sign(hash).encodeToDER());
            bos.write(SigHash.SINGLE.ordinal() + 1);
            byte[] signature=bos.toByteArray();
            ByteArrayOutputStream scriptSigBos=new UnsafeByteArrayOutputStream(signature.length + b39p2shScriptPubKey.length + 3);
            Script.writeBytes(scriptSigBos,new byte[]{(byte)OP_CHECKSIG});
            scriptSigBos.write(Script.createInputScript(signature));
            Script.writeBytes(scriptSigBos,b39p2shScriptPubKey);
            scriptSig=scriptSigBos.toByteArray();
          }
 catch (          IOException e) {
            throw new RuntimeException(e);
          }
        }
        input.setScriptBytes(scriptSig);
        lastOutPoint=new TransactionOutPoint(params,0,tx.getHash());
        b41.addTransaction(tx);
      }
      sigOps+=numTxes * b39sigOpsPerOutput;
      Transaction tx=new Transaction(params);
      tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},lastOutPoint));
      byte[] scriptPubKey=new byte[Block.MAX_BLOCK_SIGOPS - sigOps];
      Arrays.fill(scriptPubKey,(byte)OP_CHECKSIG);
      tx.addOutput(new TransactionOutput(params,tx,ZERO,scriptPubKey));
      b41.addTransaction(tx);
    }
    b41.solve();
    blocks.add(new BlockAndValidity(b41,true,false,b41.getHash(),chainHeadHeight + 13,""String_Node_Str""));
  }
  NewBlock b42=createNextBlock(b39,chainHeadHeight + 13,out12,null);
  blocks.add(new BlockAndValidity(b42,true,false,b41 == null ? b42.getHash() : b41.getHash(),chainHeadHeight + 13,""String_Node_Str""));
  spendableOutputs.offer(b42.getCoinbaseOutput());
  TransactionOutPointWithValue out13=spendableOutputs.poll();
  NewBlock b43=createNextBlock(b42,chainHeadHeight + 14,out13,null);
  blocks.add(new BlockAndValidity(b43,true,false,b43.getHash(),chainHeadHeight + 14,""String_Node_Str""));
  spendableOutputs.offer(b43.getCoinbaseOutput());
  TransactionOutPointWithValue out14=spendableOutputs.poll();
  Block b44=new Block(params);
  byte[] outScriptBytes=ScriptBuilder.createOutputScript(ECKey.fromPublicOnly(coinbaseOutKeyPubKey)).getProgram();
{
    b44.setDifficultyTarget(b43.block.getDifficultyTarget());
    b44.addCoinbaseTransaction(coinbaseOutKeyPubKey,ZERO);
    Transaction t=new Transaction(params);
    t.addOutput(new TransactionOutput(params,t,ZERO,new byte[]{OP_PUSHDATA1 - 1}));
    t.addOutput(new TransactionOutput(params,t,SATOSHI,outScriptBytes));
    t.addOutput(new TransactionOutput(params,t,ZERO,new byte[]{OP_1}));
    addOnlyInputToTransaction(t,out14);
    b44.addTransaction(t);
    b44.setPrevBlockHash(b43.getHash());
    b44.setTime(b43.block.getTimeSeconds() + 1);
  }
  b44.solve();
  blocks.add(new BlockAndValidity(b44,true,false,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  TransactionOutPointWithValue out15=spendableOutputs.poll();
  Block b45=new Block(params);
{
    b45.setDifficultyTarget(b44.getDifficultyTarget());
    Transaction t=new Transaction(params);
    t.addOutput(new TransactionOutput(params,t,ZERO,new byte[]{OP_PUSHDATA1 - 1}));
    t.addOutput(new TransactionOutput(params,t,SATOSHI,outScriptBytes));
    t.addOutput(new TransactionOutput(params,t,ZERO,new byte[]{OP_1}));
    addOnlyInputToTransaction(t,out15);
    try {
      b45.addTransaction(t);
    }
 catch (    RuntimeException e) {
    }
    if (b45.getTransactions().size() > 0)     throw new RuntimeException(""String_Node_Str"");
    b45.addTransaction(t,false);
    b45.setPrevBlockHash(b44.getHash());
    b45.setTime(b44.getTimeSeconds() + 1);
  }
  b45.solve();
  blocks.add(new BlockAndValidity(b45,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b46=new Block(params);
{
    b46.transactions=new ArrayList<Transaction>();
    b46.setDifficultyTarget(b44.getDifficultyTarget());
    b46.setMerkleRoot(Sha256Hash.ZERO_HASH);
    b46.setPrevBlockHash(b44.getHash());
    b46.setTime(b44.getTimeSeconds() + 1);
  }
  b46.solve();
  blocks.add(new BlockAndValidity(b46,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  NewBlock b47=createNextBlock(b44,chainHeadHeight + 16,out15,null);
{
    try {
      BigInteger target=b47.block.getDifficultyTargetAsInteger();
      while (true) {
        BigInteger h=b47.getHash().toBigInteger();
        if (h.compareTo(target) > 0)         break;
        b47.block.setNonce(b47.block.getNonce() + 1);
      }
    }
 catch (    VerificationException e) {
      throw new RuntimeException(e);
    }
  }
  blocks.add(new BlockAndValidity(b47,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  NewBlock b48=createNextBlock(b44,chainHeadHeight + 16,out15,null);
  b48.block.setTime(Utils.currentTimeSeconds() + 60 * 60 * 3);
  b48.solve();
  blocks.add(new BlockAndValidity(b48,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  NewBlock b49=createNextBlock(b44,chainHeadHeight + 16,out15,null);
  byte[] b49MerkleHash=Sha256Hash.ZERO_HASH.getBytes().clone();
  b49MerkleHash[1]=(byte)0xDE;
  b49.block.setMerkleRoot(Sha256Hash.of(b49MerkleHash));
  b49.solve();
  blocks.add(new BlockAndValidity(b49,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  NewBlock b50=createNextBlock(b44,chainHeadHeight + 16,out15,null);
{
    long diffTarget=b44.getDifficultyTarget();
    diffTarget&=0xFFBFFFFF;
    b50.block.setDifficultyTarget(diffTarget);
  }
  b50.solve();
  blocks.add(new BlockAndValidity(b50,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  NewBlock b51=createNextBlock(b44,chainHeadHeight + 16,out15,null);
{
    Transaction coinbase=new Transaction(params);
    coinbase.addInput(new TransactionInput(params,coinbase,new byte[]{(byte)0xff,110,1}));
    coinbase.addOutput(new TransactionOutput(params,coinbase,SATOSHI,outScriptBytes));
    b51.block.addTransaction(coinbase,false);
  }
  b51.solve();
  blocks.add(new BlockAndValidity(b51,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  NewBlock b52=createNextBlock(b44,chainHeadHeight + 16,out15,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,new byte[]{}));
    addOnlyInputToTransaction(tx,b52);
    b52.addTransaction(tx);
    b52.addTransaction(tx);
  }
  b52.solve();
  blocks.add(new BlockAndValidity(b52,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  NewBlock b53=createNextBlock(b43,chainHeadHeight + 15,out14,null);
  blocks.add(new BlockAndValidity(b53,true,false,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  spendableOutputs.offer(b53.getCoinbaseOutput());
  NewBlock b54=createNextBlock(b53,chainHeadHeight + 16,out15,null);
  b54.block.setTime(b35.block.getTimeSeconds() - 1);
  b54.solve();
  blocks.add(new BlockAndValidity(b54,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  NewBlock b55=createNextBlock(b53,chainHeadHeight + 16,out15,null);
  b55.block.setTime(b35.block.getTimeSeconds());
  b55.solve();
  blocks.add(new BlockAndValidity(b55,true,false,b55.getHash(),chainHeadHeight + 16,""String_Node_Str""));
  spendableOutputs.offer(b55.getCoinbaseOutput());
  TransactionOutPointWithValue out16=spendableOutputs.poll();
  NewBlock b57=createNextBlock(b55,chainHeadHeight + 17,out16,null);
  Transaction b56txToDuplicate;
{
    b56txToDuplicate=new Transaction(params);
    b56txToDuplicate.addOutput(new TransactionOutput(params,b56txToDuplicate,SATOSHI,new byte[]{}));
    addOnlyInputToTransaction(b56txToDuplicate,b57);
    b57.addTransaction(b56txToDuplicate);
  }
  b57.solve();
  Block b56;
  try {
    b56=new Block(params,b57.block.bitcoinSerialize());
  }
 catch (  ProtocolException e) {
    throw new RuntimeException(e);
  }
  b56.addTransaction(b56txToDuplicate);
  checkState(b56.getHash().equals(b57.getHash()));
  blocks.add(new BlockAndValidity(b56,false,true,b55.getHash(),chainHeadHeight + 16,""String_Node_Str""));
  NewBlock b57p2=createNextBlock(b55,chainHeadHeight + 17,out16,null);
  Transaction b56p2txToDuplicate1, b56p2txToDuplicate2;
{
    Transaction tx1=new Transaction(params);
    tx1.addOutput(new TransactionOutput(params,tx1,SATOSHI,new byte[]{OP_TRUE}));
    addOnlyInputToTransaction(tx1,b57p2);
    b57p2.addTransaction(tx1);
    Transaction tx2=new Transaction(params);
    tx2.addOutput(new TransactionOutput(params,tx2,SATOSHI,new byte[]{OP_TRUE}));
    addOnlyInputToTransaction(tx2,new TransactionOutPointWithValue(new TransactionOutPoint(params,0,tx1.getHash()),SATOSHI,tx1.getOutputs().get(0).getScriptPubKey()));
    b57p2.addTransaction(tx2);
    b56p2txToDuplicate1=new Transaction(params);
    b56p2txToDuplicate1.addOutput(new TransactionOutput(params,b56p2txToDuplicate1,SATOSHI,new byte[]{OP_TRUE}));
    addOnlyInputToTransaction(b56p2txToDuplicate1,new TransactionOutPointWithValue(new TransactionOutPoint(params,0,tx2.getHash()),SATOSHI,tx2.getOutputs().get(0).getScriptPubKey()));
    b57p2.addTransaction(b56p2txToDuplicate1);
    b56p2txToDuplicate2=new Transaction(params);
    b56p2txToDuplicate2.addOutput(new TransactionOutput(params,b56p2txToDuplicate2,SATOSHI,new byte[]{}));
    addOnlyInputToTransaction(b56p2txToDuplicate2,new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b56p2txToDuplicate1.getHash()),SATOSHI,b56p2txToDuplicate1.getOutputs().get(0).getScriptPubKey()));
    b57p2.addTransaction(b56p2txToDuplicate2);
  }
  b57p2.solve();
  Block b56p2;
  try {
    b56p2=new Block(params,b57p2.block.bitcoinSerialize());
  }
 catch (  ProtocolException e) {
    throw new RuntimeException(e);
  }
  b56p2.addTransaction(b56p2txToDuplicate1);
  b56p2.addTransaction(b56p2txToDuplicate2);
  checkState(b56p2.getHash().equals(b57p2.getHash()));
  blocks.add(new BlockAndValidity(b56p2,false,true,b55.getHash(),chainHeadHeight + 16,""String_Node_Str""));
  blocks.add(new BlockAndValidity(b57p2,true,false,b57p2.getHash(),chainHeadHeight + 17,""String_Node_Str""));
  blocks.add(new BlockAndValidity(b57,true,false,b57p2.getHash(),chainHeadHeight + 17,""String_Node_Str""));
  spendableOutputs.offer(b57.getCoinbaseOutput());
  TransactionOutPointWithValue out17=spendableOutputs.poll();
  NewBlock b58=createNextBlock(b57,chainHeadHeight + 18,out17,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,ZERO,new byte[]{}));
    b58.getSpendableOutput().outpoint.setIndex(42);
    addOnlyInputToTransaction(tx,b58);
    b58.addTransaction(tx);
  }
  b58.solve();
  blocks.add(new BlockAndValidity(b58,false,true,b57p2.getHash(),chainHeadHeight + 17,""String_Node_Str""));
  NewBlock b59=createNextBlock(b57,chainHeadHeight + 18,out17,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,b59.getSpendableOutput().value.add(SATOSHI),new byte[]{}));
    addOnlyInputToTransaction(tx,b59);
    b59.addTransaction(tx);
  }
  b59.solve();
  blocks.add(new BlockAndValidity(b59,false,true,b57p2.getHash(),chainHeadHeight + 17,""String_Node_Str""));
  NewBlock b60=createNextBlock(b57,chainHeadHeight + 18,out17,null);
  blocks.add(new BlockAndValidity(b60,true,false,b60.getHash(),chainHeadHeight + 18,""String_Node_Str""));
  spendableOutputs.offer(b60.getCoinbaseOutput());
  TransactionOutPointWithValue out18=spendableOutputs.poll();
  NewBlock b61=createNextBlock(b60,chainHeadHeight + 19,out18,null);
{
    b61.block.getTransactions().get(0).getInput(0).setScriptBytes(b60.block.getTransactions().get(0).getInput(0).getScriptBytes());
    b61.block.unCache();
    checkState(b61.block.getTransactions().get(0).equals(b60.block.getTransactions().get(0)));
  }
  b61.solve();
  blocks.add(new BlockAndValidity(b61,false,true,b60.getHash(),chainHeadHeight + 18,""String_Node_Str""));
  NewBlock b62=createNextBlock(b60,chainHeadHeight + 19,null,null);
{
    Transaction tx=new Transaction(params);
    tx.setLockTime(0xffffffffL);
    tx.addOutput(ZERO,OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(tx,out18,0);
    b62.addTransaction(tx);
    checkState(!tx.isFinal(chainHeadHeight + 17,b62.block.getTimeSeconds()));
  }
  b62.solve();
  blocks.add(new BlockAndValidity(b62,false,true,b60.getHash(),chainHeadHeight + 18,""String_Node_Str""));
  NewBlock b63=createNextBlock(b60,chainHeadHeight + 19,null,null);
{
    b63.block.getTransactions().get(0).setLockTime(0xffffffffL);
    b63.block.getTransactions().get(0).getInputs().get(0).setSequenceNumber(0xDEADBEEF);
    checkState(!b63.block.getTransactions().get(0).isFinal(chainHeadHeight + 17,b63.block.getTimeSeconds()));
  }
  b63.solve();
  blocks.add(new BlockAndValidity(b63,false,true,b60.getHash(),chainHeadHeight + 18,""String_Node_Str""));
  Block b64;
  NewBlock b64Original;
{
    b64Original=createNextBlock(b60,chainHeadHeight + 19,out18,null);
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIZE - b64Original.block.getMessageSize() - 65];
    Arrays.fill(outputScript,(byte)OP_FALSE);
    tx.addOutput(new TransactionOutput(params,tx,ZERO,outputScript));
    addOnlyInputToTransaction(tx,b64Original);
    b64Original.addTransaction(tx);
    b64Original.solve();
    checkState(b64Original.block.getMessageSize() == Block.MAX_BLOCK_SIZE);
    UnsafeByteArrayOutputStream stream=new UnsafeByteArrayOutputStream(b64Original.block.getMessageSize() + 8);
    b64Original.block.writeHeader(stream);
    byte[] varIntBytes=new byte[9];
    varIntBytes[0]=(byte)255;
    Utils.uint32ToByteArrayLE((long)b64Original.block.getTransactions().size(),varIntBytes,1);
    Utils.uint32ToByteArrayLE(((long)b64Original.block.getTransactions().size()) >>> 32,varIntBytes,5);
    stream.write(varIntBytes);
    checkState(new VarInt(varIntBytes,0).value == b64Original.block.getTransactions().size());
    for (    Transaction transaction : b64Original.block.getTransactions())     transaction.bitcoinSerialize(stream);
    b64=new Block(params,stream.toByteArray(),false,true,stream.size());
    checkState(stream.size() == b64Original.block.getMessageSize() + 8);
    checkState(stream.size() == b64.getMessageSize());
    checkState(Arrays.equals(stream.toByteArray(),b64.bitcoinSerialize()));
    checkState(b64.getOptimalEncodingMessageSize() == b64Original.block.getMessageSize());
  }
  blocks.add(new BlockAndValidity(b64,true,false,b64.getHash(),chainHeadHeight + 19,""String_Node_Str""));
  spendableOutputs.offer(b64Original.getCoinbaseOutput());
  TransactionOutPointWithValue out19=spendableOutputs.poll();
  checkState(out19 != null);
  NewBlock b65=createNextBlock(b64,chainHeadHeight + 20,null,null);
{
    Transaction tx1=new Transaction(params);
    tx1.addOutput(out19.value,OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(tx1,out19,0);
    b65.addTransaction(tx1);
    Transaction tx2=new Transaction(params);
    tx2.addOutput(ZERO,OP_TRUE_SCRIPT);
    tx2.addInput(tx1.getHash(),0,OP_TRUE_SCRIPT);
    b65.addTransaction(tx2);
  }
  b65.solve();
  blocks.add(new BlockAndValidity(b65,true,false,b65.getHash(),chainHeadHeight + 20,""String_Node_Str""));
  spendableOutputs.offer(b65.getCoinbaseOutput());
  TransactionOutPointWithValue out20=spendableOutputs.poll();
  checkState(out20 != null);
  NewBlock b66=createNextBlock(b65,chainHeadHeight + 21,null,null);
{
    Transaction tx1=new Transaction(params);
    tx1.addOutput(out20.value,OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(tx1,out20,0);
    Transaction tx2=new Transaction(params);
    tx2.addOutput(ZERO,OP_TRUE_SCRIPT);
    tx2.addInput(tx1.getHash(),0,OP_NOP_SCRIPT);
    b66.addTransaction(tx2);
    b66.addTransaction(tx1);
  }
  b66.solve();
  blocks.add(new BlockAndValidity(b66,false,true,b65.getHash(),chainHeadHeight + 20,""String_Node_Str""));
  NewBlock b67=createNextBlock(b65,chainHeadHeight + 21,null,null);
{
    Transaction tx1=new Transaction(params);
    tx1.addOutput(out20.value,OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(tx1,out20,0);
    b67.addTransaction(tx1);
    Transaction tx2=new Transaction(params);
    tx2.addOutput(ZERO,OP_TRUE_SCRIPT);
    tx2.addInput(tx1.getHash(),0,OP_NOP_SCRIPT);
    b67.addTransaction(tx2);
    Transaction tx3=new Transaction(params);
    tx3.addOutput(out20.value,OP_TRUE_SCRIPT);
    tx3.addInput(tx1.getHash(),0,OP_NOP_SCRIPT);
    b67.addTransaction(tx3);
  }
  b67.solve();
  blocks.add(new BlockAndValidity(b67,false,true,b65.getHash(),chainHeadHeight + 20,""String_Node_Str""));
  NewBlock b68=createNextBlock(b65,chainHeadHeight + 21,null,SATOSHI.multiply(10));
{
    Transaction tx=new Transaction(params);
    tx.addOutput(out20.value.subtract(Coin.valueOf(9)),OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(tx,out20,0);
    b68.addTransaction(tx);
  }
  b68.solve();
  blocks.add(new BlockAndValidity(b68,false,true,b65.getHash(),chainHeadHeight + 20,""String_Node_Str""));
  NewBlock b69=createNextBlock(b65,chainHeadHeight + 21,null,SATOSHI.multiply(10));
{
    Transaction tx=new Transaction(params);
    tx.addOutput(out20.value.subtract(Coin.valueOf(10)),OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(tx,out20,0);
    b69.addTransaction(tx);
  }
  b69.solve();
  blocks.add(new BlockAndValidity(b69,true,false,b69.getHash(),chainHeadHeight + 21,""String_Node_Str""));
  spendableOutputs.offer(b69.getCoinbaseOutput());
  TransactionOutPointWithValue out21=spendableOutputs.poll();
  checkState(out21 != null);
  NewBlock b70=createNextBlock(b69,chainHeadHeight + 22,out21,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(ZERO,OP_TRUE_SCRIPT);
    tx.addInput(Sha256Hash.wrap(""String_Node_Str""),0,OP_NOP_SCRIPT);
    b70.addTransaction(tx);
  }
  b70.solve();
  blocks.add(new BlockAndValidity(b70,false,true,b69.getHash(),chainHeadHeight + 21,""String_Node_Str""));
  NewBlock b72=createNextBlock(b69,chainHeadHeight + 22,out21,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(ZERO,OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(tx,b72);
    b72.addTransaction(tx);
  }
  b72.solve();
  Block b71=new Block(params,b72.block.bitcoinSerialize());
  b71.addTransaction(b72.block.getTransactions().get(2));
  checkState(b71.getHash().equals(b72.getHash()));
  blocks.add(new BlockAndValidity(b71,false,true,b69.getHash(),chainHeadHeight + 21,""String_Node_Str""));
  blocks.add(new BlockAndValidity(b72,true,false,b72.getHash(),chainHeadHeight + 22,""String_Node_Str""));
  spendableOutputs.offer(b72.getCoinbaseOutput());
  TransactionOutPointWithValue out22=spendableOutputs.poll();
  checkState(out22 != null);
  NewBlock b73=createNextBlock(b72,chainHeadHeight + 23,out22,null);
{
    int sigOps=0;
    for (    Transaction tx : b73.block.getTransactions()) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + (int)Script.MAX_SCRIPT_ELEMENT_SIZE + 1 + 5 + 1];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps]=OP_PUSHDATA4;
    Utils.uint32ToByteArrayLE(Script.MAX_SCRIPT_ELEMENT_SIZE + 1,outputScript,Block.MAX_BLOCK_SIGOPS - sigOps + 1);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,b73);
    b73.addTransaction(tx);
  }
  b73.solve();
  blocks.add(new BlockAndValidity(b73,false,true,b72.getHash(),chainHeadHeight + 22,""String_Node_Str""));
  NewBlock b74=createNextBlock(b72,chainHeadHeight + 23,out22,null);
{
    int sigOps=0;
    for (    Transaction tx : b74.block.getTransactions()) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + (int)Script.MAX_SCRIPT_ELEMENT_SIZE + 42];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 1]=OP_PUSHDATA4;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 2]=(byte)0xfe;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 3]=(byte)0xff;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 4]=(byte)0xff;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 5]=(byte)0xff;
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,b74);
    b74.addTransaction(tx);
  }
  b74.solve();
  blocks.add(new BlockAndValidity(b74,false,true,b72.getHash(),chainHeadHeight + 22,""String_Node_Str""));
  NewBlock b75=createNextBlock(b72,chainHeadHeight + 23,out22,null);
{
    int sigOps=0;
    for (    Transaction tx : b75.block.getTransactions()) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + (int)Script.MAX_SCRIPT_ELEMENT_SIZE + 42];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps]=OP_PUSHDATA4;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 1]=(byte)0xff;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 2]=(byte)0xff;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 3]=(byte)0xff;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 4]=(byte)0xff;
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,b75);
    b75.addTransaction(tx);
  }
  b75.solve();
  blocks.add(new BlockAndValidity(b75,true,false,b75.getHash(),chainHeadHeight + 23,""String_Node_Str""));
  spendableOutputs.offer(b75.getCoinbaseOutput());
  TransactionOutPointWithValue out23=spendableOutputs.poll();
  checkState(out23 != null);
  NewBlock b76=createNextBlock(b75,chainHeadHeight + 24,out23,null);
{
    int sigOps=0;
    for (    Transaction tx : b76.block.getTransactions()) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + (int)Script.MAX_SCRIPT_ELEMENT_SIZE + 1 + 5];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps]=OP_PUSHDATA4;
    Utils.uint32ToByteArrayLE(Block.MAX_BLOCK_SIGOPS,outputScript,Block.MAX_BLOCK_SIGOPS - sigOps + 1);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,b76);
    b76.addTransaction(tx);
  }
  b76.solve();
  blocks.add(new BlockAndValidity(b76,true,false,b76.getHash(),chainHeadHeight + 24,""String_Node_Str""));
  spendableOutputs.offer(b76.getCoinbaseOutput());
  TransactionOutPointWithValue out24=checkNotNull(spendableOutputs.poll());
  TransactionOutPointWithValue out25=checkNotNull(spendableOutputs.poll());
  TransactionOutPointWithValue out26=checkNotNull(spendableOutputs.poll());
  TransactionOutPointWithValue out27=checkNotNull(spendableOutputs.poll());
  NewBlock b77=createNextBlock(b76,chainHeadHeight + 25,out24,null);
  blocks.add(new BlockAndValidity(b77,true,false,b77.getHash(),chainHeadHeight + 25,""String_Node_Str""));
  spendableOutputs.offer(b77.getCoinbaseOutput());
  NewBlock b78=createNextBlock(b77,chainHeadHeight + 26,out25,null);
  Transaction b78tx=new Transaction(params);
{
    b78tx.addOutput(ZERO,OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(b78tx,b77);
    b78.addTransaction(b78tx);
  }
  b78.solve();
  blocks.add(new BlockAndValidity(b78,true,false,b78.getHash(),chainHeadHeight + 26,""String_Node_Str""));
  NewBlock b79=createNextBlock(b78,chainHeadHeight + 27,out26,null);
  Transaction b79tx=new Transaction(params);
{
    b79tx.addOutput(ZERO,OP_TRUE_SCRIPT);
    b79tx.addInput(b78tx.getHash(),0,OP_NOP_SCRIPT);
    b79.addTransaction(b79tx);
  }
  b79.solve();
  blocks.add(new BlockAndValidity(b79,true,false,b79.getHash(),chainHeadHeight + 27,""String_Node_Str""));
  blocks.add(new MemoryPoolState(new HashSet<InventoryItem>(),""String_Node_Str""));
  NewBlock b80=createNextBlock(b77,chainHeadHeight + 26,out25,null);
  blocks.add(new BlockAndValidity(b80,true,false,b79.getHash(),chainHeadHeight + 27,""String_Node_Str""));
  spendableOutputs.offer(b80.getCoinbaseOutput());
  NewBlock b81=createNextBlock(b80,chainHeadHeight + 27,out26,null);
  blocks.add(new BlockAndValidity(b81,true,false,b79.getHash(),chainHeadHeight + 27,""String_Node_Str""));
  spendableOutputs.offer(b81.getCoinbaseOutput());
  NewBlock b82=createNextBlock(b81,chainHeadHeight + 28,out27,null);
  blocks.add(new BlockAndValidity(b82,true,false,b82.getHash(),chainHeadHeight + 28,""String_Node_Str""));
  spendableOutputs.offer(b82.getCoinbaseOutput());
  HashSet<InventoryItem> post82Mempool=new HashSet<InventoryItem>();
  post82Mempool.add(new InventoryItem(InventoryItem.Type.Transaction,b78tx.getHash()));
  post82Mempool.add(new InventoryItem(InventoryItem.Type.Transaction,b79tx.getHash()));
  blocks.add(new MemoryPoolState(post82Mempool,""String_Node_Str""));
{
    TransactionOutPoint outpoint=new TransactionOutPoint(params,0,b79tx.getHash());
    long[] heights={UTXOsMessage.MEMPOOL_HEIGHT};
    UTXOsMessage result=new UTXOsMessage(params,ImmutableList.of(b79tx.getOutput(0)),heights,b82.getHash(),chainHeadHeight + 28);
    UTXORule utxo3=new UTXORule(""String_Node_Str"",outpoint,result);
    blocks.add(utxo3);
  }
  TransactionOutPointWithValue out28=spendableOutputs.poll();
  Preconditions.checkState(out28 != null);
  NewBlock b83=createNextBlock(b82,chainHeadHeight + 29,null,null);
{
    Transaction tx1=new Transaction(params);
    tx1.addOutput(new TransactionOutput(params,tx1,out28.value,new byte[]{OP_IF,(byte)OP_INVALIDOPCODE,OP_ELSE,OP_TRUE,OP_ENDIF}));
    addOnlyInputToTransaction(tx1,out28,0);
    b83.addTransaction(tx1);
    Transaction tx2=new Transaction(params);
    tx2.addOutput(new TransactionOutput(params,tx2,ZERO,new byte[]{OP_TRUE}));
    tx2.addInput(new TransactionInput(params,tx2,new byte[]{OP_FALSE},new TransactionOutPoint(params,0,tx1.getHash())));
    b83.addTransaction(tx2);
  }
  b83.solve();
  blocks.add(new BlockAndValidity(b83,true,false,b83.getHash(),chainHeadHeight + 29,""String_Node_Str""));
  spendableOutputs.offer(b83.getCoinbaseOutput());
  TransactionOutPointWithValue out29=spendableOutputs.poll();
  Preconditions.checkState(out29 != null);
  TransactionOutPointWithValue out30=spendableOutputs.poll();
  Preconditions.checkState(out30 != null);
  TransactionOutPointWithValue out31=spendableOutputs.poll();
  Preconditions.checkState(out31 != null);
  TransactionOutPointWithValue out32=spendableOutputs.poll();
  Preconditions.checkState(out32 != null);
  NewBlock b84=createNextBlock(b83,chainHeadHeight + 30,out29,null);
  Transaction b84tx1=new Transaction(params);
{
    b84tx1.addOutput(new TransactionOutput(params,b84tx1,ZERO,new byte[]{OP_RETURN}));
    b84tx1.addOutput(new TransactionOutput(params,b84tx1,ZERO,new byte[]{OP_TRUE}));
    b84tx1.addOutput(new TransactionOutput(params,b84tx1,ZERO,new byte[]{OP_TRUE}));
    b84tx1.addOutput(new TransactionOutput(params,b84tx1,ZERO,new byte[]{OP_TRUE}));
    b84tx1.addOutput(new TransactionOutput(params,b84tx1,ZERO,new byte[]{OP_TRUE}));
    addOnlyInputToTransaction(b84tx1,b84);
    b84.addTransaction(b84tx1);
    Transaction tx2=new Transaction(params);
    tx2.addOutput(new TransactionOutput(params,tx2,ZERO,new byte[]{OP_RETURN}));
    tx2.addOutput(new TransactionOutput(params,tx2,ZERO,new byte[]{OP_RETURN}));
    tx2.addInput(new TransactionInput(params,tx2,new byte[]{OP_TRUE},new TransactionOutPoint(params,1,b84tx1)));
    b84.addTransaction(tx2);
    Transaction tx3=new Transaction(params);
    tx3.addOutput(new TransactionOutput(params,tx3,ZERO,new byte[]{OP_RETURN}));
    tx3.addOutput(new TransactionOutput(params,tx3,ZERO,new byte[]{OP_TRUE}));
    tx3.addInput(new TransactionInput(params,tx3,new byte[]{OP_TRUE},new TransactionOutPoint(params,2,b84tx1)));
    b84.addTransaction(tx3);
    Transaction tx4=new Transaction(params);
    tx4.addOutput(new TransactionOutput(params,tx4,ZERO,new byte[]{OP_TRUE}));
    tx4.addOutput(new TransactionOutput(params,tx4,ZERO,new byte[]{OP_RETURN}));
    tx4.addInput(new TransactionInput(params,tx4,new byte[]{OP_TRUE},new TransactionOutPoint(params,3,b84tx1)));
    b84.addTransaction(tx4);
    Transaction tx5=new Transaction(params);
    tx5.addOutput(new TransactionOutput(params,tx5,ZERO,new byte[]{OP_RETURN}));
    tx5.addInput(new TransactionInput(params,tx5,new byte[]{OP_TRUE},new TransactionOutPoint(params,4,b84tx1)));
    b84.addTransaction(tx5);
  }
  b84.solve();
  blocks.add(new BlockAndValidity(b84,true,false,b84.getHash(),chainHeadHeight + 30,""String_Node_Str""));
  spendableOutputs.offer(b84.getCoinbaseOutput());
  NewBlock b85=createNextBlock(b83,chainHeadHeight + 30,out29,null);
  blocks.add(new BlockAndValidity(b85,true,false,b84.getHash(),chainHeadHeight + 30,""String_Node_Str""));
  NewBlock b86=createNextBlock(b85,chainHeadHeight + 31,out30,null);
  blocks.add(new BlockAndValidity(b86,true,false,b86.getHash(),chainHeadHeight + 31,""String_Node_Str""));
  NewBlock b87=createNextBlock(b84,chainHeadHeight + 31,out30,null);
  blocks.add(new BlockAndValidity(b87,true,false,b86.getHash(),chainHeadHeight + 31,""String_Node_Str""));
  spendableOutputs.offer(b87.getCoinbaseOutput());
  NewBlock b88=createNextBlock(b87,chainHeadHeight + 32,out31,null);
  blocks.add(new BlockAndValidity(b88,true,false,b88.getHash(),chainHeadHeight + 32,""String_Node_Str""));
  spendableOutputs.offer(b88.getCoinbaseOutput());
  NewBlock b89=createNextBlock(b88,chainHeadHeight + 33,out32,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,ZERO,new byte[]{OP_TRUE}));
    tx.addInput(new TransactionInput(params,tx,new byte[]{OP_TRUE},new TransactionOutPoint(params,0,b84tx1)));
    b89.addTransaction(tx);
    b89.solve();
  }
  blocks.add(new BlockAndValidity(b89,false,true,b88.getHash(),chainHeadHeight + 32,""String_Node_Str""));
  if (!runBarelyExpensiveTests) {
    if (outStream != null)     outStream.close();
    return ret;
  }
  NewBlock largeReorgFinal;
  int LARGE_REORG_SIZE=1008;
  int largeReorgLastHeight=chainHeadHeight + 33 + LARGE_REORG_SIZE+ 1;
{
    NewBlock nextBlock=b88;
    int nextHeight=chainHeadHeight + 33;
    TransactionOutPointWithValue largeReorgOutput=out32;
    for (int i=0; i < LARGE_REORG_SIZE; i++) {
      nextBlock=createNextBlock(nextBlock,nextHeight,largeReorgOutput,null);
      Transaction tx=new Transaction(params);
      byte[] outputScript=new byte[Block.MAX_BLOCK_SIZE - nextBlock.block.getMessageSize() - 65];
      Arrays.fill(outputScript,(byte)OP_FALSE);
      tx.addOutput(new TransactionOutput(params,tx,ZERO,outputScript));
      addOnlyInputToTransaction(tx,nextBlock);
      nextBlock.addTransaction(tx);
      nextBlock.solve();
      blocks.add(new BlockAndValidity(nextBlock,true,false,nextBlock.getHash(),nextHeight++,""String_Node_Str"" + i));
      spendableOutputs.offer(nextBlock.getCoinbaseOutput());
      largeReorgOutput=spendableOutputs.poll();
    }
    NewBlock reorgBase=b88;
    int reorgBaseHeight=chainHeadHeight + 33;
    for (int i=0; i < LARGE_REORG_SIZE; i++) {
      reorgBase=createNextBlock(reorgBase,reorgBaseHeight++,null,null);
      blocks.add(new BlockAndValidity(reorgBase,true,false,nextBlock.getHash(),nextHeight - 1,""String_Node_Str"" + i));
    }
    reorgBase=createNextBlock(reorgBase,reorgBaseHeight,null,null);
    blocks.add(new BlockAndValidity(reorgBase,true,false,reorgBase.getHash(),reorgBaseHeight,""String_Node_Str""));
    nextBlock=createNextBlock(nextBlock,nextHeight,null,null);
    blocks.add(new BlockAndValidity(nextBlock,true,false,reorgBase.getHash(),nextHeight++,""String_Node_Str""));
    spendableOutputs.offer(nextBlock.getCoinbaseOutput());
    nextBlock=createNextBlock(nextBlock,nextHeight,null,null);
    spendableOutputs.poll();
    blocks.add(new BlockAndValidity(nextBlock,true,false,nextBlock.getHash(),nextHeight++,""String_Node_Str""));
    spendableOutputs.offer(nextBlock.getCoinbaseOutput());
    largeReorgFinal=nextBlock;
  }
  ret.maximumReorgBlockCount=Math.max(ret.maximumReorgBlockCount,LARGE_REORG_SIZE + 2);
  NewBlock b1001=createNextBlock(largeReorgFinal,largeReorgLastHeight + 1,spendableOutputs.poll(),null);
  blocks.add(new BlockAndValidity(b1001,true,false,b1001.getHash(),largeReorgLastHeight + 1,""String_Node_Str""));
  spendableOutputs.offer(b1001.getCoinbaseOutput());
  int heightAfter1001=largeReorgLastHeight + 2;
  if (runExpensiveTests) {
    Preconditions.checkArgument(blockStorageFile != null);
    NewBlock lastBlock=b1001;
    TransactionOutPoint lastOutput=new TransactionOutPoint(params,1,b1001.block.getTransactions().get(1).getHash());
    int blockCountAfter1001;
    int nextHeight=heightAfter1001;
    List<Sha256Hash> hashesToSpend=new LinkedList<Sha256Hash>();
    final int TRANSACTION_CREATION_BLOCKS=100;
    for (blockCountAfter1001=0; blockCountAfter1001 < TRANSACTION_CREATION_BLOCKS; blockCountAfter1001++) {
      NewBlock block=createNextBlock(lastBlock,nextHeight++,null,null);
      while (block.block.getMessageSize() < Block.MAX_BLOCK_SIZE - 500) {
        Transaction tx=new Transaction(params);
        tx.addInput(lastOutput.getHash(),lastOutput.getIndex(),OP_NOP_SCRIPT);
        tx.addOutput(ZERO,OP_TRUE_SCRIPT);
        tx.addOutput(ZERO,OP_TRUE_SCRIPT);
        lastOutput=new TransactionOutPoint(params,1,tx.getHash());
        hashesToSpend.add(tx.getHash());
        block.addTransaction(tx);
      }
      block.solve();
      blocks.add(new BlockAndValidity(block,true,false,block.getHash(),nextHeight - 1,""String_Node_Str"" + blockCountAfter1001 + ""String_Node_Str""+ TRANSACTION_CREATION_BLOCKS).setSendOnce(true));
      lastBlock=block;
    }
    Iterator<Sha256Hash> hashes=hashesToSpend.iterator();
    for (int i=0; hashes.hasNext(); i++) {
      NewBlock block=createNextBlock(lastBlock,nextHeight++,null,null);
      while (block.block.getMessageSize() < Block.MAX_BLOCK_SIZE - 500 && hashes.hasNext()) {
        Transaction tx=new Transaction(params);
        tx.addInput(hashes.next(),0,OP_NOP_SCRIPT);
        tx.addOutput(ZERO,OP_TRUE_SCRIPT);
        block.addTransaction(tx);
      }
      block.solve();
      blocks.add(new BlockAndValidity(block,true,false,block.getHash(),nextHeight - 1,""String_Node_Str"" + i).setSendOnce(true));
      lastBlock=block;
      blockCountAfter1001++;
    }
    Sha256Hash firstHash=lastBlock.getHash();
    int height=nextHeight - 1;
    nextHeight=heightAfter1001;
    lastBlock=b1001;
    for (int i=0; i < blockCountAfter1001; i++) {
      NewBlock block=createNextBlock(lastBlock,nextHeight++,null,null);
      blocks.add(new BlockAndValidity(block,true,false,firstHash,height,""String_Node_Str"" + i + ""String_Node_Str""+ blockCountAfter1001));
      lastBlock=block;
    }
    NewBlock b1002=createNextBlock(lastBlock,nextHeight,null,null);
{
      Transaction tx=new Transaction(params);
      tx.addInput(hashesToSpend.get(0),0,OP_NOP_SCRIPT);
      tx.addOutput(ZERO,OP_TRUE_SCRIPT);
      b1002.addTransaction(tx);
    }
    b1002.solve();
    blocks.add(new BlockAndValidity(b1002,false,true,firstHash,height,""String_Node_Str""));
    NewBlock b1003=createNextBlock(lastBlock,nextHeight,null,null);
    blocks.add(new BlockAndValidity(b1003,true,false,b1003.getHash(),nextHeight,""String_Node_Str""));
    NewBlock b1004=createNextBlock(b1003,nextHeight + 1,null,null);
{
      Transaction tx=new Transaction(params);
      tx.addInput(hashesToSpend.get(0),0,OP_NOP_SCRIPT);
      tx.addOutput(ZERO,OP_TRUE_SCRIPT);
      b1004.addTransaction(tx);
    }
    b1004.solve();
    blocks.add(new BlockAndValidity(b1004,false,true,b1003.getHash(),nextHeight,""String_Node_Str""));
    ret.maximumReorgBlockCount=Math.max(ret.maximumReorgBlockCount,blockCountAfter1001);
  }
  if (outStream != null)   outStream.close();
  return ret;
}",0.9997491093381504
85623,"public void testBlock(byte[] blockBytes,boolean isChild,boolean lazy,boolean retain) throws Exception {
  BitcoinSerializer bsRef=new BitcoinSerializer(unitTestParams,false,false);
  ByteArrayOutputStream bos=new ByteArrayOutputStream();
  BitcoinSerializer bs=new BitcoinSerializer(unitTestParams,lazy,retain);
  Block b1;
  Block bRef;
  b1=(Block)bs.deserialize(ByteBuffer.wrap(blockBytes));
  bRef=(Block)bsRef.deserialize(ByteBuffer.wrap(blockBytes));
  bos.reset();
  bsRef.serialize(bRef,bos);
  assertTrue(Arrays.equals(bos.toByteArray(),blockBytes));
  assertEquals(!lazy,b1.isParsedTransactions());
  assertEquals(!lazy,b1.isParsedHeader());
  if (b1.isParsedHeader())   assertEquals(retain,b1.isHeaderBytesValid());
  if (b1.isParsedTransactions())   assertEquals(retain,b1.isTransactionBytesValid());
  serDeser(bs,b1,blockBytes,null,null);
  assertEquals(!lazy,b1.isParsedTransactions());
  assertEquals(!lazy,b1.isParsedHeader());
  if (b1.isParsedHeader())   assertEquals(retain,b1.isHeaderBytesValid());
  if (b1.isParsedTransactions())   assertEquals(retain,b1.isTransactionBytesValid());
  bos.reset();
  bsRef.serialize(bRef,bos);
  serDeser(bs,b1,bos.toByteArray(),null,null);
  b1.getTransactions();
  assertTrue(b1.isParsedTransactions());
  if (b1.getTransactions().size() > 0) {
    assertTrue(b1.isParsedTransactions());
    Transaction tx1=b1.getTransactions().get(0);
    if (tx1.isParsed())     assertEquals(retain,tx1.isCached());
 else     assertTrue(tx1.isCached());
    serDeser(bs,b1,bos.toByteArray(),null,null);
  }
  b1=(Block)bs.deserialize(ByteBuffer.wrap(blockBytes));
  bRef=(Block)bsRef.deserialize(ByteBuffer.wrap(blockBytes));
  b1.getDifficultyTarget();
  assertTrue(b1.isParsedHeader());
  assertEquals(lazy,!b1.isParsedTransactions());
  serDeser(bs,b1,bos.toByteArray(),null,null);
  b1=(Block)bs.deserialize(ByteBuffer.wrap(blockBytes));
  bRef=(Block)bsRef.deserialize(ByteBuffer.wrap(blockBytes));
  b1.getDifficultyTarget();
  assertTrue(b1.isParsedHeader());
  assertEquals(lazy,!b1.isParsedTransactions());
  b1.getTransactions();
  assertTrue(b1.isParsedTransactions());
  if (b1.getTransactions().size() > 0) {
    assertTrue(b1.isParsedTransactions());
    Transaction tx1=b1.getTransactions().get(0);
    if (tx1.isParsed())     assertEquals(retain,tx1.isCached());
 else     assertTrue(tx1.isCached());
  }
  serDeser(bs,b1,bos.toByteArray(),null,null);
  b1=(Block)bs.deserialize(ByteBuffer.wrap(blockBytes));
  bRef=(Block)bsRef.deserialize(ByteBuffer.wrap(blockBytes));
  b1.setNonce(23);
  bRef.setNonce(23);
  assertTrue(b1.isParsedHeader());
  assertEquals(lazy,!b1.isParsedTransactions());
  assertFalse(b1.isHeaderBytesValid());
  if (b1.isParsedTransactions())   assertEquals(retain,b1.isTransactionBytesValid());
 else   assertEquals(true,b1.isTransactionBytesValid());
  bos.reset();
  bsRef.serialize(bRef,bos);
  serDeser(bs,b1,bos.toByteArray(),null,null);
  b1=(Block)bs.deserialize(ByteBuffer.wrap(blockBytes));
  bRef=(Block)bsRef.deserialize(ByteBuffer.wrap(blockBytes));
  b1.getTransactions();
  if (b1.getTransactions().size() > 0) {
    Transaction tx1=b1.getTransactions().get(0);
    TransactionInput tin=tx1.getInputs().get(0);
    assertTrue(tx1.isParsed());
    assertTrue(b1.isParsedTransactions());
    assertEquals(!lazy,b1.isParsedHeader());
    assertEquals(!lazy,tin.isParsed());
    assertEquals(tin.isParsed() ? retain : true,tin.isCached());
    bos.reset();
    bsRef.serialize(bRef,bos);
    serDeser(bs,b1,bos.toByteArray(),null,null);
  }
  b1=(Block)bs.deserialize(ByteBuffer.wrap(blockBytes));
  bRef=(Block)bsRef.deserialize(ByteBuffer.wrap(blockBytes));
  b1.getTransactions();
  if (b1.getTransactions().size() > 0) {
    Transaction tx1=b1.getTransactions().get(0);
    if (tx1.getInputs().size() > 0) {
      tx1.addInput(tx1.getInputs().get(0));
      bRef.getTransactions().get(0).addInput(bRef.getTransactions().get(0).getInputs().get(0));
      assertFalse(tx1.isCached());
      assertTrue(tx1.isParsed());
      assertFalse(b1.isTransactionBytesValid());
      assertTrue(b1.isParsedHeader());
      if (tx1.getInputs().size() > 1) {
        boolean parsed=tx1.getInputs().get(1).isParsed();
        assertEquals(parsed ? retain : true,tx1.getInputs().get(1).isCached());
        assertEquals(!lazy,parsed);
      }
      assertFalse(b1.isHeaderBytesValid());
      bos.reset();
      bsRef.serialize(bRef,bos);
      byte[] source=bos.toByteArray();
      serDeser(bs,b1,source,null,null);
    }
    bos.reset();
    bsRef.serialize(bRef,bos);
    serDeser(bs,b1,bos.toByteArray(),null,null);
  }
  b1=(Block)bs.deserialize(ByteBuffer.wrap(blockBytes));
  Block b2=(Block)bs.deserialize(ByteBuffer.wrap(blockBytes));
  bRef=(Block)bsRef.deserialize(ByteBuffer.wrap(blockBytes));
  Block bRef2=(Block)bsRef.deserialize(ByteBuffer.wrap(blockBytes));
  b1.getTransactions();
  if (b1.getTransactions().size() > 0) {
    Transaction tx1=b1.getTransactions().get(0);
    Transaction tx2=b2.getTransactions().get(0);
    if (tx1.getInputs().size() > 0) {
      TransactionInput fromTx1=tx1.getInputs().get(0);
      tx2.addInput(fromTx1);
      TransactionInput fromTxRef=bRef.getTransactions().get(0).getInputs().get(0);
      bRef2.getTransactions().get(0).addInput(fromTxRef);
      assertFalse(b1.isTransactionBytesValid());
      assertFalse(b2.isTransactionBytesValid());
      bos.reset();
      bsRef.serialize(bRef2,bos);
      byte[] source=bos.toByteArray();
      serDeser(bs,b2,source,null,null);
    }
    bos.reset();
    bsRef.serialize(bRef,bos);
    serDeser(bs,b1,bos.toByteArray(),null,null);
    bRef=(Block)bsRef.deserialize(ByteBuffer.wrap(blockBytes));
    bos.reset();
    bsRef.serialize(bRef,bos);
    serDeser(bs,b1,bos.toByteArray(),null,null);
  }
}","public void testBlock(byte[] blockBytes,boolean isChild,boolean lazy,boolean retain) throws Exception {
  BitcoinSerializer bsRef=new BitcoinSerializer(unitTestParams,false,false);
  ByteArrayOutputStream bos=new ByteArrayOutputStream();
  BitcoinSerializer bs=new BitcoinSerializer(unitTestParams,lazy,retain);
  Block b1;
  Block bRef;
  b1=(Block)bs.deserialize(ByteBuffer.wrap(blockBytes));
  bRef=(Block)bsRef.deserialize(ByteBuffer.wrap(blockBytes));
  bos.reset();
  bsRef.serialize(bRef,bos);
  assertTrue(Arrays.equals(bos.toByteArray(),blockBytes));
  assertEquals(!lazy,b1.isParsedTransactions());
  assertEquals(!lazy,b1.isParsedHeader());
  if (b1.isParsedHeader())   assertEquals(retain,b1.isHeaderBytesValid());
  if (b1.isParsedTransactions())   assertEquals(retain,b1.isTransactionBytesValid());
  serDeser(bs,b1,blockBytes,null,null);
  assertEquals(!lazy,b1.isParsedTransactions());
  assertEquals(!lazy,b1.isParsedHeader());
  if (b1.isParsedHeader())   assertEquals(retain,b1.isHeaderBytesValid());
  if (b1.isParsedTransactions())   assertEquals(retain,b1.isTransactionBytesValid());
  bos.reset();
  bsRef.serialize(bRef,bos);
  serDeser(bs,b1,bos.toByteArray(),null,null);
  b1.getTransactions();
  assertTrue(b1.isParsedTransactions());
  if (b1.getTransactions().size() > 0) {
    assertTrue(b1.isParsedTransactions());
    Transaction tx1=b1.getTransactions().get(0);
    if (tx1.isParsed())     assertEquals(retain,tx1.isCached());
 else     assertTrue(tx1.isCached());
    serDeser(bs,b1,bos.toByteArray(),null,null);
  }
  b1=(Block)bs.deserialize(ByteBuffer.wrap(blockBytes));
  bRef=(Block)bsRef.deserialize(ByteBuffer.wrap(blockBytes));
  b1.getDifficultyTarget();
  assertTrue(b1.isParsedHeader());
  assertEquals(lazy,!b1.isParsedTransactions());
  serDeser(bs,b1,bos.toByteArray(),null,null);
  b1=(Block)bs.deserialize(ByteBuffer.wrap(blockBytes));
  bRef=(Block)bsRef.deserialize(ByteBuffer.wrap(blockBytes));
  b1.getDifficultyTarget();
  assertTrue(b1.isParsedHeader());
  assertEquals(lazy,!b1.isParsedTransactions());
  b1.getTransactions();
  assertTrue(b1.isParsedTransactions());
  if (b1.getTransactions().size() > 0) {
    assertTrue(b1.isParsedTransactions());
    Transaction tx1=b1.getTransactions().get(0);
    if (tx1.isParsed())     assertEquals(retain,tx1.isCached());
 else     assertTrue(tx1.isCached());
  }
  serDeser(bs,b1,bos.toByteArray(),null,null);
  b1=(Block)bs.deserialize(ByteBuffer.wrap(blockBytes));
  bRef=(Block)bsRef.deserialize(ByteBuffer.wrap(blockBytes));
  b1.setNonce(23);
  bRef.setNonce(23);
  assertTrue(b1.isParsedHeader());
  assertEquals(lazy,!b1.isParsedTransactions());
  assertFalse(b1.isHeaderBytesValid());
  if (b1.isParsedTransactions())   assertEquals(retain,b1.isTransactionBytesValid());
 else   assertEquals(true,b1.isTransactionBytesValid());
  bos.reset();
  bsRef.serialize(bRef,bos);
  serDeser(bs,b1,bos.toByteArray(),null,null);
  b1=(Block)bs.deserialize(ByteBuffer.wrap(blockBytes));
  bRef=(Block)bsRef.deserialize(ByteBuffer.wrap(blockBytes));
  b1.getTransactions();
  if (b1.getTransactions().size() > 0) {
    Transaction tx1=b1.getTransactions().get(0);
    TransactionInput tin=tx1.getInputs().get(0);
    assertTrue(tx1.isParsed());
    assertTrue(b1.isParsedTransactions());
    assertEquals(!lazy,b1.isParsedHeader());
    assertEquals(!lazy,tin.isParsed());
    assertEquals(!tin.isParsed() || retain,tin.isCached());
    bos.reset();
    bsRef.serialize(bRef,bos);
    serDeser(bs,b1,bos.toByteArray(),null,null);
  }
  b1=(Block)bs.deserialize(ByteBuffer.wrap(blockBytes));
  bRef=(Block)bsRef.deserialize(ByteBuffer.wrap(blockBytes));
  b1.getTransactions();
  if (b1.getTransactions().size() > 0) {
    Transaction tx1=b1.getTransactions().get(0);
    if (tx1.getInputs().size() > 0) {
      tx1.addInput(tx1.getInputs().get(0));
      bRef.getTransactions().get(0).addInput(bRef.getTransactions().get(0).getInputs().get(0));
      assertFalse(tx1.isCached());
      assertTrue(tx1.isParsed());
      assertFalse(b1.isTransactionBytesValid());
      assertTrue(b1.isParsedHeader());
      if (tx1.getInputs().size() > 1) {
        boolean parsed=tx1.getInputs().get(1).isParsed();
        assertEquals(!parsed || retain,tx1.getInputs().get(1).isCached());
        assertEquals(!lazy,parsed);
      }
      assertFalse(b1.isHeaderBytesValid());
      bos.reset();
      bsRef.serialize(bRef,bos);
      byte[] source=bos.toByteArray();
      serDeser(bs,b1,source,null,null);
    }
    bos.reset();
    bsRef.serialize(bRef,bos);
    serDeser(bs,b1,bos.toByteArray(),null,null);
  }
  b1=(Block)bs.deserialize(ByteBuffer.wrap(blockBytes));
  Block b2=(Block)bs.deserialize(ByteBuffer.wrap(blockBytes));
  bRef=(Block)bsRef.deserialize(ByteBuffer.wrap(blockBytes));
  Block bRef2=(Block)bsRef.deserialize(ByteBuffer.wrap(blockBytes));
  b1.getTransactions();
  if (b1.getTransactions().size() > 0) {
    Transaction tx1=b1.getTransactions().get(0);
    Transaction tx2=b2.getTransactions().get(0);
    if (tx1.getInputs().size() > 0) {
      TransactionInput fromTx1=tx1.getInputs().get(0);
      tx2.addInput(fromTx1);
      TransactionInput fromTxRef=bRef.getTransactions().get(0).getInputs().get(0);
      bRef2.getTransactions().get(0).addInput(fromTxRef);
      assertFalse(b1.isTransactionBytesValid());
      assertFalse(b2.isTransactionBytesValid());
      bos.reset();
      bsRef.serialize(bRef2,bos);
      byte[] source=bos.toByteArray();
      serDeser(bs,b2,source,null,null);
    }
    bos.reset();
    bsRef.serialize(bRef,bos);
    serDeser(bs,b1,bos.toByteArray(),null,null);
    bRef=(Block)bsRef.deserialize(ByteBuffer.wrap(blockBytes));
    bos.reset();
    bsRef.serialize(bRef,bos);
    serDeser(bs,b1,bos.toByteArray(),null,null);
  }
}",0.995674740484429
85624,"@Test public void validateSetup(){
  byte[] b1=new byte[]{1,1,1,2,3,4,5,6,7};
  byte[] b2=new byte[]{1,2,3};
  assertTrue(arrayContains(b1,b2));
  assertTrue(arrayContains(txMessage,txMessagePart));
  assertTrue(arrayContains(tx1BytesWithHeader,tx1Bytes));
  assertTrue(arrayContains(tx2BytesWithHeader,tx2Bytes));
  assertTrue(arrayContains(b1BytesWithHeader,b1Bytes));
  assertTrue(arrayContains(b1BytesWithHeader,tx1Bytes));
  assertTrue(arrayContains(b1BytesWithHeader,tx2Bytes));
  assertFalse(arrayContains(tx1BytesWithHeader,b1Bytes));
}","@Test public void validateSetup(){
  byte[] b1={1,1,1,2,3,4,5,6,7};
  byte[] b2={1,2,3};
  assertTrue(arrayContains(b1,b2));
  assertTrue(arrayContains(txMessage,txMessagePart));
  assertTrue(arrayContains(tx1BytesWithHeader,tx1Bytes));
  assertTrue(arrayContains(tx2BytesWithHeader,tx2Bytes));
  assertTrue(arrayContains(b1BytesWithHeader,b1Bytes));
  assertTrue(arrayContains(b1BytesWithHeader,tx1Bytes));
  assertTrue(arrayContains(b1BytesWithHeader,tx2Bytes));
  assertFalse(arrayContains(tx1BytesWithHeader,b1Bytes));
}",0.9400749063670412
85625,"/** 
 * Returns only the keys that have been issued by this chain, lookahead not included.
 */
public List<ECKey> getIssuedReceiveKeys(){
  return getKeys(false);
}","/** 
 * Returns only the external keys that have been issued by this chain, lookahead not included.
 */
public List<ECKey> getIssuedReceiveKeys(){
  final List<ECKey> keys=new ArrayList<ECKey>(getKeys(false));
  for (Iterator<ECKey> i=keys.iterator(); i.hasNext(); ) {
    DeterministicKey parent=((DeterministicKey)i.next()).getParent();
    if (parent == null || !externalKey.equals(parent))     i.remove();
  }
  return keys;
}",0.5218855218855218
85626,"@Override protected void processMessage(Message m) throws Exception {
  for (  ListenerRegistration<PeerEventListener> registration : eventListeners) {
    if (registration.executor == Threading.SAME_THREAD) {
      m=registration.listener.onPreMessageReceived(this,m);
      if (m == null)       break;
    }
  }
  if (m == null)   return;
  if (currentFilteredBlock != null && !(m instanceof Transaction)) {
    endFilteredBlock(currentFilteredBlock);
    currentFilteredBlock=null;
  }
  if (m instanceof Ping) {
    if (((Ping)m).hasNonce())     sendMessage(new Pong(((Ping)m).getNonce()));
  }
 else   if (m instanceof Pong) {
    processPong((Pong)m);
  }
 else   if (m instanceof NotFoundMessage) {
    processNotFoundMessage((NotFoundMessage)m);
  }
 else   if (m instanceof InventoryMessage) {
    processInv((InventoryMessage)m);
  }
 else   if (m instanceof Block) {
    processBlock((Block)m);
  }
 else   if (m instanceof FilteredBlock) {
    startFilteredBlock((FilteredBlock)m);
  }
 else   if (m instanceof Transaction) {
    processTransaction((Transaction)m);
  }
 else   if (m instanceof GetDataMessage) {
    processGetData((GetDataMessage)m);
  }
 else   if (m instanceof AddressMessage) {
    processAddressMessage((AddressMessage)m);
  }
 else   if (m instanceof HeadersMessage) {
    processHeaders((HeadersMessage)m);
  }
 else   if (m instanceof AlertMessage) {
    processAlert((AlertMessage)m);
  }
 else   if (m instanceof VersionMessage) {
    processVersionMessage((VersionMessage)m);
  }
 else   if (m instanceof VersionAck) {
    if (vPeerVersionMessage == null) {
      throw new ProtocolException(""String_Node_Str"");
    }
    if (isAcked) {
      throw new ProtocolException(""String_Node_Str"");
    }
    isAcked=true;
    this.setTimeoutEnabled(false);
    for (    final ListenerRegistration<PeerEventListener> registration : eventListeners) {
      registration.executor.execute(new Runnable(){
        @Override public void run(){
          registration.listener.onPeerConnected(Peer.this,1);
        }
      }
);
    }
    final int version=vMinProtocolVersion;
    if (vPeerVersionMessage.clientVersion < version) {
      log.warn(""String_Node_Str"",vPeerVersionMessage.clientVersion,version);
      close();
    }
  }
 else   if (m instanceof UTXOsMessage) {
    if (getutxoFutures != null) {
      SettableFuture<UTXOsMessage> future=getutxoFutures.pollFirst();
      if (future != null)       future.set((UTXOsMessage)m);
    }
  }
 else   if (m instanceof RejectMessage) {
    log.error(""String_Node_Str"",this,getPeerVersionMessage().subVer,m);
  }
 else {
    log.warn(""String_Node_Str"",this,m);
  }
}","@Override protected void processMessage(Message m) throws Exception {
  for (  ListenerRegistration<PeerEventListener> registration : eventListeners) {
    if (registration.executor == Threading.SAME_THREAD) {
      m=registration.listener.onPreMessageReceived(this,m);
      if (m == null)       break;
    }
  }
  if (m == null)   return;
  if (currentFilteredBlock != null && !(m instanceof Transaction)) {
    endFilteredBlock(currentFilteredBlock);
    currentFilteredBlock=null;
  }
  if (m instanceof Ping) {
    if (((Ping)m).hasNonce())     sendMessage(new Pong(((Ping)m).getNonce()));
  }
 else   if (m instanceof Pong) {
    processPong((Pong)m);
  }
 else   if (m instanceof NotFoundMessage) {
    processNotFoundMessage((NotFoundMessage)m);
  }
 else   if (m instanceof InventoryMessage) {
    processInv((InventoryMessage)m);
  }
 else   if (m instanceof Block) {
    processBlock((Block)m);
  }
 else   if (m instanceof FilteredBlock) {
    startFilteredBlock((FilteredBlock)m);
  }
 else   if (m instanceof Transaction) {
    processTransaction((Transaction)m);
  }
 else   if (m instanceof GetDataMessage) {
    processGetData((GetDataMessage)m);
  }
 else   if (m instanceof AddressMessage) {
    processAddressMessage((AddressMessage)m);
  }
 else   if (m instanceof HeadersMessage) {
    processHeaders((HeadersMessage)m);
  }
 else   if (m instanceof AlertMessage) {
    processAlert((AlertMessage)m);
  }
 else   if (m instanceof VersionMessage) {
    processVersionMessage((VersionMessage)m);
  }
 else   if (m instanceof VersionAck) {
    if (vPeerVersionMessage == null) {
      throw new ProtocolException(""String_Node_Str"");
    }
    if (isAcked) {
      throw new ProtocolException(""String_Node_Str"");
    }
    isAcked=true;
    this.setTimeoutEnabled(false);
    for (    final ListenerRegistration<PeerEventListener> registration : eventListeners) {
      registration.executor.execute(new Runnable(){
        @Override public void run(){
          registration.listener.onPeerConnected(Peer.this,1);
        }
      }
);
    }
    final int version=vMinProtocolVersion;
    if (vPeerVersionMessage.clientVersion < version) {
      log.warn(""String_Node_Str"",vPeerVersionMessage.clientVersion,version);
      close();
    }
  }
 else   if (m instanceof UTXOsMessage) {
    processUTXOMessage((UTXOsMessage)m);
  }
 else   if (m instanceof RejectMessage) {
    log.error(""String_Node_Str"",this,getPeerVersionMessage().subVer,m);
  }
 else {
    log.warn(""String_Node_Str"",this,m);
  }
}",0.969403563129357
85627,"@Override void bitcoinSerializeToStream(OutputStream stream) throws IOException {
  Utils.uint32ToByteStreamLE(height,stream);
  stream.write(chainHead.getBytes());
  stream.write(new VarInt(hits.length).encode());
  stream.write(hits);
  stream.write(new VarInt(outputs.size()).encode());
  for (  TransactionOutput output : outputs) {
    Transaction tx=output.getParentTransaction();
    Utils.uint32ToByteStreamLE(tx != null ? tx.getVersion() : 0L,stream);
    Utils.uint32ToByteStreamLE(height,stream);
    output.bitcoinSerializeToStream(stream);
  }
}","@Override void bitcoinSerializeToStream(OutputStream stream) throws IOException {
  Utils.uint32ToByteStreamLE(height,stream);
  stream.write(chainHead.getBytes());
  stream.write(new VarInt(hits.length).encode());
  stream.write(hits);
  stream.write(new VarInt(outputs.size()).encode());
  for (int i=0; i < outputs.size(); i++) {
    TransactionOutput output=outputs.get(i);
    Transaction tx=output.getParentTransaction();
    Utils.uint32ToByteStreamLE(tx != null ? tx.getVersion() : 0L,stream);
    Utils.uint32ToByteStreamLE(heights[i],stream);
    output.bitcoinSerializeToStream(stream);
  }
}",0.9388458225667528
85628,"@Override @Before public void setUp() throws Exception {
  super.setUp();
  confidenceTable=Context.get().getConfidenceTable();
  VersionMessage ver=new VersionMessage(unitTestParams,100);
  InetSocketAddress address=new InetSocketAddress(""String_Node_Str"",4000);
  peer=new Peer(unitTestParams,ver,new PeerAddress(address),blockChain);
  peer.addWallet(wallet);
}","@Override @Before public void setUp() throws Exception {
  super.setUp();
  VersionMessage ver=new VersionMessage(unitTestParams,100);
  InetSocketAddress address=new InetSocketAddress(""String_Node_Str"",4000);
  peer=new Peer(unitTestParams,ver,new PeerAddress(address),blockChain);
  peer.addWallet(wallet);
}",0.9198813056379822
85629,"@Test public void getUTXOs() throws Exception {
  connectWithVersion(GetUTXOsMessage.MIN_PROTOCOL_VERSION,VersionMessage.NODE_NETWORK | VersionMessage.NODE_GETUTXOS);
  Sha256Hash hash1=Sha256Hash.hash(""String_Node_Str"".getBytes());
  TransactionOutPoint op1=new TransactionOutPoint(unitTestParams,1,hash1);
  Sha256Hash hash2=Sha256Hash.hash(""String_Node_Str"".getBytes());
  TransactionOutPoint op2=new TransactionOutPoint(unitTestParams,2,hash1);
  ListenableFuture<UTXOsMessage> future1=peer.getUTXOs(ImmutableList.of(op1));
  ListenableFuture<UTXOsMessage> future2=peer.getUTXOs(ImmutableList.of(op2));
  GetUTXOsMessage msg1=(GetUTXOsMessage)outbound(writeTarget);
  GetUTXOsMessage msg2=(GetUTXOsMessage)outbound(writeTarget);
  assertEquals(op1,msg1.getOutPoints().get(0));
  assertEquals(op2,msg2.getOutPoints().get(0));
  assertEquals(1,msg1.getOutPoints().size());
  assertFalse(future1.isDone());
  ECKey key=new ECKey();
  TransactionOutput out1=new TransactionOutput(unitTestParams,null,Coin.CENT,key);
  UTXOsMessage response1=new UTXOsMessage(unitTestParams,ImmutableList.of(out1),new long[]{-1},Sha256Hash.ZERO_HASH,1234);
  inbound(writeTarget,response1);
  assertEquals(future1.get(),response1);
  TransactionOutput out2=new TransactionOutput(unitTestParams,null,Coin.FIFTY_COINS,key);
  UTXOsMessage response2=new UTXOsMessage(unitTestParams,ImmutableList.of(out2),new long[]{-1},Sha256Hash.ZERO_HASH,1234);
  inbound(writeTarget,response2);
  assertEquals(future1.get(),response2);
}","@Test public void getUTXOs() throws Exception {
  connectWithVersion(GetUTXOsMessage.MIN_PROTOCOL_VERSION,VersionMessage.NODE_NETWORK | VersionMessage.NODE_GETUTXOS);
  TransactionOutPoint op1=new TransactionOutPoint(unitTestParams,1,Sha256Hash.hash(""String_Node_Str"".getBytes()));
  TransactionOutPoint op2=new TransactionOutPoint(unitTestParams,2,Sha256Hash.hash(""String_Node_Str"".getBytes()));
  ListenableFuture<UTXOsMessage> future1=peer.getUTXOs(ImmutableList.of(op1));
  ListenableFuture<UTXOsMessage> future2=peer.getUTXOs(ImmutableList.of(op2));
  GetUTXOsMessage msg1=(GetUTXOsMessage)outbound(writeTarget);
  GetUTXOsMessage msg2=(GetUTXOsMessage)outbound(writeTarget);
  assertEquals(op1,msg1.getOutPoints().get(0));
  assertEquals(op2,msg2.getOutPoints().get(0));
  assertEquals(1,msg1.getOutPoints().size());
  assertFalse(future1.isDone());
  ECKey key=new ECKey();
  TransactionOutput out1=new TransactionOutput(unitTestParams,null,Coin.CENT,key);
  UTXOsMessage response1=new UTXOsMessage(unitTestParams,ImmutableList.of(out1),new long[]{UTXOsMessage.MEMPOOL_HEIGHT},Sha256Hash.ZERO_HASH,1234);
  inbound(writeTarget,response1);
  assertEquals(future1.get(),response1);
  TransactionOutput out2=new TransactionOutput(unitTestParams,null,Coin.FIFTY_COINS,key);
  UTXOsMessage response2=new UTXOsMessage(unitTestParams,ImmutableList.of(out2),new long[]{1000},Sha256Hash.ZERO_HASH,1234);
  inbound(writeTarget,response2);
  assertEquals(future2.get(),response2);
}",0.8594431398859443
85630,"private void processInv(InventoryMessage inv){
  List<InventoryItem> items=inv.getItems();
  List<InventoryItem> transactions=new LinkedList<InventoryItem>();
  List<InventoryItem> blocks=new LinkedList<InventoryItem>();
  for (  InventoryItem item : items) {
switch (item.type) {
case Transaction:
      transactions.add(item);
    break;
case Block:
  blocks.add(item);
break;
default :
throw new IllegalStateException(""String_Node_Str"" + item.type);
}
}
final boolean downloadData=this.vDownloadData;
if (transactions.size() == 0 && blocks.size() == 1) {
if (downloadData && blockChain != null) {
if (!blockChain.isOrphan(blocks.get(0).hash)) {
blocksAnnounced.incrementAndGet();
}
}
 else {
blocksAnnounced.incrementAndGet();
}
}
GetDataMessage getdata=new GetDataMessage(params);
Iterator<InventoryItem> it=transactions.iterator();
while (it.hasNext()) {
InventoryItem item=it.next();
TransactionConfidence conf=context.getConfidenceTable().seen(item.hash,this.getAddress());
if (conf.numBroadcastPeers() > 1) {
it.remove();
}
 else {
log.debug(""String_Node_Str"",getAddress(),item.hash);
getdata.addItem(item);
pendingTxDownloads.add(conf);
}
}
boolean pingAfterGetData=false;
lock.lock();
try {
if (blocks.size() > 0 && downloadData && blockChain != null) {
for (InventoryItem item : blocks) {
if (blockChain.isOrphan(item.hash) && downloadBlockBodies) {
final Block orphanRoot=checkNotNull(blockChain.getOrphanRoot(item.hash));
blockChainDownloadLocked(orphanRoot.getHash());
}
 else {
if (!pendingBlockDownloads.contains(item.hash)) {
  if (vPeerVersionMessage.isBloomFilteringSupported() && useFilteredBlocks) {
    getdata.addFilteredBlock(item.hash);
    pingAfterGetData=true;
  }
 else {
    getdata.addItem(item);
  }
  pendingBlockDownloads.add(item.hash);
}
}
}
}
}
  finally {
lock.unlock();
}
if (!getdata.getItems().isEmpty()) {
sendMessage(getdata);
}
if (pingAfterGetData) sendMessage(new Ping((long)(Math.random() * Long.MAX_VALUE)));
}","private void processInv(InventoryMessage inv){
  List<InventoryItem> items=inv.getItems();
  List<InventoryItem> transactions=new LinkedList<InventoryItem>();
  List<InventoryItem> blocks=new LinkedList<InventoryItem>();
  for (  InventoryItem item : items) {
switch (item.type) {
case Transaction:
      transactions.add(item);
    break;
case Block:
  blocks.add(item);
break;
default :
throw new IllegalStateException(""String_Node_Str"" + item.type);
}
}
final boolean downloadData=this.vDownloadData;
if (transactions.size() == 0 && blocks.size() == 1) {
if (downloadData && blockChain != null) {
if (!blockChain.isOrphan(blocks.get(0).hash)) {
blocksAnnounced.incrementAndGet();
}
}
 else {
blocksAnnounced.incrementAndGet();
}
}
GetDataMessage getdata=new GetDataMessage(params);
Iterator<InventoryItem> it=transactions.iterator();
while (it.hasNext()) {
InventoryItem item=it.next();
TransactionConfidence conf=context.getConfidenceTable().seen(item.hash,this.getAddress());
if (conf.numBroadcastPeers() > 1) {
it.remove();
}
 else if (conf.getSource().equals(TransactionConfidence.Source.SELF)) {
it.remove();
}
 else {
log.debug(""String_Node_Str"",getAddress(),item.hash);
getdata.addItem(item);
pendingTxDownloads.add(conf);
}
}
boolean pingAfterGetData=false;
lock.lock();
try {
if (blocks.size() > 0 && downloadData && blockChain != null) {
for (InventoryItem item : blocks) {
if (blockChain.isOrphan(item.hash) && downloadBlockBodies) {
final Block orphanRoot=checkNotNull(blockChain.getOrphanRoot(item.hash));
blockChainDownloadLocked(orphanRoot.getHash());
}
 else {
if (!pendingBlockDownloads.contains(item.hash)) {
  if (vPeerVersionMessage.isBloomFilteringSupported() && useFilteredBlocks) {
    getdata.addFilteredBlock(item.hash);
    pingAfterGetData=true;
  }
 else {
    getdata.addItem(item);
  }
  pendingBlockDownloads.add(item.hash);
}
}
}
}
}
  finally {
lock.unlock();
}
if (!getdata.getItems().isEmpty()) {
sendMessage(getdata);
}
if (pingAfterGetData) sendMessage(new Ping((long)(Math.random() * Long.MAX_VALUE)));
}",0.978266300274794
85631,"/** 
 * <p>Given a transaction, sends it un-announced to one peer and then waits for it to be received back from other peers. Once all connected peers have announced the transaction, the future available via the  {@link org.bitcoinj.core.TransactionBroadcast#future()} method will be completed. If anything goeswrong the exception will be thrown when get() is called, or you can receive it via a callback on the {@link ListenableFuture}. This method returns immediately, so if you want it to block just call get() on the result.</p> <p>Note that if the PeerGroup is limited to only one connection (discovery is not activated) then the future will complete as soon as the transaction was successfully written to that peer.</p> <p>The transaction won't be sent until there are at least minConnections active connections available. A good choice for proportion would be between 0.5 and 0.8 but if you want faster transmission during initial bringup of the peer group you can lower it.</p> <p>The returned   {@link org.bitcoinj.core.TransactionBroadcast} object can be used to get progress feedback,which is calculated by watching the transaction propagate across the network and be announced by peers.</p>
 */
public TransactionBroadcast broadcastTransaction(final Transaction tx,final int minConnections){
  final TransactionBroadcast broadcast=new TransactionBroadcast(this,tx);
  broadcast.setMinConnections(minConnections);
  Futures.addCallback(broadcast.future(),new FutureCallback<Transaction>(){
    @Override public void onSuccess(    Transaction transaction){
      runningBroadcasts.remove(broadcast);
      for (      Wallet wallet : wallets) {
        try {
          wallet.receivePending(transaction,null);
        }
 catch (        VerificationException e) {
          throw new RuntimeException(e);
        }
      }
    }
    @Override public void onFailure(    Throwable throwable){
      runningBroadcasts.remove(broadcast);
    }
  }
);
  runningBroadcasts.add(broadcast);
  broadcast.broadcast();
  return broadcast;
}","/** 
 * <p>Given a transaction, sends it un-announced to one peer and then waits for it to be received back from other peers. Once all connected peers have announced the transaction, the future available via the  {@link org.bitcoinj.core.TransactionBroadcast#future()} method will be completed. If anything goeswrong the exception will be thrown when get() is called, or you can receive it via a callback on the {@link ListenableFuture}. This method returns immediately, so if you want it to block just call get() on the result.</p> <p>Note that if the PeerGroup is limited to only one connection (discovery is not activated) then the future will complete as soon as the transaction was successfully written to that peer.</p> <p>The transaction won't be sent until there are at least minConnections active connections available. A good choice for proportion would be between 0.5 and 0.8 but if you want faster transmission during initial bringup of the peer group you can lower it.</p> <p>The returned   {@link org.bitcoinj.core.TransactionBroadcast} object can be used to get progress feedback,which is calculated by watching the transaction propagate across the network and be announced by peers.</p>
 */
public TransactionBroadcast broadcastTransaction(final Transaction tx,final int minConnections){
  if (tx.getConfidence().getSource().equals(TransactionConfidence.Source.UNKNOWN)) {
    tx.getConfidence().setSource(TransactionConfidence.Source.SELF);
  }
  final TransactionBroadcast broadcast=new TransactionBroadcast(this,tx);
  broadcast.setMinConnections(minConnections);
  Futures.addCallback(broadcast.future(),new FutureCallback<Transaction>(){
    @Override public void onSuccess(    Transaction transaction){
      runningBroadcasts.remove(broadcast);
      for (      Wallet wallet : wallets) {
        try {
          wallet.receivePending(transaction,null);
        }
 catch (        VerificationException e) {
          throw new RuntimeException(e);
        }
      }
    }
    @Override public void onFailure(    Throwable throwable){
      runningBroadcasts.remove(broadcast);
    }
  }
);
  runningBroadcasts.add(broadcast);
  broadcast.broadcast();
  return broadcast;
}",0.9626654064272212
85632,"@Test public void fourPeers() throws Exception {
  InboundMessageQueuer[] channels={connectPeer(1),connectPeer(2),connectPeer(3),connectPeer(4)};
  Transaction tx=new Transaction(params);
  TransactionBroadcast broadcast=new TransactionBroadcast(peerGroup,tx);
  final AtomicDouble lastProgress=new AtomicDouble();
  broadcast.setProgressCallback(new TransactionBroadcast.ProgressCallback(){
    @Override public void onBroadcastProgress(    double progress){
      lastProgress.set(progress);
    }
  }
);
  ListenableFuture<Transaction> future=broadcast.broadcast();
  assertFalse(future.isDone());
  assertEquals(0.0,lastProgress.get(),0.0);
  Message[] messages={(Message)outbound(channels[0]),(Message)outbound(channels[1]),(Message)outbound(channels[2]),(Message)outbound(channels[3])};
  assertEquals(tx,messages[0]);
  assertEquals(tx,messages[3]);
  assertNull(messages[1]);
  assertNull(messages[2]);
  Threading.waitForUserCode();
  assertFalse(future.isDone());
  assertEquals(0.0,lastProgress.get(),0.0);
  inbound(channels[1],InventoryMessage.with(tx));
  pingAndWait(channels[1]);
  future.get();
  Threading.waitForUserCode();
  assertEquals(1.0,lastProgress.get(),0.0);
}","@Test public void fourPeers() throws Exception {
  InboundMessageQueuer[] channels={connectPeer(1),connectPeer(2),connectPeer(3),connectPeer(4)};
  Transaction tx=new Transaction(params);
  tx.getConfidence().setSource(TransactionConfidence.Source.SELF);
  TransactionBroadcast broadcast=new TransactionBroadcast(peerGroup,tx);
  final AtomicDouble lastProgress=new AtomicDouble();
  broadcast.setProgressCallback(new TransactionBroadcast.ProgressCallback(){
    @Override public void onBroadcastProgress(    double progress){
      lastProgress.set(progress);
    }
  }
);
  ListenableFuture<Transaction> future=broadcast.broadcast();
  assertFalse(future.isDone());
  assertEquals(0.0,lastProgress.get(),0.0);
  Message[] messages={(Message)outbound(channels[0]),(Message)outbound(channels[1]),(Message)outbound(channels[2]),(Message)outbound(channels[3])};
  assertEquals(tx,messages[0]);
  assertEquals(tx,messages[3]);
  assertNull(messages[1]);
  assertNull(messages[2]);
  Threading.waitForUserCode();
  assertFalse(future.isDone());
  assertEquals(0.0,lastProgress.get(),0.0);
  inbound(channels[1],InventoryMessage.with(tx));
  future.get();
  Threading.waitForUserCode();
  assertEquals(1.0,lastProgress.get(),0.0);
  assertNull(outbound(channels[1]));
}",0.8866231647634584
85633,"@Override public int receiveBytes(ByteBuffer buff){
  checkArgument(buff.position() == 0 && buff.capacity() >= BitcoinSerializer.BitcoinPacketHeader.HEADER_LENGTH + 4);
  try {
    boolean firstMessage=true;
    while (true) {
      if (largeReadBuffer != null) {
        checkState(firstMessage);
        int bytesToGet=Math.min(buff.remaining(),largeReadBuffer.length - largeReadBufferPos);
        buff.get(largeReadBuffer,largeReadBufferPos,bytesToGet);
        largeReadBufferPos+=bytesToGet;
        if (largeReadBufferPos == largeReadBuffer.length) {
          processMessage(serializer.deserializePayload(header,ByteBuffer.wrap(largeReadBuffer)));
          largeReadBuffer=null;
          header=null;
        }
 else         return buff.position();
      }
      Message message;
      int preSerializePosition=buff.position();
      try {
        message=serializer.deserialize(buff);
      }
 catch (      BufferUnderflowException e) {
        if (firstMessage && buff.limit() == buff.capacity()) {
          buff.position(0);
          try {
            serializer.seekPastMagicBytes(buff);
            header=serializer.deserializeHeader(buff);
            largeReadBuffer=new byte[header.size];
            largeReadBufferPos=buff.remaining();
            buff.get(largeReadBuffer,0,largeReadBufferPos);
          }
 catch (          BufferUnderflowException e1) {
            throw new ProtocolException(""String_Node_Str"" + buff.capacity() + ""String_Node_Str"");
          }
        }
 else {
          buff.position(preSerializePosition);
        }
        return buff.position();
      }
      processMessage(message);
      firstMessage=false;
    }
  }
 catch (  Exception e) {
    exceptionCaught(e);
    return -1;
  }
}","@Override public int receiveBytes(ByteBuffer buff){
  checkArgument(buff.position() == 0 && buff.capacity() >= BitcoinSerializer.BitcoinPacketHeader.HEADER_LENGTH + 4);
  try {
    boolean firstMessage=true;
    while (true) {
      if (largeReadBuffer != null) {
        checkState(firstMessage);
        int bytesToGet=Math.min(buff.remaining(),largeReadBuffer.length - largeReadBufferPos);
        buff.get(largeReadBuffer,largeReadBufferPos,bytesToGet);
        largeReadBufferPos+=bytesToGet;
        if (largeReadBufferPos == largeReadBuffer.length) {
          processMessage(serializer.deserializePayload(header,ByteBuffer.wrap(largeReadBuffer)));
          largeReadBuffer=null;
          header=null;
          firstMessage=false;
        }
 else         return buff.position();
      }
      Message message;
      int preSerializePosition=buff.position();
      try {
        message=serializer.deserialize(buff);
      }
 catch (      BufferUnderflowException e) {
        if (firstMessage && buff.limit() == buff.capacity()) {
          buff.position(0);
          try {
            serializer.seekPastMagicBytes(buff);
            header=serializer.deserializeHeader(buff);
            largeReadBuffer=new byte[header.size];
            largeReadBufferPos=buff.remaining();
            buff.get(largeReadBuffer,0,largeReadBufferPos);
          }
 catch (          BufferUnderflowException e1) {
            throw new ProtocolException(""String_Node_Str"" + buff.capacity() + ""String_Node_Str"");
          }
        }
 else {
          buff.position(preSerializePosition);
        }
        return buff.position();
      }
      processMessage(message);
      firstMessage=false;
    }
  }
 catch (  Exception e) {
    exceptionCaught(e);
    return -1;
  }
}",0.9914578587699316
85634,"public static void main(String[] args) throws Exception {
  OptionParser parser=new OptionParser();
  parser.accepts(""String_Node_Str"");
  parser.accepts(""String_Node_Str"");
  parser.accepts(""String_Node_Str"");
  OptionSpec<String> walletFileName=parser.accepts(""String_Node_Str"").withRequiredArg().defaultsTo(""String_Node_Str"");
  seedFlag=parser.accepts(""String_Node_Str"").withRequiredArg();
  watchFlag=parser.accepts(""String_Node_Str"").withRequiredArg();
  OptionSpec<NetworkEnum> netFlag=parser.accepts(""String_Node_Str"").withOptionalArg().ofType(NetworkEnum.class).defaultsTo(NetworkEnum.PROD);
  dateFlag=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(Date.class).withValuesConvertedBy(DateConverter.datePattern(""String_Node_Str""));
  OptionSpec<WaitForEnum> waitForFlag=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(WaitForEnum.class);
  OptionSpec<ValidationMode> modeFlag=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(ValidationMode.class).defaultsTo(ValidationMode.SPV);
  OptionSpec<String> chainFlag=parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  xpubkeysFlag=parser.accepts(""String_Node_Str"").withRequiredArg();
  OptionSpec<String> outputFlag=parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  unixtimeFlag=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(Integer.class);
  OptionSpec<String> conditionFlag=parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"");
  parser.accepts(""String_Node_Str"");
  parser.accepts(""String_Node_Str"");
  lookaheadSize=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(Integer.class);
  OptionSpec<String> passwordFlag=parser.accepts(""String_Node_Str"").withRequiredArg();
  OptionSpec<String> paymentRequestLocation=parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"");
  parser.accepts(""String_Node_Str"");
  parser.accepts(""String_Node_Str"");
  options=parser.parse(args);
  final String HELP_TEXT=Resources.toString(WalletTool.class.getResource(""String_Node_Str""),Charsets.UTF_8);
  if (args.length == 0 || options.has(""String_Node_Str"") || options.nonOptionArguments().size() < 1 || options.nonOptionArguments().contains(""String_Node_Str"")) {
    System.out.println(HELP_TEXT);
    return;
  }
  ActionEnum action;
  try {
    String actionStr=options.nonOptionArguments().get(0);
    actionStr=actionStr.toUpperCase().replace(""String_Node_Str"",""String_Node_Str"");
    action=ActionEnum.valueOf(actionStr);
  }
 catch (  IllegalArgumentException e) {
    System.err.println(""String_Node_Str"" + options.nonOptionArguments().get(0));
    return;
  }
  if (options.has(""String_Node_Str"")) {
    BriefLogFormatter.init();
    log.info(""String_Node_Str"");
  }
 else {
    java.util.logging.Logger logger=LogManager.getLogManager().getLogger(""String_Node_Str"");
    logger.setLevel(Level.SEVERE);
  }
switch (netFlag.value(options)) {
case PROD:
    params=MainNetParams.get();
  chainFileName=new File(""String_Node_Str"");
break;
case TEST:
params=TestNet3Params.get();
chainFileName=new File(""String_Node_Str"");
break;
case REGTEST:
params=RegTestParams.get();
chainFileName=new File(""String_Node_Str"");
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
mode=modeFlag.value(options);
if (options.has(chainFlag)) {
chainFileName=new File(chainFlag.value(options));
}
if (options.has(""String_Node_Str"")) {
condition=new Condition(conditionFlag.value(options));
}
if (options.has(passwordFlag)) {
password=passwordFlag.value(options);
}
walletFile=new File(walletFileName.value(options));
if (action == ActionEnum.CREATE) {
createWallet(options,params,walletFile);
return;
}
if (!walletFile.exists()) {
System.err.println(""String_Node_Str"" + walletFile + ""String_Node_Str""+ walletFile+ ""String_Node_Str"");
return;
}
if (action == ActionEnum.RAW_DUMP) {
FileInputStream stream=new FileInputStream(walletFile);
try {
Protos.Wallet proto=WalletProtobufSerializer.parseToProto(stream);
proto=attemptHexConversion(proto);
System.out.println(proto.toString());
return;
}
  finally {
stream.close();
}
}
InputStream walletInputStream=null;
try {
WalletProtobufSerializer loader=new WalletProtobufSerializer();
if (options.has(""String_Node_Str"")) loader.setRequireMandatoryExtensions(false);
walletInputStream=new BufferedInputStream(new FileInputStream(walletFile));
wallet=loader.readWallet(walletInputStream);
if (!wallet.getParams().equals(params)) {
System.err.println(""String_Node_Str"" + wallet.getParams().getId() + ""String_Node_Str""+ params.getId());
return;
}
}
 catch (Exception e) {
System.err.println(""String_Node_Str"" + walletFile + ""String_Node_Str""+ e.getMessage());
e.printStackTrace();
return;
}
 finally {
if (walletInputStream != null) {
walletInputStream.close();
}
}
switch (action) {
case DUMP:
dumpWallet();
break;
case ADD_KEY:
addKey();
break;
case ADD_ADDR:
addAddr();
break;
case DELETE_KEY:
deleteKey();
break;
case RESET:
reset();
break;
case SYNC:
syncChain();
break;
case SEND:
if (options.has(paymentRequestLocation) && options.has(outputFlag)) {
System.err.println(""String_Node_Str"");
return;
}
 else if (options.has(outputFlag)) {
Coin fee=Coin.ZERO;
if (options.has(""String_Node_Str"")) {
fee=parseCoin((String)options.valueOf(""String_Node_Str""));
}
String lockTime=null;
if (options.has(""String_Node_Str"")) {
lockTime=(String)options.valueOf(""String_Node_Str"");
}
boolean allowUnconfirmed=options.has(""String_Node_Str"");
send(outputFlag.values(options),fee,lockTime,allowUnconfirmed);
}
 else if (options.has(paymentRequestLocation)) {
sendPaymentRequest(paymentRequestLocation.value(options),!options.has(""String_Node_Str""));
}
 else {
System.err.println(""String_Node_Str"");
return;
}
break;
case ENCRYPT:
encrypt();
break;
case DECRYPT:
decrypt();
break;
case MARRY:
marry();
break;
case ROTATE:
rotate();
break;
}
if (!wallet.isConsistent()) {
System.err.println(""String_Node_Str"");
return;
}
saveWallet(walletFile);
if (options.has(waitForFlag)) {
WaitForEnum value;
try {
value=waitForFlag.value(options);
}
 catch (Exception e) {
System.err.println(""String_Node_Str"" + ""String_Node_Str"");
return;
}
wait(value);
if (!wallet.isConsistent()) {
System.err.println(""String_Node_Str"");
return;
}
saveWallet(walletFile);
}
shutdown();
}","public static void main(String[] args) throws Exception {
  OptionParser parser=new OptionParser();
  parser.accepts(""String_Node_Str"");
  parser.accepts(""String_Node_Str"");
  parser.accepts(""String_Node_Str"");
  OptionSpec<String> walletFileName=parser.accepts(""String_Node_Str"").withRequiredArg().defaultsTo(""String_Node_Str"");
  seedFlag=parser.accepts(""String_Node_Str"").withRequiredArg();
  watchFlag=parser.accepts(""String_Node_Str"").withRequiredArg();
  OptionSpec<NetworkEnum> netFlag=parser.accepts(""String_Node_Str"").withOptionalArg().ofType(NetworkEnum.class).defaultsTo(NetworkEnum.PROD);
  dateFlag=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(Date.class).withValuesConvertedBy(DateConverter.datePattern(""String_Node_Str""));
  OptionSpec<WaitForEnum> waitForFlag=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(WaitForEnum.class);
  OptionSpec<ValidationMode> modeFlag=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(ValidationMode.class).defaultsTo(ValidationMode.SPV);
  OptionSpec<String> chainFlag=parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  xpubkeysFlag=parser.accepts(""String_Node_Str"").withRequiredArg();
  OptionSpec<String> outputFlag=parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  unixtimeFlag=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(Long.class);
  OptionSpec<String> conditionFlag=parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"");
  parser.accepts(""String_Node_Str"");
  parser.accepts(""String_Node_Str"");
  lookaheadSize=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(Integer.class);
  OptionSpec<String> passwordFlag=parser.accepts(""String_Node_Str"").withRequiredArg();
  OptionSpec<String> paymentRequestLocation=parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"");
  parser.accepts(""String_Node_Str"");
  parser.accepts(""String_Node_Str"");
  options=parser.parse(args);
  final String HELP_TEXT=Resources.toString(WalletTool.class.getResource(""String_Node_Str""),Charsets.UTF_8);
  if (args.length == 0 || options.has(""String_Node_Str"") || options.nonOptionArguments().size() < 1 || options.nonOptionArguments().contains(""String_Node_Str"")) {
    System.out.println(HELP_TEXT);
    return;
  }
  ActionEnum action;
  try {
    String actionStr=options.nonOptionArguments().get(0);
    actionStr=actionStr.toUpperCase().replace(""String_Node_Str"",""String_Node_Str"");
    action=ActionEnum.valueOf(actionStr);
  }
 catch (  IllegalArgumentException e) {
    System.err.println(""String_Node_Str"" + options.nonOptionArguments().get(0));
    return;
  }
  if (options.has(""String_Node_Str"")) {
    BriefLogFormatter.init();
    log.info(""String_Node_Str"");
  }
 else {
    java.util.logging.Logger logger=LogManager.getLogManager().getLogger(""String_Node_Str"");
    logger.setLevel(Level.SEVERE);
  }
switch (netFlag.value(options)) {
case PROD:
    params=MainNetParams.get();
  chainFileName=new File(""String_Node_Str"");
break;
case TEST:
params=TestNet3Params.get();
chainFileName=new File(""String_Node_Str"");
break;
case REGTEST:
params=RegTestParams.get();
chainFileName=new File(""String_Node_Str"");
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
mode=modeFlag.value(options);
if (options.has(chainFlag)) {
chainFileName=new File(chainFlag.value(options));
}
if (options.has(""String_Node_Str"")) {
condition=new Condition(conditionFlag.value(options));
}
if (options.has(passwordFlag)) {
password=passwordFlag.value(options);
}
walletFile=new File(walletFileName.value(options));
if (action == ActionEnum.CREATE) {
createWallet(options,params,walletFile);
return;
}
if (!walletFile.exists()) {
System.err.println(""String_Node_Str"" + walletFile + ""String_Node_Str""+ walletFile+ ""String_Node_Str"");
return;
}
if (action == ActionEnum.RAW_DUMP) {
FileInputStream stream=new FileInputStream(walletFile);
try {
Protos.Wallet proto=WalletProtobufSerializer.parseToProto(stream);
proto=attemptHexConversion(proto);
System.out.println(proto.toString());
return;
}
  finally {
stream.close();
}
}
InputStream walletInputStream=null;
try {
WalletProtobufSerializer loader=new WalletProtobufSerializer();
if (options.has(""String_Node_Str"")) loader.setRequireMandatoryExtensions(false);
walletInputStream=new BufferedInputStream(new FileInputStream(walletFile));
wallet=loader.readWallet(walletInputStream);
if (!wallet.getParams().equals(params)) {
System.err.println(""String_Node_Str"" + wallet.getParams().getId() + ""String_Node_Str""+ params.getId());
return;
}
}
 catch (Exception e) {
System.err.println(""String_Node_Str"" + walletFile + ""String_Node_Str""+ e.getMessage());
e.printStackTrace();
return;
}
 finally {
if (walletInputStream != null) {
walletInputStream.close();
}
}
switch (action) {
case DUMP:
dumpWallet();
break;
case ADD_KEY:
addKey();
break;
case ADD_ADDR:
addAddr();
break;
case DELETE_KEY:
deleteKey();
break;
case RESET:
reset();
break;
case SYNC:
syncChain();
break;
case SEND:
if (options.has(paymentRequestLocation) && options.has(outputFlag)) {
System.err.println(""String_Node_Str"");
return;
}
 else if (options.has(outputFlag)) {
Coin fee=Coin.ZERO;
if (options.has(""String_Node_Str"")) {
fee=parseCoin((String)options.valueOf(""String_Node_Str""));
}
String lockTime=null;
if (options.has(""String_Node_Str"")) {
lockTime=(String)options.valueOf(""String_Node_Str"");
}
boolean allowUnconfirmed=options.has(""String_Node_Str"");
send(outputFlag.values(options),fee,lockTime,allowUnconfirmed);
}
 else if (options.has(paymentRequestLocation)) {
sendPaymentRequest(paymentRequestLocation.value(options),!options.has(""String_Node_Str""));
}
 else {
System.err.println(""String_Node_Str"");
return;
}
break;
case ENCRYPT:
encrypt();
break;
case DECRYPT:
decrypt();
break;
case MARRY:
marry();
break;
case ROTATE:
rotate();
break;
}
if (!wallet.isConsistent()) {
System.err.println(""String_Node_Str"");
return;
}
saveWallet(walletFile);
if (options.has(waitForFlag)) {
WaitForEnum value;
try {
value=waitForFlag.value(options);
}
 catch (Exception e) {
System.err.println(""String_Node_Str"" + ""String_Node_Str"");
return;
}
wait(value);
if (!wallet.isConsistent()) {
System.err.println(""String_Node_Str"");
return;
}
saveWallet(walletFile);
}
shutdown();
}",0.9991723722819952
85635,"/** 
 * When downloading the block chain, the bodies will be skipped for blocks created before the given date. Any transactions relevant to the wallet will therefore not be found, but if you know your wallet has no such transactions it doesn't matter and can save a lot of bandwidth and processing time. Note that the times of blocks isn't known until their headers are available and they are requested in chunks, so some headers may be downloaded twice using this scheme, but this optimization can still be a large win for newly created wallets.
 * @param secondsSinceEpoch Time in seconds since the epoch or 0 to reset to always downloading block bodies.
 */
public void setDownloadParameters(long secondsSinceEpoch,boolean useFilteredBlocks){
  lock.lock();
  try {
    Preconditions.checkNotNull(blockChain);
    if (secondsSinceEpoch == 0) {
      fastCatchupTimeSecs=params.getGenesisBlock().getTimeSeconds();
      downloadBlockBodies=true;
    }
 else {
      fastCatchupTimeSecs=secondsSinceEpoch;
      if (fastCatchupTimeSecs > blockChain.getChainHead().getHeader().getTimeSeconds()) {
        downloadBlockBodies=false;
      }
    }
    this.useFilteredBlocks=useFilteredBlocks;
  }
  finally {
    lock.unlock();
  }
}","/** 
 * When downloading the block chain, the bodies will be skipped for blocks created before the given date. Any transactions relevant to the wallet will therefore not be found, but if you know your wallet has no such transactions it doesn't matter and can save a lot of bandwidth and processing time. Note that the times of blocks isn't known until their headers are available and they are requested in chunks, so some headers may be downloaded twice using this scheme, but this optimization can still be a large win for newly created wallets.
 * @param secondsSinceEpoch Time in seconds since the epoch or 0 to reset to always downloading block bodies.
 */
public void setDownloadParameters(long secondsSinceEpoch,boolean useFilteredBlocks){
  lock.lock();
  try {
    if (secondsSinceEpoch == 0) {
      fastCatchupTimeSecs=params.getGenesisBlock().getTimeSeconds();
      downloadBlockBodies=true;
    }
 else {
      fastCatchupTimeSecs=secondsSinceEpoch;
      if (blockChain != null && fastCatchupTimeSecs > blockChain.getChainHead().getHeader().getTimeSeconds())       downloadBlockBodies=false;
    }
    this.useFilteredBlocks=useFilteredBlocks;
  }
  finally {
    lock.unlock();
  }
}",0.9679012345679012
85636,"private Sha256Hash recursiveExtractHashes(int height,int pos,ValuesUsed used,List<Sha256Hash> matchedHashes) throws VerificationException {
  if (used.bitsUsed >= matchedChildBits.length * 8) {
    throw new VerificationException(""String_Node_Str"");
  }
  boolean parentOfMatch=checkBitLE(matchedChildBits,used.bitsUsed++);
  if (height == 0 || !parentOfMatch) {
    if (used.hashesUsed >= hashes.size()) {
      throw new VerificationException(""String_Node_Str"");
    }
    Sha256Hash hash=hashes.get(used.hashesUsed++);
    if (height == 0 && parentOfMatch)     matchedHashes.add(hash);
    return hash;
  }
 else {
    byte[] left=recursiveExtractHashes(height - 1,pos * 2,used,matchedHashes).getBytes(), right;
    if (pos * 2 + 1 < getTreeWidth(transactionCount,height - 1))     right=recursiveExtractHashes(height - 1,pos * 2 + 1,used,matchedHashes).getBytes();
 else     right=left;
    return combineLeftRight(left,right);
  }
}","private Sha256Hash recursiveExtractHashes(int height,int pos,ValuesUsed used,List<Sha256Hash> matchedHashes) throws VerificationException {
  if (used.bitsUsed >= matchedChildBits.length * 8) {
    throw new VerificationException(""String_Node_Str"");
  }
  boolean parentOfMatch=checkBitLE(matchedChildBits,used.bitsUsed++);
  if (height == 0 || !parentOfMatch) {
    if (used.hashesUsed >= hashes.size()) {
      throw new VerificationException(""String_Node_Str"");
    }
    Sha256Hash hash=hashes.get(used.hashesUsed++);
    if (height == 0 && parentOfMatch)     matchedHashes.add(hash);
    return hash;
  }
 else {
    byte[] left=recursiveExtractHashes(height - 1,pos * 2,used,matchedHashes).getBytes(), right;
    if (pos * 2 + 1 < getTreeWidth(transactionCount,height - 1)) {
      right=recursiveExtractHashes(height - 1,pos * 2 + 1,used,matchedHashes).getBytes();
      if (Arrays.equals(right,left))       throw new VerificationException(""String_Node_Str"");
    }
 else {
      right=left;
    }
    return combineLeftRight(left,right);
  }
}",0.9380976346250628
85637,"/** 
 * Extracts tx hashes that are in this merkle tree and returns the merkle root of this tree. The returned root should be checked against the merkle root contained in the block header for security.
 * @param matchedHashes A list which will contain the matched txn (will be cleared)Required to be a LinkedHashSet in order to retain order or transactions in the block
 * @return the merkle root of this merkle tree
 * @throws ProtocolException if this partial merkle tree is invalid
 */
public Sha256Hash getTxnHashAndMerkleRoot(List<Sha256Hash> matchedHashes) throws VerificationException {
  matchedHashes.clear();
  if (transactionCount == 0)   throw new VerificationException(""String_Node_Str"");
  if (transactionCount > Block.MAX_BLOCK_SIZE / 60)   throw new VerificationException(""String_Node_Str"");
  if (hashes.size() > transactionCount)   throw new VerificationException(""String_Node_Str"");
  if (matchedChildBits.length * 8 < hashes.size())   throw new VerificationException(""String_Node_Str"");
  int height=0;
  while (getTreeWidth(transactionCount,height) > 1)   height++;
  ValuesUsed used=new ValuesUsed();
  Sha256Hash merkleRoot=recursiveExtractHashes(height,0,used,matchedHashes);
  if ((used.bitsUsed + 7) / 8 != matchedChildBits.length || used.hashesUsed != hashes.size())   throw new VerificationException(""String_Node_Str"");
  return merkleRoot;
}","/** 
 * Extracts tx hashes that are in this merkle tree and returns the merkle root of this tree. The returned root should be checked against the merkle root contained in the block header for security.
 * @param matchedHashesOut A list which will contain the matched txn (will be cleared).
 * @return the merkle root of this merkle tree
 * @throws ProtocolException if this partial merkle tree is invalid
 */
public Sha256Hash getTxnHashAndMerkleRoot(List<Sha256Hash> matchedHashesOut) throws VerificationException {
  matchedHashesOut.clear();
  if (transactionCount == 0)   throw new VerificationException(""String_Node_Str"");
  if (transactionCount > Block.MAX_BLOCK_SIZE / 60)   throw new VerificationException(""String_Node_Str"");
  if (hashes.size() > transactionCount)   throw new VerificationException(""String_Node_Str"");
  if (matchedChildBits.length * 8 < hashes.size())   throw new VerificationException(""String_Node_Str"");
  int height=0;
  while (getTreeWidth(transactionCount,height) > 1)   height++;
  ValuesUsed used=new ValuesUsed();
  Sha256Hash merkleRoot=recursiveExtractHashes(height,0,used,matchedHashesOut);
  if ((used.bitsUsed + 7) / 8 != matchedChildBits.length || used.hashesUsed != hashes.size())   throw new VerificationException(""String_Node_Str"");
  return merkleRoot;
}",0.9636568002997378
85638,"/** 
 * <p>Updates the wallet by checking if this TX spends any of our outputs, and marking them as spent if so. If fromChain is true, also checks to see if any pending transaction spends outputs of this transaction and marks the spent flags appropriately.</p> <p>It can be called in two contexts. One is when we receive a transaction on the best chain but it wasn't pending, this most commonly happens when we have a set of keys but the wallet transactions were wiped and we are catching up with the block chain. It can also happen if a block includes a transaction we never saw at broadcast time. If this tx double spends, it takes precedence over our pending transactions and the pending tx goes dead.</p> <p>The other context it can be called is from   {@link Wallet#receivePending(Transaction,java.util.List)}, ie we saw a tx be broadcast or one was submitted directly that spends our own coins. If this tx double spends it does NOT take precedence because the winner will be resolved by the miners - we assume that our version will win, if we are wrong then when a block appears the tx will go dead.</p>
 * @param tx The transaction which is being updated.
 * @param fromChain If true, the tx appeared on the current best chain, if false it was pending.
 */
private void updateForSpends(Transaction tx,boolean fromChain) throws VerificationException {
  checkState(lock.isHeldByCurrentThread());
  if (fromChain)   checkState(!pending.containsKey(tx.getHash()));
  for (  TransactionInput input : tx.getInputs()) {
    TransactionInput.ConnectionResult result=input.connect(unspent,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
    if (result == TransactionInput.ConnectionResult.NO_SUCH_TX) {
      result=input.connect(spent,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
      if (result == TransactionInput.ConnectionResult.NO_SUCH_TX) {
        result=input.connect(pending,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
        if (result == TransactionInput.ConnectionResult.NO_SUCH_TX) {
          continue;
        }
      }
    }
    if (result == TransactionInput.ConnectionResult.ALREADY_SPENT) {
      if (fromChain) {
      }
 else {
        log.warn(""String_Node_Str"");
        log.warn(""String_Node_Str"",tx.getInputs().indexOf(input));
        log.warn(""String_Node_Str"",tx.getHash(),Utils.HEX.encode(tx.unsafeBitcoinSerialize()));
        Transaction other=input.getConnectedOutput().getSpentBy().getParentTransaction();
        log.warn(""String_Node_Str"",other.getHash(),Utils.HEX.encode(tx.unsafeBitcoinSerialize()));
      }
    }
 else     if (result == TransactionInput.ConnectionResult.SUCCESS) {
      Transaction connected=checkNotNull(input.getOutpoint().fromTx);
      log.info(""String_Node_Str"",input.getOutpoint());
      maybeMovePool(connected,""String_Node_Str"");
    }
  }
  if (fromChain) {
    for (    Transaction pendingTx : pending.values()) {
      for (      TransactionInput input : pendingTx.getInputs()) {
        TransactionInput.ConnectionResult result=input.connect(tx,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
        checkState(result != TransactionInput.ConnectionResult.ALREADY_SPENT);
        if (result == TransactionInput.ConnectionResult.SUCCESS) {
          log.info(""String_Node_Str"",pendingTx.getHashAsString(),pendingTx.getInputs().indexOf(input));
        }
      }
    }
  }
}","/** 
 * <p>Updates the wallet by checking if this TX spends any of our outputs, and marking them as spent if so. If fromChain is true, also checks to see if any pending transaction spends outputs of this transaction and marks the spent flags appropriately.</p> <p>It can be called in two contexts. One is when we receive a transaction on the best chain but it wasn't pending, this most commonly happens when we have a set of keys but the wallet transactions were wiped and we are catching up with the block chain. It can also happen if a block includes a transaction we never saw at broadcast time. If this tx double spends, it takes precedence over our pending transactions and the pending tx goes dead.</p> <p>The other context it can be called is from   {@link Wallet#receivePending(Transaction,java.util.List)}, ie we saw a tx be broadcast or one was submitted directly that spends our own coins. If this tx double spends it does NOT take precedence because the winner will be resolved by the miners - we assume that our version will win, if we are wrong then when a block appears the tx will go dead.</p>
 * @param tx The transaction which is being updated.
 * @param fromChain If true, the tx appeared on the current best chain, if false it was pending.
 */
private void updateForSpends(Transaction tx,boolean fromChain) throws VerificationException {
  checkState(lock.isHeldByCurrentThread());
  if (fromChain)   checkState(!pending.containsKey(tx.getHash()));
  for (  TransactionInput input : tx.getInputs()) {
    TransactionInput.ConnectionResult result=input.connect(unspent,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
    if (result == TransactionInput.ConnectionResult.NO_SUCH_TX) {
      result=input.connect(spent,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
      if (result == TransactionInput.ConnectionResult.NO_SUCH_TX) {
        result=input.connect(pending,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
        if (result == TransactionInput.ConnectionResult.NO_SUCH_TX) {
          continue;
        }
      }
    }
    if (result == TransactionInput.ConnectionResult.ALREADY_SPENT) {
      if (fromChain) {
      }
 else {
        log.warn(""String_Node_Str"");
        log.warn(""String_Node_Str"",tx.getInputs().indexOf(input));
        log.warn(""String_Node_Str"",tx.getHash(),Utils.HEX.encode(tx.unsafeBitcoinSerialize()));
        Transaction other=input.getConnectedOutput().getSpentBy().getParentTransaction();
        log.warn(""String_Node_Str"",other.getHash(),Utils.HEX.encode(tx.unsafeBitcoinSerialize()));
      }
    }
 else     if (result == TransactionInput.ConnectionResult.SUCCESS) {
      Transaction connected=checkNotNull(input.getOutpoint().fromTx);
      log.info(""String_Node_Str"",input.getOutpoint());
      maybeMovePool(connected,""String_Node_Str"");
    }
  }
  for (  Transaction pendingTx : pending.values()) {
    for (    TransactionInput input : pendingTx.getInputs()) {
      TransactionInput.ConnectionResult result=input.connect(tx,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
      if (fromChain) {
        checkState(result != TransactionInput.ConnectionResult.ALREADY_SPENT);
      }
      if (result == TransactionInput.ConnectionResult.SUCCESS) {
        log.info(""String_Node_Str"",pendingTx.getHashAsString(),pendingTx.getInputs().indexOf(input));
      }
    }
  }
  if (!fromChain) {
    maybeMovePool(tx,""String_Node_Str"");
  }
 else {
  }
}",0.9591143911439114
85639,"@Test public void replayWhilstPending() throws Exception {
  Coin value=COIN;
  Transaction tx1=createFakeTx(params,value,myAddress);
  Transaction tx2=new Transaction(params);
  tx2.addInput(tx1.getOutput(0));
  tx2.addOutput(valueOf(0,9),new ECKey());
  tx2.addOutput(CENT,wallet.getChangeAddress());
  wallet.receivePending(tx2,null);
  BlockPair bp=createFakeBlock(blockStore,tx1);
  wallet.receiveFromBlock(tx1,bp.storedBlock,AbstractBlockChain.NewBlockType.BEST_CHAIN,0);
  wallet.notifyNewBestBlock(bp.storedBlock);
  assertEquals(ZERO,wallet.getBalance());
  assertEquals(1,wallet.getPoolSize(Pool.SPENT));
  assertEquals(1,wallet.getPoolSize(Pool.PENDING));
  assertEquals(0,wallet.getPoolSize(Pool.UNSPENT));
}","@Test public void replayWhilstPending() throws Exception {
  Coin value=COIN;
  Transaction tx1=createFakeTx(params,value,myAddress);
  Transaction tx2=new Transaction(params);
  tx2.addInput(tx1.getOutput(0));
  tx2.addOutput(valueOf(0,9),someOtherAddress);
  tx2.addOutput(CENT,wallet.getChangeAddress());
  wallet.receivePending(tx2,null);
  BlockPair bp=createFakeBlock(blockStore,tx1);
  wallet.receiveFromBlock(tx1,bp.storedBlock,AbstractBlockChain.NewBlockType.BEST_CHAIN,0);
  wallet.notifyNewBestBlock(bp.storedBlock);
  assertEquals(ZERO,wallet.getBalance());
  assertEquals(1,wallet.getPoolSize(Pool.SPENT));
  assertEquals(1,wallet.getPoolSize(Pool.PENDING));
  assertEquals(0,wallet.getPoolSize(Pool.UNSPENT));
}",0.9813148788927336
85640,"private void askForPasswordAndRetry(){
  Main.OverlayUI<WalletPasswordController> pwd=Main.instance.overlayUI(""String_Node_Str"");
  final String addressStr=address.getText();
  pwd.controller.aesKeyProperty().addListener((observable,old,cur) -> {
    checkGuiThread();
    Main.OverlayUI<SendMoneyController> screen=Main.instance.overlayUI(""String_Node_Str"");
    screen.controller.aesKey=cur;
    screen.controller.address.setText(addressStr);
    screen.controller.send(null);
  }
);
}","private void askForPasswordAndRetry(){
  Main.OverlayUI<WalletPasswordController> pwd=Main.instance.overlayUI(""String_Node_Str"");
  final String addressStr=address.getText();
  final String amountStr=amountEdit.getText();
  pwd.controller.aesKeyProperty().addListener((observable,old,cur) -> {
    checkGuiThread();
    Main.OverlayUI<SendMoneyController> screen=Main.instance.overlayUI(""String_Node_Str"");
    screen.controller.aesKey=cur;
    screen.controller.address.setText(addressStr);
    screen.controller.amountEdit.setText(amountStr);
    screen.controller.send(null);
  }
);
}",0.9068901303538176
85641,"/** 
 * <p>Updates the wallet by checking if this TX spends any of our outputs, and marking them as spent if so. If fromChain is true, also checks to see if any pending transaction spends outputs of this transaction and marks the spent flags appropriately.</p> <p>It can be called in two contexts. One is when we receive a transaction on the best chain but it wasn't pending, this most commonly happens when we have a set of keys but the wallet transactions were wiped and we are catching up with the block chain. It can also happen if a block includes a transaction we never saw at broadcast time. If this tx double spends, it takes precedence over our pending transactions and the pending tx goes dead.</p> <p>The other context it can be called is from   {@link Wallet#receivePending(Transaction,java.util.List)}, ie we saw a tx be broadcast or one was submitted directly that spends our own coins. If this tx double spends it does NOT take precedence because the winner will be resolved by the miners - we assume that our version will win, if we are wrong then when a block appears the tx will go dead.</p>
 * @param tx The transaction which is being updated.
 * @param fromChain If true, the tx appeared on the current best chain, if false it was pending.
 */
private void updateForSpends(Transaction tx,boolean fromChain) throws VerificationException {
  checkState(lock.isHeldByCurrentThread());
  if (fromChain)   checkState(!pending.containsKey(tx.getHash()));
  for (  TransactionInput input : tx.getInputs()) {
    TransactionInput.ConnectionResult result=input.connect(unspent,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
    if (result == TransactionInput.ConnectionResult.NO_SUCH_TX) {
      result=input.connect(spent,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
      if (result == TransactionInput.ConnectionResult.NO_SUCH_TX) {
        result=input.connect(pending,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
        if (result == TransactionInput.ConnectionResult.NO_SUCH_TX) {
          continue;
        }
      }
    }
    if (result == TransactionInput.ConnectionResult.ALREADY_SPENT) {
      if (fromChain) {
      }
 else {
        log.warn(""String_Node_Str"");
        log.warn(""String_Node_Str"",tx.getInputs().indexOf(input));
        log.warn(""String_Node_Str"",tx.getHash(),Utils.HEX.encode(tx.unsafeBitcoinSerialize()));
        Transaction other=input.getConnectedOutput().getSpentBy().getParentTransaction();
        log.warn(""String_Node_Str"",other.getHash(),Utils.HEX.encode(tx.unsafeBitcoinSerialize()));
      }
    }
 else     if (result == TransactionInput.ConnectionResult.SUCCESS) {
      Transaction connected=checkNotNull(input.getOutpoint().fromTx);
      log.info(""String_Node_Str"",input.getOutpoint());
      maybeMovePool(connected,""String_Node_Str"");
    }
  }
  if (fromChain) {
    for (    Transaction pendingTx : pending.values()) {
      for (      TransactionInput input : pendingTx.getInputs()) {
        TransactionInput.ConnectionResult result=input.connect(tx,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
        checkState(result != TransactionInput.ConnectionResult.ALREADY_SPENT);
        if (result == TransactionInput.ConnectionResult.SUCCESS) {
          log.info(""String_Node_Str"",pendingTx.getHashAsString(),pendingTx.getInputs().indexOf(input));
        }
      }
    }
  }
}","/** 
 * <p>Updates the wallet by checking if this TX spends any of our outputs, and marking them as spent if so. If fromChain is true, also checks to see if any pending transaction spends outputs of this transaction and marks the spent flags appropriately.</p> <p>It can be called in two contexts. One is when we receive a transaction on the best chain but it wasn't pending, this most commonly happens when we have a set of keys but the wallet transactions were wiped and we are catching up with the block chain. It can also happen if a block includes a transaction we never saw at broadcast time. If this tx double spends, it takes precedence over our pending transactions and the pending tx goes dead.</p> <p>The other context it can be called is from   {@link Wallet#receivePending(Transaction,java.util.List)}, ie we saw a tx be broadcast or one was submitted directly that spends our own coins. If this tx double spends it does NOT take precedence because the winner will be resolved by the miners - we assume that our version will win, if we are wrong then when a block appears the tx will go dead.</p>
 * @param tx The transaction which is being updated.
 * @param fromChain If true, the tx appeared on the current best chain, if false it was pending.
 */
private void updateForSpends(Transaction tx,boolean fromChain) throws VerificationException {
  checkState(lock.isHeldByCurrentThread());
  if (fromChain)   checkState(!pending.containsKey(tx.getHash()));
  for (  TransactionInput input : tx.getInputs()) {
    TransactionInput.ConnectionResult result=input.connect(unspent,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
    if (result == TransactionInput.ConnectionResult.NO_SUCH_TX) {
      result=input.connect(spent,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
      if (result == TransactionInput.ConnectionResult.NO_SUCH_TX) {
        result=input.connect(pending,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
        if (result == TransactionInput.ConnectionResult.NO_SUCH_TX) {
          continue;
        }
      }
    }
    if (result == TransactionInput.ConnectionResult.ALREADY_SPENT) {
      if (fromChain) {
      }
 else {
        log.warn(""String_Node_Str"");
        log.warn(""String_Node_Str"",tx.getInputs().indexOf(input));
        log.warn(""String_Node_Str"",tx.getHash(),Utils.HEX.encode(tx.unsafeBitcoinSerialize()));
        Transaction other=input.getConnectedOutput().getSpentBy().getParentTransaction();
        log.warn(""String_Node_Str"",other.getHash(),Utils.HEX.encode(tx.unsafeBitcoinSerialize()));
      }
    }
 else     if (result == TransactionInput.ConnectionResult.SUCCESS) {
      Transaction connected=checkNotNull(input.getOutpoint().fromTx);
      log.info(""String_Node_Str"",input.getOutpoint());
      maybeMovePool(connected,""String_Node_Str"");
    }
  }
  for (  Transaction pendingTx : pending.values()) {
    for (    TransactionInput input : pendingTx.getInputs()) {
      TransactionInput.ConnectionResult result=input.connect(tx,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
      if (fromChain) {
        checkState(result != TransactionInput.ConnectionResult.ALREADY_SPENT);
      }
      if (result == TransactionInput.ConnectionResult.SUCCESS) {
        log.info(""String_Node_Str"",pendingTx.getHashAsString(),pendingTx.getInputs().indexOf(input));
      }
    }
  }
  if (!fromChain) {
    maybeMovePool(tx,""String_Node_Str"");
  }
 else {
  }
}",0.9591143911439114
85642,"@Test public void replayWhilstPending() throws Exception {
  Coin value=COIN;
  Transaction tx1=createFakeTx(params,value,myAddress);
  Transaction tx2=new Transaction(params);
  tx2.addInput(tx1.getOutput(0));
  tx2.addOutput(valueOf(0,9),new ECKey());
  tx2.addOutput(CENT,wallet.getChangeAddress());
  wallet.receivePending(tx2,null);
  BlockPair bp=createFakeBlock(blockStore,tx1);
  wallet.receiveFromBlock(tx1,bp.storedBlock,AbstractBlockChain.NewBlockType.BEST_CHAIN,0);
  wallet.notifyNewBestBlock(bp.storedBlock);
  assertEquals(ZERO,wallet.getBalance());
  assertEquals(1,wallet.getPoolSize(Pool.SPENT));
  assertEquals(1,wallet.getPoolSize(Pool.PENDING));
  assertEquals(0,wallet.getPoolSize(Pool.UNSPENT));
}","@Test public void replayWhilstPending() throws Exception {
  Coin value=COIN;
  Transaction tx1=createFakeTx(params,value,myAddress);
  Transaction tx2=new Transaction(params);
  tx2.addInput(tx1.getOutput(0));
  tx2.addOutput(valueOf(0,9),someOtherAddress);
  tx2.addOutput(CENT,wallet.getChangeAddress());
  wallet.receivePending(tx2,null);
  BlockPair bp=createFakeBlock(blockStore,tx1);
  wallet.receiveFromBlock(tx1,bp.storedBlock,AbstractBlockChain.NewBlockType.BEST_CHAIN,0);
  wallet.notifyNewBestBlock(bp.storedBlock);
  assertEquals(ZERO,wallet.getBalance());
  assertEquals(1,wallet.getPoolSize(Pool.SPENT));
  assertEquals(1,wallet.getPoolSize(Pool.PENDING));
  assertEquals(0,wallet.getPoolSize(Pool.UNSPENT));
}",0.9813148788927336
85643,"public static void main(String[] args) throws Exception {
  OptionParser parser=new OptionParser();
  parser.accepts(""String_Node_Str"");
  parser.accepts(""String_Node_Str"");
  parser.accepts(""String_Node_Str"");
  OptionSpec<String> walletFileName=parser.accepts(""String_Node_Str"").withRequiredArg().defaultsTo(""String_Node_Str"");
  seedFlag=parser.accepts(""String_Node_Str"").withRequiredArg();
  watchFlag=parser.accepts(""String_Node_Str"").withRequiredArg();
  OptionSpec<NetworkEnum> netFlag=parser.accepts(""String_Node_Str"").withOptionalArg().ofType(NetworkEnum.class).defaultsTo(NetworkEnum.MAIN);
  dateFlag=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(Date.class).withValuesConvertedBy(DateConverter.datePattern(""String_Node_Str""));
  OptionSpec<WaitForEnum> waitForFlag=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(WaitForEnum.class);
  OptionSpec<ValidationMode> modeFlag=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(ValidationMode.class).defaultsTo(ValidationMode.SPV);
  OptionSpec<String> chainFlag=parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  xpubkeysFlag=parser.accepts(""String_Node_Str"").withRequiredArg();
  OptionSpec<String> outputFlag=parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  unixtimeFlag=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(Integer.class);
  OptionSpec<String> conditionFlag=parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"");
  parser.accepts(""String_Node_Str"");
  parser.accepts(""String_Node_Str"");
  lookaheadSize=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(Integer.class);
  OptionSpec<String> passwordFlag=parser.accepts(""String_Node_Str"").withRequiredArg();
  OptionSpec<String> paymentRequestLocation=parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"");
  parser.accepts(""String_Node_Str"");
  parser.accepts(""String_Node_Str"");
  options=parser.parse(args);
  final String HELP_TEXT=Resources.toString(WalletTool.class.getResource(""String_Node_Str""),Charsets.UTF_8);
  if (args.length == 0 || options.has(""String_Node_Str"") || options.nonOptionArguments().size() < 1 || options.nonOptionArguments().contains(""String_Node_Str"")) {
    System.out.println(HELP_TEXT);
    return;
  }
  ActionEnum action;
  try {
    String actionStr=options.nonOptionArguments().get(0);
    actionStr=actionStr.toUpperCase().replace(""String_Node_Str"",""String_Node_Str"");
    action=ActionEnum.valueOf(actionStr);
  }
 catch (  IllegalArgumentException e) {
    System.err.println(""String_Node_Str"" + options.nonOptionArguments().get(0));
    return;
  }
  if (options.has(""String_Node_Str"")) {
    BriefLogFormatter.init();
    log.info(""String_Node_Str"");
  }
 else {
    java.util.logging.Logger logger=LogManager.getLogManager().getLogger(""String_Node_Str"");
    logger.setLevel(Level.SEVERE);
  }
switch (netFlag.value(options)) {
case MAIN:
case PROD:
    params=MainNetParams.get();
  chainFileName=new File(""String_Node_Str"");
break;
case TEST:
params=TestNet3Params.get();
chainFileName=new File(""String_Node_Str"");
break;
case REGTEST:
params=RegTestParams.get();
chainFileName=new File(""String_Node_Str"");
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
mode=modeFlag.value(options);
if (options.has(chainFlag)) {
chainFileName=new File(chainFlag.value(options));
}
if (options.has(""String_Node_Str"")) {
condition=new Condition(conditionFlag.value(options));
}
if (options.has(passwordFlag)) {
password=passwordFlag.value(options);
}
walletFile=new File(walletFileName.value(options));
if (action == ActionEnum.CREATE) {
createWallet(options,params,walletFile);
return;
}
if (!walletFile.exists()) {
System.err.println(""String_Node_Str"" + walletFile + ""String_Node_Str""+ walletFile+ ""String_Node_Str"");
return;
}
if (action == ActionEnum.RAW_DUMP) {
FileInputStream stream=new FileInputStream(walletFile);
try {
Protos.Wallet proto=WalletProtobufSerializer.parseToProto(stream);
proto=attemptHexConversion(proto);
System.out.println(proto.toString());
return;
}
  finally {
stream.close();
}
}
InputStream walletInputStream=null;
try {
WalletProtobufSerializer loader=new WalletProtobufSerializer();
if (options.has(""String_Node_Str"")) loader.setRequireMandatoryExtensions(false);
walletInputStream=new BufferedInputStream(new FileInputStream(walletFile));
wallet=loader.readWallet(walletInputStream);
if (!wallet.getParams().equals(params)) {
System.err.println(""String_Node_Str"" + wallet.getParams().getId() + ""String_Node_Str""+ params.getId());
return;
}
}
 catch (Exception e) {
System.err.println(""String_Node_Str"" + walletFile + ""String_Node_Str""+ e.getMessage());
e.printStackTrace();
return;
}
 finally {
if (walletInputStream != null) {
walletInputStream.close();
}
}
switch (action) {
case DUMP:
dumpWallet();
break;
case ADD_KEY:
addKey();
break;
case ADD_ADDR:
addAddr();
break;
case DELETE_KEY:
deleteKey();
break;
case RESET:
reset();
break;
case SYNC:
syncChain();
break;
case SEND:
if (options.has(paymentRequestLocation) && options.has(outputFlag)) {
System.err.println(""String_Node_Str"");
return;
}
 else if (options.has(outputFlag)) {
Coin fee=Coin.ZERO;
if (options.has(""String_Node_Str"")) {
fee=parseCoin((String)options.valueOf(""String_Node_Str""));
}
String lockTime=null;
if (options.has(""String_Node_Str"")) {
lockTime=(String)options.valueOf(""String_Node_Str"");
}
boolean allowUnconfirmed=options.has(""String_Node_Str"");
send(outputFlag.values(options),fee,lockTime,allowUnconfirmed);
}
 else if (options.has(paymentRequestLocation)) {
sendPaymentRequest(paymentRequestLocation.value(options),!options.has(""String_Node_Str""));
}
 else {
System.err.println(""String_Node_Str"");
return;
}
break;
case ENCRYPT:
encrypt();
break;
case DECRYPT:
decrypt();
break;
case MARRY:
marry();
break;
case ROTATE:
rotate();
break;
}
if (!wallet.isConsistent()) {
System.err.println(""String_Node_Str"");
return;
}
saveWallet(walletFile);
if (options.has(waitForFlag)) {
WaitForEnum value;
try {
value=waitForFlag.value(options);
}
 catch (Exception e) {
System.err.println(""String_Node_Str"" + ""String_Node_Str"");
return;
}
wait(value);
if (!wallet.isConsistent()) {
System.err.println(""String_Node_Str"");
return;
}
saveWallet(walletFile);
}
shutdown();
}","public static void main(String[] args) throws Exception {
  OptionParser parser=new OptionParser();
  parser.accepts(""String_Node_Str"");
  parser.accepts(""String_Node_Str"");
  parser.accepts(""String_Node_Str"");
  OptionSpec<String> walletFileName=parser.accepts(""String_Node_Str"").withRequiredArg().defaultsTo(""String_Node_Str"");
  seedFlag=parser.accepts(""String_Node_Str"").withRequiredArg();
  watchFlag=parser.accepts(""String_Node_Str"").withRequiredArg();
  OptionSpec<NetworkEnum> netFlag=parser.accepts(""String_Node_Str"").withOptionalArg().ofType(NetworkEnum.class).defaultsTo(NetworkEnum.MAIN);
  dateFlag=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(Date.class).withValuesConvertedBy(DateConverter.datePattern(""String_Node_Str""));
  OptionSpec<WaitForEnum> waitForFlag=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(WaitForEnum.class);
  OptionSpec<ValidationMode> modeFlag=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(ValidationMode.class).defaultsTo(ValidationMode.SPV);
  OptionSpec<String> chainFlag=parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  xpubkeysFlag=parser.accepts(""String_Node_Str"").withRequiredArg();
  OptionSpec<String> outputFlag=parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  unixtimeFlag=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(Long.class);
  OptionSpec<String> conditionFlag=parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"");
  parser.accepts(""String_Node_Str"");
  parser.accepts(""String_Node_Str"");
  lookaheadSize=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(Integer.class);
  OptionSpec<String> passwordFlag=parser.accepts(""String_Node_Str"").withRequiredArg();
  OptionSpec<String> paymentRequestLocation=parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"");
  parser.accepts(""String_Node_Str"");
  parser.accepts(""String_Node_Str"");
  options=parser.parse(args);
  final String HELP_TEXT=Resources.toString(WalletTool.class.getResource(""String_Node_Str""),Charsets.UTF_8);
  if (args.length == 0 || options.has(""String_Node_Str"") || options.nonOptionArguments().size() < 1 || options.nonOptionArguments().contains(""String_Node_Str"")) {
    System.out.println(HELP_TEXT);
    return;
  }
  ActionEnum action;
  try {
    String actionStr=options.nonOptionArguments().get(0);
    actionStr=actionStr.toUpperCase().replace(""String_Node_Str"",""String_Node_Str"");
    action=ActionEnum.valueOf(actionStr);
  }
 catch (  IllegalArgumentException e) {
    System.err.println(""String_Node_Str"" + options.nonOptionArguments().get(0));
    return;
  }
  if (options.has(""String_Node_Str"")) {
    BriefLogFormatter.init();
    log.info(""String_Node_Str"");
  }
 else {
    java.util.logging.Logger logger=LogManager.getLogManager().getLogger(""String_Node_Str"");
    logger.setLevel(Level.SEVERE);
  }
switch (netFlag.value(options)) {
case MAIN:
case PROD:
    params=MainNetParams.get();
  chainFileName=new File(""String_Node_Str"");
break;
case TEST:
params=TestNet3Params.get();
chainFileName=new File(""String_Node_Str"");
break;
case REGTEST:
params=RegTestParams.get();
chainFileName=new File(""String_Node_Str"");
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
mode=modeFlag.value(options);
if (options.has(chainFlag)) {
chainFileName=new File(chainFlag.value(options));
}
if (options.has(""String_Node_Str"")) {
condition=new Condition(conditionFlag.value(options));
}
if (options.has(passwordFlag)) {
password=passwordFlag.value(options);
}
walletFile=new File(walletFileName.value(options));
if (action == ActionEnum.CREATE) {
createWallet(options,params,walletFile);
return;
}
if (!walletFile.exists()) {
System.err.println(""String_Node_Str"" + walletFile + ""String_Node_Str""+ walletFile+ ""String_Node_Str"");
return;
}
if (action == ActionEnum.RAW_DUMP) {
FileInputStream stream=new FileInputStream(walletFile);
try {
Protos.Wallet proto=WalletProtobufSerializer.parseToProto(stream);
proto=attemptHexConversion(proto);
System.out.println(proto.toString());
return;
}
  finally {
stream.close();
}
}
InputStream walletInputStream=null;
try {
WalletProtobufSerializer loader=new WalletProtobufSerializer();
if (options.has(""String_Node_Str"")) loader.setRequireMandatoryExtensions(false);
walletInputStream=new BufferedInputStream(new FileInputStream(walletFile));
wallet=loader.readWallet(walletInputStream);
if (!wallet.getParams().equals(params)) {
System.err.println(""String_Node_Str"" + wallet.getParams().getId() + ""String_Node_Str""+ params.getId());
return;
}
}
 catch (Exception e) {
System.err.println(""String_Node_Str"" + walletFile + ""String_Node_Str""+ e.getMessage());
e.printStackTrace();
return;
}
 finally {
if (walletInputStream != null) {
walletInputStream.close();
}
}
switch (action) {
case DUMP:
dumpWallet();
break;
case ADD_KEY:
addKey();
break;
case ADD_ADDR:
addAddr();
break;
case DELETE_KEY:
deleteKey();
break;
case RESET:
reset();
break;
case SYNC:
syncChain();
break;
case SEND:
if (options.has(paymentRequestLocation) && options.has(outputFlag)) {
System.err.println(""String_Node_Str"");
return;
}
 else if (options.has(outputFlag)) {
Coin fee=Coin.ZERO;
if (options.has(""String_Node_Str"")) {
fee=parseCoin((String)options.valueOf(""String_Node_Str""));
}
String lockTime=null;
if (options.has(""String_Node_Str"")) {
lockTime=(String)options.valueOf(""String_Node_Str"");
}
boolean allowUnconfirmed=options.has(""String_Node_Str"");
send(outputFlag.values(options),fee,lockTime,allowUnconfirmed);
}
 else if (options.has(paymentRequestLocation)) {
sendPaymentRequest(paymentRequestLocation.value(options),!options.has(""String_Node_Str""));
}
 else {
System.err.println(""String_Node_Str"");
return;
}
break;
case ENCRYPT:
encrypt();
break;
case DECRYPT:
decrypt();
break;
case MARRY:
marry();
break;
case ROTATE:
rotate();
break;
}
if (!wallet.isConsistent()) {
System.err.println(""String_Node_Str"");
return;
}
saveWallet(walletFile);
if (options.has(waitForFlag)) {
WaitForEnum value;
try {
value=waitForFlag.value(options);
}
 catch (Exception e) {
System.err.println(""String_Node_Str"" + ""String_Node_Str"");
return;
}
wait(value);
if (!wallet.isConsistent()) {
System.err.println(""String_Node_Str"");
return;
}
saveWallet(walletFile);
}
shutdown();
}",0.999173739953429
85644,"public static void main(String[] args) throws Exception {
  BriefLogFormatter.init();
  System.out.println(""String_Node_Str"");
  boolean runExpensiveTests=args.length > 1 && Integer.parseInt(args[1]) == 1;
  params=RegTestParams.get();
  File blockFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  blockFile.deleteOnExit();
  FullBlockTestGenerator generator=new FullBlockTestGenerator(params);
  final RuleList blockList=generator.getBlocksToTest(true,runExpensiveTests,blockFile);
  final Map<Sha256Hash,Block> preloadedBlocks=new HashMap<Sha256Hash,Block>();
  final Iterator<Block> blocks=new BlockFileLoader(params,Arrays.asList(blockFile));
  try {
    store=new H2FullPrunedBlockStore(params,args.length > 0 ? args[0] : ""String_Node_Str"",blockList.maximumReorgBlockCount);
    ((H2FullPrunedBlockStore)store).resetStore();
    chain=new FullPrunedBlockChain(params,store);
  }
 catch (  BlockStoreException e) {
    e.printStackTrace();
    System.exit(1);
  }
  VersionMessage ver=new VersionMessage(params,42);
  ver.appendToSubVer(""String_Node_Str"",""String_Node_Str"",null);
  ver.localServices=VersionMessage.NODE_NETWORK;
  final Peer bitcoind=new Peer(params,ver,new BlockChain(params,new MemoryBlockStore(params)),new PeerAddress(InetAddress.getLocalHost()));
  Preconditions.checkState(bitcoind.getVersionMessage().hasBlockChain());
  final BlockWrapper currentBlock=new BlockWrapper();
  final Set<Sha256Hash> blocksRequested=Collections.synchronizedSet(new HashSet<Sha256Hash>());
  final Set<Sha256Hash> blocksPendingSend=Collections.synchronizedSet(new HashSet<Sha256Hash>());
  final AtomicInteger unexpectedInvs=new AtomicInteger(0);
  final SettableFuture<Void> connectedFuture=SettableFuture.create();
  bitcoind.addEventListener(new AbstractPeerEventListener(){
    @Override public void onPeerConnected(    Peer peer,    int peerCount){
      if (!peer.getPeerVersionMessage().subVer.contains(""String_Node_Str"")) {
        System.out.println();
        System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
        System.out.println();
        System.out.println(""String_Node_Str"");
        Uninterruptibles.sleepUninterruptibly(30,TimeUnit.SECONDS);
      }
      log.info(""String_Node_Str"");
      bitcoind.setDownloadParameters(0,false);
      bitcoind.startBlockChainDownload();
      connectedFuture.set(null);
    }
    @Override public void onPeerDisconnected(    Peer peer,    int peerCount){
      log.error(""String_Node_Str"");
      System.exit(1);
    }
    @Override public Message onPreMessageReceived(    Peer peer,    Message m){
      if (m instanceof HeadersMessage) {
        if (!((HeadersMessage)m).getBlockHeaders().isEmpty()) {
          Block b=Iterables.getLast(((HeadersMessage)m).getBlockHeaders());
          log.info(""String_Node_Str"" + b.getHashAsString());
          bitcoindChainHead=b.getHash();
        }
 else         log.info(""String_Node_Str"");
        return null;
      }
 else       if (m instanceof Block) {
        log.error(""String_Node_Str"");
        System.exit(1);
      }
 else       if (m instanceof GetDataMessage) {
        for (        InventoryItem item : ((GetDataMessage)m).items)         if (item.type == InventoryItem.Type.Block) {
          log.info(""String_Node_Str"" + item.hash);
          if (currentBlock.block.getHash().equals(item.hash))           bitcoind.sendMessage(currentBlock.block);
 else {
            Block nextBlock=preloadedBlocks.get(item.hash);
            if (nextBlock != null)             bitcoind.sendMessage(nextBlock);
 else {
              blocksPendingSend.add(item.hash);
              log.info(""String_Node_Str"");
            }
          }
          blocksRequested.add(item.hash);
        }
        return null;
      }
 else       if (m instanceof GetHeadersMessage) {
        try {
          if (currentBlock.block == null) {
            log.info(""String_Node_Str"");
            return null;
          }
          LinkedList<Block> headers=new LinkedList<Block>();
          Block it=blockList.hashHeaderMap.get(currentBlock.block.getHash());
          while (it != null) {
            headers.addFirst(it);
            it=blockList.hashHeaderMap.get(it.getPrevBlockHash());
          }
          LinkedList<Block> sendHeaders=new LinkedList<Block>();
          boolean found=false;
          for (          Sha256Hash hash : ((GetHeadersMessage)m).getLocator()) {
            for (            Block b : headers) {
              if (found) {
                sendHeaders.addLast(b);
                log.info(""String_Node_Str"" + b.getPrevBlockHash() + ""String_Node_Str""+ b.getHash());
                if (b.getHash().equals(((GetHeadersMessage)m).getStopHash()))                 break;
              }
 else               if (b.getHash().equals(hash)) {
                log.info(""String_Node_Str"" + b.getHashAsString());
                found=true;
              }
            }
            if (found)             break;
          }
          if (!found)           sendHeaders=headers;
          bitcoind.sendMessage(new HeadersMessage(params,sendHeaders));
          InventoryMessage i=new InventoryMessage(params);
          for (          Block b : sendHeaders)           i.addBlock(b);
          bitcoind.sendMessage(i);
        }
 catch (        Exception e) {
          throw new RuntimeException(e);
        }
        return null;
      }
 else       if (m instanceof InventoryMessage) {
        if (mostRecentInv != null) {
          log.error(""String_Node_Str"");
          unexpectedInvs.incrementAndGet();
        }
        mostRecentInv=(InventoryMessage)m;
      }
      return m;
    }
  }
,Threading.SAME_THREAD);
  bitcoindChainHead=params.getGenesisBlock().getHash();
  new NioClient(new InetSocketAddress(InetAddress.getLoopbackAddress(),args.length > 2 ? Integer.parseInt(args[2]) : params.getPort()),bitcoind,1000);
  connectedFuture.get();
  ArrayList<Sha256Hash> locator=new ArrayList<Sha256Hash>(1);
  locator.add(params.getGenesisBlock().getHash());
  Sha256Hash hashTo=new Sha256Hash(""String_Node_Str"");
  int rulesSinceFirstFail=0;
  for (  Rule rule : blockList.list) {
    if (rule instanceof FullBlockTestGenerator.BlockAndValidity) {
      FullBlockTestGenerator.BlockAndValidity block=(FullBlockTestGenerator.BlockAndValidity)rule;
      boolean threw=false;
      Block nextBlock=preloadedBlocks.get(((FullBlockTestGenerator.BlockAndValidity)rule).blockHash);
      for (int i=0; i < 1 || nextBlock == null || !nextBlock.getHash().equals(block.blockHash); i++) {
        try {
          Block b=blocks.next();
          Block oldBlockWithSameHash=preloadedBlocks.put(b.getHash(),b);
          if (oldBlockWithSameHash != null && oldBlockWithSameHash.getTransactions().size() != b.getTransactions().size())           blocksRequested.remove(b.getHash());
          nextBlock=preloadedBlocks.get(block.blockHash);
        }
 catch (        NoSuchElementException e) {
          if (nextBlock == null || !nextBlock.getHash().equals(block.blockHash))           throw e;
        }
      }
      currentBlock.block=nextBlock;
      log.info(""String_Node_Str"",block.ruleName,currentBlock.block.getHash());
      try {
        if (chain.add(nextBlock) != block.connects) {
          log.error(""String_Node_Str"" + block.ruleName + ""String_Node_Str"");
          rulesSinceFirstFail++;
        }
      }
 catch (      VerificationException e) {
        threw=true;
        if (!block.throwsException) {
          log.error(""String_Node_Str"" + block.ruleName + ""String_Node_Str"");
          e.printStackTrace();
          rulesSinceFirstFail++;
        }
 else         if (block.connects) {
          log.error(""String_Node_Str"" + block.ruleName + ""String_Node_Str"");
          e.printStackTrace();
          rulesSinceFirstFail++;
        }
      }
      if (!threw && block.throwsException) {
        log.error(""String_Node_Str"" + block.ruleName + ""String_Node_Str"");
        rulesSinceFirstFail++;
      }
 else       if (!chain.getChainHead().getHeader().getHash().equals(block.hashChainTipAfterBlock)) {
        log.error(""String_Node_Str"" + block.ruleName + ""String_Node_Str"");
        rulesSinceFirstFail++;
      }
 else       if (chain.getChainHead().getHeight() != block.heightAfterBlock) {
        log.error(""String_Node_Str"" + block.ruleName);
        rulesSinceFirstFail++;
      }
      boolean shouldntRequest=blocksRequested.contains(nextBlock.getHash());
      if (shouldntRequest)       blocksRequested.remove(nextBlock.getHash());
      InventoryMessage message=new InventoryMessage(params);
      message.addBlock(nextBlock);
      bitcoind.sendMessage(message);
      log.info(""String_Node_Str"" + nextBlock.getHashAsString());
      if (blocksPendingSend.contains(nextBlock.getHash())) {
        bitcoind.sendMessage(nextBlock);
        log.info(""String_Node_Str"" + nextBlock.getHashAsString());
      }
      for (int i=0; !shouldntRequest && !blocksRequested.contains(nextBlock.getHash()); i++) {
        int SLEEP_TIME=1;
        if (i % 1000 / SLEEP_TIME == 1000 / SLEEP_TIME - 1)         log.error(""String_Node_Str"" + block.ruleName + ""String_Node_Str""+ nextBlock.getHash());
        Thread.sleep(SLEEP_TIME);
        if (i > 60000 / SLEEP_TIME) {
          log.error(""String_Node_Str"" + block.ruleName);
          System.exit(1);
        }
      }
      if (shouldntRequest) {
        Thread.sleep(100);
        if (blocksRequested.contains(nextBlock.getHash())) {
          log.error(""String_Node_Str"" + block.ruleName + ""String_Node_Str""+ nextBlock.getHash());
          rulesSinceFirstFail++;
        }
      }
      if (block.throwsException)       blocksRequested.remove(nextBlock.getHash());
      locator.clear();
      locator.add(bitcoindChainHead);
      bitcoind.sendMessage(new GetHeadersMessage(params,locator,hashTo));
      bitcoind.ping().get();
      if (!chain.getChainHead().getHeader().getHash().equals(bitcoindChainHead)) {
        rulesSinceFirstFail++;
        log.error(""String_Node_Str"" + block.ruleName + ""String_Node_Str"");
      }
      if (block.sendOnce)       preloadedBlocks.remove(nextBlock.getHash());
      log.info(""String_Node_Str"" + block.ruleName + ""String_Node_Str"");
    }
 else     if (rule instanceof MemoryPoolState) {
      MemoryPoolMessage message=new MemoryPoolMessage();
      bitcoind.sendMessage(message);
      bitcoind.ping().get();
      if (mostRecentInv == null && !((MemoryPoolState)rule).mempool.isEmpty()) {
        log.error(""String_Node_Str"" + rule.ruleName);
        rulesSinceFirstFail++;
      }
 else       if (mostRecentInv != null && ((MemoryPoolState)rule).mempool.isEmpty()) {
        log.error(""String_Node_Str"" + rule.ruleName);
        rulesSinceFirstFail++;
      }
 else       if (mostRecentInv != null) {
        Set<InventoryItem> originalRuleSet=new HashSet<InventoryItem>(((MemoryPoolState)rule).mempool);
        boolean matches=mostRecentInv.items.size() == ((MemoryPoolState)rule).mempool.size();
        for (        InventoryItem item : mostRecentInv.items)         if (!((MemoryPoolState)rule).mempool.remove(item))         matches=false;
        if (matches)         continue;
        log.error(""String_Node_Str"" + rule.ruleName);
        log.info(""String_Node_Str"");
        for (        InventoryItem item : mostRecentInv.items)         log.info(""String_Node_Str"" + item.hash);
        log.info(""String_Node_Str"");
        for (        InventoryItem item : originalRuleSet)         log.info(""String_Node_Str"" + item.hash);
        rulesSinceFirstFail++;
      }
      mostRecentInv=null;
    }
 else {
      throw new RuntimeException(""String_Node_Str"");
    }
    if (rulesSinceFirstFail > 0)     rulesSinceFirstFail++;
    if (rulesSinceFirstFail > 6)     System.exit(1);
  }
  if (unexpectedInvs.get() > 0)   log.error(""String_Node_Str"" + unexpectedInvs.get() + ""String_Node_Str"");
  log.info(""String_Node_Str"");
  System.exit(rulesSinceFirstFail > 0 || unexpectedInvs.get() > 0 ? 1 : 0);
}","public static void main(String[] args) throws Exception {
  BriefLogFormatter.init();
  System.out.println(""String_Node_Str"");
  boolean runExpensiveTests=args.length > 1 && Integer.parseInt(args[1]) == 1;
  params=RegTestParams.get();
  File blockFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  blockFile.deleteOnExit();
  FullBlockTestGenerator generator=new FullBlockTestGenerator(params);
  final RuleList blockList=generator.getBlocksToTest(true,runExpensiveTests,blockFile);
  final Map<Sha256Hash,Block> preloadedBlocks=new HashMap<Sha256Hash,Block>();
  final Iterator<Block> blocks=new BlockFileLoader(params,Arrays.asList(blockFile));
  try {
    store=new H2FullPrunedBlockStore(params,args.length > 0 ? args[0] : ""String_Node_Str"",blockList.maximumReorgBlockCount);
    ((H2FullPrunedBlockStore)store).resetStore();
    chain=new FullPrunedBlockChain(params,store);
  }
 catch (  BlockStoreException e) {
    e.printStackTrace();
    System.exit(1);
  }
  VersionMessage ver=new VersionMessage(params,42);
  ver.appendToSubVer(""String_Node_Str"",""String_Node_Str"",null);
  ver.localServices=VersionMessage.NODE_NETWORK;
  final Peer bitcoind=new Peer(params,ver,new BlockChain(params,new MemoryBlockStore(params)),new PeerAddress(InetAddress.getLocalHost()));
  Preconditions.checkState(bitcoind.getVersionMessage().hasBlockChain());
  final BlockWrapper currentBlock=new BlockWrapper();
  final Set<Sha256Hash> blocksRequested=Collections.synchronizedSet(new HashSet<Sha256Hash>());
  final Set<Sha256Hash> blocksPendingSend=Collections.synchronizedSet(new HashSet<Sha256Hash>());
  final AtomicInteger unexpectedInvs=new AtomicInteger(0);
  final SettableFuture<Void> connectedFuture=SettableFuture.create();
  bitcoind.addEventListener(new AbstractPeerEventListener(){
    @Override public void onPeerConnected(    Peer peer,    int peerCount){
      if (!peer.getPeerVersionMessage().subVer.contains(""String_Node_Str"")) {
        System.out.println();
        System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
        System.out.println();
        System.out.println(""String_Node_Str"");
        Uninterruptibles.sleepUninterruptibly(30,TimeUnit.SECONDS);
      }
      log.info(""String_Node_Str"");
      bitcoind.setDownloadParameters(0,false);
      bitcoind.startBlockChainDownload();
      connectedFuture.set(null);
    }
    @Override public void onPeerDisconnected(    Peer peer,    int peerCount){
      log.error(""String_Node_Str"");
      System.exit(1);
    }
    @Override public Message onPreMessageReceived(    Peer peer,    Message m){
      if (m instanceof HeadersMessage) {
        if (!((HeadersMessage)m).getBlockHeaders().isEmpty()) {
          Block b=Iterables.getLast(((HeadersMessage)m).getBlockHeaders());
          log.info(""String_Node_Str"" + b.getHashAsString());
          bitcoindChainHead=b.getHash();
        }
 else         log.info(""String_Node_Str"");
        return null;
      }
 else       if (m instanceof Block) {
        log.error(""String_Node_Str"");
        System.exit(1);
      }
 else       if (m instanceof GetDataMessage) {
        for (        InventoryItem item : ((GetDataMessage)m).items)         if (item.type == InventoryItem.Type.Block) {
          log.info(""String_Node_Str"" + item.hash);
          if (currentBlock.block.getHash().equals(item.hash))           bitcoind.sendMessage(currentBlock.block);
 else {
            Block nextBlock=preloadedBlocks.get(item.hash);
            if (nextBlock != null)             bitcoind.sendMessage(nextBlock);
 else {
              blocksPendingSend.add(item.hash);
              log.info(""String_Node_Str"");
            }
          }
          blocksRequested.add(item.hash);
        }
        return null;
      }
 else       if (m instanceof GetHeadersMessage) {
        try {
          if (currentBlock.block == null) {
            log.info(""String_Node_Str"");
            return null;
          }
          LinkedList<Block> headers=new LinkedList<Block>();
          Block it=blockList.hashHeaderMap.get(currentBlock.block.getHash());
          while (it != null) {
            headers.addFirst(it);
            it=blockList.hashHeaderMap.get(it.getPrevBlockHash());
          }
          LinkedList<Block> sendHeaders=new LinkedList<Block>();
          boolean found=false;
          for (          Sha256Hash hash : ((GetHeadersMessage)m).getLocator()) {
            for (            Block b : headers) {
              if (found) {
                sendHeaders.addLast(b);
                log.info(""String_Node_Str"" + b.getPrevBlockHash() + ""String_Node_Str""+ b.getHash());
                if (b.getHash().equals(((GetHeadersMessage)m).getStopHash()))                 break;
              }
 else               if (b.getHash().equals(hash)) {
                log.info(""String_Node_Str"" + b.getHashAsString());
                found=true;
              }
            }
            if (found)             break;
          }
          if (!found)           sendHeaders=headers;
          bitcoind.sendMessage(new HeadersMessage(params,sendHeaders));
          InventoryMessage i=new InventoryMessage(params);
          for (          Block b : sendHeaders)           i.addBlock(b);
          bitcoind.sendMessage(i);
        }
 catch (        Exception e) {
          throw new RuntimeException(e);
        }
        return null;
      }
 else       if (m instanceof InventoryMessage) {
        if (mostRecentInv != null) {
          log.error(""String_Node_Str"");
          unexpectedInvs.incrementAndGet();
        }
        mostRecentInv=(InventoryMessage)m;
      }
      return m;
    }
  }
,Threading.SAME_THREAD);
  bitcoindChainHead=params.getGenesisBlock().getHash();
  new NioClient(new InetSocketAddress(InetAddress.getLocalHost(),args.length > 2 ? Integer.parseInt(args[2]) : params.getPort()),bitcoind,1000);
  connectedFuture.get();
  ArrayList<Sha256Hash> locator=new ArrayList<Sha256Hash>(1);
  locator.add(params.getGenesisBlock().getHash());
  Sha256Hash hashTo=new Sha256Hash(""String_Node_Str"");
  int rulesSinceFirstFail=0;
  for (  Rule rule : blockList.list) {
    if (rule instanceof FullBlockTestGenerator.BlockAndValidity) {
      FullBlockTestGenerator.BlockAndValidity block=(FullBlockTestGenerator.BlockAndValidity)rule;
      boolean threw=false;
      Block nextBlock=preloadedBlocks.get(((FullBlockTestGenerator.BlockAndValidity)rule).blockHash);
      for (int i=0; i < 1 || nextBlock == null || !nextBlock.getHash().equals(block.blockHash); i++) {
        try {
          Block b=blocks.next();
          Block oldBlockWithSameHash=preloadedBlocks.put(b.getHash(),b);
          if (oldBlockWithSameHash != null && oldBlockWithSameHash.getTransactions().size() != b.getTransactions().size())           blocksRequested.remove(b.getHash());
          nextBlock=preloadedBlocks.get(block.blockHash);
        }
 catch (        NoSuchElementException e) {
          if (nextBlock == null || !nextBlock.getHash().equals(block.blockHash))           throw e;
        }
      }
      currentBlock.block=nextBlock;
      log.info(""String_Node_Str"",block.ruleName,currentBlock.block.getHash());
      try {
        if (chain.add(nextBlock) != block.connects) {
          log.error(""String_Node_Str"" + block.ruleName + ""String_Node_Str"");
          rulesSinceFirstFail++;
        }
      }
 catch (      VerificationException e) {
        threw=true;
        if (!block.throwsException) {
          log.error(""String_Node_Str"" + block.ruleName + ""String_Node_Str"");
          e.printStackTrace();
          rulesSinceFirstFail++;
        }
 else         if (block.connects) {
          log.error(""String_Node_Str"" + block.ruleName + ""String_Node_Str"");
          e.printStackTrace();
          rulesSinceFirstFail++;
        }
      }
      if (!threw && block.throwsException) {
        log.error(""String_Node_Str"" + block.ruleName + ""String_Node_Str"");
        rulesSinceFirstFail++;
      }
 else       if (!chain.getChainHead().getHeader().getHash().equals(block.hashChainTipAfterBlock)) {
        log.error(""String_Node_Str"" + block.ruleName + ""String_Node_Str"");
        rulesSinceFirstFail++;
      }
 else       if (chain.getChainHead().getHeight() != block.heightAfterBlock) {
        log.error(""String_Node_Str"" + block.ruleName);
        rulesSinceFirstFail++;
      }
      boolean shouldntRequest=blocksRequested.contains(nextBlock.getHash());
      if (shouldntRequest)       blocksRequested.remove(nextBlock.getHash());
      InventoryMessage message=new InventoryMessage(params);
      message.addBlock(nextBlock);
      bitcoind.sendMessage(message);
      log.info(""String_Node_Str"" + nextBlock.getHashAsString());
      if (blocksPendingSend.contains(nextBlock.getHash())) {
        bitcoind.sendMessage(nextBlock);
        log.info(""String_Node_Str"" + nextBlock.getHashAsString());
      }
      for (int i=0; !shouldntRequest && !blocksRequested.contains(nextBlock.getHash()); i++) {
        int SLEEP_TIME=1;
        if (i % 1000 / SLEEP_TIME == 1000 / SLEEP_TIME - 1)         log.error(""String_Node_Str"" + block.ruleName + ""String_Node_Str""+ nextBlock.getHash());
        Thread.sleep(SLEEP_TIME);
        if (i > 60000 / SLEEP_TIME) {
          log.error(""String_Node_Str"" + block.ruleName);
          System.exit(1);
        }
      }
      if (shouldntRequest) {
        Thread.sleep(100);
        if (blocksRequested.contains(nextBlock.getHash())) {
          log.error(""String_Node_Str"" + block.ruleName + ""String_Node_Str""+ nextBlock.getHash());
          rulesSinceFirstFail++;
        }
      }
      if (block.throwsException)       blocksRequested.remove(nextBlock.getHash());
      locator.clear();
      locator.add(bitcoindChainHead);
      bitcoind.sendMessage(new GetHeadersMessage(params,locator,hashTo));
      bitcoind.ping().get();
      if (!chain.getChainHead().getHeader().getHash().equals(bitcoindChainHead)) {
        rulesSinceFirstFail++;
        log.error(""String_Node_Str"" + block.ruleName + ""String_Node_Str"");
      }
      if (block.sendOnce)       preloadedBlocks.remove(nextBlock.getHash());
      log.info(""String_Node_Str"" + block.ruleName + ""String_Node_Str"");
    }
 else     if (rule instanceof MemoryPoolState) {
      MemoryPoolMessage message=new MemoryPoolMessage();
      bitcoind.sendMessage(message);
      bitcoind.ping().get();
      if (mostRecentInv == null && !((MemoryPoolState)rule).mempool.isEmpty()) {
        log.error(""String_Node_Str"" + rule.ruleName);
        rulesSinceFirstFail++;
      }
 else       if (mostRecentInv != null && ((MemoryPoolState)rule).mempool.isEmpty()) {
        log.error(""String_Node_Str"" + rule.ruleName);
        rulesSinceFirstFail++;
      }
 else       if (mostRecentInv != null) {
        Set<InventoryItem> originalRuleSet=new HashSet<InventoryItem>(((MemoryPoolState)rule).mempool);
        boolean matches=mostRecentInv.items.size() == ((MemoryPoolState)rule).mempool.size();
        for (        InventoryItem item : mostRecentInv.items)         if (!((MemoryPoolState)rule).mempool.remove(item))         matches=false;
        if (matches)         continue;
        log.error(""String_Node_Str"" + rule.ruleName);
        log.info(""String_Node_Str"");
        for (        InventoryItem item : mostRecentInv.items)         log.info(""String_Node_Str"" + item.hash);
        log.info(""String_Node_Str"");
        for (        InventoryItem item : originalRuleSet)         log.info(""String_Node_Str"" + item.hash);
        rulesSinceFirstFail++;
      }
      mostRecentInv=null;
    }
 else {
      throw new RuntimeException(""String_Node_Str"");
    }
    if (rulesSinceFirstFail > 0)     rulesSinceFirstFail++;
    if (rulesSinceFirstFail > 6)     System.exit(1);
  }
  if (unexpectedInvs.get() > 0)   log.error(""String_Node_Str"" + unexpectedInvs.get() + ""String_Node_Str"");
  log.info(""String_Node_Str"");
  System.exit(rulesSinceFirstFail > 0 || unexpectedInvs.get() > 0 ? 1 : 0);
}",0.9991700556062744
85645,"private Sha256Hash recursiveExtractHashes(int height,int pos,ValuesUsed used,List<Sha256Hash> matchedHashes) throws VerificationException {
  if (used.bitsUsed >= matchedChildBits.length * 8) {
    throw new VerificationException(""String_Node_Str"");
  }
  boolean parentOfMatch=checkBitLE(matchedChildBits,used.bitsUsed++);
  if (height == 0 || !parentOfMatch) {
    if (used.hashesUsed >= hashes.size()) {
      throw new VerificationException(""String_Node_Str"");
    }
    Sha256Hash hash=hashes.get(used.hashesUsed++);
    if (height == 0 && parentOfMatch)     matchedHashes.add(hash);
    return hash;
  }
 else {
    byte[] left=recursiveExtractHashes(height - 1,pos * 2,used,matchedHashes).getBytes(), right;
    if (pos * 2 + 1 < getTreeWidth(transactionCount,height - 1))     right=recursiveExtractHashes(height - 1,pos * 2 + 1,used,matchedHashes).getBytes();
 else     right=left;
    return combineLeftRight(left,right);
  }
}","private Sha256Hash recursiveExtractHashes(int height,int pos,ValuesUsed used,List<Sha256Hash> matchedHashes) throws VerificationException {
  if (used.bitsUsed >= matchedChildBits.length * 8) {
    throw new VerificationException(""String_Node_Str"");
  }
  boolean parentOfMatch=checkBitLE(matchedChildBits,used.bitsUsed++);
  if (height == 0 || !parentOfMatch) {
    if (used.hashesUsed >= hashes.size()) {
      throw new VerificationException(""String_Node_Str"");
    }
    Sha256Hash hash=hashes.get(used.hashesUsed++);
    if (height == 0 && parentOfMatch)     matchedHashes.add(hash);
    return hash;
  }
 else {
    byte[] left=recursiveExtractHashes(height - 1,pos * 2,used,matchedHashes).getBytes(), right;
    if (pos * 2 + 1 < getTreeWidth(transactionCount,height - 1)) {
      right=recursiveExtractHashes(height - 1,pos * 2 + 1,used,matchedHashes).getBytes();
      if (Arrays.equals(right,left))       throw new VerificationException(""String_Node_Str"");
    }
 else {
      right=left;
    }
    return combineLeftRight(left,right);
  }
}",0.9380976346250628
85646,"/** 
 * Extracts tx hashes that are in this merkle tree and returns the merkle root of this tree. The returned root should be checked against the merkle root contained in the block header for security.
 * @param matchedHashes A list which will contain the matched txn (will be cleared)Required to be a LinkedHashSet in order to retain order or transactions in the block
 * @return the merkle root of this merkle tree
 * @throws ProtocolException if this partial merkle tree is invalid
 */
public Sha256Hash getTxnHashAndMerkleRoot(List<Sha256Hash> matchedHashes) throws VerificationException {
  matchedHashes.clear();
  if (transactionCount == 0)   throw new VerificationException(""String_Node_Str"");
  if (transactionCount > Block.MAX_BLOCK_SIZE / 60)   throw new VerificationException(""String_Node_Str"");
  if (hashes.size() > transactionCount)   throw new VerificationException(""String_Node_Str"");
  if (matchedChildBits.length * 8 < hashes.size())   throw new VerificationException(""String_Node_Str"");
  int height=0;
  while (getTreeWidth(transactionCount,height) > 1)   height++;
  ValuesUsed used=new ValuesUsed();
  Sha256Hash merkleRoot=recursiveExtractHashes(height,0,used,matchedHashes);
  if ((used.bitsUsed + 7) / 8 != matchedChildBits.length || used.hashesUsed != hashes.size())   throw new VerificationException(""String_Node_Str"");
  return merkleRoot;
}","/** 
 * Extracts tx hashes that are in this merkle tree and returns the merkle root of this tree. The returned root should be checked against the merkle root contained in the block header for security.
 * @param matchedHashesOut A list which will contain the matched txn (will be cleared).
 * @return the merkle root of this merkle tree
 * @throws ProtocolException if this partial merkle tree is invalid
 */
public Sha256Hash getTxnHashAndMerkleRoot(List<Sha256Hash> matchedHashesOut) throws VerificationException {
  matchedHashesOut.clear();
  if (transactionCount == 0)   throw new VerificationException(""String_Node_Str"");
  if (transactionCount > Block.MAX_BLOCK_SIZE / 60)   throw new VerificationException(""String_Node_Str"");
  if (hashes.size() > transactionCount)   throw new VerificationException(""String_Node_Str"");
  if (matchedChildBits.length * 8 < hashes.size())   throw new VerificationException(""String_Node_Str"");
  int height=0;
  while (getTreeWidth(transactionCount,height) > 1)   height++;
  ValuesUsed used=new ValuesUsed();
  Sha256Hash merkleRoot=recursiveExtractHashes(height,0,used,matchedHashesOut);
  if ((used.bitsUsed + 7) / 8 != matchedChildBits.length || used.hashesUsed != hashes.size())   throw new VerificationException(""String_Node_Str"");
  return merkleRoot;
}",0.9636568002997378
85647,"/** 
 * Helper for forcing a connection to localhost. Useful when using regtest mode. Returns the peer object.
 */
@Nullable public Peer connectToLocalHost(){
  final PeerAddress localhost=PeerAddress.localhost(params);
  backoffMap.put(localhost,new ExponentialBackoff(peerBackoffParams));
  return connectTo(localhost,true,vConnectTimeoutMillis);
}","/** 
 * Helper for forcing a connection to localhost. Useful when using regtest mode. Returns the peer object.
 */
@Nullable public Peer connectToLocalHost(){
  lock.lock();
  try {
    final PeerAddress localhost=PeerAddress.localhost(params);
    backoffMap.put(localhost,new ExponentialBackoff(peerBackoffParams));
    return connectTo(localhost,true,vConnectTimeoutMillis);
  }
  finally {
    lock.unlock();
  }
}",0.9114583333333334
85648,"/** 
 * Creates a new PeerGroup allowing you to specify the   {@link ClientConnectionManager} which is used to create newconnections and keep track of existing ones.
 */
private PeerGroup(NetworkParameters params,@Nullable AbstractBlockChain chain,ClientConnectionManager connectionManager,@Nullable TorClient torClient){
  this.params=checkNotNull(params);
  this.chain=chain;
  fastCatchupTimeSecs=params.getGenesisBlock().getTimeSeconds();
  wallets=new CopyOnWriteArrayList<Wallet>();
  peerFilterProviders=new CopyOnWriteArrayList<PeerFilterProvider>();
  this.torClient=torClient;
  executor=createPrivateExecutor();
  maxConnections=0;
  int height=chain == null ? 0 : chain.getBestChainHeight();
  versionMessage=new VersionMessage(params,height);
  versionMessage.relayTxesBeforeFilter=true;
  downloadTxDependencies=true;
  memoryPool=new MemoryPool();
  inactives=new PriorityQueue<PeerAddress>(1,new Comparator<PeerAddress>(){
    @SuppressWarnings(""String_Node_Str"") @Override public int compare(    PeerAddress a,    PeerAddress b){
      int result=backoffMap.get(a).compareTo(backoffMap.get(b));
      if (result == 0)       result=Ints.compare(a.getPort(),b.getPort());
      return result;
    }
  }
);
  backoffMap=new HashMap<PeerAddress,ExponentialBackoff>();
  peers=new CopyOnWriteArrayList<Peer>();
  pendingPeers=new CopyOnWriteArrayList<Peer>();
  channels=connectionManager;
  peerDiscoverers=new CopyOnWriteArraySet<PeerDiscovery>();
  peerEventListeners=new CopyOnWriteArrayList<ListenerRegistration<PeerEventListener>>();
  runningBroadcasts=Collections.synchronizedSet(new HashSet<TransactionBroadcast>());
  bloomFilterMerger=new FilterMerger(DEFAULT_BLOOM_FILTER_FP_RATE);
}","/** 
 * Creates a new PeerGroup allowing you to specify the   {@link ClientConnectionManager} which is used to create newconnections and keep track of existing ones.
 */
private PeerGroup(NetworkParameters params,@Nullable AbstractBlockChain chain,ClientConnectionManager connectionManager,@Nullable TorClient torClient){
  this.params=checkNotNull(params);
  this.chain=chain;
  fastCatchupTimeSecs=params.getGenesisBlock().getTimeSeconds();
  wallets=new CopyOnWriteArrayList<Wallet>();
  peerFilterProviders=new CopyOnWriteArrayList<PeerFilterProvider>();
  this.torClient=torClient;
  executor=createPrivateExecutor();
  maxConnections=0;
  int height=chain == null ? 0 : chain.getBestChainHeight();
  versionMessage=new VersionMessage(params,height);
  versionMessage.relayTxesBeforeFilter=true;
  downloadTxDependencies=true;
  memoryPool=new MemoryPool();
  inactives=new PriorityQueue<PeerAddress>(1,new Comparator<PeerAddress>(){
    @SuppressWarnings(""String_Node_Str"") @Override public int compare(    PeerAddress a,    PeerAddress b){
      checkState(lock.isHeldByCurrentThread());
      int result=backoffMap.get(a).compareTo(backoffMap.get(b));
      if (result == 0)       result=Ints.compare(a.getPort(),b.getPort());
      return result;
    }
  }
);
  backoffMap=new HashMap<PeerAddress,ExponentialBackoff>();
  peers=new CopyOnWriteArrayList<Peer>();
  pendingPeers=new CopyOnWriteArrayList<Peer>();
  channels=connectionManager;
  peerDiscoverers=new CopyOnWriteArraySet<PeerDiscovery>();
  peerEventListeners=new CopyOnWriteArrayList<ListenerRegistration<PeerEventListener>>();
  runningBroadcasts=Collections.synchronizedSet(new HashSet<TransactionBroadcast>());
  bloomFilterMerger=new FilterMerger(DEFAULT_BLOOM_FILTER_FP_RATE);
}",0.9861351819757366
85649,"/** 
 * Creates a version message to send, constructs a Peer object and attempts to connect it. Returns the peer on success or null on failure.
 * @param address Remote network address
 * @param incrementMaxConnections Whether to consider this connection an attempt to fill our quota, or somethingexplicitly requested.
 * @return Peer or null.
 */
@Nullable protected Peer connectTo(PeerAddress address,boolean incrementMaxConnections,int connectTimeoutMillis){
  VersionMessage ver=getVersionMessage().duplicate();
  ver.bestHeight=chain == null ? 0 : chain.getBestChainHeight();
  ver.time=Utils.currentTimeSeconds();
  Peer peer=new Peer(params,ver,address,chain,memoryPool,downloadTxDependencies);
  peer.addEventListener(startupListener,Threading.SAME_THREAD);
  peer.setMinProtocolVersion(vMinRequiredProtocolVersion);
  pendingPeers.add(peer);
  try {
    channels.openConnection(address.toSocketAddress(),peer);
  }
 catch (  Exception e) {
    log.warn(""String_Node_Str"" + address + ""String_Node_Str""+ e.getMessage());
    handlePeerDeath(peer,e);
    return null;
  }
  peer.setSocketTimeout(connectTimeoutMillis);
  if (incrementMaxConnections) {
    lock.lock();
    try {
      maxConnections++;
    }
  finally {
      lock.unlock();
    }
  }
  return peer;
}","/** 
 * Creates a version message to send, constructs a Peer object and attempts to connect it. Returns the peer on success or null on failure.
 * @param address Remote network address
 * @param incrementMaxConnections Whether to consider this connection an attempt to fill our quota, or somethingexplicitly requested.
 * @return Peer or null.
 */
@Nullable @GuardedBy(""String_Node_Str"") protected Peer connectTo(PeerAddress address,boolean incrementMaxConnections,int connectTimeoutMillis){
  checkState(lock.isHeldByCurrentThread());
  VersionMessage ver=getVersionMessage().duplicate();
  ver.bestHeight=chain == null ? 0 : chain.getBestChainHeight();
  ver.time=Utils.currentTimeSeconds();
  Peer peer=new Peer(params,ver,address,chain,memoryPool,downloadTxDependencies);
  peer.addEventListener(startupListener,Threading.SAME_THREAD);
  peer.setMinProtocolVersion(vMinRequiredProtocolVersion);
  pendingPeers.add(peer);
  try {
    channels.openConnection(address.toSocketAddress(),peer);
  }
 catch (  Exception e) {
    log.warn(""String_Node_Str"" + address + ""String_Node_Str""+ e.getMessage());
    handlePeerDeath(peer,e);
    return null;
  }
  peer.setSocketTimeout(connectTimeoutMillis);
  if (incrementMaxConnections) {
    maxConnections++;
  }
  return peer;
}",0.9317111459968604
85650,"public static void main(String[] args) throws Exception {
  BriefLogFormatter.init();
  System.out.println(""String_Node_Str"");
  boolean runLargeReorgs=args.length > 1 && Integer.parseInt(args[1]) == 1;
  params=RegTestParams.get();
  File blockFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  blockFile.deleteOnExit();
  FullBlockTestGenerator generator=new FullBlockTestGenerator(params);
  final RuleList blockList=generator.getBlocksToTest(false,runLargeReorgs,blockFile);
  final Map<Sha256Hash,Block> preloadedBlocks=new HashMap<Sha256Hash,Block>();
  final Iterator<Block> blocks=new BlockFileLoader(params,Arrays.asList(blockFile));
  try {
    store=new H2FullPrunedBlockStore(params,args.length > 0 ? args[0] : ""String_Node_Str"",blockList.maximumReorgBlockCount);
    ((H2FullPrunedBlockStore)store).resetStore();
    chain=new FullPrunedBlockChain(params,store);
  }
 catch (  BlockStoreException e) {
    e.printStackTrace();
    System.exit(1);
  }
  peers=new PeerGroup(params,chain);
  peers.setUserAgent(""String_Node_Str"",""String_Node_Str"");
  peers.getVersionMessage().localServices=VersionMessage.NODE_NETWORK;
  Preconditions.checkState(peers.getVersionMessage().hasBlockChain());
  peers.addAddress(new PeerAddress(InetAddress.getByName(""String_Node_Str""),args.length > 2 ? Integer.parseInt(args[2]) : params.getPort()));
  final BlockWrapper currentBlock=new BlockWrapper();
  final Set<Sha256Hash> blocksRequested=Collections.synchronizedSet(new HashSet<Sha256Hash>());
  final AtomicInteger unexpectedInvs=new AtomicInteger(0);
  peers.addEventListener(new AbstractPeerEventListener(){
    @Override public void onPeerConnected(    Peer peer,    int peerCount){
      super.onPeerConnected(peer,peerCount);
      log.info(""String_Node_Str"");
      bitcoind=peer;
    }
    @Override public void onPeerDisconnected(    Peer peer,    int peerCount){
      super.onPeerDisconnected(peer,peerCount);
      log.error(""String_Node_Str"");
      System.exit(1);
    }
    @Override public Message onPreMessageReceived(    Peer peer,    Message m){
      if (m instanceof HeadersMessage) {
        for (        Block block : ((HeadersMessage)m).getBlockHeaders())         bitcoindChainHead=block.getHash();
        return null;
      }
 else       if (m instanceof Block) {
        log.error(""String_Node_Str"");
        System.exit(1);
      }
 else       if (m instanceof GetDataMessage) {
        for (        InventoryItem item : ((GetDataMessage)m).items)         if (item.type == InventoryItem.Type.Block) {
          try {
            if (currentBlock.block.getHash().equals(item.hash))             bitcoind.sendMessage(currentBlock.block);
 else {
              Block nextBlock=preloadedBlocks.get(item.hash);
              while (nextBlock == null || !nextBlock.getHash().equals(item.hash)) {
                nextBlock=blocks.next();
                preloadedBlocks.put(nextBlock.getHash(),nextBlock);
              }
            }
          }
 catch (          IOException e) {
            throw new RuntimeException(e);
          }
          blocksRequested.add(item.hash);
        }
        return null;
      }
 else       if (m instanceof GetHeadersMessage) {
        try {
          LinkedList<Block> headers=new LinkedList<Block>();
          Block it=blockList.hashHeaderMap.get(currentBlock.block.getHash());
          while (it != null) {
            headers.addFirst(it);
            it=blockList.hashHeaderMap.get(it.getPrevBlockHash());
          }
          LinkedList<Block> sendHeaders=new LinkedList<Block>();
          for (          Sha256Hash hash : ((GetHeadersMessage)m).getLocator()) {
            boolean found=false;
            for (            Block b : headers) {
              if (found) {
                sendHeaders.addLast(b);
                if (b.getHash().equals(((GetHeadersMessage)m).getStopHash()))                 break;
              }
 else               if (b.getHash().equals(hash))               found=true;
            }
            if (found)             break;
          }
          bitcoind.sendMessage(new HeadersMessage(params,sendHeaders));
        }
 catch (        Exception e) {
          throw new RuntimeException(e);
        }
        return null;
      }
 else       if (m instanceof InventoryMessage) {
        if (mostRecentInv != null) {
          log.error(""String_Node_Str"");
          unexpectedInvs.incrementAndGet();
        }
        mostRecentInv=(InventoryMessage)m;
      }
      return m;
    }
  }
,Threading.SAME_THREAD);
  peers.addPeerFilterProvider(new PeerFilterProvider(){
    @Override public long getEarliestKeyCreationTime(){
      return Long.MAX_VALUE;
    }
    @Override public int getBloomFilterElementCount(){
      return 1;
    }
    @Override public boolean isRequiringUpdateAllBloomFilter(){
      return false;
    }
    @Override public void beginBloomFilterCalculation(){
    }
    @Override public void endBloomFilterCalculation(){
    }
    @Override public BloomFilter getBloomFilter(    int size,    double falsePositiveRate,    long nTweak){
      BloomFilter filter=new BloomFilter(1,0.99,0);
      filter.setMatchAll();
      return filter;
    }
  }
);
  bitcoindChainHead=params.getGenesisBlock().getHash();
  peers.startAsync();
  peers.setMaxConnections(1);
  peers.downloadBlockChain();
  while (bitcoind == null)   Thread.sleep(50);
  ArrayList<Sha256Hash> locator=new ArrayList<Sha256Hash>(1);
  locator.add(params.getGenesisBlock().getHash());
  Sha256Hash hashTo=new Sha256Hash(""String_Node_Str"");
  int differingBlocks=0;
  int invalidBlocks=0;
  int mempoolRulesFailed=0;
  int utxoRulesFailed=0;
  for (  Rule rule : blockList.list) {
    if (rule instanceof BlockAndValidity) {
      BlockAndValidity block=(BlockAndValidity)rule;
      boolean threw=false;
      Block nextBlock=preloadedBlocks.get(((BlockAndValidity)rule).blockHash);
      for (int i=0; i < 1 || nextBlock == null || !nextBlock.getHash().equals(((BlockAndValidity)rule).blockHash); i++) {
        Block b=blocks.next();
        preloadedBlocks.put(b.getHash(),b);
        nextBlock=preloadedBlocks.get(((BlockAndValidity)rule).blockHash);
      }
      currentBlock.block=nextBlock;
      log.info(""String_Node_Str"",currentBlock.block.getHash());
      try {
        if (chain.add(nextBlock) != block.connects) {
          log.error(""String_Node_Str"" + block.ruleName + ""String_Node_Str"");
          invalidBlocks++;
        }
      }
 catch (      VerificationException e) {
        threw=true;
        if (!block.throwsException) {
          log.error(""String_Node_Str"" + block.ruleName + ""String_Node_Str"");
          e.printStackTrace();
          invalidBlocks++;
        }
 else         if (block.connects) {
          log.error(""String_Node_Str"" + block.ruleName + ""String_Node_Str"");
          e.printStackTrace();
          invalidBlocks++;
        }
      }
      if (!threw && block.throwsException) {
        log.error(""String_Node_Str"" + block.ruleName + ""String_Node_Str"");
        invalidBlocks++;
      }
 else       if (!chain.getChainHead().getHeader().getHash().equals(block.hashChainTipAfterBlock)) {
        log.error(""String_Node_Str"" + block.ruleName + ""String_Node_Str"");
        invalidBlocks++;
      }
 else       if (chain.getChainHead().getHeight() != block.heightAfterBlock) {
        log.error(""String_Node_Str"" + block.ruleName);
        invalidBlocks++;
      }
      boolean shouldntRequest=blocksRequested.contains(nextBlock.getHash());
      if (shouldntRequest)       blocksRequested.remove(nextBlock.getHash());
      InventoryMessage message=new InventoryMessage(params);
      message.addBlock(nextBlock);
      bitcoind.sendMessage(message);
      for (int i=0; !shouldntRequest && !blocksRequested.contains(nextBlock.getHash()); i++) {
        if (i % 20 == 19)         log.error(""String_Node_Str"" + block.ruleName + ""String_Node_Str""+ nextBlock.getHash());
        Thread.sleep(50);
      }
      if (shouldntRequest) {
        Thread.sleep(100);
        if (blocksRequested.contains(nextBlock.getHash())) {
          log.error(""String_Node_Str"" + block.ruleName + ""String_Node_Str""+ nextBlock.getHash());
          invalidBlocks++;
        }
      }
      if (block.throwsException)       blocksRequested.remove(nextBlock.getHash());
      locator.clear();
      locator.add(bitcoindChainHead);
      bitcoind.sendMessage(new GetHeadersMessage(params,locator,hashTo));
      bitcoind.ping().get();
      if (!chain.getChainHead().getHeader().getHash().equals(bitcoindChainHead)) {
        differingBlocks++;
        log.error(""String_Node_Str"" + block.ruleName + ""String_Node_Str"");
      }
      log.info(""String_Node_Str"" + block.ruleName + ""String_Node_Str"");
    }
 else     if (rule instanceof MemoryPoolState) {
      MemoryPoolMessage message=new MemoryPoolMessage();
      bitcoind.sendMessage(message);
      bitcoind.ping().get();
      if (mostRecentInv == null && !((MemoryPoolState)rule).mempool.isEmpty()) {
        log.error(""String_Node_Str"" + rule.ruleName);
        mempoolRulesFailed++;
      }
 else       if (mostRecentInv != null && ((MemoryPoolState)rule).mempool.isEmpty()) {
        log.error(""String_Node_Str"" + rule.ruleName);
        mempoolRulesFailed++;
      }
 else       if (mostRecentInv != null) {
        Set<InventoryItem> originalRuleSet=new HashSet<InventoryItem>(((MemoryPoolState)rule).mempool);
        boolean matches=mostRecentInv.items.size() == ((MemoryPoolState)rule).mempool.size();
        for (        InventoryItem item : mostRecentInv.items)         if (!((MemoryPoolState)rule).mempool.remove(item))         matches=false;
        if (matches)         continue;
        log.error(""String_Node_Str"" + rule.ruleName);
        log.info(""String_Node_Str"");
        for (        InventoryItem item : mostRecentInv.items)         log.info(""String_Node_Str"" + item.hash);
        log.info(""String_Node_Str"");
        for (        InventoryItem item : originalRuleSet)         log.info(""String_Node_Str"" + item.hash);
        mempoolRulesFailed++;
      }
      mostRecentInv=null;
    }
 else     if (rule instanceof UTXORule) {
      UTXORule r=(UTXORule)rule;
      UTXOsMessage result=bitcoind.getUTXOs(r.query).get();
      if (!result.equals(r.result)) {
        log.error(""String_Node_Str"");
        log.error(""String_Node_Str"",r.result);
        log.error(""String_Node_Str"",result);
        utxoRulesFailed++;
      }
 else {
        log.info(""String_Node_Str"",r.ruleName,result);
      }
    }
 else {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
  log.info(""String_Node_Str"" + ""String_Node_Str"" + differingBlocks + ""String_Node_Str""+ ""String_Node_Str""+ invalidBlocks+ ""String_Node_Str""+ ""String_Node_Str""+ mempoolRulesFailed+ ""String_Node_Str""+ ""String_Node_Str""+ utxoRulesFailed+ ""String_Node_Str""+ ""String_Node_Str""+ unexpectedInvs.get());
  System.exit(differingBlocks > 0 || invalidBlocks > 0 || mempoolRulesFailed > 0 || utxoRulesFailed > 0 || unexpectedInvs.get() > 0 ? 1 : 0);
}","public static void main(String[] args) throws Exception {
  BriefLogFormatter.init();
  System.out.println(""String_Node_Str"");
  boolean runLargeReorgs=args.length > 1 && Integer.parseInt(args[1]) == 1;
  params=RegTestParams.get();
  File blockFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  blockFile.deleteOnExit();
  FullBlockTestGenerator generator=new FullBlockTestGenerator(params);
  final RuleList blockList=generator.getBlocksToTest(false,runLargeReorgs,blockFile);
  final Map<Sha256Hash,Block> preloadedBlocks=new HashMap<Sha256Hash,Block>();
  final Iterator<Block> blocks=new BlockFileLoader(params,Arrays.asList(blockFile));
  try {
    store=new H2FullPrunedBlockStore(params,args.length > 0 ? args[0] : ""String_Node_Str"",blockList.maximumReorgBlockCount);
    ((H2FullPrunedBlockStore)store).resetStore();
    chain=new FullPrunedBlockChain(params,store);
  }
 catch (  BlockStoreException e) {
    e.printStackTrace();
    System.exit(1);
  }
  peers=new PeerGroup(params,chain);
  peers.setUserAgent(""String_Node_Str"",""String_Node_Str"");
  peers.getVersionMessage().localServices=VersionMessage.NODE_NETWORK;
  Preconditions.checkState(peers.getVersionMessage().hasBlockChain());
  peers.addAddress(new PeerAddress(InetAddress.getByName(""String_Node_Str""),args.length > 2 ? Integer.parseInt(args[2]) : params.getPort()));
  final BlockWrapper currentBlock=new BlockWrapper();
  final Set<Sha256Hash> blocksRequested=Collections.synchronizedSet(new HashSet<Sha256Hash>());
  final AtomicInteger unexpectedInvs=new AtomicInteger(0);
  peers.addEventListener(new AbstractPeerEventListener(){
    @Override public void onPeerConnected(    Peer peer,    int peerCount){
      super.onPeerConnected(peer,peerCount);
      log.info(""String_Node_Str"");
      bitcoind=peer;
    }
    @Override public void onPeerDisconnected(    Peer peer,    int peerCount){
      super.onPeerDisconnected(peer,peerCount);
      log.error(""String_Node_Str"");
      System.exit(1);
    }
    @Override public Message onPreMessageReceived(    Peer peer,    Message m){
      if (m instanceof HeadersMessage) {
        for (        Block block : ((HeadersMessage)m).getBlockHeaders())         bitcoindChainHead=block.getHash();
        return null;
      }
 else       if (m instanceof Block) {
        log.error(""String_Node_Str"");
        System.exit(1);
      }
 else       if (m instanceof GetDataMessage) {
        for (        InventoryItem item : ((GetDataMessage)m).items)         if (item.type == InventoryItem.Type.Block) {
          try {
            if (currentBlock.block.getHash().equals(item.hash))             bitcoind.sendMessage(currentBlock.block);
 else {
              Block nextBlock=preloadedBlocks.get(item.hash);
              while (nextBlock == null || !nextBlock.getHash().equals(item.hash)) {
                nextBlock=blocks.next();
                preloadedBlocks.put(nextBlock.getHash(),nextBlock);
              }
            }
          }
 catch (          IOException e) {
            throw new RuntimeException(e);
          }
          blocksRequested.add(item.hash);
        }
        return null;
      }
 else       if (m instanceof GetHeadersMessage) {
        try {
          LinkedList<Block> headers=new LinkedList<Block>();
          Block it=blockList.hashHeaderMap.get(currentBlock.block.getHash());
          while (it != null) {
            headers.addFirst(it);
            it=blockList.hashHeaderMap.get(it.getPrevBlockHash());
          }
          LinkedList<Block> sendHeaders=new LinkedList<Block>();
          for (          Sha256Hash hash : ((GetHeadersMessage)m).getLocator()) {
            boolean found=false;
            for (            Block b : headers) {
              if (found) {
                sendHeaders.addLast(b);
                if (b.getHash().equals(((GetHeadersMessage)m).getStopHash()))                 break;
              }
 else               if (b.getHash().equals(hash))               found=true;
            }
            if (found)             break;
          }
          bitcoind.sendMessage(new HeadersMessage(params,sendHeaders));
        }
 catch (        Exception e) {
          throw new RuntimeException(e);
        }
        return null;
      }
 else       if (m instanceof InventoryMessage) {
        if (mostRecentInv != null) {
          log.error(""String_Node_Str"");
          unexpectedInvs.incrementAndGet();
        }
        mostRecentInv=(InventoryMessage)m;
      }
      return m;
    }
  }
,Threading.SAME_THREAD);
  peers.addPeerFilterProvider(new PeerFilterProvider(){
    @Override public long getEarliestKeyCreationTime(){
      return Long.MAX_VALUE;
    }
    @Override public int getBloomFilterElementCount(){
      return 1;
    }
    @Override public boolean isRequiringUpdateAllBloomFilter(){
      return false;
    }
    @Override public void beginBloomFilterCalculation(){
    }
    @Override public void endBloomFilterCalculation(){
    }
    @Override public BloomFilter getBloomFilter(    int size,    double falsePositiveRate,    long nTweak){
      BloomFilter filter=new BloomFilter(1,0.99,0);
      filter.setMatchAll();
      return filter;
    }
  }
);
  bitcoindChainHead=params.getGenesisBlock().getHash();
  peers.startAsync();
  peers.setMaxConnections(1);
  peers.downloadBlockChain();
  while (bitcoind == null)   Thread.sleep(50);
  ArrayList<Sha256Hash> locator=new ArrayList<Sha256Hash>(1);
  locator.add(params.getGenesisBlock().getHash());
  Sha256Hash hashTo=new Sha256Hash(""String_Node_Str"");
  int differingBlocks=0;
  int invalidBlocks=0;
  int mempoolRulesFailed=0;
  int utxoRulesFailed=0;
  for (  Rule rule : blockList.list) {
    if (rule instanceof BlockAndValidity) {
      BlockAndValidity block=(BlockAndValidity)rule;
      boolean threw=false;
      Block nextBlock=preloadedBlocks.get(((BlockAndValidity)rule).blockHash);
      for (int i=0; i < 1 || nextBlock == null || !nextBlock.getHash().equals(((BlockAndValidity)rule).blockHash); i++) {
        Block b=blocks.next();
        preloadedBlocks.put(b.getHash(),b);
        nextBlock=preloadedBlocks.get(((BlockAndValidity)rule).blockHash);
      }
      currentBlock.block=nextBlock;
      log.info(""String_Node_Str"",currentBlock.block.getHash());
      try {
        if (chain.add(nextBlock) != block.connects) {
          log.error(""String_Node_Str"" + block.ruleName + ""String_Node_Str"");
          invalidBlocks++;
        }
      }
 catch (      VerificationException e) {
        threw=true;
        if (!block.throwsException) {
          log.error(""String_Node_Str"" + block.ruleName + ""String_Node_Str"");
          e.printStackTrace();
          invalidBlocks++;
        }
 else         if (block.connects) {
          log.error(""String_Node_Str"" + block.ruleName + ""String_Node_Str"");
          e.printStackTrace();
          invalidBlocks++;
        }
      }
      if (!threw && block.throwsException) {
        log.error(""String_Node_Str"" + block.ruleName + ""String_Node_Str"");
        invalidBlocks++;
      }
 else       if (!chain.getChainHead().getHeader().getHash().equals(block.hashChainTipAfterBlock)) {
        log.error(""String_Node_Str"" + block.ruleName + ""String_Node_Str"");
        invalidBlocks++;
      }
 else       if (chain.getChainHead().getHeight() != block.heightAfterBlock) {
        log.error(""String_Node_Str"" + block.ruleName);
        invalidBlocks++;
      }
      boolean shouldntRequest=blocksRequested.contains(nextBlock.getHash());
      if (shouldntRequest)       blocksRequested.remove(nextBlock.getHash());
      InventoryMessage message=new InventoryMessage(params);
      message.addBlock(nextBlock);
      bitcoind.sendMessage(message);
      for (int i=0; !shouldntRequest && !blocksRequested.contains(nextBlock.getHash()); i++) {
        if (i % 20 == 19)         log.error(""String_Node_Str"" + block.ruleName + ""String_Node_Str""+ nextBlock.getHash());
        Thread.sleep(50);
      }
      if (shouldntRequest) {
        Thread.sleep(100);
        if (blocksRequested.contains(nextBlock.getHash())) {
          log.error(""String_Node_Str"" + block.ruleName + ""String_Node_Str""+ nextBlock.getHash());
          invalidBlocks++;
        }
      }
      if (block.throwsException)       blocksRequested.remove(nextBlock.getHash());
      locator.clear();
      locator.add(bitcoindChainHead);
      bitcoind.sendMessage(new GetHeadersMessage(params,locator,hashTo));
      bitcoind.ping().get();
      if (!chain.getChainHead().getHeader().getHash().equals(bitcoindChainHead)) {
        differingBlocks++;
        log.error(""String_Node_Str"" + block.ruleName + ""String_Node_Str"");
      }
      if (block.sendOnce)       preloadedBlocks.remove(nextBlock.getHash());
      log.info(""String_Node_Str"" + block.ruleName + ""String_Node_Str"");
    }
 else     if (rule instanceof MemoryPoolState) {
      MemoryPoolMessage message=new MemoryPoolMessage();
      bitcoind.sendMessage(message);
      bitcoind.ping().get();
      if (mostRecentInv == null && !((MemoryPoolState)rule).mempool.isEmpty()) {
        log.error(""String_Node_Str"" + rule.ruleName);
        mempoolRulesFailed++;
      }
 else       if (mostRecentInv != null && ((MemoryPoolState)rule).mempool.isEmpty()) {
        log.error(""String_Node_Str"" + rule.ruleName);
        mempoolRulesFailed++;
      }
 else       if (mostRecentInv != null) {
        Set<InventoryItem> originalRuleSet=new HashSet<InventoryItem>(((MemoryPoolState)rule).mempool);
        boolean matches=mostRecentInv.items.size() == ((MemoryPoolState)rule).mempool.size();
        for (        InventoryItem item : mostRecentInv.items)         if (!((MemoryPoolState)rule).mempool.remove(item))         matches=false;
        if (matches)         continue;
        log.error(""String_Node_Str"" + rule.ruleName);
        log.info(""String_Node_Str"");
        for (        InventoryItem item : mostRecentInv.items)         log.info(""String_Node_Str"" + item.hash);
        log.info(""String_Node_Str"");
        for (        InventoryItem item : originalRuleSet)         log.info(""String_Node_Str"" + item.hash);
        mempoolRulesFailed++;
      }
      mostRecentInv=null;
    }
 else     if (rule instanceof UTXORule) {
      UTXORule r=(UTXORule)rule;
      UTXOsMessage result=bitcoind.getUTXOs(r.query).get();
      if (!result.equals(r.result)) {
        log.error(""String_Node_Str"");
        log.error(""String_Node_Str"",r.result);
        log.error(""String_Node_Str"",result);
        utxoRulesFailed++;
      }
 else {
        log.info(""String_Node_Str"",r.ruleName,result);
      }
    }
 else {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
  log.info(""String_Node_Str"" + ""String_Node_Str"" + differingBlocks + ""String_Node_Str""+ ""String_Node_Str""+ invalidBlocks+ ""String_Node_Str""+ ""String_Node_Str""+ mempoolRulesFailed+ ""String_Node_Str""+ ""String_Node_Str""+ utxoRulesFailed+ ""String_Node_Str""+ ""String_Node_Str""+ unexpectedInvs.get());
  System.exit(differingBlocks > 0 || invalidBlocks > 0 || mempoolRulesFailed > 0 || utxoRulesFailed > 0 || unexpectedInvs.get() > 0 ? 1 : 0);
}",0.9965197740112994
85651,"public RuleList getBlocksToTest(boolean addSigExpensiveBlocks,boolean runLargeReorgs,File blockStorageFile) throws ScriptException, ProtocolException, IOException {
  final FileOutputStream outStream=blockStorageFile != null ? new FileOutputStream(blockStorageFile) : null;
  final Script OP_TRUE_SCRIPT=new ScriptBuilder().op(OP_TRUE).build();
  final Script OP_NOP_SCRIPT=new ScriptBuilder().op(OP_NOP).build();
  List<Rule> blocks=new LinkedList<Rule>(){
    @Override public boolean add(    Rule element){
      if (outStream != null && element instanceof BlockAndValidity) {
        try {
          outStream.write((int)(params.getPacketMagic() >>> 24));
          outStream.write((int)(params.getPacketMagic() >>> 16));
          outStream.write((int)(params.getPacketMagic() >>> 8));
          outStream.write((int)(params.getPacketMagic() >>> 0));
          byte[] block=((BlockAndValidity)element).block.bitcoinSerialize();
          byte[] length=new byte[4];
          Utils.uint32ToByteArrayBE(block.length,length,0);
          outStream.write(Utils.reverseBytes(length));
          outStream.write(block);
          ((BlockAndValidity)element).block=null;
        }
 catch (        IOException e) {
          throw new RuntimeException(e);
        }
      }
      return super.add(element);
    }
  }
;
  RuleList ret=new RuleList(blocks,hashHeaderMap,10);
  Queue<TransactionOutPointWithValue> spendableOutputs=new LinkedList<TransactionOutPointWithValue>();
  int chainHeadHeight=1;
  Block chainHead=params.getGenesisBlock().createNextBlockWithCoinbase(coinbaseOutKeyPubKey);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,chainHead,true,false,chainHead.getHash(),1,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,chainHead.getTransactions().get(0).getHash()),FIFTY_COINS,chainHead.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  for (int i=1; i < params.getSpendableCoinbaseDepth(); i++) {
    chainHead=chainHead.createNextBlockWithCoinbase(coinbaseOutKeyPubKey);
    chainHeadHeight++;
    blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,chainHead,true,false,chainHead.getHash(),i + 1,""String_Node_Str""));
    spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,chainHead.getTransactions().get(0).getHash()),FIFTY_COINS,chainHead.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  }
  Block b1=createNextBlock(chainHead,chainHeadHeight + 1,spendableOutputs.poll(),null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b1,true,false,b1.getHash(),chainHeadHeight + 1,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b1.getTransactions().get(0).getHash()),b1.getTransactions().get(0).getOutputs().get(0).getValue(),b1.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out1=spendableOutputs.poll();
  checkState(out1 != null);
  Block b2=createNextBlock(b1,chainHeadHeight + 2,out1,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b2,true,false,b2.getHash(),chainHeadHeight + 2,""String_Node_Str""));
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b2,true,false,b2.getHash(),chainHeadHeight + 2,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b2.getTransactions().get(0).getHash()),b2.getTransactions().get(0).getOutput(0).getValue(),b2.getTransactions().get(0).getOutput(0).getScriptPubKey()));
  Block b3=createNextBlock(b1,chainHeadHeight + 2,out1,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b3,true,false,b2.getHash(),chainHeadHeight + 2,""String_Node_Str""));
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b3,true,false,b2.getHash(),chainHeadHeight + 2,""String_Node_Str""));
  UTXORule utxo1;
{
    Transaction coinbase=b2.getTransactions().get(0);
    TransactionOutPoint outpoint=new TransactionOutPoint(params,0,coinbase.getHash());
    long[] heights=new long[]{chainHeadHeight + 2};
    UTXOsMessage result=new UTXOsMessage(params,ImmutableList.of(coinbase.getOutput(0)),heights,b2.getHash(),chainHeadHeight + 2);
    utxo1=new UTXORule(""String_Node_Str"",outpoint,result);
    blocks.add(utxo1);
  }
  TransactionOutPointWithValue out2=checkNotNull(spendableOutputs.poll());
  Block b4=createNextBlock(b3,chainHeadHeight + 3,out2,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b4,true,false,b4.getHash(),chainHeadHeight + 3,""String_Node_Str""));
{
    Transaction coinbase=b4.getTransactions().get(0);
    TransactionOutPoint outpoint=new TransactionOutPoint(params,0,coinbase.getHash());
    List<TransactionOutPoint> queries=ImmutableList.of(utxo1.query.get(0),outpoint);
    List<TransactionOutput> results=Lists.asList(null,coinbase.getOutput(0),new TransactionOutput[]{});
    long[] heights=new long[]{chainHeadHeight + 3};
    UTXOsMessage result=new UTXOsMessage(params,results,heights,b4.getHash(),chainHeadHeight + 3);
    UTXORule utxo2=new UTXORule(""String_Node_Str"",queries,result);
    blocks.add(utxo2);
  }
  Block b5=createNextBlock(b2,chainHeadHeight + 3,out2,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b5,true,false,b4.getHash(),chainHeadHeight + 3,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b5.getTransactions().get(0).getHash()),b5.getTransactions().get(0).getOutputs().get(0).getValue(),b5.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out3=spendableOutputs.poll();
  Block b6=createNextBlock(b5,chainHeadHeight + 4,out3,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b6,true,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  Block b7=createNextBlock(b5,chainHeadHeight + 5,out2,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b7,true,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  TransactionOutPointWithValue out4=spendableOutputs.poll();
  Block b8=createNextBlock(b7,chainHeadHeight + 6,out4,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b8,false,true,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  Block b9=createNextBlock(b6,chainHeadHeight + 5,out4,SATOSHI);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b9,false,true,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  Block b10=createNextBlock(b5,chainHeadHeight + 4,out3,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b10,true,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  Block b11=createNextBlock(b10,chainHeadHeight + 5,out4,SATOSHI);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b11,false,true,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  Block b12=createNextBlock(b5,chainHeadHeight + 4,out3,null);
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b12.getTransactions().get(0).getHash()),b12.getTransactions().get(0).getOutputs().get(0).getValue(),b12.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  Block b13=createNextBlock(b12,chainHeadHeight + 5,out4,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b13,false,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b13,false,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b13.getTransactions().get(0).getHash()),b13.getTransactions().get(0).getOutputs().get(0).getValue(),b13.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out5=spendableOutputs.poll();
  Block b14=createNextBlock(b13,chainHeadHeight + 6,out5,SATOSHI);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b14,false,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b14,false,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b12,false,true,b13.getHash(),chainHeadHeight + 5,""String_Node_Str""));
  Block b15=createNextBlock(b13,chainHeadHeight + 6,out5,null);
{
    int sigOps=0;
    for (    Transaction tx : b15.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b15.getTransactions().get(1).getHash()),SATOSHI,b15.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b15.addTransaction(tx);
  }
  b15.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b15,true,false,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b15.getTransactions().get(0).getHash()),b15.getTransactions().get(0).getOutputs().get(0).getValue(),b15.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out6=spendableOutputs.poll();
  Block b16=createNextBlock(b15,chainHeadHeight + 7,out6,null);
{
    int sigOps=0;
    for (    Transaction tx : b16.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + 1];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b16.getTransactions().get(1).getHash()),SATOSHI,b16.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b16.addTransaction(tx);
  }
  b16.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b16,false,true,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  Block b17=createNextBlock(b15,chainHeadHeight + 7,out6,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,new byte[]{}));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b3.getTransactions().get(1).getHash()),SATOSHI,b3.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b17.addTransaction(tx);
  }
  b17.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b17,false,true,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  Block b18=createNextBlock(b13,chainHeadHeight + 6,out5,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,new byte[]{}));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b3.getTransactions().get(1).getHash()),SATOSHI,b3.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b18.addTransaction(tx);
  }
  b18.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b18,true,false,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  Block b19=createNextBlock(b18,chainHeadHeight + 7,out6,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b19,false,true,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  TransactionOutPointWithValue out7=spendableOutputs.poll();
  Block b20=createNextBlock(b15,chainHeadHeight + 7,out7,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b20,false,true,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  Block b21=createNextBlock(b13,chainHeadHeight + 6,out6,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b21,true,false,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  Block b22=createNextBlock(b21,chainHeadHeight + 7,out5,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b22,false,true,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  Block b23=createNextBlock(b15,chainHeadHeight + 7,out6,null);
{
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIZE - b23.getMessageSize() - 138];
    Arrays.fill(outputScript,(byte)OP_FALSE);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b23.getTransactions().get(1).getHash()),SATOSHI,b23.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b23.addTransaction(tx);
  }
  b23.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b23,true,false,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b23.getTransactions().get(0).getHash()),b23.getTransactions().get(0).getOutputs().get(0).getValue(),b23.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  Block b24=createNextBlock(b15,chainHeadHeight + 7,out6,null);
{
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIZE - b24.getMessageSize() - 135];
    Arrays.fill(outputScript,(byte)OP_FALSE);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b24.getTransactions().get(1).getHash()),SATOSHI,b24.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b24.addTransaction(tx);
  }
  b24.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b24,false,true,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  Block b25=createNextBlock(b24,chainHeadHeight + 8,out7,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b25,false,false,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  Block b26=createNextBlock(b15,chainHeadHeight + 7,out6,null);
  b26.getTransactions().get(0).getInputs().get(0).setScriptBytes(new byte[]{0});
  b26.setMerkleRoot(null);
  b26.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b26,false,true,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  Block b27=createNextBlock(b26,chainHeadHeight + 8,out7,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b27,false,false,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  Block b28=createNextBlock(b15,chainHeadHeight + 7,out6,null);
{
    byte[] coinbase=new byte[101];
    Arrays.fill(coinbase,(byte)0);
    b28.getTransactions().get(0).getInputs().get(0).setScriptBytes(coinbase);
  }
  b28.setMerkleRoot(null);
  b28.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b28,false,true,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  Block b29=createNextBlock(b28,chainHeadHeight + 8,out7,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b29,false,false,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  Block b30=createNextBlock(b23,chainHeadHeight + 8,out7,null);
{
    byte[] coinbase=new byte[100];
    Arrays.fill(coinbase,(byte)0);
    b30.getTransactions().get(0).getInputs().get(0).setScriptBytes(coinbase);
  }
  b30.setMerkleRoot(null);
  b30.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b30,true,false,b30.getHash(),chainHeadHeight + 8,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b30.getTransactions().get(0).getHash()),b30.getTransactions().get(0).getOutputs().get(0).getValue(),b30.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out8=spendableOutputs.poll();
  Block b31=createNextBlock(b30,chainHeadHeight + 9,out8,null);
{
    int sigOps=0;
    for (    Transaction tx : b31.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[(Block.MAX_BLOCK_SIGOPS - sigOps) / 20];
    Arrays.fill(outputScript,(byte)OP_CHECKMULTISIG);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b31.getTransactions().get(1).getHash()),SATOSHI,b31.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b31.addTransaction(tx);
  }
  b31.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b31,true,false,b31.getHash(),chainHeadHeight + 9,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b31.getTransactions().get(0).getHash()),b31.getTransactions().get(0).getOutputs().get(0).getValue(),b31.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out9=spendableOutputs.poll();
  Block b32=createNextBlock(b31,chainHeadHeight + 10,out9,null);
{
    int sigOps=0;
    for (    Transaction tx : b32.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[(Block.MAX_BLOCK_SIGOPS - sigOps) / 20 + (Block.MAX_BLOCK_SIGOPS - sigOps) % 20 + 1];
    Arrays.fill(outputScript,(byte)OP_CHECKMULTISIG);
    for (int i=0; i < (Block.MAX_BLOCK_SIGOPS - sigOps) % 20; i++)     outputScript[i]=(byte)OP_CHECKSIG;
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b32.getTransactions().get(1).getHash()),SATOSHI,b32.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b32.addTransaction(tx);
  }
  b32.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b32,false,true,b31.getHash(),chainHeadHeight + 9,""String_Node_Str""));
  Block b33=createNextBlock(b31,chainHeadHeight + 10,out9,null);
{
    int sigOps=0;
    for (    Transaction tx : b33.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[(Block.MAX_BLOCK_SIGOPS - sigOps) / 20];
    Arrays.fill(outputScript,(byte)OP_CHECKMULTISIGVERIFY);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b33.getTransactions().get(1).getHash()),SATOSHI,b33.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b33.addTransaction(tx);
  }
  b33.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b33,true,false,b33.getHash(),chainHeadHeight + 10,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b33.getTransactions().get(0).getHash()),b33.getTransactions().get(0).getOutputs().get(0).getValue(),b33.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out10=spendableOutputs.poll();
  Block b34=createNextBlock(b33,chainHeadHeight + 11,out10,null);
{
    int sigOps=0;
    for (    Transaction tx : b34.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[(Block.MAX_BLOCK_SIGOPS - sigOps) / 20 + (Block.MAX_BLOCK_SIGOPS - sigOps) % 20 + 1];
    Arrays.fill(outputScript,(byte)OP_CHECKMULTISIGVERIFY);
    for (int i=0; i < (Block.MAX_BLOCK_SIGOPS - sigOps) % 20; i++)     outputScript[i]=(byte)OP_CHECKSIG;
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b34.getTransactions().get(1).getHash()),SATOSHI,b34.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b34.addTransaction(tx);
  }
  b34.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b34,false,true,b33.getHash(),chainHeadHeight + 10,""String_Node_Str""));
  Block b35=createNextBlock(b33,chainHeadHeight + 11,out10,null);
{
    int sigOps=0;
    for (    Transaction tx : b35.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps];
    Arrays.fill(outputScript,(byte)OP_CHECKSIGVERIFY);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b35.getTransactions().get(1).getHash()),SATOSHI,b35.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b35.addTransaction(tx);
  }
  b35.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b35,true,false,b35.getHash(),chainHeadHeight + 11,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b35.getTransactions().get(0).getHash()),b35.getTransactions().get(0).getOutputs().get(0).getValue(),b35.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out11=spendableOutputs.poll();
  Block b36=createNextBlock(b35,chainHeadHeight + 12,out11,null);
{
    int sigOps=0;
    for (    Transaction tx : b36.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + 1];
    Arrays.fill(outputScript,(byte)OP_CHECKSIGVERIFY);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b36.getTransactions().get(1).getHash()),SATOSHI,b36.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b36.addTransaction(tx);
  }
  b36.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b36,false,true,b35.getHash(),chainHeadHeight + 11,""String_Node_Str""));
  Block b37=createNextBlock(b35,chainHeadHeight + 12,out11,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,new byte[]{}));
    addOnlyInputToTransaction(tx,out11);
    b37.addTransaction(tx);
  }
  b37.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b37,false,true,b35.getHash(),chainHeadHeight + 11,""String_Node_Str""));
  Block b38=createNextBlock(b35,chainHeadHeight + 12,out11,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,new byte[]{}));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b37.getTransactions().get(1).getHash()),SATOSHI,b37.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b38.addTransaction(tx);
  }
  b38.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b38,false,true,b35.getHash(),chainHeadHeight + 11,""String_Node_Str""));
  byte[] b39p2shScriptPubKey;
  int b39numP2SHOutputs=0, b39sigOpsPerOutput=6;
  Block b39=createNextBlock(b35,chainHeadHeight + 12,null,null);
{
    ByteArrayOutputStream p2shScriptPubKey=new UnsafeByteArrayOutputStream();
    try {
      Script.writeBytes(p2shScriptPubKey,coinbaseOutKeyPubKey);
      p2shScriptPubKey.write(OP_2DUP);
      p2shScriptPubKey.write(OP_CHECKSIGVERIFY);
      p2shScriptPubKey.write(OP_2DUP);
      p2shScriptPubKey.write(OP_CHECKSIGVERIFY);
      p2shScriptPubKey.write(OP_2DUP);
      p2shScriptPubKey.write(OP_CHECKSIGVERIFY);
      p2shScriptPubKey.write(OP_2DUP);
      p2shScriptPubKey.write(OP_CHECKSIGVERIFY);
      p2shScriptPubKey.write(OP_2DUP);
      p2shScriptPubKey.write(OP_CHECKSIGVERIFY);
      p2shScriptPubKey.write(OP_CHECKSIG);
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
    b39p2shScriptPubKey=p2shScriptPubKey.toByteArray();
    byte[] scriptHash=Utils.sha256hash160(b39p2shScriptPubKey);
    UnsafeByteArrayOutputStream scriptPubKey=new UnsafeByteArrayOutputStream(scriptHash.length + 3);
    scriptPubKey.write(OP_HASH160);
    try {
      Script.writeBytes(scriptPubKey,scriptHash);
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
    scriptPubKey.write(OP_EQUAL);
    Coin lastOutputValue=out11.value.subtract(SATOSHI);
    TransactionOutPoint lastOutPoint;
{
      Transaction tx=new Transaction(params);
      tx.addOutput(new TransactionOutput(params,tx,SATOSHI,scriptPubKey.toByteArray()));
      tx.addOutput(new TransactionOutput(params,tx,lastOutputValue,new byte[]{OP_1}));
      addOnlyInputToTransaction(tx,out11);
      lastOutPoint=new TransactionOutPoint(params,1,tx.getHash());
      b39.addTransaction(tx);
    }
    b39numP2SHOutputs++;
    while (b39.getMessageSize() < Block.MAX_BLOCK_SIZE) {
      Transaction tx=new Transaction(params);
      lastOutputValue=lastOutputValue.subtract(SATOSHI);
      tx.addOutput(new TransactionOutput(params,tx,SATOSHI,scriptPubKey.toByteArray()));
      tx.addOutput(new TransactionOutput(params,tx,lastOutputValue,new byte[]{OP_1}));
      tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},lastOutPoint));
      lastOutPoint=new TransactionOutPoint(params,1,tx.getHash());
      if (b39.getMessageSize() + tx.getMessageSize() < Block.MAX_BLOCK_SIZE) {
        b39.addTransaction(tx);
        b39numP2SHOutputs++;
      }
 else       break;
    }
  }
  b39.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b39,true,false,b39.getHash(),chainHeadHeight + 12,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b39.getTransactions().get(0).getHash()),b39.getTransactions().get(0).getOutputs().get(0).getValue(),b39.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out12=spendableOutputs.poll();
  Block b40=createNextBlock(b39,chainHeadHeight + 13,out12,null);
{
    int sigOps=0;
    for (    Transaction tx : b40.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    int numTxes=(Block.MAX_BLOCK_SIGOPS - sigOps) / b39sigOpsPerOutput;
    checkState(numTxes <= b39numP2SHOutputs);
    TransactionOutPoint lastOutPoint=new TransactionOutPoint(params,2,b40.getTransactions().get(1).getHash());
    byte[] scriptSig=null;
    for (int i=1; i <= numTxes; i++) {
      Transaction tx=new Transaction(params);
      tx.addOutput(new TransactionOutput(params,tx,SATOSHI,new byte[]{OP_1}));
      tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},lastOutPoint));
      TransactionInput input=new TransactionInput(params,tx,new byte[]{},new TransactionOutPoint(params,0,b39.getTransactions().get(i).getHash()));
      tx.addInput(input);
      if (scriptSig == null) {
        Sha256Hash hash=tx.hashForSignature(1,b39p2shScriptPubKey,SigHash.SINGLE,false);
        try {
          ByteArrayOutputStream bos=new UnsafeByteArrayOutputStream(73);
          bos.write(coinbaseOutKey.sign(hash).encodeToDER());
          bos.write(SigHash.SINGLE.ordinal() + 1);
          byte[] signature=bos.toByteArray();
          ByteArrayOutputStream scriptSigBos=new UnsafeByteArrayOutputStream(signature.length + b39p2shScriptPubKey.length + 3);
          Script.writeBytes(scriptSigBos,new byte[]{(byte)OP_CHECKSIG});
          scriptSigBos.write(Script.createInputScript(signature));
          Script.writeBytes(scriptSigBos,b39p2shScriptPubKey);
          scriptSig=scriptSigBos.toByteArray();
        }
 catch (        IOException e) {
          throw new RuntimeException(e);
        }
      }
      input.setScriptBytes(scriptSig);
      lastOutPoint=new TransactionOutPoint(params,0,tx.getHash());
      b40.addTransaction(tx);
    }
    sigOps+=numTxes * b39sigOpsPerOutput;
    Transaction tx=new Transaction(params);
    tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},lastOutPoint));
    byte[] scriptPubKey=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + 1];
    Arrays.fill(scriptPubKey,(byte)OP_CHECKSIG);
    tx.addOutput(new TransactionOutput(params,tx,ZERO,scriptPubKey));
    b40.addTransaction(tx);
  }
  b40.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b40,false,true,b39.getHash(),chainHeadHeight + 12,""String_Node_Str""));
  Block b41=null;
  if (addSigExpensiveBlocks) {
    b41=createNextBlock(b39,chainHeadHeight + 13,out12,null);
{
      int sigOps=0;
      for (      Transaction tx : b41.transactions) {
        sigOps+=tx.getSigOpCount();
      }
      int numTxes=(Block.MAX_BLOCK_SIGOPS - sigOps) / b39sigOpsPerOutput;
      checkState(numTxes <= b39numP2SHOutputs);
      TransactionOutPoint lastOutPoint=new TransactionOutPoint(params,2,b41.getTransactions().get(1).getHash());
      byte[] scriptSig=null;
      for (int i=1; i <= numTxes; i++) {
        Transaction tx=new Transaction(params);
        tx.addOutput(new TransactionOutput(params,tx,Coin.SATOSHI,new byte[]{OP_1}));
        tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},lastOutPoint));
        TransactionInput input=new TransactionInput(params,tx,new byte[]{},new TransactionOutPoint(params,0,b39.getTransactions().get(i).getHash()));
        tx.addInput(input);
        if (scriptSig == null) {
          Sha256Hash hash=tx.hashForSignature(1,b39p2shScriptPubKey,SigHash.SINGLE,false);
          try {
            ByteArrayOutputStream bos=new UnsafeByteArrayOutputStream(73);
            bos.write(coinbaseOutKey.sign(hash).encodeToDER());
            bos.write(SigHash.SINGLE.ordinal() + 1);
            byte[] signature=bos.toByteArray();
            ByteArrayOutputStream scriptSigBos=new UnsafeByteArrayOutputStream(signature.length + b39p2shScriptPubKey.length + 3);
            Script.writeBytes(scriptSigBos,new byte[]{(byte)OP_CHECKSIG});
            scriptSigBos.write(Script.createInputScript(signature));
            Script.writeBytes(scriptSigBos,b39p2shScriptPubKey);
            scriptSig=scriptSigBos.toByteArray();
          }
 catch (          IOException e) {
            throw new RuntimeException(e);
          }
        }
        input.setScriptBytes(scriptSig);
        lastOutPoint=new TransactionOutPoint(params,0,tx.getHash());
        b41.addTransaction(tx);
      }
      sigOps+=numTxes * b39sigOpsPerOutput;
      Transaction tx=new Transaction(params);
      tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},lastOutPoint));
      byte[] scriptPubKey=new byte[Block.MAX_BLOCK_SIGOPS - sigOps];
      Arrays.fill(scriptPubKey,(byte)OP_CHECKSIG);
      tx.addOutput(new TransactionOutput(params,tx,ZERO,scriptPubKey));
      b41.addTransaction(tx);
    }
    b41.solve();
    blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b41,true,false,b41.getHash(),chainHeadHeight + 13,""String_Node_Str""));
  }
  Block b42=createNextBlock(b39,chainHeadHeight + 13,out12,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b42,true,false,b41 == null ? b42.getHash() : b41.getHash(),chainHeadHeight + 13,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b42.getTransactions().get(0).getHash()),b42.getTransactions().get(0).getOutputs().get(0).getValue(),b42.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out13=spendableOutputs.poll();
  Block b43=createNextBlock(b42,chainHeadHeight + 14,out13,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b43,true,false,b43.getHash(),chainHeadHeight + 14,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b43.getTransactions().get(0).getHash()),b43.getTransactions().get(0).getOutputs().get(0).getValue(),b43.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out14=spendableOutputs.poll();
  Block b44=new Block(params);
  byte[] outScriptBytes=ScriptBuilder.createOutputScript(ECKey.fromPublicOnly(coinbaseOutKeyPubKey)).getProgram();
{
    b44.setDifficultyTarget(b43.getDifficultyTarget());
    b44.addCoinbaseTransaction(coinbaseOutKeyPubKey,ZERO);
    Transaction t=new Transaction(params);
    t.addOutput(new TransactionOutput(params,t,ZERO,new byte[]{OP_PUSHDATA1 - 1}));
    t.addOutput(new TransactionOutput(params,t,SATOSHI,outScriptBytes));
    t.addOutput(new TransactionOutput(params,t,ZERO,new byte[]{OP_1}));
    addOnlyInputToTransaction(t,out14);
    b44.addTransaction(t);
    b44.setPrevBlockHash(b43.getHash());
    b44.setTime(b43.getTimeSeconds() + 1);
  }
  b44.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b44,true,false,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  TransactionOutPointWithValue out15=spendableOutputs.poll();
  Block b45=new Block(params);
{
    b45.setDifficultyTarget(b44.getDifficultyTarget());
    Transaction t=new Transaction(params);
    t.addOutput(new TransactionOutput(params,t,ZERO,new byte[]{OP_PUSHDATA1 - 1}));
    t.addOutput(new TransactionOutput(params,t,SATOSHI,outScriptBytes));
    t.addOutput(new TransactionOutput(params,t,ZERO,new byte[]{OP_1}));
    addOnlyInputToTransaction(t,out15);
    try {
      b45.addTransaction(t);
    }
 catch (    RuntimeException e) {
    }
    if (b45.getTransactions().size() > 0)     throw new RuntimeException(""String_Node_Str"");
    b45.addTransaction(t,false);
    b45.setPrevBlockHash(b44.getHash());
    b45.setTime(b44.getTimeSeconds() + 1);
  }
  b45.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b45,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b46=new Block(params);
{
    b46.transactions=new ArrayList<Transaction>();
    b46.setDifficultyTarget(b44.getDifficultyTarget());
    b46.setMerkleRoot(Sha256Hash.ZERO_HASH);
    b46.setPrevBlockHash(b44.getHash());
    b46.setTime(b44.getTimeSeconds() + 1);
  }
  b46.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b46,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b47=createNextBlock(b44,chainHeadHeight + 16,out15,null);
{
    try {
      BigInteger target=b47.getDifficultyTargetAsInteger();
      while (true) {
        BigInteger h=b47.getHash().toBigInteger();
        if (h.compareTo(target) > 0)         break;
        b47.setNonce(b47.getNonce() + 1);
      }
    }
 catch (    VerificationException e) {
      throw new RuntimeException(e);
    }
  }
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b47,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b48=createNextBlock(b44,chainHeadHeight + 16,out15,null);
  b48.setTime(Utils.currentTimeSeconds() + 60 * 60 * 3);
  b48.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b48,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b49=createNextBlock(b44,chainHeadHeight + 16,out15,null);
  byte[] b49MerkleHash=Sha256Hash.ZERO_HASH.getBytes().clone();
  b49MerkleHash[1]=(byte)0xDE;
  b49.setMerkleRoot(Sha256Hash.create(b49MerkleHash));
  b49.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b49,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b50=createNextBlock(b44,chainHeadHeight + 16,out15,null);
{
    long diffTarget=b44.getDifficultyTarget();
    diffTarget&=0xFFBFFFFF;
    b50.setDifficultyTarget(diffTarget);
  }
  b50.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b50,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b51=createNextBlock(b44,chainHeadHeight + 16,out15,null);
{
    Transaction coinbase=new Transaction(params);
    coinbase.addInput(new TransactionInput(params,coinbase,new byte[]{(byte)0xff,110,1}));
    coinbase.addOutput(new TransactionOutput(params,coinbase,SATOSHI,outScriptBytes));
    b51.addTransaction(coinbase,false);
  }
  b51.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b51,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b52=createNextBlock(b44,chainHeadHeight + 16,out15,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,new byte[]{}));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b52.getTransactions().get(1).getHash()),SATOSHI,b52.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b52.addTransaction(tx);
    b52.addTransaction(tx);
  }
  b52.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b52,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b53=createNextBlock(b43,chainHeadHeight + 15,out14,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b53,true,false,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b53.getTransactions().get(0).getHash()),b53.getTransactions().get(0).getOutputs().get(0).getValue(),b53.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  Block b54=createNextBlock(b53,chainHeadHeight + 16,out15,null);
  b54.setTime(b35.getTimeSeconds() - 1);
  b54.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b54,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b55=createNextBlock(b53,chainHeadHeight + 16,out15,null);
  b55.setTime(b35.getTimeSeconds());
  b55.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b55,true,false,b55.getHash(),chainHeadHeight + 16,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b55.getTransactions().get(0).getHash()),b55.getTransactions().get(0).getOutputs().get(0).getValue(),b55.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out16=spendableOutputs.poll();
  Block b57=createNextBlock(b55,chainHeadHeight + 17,out16,null);
  Transaction b56txToDuplicate;
{
    b56txToDuplicate=new Transaction(params);
    b56txToDuplicate.addOutput(new TransactionOutput(params,b56txToDuplicate,SATOSHI,new byte[]{}));
    addOnlyInputToTransaction(b56txToDuplicate,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b57.getTransactions().get(1).getHash()),SATOSHI,b57.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b57.addTransaction(b56txToDuplicate);
  }
  b57.solve();
  Block b56;
  try {
    b56=new Block(params,b57.bitcoinSerialize());
  }
 catch (  ProtocolException e) {
    throw new RuntimeException(e);
  }
  b56.addTransaction(b56txToDuplicate);
  checkState(b56.getHash().equals(b57.getHash()));
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b56,false,true,b55.getHash(),chainHeadHeight + 16,""String_Node_Str""));
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b57,true,false,b57.getHash(),chainHeadHeight + 17,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b57.getTransactions().get(0).getHash()),b57.getTransactions().get(0).getOutputs().get(0).getValue(),b57.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out17=spendableOutputs.poll();
  Block b58=createNextBlock(b57,chainHeadHeight + 18,out17,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,ZERO,new byte[]{}));
    tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},new TransactionOutPoint(params,3,b58.getTransactions().get(1).getHash())));
    b58.addTransaction(tx);
  }
  b58.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b58,false,true,b57.getHash(),chainHeadHeight + 17,""String_Node_Str""));
  Block b59=createNextBlock(b57,chainHeadHeight + 18,out17,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,b59.getTransactions().get(1).getOutputs().get(2).getValue().add(SATOSHI),new byte[]{}));
    tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},new TransactionOutPoint(params,2,b59.getTransactions().get(1).getHash())));
    b59.addTransaction(tx);
  }
  b59.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b59,false,true,b57.getHash(),chainHeadHeight + 17,""String_Node_Str""));
  Block b60=createNextBlock(b57,chainHeadHeight + 18,out17,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b60,true,false,b60.getHash(),chainHeadHeight + 18,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b60.getTransactions().get(0).getHash()),b60.getTransactions().get(0).getOutputs().get(0).getValue(),b60.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out18=spendableOutputs.poll();
  Block b61=createNextBlock(b60,chainHeadHeight + 19,out18,null);
{
    b61.getTransactions().get(0).getInput(0).setScriptBytes(b60.getTransactions().get(0).getInput(0).getScriptBytes());
    b61.unCache();
    checkState(b61.getTransactions().get(0).equals(b60.getTransactions().get(0)));
  }
  b61.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b61,false,true,b60.getHash(),chainHeadHeight + 18,""String_Node_Str""));
  Block b62=createNextBlock(b60,chainHeadHeight + 19,null,null);
{
    Transaction tx=new Transaction(params);
    tx.setLockTime(0xffffffffL);
    tx.addOutput(ZERO,OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(tx,out18,0);
    b62.addTransaction(tx);
    checkState(!tx.isFinal(chainHeadHeight + 17,b62.getTimeSeconds()));
  }
  b62.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b62,false,true,b60.getHash(),chainHeadHeight + 18,""String_Node_Str""));
  Block b63=createNextBlock(b60,chainHeadHeight + 19,null,null);
{
    b63.getTransactions().get(0).setLockTime(0xffffffffL);
    b63.getTransactions().get(0).getInputs().get(0).setSequenceNumber(0xDEADBEEF);
    checkState(!b63.getTransactions().get(0).isFinal(chainHeadHeight + 17,b63.getTimeSeconds()));
  }
  b63.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b63,false,true,b60.getHash(),chainHeadHeight + 18,""String_Node_Str""));
  Block b64;
{
    Block b64Created=createNextBlock(b60,chainHeadHeight + 19,out18,null);
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIZE - b64Created.getMessageSize() - 138];
    Arrays.fill(outputScript,(byte)OP_FALSE);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b64Created.getTransactions().get(1).getHash()),SATOSHI,b64Created.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b64Created.addTransaction(tx);
    b64Created.solve();
    UnsafeByteArrayOutputStream stream=new UnsafeByteArrayOutputStream(b64Created.getMessageSize() + 8);
    b64Created.writeHeader(stream);
    byte[] varIntBytes=new byte[9];
    varIntBytes[0]=(byte)255;
    Utils.uint32ToByteArrayLE((long)b64Created.getTransactions().size(),varIntBytes,1);
    Utils.uint32ToByteArrayLE(((long)b64Created.getTransactions().size()) >>> 32,varIntBytes,5);
    stream.write(varIntBytes);
    checkState(new VarInt(varIntBytes,0).value == b64Created.getTransactions().size());
    for (    Transaction transaction : b64Created.getTransactions())     transaction.bitcoinSerialize(stream);
    b64=new Block(params,stream.toByteArray(),false,true,stream.size());
    checkState(stream.size() == b64Created.getMessageSize() + 8);
    checkState(stream.size() == b64.getMessageSize());
    checkState(Arrays.equals(stream.toByteArray(),b64.bitcoinSerialize()));
    checkState(b64.getOptimalEncodingMessageSize() == b64Created.getMessageSize());
  }
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b64,true,false,b64.getHash(),chainHeadHeight + 19,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b64.getTransactions().get(0).getHash()),b64.getTransactions().get(0).getOutputs().get(0).getValue(),b64.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out19=spendableOutputs.poll();
  checkState(out19 != null);
  Block b65=createNextBlock(b64,chainHeadHeight + 20,null,null);
{
    Transaction tx1=new Transaction(params);
    tx1.addOutput(out19.value,OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(tx1,out19,0);
    b65.addTransaction(tx1);
    Transaction tx2=new Transaction(params);
    tx2.addOutput(ZERO,OP_TRUE_SCRIPT);
    tx2.addInput(tx1.getHash(),0,OP_TRUE_SCRIPT);
    b65.addTransaction(tx2);
  }
  b65.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b65,true,false,b65.getHash(),chainHeadHeight + 20,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b65.getTransactions().get(0).getHash()),b65.getTransactions().get(0).getOutputs().get(0).getValue(),b65.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out20=spendableOutputs.poll();
  checkState(out20 != null);
  Block b66=createNextBlock(b65,chainHeadHeight + 21,null,null);
{
    Transaction tx1=new Transaction(params);
    tx1.addOutput(out20.value,OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(tx1,out20,0);
    Transaction tx2=new Transaction(params);
    tx2.addOutput(ZERO,OP_TRUE_SCRIPT);
    tx2.addInput(tx1.getHash(),0,OP_NOP_SCRIPT);
    b66.addTransaction(tx2);
    b66.addTransaction(tx1);
  }
  b66.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b66,false,true,b65.getHash(),chainHeadHeight + 20,""String_Node_Str""));
  Block b67=createNextBlock(b65,chainHeadHeight + 21,null,null);
{
    Transaction tx1=new Transaction(params);
    tx1.addOutput(out20.value,OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(tx1,out20,0);
    b67.addTransaction(tx1);
    Transaction tx2=new Transaction(params);
    tx2.addOutput(ZERO,OP_TRUE_SCRIPT);
    tx2.addInput(tx1.getHash(),0,OP_NOP_SCRIPT);
    b67.addTransaction(tx2);
    Transaction tx3=new Transaction(params);
    tx3.addOutput(out20.value,OP_TRUE_SCRIPT);
    tx3.addInput(tx1.getHash(),0,OP_NOP_SCRIPT);
    b67.addTransaction(tx3);
  }
  b67.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b67,false,true,b65.getHash(),chainHeadHeight + 20,""String_Node_Str""));
  Block b68=createNextBlock(b65,chainHeadHeight + 21,null,SATOSHI.multiply(10));
{
    Transaction tx=new Transaction(params);
    tx.addOutput(out20.value.subtract(Coin.valueOf(9)),OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(tx,out20,0);
    b68.addTransaction(tx);
  }
  b68.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b68,false,true,b65.getHash(),chainHeadHeight + 20,""String_Node_Str""));
  Block b69=createNextBlock(b65,chainHeadHeight + 21,null,SATOSHI.multiply(10));
{
    Transaction tx=new Transaction(params);
    tx.addOutput(out20.value.subtract(Coin.valueOf(10)),OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(tx,out20,0);
    b69.addTransaction(tx);
  }
  b69.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b69,true,false,b69.getHash(),chainHeadHeight + 21,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b69.getTransactions().get(0).getHash()),b69.getTransactions().get(0).getOutputs().get(0).getValue(),b69.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out21=spendableOutputs.poll();
  checkState(out21 != null);
  Block b70=createNextBlock(b69,chainHeadHeight + 22,out21,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(ZERO,OP_TRUE_SCRIPT);
    tx.addInput(new Sha256Hash(""String_Node_Str""),0,OP_NOP_SCRIPT);
    b70.addTransaction(tx);
  }
  b70.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b70,false,true,b69.getHash(),chainHeadHeight + 21,""String_Node_Str""));
  Block b72=createNextBlock(b69,chainHeadHeight + 22,out21,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(ZERO,OP_TRUE_SCRIPT);
    final Transaction tx2=b72.getTransactions().get(1);
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,tx2.getHash()),SATOSHI,tx2.getOutput(1).getScriptPubKey()));
    b72.addTransaction(tx);
  }
  b72.solve();
  Block b71=new Block(params,b72.bitcoinSerialize());
  b71.addTransaction(b72.getTransactions().get(2));
  checkState(b71.getHash().equals(b72.getHash()));
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b71,false,true,b69.getHash(),chainHeadHeight + 21,""String_Node_Str""));
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b72,true,false,b72.getHash(),chainHeadHeight + 22,""String_Node_Str""));
  final Transaction b72tx=b72.getTransactions().get(0);
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b72tx.getHash()),b72tx.getOutput(0).getValue(),b72tx.getOutput(0).getScriptPubKey()));
  TransactionOutPointWithValue out22=spendableOutputs.poll();
  checkState(out22 != null);
  Block b73=createNextBlock(b72,chainHeadHeight + 23,out22,null);
{
    int sigOps=0;
    for (    Transaction tx : b73.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + (int)Script.MAX_SCRIPT_ELEMENT_SIZE + 1 + 5 + 1];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps]=OP_PUSHDATA4;
    Utils.uint32ToByteArrayLE(Script.MAX_SCRIPT_ELEMENT_SIZE + 1,outputScript,Block.MAX_BLOCK_SIGOPS - sigOps + 1);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b73.getTransactions().get(1).getHash()),SATOSHI,b73.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b73.addTransaction(tx);
  }
  b73.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b73,false,true,b72.getHash(),chainHeadHeight + 22,""String_Node_Str""));
  Block b74=createNextBlock(b72,chainHeadHeight + 23,out22,null);
{
    int sigOps=0;
    for (    Transaction tx : b74.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + (int)Script.MAX_SCRIPT_ELEMENT_SIZE + 42];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 1]=OP_PUSHDATA4;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 2]=(byte)0xfe;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 3]=(byte)0xff;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 4]=(byte)0xff;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 5]=(byte)0xff;
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b74.getTransactions().get(1).getHash()),SATOSHI,b74.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b74.addTransaction(tx);
  }
  b74.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b74,false,true,b72.getHash(),chainHeadHeight + 22,""String_Node_Str""));
  Block b75=createNextBlock(b72,chainHeadHeight + 23,out22,null);
{
    int sigOps=0;
    for (    Transaction tx : b75.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + (int)Script.MAX_SCRIPT_ELEMENT_SIZE + 42];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps]=OP_PUSHDATA4;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 1]=(byte)0xff;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 2]=(byte)0xff;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 3]=(byte)0xff;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 4]=(byte)0xff;
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b75.getTransactions().get(1).getHash()),SATOSHI,b75.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b75.addTransaction(tx);
  }
  b75.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b75,true,false,b75.getHash(),chainHeadHeight + 23,""String_Node_Str""));
  final Transaction b75tx=b75.getTransactions().get(0);
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b75tx.getHash()),b75tx.getOutput(0).getValue(),b75tx.getOutput(0).getScriptPubKey()));
  TransactionOutPointWithValue out23=spendableOutputs.poll();
  checkState(out23 != null);
  Block b76=createNextBlock(b75,chainHeadHeight + 24,out23,null);
{
    int sigOps=0;
    for (    Transaction tx : b76.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + (int)Script.MAX_SCRIPT_ELEMENT_SIZE + 1 + 5];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps]=OP_PUSHDATA4;
    Utils.uint32ToByteArrayLE(Block.MAX_BLOCK_SIGOPS,outputScript,Block.MAX_BLOCK_SIGOPS - sigOps + 1);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b76.getTransactions().get(1).getHash()),SATOSHI,b76.getTransactions().get(1).getOutput(1).getScriptPubKey()));
    b76.addTransaction(tx);
  }
  b76.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b76,true,false,b76.getHash(),chainHeadHeight + 24,""String_Node_Str""));
  final Transaction b76tx=b76.getTransactions().get(0);
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b76tx.getHash()),b76tx.getOutput(0).getValue(),b76tx.getOutput(0).getScriptPubKey()));
  TransactionOutPointWithValue out24=checkNotNull(spendableOutputs.poll());
  TransactionOutPointWithValue out25=checkNotNull(spendableOutputs.poll());
  TransactionOutPointWithValue out26=checkNotNull(spendableOutputs.poll());
  TransactionOutPointWithValue out27=checkNotNull(spendableOutputs.poll());
  Block b77=createNextBlock(b76,chainHeadHeight + 25,out24,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b77,true,false,b77.getHash(),chainHeadHeight + 25,""String_Node_Str""));
  Block b78=createNextBlock(b77,chainHeadHeight + 26,out25,null);
  Transaction b78tx=new Transaction(params);
{
    b78tx.addOutput(ZERO,OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(b78tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b77.getTransactions().get(1).getHash()),SATOSHI,b77.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b78.addTransaction(b78tx);
  }
  b78.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b78,true,false,b78.getHash(),chainHeadHeight + 26,""String_Node_Str""));
  Block b79=createNextBlock(b78,chainHeadHeight + 27,out26,null);
  Transaction b79tx=new Transaction(params);
{
    b79tx.addOutput(ZERO,OP_TRUE_SCRIPT);
    b79tx.addInput(b78tx.getHash(),0,OP_NOP_SCRIPT);
    b79.addTransaction(b79tx);
  }
  b79.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b79,true,false,b79.getHash(),chainHeadHeight + 27,""String_Node_Str""));
  blocks.add(new MemoryPoolState(new HashSet<InventoryItem>(),""String_Node_Str""));
  Block b80=createNextBlock(b77,chainHeadHeight + 26,out25,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b80,true,false,b79.getHash(),chainHeadHeight + 27,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b80.getTransactions().get(0).getHash()),b80.getTransactions().get(0).getOutput(0).getValue(),b80.getTransactions().get(0).getOutput(0).getScriptPubKey()));
  Block b81=createNextBlock(b80,chainHeadHeight + 27,out26,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b81,true,false,b79.getHash(),chainHeadHeight + 27,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b81.getTransactions().get(0).getHash()),b81.getTransactions().get(0).getOutput(0).getValue(),b81.getTransactions().get(0).getOutput(0).getScriptPubKey()));
  Block b82=createNextBlock(b81,chainHeadHeight + 28,out27,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b82,true,false,b82.getHash(),chainHeadHeight + 28,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b82.getTransactions().get(0).getHash()),b82.getTransactions().get(0).getOutput(0).getValue(),b82.getTransactions().get(0).getOutput(0).getScriptPubKey()));
  HashSet<InventoryItem> post82Mempool=new HashSet<InventoryItem>();
  post82Mempool.add(new InventoryItem(InventoryItem.Type.Transaction,b78tx.getHash()));
  post82Mempool.add(new InventoryItem(InventoryItem.Type.Transaction,b79tx.getHash()));
  blocks.add(new MemoryPoolState(post82Mempool,""String_Node_Str""));
{
    TransactionOutPoint outpoint=new TransactionOutPoint(params,0,b79tx.getHash());
    long[] heights=new long[]{UTXOsMessage.MEMPOOL_HEIGHT};
    UTXOsMessage result=new UTXOsMessage(params,ImmutableList.of(b79tx.getOutput(0)),heights,b82.getHash(),chainHeadHeight + 28);
    UTXORule utxo3=new UTXORule(""String_Node_Str"",outpoint,result);
    blocks.add(utxo3);
  }
  TransactionOutPointWithValue out28=spendableOutputs.poll();
  Preconditions.checkState(out28 != null);
  Block b83=createNextBlock(b82,chainHeadHeight + 29,null,null);
{
    Transaction tx1=new Transaction(params);
    tx1.addOutput(new TransactionOutput(params,tx1,out28.value,new byte[]{OP_IF,(byte)OP_INVALIDOPCODE,OP_ELSE,OP_TRUE,OP_ENDIF}));
    addOnlyInputToTransaction(tx1,out28,0);
    b83.addTransaction(tx1);
    Transaction tx2=new Transaction(params);
    tx2.addOutput(new TransactionOutput(params,tx2,BigInteger.ZERO,new byte[]{OP_TRUE}));
    tx2.addInput(new TransactionInput(params,tx2,new byte[]{OP_FALSE},new TransactionOutPoint(params,0,tx1.getHash())));
    b83.addTransaction(tx2);
  }
  b83.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b83,true,false,b83.getHash(),chainHeadHeight + 29,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b83.getTransactions().get(0).getHash()),b83.getTransactions().get(0).getOutputs().get(0).getValue(),b83.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out29=spendableOutputs.poll();
  checkState(out29 != null);
  Block b1001=createNextBlock(b83,chainHeadHeight + 30,out29,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b1001,true,false,b1001.getHash(),chainHeadHeight + 30,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b1001.getTransactions().get(0).getHash()),b1001.getTransactions().get(0).getOutputs().get(0).getValue(),b1001.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  int heightAfter1001=chainHeadHeight + 31;
  if (runLargeReorgs) {
    Preconditions.checkArgument(blockStorageFile != null);
    Block lastBlock=b1001;
    TransactionOutPoint lastOutput=new TransactionOutPoint(params,2,b1001.getTransactions().get(1).getHash());
    int blockCountAfter1001;
    int nextHeight=heightAfter1001;
    List<Sha256Hash> hashesToSpend=new LinkedList<Sha256Hash>();
    final int TRANSACTION_CREATION_BLOCKS=100;
    for (blockCountAfter1001=0; blockCountAfter1001 < TRANSACTION_CREATION_BLOCKS; blockCountAfter1001++) {
      Block block=createNextBlock(lastBlock,nextHeight++,null,null);
      while (block.getMessageSize() < Block.MAX_BLOCK_SIZE - 500) {
        Transaction tx=new Transaction(params);
        tx.addInput(lastOutput.getHash(),lastOutput.getIndex(),OP_NOP_SCRIPT);
        tx.addOutput(ZERO,OP_TRUE_SCRIPT);
        tx.addOutput(ZERO,OP_TRUE_SCRIPT);
        lastOutput=new TransactionOutPoint(params,1,tx.getHash());
        hashesToSpend.add(tx.getHash());
        block.addTransaction(tx);
      }
      block.solve();
      blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,block,true,false,block.getHash(),nextHeight - 1,""String_Node_Str"" + blockCountAfter1001 + ""String_Node_Str""+ TRANSACTION_CREATION_BLOCKS));
      lastBlock=block;
    }
    Iterator<Sha256Hash> hashes=hashesToSpend.iterator();
    for (int i=0; hashes.hasNext(); i++) {
      Block block=createNextBlock(lastBlock,nextHeight++,null,null);
      while (block.getMessageSize() < Block.MAX_BLOCK_SIZE - 500 && hashes.hasNext()) {
        Transaction tx=new Transaction(params);
        tx.addInput(hashes.next(),0,OP_NOP_SCRIPT);
        tx.addOutput(ZERO,OP_TRUE_SCRIPT);
        block.addTransaction(tx);
      }
      block.solve();
      blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,block,true,false,block.getHash(),nextHeight - 1,""String_Node_Str"" + i));
      lastBlock=block;
      blockCountAfter1001++;
    }
    Sha256Hash firstHash=lastBlock.getHash();
    int height=nextHeight - 1;
    nextHeight=heightAfter1001;
    lastBlock=b1001;
    for (int i=0; i < blockCountAfter1001; i++) {
      Block block=createNextBlock(lastBlock,nextHeight++,null,null);
      blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,block,true,false,firstHash,height,""String_Node_Str"" + i + ""String_Node_Str""+ blockCountAfter1001));
      lastBlock=block;
    }
    Block b1002=createNextBlock(lastBlock,nextHeight,null,null);
{
      Transaction tx=new Transaction(params);
      tx.addInput(hashesToSpend.get(0),0,OP_NOP_SCRIPT);
      tx.addOutput(ZERO,OP_TRUE_SCRIPT);
      b1002.addTransaction(tx);
    }
    b1002.solve();
    blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b1002,false,true,firstHash,height,""String_Node_Str""));
    Block b1003=createNextBlock(lastBlock,nextHeight,null,null);
    blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b1003,true,false,b1003.getHash(),nextHeight,""String_Node_Str""));
    Block b1004=createNextBlock(b1003,nextHeight + 1,null,null);
{
      Transaction tx=new Transaction(params);
      tx.addInput(hashesToSpend.get(0),0,OP_NOP_SCRIPT);
      tx.addOutput(ZERO,OP_TRUE_SCRIPT);
      b1004.addTransaction(tx);
    }
    b1004.solve();
    blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b1004,false,true,b1003.getHash(),nextHeight,""String_Node_Str""));
    ret.maximumReorgBlockCount=Math.max(ret.maximumReorgBlockCount,blockCountAfter1001);
  }
  if (outStream != null)   outStream.close();
  return ret;
}","public RuleList getBlocksToTest(boolean addSigExpensiveBlocks,boolean runLargeReorgs,File blockStorageFile) throws ScriptException, ProtocolException, IOException {
  final FileOutputStream outStream=blockStorageFile != null ? new FileOutputStream(blockStorageFile) : null;
  final Script OP_TRUE_SCRIPT=new ScriptBuilder().op(OP_TRUE).build();
  final Script OP_NOP_SCRIPT=new ScriptBuilder().op(OP_NOP).build();
  List<Rule> blocks=new LinkedList<Rule>(){
    @Override public boolean add(    Rule element){
      if (outStream != null && element instanceof BlockAndValidity) {
        try {
          outStream.write((int)(params.getPacketMagic() >>> 24));
          outStream.write((int)(params.getPacketMagic() >>> 16));
          outStream.write((int)(params.getPacketMagic() >>> 8));
          outStream.write((int)(params.getPacketMagic() >>> 0));
          byte[] block=((BlockAndValidity)element).block.bitcoinSerialize();
          byte[] length=new byte[4];
          Utils.uint32ToByteArrayBE(block.length,length,0);
          outStream.write(Utils.reverseBytes(length));
          outStream.write(block);
          ((BlockAndValidity)element).block=null;
        }
 catch (        IOException e) {
          throw new RuntimeException(e);
        }
      }
      return super.add(element);
    }
  }
;
  RuleList ret=new RuleList(blocks,hashHeaderMap,10);
  Queue<TransactionOutPointWithValue> spendableOutputs=new LinkedList<TransactionOutPointWithValue>();
  int chainHeadHeight=1;
  Block chainHead=params.getGenesisBlock().createNextBlockWithCoinbase(coinbaseOutKeyPubKey);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,chainHead,true,false,chainHead.getHash(),1,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,chainHead.getTransactions().get(0).getHash()),FIFTY_COINS,chainHead.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  for (int i=1; i < params.getSpendableCoinbaseDepth(); i++) {
    chainHead=chainHead.createNextBlockWithCoinbase(coinbaseOutKeyPubKey);
    chainHeadHeight++;
    blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,chainHead,true,false,chainHead.getHash(),i + 1,""String_Node_Str""));
    spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,chainHead.getTransactions().get(0).getHash()),FIFTY_COINS,chainHead.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  }
  Block b1=createNextBlock(chainHead,chainHeadHeight + 1,spendableOutputs.poll(),null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b1,true,false,b1.getHash(),chainHeadHeight + 1,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b1.getTransactions().get(0).getHash()),b1.getTransactions().get(0).getOutputs().get(0).getValue(),b1.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out1=spendableOutputs.poll();
  checkState(out1 != null);
  Block b2=createNextBlock(b1,chainHeadHeight + 2,out1,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b2,true,false,b2.getHash(),chainHeadHeight + 2,""String_Node_Str""));
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b2,true,false,b2.getHash(),chainHeadHeight + 2,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b2.getTransactions().get(0).getHash()),b2.getTransactions().get(0).getOutput(0).getValue(),b2.getTransactions().get(0).getOutput(0).getScriptPubKey()));
  Block b3=createNextBlock(b1,chainHeadHeight + 2,out1,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b3,true,false,b2.getHash(),chainHeadHeight + 2,""String_Node_Str""));
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b3,true,false,b2.getHash(),chainHeadHeight + 2,""String_Node_Str""));
  UTXORule utxo1;
{
    Transaction coinbase=b2.getTransactions().get(0);
    TransactionOutPoint outpoint=new TransactionOutPoint(params,0,coinbase.getHash());
    long[] heights=new long[]{chainHeadHeight + 2};
    UTXOsMessage result=new UTXOsMessage(params,ImmutableList.of(coinbase.getOutput(0)),heights,b2.getHash(),chainHeadHeight + 2);
    utxo1=new UTXORule(""String_Node_Str"",outpoint,result);
    blocks.add(utxo1);
  }
  TransactionOutPointWithValue out2=checkNotNull(spendableOutputs.poll());
  Block b4=createNextBlock(b3,chainHeadHeight + 3,out2,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b4,true,false,b4.getHash(),chainHeadHeight + 3,""String_Node_Str""));
{
    Transaction coinbase=b4.getTransactions().get(0);
    TransactionOutPoint outpoint=new TransactionOutPoint(params,0,coinbase.getHash());
    List<TransactionOutPoint> queries=ImmutableList.of(utxo1.query.get(0),outpoint);
    List<TransactionOutput> results=Lists.asList(null,coinbase.getOutput(0),new TransactionOutput[]{});
    long[] heights=new long[]{chainHeadHeight + 3};
    UTXOsMessage result=new UTXOsMessage(params,results,heights,b4.getHash(),chainHeadHeight + 3);
    UTXORule utxo2=new UTXORule(""String_Node_Str"",queries,result);
    blocks.add(utxo2);
  }
  Block b5=createNextBlock(b2,chainHeadHeight + 3,out2,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b5,true,false,b4.getHash(),chainHeadHeight + 3,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b5.getTransactions().get(0).getHash()),b5.getTransactions().get(0).getOutputs().get(0).getValue(),b5.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out3=spendableOutputs.poll();
  Block b6=createNextBlock(b5,chainHeadHeight + 4,out3,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b6,true,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  Block b7=createNextBlock(b5,chainHeadHeight + 5,out2,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b7,true,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  TransactionOutPointWithValue out4=spendableOutputs.poll();
  Block b8=createNextBlock(b7,chainHeadHeight + 6,out4,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b8,false,true,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  Block b9=createNextBlock(b6,chainHeadHeight + 5,out4,SATOSHI);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b9,false,true,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  Block b10=createNextBlock(b5,chainHeadHeight + 4,out3,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b10,true,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  Block b11=createNextBlock(b10,chainHeadHeight + 5,out4,SATOSHI);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b11,false,true,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  Block b12=createNextBlock(b5,chainHeadHeight + 4,out3,null);
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b12.getTransactions().get(0).getHash()),b12.getTransactions().get(0).getOutputs().get(0).getValue(),b12.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  Block b13=createNextBlock(b12,chainHeadHeight + 5,out4,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b13,false,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b13,false,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b13.getTransactions().get(0).getHash()),b13.getTransactions().get(0).getOutputs().get(0).getValue(),b13.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out5=spendableOutputs.poll();
  Block b14=createNextBlock(b13,chainHeadHeight + 6,out5,SATOSHI);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b14,false,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b14,false,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b12,false,true,b13.getHash(),chainHeadHeight + 5,""String_Node_Str""));
  Block b15=createNextBlock(b13,chainHeadHeight + 6,out5,null);
{
    int sigOps=0;
    for (    Transaction tx : b15.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b15.getTransactions().get(1).getHash()),SATOSHI,b15.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b15.addTransaction(tx);
  }
  b15.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b15,true,false,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b15.getTransactions().get(0).getHash()),b15.getTransactions().get(0).getOutputs().get(0).getValue(),b15.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out6=spendableOutputs.poll();
  Block b16=createNextBlock(b15,chainHeadHeight + 7,out6,null);
{
    int sigOps=0;
    for (    Transaction tx : b16.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + 1];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b16.getTransactions().get(1).getHash()),SATOSHI,b16.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b16.addTransaction(tx);
  }
  b16.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b16,false,true,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  Block b17=createNextBlock(b15,chainHeadHeight + 7,out6,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,new byte[]{}));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b3.getTransactions().get(1).getHash()),SATOSHI,b3.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b17.addTransaction(tx);
  }
  b17.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b17,false,true,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  Block b18=createNextBlock(b13,chainHeadHeight + 6,out5,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,new byte[]{}));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b3.getTransactions().get(1).getHash()),SATOSHI,b3.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b18.addTransaction(tx);
  }
  b18.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b18,true,false,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  Block b19=createNextBlock(b18,chainHeadHeight + 7,out6,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b19,false,true,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  TransactionOutPointWithValue out7=spendableOutputs.poll();
  Block b20=createNextBlock(b15,chainHeadHeight + 7,out7,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b20,false,true,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  Block b21=createNextBlock(b13,chainHeadHeight + 6,out6,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b21,true,false,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  Block b22=createNextBlock(b21,chainHeadHeight + 7,out5,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b22,false,true,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  Block b23=createNextBlock(b15,chainHeadHeight + 7,out6,null);
{
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIZE - b23.getMessageSize() - 138];
    Arrays.fill(outputScript,(byte)OP_FALSE);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b23.getTransactions().get(1).getHash()),SATOSHI,b23.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b23.addTransaction(tx);
  }
  b23.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b23,true,false,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b23.getTransactions().get(0).getHash()),b23.getTransactions().get(0).getOutputs().get(0).getValue(),b23.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  Block b24=createNextBlock(b15,chainHeadHeight + 7,out6,null);
{
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIZE - b24.getMessageSize() - 135];
    Arrays.fill(outputScript,(byte)OP_FALSE);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b24.getTransactions().get(1).getHash()),SATOSHI,b24.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b24.addTransaction(tx);
  }
  b24.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b24,false,true,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  Block b25=createNextBlock(b24,chainHeadHeight + 8,out7,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b25,false,false,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  Block b26=createNextBlock(b15,chainHeadHeight + 7,out6,null);
  b26.getTransactions().get(0).getInputs().get(0).setScriptBytes(new byte[]{0});
  b26.setMerkleRoot(null);
  b26.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b26,false,true,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  Block b27=createNextBlock(b26,chainHeadHeight + 8,out7,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b27,false,false,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  Block b28=createNextBlock(b15,chainHeadHeight + 7,out6,null);
{
    byte[] coinbase=new byte[101];
    Arrays.fill(coinbase,(byte)0);
    b28.getTransactions().get(0).getInputs().get(0).setScriptBytes(coinbase);
  }
  b28.setMerkleRoot(null);
  b28.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b28,false,true,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  Block b29=createNextBlock(b28,chainHeadHeight + 8,out7,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b29,false,false,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  Block b30=createNextBlock(b23,chainHeadHeight + 8,out7,null);
{
    byte[] coinbase=new byte[100];
    Arrays.fill(coinbase,(byte)0);
    b30.getTransactions().get(0).getInputs().get(0).setScriptBytes(coinbase);
  }
  b30.setMerkleRoot(null);
  b30.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b30,true,false,b30.getHash(),chainHeadHeight + 8,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b30.getTransactions().get(0).getHash()),b30.getTransactions().get(0).getOutputs().get(0).getValue(),b30.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out8=spendableOutputs.poll();
  Block b31=createNextBlock(b30,chainHeadHeight + 9,out8,null);
{
    int sigOps=0;
    for (    Transaction tx : b31.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[(Block.MAX_BLOCK_SIGOPS - sigOps) / 20];
    Arrays.fill(outputScript,(byte)OP_CHECKMULTISIG);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b31.getTransactions().get(1).getHash()),SATOSHI,b31.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b31.addTransaction(tx);
  }
  b31.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b31,true,false,b31.getHash(),chainHeadHeight + 9,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b31.getTransactions().get(0).getHash()),b31.getTransactions().get(0).getOutputs().get(0).getValue(),b31.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out9=spendableOutputs.poll();
  Block b32=createNextBlock(b31,chainHeadHeight + 10,out9,null);
{
    int sigOps=0;
    for (    Transaction tx : b32.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[(Block.MAX_BLOCK_SIGOPS - sigOps) / 20 + (Block.MAX_BLOCK_SIGOPS - sigOps) % 20 + 1];
    Arrays.fill(outputScript,(byte)OP_CHECKMULTISIG);
    for (int i=0; i < (Block.MAX_BLOCK_SIGOPS - sigOps) % 20; i++)     outputScript[i]=(byte)OP_CHECKSIG;
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b32.getTransactions().get(1).getHash()),SATOSHI,b32.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b32.addTransaction(tx);
  }
  b32.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b32,false,true,b31.getHash(),chainHeadHeight + 9,""String_Node_Str""));
  Block b33=createNextBlock(b31,chainHeadHeight + 10,out9,null);
{
    int sigOps=0;
    for (    Transaction tx : b33.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[(Block.MAX_BLOCK_SIGOPS - sigOps) / 20];
    Arrays.fill(outputScript,(byte)OP_CHECKMULTISIGVERIFY);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b33.getTransactions().get(1).getHash()),SATOSHI,b33.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b33.addTransaction(tx);
  }
  b33.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b33,true,false,b33.getHash(),chainHeadHeight + 10,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b33.getTransactions().get(0).getHash()),b33.getTransactions().get(0).getOutputs().get(0).getValue(),b33.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out10=spendableOutputs.poll();
  Block b34=createNextBlock(b33,chainHeadHeight + 11,out10,null);
{
    int sigOps=0;
    for (    Transaction tx : b34.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[(Block.MAX_BLOCK_SIGOPS - sigOps) / 20 + (Block.MAX_BLOCK_SIGOPS - sigOps) % 20 + 1];
    Arrays.fill(outputScript,(byte)OP_CHECKMULTISIGVERIFY);
    for (int i=0; i < (Block.MAX_BLOCK_SIGOPS - sigOps) % 20; i++)     outputScript[i]=(byte)OP_CHECKSIG;
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b34.getTransactions().get(1).getHash()),SATOSHI,b34.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b34.addTransaction(tx);
  }
  b34.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b34,false,true,b33.getHash(),chainHeadHeight + 10,""String_Node_Str""));
  Block b35=createNextBlock(b33,chainHeadHeight + 11,out10,null);
{
    int sigOps=0;
    for (    Transaction tx : b35.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps];
    Arrays.fill(outputScript,(byte)OP_CHECKSIGVERIFY);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b35.getTransactions().get(1).getHash()),SATOSHI,b35.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b35.addTransaction(tx);
  }
  b35.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b35,true,false,b35.getHash(),chainHeadHeight + 11,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b35.getTransactions().get(0).getHash()),b35.getTransactions().get(0).getOutputs().get(0).getValue(),b35.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out11=spendableOutputs.poll();
  Block b36=createNextBlock(b35,chainHeadHeight + 12,out11,null);
{
    int sigOps=0;
    for (    Transaction tx : b36.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + 1];
    Arrays.fill(outputScript,(byte)OP_CHECKSIGVERIFY);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b36.getTransactions().get(1).getHash()),SATOSHI,b36.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b36.addTransaction(tx);
  }
  b36.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b36,false,true,b35.getHash(),chainHeadHeight + 11,""String_Node_Str""));
  Block b37=createNextBlock(b35,chainHeadHeight + 12,out11,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,new byte[]{}));
    addOnlyInputToTransaction(tx,out11);
    b37.addTransaction(tx);
  }
  b37.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b37,false,true,b35.getHash(),chainHeadHeight + 11,""String_Node_Str""));
  Block b38=createNextBlock(b35,chainHeadHeight + 12,out11,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,new byte[]{}));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b37.getTransactions().get(1).getHash()),SATOSHI,b37.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b38.addTransaction(tx);
  }
  b38.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b38,false,true,b35.getHash(),chainHeadHeight + 11,""String_Node_Str""));
  byte[] b39p2shScriptPubKey;
  int b39numP2SHOutputs=0, b39sigOpsPerOutput=6;
  Block b39=createNextBlock(b35,chainHeadHeight + 12,null,null);
{
    ByteArrayOutputStream p2shScriptPubKey=new UnsafeByteArrayOutputStream();
    try {
      Script.writeBytes(p2shScriptPubKey,coinbaseOutKeyPubKey);
      p2shScriptPubKey.write(OP_2DUP);
      p2shScriptPubKey.write(OP_CHECKSIGVERIFY);
      p2shScriptPubKey.write(OP_2DUP);
      p2shScriptPubKey.write(OP_CHECKSIGVERIFY);
      p2shScriptPubKey.write(OP_2DUP);
      p2shScriptPubKey.write(OP_CHECKSIGVERIFY);
      p2shScriptPubKey.write(OP_2DUP);
      p2shScriptPubKey.write(OP_CHECKSIGVERIFY);
      p2shScriptPubKey.write(OP_2DUP);
      p2shScriptPubKey.write(OP_CHECKSIGVERIFY);
      p2shScriptPubKey.write(OP_CHECKSIG);
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
    b39p2shScriptPubKey=p2shScriptPubKey.toByteArray();
    byte[] scriptHash=Utils.sha256hash160(b39p2shScriptPubKey);
    UnsafeByteArrayOutputStream scriptPubKey=new UnsafeByteArrayOutputStream(scriptHash.length + 3);
    scriptPubKey.write(OP_HASH160);
    try {
      Script.writeBytes(scriptPubKey,scriptHash);
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
    scriptPubKey.write(OP_EQUAL);
    Coin lastOutputValue=out11.value.subtract(SATOSHI);
    TransactionOutPoint lastOutPoint;
{
      Transaction tx=new Transaction(params);
      tx.addOutput(new TransactionOutput(params,tx,SATOSHI,scriptPubKey.toByteArray()));
      tx.addOutput(new TransactionOutput(params,tx,lastOutputValue,new byte[]{OP_1}));
      addOnlyInputToTransaction(tx,out11);
      lastOutPoint=new TransactionOutPoint(params,1,tx.getHash());
      b39.addTransaction(tx);
    }
    b39numP2SHOutputs++;
    while (b39.getMessageSize() < Block.MAX_BLOCK_SIZE) {
      Transaction tx=new Transaction(params);
      lastOutputValue=lastOutputValue.subtract(SATOSHI);
      tx.addOutput(new TransactionOutput(params,tx,SATOSHI,scriptPubKey.toByteArray()));
      tx.addOutput(new TransactionOutput(params,tx,lastOutputValue,new byte[]{OP_1}));
      tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},lastOutPoint));
      lastOutPoint=new TransactionOutPoint(params,1,tx.getHash());
      if (b39.getMessageSize() + tx.getMessageSize() < Block.MAX_BLOCK_SIZE) {
        b39.addTransaction(tx);
        b39numP2SHOutputs++;
      }
 else       break;
    }
  }
  b39.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b39,true,false,b39.getHash(),chainHeadHeight + 12,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b39.getTransactions().get(0).getHash()),b39.getTransactions().get(0).getOutputs().get(0).getValue(),b39.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out12=spendableOutputs.poll();
  Block b40=createNextBlock(b39,chainHeadHeight + 13,out12,null);
{
    int sigOps=0;
    for (    Transaction tx : b40.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    int numTxes=(Block.MAX_BLOCK_SIGOPS - sigOps) / b39sigOpsPerOutput;
    checkState(numTxes <= b39numP2SHOutputs);
    TransactionOutPoint lastOutPoint=new TransactionOutPoint(params,2,b40.getTransactions().get(1).getHash());
    byte[] scriptSig=null;
    for (int i=1; i <= numTxes; i++) {
      Transaction tx=new Transaction(params);
      tx.addOutput(new TransactionOutput(params,tx,SATOSHI,new byte[]{OP_1}));
      tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},lastOutPoint));
      TransactionInput input=new TransactionInput(params,tx,new byte[]{},new TransactionOutPoint(params,0,b39.getTransactions().get(i).getHash()));
      tx.addInput(input);
      if (scriptSig == null) {
        Sha256Hash hash=tx.hashForSignature(1,b39p2shScriptPubKey,SigHash.SINGLE,false);
        try {
          ByteArrayOutputStream bos=new UnsafeByteArrayOutputStream(73);
          bos.write(coinbaseOutKey.sign(hash).encodeToDER());
          bos.write(SigHash.SINGLE.ordinal() + 1);
          byte[] signature=bos.toByteArray();
          ByteArrayOutputStream scriptSigBos=new UnsafeByteArrayOutputStream(signature.length + b39p2shScriptPubKey.length + 3);
          Script.writeBytes(scriptSigBos,new byte[]{(byte)OP_CHECKSIG});
          scriptSigBos.write(Script.createInputScript(signature));
          Script.writeBytes(scriptSigBos,b39p2shScriptPubKey);
          scriptSig=scriptSigBos.toByteArray();
        }
 catch (        IOException e) {
          throw new RuntimeException(e);
        }
      }
      input.setScriptBytes(scriptSig);
      lastOutPoint=new TransactionOutPoint(params,0,tx.getHash());
      b40.addTransaction(tx);
    }
    sigOps+=numTxes * b39sigOpsPerOutput;
    Transaction tx=new Transaction(params);
    tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},lastOutPoint));
    byte[] scriptPubKey=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + 1];
    Arrays.fill(scriptPubKey,(byte)OP_CHECKSIG);
    tx.addOutput(new TransactionOutput(params,tx,ZERO,scriptPubKey));
    b40.addTransaction(tx);
  }
  b40.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b40,false,true,b39.getHash(),chainHeadHeight + 12,""String_Node_Str""));
  Block b41=null;
  if (addSigExpensiveBlocks) {
    b41=createNextBlock(b39,chainHeadHeight + 13,out12,null);
{
      int sigOps=0;
      for (      Transaction tx : b41.transactions) {
        sigOps+=tx.getSigOpCount();
      }
      int numTxes=(Block.MAX_BLOCK_SIGOPS - sigOps) / b39sigOpsPerOutput;
      checkState(numTxes <= b39numP2SHOutputs);
      TransactionOutPoint lastOutPoint=new TransactionOutPoint(params,2,b41.getTransactions().get(1).getHash());
      byte[] scriptSig=null;
      for (int i=1; i <= numTxes; i++) {
        Transaction tx=new Transaction(params);
        tx.addOutput(new TransactionOutput(params,tx,Coin.SATOSHI,new byte[]{OP_1}));
        tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},lastOutPoint));
        TransactionInput input=new TransactionInput(params,tx,new byte[]{},new TransactionOutPoint(params,0,b39.getTransactions().get(i).getHash()));
        tx.addInput(input);
        if (scriptSig == null) {
          Sha256Hash hash=tx.hashForSignature(1,b39p2shScriptPubKey,SigHash.SINGLE,false);
          try {
            ByteArrayOutputStream bos=new UnsafeByteArrayOutputStream(73);
            bos.write(coinbaseOutKey.sign(hash).encodeToDER());
            bos.write(SigHash.SINGLE.ordinal() + 1);
            byte[] signature=bos.toByteArray();
            ByteArrayOutputStream scriptSigBos=new UnsafeByteArrayOutputStream(signature.length + b39p2shScriptPubKey.length + 3);
            Script.writeBytes(scriptSigBos,new byte[]{(byte)OP_CHECKSIG});
            scriptSigBos.write(Script.createInputScript(signature));
            Script.writeBytes(scriptSigBos,b39p2shScriptPubKey);
            scriptSig=scriptSigBos.toByteArray();
          }
 catch (          IOException e) {
            throw new RuntimeException(e);
          }
        }
        input.setScriptBytes(scriptSig);
        lastOutPoint=new TransactionOutPoint(params,0,tx.getHash());
        b41.addTransaction(tx);
      }
      sigOps+=numTxes * b39sigOpsPerOutput;
      Transaction tx=new Transaction(params);
      tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},lastOutPoint));
      byte[] scriptPubKey=new byte[Block.MAX_BLOCK_SIGOPS - sigOps];
      Arrays.fill(scriptPubKey,(byte)OP_CHECKSIG);
      tx.addOutput(new TransactionOutput(params,tx,ZERO,scriptPubKey));
      b41.addTransaction(tx);
    }
    b41.solve();
    blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b41,true,false,b41.getHash(),chainHeadHeight + 13,""String_Node_Str""));
  }
  Block b42=createNextBlock(b39,chainHeadHeight + 13,out12,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b42,true,false,b41 == null ? b42.getHash() : b41.getHash(),chainHeadHeight + 13,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b42.getTransactions().get(0).getHash()),b42.getTransactions().get(0).getOutputs().get(0).getValue(),b42.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out13=spendableOutputs.poll();
  Block b43=createNextBlock(b42,chainHeadHeight + 14,out13,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b43,true,false,b43.getHash(),chainHeadHeight + 14,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b43.getTransactions().get(0).getHash()),b43.getTransactions().get(0).getOutputs().get(0).getValue(),b43.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out14=spendableOutputs.poll();
  Block b44=new Block(params);
  byte[] outScriptBytes=ScriptBuilder.createOutputScript(ECKey.fromPublicOnly(coinbaseOutKeyPubKey)).getProgram();
{
    b44.setDifficultyTarget(b43.getDifficultyTarget());
    b44.addCoinbaseTransaction(coinbaseOutKeyPubKey,ZERO);
    Transaction t=new Transaction(params);
    t.addOutput(new TransactionOutput(params,t,ZERO,new byte[]{OP_PUSHDATA1 - 1}));
    t.addOutput(new TransactionOutput(params,t,SATOSHI,outScriptBytes));
    t.addOutput(new TransactionOutput(params,t,ZERO,new byte[]{OP_1}));
    addOnlyInputToTransaction(t,out14);
    b44.addTransaction(t);
    b44.setPrevBlockHash(b43.getHash());
    b44.setTime(b43.getTimeSeconds() + 1);
  }
  b44.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b44,true,false,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  TransactionOutPointWithValue out15=spendableOutputs.poll();
  Block b45=new Block(params);
{
    b45.setDifficultyTarget(b44.getDifficultyTarget());
    Transaction t=new Transaction(params);
    t.addOutput(new TransactionOutput(params,t,ZERO,new byte[]{OP_PUSHDATA1 - 1}));
    t.addOutput(new TransactionOutput(params,t,SATOSHI,outScriptBytes));
    t.addOutput(new TransactionOutput(params,t,ZERO,new byte[]{OP_1}));
    addOnlyInputToTransaction(t,out15);
    try {
      b45.addTransaction(t);
    }
 catch (    RuntimeException e) {
    }
    if (b45.getTransactions().size() > 0)     throw new RuntimeException(""String_Node_Str"");
    b45.addTransaction(t,false);
    b45.setPrevBlockHash(b44.getHash());
    b45.setTime(b44.getTimeSeconds() + 1);
  }
  b45.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b45,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b46=new Block(params);
{
    b46.transactions=new ArrayList<Transaction>();
    b46.setDifficultyTarget(b44.getDifficultyTarget());
    b46.setMerkleRoot(Sha256Hash.ZERO_HASH);
    b46.setPrevBlockHash(b44.getHash());
    b46.setTime(b44.getTimeSeconds() + 1);
  }
  b46.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b46,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b47=createNextBlock(b44,chainHeadHeight + 16,out15,null);
{
    try {
      BigInteger target=b47.getDifficultyTargetAsInteger();
      while (true) {
        BigInteger h=b47.getHash().toBigInteger();
        if (h.compareTo(target) > 0)         break;
        b47.setNonce(b47.getNonce() + 1);
      }
    }
 catch (    VerificationException e) {
      throw new RuntimeException(e);
    }
  }
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b47,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b48=createNextBlock(b44,chainHeadHeight + 16,out15,null);
  b48.setTime(Utils.currentTimeSeconds() + 60 * 60 * 3);
  b48.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b48,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b49=createNextBlock(b44,chainHeadHeight + 16,out15,null);
  byte[] b49MerkleHash=Sha256Hash.ZERO_HASH.getBytes().clone();
  b49MerkleHash[1]=(byte)0xDE;
  b49.setMerkleRoot(Sha256Hash.create(b49MerkleHash));
  b49.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b49,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b50=createNextBlock(b44,chainHeadHeight + 16,out15,null);
{
    long diffTarget=b44.getDifficultyTarget();
    diffTarget&=0xFFBFFFFF;
    b50.setDifficultyTarget(diffTarget);
  }
  b50.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b50,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b51=createNextBlock(b44,chainHeadHeight + 16,out15,null);
{
    Transaction coinbase=new Transaction(params);
    coinbase.addInput(new TransactionInput(params,coinbase,new byte[]{(byte)0xff,110,1}));
    coinbase.addOutput(new TransactionOutput(params,coinbase,SATOSHI,outScriptBytes));
    b51.addTransaction(coinbase,false);
  }
  b51.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b51,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b52=createNextBlock(b44,chainHeadHeight + 16,out15,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,new byte[]{}));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b52.getTransactions().get(1).getHash()),SATOSHI,b52.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b52.addTransaction(tx);
    b52.addTransaction(tx);
  }
  b52.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b52,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b53=createNextBlock(b43,chainHeadHeight + 15,out14,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b53,true,false,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b53.getTransactions().get(0).getHash()),b53.getTransactions().get(0).getOutputs().get(0).getValue(),b53.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  Block b54=createNextBlock(b53,chainHeadHeight + 16,out15,null);
  b54.setTime(b35.getTimeSeconds() - 1);
  b54.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b54,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b55=createNextBlock(b53,chainHeadHeight + 16,out15,null);
  b55.setTime(b35.getTimeSeconds());
  b55.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b55,true,false,b55.getHash(),chainHeadHeight + 16,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b55.getTransactions().get(0).getHash()),b55.getTransactions().get(0).getOutputs().get(0).getValue(),b55.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out16=spendableOutputs.poll();
  Block b57=createNextBlock(b55,chainHeadHeight + 17,out16,null);
  Transaction b56txToDuplicate;
{
    b56txToDuplicate=new Transaction(params);
    b56txToDuplicate.addOutput(new TransactionOutput(params,b56txToDuplicate,SATOSHI,new byte[]{}));
    addOnlyInputToTransaction(b56txToDuplicate,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b57.getTransactions().get(1).getHash()),SATOSHI,b57.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b57.addTransaction(b56txToDuplicate);
  }
  b57.solve();
  Block b56;
  try {
    b56=new Block(params,b57.bitcoinSerialize());
  }
 catch (  ProtocolException e) {
    throw new RuntimeException(e);
  }
  b56.addTransaction(b56txToDuplicate);
  checkState(b56.getHash().equals(b57.getHash()));
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b56,false,true,b55.getHash(),chainHeadHeight + 16,""String_Node_Str""));
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b57,true,false,b57.getHash(),chainHeadHeight + 17,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b57.getTransactions().get(0).getHash()),b57.getTransactions().get(0).getOutputs().get(0).getValue(),b57.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out17=spendableOutputs.poll();
  Block b58=createNextBlock(b57,chainHeadHeight + 18,out17,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,ZERO,new byte[]{}));
    tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},new TransactionOutPoint(params,3,b58.getTransactions().get(1).getHash())));
    b58.addTransaction(tx);
  }
  b58.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b58,false,true,b57.getHash(),chainHeadHeight + 17,""String_Node_Str""));
  Block b59=createNextBlock(b57,chainHeadHeight + 18,out17,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,b59.getTransactions().get(1).getOutputs().get(2).getValue().add(SATOSHI),new byte[]{}));
    tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},new TransactionOutPoint(params,2,b59.getTransactions().get(1).getHash())));
    b59.addTransaction(tx);
  }
  b59.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b59,false,true,b57.getHash(),chainHeadHeight + 17,""String_Node_Str""));
  Block b60=createNextBlock(b57,chainHeadHeight + 18,out17,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b60,true,false,b60.getHash(),chainHeadHeight + 18,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b60.getTransactions().get(0).getHash()),b60.getTransactions().get(0).getOutputs().get(0).getValue(),b60.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out18=spendableOutputs.poll();
  Block b61=createNextBlock(b60,chainHeadHeight + 19,out18,null);
{
    b61.getTransactions().get(0).getInput(0).setScriptBytes(b60.getTransactions().get(0).getInput(0).getScriptBytes());
    b61.unCache();
    checkState(b61.getTransactions().get(0).equals(b60.getTransactions().get(0)));
  }
  b61.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b61,false,true,b60.getHash(),chainHeadHeight + 18,""String_Node_Str""));
  Block b62=createNextBlock(b60,chainHeadHeight + 19,null,null);
{
    Transaction tx=new Transaction(params);
    tx.setLockTime(0xffffffffL);
    tx.addOutput(ZERO,OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(tx,out18,0);
    b62.addTransaction(tx);
    checkState(!tx.isFinal(chainHeadHeight + 17,b62.getTimeSeconds()));
  }
  b62.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b62,false,true,b60.getHash(),chainHeadHeight + 18,""String_Node_Str""));
  Block b63=createNextBlock(b60,chainHeadHeight + 19,null,null);
{
    b63.getTransactions().get(0).setLockTime(0xffffffffL);
    b63.getTransactions().get(0).getInputs().get(0).setSequenceNumber(0xDEADBEEF);
    checkState(!b63.getTransactions().get(0).isFinal(chainHeadHeight + 17,b63.getTimeSeconds()));
  }
  b63.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b63,false,true,b60.getHash(),chainHeadHeight + 18,""String_Node_Str""));
  Block b64;
{
    Block b64Created=createNextBlock(b60,chainHeadHeight + 19,out18,null);
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIZE - b64Created.getMessageSize() - 138];
    Arrays.fill(outputScript,(byte)OP_FALSE);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b64Created.getTransactions().get(1).getHash()),SATOSHI,b64Created.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b64Created.addTransaction(tx);
    b64Created.solve();
    UnsafeByteArrayOutputStream stream=new UnsafeByteArrayOutputStream(b64Created.getMessageSize() + 8);
    b64Created.writeHeader(stream);
    byte[] varIntBytes=new byte[9];
    varIntBytes[0]=(byte)255;
    Utils.uint32ToByteArrayLE((long)b64Created.getTransactions().size(),varIntBytes,1);
    Utils.uint32ToByteArrayLE(((long)b64Created.getTransactions().size()) >>> 32,varIntBytes,5);
    stream.write(varIntBytes);
    checkState(new VarInt(varIntBytes,0).value == b64Created.getTransactions().size());
    for (    Transaction transaction : b64Created.getTransactions())     transaction.bitcoinSerialize(stream);
    b64=new Block(params,stream.toByteArray(),false,true,stream.size());
    checkState(stream.size() == b64Created.getMessageSize() + 8);
    checkState(stream.size() == b64.getMessageSize());
    checkState(Arrays.equals(stream.toByteArray(),b64.bitcoinSerialize()));
    checkState(b64.getOptimalEncodingMessageSize() == b64Created.getMessageSize());
  }
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b64,true,false,b64.getHash(),chainHeadHeight + 19,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b64.getTransactions().get(0).getHash()),b64.getTransactions().get(0).getOutputs().get(0).getValue(),b64.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out19=spendableOutputs.poll();
  checkState(out19 != null);
  Block b65=createNextBlock(b64,chainHeadHeight + 20,null,null);
{
    Transaction tx1=new Transaction(params);
    tx1.addOutput(out19.value,OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(tx1,out19,0);
    b65.addTransaction(tx1);
    Transaction tx2=new Transaction(params);
    tx2.addOutput(ZERO,OP_TRUE_SCRIPT);
    tx2.addInput(tx1.getHash(),0,OP_TRUE_SCRIPT);
    b65.addTransaction(tx2);
  }
  b65.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b65,true,false,b65.getHash(),chainHeadHeight + 20,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b65.getTransactions().get(0).getHash()),b65.getTransactions().get(0).getOutputs().get(0).getValue(),b65.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out20=spendableOutputs.poll();
  checkState(out20 != null);
  Block b66=createNextBlock(b65,chainHeadHeight + 21,null,null);
{
    Transaction tx1=new Transaction(params);
    tx1.addOutput(out20.value,OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(tx1,out20,0);
    Transaction tx2=new Transaction(params);
    tx2.addOutput(ZERO,OP_TRUE_SCRIPT);
    tx2.addInput(tx1.getHash(),0,OP_NOP_SCRIPT);
    b66.addTransaction(tx2);
    b66.addTransaction(tx1);
  }
  b66.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b66,false,true,b65.getHash(),chainHeadHeight + 20,""String_Node_Str""));
  Block b67=createNextBlock(b65,chainHeadHeight + 21,null,null);
{
    Transaction tx1=new Transaction(params);
    tx1.addOutput(out20.value,OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(tx1,out20,0);
    b67.addTransaction(tx1);
    Transaction tx2=new Transaction(params);
    tx2.addOutput(ZERO,OP_TRUE_SCRIPT);
    tx2.addInput(tx1.getHash(),0,OP_NOP_SCRIPT);
    b67.addTransaction(tx2);
    Transaction tx3=new Transaction(params);
    tx3.addOutput(out20.value,OP_TRUE_SCRIPT);
    tx3.addInput(tx1.getHash(),0,OP_NOP_SCRIPT);
    b67.addTransaction(tx3);
  }
  b67.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b67,false,true,b65.getHash(),chainHeadHeight + 20,""String_Node_Str""));
  Block b68=createNextBlock(b65,chainHeadHeight + 21,null,SATOSHI.multiply(10));
{
    Transaction tx=new Transaction(params);
    tx.addOutput(out20.value.subtract(Coin.valueOf(9)),OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(tx,out20,0);
    b68.addTransaction(tx);
  }
  b68.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b68,false,true,b65.getHash(),chainHeadHeight + 20,""String_Node_Str""));
  Block b69=createNextBlock(b65,chainHeadHeight + 21,null,SATOSHI.multiply(10));
{
    Transaction tx=new Transaction(params);
    tx.addOutput(out20.value.subtract(Coin.valueOf(10)),OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(tx,out20,0);
    b69.addTransaction(tx);
  }
  b69.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b69,true,false,b69.getHash(),chainHeadHeight + 21,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b69.getTransactions().get(0).getHash()),b69.getTransactions().get(0).getOutputs().get(0).getValue(),b69.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out21=spendableOutputs.poll();
  checkState(out21 != null);
  Block b70=createNextBlock(b69,chainHeadHeight + 22,out21,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(ZERO,OP_TRUE_SCRIPT);
    tx.addInput(new Sha256Hash(""String_Node_Str""),0,OP_NOP_SCRIPT);
    b70.addTransaction(tx);
  }
  b70.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b70,false,true,b69.getHash(),chainHeadHeight + 21,""String_Node_Str""));
  Block b72=createNextBlock(b69,chainHeadHeight + 22,out21,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(ZERO,OP_TRUE_SCRIPT);
    final Transaction tx2=b72.getTransactions().get(1);
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,tx2.getHash()),SATOSHI,tx2.getOutput(1).getScriptPubKey()));
    b72.addTransaction(tx);
  }
  b72.solve();
  Block b71=new Block(params,b72.bitcoinSerialize());
  b71.addTransaction(b72.getTransactions().get(2));
  checkState(b71.getHash().equals(b72.getHash()));
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b71,false,true,b69.getHash(),chainHeadHeight + 21,""String_Node_Str""));
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b72,true,false,b72.getHash(),chainHeadHeight + 22,""String_Node_Str""));
  final Transaction b72tx=b72.getTransactions().get(0);
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b72tx.getHash()),b72tx.getOutput(0).getValue(),b72tx.getOutput(0).getScriptPubKey()));
  TransactionOutPointWithValue out22=spendableOutputs.poll();
  checkState(out22 != null);
  Block b73=createNextBlock(b72,chainHeadHeight + 23,out22,null);
{
    int sigOps=0;
    for (    Transaction tx : b73.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + (int)Script.MAX_SCRIPT_ELEMENT_SIZE + 1 + 5 + 1];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps]=OP_PUSHDATA4;
    Utils.uint32ToByteArrayLE(Script.MAX_SCRIPT_ELEMENT_SIZE + 1,outputScript,Block.MAX_BLOCK_SIGOPS - sigOps + 1);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b73.getTransactions().get(1).getHash()),SATOSHI,b73.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b73.addTransaction(tx);
  }
  b73.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b73,false,true,b72.getHash(),chainHeadHeight + 22,""String_Node_Str""));
  Block b74=createNextBlock(b72,chainHeadHeight + 23,out22,null);
{
    int sigOps=0;
    for (    Transaction tx : b74.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + (int)Script.MAX_SCRIPT_ELEMENT_SIZE + 42];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 1]=OP_PUSHDATA4;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 2]=(byte)0xfe;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 3]=(byte)0xff;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 4]=(byte)0xff;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 5]=(byte)0xff;
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b74.getTransactions().get(1).getHash()),SATOSHI,b74.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b74.addTransaction(tx);
  }
  b74.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b74,false,true,b72.getHash(),chainHeadHeight + 22,""String_Node_Str""));
  Block b75=createNextBlock(b72,chainHeadHeight + 23,out22,null);
{
    int sigOps=0;
    for (    Transaction tx : b75.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + (int)Script.MAX_SCRIPT_ELEMENT_SIZE + 42];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps]=OP_PUSHDATA4;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 1]=(byte)0xff;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 2]=(byte)0xff;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 3]=(byte)0xff;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 4]=(byte)0xff;
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b75.getTransactions().get(1).getHash()),SATOSHI,b75.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b75.addTransaction(tx);
  }
  b75.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b75,true,false,b75.getHash(),chainHeadHeight + 23,""String_Node_Str""));
  final Transaction b75tx=b75.getTransactions().get(0);
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b75tx.getHash()),b75tx.getOutput(0).getValue(),b75tx.getOutput(0).getScriptPubKey()));
  TransactionOutPointWithValue out23=spendableOutputs.poll();
  checkState(out23 != null);
  Block b76=createNextBlock(b75,chainHeadHeight + 24,out23,null);
{
    int sigOps=0;
    for (    Transaction tx : b76.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + (int)Script.MAX_SCRIPT_ELEMENT_SIZE + 1 + 5];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps]=OP_PUSHDATA4;
    Utils.uint32ToByteArrayLE(Block.MAX_BLOCK_SIGOPS,outputScript,Block.MAX_BLOCK_SIGOPS - sigOps + 1);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b76.getTransactions().get(1).getHash()),SATOSHI,b76.getTransactions().get(1).getOutput(1).getScriptPubKey()));
    b76.addTransaction(tx);
  }
  b76.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b76,true,false,b76.getHash(),chainHeadHeight + 24,""String_Node_Str""));
  final Transaction b76tx=b76.getTransactions().get(0);
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b76tx.getHash()),b76tx.getOutput(0).getValue(),b76tx.getOutput(0).getScriptPubKey()));
  TransactionOutPointWithValue out24=checkNotNull(spendableOutputs.poll());
  TransactionOutPointWithValue out25=checkNotNull(spendableOutputs.poll());
  TransactionOutPointWithValue out26=checkNotNull(spendableOutputs.poll());
  TransactionOutPointWithValue out27=checkNotNull(spendableOutputs.poll());
  Block b77=createNextBlock(b76,chainHeadHeight + 25,out24,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b77,true,false,b77.getHash(),chainHeadHeight + 25,""String_Node_Str""));
  Block b78=createNextBlock(b77,chainHeadHeight + 26,out25,null);
  Transaction b78tx=new Transaction(params);
{
    b78tx.addOutput(ZERO,OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(b78tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b77.getTransactions().get(1).getHash()),SATOSHI,b77.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b78.addTransaction(b78tx);
  }
  b78.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b78,true,false,b78.getHash(),chainHeadHeight + 26,""String_Node_Str""));
  Block b79=createNextBlock(b78,chainHeadHeight + 27,out26,null);
  Transaction b79tx=new Transaction(params);
{
    b79tx.addOutput(ZERO,OP_TRUE_SCRIPT);
    b79tx.addInput(b78tx.getHash(),0,OP_NOP_SCRIPT);
    b79.addTransaction(b79tx);
  }
  b79.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b79,true,false,b79.getHash(),chainHeadHeight + 27,""String_Node_Str""));
  blocks.add(new MemoryPoolState(new HashSet<InventoryItem>(),""String_Node_Str""));
  Block b80=createNextBlock(b77,chainHeadHeight + 26,out25,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b80,true,false,b79.getHash(),chainHeadHeight + 27,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b80.getTransactions().get(0).getHash()),b80.getTransactions().get(0).getOutput(0).getValue(),b80.getTransactions().get(0).getOutput(0).getScriptPubKey()));
  Block b81=createNextBlock(b80,chainHeadHeight + 27,out26,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b81,true,false,b79.getHash(),chainHeadHeight + 27,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b81.getTransactions().get(0).getHash()),b81.getTransactions().get(0).getOutput(0).getValue(),b81.getTransactions().get(0).getOutput(0).getScriptPubKey()));
  Block b82=createNextBlock(b81,chainHeadHeight + 28,out27,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b82,true,false,b82.getHash(),chainHeadHeight + 28,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b82.getTransactions().get(0).getHash()),b82.getTransactions().get(0).getOutput(0).getValue(),b82.getTransactions().get(0).getOutput(0).getScriptPubKey()));
  HashSet<InventoryItem> post82Mempool=new HashSet<InventoryItem>();
  post82Mempool.add(new InventoryItem(InventoryItem.Type.Transaction,b78tx.getHash()));
  post82Mempool.add(new InventoryItem(InventoryItem.Type.Transaction,b79tx.getHash()));
  blocks.add(new MemoryPoolState(post82Mempool,""String_Node_Str""));
{
    TransactionOutPoint outpoint=new TransactionOutPoint(params,0,b79tx.getHash());
    long[] heights=new long[]{UTXOsMessage.MEMPOOL_HEIGHT};
    UTXOsMessage result=new UTXOsMessage(params,ImmutableList.of(b79tx.getOutput(0)),heights,b82.getHash(),chainHeadHeight + 28);
    UTXORule utxo3=new UTXORule(""String_Node_Str"",outpoint,result);
    blocks.add(utxo3);
  }
  TransactionOutPointWithValue out28=spendableOutputs.poll();
  Preconditions.checkState(out28 != null);
  Block b83=createNextBlock(b82,chainHeadHeight + 29,null,null);
{
    Transaction tx1=new Transaction(params);
    tx1.addOutput(new TransactionOutput(params,tx1,out28.value,new byte[]{OP_IF,(byte)OP_INVALIDOPCODE,OP_ELSE,OP_TRUE,OP_ENDIF}));
    addOnlyInputToTransaction(tx1,out28,0);
    b83.addTransaction(tx1);
    Transaction tx2=new Transaction(params);
    tx2.addOutput(new TransactionOutput(params,tx2,BigInteger.ZERO,new byte[]{OP_TRUE}));
    tx2.addInput(new TransactionInput(params,tx2,new byte[]{OP_FALSE},new TransactionOutPoint(params,0,tx1.getHash())));
    b83.addTransaction(tx2);
  }
  b83.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b83,true,false,b83.getHash(),chainHeadHeight + 29,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b83.getTransactions().get(0).getHash()),b83.getTransactions().get(0).getOutputs().get(0).getValue(),b83.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out29=spendableOutputs.poll();
  checkState(out29 != null);
  Block b1001=createNextBlock(b83,chainHeadHeight + 30,out29,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b1001,true,false,b1001.getHash(),chainHeadHeight + 30,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b1001.getTransactions().get(0).getHash()),b1001.getTransactions().get(0).getOutputs().get(0).getValue(),b1001.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  int heightAfter1001=chainHeadHeight + 31;
  if (runLargeReorgs) {
    Preconditions.checkArgument(blockStorageFile != null);
    Block lastBlock=b1001;
    TransactionOutPoint lastOutput=new TransactionOutPoint(params,2,b1001.getTransactions().get(1).getHash());
    int blockCountAfter1001;
    int nextHeight=heightAfter1001;
    List<Sha256Hash> hashesToSpend=new LinkedList<Sha256Hash>();
    final int TRANSACTION_CREATION_BLOCKS=100;
    for (blockCountAfter1001=0; blockCountAfter1001 < TRANSACTION_CREATION_BLOCKS; blockCountAfter1001++) {
      Block block=createNextBlock(lastBlock,nextHeight++,null,null);
      while (block.getMessageSize() < Block.MAX_BLOCK_SIZE - 500) {
        Transaction tx=new Transaction(params);
        tx.addInput(lastOutput.getHash(),lastOutput.getIndex(),OP_NOP_SCRIPT);
        tx.addOutput(ZERO,OP_TRUE_SCRIPT);
        tx.addOutput(ZERO,OP_TRUE_SCRIPT);
        lastOutput=new TransactionOutPoint(params,1,tx.getHash());
        hashesToSpend.add(tx.getHash());
        block.addTransaction(tx);
      }
      block.solve();
      blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,block,true,false,block.getHash(),nextHeight - 1,""String_Node_Str"" + blockCountAfter1001 + ""String_Node_Str""+ TRANSACTION_CREATION_BLOCKS).setSendOnce(true));
      lastBlock=block;
    }
    Iterator<Sha256Hash> hashes=hashesToSpend.iterator();
    for (int i=0; hashes.hasNext(); i++) {
      Block block=createNextBlock(lastBlock,nextHeight++,null,null);
      while (block.getMessageSize() < Block.MAX_BLOCK_SIZE - 500 && hashes.hasNext()) {
        Transaction tx=new Transaction(params);
        tx.addInput(hashes.next(),0,OP_NOP_SCRIPT);
        tx.addOutput(ZERO,OP_TRUE_SCRIPT);
        block.addTransaction(tx);
      }
      block.solve();
      blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,block,true,false,block.getHash(),nextHeight - 1,""String_Node_Str"" + i).setSendOnce(true));
      lastBlock=block;
      blockCountAfter1001++;
    }
    Sha256Hash firstHash=lastBlock.getHash();
    int height=nextHeight - 1;
    nextHeight=heightAfter1001;
    lastBlock=b1001;
    for (int i=0; i < blockCountAfter1001; i++) {
      Block block=createNextBlock(lastBlock,nextHeight++,null,null);
      blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,block,true,false,firstHash,height,""String_Node_Str"" + i + ""String_Node_Str""+ blockCountAfter1001));
      lastBlock=block;
    }
    Block b1002=createNextBlock(lastBlock,nextHeight,null,null);
{
      Transaction tx=new Transaction(params);
      tx.addInput(hashesToSpend.get(0),0,OP_NOP_SCRIPT);
      tx.addOutput(ZERO,OP_TRUE_SCRIPT);
      b1002.addTransaction(tx);
    }
    b1002.solve();
    blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b1002,false,true,firstHash,height,""String_Node_Str""));
    Block b1003=createNextBlock(lastBlock,nextHeight,null,null);
    blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b1003,true,false,b1003.getHash(),nextHeight,""String_Node_Str""));
    Block b1004=createNextBlock(b1003,nextHeight + 1,null,null);
{
      Transaction tx=new Transaction(params);
      tx.addInput(hashesToSpend.get(0),0,OP_NOP_SCRIPT);
      tx.addOutput(ZERO,OP_TRUE_SCRIPT);
      b1004.addTransaction(tx);
    }
    b1004.solve();
    blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b1004,false,true,b1003.getHash(),nextHeight,""String_Node_Str""));
    ret.maximumReorgBlockCount=Math.max(ret.maximumReorgBlockCount,blockCountAfter1001);
  }
  if (outStream != null)   outStream.close();
  return ret;
}",0.9997166291462666
85652,"/** 
 * Called on a pushdata chunk, returns true if it uses the smallest possible way (according to BIP62) to push the data.
 */
public boolean isShortestPossiblePushData(){
  checkState(isPushData());
  if (data.length == 0)   return opcode == OP_0;
  if (data.length == 1) {
    byte b=data[0];
    if (b >= 0x01 && b <= 0x10)     return opcode == OP_1 + b - 1;
    if ((b & 0xFF) == 0x81)     return opcode == OP_1NEGATE;
  }
  if (data.length < OP_PUSHDATA1)   return opcode == data.length;
  if (data.length < 256)   return opcode == OP_PUSHDATA1;
  if (data.length < 65536)   return opcode == OP_PUSHDATA2;
  return opcode == OP_PUSHDATA4;
}","/** 
 * Called on a pushdata chunk, returns true if it uses the smallest possible way (according to BIP62) to push the data.
 */
public boolean isShortestPossiblePushData(){
  checkState(isPushData());
  if (data == null)   return true;
  if (data.length == 0)   return opcode == OP_0;
  if (data.length == 1) {
    byte b=data[0];
    if (b >= 0x01 && b <= 0x10)     return opcode == OP_1 + b - 1;
    if ((b & 0xFF) == 0x81)     return opcode == OP_1NEGATE;
  }
  if (data.length < OP_PUSHDATA1)   return opcode == data.length;
  if (data.length < 256)   return opcode == OP_PUSHDATA1;
  if (data.length < 65536)   return opcode == OP_PUSHDATA2;
  return opcode == OP_PUSHDATA4;
}",0.9736644093303236
85653,"@Before public void setup(){
  wallet=new Wallet(params){
    @Override public int getLastBlockSeenHeight(){
      return 1000;
    }
    @Override public long getLastBlockSeenTimeSecs(){
      return TIMESTAMP;
    }
  }
;
  key1=new ECKey();
}","@Before public void setup(){
  wallet=new Wallet(params){
    @Override public int getLastBlockSeenHeight(){
      return 1000;
    }
    @Override public long getLastBlockSeenTimeSecs(){
      return TIMESTAMP;
    }
  }
;
}",0.9531914893617022
85654,"public RuleList getBlocksToTest(boolean addSigExpensiveBlocks,boolean runLargeReorgs,File blockStorageFile) throws ScriptException, ProtocolException, IOException {
  final FileOutputStream outStream=blockStorageFile != null ? new FileOutputStream(blockStorageFile) : null;
  final Script OP_TRUE_SCRIPT=new ScriptBuilder().op(OP_TRUE).build();
  final Script OP_NOP_SCRIPT=new ScriptBuilder().op(OP_NOP).build();
  List<Rule> blocks=new LinkedList<Rule>(){
    @Override public boolean add(    Rule element){
      if (outStream != null && element instanceof BlockAndValidity) {
        try {
          outStream.write((int)(params.getPacketMagic() >>> 24));
          outStream.write((int)(params.getPacketMagic() >>> 16));
          outStream.write((int)(params.getPacketMagic() >>> 8));
          outStream.write((int)(params.getPacketMagic() >>> 0));
          byte[] block=((BlockAndValidity)element).block.bitcoinSerialize();
          byte[] length=new byte[4];
          Utils.uint32ToByteArrayBE(block.length,length,0);
          outStream.write(Utils.reverseBytes(length));
          outStream.write(block);
          ((BlockAndValidity)element).block=null;
        }
 catch (        IOException e) {
          throw new RuntimeException(e);
        }
      }
      return super.add(element);
    }
  }
;
  RuleList ret=new RuleList(blocks,hashHeaderMap,10);
  Queue<TransactionOutPointWithValue> spendableOutputs=new LinkedList<TransactionOutPointWithValue>();
  int chainHeadHeight=1;
  Block chainHead=params.getGenesisBlock().createNextBlockWithCoinbase(coinbaseOutKeyPubKey);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,chainHead,true,false,chainHead.getHash(),1,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,chainHead.getTransactions().get(0).getHash()),FIFTY_COINS,chainHead.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  for (int i=1; i < params.getSpendableCoinbaseDepth(); i++) {
    chainHead=chainHead.createNextBlockWithCoinbase(coinbaseOutKeyPubKey);
    chainHeadHeight++;
    blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,chainHead,true,false,chainHead.getHash(),i + 1,""String_Node_Str""));
    spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,chainHead.getTransactions().get(0).getHash()),FIFTY_COINS,chainHead.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  }
  Block b1=createNextBlock(chainHead,chainHeadHeight + 1,spendableOutputs.poll(),null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b1,true,false,b1.getHash(),chainHeadHeight + 1,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b1.getTransactions().get(0).getHash()),b1.getTransactions().get(0).getOutputs().get(0).getValue(),b1.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out1=spendableOutputs.poll();
  checkState(out1 != null);
  Block b2=createNextBlock(b1,chainHeadHeight + 2,out1,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b2,true,false,b2.getHash(),chainHeadHeight + 2,""String_Node_Str""));
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b2,true,false,b2.getHash(),chainHeadHeight + 2,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b2.getTransactions().get(0).getHash()),b2.getTransactions().get(0).getOutput(0).getValue(),b2.getTransactions().get(0).getOutput(0).getScriptPubKey()));
  Block b3=createNextBlock(b1,chainHeadHeight + 2,out1,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b3,true,false,b2.getHash(),chainHeadHeight + 2,""String_Node_Str""));
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b3,true,false,b2.getHash(),chainHeadHeight + 2,""String_Node_Str""));
  UTXORule utxo1;
{
    Transaction coinbase=b2.getTransactions().get(0);
    TransactionOutPoint outpoint=new TransactionOutPoint(params,0,coinbase.getHash());
    long[] heights=new long[]{chainHeadHeight + 2};
    UTXOsMessage result=new UTXOsMessage(params,ImmutableList.of(coinbase.getOutput(0)),heights,b2.getHash(),chainHeadHeight + 2);
    utxo1=new UTXORule(""String_Node_Str"",outpoint,result);
    blocks.add(utxo1);
  }
  TransactionOutPointWithValue out2=checkNotNull(spendableOutputs.poll());
  Block b4=createNextBlock(b3,chainHeadHeight + 3,out2,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b4,true,false,b4.getHash(),chainHeadHeight + 3,""String_Node_Str""));
{
    Transaction coinbase=b4.getTransactions().get(0);
    TransactionOutPoint outpoint=new TransactionOutPoint(params,0,coinbase.getHash());
    List<TransactionOutPoint> queries=ImmutableList.of(utxo1.query.get(0),outpoint);
    List<TransactionOutput> results=Lists.asList(null,coinbase.getOutput(0),new TransactionOutput[]{});
    long[] heights=new long[]{chainHeadHeight + 3};
    UTXOsMessage result=new UTXOsMessage(params,results,heights,b4.getHash(),chainHeadHeight + 3);
    UTXORule utxo2=new UTXORule(""String_Node_Str"",queries,result);
    blocks.add(utxo2);
  }
  Block b5=createNextBlock(b2,chainHeadHeight + 3,out2,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b5,true,false,b4.getHash(),chainHeadHeight + 3,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b5.getTransactions().get(0).getHash()),b5.getTransactions().get(0).getOutputs().get(0).getValue(),b5.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out3=spendableOutputs.poll();
  Block b6=createNextBlock(b5,chainHeadHeight + 4,out3,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b6,true,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  Block b7=createNextBlock(b5,chainHeadHeight + 5,out2,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b7,true,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  TransactionOutPointWithValue out4=spendableOutputs.poll();
  Block b8=createNextBlock(b7,chainHeadHeight + 6,out4,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b8,false,true,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  Block b9=createNextBlock(b6,chainHeadHeight + 5,out4,SATOSHI);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b9,false,true,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  Block b10=createNextBlock(b5,chainHeadHeight + 4,out3,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b10,true,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  Block b11=createNextBlock(b10,chainHeadHeight + 5,out4,SATOSHI);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b11,false,true,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  Block b12=createNextBlock(b5,chainHeadHeight + 4,out3,null);
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b12.getTransactions().get(0).getHash()),b12.getTransactions().get(0).getOutputs().get(0).getValue(),b12.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  Block b13=createNextBlock(b12,chainHeadHeight + 5,out4,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b13,false,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b13,false,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b13.getTransactions().get(0).getHash()),b13.getTransactions().get(0).getOutputs().get(0).getValue(),b13.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out5=spendableOutputs.poll();
  Block b14=createNextBlock(b13,chainHeadHeight + 6,out5,SATOSHI);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b14,false,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b14,false,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b12,false,true,b13.getHash(),chainHeadHeight + 5,""String_Node_Str""));
  Block b15=createNextBlock(b13,chainHeadHeight + 6,out5,null);
{
    int sigOps=0;
    for (    Transaction tx : b15.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b15.getTransactions().get(1).getHash()),SATOSHI,b15.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b15.addTransaction(tx);
  }
  b15.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b15,true,false,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b15.getTransactions().get(0).getHash()),b15.getTransactions().get(0).getOutputs().get(0).getValue(),b15.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out6=spendableOutputs.poll();
  Block b16=createNextBlock(b15,chainHeadHeight + 7,out6,null);
{
    int sigOps=0;
    for (    Transaction tx : b16.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + 1];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b16.getTransactions().get(1).getHash()),SATOSHI,b16.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b16.addTransaction(tx);
  }
  b16.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b16,false,true,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  Block b17=createNextBlock(b15,chainHeadHeight + 7,out6,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,new byte[]{}));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b3.getTransactions().get(1).getHash()),SATOSHI,b3.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b17.addTransaction(tx);
  }
  b17.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b17,false,true,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  Block b18=createNextBlock(b13,chainHeadHeight + 6,out5,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,new byte[]{}));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b3.getTransactions().get(1).getHash()),SATOSHI,b3.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b18.addTransaction(tx);
  }
  b18.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b18,true,false,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  Block b19=createNextBlock(b18,chainHeadHeight + 7,out6,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b19,false,true,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  TransactionOutPointWithValue out7=spendableOutputs.poll();
  Block b20=createNextBlock(b15,chainHeadHeight + 7,out7,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b20,false,true,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  Block b21=createNextBlock(b13,chainHeadHeight + 6,out6,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b21,true,false,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  Block b22=createNextBlock(b21,chainHeadHeight + 7,out5,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b22,false,true,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  Block b23=createNextBlock(b15,chainHeadHeight + 7,out6,null);
{
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIZE - b23.getMessageSize() - 138];
    Arrays.fill(outputScript,(byte)OP_FALSE);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b23.getTransactions().get(1).getHash()),SATOSHI,b23.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b23.addTransaction(tx);
  }
  b23.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b23,true,false,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b23.getTransactions().get(0).getHash()),b23.getTransactions().get(0).getOutputs().get(0).getValue(),b23.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  Block b24=createNextBlock(b15,chainHeadHeight + 7,out6,null);
{
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIZE - b24.getMessageSize() - 135];
    Arrays.fill(outputScript,(byte)OP_FALSE);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b24.getTransactions().get(1).getHash()),SATOSHI,b24.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b24.addTransaction(tx);
  }
  b24.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b24,false,true,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  Block b25=createNextBlock(b24,chainHeadHeight + 8,out7,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b25,false,false,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  Block b26=createNextBlock(b15,chainHeadHeight + 7,out6,null);
  b26.getTransactions().get(0).getInputs().get(0).setScriptBytes(new byte[]{0});
  b26.setMerkleRoot(null);
  b26.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b26,false,true,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  Block b27=createNextBlock(b26,chainHeadHeight + 8,out7,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b27,false,false,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  Block b28=createNextBlock(b15,chainHeadHeight + 7,out6,null);
{
    byte[] coinbase=new byte[101];
    Arrays.fill(coinbase,(byte)0);
    b28.getTransactions().get(0).getInputs().get(0).setScriptBytes(coinbase);
  }
  b28.setMerkleRoot(null);
  b28.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b28,false,true,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  Block b29=createNextBlock(b28,chainHeadHeight + 8,out7,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b29,false,false,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  Block b30=createNextBlock(b23,chainHeadHeight + 8,out7,null);
{
    byte[] coinbase=new byte[100];
    Arrays.fill(coinbase,(byte)0);
    b30.getTransactions().get(0).getInputs().get(0).setScriptBytes(coinbase);
  }
  b30.setMerkleRoot(null);
  b30.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b30,true,false,b30.getHash(),chainHeadHeight + 8,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b30.getTransactions().get(0).getHash()),b30.getTransactions().get(0).getOutputs().get(0).getValue(),b30.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out8=spendableOutputs.poll();
  Block b31=createNextBlock(b30,chainHeadHeight + 9,out8,null);
{
    int sigOps=0;
    for (    Transaction tx : b31.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[(Block.MAX_BLOCK_SIGOPS - sigOps) / 20];
    Arrays.fill(outputScript,(byte)OP_CHECKMULTISIG);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b31.getTransactions().get(1).getHash()),SATOSHI,b31.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b31.addTransaction(tx);
  }
  b31.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b31,true,false,b31.getHash(),chainHeadHeight + 9,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b31.getTransactions().get(0).getHash()),b31.getTransactions().get(0).getOutputs().get(0).getValue(),b31.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out9=spendableOutputs.poll();
  Block b32=createNextBlock(b31,chainHeadHeight + 10,out9,null);
{
    int sigOps=0;
    for (    Transaction tx : b32.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[(Block.MAX_BLOCK_SIGOPS - sigOps) / 20 + (Block.MAX_BLOCK_SIGOPS - sigOps) % 20 + 1];
    Arrays.fill(outputScript,(byte)OP_CHECKMULTISIG);
    for (int i=0; i < (Block.MAX_BLOCK_SIGOPS - sigOps) % 20; i++)     outputScript[i]=(byte)OP_CHECKSIG;
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b32.getTransactions().get(1).getHash()),SATOSHI,b32.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b32.addTransaction(tx);
  }
  b32.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b32,false,true,b31.getHash(),chainHeadHeight + 9,""String_Node_Str""));
  Block b33=createNextBlock(b31,chainHeadHeight + 10,out9,null);
{
    int sigOps=0;
    for (    Transaction tx : b33.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[(Block.MAX_BLOCK_SIGOPS - sigOps) / 20];
    Arrays.fill(outputScript,(byte)OP_CHECKMULTISIGVERIFY);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b33.getTransactions().get(1).getHash()),SATOSHI,b33.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b33.addTransaction(tx);
  }
  b33.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b33,true,false,b33.getHash(),chainHeadHeight + 10,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b33.getTransactions().get(0).getHash()),b33.getTransactions().get(0).getOutputs().get(0).getValue(),b33.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out10=spendableOutputs.poll();
  Block b34=createNextBlock(b33,chainHeadHeight + 11,out10,null);
{
    int sigOps=0;
    for (    Transaction tx : b34.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[(Block.MAX_BLOCK_SIGOPS - sigOps) / 20 + (Block.MAX_BLOCK_SIGOPS - sigOps) % 20 + 1];
    Arrays.fill(outputScript,(byte)OP_CHECKMULTISIGVERIFY);
    for (int i=0; i < (Block.MAX_BLOCK_SIGOPS - sigOps) % 20; i++)     outputScript[i]=(byte)OP_CHECKSIG;
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b34.getTransactions().get(1).getHash()),SATOSHI,b34.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b34.addTransaction(tx);
  }
  b34.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b34,false,true,b33.getHash(),chainHeadHeight + 10,""String_Node_Str""));
  Block b35=createNextBlock(b33,chainHeadHeight + 11,out10,null);
{
    int sigOps=0;
    for (    Transaction tx : b35.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps];
    Arrays.fill(outputScript,(byte)OP_CHECKSIGVERIFY);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b35.getTransactions().get(1).getHash()),SATOSHI,b35.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b35.addTransaction(tx);
  }
  b35.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b35,true,false,b35.getHash(),chainHeadHeight + 11,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b35.getTransactions().get(0).getHash()),b35.getTransactions().get(0).getOutputs().get(0).getValue(),b35.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out11=spendableOutputs.poll();
  Block b36=createNextBlock(b35,chainHeadHeight + 12,out11,null);
{
    int sigOps=0;
    for (    Transaction tx : b36.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + 1];
    Arrays.fill(outputScript,(byte)OP_CHECKSIGVERIFY);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b36.getTransactions().get(1).getHash()),SATOSHI,b36.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b36.addTransaction(tx);
  }
  b36.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b36,false,true,b35.getHash(),chainHeadHeight + 11,""String_Node_Str""));
  Block b37=createNextBlock(b35,chainHeadHeight + 12,out11,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,new byte[]{}));
    addOnlyInputToTransaction(tx,out11);
    b37.addTransaction(tx);
  }
  b37.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b37,false,true,b35.getHash(),chainHeadHeight + 11,""String_Node_Str""));
  Block b38=createNextBlock(b35,chainHeadHeight + 12,out11,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,new byte[]{}));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b37.getTransactions().get(1).getHash()),SATOSHI,b37.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b38.addTransaction(tx);
  }
  b38.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b38,false,true,b35.getHash(),chainHeadHeight + 11,""String_Node_Str""));
  byte[] b39p2shScriptPubKey;
  int b39numP2SHOutputs=0, b39sigOpsPerOutput=6;
  Block b39=createNextBlock(b35,chainHeadHeight + 12,null,null);
{
    ByteArrayOutputStream p2shScriptPubKey=new UnsafeByteArrayOutputStream();
    try {
      Script.writeBytes(p2shScriptPubKey,coinbaseOutKeyPubKey);
      p2shScriptPubKey.write(OP_2DUP);
      p2shScriptPubKey.write(OP_CHECKSIGVERIFY);
      p2shScriptPubKey.write(OP_2DUP);
      p2shScriptPubKey.write(OP_CHECKSIGVERIFY);
      p2shScriptPubKey.write(OP_2DUP);
      p2shScriptPubKey.write(OP_CHECKSIGVERIFY);
      p2shScriptPubKey.write(OP_2DUP);
      p2shScriptPubKey.write(OP_CHECKSIGVERIFY);
      p2shScriptPubKey.write(OP_2DUP);
      p2shScriptPubKey.write(OP_CHECKSIGVERIFY);
      p2shScriptPubKey.write(OP_CHECKSIG);
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
    b39p2shScriptPubKey=p2shScriptPubKey.toByteArray();
    byte[] scriptHash=Utils.sha256hash160(b39p2shScriptPubKey);
    UnsafeByteArrayOutputStream scriptPubKey=new UnsafeByteArrayOutputStream(scriptHash.length + 3);
    scriptPubKey.write(OP_HASH160);
    try {
      Script.writeBytes(scriptPubKey,scriptHash);
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
    scriptPubKey.write(OP_EQUAL);
    Coin lastOutputValue=out11.value.subtract(SATOSHI);
    TransactionOutPoint lastOutPoint;
{
      Transaction tx=new Transaction(params);
      tx.addOutput(new TransactionOutput(params,tx,SATOSHI,scriptPubKey.toByteArray()));
      tx.addOutput(new TransactionOutput(params,tx,lastOutputValue,new byte[]{OP_1}));
      addOnlyInputToTransaction(tx,out11);
      lastOutPoint=new TransactionOutPoint(params,1,tx.getHash());
      b39.addTransaction(tx);
    }
    b39numP2SHOutputs++;
    while (b39.getMessageSize() < Block.MAX_BLOCK_SIZE) {
      Transaction tx=new Transaction(params);
      lastOutputValue=lastOutputValue.subtract(SATOSHI);
      tx.addOutput(new TransactionOutput(params,tx,SATOSHI,scriptPubKey.toByteArray()));
      tx.addOutput(new TransactionOutput(params,tx,lastOutputValue,new byte[]{OP_1}));
      tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},lastOutPoint));
      lastOutPoint=new TransactionOutPoint(params,1,tx.getHash());
      if (b39.getMessageSize() + tx.getMessageSize() < Block.MAX_BLOCK_SIZE) {
        b39.addTransaction(tx);
        b39numP2SHOutputs++;
      }
 else       break;
    }
  }
  b39.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b39,true,false,b39.getHash(),chainHeadHeight + 12,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b39.getTransactions().get(0).getHash()),b39.getTransactions().get(0).getOutputs().get(0).getValue(),b39.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out12=spendableOutputs.poll();
  Block b40=createNextBlock(b39,chainHeadHeight + 13,out12,null);
{
    int sigOps=0;
    for (    Transaction tx : b40.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    int numTxes=(Block.MAX_BLOCK_SIGOPS - sigOps) / b39sigOpsPerOutput;
    checkState(numTxes <= b39numP2SHOutputs);
    TransactionOutPoint lastOutPoint=new TransactionOutPoint(params,2,b40.getTransactions().get(1).getHash());
    byte[] scriptSig=null;
    for (int i=1; i <= numTxes; i++) {
      Transaction tx=new Transaction(params);
      tx.addOutput(new TransactionOutput(params,tx,SATOSHI,new byte[]{OP_1}));
      tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},lastOutPoint));
      TransactionInput input=new TransactionInput(params,tx,new byte[]{},new TransactionOutPoint(params,0,b39.getTransactions().get(i).getHash()));
      tx.addInput(input);
      if (scriptSig == null) {
        Sha256Hash hash=tx.hashForSignature(1,b39p2shScriptPubKey,SigHash.SINGLE,false);
        try {
          ByteArrayOutputStream bos=new UnsafeByteArrayOutputStream(73);
          bos.write(coinbaseOutKey.sign(hash).encodeToDER());
          bos.write(SigHash.SINGLE.ordinal() + 1);
          byte[] signature=bos.toByteArray();
          ByteArrayOutputStream scriptSigBos=new UnsafeByteArrayOutputStream(signature.length + b39p2shScriptPubKey.length + 3);
          Script.writeBytes(scriptSigBos,new byte[]{(byte)OP_CHECKSIG});
          scriptSigBos.write(Script.createInputScript(signature));
          Script.writeBytes(scriptSigBos,b39p2shScriptPubKey);
          scriptSig=scriptSigBos.toByteArray();
        }
 catch (        IOException e) {
          throw new RuntimeException(e);
        }
      }
      input.setScriptBytes(scriptSig);
      lastOutPoint=new TransactionOutPoint(params,0,tx.getHash());
      b40.addTransaction(tx);
    }
    sigOps+=numTxes * b39sigOpsPerOutput;
    Transaction tx=new Transaction(params);
    tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},lastOutPoint));
    byte[] scriptPubKey=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + 1];
    Arrays.fill(scriptPubKey,(byte)OP_CHECKSIG);
    tx.addOutput(new TransactionOutput(params,tx,ZERO,scriptPubKey));
    b40.addTransaction(tx);
  }
  b40.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b40,false,true,b39.getHash(),chainHeadHeight + 12,""String_Node_Str""));
  Block b41=null;
  if (addSigExpensiveBlocks) {
    b41=createNextBlock(b39,chainHeadHeight + 13,out12,null);
{
      int sigOps=0;
      for (      Transaction tx : b41.transactions) {
        sigOps+=tx.getSigOpCount();
      }
      int numTxes=(Block.MAX_BLOCK_SIGOPS - sigOps) / b39sigOpsPerOutput;
      checkState(numTxes <= b39numP2SHOutputs);
      TransactionOutPoint lastOutPoint=new TransactionOutPoint(params,2,b41.getTransactions().get(1).getHash());
      byte[] scriptSig=null;
      for (int i=1; i <= numTxes; i++) {
        Transaction tx=new Transaction(params);
        tx.addOutput(new TransactionOutput(params,tx,Coin.SATOSHI,new byte[]{OP_1}));
        tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},lastOutPoint));
        TransactionInput input=new TransactionInput(params,tx,new byte[]{},new TransactionOutPoint(params,0,b39.getTransactions().get(i).getHash()));
        tx.addInput(input);
        if (scriptSig == null) {
          Sha256Hash hash=tx.hashForSignature(1,b39p2shScriptPubKey,SigHash.SINGLE,false);
          try {
            ByteArrayOutputStream bos=new UnsafeByteArrayOutputStream(73);
            bos.write(coinbaseOutKey.sign(hash).encodeToDER());
            bos.write(SigHash.SINGLE.ordinal() + 1);
            byte[] signature=bos.toByteArray();
            ByteArrayOutputStream scriptSigBos=new UnsafeByteArrayOutputStream(signature.length + b39p2shScriptPubKey.length + 3);
            Script.writeBytes(scriptSigBos,new byte[]{(byte)OP_CHECKSIG});
            scriptSigBos.write(Script.createInputScript(signature));
            Script.writeBytes(scriptSigBos,b39p2shScriptPubKey);
            scriptSig=scriptSigBos.toByteArray();
          }
 catch (          IOException e) {
            throw new RuntimeException(e);
          }
        }
        input.setScriptBytes(scriptSig);
        lastOutPoint=new TransactionOutPoint(params,0,tx.getHash());
        b41.addTransaction(tx);
      }
      sigOps+=numTxes * b39sigOpsPerOutput;
      Transaction tx=new Transaction(params);
      tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},lastOutPoint));
      byte[] scriptPubKey=new byte[Block.MAX_BLOCK_SIGOPS - sigOps];
      Arrays.fill(scriptPubKey,(byte)OP_CHECKSIG);
      tx.addOutput(new TransactionOutput(params,tx,ZERO,scriptPubKey));
      b41.addTransaction(tx);
    }
    b41.solve();
    blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b41,true,false,b41.getHash(),chainHeadHeight + 13,""String_Node_Str""));
  }
  Block b42=createNextBlock(b39,chainHeadHeight + 13,out12,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b42,true,false,b41 == null ? b42.getHash() : b41.getHash(),chainHeadHeight + 13,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b42.getTransactions().get(0).getHash()),b42.getTransactions().get(0).getOutputs().get(0).getValue(),b42.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out13=spendableOutputs.poll();
  Block b43=createNextBlock(b42,chainHeadHeight + 14,out13,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b43,true,false,b43.getHash(),chainHeadHeight + 14,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b43.getTransactions().get(0).getHash()),b43.getTransactions().get(0).getOutputs().get(0).getValue(),b43.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out14=spendableOutputs.poll();
  Block b44=new Block(params);
  byte[] outScriptBytes=ScriptBuilder.createOutputScript(ECKey.fromPublicOnly(coinbaseOutKeyPubKey)).getProgram();
{
    b44.setDifficultyTarget(b43.getDifficultyTarget());
    b44.addCoinbaseTransaction(coinbaseOutKeyPubKey,ZERO);
    Transaction t=new Transaction(params);
    t.addOutput(new TransactionOutput(params,t,ZERO,new byte[]{OP_PUSHDATA1 - 1}));
    t.addOutput(new TransactionOutput(params,t,SATOSHI,outScriptBytes));
    t.addOutput(new TransactionOutput(params,t,ZERO,new byte[]{OP_1}));
    addOnlyInputToTransaction(t,out14);
    b44.addTransaction(t);
    b44.setPrevBlockHash(b43.getHash());
    b44.setTime(b43.getTimeSeconds() + 1);
  }
  b44.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b44,true,false,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  TransactionOutPointWithValue out15=spendableOutputs.poll();
  Block b45=new Block(params);
{
    b45.setDifficultyTarget(b44.getDifficultyTarget());
    Transaction t=new Transaction(params);
    t.addOutput(new TransactionOutput(params,t,ZERO,new byte[]{OP_PUSHDATA1 - 1}));
    t.addOutput(new TransactionOutput(params,t,SATOSHI,outScriptBytes));
    t.addOutput(new TransactionOutput(params,t,ZERO,new byte[]{OP_1}));
    addOnlyInputToTransaction(t,out15);
    try {
      b45.addTransaction(t);
    }
 catch (    RuntimeException e) {
    }
    if (b45.getTransactions().size() > 0)     throw new RuntimeException(""String_Node_Str"");
    b45.addTransaction(t,false);
    b45.setPrevBlockHash(b44.getHash());
    b45.setTime(b44.getTimeSeconds() + 1);
  }
  b45.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b45,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b46=new Block(params);
{
    b46.transactions=new ArrayList<Transaction>();
    b46.setDifficultyTarget(b44.getDifficultyTarget());
    b46.setMerkleRoot(Sha256Hash.ZERO_HASH);
    b46.setPrevBlockHash(b44.getHash());
    b46.setTime(b44.getTimeSeconds() + 1);
  }
  b46.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b46,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b47=createNextBlock(b44,chainHeadHeight + 16,out15,null);
{
    try {
      BigInteger target=b47.getDifficultyTargetAsInteger();
      while (true) {
        BigInteger h=b47.getHash().toBigInteger();
        if (h.compareTo(target) > 0)         break;
        b47.setNonce(b47.getNonce() + 1);
      }
    }
 catch (    VerificationException e) {
      throw new RuntimeException(e);
    }
  }
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b47,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b48=createNextBlock(b44,chainHeadHeight + 16,out15,null);
  b48.setTime(Utils.currentTimeSeconds() + 60 * 60 * 3);
  b48.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b48,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b49=createNextBlock(b44,chainHeadHeight + 16,out15,null);
  b49.setMerkleRoot(Sha256Hash.ZERO_HASH);
  b49.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b49,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b50=createNextBlock(b44,chainHeadHeight + 16,out15,null);
{
    long diffTarget=b44.getDifficultyTarget();
    diffTarget&=0xFFBFFFFF;
    b50.setDifficultyTarget(diffTarget);
  }
  b50.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b50,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b51=createNextBlock(b44,chainHeadHeight + 16,out15,null);
{
    Transaction coinbase=new Transaction(params);
    coinbase.addInput(new TransactionInput(params,coinbase,new byte[]{(byte)0xff,110,1}));
    coinbase.addOutput(new TransactionOutput(params,coinbase,SATOSHI,outScriptBytes));
    b51.addTransaction(coinbase,false);
  }
  b51.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b51,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b52=createNextBlock(b44,chainHeadHeight + 16,out15,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,new byte[]{}));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b52.getTransactions().get(1).getHash()),SATOSHI,b52.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b52.addTransaction(tx);
    b52.addTransaction(tx);
  }
  b52.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b52,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b53=createNextBlock(b43,chainHeadHeight + 15,out14,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b53,true,false,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b53.getTransactions().get(0).getHash()),b53.getTransactions().get(0).getOutputs().get(0).getValue(),b53.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  Block b54=createNextBlock(b53,chainHeadHeight + 16,out15,null);
  b54.setTime(b35.getTimeSeconds() - 1);
  b54.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b54,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b55=createNextBlock(b53,chainHeadHeight + 16,out15,null);
  b55.setTime(b35.getTimeSeconds());
  b55.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b55,true,false,b55.getHash(),chainHeadHeight + 16,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b55.getTransactions().get(0).getHash()),b55.getTransactions().get(0).getOutputs().get(0).getValue(),b55.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out16=spendableOutputs.poll();
  Block b57=createNextBlock(b55,chainHeadHeight + 17,out16,null);
  Transaction b56txToDuplicate;
{
    b56txToDuplicate=new Transaction(params);
    b56txToDuplicate.addOutput(new TransactionOutput(params,b56txToDuplicate,SATOSHI,new byte[]{}));
    addOnlyInputToTransaction(b56txToDuplicate,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b57.getTransactions().get(1).getHash()),SATOSHI,b57.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b57.addTransaction(b56txToDuplicate);
  }
  b57.solve();
  Block b56;
  try {
    b56=new Block(params,b57.bitcoinSerialize());
  }
 catch (  ProtocolException e) {
    throw new RuntimeException(e);
  }
  b56.addTransaction(b56txToDuplicate);
  checkState(b56.getHash().equals(b57.getHash()));
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b56,false,true,b55.getHash(),chainHeadHeight + 16,""String_Node_Str""));
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b57,true,false,b57.getHash(),chainHeadHeight + 17,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b57.getTransactions().get(0).getHash()),b57.getTransactions().get(0).getOutputs().get(0).getValue(),b57.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out17=spendableOutputs.poll();
  Block b58=createNextBlock(b57,chainHeadHeight + 18,out17,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,ZERO,new byte[]{}));
    tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},new TransactionOutPoint(params,3,b58.getTransactions().get(1).getHash())));
    b58.addTransaction(tx);
  }
  b58.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b58,false,true,b57.getHash(),chainHeadHeight + 17,""String_Node_Str""));
  Block b59=createNextBlock(b57,chainHeadHeight + 18,out17,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,b59.getTransactions().get(1).getOutputs().get(2).getValue().add(SATOSHI),new byte[]{}));
    tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},new TransactionOutPoint(params,2,b59.getTransactions().get(1).getHash())));
    b59.addTransaction(tx);
  }
  b59.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b59,false,true,b57.getHash(),chainHeadHeight + 17,""String_Node_Str""));
  Block b60=createNextBlock(b57,chainHeadHeight + 18,out17,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b60,true,false,b60.getHash(),chainHeadHeight + 18,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b60.getTransactions().get(0).getHash()),b60.getTransactions().get(0).getOutputs().get(0).getValue(),b60.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out18=spendableOutputs.poll();
  Block b61=createNextBlock(b60,chainHeadHeight + 19,out18,null);
{
    b61.getTransactions().get(0).getInput(0).setScriptBytes(b60.getTransactions().get(0).getInput(0).getScriptBytes());
    b61.unCache();
    checkState(b61.getTransactions().get(0).equals(b60.getTransactions().get(0)));
  }
  b61.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b61,false,true,b60.getHash(),chainHeadHeight + 18,""String_Node_Str""));
  Block b62=createNextBlock(b60,chainHeadHeight + 19,null,null);
{
    Transaction tx=new Transaction(params);
    tx.setLockTime(0xffffffffL);
    tx.addOutput(ZERO,OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(tx,out18,0);
    b62.addTransaction(tx);
    checkState(!tx.isFinal(chainHeadHeight + 17,b62.getTimeSeconds()));
  }
  b62.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b62,false,true,b60.getHash(),chainHeadHeight + 18,""String_Node_Str""));
  Block b63=createNextBlock(b60,chainHeadHeight + 19,null,null);
{
    b63.getTransactions().get(0).setLockTime(0xffffffffL);
    b63.getTransactions().get(0).getInputs().get(0).setSequenceNumber(0xDEADBEEF);
    checkState(!b63.getTransactions().get(0).isFinal(chainHeadHeight + 17,b63.getTimeSeconds()));
  }
  b63.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b63,false,true,b60.getHash(),chainHeadHeight + 18,""String_Node_Str""));
  Block b64;
{
    Block b64Created=createNextBlock(b60,chainHeadHeight + 19,out18,null);
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIZE - b64Created.getMessageSize() - 138];
    Arrays.fill(outputScript,(byte)OP_FALSE);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b64Created.getTransactions().get(1).getHash()),SATOSHI,b64Created.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b64Created.addTransaction(tx);
    b64Created.solve();
    UnsafeByteArrayOutputStream stream=new UnsafeByteArrayOutputStream(b64Created.getMessageSize() + 8);
    b64Created.writeHeader(stream);
    byte[] varIntBytes=new byte[9];
    varIntBytes[0]=(byte)255;
    Utils.uint32ToByteArrayLE((long)b64Created.getTransactions().size(),varIntBytes,1);
    Utils.uint32ToByteArrayLE(((long)b64Created.getTransactions().size()) >>> 32,varIntBytes,5);
    stream.write(varIntBytes);
    checkState(new VarInt(varIntBytes,0).value == b64Created.getTransactions().size());
    for (    Transaction transaction : b64Created.getTransactions())     transaction.bitcoinSerialize(stream);
    b64=new Block(params,stream.toByteArray(),false,true,stream.size());
    checkState(stream.size() == b64Created.getMessageSize() + 8);
    checkState(stream.size() == b64.getMessageSize());
    checkState(Arrays.equals(stream.toByteArray(),b64.bitcoinSerialize()));
    checkState(b64.getOptimalEncodingMessageSize() == b64Created.getMessageSize());
  }
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b64,true,false,b64.getHash(),chainHeadHeight + 19,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b64.getTransactions().get(0).getHash()),b64.getTransactions().get(0).getOutputs().get(0).getValue(),b64.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out19=spendableOutputs.poll();
  checkState(out19 != null);
  Block b65=createNextBlock(b64,chainHeadHeight + 20,null,null);
{
    Transaction tx1=new Transaction(params);
    tx1.addOutput(out19.value,OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(tx1,out19,0);
    b65.addTransaction(tx1);
    Transaction tx2=new Transaction(params);
    tx2.addOutput(ZERO,OP_TRUE_SCRIPT);
    tx2.addInput(tx1.getHash(),0,OP_TRUE_SCRIPT);
    b65.addTransaction(tx2);
  }
  b65.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b65,true,false,b65.getHash(),chainHeadHeight + 20,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b65.getTransactions().get(0).getHash()),b65.getTransactions().get(0).getOutputs().get(0).getValue(),b65.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out20=spendableOutputs.poll();
  checkState(out20 != null);
  Block b66=createNextBlock(b65,chainHeadHeight + 21,null,null);
{
    Transaction tx1=new Transaction(params);
    tx1.addOutput(out20.value,OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(tx1,out20,0);
    Transaction tx2=new Transaction(params);
    tx2.addOutput(ZERO,OP_TRUE_SCRIPT);
    tx2.addInput(tx1.getHash(),0,OP_NOP_SCRIPT);
    b66.addTransaction(tx2);
    b66.addTransaction(tx1);
  }
  b66.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b66,false,true,b65.getHash(),chainHeadHeight + 20,""String_Node_Str""));
  Block b67=createNextBlock(b65,chainHeadHeight + 21,null,null);
{
    Transaction tx1=new Transaction(params);
    tx1.addOutput(out20.value,OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(tx1,out20,0);
    b67.addTransaction(tx1);
    Transaction tx2=new Transaction(params);
    tx2.addOutput(ZERO,OP_TRUE_SCRIPT);
    tx2.addInput(tx1.getHash(),0,OP_NOP_SCRIPT);
    b67.addTransaction(tx2);
    Transaction tx3=new Transaction(params);
    tx3.addOutput(out20.value,OP_TRUE_SCRIPT);
    tx3.addInput(tx1.getHash(),0,OP_NOP_SCRIPT);
    b67.addTransaction(tx3);
  }
  b67.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b67,false,true,b65.getHash(),chainHeadHeight + 20,""String_Node_Str""));
  Block b68=createNextBlock(b65,chainHeadHeight + 21,null,SATOSHI.multiply(10));
{
    Transaction tx=new Transaction(params);
    tx.addOutput(out20.value.subtract(Coin.valueOf(9)),OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(tx,out20,0);
    b68.addTransaction(tx);
  }
  b68.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b68,false,true,b65.getHash(),chainHeadHeight + 20,""String_Node_Str""));
  Block b69=createNextBlock(b65,chainHeadHeight + 21,null,SATOSHI.multiply(10));
{
    Transaction tx=new Transaction(params);
    tx.addOutput(out20.value.subtract(Coin.valueOf(10)),OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(tx,out20,0);
    b69.addTransaction(tx);
  }
  b69.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b69,true,false,b69.getHash(),chainHeadHeight + 21,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b69.getTransactions().get(0).getHash()),b69.getTransactions().get(0).getOutputs().get(0).getValue(),b69.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out21=spendableOutputs.poll();
  checkState(out21 != null);
  Block b70=createNextBlock(b69,chainHeadHeight + 22,out21,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(ZERO,OP_TRUE_SCRIPT);
    tx.addInput(new Sha256Hash(""String_Node_Str""),0,OP_NOP_SCRIPT);
    b70.addTransaction(tx);
  }
  b70.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b70,false,true,b69.getHash(),chainHeadHeight + 21,""String_Node_Str""));
  Block b72=createNextBlock(b69,chainHeadHeight + 22,out21,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(ZERO,OP_TRUE_SCRIPT);
    final Transaction tx2=b72.getTransactions().get(1);
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,tx2.getHash()),SATOSHI,tx2.getOutput(1).getScriptPubKey()));
    b72.addTransaction(tx);
  }
  b72.solve();
  Block b71=new Block(params,b72.bitcoinSerialize());
  b71.addTransaction(b72.getTransactions().get(2));
  checkState(b71.getHash().equals(b72.getHash()));
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b71,false,true,b69.getHash(),chainHeadHeight + 21,""String_Node_Str""));
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b72,true,false,b72.getHash(),chainHeadHeight + 22,""String_Node_Str""));
  final Transaction b72tx=b72.getTransactions().get(0);
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b72tx.getHash()),b72tx.getOutput(0).getValue(),b72tx.getOutput(0).getScriptPubKey()));
  TransactionOutPointWithValue out22=spendableOutputs.poll();
  checkState(out22 != null);
  Block b73=createNextBlock(b72,chainHeadHeight + 23,out22,null);
{
    int sigOps=0;
    for (    Transaction tx : b73.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + (int)Script.MAX_SCRIPT_ELEMENT_SIZE + 1 + 5 + 1];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps]=OP_PUSHDATA4;
    Utils.uint32ToByteArrayLE(Script.MAX_SCRIPT_ELEMENT_SIZE + 1,outputScript,Block.MAX_BLOCK_SIGOPS - sigOps + 1);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b73.getTransactions().get(1).getHash()),SATOSHI,b73.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b73.addTransaction(tx);
  }
  b73.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b73,false,true,b72.getHash(),chainHeadHeight + 22,""String_Node_Str""));
  Block b74=createNextBlock(b72,chainHeadHeight + 23,out22,null);
{
    int sigOps=0;
    for (    Transaction tx : b74.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + (int)Script.MAX_SCRIPT_ELEMENT_SIZE + 42];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 1]=OP_PUSHDATA4;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 2]=(byte)0xfe;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 3]=(byte)0xff;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 4]=(byte)0xff;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 5]=(byte)0xff;
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b74.getTransactions().get(1).getHash()),SATOSHI,b74.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b74.addTransaction(tx);
  }
  b74.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b74,false,true,b72.getHash(),chainHeadHeight + 22,""String_Node_Str""));
  Block b75=createNextBlock(b72,chainHeadHeight + 23,out22,null);
{
    int sigOps=0;
    for (    Transaction tx : b75.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + (int)Script.MAX_SCRIPT_ELEMENT_SIZE + 42];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps]=OP_PUSHDATA4;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 1]=(byte)0xff;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 2]=(byte)0xff;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 3]=(byte)0xff;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 4]=(byte)0xff;
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b75.getTransactions().get(1).getHash()),SATOSHI,b75.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b75.addTransaction(tx);
  }
  b75.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b75,true,false,b75.getHash(),chainHeadHeight + 23,""String_Node_Str""));
  final Transaction b75tx=b75.getTransactions().get(0);
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b75tx.getHash()),b75tx.getOutput(0).getValue(),b75tx.getOutput(0).getScriptPubKey()));
  TransactionOutPointWithValue out23=spendableOutputs.poll();
  checkState(out23 != null);
  Block b76=createNextBlock(b75,chainHeadHeight + 24,out23,null);
{
    int sigOps=0;
    for (    Transaction tx : b76.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + (int)Script.MAX_SCRIPT_ELEMENT_SIZE + 1 + 5];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps]=OP_PUSHDATA4;
    Utils.uint32ToByteArrayLE(Block.MAX_BLOCK_SIGOPS,outputScript,Block.MAX_BLOCK_SIGOPS - sigOps + 1);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b76.getTransactions().get(1).getHash()),SATOSHI,b76.getTransactions().get(1).getOutput(1).getScriptPubKey()));
    b76.addTransaction(tx);
  }
  b76.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b76,true,false,b76.getHash(),chainHeadHeight + 24,""String_Node_Str""));
  final Transaction b76tx=b76.getTransactions().get(0);
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b76tx.getHash()),b76tx.getOutput(0).getValue(),b76tx.getOutput(0).getScriptPubKey()));
  TransactionOutPointWithValue out24=checkNotNull(spendableOutputs.poll());
  TransactionOutPointWithValue out25=checkNotNull(spendableOutputs.poll());
  TransactionOutPointWithValue out26=checkNotNull(spendableOutputs.poll());
  TransactionOutPointWithValue out27=checkNotNull(spendableOutputs.poll());
  Block b77=createNextBlock(b76,chainHeadHeight + 25,out24,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b77,true,false,b77.getHash(),chainHeadHeight + 25,""String_Node_Str""));
  Block b78=createNextBlock(b77,chainHeadHeight + 26,out25,null);
  Transaction b78tx=new Transaction(params);
{
    b78tx.addOutput(ZERO,OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(b78tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b77.getTransactions().get(1).getHash()),SATOSHI,b77.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b78.addTransaction(b78tx);
  }
  b78.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b78,true,false,b78.getHash(),chainHeadHeight + 26,""String_Node_Str""));
  Block b79=createNextBlock(b78,chainHeadHeight + 27,out26,null);
  Transaction b79tx=new Transaction(params);
{
    b79tx.addOutput(ZERO,OP_TRUE_SCRIPT);
    b79tx.addInput(b78tx.getHash(),0,OP_NOP_SCRIPT);
    b79.addTransaction(b79tx);
  }
  b79.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b79,true,false,b79.getHash(),chainHeadHeight + 27,""String_Node_Str""));
  blocks.add(new MemoryPoolState(new HashSet<InventoryItem>(),""String_Node_Str""));
  Block b80=createNextBlock(b77,chainHeadHeight + 26,out25,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b80,true,false,b79.getHash(),chainHeadHeight + 27,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b80.getTransactions().get(0).getHash()),b80.getTransactions().get(0).getOutput(0).getValue(),b80.getTransactions().get(0).getOutput(0).getScriptPubKey()));
  Block b81=createNextBlock(b80,chainHeadHeight + 27,out26,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b81,true,false,b79.getHash(),chainHeadHeight + 27,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b81.getTransactions().get(0).getHash()),b81.getTransactions().get(0).getOutput(0).getValue(),b81.getTransactions().get(0).getOutput(0).getScriptPubKey()));
  Block b82=createNextBlock(b81,chainHeadHeight + 28,out27,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b82,true,false,b82.getHash(),chainHeadHeight + 28,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b82.getTransactions().get(0).getHash()),b82.getTransactions().get(0).getOutput(0).getValue(),b82.getTransactions().get(0).getOutput(0).getScriptPubKey()));
  HashSet<InventoryItem> post82Mempool=new HashSet<InventoryItem>();
  post82Mempool.add(new InventoryItem(InventoryItem.Type.Transaction,b78tx.getHash()));
  post82Mempool.add(new InventoryItem(InventoryItem.Type.Transaction,b79tx.getHash()));
  blocks.add(new MemoryPoolState(post82Mempool,""String_Node_Str""));
{
    TransactionOutPoint outpoint=new TransactionOutPoint(params,0,b79tx.getHash());
    long[] heights=new long[]{UTXOsMessage.MEMPOOL_HEIGHT};
    UTXOsMessage result=new UTXOsMessage(params,ImmutableList.of(b79tx.getOutput(0)),heights,b82.getHash(),chainHeadHeight + 28);
    UTXORule utxo3=new UTXORule(""String_Node_Str"",outpoint,result);
    blocks.add(utxo3);
  }
  TransactionOutPointWithValue out28=spendableOutputs.poll();
  Preconditions.checkState(out28 != null);
  Block b83=createNextBlock(b82,chainHeadHeight + 29,null,null);
{
    Transaction tx1=new Transaction(params);
    tx1.addOutput(new TransactionOutput(params,tx1,out28.value,new byte[]{OP_IF,(byte)OP_INVALIDOPCODE,OP_ELSE,OP_TRUE,OP_ENDIF}));
    addOnlyInputToTransaction(tx1,out28,0);
    b83.addTransaction(tx1);
    Transaction tx2=new Transaction(params);
    tx2.addOutput(new TransactionOutput(params,tx2,BigInteger.ZERO,new byte[]{OP_TRUE}));
    tx2.addInput(new TransactionInput(params,tx2,new byte[]{OP_FALSE},new TransactionOutPoint(params,0,tx1.getHash())));
    b83.addTransaction(tx2);
  }
  b83.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b83,true,false,b83.getHash(),chainHeadHeight + 29,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b83.getTransactions().get(0).getHash()),b83.getTransactions().get(0).getOutputs().get(0).getValue(),b83.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out29=spendableOutputs.poll();
  checkState(out29 != null);
  Block b1001=createNextBlock(b83,chainHeadHeight + 30,out29,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b1001,true,false,b1001.getHash(),chainHeadHeight + 30,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b1001.getTransactions().get(0).getHash()),b1001.getTransactions().get(0).getOutputs().get(0).getValue(),b1001.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  int nextHeight=chainHeadHeight + 31;
  if (runLargeReorgs) {
    Preconditions.checkArgument(blockStorageFile != null);
    Block lastBlock=b1001;
    TransactionOutPoint lastOutput=new TransactionOutPoint(params,2,b1001.getTransactions().get(1).getHash());
    int blockCountAfter1001;
    List<Sha256Hash> hashesToSpend=new LinkedList<Sha256Hash>();
    final int TRANSACTION_CREATION_BLOCKS=100;
    for (blockCountAfter1001=0; blockCountAfter1001 < TRANSACTION_CREATION_BLOCKS; blockCountAfter1001++) {
      Block block=createNextBlock(lastBlock,nextHeight++,null,null);
      while (block.getMessageSize() < Block.MAX_BLOCK_SIZE - 500) {
        Transaction tx=new Transaction(params);
        tx.addInput(lastOutput.getHash(),lastOutput.getIndex(),OP_NOP_SCRIPT);
        tx.addOutput(ZERO,OP_TRUE_SCRIPT);
        tx.addOutput(ZERO,OP_TRUE_SCRIPT);
        lastOutput=new TransactionOutPoint(params,1,tx.getHash());
        hashesToSpend.add(tx.getHash());
        block.addTransaction(tx);
      }
      block.solve();
      blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,block,true,false,block.getHash(),nextHeight - 1,""String_Node_Str"" + blockCountAfter1001 + ""String_Node_Str""+ TRANSACTION_CREATION_BLOCKS));
      lastBlock=block;
    }
    Iterator<Sha256Hash> hashes=hashesToSpend.iterator();
    for (int i=0; hashes.hasNext(); i++) {
      Block block=createNextBlock(lastBlock,nextHeight++,null,null);
      while (block.getMessageSize() < Block.MAX_BLOCK_SIZE - 500 && hashes.hasNext()) {
        Transaction tx=new Transaction(params);
        tx.addInput(hashes.next(),0,OP_NOP_SCRIPT);
        tx.addOutput(ZERO,OP_TRUE_SCRIPT);
        block.addTransaction(tx);
      }
      block.solve();
      blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,block,true,false,block.getHash(),nextHeight - 1,""String_Node_Str"" + i));
      lastBlock=block;
      blockCountAfter1001++;
    }
    Sha256Hash firstHash=lastBlock.getHash();
    int height=nextHeight - 1;
    nextHeight=chainHeadHeight + 26;
    lastBlock=b1001;
    for (int i=0; i < blockCountAfter1001; i++) {
      Block block=createNextBlock(lastBlock,nextHeight++,null,null);
      blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,block,true,false,firstHash,height,""String_Node_Str"" + i + ""String_Node_Str""+ blockCountAfter1001));
      lastBlock=block;
    }
    Block b1002=createNextBlock(lastBlock,nextHeight,null,null);
{
      Transaction tx=new Transaction(params);
      tx.addInput(hashesToSpend.get(0),0,OP_NOP_SCRIPT);
      tx.addOutput(ZERO,OP_TRUE_SCRIPT);
      b1002.addTransaction(tx);
    }
    b1002.solve();
    blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b1002,false,true,firstHash,height,""String_Node_Str""));
    Block b1003=createNextBlock(lastBlock,nextHeight,null,null);
    blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b1003,true,false,b1003.getHash(),nextHeight,""String_Node_Str""));
    Block b1004=createNextBlock(b1003,nextHeight + 1,null,null);
{
      Transaction tx=new Transaction(params);
      tx.addInput(hashesToSpend.get(0),0,OP_NOP_SCRIPT);
      tx.addOutput(ZERO,OP_TRUE_SCRIPT);
      b1004.addTransaction(tx);
    }
    b1004.solve();
    blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b1004,false,true,b1003.getHash(),nextHeight,""String_Node_Str""));
    ret.maximumReorgBlockCount=Math.max(ret.maximumReorgBlockCount,blockCountAfter1001);
  }
  if (outStream != null)   outStream.close();
  return ret;
}","public RuleList getBlocksToTest(boolean addSigExpensiveBlocks,boolean runLargeReorgs,File blockStorageFile) throws ScriptException, ProtocolException, IOException {
  final FileOutputStream outStream=blockStorageFile != null ? new FileOutputStream(blockStorageFile) : null;
  final Script OP_TRUE_SCRIPT=new ScriptBuilder().op(OP_TRUE).build();
  final Script OP_NOP_SCRIPT=new ScriptBuilder().op(OP_NOP).build();
  List<Rule> blocks=new LinkedList<Rule>(){
    @Override public boolean add(    Rule element){
      if (outStream != null && element instanceof BlockAndValidity) {
        try {
          outStream.write((int)(params.getPacketMagic() >>> 24));
          outStream.write((int)(params.getPacketMagic() >>> 16));
          outStream.write((int)(params.getPacketMagic() >>> 8));
          outStream.write((int)(params.getPacketMagic() >>> 0));
          byte[] block=((BlockAndValidity)element).block.bitcoinSerialize();
          byte[] length=new byte[4];
          Utils.uint32ToByteArrayBE(block.length,length,0);
          outStream.write(Utils.reverseBytes(length));
          outStream.write(block);
          ((BlockAndValidity)element).block=null;
        }
 catch (        IOException e) {
          throw new RuntimeException(e);
        }
      }
      return super.add(element);
    }
  }
;
  RuleList ret=new RuleList(blocks,hashHeaderMap,10);
  Queue<TransactionOutPointWithValue> spendableOutputs=new LinkedList<TransactionOutPointWithValue>();
  int chainHeadHeight=1;
  Block chainHead=params.getGenesisBlock().createNextBlockWithCoinbase(coinbaseOutKeyPubKey);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,chainHead,true,false,chainHead.getHash(),1,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,chainHead.getTransactions().get(0).getHash()),FIFTY_COINS,chainHead.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  for (int i=1; i < params.getSpendableCoinbaseDepth(); i++) {
    chainHead=chainHead.createNextBlockWithCoinbase(coinbaseOutKeyPubKey);
    chainHeadHeight++;
    blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,chainHead,true,false,chainHead.getHash(),i + 1,""String_Node_Str""));
    spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,chainHead.getTransactions().get(0).getHash()),FIFTY_COINS,chainHead.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  }
  Block b1=createNextBlock(chainHead,chainHeadHeight + 1,spendableOutputs.poll(),null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b1,true,false,b1.getHash(),chainHeadHeight + 1,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b1.getTransactions().get(0).getHash()),b1.getTransactions().get(0).getOutputs().get(0).getValue(),b1.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out1=spendableOutputs.poll();
  checkState(out1 != null);
  Block b2=createNextBlock(b1,chainHeadHeight + 2,out1,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b2,true,false,b2.getHash(),chainHeadHeight + 2,""String_Node_Str""));
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b2,true,false,b2.getHash(),chainHeadHeight + 2,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b2.getTransactions().get(0).getHash()),b2.getTransactions().get(0).getOutput(0).getValue(),b2.getTransactions().get(0).getOutput(0).getScriptPubKey()));
  Block b3=createNextBlock(b1,chainHeadHeight + 2,out1,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b3,true,false,b2.getHash(),chainHeadHeight + 2,""String_Node_Str""));
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b3,true,false,b2.getHash(),chainHeadHeight + 2,""String_Node_Str""));
  UTXORule utxo1;
{
    Transaction coinbase=b2.getTransactions().get(0);
    TransactionOutPoint outpoint=new TransactionOutPoint(params,0,coinbase.getHash());
    long[] heights=new long[]{chainHeadHeight + 2};
    UTXOsMessage result=new UTXOsMessage(params,ImmutableList.of(coinbase.getOutput(0)),heights,b2.getHash(),chainHeadHeight + 2);
    utxo1=new UTXORule(""String_Node_Str"",outpoint,result);
    blocks.add(utxo1);
  }
  TransactionOutPointWithValue out2=checkNotNull(spendableOutputs.poll());
  Block b4=createNextBlock(b3,chainHeadHeight + 3,out2,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b4,true,false,b4.getHash(),chainHeadHeight + 3,""String_Node_Str""));
{
    Transaction coinbase=b4.getTransactions().get(0);
    TransactionOutPoint outpoint=new TransactionOutPoint(params,0,coinbase.getHash());
    List<TransactionOutPoint> queries=ImmutableList.of(utxo1.query.get(0),outpoint);
    List<TransactionOutput> results=Lists.asList(null,coinbase.getOutput(0),new TransactionOutput[]{});
    long[] heights=new long[]{chainHeadHeight + 3};
    UTXOsMessage result=new UTXOsMessage(params,results,heights,b4.getHash(),chainHeadHeight + 3);
    UTXORule utxo2=new UTXORule(""String_Node_Str"",queries,result);
    blocks.add(utxo2);
  }
  Block b5=createNextBlock(b2,chainHeadHeight + 3,out2,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b5,true,false,b4.getHash(),chainHeadHeight + 3,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b5.getTransactions().get(0).getHash()),b5.getTransactions().get(0).getOutputs().get(0).getValue(),b5.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out3=spendableOutputs.poll();
  Block b6=createNextBlock(b5,chainHeadHeight + 4,out3,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b6,true,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  Block b7=createNextBlock(b5,chainHeadHeight + 5,out2,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b7,true,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  TransactionOutPointWithValue out4=spendableOutputs.poll();
  Block b8=createNextBlock(b7,chainHeadHeight + 6,out4,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b8,false,true,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  Block b9=createNextBlock(b6,chainHeadHeight + 5,out4,SATOSHI);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b9,false,true,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  Block b10=createNextBlock(b5,chainHeadHeight + 4,out3,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b10,true,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  Block b11=createNextBlock(b10,chainHeadHeight + 5,out4,SATOSHI);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b11,false,true,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  Block b12=createNextBlock(b5,chainHeadHeight + 4,out3,null);
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b12.getTransactions().get(0).getHash()),b12.getTransactions().get(0).getOutputs().get(0).getValue(),b12.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  Block b13=createNextBlock(b12,chainHeadHeight + 5,out4,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b13,false,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b13,false,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b13.getTransactions().get(0).getHash()),b13.getTransactions().get(0).getOutputs().get(0).getValue(),b13.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out5=spendableOutputs.poll();
  Block b14=createNextBlock(b13,chainHeadHeight + 6,out5,SATOSHI);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b14,false,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b14,false,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b12,false,true,b13.getHash(),chainHeadHeight + 5,""String_Node_Str""));
  Block b15=createNextBlock(b13,chainHeadHeight + 6,out5,null);
{
    int sigOps=0;
    for (    Transaction tx : b15.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b15.getTransactions().get(1).getHash()),SATOSHI,b15.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b15.addTransaction(tx);
  }
  b15.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b15,true,false,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b15.getTransactions().get(0).getHash()),b15.getTransactions().get(0).getOutputs().get(0).getValue(),b15.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out6=spendableOutputs.poll();
  Block b16=createNextBlock(b15,chainHeadHeight + 7,out6,null);
{
    int sigOps=0;
    for (    Transaction tx : b16.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + 1];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b16.getTransactions().get(1).getHash()),SATOSHI,b16.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b16.addTransaction(tx);
  }
  b16.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b16,false,true,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  Block b17=createNextBlock(b15,chainHeadHeight + 7,out6,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,new byte[]{}));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b3.getTransactions().get(1).getHash()),SATOSHI,b3.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b17.addTransaction(tx);
  }
  b17.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b17,false,true,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  Block b18=createNextBlock(b13,chainHeadHeight + 6,out5,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,new byte[]{}));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b3.getTransactions().get(1).getHash()),SATOSHI,b3.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b18.addTransaction(tx);
  }
  b18.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b18,true,false,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  Block b19=createNextBlock(b18,chainHeadHeight + 7,out6,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b19,false,true,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  TransactionOutPointWithValue out7=spendableOutputs.poll();
  Block b20=createNextBlock(b15,chainHeadHeight + 7,out7,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b20,false,true,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  Block b21=createNextBlock(b13,chainHeadHeight + 6,out6,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b21,true,false,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  Block b22=createNextBlock(b21,chainHeadHeight + 7,out5,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b22,false,true,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  Block b23=createNextBlock(b15,chainHeadHeight + 7,out6,null);
{
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIZE - b23.getMessageSize() - 138];
    Arrays.fill(outputScript,(byte)OP_FALSE);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b23.getTransactions().get(1).getHash()),SATOSHI,b23.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b23.addTransaction(tx);
  }
  b23.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b23,true,false,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b23.getTransactions().get(0).getHash()),b23.getTransactions().get(0).getOutputs().get(0).getValue(),b23.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  Block b24=createNextBlock(b15,chainHeadHeight + 7,out6,null);
{
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIZE - b24.getMessageSize() - 135];
    Arrays.fill(outputScript,(byte)OP_FALSE);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b24.getTransactions().get(1).getHash()),SATOSHI,b24.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b24.addTransaction(tx);
  }
  b24.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b24,false,true,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  Block b25=createNextBlock(b24,chainHeadHeight + 8,out7,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b25,false,false,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  Block b26=createNextBlock(b15,chainHeadHeight + 7,out6,null);
  b26.getTransactions().get(0).getInputs().get(0).setScriptBytes(new byte[]{0});
  b26.setMerkleRoot(null);
  b26.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b26,false,true,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  Block b27=createNextBlock(b26,chainHeadHeight + 8,out7,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b27,false,false,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  Block b28=createNextBlock(b15,chainHeadHeight + 7,out6,null);
{
    byte[] coinbase=new byte[101];
    Arrays.fill(coinbase,(byte)0);
    b28.getTransactions().get(0).getInputs().get(0).setScriptBytes(coinbase);
  }
  b28.setMerkleRoot(null);
  b28.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b28,false,true,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  Block b29=createNextBlock(b28,chainHeadHeight + 8,out7,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b29,false,false,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  Block b30=createNextBlock(b23,chainHeadHeight + 8,out7,null);
{
    byte[] coinbase=new byte[100];
    Arrays.fill(coinbase,(byte)0);
    b30.getTransactions().get(0).getInputs().get(0).setScriptBytes(coinbase);
  }
  b30.setMerkleRoot(null);
  b30.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b30,true,false,b30.getHash(),chainHeadHeight + 8,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b30.getTransactions().get(0).getHash()),b30.getTransactions().get(0).getOutputs().get(0).getValue(),b30.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out8=spendableOutputs.poll();
  Block b31=createNextBlock(b30,chainHeadHeight + 9,out8,null);
{
    int sigOps=0;
    for (    Transaction tx : b31.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[(Block.MAX_BLOCK_SIGOPS - sigOps) / 20];
    Arrays.fill(outputScript,(byte)OP_CHECKMULTISIG);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b31.getTransactions().get(1).getHash()),SATOSHI,b31.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b31.addTransaction(tx);
  }
  b31.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b31,true,false,b31.getHash(),chainHeadHeight + 9,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b31.getTransactions().get(0).getHash()),b31.getTransactions().get(0).getOutputs().get(0).getValue(),b31.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out9=spendableOutputs.poll();
  Block b32=createNextBlock(b31,chainHeadHeight + 10,out9,null);
{
    int sigOps=0;
    for (    Transaction tx : b32.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[(Block.MAX_BLOCK_SIGOPS - sigOps) / 20 + (Block.MAX_BLOCK_SIGOPS - sigOps) % 20 + 1];
    Arrays.fill(outputScript,(byte)OP_CHECKMULTISIG);
    for (int i=0; i < (Block.MAX_BLOCK_SIGOPS - sigOps) % 20; i++)     outputScript[i]=(byte)OP_CHECKSIG;
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b32.getTransactions().get(1).getHash()),SATOSHI,b32.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b32.addTransaction(tx);
  }
  b32.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b32,false,true,b31.getHash(),chainHeadHeight + 9,""String_Node_Str""));
  Block b33=createNextBlock(b31,chainHeadHeight + 10,out9,null);
{
    int sigOps=0;
    for (    Transaction tx : b33.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[(Block.MAX_BLOCK_SIGOPS - sigOps) / 20];
    Arrays.fill(outputScript,(byte)OP_CHECKMULTISIGVERIFY);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b33.getTransactions().get(1).getHash()),SATOSHI,b33.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b33.addTransaction(tx);
  }
  b33.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b33,true,false,b33.getHash(),chainHeadHeight + 10,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b33.getTransactions().get(0).getHash()),b33.getTransactions().get(0).getOutputs().get(0).getValue(),b33.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out10=spendableOutputs.poll();
  Block b34=createNextBlock(b33,chainHeadHeight + 11,out10,null);
{
    int sigOps=0;
    for (    Transaction tx : b34.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[(Block.MAX_BLOCK_SIGOPS - sigOps) / 20 + (Block.MAX_BLOCK_SIGOPS - sigOps) % 20 + 1];
    Arrays.fill(outputScript,(byte)OP_CHECKMULTISIGVERIFY);
    for (int i=0; i < (Block.MAX_BLOCK_SIGOPS - sigOps) % 20; i++)     outputScript[i]=(byte)OP_CHECKSIG;
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b34.getTransactions().get(1).getHash()),SATOSHI,b34.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b34.addTransaction(tx);
  }
  b34.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b34,false,true,b33.getHash(),chainHeadHeight + 10,""String_Node_Str""));
  Block b35=createNextBlock(b33,chainHeadHeight + 11,out10,null);
{
    int sigOps=0;
    for (    Transaction tx : b35.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps];
    Arrays.fill(outputScript,(byte)OP_CHECKSIGVERIFY);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b35.getTransactions().get(1).getHash()),SATOSHI,b35.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b35.addTransaction(tx);
  }
  b35.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b35,true,false,b35.getHash(),chainHeadHeight + 11,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b35.getTransactions().get(0).getHash()),b35.getTransactions().get(0).getOutputs().get(0).getValue(),b35.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out11=spendableOutputs.poll();
  Block b36=createNextBlock(b35,chainHeadHeight + 12,out11,null);
{
    int sigOps=0;
    for (    Transaction tx : b36.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + 1];
    Arrays.fill(outputScript,(byte)OP_CHECKSIGVERIFY);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b36.getTransactions().get(1).getHash()),SATOSHI,b36.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b36.addTransaction(tx);
  }
  b36.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b36,false,true,b35.getHash(),chainHeadHeight + 11,""String_Node_Str""));
  Block b37=createNextBlock(b35,chainHeadHeight + 12,out11,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,new byte[]{}));
    addOnlyInputToTransaction(tx,out11);
    b37.addTransaction(tx);
  }
  b37.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b37,false,true,b35.getHash(),chainHeadHeight + 11,""String_Node_Str""));
  Block b38=createNextBlock(b35,chainHeadHeight + 12,out11,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,new byte[]{}));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b37.getTransactions().get(1).getHash()),SATOSHI,b37.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b38.addTransaction(tx);
  }
  b38.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b38,false,true,b35.getHash(),chainHeadHeight + 11,""String_Node_Str""));
  byte[] b39p2shScriptPubKey;
  int b39numP2SHOutputs=0, b39sigOpsPerOutput=6;
  Block b39=createNextBlock(b35,chainHeadHeight + 12,null,null);
{
    ByteArrayOutputStream p2shScriptPubKey=new UnsafeByteArrayOutputStream();
    try {
      Script.writeBytes(p2shScriptPubKey,coinbaseOutKeyPubKey);
      p2shScriptPubKey.write(OP_2DUP);
      p2shScriptPubKey.write(OP_CHECKSIGVERIFY);
      p2shScriptPubKey.write(OP_2DUP);
      p2shScriptPubKey.write(OP_CHECKSIGVERIFY);
      p2shScriptPubKey.write(OP_2DUP);
      p2shScriptPubKey.write(OP_CHECKSIGVERIFY);
      p2shScriptPubKey.write(OP_2DUP);
      p2shScriptPubKey.write(OP_CHECKSIGVERIFY);
      p2shScriptPubKey.write(OP_2DUP);
      p2shScriptPubKey.write(OP_CHECKSIGVERIFY);
      p2shScriptPubKey.write(OP_CHECKSIG);
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
    b39p2shScriptPubKey=p2shScriptPubKey.toByteArray();
    byte[] scriptHash=Utils.sha256hash160(b39p2shScriptPubKey);
    UnsafeByteArrayOutputStream scriptPubKey=new UnsafeByteArrayOutputStream(scriptHash.length + 3);
    scriptPubKey.write(OP_HASH160);
    try {
      Script.writeBytes(scriptPubKey,scriptHash);
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
    scriptPubKey.write(OP_EQUAL);
    Coin lastOutputValue=out11.value.subtract(SATOSHI);
    TransactionOutPoint lastOutPoint;
{
      Transaction tx=new Transaction(params);
      tx.addOutput(new TransactionOutput(params,tx,SATOSHI,scriptPubKey.toByteArray()));
      tx.addOutput(new TransactionOutput(params,tx,lastOutputValue,new byte[]{OP_1}));
      addOnlyInputToTransaction(tx,out11);
      lastOutPoint=new TransactionOutPoint(params,1,tx.getHash());
      b39.addTransaction(tx);
    }
    b39numP2SHOutputs++;
    while (b39.getMessageSize() < Block.MAX_BLOCK_SIZE) {
      Transaction tx=new Transaction(params);
      lastOutputValue=lastOutputValue.subtract(SATOSHI);
      tx.addOutput(new TransactionOutput(params,tx,SATOSHI,scriptPubKey.toByteArray()));
      tx.addOutput(new TransactionOutput(params,tx,lastOutputValue,new byte[]{OP_1}));
      tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},lastOutPoint));
      lastOutPoint=new TransactionOutPoint(params,1,tx.getHash());
      if (b39.getMessageSize() + tx.getMessageSize() < Block.MAX_BLOCK_SIZE) {
        b39.addTransaction(tx);
        b39numP2SHOutputs++;
      }
 else       break;
    }
  }
  b39.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b39,true,false,b39.getHash(),chainHeadHeight + 12,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b39.getTransactions().get(0).getHash()),b39.getTransactions().get(0).getOutputs().get(0).getValue(),b39.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out12=spendableOutputs.poll();
  Block b40=createNextBlock(b39,chainHeadHeight + 13,out12,null);
{
    int sigOps=0;
    for (    Transaction tx : b40.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    int numTxes=(Block.MAX_BLOCK_SIGOPS - sigOps) / b39sigOpsPerOutput;
    checkState(numTxes <= b39numP2SHOutputs);
    TransactionOutPoint lastOutPoint=new TransactionOutPoint(params,2,b40.getTransactions().get(1).getHash());
    byte[] scriptSig=null;
    for (int i=1; i <= numTxes; i++) {
      Transaction tx=new Transaction(params);
      tx.addOutput(new TransactionOutput(params,tx,SATOSHI,new byte[]{OP_1}));
      tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},lastOutPoint));
      TransactionInput input=new TransactionInput(params,tx,new byte[]{},new TransactionOutPoint(params,0,b39.getTransactions().get(i).getHash()));
      tx.addInput(input);
      if (scriptSig == null) {
        Sha256Hash hash=tx.hashForSignature(1,b39p2shScriptPubKey,SigHash.SINGLE,false);
        try {
          ByteArrayOutputStream bos=new UnsafeByteArrayOutputStream(73);
          bos.write(coinbaseOutKey.sign(hash).encodeToDER());
          bos.write(SigHash.SINGLE.ordinal() + 1);
          byte[] signature=bos.toByteArray();
          ByteArrayOutputStream scriptSigBos=new UnsafeByteArrayOutputStream(signature.length + b39p2shScriptPubKey.length + 3);
          Script.writeBytes(scriptSigBos,new byte[]{(byte)OP_CHECKSIG});
          scriptSigBos.write(Script.createInputScript(signature));
          Script.writeBytes(scriptSigBos,b39p2shScriptPubKey);
          scriptSig=scriptSigBos.toByteArray();
        }
 catch (        IOException e) {
          throw new RuntimeException(e);
        }
      }
      input.setScriptBytes(scriptSig);
      lastOutPoint=new TransactionOutPoint(params,0,tx.getHash());
      b40.addTransaction(tx);
    }
    sigOps+=numTxes * b39sigOpsPerOutput;
    Transaction tx=new Transaction(params);
    tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},lastOutPoint));
    byte[] scriptPubKey=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + 1];
    Arrays.fill(scriptPubKey,(byte)OP_CHECKSIG);
    tx.addOutput(new TransactionOutput(params,tx,ZERO,scriptPubKey));
    b40.addTransaction(tx);
  }
  b40.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b40,false,true,b39.getHash(),chainHeadHeight + 12,""String_Node_Str""));
  Block b41=null;
  if (addSigExpensiveBlocks) {
    b41=createNextBlock(b39,chainHeadHeight + 13,out12,null);
{
      int sigOps=0;
      for (      Transaction tx : b41.transactions) {
        sigOps+=tx.getSigOpCount();
      }
      int numTxes=(Block.MAX_BLOCK_SIGOPS - sigOps) / b39sigOpsPerOutput;
      checkState(numTxes <= b39numP2SHOutputs);
      TransactionOutPoint lastOutPoint=new TransactionOutPoint(params,2,b41.getTransactions().get(1).getHash());
      byte[] scriptSig=null;
      for (int i=1; i <= numTxes; i++) {
        Transaction tx=new Transaction(params);
        tx.addOutput(new TransactionOutput(params,tx,Coin.SATOSHI,new byte[]{OP_1}));
        tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},lastOutPoint));
        TransactionInput input=new TransactionInput(params,tx,new byte[]{},new TransactionOutPoint(params,0,b39.getTransactions().get(i).getHash()));
        tx.addInput(input);
        if (scriptSig == null) {
          Sha256Hash hash=tx.hashForSignature(1,b39p2shScriptPubKey,SigHash.SINGLE,false);
          try {
            ByteArrayOutputStream bos=new UnsafeByteArrayOutputStream(73);
            bos.write(coinbaseOutKey.sign(hash).encodeToDER());
            bos.write(SigHash.SINGLE.ordinal() + 1);
            byte[] signature=bos.toByteArray();
            ByteArrayOutputStream scriptSigBos=new UnsafeByteArrayOutputStream(signature.length + b39p2shScriptPubKey.length + 3);
            Script.writeBytes(scriptSigBos,new byte[]{(byte)OP_CHECKSIG});
            scriptSigBos.write(Script.createInputScript(signature));
            Script.writeBytes(scriptSigBos,b39p2shScriptPubKey);
            scriptSig=scriptSigBos.toByteArray();
          }
 catch (          IOException e) {
            throw new RuntimeException(e);
          }
        }
        input.setScriptBytes(scriptSig);
        lastOutPoint=new TransactionOutPoint(params,0,tx.getHash());
        b41.addTransaction(tx);
      }
      sigOps+=numTxes * b39sigOpsPerOutput;
      Transaction tx=new Transaction(params);
      tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},lastOutPoint));
      byte[] scriptPubKey=new byte[Block.MAX_BLOCK_SIGOPS - sigOps];
      Arrays.fill(scriptPubKey,(byte)OP_CHECKSIG);
      tx.addOutput(new TransactionOutput(params,tx,ZERO,scriptPubKey));
      b41.addTransaction(tx);
    }
    b41.solve();
    blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b41,true,false,b41.getHash(),chainHeadHeight + 13,""String_Node_Str""));
  }
  Block b42=createNextBlock(b39,chainHeadHeight + 13,out12,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b42,true,false,b41 == null ? b42.getHash() : b41.getHash(),chainHeadHeight + 13,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b42.getTransactions().get(0).getHash()),b42.getTransactions().get(0).getOutputs().get(0).getValue(),b42.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out13=spendableOutputs.poll();
  Block b43=createNextBlock(b42,chainHeadHeight + 14,out13,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b43,true,false,b43.getHash(),chainHeadHeight + 14,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b43.getTransactions().get(0).getHash()),b43.getTransactions().get(0).getOutputs().get(0).getValue(),b43.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out14=spendableOutputs.poll();
  Block b44=new Block(params);
  byte[] outScriptBytes=ScriptBuilder.createOutputScript(ECKey.fromPublicOnly(coinbaseOutKeyPubKey)).getProgram();
{
    b44.setDifficultyTarget(b43.getDifficultyTarget());
    b44.addCoinbaseTransaction(coinbaseOutKeyPubKey,ZERO);
    Transaction t=new Transaction(params);
    t.addOutput(new TransactionOutput(params,t,ZERO,new byte[]{OP_PUSHDATA1 - 1}));
    t.addOutput(new TransactionOutput(params,t,SATOSHI,outScriptBytes));
    t.addOutput(new TransactionOutput(params,t,ZERO,new byte[]{OP_1}));
    addOnlyInputToTransaction(t,out14);
    b44.addTransaction(t);
    b44.setPrevBlockHash(b43.getHash());
    b44.setTime(b43.getTimeSeconds() + 1);
  }
  b44.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b44,true,false,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  TransactionOutPointWithValue out15=spendableOutputs.poll();
  Block b45=new Block(params);
{
    b45.setDifficultyTarget(b44.getDifficultyTarget());
    Transaction t=new Transaction(params);
    t.addOutput(new TransactionOutput(params,t,ZERO,new byte[]{OP_PUSHDATA1 - 1}));
    t.addOutput(new TransactionOutput(params,t,SATOSHI,outScriptBytes));
    t.addOutput(new TransactionOutput(params,t,ZERO,new byte[]{OP_1}));
    addOnlyInputToTransaction(t,out15);
    try {
      b45.addTransaction(t);
    }
 catch (    RuntimeException e) {
    }
    if (b45.getTransactions().size() > 0)     throw new RuntimeException(""String_Node_Str"");
    b45.addTransaction(t,false);
    b45.setPrevBlockHash(b44.getHash());
    b45.setTime(b44.getTimeSeconds() + 1);
  }
  b45.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b45,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b46=new Block(params);
{
    b46.transactions=new ArrayList<Transaction>();
    b46.setDifficultyTarget(b44.getDifficultyTarget());
    b46.setMerkleRoot(Sha256Hash.ZERO_HASH);
    b46.setPrevBlockHash(b44.getHash());
    b46.setTime(b44.getTimeSeconds() + 1);
  }
  b46.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b46,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b47=createNextBlock(b44,chainHeadHeight + 16,out15,null);
{
    try {
      BigInteger target=b47.getDifficultyTargetAsInteger();
      while (true) {
        BigInteger h=b47.getHash().toBigInteger();
        if (h.compareTo(target) > 0)         break;
        b47.setNonce(b47.getNonce() + 1);
      }
    }
 catch (    VerificationException e) {
      throw new RuntimeException(e);
    }
  }
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b47,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b48=createNextBlock(b44,chainHeadHeight + 16,out15,null);
  b48.setTime(Utils.currentTimeSeconds() + 60 * 60 * 3);
  b48.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b48,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b49=createNextBlock(b44,chainHeadHeight + 16,out15,null);
  byte[] b49MerkleHash=Sha256Hash.ZERO_HASH.getBytes().clone();
  b49MerkleHash[1]=(byte)0xDE;
  b49.setMerkleRoot(Sha256Hash.create(b49MerkleHash));
  b49.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b49,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b50=createNextBlock(b44,chainHeadHeight + 16,out15,null);
{
    long diffTarget=b44.getDifficultyTarget();
    diffTarget&=0xFFBFFFFF;
    b50.setDifficultyTarget(diffTarget);
  }
  b50.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b50,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b51=createNextBlock(b44,chainHeadHeight + 16,out15,null);
{
    Transaction coinbase=new Transaction(params);
    coinbase.addInput(new TransactionInput(params,coinbase,new byte[]{(byte)0xff,110,1}));
    coinbase.addOutput(new TransactionOutput(params,coinbase,SATOSHI,outScriptBytes));
    b51.addTransaction(coinbase,false);
  }
  b51.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b51,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b52=createNextBlock(b44,chainHeadHeight + 16,out15,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,new byte[]{}));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b52.getTransactions().get(1).getHash()),SATOSHI,b52.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b52.addTransaction(tx);
    b52.addTransaction(tx);
  }
  b52.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b52,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b53=createNextBlock(b43,chainHeadHeight + 15,out14,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b53,true,false,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b53.getTransactions().get(0).getHash()),b53.getTransactions().get(0).getOutputs().get(0).getValue(),b53.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  Block b54=createNextBlock(b53,chainHeadHeight + 16,out15,null);
  b54.setTime(b35.getTimeSeconds() - 1);
  b54.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b54,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b55=createNextBlock(b53,chainHeadHeight + 16,out15,null);
  b55.setTime(b35.getTimeSeconds());
  b55.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b55,true,false,b55.getHash(),chainHeadHeight + 16,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b55.getTransactions().get(0).getHash()),b55.getTransactions().get(0).getOutputs().get(0).getValue(),b55.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out16=spendableOutputs.poll();
  Block b57=createNextBlock(b55,chainHeadHeight + 17,out16,null);
  Transaction b56txToDuplicate;
{
    b56txToDuplicate=new Transaction(params);
    b56txToDuplicate.addOutput(new TransactionOutput(params,b56txToDuplicate,SATOSHI,new byte[]{}));
    addOnlyInputToTransaction(b56txToDuplicate,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b57.getTransactions().get(1).getHash()),SATOSHI,b57.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b57.addTransaction(b56txToDuplicate);
  }
  b57.solve();
  Block b56;
  try {
    b56=new Block(params,b57.bitcoinSerialize());
  }
 catch (  ProtocolException e) {
    throw new RuntimeException(e);
  }
  b56.addTransaction(b56txToDuplicate);
  checkState(b56.getHash().equals(b57.getHash()));
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b56,false,true,b55.getHash(),chainHeadHeight + 16,""String_Node_Str""));
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b57,true,false,b57.getHash(),chainHeadHeight + 17,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b57.getTransactions().get(0).getHash()),b57.getTransactions().get(0).getOutputs().get(0).getValue(),b57.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out17=spendableOutputs.poll();
  Block b58=createNextBlock(b57,chainHeadHeight + 18,out17,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,ZERO,new byte[]{}));
    tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},new TransactionOutPoint(params,3,b58.getTransactions().get(1).getHash())));
    b58.addTransaction(tx);
  }
  b58.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b58,false,true,b57.getHash(),chainHeadHeight + 17,""String_Node_Str""));
  Block b59=createNextBlock(b57,chainHeadHeight + 18,out17,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,b59.getTransactions().get(1).getOutputs().get(2).getValue().add(SATOSHI),new byte[]{}));
    tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},new TransactionOutPoint(params,2,b59.getTransactions().get(1).getHash())));
    b59.addTransaction(tx);
  }
  b59.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b59,false,true,b57.getHash(),chainHeadHeight + 17,""String_Node_Str""));
  Block b60=createNextBlock(b57,chainHeadHeight + 18,out17,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b60,true,false,b60.getHash(),chainHeadHeight + 18,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b60.getTransactions().get(0).getHash()),b60.getTransactions().get(0).getOutputs().get(0).getValue(),b60.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out18=spendableOutputs.poll();
  Block b61=createNextBlock(b60,chainHeadHeight + 19,out18,null);
{
    b61.getTransactions().get(0).getInput(0).setScriptBytes(b60.getTransactions().get(0).getInput(0).getScriptBytes());
    b61.unCache();
    checkState(b61.getTransactions().get(0).equals(b60.getTransactions().get(0)));
  }
  b61.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b61,false,true,b60.getHash(),chainHeadHeight + 18,""String_Node_Str""));
  Block b62=createNextBlock(b60,chainHeadHeight + 19,null,null);
{
    Transaction tx=new Transaction(params);
    tx.setLockTime(0xffffffffL);
    tx.addOutput(ZERO,OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(tx,out18,0);
    b62.addTransaction(tx);
    checkState(!tx.isFinal(chainHeadHeight + 17,b62.getTimeSeconds()));
  }
  b62.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b62,false,true,b60.getHash(),chainHeadHeight + 18,""String_Node_Str""));
  Block b63=createNextBlock(b60,chainHeadHeight + 19,null,null);
{
    b63.getTransactions().get(0).setLockTime(0xffffffffL);
    b63.getTransactions().get(0).getInputs().get(0).setSequenceNumber(0xDEADBEEF);
    checkState(!b63.getTransactions().get(0).isFinal(chainHeadHeight + 17,b63.getTimeSeconds()));
  }
  b63.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b63,false,true,b60.getHash(),chainHeadHeight + 18,""String_Node_Str""));
  Block b64;
{
    Block b64Created=createNextBlock(b60,chainHeadHeight + 19,out18,null);
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIZE - b64Created.getMessageSize() - 138];
    Arrays.fill(outputScript,(byte)OP_FALSE);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b64Created.getTransactions().get(1).getHash()),SATOSHI,b64Created.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b64Created.addTransaction(tx);
    b64Created.solve();
    UnsafeByteArrayOutputStream stream=new UnsafeByteArrayOutputStream(b64Created.getMessageSize() + 8);
    b64Created.writeHeader(stream);
    byte[] varIntBytes=new byte[9];
    varIntBytes[0]=(byte)255;
    Utils.uint32ToByteArrayLE((long)b64Created.getTransactions().size(),varIntBytes,1);
    Utils.uint32ToByteArrayLE(((long)b64Created.getTransactions().size()) >>> 32,varIntBytes,5);
    stream.write(varIntBytes);
    checkState(new VarInt(varIntBytes,0).value == b64Created.getTransactions().size());
    for (    Transaction transaction : b64Created.getTransactions())     transaction.bitcoinSerialize(stream);
    b64=new Block(params,stream.toByteArray(),false,true,stream.size());
    checkState(stream.size() == b64Created.getMessageSize() + 8);
    checkState(stream.size() == b64.getMessageSize());
    checkState(Arrays.equals(stream.toByteArray(),b64.bitcoinSerialize()));
    checkState(b64.getOptimalEncodingMessageSize() == b64Created.getMessageSize());
  }
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b64,true,false,b64.getHash(),chainHeadHeight + 19,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b64.getTransactions().get(0).getHash()),b64.getTransactions().get(0).getOutputs().get(0).getValue(),b64.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out19=spendableOutputs.poll();
  checkState(out19 != null);
  Block b65=createNextBlock(b64,chainHeadHeight + 20,null,null);
{
    Transaction tx1=new Transaction(params);
    tx1.addOutput(out19.value,OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(tx1,out19,0);
    b65.addTransaction(tx1);
    Transaction tx2=new Transaction(params);
    tx2.addOutput(ZERO,OP_TRUE_SCRIPT);
    tx2.addInput(tx1.getHash(),0,OP_TRUE_SCRIPT);
    b65.addTransaction(tx2);
  }
  b65.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b65,true,false,b65.getHash(),chainHeadHeight + 20,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b65.getTransactions().get(0).getHash()),b65.getTransactions().get(0).getOutputs().get(0).getValue(),b65.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out20=spendableOutputs.poll();
  checkState(out20 != null);
  Block b66=createNextBlock(b65,chainHeadHeight + 21,null,null);
{
    Transaction tx1=new Transaction(params);
    tx1.addOutput(out20.value,OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(tx1,out20,0);
    Transaction tx2=new Transaction(params);
    tx2.addOutput(ZERO,OP_TRUE_SCRIPT);
    tx2.addInput(tx1.getHash(),0,OP_NOP_SCRIPT);
    b66.addTransaction(tx2);
    b66.addTransaction(tx1);
  }
  b66.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b66,false,true,b65.getHash(),chainHeadHeight + 20,""String_Node_Str""));
  Block b67=createNextBlock(b65,chainHeadHeight + 21,null,null);
{
    Transaction tx1=new Transaction(params);
    tx1.addOutput(out20.value,OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(tx1,out20,0);
    b67.addTransaction(tx1);
    Transaction tx2=new Transaction(params);
    tx2.addOutput(ZERO,OP_TRUE_SCRIPT);
    tx2.addInput(tx1.getHash(),0,OP_NOP_SCRIPT);
    b67.addTransaction(tx2);
    Transaction tx3=new Transaction(params);
    tx3.addOutput(out20.value,OP_TRUE_SCRIPT);
    tx3.addInput(tx1.getHash(),0,OP_NOP_SCRIPT);
    b67.addTransaction(tx3);
  }
  b67.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b67,false,true,b65.getHash(),chainHeadHeight + 20,""String_Node_Str""));
  Block b68=createNextBlock(b65,chainHeadHeight + 21,null,SATOSHI.multiply(10));
{
    Transaction tx=new Transaction(params);
    tx.addOutput(out20.value.subtract(Coin.valueOf(9)),OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(tx,out20,0);
    b68.addTransaction(tx);
  }
  b68.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b68,false,true,b65.getHash(),chainHeadHeight + 20,""String_Node_Str""));
  Block b69=createNextBlock(b65,chainHeadHeight + 21,null,SATOSHI.multiply(10));
{
    Transaction tx=new Transaction(params);
    tx.addOutput(out20.value.subtract(Coin.valueOf(10)),OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(tx,out20,0);
    b69.addTransaction(tx);
  }
  b69.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b69,true,false,b69.getHash(),chainHeadHeight + 21,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b69.getTransactions().get(0).getHash()),b69.getTransactions().get(0).getOutputs().get(0).getValue(),b69.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out21=spendableOutputs.poll();
  checkState(out21 != null);
  Block b70=createNextBlock(b69,chainHeadHeight + 22,out21,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(ZERO,OP_TRUE_SCRIPT);
    tx.addInput(new Sha256Hash(""String_Node_Str""),0,OP_NOP_SCRIPT);
    b70.addTransaction(tx);
  }
  b70.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b70,false,true,b69.getHash(),chainHeadHeight + 21,""String_Node_Str""));
  Block b72=createNextBlock(b69,chainHeadHeight + 22,out21,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(ZERO,OP_TRUE_SCRIPT);
    final Transaction tx2=b72.getTransactions().get(1);
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,tx2.getHash()),SATOSHI,tx2.getOutput(1).getScriptPubKey()));
    b72.addTransaction(tx);
  }
  b72.solve();
  Block b71=new Block(params,b72.bitcoinSerialize());
  b71.addTransaction(b72.getTransactions().get(2));
  checkState(b71.getHash().equals(b72.getHash()));
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b71,false,true,b69.getHash(),chainHeadHeight + 21,""String_Node_Str""));
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b72,true,false,b72.getHash(),chainHeadHeight + 22,""String_Node_Str""));
  final Transaction b72tx=b72.getTransactions().get(0);
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b72tx.getHash()),b72tx.getOutput(0).getValue(),b72tx.getOutput(0).getScriptPubKey()));
  TransactionOutPointWithValue out22=spendableOutputs.poll();
  checkState(out22 != null);
  Block b73=createNextBlock(b72,chainHeadHeight + 23,out22,null);
{
    int sigOps=0;
    for (    Transaction tx : b73.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + (int)Script.MAX_SCRIPT_ELEMENT_SIZE + 1 + 5 + 1];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps]=OP_PUSHDATA4;
    Utils.uint32ToByteArrayLE(Script.MAX_SCRIPT_ELEMENT_SIZE + 1,outputScript,Block.MAX_BLOCK_SIGOPS - sigOps + 1);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b73.getTransactions().get(1).getHash()),SATOSHI,b73.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b73.addTransaction(tx);
  }
  b73.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b73,false,true,b72.getHash(),chainHeadHeight + 22,""String_Node_Str""));
  Block b74=createNextBlock(b72,chainHeadHeight + 23,out22,null);
{
    int sigOps=0;
    for (    Transaction tx : b74.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + (int)Script.MAX_SCRIPT_ELEMENT_SIZE + 42];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 1]=OP_PUSHDATA4;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 2]=(byte)0xfe;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 3]=(byte)0xff;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 4]=(byte)0xff;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 5]=(byte)0xff;
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b74.getTransactions().get(1).getHash()),SATOSHI,b74.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b74.addTransaction(tx);
  }
  b74.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b74,false,true,b72.getHash(),chainHeadHeight + 22,""String_Node_Str""));
  Block b75=createNextBlock(b72,chainHeadHeight + 23,out22,null);
{
    int sigOps=0;
    for (    Transaction tx : b75.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + (int)Script.MAX_SCRIPT_ELEMENT_SIZE + 42];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps]=OP_PUSHDATA4;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 1]=(byte)0xff;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 2]=(byte)0xff;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 3]=(byte)0xff;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 4]=(byte)0xff;
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b75.getTransactions().get(1).getHash()),SATOSHI,b75.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b75.addTransaction(tx);
  }
  b75.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b75,true,false,b75.getHash(),chainHeadHeight + 23,""String_Node_Str""));
  final Transaction b75tx=b75.getTransactions().get(0);
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b75tx.getHash()),b75tx.getOutput(0).getValue(),b75tx.getOutput(0).getScriptPubKey()));
  TransactionOutPointWithValue out23=spendableOutputs.poll();
  checkState(out23 != null);
  Block b76=createNextBlock(b75,chainHeadHeight + 24,out23,null);
{
    int sigOps=0;
    for (    Transaction tx : b76.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + (int)Script.MAX_SCRIPT_ELEMENT_SIZE + 1 + 5];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps]=OP_PUSHDATA4;
    Utils.uint32ToByteArrayLE(Block.MAX_BLOCK_SIGOPS,outputScript,Block.MAX_BLOCK_SIGOPS - sigOps + 1);
    tx.addOutput(new TransactionOutput(params,tx,SATOSHI,outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b76.getTransactions().get(1).getHash()),SATOSHI,b76.getTransactions().get(1).getOutput(1).getScriptPubKey()));
    b76.addTransaction(tx);
  }
  b76.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b76,true,false,b76.getHash(),chainHeadHeight + 24,""String_Node_Str""));
  final Transaction b76tx=b76.getTransactions().get(0);
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b76tx.getHash()),b76tx.getOutput(0).getValue(),b76tx.getOutput(0).getScriptPubKey()));
  TransactionOutPointWithValue out24=checkNotNull(spendableOutputs.poll());
  TransactionOutPointWithValue out25=checkNotNull(spendableOutputs.poll());
  TransactionOutPointWithValue out26=checkNotNull(spendableOutputs.poll());
  TransactionOutPointWithValue out27=checkNotNull(spendableOutputs.poll());
  Block b77=createNextBlock(b76,chainHeadHeight + 25,out24,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b77,true,false,b77.getHash(),chainHeadHeight + 25,""String_Node_Str""));
  Block b78=createNextBlock(b77,chainHeadHeight + 26,out25,null);
  Transaction b78tx=new Transaction(params);
{
    b78tx.addOutput(ZERO,OP_TRUE_SCRIPT);
    addOnlyInputToTransaction(b78tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b77.getTransactions().get(1).getHash()),SATOSHI,b77.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b78.addTransaction(b78tx);
  }
  b78.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b78,true,false,b78.getHash(),chainHeadHeight + 26,""String_Node_Str""));
  Block b79=createNextBlock(b78,chainHeadHeight + 27,out26,null);
  Transaction b79tx=new Transaction(params);
{
    b79tx.addOutput(ZERO,OP_TRUE_SCRIPT);
    b79tx.addInput(b78tx.getHash(),0,OP_NOP_SCRIPT);
    b79.addTransaction(b79tx);
  }
  b79.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b79,true,false,b79.getHash(),chainHeadHeight + 27,""String_Node_Str""));
  blocks.add(new MemoryPoolState(new HashSet<InventoryItem>(),""String_Node_Str""));
  Block b80=createNextBlock(b77,chainHeadHeight + 26,out25,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b80,true,false,b79.getHash(),chainHeadHeight + 27,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b80.getTransactions().get(0).getHash()),b80.getTransactions().get(0).getOutput(0).getValue(),b80.getTransactions().get(0).getOutput(0).getScriptPubKey()));
  Block b81=createNextBlock(b80,chainHeadHeight + 27,out26,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b81,true,false,b79.getHash(),chainHeadHeight + 27,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b81.getTransactions().get(0).getHash()),b81.getTransactions().get(0).getOutput(0).getValue(),b81.getTransactions().get(0).getOutput(0).getScriptPubKey()));
  Block b82=createNextBlock(b81,chainHeadHeight + 28,out27,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b82,true,false,b82.getHash(),chainHeadHeight + 28,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b82.getTransactions().get(0).getHash()),b82.getTransactions().get(0).getOutput(0).getValue(),b82.getTransactions().get(0).getOutput(0).getScriptPubKey()));
  HashSet<InventoryItem> post82Mempool=new HashSet<InventoryItem>();
  post82Mempool.add(new InventoryItem(InventoryItem.Type.Transaction,b78tx.getHash()));
  post82Mempool.add(new InventoryItem(InventoryItem.Type.Transaction,b79tx.getHash()));
  blocks.add(new MemoryPoolState(post82Mempool,""String_Node_Str""));
{
    TransactionOutPoint outpoint=new TransactionOutPoint(params,0,b79tx.getHash());
    long[] heights=new long[]{UTXOsMessage.MEMPOOL_HEIGHT};
    UTXOsMessage result=new UTXOsMessage(params,ImmutableList.of(b79tx.getOutput(0)),heights,b82.getHash(),chainHeadHeight + 28);
    UTXORule utxo3=new UTXORule(""String_Node_Str"",outpoint,result);
    blocks.add(utxo3);
  }
  TransactionOutPointWithValue out28=spendableOutputs.poll();
  Preconditions.checkState(out28 != null);
  Block b83=createNextBlock(b82,chainHeadHeight + 29,null,null);
{
    Transaction tx1=new Transaction(params);
    tx1.addOutput(new TransactionOutput(params,tx1,out28.value,new byte[]{OP_IF,(byte)OP_INVALIDOPCODE,OP_ELSE,OP_TRUE,OP_ENDIF}));
    addOnlyInputToTransaction(tx1,out28,0);
    b83.addTransaction(tx1);
    Transaction tx2=new Transaction(params);
    tx2.addOutput(new TransactionOutput(params,tx2,BigInteger.ZERO,new byte[]{OP_TRUE}));
    tx2.addInput(new TransactionInput(params,tx2,new byte[]{OP_FALSE},new TransactionOutPoint(params,0,tx1.getHash())));
    b83.addTransaction(tx2);
  }
  b83.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b83,true,false,b83.getHash(),chainHeadHeight + 29,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b83.getTransactions().get(0).getHash()),b83.getTransactions().get(0).getOutputs().get(0).getValue(),b83.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out29=spendableOutputs.poll();
  checkState(out29 != null);
  Block b1001=createNextBlock(b83,chainHeadHeight + 30,out29,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b1001,true,false,b1001.getHash(),chainHeadHeight + 30,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b1001.getTransactions().get(0).getHash()),b1001.getTransactions().get(0).getOutputs().get(0).getValue(),b1001.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  int nextHeight=chainHeadHeight + 31;
  if (runLargeReorgs) {
    Preconditions.checkArgument(blockStorageFile != null);
    Block lastBlock=b1001;
    TransactionOutPoint lastOutput=new TransactionOutPoint(params,2,b1001.getTransactions().get(1).getHash());
    int blockCountAfter1001;
    List<Sha256Hash> hashesToSpend=new LinkedList<Sha256Hash>();
    final int TRANSACTION_CREATION_BLOCKS=100;
    for (blockCountAfter1001=0; blockCountAfter1001 < TRANSACTION_CREATION_BLOCKS; blockCountAfter1001++) {
      Block block=createNextBlock(lastBlock,nextHeight++,null,null);
      while (block.getMessageSize() < Block.MAX_BLOCK_SIZE - 500) {
        Transaction tx=new Transaction(params);
        tx.addInput(lastOutput.getHash(),lastOutput.getIndex(),OP_NOP_SCRIPT);
        tx.addOutput(ZERO,OP_TRUE_SCRIPT);
        tx.addOutput(ZERO,OP_TRUE_SCRIPT);
        lastOutput=new TransactionOutPoint(params,1,tx.getHash());
        hashesToSpend.add(tx.getHash());
        block.addTransaction(tx);
      }
      block.solve();
      blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,block,true,false,block.getHash(),nextHeight - 1,""String_Node_Str"" + blockCountAfter1001 + ""String_Node_Str""+ TRANSACTION_CREATION_BLOCKS));
      lastBlock=block;
    }
    Iterator<Sha256Hash> hashes=hashesToSpend.iterator();
    for (int i=0; hashes.hasNext(); i++) {
      Block block=createNextBlock(lastBlock,nextHeight++,null,null);
      while (block.getMessageSize() < Block.MAX_BLOCK_SIZE - 500 && hashes.hasNext()) {
        Transaction tx=new Transaction(params);
        tx.addInput(hashes.next(),0,OP_NOP_SCRIPT);
        tx.addOutput(ZERO,OP_TRUE_SCRIPT);
        block.addTransaction(tx);
      }
      block.solve();
      blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,block,true,false,block.getHash(),nextHeight - 1,""String_Node_Str"" + i));
      lastBlock=block;
      blockCountAfter1001++;
    }
    Sha256Hash firstHash=lastBlock.getHash();
    int height=nextHeight - 1;
    nextHeight=chainHeadHeight + 26;
    lastBlock=b1001;
    for (int i=0; i < blockCountAfter1001; i++) {
      Block block=createNextBlock(lastBlock,nextHeight++,null,null);
      blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,block,true,false,firstHash,height,""String_Node_Str"" + i + ""String_Node_Str""+ blockCountAfter1001));
      lastBlock=block;
    }
    Block b1002=createNextBlock(lastBlock,nextHeight,null,null);
{
      Transaction tx=new Transaction(params);
      tx.addInput(hashesToSpend.get(0),0,OP_NOP_SCRIPT);
      tx.addOutput(ZERO,OP_TRUE_SCRIPT);
      b1002.addTransaction(tx);
    }
    b1002.solve();
    blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b1002,false,true,firstHash,height,""String_Node_Str""));
    Block b1003=createNextBlock(lastBlock,nextHeight,null,null);
    blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b1003,true,false,b1003.getHash(),nextHeight,""String_Node_Str""));
    Block b1004=createNextBlock(b1003,nextHeight + 1,null,null);
{
      Transaction tx=new Transaction(params);
      tx.addInput(hashesToSpend.get(0),0,OP_NOP_SCRIPT);
      tx.addOutput(ZERO,OP_TRUE_SCRIPT);
      b1004.addTransaction(tx);
    }
    b1004.solve();
    blocks.add(new BlockAndValidity(blockToHeightMap,hashHeaderMap,b1004,false,true,b1003.getHash(),nextHeight,""String_Node_Str""));
    ret.maximumReorgBlockCount=Math.max(ret.maximumReorgBlockCount,blockCountAfter1001);
  }
  if (outStream != null)   outStream.close();
  return ret;
}",0.9990144054499436
85655,"/** 
 * Called on a pushdata chunk, returns true if it uses the smallest possible way (according to BIP62) to push the data.
 */
public boolean isShortestPossiblePushData(){
  checkState(isPushData());
  if (data.length == 0)   return opcode == OP_0;
  if (data.length == 1) {
    byte b=data[0];
    if (b >= 0x01 && b <= 0x10)     return opcode == OP_1 + b - 1;
    if ((b & 0xFF) == 0x81)     return opcode == OP_1NEGATE;
  }
  if (data.length < OP_PUSHDATA1)   return opcode == data.length;
  if (data.length < 256)   return opcode == OP_PUSHDATA1;
  if (data.length < 65536)   return opcode == OP_PUSHDATA2;
  return opcode == OP_PUSHDATA4;
}","/** 
 * Called on a pushdata chunk, returns true if it uses the smallest possible way (according to BIP62) to push the data.
 */
public boolean isShortestPossiblePushData(){
  checkState(isPushData());
  if (data == null)   return true;
  if (data.length == 0)   return opcode == OP_0;
  if (data.length == 1) {
    byte b=data[0];
    if (b >= 0x01 && b <= 0x10)     return opcode == OP_1 + b - 1;
    if ((b & 0xFF) == 0x81)     return opcode == OP_1NEGATE;
  }
  if (data.length < OP_PUSHDATA1)   return opcode == data.length;
  if (data.length < 256)   return opcode == OP_PUSHDATA1;
  if (data.length < 65536)   return opcode == OP_PUSHDATA2;
  return opcode == OP_PUSHDATA4;
}",0.9736644093303236
85656,"@Before public void setup(){
  wallet=new Wallet(params){
    @Override public int getLastBlockSeenHeight(){
      return 1000;
    }
    @Override public long getLastBlockSeenTimeSecs(){
      return TIMESTAMP;
    }
  }
;
  key1=new ECKey();
}","@Before public void setup(){
  wallet=new Wallet(params){
    @Override public int getLastBlockSeenHeight(){
      return 1000;
    }
    @Override public long getLastBlockSeenTimeSecs(){
      return TIMESTAMP;
    }
  }
;
}",0.9531914893617022
85657,"/** 
 * Get the map of the   {@link org.bitcoinj.core.TransactionOutput}'s keyed on their height for a given address and a specified height.
 * @param address The address.
 * @param maxHeight The minimum block height of this tx output (inclusive).
 * @return The map of transaction outputs (list) keyed by height
 * @throws BlockStoreException If there is an error getting the list out outputs.
 */
public Map<Integer,List<TransactionOutput>> getOpenTransactionOutputsHeightMap(Address address,@Nullable Integer maxHeight) throws BlockStoreException {
  maybeConnect();
  PreparedStatement s=null;
  HashMap<Integer,List<TransactionOutput>> outputsMap=new HashMap<Integer,List<TransactionOutput>>();
  try {
    if (maxHeight != null) {
      s=conn.get().prepareStatement(getTrasactionOutputWithHeightSelectSQL());
      s.setInt(2,maxHeight);
    }
 else {
      s=conn.get().prepareStatement(getTrasactionOutputSelectSQL());
    }
    s.setString(1,address.toString());
    ResultSet rs=s.executeQuery();
    while (rs.next()) {
      Coin amount=Coin.valueOf((new BigInteger(rs.getBytes(1)).longValue()));
      byte[] scriptBytes=rs.getBytes(2);
      int height=rs.getInt(3);
      TransactionOutput output=new TransactionOutput(params,null,amount,scriptBytes);
      if (outputsMap.containsKey(height)) {
        outputsMap.get(height).add(output);
      }
 else {
        List outputs=new ArrayList<TransactionOutput>();
        outputs.add(output);
        outputsMap.put(height,outputs);
      }
    }
    return outputsMap;
  }
 catch (  SQLException ex) {
    throw new BlockStoreException(ex);
  }
 finally {
    if (s != null)     try {
      s.close();
    }
 catch (    SQLException e) {
      throw new BlockStoreException(""String_Node_Str"");
    }
  }
}","/** 
 * Get the map of the   {@link org.bitcoinj.core.TransactionOutput}'s keyed on their height for a given address and a specified height.
 * @param address The address.
 * @param maxHeight The minimum block height of this tx output (inclusive).
 * @return The map of transaction outputs (list) keyed by height
 * @throws BlockStoreException If there is an error getting the list out outputs.
 */
public Map<Integer,List<TransactionOutput>> getOpenTransactionOutputsHeightMap(Address address,@Nullable Integer maxHeight) throws BlockStoreException {
  maybeConnect();
  PreparedStatement s=null;
  HashMap<Integer,List<TransactionOutput>> outputsMap=new HashMap<Integer,List<TransactionOutput>>();
  try {
    if (maxHeight != null) {
      s=conn.get().prepareStatement(getTrasactionOutputWithHeightSelectSQL());
      s.setInt(2,maxHeight);
    }
 else {
      s=conn.get().prepareStatement(getTrasactionOutputSelectSQL());
    }
    s.setString(1,address.toString());
    ResultSet rs=s.executeQuery();
    while (rs.next()) {
      Coin amount=Coin.valueOf(rs.getLong(1));
      byte[] scriptBytes=rs.getBytes(2);
      int height=rs.getInt(3);
      TransactionOutput output=new TransactionOutput(params,null,amount,scriptBytes);
      if (outputsMap.containsKey(height)) {
        outputsMap.get(height).add(output);
      }
 else {
        List outputs=new ArrayList<TransactionOutput>();
        outputs.add(output);
        outputsMap.put(height,outputs);
      }
    }
    return outputsMap;
  }
 catch (  SQLException ex) {
    throw new BlockStoreException(ex);
  }
 finally {
    if (s != null)     try {
      s.close();
    }
 catch (    SQLException e) {
      throw new BlockStoreException(""String_Node_Str"");
    }
  }
}",0.985474223867844
85658,"/** 
 * Returns the minimum value for this output to be considered ""not dust"", i.e. the transaction will be relayable and mined by default miners. For normal pay to address outputs, this is 5460 satoshis, the same as  {@link Transaction#MIN_NONDUST_OUTPUT}.
 */
public Coin getMinNonDustValue(){
  return getMinNonDustValue(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.multiply(3));
}","/** 
 * Returns the minimum value for this output to be considered ""not dust"", i.e. the transaction will be relayable and mined by default miners. For normal pay to address outputs, this is 546 satoshis, the same as  {@link Transaction#MIN_NONDUST_OUTPUT}.
 */
public Coin getMinNonDustValue(){
  return getMinNonDustValue(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.multiply(3));
}",0.9986824769433466
85659,"/** 
 * Given a spend request containing an incomplete transaction, makes it valid by adding outputs and signed inputs according to the instructions in the request. The transaction in the request is modified by this method.
 * @param req a SendRequest that contains the incomplete transaction and details for how to make it valid.
 * @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
 * @throws IllegalArgumentException if you try and complete the same SendRequest twice
 * @throws DustySendRequested if the resultant transaction would violate the dust rules (an output that's too small to be worthwhile)
 * @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
 * @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process (try breaking up the amounts of value)
 */
public void completeTx(SendRequest req) throws InsufficientMoneyException {
  lock.lock();
  try {
    checkArgument(!req.completed,""String_Node_Str"");
    Coin value=Coin.ZERO;
    for (    TransactionOutput output : req.tx.getOutputs()) {
      value=value.add(output.getValue());
    }
    log.info(""String_Node_Str"",req.tx.getOutputs().size(),value.toFriendlyString());
    Coin totalInput=Coin.ZERO;
    for (    TransactionInput input : req.tx.getInputs())     if (input.getConnectedOutput() != null)     totalInput=totalInput.add(input.getConnectedOutput().getValue());
 else     log.warn(""String_Node_Str"");
    value=value.subtract(totalInput);
    List<TransactionInput> originalInputs=new ArrayList<TransactionInput>(req.tx.getInputs());
    boolean needAtLeastReferenceFee=false;
    if (req.ensureMinRequiredFee && !req.emptyWallet) {
      for (      TransactionOutput output : req.tx.getOutputs())       if (output.getValue().compareTo(Coin.CENT) < 0) {
        if (output.getValue().compareTo(output.getMinNonDustValue()) < 0)         throw new DustySendRequested();
        needAtLeastReferenceFee=true;
        break;
      }
    }
    LinkedList<TransactionOutput> candidates=calculateAllSpendCandidates(true);
    CoinSelection bestCoinSelection;
    TransactionOutput bestChangeOutput=null;
    if (!req.emptyWallet) {
      FeeCalculation feeCalculation;
      feeCalculation=calculateFee(req,value,originalInputs,needAtLeastReferenceFee,candidates);
      bestCoinSelection=feeCalculation.bestCoinSelection;
      bestChangeOutput=feeCalculation.bestChangeOutput;
    }
 else {
      checkState(req.tx.getOutputs().size() == 1,""String_Node_Str"");
      CoinSelector selector=req.coinSelector == null ? coinSelector : req.coinSelector;
      bestCoinSelection=selector.select(NetworkParameters.MAX_MONEY,candidates);
      candidates=null;
      req.tx.getOutput(0).setValue(bestCoinSelection.valueGathered);
      log.info(""String_Node_Str"",bestCoinSelection.valueGathered.toFriendlyString());
    }
    for (    TransactionOutput output : bestCoinSelection.gathered)     req.tx.addInput(output);
    if (req.ensureMinRequiredFee && req.emptyWallet) {
      final Coin baseFee=req.fee == null ? Coin.ZERO : req.fee;
      final Coin feePerKb=req.feePerKb == null ? Coin.ZERO : req.feePerKb;
      Transaction tx=req.tx;
      if (!adjustOutputDownwardsForFee(tx,bestCoinSelection,baseFee,feePerKb))       throw new CouldNotAdjustDownwards();
    }
    if (bestChangeOutput != null) {
      req.tx.addOutput(bestChangeOutput);
      log.info(""String_Node_Str"",bestChangeOutput.getValue().toFriendlyString());
    }
    if (req.shuffleOutputs)     req.tx.shuffleOutputs();
    if (req.signInputs) {
      signTransaction(req);
    }
    int size=req.tx.bitcoinSerialize().length;
    if (size > Transaction.MAX_STANDARD_TX_SIZE)     throw new ExceededMaxTransactionSize();
    final Coin calculatedFee=req.tx.getFee();
    if (calculatedFee != null) {
      log.info(""String_Node_Str"",calculatedFee.toFriendlyString());
    }
    req.tx.getConfidence().setSource(TransactionConfidence.Source.SELF);
    req.tx.setPurpose(Transaction.Purpose.USER_PAYMENT);
    req.tx.setExchangeRate(req.exchangeRate);
    req.tx.setMemo(req.memo);
    req.completed=true;
    req.fee=calculatedFee;
    log.info(""String_Node_Str"",req.tx);
  }
  finally {
    lock.unlock();
  }
}","/** 
 * Given a spend request containing an incomplete transaction, makes it valid by adding outputs and signed inputs according to the instructions in the request. The transaction in the request is modified by this method.
 * @param req a SendRequest that contains the incomplete transaction and details for how to make it valid.
 * @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
 * @throws IllegalArgumentException if you try and complete the same SendRequest twice
 * @throws DustySendRequested if the resultant transaction would violate the dust rules (an output that's too small to be worthwhile)
 * @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
 * @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process (try breaking up the amounts of value)
 */
public void completeTx(SendRequest req) throws InsufficientMoneyException {
  lock.lock();
  try {
    checkArgument(!req.completed,""String_Node_Str"");
    Coin value=Coin.ZERO;
    for (    TransactionOutput output : req.tx.getOutputs()) {
      value=value.add(output.getValue());
    }
    log.info(""String_Node_Str"",req.tx.getOutputs().size(),value.toFriendlyString());
    Coin totalInput=Coin.ZERO;
    for (    TransactionInput input : req.tx.getInputs())     if (input.getConnectedOutput() != null)     totalInput=totalInput.add(input.getConnectedOutput().getValue());
 else     log.warn(""String_Node_Str"");
    value=value.subtract(totalInput);
    List<TransactionInput> originalInputs=new ArrayList<TransactionInput>(req.tx.getInputs());
    int opReturnCount=0;
    boolean needAtLeastReferenceFee=false;
    if (req.ensureMinRequiredFee && !req.emptyWallet) {
      for (      TransactionOutput output : req.tx.getOutputs()) {
        if (output.getValue().compareTo(Coin.CENT) < 0) {
          needAtLeastReferenceFee=true;
          if (output.getValue().compareTo(output.getMinNonDustValue()) < 0) {
            if (output.getScriptPubKey().isOpReturn()) {
              ++opReturnCount;
              continue;
            }
 else {
              throw new DustySendRequested();
            }
          }
          break;
        }
      }
    }
    if (opReturnCount > 1) {
      throw new MultipleOpReturnRequested();
    }
    LinkedList<TransactionOutput> candidates=calculateAllSpendCandidates(true);
    CoinSelection bestCoinSelection;
    TransactionOutput bestChangeOutput=null;
    if (!req.emptyWallet) {
      FeeCalculation feeCalculation;
      feeCalculation=calculateFee(req,value,originalInputs,needAtLeastReferenceFee,candidates);
      bestCoinSelection=feeCalculation.bestCoinSelection;
      bestChangeOutput=feeCalculation.bestChangeOutput;
    }
 else {
      checkState(req.tx.getOutputs().size() == 1,""String_Node_Str"");
      CoinSelector selector=req.coinSelector == null ? coinSelector : req.coinSelector;
      bestCoinSelection=selector.select(NetworkParameters.MAX_MONEY,candidates);
      candidates=null;
      req.tx.getOutput(0).setValue(bestCoinSelection.valueGathered);
      log.info(""String_Node_Str"",bestCoinSelection.valueGathered.toFriendlyString());
    }
    for (    TransactionOutput output : bestCoinSelection.gathered)     req.tx.addInput(output);
    if (req.ensureMinRequiredFee && req.emptyWallet) {
      final Coin baseFee=req.fee == null ? Coin.ZERO : req.fee;
      final Coin feePerKb=req.feePerKb == null ? Coin.ZERO : req.feePerKb;
      Transaction tx=req.tx;
      if (!adjustOutputDownwardsForFee(tx,bestCoinSelection,baseFee,feePerKb))       throw new CouldNotAdjustDownwards();
    }
    if (bestChangeOutput != null) {
      req.tx.addOutput(bestChangeOutput);
      log.info(""String_Node_Str"",bestChangeOutput.getValue().toFriendlyString());
    }
    if (req.shuffleOutputs)     req.tx.shuffleOutputs();
    if (req.signInputs) {
      signTransaction(req);
    }
    int size=req.tx.bitcoinSerialize().length;
    if (size > Transaction.MAX_STANDARD_TX_SIZE)     throw new ExceededMaxTransactionSize();
    final Coin calculatedFee=req.tx.getFee();
    if (calculatedFee != null) {
      log.info(""String_Node_Str"",calculatedFee.toFriendlyString());
    }
    req.tx.getConfidence().setSource(TransactionConfidence.Source.SELF);
    req.tx.setPurpose(Transaction.Purpose.USER_PAYMENT);
    req.tx.setExchangeRate(req.exchangeRate);
    req.tx.setMemo(req.memo);
    req.completed=true;
    req.fee=calculatedFee;
    log.info(""String_Node_Str"",req.tx);
  }
  finally {
    lock.unlock();
  }
}",0.9561040991846308
85660,"private void receiveATransaction(Wallet wallet,Address toAddress) throws Exception {
  Coin v1=COIN;
  final ListenableFuture<Coin> availFuture=wallet.getBalanceFuture(v1,Wallet.BalanceType.AVAILABLE);
  final ListenableFuture<Coin> estimatedFuture=wallet.getBalanceFuture(v1,Wallet.BalanceType.ESTIMATED);
  assertFalse(availFuture.isDone());
  assertFalse(estimatedFuture.isDone());
  Transaction t1=sendMoneyToWallet(wallet,v1,toAddress,null);
  Threading.waitForUserCode();
  final ListenableFuture<Transaction> depthFuture=t1.getConfidence().getDepthFuture(1);
  assertFalse(depthFuture.isDone());
  assertEquals(ZERO,wallet.getBalance());
  assertEquals(v1,wallet.getBalance(Wallet.BalanceType.ESTIMATED));
  assertFalse(availFuture.isDone());
  assertTrue(estimatedFuture.isDone());
  assertEquals(1,wallet.getPoolSize(Pool.PENDING));
  assertEquals(0,wallet.getPoolSize(WalletTransaction.Pool.UNSPENT));
  sendMoneyToWallet(wallet,t1,AbstractBlockChain.NewBlockType.BEST_CHAIN);
  assertEquals(""String_Node_Str"",v1,wallet.getBalance());
  assertEquals(""String_Node_Str"",0,wallet.getPoolSize(WalletTransaction.Pool.PENDING));
  assertEquals(""String_Node_Str"",1,wallet.getPoolSize(WalletTransaction.Pool.UNSPENT));
  assertEquals(""String_Node_Str"",1,wallet.getTransactions(true).size());
  Threading.waitForUserCode();
  assertTrue(availFuture.isDone());
  assertTrue(estimatedFuture.isDone());
  assertTrue(depthFuture.isDone());
}","private void receiveATransaction(Wallet wallet,Address toAddress) throws Exception {
  receiveATransactionAmount(wallet,toAddress,COIN);
}",0.1675126903553299
85661,"protected void initPeerGroup(){
  if (clientType == ClientType.NIO_CLIENT_MANAGER)   peerGroup=new PeerGroup(unitTestParams,blockChain,new NioClientManager());
 else   peerGroup=new PeerGroup(unitTestParams,blockChain,new BlockingClientManager());
  peerGroup.setPingIntervalMsec(0);
  peerGroup.addWallet(wallet);
}","protected void initPeerGroup(){
  if (clientType == ClientType.NIO_CLIENT_MANAGER)   peerGroup=new PeerGroup(unitTestParams,blockChain,new NioClientManager());
 else   peerGroup=new PeerGroup(unitTestParams,blockChain,new BlockingClientManager());
  peerGroup.setPingIntervalMsec(0);
  peerGroup.addWallet(wallet);
  peerGroup.setUseLocalhostPeerWhenPossible(false);
}",0.9239766081871345
85662,"@Test public void serializeDownloadBlockWithWallet() throws Exception {
  unitTestParams=UnitTestParams.get();
  Block block=new Block(unitTestParams,HEX.decode(""String_Node_Str""));
  FilteredBlock filteredBlock=new FilteredBlock(unitTestParams,HEX.decode(""String_Node_Str""));
  assertTrue(block.getHash().equals(new Sha256Hash(""String_Node_Str"")));
  assertTrue(filteredBlock.getHash().equals(block.getHash()));
  List<Sha256Hash> txHashList=filteredBlock.getTransactionHashes();
  assertTrue(txHashList.size() == 4);
  Transaction tx0=new Transaction(unitTestParams,HEX.decode(""String_Node_Str""));
  assertTrue(tx0.getHash().equals(new Sha256Hash(""String_Node_Str"")));
  assertEquals(tx0.getHash(),txHashList.get(0));
  Transaction tx1=new Transaction(unitTestParams,HEX.decode(""String_Node_Str""));
  assertTrue(tx1.getHash().equals(new Sha256Hash(""String_Node_Str"")));
  assertEquals(tx1.getHash(),txHashList.get(1));
  Transaction tx2=new Transaction(unitTestParams,HEX.decode(""String_Node_Str""));
  assertTrue(tx2.getHash().equals(new Sha256Hash(""String_Node_Str"")));
  assertEquals(tx2.getHash(),txHashList.get(2));
  Transaction tx3=new Transaction(unitTestParams,HEX.decode(""String_Node_Str""));
  assertTrue(tx3.getHash().equals(new Sha256Hash(""String_Node_Str"")));
  assertEquals(tx3.getHash(),txHashList.get(3));
  KeyChainGroup group=new KeyChainGroup(unitTestParams);
  group.importKeys(ECKey.fromPublicOnly(HEX.decode(""String_Node_Str"")),ECKey.fromPublicOnly(HEX.decode(""String_Node_Str"")),ECKey.fromPublicOnly(HEX.decode(""String_Node_Str"")),ECKey.fromPublicOnly(HEX.decode(""String_Node_Str"")));
  Wallet wallet=new Wallet(unitTestParams,group);
  BloomFilter filter=wallet.getBloomFilter(wallet.getKeychainSize() * 2,0.001,0xDEADBEEF);
  assertTrue(Arrays.equals(filter.bitcoinSerialize(),HEX.decode(""String_Node_Str"")));
  blockStore=new MemoryBlockStore(UnitTestParams.get());
  blockStore.put(new StoredBlock(new Block(unitTestParams,HEX.decode(""String_Node_Str"")),BigInteger.valueOf(1),100000));
  blockStore.setChainHead(blockStore.get(new Sha256Hash(""String_Node_Str"")));
  super.setUp(blockStore);
  peerGroup.addWallet(wallet);
  blockChain.addWallet(wallet);
  peerGroup.startAsync();
  peerGroup.awaitRunning();
  InboundMessageQueuer p1=connectPeer(1);
  assertEquals(1,peerGroup.numConnectedPeers());
  InventoryMessage inv=new InventoryMessage(unitTestParams);
  inv.addBlock(block);
  inbound(p1,inv);
  Object getData=outbound(p1);
  assertTrue(getData instanceof GetDataMessage);
  assertTrue(((GetDataMessage)getData).getItems().size() == 1);
  assertTrue(((GetDataMessage)getData).getItems().get(0).hash.equals(block.getHash()));
  assertTrue(((GetDataMessage)getData).getItems().get(0).type == InventoryItem.Type.FilteredBlock);
  Object ping=outbound(p1);
  assertTrue(ping instanceof Ping);
  inbound(p1,filteredBlock);
  inbound(p1,tx0);
  inbound(p1,tx1);
  inbound(p1,tx2);
  inbound(p1,tx3);
  inbound(p1,new Pong(((Ping)ping).getNonce()));
  pingAndWait(p1);
  Set<Transaction> transactions=wallet.getTransactions(false);
  assertTrue(transactions.size() == 4);
  for (  Transaction tx : transactions) {
    assertTrue(tx.getConfidence().getConfidenceType() == ConfidenceType.BUILDING);
    assertTrue(tx.getConfidence().getDepthInBlocks() == 1);
    assertTrue(tx.getAppearsInHashes().keySet().contains(block.getHash()));
    assertTrue(tx.getAppearsInHashes().size() == 1);
  }
  closePeer(peerOf(p1));
  peerGroup.stopAsync();
  super.tearDown();
}","@Test public void serializeDownloadBlockWithWallet() throws Exception {
  unitTestParams=UnitTestParams.get();
  Block block=new Block(unitTestParams,HEX.decode(""String_Node_Str""));
  FilteredBlock filteredBlock=new FilteredBlock(unitTestParams,HEX.decode(""String_Node_Str""));
  assertTrue(block.getHash().equals(new Sha256Hash(""String_Node_Str"")));
  assertTrue(filteredBlock.getHash().equals(block.getHash()));
  List<Sha256Hash> txHashList=filteredBlock.getTransactionHashes();
  assertTrue(txHashList.size() == 4);
  Transaction tx0=new Transaction(unitTestParams,HEX.decode(""String_Node_Str""));
  assertTrue(tx0.getHash().equals(new Sha256Hash(""String_Node_Str"")));
  assertEquals(tx0.getHash(),txHashList.get(0));
  Transaction tx1=new Transaction(unitTestParams,HEX.decode(""String_Node_Str""));
  assertTrue(tx1.getHash().equals(new Sha256Hash(""String_Node_Str"")));
  assertEquals(tx1.getHash(),txHashList.get(1));
  Transaction tx2=new Transaction(unitTestParams,HEX.decode(""String_Node_Str""));
  assertTrue(tx2.getHash().equals(new Sha256Hash(""String_Node_Str"")));
  assertEquals(tx2.getHash(),txHashList.get(2));
  Transaction tx3=new Transaction(unitTestParams,HEX.decode(""String_Node_Str""));
  assertTrue(tx3.getHash().equals(new Sha256Hash(""String_Node_Str"")));
  assertEquals(tx3.getHash(),txHashList.get(3));
  KeyChainGroup group=new KeyChainGroup(unitTestParams);
  group.importKeys(ECKey.fromPublicOnly(HEX.decode(""String_Node_Str"")),ECKey.fromPublicOnly(HEX.decode(""String_Node_Str"")),ECKey.fromPublicOnly(HEX.decode(""String_Node_Str"")),ECKey.fromPublicOnly(HEX.decode(""String_Node_Str"")));
  Wallet wallet=new Wallet(unitTestParams,group);
  BloomFilter filter=wallet.getBloomFilter(wallet.getKeychainSize() * 2,0.001,0xDEADBEEF);
  assertTrue(Arrays.equals(filter.bitcoinSerialize(),HEX.decode(""String_Node_Str"")));
  blockStore=new MemoryBlockStore(UnitTestParams.get());
  blockStore.put(new StoredBlock(new Block(unitTestParams,HEX.decode(""String_Node_Str"")),BigInteger.valueOf(1),100000));
  blockStore.setChainHead(blockStore.get(new Sha256Hash(""String_Node_Str"")));
  super.setUp(blockStore);
  peerGroup.addWallet(wallet);
  peerGroup.setUseLocalhostPeerWhenPossible(false);
  blockChain.addWallet(wallet);
  peerGroup.startAsync();
  peerGroup.awaitRunning();
  InboundMessageQueuer p1=connectPeer(1);
  assertEquals(1,peerGroup.numConnectedPeers());
  InventoryMessage inv=new InventoryMessage(unitTestParams);
  inv.addBlock(block);
  inbound(p1,inv);
  Object getData=outbound(p1);
  assertTrue(getData instanceof GetDataMessage);
  assertTrue(((GetDataMessage)getData).getItems().size() == 1);
  assertTrue(((GetDataMessage)getData).getItems().get(0).hash.equals(block.getHash()));
  assertTrue(((GetDataMessage)getData).getItems().get(0).type == InventoryItem.Type.FilteredBlock);
  Object ping=outbound(p1);
  assertTrue(ping instanceof Ping);
  inbound(p1,filteredBlock);
  inbound(p1,tx0);
  inbound(p1,tx1);
  inbound(p1,tx2);
  inbound(p1,tx3);
  inbound(p1,new Pong(((Ping)ping).getNonce()));
  pingAndWait(p1);
  Set<Transaction> transactions=wallet.getTransactions(false);
  assertTrue(transactions.size() == 4);
  for (  Transaction tx : transactions) {
    assertTrue(tx.getConfidence().getConfidenceType() == ConfidenceType.BUILDING);
    assertTrue(tx.getConfidence().getDepthInBlocks() == 1);
    assertTrue(tx.getAppearsInHashes().keySet().contains(block.getHash()));
    assertTrue(tx.getAppearsInHashes().size() == 1);
  }
  closePeer(peerOf(p1));
  peerGroup.stopAsync();
  super.tearDown();
}",0.9926073357975548
85663,"@Test public void preferLocalPeer() throws IOException {
  ServerSocket local=new ServerSocket(params.getPort(),100,InetAddresses.forString(""String_Node_Str""));
  try {
    peerGroup.startAsync();
    peerGroup.awaitRunning();
    local.accept().close();
    local.accept();
    assertEquals(1,peerGroup.getMaxConnections());
    assertEquals(PeerAddress.localhost(params),peerGroup.getPendingPeers().get(0).getAddress());
  }
  finally {
    local.close();
  }
}","@Test public void preferLocalPeer() throws IOException {
  ServerSocket local=null;
  try {
    local=new ServerSocket(params.getPort(),100,InetAddresses.forString(""String_Node_Str""));
  }
 catch (  BindException e) {
    return;
  }
  try {
    peerGroup.setUseLocalhostPeerWhenPossible(true);
    peerGroup.startAsync();
    peerGroup.awaitRunning();
    local.accept().close();
    local.accept();
    assertEquals(1,peerGroup.getMaxConnections());
    assertEquals(PeerAddress.localhost(params),peerGroup.getPendingPeers().get(0).getAddress());
  }
  finally {
    local.close();
  }
}",0.8802281368821293
85664,"/** 
 * Called on a pushdata chunk, returns true if it uses the smallest possible way (according to BIP62) to push the data.
 */
public boolean isShortestPossiblePushData(){
  checkState(isPushData());
  if (data.length == 0)   return opcode == OP_0;
  if (data.length == 1) {
    byte b=data[0];
    if (b >= 0x01 && b <= 0x10)     return opcode == OP_1 + b - 1;
    if (b == 0x81)     return opcode == OP_1NEGATE;
  }
  if (data.length < OP_PUSHDATA1)   return opcode == data.length;
  if (data.length < 256)   return opcode == OP_PUSHDATA1;
  if (data.length < 65536)   return opcode == OP_PUSHDATA2;
  return opcode == OP_PUSHDATA4;
}","/** 
 * Called on a pushdata chunk, returns true if it uses the smallest possible way (according to BIP62) to push the data.
 */
public boolean isShortestPossiblePushData(){
  checkState(isPushData());
  if (data.length == 0)   return opcode == OP_0;
  if (data.length == 1) {
    byte b=data[0];
    if (b >= 0x01 && b <= 0x10)     return opcode == OP_1 + b - 1;
    if ((b & 0xFF) == 0x81)     return opcode == OP_1NEGATE;
  }
  if (data.length < OP_PUSHDATA1)   return opcode == data.length;
  if (data.length < 256)   return opcode == OP_PUSHDATA1;
  if (data.length < 65536)   return opcode == OP_PUSHDATA2;
  return opcode == OP_PUSHDATA4;
}",0.9914396887159532
85665,"public void write(OutputStream stream) throws IOException {
  if (isOpCode()) {
    checkState(data == null);
    stream.write(opcode);
  }
 else   if (data != null) {
    checkNotNull(data);
    if (opcode < OP_PUSHDATA1) {
      checkState(data.length == opcode);
      stream.write(opcode);
    }
 else     if (opcode == OP_PUSHDATA1) {
      checkState(data.length <= 0xFF);
      stream.write(OP_PUSHDATA1);
      stream.write(data.length);
    }
 else     if (opcode == OP_PUSHDATA2) {
      checkState(data.length <= 0xFFFF);
      stream.write(OP_PUSHDATA2);
      stream.write(0xFF & data.length);
      stream.write(0xFF & (data.length >> 8));
    }
 else     if (opcode == OP_PUSHDATA4) {
      checkState(data.length <= Script.MAX_SCRIPT_ELEMENT_SIZE);
      stream.write(OP_PUSHDATA4);
      Utils.uint32ToByteStreamLE(data.length,stream);
    }
 else {
      throw new RuntimeException(""String_Node_Str"");
    }
    stream.write(data);
  }
 else {
    stream.write(opcode);
  }
}","public void write(OutputStream stream) throws IOException {
  if (isOpCode()) {
    checkState(data == null);
    stream.write(opcode);
  }
 else   if (data != null) {
    if (opcode < OP_PUSHDATA1) {
      checkState(data.length == opcode);
      stream.write(opcode);
    }
 else     if (opcode == OP_PUSHDATA1) {
      checkState(data.length <= 0xFF);
      stream.write(OP_PUSHDATA1);
      stream.write(data.length);
    }
 else     if (opcode == OP_PUSHDATA2) {
      checkState(data.length <= 0xFFFF);
      stream.write(OP_PUSHDATA2);
      stream.write(0xFF & data.length);
      stream.write(0xFF & (data.length >> 8));
    }
 else     if (opcode == OP_PUSHDATA4) {
      checkState(data.length <= Script.MAX_SCRIPT_ELEMENT_SIZE);
      stream.write(OP_PUSHDATA4);
      Utils.uint32ToByteStreamLE(data.length,stream);
    }
 else {
      throw new RuntimeException(""String_Node_Str"");
    }
    stream.write(data);
  }
 else {
    stream.write(opcode);
  }
}",0.9877675840978594
85666,"/** 
 * Returns the minimum value for this output to be considered ""not dust"", i.e. the transaction will be relayable and mined by default miners. For normal pay to address outputs, this is 5460 satoshis, the same as  {@link Transaction#MIN_NONDUST_OUTPUT}.
 */
public Coin getMinNonDustValue(){
  return getMinNonDustValue(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.multiply(3));
}","/** 
 * Returns the minimum value for this output to be considered ""not dust"", i.e. the transaction will be relayable and mined by default miners. For normal pay to address outputs, this is 546 satoshis, the same as  {@link Transaction#MIN_NONDUST_OUTPUT}.
 */
public Coin getMinNonDustValue(){
  return getMinNonDustValue(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.multiply(3));
}",0.9986824769433466
85667,"/** 
 * Given a spend request containing an incomplete transaction, makes it valid by adding outputs and signed inputs according to the instructions in the request. The transaction in the request is modified by this method.
 * @param req a SendRequest that contains the incomplete transaction and details for how to make it valid.
 * @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
 * @throws IllegalArgumentException if you try and complete the same SendRequest twice
 * @throws DustySendRequested if the resultant transaction would violate the dust rules (an output that's too small to be worthwhile)
 * @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
 * @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process (try breaking up the amounts of value)
 */
public void completeTx(SendRequest req) throws InsufficientMoneyException {
  lock.lock();
  try {
    checkArgument(!req.completed,""String_Node_Str"");
    Coin value=Coin.ZERO;
    for (    TransactionOutput output : req.tx.getOutputs()) {
      value=value.add(output.getValue());
    }
    log.info(""String_Node_Str"",req.tx.getOutputs().size(),value.toFriendlyString());
    Coin totalInput=Coin.ZERO;
    for (    TransactionInput input : req.tx.getInputs())     if (input.getConnectedOutput() != null)     totalInput=totalInput.add(input.getConnectedOutput().getValue());
 else     log.warn(""String_Node_Str"");
    value=value.subtract(totalInput);
    List<TransactionInput> originalInputs=new ArrayList<TransactionInput>(req.tx.getInputs());
    boolean needAtLeastReferenceFee=false;
    if (req.ensureMinRequiredFee && !req.emptyWallet) {
      for (      TransactionOutput output : req.tx.getOutputs())       if (output.getValue().compareTo(Coin.CENT) < 0) {
        if (output.getValue().compareTo(output.getMinNonDustValue()) < 0)         throw new DustySendRequested();
        needAtLeastReferenceFee=true;
        break;
      }
    }
    LinkedList<TransactionOutput> candidates=calculateAllSpendCandidates(true);
    CoinSelection bestCoinSelection;
    TransactionOutput bestChangeOutput=null;
    if (!req.emptyWallet) {
      FeeCalculation feeCalculation;
      feeCalculation=calculateFee(req,value,originalInputs,needAtLeastReferenceFee,candidates);
      bestCoinSelection=feeCalculation.bestCoinSelection;
      bestChangeOutput=feeCalculation.bestChangeOutput;
    }
 else {
      checkState(req.tx.getOutputs().size() == 1,""String_Node_Str"");
      CoinSelector selector=req.coinSelector == null ? coinSelector : req.coinSelector;
      bestCoinSelection=selector.select(NetworkParameters.MAX_MONEY,candidates);
      candidates=null;
      req.tx.getOutput(0).setValue(bestCoinSelection.valueGathered);
      log.info(""String_Node_Str"",bestCoinSelection.valueGathered.toFriendlyString());
    }
    for (    TransactionOutput output : bestCoinSelection.gathered)     req.tx.addInput(output);
    if (req.ensureMinRequiredFee && req.emptyWallet) {
      final Coin baseFee=req.fee == null ? Coin.ZERO : req.fee;
      final Coin feePerKb=req.feePerKb == null ? Coin.ZERO : req.feePerKb;
      Transaction tx=req.tx;
      if (!adjustOutputDownwardsForFee(tx,bestCoinSelection,baseFee,feePerKb))       throw new CouldNotAdjustDownwards();
    }
    if (bestChangeOutput != null) {
      req.tx.addOutput(bestChangeOutput);
      log.info(""String_Node_Str"",bestChangeOutput.getValue().toFriendlyString());
    }
    if (req.shuffleOutputs)     req.tx.shuffleOutputs();
    if (req.signInputs) {
      signTransaction(req);
    }
    int size=req.tx.bitcoinSerialize().length;
    if (size > Transaction.MAX_STANDARD_TX_SIZE)     throw new ExceededMaxTransactionSize();
    final Coin calculatedFee=req.tx.getFee();
    if (calculatedFee != null) {
      log.info(""String_Node_Str"",calculatedFee.toFriendlyString());
    }
    req.tx.getConfidence().setSource(TransactionConfidence.Source.SELF);
    req.tx.setPurpose(Transaction.Purpose.USER_PAYMENT);
    req.tx.setExchangeRate(req.exchangeRate);
    req.tx.setMemo(req.memo);
    req.completed=true;
    req.fee=calculatedFee;
    log.info(""String_Node_Str"",req.tx);
  }
  finally {
    lock.unlock();
  }
}","/** 
 * Given a spend request containing an incomplete transaction, makes it valid by adding outputs and signed inputs according to the instructions in the request. The transaction in the request is modified by this method.
 * @param req a SendRequest that contains the incomplete transaction and details for how to make it valid.
 * @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
 * @throws IllegalArgumentException if you try and complete the same SendRequest twice
 * @throws DustySendRequested if the resultant transaction would violate the dust rules (an output that's too small to be worthwhile)
 * @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
 * @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process (try breaking up the amounts of value)
 */
public void completeTx(SendRequest req) throws InsufficientMoneyException {
  lock.lock();
  try {
    checkArgument(!req.completed,""String_Node_Str"");
    Coin value=Coin.ZERO;
    for (    TransactionOutput output : req.tx.getOutputs()) {
      value=value.add(output.getValue());
    }
    log.info(""String_Node_Str"",req.tx.getOutputs().size(),value.toFriendlyString());
    Coin totalInput=Coin.ZERO;
    for (    TransactionInput input : req.tx.getInputs())     if (input.getConnectedOutput() != null)     totalInput=totalInput.add(input.getConnectedOutput().getValue());
 else     log.warn(""String_Node_Str"");
    value=value.subtract(totalInput);
    List<TransactionInput> originalInputs=new ArrayList<TransactionInput>(req.tx.getInputs());
    int opReturnCount=0;
    boolean needAtLeastReferenceFee=false;
    if (req.ensureMinRequiredFee && !req.emptyWallet) {
      for (      TransactionOutput output : req.tx.getOutputs()) {
        if (output.getValue().compareTo(Coin.CENT) < 0) {
          needAtLeastReferenceFee=true;
          if (output.getValue().compareTo(output.getMinNonDustValue()) < 0) {
            if (output.getScriptPubKey().isOpReturn()) {
              ++opReturnCount;
              continue;
            }
 else {
              throw new DustySendRequested();
            }
          }
          break;
        }
      }
    }
    if (opReturnCount > 1) {
      throw new MultipleOpReturnRequested();
    }
    LinkedList<TransactionOutput> candidates=calculateAllSpendCandidates(true);
    CoinSelection bestCoinSelection;
    TransactionOutput bestChangeOutput=null;
    if (!req.emptyWallet) {
      FeeCalculation feeCalculation;
      feeCalculation=calculateFee(req,value,originalInputs,needAtLeastReferenceFee,candidates);
      bestCoinSelection=feeCalculation.bestCoinSelection;
      bestChangeOutput=feeCalculation.bestChangeOutput;
    }
 else {
      checkState(req.tx.getOutputs().size() == 1,""String_Node_Str"");
      CoinSelector selector=req.coinSelector == null ? coinSelector : req.coinSelector;
      bestCoinSelection=selector.select(NetworkParameters.MAX_MONEY,candidates);
      candidates=null;
      req.tx.getOutput(0).setValue(bestCoinSelection.valueGathered);
      log.info(""String_Node_Str"",bestCoinSelection.valueGathered.toFriendlyString());
    }
    for (    TransactionOutput output : bestCoinSelection.gathered)     req.tx.addInput(output);
    if (req.ensureMinRequiredFee && req.emptyWallet) {
      final Coin baseFee=req.fee == null ? Coin.ZERO : req.fee;
      final Coin feePerKb=req.feePerKb == null ? Coin.ZERO : req.feePerKb;
      Transaction tx=req.tx;
      if (!adjustOutputDownwardsForFee(tx,bestCoinSelection,baseFee,feePerKb))       throw new CouldNotAdjustDownwards();
    }
    if (bestChangeOutput != null) {
      req.tx.addOutput(bestChangeOutput);
      log.info(""String_Node_Str"",bestChangeOutput.getValue().toFriendlyString());
    }
    if (req.shuffleOutputs)     req.tx.shuffleOutputs();
    if (req.signInputs) {
      signTransaction(req);
    }
    int size=req.tx.bitcoinSerialize().length;
    if (size > Transaction.MAX_STANDARD_TX_SIZE)     throw new ExceededMaxTransactionSize();
    final Coin calculatedFee=req.tx.getFee();
    if (calculatedFee != null) {
      log.info(""String_Node_Str"",calculatedFee.toFriendlyString());
    }
    req.tx.getConfidence().setSource(TransactionConfidence.Source.SELF);
    req.tx.setPurpose(Transaction.Purpose.USER_PAYMENT);
    req.tx.setExchangeRate(req.exchangeRate);
    req.tx.setMemo(req.memo);
    req.completed=true;
    req.fee=calculatedFee;
    log.info(""String_Node_Str"",req.tx);
  }
  finally {
    lock.unlock();
  }
}",0.9561040991846308
85668,"private void receiveATransaction(Wallet wallet,Address toAddress) throws Exception {
  Coin v1=COIN;
  final ListenableFuture<Coin> availFuture=wallet.getBalanceFuture(v1,Wallet.BalanceType.AVAILABLE);
  final ListenableFuture<Coin> estimatedFuture=wallet.getBalanceFuture(v1,Wallet.BalanceType.ESTIMATED);
  assertFalse(availFuture.isDone());
  assertFalse(estimatedFuture.isDone());
  Transaction t1=sendMoneyToWallet(wallet,v1,toAddress,null);
  Threading.waitForUserCode();
  final ListenableFuture<Transaction> depthFuture=t1.getConfidence().getDepthFuture(1);
  assertFalse(depthFuture.isDone());
  assertEquals(ZERO,wallet.getBalance());
  assertEquals(v1,wallet.getBalance(Wallet.BalanceType.ESTIMATED));
  assertFalse(availFuture.isDone());
  assertTrue(estimatedFuture.isDone());
  assertEquals(1,wallet.getPoolSize(Pool.PENDING));
  assertEquals(0,wallet.getPoolSize(WalletTransaction.Pool.UNSPENT));
  sendMoneyToWallet(wallet,t1,AbstractBlockChain.NewBlockType.BEST_CHAIN);
  assertEquals(""String_Node_Str"",v1,wallet.getBalance());
  assertEquals(""String_Node_Str"",0,wallet.getPoolSize(WalletTransaction.Pool.PENDING));
  assertEquals(""String_Node_Str"",1,wallet.getPoolSize(WalletTransaction.Pool.UNSPENT));
  assertEquals(""String_Node_Str"",1,wallet.getTransactions(true).size());
  Threading.waitForUserCode();
  assertTrue(availFuture.isDone());
  assertTrue(estimatedFuture.isDone());
  assertTrue(depthFuture.isDone());
}","private void receiveATransaction(Wallet wallet,Address toAddress) throws Exception {
  receiveATransactionAmount(wallet,toAddress,COIN);
}",0.1675126903553299
85669,"protected void initPeerGroup(){
  if (clientType == ClientType.NIO_CLIENT_MANAGER)   peerGroup=new PeerGroup(unitTestParams,blockChain,new NioClientManager());
 else   peerGroup=new PeerGroup(unitTestParams,blockChain,new BlockingClientManager());
  peerGroup.setPingIntervalMsec(0);
  peerGroup.addWallet(wallet);
}","protected void initPeerGroup(){
  if (clientType == ClientType.NIO_CLIENT_MANAGER)   peerGroup=new PeerGroup(unitTestParams,blockChain,new NioClientManager());
 else   peerGroup=new PeerGroup(unitTestParams,blockChain,new BlockingClientManager());
  peerGroup.setPingIntervalMsec(0);
  peerGroup.addWallet(wallet);
  peerGroup.setUseLocalhostPeerWhenPossible(false);
}",0.9239766081871345
85670,"@Test public void serializeDownloadBlockWithWallet() throws Exception {
  unitTestParams=UnitTestParams.get();
  Block block=new Block(unitTestParams,HEX.decode(""String_Node_Str""));
  FilteredBlock filteredBlock=new FilteredBlock(unitTestParams,HEX.decode(""String_Node_Str""));
  assertTrue(block.getHash().equals(new Sha256Hash(""String_Node_Str"")));
  assertTrue(filteredBlock.getHash().equals(block.getHash()));
  List<Sha256Hash> txHashList=filteredBlock.getTransactionHashes();
  assertTrue(txHashList.size() == 4);
  Transaction tx0=new Transaction(unitTestParams,HEX.decode(""String_Node_Str""));
  assertTrue(tx0.getHash().equals(new Sha256Hash(""String_Node_Str"")));
  assertEquals(tx0.getHash(),txHashList.get(0));
  Transaction tx1=new Transaction(unitTestParams,HEX.decode(""String_Node_Str""));
  assertTrue(tx1.getHash().equals(new Sha256Hash(""String_Node_Str"")));
  assertEquals(tx1.getHash(),txHashList.get(1));
  Transaction tx2=new Transaction(unitTestParams,HEX.decode(""String_Node_Str""));
  assertTrue(tx2.getHash().equals(new Sha256Hash(""String_Node_Str"")));
  assertEquals(tx2.getHash(),txHashList.get(2));
  Transaction tx3=new Transaction(unitTestParams,HEX.decode(""String_Node_Str""));
  assertTrue(tx3.getHash().equals(new Sha256Hash(""String_Node_Str"")));
  assertEquals(tx3.getHash(),txHashList.get(3));
  KeyChainGroup group=new KeyChainGroup(unitTestParams);
  group.importKeys(ECKey.fromPublicOnly(HEX.decode(""String_Node_Str"")),ECKey.fromPublicOnly(HEX.decode(""String_Node_Str"")),ECKey.fromPublicOnly(HEX.decode(""String_Node_Str"")),ECKey.fromPublicOnly(HEX.decode(""String_Node_Str"")));
  Wallet wallet=new Wallet(unitTestParams,group);
  BloomFilter filter=wallet.getBloomFilter(wallet.getKeychainSize() * 2,0.001,0xDEADBEEF);
  assertTrue(Arrays.equals(filter.bitcoinSerialize(),HEX.decode(""String_Node_Str"")));
  blockStore=new MemoryBlockStore(UnitTestParams.get());
  blockStore.put(new StoredBlock(new Block(unitTestParams,HEX.decode(""String_Node_Str"")),BigInteger.valueOf(1),100000));
  blockStore.setChainHead(blockStore.get(new Sha256Hash(""String_Node_Str"")));
  super.setUp(blockStore);
  peerGroup.addWallet(wallet);
  blockChain.addWallet(wallet);
  peerGroup.startAsync();
  peerGroup.awaitRunning();
  InboundMessageQueuer p1=connectPeer(1);
  assertEquals(1,peerGroup.numConnectedPeers());
  InventoryMessage inv=new InventoryMessage(unitTestParams);
  inv.addBlock(block);
  inbound(p1,inv);
  Object getData=outbound(p1);
  assertTrue(getData instanceof GetDataMessage);
  assertTrue(((GetDataMessage)getData).getItems().size() == 1);
  assertTrue(((GetDataMessage)getData).getItems().get(0).hash.equals(block.getHash()));
  assertTrue(((GetDataMessage)getData).getItems().get(0).type == InventoryItem.Type.FilteredBlock);
  Object ping=outbound(p1);
  assertTrue(ping instanceof Ping);
  inbound(p1,filteredBlock);
  inbound(p1,tx0);
  inbound(p1,tx1);
  inbound(p1,tx2);
  inbound(p1,tx3);
  inbound(p1,new Pong(((Ping)ping).getNonce()));
  pingAndWait(p1);
  Set<Transaction> transactions=wallet.getTransactions(false);
  assertTrue(transactions.size() == 4);
  for (  Transaction tx : transactions) {
    assertTrue(tx.getConfidence().getConfidenceType() == ConfidenceType.BUILDING);
    assertTrue(tx.getConfidence().getDepthInBlocks() == 1);
    assertTrue(tx.getAppearsInHashes().keySet().contains(block.getHash()));
    assertTrue(tx.getAppearsInHashes().size() == 1);
  }
  closePeer(peerOf(p1));
  peerGroup.stopAsync();
  super.tearDown();
}","@Test public void serializeDownloadBlockWithWallet() throws Exception {
  unitTestParams=UnitTestParams.get();
  Block block=new Block(unitTestParams,HEX.decode(""String_Node_Str""));
  FilteredBlock filteredBlock=new FilteredBlock(unitTestParams,HEX.decode(""String_Node_Str""));
  assertTrue(block.getHash().equals(new Sha256Hash(""String_Node_Str"")));
  assertTrue(filteredBlock.getHash().equals(block.getHash()));
  List<Sha256Hash> txHashList=filteredBlock.getTransactionHashes();
  assertTrue(txHashList.size() == 4);
  Transaction tx0=new Transaction(unitTestParams,HEX.decode(""String_Node_Str""));
  assertTrue(tx0.getHash().equals(new Sha256Hash(""String_Node_Str"")));
  assertEquals(tx0.getHash(),txHashList.get(0));
  Transaction tx1=new Transaction(unitTestParams,HEX.decode(""String_Node_Str""));
  assertTrue(tx1.getHash().equals(new Sha256Hash(""String_Node_Str"")));
  assertEquals(tx1.getHash(),txHashList.get(1));
  Transaction tx2=new Transaction(unitTestParams,HEX.decode(""String_Node_Str""));
  assertTrue(tx2.getHash().equals(new Sha256Hash(""String_Node_Str"")));
  assertEquals(tx2.getHash(),txHashList.get(2));
  Transaction tx3=new Transaction(unitTestParams,HEX.decode(""String_Node_Str""));
  assertTrue(tx3.getHash().equals(new Sha256Hash(""String_Node_Str"")));
  assertEquals(tx3.getHash(),txHashList.get(3));
  KeyChainGroup group=new KeyChainGroup(unitTestParams);
  group.importKeys(ECKey.fromPublicOnly(HEX.decode(""String_Node_Str"")),ECKey.fromPublicOnly(HEX.decode(""String_Node_Str"")),ECKey.fromPublicOnly(HEX.decode(""String_Node_Str"")),ECKey.fromPublicOnly(HEX.decode(""String_Node_Str"")));
  Wallet wallet=new Wallet(unitTestParams,group);
  BloomFilter filter=wallet.getBloomFilter(wallet.getKeychainSize() * 2,0.001,0xDEADBEEF);
  assertTrue(Arrays.equals(filter.bitcoinSerialize(),HEX.decode(""String_Node_Str"")));
  blockStore=new MemoryBlockStore(UnitTestParams.get());
  blockStore.put(new StoredBlock(new Block(unitTestParams,HEX.decode(""String_Node_Str"")),BigInteger.valueOf(1),100000));
  blockStore.setChainHead(blockStore.get(new Sha256Hash(""String_Node_Str"")));
  super.setUp(blockStore);
  peerGroup.addWallet(wallet);
  peerGroup.setUseLocalhostPeerWhenPossible(false);
  blockChain.addWallet(wallet);
  peerGroup.startAsync();
  peerGroup.awaitRunning();
  InboundMessageQueuer p1=connectPeer(1);
  assertEquals(1,peerGroup.numConnectedPeers());
  InventoryMessage inv=new InventoryMessage(unitTestParams);
  inv.addBlock(block);
  inbound(p1,inv);
  Object getData=outbound(p1);
  assertTrue(getData instanceof GetDataMessage);
  assertTrue(((GetDataMessage)getData).getItems().size() == 1);
  assertTrue(((GetDataMessage)getData).getItems().get(0).hash.equals(block.getHash()));
  assertTrue(((GetDataMessage)getData).getItems().get(0).type == InventoryItem.Type.FilteredBlock);
  Object ping=outbound(p1);
  assertTrue(ping instanceof Ping);
  inbound(p1,filteredBlock);
  inbound(p1,tx0);
  inbound(p1,tx1);
  inbound(p1,tx2);
  inbound(p1,tx3);
  inbound(p1,new Pong(((Ping)ping).getNonce()));
  pingAndWait(p1);
  Set<Transaction> transactions=wallet.getTransactions(false);
  assertTrue(transactions.size() == 4);
  for (  Transaction tx : transactions) {
    assertTrue(tx.getConfidence().getConfidenceType() == ConfidenceType.BUILDING);
    assertTrue(tx.getConfidence().getDepthInBlocks() == 1);
    assertTrue(tx.getAppearsInHashes().keySet().contains(block.getHash()));
    assertTrue(tx.getAppearsInHashes().size() == 1);
  }
  closePeer(peerOf(p1));
  peerGroup.stopAsync();
  super.tearDown();
}",0.9926073357975548
85671,"@Test public void preferLocalPeer() throws IOException {
  ServerSocket local=new ServerSocket(params.getPort(),100,InetAddresses.forString(""String_Node_Str""));
  try {
    peerGroup.startAsync();
    peerGroup.awaitRunning();
    local.accept().close();
    local.accept();
    assertEquals(1,peerGroup.getMaxConnections());
    assertEquals(PeerAddress.localhost(params),peerGroup.getPendingPeers().get(0).getAddress());
  }
  finally {
    local.close();
  }
}","@Test public void preferLocalPeer() throws IOException {
  ServerSocket local=null;
  try {
    local=new ServerSocket(params.getPort(),100,InetAddresses.forString(""String_Node_Str""));
  }
 catch (  BindException e) {
    return;
  }
  try {
    peerGroup.setUseLocalhostPeerWhenPossible(true);
    peerGroup.startAsync();
    peerGroup.awaitRunning();
    local.accept().close();
    local.accept();
    assertEquals(1,peerGroup.getMaxConnections());
    assertEquals(PeerAddress.localhost(params),peerGroup.getPendingPeers().get(0).getAddress());
  }
  finally {
    local.close();
  }
}",0.8802281368821293
85672,"private List<Transaction> maybeRotateKeys(@Nullable KeyParameter aesKey,boolean sign) throws DeterministicUpgradeRequiresPassword {
  checkState(lock.isHeldByCurrentThread());
  List<Transaction> results=Lists.newLinkedList();
  long keyRotationTimestamp=vKeyRotationTimestamp;
  if (keyRotationTimestamp == 0)   return results;
  boolean allChainsRotating=true;
  for (  DeterministicKeyChain chain : keychain.getDeterministicKeyChains()) {
    if (chain.getEarliestKeyCreationTime() > vKeyRotationTimestamp) {
      allChainsRotating=false;
      break;
    }
  }
  if (allChainsRotating) {
    try {
      if (keychain.getImportedKeys().isEmpty()) {
        log.info(""String_Node_Str"");
        keychain.createAndActivateNewHDChain();
      }
 else {
        log.info(""String_Node_Str"");
        keychain.upgradeToDeterministic(keyRotationTimestamp,aesKey);
        log.info(""String_Node_Str"");
      }
    }
 catch (    AllRandomKeysRotating rotating) {
      log.info(""String_Node_Str"");
      keychain.createAndActivateNewHDChain();
    }
    saveNow();
  }
  Transaction tx;
  do {
    tx=rekeyOneBatch(keyRotationTimestamp,aesKey,results,sign);
    if (tx != null)     results.add(tx);
  }
 while (tx != null && tx.getInputs().size() == KeyTimeCoinSelector.MAX_SIMULTANEOUS_INPUTS);
  return results;
}","private List<Transaction> maybeRotateKeys(@Nullable KeyParameter aesKey,boolean sign) throws DeterministicUpgradeRequiresPassword {
  checkState(lock.isHeldByCurrentThread());
  List<Transaction> results=Lists.newLinkedList();
  long keyRotationTimestamp=vKeyRotationTimestamp;
  if (keyRotationTimestamp == 0)   return results;
  boolean allChainsRotating=true;
  for (  DeterministicKeyChain chain : keychain.getDeterministicKeyChains()) {
    if (chain.getEarliestKeyCreationTime() >= vKeyRotationTimestamp) {
      allChainsRotating=false;
      break;
    }
  }
  if (allChainsRotating) {
    try {
      if (keychain.getImportedKeys().isEmpty()) {
        log.info(""String_Node_Str"");
        keychain.createAndActivateNewHDChain();
      }
 else {
        log.info(""String_Node_Str"");
        keychain.upgradeToDeterministic(keyRotationTimestamp,aesKey);
        log.info(""String_Node_Str"");
      }
    }
 catch (    AllRandomKeysRotating rotating) {
      log.info(""String_Node_Str"");
      keychain.createAndActivateNewHDChain();
    }
    saveNow();
  }
  Transaction tx;
  do {
    tx=rekeyOneBatch(keyRotationTimestamp,aesKey,results,sign);
    if (tx != null)     results.add(tx);
  }
 while (tx != null && tx.getInputs().size() == KeyTimeCoinSelector.MAX_SIMULTANEOUS_INPUTS);
  return results;
}",0.9996184662342618
85673,"@SuppressWarnings(""String_Node_Str"") @Test public void keyRotationHD2() throws Exception {
  Utils.setMockClock();
  ECKey badKey=ECKey.fromPrivate(Utils.HEX.decode(""String_Node_Str""));
  badKey.setCreationTimeSeconds(Utils.currentTimeSeconds());
  Utils.rollMockClock(86400);
  ECKey goodKey=ECKey.fromPrivate(Utils.HEX.decode(""String_Node_Str""));
  goodKey.setCreationTimeSeconds(Utils.currentTimeSeconds());
  KeyChainGroup kcg=new KeyChainGroup(params);
  kcg.importKeys(badKey,goodKey);
  Utils.rollMockClock(86400);
  wallet=new Wallet(params,kcg);
  wallet.upgradeToDeterministic(null);
  DeterministicKey badWatchingKey=wallet.getWatchingKey();
  assertEquals(badKey.getCreationTimeSeconds(),badWatchingKey.getCreationTimeSeconds());
  sendMoneyToWallet(wallet,CENT,badWatchingKey.toAddress(params),AbstractBlockChain.NewBlockType.BEST_CHAIN);
  wallet.setKeyRotationTime(goodKey.getCreationTimeSeconds());
  List<Transaction> txns=wallet.doMaintenance(null,false).get();
  assertEquals(1,txns.size());
  Address output=txns.get(0).getOutput(0).getAddressFromP2PKHScript(params);
  ECKey usedKey=wallet.findKeyFromPubHash(output.getHash160());
  assertEquals(goodKey.getCreationTimeSeconds(),usedKey.getCreationTimeSeconds());
  assertEquals(goodKey.getCreationTimeSeconds(),wallet.freshReceiveKey().getCreationTimeSeconds());
  assertEquals(""String_Node_Str"",usedKey.toAddress(params).toString());
}","@SuppressWarnings(""String_Node_Str"") @Test public void keyRotationHD2() throws Exception {
  Utils.setMockClock();
  ECKey badKey=ECKey.fromPrivate(Utils.HEX.decode(""String_Node_Str""));
  badKey.setCreationTimeSeconds(Utils.currentTimeSeconds());
  Utils.rollMockClock(86400);
  ECKey goodKey=ECKey.fromPrivate(Utils.HEX.decode(""String_Node_Str""));
  goodKey.setCreationTimeSeconds(Utils.currentTimeSeconds());
  final AtomicReference<List<DeterministicKeyChain>> fChains=new AtomicReference<List<DeterministicKeyChain>>();
  KeyChainGroup kcg=new KeyChainGroup(params){
{
      fChains.set(chains);
    }
  }
;
  kcg.importKeys(badKey,goodKey);
  Utils.rollMockClock(86400);
  wallet=new Wallet(params,kcg);
  assertTrue(fChains.get().isEmpty());
  wallet.upgradeToDeterministic(null);
  DeterministicKey badWatchingKey=wallet.getWatchingKey();
  assertEquals(badKey.getCreationTimeSeconds(),badWatchingKey.getCreationTimeSeconds());
  sendMoneyToWallet(wallet,CENT,badWatchingKey.toAddress(params),AbstractBlockChain.NewBlockType.BEST_CHAIN);
  wallet.setKeyRotationTime(goodKey.getCreationTimeSeconds());
  List<Transaction> txns=wallet.doMaintenance(null,false).get();
  assertEquals(1,txns.size());
  Address output=txns.get(0).getOutput(0).getAddressFromP2PKHScript(params);
  ECKey usedKey=wallet.findKeyFromPubHash(output.getHash160());
  assertEquals(goodKey.getCreationTimeSeconds(),usedKey.getCreationTimeSeconds());
  assertEquals(goodKey.getCreationTimeSeconds(),wallet.freshReceiveKey().getCreationTimeSeconds());
  assertEquals(""String_Node_Str"",usedKey.toAddress(params).toString());
  DeterministicKeyChain c=fChains.get().get(1);
  assertEquals(c.getEarliestKeyCreationTime(),goodKey.getCreationTimeSeconds());
  assertEquals(2,fChains.get().size());
  wallet.commitTx(txns.get(0));
  assertTrue(wallet.doMaintenance(null,false).get().isEmpty());
  assertEquals(c,fChains.get().get(1));
  assertEquals(2,fChains.get().size());
}",0.8395945140131187
85674,"private List<Transaction> maybeRotateKeys(@Nullable KeyParameter aesKey,boolean sign) throws DeterministicUpgradeRequiresPassword {
  checkState(lock.isHeldByCurrentThread());
  List<Transaction> results=Lists.newLinkedList();
  long keyRotationTimestamp=vKeyRotationTimestamp;
  if (keyRotationTimestamp == 0)   return results;
  boolean allChainsRotating=true;
  for (  DeterministicKeyChain chain : keychain.getDeterministicKeyChains()) {
    if (chain.getEarliestKeyCreationTime() > vKeyRotationTimestamp) {
      allChainsRotating=false;
      break;
    }
  }
  if (allChainsRotating) {
    try {
      if (keychain.getImportedKeys().isEmpty()) {
        log.info(""String_Node_Str"");
        keychain.createAndActivateNewHDChain();
      }
 else {
        log.info(""String_Node_Str"");
        keychain.upgradeToDeterministic(keyRotationTimestamp,aesKey);
        log.info(""String_Node_Str"");
      }
    }
 catch (    AllRandomKeysRotating rotating) {
      log.info(""String_Node_Str"");
      keychain.createAndActivateNewHDChain();
    }
    saveNow();
  }
  Transaction tx;
  do {
    tx=rekeyOneBatch(keyRotationTimestamp,aesKey,results,sign);
    if (tx != null)     results.add(tx);
  }
 while (tx != null && tx.getInputs().size() == KeyTimeCoinSelector.MAX_SIMULTANEOUS_INPUTS);
  return results;
}","private List<Transaction> maybeRotateKeys(@Nullable KeyParameter aesKey,boolean sign) throws DeterministicUpgradeRequiresPassword {
  checkState(lock.isHeldByCurrentThread());
  List<Transaction> results=Lists.newLinkedList();
  long keyRotationTimestamp=vKeyRotationTimestamp;
  if (keyRotationTimestamp == 0)   return results;
  boolean allChainsRotating=true;
  for (  DeterministicKeyChain chain : keychain.getDeterministicKeyChains()) {
    if (chain.getEarliestKeyCreationTime() >= vKeyRotationTimestamp) {
      allChainsRotating=false;
      break;
    }
  }
  if (allChainsRotating) {
    try {
      if (keychain.getImportedKeys().isEmpty()) {
        log.info(""String_Node_Str"");
        keychain.createAndActivateNewHDChain();
      }
 else {
        log.info(""String_Node_Str"");
        keychain.upgradeToDeterministic(keyRotationTimestamp,aesKey);
        log.info(""String_Node_Str"");
      }
    }
 catch (    AllRandomKeysRotating rotating) {
      log.info(""String_Node_Str"");
      keychain.createAndActivateNewHDChain();
    }
    saveNow();
  }
  Transaction tx;
  do {
    tx=rekeyOneBatch(keyRotationTimestamp,aesKey,results,sign);
    if (tx != null)     results.add(tx);
  }
 while (tx != null && tx.getInputs().size() == KeyTimeCoinSelector.MAX_SIMULTANEOUS_INPUTS);
  return results;
}",0.9996184662342618
85675,"@SuppressWarnings(""String_Node_Str"") @Test public void keyRotationHD2() throws Exception {
  Utils.setMockClock();
  ECKey badKey=ECKey.fromPrivate(Utils.HEX.decode(""String_Node_Str""));
  badKey.setCreationTimeSeconds(Utils.currentTimeSeconds());
  Utils.rollMockClock(86400);
  ECKey goodKey=ECKey.fromPrivate(Utils.HEX.decode(""String_Node_Str""));
  goodKey.setCreationTimeSeconds(Utils.currentTimeSeconds());
  KeyChainGroup kcg=new KeyChainGroup(params);
  kcg.importKeys(badKey,goodKey);
  Utils.rollMockClock(86400);
  wallet=new Wallet(params,kcg);
  wallet.upgradeToDeterministic(null);
  DeterministicKey badWatchingKey=wallet.getWatchingKey();
  assertEquals(badKey.getCreationTimeSeconds(),badWatchingKey.getCreationTimeSeconds());
  sendMoneyToWallet(wallet,CENT,badWatchingKey.toAddress(params),AbstractBlockChain.NewBlockType.BEST_CHAIN);
  wallet.setKeyRotationTime(goodKey.getCreationTimeSeconds());
  List<Transaction> txns=wallet.doMaintenance(null,false).get();
  assertEquals(1,txns.size());
  Address output=txns.get(0).getOutput(0).getAddressFromP2PKHScript(params);
  ECKey usedKey=wallet.findKeyFromPubHash(output.getHash160());
  assertEquals(goodKey.getCreationTimeSeconds(),usedKey.getCreationTimeSeconds());
  assertEquals(goodKey.getCreationTimeSeconds(),wallet.freshReceiveKey().getCreationTimeSeconds());
  assertEquals(""String_Node_Str"",usedKey.toAddress(params).toString());
}","@SuppressWarnings(""String_Node_Str"") @Test public void keyRotationHD2() throws Exception {
  Utils.setMockClock();
  ECKey badKey=ECKey.fromPrivate(Utils.HEX.decode(""String_Node_Str""));
  badKey.setCreationTimeSeconds(Utils.currentTimeSeconds());
  Utils.rollMockClock(86400);
  ECKey goodKey=ECKey.fromPrivate(Utils.HEX.decode(""String_Node_Str""));
  goodKey.setCreationTimeSeconds(Utils.currentTimeSeconds());
  final AtomicReference<List<DeterministicKeyChain>> fChains=new AtomicReference<List<DeterministicKeyChain>>();
  KeyChainGroup kcg=new KeyChainGroup(params){
{
      fChains.set(chains);
    }
  }
;
  kcg.importKeys(badKey,goodKey);
  Utils.rollMockClock(86400);
  wallet=new Wallet(params,kcg);
  assertTrue(fChains.get().isEmpty());
  wallet.upgradeToDeterministic(null);
  DeterministicKey badWatchingKey=wallet.getWatchingKey();
  assertEquals(badKey.getCreationTimeSeconds(),badWatchingKey.getCreationTimeSeconds());
  sendMoneyToWallet(wallet,CENT,badWatchingKey.toAddress(params),AbstractBlockChain.NewBlockType.BEST_CHAIN);
  wallet.setKeyRotationTime(goodKey.getCreationTimeSeconds());
  List<Transaction> txns=wallet.doMaintenance(null,false).get();
  assertEquals(1,txns.size());
  Address output=txns.get(0).getOutput(0).getAddressFromP2PKHScript(params);
  ECKey usedKey=wallet.findKeyFromPubHash(output.getHash160());
  assertEquals(goodKey.getCreationTimeSeconds(),usedKey.getCreationTimeSeconds());
  assertEquals(goodKey.getCreationTimeSeconds(),wallet.freshReceiveKey().getCreationTimeSeconds());
  assertEquals(""String_Node_Str"",usedKey.toAddress(params).toString());
  DeterministicKeyChain c=fChains.get().get(1);
  assertEquals(c.getEarliestKeyCreationTime(),goodKey.getCreationTimeSeconds());
  assertEquals(2,fChains.get().size());
  wallet.commitTx(txns.get(0));
  assertTrue(wallet.doMaintenance(null,false).get().isEmpty());
  assertEquals(c,fChains.get().get(1));
  assertEquals(2,fChains.get().size());
}",0.8395945140131187
85676,"/** 
 * Called on a pushdata chunk, returns true if it uses the smallest possible way (according to BIP62) to push the data.
 */
public boolean isShortestPossiblePushData(){
  checkState(isPushData());
  if (data.length == 0)   return opcode == OP_0;
  if (data.length == 1) {
    byte b=data[0];
    if (b >= 0x01 && b <= 0x10)     return opcode == OP_1 + b - 1;
    if (b == 0x81)     return opcode == OP_1NEGATE;
  }
  if (data.length < OP_PUSHDATA1)   return opcode == data.length;
  if (data.length < 256)   return opcode == OP_PUSHDATA1;
  if (data.length < 65536)   return opcode == OP_PUSHDATA2;
  return opcode == OP_PUSHDATA4;
}","/** 
 * Called on a pushdata chunk, returns true if it uses the smallest possible way (according to BIP62) to push the data.
 */
public boolean isShortestPossiblePushData(){
  checkState(isPushData());
  if (data.length == 0)   return opcode == OP_0;
  if (data.length == 1) {
    byte b=data[0];
    if (b >= 0x01 && b <= 0x10)     return opcode == OP_1 + b - 1;
    if ((b & 0xFF) == 0x81)     return opcode == OP_1NEGATE;
  }
  if (data.length < OP_PUSHDATA1)   return opcode == data.length;
  if (data.length < 256)   return opcode == OP_PUSHDATA1;
  if (data.length < 65536)   return opcode == OP_PUSHDATA2;
  return opcode == OP_PUSHDATA4;
}",0.9914396887159532
85677,"public void write(OutputStream stream) throws IOException {
  if (isOpCode()) {
    checkState(data == null);
    stream.write(opcode);
  }
 else   if (data != null) {
    checkNotNull(data);
    if (opcode < OP_PUSHDATA1) {
      checkState(data.length == opcode);
      stream.write(opcode);
    }
 else     if (opcode == OP_PUSHDATA1) {
      checkState(data.length <= 0xFF);
      stream.write(OP_PUSHDATA1);
      stream.write(data.length);
    }
 else     if (opcode == OP_PUSHDATA2) {
      checkState(data.length <= 0xFFFF);
      stream.write(OP_PUSHDATA2);
      stream.write(0xFF & data.length);
      stream.write(0xFF & (data.length >> 8));
    }
 else     if (opcode == OP_PUSHDATA4) {
      checkState(data.length <= Script.MAX_SCRIPT_ELEMENT_SIZE);
      stream.write(OP_PUSHDATA4);
      Utils.uint32ToByteStreamLE(data.length,stream);
    }
 else {
      throw new RuntimeException(""String_Node_Str"");
    }
    stream.write(data);
  }
 else {
    stream.write(opcode);
  }
}","public void write(OutputStream stream) throws IOException {
  if (isOpCode()) {
    checkState(data == null);
    stream.write(opcode);
  }
 else   if (data != null) {
    if (opcode < OP_PUSHDATA1) {
      checkState(data.length == opcode);
      stream.write(opcode);
    }
 else     if (opcode == OP_PUSHDATA1) {
      checkState(data.length <= 0xFF);
      stream.write(OP_PUSHDATA1);
      stream.write(data.length);
    }
 else     if (opcode == OP_PUSHDATA2) {
      checkState(data.length <= 0xFFFF);
      stream.write(OP_PUSHDATA2);
      stream.write(0xFF & data.length);
      stream.write(0xFF & (data.length >> 8));
    }
 else     if (opcode == OP_PUSHDATA4) {
      checkState(data.length <= Script.MAX_SCRIPT_ELEMENT_SIZE);
      stream.write(OP_PUSHDATA4);
      Utils.uint32ToByteStreamLE(data.length,stream);
    }
 else {
      throw new RuntimeException(""String_Node_Str"");
    }
    stream.write(data);
  }
 else {
    stream.write(opcode);
  }
}",0.9877675840978594
85678,"/** 
 * Checks the output to see if the script violates a standardness rule. Not complete.
 */
public static RuleViolation isOutputStandard(TransactionOutput output){
  if (MIN_ANALYSIS_NONDUST_OUTPUT.compareTo(output.getValue()) > 0)   return RuleViolation.DUST;
  for (  ScriptChunk chunk : output.getScriptPubKey().getChunks()) {
    if (chunk.isPushData() && !chunk.isShortestPossiblePushData())     return RuleViolation.SHORTEST_POSSIBLE_PUSHDATA;
  }
  return RuleViolation.NONE;
}","/** 
 * Checks the output to see if the script violates a standardness rule. Not complete.
 */
public static RuleViolation isOutputStandard(TransactionOutput output){
  if (output.getValue().compareTo(MIN_ANALYSIS_NONDUST_OUTPUT) < 0)   return RuleViolation.DUST;
  for (  ScriptChunk chunk : output.getScriptPubKey().getChunks()) {
    if (chunk.isPushData() && !chunk.isShortestPossiblePushData())     return RuleViolation.SHORTEST_POSSIBLE_PUSHDATA;
  }
  return RuleViolation.NONE;
}",0.9363449691991786
85679,"/** 
 * Checks the output to see if the script violates a standardness rule. Not complete.
 */
public static RuleViolation isOutputStandard(TransactionOutput output){
  if (MIN_ANALYSIS_NONDUST_OUTPUT.compareTo(output.getValue()) > 0)   return RuleViolation.DUST;
  for (  ScriptChunk chunk : output.getScriptPubKey().getChunks()) {
    if (chunk.isPushData() && !chunk.isShortestPossiblePushData())     return RuleViolation.SHORTEST_POSSIBLE_PUSHDATA;
  }
  return RuleViolation.NONE;
}","/** 
 * Checks the output to see if the script violates a standardness rule. Not complete.
 */
public static RuleViolation isOutputStandard(TransactionOutput output){
  if (output.getValue().compareTo(MIN_ANALYSIS_NONDUST_OUTPUT) < 0)   return RuleViolation.DUST;
  for (  ScriptChunk chunk : output.getScriptPubKey().getChunks()) {
    if (chunk.isPushData() && !chunk.isShortestPossiblePushData())     return RuleViolation.SHORTEST_POSSIBLE_PUSHDATA;
  }
  return RuleViolation.NONE;
}",0.9363449691991786
85680,"/** 
 * Convert entropy data to mnemonic word list.
 */
public List<String> toMnemonic(byte[] entropy) throws MnemonicException.MnemonicLengthException {
  if (entropy.length % 4 > 0)   throw new MnemonicException.MnemonicLengthException(""String_Node_Str"");
  byte[] hash=Sha256Hash.create(entropy).getBytes();
  boolean[] hashBits=bytesToBits(hash);
  boolean[] entropyBits=bytesToBits(entropy);
  int checksumLengthBits=entropyBits.length / 32;
  boolean[] concatBits=new boolean[entropyBits.length + checksumLengthBits];
  System.arraycopy(entropyBits,0,concatBits,0,entropyBits.length);
  System.arraycopy(hashBits,0,concatBits,entropyBits.length,checksumLengthBits);
  ArrayList<String> words=new ArrayList<String>();
  int nwords=concatBits.length / 11;
  for (int i=0; i < nwords; ++i) {
    int index=0;
    for (int j=0; j < 11; ++j) {
      index<<=1;
      if (concatBits[(i * 11) + j])       index|=0x1;
    }
    words.add(this.wordList.get(index));
  }
  return words;
}","/** 
 * Convert entropy data to mnemonic word list.
 */
public List<String> toMnemonic(byte[] entropy) throws MnemonicException.MnemonicLengthException {
  if (entropy.length % 4 > 0)   throw new MnemonicException.MnemonicLengthException(""String_Node_Str"");
  if (entropy.length == 0)   throw new MnemonicException.MnemonicLengthException(""String_Node_Str"");
  byte[] hash=Sha256Hash.create(entropy).getBytes();
  boolean[] hashBits=bytesToBits(hash);
  boolean[] entropyBits=bytesToBits(entropy);
  int checksumLengthBits=entropyBits.length / 32;
  boolean[] concatBits=new boolean[entropyBits.length + checksumLengthBits];
  System.arraycopy(entropyBits,0,concatBits,0,entropyBits.length);
  System.arraycopy(hashBits,0,concatBits,entropyBits.length,checksumLengthBits);
  ArrayList<String> words=new ArrayList<String>();
  int nwords=concatBits.length / 11;
  for (int i=0; i < nwords; ++i) {
    int index=0;
    for (int j=0; j < 11; ++j) {
      index<<=1;
      if (concatBits[(i * 11) + j])       index|=0x1;
    }
    words.add(this.wordList.get(index));
  }
  return words;
}",0.9511841469308844
85681,"/** 
 * Convert mnemonic word list to original entropy value.
 */
public byte[] toEntropy(List<String> words) throws MnemonicException.MnemonicLengthException, MnemonicException.MnemonicWordException, MnemonicException.MnemonicChecksumException {
  if (words.size() % 3 > 0)   throw new MnemonicException.MnemonicLengthException(""String_Node_Str"");
  int concatLenBits=words.size() * 11;
  boolean[] concatBits=new boolean[concatLenBits];
  int wordindex=0;
  for (  String word : words) {
    int ndx=Collections.binarySearch(this.wordList,word);
    if (ndx < 0)     throw new MnemonicException.MnemonicWordException(word);
    for (int ii=0; ii < 11; ++ii)     concatBits[(wordindex * 11) + ii]=(ndx & (1 << (10 - ii))) != 0;
    ++wordindex;
  }
  int checksumLengthBits=concatLenBits / 33;
  int entropyLengthBits=concatLenBits - checksumLengthBits;
  byte[] entropy=new byte[entropyLengthBits / 8];
  for (int ii=0; ii < entropy.length; ++ii)   for (int jj=0; jj < 8; ++jj)   if (concatBits[(ii * 8) + jj])   entropy[ii]|=1 << (7 - jj);
  byte[] hash=Sha256Hash.create(entropy).getBytes();
  boolean[] hashBits=bytesToBits(hash);
  for (int i=0; i < checksumLengthBits; ++i)   if (concatBits[entropyLengthBits + i] != hashBits[i])   throw new MnemonicException.MnemonicChecksumException();
  return entropy;
}","/** 
 * Convert mnemonic word list to original entropy value.
 */
public byte[] toEntropy(List<String> words) throws MnemonicException.MnemonicLengthException, MnemonicException.MnemonicWordException, MnemonicException.MnemonicChecksumException {
  if (words.size() % 3 > 0)   throw new MnemonicException.MnemonicLengthException(""String_Node_Str"");
  if (words.size() == 0)   throw new MnemonicException.MnemonicLengthException(""String_Node_Str"");
  int concatLenBits=words.size() * 11;
  boolean[] concatBits=new boolean[concatLenBits];
  int wordindex=0;
  for (  String word : words) {
    int ndx=Collections.binarySearch(this.wordList,word);
    if (ndx < 0)     throw new MnemonicException.MnemonicWordException(word);
    for (int ii=0; ii < 11; ++ii)     concatBits[(wordindex * 11) + ii]=(ndx & (1 << (10 - ii))) != 0;
    ++wordindex;
  }
  int checksumLengthBits=concatLenBits / 33;
  int entropyLengthBits=concatLenBits - checksumLengthBits;
  byte[] entropy=new byte[entropyLengthBits / 8];
  for (int ii=0; ii < entropy.length; ++ii)   for (int jj=0; jj < 8; ++jj)   if (concatBits[(ii * 8) + jj])   entropy[ii]|=1 << (7 - jj);
  byte[] hash=Sha256Hash.create(entropy).getBytes();
  boolean[] hashBits=bytesToBits(hash);
  for (int i=0; i < checksumLengthBits; ++i)   if (concatBits[entropyLengthBits + i] != hashBits[i])   throw new MnemonicException.MnemonicChecksumException();
  return entropy;
}",0.9637229754488824
85682,"/** 
 * <p>Updates the wallet by checking if this TX spends any of our outputs, and marking them as spent if so. If fromChain is true, also checks to see if any pending transaction spends outputs of this transaction and marks the spent flags appropriately.</p> <p>It can be called in two contexts. One is when we receive a transaction on the best chain but it wasn't pending, this most commonly happens when we have a set of keys but the wallet transactions were wiped and we are catching up with the block chain. It can also happen if a block includes a transaction we never saw at broadcast time. If this tx double spends, it takes precedence over our pending transactions and the pending tx goes dead.</p> <p>The other context it can be called is from   {@link Wallet#receivePending(Transaction,java.util.List)}, ie we saw a tx be broadcast or one was submitted directly that spends our own coins. If this tx double spends it does NOT take precedence because the winner will be resolved by the miners - we assume that our version will win, if we are wrong then when a block appears the tx will go dead.</p>
 * @param tx The transaction which is being updated.
 * @param fromChain If true, the tx appeared on the current best chain, if false it was pending.
 */
private void updateForSpends(Transaction tx,boolean fromChain) throws VerificationException {
  checkState(lock.isHeldByCurrentThread());
  if (fromChain)   checkState(!pending.containsKey(tx.getHash()));
  for (  TransactionInput input : tx.getInputs()) {
    TransactionInput.ConnectionResult result=input.connect(unspent,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
    if (result == TransactionInput.ConnectionResult.NO_SUCH_TX) {
      result=input.connect(spent,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
      if (result == TransactionInput.ConnectionResult.NO_SUCH_TX) {
        result=input.connect(pending,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
        if (result == TransactionInput.ConnectionResult.NO_SUCH_TX) {
          continue;
        }
      }
    }
    if (result == TransactionInput.ConnectionResult.ALREADY_SPENT) {
      if (fromChain) {
        log.warn(""String_Node_Str"");
      }
 else {
        log.warn(""String_Node_Str"");
        log.warn(""String_Node_Str"",tx.getInputs().indexOf(input));
        log.warn(""String_Node_Str"",tx.getHash(),Utils.HEX.encode(tx.unsafeBitcoinSerialize()));
        Transaction other=input.getConnectedOutput().getSpentBy().getParentTransaction();
        log.warn(""String_Node_Str"",other.getHash(),Utils.HEX.encode(tx.unsafeBitcoinSerialize()));
      }
    }
 else     if (result == TransactionInput.ConnectionResult.SUCCESS) {
      Transaction connected=checkNotNull(input.getOutpoint().fromTx);
      log.info(""String_Node_Str"",input.getOutpoint());
      maybeMovePool(connected,""String_Node_Str"");
    }
  }
  if (fromChain) {
    for (    Transaction pendingTx : pending.values()) {
      for (      TransactionInput input : pendingTx.getInputs()) {
        TransactionInput.ConnectionResult result=input.connect(tx,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
        checkState(result != TransactionInput.ConnectionResult.ALREADY_SPENT);
        if (result == TransactionInput.ConnectionResult.SUCCESS) {
          log.info(""String_Node_Str"",pendingTx.getHashAsString(),pendingTx.getInputs().indexOf(input));
        }
      }
    }
  }
}","/** 
 * <p>Updates the wallet by checking if this TX spends any of our outputs, and marking them as spent if so. If fromChain is true, also checks to see if any pending transaction spends outputs of this transaction and marks the spent flags appropriately.</p> <p>It can be called in two contexts. One is when we receive a transaction on the best chain but it wasn't pending, this most commonly happens when we have a set of keys but the wallet transactions were wiped and we are catching up with the block chain. It can also happen if a block includes a transaction we never saw at broadcast time. If this tx double spends, it takes precedence over our pending transactions and the pending tx goes dead.</p> <p>The other context it can be called is from   {@link Wallet#receivePending(Transaction,java.util.List)}, ie we saw a tx be broadcast or one was submitted directly that spends our own coins. If this tx double spends it does NOT take precedence because the winner will be resolved by the miners - we assume that our version will win, if we are wrong then when a block appears the tx will go dead.</p>
 * @param tx The transaction which is being updated.
 * @param fromChain If true, the tx appeared on the current best chain, if false it was pending.
 */
private void updateForSpends(Transaction tx,boolean fromChain) throws VerificationException {
  checkState(lock.isHeldByCurrentThread());
  if (fromChain)   checkState(!pending.containsKey(tx.getHash()));
  for (  TransactionInput input : tx.getInputs()) {
    TransactionInput.ConnectionResult result=input.connect(unspent,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
    if (result == TransactionInput.ConnectionResult.NO_SUCH_TX) {
      result=input.connect(spent,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
      if (result == TransactionInput.ConnectionResult.NO_SUCH_TX) {
        result=input.connect(pending,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
        if (result == TransactionInput.ConnectionResult.NO_SUCH_TX) {
          continue;
        }
      }
    }
    if (result == TransactionInput.ConnectionResult.ALREADY_SPENT) {
      if (fromChain) {
      }
 else {
        log.warn(""String_Node_Str"");
        log.warn(""String_Node_Str"",tx.getInputs().indexOf(input));
        log.warn(""String_Node_Str"",tx.getHash(),Utils.HEX.encode(tx.unsafeBitcoinSerialize()));
        Transaction other=input.getConnectedOutput().getSpentBy().getParentTransaction();
        log.warn(""String_Node_Str"",other.getHash(),Utils.HEX.encode(tx.unsafeBitcoinSerialize()));
      }
    }
 else     if (result == TransactionInput.ConnectionResult.SUCCESS) {
      Transaction connected=checkNotNull(input.getOutpoint().fromTx);
      log.info(""String_Node_Str"",input.getOutpoint());
      maybeMovePool(connected,""String_Node_Str"");
    }
  }
  if (fromChain) {
    for (    Transaction pendingTx : pending.values()) {
      for (      TransactionInput input : pendingTx.getInputs()) {
        TransactionInput.ConnectionResult result=input.connect(tx,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
        checkState(result != TransactionInput.ConnectionResult.ALREADY_SPENT);
        if (result == TransactionInput.ConnectionResult.SUCCESS) {
          log.info(""String_Node_Str"",pendingTx.getHashAsString(),pendingTx.getInputs().indexOf(input));
        }
      }
    }
  }
}",0.9945160812212837
85683,"private void handleKey(SelectionKey key) throws IOException {
  if (key.isValid() && key.isConnectable()) {
    StreamParser parser=(StreamParser)key.attachment();
    SocketChannel sc=(SocketChannel)key.channel();
    ConnectionHandler handler=new ConnectionHandler(parser,key,connectedHandlers);
    try {
      if (sc.finishConnect()) {
        log.info(""String_Node_Str"",sc.socket().getRemoteSocketAddress());
        key.interestOps(key.interestOps() | SelectionKey.OP_READ).attach(handler);
        handler.parser.connectionOpened();
      }
 else {
        log.error(""String_Node_Str"",sc.socket().getRemoteSocketAddress());
        handler.closeConnection();
      }
    }
 catch (    Exception e) {
      log.error(""String_Node_Str"",Throwables.getRootCause(e).getMessage());
      handler.closeConnection();
    }
  }
 else   ConnectionHandler.handleKey(key);
}","private void handleKey(SelectionKey key) throws IOException {
  if (key.isValid() && key.isConnectable()) {
    StreamParser parser=(StreamParser)key.attachment();
    SocketChannel sc=(SocketChannel)key.channel();
    ConnectionHandler handler=new ConnectionHandler(parser,key,connectedHandlers);
    try {
      if (sc.finishConnect()) {
        log.info(""String_Node_Str"",sc.socket().getRemoteSocketAddress());
        key.interestOps((key.interestOps() | SelectionKey.OP_READ) & ~SelectionKey.OP_CONNECT).attach(handler);
        handler.parser.connectionOpened();
      }
 else {
        log.error(""String_Node_Str"",sc.socket().getRemoteSocketAddress());
        handler.closeConnection();
      }
    }
 catch (    Exception e) {
      log.error(""String_Node_Str"",Throwables.getRootCause(e).getMessage());
      handler.closeConnection();
    }
  }
 else   ConnectionHandler.handleKey(key);
}",0.9835880022637238
85684,"/** 
 * <p>Gets a bloom filter that contains all of the public keys from this wallet, and which will provide the given false-positive rate if it has size elements. Keep in mind that you will get 2 elements in the bloom filter for each key in the wallet, for the public key and the hash of the public key (address form).</p> <p>This is used to generate a BloomFilter which can be   {@link BloomFilter#merge(BloomFilter)}d with another. It could also be used if you have a specific target for the filter's size.</p> <p>See the docs for   {@link BloomFilter(int, double)} for a brief explanation of anonymity when using bloomfilters.</p>
 */
@Override public BloomFilter getBloomFilter(int size,double falsePositiveRate,long nTweak){
  BloomFilter filter;
  lock.lock();
  try {
    filter=keychain.getBloomFilter(size,falsePositiveRate,nTweak);
    for (    Script script : watchedScripts) {
      for (      ScriptChunk chunk : script.getChunks()) {
        if (!chunk.isOpCode() && chunk.data.length >= MINIMUM_BLOOM_DATA_LENGTH) {
          filter.insert(chunk.data);
        }
      }
    }
  }
  finally {
    lock.unlock();
  }
  for (  Transaction tx : getTransactions(false)) {
    for (int i=0; i < tx.getOutputs().size(); i++) {
      TransactionOutput out=tx.getOutputs().get(i);
      try {
        if (isTxOutputBloomFilterable(out)) {
          TransactionOutPoint outPoint=new TransactionOutPoint(params,i,tx);
          filter.insert(outPoint.bitcoinSerialize());
        }
      }
 catch (      ScriptException e) {
        throw new RuntimeException(e);
      }
    }
  }
  return filter;
}","/** 
 * <p>Gets a bloom filter that contains all of the public keys from this wallet, and which will provide the given false-positive rate if it has size elements. Keep in mind that you will get 2 elements in the bloom filter for each key in the wallet, for the public key and the hash of the public key (address form).</p> <p>This is used to generate a BloomFilter which can be   {@link BloomFilter#merge(BloomFilter)}d with another. It could also be used if you have a specific target for the filter's size.</p> <p>See the docs for   {@link BloomFilter(int, double)} for a brief explanation of anonymity when using bloomfilters.</p>
 */
@Override public BloomFilter getBloomFilter(int size,double falsePositiveRate,long nTweak){
  lock.lock();
  try {
    BloomFilter filter=keychain.getBloomFilter(size,falsePositiveRate,nTweak);
    for (    Script script : watchedScripts) {
      for (      ScriptChunk chunk : script.getChunks()) {
        if (!chunk.isOpCode() && chunk.data.length >= MINIMUM_BLOOM_DATA_LENGTH) {
          filter.insert(chunk.data);
        }
      }
    }
    for (    Transaction tx : getTransactions(false)) {
      for (int i=0; i < tx.getOutputs().size(); i++) {
        TransactionOutput out=tx.getOutputs().get(i);
        try {
          if (isTxOutputBloomFilterable(out)) {
            TransactionOutPoint outPoint=new TransactionOutPoint(params,i,tx);
            filter.insert(outPoint.bitcoinSerialize());
          }
        }
 catch (        ScriptException e) {
          throw new RuntimeException(e);
        }
      }
    }
    return filter;
  }
  finally {
    lock.unlock();
  }
}",0.9196042053184912
85685,"private boolean isTxOutputBloomFilterable(TransactionOutput out){
  boolean isScriptTypeSupported=out.getScriptPubKey().isSentToRawPubKey() || out.getScriptPubKey().isPayToScriptHash();
  return (out.isMine(this) && isScriptTypeSupported) || out.isWatched(this);
}","private boolean isTxOutputBloomFilterable(TransactionOutput out){
  checkState(lock.isHeldByCurrentThread());
  boolean isScriptTypeSupported=out.getScriptPubKey().isSentToRawPubKey() || out.getScriptPubKey().isPayToScriptHash();
  return (out.isMine(this) && isScriptTypeSupported) || out.isWatched(this);
}",0.9230769230769232
85686,"/** 
 * If we are watching any scripts, the bloom filter must update on peers whenever an output is identified.  This is because we don't necessarily have the associated pubkey, so we can't watch for it on spending transactions.
 */
@Override public boolean isRequiringUpdateAllBloomFilter(){
  return !watchedScripts.isEmpty();
}","/** 
 * If we are watching any scripts, the bloom filter must update on peers whenever an output is identified.  This is because we don't necessarily have the associated pubkey, so we can't watch for it on spending transactions.
 */
@Override public boolean isRequiringUpdateAllBloomFilter(){
  lock.lock();
  try {
    return !watchedScripts.isEmpty();
  }
  finally {
    lock.unlock();
  }
}",0.8287292817679558
85687,"/** 
 * Returns the number of distinct data items (note: NOT keys) that will be inserted into a bloom filter, when it is constructed.
 */
@Override public int getBloomFilterElementCount(){
  int size=keychain.getBloomFilterElementCount();
  for (  Transaction tx : getTransactions(false)) {
    for (    TransactionOutput out : tx.getOutputs()) {
      try {
        if (isTxOutputBloomFilterable(out))         size++;
      }
 catch (      ScriptException e) {
        throw new RuntimeException(e);
      }
    }
  }
  size+=watchedScripts.size();
  return size;
}","/** 
 * Returns the number of distinct data items (note: NOT keys) that will be inserted into a bloom filter, when it is constructed.
 */
@Override public int getBloomFilterElementCount(){
  lock.lock();
  try {
    int size=keychain.getBloomFilterElementCount();
    for (    Transaction tx : getTransactions(false)) {
      for (      TransactionOutput out : tx.getOutputs()) {
        try {
          if (isTxOutputBloomFilterable(out))           size++;
        }
 catch (        ScriptException e) {
          throw new RuntimeException(e);
        }
      }
    }
    size+=watchedScripts.size();
    return size;
  }
  finally {
    lock.unlock();
  }
}",0.9233278955954324
85688,"@Override public int numKeys(){
  return basicKeyChain.numKeys();
}","@Override public int numKeys(){
  lock.lock();
  try {
    maybeLookAhead();
    return basicKeyChain.numKeys();
  }
  finally {
    lock.unlock();
  }
}",0.6090909090909091
85689,"/** 
 * Pre-generate enough keys to reach the lookahead size, but only if there are more than the lookaheadThreshold to be generated, so that the Bloom filter does not have to be regenerated that often. The returned mutable list of keys must be inserted into the basic key chain.
 */
private List<DeterministicKey> maybeLookAhead(DeterministicKey parent,int issued){
  checkState(lock.isHeldByCurrentThread());
  final int numChildren=hierarchy.getNumChildren(parent.getPath());
  final int lookaheadSize=getLookaheadSize();
  final int lookaheadThreshold=getLookaheadThreshold();
  final int needed=issued + lookaheadSize + lookaheadThreshold - numChildren;
  log.info(""String_Node_Str"",needed,issued,lookaheadSize,lookaheadThreshold,numChildren);
  if (needed <= lookaheadThreshold)   return new ArrayList<DeterministicKey>();
  List<DeterministicKey> result=new ArrayList<DeterministicKey>(needed);
  long now=System.currentTimeMillis();
  log.info(""String_Node_Str"",needed,parent.getPathAsString());
  int nextChild=numChildren;
  for (int i=0; i < needed; i++) {
    DeterministicKey key=HDKeyDerivation.deriveThisOrNextChildKey(parent,nextChild);
    key=key.getPubOnly();
    hierarchy.putKey(key);
    result.add(key);
    nextChild=key.getChildNumber().num() + 1;
  }
  log.info(""String_Node_Str"",System.currentTimeMillis() - now);
  return result;
}","/** 
 * Pre-generate enough keys to reach the lookahead size, but only if there are more than the lookaheadThreshold to be generated, so that the Bloom filter does not have to be regenerated that often. The returned mutable list of keys must be inserted into the basic key chain.
 */
private List<DeterministicKey> maybeLookAhead(DeterministicKey parent,int issued){
  checkState(lock.isHeldByCurrentThread());
  final int numChildren=hierarchy.getNumChildren(parent.getPath());
  final int lookaheadSize=getLookaheadSize();
  final int lookaheadThreshold=getLookaheadThreshold();
  final int needed=issued + lookaheadSize + lookaheadThreshold - numChildren;
  if (needed <= lookaheadThreshold)   return new ArrayList<DeterministicKey>();
  log.info(""String_Node_Str"",needed,parent.getPathAsString(),issued,lookaheadSize,lookaheadThreshold,numChildren);
  List<DeterministicKey> result=new ArrayList<DeterministicKey>(needed);
  long now=System.currentTimeMillis();
  int nextChild=numChildren;
  for (int i=0; i < needed; i++) {
    DeterministicKey key=HDKeyDerivation.deriveThisOrNextChildKey(parent,nextChild);
    key=key.getPubOnly();
    hierarchy.putKey(key);
    result.add(key);
    nextChild=key.getChildNumber().num() + 1;
  }
  log.info(""String_Node_Str"",System.currentTimeMillis() - now);
  return result;
}",0.9029850746268656
85690,"@Override public BloomFilter getFilter(int size,double falsePositiveRate,long tweak){
  checkArgument(size >= numBloomFilterEntries());
  return basicKeyChain.getFilter(size,falsePositiveRate,tweak);
}","@Override public BloomFilter getFilter(int size,double falsePositiveRate,long tweak){
  lock.lock();
  try {
    checkArgument(size >= numBloomFilterEntries());
    maybeLookAhead();
    return basicKeyChain.getFilter(size,falsePositiveRate,tweak);
  }
  finally {
    lock.unlock();
  }
}",0.8204081632653061
85691,"@Test public void testBloomResendOnNewKey() throws Exception {
  wallet.setKeychainLookaheadSize(20);
  peerGroup.startAsync();
  peerGroup.awaitRunning();
  InboundMessageQueuer p1=connectPeer(1);
  InboundMessageQueuer p2=connectPeer(2);
  peerGroup.waitForJobQueue();
  BloomFilter f1=p1.lastReceivedFilter;
  int threshold=wallet.getKeychainLookaheadThreshold();
  wallet.freshReceiveKey();
  peerGroup.waitForJobQueue();
  assertEquals(BloomFilter.class,outbound(p1).getClass());
  assertEquals(MemoryPoolMessage.class,outbound(p1).getClass());
  ECKey key=null;
  for (int i=0; i < threshold + 2; i++) {
    key=wallet.freshReceiveKey();
  }
  peerGroup.waitForJobQueue();
  BloomFilter f3=(BloomFilter)outbound(p1);
  assertNotNull(f3);
  assertEquals(MemoryPoolMessage.class,outbound(p1).getClass());
  assertNull(outbound(p1));
  assertNotEquals(f1,f3);
  assertTrue(f3.contains(key.getPubKey()));
  assertTrue(f3.contains(key.getPubKeyHash()));
  assertFalse(f1.contains(key.getPubKey()));
  assertFalse(f1.contains(key.getPubKeyHash()));
}","@Test public void testBloomResendOnNewKey() throws Exception {
  wallet.setKeychainLookaheadSize(5);
  wallet.setKeychainLookaheadThreshold(4);
  peerGroup.startAsync();
  peerGroup.awaitRunning();
  InboundMessageQueuer p1=connectPeer(1);
  InboundMessageQueuer p2=connectPeer(2);
  peerGroup.waitForJobQueue();
  BloomFilter f1=p1.lastReceivedFilter;
  ECKey key=null;
  for (int i=0; i < wallet.getKeychainLookaheadSize() + wallet.getKeychainLookaheadThreshold() + 1; i++) {
    key=wallet.freshReceiveKey();
  }
  peerGroup.waitForJobQueue();
  BloomFilter bf, f2=null;
  while ((bf=(BloomFilter)outbound(p1)) != null) {
    assertEquals(MemoryPoolMessage.class,outbound(p1).getClass());
    f2=bf;
  }
  assertNotNull(key);
  assertNotNull(f2);
  assertNull(outbound(p1));
  assertNotEquals(f1,f2);
  assertTrue(f2.contains(key.getPubKey()));
  assertTrue(f2.contains(key.getPubKeyHash()));
  assertFalse(f1.contains(key.getPubKey()));
  assertFalse(f1.contains(key.getPubKeyHash()));
}",0.4595786379225869
85692,"@Test public void freshAddress() throws Exception {
  group=createMarriedKeyChainGroup();
  Address a1=group.freshAddress(KeyChain.KeyPurpose.RECEIVE_FUNDS);
  Address a2=group.freshAddress(KeyChain.KeyPurpose.RECEIVE_FUNDS);
  assertTrue(a1.isP2SHAddress());
  assertNotEquals(a1,a2);
  assertEquals(INITIAL_KEYS + 1 + group.getLookaheadSize()+ group.getLookaheadThreshold(),group.numKeys());
  Address a3=group.currentAddress(KeyChain.KeyPurpose.RECEIVE_FUNDS);
  assertEquals(a2,a3);
}","@Test public void freshAddress() throws Exception {
  group=createMarriedKeyChainGroup();
  Address a1=group.freshAddress(KeyChain.KeyPurpose.RECEIVE_FUNDS);
  Address a2=group.freshAddress(KeyChain.KeyPurpose.RECEIVE_FUNDS);
  assertTrue(a1.isP2SHAddress());
  assertNotEquals(a1,a2);
  assertEquals(((group.getLookaheadSize() + group.getLookaheadThreshold()) * 2) + 2 + 3,group.numKeys());
  Address a3=group.currentAddress(KeyChain.KeyPurpose.RECEIVE_FUNDS);
  assertEquals(a2,a3);
}",0.864476386036961
85693,"@Test public void currentP2SHAddress() throws Exception {
  group=createMarriedKeyChainGroup();
  assertEquals(INITIAL_KEYS,group.numKeys());
  Address a1=group.currentAddress(KeyChain.KeyPurpose.RECEIVE_FUNDS);
  assertEquals(INITIAL_KEYS + 1 + LOOKAHEAD_SIZE+ group.getLookaheadThreshold(),group.numKeys());
  assertTrue(a1.isP2SHAddress());
  Address a2=group.currentAddress(KeyChain.KeyPurpose.RECEIVE_FUNDS);
  assertEquals(a1,a2);
  assertEquals(INITIAL_KEYS + 1 + LOOKAHEAD_SIZE+ group.getLookaheadThreshold(),group.numKeys());
  Address a3=group.currentAddress(KeyChain.KeyPurpose.CHANGE);
  assertNotEquals(a2,a3);
}","@Test public void currentP2SHAddress() throws Exception {
  group=createMarriedKeyChainGroup();
  Address a1=group.currentAddress(KeyChain.KeyPurpose.RECEIVE_FUNDS);
  assertTrue(a1.isP2SHAddress());
  Address a2=group.currentAddress(KeyChain.KeyPurpose.RECEIVE_FUNDS);
  assertEquals(a1,a2);
  Address a3=group.currentAddress(KeyChain.KeyPurpose.CHANGE);
  assertNotEquals(a2,a3);
}",0.7599206349206349
85694,"@Test public void bloom() throws Exception {
  assertEquals(INITIAL_KEYS * 2,group.getBloomFilterElementCount());
  ECKey key1=group.freshKey(KeyChain.KeyPurpose.RECEIVE_FUNDS);
  ECKey key2=new ECKey();
  final int size=(INITIAL_KEYS + LOOKAHEAD_SIZE + group.getLookaheadThreshold()+ 1) * 2;
  assertEquals(size,group.getBloomFilterElementCount());
  BloomFilter filter=group.getBloomFilter(size,0.001,(long)(Math.random() * Long.MAX_VALUE));
  assertTrue(filter.contains(key1.getPubKeyHash()));
  assertTrue(filter.contains(key1.getPubKey()));
  assertFalse(filter.contains(key2.getPubKey()));
  for (int i=0; i < LOOKAHEAD_SIZE + group.getLookaheadThreshold(); i++) {
    ECKey k=group.freshKey(KeyChain.KeyPurpose.RECEIVE_FUNDS);
    assertTrue(filter.contains(k.getPubKeyHash()));
  }
  assertFalse(filter.contains(group.freshKey(KeyChain.KeyPurpose.RECEIVE_FUNDS).getPubKey()));
  group.importKeys(key2);
  filter=group.getBloomFilter(group.getBloomFilterElementCount(),0.001,(long)(Math.random() * Long.MAX_VALUE));
  assertTrue(filter.contains(key1.getPubKeyHash()));
  assertTrue(filter.contains(key1.getPubKey()));
  assertTrue(filter.contains(key2.getPubKey()));
}","@Test public void bloom() throws Exception {
  ECKey key1=group.freshKey(KeyChain.KeyPurpose.RECEIVE_FUNDS);
  ECKey key2=new ECKey();
  BloomFilter filter=group.getBloomFilter(group.getBloomFilterElementCount(),0.001,(long)(Math.random() * Long.MAX_VALUE));
  assertTrue(filter.contains(key1.getPubKeyHash()));
  assertTrue(filter.contains(key1.getPubKey()));
  assertFalse(filter.contains(key2.getPubKey()));
  for (int i=0; i < LOOKAHEAD_SIZE + group.getLookaheadThreshold(); i++) {
    ECKey k=group.freshKey(KeyChain.KeyPurpose.RECEIVE_FUNDS);
    assertTrue(filter.contains(k.getPubKeyHash()));
  }
  assertFalse(filter.contains(group.freshKey(KeyChain.KeyPurpose.RECEIVE_FUNDS).getPubKey()));
  group.importKeys(key2);
  filter=group.getBloomFilter(group.getBloomFilterElementCount(),0.001,(long)(Math.random() * Long.MAX_VALUE));
  assertTrue(filter.contains(key1.getPubKeyHash()));
  assertTrue(filter.contains(key1.getPubKey()));
  assertTrue(filter.contains(key2.getPubKey()));
}",0.8757505773672055
85695,"@Test public void imports() throws Exception {
  ECKey key1=new ECKey();
  assertFalse(group.removeImportedKey(key1));
  assertEquals(1,group.importKeys(ImmutableList.of(key1)));
  assertEquals(INITIAL_KEYS + 1,group.numKeys());
  group.removeImportedKey(key1);
  assertEquals(INITIAL_KEYS,group.numKeys());
}","@Test public void imports() throws Exception {
  ECKey key1=new ECKey();
  int numKeys=group.numKeys();
  assertFalse(group.removeImportedKey(key1));
  assertEquals(1,group.importKeys(ImmutableList.of(key1)));
  assertEquals(numKeys + 1,group.numKeys());
  group.removeImportedKey(key1);
  assertEquals(numKeys,group.numKeys());
}",0.672926447574335
85696,"@Test public void freshCurrentKeys() throws Exception {
  assertEquals(INITIAL_KEYS,group.numKeys());
  assertEquals(2 * INITIAL_KEYS,group.getBloomFilterElementCount());
  ECKey r1=group.currentKey(KeyChain.KeyPurpose.RECEIVE_FUNDS);
  final int keys=INITIAL_KEYS + LOOKAHEAD_SIZE + group.getLookaheadThreshold()+ 1;
  assertEquals(keys,group.numKeys());
  assertEquals(2 * keys,group.getBloomFilterElementCount());
  ECKey i1=new ECKey();
  group.importKeys(i1);
  assertEquals(keys + 1,group.numKeys());
  assertEquals(2 * (keys + 1),group.getBloomFilterElementCount());
  ECKey r2=group.currentKey(KeyChain.KeyPurpose.RECEIVE_FUNDS);
  assertEquals(r1,r2);
  ECKey c1=group.currentKey(KeyChain.KeyPurpose.CHANGE);
  assertNotEquals(r1,c1);
  ECKey r3=group.freshKey(KeyChain.KeyPurpose.RECEIVE_FUNDS);
  assertNotEquals(r1,r3);
  ECKey c2=group.freshKey(KeyChain.KeyPurpose.CHANGE);
  assertNotEquals(r3,c2);
  ECKey r4=group.currentKey(KeyChain.KeyPurpose.RECEIVE_FUNDS);
  assertEquals(r2,r4);
  ECKey c3=group.currentKey(KeyChain.KeyPurpose.CHANGE);
  assertEquals(c1,c3);
  group.markPubKeyAsUsed(r4.getPubKey());
  ECKey r5=group.currentKey(KeyChain.KeyPurpose.RECEIVE_FUNDS);
  assertNotEquals(r4,r5);
}","@Test public void freshCurrentKeys() throws Exception {
  int numKeys=((group.getLookaheadSize() + group.getLookaheadThreshold()) * 2) + 1 + 3;
  assertEquals(numKeys,group.numKeys());
  assertEquals(2 * numKeys,group.getBloomFilterElementCount());
  ECKey r1=group.currentKey(KeyChain.KeyPurpose.RECEIVE_FUNDS);
  assertEquals(numKeys,group.numKeys());
  assertEquals(2 * numKeys,group.getBloomFilterElementCount());
  ECKey i1=new ECKey();
  group.importKeys(i1);
  numKeys++;
  assertEquals(numKeys,group.numKeys());
  assertEquals(2 * numKeys,group.getBloomFilterElementCount());
  ECKey r2=group.currentKey(KeyChain.KeyPurpose.RECEIVE_FUNDS);
  assertEquals(r1,r2);
  ECKey c1=group.currentKey(KeyChain.KeyPurpose.CHANGE);
  assertNotEquals(r1,c1);
  ECKey r3=group.freshKey(KeyChain.KeyPurpose.RECEIVE_FUNDS);
  assertNotEquals(r1,r3);
  ECKey c2=group.freshKey(KeyChain.KeyPurpose.CHANGE);
  assertNotEquals(r3,c2);
  ECKey r4=group.currentKey(KeyChain.KeyPurpose.RECEIVE_FUNDS);
  assertEquals(r2,r4);
  ECKey c3=group.currentKey(KeyChain.KeyPurpose.CHANGE);
  assertEquals(c1,c3);
  group.markPubKeyAsUsed(r4.getPubKey());
  ECKey r5=group.currentKey(KeyChain.KeyPurpose.RECEIVE_FUNDS);
  assertNotEquals(r4,r5);
}",0.8916256157635468
85697,"@Test public void encryptionWhilstEmpty() throws Exception {
  group=new KeyChainGroup(params);
  group.setLookaheadSize(5);
  KeyCrypterScrypt scrypt=new KeyCrypterScrypt(2);
  final KeyParameter aesKey=scrypt.deriveKey(""String_Node_Str"");
  group.encrypt(scrypt,aesKey);
  assertEquals(4,group.numKeys());
  assertTrue(group.freshKey(KeyChain.KeyPurpose.RECEIVE_FUNDS).isEncrypted());
  final ECKey key=group.currentKey(KeyChain.KeyPurpose.RECEIVE_FUNDS);
  group.decrypt(aesKey);
  assertFalse(checkNotNull(group.findKeyFromPubKey(key.getPubKey())).isEncrypted());
}","@Test public void encryptionWhilstEmpty() throws Exception {
  group=new KeyChainGroup(params);
  group.setLookaheadSize(5);
  KeyCrypterScrypt scrypt=new KeyCrypterScrypt(2);
  final KeyParameter aesKey=scrypt.deriveKey(""String_Node_Str"");
  group.encrypt(scrypt,aesKey);
  assertTrue(group.freshKey(KeyChain.KeyPurpose.RECEIVE_FUNDS).isEncrypted());
  final ECKey key=group.currentKey(KeyChain.KeyPurpose.RECEIVE_FUNDS);
  group.decrypt(aesKey);
  assertFalse(checkNotNull(group.findKeyFromPubKey(key.getPubKey())).isEncrypted());
}",0.9682683590208522
85698,"public int getOptimalEncodingMessageSize(){
  if (optimalEncodingMessageSize != 0)   return optimalEncodingMessageSize;
  maybeParseTransactions();
  if (optimalEncodingMessageSize != 0)   return optimalEncodingMessageSize;
  optimalEncodingMessageSize=getMessageSize();
  return optimalEncodingMessageSize;
}","public int getOptimalEncodingMessageSize(){
  if (optimalEncodingMessageSize != 0)   return optimalEncodingMessageSize;
  maybeParseTransactions();
  if (optimalEncodingMessageSize != 0)   return optimalEncodingMessageSize;
  optimalEncodingMessageSize=bitcoinSerialize().length;
  return optimalEncodingMessageSize;
}",0.934609250398724
85699,"private KeyChainGroup(NetworkParameters params,@Nullable BasicKeyChain basicKeyChain,List<DeterministicKeyChain> chains,@Nullable EnumMap<KeyChain.KeyPurpose,DeterministicKey> currentKeys,Multimap<DeterministicKey,DeterministicKeyChain> followingKeychains,@Nullable KeyCrypter crypter){
  this.params=params;
  this.basic=basicKeyChain == null ? new BasicKeyChain() : basicKeyChain;
  this.chains=new ArrayList<DeterministicKeyChain>(checkNotNull(chains));
  this.keyCrypter=crypter;
  this.currentKeys=currentKeys == null ? new EnumMap<KeyChain.KeyPurpose,DeterministicKey>(KeyChain.KeyPurpose.class) : currentKeys;
  this.currentAddresses=new EnumMap<KeyChain.KeyPurpose,Address>(KeyChain.KeyPurpose.class);
  this.followingKeychains=HashMultimap.create();
  if (followingKeychains != null) {
    this.followingKeychains.putAll(followingKeychains);
  }
  marriedKeysScripts=new LinkedHashMap<ByteString,Script>();
  maybeLookaheadScripts();
  if (!this.currentKeys.isEmpty()) {
    DeterministicKey followedWatchKey=getActiveKeyChain().getWatchingKey();
    for (    Map.Entry<KeyChain.KeyPurpose,DeterministicKey> entry : this.currentKeys.entrySet()) {
      Address address=makeP2SHOutputScript(entry.getValue(),followedWatchKey).getToAddress(params);
      currentAddresses.put(entry.getKey(),address);
    }
  }
}","private KeyChainGroup(NetworkParameters params,@Nullable BasicKeyChain basicKeyChain,List<DeterministicKeyChain> chains,@Nullable EnumMap<KeyChain.KeyPurpose,DeterministicKey> currentKeys,Multimap<DeterministicKey,DeterministicKeyChain> followingKeychains,@Nullable KeyCrypter crypter){
  this.params=params;
  this.basic=basicKeyChain == null ? new BasicKeyChain() : basicKeyChain;
  this.chains=new ArrayList<DeterministicKeyChain>(checkNotNull(chains));
  this.keyCrypter=crypter;
  this.currentKeys=currentKeys == null ? new EnumMap<KeyChain.KeyPurpose,DeterministicKey>(KeyChain.KeyPurpose.class) : currentKeys;
  this.currentAddresses=new EnumMap<KeyChain.KeyPurpose,Address>(KeyChain.KeyPurpose.class);
  this.followingKeychains=HashMultimap.create();
  if (followingKeychains != null) {
    this.followingKeychains.putAll(followingKeychains);
  }
  marriedKeysScripts=new LinkedHashMap<ByteString,Script>();
  maybeLookaheadScripts();
  if (!this.followingKeychains.isEmpty()) {
    DeterministicKey followedWatchKey=getActiveKeyChain().getWatchingKey();
    for (    Map.Entry<KeyChain.KeyPurpose,DeterministicKey> entry : this.currentKeys.entrySet()) {
      Address address=makeP2SHOutputScript(entry.getValue(),followedWatchKey).getToAddress(params);
      currentAddresses.put(entry.getKey(),address);
    }
  }
}",0.9897920604914934
85700,"public void setPasswordClicked(ActionEvent event){
  if (!pass1.getText().equals(pass2.getText())) {
    informationalAlert(""String_Node_Str"",""String_Node_Str"");
    return;
  }
  String password=pass1.getText();
  if (password.length() < 4) {
    informationalAlert(""String_Node_Str"",""String_Node_Str"");
    return;
  }
  fadeIn(progressMeter);
  fadeIn(padlockImage);
  fadeOut(widgetGrid);
  fadeOut(explanationLabel);
  fadeOut(closeButton);
  IdealPasswordParameters params=new IdealPasswordParameters(password);
  KeyCrypterScrypt scrypt=new KeyCrypterScrypt(params.realIterations);
  WalletPasswordController.setTargetTime(params.realTargetTime);
  KeyDerivationTasks tasks=new KeyDerivationTasks(scrypt,password,params.realTargetTime){
    @Override protected void onFinish(    KeyParameter aesKey){
      Main.bitcoin.wallet().encrypt(scrypt,aesKey);
      fadeIn(explanationLabel);
      fadeIn(widgetGrid);
      fadeIn(closeButton);
      fadeOut(progressMeter);
      fadeOut(padlockImage);
    }
  }
;
  progressMeter.progressProperty().bind(tasks.progress);
  tasks.start();
}","public void setPasswordClicked(ActionEvent event){
  if (!pass1.getText().equals(pass2.getText())) {
    informationalAlert(""String_Node_Str"",""String_Node_Str"");
    return;
  }
  String password=pass1.getText();
  if (password.length() < 4) {
    informationalAlert(""String_Node_Str"",""String_Node_Str"");
    return;
  }
  fadeIn(progressMeter);
  fadeIn(padlockImage);
  fadeOut(widgetGrid);
  fadeOut(explanationLabel);
  fadeOut(closeButton);
  IdealPasswordParameters params=new IdealPasswordParameters(password);
  KeyCrypterScrypt scrypt=new KeyCrypterScrypt(params.realIterations);
  WalletPasswordController.setTargetTime(params.realTargetTime);
  KeyDerivationTasks tasks=new KeyDerivationTasks(scrypt,password,params.realTargetTime){
    @Override protected void onFinish(    KeyParameter aesKey){
      Main.bitcoin.wallet().encrypt(scrypt,aesKey);
      informationalAlert(""String_Node_Str"",""String_Node_Str"");
      overlayUI.done();
    }
  }
;
  progressMeter.progressProperty().bind(tasks.progress);
  tasks.start();
}",0.819764705882353
85701,"@Override protected void onFinish(KeyParameter aesKey){
  Main.bitcoin.wallet().encrypt(scrypt,aesKey);
  fadeIn(explanationLabel);
  fadeIn(widgetGrid);
  fadeIn(closeButton);
  fadeOut(progressMeter);
  fadeOut(padlockImage);
}","@Override protected void onFinish(KeyParameter aesKey){
  Main.bitcoin.wallet().encrypt(scrypt,aesKey);
  informationalAlert(""String_Node_Str"",""String_Node_Str"");
  overlayUI.done();
}",0.6246973365617433
85702,"public void passwordButtonClicked(ActionEvent event){
  if (aesKey == null) {
    Main.instance.overlayUI(""String_Node_Str"");
  }
 else {
    Main.bitcoin.wallet().decrypt(aesKey);
    informationalAlert(""String_Node_Str"",""String_Node_Str"");
    passwordButton.setText(""String_Node_Str"");
  }
}","public void passwordButtonClicked(ActionEvent event){
  if (aesKey == null) {
    Main.instance.overlayUI(""String_Node_Str"");
  }
 else {
    Main.bitcoin.wallet().decrypt(aesKey);
    informationalAlert(""String_Node_Str"",""String_Node_Str"");
    passwordButton.setText(""String_Node_Str"");
    aesKey=null;
  }
}",0.971900826446281
85703,"public static void initCheckpoints(Map<Integer,Sha256Hash> checkpoints){
  checkpoints.put(1500,new Sha256Hash(""String_Node_Str""));
  checkpoints.put(4991,new Sha256Hash(""String_Node_Str""));
  checkpoints.put(9918,new Sha256Hash(""String_Node_Str""));
  checkpoints.put(16912,new Sha256Hash(""String_Node_Str""));
  checkpoints.put(23912,new Sha256Hash(""String_Node_Str""));
  checkpoints.put(35457,new Sha256Hash(""String_Node_Str""));
  checkpoints.put(45479,new Sha256Hash(""String_Node_Str""));
  checkpoints.put(55895,new Sha256Hash(""String_Node_Str""));
  checkpoints.put(68899,new Sha256Hash(""String_Node_Str""));
  checkpoints.put(74619,new Sha256Hash(""String_Node_Str""));
  checkpoints.put(75095,new Sha256Hash(""String_Node_Str""));
  checkpoints.put(88805,new Sha256Hash(""String_Node_Str""));
}","public static void initCheckpoints(Map<Integer,Sha256Hash> checkpoints){
  checkpoints.put(1500,new Sha256Hash(""String_Node_Str""));
  checkpoints.put(4991,new Sha256Hash(""String_Node_Str""));
  checkpoints.put(9918,new Sha256Hash(""String_Node_Str""));
  checkpoints.put(16912,new Sha256Hash(""String_Node_Str""));
  checkpoints.put(23912,new Sha256Hash(""String_Node_Str""));
  checkpoints.put(35457,new Sha256Hash(""String_Node_Str""));
  checkpoints.put(45479,new Sha256Hash(""String_Node_Str""));
  checkpoints.put(55895,new Sha256Hash(""String_Node_Str""));
  checkpoints.put(68899,new Sha256Hash(""String_Node_Str""));
  checkpoints.put(74619,new Sha256Hash(""String_Node_Str""));
  checkpoints.put(75095,new Sha256Hash(""String_Node_Str""));
  checkpoints.put(88805,new Sha256Hash(""String_Node_Str""));
  checkpoints.put(90544,new Sha256Hash(""String_Node_Str""));
}",0.9634591961023142
85704,"@Override void parse() throws ProtocolException {
  long numHeaders=readVarInt();
  if (numHeaders > MAX_HEADERS)   throw new ProtocolException(""String_Node_Str"" + numHeaders + ""String_Node_Str""+ MAX_HEADERS);
  blockHeaders=new ArrayList<Block>();
  for (int i=0; i < numHeaders; ++i) {
    byte[] blockHeader=readBytes(81);
    if (blockHeader[80] != 0)     throw new ProtocolException(""String_Node_Str"");
    Block newBlockHeader=new Block(this.params,blockHeader,true,true,81);
    if (newBlockHeader.shouldHaveMasterNodeVotes()) {
      byte[] mnv=readBytes(1);
      if (mnv[0] != 0)       throw new ProtocolException(""String_Node_Str"");
    }
    blockHeaders.add(newBlockHeader);
  }
  if (log.isDebugEnabled()) {
    for (int i=0; i < numHeaders; ++i) {
      log.debug(this.blockHeaders.get(i).toString());
    }
  }
}","@Override void parse() throws ProtocolException {
  long numHeaders=readVarInt();
  if (numHeaders > MAX_HEADERS)   throw new ProtocolException(""String_Node_Str"" + numHeaders + ""String_Node_Str""+ MAX_HEADERS);
  blockHeaders=new ArrayList<Block>();
  for (int i=0; i < numHeaders; ++i) {
    byte[] blockHeader=readBytes(81);
    if (blockHeader[80] != 0)     throw new ProtocolException(""String_Node_Str"");
    Block newBlockHeader=new Block(this.params,blockHeader,true,true,81);
    blockHeaders.add(newBlockHeader);
  }
  if (log.isDebugEnabled()) {
    for (int i=0; i < numHeaders; ++i) {
      log.debug(this.blockHeaders.get(i).toString());
    }
  }
}",0.8870967741935484
85705,"public byte[] encode(){
  if (isLessThanUnsigned(value,253)) {
    return new byte[]{(byte)value};
  }
 else   if (isLessThanUnsigned(value,65536)) {
    return new byte[]{(byte)253,(byte)(value),(byte)(value >> 8)};
  }
 else   if (isLessThanUnsigned(value,UnsignedInteger.MAX_VALUE.longValue())) {
    byte[] bytes=new byte[5];
    bytes[0]=(byte)254;
    Utils.uint32ToByteArrayLE(value,bytes,1);
    return bytes;
  }
 else {
    byte[] bytes=new byte[9];
    bytes[0]=(byte)255;
    Utils.uint32ToByteArrayLE(value,bytes,1);
    Utils.uint32ToByteArrayLE(value >>> 32,bytes,5);
    return bytes;
  }
}","public byte[] encode(){
  if (isLessThanUnsigned(value,253)) {
    return new byte[]{(byte)value};
  }
 else   if (isLessThanOrEqualToUnsigned(value,0xFFFFL)) {
    return new byte[]{(byte)253,(byte)(value),(byte)(value >> 8)};
  }
 else   if (isLessThanOrEqualToUnsigned(value,0xFFFFFFFFL)) {
    byte[] bytes=new byte[5];
    bytes[0]=(byte)254;
    Utils.uint32ToByteArrayLE(value,bytes,1);
    return bytes;
  }
 else {
    byte[] bytes=new byte[9];
    bytes[0]=(byte)255;
    Utils.uint32ToByteArrayLE(value,bytes,1);
    Utils.uint32ToByteArrayLE(value >>> 32,bytes,5);
    return bytes;
  }
}",0.87893864013267
85706,"/** 
 * Gets the minimum encoded size of the given value.
 */
public static int sizeOf(long value){
  if (isLessThanUnsigned(value,253))   return 1;
 else   if (isLessThanUnsigned(value,65536))   return 3;
 else   if (isLessThanUnsigned(value,UnsignedInteger.MAX_VALUE.longValue()))   return 5;
 else   return 9;
}","/** 
 * Gets the minimum encoded size of the given value.
 */
public static int sizeOf(long value){
  if (isLessThanUnsigned(value,253))   return 1;
 else   if (isLessThanOrEqualToUnsigned(value,0xFFFFL))   return 3;
 else   if (isLessThanOrEqualToUnsigned(value,0xFFFFFFFFL))   return 5;
 else   return 9;
}",0.8745980707395499
85707,"/** 
 * Given a spend request containing an incomplete transaction, makes it valid by adding outputs and signed inputs according to the instructions in the request. The transaction in the request is modified by this method, as is the fee parameter.
 * @param req a SendRequest that contains the incomplete transaction and details for how to make it valid.
 * @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
 * @throws IllegalArgumentException if you try and complete the same SendRequest twice
 * @throws DustySendRequested if the resultant transaction would violate the dust rules (an output that's too small to be worthwhile)
 * @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
 * @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process (try breaking up the amounts of value)
 */
public void completeTx(SendRequest req) throws InsufficientMoneyException {
  lock.lock();
  try {
    checkArgument(!req.completed,""String_Node_Str"");
    Coin value=Coin.ZERO;
    for (    TransactionOutput output : req.tx.getOutputs()) {
      value=value.add(output.getValue());
    }
    Coin totalOutput=value;
    log.info(""String_Node_Str"",req.tx.getOutputs().size(),value);
    Coin totalInput=Coin.ZERO;
    for (    TransactionInput input : req.tx.getInputs())     if (input.getConnectedOutput() != null)     totalInput=totalInput.add(input.getConnectedOutput().getValue());
 else     log.warn(""String_Node_Str"");
    value=value.subtract(totalInput);
    List<TransactionInput> originalInputs=new ArrayList<TransactionInput>(req.tx.getInputs());
    boolean needAtLeastReferenceFee=false;
    if (req.ensureMinRequiredFee && !req.emptyWallet) {
      for (      TransactionOutput output : req.tx.getOutputs())       if (output.getValue().compareTo(Coin.CENT) < 0) {
        if (output.getValue().compareTo(output.getMinNonDustValue()) < 0)         throw new DustySendRequested();
        needAtLeastReferenceFee=true;
        break;
      }
    }
    LinkedList<TransactionOutput> candidates=calculateAllSpendCandidates(true);
    CoinSelection bestCoinSelection;
    TransactionOutput bestChangeOutput=null;
    if (!req.emptyWallet) {
      FeeCalculation feeCalculation;
      feeCalculation=new FeeCalculation(req,value,originalInputs,needAtLeastReferenceFee,candidates);
      bestCoinSelection=feeCalculation.bestCoinSelection;
      bestChangeOutput=feeCalculation.bestChangeOutput;
    }
 else {
      checkState(req.tx.getOutputs().size() == 1,""String_Node_Str"");
      CoinSelector selector=req.coinSelector == null ? coinSelector : req.coinSelector;
      bestCoinSelection=selector.select(NetworkParameters.MAX_MONEY,candidates);
      candidates=null;
      req.tx.getOutput(0).setValue(bestCoinSelection.valueGathered);
      totalOutput=bestCoinSelection.valueGathered;
    }
    for (    TransactionOutput output : bestCoinSelection.gathered)     req.tx.addInput(output);
    if (req.ensureMinRequiredFee && req.emptyWallet) {
      final Coin baseFee=req.fee == null ? Coin.ZERO : req.fee;
      final Coin feePerKb=req.feePerKb == null ? Coin.ZERO : req.feePerKb;
      Transaction tx=req.tx;
      if (!adjustOutputDownwardsForFee(tx,bestCoinSelection,baseFee,feePerKb))       throw new CouldNotAdjustDownwards();
    }
    totalInput=totalInput.add(bestCoinSelection.valueGathered);
    if (bestChangeOutput != null) {
      req.tx.addOutput(bestChangeOutput);
      totalOutput=totalOutput.add(bestChangeOutput.getValue());
      log.info(""String_Node_Str"",bestChangeOutput.getValue().toFriendlyString());
    }
    final Coin calculatedFee=totalInput.subtract(totalOutput);
    if (calculatedFee.signum() > 0) {
      log.info(""String_Node_Str"",calculatedFee.toFriendlyString());
    }
    if (req.shuffleOutputs)     req.tx.shuffleOutputs();
    req.tx.signInputs(Transaction.SigHash.ALL,this,req.aesKey);
    int size=req.tx.bitcoinSerialize().length;
    if (size > Transaction.MAX_STANDARD_TX_SIZE)     throw new ExceededMaxTransactionSize();
    req.tx.getConfidence().setSource(TransactionConfidence.Source.SELF);
    req.tx.setPurpose(Transaction.Purpose.USER_PAYMENT);
    req.completed=true;
    req.fee=calculatedFee;
    log.info(""String_Node_Str"",req.tx);
  }
  finally {
    lock.unlock();
  }
}","/** 
 * Given a spend request containing an incomplete transaction, makes it valid by adding outputs and signed inputs according to the instructions in the request. The transaction in the request is modified by this method.
 * @param req a SendRequest that contains the incomplete transaction and details for how to make it valid.
 * @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
 * @throws IllegalArgumentException if you try and complete the same SendRequest twice
 * @throws DustySendRequested if the resultant transaction would violate the dust rules (an output that's too small to be worthwhile)
 * @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
 * @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process (try breaking up the amounts of value)
 */
public void completeTx(SendRequest req) throws InsufficientMoneyException {
  lock.lock();
  try {
    checkArgument(!req.completed,""String_Node_Str"");
    Coin value=Coin.ZERO;
    for (    TransactionOutput output : req.tx.getOutputs()) {
      value=value.add(output.getValue());
    }
    Coin totalOutput=value;
    log.info(""String_Node_Str"",req.tx.getOutputs().size(),value);
    Coin totalInput=Coin.ZERO;
    for (    TransactionInput input : req.tx.getInputs())     if (input.getConnectedOutput() != null)     totalInput=totalInput.add(input.getConnectedOutput().getValue());
 else     log.warn(""String_Node_Str"");
    value=value.subtract(totalInput);
    List<TransactionInput> originalInputs=new ArrayList<TransactionInput>(req.tx.getInputs());
    boolean needAtLeastReferenceFee=false;
    if (req.ensureMinRequiredFee && !req.emptyWallet) {
      for (      TransactionOutput output : req.tx.getOutputs())       if (output.getValue().compareTo(Coin.CENT) < 0) {
        if (output.getValue().compareTo(output.getMinNonDustValue()) < 0)         throw new DustySendRequested();
        needAtLeastReferenceFee=true;
        break;
      }
    }
    LinkedList<TransactionOutput> candidates=calculateAllSpendCandidates(true);
    CoinSelection bestCoinSelection;
    TransactionOutput bestChangeOutput=null;
    if (!req.emptyWallet) {
      FeeCalculation feeCalculation;
      feeCalculation=new FeeCalculation(req,value,originalInputs,needAtLeastReferenceFee,candidates);
      bestCoinSelection=feeCalculation.bestCoinSelection;
      bestChangeOutput=feeCalculation.bestChangeOutput;
    }
 else {
      checkState(req.tx.getOutputs().size() == 1,""String_Node_Str"");
      CoinSelector selector=req.coinSelector == null ? coinSelector : req.coinSelector;
      bestCoinSelection=selector.select(NetworkParameters.MAX_MONEY,candidates);
      candidates=null;
      req.tx.getOutput(0).setValue(bestCoinSelection.valueGathered);
      totalOutput=bestCoinSelection.valueGathered;
    }
    for (    TransactionOutput output : bestCoinSelection.gathered)     req.tx.addInput(output);
    if (req.ensureMinRequiredFee && req.emptyWallet) {
      final Coin baseFee=req.fee == null ? Coin.ZERO : req.fee;
      final Coin feePerKb=req.feePerKb == null ? Coin.ZERO : req.feePerKb;
      Transaction tx=req.tx;
      if (!adjustOutputDownwardsForFee(tx,bestCoinSelection,baseFee,feePerKb))       throw new CouldNotAdjustDownwards();
    }
    totalInput=totalInput.add(bestCoinSelection.valueGathered);
    if (bestChangeOutput != null) {
      req.tx.addOutput(bestChangeOutput);
      totalOutput=totalOutput.add(bestChangeOutput.getValue());
      log.info(""String_Node_Str"",bestChangeOutput.getValue().toFriendlyString());
    }
    if (req.shuffleOutputs)     req.tx.shuffleOutputs();
    req.tx.signInputs(Transaction.SigHash.ALL,this,req.aesKey);
    int size=req.tx.bitcoinSerialize().length;
    if (size > Transaction.MAX_STANDARD_TX_SIZE)     throw new ExceededMaxTransactionSize();
    final Coin calculatedFee=req.tx.getFee();
    if (calculatedFee != null) {
      log.info(""String_Node_Str"",calculatedFee.toFriendlyString());
    }
    req.tx.getConfidence().setSource(TransactionConfidence.Source.SELF);
    req.tx.setPurpose(Transaction.Purpose.USER_PAYMENT);
    req.completed=true;
    req.fee=calculatedFee;
    log.info(""String_Node_Str"",req.tx);
  }
  finally {
    lock.unlock();
  }
}",0.959790408930402
85708,"/** 
 * Creates the initial multisig contract and incomplete refund transaction which can be requested at the appropriate time using   {@link PaymentChannelClientState#getIncompleteRefundTransaction} and{@link PaymentChannelClientState#getMultisigContract()}. The way the contract is crafted can be adjusted by overriding   {@link PaymentChannelClientState#editContractSendRequest(com.google.bitcoin.core.Wallet.SendRequest)}. By default unconfirmed coins are allowed to be used, as for micropayments the risk should be relatively low.
 * @throws ValueOutOfRangeException if the value being used is too small to be accepted by the network
 * @throws InsufficientMoneyException if the wallet doesn't contain enough balance to initiate
 */
public synchronized void initiate() throws ValueOutOfRangeException, InsufficientMoneyException {
  final NetworkParameters params=wallet.getParams();
  Transaction template=new Transaction(params);
  List<ECKey> keys=Lists.newArrayList(myKey,serverMultisigKey);
  TransactionOutput multisigOutput=template.addOutput(totalValue,ScriptBuilder.createMultiSigOutputScript(2,keys));
  if (multisigOutput.getMinNonDustValue().compareTo(totalValue) > 0)   throw new ValueOutOfRangeException(""String_Node_Str"");
  Wallet.SendRequest req=Wallet.SendRequest.forTx(template);
  req.coinSelector=AllowUnconfirmedCoinSelector.get();
  editContractSendRequest(req);
  req.shuffleOutputs=false;
  wallet.completeTx(req);
  Coin multisigFee=req.fee;
  multisigContract=req.tx;
  refundTx=new Transaction(params);
  refundTx.addInput(multisigOutput).setSequenceNumber(0);
  refundTx.setLockTime(expiryTime);
  if (totalValue.compareTo(Coin.CENT) < 0) {
    final Coin valueAfterFee=totalValue.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE);
    if (Transaction.MIN_NONDUST_OUTPUT.compareTo(valueAfterFee) > 0)     throw new ValueOutOfRangeException(""String_Node_Str"");
    refundTx.addOutput(valueAfterFee,myKey.toAddress(params));
    refundFees=multisigFee.add(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE);
  }
 else {
    refundTx.addOutput(totalValue,myKey.toAddress(params));
    refundFees=multisigFee;
  }
  refundTx.getConfidence().setSource(TransactionConfidence.Source.SELF);
  log.info(""String_Node_Str"",multisigContract.getHashAsString(),refundTx.getHashAsString());
  state=State.INITIATED;
}","/** 
 * Creates the initial multisig contract and incomplete refund transaction which can be requested at the appropriate time using   {@link PaymentChannelClientState#getIncompleteRefundTransaction} and{@link PaymentChannelClientState#getMultisigContract()}. The way the contract is crafted can be adjusted by overriding   {@link PaymentChannelClientState#editContractSendRequest(com.google.bitcoin.core.Wallet.SendRequest)}. By default unconfirmed coins are allowed to be used, as for micropayments the risk should be relatively low.
 * @throws ValueOutOfRangeException if the value being used is too small to be accepted by the network
 * @throws InsufficientMoneyException if the wallet doesn't contain enough balance to initiate
 */
public synchronized void initiate() throws ValueOutOfRangeException, InsufficientMoneyException {
  final NetworkParameters params=wallet.getParams();
  Transaction template=new Transaction(params);
  List<ECKey> keys=Lists.newArrayList(myKey,serverMultisigKey);
  TransactionOutput multisigOutput=template.addOutput(totalValue,ScriptBuilder.createMultiSigOutputScript(2,keys));
  if (multisigOutput.getMinNonDustValue().compareTo(totalValue) > 0)   throw new ValueOutOfRangeException(""String_Node_Str"");
  Wallet.SendRequest req=Wallet.SendRequest.forTx(template);
  req.coinSelector=AllowUnconfirmedCoinSelector.get();
  editContractSendRequest(req);
  req.shuffleOutputs=false;
  wallet.completeTx(req);
  Coin multisigFee=req.tx.getFee();
  multisigContract=req.tx;
  refundTx=new Transaction(params);
  refundTx.addInput(multisigOutput).setSequenceNumber(0);
  refundTx.setLockTime(expiryTime);
  if (totalValue.compareTo(Coin.CENT) < 0) {
    final Coin valueAfterFee=totalValue.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE);
    if (Transaction.MIN_NONDUST_OUTPUT.compareTo(valueAfterFee) > 0)     throw new ValueOutOfRangeException(""String_Node_Str"");
    refundTx.addOutput(valueAfterFee,myKey.toAddress(params));
    refundFees=multisigFee.add(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE);
  }
 else {
    refundTx.addOutput(totalValue,myKey.toAddress(params));
    refundFees=multisigFee;
  }
  refundTx.getConfidence().setSource(TransactionConfidence.Source.SELF);
  log.info(""String_Node_Str"",multisigContract.getHashAsString(),refundTx.getHashAsString());
  state=State.INITIATED;
}",0.9969982847341338
85709,"/** 
 * <p>Closes this channel and broadcasts the highest value payment transaction on the network.</p> <p>This will set the state to   {@link State#CLOSED} if the transaction is successfully broadcast on the network.If we fail to broadcast for some reason, the state is set to  {@link State#ERROR}.</p> <p>If the current state is before   {@link State#READY} (ie we have not finished initializing the channel), wesimply set the state to  {@link State#CLOSED} and let the client handle getting its refund transaction confirmed.</p>
 * @return a future which completes when the provided multisig contract successfully broadcasts, or throws if thebroadcast fails for some reason. Note that if the network simply rejects the transaction, this future will never complete, a timeout should be used.
 * @throws InsufficientMoneyException If the payment tx would have cost more in fees to spend than it is worth.
 */
public synchronized ListenableFuture<Transaction> close() throws InsufficientMoneyException {
  if (storedServerChannel != null) {
    StoredServerChannel temp=storedServerChannel;
    storedServerChannel=null;
    StoredPaymentChannelServerStates channels=(StoredPaymentChannelServerStates)wallet.getExtensions().get(StoredPaymentChannelServerStates.EXTENSION_ID);
    channels.closeChannel(temp);
    if (state.compareTo(State.CLOSING) >= 0)     return closedFuture;
  }
  if (state.ordinal() < State.READY.ordinal()) {
    log.error(""String_Node_Str"" + state);
    state=State.CLOSED;
    closedFuture.set(null);
    return closedFuture;
  }
  if (state != State.READY) {
    log.warn(""String_Node_Str"" + state);
    return closedFuture;
  }
  Transaction tx=null;
  try {
    Wallet.SendRequest req=makeUnsignedChannelContract(bestValueToMe);
    tx=req.tx;
    signMultisigInput(tx,Transaction.SigHash.NONE,true);
    req.shuffleOutputs=false;
    wallet.completeTx(req);
    feePaidForPayment=req.fee;
    log.info(""String_Node_Str"",feePaidForPayment);
    if (feePaidForPayment.compareTo(bestValueToMe) >= 0) {
      final String msg=String.format(""String_Node_Str"",feePaidForPayment,bestValueToMe);
      throw new InsufficientMoneyException(feePaidForPayment.subtract(bestValueToMe),msg);
    }
    signMultisigInput(tx,Transaction.SigHash.ALL,false);
    tx.verify();
    for (    TransactionInput input : tx.getInputs())     input.verify();
  }
 catch (  InsufficientMoneyException e) {
    throw e;
  }
catch (  Exception e) {
    log.error(""String_Node_Str"",multisigContract,tx != null ? tx : ""String_Node_Str"");
    throw new RuntimeException(e);
  }
  state=State.CLOSING;
  log.info(""String_Node_Str"",tx);
  ListenableFuture<Transaction> future=broadcaster.broadcastTransaction(tx);
  Futures.addCallback(future,new FutureCallback<Transaction>(){
    @Override public void onSuccess(    Transaction transaction){
      log.info(""String_Node_Str"",transaction.getHash());
      state=State.CLOSED;
      closedFuture.set(transaction);
    }
    @Override public void onFailure(    Throwable throwable){
      log.error(""String_Node_Str"",throwable.toString());
      throwable.printStackTrace();
      state=State.ERROR;
      closedFuture.setException(throwable);
    }
  }
);
  return closedFuture;
}","/** 
 * <p>Closes this channel and broadcasts the highest value payment transaction on the network.</p> <p>This will set the state to   {@link State#CLOSED} if the transaction is successfully broadcast on the network.If we fail to broadcast for some reason, the state is set to  {@link State#ERROR}.</p> <p>If the current state is before   {@link State#READY} (ie we have not finished initializing the channel), wesimply set the state to  {@link State#CLOSED} and let the client handle getting its refund transaction confirmed.</p>
 * @return a future which completes when the provided multisig contract successfully broadcasts, or throws if thebroadcast fails for some reason. Note that if the network simply rejects the transaction, this future will never complete, a timeout should be used.
 * @throws InsufficientMoneyException If the payment tx would have cost more in fees to spend than it is worth.
 */
public synchronized ListenableFuture<Transaction> close() throws InsufficientMoneyException {
  if (storedServerChannel != null) {
    StoredServerChannel temp=storedServerChannel;
    storedServerChannel=null;
    StoredPaymentChannelServerStates channels=(StoredPaymentChannelServerStates)wallet.getExtensions().get(StoredPaymentChannelServerStates.EXTENSION_ID);
    channels.closeChannel(temp);
    if (state.compareTo(State.CLOSING) >= 0)     return closedFuture;
  }
  if (state.ordinal() < State.READY.ordinal()) {
    log.error(""String_Node_Str"" + state);
    state=State.CLOSED;
    closedFuture.set(null);
    return closedFuture;
  }
  if (state != State.READY) {
    log.warn(""String_Node_Str"" + state);
    return closedFuture;
  }
  Transaction tx=null;
  try {
    Wallet.SendRequest req=makeUnsignedChannelContract(bestValueToMe);
    tx=req.tx;
    signMultisigInput(tx,Transaction.SigHash.NONE,true);
    req.shuffleOutputs=false;
    wallet.completeTx(req);
    feePaidForPayment=req.tx.getFee();
    log.info(""String_Node_Str"",feePaidForPayment);
    if (feePaidForPayment.compareTo(bestValueToMe) >= 0) {
      final String msg=String.format(""String_Node_Str"",feePaidForPayment,bestValueToMe);
      throw new InsufficientMoneyException(feePaidForPayment.subtract(bestValueToMe),msg);
    }
    signMultisigInput(tx,Transaction.SigHash.ALL,false);
    tx.verify();
    for (    TransactionInput input : tx.getInputs())     input.verify();
  }
 catch (  InsufficientMoneyException e) {
    throw e;
  }
catch (  Exception e) {
    log.error(""String_Node_Str"",multisigContract,tx != null ? tx : ""String_Node_Str"");
    throw new RuntimeException(e);
  }
  state=State.CLOSING;
  log.info(""String_Node_Str"",tx);
  ListenableFuture<Transaction> future=broadcaster.broadcastTransaction(tx);
  Futures.addCallback(future,new FutureCallback<Transaction>(){
    @Override public void onSuccess(    Transaction transaction){
      log.info(""String_Node_Str"",transaction.getHash());
      state=State.CLOSED;
      closedFuture.set(transaction);
    }
    @Override public void onFailure(    Throwable throwable){
      log.error(""String_Node_Str"",throwable.toString());
      throwable.printStackTrace();
      state=State.ERROR;
      closedFuture.setException(throwable);
    }
  }
);
  return closedFuture;
}",0.9978321461752864
85710,"/** 
 * See   {@link com.google.bitcoin.wallet.DeterministicKeyChain#setLookaheadThreshold(int)} for more info on this. 
 */
public int getKeychainLookaheadThreshold(){
  int threshold=0;
  lock.lock();
  try {
    threshold=keychain.getLookaheadThreshold();
  }
  finally {
    lock.unlock();
  }
  return threshold;
}","/** 
 * See   {@link com.google.bitcoin.wallet.DeterministicKeyChain#setLookaheadThreshold(int)} for more info on this. 
 */
public int getKeychainLookaheadThreshold(){
  lock.lock();
  try {
    return keychain.getLookaheadThreshold();
  }
  finally {
    lock.unlock();
  }
}",0.6342281879194631
85711,"/** 
 * Mark the DeterministicKey as used. Also correct the issued{Internal|External}Keys counter, because all lower children seem to be requested already. If the counter was updated, we also might want to update the lookahead keys.
 */
public DeterministicKey markKeyAsUsed(DeterministicKey k){
  int numchilds=k.getChildNumber().i() + 1;
  if (k.getParent() == internalKey) {
    if (issuedInternalKeys < numchilds) {
      issuedInternalKeys=numchilds;
      maybeLookAhead();
    }
  }
 else   if (k.getParent() == externalKey) {
    if (issuedExternalKeys < numchilds) {
      issuedExternalKeys=numchilds;
      maybeLookAhead();
    }
  }
  return k;
}","/** 
 * Mark the DeterministicKey as used. Also correct the issued{Internal|External}Keys counter, because all lower children seem to be requested already. If the counter was updated, we also might trigger lookahead.
 */
public DeterministicKey markKeyAsUsed(DeterministicKey k){
  int numChildren=k.getChildNumber().i() + 1;
  if (k.getParent() == internalKey) {
    if (issuedInternalKeys < numChildren) {
      issuedInternalKeys=numChildren;
      maybeLookAhead();
    }
  }
 else   if (k.getParent() == externalKey) {
    if (issuedExternalKeys < numChildren) {
      issuedExternalKeys=numChildren;
      maybeLookAhead();
    }
  }
  return k;
}",0.9085365853658536
85712,"/** 
 * Pre-generate enough keys to reach the lookahead size, but only if there are more than the lookaheadThreshold to be generated, so that the Bloom filter does not have to be regenerated that often. Returned keys must be inserted into the basic key chain.
 */
private List<DeterministicKey> maybeLookAhead(DeterministicKey parent,int issued){
  checkState(lock.isHeldByCurrentThread());
  final int numChildren=hierarchy.getNumChildren(parent.getPath());
  final int needed=issued + getLookaheadSize() - numChildren;
  log.info(""String_Node_Str"",parent.getPathAsString(),getLookaheadSize(),numChildren,issued,needed,getLookaheadThreshold());
  if (needed <= getLookaheadThreshold())   return Collections.emptyList();
  List<DeterministicKey> result=new ArrayList<DeterministicKey>(needed);
  long now=System.currentTimeMillis();
  log.info(""String_Node_Str"",needed,parent.getPathAsString());
  for (int i=0; i < needed; i++) {
    DeterministicKey key=HDKeyDerivation.deriveChildKey(parent,numChildren + i);
    key=key.getPubOnly();
    hierarchy.putKey(key);
    result.add(key);
  }
  log.info(""String_Node_Str"",System.currentTimeMillis() - now);
  return result;
}","/** 
 * Pre-generate enough keys to reach the lookahead size, but only if there are more than the lookaheadThreshold to be generated, so that the Bloom filter does not have to be regenerated that often. The return mutable list of keys must be inserted into the basic key chain.
 */
private List<DeterministicKey> maybeLookAhead(DeterministicKey parent,int issued){
  checkState(lock.isHeldByCurrentThread());
  final int numChildren=hierarchy.getNumChildren(parent.getPath());
  final int needed=issued + getLookaheadSize() - numChildren;
  log.info(""String_Node_Str"",parent.getPathAsString(),getLookaheadSize(),numChildren,issued,needed,getLookaheadThreshold());
  if (needed <= getLookaheadThreshold())   return new ArrayList<DeterministicKey>();
  List<DeterministicKey> result=new ArrayList<DeterministicKey>(needed);
  long now=System.currentTimeMillis();
  log.info(""String_Node_Str"",needed,parent.getPathAsString());
  for (int i=0; i < needed; i++) {
    DeterministicKey key=HDKeyDerivation.deriveChildKey(parent,numChildren + i);
    key=key.getPubOnly();
    hierarchy.putKey(key);
    result.add(key);
  }
  log.info(""String_Node_Str"",System.currentTimeMillis() - now);
  return result;
}",0.9679595278246206
85713,"/** 
 * Sets the threshold for the key pre-generation. If a key is used in a transaction, the keychain would pre-generate a new key, for every issued key, even if it is only one. If the blockchain is replayed, every key would trigger a regeneration of the bloom filter sent to the peers as a consequence. To prevent this, new keys are only generated, if more than the threshold value are needed.
 */
public void setLookaheadThreshold(int num){
  lock.lock();
  if (num >= lookaheadSize)   throw new IllegalArgumentException(""String_Node_Str"");
  try {
    this.lookaheadThreshold=num;
  }
  finally {
    lock.unlock();
  }
}","/** 
 * Sets the threshold for the key pre-generation. If a key is used in a transaction, the keychain would pre-generate a new key, for every issued key, even if it is only one. If the blockchain is replayed, every key would trigger a regeneration of the bloom filter sent to the peers as a consequence. To prevent this, new keys are only generated, if more than the threshold value are needed.
 */
public void setLookaheadThreshold(int num){
  lock.lock();
  try {
    if (num >= lookaheadSize)     throw new IllegalArgumentException(""String_Node_Str"");
    this.lookaheadThreshold=num;
  }
  finally {
    lock.unlock();
  }
}",0.9840510366826156
85714,"private void informListenersForNewBlock(final Block block,final NewBlockType newBlockType,@Nullable final List<Sha256Hash> filteredTxHashList,@Nullable final Map<Sha256Hash,Transaction> filteredTxn,final StoredBlock newStoredBlock) throws VerificationException {
  boolean first=true;
  Set<Transaction> falsePositives=Sets.newHashSet();
  if (filteredTxn != null)   falsePositives.addAll(filteredTxn.values());
  for (  final ListenerRegistration<BlockChainListener> registration : listeners) {
    if (registration.executor == Threading.SAME_THREAD) {
      informListenerForNewTransactions(block,newBlockType,filteredTxHashList,filteredTxn,newStoredBlock,first,registration.listener,falsePositives);
      if (newBlockType == NewBlockType.BEST_CHAIN)       registration.listener.notifyNewBestBlock(newStoredBlock);
    }
 else {
      final boolean notFirst=!first;
      registration.executor.execute(new Runnable(){
        @Override public void run(){
          try {
            Set<Transaction> ignoredFalsePositives=Sets.newHashSet();
            informListenerForNewTransactions(block,newBlockType,filteredTxHashList,filteredTxn,newStoredBlock,notFirst,registration.listener,ignoredFalsePositives);
            if (newBlockType == NewBlockType.BEST_CHAIN)             registration.listener.notifyNewBestBlock(newStoredBlock);
          }
 catch (          VerificationException e) {
            log.error(""String_Node_Str"",e);
          }
        }
      }
);
    }
    first=false;
  }
  trackFalsePositives(falsePositives.size());
}","private void informListenersForNewBlock(final Block block,final NewBlockType newBlockType,@Nullable final List<Sha256Hash> filteredTxHashList,@Nullable final Map<Sha256Hash,Transaction> filteredTxn,final StoredBlock newStoredBlock) throws VerificationException {
  boolean first=true;
  Set<Sha256Hash> falsePositives=Sets.newHashSet();
  if (filteredTxHashList != null)   falsePositives.addAll(filteredTxHashList);
  for (  final ListenerRegistration<BlockChainListener> registration : listeners) {
    if (registration.executor == Threading.SAME_THREAD) {
      informListenerForNewTransactions(block,newBlockType,filteredTxHashList,filteredTxn,newStoredBlock,first,registration.listener,falsePositives);
      if (newBlockType == NewBlockType.BEST_CHAIN)       registration.listener.notifyNewBestBlock(newStoredBlock);
    }
 else {
      final boolean notFirst=!first;
      registration.executor.execute(new Runnable(){
        @Override public void run(){
          try {
            Set<Sha256Hash> ignoredFalsePositives=Sets.newHashSet();
            informListenerForNewTransactions(block,newBlockType,filteredTxHashList,filteredTxn,newStoredBlock,notFirst,registration.listener,ignoredFalsePositives);
            if (newBlockType == NewBlockType.BEST_CHAIN)             registration.listener.notifyNewBestBlock(newStoredBlock);
          }
 catch (          VerificationException e) {
            log.error(""String_Node_Str"",e);
          }
        }
      }
);
    }
    first=false;
  }
  trackFalsePositives(falsePositives.size());
}",0.9776771271433192
85715,"private static void sendTransactionsToListener(StoredBlock block,NewBlockType blockType,BlockChainListener listener,int relativityOffset,List<Transaction> transactions,boolean clone,Set<Transaction> falsePositives) throws VerificationException {
  for (  Transaction tx : transactions) {
    try {
      if (listener.isTransactionRelevant(tx)) {
        falsePositives.remove(tx);
        if (clone)         tx=new Transaction(tx.params,tx.bitcoinSerialize());
        listener.receiveFromBlock(tx,block,blockType,relativityOffset++);
      }
    }
 catch (    ScriptException e) {
      log.warn(""String_Node_Str"" + e.toString());
    }
catch (    ProtocolException e) {
      throw new RuntimeException(e);
    }
  }
}","private static void sendTransactionsToListener(StoredBlock block,NewBlockType blockType,BlockChainListener listener,int relativityOffset,List<Transaction> transactions,boolean clone,Set<Sha256Hash> falsePositives) throws VerificationException {
  for (  Transaction tx : transactions) {
    try {
      if (listener.isTransactionRelevant(tx)) {
        falsePositives.remove(tx.getHash());
        if (clone)         tx=new Transaction(tx.params,tx.bitcoinSerialize());
        listener.receiveFromBlock(tx,block,blockType,relativityOffset++);
      }
    }
 catch (    ScriptException e) {
      log.warn(""String_Node_Str"" + e.toString());
    }
catch (    ProtocolException e) {
      throw new RuntimeException(e);
    }
  }
}",0.9786059351276742
85716,"private static void informListenerForNewTransactions(Block block,NewBlockType newBlockType,@Nullable List<Sha256Hash> filteredTxHashList,@Nullable Map<Sha256Hash,Transaction> filteredTxn,StoredBlock newStoredBlock,boolean first,BlockChainListener listener,Set<Transaction> falsePositives) throws VerificationException {
  if (block.transactions != null) {
    sendTransactionsToListener(newStoredBlock,newBlockType,listener,0,block.transactions,!first,falsePositives);
  }
 else   if (filteredTxHashList != null) {
    checkNotNull(filteredTxn);
    int relativityOffset=0;
    for (    Sha256Hash hash : filteredTxHashList) {
      Transaction tx=filteredTxn.get(hash);
      if (tx != null)       sendTransactionsToListener(newStoredBlock,newBlockType,listener,relativityOffset,Arrays.asList(tx),!first,falsePositives);
 else       listener.notifyTransactionIsInBlock(hash,newStoredBlock,newBlockType,relativityOffset);
      relativityOffset++;
    }
  }
}","private static void informListenerForNewTransactions(Block block,NewBlockType newBlockType,@Nullable List<Sha256Hash> filteredTxHashList,@Nullable Map<Sha256Hash,Transaction> filteredTxn,StoredBlock newStoredBlock,boolean first,BlockChainListener listener,Set<Sha256Hash> falsePositives) throws VerificationException {
  if (block.transactions != null) {
    sendTransactionsToListener(newStoredBlock,newBlockType,listener,0,block.transactions,!first,falsePositives);
  }
 else   if (filteredTxHashList != null) {
    checkNotNull(filteredTxn);
    int relativityOffset=0;
    for (    Sha256Hash hash : filteredTxHashList) {
      Transaction tx=filteredTxn.get(hash);
      if (tx != null) {
        sendTransactionsToListener(newStoredBlock,newBlockType,listener,relativityOffset,Arrays.asList(tx),!first,falsePositives);
      }
 else {
        if (listener.notifyTransactionIsInBlock(hash,newStoredBlock,newBlockType,relativityOffset)) {
          falsePositives.remove(hash);
        }
      }
      relativityOffset++;
    }
  }
}",0.6142284569138277
85717,"@Override public void notifyTransactionIsInBlock(Sha256Hash txHash,StoredBlock block,BlockChain.NewBlockType blockType,int relativityOffset) throws VerificationException {
}","@Override public boolean notifyTransactionIsInBlock(Sha256Hash txHash,StoredBlock block,BlockChain.NewBlockType blockType,int relativityOffset) throws VerificationException {
  return false;
}",0.9315068493150684
85718,"/** 
 * <p>Called by the   {@link BlockChain} when we receive a new {@link FilteredBlock} that contains the giventransaction hash in its merkle tree.</p> <p>A transaction may be received multiple times if is included into blocks in parallel chains. The blockType parameter describes whether the containing block is on the main/best chain or whether it's on a presently inactive side chain.</p> <p>The relativityOffset parameter in this case is an arbitrary (meaningless) number, that is useful only when compared to the relativity count of another transaction received inside the same block. It is used to establish an ordering of transactions relative to one another.</p>
 */
void notifyTransactionIsInBlock(Sha256Hash txHash,StoredBlock block,BlockChain.NewBlockType blockType,int relativityOffset) throws VerificationException ;","/** 
 * <p>Called by the   {@link BlockChain} when we receive a new {@link FilteredBlock} that contains the giventransaction hash in its merkle tree.</p> <p>A transaction may be received multiple times if is included into blocks in parallel chains. The blockType parameter describes whether the containing block is on the main/best chain or whether it's on a presently inactive side chain.</p> <p>The relativityOffset parameter in this case is an arbitrary (meaningless) number, that is useful only when compared to the relativity count of another transaction received inside the same block. It is used to establish an ordering of transactions relative to one another.</p> <p>This method should return false if the given tx hash isn't known about, e.g. because the the transaction was a Bloom false positive. If it was known about and stored, it should return true. The caller may need to know this to calculate the effective FP rate.</p>
 * @return whether the transaction is known about i.e. was considered relevant previously.
 */
boolean notifyTransactionIsInBlock(Sha256Hash txHash,StoredBlock block,BlockChain.NewBlockType blockType,int relativityOffset) throws VerificationException ;",0.8180019782393669
85719,"/** 
 * Called by the   {@link BlockChain} when we receive a new filtered block that contains a transactions previouslyreceived by a call to @{link receivePending}.<p> This is necessary for the internal book-keeping Wallet does. When a transaction is received that sends us coins it is added to a pool so we can use it later to create spends. When a transaction is received that consumes outputs they are marked as spent so they won't be used in future.<p> A transaction that spends our own coins can be received either because a spend we created was accepted by the network and thus made it into a block, or because our keys are being shared between multiple instances and some other node spent the coins instead. We still have to know about that to avoid accidentally trying to double spend.<p> A transaction may be received multiple times if is included into blocks in parallel chains. The blockType parameter describes whether the containing block is on the main/best chain or whether it's on a presently inactive side chain. We must still record these transactions and the blocks they appear in because a future block might change which chain is best causing a reorganize. A re-org can totally change our balance!
 */
public void notifyTransactionIsInBlock(Sha256Hash txHash,StoredBlock block,BlockChain.NewBlockType blockType,int relativityOffset) throws VerificationException {
  lock.lock();
  try {
    Transaction tx=transactions.get(txHash);
    if (tx == null) {
      tx=riskDropped.get(txHash);
      if (tx != null) {
        log.info(""String_Node_Str"",tx.getHash());
      }
 else {
        log.error(""String_Node_Str"",txHash);
        return;
      }
    }
    receive(tx,block,blockType,relativityOffset);
  }
  finally {
    lock.unlock();
  }
  if (blockType == AbstractBlockChain.NewBlockType.BEST_CHAIN) {
    maybeRotateKeys();
  }
}","/** 
 * Called by the   {@link BlockChain} when we receive a new filtered block that contains a transactions previouslyreceived by a call to @{link receivePending}.<p> This is necessary for the internal book-keeping Wallet does. When a transaction is received that sends us coins it is added to a pool so we can use it later to create spends. When a transaction is received that consumes outputs they are marked as spent so they won't be used in future.<p> A transaction that spends our own coins can be received either because a spend we created was accepted by the network and thus made it into a block, or because our keys are being shared between multiple instances and some other node spent the coins instead. We still have to know about that to avoid accidentally trying to double spend.<p> A transaction may be received multiple times if is included into blocks in parallel chains. The blockType parameter describes whether the containing block is on the main/best chain or whether it's on a presently inactive side chain. We must still record these transactions and the blocks they appear in because a future block might change which chain is best causing a reorganize. A re-org can totally change our balance!
 */
public boolean notifyTransactionIsInBlock(Sha256Hash txHash,StoredBlock block,BlockChain.NewBlockType blockType,int relativityOffset) throws VerificationException {
  lock.lock();
  try {
    Transaction tx=transactions.get(txHash);
    if (tx == null) {
      tx=riskDropped.get(txHash);
      if (tx != null) {
        log.info(""String_Node_Str"",tx.getHash());
      }
 else {
        return false;
      }
    }
    receive(tx,block,blockType,relativityOffset);
  }
  finally {
    lock.unlock();
  }
  if (blockType == AbstractBlockChain.NewBlockType.BEST_CHAIN) {
    maybeRotateKeys();
  }
  return true;
}",0.9758872934164184
85720,"@Override public native void notifyTransactionIsInBlock(Sha256Hash txHash,StoredBlock block,BlockChain.NewBlockType blockType,int relativityOffset) throws VerificationException ;","@Override public native boolean notifyTransactionIsInBlock(Sha256Hash txHash,StoredBlock block,BlockChain.NewBlockType blockType,int relativityOffset) throws VerificationException ;",0.9749303621169916
85721,"@Override protected void startUp() throws Exception {
  if (!directory.exists()) {
    if (!directory.mkdir()) {
      throw new IOException(""String_Node_Str"");
    }
  }
  try {
    File chainFile=new File(directory,filePrefix + ""String_Node_Str"");
    boolean chainFileExists=chainFile.exists();
    vWalletFile=new File(directory,filePrefix + ""String_Node_Str"");
    boolean shouldReplayWallet=vWalletFile.exists() && !chainFileExists;
    vStore=new SPVBlockStore(params,chainFile);
    if (!chainFileExists && checkpoints != null) {
      long time=Long.MAX_VALUE;
      if (vWalletFile.exists()) {
        FileInputStream stream=new FileInputStream(vWalletFile);
        final WalletProtobufSerializer serializer=new WalletProtobufSerializer();
        final Wallet wallet=serializer.readWallet(params,null,WalletProtobufSerializer.parseToProto(stream));
        time=wallet.getEarliestKeyCreationTime();
      }
      CheckpointManager.checkpoint(params,checkpoints,vStore,time);
    }
    vChain=new BlockChain(params,vStore);
    vPeerGroup=createPeerGroup();
    if (this.userAgent != null)     vPeerGroup.setUserAgent(userAgent,version);
    if (vWalletFile.exists()) {
      FileInputStream walletStream=new FileInputStream(vWalletFile);
      try {
        List<WalletExtension> extensions=provideWalletExtensions();
        vWallet=new Wallet(params);
        Protos.Wallet proto=WalletProtobufSerializer.parseToProto(walletStream);
        new WalletProtobufSerializer().readWallet(params,(WalletExtension[])extensions.toArray(),proto);
        if (shouldReplayWallet)         vWallet.clearTransactions(0);
      }
  finally {
        walletStream.close();
      }
    }
 else {
      vWallet=new Wallet(params);
      vWallet.freshReceiveKey();
      for (      WalletExtension e : provideWalletExtensions()) {
        vWallet.addExtension(e);
      }
      vWallet.saveToFile(vWalletFile);
    }
    if (useAutoSave)     vWallet.autosaveToFile(vWalletFile,200,TimeUnit.MILLISECONDS,null);
    if (peerAddresses != null) {
      for (      PeerAddress addr : peerAddresses)       vPeerGroup.addAddress(addr);
      peerAddresses=null;
    }
 else {
      vPeerGroup.addPeerDiscovery(new DnsDiscovery(params));
    }
    vChain.addWallet(vWallet);
    vPeerGroup.addWallet(vWallet);
    onSetupCompleted();
    if (blockingStartup) {
      vPeerGroup.startAsync();
      vPeerGroup.awaitRunning();
      installShutdownHook();
      final DownloadListener listener=new DownloadListener();
      vPeerGroup.startBlockChainDownload(listener);
      listener.await();
    }
 else {
      vPeerGroup.startAsync();
      vPeerGroup.addListener(new Service.Listener(){
        @Override public void running(){
          final PeerEventListener l=downloadListener == null ? new DownloadListener() : downloadListener;
          vPeerGroup.startBlockChainDownload(l);
        }
        @Override public void failed(        State from,        Throwable failure){
          throw new RuntimeException(failure);
        }
      }
,MoreExecutors.sameThreadExecutor());
    }
  }
 catch (  BlockStoreException e) {
    throw new IOException(e);
  }
}","@Override protected void startUp() throws Exception {
  if (!directory.exists()) {
    if (!directory.mkdir()) {
      throw new IOException(""String_Node_Str"");
    }
  }
  try {
    File chainFile=new File(directory,filePrefix + ""String_Node_Str"");
    boolean chainFileExists=chainFile.exists();
    vWalletFile=new File(directory,filePrefix + ""String_Node_Str"");
    boolean shouldReplayWallet=vWalletFile.exists() && !chainFileExists;
    vStore=new SPVBlockStore(params,chainFile);
    if (!chainFileExists && checkpoints != null) {
      long time=Long.MAX_VALUE;
      if (vWalletFile.exists()) {
        FileInputStream stream=new FileInputStream(vWalletFile);
        final WalletProtobufSerializer serializer=new WalletProtobufSerializer();
        final Wallet wallet=serializer.readWallet(params,null,WalletProtobufSerializer.parseToProto(stream));
        time=wallet.getEarliestKeyCreationTime();
      }
      CheckpointManager.checkpoint(params,checkpoints,vStore,time);
    }
    vChain=new BlockChain(params,vStore);
    vPeerGroup=createPeerGroup();
    if (this.userAgent != null)     vPeerGroup.setUserAgent(userAgent,version);
    if (vWalletFile.exists()) {
      FileInputStream walletStream=new FileInputStream(vWalletFile);
      try {
        List<WalletExtension> extensions=provideWalletExtensions();
        vWallet=new Wallet(params);
        WalletExtension[] extArray=extensions.toArray(new WalletExtension[extensions.size()]);
        Protos.Wallet proto=WalletProtobufSerializer.parseToProto(walletStream);
        new WalletProtobufSerializer().readWallet(params,extArray,proto);
        if (shouldReplayWallet)         vWallet.clearTransactions(0);
      }
  finally {
        walletStream.close();
      }
    }
 else {
      vWallet=new Wallet(params);
      vWallet.freshReceiveKey();
      for (      WalletExtension e : provideWalletExtensions()) {
        vWallet.addExtension(e);
      }
      vWallet.saveToFile(vWalletFile);
    }
    if (useAutoSave)     vWallet.autosaveToFile(vWalletFile,200,TimeUnit.MILLISECONDS,null);
    if (peerAddresses != null) {
      for (      PeerAddress addr : peerAddresses)       vPeerGroup.addAddress(addr);
      peerAddresses=null;
    }
 else {
      vPeerGroup.addPeerDiscovery(new DnsDiscovery(params));
    }
    vChain.addWallet(vWallet);
    vPeerGroup.addWallet(vWallet);
    onSetupCompleted();
    if (blockingStartup) {
      vPeerGroup.startAsync();
      vPeerGroup.awaitRunning();
      installShutdownHook();
      final DownloadListener listener=new DownloadListener();
      vPeerGroup.startBlockChainDownload(listener);
      listener.await();
    }
 else {
      vPeerGroup.startAsync();
      vPeerGroup.addListener(new Service.Listener(){
        @Override public void running(){
          final PeerEventListener l=downloadListener == null ? new DownloadListener() : downloadListener;
          vPeerGroup.startBlockChainDownload(l);
        }
        @Override public void failed(        State from,        Throwable failure){
          throw new RuntimeException(failure);
        }
      }
,MoreExecutors.sameThreadExecutor());
    }
  }
 catch (  BlockStoreException e) {
    throw new IOException(e);
  }
}",0.9798931825322024
85722,"public DeterministicKey derive(int child){
  return HDKeyDerivation.deriveChildKey(this,new ChildNumber(child,true));
}","/** 
 * Derives a child at the given index (note: not the ""i"" value).
 */
public DeterministicKey derive(int child){
  return HDKeyDerivation.deriveChildKey(this,new ChildNumber(child,true));
}",0.7628205128205128
85723,"@Override public DeterministicKeyChain toDecrypted(KeyParameter aesKey){
  checkState(getKeyCrypter() != null,""String_Node_Str"");
  checkState(seed.isEncrypted());
  DeterministicSeed decSeed=seed.decrypt(getKeyCrypter(),aesKey);
  DeterministicKeyChain chain=new DeterministicKeyChain(decSeed);
  chain.lookaheadSize=lookaheadSize;
  for (  ECKey eckey : basicKeyChain.getKeys()) {
    DeterministicKey key=(DeterministicKey)eckey;
    if (key.getPath().size() != 3)     continue;
    checkState(key.isEncrypted());
    DeterministicKey parent=chain.hierarchy.get(checkNotNull(key.getParent()).getPath(),false,false);
    key=new DeterministicKey(key.getPubOnly(),parent);
    chain.hierarchy.putKey(key);
    chain.basicKeyChain.importKey(key);
  }
  chain.issuedExternalKeys=issuedExternalKeys;
  chain.issuedInternalKeys=issuedInternalKeys;
  return chain;
}","@Override public DeterministicKeyChain toDecrypted(KeyParameter aesKey){
  checkState(getKeyCrypter() != null,""String_Node_Str"");
  checkState(seed.isEncrypted());
  DeterministicSeed decSeed=seed.decrypt(getKeyCrypter(),aesKey);
  DeterministicKeyChain chain=new DeterministicKeyChain(decSeed);
  if (!chain.getWatchingKey().getPubKeyPoint().equals(getWatchingKey().getPubKeyPoint()))   throw new KeyCrypterException(""String_Node_Str"");
  chain.lookaheadSize=lookaheadSize;
  for (  ECKey eckey : basicKeyChain.getKeys()) {
    DeterministicKey key=(DeterministicKey)eckey;
    if (key.getPath().size() != 3)     continue;
    checkState(key.isEncrypted());
    DeterministicKey parent=chain.hierarchy.get(checkNotNull(key.getParent()).getPath(),false,false);
    key=new DeterministicKey(key.getPubOnly(),parent);
    chain.hierarchy.putKey(key);
    chain.basicKeyChain.importKey(key);
  }
  chain.issuedExternalKeys=issuedExternalKeys;
  chain.issuedInternalKeys=issuedInternalKeys;
  return chain;
}",0.9239013933547696
85724,"@Test public void findKey() throws Exception {
  ECKey a=group.freshKey(KeyChain.KeyPurpose.RECEIVE_FUNDS);
  assertTrue(a instanceof DeterministicKey);
  ECKey b=group.freshKey(KeyChain.KeyPurpose.CHANGE);
  ECKey c=new ECKey();
  ECKey d=new ECKey();
  group.importKeys(c);
  assertTrue(group.hasKey(a));
  assertTrue(group.hasKey(b));
  assertTrue(group.hasKey(c));
  assertFalse(group.hasKey(d));
  ECKey result=group.findKeyFromPubKey(a.getPubKey());
  assertEquals(a,result);
  result=group.findKeyFromPubKey(b.getPubKey());
  assertEquals(b,result);
  result=group.findKeyFromPubHash(a.getPubKeyHash());
  assertEquals(a,result);
  result=group.findKeyFromPubHash(b.getPubKeyHash());
  assertEquals(b,result);
  result=group.findKeyFromPubKey(c.getPubKey());
  assertEquals(c,result);
  result=group.findKeyFromPubHash(c.getPubKeyHash());
  assertEquals(c,result);
  assertNull(group.findKeyFromPubKey(d.getPubKey()));
  assertNull(group.findKeyFromPubHash(d.getPubKeyHash()));
}","@Test public void findKey() throws Exception {
  ECKey a=group.freshKey(KeyChain.KeyPurpose.RECEIVE_FUNDS);
  ECKey b=group.freshKey(KeyChain.KeyPurpose.CHANGE);
  ECKey c=new ECKey();
  ECKey d=new ECKey();
  group.importKeys(c);
  assertTrue(group.hasKey(a));
  assertTrue(group.hasKey(b));
  assertTrue(group.hasKey(c));
  assertFalse(group.hasKey(d));
  ECKey result=group.findKeyFromPubKey(a.getPubKey());
  assertEquals(a,result);
  result=group.findKeyFromPubKey(b.getPubKey());
  assertEquals(b,result);
  result=group.findKeyFromPubHash(a.getPubKeyHash());
  assertEquals(a,result);
  result=group.findKeyFromPubHash(b.getPubKeyHash());
  assertEquals(b,result);
  result=group.findKeyFromPubKey(c.getPubKey());
  assertEquals(c,result);
  result=group.findKeyFromPubHash(c.getPubKeyHash());
  assertEquals(c,result);
  assertNull(group.findKeyFromPubKey(d.getPubKey()));
  assertNull(group.findKeyFromPubHash(d.getPubKeyHash()));
}",0.9766476388168136
85725,"/** 
 * Returns the same key with the private part removed. May return the same instance.
 */
public DeterministicKey getPubOnly(){
  if (isPubKeyOnly())   return this;
  final DeterministicKey parentPub=getParent() == null ? null : getParent().getPubOnly();
  return new DeterministicKey(getPath(),getChainCode(),getPubKeyPoint(),null,parentPub);
}","/** 
 * Returns the same key with the private part removed. May return the same instance.
 */
public DeterministicKey getPubOnly(){
  if (isPubKeyOnly())   return this;
  return new DeterministicKey(getPath(),getChainCode(),getPubKeyPoint(),null,parent);
}",0.8462809917355372
85726,"static ImmutableList<ChildNumber> append(ImmutableList<ChildNumber> path,ChildNumber childNumber){
  return ImmutableList.<ChildNumber>builder().addAll(path).add(childNumber).build();
}","public static ImmutableList<ChildNumber> append(ImmutableList<ChildNumber> path,ChildNumber childNumber){
  return ImmutableList.<ChildNumber>builder().addAll(path).add(childNumber).build();
}",0.9814323607427056
85727,"/** 
 * Returns a freshly derived key that has not been returned by this method before. 
 */
@Override public DeterministicKey getKey(KeyPurpose purpose){
  lock.lock();
  try {
    DeterministicKey key;
    List<DeterministicKey> lookahead;
    if (purpose == KeyPurpose.RECEIVE_FUNDS) {
      issuedExternalKeys++;
      lookahead=maybeLookAhead(externalKey,issuedExternalKeys);
      key=HDKeyDerivation.deriveChildKey(externalKey,issuedExternalKeys - 1);
    }
 else     if (purpose == KeyPurpose.CHANGE) {
      issuedInternalKeys++;
      lookahead=maybeLookAhead(internalKey,issuedInternalKeys);
      key=HDKeyDerivation.deriveChildKey(internalKey,issuedInternalKeys - 1);
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + purpose);
    }
    basicKeyChain.importKeys(lookahead);
    return key;
  }
  finally {
    lock.unlock();
  }
}","/** 
 * Returns a freshly derived key that has not been returned by this method before. 
 */
@Override public DeterministicKey getKey(KeyPurpose purpose){
  lock.lock();
  try {
    DeterministicKey key, parentKey;
    int index;
    if (purpose == KeyPurpose.RECEIVE_FUNDS) {
      index=++issuedExternalKeys;
      parentKey=externalKey;
    }
 else     if (purpose == KeyPurpose.CHANGE) {
      index=++issuedInternalKeys;
      parentKey=internalKey;
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + purpose);
    }
    List<DeterministicKey> lookahead=maybeLookAhead(parentKey,index);
    basicKeyChain.importKeys(lookahead);
    key=hierarchy.get(HDUtils.append(parentKey.getPath(),new ChildNumber(index - 1,false)),false,false);
    return key;
  }
  finally {
    lock.unlock();
  }
}",0.6603438055720213
85728,"private List<DeterministicKey> maybeLookAhead(DeterministicKey parent,int issued){
  checkState(lock.isHeldByCurrentThread());
  final int numChildren=hierarchy.getNumChildren(parent.getPath());
  int needed=issued + getLookaheadSize() - numChildren;
  checkState(needed >= 0,""String_Node_Str"" + needed);
  List<DeterministicKey> result=new ArrayList<DeterministicKey>(needed);
  if (needed == 0)   return result;
  long now=System.currentTimeMillis();
  log.info(""String_Node_Str"",needed,parent.getPathAsString());
  for (int i=0; i < needed; i++) {
    DeterministicKey key=HDKeyDerivation.deriveChildKey(parent,numChildren + i);
    hierarchy.putKey(key);
    result.add(key);
  }
  log.info(""String_Node_Str"",System.currentTimeMillis() - now);
  return result;
}","private List<DeterministicKey> maybeLookAhead(DeterministicKey parent,int issued){
  checkState(lock.isHeldByCurrentThread());
  final int numChildren=hierarchy.getNumChildren(parent.getPath());
  int needed=issued + getLookaheadSize() - numChildren;
  checkState(needed >= 0,""String_Node_Str"" + needed);
  List<DeterministicKey> result=new ArrayList<DeterministicKey>(needed);
  if (needed == 0)   return result;
  long now=System.currentTimeMillis();
  log.info(""String_Node_Str"",needed,parent.getPathAsString());
  for (int i=0; i < needed; i++) {
    DeterministicKey key=HDKeyDerivation.deriveChildKey(parent,numChildren + i);
    key=key.getPubOnly();
    hierarchy.putKey(key);
    result.add(key);
  }
  log.info(""String_Node_Str"",System.currentTimeMillis() - now);
  return result;
}",0.9833119383825416
85729,"@Override protected void startUp() throws Exception {
  if (!directory.exists()) {
    if (!directory.mkdir()) {
      throw new IOException(""String_Node_Str"");
    }
  }
  try {
    File chainFile=new File(directory,filePrefix + ""String_Node_Str"");
    boolean chainFileExists=chainFile.exists();
    vWalletFile=new File(directory,filePrefix + ""String_Node_Str"");
    boolean shouldReplayWallet=vWalletFile.exists() && !chainFileExists;
    vStore=new SPVBlockStore(params,chainFile);
    if (!chainFileExists && checkpoints != null) {
      long time=Long.MAX_VALUE;
      if (vWalletFile.exists()) {
        FileInputStream stream=new FileInputStream(vWalletFile);
        final WalletProtobufSerializer serializer=new WalletProtobufSerializer();
        final Wallet wallet=serializer.readWallet(params,null,WalletProtobufSerializer.parseToProto(stream));
        time=wallet.getEarliestKeyCreationTime();
      }
      CheckpointManager.checkpoint(params,checkpoints,vStore,time);
    }
    vChain=new BlockChain(params,vStore);
    vPeerGroup=createPeerGroup();
    if (this.userAgent != null)     vPeerGroup.setUserAgent(userAgent,version);
    if (vWalletFile.exists()) {
      FileInputStream walletStream=new FileInputStream(vWalletFile);
      try {
        List<WalletExtension> extensions=provideWalletExtensions();
        vWallet=new Wallet(params);
        WalletExtension[] extArray=extensions.toArray(new WalletExtension[extensions.size()]);
        Protos.Wallet proto=WalletProtobufSerializer.parseToProto(walletStream);
        new WalletProtobufSerializer().readWallet(params,extArray,proto);
        if (shouldReplayWallet)         vWallet.clearTransactions(0);
      }
  finally {
        walletStream.close();
      }
    }
 else {
      vWallet=new Wallet(params);
      vWallet.freshReceiveKey();
      for (      WalletExtension e : provideWalletExtensions()) {
        vWallet.addExtension(e);
      }
      vWallet.saveToFile(vWalletFile);
    }
    if (useAutoSave)     vWallet.autosaveToFile(vWalletFile,200,TimeUnit.MILLISECONDS,null);
    if (peerAddresses != null) {
      for (      PeerAddress addr : peerAddresses)       vPeerGroup.addAddress(addr);
      peerAddresses=null;
    }
 else {
      vPeerGroup.addPeerDiscovery(new DnsDiscovery(params));
    }
    vChain.addWallet(vWallet);
    vPeerGroup.addWallet(vWallet);
    onSetupCompleted();
    if (blockingStartup) {
      vPeerGroup.startAsync();
      vPeerGroup.awaitRunning();
      installShutdownHook();
      final DownloadListener listener=new DownloadListener();
      vPeerGroup.startBlockChainDownload(listener);
      listener.await();
    }
 else {
      vPeerGroup.startAsync();
      vPeerGroup.addListener(new Service.Listener(){
        @Override public void running(){
          final PeerEventListener l=downloadListener == null ? new DownloadListener() : downloadListener;
          vPeerGroup.startBlockChainDownload(l);
        }
        @Override public void failed(        State from,        Throwable failure){
          throw new RuntimeException(failure);
        }
      }
,MoreExecutors.sameThreadExecutor());
    }
  }
 catch (  BlockStoreException e) {
    throw new IOException(e);
  }
}","@Override protected void startUp() throws Exception {
  if (!directory.exists()) {
    if (!directory.mkdir()) {
      throw new IOException(""String_Node_Str"");
    }
  }
  try {
    File chainFile=new File(directory,filePrefix + ""String_Node_Str"");
    boolean chainFileExists=chainFile.exists();
    vWalletFile=new File(directory,filePrefix + ""String_Node_Str"");
    boolean shouldReplayWallet=vWalletFile.exists() && !chainFileExists;
    vStore=new SPVBlockStore(params,chainFile);
    if (!chainFileExists && checkpoints != null) {
      long time=Long.MAX_VALUE;
      if (vWalletFile.exists()) {
        FileInputStream stream=new FileInputStream(vWalletFile);
        final WalletProtobufSerializer serializer=new WalletProtobufSerializer();
        final Wallet wallet=serializer.readWallet(params,null,WalletProtobufSerializer.parseToProto(stream));
        time=wallet.getEarliestKeyCreationTime();
      }
      CheckpointManager.checkpoint(params,checkpoints,vStore,time);
    }
    vChain=new BlockChain(params,vStore);
    vPeerGroup=createPeerGroup();
    if (this.userAgent != null)     vPeerGroup.setUserAgent(userAgent,version);
    if (vWalletFile.exists()) {
      FileInputStream walletStream=new FileInputStream(vWalletFile);
      try {
        List<WalletExtension> extensions=provideWalletExtensions();
        vWallet=new Wallet(params);
        WalletExtension[] extArray=extensions.toArray(new WalletExtension[extensions.size()]);
        Protos.Wallet proto=WalletProtobufSerializer.parseToProto(walletStream);
        vWallet=new WalletProtobufSerializer().readWallet(params,extArray,proto);
        if (shouldReplayWallet)         vWallet.clearTransactions(0);
      }
  finally {
        walletStream.close();
      }
    }
 else {
      vWallet=new Wallet(params);
      vWallet.freshReceiveKey();
      for (      WalletExtension e : provideWalletExtensions()) {
        vWallet.addExtension(e);
      }
      vWallet.saveToFile(vWalletFile);
    }
    if (useAutoSave)     vWallet.autosaveToFile(vWalletFile,200,TimeUnit.MILLISECONDS,null);
    if (peerAddresses != null) {
      for (      PeerAddress addr : peerAddresses)       vPeerGroup.addAddress(addr);
      peerAddresses=null;
    }
 else {
      vPeerGroup.addPeerDiscovery(new DnsDiscovery(params));
    }
    vChain.addWallet(vWallet);
    vPeerGroup.addWallet(vWallet);
    onSetupCompleted();
    if (blockingStartup) {
      vPeerGroup.startAsync();
      vPeerGroup.awaitRunning();
      installShutdownHook();
      final DownloadListener listener=new DownloadListener();
      vPeerGroup.startBlockChainDownload(listener);
      listener.await();
    }
 else {
      vPeerGroup.startAsync();
      vPeerGroup.addListener(new Service.Listener(){
        @Override public void running(){
          final PeerEventListener l=downloadListener == null ? new DownloadListener() : downloadListener;
          vPeerGroup.startBlockChainDownload(l);
        }
        @Override public void failed(        State from,        Throwable failure){
          throw new RuntimeException(failure);
        }
      }
,MoreExecutors.sameThreadExecutor());
    }
  }
 catch (  BlockStoreException e) {
    throw new IOException(e);
  }
}",0.9987573780677228
85730,"private void createAndActivateNewHDChain(){
  final DeterministicKeyChain chain=new DeterministicKeyChain(new SecureRandom());
  if (lookaheadSize >= 0)   chain.setLookaheadSize(lookaheadSize);
  chains.add(chain);
}","private void createAndActivateNewHDChain(){
  final DeterministicKeyChain chain=new DeterministicKeyChain(new SecureRandom());
  for (  ListenerRegistration<KeyChainEventListener> registration : basic.getListeners())   chain.addEventListener(registration.listener,registration.executor);
  if (lookaheadSize >= 0)   chain.setLookaheadSize(lookaheadSize);
  chains.add(chain);
}",0.7284991568296796
85731,"@Override public long getEarliestKeyCreationTime(){
  return seed.getCreationTimeSeconds();
}","@Override public long getEarliestKeyCreationTime(){
  return seed != null ? seed.getCreationTimeSeconds() : Utils.currentTimeSeconds();
}",0.808695652173913
85732,"@Test public void watchingChain() throws UnreadableWalletException {
  DeterministicKey key1=chain.getKey(KeyChain.KeyPurpose.RECEIVE_FUNDS);
  DeterministicKey key2=chain.getKey(KeyChain.KeyPurpose.RECEIVE_FUNDS);
  DeterministicKey key3=chain.getKey(KeyChain.KeyPurpose.CHANGE);
  DeterministicKey key4=chain.getKey(KeyChain.KeyPurpose.CHANGE);
  DeterministicKey watchingKey=chain.getWatchingKey();
  final String pub58=watchingKey.serializePubB58();
  assertEquals(""String_Node_Str"",pub58);
  watchingKey=DeterministicKey.deserializeB58(null,pub58);
  chain=new DeterministicKeyChain(watchingKey);
  chain.setLookaheadSize(10);
  assertEquals(key1.getPubKeyPoint(),chain.getKey(KeyChain.KeyPurpose.RECEIVE_FUNDS).getPubKeyPoint());
  assertEquals(key2.getPubKeyPoint(),chain.getKey(KeyChain.KeyPurpose.RECEIVE_FUNDS).getPubKeyPoint());
  final DeterministicKey key=chain.getKey(KeyChain.KeyPurpose.CHANGE);
  assertEquals(key3.getPubKeyPoint(),key.getPubKeyPoint());
  try {
    key.sign(Sha256Hash.ZERO_HASH);
    fail();
  }
 catch (  ECKey.MissingPrivateKeyException e) {
  }
  List<Protos.Key> serialization=chain.serializeToProtobuf();
  checkSerialization(serialization,""String_Node_Str"");
  chain=DeterministicKeyChain.fromProtobuf(serialization,null).get(0);
  final DeterministicKey rekey4=chain.getKey(KeyChain.KeyPurpose.CHANGE);
  assertEquals(key4.getPubKeyPoint(),rekey4.getPubKeyPoint());
}","@Test public void watchingChain() throws UnreadableWalletException {
  Utils.setMockClock();
  DeterministicKey key1=chain.getKey(KeyChain.KeyPurpose.RECEIVE_FUNDS);
  DeterministicKey key2=chain.getKey(KeyChain.KeyPurpose.RECEIVE_FUNDS);
  DeterministicKey key3=chain.getKey(KeyChain.KeyPurpose.CHANGE);
  DeterministicKey key4=chain.getKey(KeyChain.KeyPurpose.CHANGE);
  DeterministicKey watchingKey=chain.getWatchingKey();
  final String pub58=watchingKey.serializePubB58();
  assertEquals(""String_Node_Str"",pub58);
  watchingKey=DeterministicKey.deserializeB58(null,pub58);
  chain=new DeterministicKeyChain(watchingKey);
  assertEquals(Utils.currentTimeSeconds(),chain.getEarliestKeyCreationTime());
  chain.setLookaheadSize(10);
  assertEquals(key1.getPubKeyPoint(),chain.getKey(KeyChain.KeyPurpose.RECEIVE_FUNDS).getPubKeyPoint());
  assertEquals(key2.getPubKeyPoint(),chain.getKey(KeyChain.KeyPurpose.RECEIVE_FUNDS).getPubKeyPoint());
  final DeterministicKey key=chain.getKey(KeyChain.KeyPurpose.CHANGE);
  assertEquals(key3.getPubKeyPoint(),key.getPubKeyPoint());
  try {
    key.sign(Sha256Hash.ZERO_HASH);
    fail();
  }
 catch (  ECKey.MissingPrivateKeyException e) {
  }
  List<Protos.Key> serialization=chain.serializeToProtobuf();
  checkSerialization(serialization,""String_Node_Str"");
  chain=DeterministicKeyChain.fromProtobuf(serialization,null).get(0);
  final DeterministicKey rekey4=chain.getKey(KeyChain.KeyPurpose.CHANGE);
  assertEquals(key4.getPubKeyPoint(),rekey4.getPubKeyPoint());
}",0.9647381033892504
85733,"@Test public void mnemonicCode() throws Exception {
  final List<String> words=chain.toMnemonicCode();
  assertEquals(""String_Node_Str"",Joiner.on(""String_Node_Str"").join(words));
  DeterministicSeed seed=new DeterministicSeed(words,checkNotNull(chain.getSeed()).getCreationTimeSeconds());
}","@Test public void mnemonicCode() throws Exception {
  final List<String> words=chain.toMnemonicCode();
  assertEquals(""String_Node_Str"",Joiner.on(""String_Node_Str"").join(words));
  new DeterministicSeed(words,checkNotNull(chain.getSeed()).getCreationTimeSeconds());
}",0.9443447037701976
85734,"/** 
 * @param iv
 * @param encryptedPrivateKeys
 */
public EncryptedPrivateKey(byte[] initialisationVector,byte[] encryptedPrivateKeys){
  setInitialisationVector(initialisationVector);
  setEncryptedPrivateBytes(encryptedPrivateKeys);
}","/** 
 * @param initialisationVector
 * @param encryptedPrivateKeys
 */
public EncryptedPrivateKey(byte[] initialisationVector,byte[] encryptedPrivateKeys){
  setInitialisationVector(initialisationVector);
  setEncryptedPrivateBytes(encryptedPrivateKeys);
}",0.9595141700404858
85735,"private Collection<InetSocketAddress> lookupAddresses(long timeoutValue,TimeUnit timeoutUnit,List<Circuit> circuits) throws InterruptedException {
  createThreadPool(circuits.size() * hostNames.length);
  try {
    List<ListenableFuture<Lookup>> lookupFutures=Lists.newArrayList();
    for (    final Circuit circuit : circuits) {
      for (      final String seed : hostNames) {
        lookupFutures.add(threadPool.submit(new Callable<Lookup>(){
          public Lookup call() throws Exception {
            return new Lookup(circuit.getFinalCircuitNode().getRouter(),lookup(circuit,seed));
          }
        }
));
      }
    }
    threadPool.awaitTermination(timeoutValue,timeoutUnit);
    for (    ListenableFuture<Lookup> future : lookupFutures) {
      if (!future.isDone()) {
        log.warn(""String_Node_Str"");
        future.cancel(true);
      }
    }
    try {
      List<Lookup> lookups=Futures.successfulAsList(lookupFutures).get();
      lookups.removeAll(Collections.singleton(null));
      Map<HexDigest,InetSocketAddress> lookupMap=Maps.newHashMap();
      for (      Lookup lookup : lookups) {
        InetSocketAddress address=new InetSocketAddress(lookup.address,netParams.getPort());
        lookupMap.put(lookup.router.getIdentityHash(),address);
      }
      return lookupMap.values();
    }
 catch (    ExecutionException e) {
      throw new RuntimeException(e);
    }
  }
  finally {
    shutdownThreadPool();
  }
}","private Collection<InetSocketAddress> lookupAddresses(long timeoutValue,TimeUnit timeoutUnit,List<Circuit> circuits) throws InterruptedException {
  createThreadPool(circuits.size() * hostNames.length);
  try {
    List<ListenableFuture<Lookup>> lookupFutures=Lists.newArrayList();
    for (    final Circuit circuit : circuits) {
      for (      final String seed : hostNames) {
        lookupFutures.add(threadPool.submit(new Callable<Lookup>(){
          public Lookup call() throws Exception {
            return new Lookup(circuit.getFinalCircuitNode().getRouter(),lookup(circuit,seed));
          }
        }
));
      }
    }
    threadPool.awaitTermination(timeoutValue,timeoutUnit);
    for (    ListenableFuture<Lookup> future : lookupFutures) {
      if (!future.isDone()) {
        log.warn(""String_Node_Str"");
        future.cancel(true);
      }
    }
    try {
      List<Lookup> lookups=new ArrayList<Lookup>(Futures.successfulAsList(lookupFutures).get());
      lookups.removeAll(singleton(null));
      Map<HexDigest,InetSocketAddress> lookupMap=Maps.newHashMap();
      for (      Lookup lookup : lookups) {
        InetSocketAddress address=new InetSocketAddress(lookup.address,netParams.getPort());
        lookupMap.put(lookup.router.getIdentityHash(),address);
      }
      return lookupMap.values();
    }
 catch (    ExecutionException e) {
      throw new RuntimeException(e);
    }
  }
  finally {
    shutdownThreadPool();
  }
}",0.9879518072289156
85736,"private List<Circuit> getCircuits(long timeoutValue,TimeUnit timeoutUnit,Set<Router> routers) throws InterruptedException {
  createThreadPool(routers.size());
  try {
    List<ListenableFuture<Circuit>> circuitFutures=Lists.newArrayList();
    for (    final Router router : routers) {
      circuitFutures.add(threadPool.submit(new Callable<Circuit>(){
        public Circuit call() throws Exception {
          return torClient.getCircuitManager().openInternalCircuitTo(Lists.newArrayList(router));
        }
      }
));
    }
    threadPool.awaitTermination(timeoutValue,timeoutUnit);
    for (    ListenableFuture<Circuit> future : circuitFutures) {
      if (!future.isDone()) {
        log.warn(""String_Node_Str"");
        future.cancel(true);
      }
    }
    List<Circuit> circuits;
    try {
      circuits=Futures.successfulAsList(circuitFutures).get();
      circuits.removeAll(Collections.singleton(null));
      return circuits;
    }
 catch (    ExecutionException e) {
      throw new RuntimeException(e);
    }
  }
  finally {
    shutdownThreadPool();
  }
}","private List<Circuit> getCircuits(long timeoutValue,TimeUnit timeoutUnit,Set<Router> routers) throws InterruptedException {
  createThreadPool(routers.size());
  try {
    List<ListenableFuture<Circuit>> circuitFutures=Lists.newArrayList();
    for (    final Router router : routers) {
      circuitFutures.add(threadPool.submit(new Callable<Circuit>(){
        public Circuit call() throws Exception {
          return torClient.getCircuitManager().openInternalCircuitTo(Lists.newArrayList(router));
        }
      }
));
    }
    threadPool.awaitTermination(timeoutValue,timeoutUnit);
    for (    ListenableFuture<Circuit> future : circuitFutures) {
      if (!future.isDone()) {
        log.warn(""String_Node_Str"");
        future.cancel(true);
      }
    }
    try {
      List<Circuit> circuits=new ArrayList<Circuit>(Futures.successfulAsList(circuitFutures).get());
      circuits.removeAll(singleton(null));
      return circuits;
    }
 catch (    ExecutionException e) {
      throw new RuntimeException(e);
    }
  }
  finally {
    shutdownThreadPool();
  }
}",0.9655813953488372
85737,"/** 
 * Create an encrypted private key with the keyCrypter and the AES key supplied. This method returns a new encrypted key and leaves the original unchanged. To be secure you need to clear the original, unencrypted private key bytes.
 * @param keyCrypter The keyCrypter that specifies exactly how the encrypted bytes are created.
 * @param aesKey The KeyParameter with the AES encryption key (usually constructed with keyCrypter#deriveKey and cached as it is slow to create).
 * @return encryptedKey
 */
public ECKey encrypt(KeyCrypter keyCrypter,KeyParameter aesKey) throws KeyCrypterException {
  Preconditions.checkNotNull(keyCrypter);
  final byte[] privKeyBytes=getPrivKeyBytes();
  checkState(privKeyBytes != null,""String_Node_Str"");
  EncryptedPrivateKey encryptedPrivateKey=keyCrypter.encrypt(privKeyBytes,aesKey);
  return new ECKey(encryptedPrivateKey,getPubKey(),keyCrypter);
}","/** 
 * Create an encrypted private key with the keyCrypter and the AES key supplied. This method returns a new encrypted key and leaves the original unchanged. To be secure you need to clear the original, unencrypted private key bytes.
 * @param keyCrypter The keyCrypter that specifies exactly how the encrypted bytes are created.
 * @param aesKey The KeyParameter with the AES encryption key (usually constructed with keyCrypter#deriveKey and cached as it is slow to create).
 * @return encryptedKey
 */
public ECKey encrypt(KeyCrypter keyCrypter,KeyParameter aesKey) throws KeyCrypterException {
  Preconditions.checkNotNull(keyCrypter);
  final byte[] privKeyBytes=getPrivKeyBytes();
  checkState(privKeyBytes != null,""String_Node_Str"");
  EncryptedPrivateKey encryptedPrivateKey=keyCrypter.encrypt(privKeyBytes,aesKey);
  ECKey result=new ECKey(encryptedPrivateKey,getPubKey(),keyCrypter);
  result.setCreationTimeSeconds(creationTimeSeconds);
  return result;
}",0.951048951048951
85738,"/** 
 * Create a decrypted private key with the keyCrypter and AES key supplied. Note that if the aesKey is wrong, this has some chance of throwing KeyCrypterException due to the corrupted padding that will result, but it can also just yield a garbage key.
 * @param keyCrypter The keyCrypter that specifies exactly how the decrypted bytes are created.
 * @param aesKey The KeyParameter with the AES encryption key (usually constructed with keyCrypter#deriveKey and cached).
 * @return unencryptedKey
 */
public ECKey decrypt(KeyCrypter keyCrypter,KeyParameter aesKey) throws KeyCrypterException {
  Preconditions.checkNotNull(keyCrypter);
  if (this.keyCrypter != null && !this.keyCrypter.equals(keyCrypter)) {
    throw new KeyCrypterException(""String_Node_Str"");
  }
  byte[] unencryptedPrivateKey=keyCrypter.decrypt(encryptedPrivateKey,aesKey);
  ECKey key=new ECKey(new BigInteger(1,unencryptedPrivateKey),null,isCompressed());
  if (!Arrays.equals(key.getPubKey(),getPubKey()))   throw new KeyCrypterException(""String_Node_Str"");
  return key;
}","/** 
 * Create a decrypted private key with the keyCrypter and AES key supplied. Note that if the aesKey is wrong, this has some chance of throwing KeyCrypterException due to the corrupted padding that will result, but it can also just yield a garbage key.
 * @param keyCrypter The keyCrypter that specifies exactly how the decrypted bytes are created.
 * @param aesKey The KeyParameter with the AES encryption key (usually constructed with keyCrypter#deriveKey and cached).
 * @return unencryptedKey
 */
public ECKey decrypt(KeyCrypter keyCrypter,KeyParameter aesKey) throws KeyCrypterException {
  Preconditions.checkNotNull(keyCrypter);
  if (this.keyCrypter != null && !this.keyCrypter.equals(keyCrypter)) {
    throw new KeyCrypterException(""String_Node_Str"");
  }
  byte[] unencryptedPrivateKey=keyCrypter.decrypt(encryptedPrivateKey,aesKey);
  ECKey key=new ECKey(new BigInteger(1,unencryptedPrivateKey),null,isCompressed());
  if (!Arrays.equals(key.getPubKey(),getPubKey()))   throw new KeyCrypterException(""String_Node_Str"");
  key.setCreationTimeSeconds(creationTimeSeconds);
  return key;
}",0.9670227589410124
85739,"@Test public void testEncryptedCreate() throws Exception {
  ECKey unencryptedKey=new ECKey();
  byte[] originalPrivateKeyBytes=new byte[32];
  System.arraycopy(unencryptedKey.getPrivKeyBytes(),0,originalPrivateKeyBytes,0,32);
  log.info(""String_Node_Str"" + Utils.bytesToHexString(originalPrivateKeyBytes));
  EncryptedPrivateKey encryptedPrivateKey=keyCrypter.encrypt(unencryptedKey.getPrivKeyBytes(),keyCrypter.deriveKey(PASSWORD1));
  ECKey encryptedKey=new ECKey(encryptedPrivateKey,unencryptedKey.getPubKey(),keyCrypter);
  assertTrue(""String_Node_Str"",encryptedKey.isEncrypted());
  byte[] privateKeyBytes=encryptedKey.getPrivKeyBytes();
  if (privateKeyBytes != null) {
    for (int i=0; i < privateKeyBytes.length; i++) {
      assertEquals(""String_Node_Str"" + i + ""String_Node_Str"",0,privateKeyBytes[i]);
    }
  }
  ECKey rebornUnencryptedKey=encryptedKey.decrypt(keyCrypter,keyCrypter.deriveKey(PASSWORD1));
  assertTrue(""String_Node_Str"",!rebornUnencryptedKey.isEncrypted());
  privateKeyBytes=rebornUnencryptedKey.getPrivKeyBytes();
  log.info(""String_Node_Str"" + Utils.bytesToHexString(privateKeyBytes));
  for (int i=0; i < privateKeyBytes.length; i++) {
    assertEquals(""String_Node_Str"" + i + ""String_Node_Str"",originalPrivateKeyBytes[i],privateKeyBytes[i]);
  }
}","@Test public void testEncryptedCreate() throws Exception {
  ECKey unencryptedKey=new ECKey();
  byte[] originalPrivateKeyBytes=checkNotNull(unencryptedKey.getPrivKeyBytes());
  log.info(""String_Node_Str"" + Utils.bytesToHexString(originalPrivateKeyBytes));
  EncryptedPrivateKey encryptedPrivateKey=keyCrypter.encrypt(unencryptedKey.getPrivKeyBytes(),keyCrypter.deriveKey(PASSWORD1));
  ECKey encryptedKey=new ECKey(encryptedPrivateKey,unencryptedKey.getPubKey(),keyCrypter);
  assertTrue(""String_Node_Str"",encryptedKey.isEncrypted());
  byte[] privateKeyBytes=encryptedKey.getPrivKeyBytes();
  if (privateKeyBytes != null) {
    for (int i=0; i < privateKeyBytes.length; i++) {
      assertEquals(""String_Node_Str"" + i + ""String_Node_Str"",0,privateKeyBytes[i]);
    }
  }
  ECKey rebornUnencryptedKey=encryptedKey.decrypt(keyCrypter,keyCrypter.deriveKey(PASSWORD1));
  assertTrue(!rebornUnencryptedKey.isEncrypted());
  assertArrayEquals(originalPrivateKeyBytes,rebornUnencryptedKey.getPrivKeyBytes());
}",0.7870572802798426
85740,"@Test public void testUnencryptedCreate() throws Exception {
  ECKey unencryptedKey=new ECKey();
  assertTrue(!unencryptedKey.isEncrypted());
  byte[] originalPrivateKeyBytes=new byte[32];
  System.arraycopy(unencryptedKey.getPrivKeyBytes(),0,originalPrivateKeyBytes,0,32);
  log.info(""String_Node_Str"" + Utils.bytesToHexString(originalPrivateKeyBytes));
  ECKey encryptedKey=unencryptedKey.encrypt(keyCrypter,keyCrypter.deriveKey(PASSWORD1));
  assertTrue(""String_Node_Str"",encryptedKey.isEncrypted());
  byte[] privateKeyBytes=encryptedKey.getPrivKeyBytes();
  if (privateKeyBytes != null) {
    for (int i=0; i < privateKeyBytes.length; i++) {
      assertEquals(""String_Node_Str"" + i + ""String_Node_Str"",0,privateKeyBytes[i]);
    }
  }
  unencryptedKey=encryptedKey.decrypt(keyCrypter,keyCrypter.deriveKey(PASSWORD1));
  assertTrue(""String_Node_Str"",!unencryptedKey.isEncrypted());
  privateKeyBytes=unencryptedKey.getPrivKeyBytes();
  log.info(""String_Node_Str"" + Utils.bytesToHexString(privateKeyBytes));
  for (int i=0; i < privateKeyBytes.length; i++) {
    assertEquals(""String_Node_Str"" + i + ""String_Node_Str"",originalPrivateKeyBytes[i],privateKeyBytes[i]);
  }
}","@Test public void testUnencryptedCreate() throws Exception {
  Utils.rollMockClock(0);
  ECKey key=new ECKey();
  long time=key.getCreationTimeSeconds();
  assertNotEquals(0,time);
  assertTrue(!key.isEncrypted());
  byte[] originalPrivateKeyBytes=key.getPrivKeyBytes();
  ECKey encryptedKey=key.encrypt(keyCrypter,keyCrypter.deriveKey(PASSWORD1));
  assertEquals(time,encryptedKey.getCreationTimeSeconds());
  assertTrue(encryptedKey.isEncrypted());
  assertNull(encryptedKey.getPrivKeyBytes());
  key=encryptedKey.decrypt(keyCrypter,keyCrypter.deriveKey(PASSWORD1));
  assertTrue(!key.isEncrypted());
  assertArrayEquals(originalPrivateKeyBytes,key.getPrivKeyBytes());
}",0.3779101245262588
85741,"/** 
 * Picks a peer from discovery and connects to it. If connection fails, picks another and tries again. 
 */
protected void connectToAnyPeer() throws PeerDiscoveryException {
  final State state=state();
  if (!(state == State.STARTING || state == State.RUNNING))   return;
  final PeerAddress addr;
  long nowMillis=Utils.currentTimeMillis();
  lock.lock();
  try {
    if (!haveReadyInactivePeer(nowMillis)) {
      discoverPeers();
      groupBackoff.trackSuccess();
      nowMillis=Utils.currentTimeMillis();
    }
    if (inactives.size() == 0) {
      log.debug(""String_Node_Str"");
      return;
    }
    addr=inactives.poll();
  }
  finally {
    lock.unlock();
  }
  long retryTime=Math.max(backoffMap.get(addr).getRetryTime(),groupBackoff.getRetryTime());
  if (retryTime > nowMillis) {
    Utils.sleep(retryTime - nowMillis);
  }
  connectTo(addr,false);
}","/** 
 * Picks a peer from discovery and connects to it. If connection fails, picks another and tries again. 
 */
protected void connectToAnyPeer() throws PeerDiscoveryException {
  final State state=state();
  if (!(state == State.STARTING || state == State.RUNNING))   return;
  PeerAddress addr=null;
  long nowMillis=Utils.currentTimeMillis();
  long retryTime=0;
  lock.lock();
  try {
    if (!haveReadyInactivePeer(nowMillis)) {
      discoverPeers();
      groupBackoff.trackSuccess();
      nowMillis=Utils.currentTimeMillis();
    }
    if (inactives.size() == 0) {
      log.debug(""String_Node_Str"");
      return;
    }
    addr=inactives.poll();
    retryTime=backoffMap.get(addr).getRetryTime();
  }
  finally {
    retryTime=Math.max(retryTime,groupBackoff.getRetryTime());
    lock.unlock();
    if (retryTime > nowMillis) {
      final long millis=retryTime - nowMillis;
      log.info(""String_Node_Str"",millis,addr == null ? ""String_Node_Str"" : ""String_Node_Str"" + addr);
      Utils.sleep(millis);
    }
  }
  checkNotNull(addr);
  connectTo(addr,false);
}",0.8113110539845758
85742,"protected void discoverPeers() throws PeerDiscoveryException {
  long start=System.currentTimeMillis();
  Set<PeerAddress> addressSet=Sets.newHashSet();
  for (  PeerDiscovery peerDiscovery : peerDiscoverers) {
    InetSocketAddress[] addresses;
    addresses=peerDiscovery.getPeers(5,TimeUnit.SECONDS);
    for (    InetSocketAddress address : addresses)     addressSet.add(new PeerAddress(address));
    if (addressSet.size() > 0)     break;
  }
  lock.lock();
  try {
    for (    PeerAddress address : addressSet) {
      addInactive(address);
    }
  }
  finally {
    lock.unlock();
  }
  log.info(""String_Node_Str"",System.currentTimeMillis() - start,addressSet.size());
}","protected void discoverPeers() throws PeerDiscoveryException {
  if (peerDiscoverers.isEmpty())   throw new PeerDiscoveryException(""String_Node_Str"");
  long start=System.currentTimeMillis();
  Set<PeerAddress> addressSet=Sets.newHashSet();
  for (  PeerDiscovery peerDiscovery : peerDiscoverers) {
    InetSocketAddress[] addresses;
    addresses=peerDiscovery.getPeers(5,TimeUnit.SECONDS);
    for (    InetSocketAddress address : addresses)     addressSet.add(new PeerAddress(address));
    if (addressSet.size() > 0)     break;
  }
  lock.lock();
  try {
    for (    PeerAddress address : addressSet) {
      addInactive(address);
    }
  }
  finally {
    lock.unlock();
  }
  log.info(""String_Node_Str"",System.currentTimeMillis() - start,addressSet.size());
}",0.9390581717451524
85743,"Ack(String memo){
  this.memo=memo;
}","Ack(@Nullable String memo){
  this.memo=memo;
}",0.8809523809523809
85744,"@Override public Ack call() throws Exception {
  HttpURLConnection connection=(HttpURLConnection)url.openConnection();
  connection.setRequestMethod(""String_Node_Str"");
  connection.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
  connection.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
  connection.setRequestProperty(""String_Node_Str"",Integer.toString(payment.getSerializedSize()));
  connection.setUseCaches(false);
  connection.setDoInput(true);
  connection.setDoOutput(true);
  DataOutputStream outStream=new DataOutputStream(connection.getOutputStream());
  payment.writeTo(outStream);
  outStream.flush();
  outStream.close();
  InputStream inStream=connection.getInputStream();
  Protos.PaymentACK.Builder paymentAckBuilder=Protos.PaymentACK.newBuilder().mergeFrom(inStream);
  Protos.PaymentACK paymentAck=paymentAckBuilder.build();
  String memo=""String_Node_Str"";
  if (paymentAck.hasMemo())   memo=paymentAck.getMemo();
  return new Ack(memo);
}","@Override public Ack call() throws Exception {
  HttpURLConnection connection=(HttpURLConnection)url.openConnection();
  connection.setRequestMethod(""String_Node_Str"");
  connection.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
  connection.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
  connection.setRequestProperty(""String_Node_Str"",Integer.toString(payment.getSerializedSize()));
  connection.setUseCaches(false);
  connection.setDoInput(true);
  connection.setDoOutput(true);
  DataOutputStream outStream=new DataOutputStream(connection.getOutputStream());
  payment.writeTo(outStream);
  outStream.flush();
  outStream.close();
  InputStream inStream=connection.getInputStream();
  Protos.PaymentACK.Builder paymentAckBuilder=Protos.PaymentACK.newBuilder().mergeFrom(inStream);
  Protos.PaymentACK paymentAck=paymentAckBuilder.build();
  String memo=null;
  if (paymentAck.hasMemo())   memo=paymentAck.getMemo();
  return new Ack(memo);
}",0.9892141756548536
85745,"/** 
 * Returns the memo included by the merchant in the payment request.
 */
public String getMemo(){
  return paymentDetails.getMemo();
}","/** 
 * Returns the memo included by the merchant in the payment request, or null if not found.
 */
@Nullable public String getMemo(){
  if (paymentDetails.hasMemo())   return paymentDetails.getMemo();
 else   return null;
}",0.7548209366391184
85746,"private void parsePaymentRequest(Protos.PaymentRequest request) throws PaymentRequestException {
  try {
    if (request == null)     throw new PaymentRequestException(""String_Node_Str"");
    if (!request.hasPaymentDetailsVersion())     throw new PaymentRequestException.InvalidVersion(""String_Node_Str"");
    if (request.getPaymentDetailsVersion() != 1)     throw new PaymentRequestException.InvalidVersion(""String_Node_Str"" + request.getPaymentDetailsVersion());
    paymentRequest=request;
    if (!request.hasSerializedPaymentDetails())     throw new PaymentRequestException(""String_Node_Str"");
    paymentDetails=Protos.PaymentDetails.newBuilder().mergeFrom(request.getSerializedPaymentDetails()).build();
    if (paymentDetails == null)     throw new PaymentRequestException(""String_Node_Str"");
    if (!paymentDetails.hasNetwork())     params=MainNetParams.get();
 else     params=NetworkParameters.fromPmtProtocolID(paymentDetails.getNetwork());
    if (params == null)     throw new PaymentRequestException.InvalidNetwork(""String_Node_Str"" + paymentDetails.getNetwork());
    if (paymentDetails.getOutputsCount() < 1)     throw new PaymentRequestException.InvalidOutputs(""String_Node_Str"");
    for (    Protos.Output output : paymentDetails.getOutputsList()) {
      if (output.hasAmount())       totalValue=totalValue.add(BigInteger.valueOf(output.getAmount()));
    }
    if (totalValue.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) > 0)     throw new PaymentRequestException.InvalidOutputs(""String_Node_Str"");
  }
 catch (  InvalidProtocolBufferException e) {
    throw new PaymentRequestException(e);
  }
}","private void parsePaymentRequest(Protos.PaymentRequest request) throws PaymentRequestException {
  try {
    if (request == null)     throw new PaymentRequestException(""String_Node_Str"");
    if (!request.hasPaymentDetailsVersion())     throw new PaymentRequestException.InvalidVersion(""String_Node_Str"");
    if (request.getPaymentDetailsVersion() != 1)     throw new PaymentRequestException.InvalidVersion(""String_Node_Str"" + request.getPaymentDetailsVersion());
    paymentRequest=request;
    if (!request.hasSerializedPaymentDetails())     throw new PaymentRequestException(""String_Node_Str"");
    paymentDetails=Protos.PaymentDetails.newBuilder().mergeFrom(request.getSerializedPaymentDetails()).build();
    if (paymentDetails == null)     throw new PaymentRequestException(""String_Node_Str"");
    if (!paymentDetails.hasNetwork())     params=MainNetParams.get();
 else     params=NetworkParameters.fromPmtProtocolID(paymentDetails.getNetwork());
    if (params == null)     throw new PaymentRequestException.InvalidNetwork(""String_Node_Str"" + paymentDetails.getNetwork());
    if (paymentDetails.getOutputsCount() < 1)     throw new PaymentRequestException.InvalidOutputs(""String_Node_Str"");
    for (    Protos.Output output : paymentDetails.getOutputsList()) {
      if (output.hasAmount())       totalValue=totalValue.add(BigInteger.valueOf(output.getAmount()));
    }
    if (totalValue.compareTo(NetworkParameters.MAX_MONEY) > 0)     throw new PaymentRequestException.InvalidOutputs(""String_Node_Str"");
  }
 catch (  InvalidProtocolBufferException e) {
    throw new PaymentRequestException(e);
  }
}",0.9848437983297248
85747,"@VisibleForTesting protected ListenableFuture<Ack> sendPayment(final URL url,final Protos.Payment payment){
  return executor.submit(new Callable<Ack>(){
    @Override public Ack call() throws Exception {
      HttpURLConnection connection=(HttpURLConnection)url.openConnection();
      connection.setRequestMethod(""String_Node_Str"");
      connection.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
      connection.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
      connection.setRequestProperty(""String_Node_Str"",Integer.toString(payment.getSerializedSize()));
      connection.setUseCaches(false);
      connection.setDoInput(true);
      connection.setDoOutput(true);
      DataOutputStream outStream=new DataOutputStream(connection.getOutputStream());
      payment.writeTo(outStream);
      outStream.flush();
      outStream.close();
      InputStream inStream=connection.getInputStream();
      Protos.PaymentACK.Builder paymentAckBuilder=Protos.PaymentACK.newBuilder().mergeFrom(inStream);
      Protos.PaymentACK paymentAck=paymentAckBuilder.build();
      String memo=""String_Node_Str"";
      if (paymentAck.hasMemo())       memo=paymentAck.getMemo();
      return new Ack(memo);
    }
  }
);
}","@VisibleForTesting protected ListenableFuture<Ack> sendPayment(final URL url,final Protos.Payment payment){
  return executor.submit(new Callable<Ack>(){
    @Override public Ack call() throws Exception {
      HttpURLConnection connection=(HttpURLConnection)url.openConnection();
      connection.setRequestMethod(""String_Node_Str"");
      connection.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
      connection.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
      connection.setRequestProperty(""String_Node_Str"",Integer.toString(payment.getSerializedSize()));
      connection.setUseCaches(false);
      connection.setDoInput(true);
      connection.setDoOutput(true);
      DataOutputStream outStream=new DataOutputStream(connection.getOutputStream());
      payment.writeTo(outStream);
      outStream.flush();
      outStream.close();
      InputStream inStream=connection.getInputStream();
      Protos.PaymentACK.Builder paymentAckBuilder=Protos.PaymentACK.newBuilder().mergeFrom(inStream);
      Protos.PaymentACK paymentAck=paymentAckBuilder.build();
      String memo=null;
      if (paymentAck.hasMemo())       memo=paymentAck.getMemo();
      return new Ack(memo);
    }
  }
);
}",0.991396968455551
85748,"private String getNameFromCert(TrustAnchor rootAuthority) throws PaymentRequestException.PkiVerificationException {
  org.spongycastle.asn1.x500.X500Name name=new X500Name(rootAuthority.getTrustedCert().getSubjectX500Principal().getName());
  String commonName=null, org=null, location=null, country=null;
  for (  RDN rdn : name.getRDNs()) {
    AttributeTypeAndValue pair=rdn.getFirst();
    String val=((ASN1String)pair.getValue()).getString();
    if (pair.getType().equals(RFC4519Style.cn))     commonName=val;
 else     if (pair.getType().equals(RFC4519Style.o))     org=val;
 else     if (pair.getType().equals(RFC4519Style.l))     location=val;
 else     if (pair.getType().equals(RFC4519Style.c))     country=val;
  }
  if (org != null && location != null && country != null) {
    return org + ""String_Node_Str"" + location+ ""String_Node_Str""+ country;
  }
 else {
    if (commonName == null)     throw new PaymentRequestException.PkiVerificationException(""String_Node_Str"");
    return commonName;
  }
}","private String getNameFromCert(TrustAnchor rootAuthority) throws PaymentRequestException.PkiVerificationException {
  org.spongycastle.asn1.x500.X500Name name=new X500Name(rootAuthority.getTrustedCert().getSubjectX500Principal().getName());
  String commonName=null, org=null, location=null, country=null;
  for (  RDN rdn : name.getRDNs()) {
    AttributeTypeAndValue pair=rdn.getFirst();
    String val=((ASN1String)pair.getValue()).getString();
    if (pair.getType().equals(RFC4519Style.cn))     commonName=val;
 else     if (pair.getType().equals(RFC4519Style.o))     org=val;
 else     if (pair.getType().equals(RFC4519Style.l))     location=val;
 else     if (pair.getType().equals(RFC4519Style.c))     country=val;
  }
  if (org != null) {
    return Joiner.on(""String_Node_Str"").skipNulls().join(org,location,country);
  }
 else {
    if (commonName == null)     throw new PaymentRequestException.PkiVerificationException(""String_Node_Str"");
    return commonName;
  }
}",0.9327309236947792
85749,"@Override public void onKeysAdded(Wallet wallet,List<ECKey> keys){
  Uninterruptibles.putUninterruptibly(jobQueue,recalculateRunnable);
}","@Override public void onKeysAdded(Wallet wallet,List<ECKey> keys){
  queueRecalc();
}",0.7387387387387387
85750,"@Override public void onScriptsAdded(Wallet wallet,List<Script> scripts){
  Uninterruptibles.putUninterruptibly(jobQueue,recalculateRunnable);
}","@Override public void onScriptsAdded(Wallet wallet,List<Script> scripts){
  queueRecalc();
}",0.7542372881355932
85751,"@Test public void watchingScriptsConfirmed() throws Exception {
  ECKey key=new ECKey();
  Address watchedAddress=key.toAddress(params);
  wallet.addWatchedAddress(watchedAddress);
  Transaction t1=createFakeTx(params,CENT,watchedAddress);
  StoredBlock b3=createFakeBlock(blockStore,t1).storedBlock;
  wallet.receiveFromBlock(t1,b3,BlockChain.NewBlockType.BEST_CHAIN,0);
  assertEquals(BigInteger.ZERO,wallet.getBalance());
  assertEquals(CENT,wallet.getWatchedBalance());
  Address notMyAddr=new ECKey().toAddress(params);
  assertNull(wallet.createSend(notMyAddr,CENT));
}","@Test(expected=InsufficientMoneyException.class) public void watchingScriptsConfirmed() throws Exception {
  ECKey key=new ECKey();
  Address watchedAddress=key.toAddress(params);
  wallet.addWatchedAddress(watchedAddress);
  Transaction t1=createFakeTx(params,CENT,watchedAddress);
  StoredBlock b3=createFakeBlock(blockStore,t1).storedBlock;
  wallet.receiveFromBlock(t1,b3,BlockChain.NewBlockType.BEST_CHAIN,0);
  assertEquals(BigInteger.ZERO,wallet.getBalance());
  assertEquals(CENT,wallet.getWatchedBalance());
  Address notMyAddr=new ECKey().toAddress(params);
  wallet.createSend(notMyAddr,CENT);
}",0.9009314140558848
85752,"@Test public void disconnectOldVersions1() throws Exception {
  final SettableFuture<Void> connectedFuture=SettableFuture.create();
  final SettableFuture<Void> disconnectedFuture=SettableFuture.create();
  peer.addEventListener(new AbstractPeerEventListener(){
    @Override public void onPeerConnected(    Peer peer,    int peerCount){
      connectedFuture.set(null);
    }
    @Override public void onPeerDisconnected(    Peer peer,    int peerCount){
      disconnectedFuture.set(null);
    }
  }
);
  connectWithVersion(500);
  connectedFuture.get();
  disconnectedFuture.get();
  try {
    peer.writeTarget.writeBytes(new byte[1]);
    fail();
  }
 catch (  IOException e) {
    assertTrue((e.getCause() != null && e.getCause() instanceof CancelledKeyException) || (e instanceof SocketException && e.getMessage().equals(""String_Node_Str"")));
  }
}","@Test public void disconnectOldVersions1() throws Exception {
  final SettableFuture<Void> connectedFuture=SettableFuture.create();
  final SettableFuture<Void> disconnectedFuture=SettableFuture.create();
  peer.addEventListener(new AbstractPeerEventListener(){
    @Override public void onPeerConnected(    Peer peer,    int peerCount){
      connectedFuture.set(null);
    }
    @Override public void onPeerDisconnected(    Peer peer,    int peerCount){
      disconnectedFuture.set(null);
    }
  }
);
  connectWithVersion(500);
  Uninterruptibles.getUninterruptibly(connectedFuture);
  Uninterruptibles.getUninterruptibly(disconnectedFuture);
  try {
    peer.writeTarget.writeBytes(new byte[1]);
    fail();
  }
 catch (  IOException e) {
    assertTrue((e.getCause() != null && e.getCause() instanceof CancelledKeyException) || (e instanceof SocketException && e.getMessage().equals(""String_Node_Str"")));
  }
}",0.952542372881356
85753,"private void processVersionMessage(VersionMessage m) throws ProtocolException {
  if (vPeerVersionMessage != null)   throw new ProtocolException(""String_Node_Str"");
  vPeerVersionMessage=m;
  int peerVersion=vPeerVersionMessage.clientVersion;
  PeerAddress peerAddress=getAddress();
  log.info(""String_Node_Str"",new Object[]{peerAddress == null ? ""String_Node_Str"" : peerAddress.getAddr().getHostAddress(),peerVersion,vPeerVersionMessage.subVer,vPeerVersionMessage.localServices,new Date(vPeerVersionMessage.time * 1000),vPeerVersionMessage.bestHeight});
  sendMessage(new VersionAck());
  if (!vPeerVersionMessage.hasBlockChain() || (!params.allowEmptyPeerChain() && vPeerVersionMessage.bestHeight <= 0)) {
    throw new ProtocolException(""String_Node_Str"");
  }
}","private void processVersionMessage(VersionMessage m) throws ProtocolException {
  if (vPeerVersionMessage != null)   throw new ProtocolException(""String_Node_Str"");
  vPeerVersionMessage=m;
  int peerVersion=vPeerVersionMessage.clientVersion;
  PeerAddress peerAddress=getAddress();
  long peerTime=vPeerVersionMessage.time * 1000;
  log.info(""String_Node_Str"",peerAddress == null ? ""String_Node_Str"" : peerAddress.getAddr().getHostAddress(),peerVersion,vPeerVersionMessage.subVer,vPeerVersionMessage.localServices,String.format(""String_Node_Str"",peerTime,peerTime),vPeerVersionMessage.bestHeight);
  sendMessage(new VersionAck());
  if (!vPeerVersionMessage.hasBlockChain() || (!params.allowEmptyPeerChain() && vPeerVersionMessage.bestHeight <= 0)) {
    throw new ProtocolException(""String_Node_Str"");
  }
}",0.6899618805590851
85754,"private void handleKey(SelectionKey key) throws IOException {
  if (key.isValid() && key.isConnectable()) {
    StreamParser parser=(StreamParser)key.attachment();
    SocketChannel sc=(SocketChannel)key.channel();
    ConnectionHandler handler=new ConnectionHandler(parser,key,connectedHandlers);
    try {
      if (sc.finishConnect()) {
        log.info(""String_Node_Str"",sc.socket().getRemoteSocketAddress());
        handler.parser.connectionOpened();
        key.interestOps(SelectionKey.OP_READ).attach(handler);
      }
 else {
        log.error(""String_Node_Str"",sc.socket().getRemoteSocketAddress());
        handler.closeConnection();
      }
    }
 catch (    IOException e) {
      log.error(""String_Node_Str"",e.getMessage());
      handler.closeConnection();
    }
catch (    CancelledKeyException e) {
      log.error(""String_Node_Str"",e.getMessage());
      handler.closeConnection();
    }
  }
 else   ConnectionHandler.handleKey(key);
}","private void handleKey(SelectionKey key) throws IOException {
  if (key.isValid() && key.isConnectable()) {
    StreamParser parser=(StreamParser)key.attachment();
    SocketChannel sc=(SocketChannel)key.channel();
    ConnectionHandler handler=new ConnectionHandler(parser,key,connectedHandlers);
    try {
      if (sc.finishConnect()) {
        log.info(""String_Node_Str"",sc.socket().getRemoteSocketAddress());
        key.interestOps(SelectionKey.OP_READ).attach(handler);
        handler.parser.connectionOpened();
      }
 else {
        log.error(""String_Node_Str"",sc.socket().getRemoteSocketAddress());
        handler.closeConnection();
      }
    }
 catch (    IOException e) {
      log.error(""String_Node_Str"",e.getMessage());
      handler.closeConnection();
    }
catch (    CancelledKeyException e) {
      log.error(""String_Node_Str"",e.getMessage());
      handler.closeConnection();
    }
  }
 else   ConnectionHandler.handleKey(key);
}",0.9549266247379457
85755,"public TestNet3Params(){
  super();
  id=ID_TESTNET;
  packetMagic=0x0b110907;
  interval=INTERVAL;
  targetTimespan=TARGET_TIMESPAN;
  proofOfWorkLimit=Utils.decodeCompactBits(0x1d00ffffL);
  port=CoinDefinition.TestPort;
  addressHeader=CoinDefinition.testnetAddressHeader;
  acceptableAddressCodes=new int[]{CoinDefinition.testnetAddressHeader};
  dumpedPrivateKeyHeader=128 + CoinDefinition.testnetAddressHeader;
  genesisBlock.setTime(1296688602L);
  genesisBlock.setDifficultyTarget(0x1d00ffffL);
  genesisBlock.setNonce(414098458);
  spendableCoinbaseDepth=CoinDefinition.spendableCoinbaseDepth;
  subsidyDecreaseBlockCount=CoinDefinition.subsidyDecreaseBlockCount;
  String genesisHash=genesisBlock.getHashAsString();
  checkState(genesisHash.equals(CoinDefinition.testnetGenesisHash));
  alertSigningKey=Hex.decode(""String_Node_Str"");
  dnsSeeds=CoinDefinition.testnetDnsSeeds;
}","public TestNet3Params(){
  super();
  id=ID_TESTNET;
  packetMagic=0x0b110907;
  interval=INTERVAL;
  targetTimespan=TARGET_TIMESPAN;
  proofOfWorkLimit=Utils.decodeCompactBits(0x1d00ffffL);
  port=CoinDefinition.TestPort;
  addressHeader=CoinDefinition.testnetAddressHeader;
  acceptableAddressCodes=new int[]{CoinDefinition.testnetAddressHeader};
  dumpedPrivateKeyHeader=128 + CoinDefinition.testnetAddressHeader;
  genesisBlock.setTime(1296688602L);
  genesisBlock.setDifficultyTarget(0x1d00ffffL);
  genesisBlock.setNonce(414098458);
  spendableCoinbaseDepth=CoinDefinition.spendableCoinbaseDepth;
  subsidyDecreaseBlockCount=CoinDefinition.subsidyDecreaseBlockCount;
  String genesisHash=genesisBlock.getHashAsString();
  alertSigningKey=Hex.decode(""String_Node_Str"");
  dnsSeeds=CoinDefinition.testnetDnsSeeds;
}",0.9595782073813708
85756,"private static void executeCheckSig(Transaction txContainingThis,int index,Script script,LinkedList<byte[]> stack,int lastCodeSepLocation,int opcode) throws ScriptException {
  if (stack.size() < 2)   throw new ScriptException(""String_Node_Str"");
  byte[] pubKey=stack.pollLast();
  byte[] sigBytes=stack.pollLast();
  if (sigBytes.length == 0 || pubKey.length == 0)   throw new ScriptException(""String_Node_Str"");
  byte[] prog=script.getProgram();
  byte[] connectedScript=Arrays.copyOfRange(prog,lastCodeSepLocation,prog.length);
  UnsafeByteArrayOutputStream outStream=new UnsafeByteArrayOutputStream(sigBytes.length + 1);
  try {
    writeBytes(outStream,sigBytes);
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  connectedScript=removeAllInstancesOf(connectedScript,outStream.toByteArray());
  boolean sigValid=false;
  try {
    TransactionSignature sig=TransactionSignature.decodeFromBitcoin(sigBytes,false);
    Sha256Hash hash=txContainingThis.hashForSignature(index,connectedScript,(byte)sig.sighashFlags);
    sigValid=ECKey.verify(hash.getBytes(),sig,pubKey);
  }
 catch (  Exception e1) {
    log.warn(e1.toString());
  }
  if (opcode == OP_CHECKSIG)   stack.add(sigValid ? new byte[]{1} : new byte[]{0});
 else   if (opcode == OP_CHECKSIGVERIFY)   if (!sigValid)   throw new ScriptException(""String_Node_Str"");
}","private static void executeCheckSig(Transaction txContainingThis,int index,Script script,LinkedList<byte[]> stack,int lastCodeSepLocation,int opcode) throws ScriptException {
  if (stack.size() < 2)   throw new ScriptException(""String_Node_Str"");
  byte[] pubKey=stack.pollLast();
  byte[] sigBytes=stack.pollLast();
  if (sigBytes.length == 0 || pubKey.length == 0) {
    if (opcode == OP_CHECKSIG)     stack.add(new byte[]{0});
 else     if (opcode == OP_CHECKSIGVERIFY)     throw new ScriptException(""String_Node_Str"");
    return;
  }
  byte[] prog=script.getProgram();
  byte[] connectedScript=Arrays.copyOfRange(prog,lastCodeSepLocation,prog.length);
  UnsafeByteArrayOutputStream outStream=new UnsafeByteArrayOutputStream(sigBytes.length + 1);
  try {
    writeBytes(outStream,sigBytes);
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  connectedScript=removeAllInstancesOf(connectedScript,outStream.toByteArray());
  boolean sigValid=false;
  try {
    TransactionSignature sig=TransactionSignature.decodeFromBitcoin(sigBytes,false);
    Sha256Hash hash=txContainingThis.hashForSignature(index,connectedScript,(byte)sig.sighashFlags);
    sigValid=ECKey.verify(hash.getBytes(),sig,pubKey);
  }
 catch (  Exception e1) {
    log.warn(e1.toString());
  }
  if (opcode == OP_CHECKSIG)   stack.add(sigValid ? new byte[]{1} : new byte[]{0});
 else   if (opcode == OP_CHECKSIGVERIFY)   if (!sigValid)   throw new ScriptException(""String_Node_Str"");
}",0.3680113234253361
85757,"private void watchCloseConfirmations(){
  storedChannel.close.getConfidence().getDepthFuture(CONFIRMATIONS_FOR_DELETE).addListener(new Runnable(){
    @Override public void run(){
      deleteChannelFromWallet();
    }
  }
,Threading.SAME_THREAD);
}","private void watchCloseConfirmations(){
  final TransactionConfidence confidence=storedChannel.close.getConfidence();
  ListenableFuture<Transaction> future=confidence.getDepthFuture(CONFIRMATIONS_FOR_DELETE,Threading.SAME_THREAD);
  Futures.addCallback(future,new FutureCallback<Transaction>(){
    @Override public void onSuccess(    Transaction result){
      deleteChannelFromWallet();
    }
    @Override public void onFailure(    Throwable t){
      Throwables.propagate(t);
    }
  }
);
}",0.3844086021505376
85758,"@After @Override public void tearDown() throws Exception {
  super.tearDown();
}","@After @Override public void tearDown() throws Exception {
  super.tearDown();
  ECKey.FAKE_SIGNATURES=false;
}",0.837696335078534
85759,"@Test public void testSimpleChannel() throws Exception {
  final SettableFuture<ListenableFuture<PaymentChannelServerState>> serverCloseFuture=SettableFuture.create();
  final SettableFuture<Sha256Hash> channelOpenFuture=SettableFuture.create();
  final BlockingQueue<BigInteger> q=new LinkedBlockingQueue<BigInteger>();
  final PaymentChannelServerListener server=new PaymentChannelServerListener(mockBroadcaster,serverWallet,1,Utils.COIN,new PaymentChannelServerListener.HandlerFactory(){
    @Nullable @Override public ServerConnectionEventHandler onNewConnection(    SocketAddress clientAddress){
      return new ServerConnectionEventHandler(){
        @Override public void channelOpen(        Sha256Hash channelId){
          channelOpenFuture.set(channelId);
        }
        @Override public void paymentIncrease(        BigInteger by,        BigInteger to){
          q.add(to);
        }
        @Override public void channelClosed(        CloseReason reason){
          serverCloseFuture.set(null);
        }
      }
;
    }
  }
);
  server.bindAndStart(4243);
  PaymentChannelClientConnection client=new PaymentChannelClientConnection(new InetSocketAddress(""String_Node_Str"",4243),1,wallet,myKey,Utils.COIN,""String_Node_Str"");
  broadcastTxPause.release();
  Transaction broadcastMultiSig=broadcasts.take();
  client.getChannelOpenFuture().get();
  assertEquals(broadcastMultiSig.getHash(),channelOpenFuture.get());
  assertEquals(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE,client.state().getValueSpent());
  final CountDownLatch latch=new CountDownLatch(3);
  File tempFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  tempFile.deleteOnExit();
  serverWallet.autosaveToFile(tempFile,0,TimeUnit.SECONDS,new WalletFiles.Listener(){
    @Override public void onBeforeAutoSave(    File tempFile){
      latch.countDown();
    }
    @Override public void onAfterAutoSave(    File newlySavedFile){
    }
  }
);
  Thread.sleep(1250);
  BigInteger amount=client.state().getValueSpent();
  assertEquals(amount,q.take());
  client.incrementPayment(Utils.CENT).get();
  amount=amount.add(Utils.CENT);
  assertEquals(amount,q.take());
  client.incrementPayment(Utils.CENT).get();
  amount=amount.add(Utils.CENT);
  assertEquals(amount,q.take());
  client.incrementPayment(Utils.CENT).get();
  amount=amount.add(Utils.CENT);
  assertEquals(amount,q.take());
  latch.await();
  StoredPaymentChannelServerStates channels=(StoredPaymentChannelServerStates)serverWallet.getExtensions().get(StoredPaymentChannelServerStates.EXTENSION_ID);
  StoredServerChannel storedServerChannel=channels.getChannel(broadcastMultiSig.getHash());
  PaymentChannelServerState serverState=storedServerChannel.getOrCreateState(serverWallet,mockBroadcaster);
  client.settle();
  client.settle();
  broadcastTxPause.release();
  Transaction settleTx=broadcasts.take();
  assertEquals(PaymentChannelServerState.State.CLOSED,serverState.getState());
  if (!serverState.getBestValueToMe().equals(amount) || !serverState.getFeePaid().equals(BigInteger.ZERO))   fail();
  assertTrue(channels.mapChannels.isEmpty());
  sendMoneyToWallet(settleTx,AbstractBlockChain.NewBlockType.BEST_CHAIN);
  assertEquals(PaymentChannelClientState.State.CLOSED,client.state().getState());
  server.close();
  server.close();
  assertEquals(1,StoredPaymentChannelClientStates.getFromWallet(wallet).mapChannels.size());
  wallet.notifyNewBestBlock(createFakeBlock(blockStore).storedBlock);
  assertEquals(1,StoredPaymentChannelClientStates.getFromWallet(wallet).mapChannels.size());
  wallet.notifyNewBestBlock(createFakeBlock(blockStore).storedBlock);
  assertEquals(1,StoredPaymentChannelClientStates.getFromWallet(wallet).mapChannels.size());
  wallet.notifyNewBestBlock(createFakeBlock(blockStore).storedBlock);
  assertEquals(0,StoredPaymentChannelClientStates.getFromWallet(wallet).mapChannels.size());
}","@Test public void testSimpleChannel() throws Exception {
  final SettableFuture<ListenableFuture<PaymentChannelServerState>> serverCloseFuture=SettableFuture.create();
  final SettableFuture<Sha256Hash> channelOpenFuture=SettableFuture.create();
  final BlockingQueue<BigInteger> q=new LinkedBlockingQueue<BigInteger>();
  final PaymentChannelServerListener server=new PaymentChannelServerListener(mockBroadcaster,serverWallet,30,Utils.COIN,new PaymentChannelServerListener.HandlerFactory(){
    @Nullable @Override public ServerConnectionEventHandler onNewConnection(    SocketAddress clientAddress){
      return new ServerConnectionEventHandler(){
        @Override public void channelOpen(        Sha256Hash channelId){
          channelOpenFuture.set(channelId);
        }
        @Override public void paymentIncrease(        BigInteger by,        BigInteger to){
          q.add(to);
        }
        @Override public void channelClosed(        CloseReason reason){
          serverCloseFuture.set(null);
        }
      }
;
    }
  }
);
  server.bindAndStart(4243);
  PaymentChannelClientConnection client=new PaymentChannelClientConnection(new InetSocketAddress(""String_Node_Str"",4243),30,wallet,myKey,Utils.COIN,""String_Node_Str"");
  broadcastTxPause.release();
  Transaction broadcastMultiSig=broadcasts.take();
  client.getChannelOpenFuture().get();
  assertEquals(broadcastMultiSig.getHash(),channelOpenFuture.get());
  assertEquals(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE,client.state().getValueSpent());
  final CountDownLatch latch=new CountDownLatch(3);
  File tempFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  tempFile.deleteOnExit();
  serverWallet.autosaveToFile(tempFile,0,TimeUnit.SECONDS,new WalletFiles.Listener(){
    @Override public void onBeforeAutoSave(    File tempFile){
      latch.countDown();
    }
    @Override public void onAfterAutoSave(    File newlySavedFile){
    }
  }
);
  Thread.sleep(1250);
  BigInteger amount=client.state().getValueSpent();
  assertEquals(amount,q.take());
  client.incrementPayment(Utils.CENT).get();
  amount=amount.add(Utils.CENT);
  assertEquals(amount,q.take());
  client.incrementPayment(Utils.CENT).get();
  amount=amount.add(Utils.CENT);
  assertEquals(amount,q.take());
  client.incrementPayment(Utils.CENT).get();
  amount=amount.add(Utils.CENT);
  assertEquals(amount,q.take());
  latch.await();
  StoredPaymentChannelServerStates channels=(StoredPaymentChannelServerStates)serverWallet.getExtensions().get(StoredPaymentChannelServerStates.EXTENSION_ID);
  StoredServerChannel storedServerChannel=channels.getChannel(broadcastMultiSig.getHash());
  PaymentChannelServerState serverState=storedServerChannel.getOrCreateState(serverWallet,mockBroadcaster);
  client.settle();
  client.settle();
  broadcastTxPause.release();
  Transaction settleTx=broadcasts.take();
  assertEquals(PaymentChannelServerState.State.CLOSED,serverState.getState());
  if (!serverState.getBestValueToMe().equals(amount) || !serverState.getFeePaid().equals(BigInteger.ZERO))   fail();
  assertTrue(channels.mapChannels.isEmpty());
  sendMoneyToWallet(settleTx,AbstractBlockChain.NewBlockType.BEST_CHAIN);
  assertEquals(PaymentChannelClientState.State.CLOSED,client.state().getState());
  server.close();
  server.close();
  assertEquals(1,StoredPaymentChannelClientStates.getFromWallet(wallet).mapChannels.size());
  wallet.notifyNewBestBlock(createFakeBlock(blockStore).storedBlock);
  assertEquals(1,StoredPaymentChannelClientStates.getFromWallet(wallet).mapChannels.size());
  wallet.notifyNewBestBlock(createFakeBlock(blockStore).storedBlock);
  assertEquals(0,StoredPaymentChannelClientStates.getFromWallet(wallet).mapChannels.size());
}",0.9777367935713344
85760,"@Before public void setUp() throws Exception {
  super.setUp();
  sendMoneyToWallet(Utils.COIN,AbstractBlockChain.NewBlockType.BEST_CHAIN);
  sendMoneyToWallet(Utils.COIN,AbstractBlockChain.NewBlockType.BEST_CHAIN);
  wallet.addExtension(new StoredPaymentChannelClientStates(wallet,failBroadcaster));
  serverWallet=new Wallet(params);
  serverWallet.addExtension(new StoredPaymentChannelServerStates(serverWallet,failBroadcaster));
  serverWallet.addKey(new ECKey());
  serverChain=new BlockChain(params,serverWallet,blockStore);
  fail=new AtomicBoolean(false);
  broadcasts=new LinkedBlockingQueue<Transaction>();
  broadcastTxPause=new Semaphore(0);
  mockBroadcaster=new TransactionBroadcaster(){
    @Override public ListenableFuture<Transaction> broadcastTransaction(    Transaction tx){
      broadcastTxPause.acquireUninterruptibly();
      SettableFuture<Transaction> future=SettableFuture.create();
      future.set(tx);
      broadcasts.add(tx);
      return future;
    }
  }
;
  Threading.warnOnLockCycles();
}","@Before public void setUp() throws Exception {
  super.setUp();
  sendMoneyToWallet(Utils.COIN,AbstractBlockChain.NewBlockType.BEST_CHAIN);
  sendMoneyToWallet(Utils.COIN,AbstractBlockChain.NewBlockType.BEST_CHAIN);
  wallet.addExtension(new StoredPaymentChannelClientStates(wallet,failBroadcaster));
  serverWallet=new Wallet(params);
  serverWallet.addExtension(new StoredPaymentChannelServerStates(serverWallet,failBroadcaster));
  serverWallet.addKey(new ECKey());
  serverChain=new BlockChain(params,serverWallet,blockStore);
  fail=new AtomicBoolean(false);
  broadcasts=new LinkedBlockingQueue<Transaction>();
  broadcastTxPause=new Semaphore(0);
  mockBroadcaster=new TransactionBroadcaster(){
    @Override public ListenableFuture<Transaction> broadcastTransaction(    Transaction tx){
      broadcastTxPause.acquireUninterruptibly();
      SettableFuture<Transaction> future=SettableFuture.create();
      future.set(tx);
      broadcasts.add(tx);
      return future;
    }
  }
;
  Threading.warnOnLockCycles();
  ECKey.FAKE_SIGNATURES=true;
}",0.985563041385948
85761,"/** 
 * Returns the script bytes of inputScript with all instances of the specified script object removed
 */
public static byte[] removeAllInstancesOf(byte[] inputScript,byte[] chunkToRemove){
  UnsafeByteArrayOutputStream bos=new UnsafeByteArrayOutputStream(inputScript.length);
  int cursor=0;
  while (cursor < inputScript.length) {
    boolean skip=equalsRange(inputScript,cursor,chunkToRemove);
    int opcode=inputScript[cursor++] & 0xFF;
    int additionalBytes=0;
    if (opcode >= 0 && opcode < OP_PUSHDATA1) {
      additionalBytes=opcode;
    }
 else     if (opcode == OP_PUSHDATA1) {
      additionalBytes=inputScript[cursor] + 1;
    }
 else     if (opcode == OP_PUSHDATA2) {
      additionalBytes=((0xFF & inputScript[cursor]) | ((0xFF & inputScript[cursor + 1]) << 8)) + 2;
    }
 else     if (opcode == OP_PUSHDATA4) {
      additionalBytes=((0xFF & inputScript[cursor]) | ((0xFF & inputScript[cursor + 1]) << 8) | ((0xFF & inputScript[cursor + 1]) << 16)| ((0xFF & inputScript[cursor + 1]) << 24)) + 4;
    }
    if (!skip) {
      try {
        bos.write(opcode);
        bos.write(Arrays.copyOfRange(inputScript,cursor,cursor + additionalBytes));
      }
 catch (      IOException e) {
        throw new RuntimeException(e);
      }
    }
    cursor+=additionalBytes;
  }
  return bos.toByteArray();
}","/** 
 * Returns the script bytes of inputScript with all instances of the specified script object removed
 */
public static byte[] removeAllInstancesOf(byte[] inputScript,byte[] chunkToRemove){
  UnsafeByteArrayOutputStream bos=new UnsafeByteArrayOutputStream(inputScript.length);
  int cursor=0;
  while (cursor < inputScript.length) {
    boolean skip=equalsRange(inputScript,cursor,chunkToRemove);
    int opcode=inputScript[cursor++] & 0xFF;
    int additionalBytes=0;
    if (opcode >= 0 && opcode < OP_PUSHDATA1) {
      additionalBytes=opcode;
    }
 else     if (opcode == OP_PUSHDATA1) {
      additionalBytes=(0xFF & inputScript[cursor]) + 1;
    }
 else     if (opcode == OP_PUSHDATA2) {
      additionalBytes=((0xFF & inputScript[cursor]) | ((0xFF & inputScript[cursor + 1]) << 8)) + 2;
    }
 else     if (opcode == OP_PUSHDATA4) {
      additionalBytes=((0xFF & inputScript[cursor]) | ((0xFF & inputScript[cursor + 1]) << 8) | ((0xFF & inputScript[cursor + 1]) << 16)| ((0xFF & inputScript[cursor + 1]) << 24)) + 4;
    }
    if (!skip) {
      try {
        bos.write(opcode);
        bos.write(Arrays.copyOfRange(inputScript,cursor,cursor + additionalBytes));
      }
 catch (      IOException e) {
        throw new RuntimeException(e);
      }
    }
    cursor+=additionalBytes;
  }
  return bos.toByteArray();
}",0.996605054696341
85762,"/** 
 * Given a spend request containing an incomplete transaction, makes it valid by adding outputs and signed inputs according to the instructions in the request. The transaction in the request is modified by this method, as is the fee parameter.
 * @param req a SendRequest that contains the incomplete transaction and details for how to make it valid.
 * @throws IllegalArgumentException if you try and complete the same SendRequest twice.
 * @return whether or not the requested send is affordable.
 */
public boolean completeTx(SendRequest req){
  lock.lock();
  try {
    Preconditions.checkArgument(!req.completed,""String_Node_Str"");
    BigInteger value=BigInteger.ZERO;
    for (    TransactionOutput output : req.tx.getOutputs()) {
      value=value.add(output.getValue());
    }
    BigInteger totalOutput=value;
    log.info(""String_Node_Str"",req.tx.getOutputs().size(),bitcoinValueToFriendlyString(value));
    BigInteger totalInput=BigInteger.ZERO;
    for (    TransactionInput input : req.tx.getInputs())     if (input.getConnectedOutput() != null)     totalInput=totalInput.add(input.getConnectedOutput().getValue());
 else     log.warn(""String_Node_Str"");
    value=value.subtract(totalInput);
    List<TransactionInput> originalInputs=new ArrayList<TransactionInput>(req.tx.getInputs());
    boolean needAtLeastReferenceFee=false;
    if (req.ensureMinRequiredFee && !req.emptyWallet) {
      for (      TransactionOutput output : req.tx.getOutputs())       if (output.getValue().compareTo(Utils.CENT) < 0) {
        if (output.getValue().compareTo(output.getMinNonDustValue()) < 0) {
          log.error(""String_Node_Str"");
          return false;
        }
        needAtLeastReferenceFee=true;
        break;
      }
    }
    LinkedList<TransactionOutput> candidates=calculateAllSpendCandidates(true);
    CoinSelection bestCoinSelection;
    TransactionOutput bestChangeOutput=null;
    if (!req.emptyWallet) {
      FeeCalculation feeCalculation;
      try {
        feeCalculation=new FeeCalculation(req,value,originalInputs,needAtLeastReferenceFee,candidates);
      }
 catch (      InsufficientMoneyException e) {
        return false;
      }
      bestCoinSelection=feeCalculation.bestCoinSelection;
      bestChangeOutput=feeCalculation.bestChangeOutput;
    }
 else {
      checkState(req.tx.getOutputs().size() == 1,""String_Node_Str"");
      CoinSelector selector=req.coinSelector == null ? coinSelector : req.coinSelector;
      bestCoinSelection=selector.select(NetworkParameters.MAX_MONEY,candidates);
      req.tx.getOutput(0).setValue(bestCoinSelection.valueGathered);
    }
    for (    TransactionOutput output : bestCoinSelection.gathered)     req.tx.addInput(output);
    if (req.ensureMinRequiredFee && req.emptyWallet) {
      final BigInteger baseFee=req.fee == null ? BigInteger.ZERO : req.fee;
      final BigInteger feePerKb=req.feePerKb == null ? BigInteger.ZERO : req.feePerKb;
      Transaction tx=req.tx;
      if (!adjustOutputDownwardsForFee(tx,bestCoinSelection,baseFee,feePerKb))       return false;
    }
    totalInput=totalInput.add(bestCoinSelection.valueGathered);
    if (bestChangeOutput != null) {
      req.tx.addOutput(bestChangeOutput);
      totalOutput=totalOutput.add(bestChangeOutput.getValue());
      log.info(""String_Node_Str"",bitcoinValueToFriendlyString(bestChangeOutput.getValue()));
    }
    final BigInteger calculatedFee=totalInput.subtract(totalOutput);
    if (calculatedFee.compareTo(BigInteger.ZERO) > 0) {
      log.info(""String_Node_Str"",bitcoinValueToFriendlyString(calculatedFee));
    }
    try {
      req.tx.signInputs(Transaction.SigHash.ALL,this,req.aesKey);
    }
 catch (    ScriptException e) {
      throw new RuntimeException(e);
    }
    int size=req.tx.bitcoinSerialize().length;
    if (size > Transaction.MAX_STANDARD_TX_SIZE) {
      log.warn(String.format(""String_Node_Str"",size,Transaction.MAX_STANDARD_TX_SIZE));
      return false;
    }
    req.tx.getConfidence().setSource(TransactionConfidence.Source.SELF);
    req.tx.setPurpose(Transaction.Purpose.USER_PAYMENT);
    req.completed=true;
    req.fee=calculatedFee;
    log.info(""String_Node_Str"",req.tx);
    return true;
  }
  finally {
    lock.unlock();
  }
}","/** 
 * Given a spend request containing an incomplete transaction, makes it valid by adding outputs and signed inputs according to the instructions in the request. The transaction in the request is modified by this method, as is the fee parameter.
 * @param req a SendRequest that contains the incomplete transaction and details for how to make it valid.
 * @throws IllegalArgumentException if you try and complete the same SendRequest twice.
 * @return whether or not the requested send is affordable.
 */
public boolean completeTx(SendRequest req){
  lock.lock();
  try {
    Preconditions.checkArgument(!req.completed,""String_Node_Str"");
    BigInteger value=BigInteger.ZERO;
    for (    TransactionOutput output : req.tx.getOutputs()) {
      value=value.add(output.getValue());
    }
    BigInteger totalOutput=value;
    log.info(""String_Node_Str"",req.tx.getOutputs().size(),value);
    BigInteger totalInput=BigInteger.ZERO;
    for (    TransactionInput input : req.tx.getInputs())     if (input.getConnectedOutput() != null)     totalInput=totalInput.add(input.getConnectedOutput().getValue());
 else     log.warn(""String_Node_Str"");
    value=value.subtract(totalInput);
    List<TransactionInput> originalInputs=new ArrayList<TransactionInput>(req.tx.getInputs());
    boolean needAtLeastReferenceFee=false;
    if (req.ensureMinRequiredFee && !req.emptyWallet) {
      for (      TransactionOutput output : req.tx.getOutputs())       if (output.getValue().compareTo(Utils.CENT) < 0) {
        if (output.getValue().compareTo(output.getMinNonDustValue()) < 0) {
          log.error(""String_Node_Str"");
          return false;
        }
        needAtLeastReferenceFee=true;
        break;
      }
    }
    LinkedList<TransactionOutput> candidates=calculateAllSpendCandidates(true);
    CoinSelection bestCoinSelection;
    TransactionOutput bestChangeOutput=null;
    if (!req.emptyWallet) {
      FeeCalculation feeCalculation;
      try {
        feeCalculation=new FeeCalculation(req,value,originalInputs,needAtLeastReferenceFee,candidates);
      }
 catch (      InsufficientMoneyException e) {
        log.error(""String_Node_Str"");
        return false;
      }
      bestCoinSelection=feeCalculation.bestCoinSelection;
      bestChangeOutput=feeCalculation.bestChangeOutput;
    }
 else {
      checkState(req.tx.getOutputs().size() == 1,""String_Node_Str"");
      CoinSelector selector=req.coinSelector == null ? coinSelector : req.coinSelector;
      bestCoinSelection=selector.select(NetworkParameters.MAX_MONEY,candidates);
      req.tx.getOutput(0).setValue(bestCoinSelection.valueGathered);
      totalOutput=bestCoinSelection.valueGathered;
    }
    for (    TransactionOutput output : bestCoinSelection.gathered)     req.tx.addInput(output);
    if (req.ensureMinRequiredFee && req.emptyWallet) {
      final BigInteger baseFee=req.fee == null ? BigInteger.ZERO : req.fee;
      final BigInteger feePerKb=req.feePerKb == null ? BigInteger.ZERO : req.feePerKb;
      Transaction tx=req.tx;
      if (!adjustOutputDownwardsForFee(tx,bestCoinSelection,baseFee,feePerKb)) {
        log.error(""String_Node_Str"");
        return false;
      }
    }
    totalInput=totalInput.add(bestCoinSelection.valueGathered);
    if (bestChangeOutput != null) {
      req.tx.addOutput(bestChangeOutput);
      totalOutput=totalOutput.add(bestChangeOutput.getValue());
      log.info(""String_Node_Str"",bitcoinValueToFriendlyString(bestChangeOutput.getValue()));
    }
    final BigInteger calculatedFee=totalInput.subtract(totalOutput);
    if (calculatedFee.compareTo(BigInteger.ZERO) > 0) {
      log.info(""String_Node_Str"",bitcoinValueToFriendlyString(calculatedFee));
    }
    try {
      req.tx.signInputs(Transaction.SigHash.ALL,this,req.aesKey);
    }
 catch (    ScriptException e) {
      throw new RuntimeException(e);
    }
    int size=req.tx.bitcoinSerialize().length;
    if (size > Transaction.MAX_STANDARD_TX_SIZE) {
      log.error(""String_Node_Str"",size,Transaction.MAX_STANDARD_TX_SIZE);
      return false;
    }
    req.tx.getConfidence().setSource(TransactionConfidence.Source.SELF);
    req.tx.setPurpose(Transaction.Purpose.USER_PAYMENT);
    req.completed=true;
    req.fee=calculatedFee;
    log.info(""String_Node_Str"",req.tx);
    return true;
  }
  finally {
    lock.unlock();
  }
}",0.972972972972973
85763,"/** 
 * <p>Called by the   {@link BlockChain} when a new block on the best chain is seen, AFTER relevant wallettransactions are extracted and sent to us UNLESS the new block caused a re-org, in which case this will not be called (the  {@link Wallet#reorganize(StoredBlock,java.util.List,java.util.List)} method willcall this one in that case).</p> <p/> <p>Used to update confidence data in each transaction and last seen block hash. Triggers auto saving. Invokes the onWalletChanged event listener if there were any affected transactions.</p>
 */
public void notifyNewBestBlock(StoredBlock block) throws VerificationException {
  Sha256Hash newBlockHash=block.getHeader().getHash();
  if (newBlockHash.equals(getLastBlockSeenHash()))   return;
  lock.lock();
  try {
    setLastBlockSeenHash(newBlockHash);
    setLastBlockSeenHeight(block.getHeight());
    Set<Transaction> transactions=getTransactions(true);
    for (    Transaction tx : transactions) {
      if (ignoreNextNewBlock.contains(tx.getHash())) {
        ignoreNextNewBlock.remove(tx.getHash());
      }
 else {
        tx.getConfidence().notifyWorkDone(block.getHeader());
        confidenceChanged.put(tx,TransactionConfidence.Listener.ChangeReason.DEPTH);
      }
    }
    informConfidenceListenersIfNotReorganizing();
    maybeQueueOnWalletChanged();
    saveLater();
  }
  finally {
    lock.unlock();
  }
}","/** 
 * <p>Called by the   {@link BlockChain} when a new block on the best chain is seen, AFTER relevant wallettransactions are extracted and sent to us UNLESS the new block caused a re-org, in which case this will not be called (the  {@link Wallet#reorganize(StoredBlock,java.util.List,java.util.List)} method willcall this one in that case).</p> <p/> <p>Used to update confidence data in each transaction and last seen block hash. Triggers auto saving. Invokes the onWalletChanged event listener if there were any affected transactions.</p>
 */
public void notifyNewBestBlock(StoredBlock block) throws VerificationException {
  Sha256Hash newBlockHash=block.getHeader().getHash();
  if (newBlockHash.equals(getLastBlockSeenHash()))   return;
  lock.lock();
  try {
    setLastBlockSeenHash(newBlockHash);
    setLastBlockSeenHeight(block.getHeight());
    Set<Transaction> transactions=getTransactions(true);
    for (    Transaction tx : transactions) {
      if (ignoreNextNewBlock.contains(tx.getHash())) {
        ignoreNextNewBlock.remove(tx.getHash());
      }
 else       if (tx.getConfidence().getConfidenceType() == ConfidenceType.BUILDING) {
        tx.getConfidence().notifyWorkDone(block.getHeader());
        confidenceChanged.put(tx,TransactionConfidence.Listener.ChangeReason.DEPTH);
      }
    }
    informConfidenceListenersIfNotReorganizing();
    maybeQueueOnWalletChanged();
    saveLater();
  }
  finally {
    lock.unlock();
  }
}",0.9728203318037416
85764,"@Test public void pending1() throws Exception {
  final BigInteger nanos=Utils.toNanoCoins(1,0);
  final Transaction t1=createFakeTx(params,nanos,myAddress);
  final boolean[] flags=new boolean[2];
  final Transaction[] notifiedTx=new Transaction[1];
  final int[] walletChanged=new int[1];
  wallet.addEventListener(new AbstractWalletEventListener(){
    @Override public void onCoinsReceived(    Wallet wallet,    Transaction tx,    BigInteger prevBalance,    BigInteger newBalance){
      assertEquals(tx,t1);
      assertEquals(prevBalance,BigInteger.ZERO);
      assertEquals(newBalance,nanos);
      flags[0]=true;
      flags[1]=tx.isPending();
      notifiedTx[0]=tx;
    }
    @Override public void onWalletChanged(    Wallet wallet){
      walletChanged[0]++;
    }
  }
);
  if (wallet.isPendingTransactionRelevant(t1))   wallet.receivePending(t1,null);
  Threading.waitForUserCode();
  assertTrue(flags[0]);
  assertTrue(flags[1]);
  flags[0]=false;
  assertFalse(wallet.isPendingTransactionRelevant(t1));
  assertFalse(flags[0]);
  flags[0]=flags[1]=false;
  notifiedTx[0].getConfidence().addEventListener(new TransactionConfidence.Listener(){
    public void onConfidenceChanged(    Transaction tx,    TransactionConfidence.Listener.ChangeReason reason){
      flags[1]=true;
    }
  }
);
  assertEquals(TransactionConfidence.ConfidenceType.PENDING,notifiedTx[0].getConfidence().getConfidenceType());
  final Transaction t1Copy=new Transaction(params,t1.bitcoinSerialize());
  sendMoneyToWallet(t1Copy,AbstractBlockChain.NewBlockType.BEST_CHAIN);
  Threading.waitForUserCode();
  assertFalse(flags[0]);
  assertTrue(flags[1]);
  assertEquals(TransactionConfidence.ConfidenceType.BUILDING,notifiedTx[0].getConfidence().getConfidenceType());
  flags[0]=false;
  flags[1]=false;
  Transaction irrelevant=createFakeTx(params,nanos,new ECKey().toAddress(params));
  if (wallet.isPendingTransactionRelevant(irrelevant))   wallet.receivePending(irrelevant,null);
  Threading.waitForUserCode();
  assertFalse(flags[0]);
  assertEquals(2,walletChanged[0]);
}","@Test public void pending1() throws Exception {
  final BigInteger nanos=Utils.toNanoCoins(1,0);
  final Transaction t1=createFakeTx(params,nanos,myAddress);
  final boolean[] flags=new boolean[2];
  final Transaction[] notifiedTx=new Transaction[1];
  final int[] walletChanged=new int[1];
  wallet.addEventListener(new AbstractWalletEventListener(){
    @Override public void onCoinsReceived(    Wallet wallet,    Transaction tx,    BigInteger prevBalance,    BigInteger newBalance){
      assertEquals(tx,t1);
      assertEquals(prevBalance,BigInteger.ZERO);
      assertEquals(newBalance,nanos);
      flags[0]=true;
      flags[1]=tx.isPending();
      notifiedTx[0]=tx;
    }
    @Override public void onWalletChanged(    Wallet wallet){
      walletChanged[0]++;
    }
  }
);
  if (wallet.isPendingTransactionRelevant(t1))   wallet.receivePending(t1,null);
  Threading.waitForUserCode();
  assertTrue(flags[0]);
  assertTrue(flags[1]);
  flags[0]=false;
  assertFalse(wallet.isPendingTransactionRelevant(t1));
  assertFalse(flags[0]);
  flags[0]=flags[1]=false;
  final TransactionConfidence.Listener.ChangeReason[] reasons=new TransactionConfidence.Listener.ChangeReason[1];
  notifiedTx[0].getConfidence().addEventListener(new TransactionConfidence.Listener(){
    public void onConfidenceChanged(    Transaction tx,    TransactionConfidence.Listener.ChangeReason reason){
      flags[1]=true;
      reasons[0]=reason;
    }
  }
);
  assertEquals(TransactionConfidence.ConfidenceType.PENDING,notifiedTx[0].getConfidence().getConfidenceType());
  wallet.notifyNewBestBlock(createFakeBlock(blockStore).storedBlock);
  Threading.waitForUserCode();
  assertNull(reasons[0]);
  final Transaction t1Copy=new Transaction(params,t1.bitcoinSerialize());
  sendMoneyToWallet(t1Copy,AbstractBlockChain.NewBlockType.BEST_CHAIN);
  Threading.waitForUserCode();
  assertFalse(flags[0]);
  assertTrue(flags[1]);
  assertEquals(TransactionConfidence.ConfidenceType.BUILDING,notifiedTx[0].getConfidence().getConfidenceType());
  flags[0]=false;
  flags[1]=false;
  Transaction irrelevant=createFakeTx(params,nanos,new ECKey().toAddress(params));
  if (wallet.isPendingTransactionRelevant(irrelevant))   wallet.receivePending(irrelevant,null);
  Threading.waitForUserCode();
  assertFalse(flags[0]);
  assertEquals(3,walletChanged[0]);
}",0.9389521640091116
85765,"public void onConfidenceChanged(Transaction tx,TransactionConfidence.Listener.ChangeReason reason){
  flags[1]=true;
}","public void onConfidenceChanged(Transaction tx,TransactionConfidence.Listener.ChangeReason reason){
  flags[1]=true;
  reasons[0]=reason;
}",0.9182879377431906
85766,"@Test public void basicTimeoutTest() throws Exception {
  final SettableFuture<Void> serverConnection1Open=SettableFuture.create();
  final SettableFuture<Void> clientConnection1Open=SettableFuture.create();
  final SettableFuture<Void> serverConnection1Closed=SettableFuture.create();
  final SettableFuture<Void> clientConnection1Closed=SettableFuture.create();
  final SettableFuture<Void> serverConnection2Open=SettableFuture.create();
  final SettableFuture<Void> clientConnection2Open=SettableFuture.create();
  final SettableFuture<Void> serverConnection2Closed=SettableFuture.create();
  final SettableFuture<Void> clientConnection2Closed=SettableFuture.create();
  NioServer server=new NioServer(new StreamParserFactory(){
    @Override public ProtobufParser getNewParser(    InetAddress inetAddress,    int port){
      return new ProtobufParser<Protos.TwoWayChannelMessage>(new ProtobufParser.Listener<Protos.TwoWayChannelMessage>(){
        @Override public void messageReceived(        ProtobufParser handler,        Protos.TwoWayChannelMessage msg){
          fail.set(true);
        }
        @Override public synchronized void connectionOpen(        ProtobufParser handler){
          if (serverConnection1Open.isDone()) {
            handler.setSocketTimeout(0);
            serverConnection2Open.set(null);
          }
 else           serverConnection1Open.set(null);
        }
        @Override public synchronized void connectionClosed(        ProtobufParser handler){
          if (serverConnection1Closed.isDone()) {
            serverConnection2Closed.set(null);
          }
 else           serverConnection1Closed.set(null);
        }
      }
,Protos.TwoWayChannelMessage.getDefaultInstance(),1000,10);
    }
  }
);
  server.start(new InetSocketAddress(""String_Node_Str"",4243));
  new NioClient(new InetSocketAddress(""String_Node_Str"",4243),new ProtobufParser<Protos.TwoWayChannelMessage>(new ProtobufParser.Listener<Protos.TwoWayChannelMessage>(){
    @Override public void messageReceived(    ProtobufParser handler,    Protos.TwoWayChannelMessage msg){
      fail.set(true);
    }
    @Override public void connectionOpen(    ProtobufParser handler){
      clientConnection1Open.set(null);
    }
    @Override public void connectionClosed(    ProtobufParser handler){
      clientConnection1Closed.set(null);
    }
  }
,Protos.TwoWayChannelMessage.getDefaultInstance(),1000,0),0);
  clientConnection1Open.get();
  serverConnection1Open.get();
  Thread.sleep(15);
  assertTrue(clientConnection1Closed.isDone() && serverConnection1Closed.isDone());
  ProtobufParser<Protos.TwoWayChannelMessage> client2Handler=new ProtobufParser<Protos.TwoWayChannelMessage>(new ProtobufParser.Listener<Protos.TwoWayChannelMessage>(){
    @Override public void messageReceived(    ProtobufParser handler,    Protos.TwoWayChannelMessage msg){
      fail.set(true);
    }
    @Override public void connectionOpen(    ProtobufParser handler){
      clientConnection2Open.set(null);
    }
    @Override public void connectionClosed(    ProtobufParser handler){
      clientConnection2Closed.set(null);
    }
  }
,Protos.TwoWayChannelMessage.getDefaultInstance(),1000,0);
  NioClient client2=new NioClient(new InetSocketAddress(""String_Node_Str"",4243),client2Handler,0);
  clientConnection2Open.get();
  serverConnection2Open.get();
  Thread.sleep(15);
  assertFalse(clientConnection2Closed.isDone() || serverConnection2Closed.isDone());
  client2Handler.setSocketTimeout(10);
  Thread.sleep(15);
  assertTrue(clientConnection2Closed.isDone() && serverConnection2Closed.isDone());
  server.stop();
}","@Test public void basicTimeoutTest() throws Exception {
  final SettableFuture<Void> serverConnection1Open=SettableFuture.create();
  final SettableFuture<Void> clientConnection1Open=SettableFuture.create();
  final SettableFuture<Void> serverConnection1Closed=SettableFuture.create();
  final SettableFuture<Void> clientConnection1Closed=SettableFuture.create();
  final SettableFuture<Void> serverConnection2Open=SettableFuture.create();
  final SettableFuture<Void> clientConnection2Open=SettableFuture.create();
  final SettableFuture<Void> serverConnection2Closed=SettableFuture.create();
  final SettableFuture<Void> clientConnection2Closed=SettableFuture.create();
  NioServer server=new NioServer(new StreamParserFactory(){
    @Override public ProtobufParser getNewParser(    InetAddress inetAddress,    int port){
      return new ProtobufParser<Protos.TwoWayChannelMessage>(new ProtobufParser.Listener<Protos.TwoWayChannelMessage>(){
        @Override public void messageReceived(        ProtobufParser handler,        Protos.TwoWayChannelMessage msg){
          fail.set(true);
        }
        @Override public synchronized void connectionOpen(        ProtobufParser handler){
          if (serverConnection1Open.isDone()) {
            handler.setSocketTimeout(0);
            serverConnection2Open.set(null);
          }
 else           serverConnection1Open.set(null);
        }
        @Override public synchronized void connectionClosed(        ProtobufParser handler){
          if (serverConnection1Closed.isDone()) {
            serverConnection2Closed.set(null);
          }
 else           serverConnection1Closed.set(null);
        }
      }
,Protos.TwoWayChannelMessage.getDefaultInstance(),1000,10);
    }
  }
);
  server.start(new InetSocketAddress(""String_Node_Str"",4243));
  new NioClient(new InetSocketAddress(""String_Node_Str"",4243),new ProtobufParser<Protos.TwoWayChannelMessage>(new ProtobufParser.Listener<Protos.TwoWayChannelMessage>(){
    @Override public void messageReceived(    ProtobufParser handler,    Protos.TwoWayChannelMessage msg){
      fail.set(true);
    }
    @Override public void connectionOpen(    ProtobufParser handler){
      clientConnection1Open.set(null);
    }
    @Override public void connectionClosed(    ProtobufParser handler){
      clientConnection1Closed.set(null);
    }
  }
,Protos.TwoWayChannelMessage.getDefaultInstance(),1000,0),0);
  clientConnection1Open.get();
  serverConnection1Open.get();
  long closeDelayStart=System.currentTimeMillis();
  clientConnection1Closed.get();
  serverConnection1Closed.get();
  long closeDelayFinish=System.currentTimeMillis();
  ProtobufParser<Protos.TwoWayChannelMessage> client2Handler=new ProtobufParser<Protos.TwoWayChannelMessage>(new ProtobufParser.Listener<Protos.TwoWayChannelMessage>(){
    @Override public void messageReceived(    ProtobufParser handler,    Protos.TwoWayChannelMessage msg){
      fail.set(true);
    }
    @Override public void connectionOpen(    ProtobufParser handler){
      clientConnection2Open.set(null);
    }
    @Override public void connectionClosed(    ProtobufParser handler){
      clientConnection2Closed.set(null);
    }
  }
,Protos.TwoWayChannelMessage.getDefaultInstance(),1000,0);
  NioClient client2=new NioClient(new InetSocketAddress(""String_Node_Str"",4243),client2Handler,0);
  clientConnection2Open.get();
  serverConnection2Open.get();
  Thread.sleep((closeDelayFinish - closeDelayStart) * 10);
  assertFalse(clientConnection2Closed.isDone() || serverConnection2Closed.isDone());
  client2Handler.setSocketTimeout(10);
  clientConnection2Closed.get();
  serverConnection2Closed.get();
  server.stop();
}",0.9331499312242092
85767,"/** 
 * <p>Link the given wallet to this PeerGroup. This is used for three purposes:</p> <ol> <li>So the wallet receives broadcast transactions.</li> <li>Announcing pending transactions that didn't get into the chain yet to our peers.</li> <li>Set the fast catchup time using   {@link PeerGroup#setFastCatchupTimeSecs(long)}, to optimize chain download.</li> </ol> <p>Note that this should be done before chain download commences because if you add a wallet with keys earlier than the current chain head, the relevant parts of the chain won't be redownloaded for you.</p> <p>The Wallet will have an event listener registered on it, so to avoid leaks remember to use  {@link PeerGroup#removeWallet(Wallet)} on it if you wish to keep the Wallet but lose the PeerGroup.</p>
 */
public void addWallet(Wallet wallet){
  lock.lock();
  try {
    checkNotNull(wallet);
    checkState(!wallets.contains(wallet));
    wallets.add(wallet);
    wallet.setTransactionBroadcaster(this);
    announcePendingWalletTransactions(Collections.singletonList(wallet),peers);
    wallet.addEventListener(walletEventListener);
    addPeerFilterProvider(wallet);
  }
  finally {
    lock.unlock();
  }
}","/** 
 * <p>Link the given wallet to this PeerGroup. This is used for three purposes:</p> <ol> <li>So the wallet receives broadcast transactions.</li> <li>Announcing pending transactions that didn't get into the chain yet to our peers.</li> <li>Set the fast catchup time using   {@link PeerGroup#setFastCatchupTimeSecs(long)}, to optimize chain download.</li> </ol> <p>Note that this should be done before chain download commences because if you add a wallet with keys earlier than the current chain head, the relevant parts of the chain won't be redownloaded for you.</p> <p>The Wallet will have an event listener registered on it, so to avoid leaks remember to use  {@link PeerGroup#removeWallet(Wallet)} on it if you wish to keep the Wallet but lose the PeerGroup.</p>
 */
public void addWallet(Wallet wallet){
  lock.lock();
  try {
    checkNotNull(wallet);
    checkState(!wallets.contains(wallet));
    wallets.add(wallet);
    wallet.setTransactionBroadcaster(this);
    wallet.addEventListener(walletEventListener);
    addPeerFilterProvider(wallet);
  }
  finally {
    lock.unlock();
  }
}",0.9648814749780508
85768,"protected void handleNewPeer(final Peer peer){
  int newSize=-1;
  lock.lock();
  try {
    log.info(""String_Node_Str"",peer);
    pendingPeers.remove(peer);
    peers.add(peer);
    newSize=peers.size();
    try {
      if (bloomFilter != null)       peer.setBloomFilter(bloomFilter);
    }
 catch (    IOException e) {
    }
    peer.setDownloadData(false);
    for (    Wallet wallet : wallets)     peer.addWallet(wallet);
    Peer newDownloadPeer=selectDownloadPeer(peers);
    if (downloadPeer != newDownloadPeer) {
      setDownloadPeer(newDownloadPeer);
      boolean shouldDownloadChain=downloadListener != null && chain != null;
      if (shouldDownloadChain) {
        startBlockChainDownloadFromPeer(downloadPeer);
      }
    }
    peer.addEventListener(getDataListener,Threading.SAME_THREAD);
    announcePendingWalletTransactions(wallets,Collections.singletonList(peer));
    for (    ListenerRegistration<PeerEventListener> registration : peerEventListeners) {
      peer.addEventListener(registration.listener,registration.executor);
    }
    setupPingingForNewPeer(peer);
  }
  finally {
    lock.unlock();
  }
  final int fNewSize=newSize;
  for (  final ListenerRegistration<PeerEventListener> registration : peerEventListeners) {
    registration.executor.execute(new Runnable(){
      @Override public void run(){
        registration.listener.onPeerConnected(peer,fNewSize);
      }
    }
);
  }
}","protected void handleNewPeer(final Peer peer){
  int newSize=-1;
  lock.lock();
  try {
    log.info(""String_Node_Str"",peer);
    pendingPeers.remove(peer);
    peers.add(peer);
    newSize=peers.size();
    try {
      if (bloomFilter != null)       peer.setBloomFilter(bloomFilter);
    }
 catch (    IOException e) {
    }
    peer.setDownloadData(false);
    for (    Wallet wallet : wallets)     peer.addWallet(wallet);
    Peer newDownloadPeer=selectDownloadPeer(peers);
    if (downloadPeer != newDownloadPeer) {
      setDownloadPeer(newDownloadPeer);
      boolean shouldDownloadChain=downloadListener != null && chain != null;
      if (shouldDownloadChain) {
        startBlockChainDownloadFromPeer(downloadPeer);
      }
    }
    peer.addEventListener(getDataListener,Threading.SAME_THREAD);
    for (    ListenerRegistration<PeerEventListener> registration : peerEventListeners) {
      peer.addEventListener(registration.listener,registration.executor);
    }
    setupPingingForNewPeer(peer);
  }
  finally {
    lock.unlock();
  }
  final int fNewSize=newSize;
  for (  final ListenerRegistration<PeerEventListener> registration : peerEventListeners) {
    registration.executor.execute(new Runnable(){
      @Override public void run(){
        registration.listener.onPeerConnected(peer,fNewSize);
      }
    }
);
  }
}",0.9709934735315446
85769,"/** 
 * Unlinks the given wallet so it no longer receives broadcast transactions or has its transactions announced.
 */
public void removeWallet(Wallet wallet){
  wallets.remove(checkNotNull(wallet));
  peerFilterProviders.remove(wallet);
  wallet.removeEventListener(walletEventListener);
}","/** 
 * Unlinks the given wallet so it no longer receives broadcast transactions or has its transactions announced.
 */
public void removeWallet(Wallet wallet){
  wallets.remove(checkNotNull(wallet));
  peerFilterProviders.remove(wallet);
  wallet.removeEventListener(walletEventListener);
  wallet.setTransactionBroadcaster(null);
}",0.9326923076923076
85770,"/** 
 * <p>Specifies that the given   {@link TransactionBroadcaster}, typically a   {@link PeerGroup}, should be used for sending transactions to the Bitcoin network by default. Some sendCoins methods let you specify a broadcaster explicitly, in that case, they don't use this broadcaster. If null is specified then the wallet won't attempt to broadcast transactions itself.</p> <p>You don't normally need to call this. A   {@link PeerGroup} will automatically set itself as the walletsbroadcaster when you use  {@link PeerGroup#addWallet(Wallet)}. A wallet can use the broadcaster when you ask it to send money, but in future also at other times to implement various features that may require asynchronous re-organisation of the wallet contents on the block chain. For instance, in future the wallet may choose to optimise itself to reduce fees or improve privacy.</p>
 */
public void setTransactionBroadcaster(@Nullable com.google.bitcoin.core.TransactionBroadcaster broadcaster){
  vTransactionBroadcaster=broadcaster;
}","/** 
 * <p>Specifies that the given   {@link TransactionBroadcaster}, typically a   {@link PeerGroup}, should be used for sending transactions to the Bitcoin network by default. Some sendCoins methods let you specify a broadcaster explicitly, in that case, they don't use this broadcaster. If null is specified then the wallet won't attempt to broadcast transactions itself.</p> <p>You don't normally need to call this. A   {@link PeerGroup} will automatically set itself as the walletsbroadcaster when you use  {@link PeerGroup#addWallet(Wallet)}. A wallet can use the broadcaster when you ask it to send money, but in future also at other times to implement various features that may require asynchronous re-organisation of the wallet contents on the block chain. For instance, in future the wallet may choose to optimise itself to reduce fees or improve privacy.</p>
 */
public void setTransactionBroadcaster(@Nullable com.google.bitcoin.core.TransactionBroadcaster broadcaster){
  lock.lock();
  try {
    if (vTransactionBroadcaster == broadcaster)     return;
    vTransactionBroadcaster=broadcaster;
    if (broadcaster == null)     return;
    for (    Transaction tx : pending.values()) {
      checkState(tx.getConfidence().getConfidenceType() == ConfidenceType.PENDING);
      if (tx.getConfidence().numBroadcastPeers() == 0) {
        log.info(""String_Node_Str"",tx.getHash());
        broadcaster.broadcastTransaction(tx);
      }
    }
  }
  finally {
    lock.unlock();
  }
}",0.8057324840764332
85771,"@Test public void announce() throws Exception {
  FakeChannel p1=connectPeer(1,new VersionMessage(params,2));
  FakeChannel p2=connectPeer(2);
  assertNotNull(peerGroup.getDownloadPeer());
  control.replay();
  peerGroup.setMinBroadcastConnections(2);
  Block b1=TestUtils.makeSolvedTestBlock(blockStore,address);
  inbound(p1,b1);
  assertNull(outbound(p1));
  assertEquals(Utils.toNanoCoins(50,0),wallet.getBalance());
  final Transaction[] transactions=new Transaction[1];
  wallet.addEventListener(new AbstractWalletEventListener(){
    @Override public void onTransactionConfidenceChanged(    Wallet wallet,    Transaction tx){
      transactions[0]=tx;
    }
  }
);
  Address dest=new ECKey().toAddress(params);
  Wallet.SendResult sendResult=wallet.sendCoins(peerGroup,dest,Utils.toNanoCoins(1,0));
  assertNotNull(sendResult.tx);
  Threading.waitForUserCode();
  assertFalse(sendResult.broadcastComplete.isDone());
  assertEquals(transactions[0],sendResult.tx);
  assertEquals(transactions[0].getConfidence().numBroadcastPeers(),1);
  transactions[0]=null;
  Transaction t1=(Transaction)outbound(p1);
  assertNotNull(t1);
  assertEquals(Utils.toNanoCoins(49,0),t1.getValueSentToMe(wallet));
  InventoryMessage inv=new InventoryMessage(params);
  inv.addTransaction(t1);
  inbound(p2,inv);
  Threading.waitForUserCode();
  assertTrue(sendResult.broadcastComplete.isDone());
  assertEquals(transactions[0],sendResult.tx);
  assertEquals(transactions[0].getConfidence().numBroadcastPeers(),2);
  Block b2=TestUtils.createFakeBlock(blockStore,t1).block;
  inbound(p1,b2);
  assertNull(outbound(p1));
  peerGroup.removeWallet(wallet);
  Wallet.SendRequest req=Wallet.SendRequest.to(dest,Utils.toNanoCoins(2,0));
  req.ensureMinRequiredFee=false;
  Transaction t3=wallet.sendCoinsOffline(req);
  assertNull(outbound(p1));
  peerGroup.addWallet(wallet);
  InventoryMessage inv1=(InventoryMessage)outbound(p1);
  assertEquals(t3.getHash(),inv1.getItems().get(0).hash);
  GetDataMessage getdata=new GetDataMessage(params);
  getdata.addItem(inv1.getItems().get(0));
  inbound(p1,getdata);
  Transaction t4=(Transaction)outbound(p1);
  assertEquals(t3,t4);
  FakeChannel p3=connectPeer(3);
  assertTrue(outbound(p3) instanceof InventoryMessage);
  control.verify();
}","@Test public void announce() throws Exception {
  FakeChannel p1=connectPeer(1,new VersionMessage(params,2));
  FakeChannel p2=connectPeer(2);
  assertNotNull(peerGroup.getDownloadPeer());
  control.replay();
  peerGroup.setMinBroadcastConnections(2);
  Block b1=TestUtils.makeSolvedTestBlock(blockStore,address);
  inbound(p1,b1);
  assertNull(outbound(p1));
  assertEquals(Utils.toNanoCoins(50,0),wallet.getBalance());
  final Transaction[] transactions=new Transaction[1];
  wallet.addEventListener(new AbstractWalletEventListener(){
    @Override public void onTransactionConfidenceChanged(    Wallet wallet,    Transaction tx){
      transactions[0]=tx;
    }
  }
);
  Address dest=new ECKey().toAddress(params);
  Wallet.SendResult sendResult=wallet.sendCoins(peerGroup,dest,Utils.toNanoCoins(1,0));
  assertNotNull(sendResult.tx);
  Threading.waitForUserCode();
  assertFalse(sendResult.broadcastComplete.isDone());
  assertEquals(transactions[0],sendResult.tx);
  assertEquals(transactions[0].getConfidence().numBroadcastPeers(),1);
  transactions[0]=null;
  Transaction t1=(Transaction)outbound(p1);
  assertNotNull(t1);
  assertEquals(Utils.toNanoCoins(49,0),t1.getValueSentToMe(wallet));
  InventoryMessage inv=new InventoryMessage(params);
  inv.addTransaction(t1);
  inbound(p2,inv);
  Threading.waitForUserCode();
  assertTrue(sendResult.broadcastComplete.isDone());
  assertEquals(transactions[0],sendResult.tx);
  assertEquals(2,transactions[0].getConfidence().numBroadcastPeers());
  Block b2=TestUtils.createFakeBlock(blockStore,t1).block;
  inbound(p1,b2);
  assertNull(outbound(p1));
  peerGroup.removeWallet(wallet);
  Wallet.SendRequest req=Wallet.SendRequest.to(dest,Utils.toNanoCoins(2,0));
  req.ensureMinRequiredFee=false;
  Transaction t3=checkNotNull(wallet.sendCoinsOffline(req));
  assertNull(outbound(p1));
  peerGroup.addWallet(wallet);
  assertEquals(t3.getHash(),((Transaction)outbound(p1)).getHash());
}",0.8998334522959791
85772,"public static void main(String[] args) throws Exception {
  OptionParser parser=new OptionParser();
  parser.accepts(""String_Node_Str"");
  parser.accepts(""String_Node_Str"");
  parser.accepts(""String_Node_Str"");
  walletFileName=parser.accepts(""String_Node_Str"").withRequiredArg().defaultsTo(""String_Node_Str"");
  actionFlag=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(ActionEnum.class);
  netFlag=parser.accepts(""String_Node_Str"").withOptionalArg().ofType(NetworkEnum.class).defaultsTo(NetworkEnum.PROD);
  dateFlag=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(Date.class).withValuesConvertedBy(DateConverter.datePattern(""String_Node_Str""));
  waitForFlag=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(WaitForEnum.class);
  modeFlag=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(ValidationMode.class).defaultsTo(ValidationMode.SPV);
  OptionSpec<String> chainFlag=parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  OptionSpec<String> outputFlag=parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  unixtimeFlag=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(Integer.class);
  conditionFlag=parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"");
  OptionSpec<String> passwordFlag=parser.accepts(""String_Node_Str"").withRequiredArg();
  options=parser.parse(args);
  if (args.length == 0 || options.has(""String_Node_Str"") || options.nonOptionArguments().size() > 0) {
    System.out.println(HELP_TEXT);
    return;
  }
  if (options.has(""String_Node_Str"")) {
    BriefLogFormatter.init();
    log.info(""String_Node_Str"");
  }
 else {
    logger=LogManager.getLogManager().getLogger(""String_Node_Str"");
    logger.setLevel(Level.SEVERE);
  }
switch (netFlag.value(options)) {
case PROD:
    params=MainNetParams.get();
  chainFileName=new File(""String_Node_Str"");
break;
case TEST:
params=TestNet3Params.get();
chainFileName=new File(""String_Node_Str"");
break;
case REGTEST:
params=RegTestParams.get();
chainFileName=new File(""String_Node_Str"");
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
mode=modeFlag.value(options);
if (options.has(chainFlag)) {
chainFileName=new File(chainFlag.value(options));
}
if (options.has(""String_Node_Str"")) {
condition=new Condition(conditionFlag.value(options));
}
if (options.has(passwordFlag)) {
password=passwordFlag.value(options);
}
ActionEnum action=ActionEnum.NONE;
if (options.has(actionFlag)) action=actionFlag.value(options);
walletFile=new File(walletFileName.value(options));
if (action == ActionEnum.CREATE) {
createWallet(options,params,walletFile);
return;
}
if (!walletFile.exists()) {
System.err.println(""String_Node_Str"" + walletFile + ""String_Node_Str"");
return;
}
if (action == ActionEnum.RAW_DUMP) {
FileInputStream stream=new FileInputStream(walletFile);
try {
Protos.Wallet proto=WalletProtobufSerializer.parseToProto(stream);
System.out.println(proto.toString());
return;
}
  finally {
stream.close();
}
}
try {
WalletProtobufSerializer loader=new WalletProtobufSerializer();
wallet=loader.readWallet(new BufferedInputStream(new FileInputStream(walletFile)));
if (!wallet.getParams().equals(params)) {
System.err.println(""String_Node_Str"" + wallet.getParams().getId() + ""String_Node_Str""+ params.getId());
return;
}
}
 catch (Exception e) {
System.err.println(""String_Node_Str"" + walletFile + ""String_Node_Str""+ e.getMessage());
e.printStackTrace();
return;
}
switch (action) {
case DUMP:
dumpWallet();
break;
case ADD_KEY:
addKey();
break;
case DELETE_KEY:
deleteKey();
break;
case RESET:
reset();
break;
case SYNC:
syncChain();
break;
case SEND:
if (!options.has(outputFlag)) {
System.err.println(""String_Node_Str"");
return;
}
BigInteger fee=BigInteger.ZERO;
if (options.has(""String_Node_Str"")) {
fee=Utils.toNanoCoins((String)options.valueOf(""String_Node_Str""));
}
String lockTime=null;
if (options.has(""String_Node_Str"")) {
lockTime=(String)options.valueOf(""String_Node_Str"");
}
boolean allowUnconfirmed=options.has(""String_Node_Str"");
send(outputFlag.values(options),fee,lockTime,allowUnconfirmed);
break;
}
if (!wallet.isConsistent()) {
System.err.println(""String_Node_Str"");
return;
}
saveWallet(walletFile);
if (options.has(waitForFlag)) {
WaitForEnum value;
try {
value=waitForFlag.value(options);
}
 catch (Exception e) {
System.err.println(""String_Node_Str"" + ""String_Node_Str"");
return;
}
wait(value);
if (!wallet.isConsistent()) {
System.err.println(""String_Node_Str"");
return;
}
saveWallet(walletFile);
}
shutdown();
}","public static void main(String[] args) throws Exception {
  OptionParser parser=new OptionParser();
  parser.accepts(""String_Node_Str"");
  parser.accepts(""String_Node_Str"");
  parser.accepts(""String_Node_Str"");
  walletFileName=parser.accepts(""String_Node_Str"").withRequiredArg().defaultsTo(""String_Node_Str"");
  actionFlag=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(ActionEnum.class);
  netFlag=parser.accepts(""String_Node_Str"").withOptionalArg().ofType(NetworkEnum.class).defaultsTo(NetworkEnum.PROD);
  dateFlag=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(Date.class).withValuesConvertedBy(DateConverter.datePattern(""String_Node_Str""));
  waitForFlag=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(WaitForEnum.class);
  modeFlag=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(ValidationMode.class).defaultsTo(ValidationMode.SPV);
  OptionSpec<String> chainFlag=parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  OptionSpec<String> outputFlag=parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  unixtimeFlag=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(Integer.class);
  conditionFlag=parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"");
  parser.accepts(""String_Node_Str"");
  OptionSpec<String> passwordFlag=parser.accepts(""String_Node_Str"").withRequiredArg();
  options=parser.parse(args);
  if (args.length == 0 || options.has(""String_Node_Str"") || options.nonOptionArguments().size() > 0) {
    System.out.println(HELP_TEXT);
    return;
  }
  if (options.has(""String_Node_Str"")) {
    BriefLogFormatter.init();
    log.info(""String_Node_Str"");
  }
 else {
    logger=LogManager.getLogManager().getLogger(""String_Node_Str"");
    logger.setLevel(Level.SEVERE);
  }
switch (netFlag.value(options)) {
case PROD:
    params=MainNetParams.get();
  chainFileName=new File(""String_Node_Str"");
break;
case TEST:
params=TestNet3Params.get();
chainFileName=new File(""String_Node_Str"");
break;
case REGTEST:
params=RegTestParams.get();
chainFileName=new File(""String_Node_Str"");
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
mode=modeFlag.value(options);
if (options.has(chainFlag)) {
chainFileName=new File(chainFlag.value(options));
}
if (options.has(""String_Node_Str"")) {
condition=new Condition(conditionFlag.value(options));
}
if (options.has(passwordFlag)) {
password=passwordFlag.value(options);
}
ActionEnum action=ActionEnum.NONE;
if (options.has(actionFlag)) action=actionFlag.value(options);
walletFile=new File(walletFileName.value(options));
if (action == ActionEnum.CREATE) {
createWallet(options,params,walletFile);
return;
}
if (!walletFile.exists()) {
System.err.println(""String_Node_Str"" + walletFile + ""String_Node_Str"");
return;
}
if (action == ActionEnum.RAW_DUMP) {
FileInputStream stream=new FileInputStream(walletFile);
try {
Protos.Wallet proto=WalletProtobufSerializer.parseToProto(stream);
System.out.println(proto.toString());
return;
}
  finally {
stream.close();
}
}
try {
WalletProtobufSerializer loader=new WalletProtobufSerializer();
wallet=loader.readWallet(new BufferedInputStream(new FileInputStream(walletFile)));
if (!wallet.getParams().equals(params)) {
System.err.println(""String_Node_Str"" + wallet.getParams().getId() + ""String_Node_Str""+ params.getId());
return;
}
}
 catch (Exception e) {
System.err.println(""String_Node_Str"" + walletFile + ""String_Node_Str""+ e.getMessage());
e.printStackTrace();
return;
}
switch (action) {
case DUMP:
dumpWallet();
break;
case ADD_KEY:
addKey();
break;
case DELETE_KEY:
deleteKey();
break;
case RESET:
reset();
break;
case SYNC:
syncChain();
break;
case SEND:
if (!options.has(outputFlag)) {
System.err.println(""String_Node_Str"");
return;
}
BigInteger fee=BigInteger.ZERO;
if (options.has(""String_Node_Str"")) {
fee=Utils.toNanoCoins((String)options.valueOf(""String_Node_Str""));
}
String lockTime=null;
if (options.has(""String_Node_Str"")) {
lockTime=(String)options.valueOf(""String_Node_Str"");
}
boolean allowUnconfirmed=options.has(""String_Node_Str"");
send(outputFlag.values(options),fee,lockTime,allowUnconfirmed);
break;
}
if (!wallet.isConsistent()) {
System.err.println(""String_Node_Str"");
return;
}
saveWallet(walletFile);
if (options.has(waitForFlag)) {
WaitForEnum value;
try {
value=waitForFlag.value(options);
}
 catch (Exception e) {
System.err.println(""String_Node_Str"" + ""String_Node_Str"");
return;
}
wait(value);
if (!wallet.isConsistent()) {
System.err.println(""String_Node_Str"");
return;
}
saveWallet(walletFile);
}
shutdown();
}",0.9962379257752924
85773,"private static void send(List<String> outputs,BigInteger fee,String lockTimeStr,boolean allowUnconfirmed){
  try {
    Transaction t=new Transaction(params);
    for (    String spec : outputs) {
      String[] parts=spec.split(""String_Node_Str"");
      if (parts.length != 2) {
        System.err.println(""String_Node_Str"");
        return;
      }
      String destination=parts[0];
      try {
        BigInteger value=Utils.toNanoCoins(parts[1]);
        if (destination.startsWith(""String_Node_Str"") && (destination.length() == 130 || destination.length() == 66)) {
          BigInteger pubKey=new BigInteger(destination,16);
          ECKey key=new ECKey(null,pubKey);
          t.addOutput(value,key);
        }
 else {
          Address addr=new Address(params,destination);
          t.addOutput(value,addr);
        }
      }
 catch (      WrongNetworkException e) {
        System.err.println(""String_Node_Str"" + parts[0]);
        return;
      }
catch (      AddressFormatException e) {
        System.err.println(""String_Node_Str"" + parts[0]);
        return;
      }
catch (      NumberFormatException e) {
        System.err.println(""String_Node_Str"" + parts[1]);
      }
    }
    Wallet.SendRequest req=Wallet.SendRequest.forTx(t);
    if (t.getOutputs().size() == 1 && t.getOutput(0).getValue().equals(wallet.getBalance())) {
      log.info(""String_Node_Str"");
      req.emptyWallet=true;
    }
    req.fee=fee;
    if (allowUnconfirmed) {
      wallet.allowSpendingUnconfirmedTransactions();
    }
    if (password != null) {
      if (!wallet.checkPassword(password)) {
        System.err.println(""String_Node_Str"");
        return;
      }
      req.aesKey=wallet.getKeyCrypter().deriveKey(password);
    }
    if (!wallet.completeTx(req)) {
      System.err.println(""String_Node_Str"" + Utils.bitcoinValueToFriendlyString(wallet.getBalance()));
      return;
    }
    try {
      if (lockTimeStr != null) {
        t.setLockTime(Transaction.parseLockTimeStr(lockTimeStr));
        t.getInputs().get(0).setSequenceNumber(0);
        t.signInputs(Transaction.SigHash.ALL,wallet);
      }
    }
 catch (    ParseException e) {
      System.err.println(""String_Node_Str"" + lockTimeStr);
      return;
    }
catch (    ScriptException e) {
      throw new RuntimeException(e);
    }
catch (    KeyCrypterException e) {
      throw new RuntimeException(e);
    }
    t=req.tx;
    setup();
    peers.startAndWait();
    peers.broadcastTransaction(t).get();
    if (peers.getMinBroadcastConnections() == 1) {
      Thread.sleep(5000);
    }
    System.out.println(t.getHashAsString());
  }
 catch (  BlockStoreException e) {
    throw new RuntimeException(e);
  }
catch (  KeyCrypterException e) {
    throw new RuntimeException(e);
  }
catch (  InterruptedException e) {
    throw new RuntimeException(e);
  }
catch (  ExecutionException e) {
    throw new RuntimeException(e);
  }
}","private static void send(List<String> outputs,BigInteger fee,String lockTimeStr,boolean allowUnconfirmed) throws VerificationException {
  try {
    Transaction t=new Transaction(params);
    for (    String spec : outputs) {
      String[] parts=spec.split(""String_Node_Str"");
      if (parts.length != 2) {
        System.err.println(""String_Node_Str"");
        return;
      }
      String destination=parts[0];
      try {
        BigInteger value=Utils.toNanoCoins(parts[1]);
        if (destination.startsWith(""String_Node_Str"") && (destination.length() == 130 || destination.length() == 66)) {
          BigInteger pubKey=new BigInteger(destination,16);
          ECKey key=new ECKey(null,pubKey);
          t.addOutput(value,key);
        }
 else {
          Address addr=new Address(params,destination);
          t.addOutput(value,addr);
        }
      }
 catch (      WrongNetworkException e) {
        System.err.println(""String_Node_Str"" + parts[0]);
        return;
      }
catch (      AddressFormatException e) {
        System.err.println(""String_Node_Str"" + parts[0]);
        return;
      }
catch (      NumberFormatException e) {
        System.err.println(""String_Node_Str"" + parts[1]);
      }
    }
    Wallet.SendRequest req=Wallet.SendRequest.forTx(t);
    if (t.getOutputs().size() == 1 && t.getOutput(0).getValue().equals(wallet.getBalance())) {
      log.info(""String_Node_Str"");
      req.emptyWallet=true;
    }
    req.fee=fee;
    if (allowUnconfirmed) {
      wallet.allowSpendingUnconfirmedTransactions();
    }
    if (password != null) {
      if (!wallet.checkPassword(password)) {
        System.err.println(""String_Node_Str"");
        return;
      }
      req.aesKey=wallet.getKeyCrypter().deriveKey(password);
    }
    if (!wallet.completeTx(req)) {
      System.err.println(""String_Node_Str"" + Utils.bitcoinValueToFriendlyString(wallet.getBalance()));
      return;
    }
    try {
      if (lockTimeStr != null) {
        t.setLockTime(Transaction.parseLockTimeStr(lockTimeStr));
        t.getInputs().get(0).setSequenceNumber(0);
        t.signInputs(Transaction.SigHash.ALL,wallet);
      }
    }
 catch (    ParseException e) {
      System.err.println(""String_Node_Str"" + lockTimeStr);
      return;
    }
catch (    ScriptException e) {
      throw new RuntimeException(e);
    }
catch (    KeyCrypterException e) {
      throw new RuntimeException(e);
    }
    t=req.tx;
    System.out.println(t.getHashAsString());
    if (options.has(""String_Node_Str"")) {
      wallet.commitTx(t);
      return;
    }
    setup();
    peers.startAndWait();
    peers.broadcastTransaction(t).get();
    if (peers.getMinBroadcastConnections() == 1) {
      Thread.sleep(5000);
    }
  }
 catch (  BlockStoreException e) {
    throw new RuntimeException(e);
  }
catch (  KeyCrypterException e) {
    throw new RuntimeException(e);
  }
catch (  InterruptedException e) {
    throw new RuntimeException(e);
  }
catch (  ExecutionException e) {
    throw new RuntimeException(e);
  }
}",0.9648529908752956
85774,"public int getSerializedSize(){
  int size=memoizedSerializedSize;
  if (size != -1)   return size;
  size=0;
  if (((bitField0_ & 0x00000001) == 0x00000001)) {
    size+=com.google.protobuf.CodedOutputStream.computeBytesSize(1,id_);
  }
  if (((bitField0_ & 0x00000002) == 0x00000002)) {
    size+=com.google.protobuf.CodedOutputStream.computeBytesSize(2,contractTransaction_);
  }
  if (((bitField0_ & 0x00000004) == 0x00000004)) {
    size+=com.google.protobuf.CodedOutputStream.computeBytesSize(3,refundTransaction_);
  }
  if (((bitField0_ & 0x00000008) == 0x00000008)) {
    size+=com.google.protobuf.CodedOutputStream.computeBytesSize(4,myKey_);
  }
  if (((bitField0_ & 0x00000010) == 0x00000010)) {
    size+=com.google.protobuf.CodedOutputStream.computeUInt64Size(5,valueToMe_);
  }
  if (((bitField0_ & 0x00000020) == 0x00000020)) {
    size+=com.google.protobuf.CodedOutputStream.computeUInt64Size(6,refundFees_);
  }
  size+=getUnknownFields().getSerializedSize();
  memoizedSerializedSize=size;
  return size;
}","public int getSerializedSize(){
  int size=memoizedSerializedSize;
  if (size != -1)   return size;
  size=0;
  if (((bitField0_ & 0x00000001) == 0x00000001)) {
    size+=com.google.protobuf.CodedOutputStream.computeBytesSize(1,id_);
  }
  if (((bitField0_ & 0x00000002) == 0x00000002)) {
    size+=com.google.protobuf.CodedOutputStream.computeBytesSize(2,contractTransaction_);
  }
  if (((bitField0_ & 0x00000004) == 0x00000004)) {
    size+=com.google.protobuf.CodedOutputStream.computeBytesSize(3,refundTransaction_);
  }
  if (((bitField0_ & 0x00000008) == 0x00000008)) {
    size+=com.google.protobuf.CodedOutputStream.computeBytesSize(4,myKey_);
  }
  if (((bitField0_ & 0x00000010) == 0x00000010)) {
    size+=com.google.protobuf.CodedOutputStream.computeUInt64Size(5,valueToMe_);
  }
  if (((bitField0_ & 0x00000020) == 0x00000020)) {
    size+=com.google.protobuf.CodedOutputStream.computeUInt64Size(6,refundFees_);
  }
  if (((bitField0_ & 0x00000040) == 0x00000040)) {
    size+=com.google.protobuf.CodedOutputStream.computeBytesSize(7,closeTransactionHash_);
  }
  size+=getUnknownFields().getSerializedSize();
  memoizedSerializedSize=size;
  return size;
}",0.9335154826958104
85775,"public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
  getSerializedSize();
  if (((bitField0_ & 0x00000001) == 0x00000001)) {
    output.writeBytes(1,id_);
  }
  if (((bitField0_ & 0x00000002) == 0x00000002)) {
    output.writeBytes(2,contractTransaction_);
  }
  if (((bitField0_ & 0x00000004) == 0x00000004)) {
    output.writeBytes(3,refundTransaction_);
  }
  if (((bitField0_ & 0x00000008) == 0x00000008)) {
    output.writeBytes(4,myKey_);
  }
  if (((bitField0_ & 0x00000010) == 0x00000010)) {
    output.writeUInt64(5,valueToMe_);
  }
  if (((bitField0_ & 0x00000020) == 0x00000020)) {
    output.writeUInt64(6,refundFees_);
  }
  getUnknownFields().writeTo(output);
}","public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
  getSerializedSize();
  if (((bitField0_ & 0x00000001) == 0x00000001)) {
    output.writeBytes(1,id_);
  }
  if (((bitField0_ & 0x00000002) == 0x00000002)) {
    output.writeBytes(2,contractTransaction_);
  }
  if (((bitField0_ & 0x00000004) == 0x00000004)) {
    output.writeBytes(3,refundTransaction_);
  }
  if (((bitField0_ & 0x00000008) == 0x00000008)) {
    output.writeBytes(4,myKey_);
  }
  if (((bitField0_ & 0x00000010) == 0x00000010)) {
    output.writeUInt64(5,valueToMe_);
  }
  if (((bitField0_ & 0x00000020) == 0x00000020)) {
    output.writeUInt64(6,refundFees_);
  }
  if (((bitField0_ & 0x00000040) == 0x00000040)) {
    output.writeBytes(7,closeTransactionHash_);
  }
  getUnknownFields().writeTo(output);
}",0.9331602855288772
85776,"public com.google.bitcoin.protocols.channels.ClientState.StoredClientPaymentChannel buildPartial(){
  com.google.bitcoin.protocols.channels.ClientState.StoredClientPaymentChannel result=new com.google.bitcoin.protocols.channels.ClientState.StoredClientPaymentChannel(this);
  int from_bitField0_=bitField0_;
  int to_bitField0_=0;
  if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
    to_bitField0_|=0x00000001;
  }
  result.id_=id_;
  if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
    to_bitField0_|=0x00000002;
  }
  result.contractTransaction_=contractTransaction_;
  if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
    to_bitField0_|=0x00000004;
  }
  result.refundTransaction_=refundTransaction_;
  if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
    to_bitField0_|=0x00000008;
  }
  result.myKey_=myKey_;
  if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
    to_bitField0_|=0x00000010;
  }
  result.valueToMe_=valueToMe_;
  if (((from_bitField0_ & 0x00000020) == 0x00000020)) {
    to_bitField0_|=0x00000020;
  }
  result.refundFees_=refundFees_;
  result.bitField0_=to_bitField0_;
  onBuilt();
  return result;
}","public com.google.bitcoin.protocols.channels.ClientState.StoredClientPaymentChannel buildPartial(){
  com.google.bitcoin.protocols.channels.ClientState.StoredClientPaymentChannel result=new com.google.bitcoin.protocols.channels.ClientState.StoredClientPaymentChannel(this);
  int from_bitField0_=bitField0_;
  int to_bitField0_=0;
  if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
    to_bitField0_|=0x00000001;
  }
  result.id_=id_;
  if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
    to_bitField0_|=0x00000002;
  }
  result.contractTransaction_=contractTransaction_;
  if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
    to_bitField0_|=0x00000004;
  }
  result.refundTransaction_=refundTransaction_;
  if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
    to_bitField0_|=0x00000008;
  }
  result.myKey_=myKey_;
  if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
    to_bitField0_|=0x00000010;
  }
  result.valueToMe_=valueToMe_;
  if (((from_bitField0_ & 0x00000020) == 0x00000020)) {
    to_bitField0_|=0x00000020;
  }
  result.refundFees_=refundFees_;
  if (((from_bitField0_ & 0x00000040) == 0x00000040)) {
    to_bitField0_|=0x00000040;
  }
  result.closeTransactionHash_=closeTransactionHash_;
  result.bitField0_=to_bitField0_;
  onBuilt();
  return result;
}",0.9407437678790356
85777,"private StoredClientPaymentChannel(com.google.protobuf.CodedInputStream input,com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
  initFields();
  int mutable_bitField0_=0;
  com.google.protobuf.UnknownFieldSet.Builder unknownFields=com.google.protobuf.UnknownFieldSet.newBuilder();
  try {
    boolean done=false;
    while (!done) {
      int tag=input.readTag();
switch (tag) {
case 0:
        done=true;
      break;
default :
{
      if (!parseUnknownField(input,unknownFields,extensionRegistry,tag)) {
        done=true;
      }
      break;
    }
case 10:
{
    bitField0_|=0x00000001;
    id_=input.readBytes();
    break;
  }
case 18:
{
  bitField0_|=0x00000002;
  contractTransaction_=input.readBytes();
  break;
}
case 26:
{
bitField0_|=0x00000004;
refundTransaction_=input.readBytes();
break;
}
case 34:
{
bitField0_|=0x00000008;
myKey_=input.readBytes();
break;
}
case 40:
{
bitField0_|=0x00000010;
valueToMe_=input.readUInt64();
break;
}
case 48:
{
bitField0_|=0x00000020;
refundFees_=input.readUInt64();
break;
}
}
}
}
 catch (com.google.protobuf.InvalidProtocolBufferException e) {
throw e.setUnfinishedMessage(this);
}
catch (java.io.IOException e) {
throw new com.google.protobuf.InvalidProtocolBufferException(e.getMessage()).setUnfinishedMessage(this);
}
 finally {
this.unknownFields=unknownFields.build();
makeExtensionsImmutable();
}
}","private StoredClientPaymentChannel(com.google.protobuf.CodedInputStream input,com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
  initFields();
  int mutable_bitField0_=0;
  com.google.protobuf.UnknownFieldSet.Builder unknownFields=com.google.protobuf.UnknownFieldSet.newBuilder();
  try {
    boolean done=false;
    while (!done) {
      int tag=input.readTag();
switch (tag) {
case 0:
        done=true;
      break;
default :
{
      if (!parseUnknownField(input,unknownFields,extensionRegistry,tag)) {
        done=true;
      }
      break;
    }
case 10:
{
    bitField0_|=0x00000001;
    id_=input.readBytes();
    break;
  }
case 18:
{
  bitField0_|=0x00000002;
  contractTransaction_=input.readBytes();
  break;
}
case 26:
{
bitField0_|=0x00000004;
refundTransaction_=input.readBytes();
break;
}
case 34:
{
bitField0_|=0x00000008;
myKey_=input.readBytes();
break;
}
case 40:
{
bitField0_|=0x00000010;
valueToMe_=input.readUInt64();
break;
}
case 48:
{
bitField0_|=0x00000020;
refundFees_=input.readUInt64();
break;
}
case 58:
{
bitField0_|=0x00000040;
closeTransactionHash_=input.readBytes();
break;
}
}
}
}
 catch (com.google.protobuf.InvalidProtocolBufferException e) {
throw e.setUnfinishedMessage(this);
}
catch (java.io.IOException e) {
throw new com.google.protobuf.InvalidProtocolBufferException(e.getMessage()).setUnfinishedMessage(this);
}
 finally {
this.unknownFields=unknownFields.build();
makeExtensionsImmutable();
}
}",0.9710982658959536
85778,"public Builder clear(){
  super.clear();
  id_=com.google.protobuf.ByteString.EMPTY;
  bitField0_=(bitField0_ & ~0x00000001);
  contractTransaction_=com.google.protobuf.ByteString.EMPTY;
  bitField0_=(bitField0_ & ~0x00000002);
  refundTransaction_=com.google.protobuf.ByteString.EMPTY;
  bitField0_=(bitField0_ & ~0x00000004);
  myKey_=com.google.protobuf.ByteString.EMPTY;
  bitField0_=(bitField0_ & ~0x00000008);
  valueToMe_=0L;
  bitField0_=(bitField0_ & ~0x00000010);
  refundFees_=0L;
  bitField0_=(bitField0_ & ~0x00000020);
  return this;
}","public Builder clear(){
  super.clear();
  id_=com.google.protobuf.ByteString.EMPTY;
  bitField0_=(bitField0_ & ~0x00000001);
  contractTransaction_=com.google.protobuf.ByteString.EMPTY;
  bitField0_=(bitField0_ & ~0x00000002);
  refundTransaction_=com.google.protobuf.ByteString.EMPTY;
  bitField0_=(bitField0_ & ~0x00000004);
  myKey_=com.google.protobuf.ByteString.EMPTY;
  bitField0_=(bitField0_ & ~0x00000008);
  valueToMe_=0L;
  bitField0_=(bitField0_ & ~0x00000010);
  refundFees_=0L;
  bitField0_=(bitField0_ & ~0x00000020);
  closeTransactionHash_=com.google.protobuf.ByteString.EMPTY;
  bitField0_=(bitField0_ & ~0x00000040);
  return this;
}",0.9009159034138218
85779,"public com.google.protobuf.ExtensionRegistry assignDescriptors(com.google.protobuf.Descriptors.FileDescriptor root){
  descriptor=root;
  internal_static_paymentchannels_StoredClientPaymentChannels_descriptor=getDescriptor().getMessageTypes().get(0);
  internal_static_paymentchannels_StoredClientPaymentChannels_fieldAccessorTable=new com.google.protobuf.GeneratedMessage.FieldAccessorTable(internal_static_paymentchannels_StoredClientPaymentChannels_descriptor,new java.lang.String[]{""String_Node_Str""});
  internal_static_paymentchannels_StoredClientPaymentChannel_descriptor=getDescriptor().getMessageTypes().get(1);
  internal_static_paymentchannels_StoredClientPaymentChannel_fieldAccessorTable=new com.google.protobuf.GeneratedMessage.FieldAccessorTable(internal_static_paymentchannels_StoredClientPaymentChannel_descriptor,new java.lang.String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  return null;
}","public com.google.protobuf.ExtensionRegistry assignDescriptors(com.google.protobuf.Descriptors.FileDescriptor root){
  descriptor=root;
  internal_static_paymentchannels_StoredClientPaymentChannels_descriptor=getDescriptor().getMessageTypes().get(0);
  internal_static_paymentchannels_StoredClientPaymentChannels_fieldAccessorTable=new com.google.protobuf.GeneratedMessage.FieldAccessorTable(internal_static_paymentchannels_StoredClientPaymentChannels_descriptor,new java.lang.String[]{""String_Node_Str""});
  internal_static_paymentchannels_StoredClientPaymentChannel_descriptor=getDescriptor().getMessageTypes().get(1);
  internal_static_paymentchannels_StoredClientPaymentChannel_fieldAccessorTable=new com.google.protobuf.GeneratedMessage.FieldAccessorTable(internal_static_paymentchannels_StoredClientPaymentChannel_descriptor,new java.lang.String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  return null;
}",0.990909090909091
85780,"private void initFields(){
  id_=com.google.protobuf.ByteString.EMPTY;
  contractTransaction_=com.google.protobuf.ByteString.EMPTY;
  refundTransaction_=com.google.protobuf.ByteString.EMPTY;
  myKey_=com.google.protobuf.ByteString.EMPTY;
  valueToMe_=0L;
  refundFees_=0L;
}","private void initFields(){
  id_=com.google.protobuf.ByteString.EMPTY;
  contractTransaction_=com.google.protobuf.ByteString.EMPTY;
  refundTransaction_=com.google.protobuf.ByteString.EMPTY;
  myKey_=com.google.protobuf.ByteString.EMPTY;
  valueToMe_=0L;
  refundFees_=0L;
  closeTransactionHash_=com.google.protobuf.ByteString.EMPTY;
}",0.898360655737705
85781,"/** 
 * Creates a state object for a payment channel client. It is expected that you be ready to  {@link PaymentChannelClientState#initiate()} after construction (to avoid creating objects for channels which arenot going to finish opening) and thus some parameters provided here are only used in {@link PaymentChannelClientState#initiate()} to create the Multisig contract and refund transaction.
 * @param wallet a wallet that contains at least the specified amount of value.
 * @param myKey a freshly generated private key for this channel.
 * @param serverMultisigKey a public key retrieved from the server used for the initial multisig contract
 * @param value how many satoshis to put into this contract. If the channel reaches this limit, it must be closed.It is suggested you use at least  {@link Utils#CENT} to avoid paying fees if you need to spend the refund transaction
 * @param expiryTimeInSeconds At what point (UNIX timestamp +/- a few hours) the channel will expire
 * @throws VerificationException If either myKey's pubkey or serverMultisigKey's pubkey are non-canonical (ie invalid)
 */
public PaymentChannelClientState(Wallet wallet,ECKey myKey,ECKey serverMultisigKey,BigInteger value,long expiryTimeInSeconds) throws VerificationException {
  checkArgument(value.compareTo(BigInteger.ZERO) > 0);
  this.wallet=checkNotNull(wallet);
  this.serverMultisigKey=checkNotNull(serverMultisigKey);
  if (!myKey.isPubKeyCanonical() || !serverMultisigKey.isPubKeyCanonical())   throw new VerificationException(""String_Node_Str"");
  this.myKey=checkNotNull(myKey);
  this.valueToMe=this.totalValue=checkNotNull(value);
  this.expiryTime=expiryTimeInSeconds;
  this.state=State.NEW;
}","/** 
 * Creates a state object for a payment channel client. It is expected that you be ready to  {@link PaymentChannelClientState#initiate()} after construction (to avoid creating objects for channels which arenot going to finish opening) and thus some parameters provided here are only used in {@link PaymentChannelClientState#initiate()} to create the Multisig contract and refund transaction.
 * @param wallet a wallet that contains at least the specified amount of value.
 * @param myKey a freshly generated private key for this channel.
 * @param serverMultisigKey a public key retrieved from the server used for the initial multisig contract
 * @param value how many satoshis to put into this contract. If the channel reaches this limit, it must be closed.It is suggested you use at least  {@link Utils#CENT} to avoid paying fees if you need to spend the refund transaction
 * @param expiryTimeInSeconds At what point (UNIX timestamp +/- a few hours) the channel will expire
 * @throws VerificationException If either myKey's pubkey or serverMultisigKey's pubkey are non-canonical (ie invalid)
 */
public PaymentChannelClientState(Wallet wallet,ECKey myKey,ECKey serverMultisigKey,BigInteger value,long expiryTimeInSeconds) throws VerificationException {
  checkArgument(value.compareTo(BigInteger.ZERO) > 0);
  this.wallet=checkNotNull(wallet);
  initWalletListeners();
  this.serverMultisigKey=checkNotNull(serverMultisigKey);
  if (!myKey.isPubKeyCanonical() || !serverMultisigKey.isPubKeyCanonical())   throw new VerificationException(""String_Node_Str"");
  this.myKey=checkNotNull(myKey);
  this.valueToMe=this.totalValue=checkNotNull(value);
  this.expiryTime=expiryTimeInSeconds;
  this.state=State.NEW;
}",0.9926707710348872
85782,"/** 
 * Sets this channel's state in   {@link StoredPaymentChannelClientStates} to unopened so this channel can be reopenedlater.
 * @see PaymentChannelClientState#storeChannelInWallet(Sha256Hash)
 */
public synchronized void disconnectFromChannel(){
  if (storedChannel == null)   return;
synchronized (storedChannel) {
    storedChannel.active=false;
  }
  storedChannel=null;
}","/** 
 * Sets this channel's state in   {@link StoredPaymentChannelClientStates} to unopened so this channel can be reopenedlater.
 * @see PaymentChannelClientState#storeChannelInWallet(Sha256Hash)
 */
public synchronized void disconnectFromChannel(){
  if (storedChannel == null)   return;
synchronized (storedChannel) {
    storedChannel.active=false;
  }
}",0.9701897018970188
85783,"@Override protected void startUp() throws Exception {
  if (!directory.exists()) {
    if (!directory.mkdir()) {
      throw new IOException(""String_Node_Str"");
    }
  }
  FileInputStream walletStream=null;
  try {
    File chainFile=new File(directory,filePrefix + ""String_Node_Str"");
    boolean chainFileExists=chainFile.exists();
    vWalletFile=new File(directory,filePrefix + ""String_Node_Str"");
    boolean shouldReplayWallet=vWalletFile.exists() && !chainFileExists;
    if (vWalletFile.exists()) {
      walletStream=new FileInputStream(vWalletFile);
      vWallet=new Wallet(params);
      addWalletExtensions();
      new WalletProtobufSerializer().readWallet(WalletProtobufSerializer.parseToProto(walletStream),vWallet);
      if (shouldReplayWallet)       vWallet.clearTransactions(0);
    }
 else {
      vWallet=new Wallet(params);
      vWallet.addKey(new ECKey());
      addWalletExtensions();
    }
    if (useAutoSave)     vWallet.autosaveToFile(vWalletFile,1,TimeUnit.SECONDS,null);
    vStore=new SPVBlockStore(params,chainFile);
    if (!chainFileExists && checkpoints != null) {
      CheckpointManager.checkpoint(params,checkpoints,vStore,vWallet.getEarliestKeyCreationTime());
    }
    vChain=new BlockChain(params,vStore);
    vPeerGroup=new PeerGroup(params,vChain);
    if (peerAddresses != null) {
      for (      PeerAddress addr : peerAddresses)       vPeerGroup.addAddress(addr);
      peerAddresses=null;
    }
 else {
      vPeerGroup.addPeerDiscovery(new DnsDiscovery(params));
    }
    vChain.addWallet(vWallet);
    vPeerGroup.addWallet(vWallet);
    onSetupCompleted();
    if (blockingStartup) {
      vPeerGroup.startAndWait();
      installShutdownHook();
      final DownloadListener listener=new DownloadListener();
      vPeerGroup.startBlockChainDownload(listener);
      listener.await();
    }
 else {
      Futures.addCallback(vPeerGroup.start(),new FutureCallback<State>(){
        @Override public void onSuccess(        State result){
          final PeerEventListener l=downloadListener == null ? new DownloadListener() : downloadListener;
          vPeerGroup.startBlockChainDownload(l);
        }
        @Override public void onFailure(        Throwable t){
          throw new RuntimeException(t);
        }
      }
);
    }
  }
 catch (  BlockStoreException e) {
    throw new IOException(e);
  }
 finally {
    if (walletStream != null)     walletStream.close();
  }
}","@Override protected void startUp() throws Exception {
  if (!directory.exists()) {
    if (!directory.mkdir()) {
      throw new IOException(""String_Node_Str"");
    }
  }
  FileInputStream walletStream=null;
  try {
    File chainFile=new File(directory,filePrefix + ""String_Node_Str"");
    boolean chainFileExists=chainFile.exists();
    vStore=new SPVBlockStore(params,chainFile);
    if (!chainFileExists && checkpoints != null) {
      CheckpointManager.checkpoint(params,checkpoints,vStore,vWallet.getEarliestKeyCreationTime());
    }
    vChain=new BlockChain(params,vStore);
    vPeerGroup=new PeerGroup(params,vChain);
    vWalletFile=new File(directory,filePrefix + ""String_Node_Str"");
    boolean shouldReplayWallet=vWalletFile.exists() && !chainFileExists;
    if (vWalletFile.exists()) {
      walletStream=new FileInputStream(vWalletFile);
      vWallet=new Wallet(params);
      addWalletExtensions();
      new WalletProtobufSerializer().readWallet(WalletProtobufSerializer.parseToProto(walletStream),vWallet);
      if (shouldReplayWallet)       vWallet.clearTransactions(0);
    }
 else {
      vWallet=new Wallet(params);
      vWallet.addKey(new ECKey());
      addWalletExtensions();
    }
    if (useAutoSave)     vWallet.autosaveToFile(vWalletFile,1,TimeUnit.SECONDS,null);
    if (peerAddresses != null) {
      for (      PeerAddress addr : peerAddresses)       vPeerGroup.addAddress(addr);
      peerAddresses=null;
    }
 else {
      vPeerGroup.addPeerDiscovery(new DnsDiscovery(params));
    }
    vChain.addWallet(vWallet);
    vPeerGroup.addWallet(vWallet);
    onSetupCompleted();
    if (blockingStartup) {
      vPeerGroup.startAndWait();
      installShutdownHook();
      final DownloadListener listener=new DownloadListener();
      vPeerGroup.startBlockChainDownload(listener);
      listener.await();
    }
 else {
      Futures.addCallback(vPeerGroup.start(),new FutureCallback<State>(){
        @Override public void onSuccess(        State result){
          final PeerEventListener l=downloadListener == null ? new DownloadListener() : downloadListener;
          vPeerGroup.startBlockChainDownload(l);
        }
        @Override public void onFailure(        Throwable t){
          throw new RuntimeException(t);
        }
      }
);
    }
  }
 catch (  BlockStoreException e) {
    throw new IOException(e);
  }
 finally {
    if (walletStream != null)     walletStream.close();
  }
}",0.8798353909465021
85784,"@Override protected synchronized TransactionOutputChanges connectTransactions(StoredBlock newBlock) throws VerificationException, BlockStoreException, PrunedException {
  checkState(lock.isHeldByCurrentThread());
  if (!params.passesCheckpoint(newBlock.getHeight(),newBlock.getHeader().getHash()))   throw new VerificationException(""String_Node_Str"" + newBlock.getHeight());
  blockStore.beginDatabaseBatchWrite();
  StoredUndoableBlock block=blockStore.getUndoBlock(newBlock.getHeader().getHash());
  if (block == null) {
    blockStore.abortDatabaseBatchWrite();
    throw new PrunedException(newBlock.getHeader().getHash());
  }
  TransactionOutputChanges txOutChanges;
  try {
    List<Transaction> transactions=block.getTransactions();
    if (transactions != null) {
      LinkedList<StoredTransactionOutput> txOutsSpent=new LinkedList<StoredTransactionOutput>();
      LinkedList<StoredTransactionOutput> txOutsCreated=new LinkedList<StoredTransactionOutput>();
      long sigOps=0;
      final boolean enforcePayToScriptHash=newBlock.getHeader().getTimeSeconds() >= NetworkParameters.BIP16_ENFORCE_TIME;
      if (!params.isCheckpoint(newBlock.getHeight())) {
        for (        Transaction tx : transactions) {
          Sha256Hash hash=tx.getHash();
          if (blockStore.hasUnspentOutputs(hash,tx.getOutputs().size()))           throw new VerificationException(""String_Node_Str"");
        }
      }
      BigInteger totalFees=BigInteger.ZERO;
      BigInteger coinbaseValue=null;
      if (scriptVerificationExecutor.isShutdown())       scriptVerificationExecutor=Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
      List<Future<VerificationException>> listScriptVerificationResults=new ArrayList<Future<VerificationException>>(transactions.size());
      for (      final Transaction tx : transactions) {
        boolean isCoinBase=tx.isCoinBase();
        BigInteger valueIn=BigInteger.ZERO;
        BigInteger valueOut=BigInteger.ZERO;
        final List<Script> prevOutScripts=new LinkedList<Script>();
        if (!isCoinBase) {
          for (int index=0; index < tx.getInputs().size(); index++) {
            final TransactionInput in=tx.getInputs().get(index);
            final StoredTransactionOutput prevOut=blockStore.getTransactionOutput(in.getOutpoint().getHash(),in.getOutpoint().getIndex());
            if (prevOut == null)             throw new VerificationException(""String_Node_Str"");
            if (newBlock.getHeight() - prevOut.getHeight() < params.getSpendableCoinbaseDepth())             throw new VerificationException(""String_Node_Str"" + (newBlock.getHeight() - prevOut.getHeight()));
            valueIn=valueIn.add(prevOut.getValue());
            if (enforcePayToScriptHash) {
              Script script=new Script(prevOut.getScriptBytes());
              if (script.isPayToScriptHash())               sigOps+=Script.getP2SHSigOpCount(in.getScriptBytes());
              if (sigOps > Block.MAX_BLOCK_SIGOPS)               throw new VerificationException(""String_Node_Str"");
            }
            prevOutScripts.add(new Script(prevOut.getScriptBytes()));
            blockStore.removeUnspentTransactionOutput(prevOut);
            txOutsSpent.add(prevOut);
          }
        }
        Sha256Hash hash=tx.getHash();
        for (        TransactionOutput out : tx.getOutputs()) {
          valueOut=valueOut.add(out.getValue());
          StoredTransactionOutput newOut=new StoredTransactionOutput(hash,out.getIndex(),out.getValue(),newBlock.getHeight(),isCoinBase,out.getScriptBytes());
          blockStore.addUnspentTransactionOutput(newOut);
          txOutsCreated.add(newOut);
        }
        if (valueOut.compareTo(BigInteger.ZERO) < 0 || valueOut.compareTo(params.MAX_MONEY) > 0)         throw new VerificationException(""String_Node_Str"");
        if (isCoinBase) {
          coinbaseValue=valueOut;
        }
 else {
          if (valueIn.compareTo(valueOut) < 0 || valueIn.compareTo(params.MAX_MONEY) > 0)           throw new VerificationException(""String_Node_Str"");
          totalFees=totalFees.add(valueIn.subtract(valueOut));
        }
        if (!isCoinBase) {
          FutureTask<VerificationException> future=new FutureTask<VerificationException>(new Verifyer(tx,prevOutScripts,enforcePayToScriptHash));
          scriptVerificationExecutor.execute(future);
          listScriptVerificationResults.add(future);
        }
      }
      if (totalFees.compareTo(params.MAX_MONEY) > 0 || newBlock.getHeader().getBlockInflation(newBlock.getHeight()).add(totalFees).compareTo(coinbaseValue) < 0)       throw new VerificationException(""String_Node_Str"");
      txOutChanges=new TransactionOutputChanges(txOutsCreated,txOutsSpent);
      for (      Future<VerificationException> future : listScriptVerificationResults) {
        VerificationException e;
        try {
          e=future.get();
        }
 catch (        InterruptedException thrownE) {
          throw new RuntimeException(thrownE);
        }
catch (        ExecutionException thrownE) {
          log.error(""String_Node_Str"" + thrownE.getCause());
          throw new VerificationException(""String_Node_Str"",thrownE);
        }
        if (e != null)         throw e;
      }
    }
 else {
      txOutChanges=block.getTxOutChanges();
      if (!params.isCheckpoint(newBlock.getHeight()))       for (      StoredTransactionOutput out : txOutChanges.txOutsCreated) {
        Sha256Hash hash=out.getHash();
        if (blockStore.getTransactionOutput(hash,out.getIndex()) != null)         throw new VerificationException(""String_Node_Str"");
      }
      for (      StoredTransactionOutput out : txOutChanges.txOutsCreated)       blockStore.addUnspentTransactionOutput(out);
      for (      StoredTransactionOutput out : txOutChanges.txOutsSpent)       blockStore.removeUnspentTransactionOutput(out);
    }
  }
 catch (  VerificationException e) {
    scriptVerificationExecutor.shutdownNow();
    blockStore.abortDatabaseBatchWrite();
    throw e;
  }
catch (  BlockStoreException e) {
    scriptVerificationExecutor.shutdownNow();
    blockStore.abortDatabaseBatchWrite();
    throw e;
  }
  return txOutChanges;
}","@Override protected synchronized TransactionOutputChanges connectTransactions(StoredBlock newBlock) throws VerificationException, BlockStoreException, PrunedException {
  checkState(lock.isHeldByCurrentThread());
  if (!params.passesCheckpoint(newBlock.getHeight(),newBlock.getHeader().getHash()))   throw new VerificationException(""String_Node_Str"" + newBlock.getHeight());
  blockStore.beginDatabaseBatchWrite();
  StoredUndoableBlock block=blockStore.getUndoBlock(newBlock.getHeader().getHash());
  if (block == null) {
    blockStore.abortDatabaseBatchWrite();
    throw new PrunedException(newBlock.getHeader().getHash());
  }
  TransactionOutputChanges txOutChanges;
  try {
    List<Transaction> transactions=block.getTransactions();
    if (transactions != null) {
      LinkedList<StoredTransactionOutput> txOutsSpent=new LinkedList<StoredTransactionOutput>();
      LinkedList<StoredTransactionOutput> txOutsCreated=new LinkedList<StoredTransactionOutput>();
      long sigOps=0;
      final boolean enforcePayToScriptHash=newBlock.getHeader().getTimeSeconds() >= NetworkParameters.BIP16_ENFORCE_TIME;
      if (!params.isCheckpoint(newBlock.getHeight())) {
        for (        Transaction tx : transactions) {
          Sha256Hash hash=tx.getHash();
          if (blockStore.hasUnspentOutputs(hash,tx.getOutputs().size()))           throw new VerificationException(""String_Node_Str"");
        }
      }
      BigInteger totalFees=BigInteger.ZERO;
      BigInteger coinbaseValue=null;
      if (scriptVerificationExecutor.isShutdown())       scriptVerificationExecutor=Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
      List<Future<VerificationException>> listScriptVerificationResults=new ArrayList<Future<VerificationException>>(transactions.size());
      for (      final Transaction tx : transactions) {
        boolean isCoinBase=tx.isCoinBase();
        BigInteger valueIn=BigInteger.ZERO;
        BigInteger valueOut=BigInteger.ZERO;
        final List<Script> prevOutScripts=new LinkedList<Script>();
        if (!isCoinBase) {
          for (int index=0; index < tx.getInputs().size(); index++) {
            final TransactionInput in=tx.getInputs().get(index);
            final StoredTransactionOutput prevOut=blockStore.getTransactionOutput(in.getOutpoint().getHash(),in.getOutpoint().getIndex());
            if (prevOut == null)             throw new VerificationException(""String_Node_Str"");
            if (newBlock.getHeight() - prevOut.getHeight() < params.getSpendableCoinbaseDepth())             throw new VerificationException(""String_Node_Str"" + (newBlock.getHeight() - prevOut.getHeight()));
            valueIn=valueIn.add(prevOut.getValue());
            if (enforcePayToScriptHash) {
              Script script=new Script(prevOut.getScriptBytes());
              if (script.isPayToScriptHash())               sigOps+=Script.getP2SHSigOpCount(in.getScriptBytes());
              if (sigOps > Block.MAX_BLOCK_SIGOPS)               throw new VerificationException(""String_Node_Str"");
            }
            prevOutScripts.add(new Script(prevOut.getScriptBytes()));
            blockStore.removeUnspentTransactionOutput(prevOut);
            txOutsSpent.add(prevOut);
          }
        }
        Sha256Hash hash=tx.getHash();
        for (        TransactionOutput out : tx.getOutputs()) {
          valueOut=valueOut.add(out.getValue());
          StoredTransactionOutput newOut=new StoredTransactionOutput(hash,out.getIndex(),out.getValue(),newBlock.getHeight(),isCoinBase,out.getScriptBytes());
          blockStore.addUnspentTransactionOutput(newOut);
          txOutsCreated.add(newOut);
        }
        if (valueOut.compareTo(BigInteger.ZERO) < 0 || valueOut.compareTo(params.MAX_MONEY) > 0)         throw new VerificationException(""String_Node_Str"");
        if (isCoinBase) {
          coinbaseValue=valueOut;
        }
 else {
          if (valueIn.compareTo(valueOut) < 0 || valueIn.compareTo(params.MAX_MONEY) > 0)           throw new VerificationException(""String_Node_Str"");
          totalFees=totalFees.add(valueIn.subtract(valueOut));
        }
        if (!isCoinBase) {
          FutureTask<VerificationException> future=new FutureTask<VerificationException>(new Verifier(tx,prevOutScripts,enforcePayToScriptHash));
          scriptVerificationExecutor.execute(future);
          listScriptVerificationResults.add(future);
        }
      }
      if (totalFees.compareTo(params.MAX_MONEY) > 0 || newBlock.getHeader().getBlockInflation(newBlock.getHeight()).add(totalFees).compareTo(coinbaseValue) < 0)       throw new VerificationException(""String_Node_Str"");
      txOutChanges=new TransactionOutputChanges(txOutsCreated,txOutsSpent);
      for (      Future<VerificationException> future : listScriptVerificationResults) {
        VerificationException e;
        try {
          e=future.get();
        }
 catch (        InterruptedException thrownE) {
          throw new RuntimeException(thrownE);
        }
catch (        ExecutionException thrownE) {
          log.error(""String_Node_Str"" + thrownE.getCause());
          throw new VerificationException(""String_Node_Str"",thrownE);
        }
        if (e != null)         throw e;
      }
    }
 else {
      txOutChanges=block.getTxOutChanges();
      if (!params.isCheckpoint(newBlock.getHeight()))       for (      StoredTransactionOutput out : txOutChanges.txOutsCreated) {
        Sha256Hash hash=out.getHash();
        if (blockStore.getTransactionOutput(hash,out.getIndex()) != null)         throw new VerificationException(""String_Node_Str"");
      }
      for (      StoredTransactionOutput out : txOutChanges.txOutsCreated)       blockStore.addUnspentTransactionOutput(out);
      for (      StoredTransactionOutput out : txOutChanges.txOutsSpent)       blockStore.removeUnspentTransactionOutput(out);
    }
  }
 catch (  VerificationException e) {
    scriptVerificationExecutor.shutdownNow();
    blockStore.abortDatabaseBatchWrite();
    throw e;
  }
catch (  BlockStoreException e) {
    scriptVerificationExecutor.shutdownNow();
    blockStore.abortDatabaseBatchWrite();
    throw e;
  }
  return txOutChanges;
}",0.9998380304502752
85785,"/** 
 * Alias for TestNet2Params.get(), use that instead. 
 */
public static NetworkParameters testNet2(){
  return TestNet2Params.get();
}","/** 
 * Alias for TestNet2Params.get(), use that instead. 
 */
@Deprecated public static NetworkParameters testNet2(){
  return TestNet2Params.get();
}",0.9586206896551724
85786,"/** 
 * Alias for TestNet3Params.get(), use that instead. 
 */
public static NetworkParameters testNet3(){
  return TestNet3Params.get();
}","/** 
 * Alias for TestNet3Params.get(), use that instead. 
 */
@Deprecated public static NetworkParameters testNet3(){
  return TestNet3Params.get();
}",0.9586206896551724
85787,"/** 
 * Returns a testnet params modified to allow any difficulty target. 
 */
public static NetworkParameters unitTests(){
  return UnitTestParams.get();
}","/** 
 * Returns a testnet params modified to allow any difficulty target. 
 */
@Deprecated public static NetworkParameters unitTests(){
  return UnitTestParams.get();
}",0.9629629629629628
85788,"/** 
 * Alias for MainNetParams.get(), use that instead 
 */
public static NetworkParameters prodNet(){
  return MainNetParams.get();
}","/** 
 * Alias for MainNetParams.get(), use that instead 
 */
@Deprecated public static NetworkParameters prodNet(){
  return MainNetParams.get();
}",0.9574468085106383
85789,"/** 
 * Alias for TestNet3Params.get(), use that instead. 
 */
public static NetworkParameters testNet(){
  return TestNet3Params.get();
}","/** 
 * Alias for TestNet3Params.get(), use that instead. 
 */
@Deprecated public static NetworkParameters testNet(){
  return TestNet3Params.get();
}",0.9583333333333334
85790,"/** 
 * <p>Updates the wallet by checking if this TX spends any of our outputs, and marking them as spent if so. If fromChain is true, also checks to see if any pending transaction spends outputs of this transaction and marks the spent flags appropriately.</p> <p>It can be called in two contexts. One is when we receive a transaction on the best chain but it wasn't pending, this most commonly happens when we have a set of keys but the wallet transactions were wiped and we are catching up with the block chain. It can also happen if a block includes a transaction we never saw at broadcast time. If this tx double spends, it takes precedence over our pending transactions and the pending tx goes dead.</p> <p>The other context it can be called is from   {@link Wallet#receivePending(Transaction,java.util.List)}, ie we saw a tx be broadcast or one was submitted directly that spends our own coins. If this tx double spends it does NOT take precedence because the winner will be resolved by the miners - we assume that our version will win, if we are wrong then when a block appears the tx will go dead.</p>
 * @param tx The transaction which is being updated.
 * @param fromChain If true, the tx appeared on the current best chain, if false it was pending.
 */
private void updateForSpends(Transaction tx,boolean fromChain) throws VerificationException {
  checkState(lock.isHeldByCurrentThread());
  if (fromChain)   checkState(!pending.containsKey(tx.getHash()));
  for (  TransactionInput input : tx.getInputs()) {
    TransactionInput.ConnectionResult result=input.connect(unspent,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
    if (result == TransactionInput.ConnectionResult.NO_SUCH_TX) {
      result=input.connect(spent,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
      if (result == TransactionInput.ConnectionResult.NO_SUCH_TX) {
        result=input.connect(pending,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
        if (result == TransactionInput.ConnectionResult.NO_SUCH_TX) {
          continue;
        }
      }
    }
    if (result == TransactionInput.ConnectionResult.ALREADY_SPENT) {
      if (fromChain) {
      }
 else {
        log.warn(""String_Node_Str"",tx.getHash(),input.getConnectedOutput().getSpentBy().getParentTransaction().getHash());
        log.warn(""String_Node_Str"",tx.getInputs().indexOf(input));
      }
    }
 else     if (result == TransactionInput.ConnectionResult.SUCCESS) {
      Transaction connected=checkNotNull(input.getOutpoint().fromTx);
      maybeMovePool(connected,""String_Node_Str"");
    }
  }
  if (fromChain) {
    for (    Transaction pendingTx : pending.values()) {
      for (      TransactionInput input : pendingTx.getInputs()) {
        TransactionInput.ConnectionResult result=input.connect(tx,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
        checkState(result != TransactionInput.ConnectionResult.ALREADY_SPENT);
        if (result == TransactionInput.ConnectionResult.SUCCESS) {
          log.info(""String_Node_Str"",pendingTx.getHashAsString(),pendingTx.getInputs().indexOf(input));
        }
      }
    }
  }
}","/** 
 * <p>Updates the wallet by checking if this TX spends any of our outputs, and marking them as spent if so. If fromChain is true, also checks to see if any pending transaction spends outputs of this transaction and marks the spent flags appropriately.</p> <p>It can be called in two contexts. One is when we receive a transaction on the best chain but it wasn't pending, this most commonly happens when we have a set of keys but the wallet transactions were wiped and we are catching up with the block chain. It can also happen if a block includes a transaction we never saw at broadcast time. If this tx double spends, it takes precedence over our pending transactions and the pending tx goes dead.</p> <p>The other context it can be called is from   {@link Wallet#receivePending(Transaction,java.util.List)}, ie we saw a tx be broadcast or one was submitted directly that spends our own coins. If this tx double spends it does NOT take precedence because the winner will be resolved by the miners - we assume that our version will win, if we are wrong then when a block appears the tx will go dead.</p>
 * @param tx The transaction which is being updated.
 * @param fromChain If true, the tx appeared on the current best chain, if false it was pending.
 */
private void updateForSpends(Transaction tx,boolean fromChain) throws VerificationException {
  checkState(lock.isHeldByCurrentThread());
  if (fromChain)   checkState(!pending.containsKey(tx.getHash()));
  for (  TransactionInput input : tx.getInputs()) {
    TransactionInput.ConnectionResult result=input.connect(unspent,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
    if (result == TransactionInput.ConnectionResult.NO_SUCH_TX) {
      result=input.connect(spent,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
      if (result == TransactionInput.ConnectionResult.NO_SUCH_TX) {
        result=input.connect(pending,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
        if (result == TransactionInput.ConnectionResult.NO_SUCH_TX) {
          continue;
        }
      }
    }
    if (result == TransactionInput.ConnectionResult.ALREADY_SPENT) {
      if (fromChain) {
        log.warn(""String_Node_Str"");
      }
 else {
        log.warn(""String_Node_Str"",tx.getHash(),input.getConnectedOutput().getSpentBy().getParentTransaction().getHash());
        log.warn(""String_Node_Str"",tx.getInputs().indexOf(input));
      }
    }
 else     if (result == TransactionInput.ConnectionResult.SUCCESS) {
      Transaction connected=checkNotNull(input.getOutpoint().fromTx);
      log.info(""String_Node_Str"",input.getOutpoint());
      maybeMovePool(connected,""String_Node_Str"");
    }
  }
  if (fromChain) {
    for (    Transaction pendingTx : pending.values()) {
      for (      TransactionInput input : pendingTx.getInputs()) {
        TransactionInput.ConnectionResult result=input.connect(tx,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
        checkState(result != TransactionInput.ConnectionResult.ALREADY_SPENT);
        if (result == TransactionInput.ConnectionResult.SUCCESS) {
          log.info(""String_Node_Str"",pendingTx.getHashAsString(),pendingTx.getInputs().indexOf(input));
        }
      }
    }
  }
}",0.9853829043533524
85791,"public MainNetParams(){
  super();
  interval=INTERVAL;
  targetTimespan=TARGET_TIMESPAN;
  proofOfWorkLimit=Utils.decodeCompactBits(0x1d00ffffL);
  acceptableAddressCodes=new int[]{0};
  dumpedPrivateKeyHeader=128;
  addressHeader=0;
  port=8333;
  packetMagic=0xf9beb4d9L;
  genesisBlock.setDifficultyTarget(0x1d00ffffL);
  genesisBlock.setTime(1231006505L);
  genesisBlock.setNonce(2083236893);
  id=ID_PRODNET;
  subsidyDecreaseBlockCount=210000;
  spendableCoinbaseDepth=100;
  String genesisHash=genesisBlock.getHashAsString();
  checkState(genesisHash.equals(""String_Node_Str""),genesisHash);
  checkpoints.put(91722,new Sha256Hash(""String_Node_Str""));
  checkpoints.put(91812,new Sha256Hash(""String_Node_Str""));
  checkpoints.put(91842,new Sha256Hash(""String_Node_Str""));
  checkpoints.put(91880,new Sha256Hash(""String_Node_Str""));
  checkpoints.put(200000,new Sha256Hash(""String_Node_Str""));
  dnsSeeds=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
}","public MainNetParams(){
  super();
  interval=INTERVAL;
  targetTimespan=TARGET_TIMESPAN;
  proofOfWorkLimit=Utils.decodeCompactBits(0x1d00ffffL);
  acceptableAddressCodes=new int[]{0};
  dumpedPrivateKeyHeader=128;
  addressHeader=0;
  port=8333;
  packetMagic=0xf9beb4d9L;
  genesisBlock.setDifficultyTarget(0x1d00ffffL);
  genesisBlock.setTime(1231006505L);
  genesisBlock.setNonce(2083236893);
  id=ID_MAINNET;
  subsidyDecreaseBlockCount=210000;
  spendableCoinbaseDepth=100;
  String genesisHash=genesisBlock.getHashAsString();
  checkState(genesisHash.equals(""String_Node_Str""),genesisHash);
  checkpoints.put(91722,new Sha256Hash(""String_Node_Str""));
  checkpoints.put(91812,new Sha256Hash(""String_Node_Str""));
  checkpoints.put(91842,new Sha256Hash(""String_Node_Str""));
  checkpoints.put(91880,new Sha256Hash(""String_Node_Str""));
  checkpoints.put(200000,new Sha256Hash(""String_Node_Str""));
  dnsSeeds=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
}",0.9959225280326198
85792,"@VisibleForTesting synchronized void doStoreChannelInWallet(Sha256Hash id){
  StoredPaymentChannelClientStates channels=(StoredPaymentChannelClientStates)wallet.getExtensions().get(StoredPaymentChannelClientStates.EXTENSION_ID);
  checkState(channels.getChannel(id,multisigContract.getHash()) == null);
  storedChannel=new StoredClientChannel(id,multisigContract,refundTx,myKey,valueToMe,refundFees);
  channels.putChannel(storedChannel);
  wallet.addOrUpdateExtension(channels);
}","@VisibleForTesting synchronized void doStoreChannelInWallet(Sha256Hash id){
  StoredPaymentChannelClientStates channels=(StoredPaymentChannelClientStates)wallet.getExtensions().get(StoredPaymentChannelClientStates.EXTENSION_ID);
  checkState(channels.getChannel(id,multisigContract.getHash()) == null);
  storedChannel=new StoredClientChannel(id,multisigContract,refundTx,myKey,valueToMe,refundFees,true);
  channels.putChannel(storedChannel);
  wallet.addOrUpdateExtension(channels);
}",0.9948293691830404
85793,"@Override public void deserializeWalletExtension(Wallet containingWallet,byte[] data) throws Exception {
  lock.lock();
  try {
    checkState(this.containingWallet == null || this.containingWallet == containingWallet);
    this.containingWallet=containingWallet;
    NetworkParameters params=containingWallet.getParams();
    ClientState.StoredClientPaymentChannels states=ClientState.StoredClientPaymentChannels.parseFrom(data);
    for (    ClientState.StoredClientPaymentChannel storedState : states.getChannelsList()) {
      Transaction refundTransaction=new Transaction(params,storedState.getRefundTransaction().toByteArray());
      refundTransaction.getConfidence().setSource(TransactionConfidence.Source.SELF);
      StoredClientChannel channel=new StoredClientChannel(new Sha256Hash(storedState.getId().toByteArray()),new Transaction(params,storedState.getContractTransaction().toByteArray()),refundTransaction,new ECKey(storedState.getMyKey().toByteArray(),null),BigInteger.valueOf(storedState.getValueToMe()),BigInteger.valueOf(storedState.getRefundFees()));
      putChannel(channel,false);
    }
  }
  finally {
    lock.unlock();
  }
}","@Override public void deserializeWalletExtension(Wallet containingWallet,byte[] data) throws Exception {
  lock.lock();
  try {
    checkState(this.containingWallet == null || this.containingWallet == containingWallet);
    this.containingWallet=containingWallet;
    NetworkParameters params=containingWallet.getParams();
    ClientState.StoredClientPaymentChannels states=ClientState.StoredClientPaymentChannels.parseFrom(data);
    for (    ClientState.StoredClientPaymentChannel storedState : states.getChannelsList()) {
      Transaction refundTransaction=new Transaction(params,storedState.getRefundTransaction().toByteArray());
      refundTransaction.getConfidence().setSource(TransactionConfidence.Source.SELF);
      StoredClientChannel channel=new StoredClientChannel(new Sha256Hash(storedState.getId().toByteArray()),new Transaction(params,storedState.getContractTransaction().toByteArray()),refundTransaction,new ECKey(new BigInteger(1,storedState.getMyKey().toByteArray()),null,true),BigInteger.valueOf(storedState.getValueToMe()),BigInteger.valueOf(storedState.getRefundFees()),false);
      putChannel(channel,false);
    }
  }
  finally {
    lock.unlock();
  }
}",0.9832689832689832
85794,"StoredClientChannel(Sha256Hash id,Transaction contract,Transaction refund,ECKey myKey,BigInteger valueToMe,BigInteger refundFees){
  this.id=id;
  this.contract=contract;
  this.refund=refund;
  this.myKey=myKey;
  this.valueToMe=valueToMe;
  this.refundFees=refundFees;
  this.active=true;
}","StoredClientChannel(Sha256Hash id,Transaction contract,Transaction refund,ECKey myKey,BigInteger valueToMe,BigInteger refundFees,boolean active){
  this.id=id;
  this.contract=contract;
  this.refund=refund;
  this.myKey=myKey;
  this.valueToMe=valueToMe;
  this.refundFees=refundFees;
  this.active=active;
}",0.961730449251248
85795,"@Test public void testChannelResume() throws Exception {
  Utils.rollMockClock(0);
  final Sha256Hash someServerId=Sha256Hash.create(new byte[]{});
  ChannelTestUtils.RecordingPair pair=ChannelTestUtils.makeRecorders(serverWallet,mockBroadcaster);
  pair.server.connectionOpen();
  PaymentChannelClient client=new PaymentChannelClient(wallet,myKey,Utils.COIN,someServerId,pair.clientRecorder);
  PaymentChannelServer server=pair.server;
  client.connectionOpen();
  server.receiveMessage(pair.clientRecorder.checkNextMsg(MessageType.CLIENT_VERSION));
  client.receiveMessage(pair.serverRecorder.checkNextMsg(MessageType.SERVER_VERSION));
  client.receiveMessage(pair.serverRecorder.checkNextMsg(MessageType.INITIATE));
  server.receiveMessage(pair.clientRecorder.checkNextMsg(MessageType.PROVIDE_REFUND));
  client.receiveMessage(pair.serverRecorder.checkNextMsg(MessageType.RETURN_REFUND));
  broadcastTxPause.release();
  server.receiveMessage(pair.clientRecorder.checkNextMsg(MessageType.PROVIDE_CONTRACT));
  broadcasts.take();
  client.receiveMessage(pair.serverRecorder.checkNextMsg(MessageType.CHANNEL_OPEN));
  Sha256Hash contractHash=(Sha256Hash)pair.serverRecorder.q.take();
  pair.clientRecorder.checkOpened();
  assertNull(pair.serverRecorder.q.poll());
  assertNull(pair.clientRecorder.q.poll());
  client.incrementPayment(Utils.CENT);
  server.receiveMessage(pair.clientRecorder.checkNextMsg(MessageType.UPDATE_PAYMENT));
  assertEquals(Utils.CENT,pair.serverRecorder.q.take());
  server.close();
  server.connectionClosed();
  client.receiveMessage(pair.serverRecorder.checkNextMsg(MessageType.CLOSE));
  client.connectionClosed();
  assertFalse(client.connectionOpen);
  StoredPaymentChannelClientStates clientStoredChannels=(StoredPaymentChannelClientStates)wallet.getExtensions().get(StoredPaymentChannelClientStates.EXTENSION_ID);
  assertEquals(1,clientStoredChannels.mapChannels.size());
  assertFalse(clientStoredChannels.mapChannels.values().iterator().next().active);
  pair=ChannelTestUtils.makeRecorders(serverWallet,mockBroadcaster);
  pair.server.connectionOpen();
  pair.server.receiveMessage(Protos.TwoWayChannelMessage.newBuilder().setType(MessageType.CLIENT_VERSION).setClientVersion(Protos.ClientVersion.newBuilder().setPreviousChannelContractHash(ByteString.copyFrom(Sha256Hash.create(new byte[]{0x03}).getBytes())).setMajor(0).setMinor(42)).build());
  pair.serverRecorder.checkNextMsg(MessageType.SERVER_VERSION);
  pair.serverRecorder.checkNextMsg(MessageType.INITIATE);
  pair=ChannelTestUtils.makeRecorders(serverWallet,mockBroadcaster);
  client=new PaymentChannelClient(wallet,myKey,Utils.COIN,someServerId,pair.clientRecorder);
  server=pair.server;
  client.connectionOpen();
  server.connectionOpen();
  final Protos.TwoWayChannelMessage clientVersionMsg=pair.clientRecorder.checkNextMsg(MessageType.CLIENT_VERSION);
  assertEquals(contractHash,new Sha256Hash(clientVersionMsg.getClientVersion().getPreviousChannelContractHash().toByteArray()));
  server.receiveMessage(clientVersionMsg);
  client.receiveMessage(pair.serverRecorder.checkNextMsg(MessageType.SERVER_VERSION));
  client.receiveMessage(pair.serverRecorder.checkNextMsg(MessageType.CHANNEL_OPEN));
  assertEquals(contractHash,pair.serverRecorder.q.take());
  pair.clientRecorder.checkOpened();
  assertNull(pair.serverRecorder.q.poll());
  assertNull(pair.clientRecorder.q.poll());
  client.incrementPayment(Utils.CENT);
  server.receiveMessage(pair.clientRecorder.checkNextMsg(MessageType.UPDATE_PAYMENT));
  pair.serverRecorder.checkTotalPayment(Utils.CENT.multiply(BigInteger.valueOf(2)));
  PaymentChannelClient openClient=client;
  ChannelTestUtils.RecordingPair openPair=pair;
  pair=ChannelTestUtils.makeRecorders(serverWallet,mockBroadcaster);
  client=new PaymentChannelClient(wallet,myKey,Utils.COIN,someServerId,pair.clientRecorder);
  server=pair.server;
  client.connectionOpen();
  server.connectionOpen();
{
    Protos.TwoWayChannelMessage msg=pair.clientRecorder.checkNextMsg(MessageType.CLIENT_VERSION);
    assertFalse(msg.getClientVersion().hasPreviousChannelContractHash());
  }
  pair=ChannelTestUtils.makeRecorders(serverWallet,mockBroadcaster);
  client=new PaymentChannelClient(wallet,myKey,Utils.COIN,someServerId,pair.clientRecorder);
  server=pair.server;
  client.connectionOpen();
  server.connectionOpen();
  pair.clientRecorder.getNextMsg();
  server.receiveMessage(Protos.TwoWayChannelMessage.newBuilder().setType(MessageType.CLIENT_VERSION).setClientVersion(Protos.ClientVersion.newBuilder().setPreviousChannelContractHash(ByteString.copyFrom(contractHash.getBytes())).setMajor(0).setMinor(42)).build());
  client.receiveMessage(pair.serverRecorder.checkNextMsg(MessageType.SERVER_VERSION));
  client.receiveMessage(pair.serverRecorder.checkNextMsg(MessageType.INITIATE));
  server.receiveMessage(pair.clientRecorder.checkNextMsg(MessageType.PROVIDE_REFUND));
  client.receiveMessage(pair.serverRecorder.checkNextMsg(MessageType.RETURN_REFUND));
  broadcastTxPause.release();
  server.receiveMessage(pair.clientRecorder.checkNextMsg(MessageType.PROVIDE_CONTRACT));
  broadcasts.take();
  client.receiveMessage(pair.serverRecorder.checkNextMsg(MessageType.CHANNEL_OPEN));
  Sha256Hash secondContractHash=(Sha256Hash)pair.serverRecorder.q.take();
  pair.clientRecorder.checkOpened();
  assertNull(pair.serverRecorder.q.poll());
  assertNull(pair.clientRecorder.q.poll());
  client.close();
  client.connectionClosed();
  pair.server.close();
  pair.server.connectionClosed();
  pair=ChannelTestUtils.makeRecorders(serverWallet,mockBroadcaster);
  client=new PaymentChannelClient(wallet,myKey,Utils.COIN,someServerId,pair.clientRecorder);
  server=pair.server;
  client.connectionOpen();
  server.connectionOpen();
{
    Protos.TwoWayChannelMessage msg=pair.clientRecorder.checkNextMsg(MessageType.CLIENT_VERSION);
    assertEquals(secondContractHash,new Sha256Hash(msg.getClientVersion().getPreviousChannelContractHash().toByteArray()));
    server.receiveMessage(msg);
  }
  client.receiveMessage(pair.serverRecorder.checkNextMsg(MessageType.SERVER_VERSION));
  client.receiveMessage(pair.serverRecorder.checkNextMsg(MessageType.CHANNEL_OPEN));
  pair.clientRecorder.checkOpened();
  assertEquals(2,clientStoredChannels.mapChannels.size());
  broadcastTxPause.release();
  client.close();
  server.receiveMessage(pair.clientRecorder.checkNextMsg(MessageType.CLOSE));
  assertEquals(CloseReason.CLIENT_REQUESTED_CLOSE,pair.clientRecorder.q.take());
  server.connectionClosed();
  client.connectionClosed();
  assertFalse(clientStoredChannels.getChannel(Sha256Hash.create(new byte[]{}),secondContractHash).active);
  assertTrue(clientStoredChannels.getChannel(Sha256Hash.create(new byte[]{}),contractHash).active);
  openClient.connectionClosed();
  assertFalse(clientStoredChannels.getChannel(Sha256Hash.create(new byte[]{}),contractHash).active);
  Utils.rollMockClock(60 * 60 * 24 + 60 * 5);
  StoredPaymentChannelClientStates newClientStates=new StoredPaymentChannelClientStates(mockBroadcaster,wallet);
  newClientStates.deserializeWalletExtension(wallet,clientStoredChannels.serializeWalletExtension());
  for (int i=0; i < 2; i++) {
    broadcastTxPause.release();
    assertTrue(broadcasts.take().getOutput(0).getScriptPubKey().isSentToMultiSig());
    broadcastTxPause.release();
    assertEquals(TransactionConfidence.Source.SELF,broadcasts.take().getConfidence().getSource());
  }
  assertTrue(broadcasts.isEmpty());
  assertTrue(newClientStates.mapChannels.isEmpty());
  StoredPaymentChannelServerStates serverStoredChannels=new StoredPaymentChannelServerStates(serverWallet,mockBroadcaster);
  Thread.sleep(2000);
  assertTrue(serverStoredChannels.mapChannels.isEmpty());
}","@Test public void testChannelResume() throws Exception {
  Utils.rollMockClock(0);
  final Sha256Hash someServerId=Sha256Hash.create(new byte[]{});
  ChannelTestUtils.RecordingPair pair=ChannelTestUtils.makeRecorders(serverWallet,mockBroadcaster);
  pair.server.connectionOpen();
  PaymentChannelClient client=new PaymentChannelClient(wallet,myKey,Utils.COIN,someServerId,pair.clientRecorder);
  PaymentChannelServer server=pair.server;
  client.connectionOpen();
  server.receiveMessage(pair.clientRecorder.checkNextMsg(MessageType.CLIENT_VERSION));
  client.receiveMessage(pair.serverRecorder.checkNextMsg(MessageType.SERVER_VERSION));
  client.receiveMessage(pair.serverRecorder.checkNextMsg(MessageType.INITIATE));
  server.receiveMessage(pair.clientRecorder.checkNextMsg(MessageType.PROVIDE_REFUND));
  client.receiveMessage(pair.serverRecorder.checkNextMsg(MessageType.RETURN_REFUND));
  broadcastTxPause.release();
  server.receiveMessage(pair.clientRecorder.checkNextMsg(MessageType.PROVIDE_CONTRACT));
  broadcasts.take();
  client.receiveMessage(pair.serverRecorder.checkNextMsg(MessageType.CHANNEL_OPEN));
  Sha256Hash contractHash=(Sha256Hash)pair.serverRecorder.q.take();
  pair.clientRecorder.checkOpened();
  assertNull(pair.serverRecorder.q.poll());
  assertNull(pair.clientRecorder.q.poll());
  client.incrementPayment(Utils.CENT);
  server.receiveMessage(pair.clientRecorder.checkNextMsg(MessageType.UPDATE_PAYMENT));
  assertEquals(Utils.CENT,pair.serverRecorder.q.take());
  server.close();
  server.connectionClosed();
  client.receiveMessage(pair.serverRecorder.checkNextMsg(MessageType.CLOSE));
  client.connectionClosed();
  assertFalse(client.connectionOpen);
  StoredPaymentChannelClientStates clientStoredChannels=(StoredPaymentChannelClientStates)wallet.getExtensions().get(StoredPaymentChannelClientStates.EXTENSION_ID);
  assertEquals(1,clientStoredChannels.mapChannels.size());
  assertFalse(clientStoredChannels.mapChannels.values().iterator().next().active);
  pair=ChannelTestUtils.makeRecorders(serverWallet,mockBroadcaster);
  pair.server.connectionOpen();
  pair.server.receiveMessage(Protos.TwoWayChannelMessage.newBuilder().setType(MessageType.CLIENT_VERSION).setClientVersion(Protos.ClientVersion.newBuilder().setPreviousChannelContractHash(ByteString.copyFrom(Sha256Hash.create(new byte[]{0x03}).getBytes())).setMajor(0).setMinor(42)).build());
  pair.serverRecorder.checkNextMsg(MessageType.SERVER_VERSION);
  pair.serverRecorder.checkNextMsg(MessageType.INITIATE);
  wallet=roundTripClientWallet(wallet);
  serverWallet=roundTripServerWallet(serverWallet);
  clientStoredChannels=(StoredPaymentChannelClientStates)wallet.getExtensions().get(StoredPaymentChannelClientStates.EXTENSION_ID);
  pair=ChannelTestUtils.makeRecorders(serverWallet,mockBroadcaster);
  client=new PaymentChannelClient(wallet,myKey,Utils.COIN,someServerId,pair.clientRecorder);
  server=pair.server;
  client.connectionOpen();
  server.connectionOpen();
  final Protos.TwoWayChannelMessage clientVersionMsg=pair.clientRecorder.checkNextMsg(MessageType.CLIENT_VERSION);
  assertTrue(clientVersionMsg.getClientVersion().hasPreviousChannelContractHash());
  assertEquals(contractHash,new Sha256Hash(clientVersionMsg.getClientVersion().getPreviousChannelContractHash().toByteArray()));
  server.receiveMessage(clientVersionMsg);
  client.receiveMessage(pair.serverRecorder.checkNextMsg(MessageType.SERVER_VERSION));
  client.receiveMessage(pair.serverRecorder.checkNextMsg(MessageType.CHANNEL_OPEN));
  assertEquals(contractHash,pair.serverRecorder.q.take());
  pair.clientRecorder.checkOpened();
  assertNull(pair.serverRecorder.q.poll());
  assertNull(pair.clientRecorder.q.poll());
  client.incrementPayment(Utils.CENT);
  server.receiveMessage(pair.clientRecorder.checkNextMsg(MessageType.UPDATE_PAYMENT));
  pair.serverRecorder.checkTotalPayment(Utils.CENT.multiply(BigInteger.valueOf(2)));
  PaymentChannelClient openClient=client;
  ChannelTestUtils.RecordingPair openPair=pair;
  pair=ChannelTestUtils.makeRecorders(serverWallet,mockBroadcaster);
  client=new PaymentChannelClient(wallet,myKey,Utils.COIN,someServerId,pair.clientRecorder);
  server=pair.server;
  client.connectionOpen();
  server.connectionOpen();
{
    Protos.TwoWayChannelMessage msg=pair.clientRecorder.checkNextMsg(MessageType.CLIENT_VERSION);
    assertFalse(msg.getClientVersion().hasPreviousChannelContractHash());
  }
  pair=ChannelTestUtils.makeRecorders(serverWallet,mockBroadcaster);
  client=new PaymentChannelClient(wallet,myKey,Utils.COIN,someServerId,pair.clientRecorder);
  server=pair.server;
  client.connectionOpen();
  server.connectionOpen();
  pair.clientRecorder.getNextMsg();
  server.receiveMessage(Protos.TwoWayChannelMessage.newBuilder().setType(MessageType.CLIENT_VERSION).setClientVersion(Protos.ClientVersion.newBuilder().setPreviousChannelContractHash(ByteString.copyFrom(contractHash.getBytes())).setMajor(0).setMinor(42)).build());
  client.receiveMessage(pair.serverRecorder.checkNextMsg(MessageType.SERVER_VERSION));
  client.receiveMessage(pair.serverRecorder.checkNextMsg(MessageType.INITIATE));
  server.receiveMessage(pair.clientRecorder.checkNextMsg(MessageType.PROVIDE_REFUND));
  client.receiveMessage(pair.serverRecorder.checkNextMsg(MessageType.RETURN_REFUND));
  broadcastTxPause.release();
  server.receiveMessage(pair.clientRecorder.checkNextMsg(MessageType.PROVIDE_CONTRACT));
  broadcasts.take();
  client.receiveMessage(pair.serverRecorder.checkNextMsg(MessageType.CHANNEL_OPEN));
  Sha256Hash secondContractHash=(Sha256Hash)pair.serverRecorder.q.take();
  pair.clientRecorder.checkOpened();
  assertNull(pair.serverRecorder.q.poll());
  assertNull(pair.clientRecorder.q.poll());
  client.close();
  client.connectionClosed();
  pair.server.close();
  pair.server.connectionClosed();
  pair=ChannelTestUtils.makeRecorders(serverWallet,mockBroadcaster);
  client=new PaymentChannelClient(wallet,myKey,Utils.COIN,someServerId,pair.clientRecorder);
  server=pair.server;
  client.connectionOpen();
  server.connectionOpen();
{
    Protos.TwoWayChannelMessage msg=pair.clientRecorder.checkNextMsg(MessageType.CLIENT_VERSION);
    assertEquals(secondContractHash,new Sha256Hash(msg.getClientVersion().getPreviousChannelContractHash().toByteArray()));
    server.receiveMessage(msg);
  }
  client.receiveMessage(pair.serverRecorder.checkNextMsg(MessageType.SERVER_VERSION));
  client.receiveMessage(pair.serverRecorder.checkNextMsg(MessageType.CHANNEL_OPEN));
  pair.clientRecorder.checkOpened();
  assertEquals(2,clientStoredChannels.mapChannels.size());
  broadcastTxPause.release();
  client.close();
  server.receiveMessage(pair.clientRecorder.checkNextMsg(MessageType.CLOSE));
  assertEquals(CloseReason.CLIENT_REQUESTED_CLOSE,pair.clientRecorder.q.take());
  server.connectionClosed();
  client.connectionClosed();
  assertFalse(clientStoredChannels.getChannel(Sha256Hash.create(new byte[]{}),secondContractHash).active);
  assertTrue(clientStoredChannels.getChannel(Sha256Hash.create(new byte[]{}),contractHash).active);
  openClient.connectionClosed();
  assertFalse(clientStoredChannels.getChannel(Sha256Hash.create(new byte[]{}),contractHash).active);
  Utils.rollMockClock(60 * 60 * 24 + 60 * 5);
  StoredPaymentChannelClientStates newClientStates=new StoredPaymentChannelClientStates(mockBroadcaster,wallet);
  newClientStates.deserializeWalletExtension(wallet,clientStoredChannels.serializeWalletExtension());
  for (int i=0; i < 2; i++) {
    broadcastTxPause.release();
    assertTrue(broadcasts.take().getOutput(0).getScriptPubKey().isSentToMultiSig());
    broadcastTxPause.release();
    assertEquals(TransactionConfidence.Source.SELF,broadcasts.take().getConfidence().getSource());
  }
  assertTrue(broadcasts.isEmpty());
  assertTrue(newClientStates.mapChannels.isEmpty());
  StoredPaymentChannelServerStates serverStoredChannels=new StoredPaymentChannelServerStates(serverWallet,mockBroadcaster);
  Thread.sleep(2000);
  assertTrue(serverStoredChannels.mapChannels.isEmpty());
}",0.9804494096737336
85796,"@Before public void setUp() throws Exception {
  super.setUp();
  sendMoneyToWallet(Utils.COIN,AbstractBlockChain.NewBlockType.BEST_CHAIN);
  sendMoneyToWallet(Utils.COIN,AbstractBlockChain.NewBlockType.BEST_CHAIN);
  wallet.addExtension(new StoredPaymentChannelClientStates(new TransactionBroadcaster(){
    @Override public ListenableFuture<Transaction> broadcastTransaction(    Transaction tx){
      fail();
      return null;
    }
  }
,wallet));
  chain=new BlockChain(params,wallet,blockStore);
  serverWallet=new Wallet(params);
  serverWallet.addKey(new ECKey());
  chain.addWallet(serverWallet);
  fail=new AtomicBoolean(false);
  broadcasts=new LinkedBlockingQueue<Transaction>();
  broadcastTxPause=new Semaphore(0);
  mockBroadcaster=new TransactionBroadcaster(){
    @Override public ListenableFuture<Transaction> broadcastTransaction(    Transaction tx){
      broadcastTxPause.acquireUninterruptibly();
      SettableFuture<Transaction> future=SettableFuture.create();
      future.set(tx);
      broadcasts.add(tx);
      return future;
    }
  }
;
  Threading.warnOnLockCycles();
}","@Before public void setUp() throws Exception {
  super.setUp();
  sendMoneyToWallet(Utils.COIN,AbstractBlockChain.NewBlockType.BEST_CHAIN);
  sendMoneyToWallet(Utils.COIN,AbstractBlockChain.NewBlockType.BEST_CHAIN);
  wallet.addExtension(new StoredPaymentChannelClientStates(failBroadcaster,wallet));
  chain=new BlockChain(params,wallet,blockStore);
  serverWallet=new Wallet(params);
  serverWallet.addExtension(new StoredPaymentChannelServerStates(serverWallet,failBroadcaster));
  serverWallet.addKey(new ECKey());
  chain.addWallet(serverWallet);
  fail=new AtomicBoolean(false);
  broadcasts=new LinkedBlockingQueue<Transaction>();
  broadcastTxPause=new Semaphore(0);
  mockBroadcaster=new TransactionBroadcaster(){
    @Override public ListenableFuture<Transaction> broadcastTransaction(    Transaction tx){
      broadcastTxPause.acquireUninterruptibly();
      SettableFuture<Transaction> future=SettableFuture.create();
      future.set(tx);
      broadcasts.add(tx);
      return future;
    }
  }
;
  Threading.warnOnLockCycles();
}",0.5848880597014925
85797,"/** 
 * Called when a message is received from the server. Processes the given message and generates events based on its content.
 */
public void receiveMessage(Protos.TwoWayChannelMessage msg){
  lock.lock();
  try {
    checkState(connectionOpen);
    Protos.Error.Builder errorBuilder;
    CloseReason closeReason;
    try {
switch (msg.getType()) {
case SERVER_VERSION:
        checkState(step == InitStep.WAITING_FOR_VERSION_NEGOTIATION && msg.hasServerVersion());
      if (msg.getServerVersion().getMajor() != 0) {
        errorBuilder=Protos.Error.newBuilder().setCode(Protos.Error.ErrorCode.NO_ACCEPTABLE_VERSION);
        closeReason=CloseReason.NO_ACCEPTABLE_VERSION;
        break;
      }
    log.info(""String_Node_Str"");
  step=InitStep.WAITING_FOR_INITIATE;
return;
case INITIATE:
checkState(step == InitStep.WAITING_FOR_INITIATE && msg.hasInitiate());
Protos.Initiate initiate=msg.getInitiate();
checkState(initiate.getExpireTimeSecs() > 0 && initiate.getMinAcceptedChannelSize() >= 0);
if (initiate.getExpireTimeSecs() > Utils.now().getTime() / 1000 + MAX_TIME_WINDOW) {
errorBuilder=Protos.Error.newBuilder().setCode(Protos.Error.ErrorCode.TIME_WINDOW_TOO_LARGE);
closeReason=CloseReason.TIME_WINDOW_TOO_LARGE;
break;
}
BigInteger minChannelSize=BigInteger.valueOf(initiate.getMinAcceptedChannelSize());
if (minChannelSize.compareTo(maxValue) > 0) {
errorBuilder=Protos.Error.newBuilder().setCode(Protos.Error.ErrorCode.CHANNEL_VALUE_TOO_LARGE);
closeReason=CloseReason.SERVER_REQUESTED_TOO_MUCH_VALUE;
break;
}
receiveInitiate(initiate,minChannelSize);
return;
case RETURN_REFUND:
receiveRefund(msg);
return;
case CHANNEL_OPEN:
receiveChannelOpen();
return;
case CLOSE:
conn.destroyConnection(CloseReason.SERVER_REQUESTED_CLOSE);
return;
case ERROR:
checkState(msg.hasError());
log.error(""String_Node_Str"",msg.getError().getCode().name(),msg.getError().hasExplanation() ? msg.getError().getExplanation() : ""String_Node_Str"");
conn.destroyConnection(CloseReason.REMOTE_SENT_ERROR);
return;
default :
log.error(""String_Node_Str"");
errorBuilder=Protos.Error.newBuilder().setCode(Protos.Error.ErrorCode.SYNTAX_ERROR);
closeReason=CloseReason.REMOTE_SENT_INVALID_MESSAGE;
break;
}
}
 catch (VerificationException e) {
log.error(""String_Node_Str"",e);
errorBuilder=Protos.Error.newBuilder().setCode(Protos.Error.ErrorCode.BAD_TRANSACTION).setExplanation(e.getMessage());
closeReason=CloseReason.REMOTE_SENT_INVALID_MESSAGE;
}
catch (ValueOutOfRangeException e) {
log.error(""String_Node_Str"",e);
errorBuilder=Protos.Error.newBuilder().setCode(Protos.Error.ErrorCode.BAD_TRANSACTION).setExplanation(e.getMessage());
closeReason=CloseReason.REMOTE_SENT_INVALID_MESSAGE;
}
catch (IllegalStateException e) {
log.error(""String_Node_Str"",e);
errorBuilder=Protos.Error.newBuilder().setCode(Protos.Error.ErrorCode.SYNTAX_ERROR);
closeReason=CloseReason.REMOTE_SENT_INVALID_MESSAGE;
}
conn.sendToServer(Protos.TwoWayChannelMessage.newBuilder().setError(errorBuilder).setType(Protos.TwoWayChannelMessage.MessageType.ERROR).build());
conn.destroyConnection(closeReason);
}
  finally {
lock.unlock();
}
}","/** 
 * Called when a message is received from the server. Processes the given message and generates events based on its content.
 */
public void receiveMessage(Protos.TwoWayChannelMessage msg){
  lock.lock();
  try {
    checkState(connectionOpen);
    Protos.Error.Builder errorBuilder;
    CloseReason closeReason;
    try {
switch (msg.getType()) {
case SERVER_VERSION:
        checkState(step == InitStep.WAITING_FOR_VERSION_NEGOTIATION && msg.hasServerVersion());
      if (msg.getServerVersion().getMajor() != 0) {
        errorBuilder=Protos.Error.newBuilder().setCode(Protos.Error.ErrorCode.NO_ACCEPTABLE_VERSION);
        closeReason=CloseReason.NO_ACCEPTABLE_VERSION;
        break;
      }
    log.info(""String_Node_Str"");
  step=InitStep.WAITING_FOR_INITIATE;
return;
case INITIATE:
checkState(step == InitStep.WAITING_FOR_INITIATE && msg.hasInitiate());
Protos.Initiate initiate=msg.getInitiate();
checkState(initiate.getExpireTimeSecs() > 0 && initiate.getMinAcceptedChannelSize() >= 0);
if (initiate.getExpireTimeSecs() > Utils.now().getTime() / 1000 + MAX_TIME_WINDOW) {
errorBuilder=Protos.Error.newBuilder().setCode(Protos.Error.ErrorCode.TIME_WINDOW_TOO_LARGE);
closeReason=CloseReason.TIME_WINDOW_TOO_LARGE;
break;
}
BigInteger minChannelSize=BigInteger.valueOf(initiate.getMinAcceptedChannelSize());
if (maxValue.compareTo(minChannelSize) < 0) {
errorBuilder=Protos.Error.newBuilder().setCode(Protos.Error.ErrorCode.CHANNEL_VALUE_TOO_LARGE);
closeReason=CloseReason.SERVER_REQUESTED_TOO_MUCH_VALUE;
break;
}
receiveInitiate(initiate,maxValue);
return;
case RETURN_REFUND:
receiveRefund(msg);
return;
case CHANNEL_OPEN:
receiveChannelOpen();
return;
case CLOSE:
conn.destroyConnection(CloseReason.SERVER_REQUESTED_CLOSE);
return;
case ERROR:
checkState(msg.hasError());
log.error(""String_Node_Str"",msg.getError().getCode().name(),msg.getError().hasExplanation() ? msg.getError().getExplanation() : ""String_Node_Str"");
conn.destroyConnection(CloseReason.REMOTE_SENT_ERROR);
return;
default :
log.error(""String_Node_Str"");
errorBuilder=Protos.Error.newBuilder().setCode(Protos.Error.ErrorCode.SYNTAX_ERROR);
closeReason=CloseReason.REMOTE_SENT_INVALID_MESSAGE;
break;
}
}
 catch (VerificationException e) {
log.error(""String_Node_Str"",e);
errorBuilder=Protos.Error.newBuilder().setCode(Protos.Error.ErrorCode.BAD_TRANSACTION).setExplanation(e.getMessage());
closeReason=CloseReason.REMOTE_SENT_INVALID_MESSAGE;
}
catch (ValueOutOfRangeException e) {
log.error(""String_Node_Str"",e);
errorBuilder=Protos.Error.newBuilder().setCode(Protos.Error.ErrorCode.BAD_TRANSACTION).setExplanation(e.getMessage());
closeReason=CloseReason.REMOTE_SENT_INVALID_MESSAGE;
}
catch (IllegalStateException e) {
log.error(""String_Node_Str"",e);
errorBuilder=Protos.Error.newBuilder().setCode(Protos.Error.ErrorCode.SYNTAX_ERROR);
closeReason=CloseReason.REMOTE_SENT_INVALID_MESSAGE;
}
conn.sendToServer(Protos.TwoWayChannelMessage.newBuilder().setError(errorBuilder).setType(Protos.TwoWayChannelMessage.MessageType.ERROR).build());
conn.destroyConnection(closeReason);
}
  finally {
lock.unlock();
}
}",0.9293548387096774
85798,"@GuardedBy(""String_Node_Str"") private void receiveInitiate(Protos.Initiate initiate,BigInteger minChannelSize) throws VerificationException, ValueOutOfRangeException {
  log.info(""String_Node_Str"");
  state=new PaymentChannelClientState(wallet,myKey,new ECKey(null,initiate.getMultisigKey().toByteArray()),minChannelSize,initiate.getExpireTimeSecs());
  state.initiate();
  step=InitStep.WAITING_FOR_REFUND_RETURN;
  Protos.ProvideRefund.Builder provideRefundBuilder=Protos.ProvideRefund.newBuilder().setMultisigKey(ByteString.copyFrom(myKey.getPubKey())).setTx(ByteString.copyFrom(state.getIncompleteRefundTransaction().bitcoinSerialize()));
  conn.sendToServer(Protos.TwoWayChannelMessage.newBuilder().setProvideRefund(provideRefundBuilder).setType(Protos.TwoWayChannelMessage.MessageType.PROVIDE_REFUND).build());
}","@GuardedBy(""String_Node_Str"") private void receiveInitiate(Protos.Initiate initiate,BigInteger contractValue) throws VerificationException, ValueOutOfRangeException {
  log.info(""String_Node_Str"");
  state=new PaymentChannelClientState(wallet,myKey,new ECKey(null,initiate.getMultisigKey().toByteArray()),contractValue,initiate.getExpireTimeSecs());
  state.initiate();
  step=InitStep.WAITING_FOR_REFUND_RETURN;
  Protos.ProvideRefund.Builder provideRefundBuilder=Protos.ProvideRefund.newBuilder().setMultisigKey(ByteString.copyFrom(myKey.getPubKey())).setTx(ByteString.copyFrom(state.getIncompleteRefundTransaction().bitcoinSerialize()));
  conn.sendToServer(Protos.TwoWayChannelMessage.newBuilder().setProvideRefund(provideRefundBuilder).setType(Protos.TwoWayChannelMessage.MessageType.PROVIDE_REFUND).build());
}",0.9694002447980417
85799,"/** 
 * Password based encryption using AES - CBC 256 bits.
 */
@Override public EncryptedPrivateKey encrypt(byte[] plainBytes,KeyParameter aesKey) throws KeyCrypterException {
  Preconditions.checkNotNull(plainBytes);
  Preconditions.checkNotNull(aesKey);
  try {
    byte[] iv=new byte[BLOCK_LENGTH];
    secureRandom.nextBytes(iv);
    ParametersWithIV keyWithIv=new ParametersWithIV(aesKey,iv);
    BufferedBlockCipher cipher=new PaddedBufferedBlockCipher(new CBCBlockCipher(new AESFastEngine()));
    cipher.init(true,keyWithIv);
    byte[] encryptedBytes=new byte[cipher.getOutputSize(plainBytes.length)];
    int length=cipher.processBytes(plainBytes,0,plainBytes.length,encryptedBytes,0);
    cipher.doFinal(encryptedBytes,length);
    return new EncryptedPrivateKey(iv,encryptedBytes);
  }
 catch (  Exception e) {
    throw new KeyCrypterException(""String_Node_Str"",e);
  }
}","/** 
 * Password based encryption using AES - CBC 256 bits.
 */
@Override public EncryptedPrivateKey encrypt(byte[] plainBytes,KeyParameter aesKey) throws KeyCrypterException {
  checkNotNull(plainBytes);
  checkNotNull(aesKey);
  try {
    byte[] iv=new byte[BLOCK_LENGTH];
    secureRandom.nextBytes(iv);
    ParametersWithIV keyWithIv=new ParametersWithIV(aesKey,iv);
    BufferedBlockCipher cipher=new PaddedBufferedBlockCipher(new CBCBlockCipher(new AESFastEngine()));
    cipher.init(true,keyWithIv);
    byte[] encryptedBytes=new byte[cipher.getOutputSize(plainBytes.length)];
    int length=cipher.processBytes(plainBytes,0,plainBytes.length,encryptedBytes,0);
    cipher.doFinal(encryptedBytes,length);
    return new EncryptedPrivateKey(iv,encryptedBytes);
  }
 catch (  Exception e) {
    throw new KeyCrypterException(""String_Node_Str"",e);
  }
}",0.983926521239954
85800,"/** 
 * Convert a CharSequence (which are UTF16) into a byte array. Note: a String.getBytes() is not used to avoid creating a String of the password in the JVM.
 */
private byte[] convertToByteArray(CharSequence charSequence){
  Preconditions.checkNotNull(charSequence);
  byte[] byteArray=new byte[charSequence.length() << 1];
  for (int i=0; i < charSequence.length(); i++) {
    int bytePosition=i << 1;
    byteArray[bytePosition]=(byte)((charSequence.charAt(i) & 0xFF00) >> 8);
    byteArray[bytePosition + 1]=(byte)(charSequence.charAt(i) & 0x00FF);
  }
  return byteArray;
}","/** 
 * Convert a CharSequence (which are UTF16) into a byte array. Note: a String.getBytes() is not used to avoid creating a String of the password in the JVM.
 */
private static byte[] convertToByteArray(CharSequence charSequence){
  checkNotNull(charSequence);
  byte[] byteArray=new byte[charSequence.length() << 1];
  for (int i=0; i < charSequence.length(); i++) {
    int bytePosition=i << 1;
    byteArray[bytePosition]=(byte)((charSequence.charAt(i) & 0xFF00) >> 8);
    byteArray[bytePosition + 1]=(byte)(charSequence.charAt(i) & 0x00FF);
  }
  return byteArray;
}",0.9818181818181818
85801,"/** 
 * Encryption/ Decryption using specified Scrypt parameters.
 * @param scryptParameters ScryptParameters to use
 * @throws NullPointerException if the scryptParameters or any of its N, R or P is null.
 */
public KeyCrypterScrypt(ScryptParameters scryptParameters){
  this.scryptParameters=Preconditions.checkNotNull(scryptParameters);
  if (scryptParameters.getSalt() == null || scryptParameters.getSalt().toByteArray() == null || scryptParameters.getSalt().toByteArray().length == 0) {
    log.warn(""String_Node_Str"");
  }
}","/** 
 * Encryption/ Decryption using specified Scrypt parameters.
 * @param scryptParameters ScryptParameters to use
 * @throws NullPointerException if the scryptParameters or any of its N, R or P is null.
 */
public KeyCrypterScrypt(ScryptParameters scryptParameters){
  this.scryptParameters=checkNotNull(scryptParameters);
  if (scryptParameters.getSalt() == null || scryptParameters.getSalt().toByteArray() == null || scryptParameters.getSalt().toByteArray().length == 0) {
    log.warn(""String_Node_Str"");
  }
}",0.9866156787762906
85802,"/** 
 * Decrypt bytes previously encrypted with this class.
 * @param privateKeyToDecode    The private key to decrypt
 * @param aesKey           The AES key to use for decryption
 * @return                 The decrypted bytes
 * @throws KeyCrypterException if bytes could not be decoded to a valid key
 */
@Override public byte[] decrypt(EncryptedPrivateKey privateKeyToDecode,KeyParameter aesKey) throws KeyCrypterException {
  Preconditions.checkNotNull(privateKeyToDecode);
  Preconditions.checkNotNull(aesKey);
  try {
    ParametersWithIV keyWithIv=new ParametersWithIV(new KeyParameter(aesKey.getKey()),privateKeyToDecode.getInitialisationVector());
    BufferedBlockCipher cipher=new PaddedBufferedBlockCipher(new CBCBlockCipher(new AESFastEngine()));
    cipher.init(false,keyWithIv);
    byte[] cipherBytes=privateKeyToDecode.getEncryptedBytes();
    int minimumSize=cipher.getOutputSize(cipherBytes.length);
    byte[] outputBuffer=new byte[minimumSize];
    int length1=cipher.processBytes(cipherBytes,0,cipherBytes.length,outputBuffer,0);
    int length2=cipher.doFinal(outputBuffer,length1);
    int actualLength=length1 + length2;
    byte[] decryptedBytes=new byte[actualLength];
    System.arraycopy(outputBuffer,0,decryptedBytes,0,actualLength);
    return decryptedBytes;
  }
 catch (  Exception e) {
    throw new KeyCrypterException(""String_Node_Str"",e);
  }
}","/** 
 * Decrypt bytes previously encrypted with this class.
 * @param privateKeyToDecode    The private key to decrypt
 * @param aesKey           The AES key to use for decryption
 * @return                 The decrypted bytes
 * @throws KeyCrypterException if bytes could not be decoded to a valid key
 */
@Override public byte[] decrypt(EncryptedPrivateKey privateKeyToDecode,KeyParameter aesKey) throws KeyCrypterException {
  checkNotNull(privateKeyToDecode);
  checkNotNull(aesKey);
  try {
    ParametersWithIV keyWithIv=new ParametersWithIV(new KeyParameter(aesKey.getKey()),privateKeyToDecode.getInitialisationVector());
    BufferedBlockCipher cipher=new PaddedBufferedBlockCipher(new CBCBlockCipher(new AESFastEngine()));
    cipher.init(false,keyWithIv);
    byte[] cipherBytes=privateKeyToDecode.getEncryptedBytes();
    int minimumSize=cipher.getOutputSize(cipherBytes.length);
    byte[] outputBuffer=new byte[minimumSize];
    int length1=cipher.processBytes(cipherBytes,0,cipherBytes.length,outputBuffer,0);
    int length2=cipher.doFinal(outputBuffer,length1);
    int actualLength=length1 + length2;
    byte[] decryptedBytes=new byte[actualLength];
    System.arraycopy(outputBuffer,0,decryptedBytes,0,actualLength);
    return decryptedBytes;
  }
 catch (  Exception e) {
    throw new KeyCrypterException(""String_Node_Str"",e);
  }
}",0.9897585954645208
85803,"/** 
 * Contruct a block object from the Bitcoin wire format.
 * @param params NetworkParameters object.
 * @param parseLazy Whether to perform a full parse immediately or delay until a read is requested.
 * @param parseRetain Whether to retain the backing byte array for quick reserialization.  If true and the backing byte array is invalidated due to modification of a field then  the cached bytes may be repopulated and retained if the message is serialized again in the future.
 * @param length The length of message if known.  Usually this is provided when deserializing of the wireas the length will be provided as part of the header.  If unknown then set to Message.UNKNOWN_LENGTH
 * @throws ProtocolException
 */
public Block(NetworkParameters params,byte[] payloadBytes,boolean parseLazy,boolean parseRetain,int length) throws ProtocolException {
  super(params,payloadBytes,0,parseLazy,parseRetain,length);
}","/** 
 * Construct a block initialized with all the given fields.
 * @param params Which network the block is for.
 * @param version This should usually be set to 1 or 2, depending on if the height is in the coinbase input.
 * @param prevBlockHash Reference to previous block in the chain or {@link Sha256Hash#ZERO_HASH} if genesis.
 * @param merkleRoot The root of the merkle tree formed by the transactions.
 * @param time UNIX time when the block was mined.
 * @param difficultyTarget Number which this block hashes lower than.
 * @param nonce Arbitrary number to make the block hash lower than the target.
 * @param transactions List of transactions including the coinbase.
 */
public Block(NetworkParameters params,long version,Sha256Hash prevBlockHash,Sha256Hash merkleRoot,long time,long difficultyTarget,long nonce,List<Transaction> transactions){
  super(params);
  this.version=version;
  this.prevBlockHash=prevBlockHash;
  this.merkleRoot=merkleRoot;
  this.time=time;
  this.difficultyTarget=difficultyTarget;
  this.nonce=nonce;
  this.transactions=new LinkedList<Transaction>();
  this.transactions.addAll(transactions);
}",0.1041869522882181
85804,"/** 
 * Called when download is initiated.
 * @param blocks the number of blocks to download, estimated
 */
protected void startDownload(int blocks){
  if (blocks > 0)   System.out.println(""String_Node_Str"" + blocks + ""String_Node_Str""+ (blocks > 1000 ? ""String_Node_Str"" : ""String_Node_Str""));
}","/** 
 * Called when download is initiated.
 * @param blocks the number of blocks to download, estimated
 */
protected void startDownload(int blocks){
  if (blocks > 0)   log.info(""String_Node_Str"" + blocks + ""String_Node_Str""+ (blocks > 1000 ? ""String_Node_Str"" : ""String_Node_Str""));
}",0.9587628865979382
85805,"/** 
 * Called when download progress is made.
 * @param pct  the percentage of chain downloaded, estimated
 * @param date the date of the last block downloaded
 */
protected void progress(double pct,int blocksSoFar,Date date){
  System.out.println(String.format(""String_Node_Str"",(int)pct,blocksSoFar,DateFormat.getDateTimeInstance().format(date)));
}","/** 
 * Called when download progress is made.
 * @param pct  the percentage of chain downloaded, estimated
 * @param date the date of the last block downloaded
 */
protected void progress(double pct,int blocksSoFar,Date date){
  log.info(String.format(""String_Node_Str"",(int)pct,blocksSoFar,DateFormat.getDateTimeInstance().format(date)));
}",0.962536023054755
85806,"@Test public void testLazyParsing() throws Exception {
  BitcoinSerializer bs=new BitcoinSerializer(MainNetParams.get(),true,false);
  ByteArrayInputStream bais=new ByteArrayInputStream(txMessage);
  Transaction tx=(Transaction)bs.deserialize(bais);
  assertNotNull(tx);
  assertEquals(false,tx.isParsed());
  assertEquals(true,tx.isCached());
  tx.getInputs();
  assertEquals(true,tx.isParsed());
  ByteArrayOutputStream bos=new ByteArrayOutputStream();
  bs.serialize(tx,bos);
  System.out.println(Utils.bytesToHexString(txMessage));
  System.out.println(Utils.bytesToHexString(bos.toByteArray()));
  assertEquals(true,Arrays.equals(txMessage,bos.toByteArray()));
}","@Test public void testLazyParsing() throws Exception {
  BitcoinSerializer bs=new BitcoinSerializer(MainNetParams.get(),true,false);
  ByteArrayInputStream bais=new ByteArrayInputStream(txMessage);
  Transaction tx=(Transaction)bs.deserialize(bais);
  assertNotNull(tx);
  assertEquals(false,tx.isParsed());
  assertEquals(true,tx.isCached());
  tx.getInputs();
  assertEquals(true,tx.isParsed());
  ByteArrayOutputStream bos=new ByteArrayOutputStream();
  bs.serialize(tx,bos);
  assertEquals(true,Arrays.equals(txMessage,bos.toByteArray()));
}",0.8993399339933993
85807,"@Test public void feeSolverAndCoinSelectionTest() throws Exception {
  assertEquals(0,wallet.getTransactions(true).size());
  Address notMyAddr=new ECKey().toAddress(params);
  StoredBlock block=new StoredBlock(makeSolvedTestBlock(blockStore,notMyAddr),BigInteger.ONE,1);
  Transaction tx1=createFakeTx(params,BigInteger.ONE,myAddress);
  wallet.receiveFromBlock(tx1,block,AbstractBlockChain.NewBlockType.BEST_CHAIN);
  Transaction tx2=createFakeTx(params,BigInteger.ONE,myAddress);
  assertTrue(!tx1.getHash().equals(tx2.getHash()));
  wallet.receiveFromBlock(tx2,block,AbstractBlockChain.NewBlockType.BEST_CHAIN);
  Transaction tx3=createFakeTx(params,BigInteger.TEN,myAddress);
  wallet.receiveFromBlock(tx3,block,AbstractBlockChain.NewBlockType.BEST_CHAIN);
  assertNull(wallet.createSend(notMyAddr,BigInteger.ONE));
  SendRequest req=SendRequest.to(notMyAddr,BigInteger.TEN.add(BigInteger.ONE.add(BigInteger.ONE)));
  req.ensureMinRequiredFee=false;
  assertNotNull(wallet.sendCoinsOffline(req));
  assertEquals(BigInteger.ZERO,wallet.getBalance());
  block=new StoredBlock(makeSolvedTestBlock(blockStore,notMyAddr),BigInteger.ONE,1);
  Transaction tx4=createFakeTx(params,Utils.COIN,myAddress);
  wallet.receiveFromBlock(tx4,block,AbstractBlockChain.NewBlockType.BEST_CHAIN);
  Transaction spend1=wallet.createSend(notMyAddr,Utils.CENT.subtract(BigInteger.ONE));
  assertEquals(2,spend1.getOutputs().size());
  assertEquals(spend1.getOutput(0).getValue().add(spend1.getOutput(1).getValue()),Utils.COIN.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE));
  Transaction spend2=wallet.createSend(notMyAddr,Utils.CENT);
  assertEquals(2,spend2.getOutputs().size());
  assertEquals(Utils.COIN,spend2.getOutput(0).getValue().add(spend2.getOutput(1).getValue()));
  SendRequest request3=SendRequest.to(notMyAddr,Utils.CENT.subtract(BigInteger.ONE));
  request3.fee=Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.add(BigInteger.ONE);
  assertTrue(wallet.completeTx(request3));
  assertEquals(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.add(BigInteger.ONE),request3.fee);
  Transaction spend3=request3.tx;
  assertEquals(2,spend3.getOutputs().size());
  assertEquals(spend3.getOutput(0).getValue().add(spend3.getOutput(1).getValue()),Utils.COIN.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.add(BigInteger.ONE)));
  SendRequest request4=SendRequest.to(notMyAddr,Utils.CENT.subtract(BigInteger.ONE));
  request4.fee=Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.subtract(BigInteger.ONE);
  assertTrue(wallet.completeTx(request4));
  assertEquals(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE,request4.fee);
  Transaction spend4=request4.tx;
  assertEquals(2,spend4.getOutputs().size());
  assertEquals(spend4.getOutput(0).getValue().add(spend4.getOutput(1).getValue()),Utils.COIN.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE));
  SendRequest request5=SendRequest.to(notMyAddr,Utils.COIN.subtract(Utils.CENT.subtract(BigInteger.ONE)));
  assertTrue(wallet.completeTx(request5));
  assertEquals(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE,request5.fee);
  Transaction spend5=request5.tx;
  assertEquals(2,spend5.getOutputs().size());
  assertEquals(spend5.getOutput(0).getValue().add(spend5.getOutput(1).getValue()),Utils.COIN.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE));
  SendRequest request6=SendRequest.to(notMyAddr,Utils.COIN.subtract(Utils.CENT));
  assertTrue(wallet.completeTx(request6));
  assertEquals(BigInteger.ZERO,request6.fee);
  Transaction spend6=request6.tx;
  assertEquals(2,spend6.getOutputs().size());
  assertEquals(Utils.COIN,spend6.getOutput(0).getValue().add(spend6.getOutput(1).getValue()));
  SendRequest request7=SendRequest.to(notMyAddr,Utils.COIN.subtract(Utils.CENT.subtract(BigInteger.valueOf(2)).multiply(BigInteger.valueOf(2))));
  request7.tx.addOutput(Utils.CENT.subtract(BigInteger.ONE),notMyAddr);
  assertTrue(wallet.completeTx(request7));
  assertEquals(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE,request7.fee);
  Transaction spend7=request7.tx;
  assertEquals(3,spend7.getOutputs().size());
  assertEquals(spend7.getOutput(0).getValue().add(spend7.getOutput(1).getValue()).add(spend7.getOutput(2).getValue()),Utils.COIN.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE));
  SendRequest request8=SendRequest.to(notMyAddr,Utils.COIN.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE));
  assertTrue(wallet.completeTx(request8));
  assertEquals(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE,request8.fee);
  Transaction spend8=request8.tx;
  assertEquals(1,spend8.getOutputs().size());
  assertEquals(spend8.getOutput(0).getValue(),Utils.COIN.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE));
  SendRequest request9=SendRequest.to(notMyAddr,Utils.COIN.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.add(Transaction.MIN_NONDUST_OUTPUT)));
  assertTrue(wallet.completeTx(request9));
  assertEquals(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.add(Transaction.MIN_NONDUST_OUTPUT),request9.fee);
  Transaction spend9=request9.tx;
  assertEquals(1,spend9.getOutputs().size());
  assertEquals(spend9.getOutput(0).getValue(),Utils.COIN.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.add(Transaction.MIN_NONDUST_OUTPUT)));
  SendRequest request10=SendRequest.to(notMyAddr,Utils.COIN.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.add(Transaction.MIN_NONDUST_OUTPUT).add(BigInteger.ONE)));
  assertTrue(wallet.completeTx(request10));
  assertEquals(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE,request10.fee);
  Transaction spend10=request10.tx;
  assertEquals(2,spend10.getOutputs().size());
  assertEquals(spend10.getOutput(0).getValue().add(spend10.getOutput(1).getValue()),Utils.COIN.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE));
  SendRequest request11=SendRequest.to(notMyAddr,Utils.COIN.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.add(Transaction.MIN_NONDUST_OUTPUT).add(BigInteger.valueOf(2))));
  request11.fee=Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.add(BigInteger.ONE);
  assertTrue(wallet.completeTx(request11));
  assertEquals(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.add(BigInteger.ONE),request11.fee);
  Transaction spend11=request11.tx;
  assertEquals(2,spend11.getOutputs().size());
  assertEquals(spend11.getOutput(0).getValue().add(spend11.getOutput(1).getValue()),Utils.COIN.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.add(BigInteger.ONE)));
  wallet.commitTx(spend11);
  Transaction tx5=createFakeTx(params,Utils.CENT,myAddress);
  wallet.receiveFromBlock(tx5,block,AbstractBlockChain.NewBlockType.BEST_CHAIN);
  assertEquals(Utils.CENT,wallet.getBalance());
  for (int i=0; i < 100; i++) {
    block=new StoredBlock(makeSolvedTestBlock(blockStore,notMyAddr),BigInteger.ONE,1);
    wallet.notifyNewBestBlock(block);
  }
  block=new StoredBlock(makeSolvedTestBlock(blockStore,notMyAddr),BigInteger.ONE,1);
  Transaction tx6=createFakeTx(params,Utils.COIN,myAddress);
  wallet.receiveFromBlock(tx6,block,AbstractBlockChain.NewBlockType.BEST_CHAIN);
  assertTrue(tx5.getOutput(0).isMine(wallet) && tx5.getOutput(0).isAvailableForSpending() && tx5.getConfidence().getDepthInBlocks() == 100);
  assertTrue(tx6.getOutput(0).isMine(wallet) && tx6.getOutput(0).isAvailableForSpending() && tx6.getConfidence().getDepthInBlocks() == 1);
  Transaction spend12=wallet.createSend(notMyAddr,Utils.CENT);
  assertTrue(spend12.getOutputs().size() == 2 && spend12.getOutput(0).getValue().add(spend12.getOutput(1).getValue()).equals(Utils.COIN));
  wallet.notifyNewBestBlock(block);
  assertTrue(tx5.getOutput(0).isMine(wallet) && tx5.getOutput(0).isAvailableForSpending() && tx5.getConfidence().getDepthInBlocks() == 101);
  assertTrue(tx6.getOutput(0).isMine(wallet) && tx6.getOutput(0).isAvailableForSpending() && tx6.getConfidence().getDepthInBlocks() == 1);
  Transaction spend13=wallet.createSend(notMyAddr,Utils.CENT);
  assertTrue(spend13.getOutputs().size() == 1 && spend13.getOutput(0).getValue().equals(Utils.CENT));
  block=new StoredBlock(makeSolvedTestBlock(blockStore,notMyAddr),BigInteger.ONE,1);
  wallet.notifyNewBestBlock(block);
  assertTrue(tx5.getOutput(0).isMine(wallet) && tx5.getOutput(0).isAvailableForSpending() && tx5.getConfidence().getDepthInBlocks() == 102);
  assertTrue(tx6.getOutput(0).isMine(wallet) && tx6.getOutput(0).isAvailableForSpending() && tx6.getConfidence().getDepthInBlocks() == 2);
  Transaction spend14=wallet.createSend(notMyAddr,Utils.CENT);
  assertTrue(spend14.getOutputs().size() == 2 && spend14.getOutput(0).getValue().add(spend14.getOutput(1).getValue()).equals(Utils.COIN));
  SendRequest request15=SendRequest.to(notMyAddr,Utils.CENT);
  for (int i=0; i < 29; i++)   request15.tx.addOutput(Utils.CENT,notMyAddr);
  assertTrue(request15.tx.bitcoinSerialize().length > 1000);
  request15.feePerKb=BigInteger.ONE;
  assertTrue(wallet.completeTx(request15));
  assertEquals(BigInteger.valueOf(2),request15.fee);
  Transaction spend15=request15.tx;
  assertEquals(31,spend15.getOutputs().size());
  BigInteger outValue15=BigInteger.ZERO;
  for (  TransactionOutput out : spend15.getOutputs())   outValue15=outValue15.add(out.getValue());
  assertEquals(Utils.COIN.subtract(BigInteger.valueOf(2)),outValue15);
  SendRequest request16=SendRequest.to(notMyAddr,Utils.CENT);
  request16.feePerKb=BigInteger.ZERO;
  for (int i=0; i < 29; i++)   request16.tx.addOutput(Utils.CENT,notMyAddr);
  assertTrue(request16.tx.bitcoinSerialize().length > 1000);
  assertTrue(wallet.completeTx(request16));
  assertEquals(BigInteger.ZERO,request16.fee);
  Transaction spend16=request16.tx;
  assertEquals(31,spend16.getOutputs().size());
  BigInteger outValue16=BigInteger.ZERO;
  for (  TransactionOutput out : spend16.getOutputs())   outValue16=outValue16.add(out.getValue());
  assertEquals(Utils.COIN,outValue16);
  SendRequest request17=SendRequest.to(notMyAddr,Utils.CENT);
  for (int i=0; i < 22; i++)   request17.tx.addOutput(Utils.CENT,notMyAddr);
  request17.tx.addOutput(new TransactionOutput(params,request17.tx,Utils.CENT,new byte[15]));
  request17.feePerKb=BigInteger.ONE;
  assertTrue(wallet.completeTx(request17));
  assertEquals(BigInteger.ONE,request17.fee);
  assertEquals(1,request17.tx.getInputs().size());
  int theoreticalMaxLength17=request17.tx.bitcoinSerialize().length + myKey.getPubKey().length + 75;
  for (  TransactionInput in : request17.tx.getInputs())   theoreticalMaxLength17-=in.getScriptBytes().length;
  assertEquals(999,theoreticalMaxLength17);
  Transaction spend17=request17.tx;
{
    final int length=spend17.bitcoinSerialize().length;
    assertTrue(Integer.toString(length),length >= 997 && length <= 999);
  }
  assertEquals(25,spend17.getOutputs().size());
  BigInteger outValue17=BigInteger.ZERO;
  for (  TransactionOutput out : spend17.getOutputs())   outValue17=outValue17.add(out.getValue());
  assertEquals(Utils.COIN.subtract(BigInteger.ONE),outValue17);
  SendRequest request18=SendRequest.to(notMyAddr,Utils.CENT);
  for (int i=0; i < 22; i++)   request18.tx.addOutput(Utils.CENT,notMyAddr);
  request18.tx.addOutput(new TransactionOutput(params,request18.tx,Utils.CENT,new byte[17]));
  request18.feePerKb=BigInteger.ONE;
  assertTrue(wallet.completeTx(request18));
  assertEquals(BigInteger.valueOf(2),request18.fee);
  assertEquals(1,request18.tx.getInputs().size());
  Transaction spend18=request18.tx;
  int theoreticalMaxLength18=spend18.bitcoinSerialize().length + myKey.getPubKey().length + 75;
  for (  TransactionInput in : spend18.getInputs())   theoreticalMaxLength18-=in.getScriptBytes().length;
  assertEquals(1001,theoreticalMaxLength18);
  assertTrue(spend18.bitcoinSerialize().length >= 998);
  assertTrue(spend18.bitcoinSerialize().length <= 1001);
  assertEquals(25,spend18.getOutputs().size());
  BigInteger outValue18=BigInteger.ZERO;
  for (  TransactionOutput out : spend18.getOutputs())   outValue18=outValue18.add(out.getValue());
  assertEquals(outValue18,Utils.COIN.subtract(BigInteger.valueOf(2)));
  assertEquals(wallet.getBalance(),Utils.CENT.add(Utils.COIN));
  SendRequest request19=SendRequest.to(notMyAddr,Utils.CENT);
  request19.feePerKb=BigInteger.ZERO;
  for (int i=0; i < 99; i++)   request19.tx.addOutput(Utils.CENT,notMyAddr);
  assertTrue(wallet.completeTx(request19));
  assertEquals(BigInteger.ZERO,request19.fee);
  assertEquals(1,request19.tx.getInputs().size());
  assertEquals(100,request19.tx.getOutputs().size());
  request19.tx.clearInputs();
  request19=SendRequest.forTx(request19.tx);
  request19.feePerKb=BigInteger.ONE;
  assertTrue(wallet.completeTx(request19));
  assertEquals(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE,request19.fee);
  assertEquals(2,request19.tx.getInputs().size());
  BigInteger outValue19=BigInteger.ZERO;
  for (  TransactionOutput out : request19.tx.getOutputs())   outValue19=outValue19.add(out.getValue());
  assertEquals(request19.tx.getOutput(request19.tx.getOutputs().size() - 1).getValue(),Utils.CENT.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE));
  assertEquals(outValue19,Utils.COIN.add(Utils.CENT).subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE));
  SendRequest request20=SendRequest.to(notMyAddr,Utils.CENT);
  request20.feePerKb=BigInteger.ZERO;
  for (int i=0; i < 99; i++)   request20.tx.addOutput(Utils.CENT,notMyAddr);
  assertTrue(wallet.completeTx(request20));
  assertEquals(BigInteger.ZERO,request20.fee);
  assertEquals(1,request20.tx.getInputs().size());
  assertEquals(100,request20.tx.getOutputs().size());
  request20.tx.clearInputs();
  request20=SendRequest.forTx(request20.tx);
  request20.feePerKb=Transaction.REFERENCE_DEFAULT_MIN_TX_FEE;
  assertTrue(wallet.completeTx(request20));
  assertEquals(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.multiply(BigInteger.valueOf(4)),request20.fee);
  assertEquals(2,request20.tx.getInputs().size());
  BigInteger outValue20=BigInteger.ZERO;
  for (  TransactionOutput out : request20.tx.getOutputs())   outValue20=outValue20.add(out.getValue());
  assertEquals(outValue20,Utils.COIN.add(Utils.CENT).subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.multiply(BigInteger.valueOf(4))));
  SendRequest request21=SendRequest.to(notMyAddr,Utils.CENT);
  request21.feePerKb=BigInteger.ZERO;
  for (int i=0; i < 99; i++)   request21.tx.addOutput(Utils.CENT,notMyAddr);
  request21.tx.addOutput(Utils.CENT.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE),notMyAddr);
  assertTrue(wallet.completeTx(request21));
  assertEquals(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE,request21.fee);
  assertEquals(2,request21.tx.getInputs().size());
  BigInteger outValue21=BigInteger.ZERO;
  for (  TransactionOutput out : request21.tx.getOutputs())   outValue21=outValue21.add(out.getValue());
  assertEquals(outValue21,Utils.COIN.add(Utils.CENT).subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE));
  SendRequest request25=SendRequest.to(notMyAddr,Utils.CENT);
  request25.feePerKb=BigInteger.ZERO;
  for (int i=0; i < 70; i++)   request25.tx.addOutput(Utils.CENT,notMyAddr);
  assertTrue(wallet.completeTx(request25));
  assertEquals(BigInteger.ZERO,request25.fee);
  assertEquals(1,request25.tx.getInputs().size());
  assertEquals(72,request25.tx.getOutputs().size());
  System.out.println(request25.tx.bitcoinSerialize().length);
  request25.tx.clearInputs();
  request25=SendRequest.forTx(request25.tx);
  request25.feePerKb=Utils.CENT.divide(BigInteger.valueOf(3));
  request25.ensureMinRequiredFee=false;
  assertTrue(wallet.completeTx(request25));
  assertEquals(Utils.CENT.subtract(BigInteger.ONE),request25.fee);
  assertEquals(2,request25.tx.getInputs().size());
  BigInteger outValue25=BigInteger.ZERO;
  for (  TransactionOutput out : request25.tx.getOutputs())   outValue25=outValue25.add(out.getValue());
  assertEquals(BigInteger.ONE,request25.tx.getOutput(request25.tx.getOutputs().size() - 1).getValue());
  assertEquals(outValue25,Utils.COIN.add(BigInteger.ONE));
  Transaction spendTx5=new Transaction(params);
  spendTx5.addOutput(Utils.CENT,notMyAddr);
  spendTx5.addInput(tx5.getOutput(0));
  spendTx5.signInputs(SigHash.ALL,wallet);
  wallet.receiveFromBlock(spendTx5,block,AbstractBlockChain.NewBlockType.BEST_CHAIN);
  assertEquals(Utils.COIN,wallet.getBalance());
  SendRequest request26=SendRequest.to(notMyAddr,Utils.CENT);
  for (int i=0; i < 98; i++)   request26.tx.addOutput(Utils.CENT,notMyAddr);
  request26.tx.addOutput(Utils.CENT.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.add(Transaction.MIN_NONDUST_OUTPUT)),notMyAddr);
  assertTrue(request26.tx.bitcoinSerialize().length > 1000);
  request26.feePerKb=BigInteger.ONE;
  assertTrue(wallet.completeTx(request26));
  assertEquals(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.add(Transaction.MIN_NONDUST_OUTPUT),request26.fee);
  Transaction spend26=request26.tx;
  assertEquals(100,spend26.getOutputs().size());
  BigInteger outValue26=BigInteger.ZERO;
  for (  TransactionOutput out : spend26.getOutputs())   outValue26=outValue26.add(out.getValue());
  assertEquals(outValue26,Utils.COIN.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.add(Transaction.MIN_NONDUST_OUTPUT)));
}","@Test public void feeSolverAndCoinSelectionTest() throws Exception {
  assertEquals(0,wallet.getTransactions(true).size());
  Address notMyAddr=new ECKey().toAddress(params);
  StoredBlock block=new StoredBlock(makeSolvedTestBlock(blockStore,notMyAddr),BigInteger.ONE,1);
  Transaction tx1=createFakeTx(params,BigInteger.ONE,myAddress);
  wallet.receiveFromBlock(tx1,block,AbstractBlockChain.NewBlockType.BEST_CHAIN);
  Transaction tx2=createFakeTx(params,BigInteger.ONE,myAddress);
  assertTrue(!tx1.getHash().equals(tx2.getHash()));
  wallet.receiveFromBlock(tx2,block,AbstractBlockChain.NewBlockType.BEST_CHAIN);
  Transaction tx3=createFakeTx(params,BigInteger.TEN,myAddress);
  wallet.receiveFromBlock(tx3,block,AbstractBlockChain.NewBlockType.BEST_CHAIN);
  assertNull(wallet.createSend(notMyAddr,BigInteger.ONE));
  SendRequest req=SendRequest.to(notMyAddr,BigInteger.TEN.add(BigInteger.ONE.add(BigInteger.ONE)));
  req.ensureMinRequiredFee=false;
  assertNotNull(wallet.sendCoinsOffline(req));
  assertEquals(BigInteger.ZERO,wallet.getBalance());
  block=new StoredBlock(makeSolvedTestBlock(blockStore,notMyAddr),BigInteger.ONE,1);
  Transaction tx4=createFakeTx(params,Utils.COIN,myAddress);
  wallet.receiveFromBlock(tx4,block,AbstractBlockChain.NewBlockType.BEST_CHAIN);
  Transaction spend1=wallet.createSend(notMyAddr,Utils.CENT.subtract(BigInteger.ONE));
  assertEquals(2,spend1.getOutputs().size());
  assertEquals(spend1.getOutput(0).getValue().add(spend1.getOutput(1).getValue()),Utils.COIN.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE));
  Transaction spend2=wallet.createSend(notMyAddr,Utils.CENT);
  assertEquals(2,spend2.getOutputs().size());
  assertEquals(Utils.COIN,spend2.getOutput(0).getValue().add(spend2.getOutput(1).getValue()));
  SendRequest request3=SendRequest.to(notMyAddr,Utils.CENT.subtract(BigInteger.ONE));
  request3.fee=Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.add(BigInteger.ONE);
  assertTrue(wallet.completeTx(request3));
  assertEquals(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.add(BigInteger.ONE),request3.fee);
  Transaction spend3=request3.tx;
  assertEquals(2,spend3.getOutputs().size());
  assertEquals(spend3.getOutput(0).getValue().add(spend3.getOutput(1).getValue()),Utils.COIN.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.add(BigInteger.ONE)));
  SendRequest request4=SendRequest.to(notMyAddr,Utils.CENT.subtract(BigInteger.ONE));
  request4.fee=Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.subtract(BigInteger.ONE);
  assertTrue(wallet.completeTx(request4));
  assertEquals(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE,request4.fee);
  Transaction spend4=request4.tx;
  assertEquals(2,spend4.getOutputs().size());
  assertEquals(spend4.getOutput(0).getValue().add(spend4.getOutput(1).getValue()),Utils.COIN.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE));
  SendRequest request5=SendRequest.to(notMyAddr,Utils.COIN.subtract(Utils.CENT.subtract(BigInteger.ONE)));
  assertTrue(wallet.completeTx(request5));
  assertEquals(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE,request5.fee);
  Transaction spend5=request5.tx;
  assertEquals(2,spend5.getOutputs().size());
  assertEquals(spend5.getOutput(0).getValue().add(spend5.getOutput(1).getValue()),Utils.COIN.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE));
  SendRequest request6=SendRequest.to(notMyAddr,Utils.COIN.subtract(Utils.CENT));
  assertTrue(wallet.completeTx(request6));
  assertEquals(BigInteger.ZERO,request6.fee);
  Transaction spend6=request6.tx;
  assertEquals(2,spend6.getOutputs().size());
  assertEquals(Utils.COIN,spend6.getOutput(0).getValue().add(spend6.getOutput(1).getValue()));
  SendRequest request7=SendRequest.to(notMyAddr,Utils.COIN.subtract(Utils.CENT.subtract(BigInteger.valueOf(2)).multiply(BigInteger.valueOf(2))));
  request7.tx.addOutput(Utils.CENT.subtract(BigInteger.ONE),notMyAddr);
  assertTrue(wallet.completeTx(request7));
  assertEquals(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE,request7.fee);
  Transaction spend7=request7.tx;
  assertEquals(3,spend7.getOutputs().size());
  assertEquals(spend7.getOutput(0).getValue().add(spend7.getOutput(1).getValue()).add(spend7.getOutput(2).getValue()),Utils.COIN.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE));
  SendRequest request8=SendRequest.to(notMyAddr,Utils.COIN.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE));
  assertTrue(wallet.completeTx(request8));
  assertEquals(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE,request8.fee);
  Transaction spend8=request8.tx;
  assertEquals(1,spend8.getOutputs().size());
  assertEquals(spend8.getOutput(0).getValue(),Utils.COIN.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE));
  SendRequest request9=SendRequest.to(notMyAddr,Utils.COIN.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.add(Transaction.MIN_NONDUST_OUTPUT)));
  assertTrue(wallet.completeTx(request9));
  assertEquals(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.add(Transaction.MIN_NONDUST_OUTPUT),request9.fee);
  Transaction spend9=request9.tx;
  assertEquals(1,spend9.getOutputs().size());
  assertEquals(spend9.getOutput(0).getValue(),Utils.COIN.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.add(Transaction.MIN_NONDUST_OUTPUT)));
  SendRequest request10=SendRequest.to(notMyAddr,Utils.COIN.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.add(Transaction.MIN_NONDUST_OUTPUT).add(BigInteger.ONE)));
  assertTrue(wallet.completeTx(request10));
  assertEquals(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE,request10.fee);
  Transaction spend10=request10.tx;
  assertEquals(2,spend10.getOutputs().size());
  assertEquals(spend10.getOutput(0).getValue().add(spend10.getOutput(1).getValue()),Utils.COIN.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE));
  SendRequest request11=SendRequest.to(notMyAddr,Utils.COIN.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.add(Transaction.MIN_NONDUST_OUTPUT).add(BigInteger.valueOf(2))));
  request11.fee=Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.add(BigInteger.ONE);
  assertTrue(wallet.completeTx(request11));
  assertEquals(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.add(BigInteger.ONE),request11.fee);
  Transaction spend11=request11.tx;
  assertEquals(2,spend11.getOutputs().size());
  assertEquals(spend11.getOutput(0).getValue().add(spend11.getOutput(1).getValue()),Utils.COIN.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.add(BigInteger.ONE)));
  wallet.commitTx(spend11);
  Transaction tx5=createFakeTx(params,Utils.CENT,myAddress);
  wallet.receiveFromBlock(tx5,block,AbstractBlockChain.NewBlockType.BEST_CHAIN);
  assertEquals(Utils.CENT,wallet.getBalance());
  for (int i=0; i < 100; i++) {
    block=new StoredBlock(makeSolvedTestBlock(blockStore,notMyAddr),BigInteger.ONE,1);
    wallet.notifyNewBestBlock(block);
  }
  block=new StoredBlock(makeSolvedTestBlock(blockStore,notMyAddr),BigInteger.ONE,1);
  Transaction tx6=createFakeTx(params,Utils.COIN,myAddress);
  wallet.receiveFromBlock(tx6,block,AbstractBlockChain.NewBlockType.BEST_CHAIN);
  assertTrue(tx5.getOutput(0).isMine(wallet) && tx5.getOutput(0).isAvailableForSpending() && tx5.getConfidence().getDepthInBlocks() == 100);
  assertTrue(tx6.getOutput(0).isMine(wallet) && tx6.getOutput(0).isAvailableForSpending() && tx6.getConfidence().getDepthInBlocks() == 1);
  Transaction spend12=wallet.createSend(notMyAddr,Utils.CENT);
  assertTrue(spend12.getOutputs().size() == 2 && spend12.getOutput(0).getValue().add(spend12.getOutput(1).getValue()).equals(Utils.COIN));
  wallet.notifyNewBestBlock(block);
  assertTrue(tx5.getOutput(0).isMine(wallet) && tx5.getOutput(0).isAvailableForSpending() && tx5.getConfidence().getDepthInBlocks() == 101);
  assertTrue(tx6.getOutput(0).isMine(wallet) && tx6.getOutput(0).isAvailableForSpending() && tx6.getConfidence().getDepthInBlocks() == 1);
  Transaction spend13=wallet.createSend(notMyAddr,Utils.CENT);
  assertTrue(spend13.getOutputs().size() == 1 && spend13.getOutput(0).getValue().equals(Utils.CENT));
  block=new StoredBlock(makeSolvedTestBlock(blockStore,notMyAddr),BigInteger.ONE,1);
  wallet.notifyNewBestBlock(block);
  assertTrue(tx5.getOutput(0).isMine(wallet) && tx5.getOutput(0).isAvailableForSpending() && tx5.getConfidence().getDepthInBlocks() == 102);
  assertTrue(tx6.getOutput(0).isMine(wallet) && tx6.getOutput(0).isAvailableForSpending() && tx6.getConfidence().getDepthInBlocks() == 2);
  Transaction spend14=wallet.createSend(notMyAddr,Utils.CENT);
  assertTrue(spend14.getOutputs().size() == 2 && spend14.getOutput(0).getValue().add(spend14.getOutput(1).getValue()).equals(Utils.COIN));
  SendRequest request15=SendRequest.to(notMyAddr,Utils.CENT);
  for (int i=0; i < 29; i++)   request15.tx.addOutput(Utils.CENT,notMyAddr);
  assertTrue(request15.tx.bitcoinSerialize().length > 1000);
  request15.feePerKb=BigInteger.ONE;
  assertTrue(wallet.completeTx(request15));
  assertEquals(BigInteger.valueOf(2),request15.fee);
  Transaction spend15=request15.tx;
  assertEquals(31,spend15.getOutputs().size());
  BigInteger outValue15=BigInteger.ZERO;
  for (  TransactionOutput out : spend15.getOutputs())   outValue15=outValue15.add(out.getValue());
  assertEquals(Utils.COIN.subtract(BigInteger.valueOf(2)),outValue15);
  SendRequest request16=SendRequest.to(notMyAddr,Utils.CENT);
  request16.feePerKb=BigInteger.ZERO;
  for (int i=0; i < 29; i++)   request16.tx.addOutput(Utils.CENT,notMyAddr);
  assertTrue(request16.tx.bitcoinSerialize().length > 1000);
  assertTrue(wallet.completeTx(request16));
  assertEquals(BigInteger.ZERO,request16.fee);
  Transaction spend16=request16.tx;
  assertEquals(31,spend16.getOutputs().size());
  BigInteger outValue16=BigInteger.ZERO;
  for (  TransactionOutput out : spend16.getOutputs())   outValue16=outValue16.add(out.getValue());
  assertEquals(Utils.COIN,outValue16);
  SendRequest request17=SendRequest.to(notMyAddr,Utils.CENT);
  for (int i=0; i < 22; i++)   request17.tx.addOutput(Utils.CENT,notMyAddr);
  request17.tx.addOutput(new TransactionOutput(params,request17.tx,Utils.CENT,new byte[15]));
  request17.feePerKb=BigInteger.ONE;
  assertTrue(wallet.completeTx(request17));
  assertEquals(BigInteger.ONE,request17.fee);
  assertEquals(1,request17.tx.getInputs().size());
  int theoreticalMaxLength17=request17.tx.bitcoinSerialize().length + myKey.getPubKey().length + 75;
  for (  TransactionInput in : request17.tx.getInputs())   theoreticalMaxLength17-=in.getScriptBytes().length;
  assertEquals(999,theoreticalMaxLength17);
  Transaction spend17=request17.tx;
{
    final int length=spend17.bitcoinSerialize().length;
    assertTrue(Integer.toString(length),length >= 997 && length <= 999);
  }
  assertEquals(25,spend17.getOutputs().size());
  BigInteger outValue17=BigInteger.ZERO;
  for (  TransactionOutput out : spend17.getOutputs())   outValue17=outValue17.add(out.getValue());
  assertEquals(Utils.COIN.subtract(BigInteger.ONE),outValue17);
  SendRequest request18=SendRequest.to(notMyAddr,Utils.CENT);
  for (int i=0; i < 22; i++)   request18.tx.addOutput(Utils.CENT,notMyAddr);
  request18.tx.addOutput(new TransactionOutput(params,request18.tx,Utils.CENT,new byte[17]));
  request18.feePerKb=BigInteger.ONE;
  assertTrue(wallet.completeTx(request18));
  assertEquals(BigInteger.valueOf(2),request18.fee);
  assertEquals(1,request18.tx.getInputs().size());
  Transaction spend18=request18.tx;
  int theoreticalMaxLength18=spend18.bitcoinSerialize().length + myKey.getPubKey().length + 75;
  for (  TransactionInput in : spend18.getInputs())   theoreticalMaxLength18-=in.getScriptBytes().length;
  assertEquals(1001,theoreticalMaxLength18);
  assertTrue(spend18.bitcoinSerialize().length >= 998);
  assertTrue(spend18.bitcoinSerialize().length <= 1001);
  assertEquals(25,spend18.getOutputs().size());
  BigInteger outValue18=BigInteger.ZERO;
  for (  TransactionOutput out : spend18.getOutputs())   outValue18=outValue18.add(out.getValue());
  assertEquals(outValue18,Utils.COIN.subtract(BigInteger.valueOf(2)));
  assertEquals(wallet.getBalance(),Utils.CENT.add(Utils.COIN));
  SendRequest request19=SendRequest.to(notMyAddr,Utils.CENT);
  request19.feePerKb=BigInteger.ZERO;
  for (int i=0; i < 99; i++)   request19.tx.addOutput(Utils.CENT,notMyAddr);
  assertTrue(wallet.completeTx(request19));
  assertEquals(BigInteger.ZERO,request19.fee);
  assertEquals(1,request19.tx.getInputs().size());
  assertEquals(100,request19.tx.getOutputs().size());
  request19.tx.clearInputs();
  request19=SendRequest.forTx(request19.tx);
  request19.feePerKb=BigInteger.ONE;
  assertTrue(wallet.completeTx(request19));
  assertEquals(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE,request19.fee);
  assertEquals(2,request19.tx.getInputs().size());
  BigInteger outValue19=BigInteger.ZERO;
  for (  TransactionOutput out : request19.tx.getOutputs())   outValue19=outValue19.add(out.getValue());
  assertEquals(request19.tx.getOutput(request19.tx.getOutputs().size() - 1).getValue(),Utils.CENT.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE));
  assertEquals(outValue19,Utils.COIN.add(Utils.CENT).subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE));
  SendRequest request20=SendRequest.to(notMyAddr,Utils.CENT);
  request20.feePerKb=BigInteger.ZERO;
  for (int i=0; i < 99; i++)   request20.tx.addOutput(Utils.CENT,notMyAddr);
  assertTrue(wallet.completeTx(request20));
  assertEquals(BigInteger.ZERO,request20.fee);
  assertEquals(1,request20.tx.getInputs().size());
  assertEquals(100,request20.tx.getOutputs().size());
  request20.tx.clearInputs();
  request20=SendRequest.forTx(request20.tx);
  request20.feePerKb=Transaction.REFERENCE_DEFAULT_MIN_TX_FEE;
  assertTrue(wallet.completeTx(request20));
  assertEquals(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.multiply(BigInteger.valueOf(4)),request20.fee);
  assertEquals(2,request20.tx.getInputs().size());
  BigInteger outValue20=BigInteger.ZERO;
  for (  TransactionOutput out : request20.tx.getOutputs())   outValue20=outValue20.add(out.getValue());
  assertEquals(outValue20,Utils.COIN.add(Utils.CENT).subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.multiply(BigInteger.valueOf(4))));
  SendRequest request21=SendRequest.to(notMyAddr,Utils.CENT);
  request21.feePerKb=BigInteger.ZERO;
  for (int i=0; i < 99; i++)   request21.tx.addOutput(Utils.CENT,notMyAddr);
  request21.tx.addOutput(Utils.CENT.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE),notMyAddr);
  assertTrue(wallet.completeTx(request21));
  assertEquals(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE,request21.fee);
  assertEquals(2,request21.tx.getInputs().size());
  BigInteger outValue21=BigInteger.ZERO;
  for (  TransactionOutput out : request21.tx.getOutputs())   outValue21=outValue21.add(out.getValue());
  assertEquals(outValue21,Utils.COIN.add(Utils.CENT).subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE));
  SendRequest request25=SendRequest.to(notMyAddr,Utils.CENT);
  request25.feePerKb=BigInteger.ZERO;
  for (int i=0; i < 70; i++)   request25.tx.addOutput(Utils.CENT,notMyAddr);
  assertTrue(wallet.completeTx(request25));
  assertEquals(BigInteger.ZERO,request25.fee);
  assertEquals(1,request25.tx.getInputs().size());
  assertEquals(72,request25.tx.getOutputs().size());
  request25.tx.clearInputs();
  request25=SendRequest.forTx(request25.tx);
  request25.feePerKb=Utils.CENT.divide(BigInteger.valueOf(3));
  request25.ensureMinRequiredFee=false;
  assertTrue(wallet.completeTx(request25));
  assertEquals(Utils.CENT.subtract(BigInteger.ONE),request25.fee);
  assertEquals(2,request25.tx.getInputs().size());
  BigInteger outValue25=BigInteger.ZERO;
  for (  TransactionOutput out : request25.tx.getOutputs())   outValue25=outValue25.add(out.getValue());
  assertEquals(BigInteger.ONE,request25.tx.getOutput(request25.tx.getOutputs().size() - 1).getValue());
  assertEquals(outValue25,Utils.COIN.add(BigInteger.ONE));
  Transaction spendTx5=new Transaction(params);
  spendTx5.addOutput(Utils.CENT,notMyAddr);
  spendTx5.addInput(tx5.getOutput(0));
  spendTx5.signInputs(SigHash.ALL,wallet);
  wallet.receiveFromBlock(spendTx5,block,AbstractBlockChain.NewBlockType.BEST_CHAIN);
  assertEquals(Utils.COIN,wallet.getBalance());
  SendRequest request26=SendRequest.to(notMyAddr,Utils.CENT);
  for (int i=0; i < 98; i++)   request26.tx.addOutput(Utils.CENT,notMyAddr);
  request26.tx.addOutput(Utils.CENT.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.add(Transaction.MIN_NONDUST_OUTPUT)),notMyAddr);
  assertTrue(request26.tx.bitcoinSerialize().length > 1000);
  request26.feePerKb=BigInteger.ONE;
  assertTrue(wallet.completeTx(request26));
  assertEquals(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.add(Transaction.MIN_NONDUST_OUTPUT),request26.fee);
  Transaction spend26=request26.tx;
  assertEquals(100,spend26.getOutputs().size());
  BigInteger outValue26=BigInteger.ZERO;
  for (  TransactionOutput out : spend26.getOutputs())   outValue26=outValue26.add(out.getValue());
  assertEquals(outValue26,Utils.COIN.subtract(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.add(Transaction.MIN_NONDUST_OUTPUT)));
}",0.9981661145291056
85808,"private static void executeCheckSig(Transaction txContainingThis,int index,Script script,LinkedList<byte[]> stack,int lastCodeSepLocation,int opcode) throws ScriptException {
  if (stack.size() < 2)   throw new ScriptException(""String_Node_Str"");
  byte[] pubKey=stack.pollLast();
  byte[] sig=stack.pollLast();
  byte[] prog=script.getProgram();
  byte[] connectedScript=Arrays.copyOfRange(prog,lastCodeSepLocation,prog.length);
  UnsafeByteArrayOutputStream outStream=new UnsafeByteArrayOutputStream(sig.length + 1);
  try {
    writeBytes(outStream,sig);
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  connectedScript=removeAllInstancesOf(connectedScript,outStream.toByteArray());
  Sha256Hash hash=txContainingThis.hashTransactionForSignature(index,connectedScript,sig[sig.length - 1]);
  boolean sigValid;
  try {
    sigValid=ECKey.verify(hash.getBytes(),Arrays.copyOf(sig,sig.length - 1),pubKey);
  }
 catch (  Exception e1) {
    log.warn(e1.toString());
    sigValid=false;
  }
  if (opcode == OP_CHECKSIG)   stack.add(sigValid ? new byte[]{1} : new byte[]{0});
 else   if (opcode == OP_CHECKSIGVERIFY)   if (!sigValid)   throw new ScriptException(""String_Node_Str"");
}","private static void executeCheckSig(Transaction txContainingThis,int index,Script script,LinkedList<byte[]> stack,int lastCodeSepLocation,int opcode) throws ScriptException {
  if (stack.size() < 2)   throw new ScriptException(""String_Node_Str"");
  byte[] pubKey=stack.pollLast();
  byte[] sig=stack.pollLast();
  if (sig.length == 0 || pubKey.length == 0)   throw new ScriptException(""String_Node_Str"");
  byte[] prog=script.getProgram();
  byte[] connectedScript=Arrays.copyOfRange(prog,lastCodeSepLocation,prog.length);
  UnsafeByteArrayOutputStream outStream=new UnsafeByteArrayOutputStream(sig.length + 1);
  try {
    writeBytes(outStream,sig);
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  connectedScript=removeAllInstancesOf(connectedScript,outStream.toByteArray());
  Sha256Hash hash=txContainingThis.hashTransactionForSignature(index,connectedScript,sig[sig.length - 1]);
  boolean sigValid;
  try {
    sigValid=ECKey.verify(hash.getBytes(),Arrays.copyOf(sig,sig.length - 1),pubKey);
  }
 catch (  Exception e1) {
    log.warn(e1.toString());
    sigValid=false;
  }
  if (opcode == OP_CHECKSIG)   stack.add(sigValid ? new byte[]{1} : new byte[]{0});
 else   if (opcode == OP_CHECKSIGVERIFY)   if (!sigValid)   throw new ScriptException(""String_Node_Str"");
}",0.9627851140456184
85809,"private static int executeMultiSig(Transaction txContainingThis,int index,Script script,LinkedList<byte[]> stack,int opCount,int lastCodeSepLocation,int opcode) throws ScriptException {
  if (stack.size() < 2)   throw new ScriptException(""String_Node_Str"");
  int pubKeyCount=castToBigInteger(stack.pollLast()).intValue();
  if (pubKeyCount < 0 || pubKeyCount > 20)   throw new ScriptException(""String_Node_Str"");
  opCount+=pubKeyCount;
  if (opCount > 201)   throw new ScriptException(""String_Node_Str"");
  if (stack.size() < pubKeyCount + 1)   throw new ScriptException(""String_Node_Str"");
  LinkedList<byte[]> pubkeys=new LinkedList<byte[]>();
  for (int i=0; i < pubKeyCount; i++)   pubkeys.add(stack.pollLast());
  int sigCount=castToBigInteger(stack.pollLast()).intValue();
  if (sigCount < 0 || sigCount > pubKeyCount)   throw new ScriptException(""String_Node_Str"");
  if (stack.size() < sigCount + 1)   throw new ScriptException(""String_Node_Str"");
  LinkedList<byte[]> sigs=new LinkedList<byte[]>();
  for (int i=0; i < sigCount; i++)   sigs.add(stack.pollLast());
  byte[] prog=script.getProgram();
  byte[] connectedScript=Arrays.copyOfRange(prog,lastCodeSepLocation,prog.length);
  for (  byte[] sig : sigs) {
    UnsafeByteArrayOutputStream outStream=new UnsafeByteArrayOutputStream(sig.length + 1);
    try {
      writeBytes(outStream,sig);
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
    connectedScript=removeAllInstancesOf(connectedScript,outStream.toByteArray());
  }
  boolean valid=true;
  while (sigs.size() > 0) {
    byte[] sig=sigs.getFirst();
    byte[] pubKey=pubkeys.pollFirst();
    Sha256Hash hash=txContainingThis.hashTransactionForSignature(index,connectedScript,sig[sig.length - 1]);
    try {
      if (ECKey.verify(hash.getBytes(),Arrays.copyOf(sig,sig.length - 1),pubKey))       sigs.pollFirst();
    }
 catch (    Exception e) {
    }
    if (sigs.size() > pubkeys.size()) {
      valid=false;
      break;
    }
  }
  stack.pollLast();
  if (opcode == OP_CHECKMULTISIG) {
    stack.add(valid ? new byte[]{1} : new byte[]{0});
  }
 else   if (opcode == OP_CHECKMULTISIGVERIFY) {
    if (!valid)     throw new ScriptException(""String_Node_Str"");
  }
  return opCount;
}","private static int executeMultiSig(Transaction txContainingThis,int index,Script script,LinkedList<byte[]> stack,int opCount,int lastCodeSepLocation,int opcode) throws ScriptException {
  if (stack.size() < 2)   throw new ScriptException(""String_Node_Str"");
  int pubKeyCount=castToBigInteger(stack.pollLast()).intValue();
  if (pubKeyCount < 0 || pubKeyCount > 20)   throw new ScriptException(""String_Node_Str"");
  opCount+=pubKeyCount;
  if (opCount > 201)   throw new ScriptException(""String_Node_Str"");
  if (stack.size() < pubKeyCount + 1)   throw new ScriptException(""String_Node_Str"");
  LinkedList<byte[]> pubkeys=new LinkedList<byte[]>();
  for (int i=0; i < pubKeyCount; i++) {
    byte[] pubKey=stack.pollLast();
    if (pubKey.length == 0)     throw new ScriptException(""String_Node_Str"");
    pubkeys.add(pubKey);
  }
  int sigCount=castToBigInteger(stack.pollLast()).intValue();
  if (sigCount < 0 || sigCount > pubKeyCount)   throw new ScriptException(""String_Node_Str"");
  if (stack.size() < sigCount + 1)   throw new ScriptException(""String_Node_Str"");
  LinkedList<byte[]> sigs=new LinkedList<byte[]>();
  for (int i=0; i < sigCount; i++) {
    byte[] sig=stack.pollLast();
    if (sig.length == 0)     throw new ScriptException(""String_Node_Str"");
    sigs.add(sig);
  }
  byte[] prog=script.getProgram();
  byte[] connectedScript=Arrays.copyOfRange(prog,lastCodeSepLocation,prog.length);
  for (  byte[] sig : sigs) {
    UnsafeByteArrayOutputStream outStream=new UnsafeByteArrayOutputStream(sig.length + 1);
    try {
      writeBytes(outStream,sig);
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
    connectedScript=removeAllInstancesOf(connectedScript,outStream.toByteArray());
  }
  boolean valid=true;
  while (sigs.size() > 0) {
    byte[] sig=sigs.getFirst();
    byte[] pubKey=pubkeys.pollFirst();
    Sha256Hash hash=txContainingThis.hashTransactionForSignature(index,connectedScript,sig[sig.length - 1]);
    try {
      if (ECKey.verify(hash.getBytes(),Arrays.copyOf(sig,sig.length - 1),pubKey))       sigs.pollFirst();
    }
 catch (    Exception e) {
    }
    if (sigs.size() > pubkeys.size()) {
      valid=false;
      break;
    }
  }
  stack.pollLast();
  if (opcode == OP_CHECKMULTISIG) {
    stack.add(valid ? new byte[]{1} : new byte[]{0});
  }
 else   if (opcode == OP_CHECKMULTISIGVERIFY) {
    if (!valid)     throw new ScriptException(""String_Node_Str"");
  }
  return opCount;
}",0.9358892438764644
85810,"private static void executeScript(Transaction txContainingThis,long index,Script script,LinkedList<byte[]> stack) throws ScriptException {
  int opCount=0;
  int lastCodeSepLocation=0;
  LinkedList<byte[]> altstack=new LinkedList<byte[]>();
  LinkedList<Boolean> ifStack=new LinkedList<Boolean>();
  for (  ScriptChunk chunk : script.chunks) {
    boolean shouldExecute=!ifStack.contains(false);
    if (!chunk.isOpCode()) {
      if (!shouldExecute)       continue;
      stack.add(chunk.data);
    }
 else {
      int opcode=0xFF & chunk.data[0];
      if (opcode > OP_16) {
        opCount++;
        if (opCount > 201)         throw new ScriptException(""String_Node_Str"");
      }
      if (opcode == OP_VERIF || opcode == OP_VERNOTIF)       throw new ScriptException(""String_Node_Str"");
      if (opcode == OP_CAT || opcode == OP_SUBSTR || opcode == OP_LEFT || opcode == OP_RIGHT || opcode == OP_INVERT || opcode == OP_AND || opcode == OP_OR || opcode == OP_XOR || opcode == OP_2MUL || opcode == OP_2DIV || opcode == OP_MUL || opcode == OP_DIV || opcode == OP_MOD || opcode == OP_LSHIFT || opcode == OP_RSHIFT)       throw new ScriptException(""String_Node_Str"");
switch (opcode) {
case OP_IF:
        if (!shouldExecute) {
          ifStack.add(false);
          continue;
        }
      if (stack.size() < 1)       throw new ScriptException(""String_Node_Str"");
    ifStack.add(castToBool(stack.pollLast()));
  continue;
case OP_NOTIF:
if (!shouldExecute) {
  ifStack.add(false);
  continue;
}
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
ifStack.add(!castToBool(stack.pollLast()));
continue;
case OP_ELSE:
if (ifStack.isEmpty()) throw new ScriptException(""String_Node_Str"");
ifStack.add(!ifStack.pollLast());
continue;
case OP_ENDIF:
if (ifStack.isEmpty()) throw new ScriptException(""String_Node_Str"");
ifStack.pollLast();
continue;
}
if (!shouldExecute) continue;
switch (opcode) {
case OP_0:
stack.add(new byte[]{0});
break;
case OP_1NEGATE:
stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.ONE.negate(),false)));
break;
case OP_1:
case OP_2:
case OP_3:
case OP_4:
case OP_5:
case OP_6:
case OP_7:
case OP_8:
case OP_9:
case OP_10:
case OP_11:
case OP_12:
case OP_13:
case OP_14:
case OP_15:
case OP_16:
stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.valueOf(decodeFromOpN(opcode)),false)));
break;
case OP_NOP:
break;
case OP_VERIFY:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
if (!castToBool(stack.pollLast())) throw new ScriptException(""String_Node_Str"");
break;
case OP_RETURN:
throw new ScriptException(""String_Node_Str"");
case OP_TOALTSTACK:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
altstack.add(stack.pollLast());
break;
case OP_FROMALTSTACK:
if (altstack.size() < 1) throw new ScriptException(""String_Node_Str"");
stack.add(altstack.pollLast());
break;
case OP_2DROP:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
stack.pollLast();
stack.pollLast();
break;
case OP_2DUP:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
Iterator<byte[]> it2DUP=stack.descendingIterator();
byte[] OP2DUPtmpChunk2=it2DUP.next();
stack.add(it2DUP.next());
stack.add(OP2DUPtmpChunk2);
break;
case OP_3DUP:
if (stack.size() < 3) throw new ScriptException(""String_Node_Str"");
Iterator<byte[]> it3DUP=stack.descendingIterator();
byte[] OP3DUPtmpChunk3=it3DUP.next();
byte[] OP3DUPtmpChunk2=it3DUP.next();
stack.add(it3DUP.next());
stack.add(OP3DUPtmpChunk2);
stack.add(OP3DUPtmpChunk3);
break;
case OP_2OVER:
if (stack.size() < 4) throw new ScriptException(""String_Node_Str"");
Iterator<byte[]> it2OVER=stack.descendingIterator();
it2OVER.next();
it2OVER.next();
byte[] OP2OVERtmpChunk2=it2OVER.next();
stack.add(it2OVER.next());
stack.add(OP2OVERtmpChunk2);
break;
case OP_2ROT:
if (stack.size() < 6) throw new ScriptException(""String_Node_Str"");
byte[] OP2ROTtmpChunk6=stack.pollLast();
byte[] OP2ROTtmpChunk5=stack.pollLast();
byte[] OP2ROTtmpChunk4=stack.pollLast();
byte[] OP2ROTtmpChunk3=stack.pollLast();
byte[] OP2ROTtmpChunk2=stack.pollLast();
byte[] OP2ROTtmpChunk1=stack.pollLast();
stack.add(OP2ROTtmpChunk3);
stack.add(OP2ROTtmpChunk4);
stack.add(OP2ROTtmpChunk5);
stack.add(OP2ROTtmpChunk6);
stack.add(OP2ROTtmpChunk1);
stack.add(OP2ROTtmpChunk2);
break;
case OP_2SWAP:
if (stack.size() < 4) throw new ScriptException(""String_Node_Str"");
byte[] OP2SWAPtmpChunk4=stack.pollLast();
byte[] OP2SWAPtmpChunk3=stack.pollLast();
byte[] OP2SWAPtmpChunk2=stack.pollLast();
byte[] OP2SWAPtmpChunk1=stack.pollLast();
stack.add(OP2SWAPtmpChunk3);
stack.add(OP2SWAPtmpChunk4);
stack.add(OP2SWAPtmpChunk1);
stack.add(OP2SWAPtmpChunk2);
break;
case OP_IFDUP:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
if (castToBool(stack.getLast())) stack.add(stack.getLast());
break;
case OP_DEPTH:
stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.valueOf(stack.size()),false)));
break;
case OP_DROP:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
stack.pollLast();
break;
case OP_DUP:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
stack.add(stack.getLast());
break;
case OP_NIP:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
byte[] OPNIPtmpChunk=stack.pollLast();
stack.pollLast();
stack.add(OPNIPtmpChunk);
break;
case OP_OVER:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
Iterator<byte[]> itOVER=stack.descendingIterator();
itOVER.next();
stack.add(itOVER.next());
break;
case OP_PICK:
case OP_ROLL:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
long val=castToBigInteger(stack.pollLast()).longValue();
if (val < 0 || val >= stack.size()) throw new ScriptException(""String_Node_Str"");
Iterator<byte[]> itPICK=stack.descendingIterator();
for (long i=0; i < val; i++) itPICK.next();
byte[] OPROLLtmpChunk=itPICK.next();
if (opcode == OP_ROLL) itPICK.remove();
stack.add(OPROLLtmpChunk);
break;
case OP_ROT:
if (stack.size() < 3) throw new ScriptException(""String_Node_Str"");
byte[] OPROTtmpChunk3=stack.pollLast();
byte[] OPROTtmpChunk2=stack.pollLast();
byte[] OPROTtmpChunk1=stack.pollLast();
stack.add(OPROTtmpChunk2);
stack.add(OPROTtmpChunk3);
stack.add(OPROTtmpChunk1);
break;
case OP_SWAP:
case OP_TUCK:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
byte[] OPSWAPtmpChunk2=stack.pollLast();
byte[] OPSWAPtmpChunk1=stack.pollLast();
stack.add(OPSWAPtmpChunk2);
stack.add(OPSWAPtmpChunk1);
if (opcode == OP_TUCK) stack.add(OPSWAPtmpChunk2);
break;
case OP_CAT:
case OP_SUBSTR:
case OP_LEFT:
case OP_RIGHT:
throw new ScriptException(""String_Node_Str"");
case OP_SIZE:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.valueOf(stack.getLast().length),false)));
break;
case OP_INVERT:
case OP_AND:
case OP_OR:
case OP_XOR:
throw new ScriptException(""String_Node_Str"");
case OP_EQUAL:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
stack.add(Arrays.equals(stack.pollLast(),stack.pollLast()) ? new byte[]{1} : new byte[]{0});
break;
case OP_EQUALVERIFY:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
if (!Arrays.equals(stack.pollLast(),stack.pollLast())) throw new ScriptException(""String_Node_Str"");
break;
case OP_1ADD:
case OP_1SUB:
case OP_NEGATE:
case OP_ABS:
case OP_NOT:
case OP_0NOTEQUAL:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
BigInteger numericOPnum=castToBigInteger(stack.pollLast());
switch (opcode) {
case OP_1ADD:
numericOPnum=numericOPnum.add(BigInteger.ONE);
break;
case OP_1SUB:
numericOPnum=numericOPnum.subtract(BigInteger.ONE);
break;
case OP_NEGATE:
numericOPnum=numericOPnum.negate();
break;
case OP_ABS:
if (numericOPnum.compareTo(BigInteger.ZERO) < 0) numericOPnum=numericOPnum.negate();
break;
case OP_NOT:
if (numericOPnum.equals(BigInteger.ZERO)) numericOPnum=BigInteger.ONE;
 else numericOPnum=BigInteger.ZERO;
break;
case OP_0NOTEQUAL:
if (numericOPnum.equals(BigInteger.ZERO)) numericOPnum=BigInteger.ZERO;
 else numericOPnum=BigInteger.ONE;
break;
default :
throw new AssertionError(""String_Node_Str"");
}
stack.add(Utils.reverseBytes(Utils.encodeMPI(numericOPnum,false)));
break;
case OP_2MUL:
case OP_2DIV:
throw new ScriptException(""String_Node_Str"");
case OP_ADD:
case OP_SUB:
case OP_BOOLAND:
case OP_BOOLOR:
case OP_NUMEQUAL:
case OP_NUMNOTEQUAL:
case OP_LESSTHAN:
case OP_GREATERTHAN:
case OP_LESSTHANOREQUAL:
case OP_GREATERTHANOREQUAL:
case OP_MIN:
case OP_MAX:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
BigInteger numericOPnum2=castToBigInteger(stack.pollLast());
BigInteger numericOPnum1=castToBigInteger(stack.pollLast());
BigInteger numericOPresult;
switch (opcode) {
case OP_ADD:
numericOPresult=numericOPnum1.add(numericOPnum2);
break;
case OP_SUB:
numericOPresult=numericOPnum1.subtract(numericOPnum2);
break;
case OP_BOOLAND:
if (!numericOPnum1.equals(BigInteger.ZERO) && !numericOPnum2.equals(BigInteger.ZERO)) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_BOOLOR:
if (!numericOPnum1.equals(BigInteger.ZERO) || !numericOPnum2.equals(BigInteger.ZERO)) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_NUMEQUAL:
if (numericOPnum1.equals(numericOPnum2)) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_NUMNOTEQUAL:
if (!numericOPnum1.equals(numericOPnum2)) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_LESSTHAN:
if (numericOPnum1.compareTo(numericOPnum2) < 0) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_GREATERTHAN:
if (numericOPnum1.compareTo(numericOPnum2) > 0) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_LESSTHANOREQUAL:
if (numericOPnum1.compareTo(numericOPnum2) <= 0) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_GREATERTHANOREQUAL:
if (numericOPnum1.compareTo(numericOPnum2) >= 0) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_MIN:
if (numericOPnum1.compareTo(numericOPnum2) < 0) numericOPresult=numericOPnum1;
 else numericOPresult=numericOPnum2;
break;
case OP_MAX:
if (numericOPnum1.compareTo(numericOPnum2) > 0) numericOPresult=numericOPnum1;
 else numericOPresult=numericOPnum2;
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
stack.add(Utils.reverseBytes(Utils.encodeMPI(numericOPresult,false)));
break;
case OP_MUL:
case OP_DIV:
case OP_MOD:
case OP_LSHIFT:
case OP_RSHIFT:
throw new ScriptException(""String_Node_Str"");
case OP_NUMEQUALVERIFY:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
BigInteger OPNUMEQUALVERIFYnum2=castToBigInteger(stack.pollLast());
BigInteger OPNUMEQUALVERIFYnum1=castToBigInteger(stack.pollLast());
if (!OPNUMEQUALVERIFYnum1.equals(OPNUMEQUALVERIFYnum2)) throw new ScriptException(""String_Node_Str"");
break;
case OP_WITHIN:
if (stack.size() < 3) throw new ScriptException(""String_Node_Str"");
BigInteger OPWITHINnum3=castToBigInteger(stack.pollLast());
BigInteger OPWITHINnum2=castToBigInteger(stack.pollLast());
BigInteger OPWITHINnum1=castToBigInteger(stack.pollLast());
if (OPWITHINnum2.compareTo(OPWITHINnum1) <= 0 && OPWITHINnum1.compareTo(OPWITHINnum3) < 0) stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.ONE,false)));
 else stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.ZERO,false)));
break;
case OP_RIPEMD160:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
RIPEMD160Digest digest=new RIPEMD160Digest();
byte[] dataToHash=stack.pollLast();
digest.update(dataToHash,0,dataToHash.length);
byte[] ripmemdHash=new byte[20];
digest.doFinal(ripmemdHash,0);
stack.add(ripmemdHash);
break;
case OP_SHA1:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
try {
stack.add(MessageDigest.getInstance(""String_Node_Str"").digest(stack.pollLast()));
}
 catch (NoSuchAlgorithmException e) {
throw new RuntimeException(e);
}
break;
case OP_SHA256:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
try {
stack.add(MessageDigest.getInstance(""String_Node_Str"").digest(stack.pollLast()));
}
 catch (NoSuchAlgorithmException e) {
throw new RuntimeException(e);
}
break;
case OP_HASH160:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
stack.add(Utils.sha256hash160(stack.pollLast()));
break;
case OP_HASH256:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
stack.add(Utils.doubleDigest(stack.pollLast()));
break;
case OP_CODESEPARATOR:
lastCodeSepLocation=chunk.getStartLocationInProgram() + 1;
break;
case OP_CHECKSIG:
case OP_CHECKSIGVERIFY:
executeCheckSig(txContainingThis,(int)index,script,stack,lastCodeSepLocation,opcode);
break;
case OP_CHECKMULTISIG:
case OP_CHECKMULTISIGVERIFY:
opCount=executeMultiSig(txContainingThis,(int)index,script,stack,opCount,lastCodeSepLocation,opcode);
break;
case OP_NOP1:
case OP_NOP2:
case OP_NOP3:
case OP_NOP4:
case OP_NOP5:
case OP_NOP6:
case OP_NOP7:
case OP_NOP8:
case OP_NOP9:
case OP_NOP10:
break;
default :
throw new ScriptException(""String_Node_Str"" + opcode);
}
}
if (stack.size() + altstack.size() > 1000 || stack.size() + altstack.size() < 0) throw new ScriptException(""String_Node_Str"");
}
if (!ifStack.isEmpty()) throw new ScriptException(""String_Node_Str"");
}","private static void executeScript(Transaction txContainingThis,long index,Script script,LinkedList<byte[]> stack) throws ScriptException {
  int opCount=0;
  int lastCodeSepLocation=0;
  LinkedList<byte[]> altstack=new LinkedList<byte[]>();
  LinkedList<Boolean> ifStack=new LinkedList<Boolean>();
  for (  ScriptChunk chunk : script.chunks) {
    boolean shouldExecute=!ifStack.contains(false);
    if (!chunk.isOpCode()) {
      if (chunk.data.length > MAX_SCRIPT_ELEMENT_SIZE)       throw new ScriptException(""String_Node_Str"");
      if (!shouldExecute)       continue;
      stack.add(chunk.data);
    }
 else {
      int opcode=0xFF & chunk.data[0];
      if (opcode > OP_16) {
        opCount++;
        if (opCount > 201)         throw new ScriptException(""String_Node_Str"");
      }
      if (opcode == OP_VERIF || opcode == OP_VERNOTIF)       throw new ScriptException(""String_Node_Str"");
      if (opcode == OP_CAT || opcode == OP_SUBSTR || opcode == OP_LEFT || opcode == OP_RIGHT || opcode == OP_INVERT || opcode == OP_AND || opcode == OP_OR || opcode == OP_XOR || opcode == OP_2MUL || opcode == OP_2DIV || opcode == OP_MUL || opcode == OP_DIV || opcode == OP_MOD || opcode == OP_LSHIFT || opcode == OP_RSHIFT)       throw new ScriptException(""String_Node_Str"");
switch (opcode) {
case OP_IF:
        if (!shouldExecute) {
          ifStack.add(false);
          continue;
        }
      if (stack.size() < 1)       throw new ScriptException(""String_Node_Str"");
    ifStack.add(castToBool(stack.pollLast()));
  continue;
case OP_NOTIF:
if (!shouldExecute) {
  ifStack.add(false);
  continue;
}
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
ifStack.add(!castToBool(stack.pollLast()));
continue;
case OP_ELSE:
if (ifStack.isEmpty()) throw new ScriptException(""String_Node_Str"");
ifStack.add(!ifStack.pollLast());
continue;
case OP_ENDIF:
if (ifStack.isEmpty()) throw new ScriptException(""String_Node_Str"");
ifStack.pollLast();
continue;
}
if (!shouldExecute) continue;
switch (opcode) {
case OP_0:
stack.add(new byte[]{0});
break;
case OP_1NEGATE:
stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.ONE.negate(),false)));
break;
case OP_1:
case OP_2:
case OP_3:
case OP_4:
case OP_5:
case OP_6:
case OP_7:
case OP_8:
case OP_9:
case OP_10:
case OP_11:
case OP_12:
case OP_13:
case OP_14:
case OP_15:
case OP_16:
stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.valueOf(decodeFromOpN(opcode)),false)));
break;
case OP_NOP:
break;
case OP_VERIFY:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
if (!castToBool(stack.pollLast())) throw new ScriptException(""String_Node_Str"");
break;
case OP_RETURN:
throw new ScriptException(""String_Node_Str"");
case OP_TOALTSTACK:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
altstack.add(stack.pollLast());
break;
case OP_FROMALTSTACK:
if (altstack.size() < 1) throw new ScriptException(""String_Node_Str"");
stack.add(altstack.pollLast());
break;
case OP_2DROP:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
stack.pollLast();
stack.pollLast();
break;
case OP_2DUP:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
Iterator<byte[]> it2DUP=stack.descendingIterator();
byte[] OP2DUPtmpChunk2=it2DUP.next();
stack.add(it2DUP.next());
stack.add(OP2DUPtmpChunk2);
break;
case OP_3DUP:
if (stack.size() < 3) throw new ScriptException(""String_Node_Str"");
Iterator<byte[]> it3DUP=stack.descendingIterator();
byte[] OP3DUPtmpChunk3=it3DUP.next();
byte[] OP3DUPtmpChunk2=it3DUP.next();
stack.add(it3DUP.next());
stack.add(OP3DUPtmpChunk2);
stack.add(OP3DUPtmpChunk3);
break;
case OP_2OVER:
if (stack.size() < 4) throw new ScriptException(""String_Node_Str"");
Iterator<byte[]> it2OVER=stack.descendingIterator();
it2OVER.next();
it2OVER.next();
byte[] OP2OVERtmpChunk2=it2OVER.next();
stack.add(it2OVER.next());
stack.add(OP2OVERtmpChunk2);
break;
case OP_2ROT:
if (stack.size() < 6) throw new ScriptException(""String_Node_Str"");
byte[] OP2ROTtmpChunk6=stack.pollLast();
byte[] OP2ROTtmpChunk5=stack.pollLast();
byte[] OP2ROTtmpChunk4=stack.pollLast();
byte[] OP2ROTtmpChunk3=stack.pollLast();
byte[] OP2ROTtmpChunk2=stack.pollLast();
byte[] OP2ROTtmpChunk1=stack.pollLast();
stack.add(OP2ROTtmpChunk3);
stack.add(OP2ROTtmpChunk4);
stack.add(OP2ROTtmpChunk5);
stack.add(OP2ROTtmpChunk6);
stack.add(OP2ROTtmpChunk1);
stack.add(OP2ROTtmpChunk2);
break;
case OP_2SWAP:
if (stack.size() < 4) throw new ScriptException(""String_Node_Str"");
byte[] OP2SWAPtmpChunk4=stack.pollLast();
byte[] OP2SWAPtmpChunk3=stack.pollLast();
byte[] OP2SWAPtmpChunk2=stack.pollLast();
byte[] OP2SWAPtmpChunk1=stack.pollLast();
stack.add(OP2SWAPtmpChunk3);
stack.add(OP2SWAPtmpChunk4);
stack.add(OP2SWAPtmpChunk1);
stack.add(OP2SWAPtmpChunk2);
break;
case OP_IFDUP:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
if (castToBool(stack.getLast())) stack.add(stack.getLast());
break;
case OP_DEPTH:
stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.valueOf(stack.size()),false)));
break;
case OP_DROP:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
stack.pollLast();
break;
case OP_DUP:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
stack.add(stack.getLast());
break;
case OP_NIP:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
byte[] OPNIPtmpChunk=stack.pollLast();
stack.pollLast();
stack.add(OPNIPtmpChunk);
break;
case OP_OVER:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
Iterator<byte[]> itOVER=stack.descendingIterator();
itOVER.next();
stack.add(itOVER.next());
break;
case OP_PICK:
case OP_ROLL:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
long val=castToBigInteger(stack.pollLast()).longValue();
if (val < 0 || val >= stack.size()) throw new ScriptException(""String_Node_Str"");
Iterator<byte[]> itPICK=stack.descendingIterator();
for (long i=0; i < val; i++) itPICK.next();
byte[] OPROLLtmpChunk=itPICK.next();
if (opcode == OP_ROLL) itPICK.remove();
stack.add(OPROLLtmpChunk);
break;
case OP_ROT:
if (stack.size() < 3) throw new ScriptException(""String_Node_Str"");
byte[] OPROTtmpChunk3=stack.pollLast();
byte[] OPROTtmpChunk2=stack.pollLast();
byte[] OPROTtmpChunk1=stack.pollLast();
stack.add(OPROTtmpChunk2);
stack.add(OPROTtmpChunk3);
stack.add(OPROTtmpChunk1);
break;
case OP_SWAP:
case OP_TUCK:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
byte[] OPSWAPtmpChunk2=stack.pollLast();
byte[] OPSWAPtmpChunk1=stack.pollLast();
stack.add(OPSWAPtmpChunk2);
stack.add(OPSWAPtmpChunk1);
if (opcode == OP_TUCK) stack.add(OPSWAPtmpChunk2);
break;
case OP_CAT:
case OP_SUBSTR:
case OP_LEFT:
case OP_RIGHT:
throw new ScriptException(""String_Node_Str"");
case OP_SIZE:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.valueOf(stack.getLast().length),false)));
break;
case OP_INVERT:
case OP_AND:
case OP_OR:
case OP_XOR:
throw new ScriptException(""String_Node_Str"");
case OP_EQUAL:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
stack.add(Arrays.equals(stack.pollLast(),stack.pollLast()) ? new byte[]{1} : new byte[]{0});
break;
case OP_EQUALVERIFY:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
if (!Arrays.equals(stack.pollLast(),stack.pollLast())) throw new ScriptException(""String_Node_Str"");
break;
case OP_1ADD:
case OP_1SUB:
case OP_NEGATE:
case OP_ABS:
case OP_NOT:
case OP_0NOTEQUAL:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
BigInteger numericOPnum=castToBigInteger(stack.pollLast());
switch (opcode) {
case OP_1ADD:
numericOPnum=numericOPnum.add(BigInteger.ONE);
break;
case OP_1SUB:
numericOPnum=numericOPnum.subtract(BigInteger.ONE);
break;
case OP_NEGATE:
numericOPnum=numericOPnum.negate();
break;
case OP_ABS:
if (numericOPnum.compareTo(BigInteger.ZERO) < 0) numericOPnum=numericOPnum.negate();
break;
case OP_NOT:
if (numericOPnum.equals(BigInteger.ZERO)) numericOPnum=BigInteger.ONE;
 else numericOPnum=BigInteger.ZERO;
break;
case OP_0NOTEQUAL:
if (numericOPnum.equals(BigInteger.ZERO)) numericOPnum=BigInteger.ZERO;
 else numericOPnum=BigInteger.ONE;
break;
default :
throw new AssertionError(""String_Node_Str"");
}
stack.add(Utils.reverseBytes(Utils.encodeMPI(numericOPnum,false)));
break;
case OP_2MUL:
case OP_2DIV:
throw new ScriptException(""String_Node_Str"");
case OP_ADD:
case OP_SUB:
case OP_BOOLAND:
case OP_BOOLOR:
case OP_NUMEQUAL:
case OP_NUMNOTEQUAL:
case OP_LESSTHAN:
case OP_GREATERTHAN:
case OP_LESSTHANOREQUAL:
case OP_GREATERTHANOREQUAL:
case OP_MIN:
case OP_MAX:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
BigInteger numericOPnum2=castToBigInteger(stack.pollLast());
BigInteger numericOPnum1=castToBigInteger(stack.pollLast());
BigInteger numericOPresult;
switch (opcode) {
case OP_ADD:
numericOPresult=numericOPnum1.add(numericOPnum2);
break;
case OP_SUB:
numericOPresult=numericOPnum1.subtract(numericOPnum2);
break;
case OP_BOOLAND:
if (!numericOPnum1.equals(BigInteger.ZERO) && !numericOPnum2.equals(BigInteger.ZERO)) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_BOOLOR:
if (!numericOPnum1.equals(BigInteger.ZERO) || !numericOPnum2.equals(BigInteger.ZERO)) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_NUMEQUAL:
if (numericOPnum1.equals(numericOPnum2)) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_NUMNOTEQUAL:
if (!numericOPnum1.equals(numericOPnum2)) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_LESSTHAN:
if (numericOPnum1.compareTo(numericOPnum2) < 0) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_GREATERTHAN:
if (numericOPnum1.compareTo(numericOPnum2) > 0) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_LESSTHANOREQUAL:
if (numericOPnum1.compareTo(numericOPnum2) <= 0) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_GREATERTHANOREQUAL:
if (numericOPnum1.compareTo(numericOPnum2) >= 0) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_MIN:
if (numericOPnum1.compareTo(numericOPnum2) < 0) numericOPresult=numericOPnum1;
 else numericOPresult=numericOPnum2;
break;
case OP_MAX:
if (numericOPnum1.compareTo(numericOPnum2) > 0) numericOPresult=numericOPnum1;
 else numericOPresult=numericOPnum2;
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
stack.add(Utils.reverseBytes(Utils.encodeMPI(numericOPresult,false)));
break;
case OP_MUL:
case OP_DIV:
case OP_MOD:
case OP_LSHIFT:
case OP_RSHIFT:
throw new ScriptException(""String_Node_Str"");
case OP_NUMEQUALVERIFY:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
BigInteger OPNUMEQUALVERIFYnum2=castToBigInteger(stack.pollLast());
BigInteger OPNUMEQUALVERIFYnum1=castToBigInteger(stack.pollLast());
if (!OPNUMEQUALVERIFYnum1.equals(OPNUMEQUALVERIFYnum2)) throw new ScriptException(""String_Node_Str"");
break;
case OP_WITHIN:
if (stack.size() < 3) throw new ScriptException(""String_Node_Str"");
BigInteger OPWITHINnum3=castToBigInteger(stack.pollLast());
BigInteger OPWITHINnum2=castToBigInteger(stack.pollLast());
BigInteger OPWITHINnum1=castToBigInteger(stack.pollLast());
if (OPWITHINnum2.compareTo(OPWITHINnum1) <= 0 && OPWITHINnum1.compareTo(OPWITHINnum3) < 0) stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.ONE,false)));
 else stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.ZERO,false)));
break;
case OP_RIPEMD160:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
RIPEMD160Digest digest=new RIPEMD160Digest();
byte[] dataToHash=stack.pollLast();
digest.update(dataToHash,0,dataToHash.length);
byte[] ripmemdHash=new byte[20];
digest.doFinal(ripmemdHash,0);
stack.add(ripmemdHash);
break;
case OP_SHA1:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
try {
stack.add(MessageDigest.getInstance(""String_Node_Str"").digest(stack.pollLast()));
}
 catch (NoSuchAlgorithmException e) {
throw new RuntimeException(e);
}
break;
case OP_SHA256:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
try {
stack.add(MessageDigest.getInstance(""String_Node_Str"").digest(stack.pollLast()));
}
 catch (NoSuchAlgorithmException e) {
throw new RuntimeException(e);
}
break;
case OP_HASH160:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
stack.add(Utils.sha256hash160(stack.pollLast()));
break;
case OP_HASH256:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
stack.add(Utils.doubleDigest(stack.pollLast()));
break;
case OP_CODESEPARATOR:
lastCodeSepLocation=chunk.getStartLocationInProgram() + 1;
break;
case OP_CHECKSIG:
case OP_CHECKSIGVERIFY:
executeCheckSig(txContainingThis,(int)index,script,stack,lastCodeSepLocation,opcode);
break;
case OP_CHECKMULTISIG:
case OP_CHECKMULTISIGVERIFY:
opCount=executeMultiSig(txContainingThis,(int)index,script,stack,opCount,lastCodeSepLocation,opcode);
break;
case OP_NOP1:
case OP_NOP2:
case OP_NOP3:
case OP_NOP4:
case OP_NOP5:
case OP_NOP6:
case OP_NOP7:
case OP_NOP8:
case OP_NOP9:
case OP_NOP10:
break;
default :
throw new ScriptException(""String_Node_Str"" + opcode);
}
}
if (stack.size() + altstack.size() > 1000 || stack.size() + altstack.size() < 0) throw new ScriptException(""String_Node_Str"");
}
if (!ifStack.isEmpty()) throw new ScriptException(""String_Node_Str"");
}",0.9960254076743064
85811,"/** 
 * <p>To run a script, first we parse it which breaks it up into chunks representing pushes of data or logical opcodes. Then we can run the parsed chunks.</p> <p>The reason for this split, instead of just interpreting directly, is to make it easier to reach into a programs structure and pull out bits of data without having to run it. This is necessary to render the to/from addresses of transactions in a user interface. The official client does something similar.</p>
 */
private void parse(byte[] program) throws ScriptException {
  chunks=new ArrayList<ScriptChunk>(10);
  ByteArrayInputStream bis=new ByteArrayInputStream(program);
  int initialSize=bis.available();
  while (bis.available() > 0) {
    int startLocationInProgram=initialSize - bis.available();
    int opcode=bis.read();
    long dataToRead=-1;
    if (opcode >= 0 && opcode < OP_PUSHDATA1) {
      dataToRead=opcode;
    }
 else     if (opcode == OP_PUSHDATA1) {
      if (bis.available() < 1)       throw new ScriptException(""String_Node_Str"");
      dataToRead=bis.read();
    }
 else     if (opcode == OP_PUSHDATA2) {
      if (bis.available() < 2)       throw new ScriptException(""String_Node_Str"");
      dataToRead=bis.read() | (bis.read() << 8);
    }
 else     if (opcode == OP_PUSHDATA4) {
      if (bis.available() < 4)       throw new ScriptException(""String_Node_Str"");
      dataToRead=bis.read() | (bis.read() << 8) | (bis.read() << 16)| (bis.read() << 24);
    }
    if (dataToRead == -1) {
      chunks.add(new ScriptChunk(true,new byte[]{(byte)opcode},startLocationInProgram));
    }
 else {
      if (dataToRead > MAX_SCRIPT_ELEMENT_SIZE)       throw new ScriptException(""String_Node_Str"");
      byte[] data=new byte[(int)dataToRead];
      if (dataToRead > 0 && bis.read(data,0,(int)dataToRead) < dataToRead)       throw new ScriptException(""String_Node_Str"");
      chunks.add(new ScriptChunk(false,data,startLocationInProgram));
    }
  }
}","/** 
 * <p>To run a script, first we parse it which breaks it up into chunks representing pushes of data or logical opcodes. Then we can run the parsed chunks.</p> <p>The reason for this split, instead of just interpreting directly, is to make it easier to reach into a programs structure and pull out bits of data without having to run it. This is necessary to render the to/from addresses of transactions in a user interface. The official client does something similar.</p>
 */
private void parse(byte[] program) throws ScriptException {
  chunks=new ArrayList<ScriptChunk>(10);
  ByteArrayInputStream bis=new ByteArrayInputStream(program);
  int initialSize=bis.available();
  while (bis.available() > 0) {
    int startLocationInProgram=initialSize - bis.available();
    int opcode=bis.read();
    long dataToRead=-1;
    if (opcode >= 0 && opcode < OP_PUSHDATA1) {
      dataToRead=opcode;
    }
 else     if (opcode == OP_PUSHDATA1) {
      if (bis.available() < 1)       throw new ScriptException(""String_Node_Str"");
      dataToRead=bis.read();
    }
 else     if (opcode == OP_PUSHDATA2) {
      if (bis.available() < 2)       throw new ScriptException(""String_Node_Str"");
      dataToRead=bis.read() | (bis.read() << 8);
    }
 else     if (opcode == OP_PUSHDATA4) {
      if (bis.available() < 4)       throw new ScriptException(""String_Node_Str"");
      dataToRead=((long)bis.read()) | (((long)bis.read()) << 8) | (((long)bis.read()) << 16)| (((long)bis.read()) << 24);
    }
    if (dataToRead == -1) {
      chunks.add(new ScriptChunk(true,new byte[]{(byte)opcode},startLocationInProgram));
    }
 else {
      if (dataToRead > bis.available())       throw new ScriptException(""String_Node_Str"");
      byte[] data=new byte[(int)dataToRead];
      checkState(dataToRead == 0 || bis.read(data,0,(int)dataToRead) == dataToRead);
      chunks.add(new ScriptChunk(false,data,startLocationInProgram));
    }
  }
}",0.9099378881987578
85812,"public BlockAndValidityList getBlocksToTest(boolean addSigExpensiveBlocks,boolean runLargeReorgs,File blockStorageFile) throws ScriptException, ProtocolException, IOException {
  final FileOutputStream outStream=blockStorageFile != null ? new FileOutputStream(blockStorageFile) : null;
  List<BlockAndValidity> blocks=new LinkedList<BlockAndValidity>(){
    @Override public boolean add(    BlockAndValidity element){
      if (outStream != null) {
        try {
          outStream.write((int)(params.packetMagic >>> 24));
          outStream.write((int)(params.packetMagic >>> 16));
          outStream.write((int)(params.packetMagic >>> 8));
          outStream.write((int)(params.packetMagic >>> 0));
          byte[] block=element.block.bitcoinSerialize();
          byte[] length=new byte[4];
          Utils.uint32ToByteArrayBE(block.length,length,0);
          outStream.write(Utils.reverseBytes(length));
          outStream.write(block);
          element.block=null;
        }
 catch (        IOException e) {
          throw new RuntimeException(e);
        }
      }
      return super.add(element);
    }
  }
;
  BlockAndValidityList ret=new BlockAndValidityList(blocks,10);
  Queue<TransactionOutPointWithValue> spendableOutputs=new LinkedList<TransactionOutPointWithValue>();
  int chainHeadHeight=1;
  Block chainHead=params.genesisBlock.createNextBlockWithCoinbase(coinbaseOutKeyPubKey);
  blocks.add(new BlockAndValidity(blockToHeightMap,chainHead,true,false,chainHead.getHash(),1,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,chainHead.getTransactions().get(0).getHash()),Utils.toNanoCoins(50,0),chainHead.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  for (int i=1; i < params.getSpendableCoinbaseDepth(); i++) {
    chainHead=chainHead.createNextBlockWithCoinbase(coinbaseOutKeyPubKey);
    chainHeadHeight++;
    blocks.add(new BlockAndValidity(blockToHeightMap,chainHead,true,false,chainHead.getHash(),i + 1,""String_Node_Str""));
    spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,chainHead.getTransactions().get(0).getHash()),Utils.toNanoCoins(50,0),chainHead.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  }
  Block b1=createNextBlock(chainHead,chainHeadHeight + 1,spendableOutputs.poll(),null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b1,true,false,b1.getHash(),chainHeadHeight + 1,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b1.getTransactions().get(0).getHash()),b1.getTransactions().get(0).getOutputs().get(0).getValue(),b1.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out1=spendableOutputs.poll();
  Preconditions.checkState(out1 != null);
  Block b2=createNextBlock(b1,chainHeadHeight + 2,out1,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b2,true,false,b2.getHash(),chainHeadHeight + 2,""String_Node_Str""));
  blocks.add(new BlockAndValidity(blockToHeightMap,b2,true,false,b2.getHash(),chainHeadHeight + 2,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b2.getTransactions().get(0).getHash()),b2.getTransactions().get(0).getOutputs().get(0).getValue(),b2.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  Block b3=createNextBlock(b1,chainHeadHeight + 2,out1,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b3,true,false,b2.getHash(),chainHeadHeight + 2,""String_Node_Str""));
  blocks.add(new BlockAndValidity(blockToHeightMap,b3,true,false,b2.getHash(),chainHeadHeight + 2,""String_Node_Str""));
  TransactionOutPointWithValue out2=spendableOutputs.poll();
  Preconditions.checkState(out2 != null);
  Block b4=createNextBlock(b3,chainHeadHeight + 3,out2,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b4,true,false,b4.getHash(),chainHeadHeight + 3,""String_Node_Str""));
  Block b5=createNextBlock(b2,chainHeadHeight + 3,out2,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b5,true,false,b4.getHash(),chainHeadHeight + 3,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b5.getTransactions().get(0).getHash()),b5.getTransactions().get(0).getOutputs().get(0).getValue(),b5.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out3=spendableOutputs.poll();
  Block b6=createNextBlock(b5,chainHeadHeight + 4,out3,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b6,true,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  Block b7=createNextBlock(b5,chainHeadHeight + 5,out2,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b7,true,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  TransactionOutPointWithValue out4=spendableOutputs.poll();
  Block b8=createNextBlock(b7,chainHeadHeight + 6,out4,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b8,false,true,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  Block b9=createNextBlock(b6,chainHeadHeight + 5,out4,BigInteger.valueOf(1));
  blocks.add(new BlockAndValidity(blockToHeightMap,b9,false,true,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  Block b10=createNextBlock(b5,chainHeadHeight + 4,out3,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b10,true,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  Block b11=createNextBlock(b10,chainHeadHeight + 5,out4,BigInteger.valueOf(1));
  blocks.add(new BlockAndValidity(blockToHeightMap,b11,false,true,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  Block b12=createNextBlock(b5,chainHeadHeight + 4,out3,null);
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b12.getTransactions().get(0).getHash()),b12.getTransactions().get(0).getOutputs().get(0).getValue(),b12.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  Block b13=createNextBlock(b12,chainHeadHeight + 5,out4,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b13,false,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  blocks.add(new BlockAndValidity(blockToHeightMap,b13,false,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b13.getTransactions().get(0).getHash()),b13.getTransactions().get(0).getOutputs().get(0).getValue(),b13.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out5=spendableOutputs.poll();
  Block b14=createNextBlock(b13,chainHeadHeight + 6,out5,BigInteger.valueOf(1));
  blocks.add(new BlockAndValidity(blockToHeightMap,b14,false,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  blocks.add(new BlockAndValidity(blockToHeightMap,b14,false,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  blocks.add(new BlockAndValidity(blockToHeightMap,b12,false,true,b13.getHash(),chainHeadHeight + 5,""String_Node_Str""));
  Block b15=createNextBlock(b13,chainHeadHeight + 6,out5,null);
{
    int sigOps=0;
    for (    Transaction tx : b15.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b15.getTransactions().get(1).getHash()),BigInteger.valueOf(1),b15.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b15.addTransaction(tx);
  }
  b15.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b15,true,false,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b15.getTransactions().get(0).getHash()),b15.getTransactions().get(0).getOutputs().get(0).getValue(),b15.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out6=spendableOutputs.poll();
  Block b16=createNextBlock(b15,chainHeadHeight + 7,out6,null);
{
    int sigOps=0;
    for (    Transaction tx : b16.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + 1];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b16.getTransactions().get(1).getHash()),BigInteger.valueOf(1),b16.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b16.addTransaction(tx);
  }
  b16.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b16,false,true,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  Block b17=createNextBlock(b15,chainHeadHeight + 7,out6,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),new byte[]{}));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b3.getTransactions().get(1).getHash()),BigInteger.valueOf(1),b3.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b17.addTransaction(tx);
  }
  b17.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b17,false,true,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  Block b18=createNextBlock(b13,chainHeadHeight + 6,out5,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),new byte[]{}));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b3.getTransactions().get(1).getHash()),BigInteger.valueOf(1),b3.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b18.addTransaction(tx);
  }
  b18.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b18,true,false,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  Block b19=createNextBlock(b18,chainHeadHeight + 7,out6,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b19,false,true,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  TransactionOutPointWithValue out7=spendableOutputs.poll();
  Block b20=createNextBlock(b15,chainHeadHeight + 7,out7,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b20,false,true,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  Block b21=createNextBlock(b13,chainHeadHeight + 6,out6,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b21,true,false,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  Block b22=createNextBlock(b21,chainHeadHeight + 7,out5,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b22,false,true,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  Block b23=createNextBlock(b15,chainHeadHeight + 7,out6,null);
{
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIZE - b23.getMessageSize() - 138];
    Arrays.fill(outputScript,(byte)OP_FALSE);
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b23.getTransactions().get(1).getHash()),BigInteger.valueOf(1),b23.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b23.addTransaction(tx);
  }
  b23.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b23,true,false,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b23.getTransactions().get(0).getHash()),b23.getTransactions().get(0).getOutputs().get(0).getValue(),b23.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  Block b24=createNextBlock(b15,chainHeadHeight + 7,out6,null);
{
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIZE - b24.getMessageSize() - 135];
    Arrays.fill(outputScript,(byte)OP_FALSE);
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b24.getTransactions().get(1).getHash()),BigInteger.valueOf(1),b24.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b24.addTransaction(tx);
  }
  b24.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b24,false,true,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  Block b25=createNextBlock(b24,chainHeadHeight + 8,out7,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b25,false,false,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  Block b26=createNextBlock(b15,chainHeadHeight + 7,out6,null);
  b26.getTransactions().get(0).getInputs().get(0).setScriptBytes(new byte[]{0});
  b26.setMerkleRoot(null);
  b26.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b26,false,true,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  Block b27=createNextBlock(b26,chainHeadHeight + 8,out7,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b27,false,false,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  Block b28=createNextBlock(b15,chainHeadHeight + 7,out6,null);
{
    byte[] coinbase=new byte[101];
    Arrays.fill(coinbase,(byte)0);
    b28.getTransactions().get(0).getInputs().get(0).setScriptBytes(coinbase);
  }
  b28.setMerkleRoot(null);
  b28.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b28,false,true,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  Block b29=createNextBlock(b28,chainHeadHeight + 8,out7,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b29,false,false,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  Block b30=createNextBlock(b23,chainHeadHeight + 8,out7,null);
{
    byte[] coinbase=new byte[100];
    Arrays.fill(coinbase,(byte)0);
    b30.getTransactions().get(0).getInputs().get(0).setScriptBytes(coinbase);
  }
  b30.setMerkleRoot(null);
  b30.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b30,true,false,b30.getHash(),chainHeadHeight + 8,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b30.getTransactions().get(0).getHash()),b30.getTransactions().get(0).getOutputs().get(0).getValue(),b30.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out8=spendableOutputs.poll();
  Block b31=createNextBlock(b30,chainHeadHeight + 9,out8,null);
{
    int sigOps=0;
    for (    Transaction tx : b31.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[(Block.MAX_BLOCK_SIGOPS - sigOps) / 20];
    Arrays.fill(outputScript,(byte)OP_CHECKMULTISIG);
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b31.getTransactions().get(1).getHash()),BigInteger.valueOf(1),b31.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b31.addTransaction(tx);
  }
  b31.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b31,true,false,b31.getHash(),chainHeadHeight + 9,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b31.getTransactions().get(0).getHash()),b31.getTransactions().get(0).getOutputs().get(0).getValue(),b31.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out9=spendableOutputs.poll();
  Block b32=createNextBlock(b31,chainHeadHeight + 10,out9,null);
{
    int sigOps=0;
    for (    Transaction tx : b32.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[(Block.MAX_BLOCK_SIGOPS - sigOps) / 20 + (Block.MAX_BLOCK_SIGOPS - sigOps) % 20 + 1];
    Arrays.fill(outputScript,(byte)OP_CHECKMULTISIG);
    for (int i=0; i < (Block.MAX_BLOCK_SIGOPS - sigOps) % 20; i++)     outputScript[i]=(byte)OP_CHECKSIG;
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b32.getTransactions().get(1).getHash()),BigInteger.valueOf(1),b32.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b32.addTransaction(tx);
  }
  b32.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b32,false,true,b31.getHash(),chainHeadHeight + 9,""String_Node_Str""));
  Block b33=createNextBlock(b31,chainHeadHeight + 10,out9,null);
{
    int sigOps=0;
    for (    Transaction tx : b33.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[(Block.MAX_BLOCK_SIGOPS - sigOps) / 20];
    Arrays.fill(outputScript,(byte)OP_CHECKMULTISIGVERIFY);
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b33.getTransactions().get(1).getHash()),BigInteger.valueOf(1),b33.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b33.addTransaction(tx);
  }
  b33.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b33,true,false,b33.getHash(),chainHeadHeight + 10,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b33.getTransactions().get(0).getHash()),b33.getTransactions().get(0).getOutputs().get(0).getValue(),b33.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out10=spendableOutputs.poll();
  Block b34=createNextBlock(b33,chainHeadHeight + 11,out10,null);
{
    int sigOps=0;
    for (    Transaction tx : b34.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[(Block.MAX_BLOCK_SIGOPS - sigOps) / 20 + (Block.MAX_BLOCK_SIGOPS - sigOps) % 20 + 1];
    Arrays.fill(outputScript,(byte)OP_CHECKMULTISIGVERIFY);
    for (int i=0; i < (Block.MAX_BLOCK_SIGOPS - sigOps) % 20; i++)     outputScript[i]=(byte)OP_CHECKSIG;
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b34.getTransactions().get(1).getHash()),BigInteger.valueOf(1),b34.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b34.addTransaction(tx);
  }
  b34.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b34,false,true,b33.getHash(),chainHeadHeight + 10,""String_Node_Str""));
  Block b35=createNextBlock(b33,chainHeadHeight + 11,out10,null);
{
    int sigOps=0;
    for (    Transaction tx : b35.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps];
    Arrays.fill(outputScript,(byte)OP_CHECKSIGVERIFY);
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b35.getTransactions().get(1).getHash()),BigInteger.valueOf(1),b35.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b35.addTransaction(tx);
  }
  b35.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b35,true,false,b35.getHash(),chainHeadHeight + 11,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b35.getTransactions().get(0).getHash()),b35.getTransactions().get(0).getOutputs().get(0).getValue(),b35.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out11=spendableOutputs.poll();
  Block b36=createNextBlock(b35,chainHeadHeight + 12,out11,null);
{
    int sigOps=0;
    for (    Transaction tx : b36.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + 1];
    Arrays.fill(outputScript,(byte)OP_CHECKSIGVERIFY);
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b36.getTransactions().get(1).getHash()),BigInteger.valueOf(1),b36.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b36.addTransaction(tx);
  }
  b36.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b36,false,true,b35.getHash(),chainHeadHeight + 11,""String_Node_Str""));
  Block b37=createNextBlock(b35,chainHeadHeight + 12,out11,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),new byte[]{}));
    addOnlyInputToTransaction(tx,out11);
    b37.addTransaction(tx);
  }
  b37.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b37,false,true,b35.getHash(),chainHeadHeight + 11,""String_Node_Str""));
  Block b38=createNextBlock(b35,chainHeadHeight + 12,out11,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),new byte[]{}));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b37.getTransactions().get(1).getHash()),BigInteger.valueOf(1),b37.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b38.addTransaction(tx);
  }
  b38.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b38,false,true,b35.getHash(),chainHeadHeight + 11,""String_Node_Str""));
  byte[] b39p2shScriptPubKey;
  int b39numP2SHOutputs=0, b39sigOpsPerOutput=6;
  Block b39=createNextBlock(b35,chainHeadHeight + 12,null,null);
{
    ByteArrayOutputStream p2shScriptPubKey=new UnsafeByteArrayOutputStream();
    try {
      Script.writeBytes(p2shScriptPubKey,coinbaseOutKeyPubKey);
      p2shScriptPubKey.write(OP_2DUP);
      p2shScriptPubKey.write(OP_CHECKSIGVERIFY);
      p2shScriptPubKey.write(OP_2DUP);
      p2shScriptPubKey.write(OP_CHECKSIGVERIFY);
      p2shScriptPubKey.write(OP_2DUP);
      p2shScriptPubKey.write(OP_CHECKSIGVERIFY);
      p2shScriptPubKey.write(OP_2DUP);
      p2shScriptPubKey.write(OP_CHECKSIGVERIFY);
      p2shScriptPubKey.write(OP_2DUP);
      p2shScriptPubKey.write(OP_CHECKSIGVERIFY);
      p2shScriptPubKey.write(OP_CHECKSIG);
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
    b39p2shScriptPubKey=p2shScriptPubKey.toByteArray();
    byte[] scriptHash=Utils.sha256hash160(b39p2shScriptPubKey);
    UnsafeByteArrayOutputStream scriptPubKey=new UnsafeByteArrayOutputStream(scriptHash.length + 3);
    scriptPubKey.write(OP_HASH160);
    try {
      Script.writeBytes(scriptPubKey,scriptHash);
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
    scriptPubKey.write(OP_EQUAL);
    BigInteger lastOutputValue=out11.value.subtract(BigInteger.valueOf(1));
    TransactionOutPoint lastOutPoint;
{
      Transaction tx=new Transaction(params);
      tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),scriptPubKey.toByteArray()));
      tx.addOutput(new TransactionOutput(params,tx,lastOutputValue,new byte[]{OP_1}));
      addOnlyInputToTransaction(tx,out11);
      lastOutPoint=new TransactionOutPoint(params,1,tx.getHash());
      b39.addTransaction(tx);
    }
    b39numP2SHOutputs++;
    while (b39.getMessageSize() < Block.MAX_BLOCK_SIZE) {
      Transaction tx=new Transaction(params);
      lastOutputValue=lastOutputValue.subtract(BigInteger.valueOf(1));
      tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),scriptPubKey.toByteArray()));
      tx.addOutput(new TransactionOutput(params,tx,lastOutputValue,new byte[]{OP_1}));
      tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},lastOutPoint));
      lastOutPoint=new TransactionOutPoint(params,1,tx.getHash());
      if (b39.getMessageSize() + tx.getMessageSize() < Block.MAX_BLOCK_SIZE) {
        b39.addTransaction(tx);
        b39numP2SHOutputs++;
      }
 else       break;
    }
  }
  b39.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b39,true,false,b39.getHash(),chainHeadHeight + 12,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b39.getTransactions().get(0).getHash()),b39.getTransactions().get(0).getOutputs().get(0).getValue(),b39.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out12=spendableOutputs.poll();
  Block b40=createNextBlock(b39,chainHeadHeight + 13,out12,null);
{
    int sigOps=0;
    for (    Transaction tx : b40.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    int numTxes=(Block.MAX_BLOCK_SIGOPS - sigOps) / b39sigOpsPerOutput;
    Preconditions.checkState(numTxes <= b39numP2SHOutputs);
    TransactionOutPoint lastOutPoint=new TransactionOutPoint(params,2,b40.getTransactions().get(1).getHash());
    byte[] scriptSig=null;
    for (int i=1; i <= numTxes; i++) {
      Transaction tx=new Transaction(params);
      tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),new byte[]{OP_1}));
      tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},lastOutPoint));
      TransactionInput input=new TransactionInput(params,tx,new byte[]{},new TransactionOutPoint(params,0,b39.getTransactions().get(i).getHash()));
      tx.addInput(input);
      if (scriptSig == null) {
        Sha256Hash hash=tx.hashTransactionForSignature(1,b39p2shScriptPubKey,SigHash.SINGLE,false);
        try {
          ByteArrayOutputStream bos=new UnsafeByteArrayOutputStream(73);
          bos.write(coinbaseOutKey.sign(hash).encodeToDER());
          bos.write(SigHash.SINGLE.ordinal() + 1);
          byte[] signature=bos.toByteArray();
          ByteArrayOutputStream scriptSigBos=new UnsafeByteArrayOutputStream(signature.length + b39p2shScriptPubKey.length + 3);
          Script.writeBytes(scriptSigBos,new byte[]{(byte)OP_CHECKSIG});
          scriptSigBos.write(Script.createInputScript(signature));
          Script.writeBytes(scriptSigBos,b39p2shScriptPubKey);
          scriptSig=scriptSigBos.toByteArray();
        }
 catch (        IOException e) {
          throw new RuntimeException(e);
        }
      }
      input.setScriptBytes(scriptSig);
      lastOutPoint=new TransactionOutPoint(params,0,tx.getHash());
      b40.addTransaction(tx);
    }
    sigOps+=numTxes * b39sigOpsPerOutput;
    Transaction tx=new Transaction(params);
    tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},lastOutPoint));
    byte[] scriptPubKey=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + 1];
    Arrays.fill(scriptPubKey,(byte)OP_CHECKSIG);
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.ZERO,scriptPubKey));
    b40.addTransaction(tx);
  }
  b40.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b40,false,true,b39.getHash(),chainHeadHeight + 12,""String_Node_Str""));
  Block b41=null;
  if (addSigExpensiveBlocks) {
    b41=createNextBlock(b39,chainHeadHeight + 13,out12,null);
{
      int sigOps=0;
      for (      Transaction tx : b41.transactions) {
        sigOps+=tx.getSigOpCount();
      }
      int numTxes=(Block.MAX_BLOCK_SIGOPS - sigOps) / b39sigOpsPerOutput;
      Preconditions.checkState(numTxes <= b39numP2SHOutputs);
      TransactionOutPoint lastOutPoint=new TransactionOutPoint(params,2,b41.getTransactions().get(1).getHash());
      byte[] scriptSig=null;
      for (int i=1; i <= numTxes; i++) {
        Transaction tx=new Transaction(params);
        tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),new byte[]{OP_1}));
        tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},lastOutPoint));
        TransactionInput input=new TransactionInput(params,tx,new byte[]{},new TransactionOutPoint(params,0,b39.getTransactions().get(i).getHash()));
        tx.addInput(input);
        if (scriptSig == null) {
          Sha256Hash hash=tx.hashTransactionForSignature(1,b39p2shScriptPubKey,SigHash.SINGLE,false);
          try {
            ByteArrayOutputStream bos=new UnsafeByteArrayOutputStream(73);
            bos.write(coinbaseOutKey.sign(hash).encodeToDER());
            bos.write(SigHash.SINGLE.ordinal() + 1);
            byte[] signature=bos.toByteArray();
            ByteArrayOutputStream scriptSigBos=new UnsafeByteArrayOutputStream(signature.length + b39p2shScriptPubKey.length + 3);
            Script.writeBytes(scriptSigBos,new byte[]{(byte)OP_CHECKSIG});
            scriptSigBos.write(Script.createInputScript(signature));
            Script.writeBytes(scriptSigBos,b39p2shScriptPubKey);
            scriptSig=scriptSigBos.toByteArray();
          }
 catch (          IOException e) {
            throw new RuntimeException(e);
          }
        }
        input.setScriptBytes(scriptSig);
        lastOutPoint=new TransactionOutPoint(params,0,tx.getHash());
        b41.addTransaction(tx);
      }
      sigOps+=numTxes * b39sigOpsPerOutput;
      Transaction tx=new Transaction(params);
      tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},lastOutPoint));
      byte[] scriptPubKey=new byte[Block.MAX_BLOCK_SIGOPS - sigOps];
      Arrays.fill(scriptPubKey,(byte)OP_CHECKSIG);
      tx.addOutput(new TransactionOutput(params,tx,BigInteger.ZERO,scriptPubKey));
      b41.addTransaction(tx);
    }
    b41.solve();
    blocks.add(new BlockAndValidity(blockToHeightMap,b41,true,false,b41.getHash(),chainHeadHeight + 13,""String_Node_Str""));
  }
  Block b42=createNextBlock(b39,chainHeadHeight + 13,out12,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b42,true,false,b41 == null ? b42.getHash() : b41.getHash(),chainHeadHeight + 13,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b42.getTransactions().get(0).getHash()),b42.getTransactions().get(0).getOutputs().get(0).getValue(),b42.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out13=spendableOutputs.poll();
  Block b43=createNextBlock(b42,chainHeadHeight + 14,out13,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b43,true,false,b43.getHash(),chainHeadHeight + 14,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b43.getTransactions().get(0).getHash()),b43.getTransactions().get(0).getOutputs().get(0).getValue(),b43.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out14=spendableOutputs.poll();
  Block b44=new Block(params);
  byte[] outScriptBytes=ScriptBuilder.createOutputScript(new ECKey(null,coinbaseOutKeyPubKey)).getProgram();
{
    b44.setDifficultyTarget(b43.getDifficultyTarget());
    b44.addCoinbaseTransaction(coinbaseOutKeyPubKey,BigInteger.ZERO);
    Transaction t=new Transaction(params);
    t.addOutput(new TransactionOutput(params,t,BigInteger.valueOf(0),new byte[]{OP_PUSHDATA1 - 1}));
    t.addOutput(new TransactionOutput(params,t,BigInteger.valueOf(1),outScriptBytes));
    t.addOutput(new TransactionOutput(params,t,BigInteger.ZERO,new byte[]{OP_1}));
    addOnlyInputToTransaction(t,out14);
    b44.addTransaction(t);
    b44.setPrevBlockHash(b43.getHash());
    b44.setTime(b43.getTimeSeconds() + 1);
  }
  b44.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b44,true,false,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  TransactionOutPointWithValue out15=spendableOutputs.poll();
  Block b45=new Block(params);
{
    b45.setDifficultyTarget(b44.getDifficultyTarget());
    Transaction t=new Transaction(params);
    t.addOutput(new TransactionOutput(params,t,BigInteger.valueOf(0),new byte[]{OP_PUSHDATA1 - 1}));
    t.addOutput(new TransactionOutput(params,t,BigInteger.valueOf(1),outScriptBytes));
    t.addOutput(new TransactionOutput(params,t,BigInteger.ZERO,new byte[]{OP_1}));
    addOnlyInputToTransaction(t,out15);
    try {
      b45.addTransaction(t);
    }
 catch (    RuntimeException e) {
    }
    if (b45.getTransactions().size() > 0)     throw new RuntimeException(""String_Node_Str"");
    b45.addTransaction(t,false);
    b45.setPrevBlockHash(b44.getHash());
    b45.setTime(b44.getTimeSeconds() + 1);
  }
  b45.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b45,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b46=new Block(params);
{
    b46.transactions=new ArrayList<Transaction>();
    b46.setDifficultyTarget(b44.getDifficultyTarget());
    b46.setMerkleRoot(Sha256Hash.ZERO_HASH);
    b46.setPrevBlockHash(b44.getHash());
    b46.setTime(b44.getTimeSeconds() + 1);
  }
  b46.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b46,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b47=createNextBlock(b44,chainHeadHeight + 16,out15,null);
{
    try {
      BigInteger target=b47.getDifficultyTargetAsInteger();
      while (true) {
        BigInteger h=b47.getHash().toBigInteger();
        if (h.compareTo(target) > 0)         break;
        b47.setNonce(b47.getNonce() + 1);
      }
    }
 catch (    VerificationException e) {
      throw new RuntimeException(e);
    }
  }
  blocks.add(new BlockAndValidity(blockToHeightMap,b47,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b48=createNextBlock(b44,chainHeadHeight + 16,out15,null);
  b48.setTime(Utils.now().getTime() / 1000 + 60 * 60 * 3);
  b48.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b48,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b49=createNextBlock(b44,chainHeadHeight + 16,out15,null);
  b49.setMerkleRoot(Sha256Hash.ZERO_HASH);
  b49.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b49,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b50=createNextBlock(b44,chainHeadHeight + 16,out15,null);
{
    long diffTarget=b44.getDifficultyTarget();
    diffTarget&=0xFFBFFFFF;
    b50.setDifficultyTarget(diffTarget);
  }
  b50.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b50,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b51=createNextBlock(b44,chainHeadHeight + 16,out15,null);
{
    Transaction coinbase=new Transaction(params);
    coinbase.addInput(new TransactionInput(params,coinbase,new byte[]{(byte)0xff,110,1}));
    coinbase.addOutput(new TransactionOutput(params,coinbase,BigInteger.ONE,outScriptBytes));
    b51.addTransaction(coinbase,false);
  }
  b51.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b51,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b52=createNextBlock(b44,chainHeadHeight + 16,out15,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),new byte[]{}));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b52.getTransactions().get(1).getHash()),BigInteger.valueOf(1),b52.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b52.addTransaction(tx);
    b52.addTransaction(tx);
  }
  b52.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b52,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b53=createNextBlock(b43,chainHeadHeight + 15,out14,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b53,true,false,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b53.getTransactions().get(0).getHash()),b53.getTransactions().get(0).getOutputs().get(0).getValue(),b53.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  Block b54=createNextBlock(b53,chainHeadHeight + 16,out15,null);
  b54.setTime(b35.getTimeSeconds() - 1);
  b54.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b54,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b55=createNextBlock(b53,chainHeadHeight + 16,out15,null);
  b55.setTime(b35.getTimeSeconds());
  b55.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b55,true,false,b55.getHash(),chainHeadHeight + 16,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b55.getTransactions().get(0).getHash()),b55.getTransactions().get(0).getOutputs().get(0).getValue(),b55.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out16=spendableOutputs.poll();
  Block b57=createNextBlock(b55,chainHeadHeight + 17,out16,null);
  Transaction b56txToDuplicate;
{
    b56txToDuplicate=new Transaction(params);
    b56txToDuplicate.addOutput(new TransactionOutput(params,b56txToDuplicate,BigInteger.valueOf(1),new byte[]{}));
    addOnlyInputToTransaction(b56txToDuplicate,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b57.getTransactions().get(1).getHash()),BigInteger.valueOf(1),b57.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b57.addTransaction(b56txToDuplicate);
  }
  b57.solve();
  Block b56;
  try {
    b56=new Block(params,b57.bitcoinSerialize());
  }
 catch (  ProtocolException e) {
    throw new RuntimeException(e);
  }
  b56.addTransaction(b56txToDuplicate);
  Preconditions.checkState(b56.getHash().equals(b57.getHash()));
  blocks.add(new BlockAndValidity(blockToHeightMap,b56,false,true,b55.getHash(),chainHeadHeight + 16,""String_Node_Str""));
  blocks.add(new BlockAndValidity(blockToHeightMap,b57,true,false,b57.getHash(),chainHeadHeight + 17,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b57.getTransactions().get(0).getHash()),b57.getTransactions().get(0).getOutputs().get(0).getValue(),b57.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out17=spendableOutputs.poll();
  Block b58=createNextBlock(b57,chainHeadHeight + 18,out17,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.ZERO,new byte[]{}));
    tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},new TransactionOutPoint(params,3,b58.getTransactions().get(1).getHash())));
    b58.addTransaction(tx);
  }
  b58.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b58,false,true,b57.getHash(),chainHeadHeight + 17,""String_Node_Str""));
  Block b59=createNextBlock(b57,chainHeadHeight + 18,out17,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,b59.getTransactions().get(1).getOutputs().get(2).getValue().add(BigInteger.ONE),new byte[]{}));
    tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},new TransactionOutPoint(params,2,b59.getTransactions().get(1).getHash())));
    b59.addTransaction(tx);
  }
  b59.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b59,false,true,b57.getHash(),chainHeadHeight + 17,""String_Node_Str""));
  Block b60=createNextBlock(b57,chainHeadHeight + 18,out17,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b60,true,false,b60.getHash(),chainHeadHeight + 18,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b60.getTransactions().get(0).getHash()),b60.getTransactions().get(0).getOutputs().get(0).getValue(),b60.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out18=spendableOutputs.poll();
  Block b61=createNextBlock(b60,chainHeadHeight + 19,out18,null);
{
    byte[] scriptBytes=b61.getTransactions().get(0).getInputs().get(0).getScriptBytes();
    scriptBytes[0]--;
    b61.getTransactions().get(0).getInputs().get(0).setScriptBytes(scriptBytes);
    b61.unCache();
    Preconditions.checkState(b61.getTransactions().get(0).equals(b60.getTransactions().get(0)));
  }
  b61.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b61,false,true,b60.getHash(),chainHeadHeight + 18,""String_Node_Str""));
  Block b62=createNextBlock(b60,chainHeadHeight + 19,null,null);
{
    Transaction tx=new Transaction(params);
    tx.setLockTime(0xffffffffL);
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.ZERO,new byte[]{OP_TRUE}));
    addOnlyInputToTransaction(tx,out18,0);
    b62.addTransaction(tx);
    Preconditions.checkState(!tx.isFinal(chainHeadHeight + 17,b62.getTimeSeconds()));
  }
  b62.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b62,false,true,b60.getHash(),chainHeadHeight + 18,""String_Node_Str""));
  Block b63=createNextBlock(b60,chainHeadHeight + 19,null,null);
{
    b63.getTransactions().get(0).setLockTime(0xffffffffL);
    b63.getTransactions().get(0).getInputs().get(0).setSequenceNumber(0xDEADBEEF);
    Preconditions.checkState(!b63.getTransactions().get(0).isFinal(chainHeadHeight + 17,b63.getTimeSeconds()));
  }
  b63.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b63,false,true,b60.getHash(),chainHeadHeight + 18,""String_Node_Str""));
  Block b64;
{
    Block b64Created=createNextBlock(b60,chainHeadHeight + 19,out18,null);
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIZE - b64Created.getMessageSize() - 138];
    Arrays.fill(outputScript,(byte)OP_FALSE);
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b64Created.getTransactions().get(1).getHash()),BigInteger.valueOf(1),b64Created.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b64Created.addTransaction(tx);
    b64Created.solve();
    UnsafeByteArrayOutputStream stream=new UnsafeByteArrayOutputStream(b64Created.getMessageSize() + 8);
    b64Created.writeHeader(stream);
    byte[] varIntBytes=new byte[9];
    varIntBytes[0]=(byte)255;
    Utils.uint32ToByteArrayLE((long)b64Created.getTransactions().size(),varIntBytes,1);
    Utils.uint32ToByteArrayLE(((long)b64Created.getTransactions().size()) >>> 32,varIntBytes,5);
    stream.write(varIntBytes);
    Preconditions.checkState(new VarInt(varIntBytes,0).value == b64Created.getTransactions().size());
    for (    Transaction transaction : b64Created.getTransactions())     transaction.bitcoinSerialize(stream);
    b64=new Block(params,stream.toByteArray(),false,true,stream.size());
    Preconditions.checkState(stream.size() == b64Created.getMessageSize() + 8);
    Preconditions.checkState(stream.size() == b64.getMessageSize());
    Preconditions.checkState(Arrays.equals(stream.toByteArray(),b64.bitcoinSerialize()));
    Preconditions.checkState(b64.getOptimalEncodingMessageSize() == b64Created.getMessageSize());
  }
  blocks.add(new BlockAndValidity(blockToHeightMap,b64,true,false,b64.getHash(),chainHeadHeight + 19,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b64.getTransactions().get(0).getHash()),b64.getTransactions().get(0).getOutputs().get(0).getValue(),b64.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out19=spendableOutputs.poll();
  Preconditions.checkState(out19 != null);
  Block b65=createNextBlock(b64,chainHeadHeight + 20,null,null);
{
    Transaction tx1=new Transaction(params);
    tx1.addOutput(new TransactionOutput(params,tx1,out19.value,new byte[]{OP_TRUE}));
    addOnlyInputToTransaction(tx1,out19,0);
    b65.addTransaction(tx1);
    Transaction tx2=new Transaction(params);
    tx2.addOutput(new TransactionOutput(params,tx2,BigInteger.ZERO,new byte[]{OP_TRUE}));
    tx2.addInput(new TransactionInput(params,tx2,new byte[]{OP_TRUE},new TransactionOutPoint(params,0,tx1.getHash())));
    b65.addTransaction(tx2);
  }
  b65.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b65,true,false,b65.getHash(),chainHeadHeight + 20,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b65.getTransactions().get(0).getHash()),b65.getTransactions().get(0).getOutputs().get(0).getValue(),b65.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out20=spendableOutputs.poll();
  Preconditions.checkState(out20 != null);
  Block b66=createNextBlock(b65,chainHeadHeight + 21,null,null);
{
    Transaction tx1=new Transaction(params);
    tx1.addOutput(new TransactionOutput(params,tx1,out20.value,new byte[]{OP_TRUE}));
    addOnlyInputToTransaction(tx1,out20,0);
    Transaction tx2=new Transaction(params);
    tx2.addOutput(new TransactionOutput(params,tx2,BigInteger.ZERO,new byte[]{OP_TRUE}));
    tx2.addInput(new TransactionInput(params,tx2,new byte[]{OP_TRUE},new TransactionOutPoint(params,0,tx1.getHash())));
    b66.addTransaction(tx2);
    b66.addTransaction(tx1);
  }
  b66.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b66,false,true,b65.getHash(),chainHeadHeight + 20,""String_Node_Str""));
  Block b67=createNextBlock(b65,chainHeadHeight + 21,null,null);
{
    Transaction tx1=new Transaction(params);
    tx1.addOutput(new TransactionOutput(params,tx1,out20.value,new byte[]{OP_TRUE}));
    addOnlyInputToTransaction(tx1,out20,0);
    b67.addTransaction(tx1);
    Transaction tx2=new Transaction(params);
    tx2.addOutput(new TransactionOutput(params,tx2,BigInteger.ZERO,new byte[]{OP_TRUE}));
    tx2.addInput(new TransactionInput(params,tx2,new byte[]{OP_TRUE},new TransactionOutPoint(params,0,tx1.getHash())));
    b67.addTransaction(tx2);
    Transaction tx3=new Transaction(params);
    tx3.addOutput(new TransactionOutput(params,tx3,out20.value,new byte[]{OP_TRUE}));
    tx3.addInput(new TransactionInput(params,tx3,new byte[]{OP_TRUE},new TransactionOutPoint(params,0,tx1.getHash())));
    b67.addTransaction(tx3);
  }
  b67.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b67,false,true,b65.getHash(),chainHeadHeight + 20,""String_Node_Str""));
  Block b68=createNextBlock(b65,chainHeadHeight + 21,null,BigInteger.TEN);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,out20.value.subtract(BigInteger.valueOf(9)),new byte[]{OP_TRUE}));
    addOnlyInputToTransaction(tx,out20,0);
    b68.addTransaction(tx);
  }
  b68.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b68,false,true,b65.getHash(),chainHeadHeight + 20,""String_Node_Str""));
  Block b69=createNextBlock(b65,chainHeadHeight + 21,null,BigInteger.TEN);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,out20.value.subtract(BigInteger.TEN),new byte[]{OP_TRUE}));
    addOnlyInputToTransaction(tx,out20,0);
    b69.addTransaction(tx);
  }
  b69.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b69,true,false,b69.getHash(),chainHeadHeight + 21,""String_Node_Str""));
  TransactionOutPointWithValue out21=spendableOutputs.poll();
  Preconditions.checkState(out21 != null);
  Block b70=createNextBlock(b69,chainHeadHeight + 22,out21,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.ZERO,new byte[]{OP_TRUE}));
    tx.addInput(new TransactionInput(params,tx,new byte[]{OP_TRUE},new TransactionOutPoint(params,0,new Sha256Hash(""String_Node_Str""))));
    b70.addTransaction(tx);
  }
  b70.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b70,false,true,b69.getHash(),chainHeadHeight + 21,""String_Node_Str""));
  Block b72=createNextBlock(b69,chainHeadHeight + 22,out21,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.ZERO,new byte[]{OP_TRUE}));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b72.getTransactions().get(1).getHash()),BigInteger.valueOf(1),b72.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b72.addTransaction(tx);
  }
  b72.solve();
  Block b71=new Block(params,b72.bitcoinSerialize());
  b71.addTransaction(b72.getTransactions().get(2));
  Preconditions.checkState(b71.getHash().equals(b72.getHash()));
  blocks.add(new BlockAndValidity(blockToHeightMap,b71,false,true,b69.getHash(),chainHeadHeight + 21,""String_Node_Str""));
  blocks.add(new BlockAndValidity(blockToHeightMap,b72,true,false,b72.getHash(),chainHeadHeight + 22,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b72.getTransactions().get(0).getHash()),b72.getTransactions().get(0).getOutputs().get(0).getValue(),b72.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out22=spendableOutputs.poll();
  Preconditions.checkState(out22 != null);
  Block b1001=createNextBlock(b72,chainHeadHeight + 23,out22,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b1001,true,false,b1001.getHash(),chainHeadHeight + 23,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b1001.getTransactions().get(0).getHash()),b1001.getTransactions().get(0).getOutputs().get(0).getValue(),b1001.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  if (runLargeReorgs) {
    Preconditions.checkArgument(blockStorageFile != null);
    Block lastBlock=b1001;
    int nextHeight=chainHeadHeight + 24;
    TransactionOutPoint lastOutput=new TransactionOutPoint(params,2,b1001.getTransactions().get(1).getHash());
    int blockCountAfter1001;
    List<Sha256Hash> hashesToSpend=new LinkedList<Sha256Hash>();
    final int TRANSACTION_CREATION_BLOCKS=100;
    for (blockCountAfter1001=0; blockCountAfter1001 < TRANSACTION_CREATION_BLOCKS; blockCountAfter1001++) {
      Block block=createNextBlock(lastBlock,nextHeight++,null,null);
      while (block.getMessageSize() < Block.MAX_BLOCK_SIZE - 500) {
        Transaction tx=new Transaction(params);
        tx.addInput(new TransactionInput(params,tx,new byte[]{OP_TRUE},lastOutput));
        tx.addOutput(new TransactionOutput(params,tx,BigInteger.ZERO,new byte[]{OP_TRUE}));
        tx.addOutput(new TransactionOutput(params,tx,BigInteger.ZERO,new byte[]{OP_TRUE}));
        lastOutput=new TransactionOutPoint(params,1,tx.getHash());
        hashesToSpend.add(tx.getHash());
        block.addTransaction(tx);
      }
      block.solve();
      blocks.add(new BlockAndValidity(blockToHeightMap,block,true,false,block.getHash(),nextHeight - 1,""String_Node_Str"" + blockCountAfter1001 + ""String_Node_Str""+ TRANSACTION_CREATION_BLOCKS));
      lastBlock=block;
    }
    Iterator<Sha256Hash> hashes=hashesToSpend.iterator();
    for (int i=0; hashes.hasNext(); i++) {
      Block block=createNextBlock(lastBlock,nextHeight++,null,null);
      while (block.getMessageSize() < Block.MAX_BLOCK_SIZE - 500 && hashes.hasNext()) {
        Transaction tx=new Transaction(params);
        tx.addInput(new TransactionInput(params,tx,new byte[]{OP_TRUE},new TransactionOutPoint(params,0,hashes.next())));
        tx.addOutput(new TransactionOutput(params,tx,BigInteger.ZERO,new byte[]{OP_TRUE}));
        block.addTransaction(tx);
      }
      block.solve();
      blocks.add(new BlockAndValidity(blockToHeightMap,block,true,false,block.getHash(),nextHeight - 1,""String_Node_Str"" + i));
      lastBlock=block;
      blockCountAfter1001++;
    }
    Sha256Hash firstHash=lastBlock.getHash();
    int height=nextHeight - 1;
    nextHeight=chainHeadHeight + 24;
    lastBlock=b1001;
    for (int i=0; i < blockCountAfter1001; i++) {
      Block block=createNextBlock(lastBlock,nextHeight++,null,null);
      blocks.add(new BlockAndValidity(blockToHeightMap,block,true,false,firstHash,height,""String_Node_Str"" + i + ""String_Node_Str""+ blockCountAfter1001));
      lastBlock=block;
    }
    Block b1002=createNextBlock(lastBlock,nextHeight,null,null);
{
      Transaction tx=new Transaction(params);
      tx.addInput(new TransactionInput(params,tx,new byte[]{OP_TRUE},new TransactionOutPoint(params,0,hashesToSpend.get(0))));
      tx.addOutput(new TransactionOutput(params,tx,BigInteger.ZERO,new byte[]{OP_TRUE}));
      b1002.addTransaction(tx);
    }
    b1002.solve();
    blocks.add(new BlockAndValidity(blockToHeightMap,b1002,false,true,firstHash,height,""String_Node_Str""));
    Block b1003=createNextBlock(lastBlock,nextHeight,null,null);
    blocks.add(new BlockAndValidity(blockToHeightMap,b1003,true,false,b1003.getHash(),nextHeight,""String_Node_Str""));
    Block b1004=createNextBlock(b1003,nextHeight + 1,null,null);
{
      Transaction tx=new Transaction(params);
      tx.addInput(new TransactionInput(params,tx,new byte[]{OP_TRUE},new TransactionOutPoint(params,0,hashesToSpend.get(0))));
      tx.addOutput(new TransactionOutput(params,tx,BigInteger.ZERO,new byte[]{OP_TRUE}));
      b1004.addTransaction(tx);
    }
    b1004.solve();
    blocks.add(new BlockAndValidity(blockToHeightMap,b1004,false,true,b1003.getHash(),nextHeight,""String_Node_Str""));
    ret.maximumReorgBlockCount=Math.max(ret.maximumReorgBlockCount,blockCountAfter1001);
  }
  if (outStream != null)   outStream.close();
  return ret;
}","public BlockAndValidityList getBlocksToTest(boolean addSigExpensiveBlocks,boolean runLargeReorgs,File blockStorageFile) throws ScriptException, ProtocolException, IOException {
  final FileOutputStream outStream=blockStorageFile != null ? new FileOutputStream(blockStorageFile) : null;
  List<BlockAndValidity> blocks=new LinkedList<BlockAndValidity>(){
    @Override public boolean add(    BlockAndValidity element){
      if (outStream != null) {
        try {
          outStream.write((int)(params.packetMagic >>> 24));
          outStream.write((int)(params.packetMagic >>> 16));
          outStream.write((int)(params.packetMagic >>> 8));
          outStream.write((int)(params.packetMagic >>> 0));
          byte[] block=element.block.bitcoinSerialize();
          byte[] length=new byte[4];
          Utils.uint32ToByteArrayBE(block.length,length,0);
          outStream.write(Utils.reverseBytes(length));
          outStream.write(block);
          element.block=null;
        }
 catch (        IOException e) {
          throw new RuntimeException(e);
        }
      }
      return super.add(element);
    }
  }
;
  BlockAndValidityList ret=new BlockAndValidityList(blocks,10);
  Queue<TransactionOutPointWithValue> spendableOutputs=new LinkedList<TransactionOutPointWithValue>();
  int chainHeadHeight=1;
  Block chainHead=params.genesisBlock.createNextBlockWithCoinbase(coinbaseOutKeyPubKey);
  blocks.add(new BlockAndValidity(blockToHeightMap,chainHead,true,false,chainHead.getHash(),1,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,chainHead.getTransactions().get(0).getHash()),Utils.toNanoCoins(50,0),chainHead.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  for (int i=1; i < params.getSpendableCoinbaseDepth(); i++) {
    chainHead=chainHead.createNextBlockWithCoinbase(coinbaseOutKeyPubKey);
    chainHeadHeight++;
    blocks.add(new BlockAndValidity(blockToHeightMap,chainHead,true,false,chainHead.getHash(),i + 1,""String_Node_Str""));
    spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,chainHead.getTransactions().get(0).getHash()),Utils.toNanoCoins(50,0),chainHead.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  }
  Block b1=createNextBlock(chainHead,chainHeadHeight + 1,spendableOutputs.poll(),null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b1,true,false,b1.getHash(),chainHeadHeight + 1,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b1.getTransactions().get(0).getHash()),b1.getTransactions().get(0).getOutputs().get(0).getValue(),b1.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out1=spendableOutputs.poll();
  Preconditions.checkState(out1 != null);
  Block b2=createNextBlock(b1,chainHeadHeight + 2,out1,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b2,true,false,b2.getHash(),chainHeadHeight + 2,""String_Node_Str""));
  blocks.add(new BlockAndValidity(blockToHeightMap,b2,true,false,b2.getHash(),chainHeadHeight + 2,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b2.getTransactions().get(0).getHash()),b2.getTransactions().get(0).getOutputs().get(0).getValue(),b2.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  Block b3=createNextBlock(b1,chainHeadHeight + 2,out1,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b3,true,false,b2.getHash(),chainHeadHeight + 2,""String_Node_Str""));
  blocks.add(new BlockAndValidity(blockToHeightMap,b3,true,false,b2.getHash(),chainHeadHeight + 2,""String_Node_Str""));
  TransactionOutPointWithValue out2=spendableOutputs.poll();
  Preconditions.checkState(out2 != null);
  Block b4=createNextBlock(b3,chainHeadHeight + 3,out2,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b4,true,false,b4.getHash(),chainHeadHeight + 3,""String_Node_Str""));
  Block b5=createNextBlock(b2,chainHeadHeight + 3,out2,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b5,true,false,b4.getHash(),chainHeadHeight + 3,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b5.getTransactions().get(0).getHash()),b5.getTransactions().get(0).getOutputs().get(0).getValue(),b5.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out3=spendableOutputs.poll();
  Block b6=createNextBlock(b5,chainHeadHeight + 4,out3,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b6,true,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  Block b7=createNextBlock(b5,chainHeadHeight + 5,out2,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b7,true,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  TransactionOutPointWithValue out4=spendableOutputs.poll();
  Block b8=createNextBlock(b7,chainHeadHeight + 6,out4,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b8,false,true,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  Block b9=createNextBlock(b6,chainHeadHeight + 5,out4,BigInteger.valueOf(1));
  blocks.add(new BlockAndValidity(blockToHeightMap,b9,false,true,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  Block b10=createNextBlock(b5,chainHeadHeight + 4,out3,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b10,true,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  Block b11=createNextBlock(b10,chainHeadHeight + 5,out4,BigInteger.valueOf(1));
  blocks.add(new BlockAndValidity(blockToHeightMap,b11,false,true,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  Block b12=createNextBlock(b5,chainHeadHeight + 4,out3,null);
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b12.getTransactions().get(0).getHash()),b12.getTransactions().get(0).getOutputs().get(0).getValue(),b12.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  Block b13=createNextBlock(b12,chainHeadHeight + 5,out4,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b13,false,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  blocks.add(new BlockAndValidity(blockToHeightMap,b13,false,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b13.getTransactions().get(0).getHash()),b13.getTransactions().get(0).getOutputs().get(0).getValue(),b13.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out5=spendableOutputs.poll();
  Block b14=createNextBlock(b13,chainHeadHeight + 6,out5,BigInteger.valueOf(1));
  blocks.add(new BlockAndValidity(blockToHeightMap,b14,false,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  blocks.add(new BlockAndValidity(blockToHeightMap,b14,false,false,b6.getHash(),chainHeadHeight + 4,""String_Node_Str""));
  blocks.add(new BlockAndValidity(blockToHeightMap,b12,false,true,b13.getHash(),chainHeadHeight + 5,""String_Node_Str""));
  Block b15=createNextBlock(b13,chainHeadHeight + 6,out5,null);
{
    int sigOps=0;
    for (    Transaction tx : b15.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b15.getTransactions().get(1).getHash()),BigInteger.valueOf(1),b15.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b15.addTransaction(tx);
  }
  b15.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b15,true,false,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b15.getTransactions().get(0).getHash()),b15.getTransactions().get(0).getOutputs().get(0).getValue(),b15.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out6=spendableOutputs.poll();
  Block b16=createNextBlock(b15,chainHeadHeight + 7,out6,null);
{
    int sigOps=0;
    for (    Transaction tx : b16.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + 1];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b16.getTransactions().get(1).getHash()),BigInteger.valueOf(1),b16.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b16.addTransaction(tx);
  }
  b16.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b16,false,true,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  Block b17=createNextBlock(b15,chainHeadHeight + 7,out6,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),new byte[]{}));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b3.getTransactions().get(1).getHash()),BigInteger.valueOf(1),b3.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b17.addTransaction(tx);
  }
  b17.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b17,false,true,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  Block b18=createNextBlock(b13,chainHeadHeight + 6,out5,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),new byte[]{}));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b3.getTransactions().get(1).getHash()),BigInteger.valueOf(1),b3.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b18.addTransaction(tx);
  }
  b18.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b18,true,false,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  Block b19=createNextBlock(b18,chainHeadHeight + 7,out6,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b19,false,true,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  TransactionOutPointWithValue out7=spendableOutputs.poll();
  Block b20=createNextBlock(b15,chainHeadHeight + 7,out7,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b20,false,true,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  Block b21=createNextBlock(b13,chainHeadHeight + 6,out6,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b21,true,false,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  Block b22=createNextBlock(b21,chainHeadHeight + 7,out5,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b22,false,true,b15.getHash(),chainHeadHeight + 6,""String_Node_Str""));
  Block b23=createNextBlock(b15,chainHeadHeight + 7,out6,null);
{
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIZE - b23.getMessageSize() - 138];
    Arrays.fill(outputScript,(byte)OP_FALSE);
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b23.getTransactions().get(1).getHash()),BigInteger.valueOf(1),b23.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b23.addTransaction(tx);
  }
  b23.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b23,true,false,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b23.getTransactions().get(0).getHash()),b23.getTransactions().get(0).getOutputs().get(0).getValue(),b23.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  Block b24=createNextBlock(b15,chainHeadHeight + 7,out6,null);
{
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIZE - b24.getMessageSize() - 135];
    Arrays.fill(outputScript,(byte)OP_FALSE);
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b24.getTransactions().get(1).getHash()),BigInteger.valueOf(1),b24.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b24.addTransaction(tx);
  }
  b24.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b24,false,true,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  Block b25=createNextBlock(b24,chainHeadHeight + 8,out7,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b25,false,false,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  Block b26=createNextBlock(b15,chainHeadHeight + 7,out6,null);
  b26.getTransactions().get(0).getInputs().get(0).setScriptBytes(new byte[]{0});
  b26.setMerkleRoot(null);
  b26.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b26,false,true,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  Block b27=createNextBlock(b26,chainHeadHeight + 8,out7,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b27,false,false,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  Block b28=createNextBlock(b15,chainHeadHeight + 7,out6,null);
{
    byte[] coinbase=new byte[101];
    Arrays.fill(coinbase,(byte)0);
    b28.getTransactions().get(0).getInputs().get(0).setScriptBytes(coinbase);
  }
  b28.setMerkleRoot(null);
  b28.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b28,false,true,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  Block b29=createNextBlock(b28,chainHeadHeight + 8,out7,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b29,false,false,b23.getHash(),chainHeadHeight + 7,""String_Node_Str""));
  Block b30=createNextBlock(b23,chainHeadHeight + 8,out7,null);
{
    byte[] coinbase=new byte[100];
    Arrays.fill(coinbase,(byte)0);
    b30.getTransactions().get(0).getInputs().get(0).setScriptBytes(coinbase);
  }
  b30.setMerkleRoot(null);
  b30.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b30,true,false,b30.getHash(),chainHeadHeight + 8,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b30.getTransactions().get(0).getHash()),b30.getTransactions().get(0).getOutputs().get(0).getValue(),b30.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out8=spendableOutputs.poll();
  Block b31=createNextBlock(b30,chainHeadHeight + 9,out8,null);
{
    int sigOps=0;
    for (    Transaction tx : b31.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[(Block.MAX_BLOCK_SIGOPS - sigOps) / 20];
    Arrays.fill(outputScript,(byte)OP_CHECKMULTISIG);
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b31.getTransactions().get(1).getHash()),BigInteger.valueOf(1),b31.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b31.addTransaction(tx);
  }
  b31.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b31,true,false,b31.getHash(),chainHeadHeight + 9,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b31.getTransactions().get(0).getHash()),b31.getTransactions().get(0).getOutputs().get(0).getValue(),b31.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out9=spendableOutputs.poll();
  Block b32=createNextBlock(b31,chainHeadHeight + 10,out9,null);
{
    int sigOps=0;
    for (    Transaction tx : b32.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[(Block.MAX_BLOCK_SIGOPS - sigOps) / 20 + (Block.MAX_BLOCK_SIGOPS - sigOps) % 20 + 1];
    Arrays.fill(outputScript,(byte)OP_CHECKMULTISIG);
    for (int i=0; i < (Block.MAX_BLOCK_SIGOPS - sigOps) % 20; i++)     outputScript[i]=(byte)OP_CHECKSIG;
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b32.getTransactions().get(1).getHash()),BigInteger.valueOf(1),b32.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b32.addTransaction(tx);
  }
  b32.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b32,false,true,b31.getHash(),chainHeadHeight + 9,""String_Node_Str""));
  Block b33=createNextBlock(b31,chainHeadHeight + 10,out9,null);
{
    int sigOps=0;
    for (    Transaction tx : b33.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[(Block.MAX_BLOCK_SIGOPS - sigOps) / 20];
    Arrays.fill(outputScript,(byte)OP_CHECKMULTISIGVERIFY);
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b33.getTransactions().get(1).getHash()),BigInteger.valueOf(1),b33.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b33.addTransaction(tx);
  }
  b33.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b33,true,false,b33.getHash(),chainHeadHeight + 10,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b33.getTransactions().get(0).getHash()),b33.getTransactions().get(0).getOutputs().get(0).getValue(),b33.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out10=spendableOutputs.poll();
  Block b34=createNextBlock(b33,chainHeadHeight + 11,out10,null);
{
    int sigOps=0;
    for (    Transaction tx : b34.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[(Block.MAX_BLOCK_SIGOPS - sigOps) / 20 + (Block.MAX_BLOCK_SIGOPS - sigOps) % 20 + 1];
    Arrays.fill(outputScript,(byte)OP_CHECKMULTISIGVERIFY);
    for (int i=0; i < (Block.MAX_BLOCK_SIGOPS - sigOps) % 20; i++)     outputScript[i]=(byte)OP_CHECKSIG;
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b34.getTransactions().get(1).getHash()),BigInteger.valueOf(1),b34.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b34.addTransaction(tx);
  }
  b34.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b34,false,true,b33.getHash(),chainHeadHeight + 10,""String_Node_Str""));
  Block b35=createNextBlock(b33,chainHeadHeight + 11,out10,null);
{
    int sigOps=0;
    for (    Transaction tx : b35.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps];
    Arrays.fill(outputScript,(byte)OP_CHECKSIGVERIFY);
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b35.getTransactions().get(1).getHash()),BigInteger.valueOf(1),b35.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b35.addTransaction(tx);
  }
  b35.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b35,true,false,b35.getHash(),chainHeadHeight + 11,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b35.getTransactions().get(0).getHash()),b35.getTransactions().get(0).getOutputs().get(0).getValue(),b35.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out11=spendableOutputs.poll();
  Block b36=createNextBlock(b35,chainHeadHeight + 12,out11,null);
{
    int sigOps=0;
    for (    Transaction tx : b36.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + 1];
    Arrays.fill(outputScript,(byte)OP_CHECKSIGVERIFY);
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b36.getTransactions().get(1).getHash()),BigInteger.valueOf(1),b36.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b36.addTransaction(tx);
  }
  b36.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b36,false,true,b35.getHash(),chainHeadHeight + 11,""String_Node_Str""));
  Block b37=createNextBlock(b35,chainHeadHeight + 12,out11,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),new byte[]{}));
    addOnlyInputToTransaction(tx,out11);
    b37.addTransaction(tx);
  }
  b37.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b37,false,true,b35.getHash(),chainHeadHeight + 11,""String_Node_Str""));
  Block b38=createNextBlock(b35,chainHeadHeight + 12,out11,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),new byte[]{}));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b37.getTransactions().get(1).getHash()),BigInteger.valueOf(1),b37.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b38.addTransaction(tx);
  }
  b38.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b38,false,true,b35.getHash(),chainHeadHeight + 11,""String_Node_Str""));
  byte[] b39p2shScriptPubKey;
  int b39numP2SHOutputs=0, b39sigOpsPerOutput=6;
  Block b39=createNextBlock(b35,chainHeadHeight + 12,null,null);
{
    ByteArrayOutputStream p2shScriptPubKey=new UnsafeByteArrayOutputStream();
    try {
      Script.writeBytes(p2shScriptPubKey,coinbaseOutKeyPubKey);
      p2shScriptPubKey.write(OP_2DUP);
      p2shScriptPubKey.write(OP_CHECKSIGVERIFY);
      p2shScriptPubKey.write(OP_2DUP);
      p2shScriptPubKey.write(OP_CHECKSIGVERIFY);
      p2shScriptPubKey.write(OP_2DUP);
      p2shScriptPubKey.write(OP_CHECKSIGVERIFY);
      p2shScriptPubKey.write(OP_2DUP);
      p2shScriptPubKey.write(OP_CHECKSIGVERIFY);
      p2shScriptPubKey.write(OP_2DUP);
      p2shScriptPubKey.write(OP_CHECKSIGVERIFY);
      p2shScriptPubKey.write(OP_CHECKSIG);
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
    b39p2shScriptPubKey=p2shScriptPubKey.toByteArray();
    byte[] scriptHash=Utils.sha256hash160(b39p2shScriptPubKey);
    UnsafeByteArrayOutputStream scriptPubKey=new UnsafeByteArrayOutputStream(scriptHash.length + 3);
    scriptPubKey.write(OP_HASH160);
    try {
      Script.writeBytes(scriptPubKey,scriptHash);
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
    scriptPubKey.write(OP_EQUAL);
    BigInteger lastOutputValue=out11.value.subtract(BigInteger.valueOf(1));
    TransactionOutPoint lastOutPoint;
{
      Transaction tx=new Transaction(params);
      tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),scriptPubKey.toByteArray()));
      tx.addOutput(new TransactionOutput(params,tx,lastOutputValue,new byte[]{OP_1}));
      addOnlyInputToTransaction(tx,out11);
      lastOutPoint=new TransactionOutPoint(params,1,tx.getHash());
      b39.addTransaction(tx);
    }
    b39numP2SHOutputs++;
    while (b39.getMessageSize() < Block.MAX_BLOCK_SIZE) {
      Transaction tx=new Transaction(params);
      lastOutputValue=lastOutputValue.subtract(BigInteger.valueOf(1));
      tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),scriptPubKey.toByteArray()));
      tx.addOutput(new TransactionOutput(params,tx,lastOutputValue,new byte[]{OP_1}));
      tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},lastOutPoint));
      lastOutPoint=new TransactionOutPoint(params,1,tx.getHash());
      if (b39.getMessageSize() + tx.getMessageSize() < Block.MAX_BLOCK_SIZE) {
        b39.addTransaction(tx);
        b39numP2SHOutputs++;
      }
 else       break;
    }
  }
  b39.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b39,true,false,b39.getHash(),chainHeadHeight + 12,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b39.getTransactions().get(0).getHash()),b39.getTransactions().get(0).getOutputs().get(0).getValue(),b39.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out12=spendableOutputs.poll();
  Block b40=createNextBlock(b39,chainHeadHeight + 13,out12,null);
{
    int sigOps=0;
    for (    Transaction tx : b40.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    int numTxes=(Block.MAX_BLOCK_SIGOPS - sigOps) / b39sigOpsPerOutput;
    Preconditions.checkState(numTxes <= b39numP2SHOutputs);
    TransactionOutPoint lastOutPoint=new TransactionOutPoint(params,2,b40.getTransactions().get(1).getHash());
    byte[] scriptSig=null;
    for (int i=1; i <= numTxes; i++) {
      Transaction tx=new Transaction(params);
      tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),new byte[]{OP_1}));
      tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},lastOutPoint));
      TransactionInput input=new TransactionInput(params,tx,new byte[]{},new TransactionOutPoint(params,0,b39.getTransactions().get(i).getHash()));
      tx.addInput(input);
      if (scriptSig == null) {
        Sha256Hash hash=tx.hashTransactionForSignature(1,b39p2shScriptPubKey,SigHash.SINGLE,false);
        try {
          ByteArrayOutputStream bos=new UnsafeByteArrayOutputStream(73);
          bos.write(coinbaseOutKey.sign(hash).encodeToDER());
          bos.write(SigHash.SINGLE.ordinal() + 1);
          byte[] signature=bos.toByteArray();
          ByteArrayOutputStream scriptSigBos=new UnsafeByteArrayOutputStream(signature.length + b39p2shScriptPubKey.length + 3);
          Script.writeBytes(scriptSigBos,new byte[]{(byte)OP_CHECKSIG});
          scriptSigBos.write(Script.createInputScript(signature));
          Script.writeBytes(scriptSigBos,b39p2shScriptPubKey);
          scriptSig=scriptSigBos.toByteArray();
        }
 catch (        IOException e) {
          throw new RuntimeException(e);
        }
      }
      input.setScriptBytes(scriptSig);
      lastOutPoint=new TransactionOutPoint(params,0,tx.getHash());
      b40.addTransaction(tx);
    }
    sigOps+=numTxes * b39sigOpsPerOutput;
    Transaction tx=new Transaction(params);
    tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},lastOutPoint));
    byte[] scriptPubKey=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + 1];
    Arrays.fill(scriptPubKey,(byte)OP_CHECKSIG);
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.ZERO,scriptPubKey));
    b40.addTransaction(tx);
  }
  b40.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b40,false,true,b39.getHash(),chainHeadHeight + 12,""String_Node_Str""));
  Block b41=null;
  if (addSigExpensiveBlocks) {
    b41=createNextBlock(b39,chainHeadHeight + 13,out12,null);
{
      int sigOps=0;
      for (      Transaction tx : b41.transactions) {
        sigOps+=tx.getSigOpCount();
      }
      int numTxes=(Block.MAX_BLOCK_SIGOPS - sigOps) / b39sigOpsPerOutput;
      Preconditions.checkState(numTxes <= b39numP2SHOutputs);
      TransactionOutPoint lastOutPoint=new TransactionOutPoint(params,2,b41.getTransactions().get(1).getHash());
      byte[] scriptSig=null;
      for (int i=1; i <= numTxes; i++) {
        Transaction tx=new Transaction(params);
        tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),new byte[]{OP_1}));
        tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},lastOutPoint));
        TransactionInput input=new TransactionInput(params,tx,new byte[]{},new TransactionOutPoint(params,0,b39.getTransactions().get(i).getHash()));
        tx.addInput(input);
        if (scriptSig == null) {
          Sha256Hash hash=tx.hashTransactionForSignature(1,b39p2shScriptPubKey,SigHash.SINGLE,false);
          try {
            ByteArrayOutputStream bos=new UnsafeByteArrayOutputStream(73);
            bos.write(coinbaseOutKey.sign(hash).encodeToDER());
            bos.write(SigHash.SINGLE.ordinal() + 1);
            byte[] signature=bos.toByteArray();
            ByteArrayOutputStream scriptSigBos=new UnsafeByteArrayOutputStream(signature.length + b39p2shScriptPubKey.length + 3);
            Script.writeBytes(scriptSigBos,new byte[]{(byte)OP_CHECKSIG});
            scriptSigBos.write(Script.createInputScript(signature));
            Script.writeBytes(scriptSigBos,b39p2shScriptPubKey);
            scriptSig=scriptSigBos.toByteArray();
          }
 catch (          IOException e) {
            throw new RuntimeException(e);
          }
        }
        input.setScriptBytes(scriptSig);
        lastOutPoint=new TransactionOutPoint(params,0,tx.getHash());
        b41.addTransaction(tx);
      }
      sigOps+=numTxes * b39sigOpsPerOutput;
      Transaction tx=new Transaction(params);
      tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},lastOutPoint));
      byte[] scriptPubKey=new byte[Block.MAX_BLOCK_SIGOPS - sigOps];
      Arrays.fill(scriptPubKey,(byte)OP_CHECKSIG);
      tx.addOutput(new TransactionOutput(params,tx,BigInteger.ZERO,scriptPubKey));
      b41.addTransaction(tx);
    }
    b41.solve();
    blocks.add(new BlockAndValidity(blockToHeightMap,b41,true,false,b41.getHash(),chainHeadHeight + 13,""String_Node_Str""));
  }
  Block b42=createNextBlock(b39,chainHeadHeight + 13,out12,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b42,true,false,b41 == null ? b42.getHash() : b41.getHash(),chainHeadHeight + 13,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b42.getTransactions().get(0).getHash()),b42.getTransactions().get(0).getOutputs().get(0).getValue(),b42.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out13=spendableOutputs.poll();
  Block b43=createNextBlock(b42,chainHeadHeight + 14,out13,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b43,true,false,b43.getHash(),chainHeadHeight + 14,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b43.getTransactions().get(0).getHash()),b43.getTransactions().get(0).getOutputs().get(0).getValue(),b43.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out14=spendableOutputs.poll();
  Block b44=new Block(params);
  byte[] outScriptBytes=ScriptBuilder.createOutputScript(new ECKey(null,coinbaseOutKeyPubKey)).getProgram();
{
    b44.setDifficultyTarget(b43.getDifficultyTarget());
    b44.addCoinbaseTransaction(coinbaseOutKeyPubKey,BigInteger.ZERO);
    Transaction t=new Transaction(params);
    t.addOutput(new TransactionOutput(params,t,BigInteger.valueOf(0),new byte[]{OP_PUSHDATA1 - 1}));
    t.addOutput(new TransactionOutput(params,t,BigInteger.valueOf(1),outScriptBytes));
    t.addOutput(new TransactionOutput(params,t,BigInteger.ZERO,new byte[]{OP_1}));
    addOnlyInputToTransaction(t,out14);
    b44.addTransaction(t);
    b44.setPrevBlockHash(b43.getHash());
    b44.setTime(b43.getTimeSeconds() + 1);
  }
  b44.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b44,true,false,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  TransactionOutPointWithValue out15=spendableOutputs.poll();
  Block b45=new Block(params);
{
    b45.setDifficultyTarget(b44.getDifficultyTarget());
    Transaction t=new Transaction(params);
    t.addOutput(new TransactionOutput(params,t,BigInteger.valueOf(0),new byte[]{OP_PUSHDATA1 - 1}));
    t.addOutput(new TransactionOutput(params,t,BigInteger.valueOf(1),outScriptBytes));
    t.addOutput(new TransactionOutput(params,t,BigInteger.ZERO,new byte[]{OP_1}));
    addOnlyInputToTransaction(t,out15);
    try {
      b45.addTransaction(t);
    }
 catch (    RuntimeException e) {
    }
    if (b45.getTransactions().size() > 0)     throw new RuntimeException(""String_Node_Str"");
    b45.addTransaction(t,false);
    b45.setPrevBlockHash(b44.getHash());
    b45.setTime(b44.getTimeSeconds() + 1);
  }
  b45.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b45,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b46=new Block(params);
{
    b46.transactions=new ArrayList<Transaction>();
    b46.setDifficultyTarget(b44.getDifficultyTarget());
    b46.setMerkleRoot(Sha256Hash.ZERO_HASH);
    b46.setPrevBlockHash(b44.getHash());
    b46.setTime(b44.getTimeSeconds() + 1);
  }
  b46.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b46,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b47=createNextBlock(b44,chainHeadHeight + 16,out15,null);
{
    try {
      BigInteger target=b47.getDifficultyTargetAsInteger();
      while (true) {
        BigInteger h=b47.getHash().toBigInteger();
        if (h.compareTo(target) > 0)         break;
        b47.setNonce(b47.getNonce() + 1);
      }
    }
 catch (    VerificationException e) {
      throw new RuntimeException(e);
    }
  }
  blocks.add(new BlockAndValidity(blockToHeightMap,b47,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b48=createNextBlock(b44,chainHeadHeight + 16,out15,null);
  b48.setTime(Utils.now().getTime() / 1000 + 60 * 60 * 3);
  b48.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b48,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b49=createNextBlock(b44,chainHeadHeight + 16,out15,null);
  b49.setMerkleRoot(Sha256Hash.ZERO_HASH);
  b49.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b49,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b50=createNextBlock(b44,chainHeadHeight + 16,out15,null);
{
    long diffTarget=b44.getDifficultyTarget();
    diffTarget&=0xFFBFFFFF;
    b50.setDifficultyTarget(diffTarget);
  }
  b50.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b50,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b51=createNextBlock(b44,chainHeadHeight + 16,out15,null);
{
    Transaction coinbase=new Transaction(params);
    coinbase.addInput(new TransactionInput(params,coinbase,new byte[]{(byte)0xff,110,1}));
    coinbase.addOutput(new TransactionOutput(params,coinbase,BigInteger.ONE,outScriptBytes));
    b51.addTransaction(coinbase,false);
  }
  b51.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b51,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b52=createNextBlock(b44,chainHeadHeight + 16,out15,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),new byte[]{}));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b52.getTransactions().get(1).getHash()),BigInteger.valueOf(1),b52.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b52.addTransaction(tx);
    b52.addTransaction(tx);
  }
  b52.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b52,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b53=createNextBlock(b43,chainHeadHeight + 15,out14,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b53,true,false,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b53.getTransactions().get(0).getHash()),b53.getTransactions().get(0).getOutputs().get(0).getValue(),b53.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  Block b54=createNextBlock(b53,chainHeadHeight + 16,out15,null);
  b54.setTime(b35.getTimeSeconds() - 1);
  b54.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b54,false,true,b44.getHash(),chainHeadHeight + 15,""String_Node_Str""));
  Block b55=createNextBlock(b53,chainHeadHeight + 16,out15,null);
  b55.setTime(b35.getTimeSeconds());
  b55.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b55,true,false,b55.getHash(),chainHeadHeight + 16,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b55.getTransactions().get(0).getHash()),b55.getTransactions().get(0).getOutputs().get(0).getValue(),b55.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out16=spendableOutputs.poll();
  Block b57=createNextBlock(b55,chainHeadHeight + 17,out16,null);
  Transaction b56txToDuplicate;
{
    b56txToDuplicate=new Transaction(params);
    b56txToDuplicate.addOutput(new TransactionOutput(params,b56txToDuplicate,BigInteger.valueOf(1),new byte[]{}));
    addOnlyInputToTransaction(b56txToDuplicate,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b57.getTransactions().get(1).getHash()),BigInteger.valueOf(1),b57.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b57.addTransaction(b56txToDuplicate);
  }
  b57.solve();
  Block b56;
  try {
    b56=new Block(params,b57.bitcoinSerialize());
  }
 catch (  ProtocolException e) {
    throw new RuntimeException(e);
  }
  b56.addTransaction(b56txToDuplicate);
  Preconditions.checkState(b56.getHash().equals(b57.getHash()));
  blocks.add(new BlockAndValidity(blockToHeightMap,b56,false,true,b55.getHash(),chainHeadHeight + 16,""String_Node_Str""));
  blocks.add(new BlockAndValidity(blockToHeightMap,b57,true,false,b57.getHash(),chainHeadHeight + 17,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b57.getTransactions().get(0).getHash()),b57.getTransactions().get(0).getOutputs().get(0).getValue(),b57.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out17=spendableOutputs.poll();
  Block b58=createNextBlock(b57,chainHeadHeight + 18,out17,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.ZERO,new byte[]{}));
    tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},new TransactionOutPoint(params,3,b58.getTransactions().get(1).getHash())));
    b58.addTransaction(tx);
  }
  b58.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b58,false,true,b57.getHash(),chainHeadHeight + 17,""String_Node_Str""));
  Block b59=createNextBlock(b57,chainHeadHeight + 18,out17,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,b59.getTransactions().get(1).getOutputs().get(2).getValue().add(BigInteger.ONE),new byte[]{}));
    tx.addInput(new TransactionInput(params,tx,new byte[]{OP_1},new TransactionOutPoint(params,2,b59.getTransactions().get(1).getHash())));
    b59.addTransaction(tx);
  }
  b59.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b59,false,true,b57.getHash(),chainHeadHeight + 17,""String_Node_Str""));
  Block b60=createNextBlock(b57,chainHeadHeight + 18,out17,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b60,true,false,b60.getHash(),chainHeadHeight + 18,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b60.getTransactions().get(0).getHash()),b60.getTransactions().get(0).getOutputs().get(0).getValue(),b60.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out18=spendableOutputs.poll();
  Block b61=createNextBlock(b60,chainHeadHeight + 19,out18,null);
{
    byte[] scriptBytes=b61.getTransactions().get(0).getInputs().get(0).getScriptBytes();
    scriptBytes[0]--;
    b61.getTransactions().get(0).getInputs().get(0).setScriptBytes(scriptBytes);
    b61.unCache();
    Preconditions.checkState(b61.getTransactions().get(0).equals(b60.getTransactions().get(0)));
  }
  b61.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b61,false,true,b60.getHash(),chainHeadHeight + 18,""String_Node_Str""));
  Block b62=createNextBlock(b60,chainHeadHeight + 19,null,null);
{
    Transaction tx=new Transaction(params);
    tx.setLockTime(0xffffffffL);
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.ZERO,new byte[]{OP_TRUE}));
    addOnlyInputToTransaction(tx,out18,0);
    b62.addTransaction(tx);
    Preconditions.checkState(!tx.isFinal(chainHeadHeight + 17,b62.getTimeSeconds()));
  }
  b62.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b62,false,true,b60.getHash(),chainHeadHeight + 18,""String_Node_Str""));
  Block b63=createNextBlock(b60,chainHeadHeight + 19,null,null);
{
    b63.getTransactions().get(0).setLockTime(0xffffffffL);
    b63.getTransactions().get(0).getInputs().get(0).setSequenceNumber(0xDEADBEEF);
    Preconditions.checkState(!b63.getTransactions().get(0).isFinal(chainHeadHeight + 17,b63.getTimeSeconds()));
  }
  b63.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b63,false,true,b60.getHash(),chainHeadHeight + 18,""String_Node_Str""));
  Block b64;
{
    Block b64Created=createNextBlock(b60,chainHeadHeight + 19,out18,null);
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIZE - b64Created.getMessageSize() - 138];
    Arrays.fill(outputScript,(byte)OP_FALSE);
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b64Created.getTransactions().get(1).getHash()),BigInteger.valueOf(1),b64Created.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b64Created.addTransaction(tx);
    b64Created.solve();
    UnsafeByteArrayOutputStream stream=new UnsafeByteArrayOutputStream(b64Created.getMessageSize() + 8);
    b64Created.writeHeader(stream);
    byte[] varIntBytes=new byte[9];
    varIntBytes[0]=(byte)255;
    Utils.uint32ToByteArrayLE((long)b64Created.getTransactions().size(),varIntBytes,1);
    Utils.uint32ToByteArrayLE(((long)b64Created.getTransactions().size()) >>> 32,varIntBytes,5);
    stream.write(varIntBytes);
    Preconditions.checkState(new VarInt(varIntBytes,0).value == b64Created.getTransactions().size());
    for (    Transaction transaction : b64Created.getTransactions())     transaction.bitcoinSerialize(stream);
    b64=new Block(params,stream.toByteArray(),false,true,stream.size());
    Preconditions.checkState(stream.size() == b64Created.getMessageSize() + 8);
    Preconditions.checkState(stream.size() == b64.getMessageSize());
    Preconditions.checkState(Arrays.equals(stream.toByteArray(),b64.bitcoinSerialize()));
    Preconditions.checkState(b64.getOptimalEncodingMessageSize() == b64Created.getMessageSize());
  }
  blocks.add(new BlockAndValidity(blockToHeightMap,b64,true,false,b64.getHash(),chainHeadHeight + 19,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b64.getTransactions().get(0).getHash()),b64.getTransactions().get(0).getOutputs().get(0).getValue(),b64.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out19=spendableOutputs.poll();
  Preconditions.checkState(out19 != null);
  Block b65=createNextBlock(b64,chainHeadHeight + 20,null,null);
{
    Transaction tx1=new Transaction(params);
    tx1.addOutput(new TransactionOutput(params,tx1,out19.value,new byte[]{OP_TRUE}));
    addOnlyInputToTransaction(tx1,out19,0);
    b65.addTransaction(tx1);
    Transaction tx2=new Transaction(params);
    tx2.addOutput(new TransactionOutput(params,tx2,BigInteger.ZERO,new byte[]{OP_TRUE}));
    tx2.addInput(new TransactionInput(params,tx2,new byte[]{OP_TRUE},new TransactionOutPoint(params,0,tx1.getHash())));
    b65.addTransaction(tx2);
  }
  b65.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b65,true,false,b65.getHash(),chainHeadHeight + 20,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b65.getTransactions().get(0).getHash()),b65.getTransactions().get(0).getOutputs().get(0).getValue(),b65.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out20=spendableOutputs.poll();
  Preconditions.checkState(out20 != null);
  Block b66=createNextBlock(b65,chainHeadHeight + 21,null,null);
{
    Transaction tx1=new Transaction(params);
    tx1.addOutput(new TransactionOutput(params,tx1,out20.value,new byte[]{OP_TRUE}));
    addOnlyInputToTransaction(tx1,out20,0);
    Transaction tx2=new Transaction(params);
    tx2.addOutput(new TransactionOutput(params,tx2,BigInteger.ZERO,new byte[]{OP_TRUE}));
    tx2.addInput(new TransactionInput(params,tx2,new byte[]{OP_TRUE},new TransactionOutPoint(params,0,tx1.getHash())));
    b66.addTransaction(tx2);
    b66.addTransaction(tx1);
  }
  b66.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b66,false,true,b65.getHash(),chainHeadHeight + 20,""String_Node_Str""));
  Block b67=createNextBlock(b65,chainHeadHeight + 21,null,null);
{
    Transaction tx1=new Transaction(params);
    tx1.addOutput(new TransactionOutput(params,tx1,out20.value,new byte[]{OP_TRUE}));
    addOnlyInputToTransaction(tx1,out20,0);
    b67.addTransaction(tx1);
    Transaction tx2=new Transaction(params);
    tx2.addOutput(new TransactionOutput(params,tx2,BigInteger.ZERO,new byte[]{OP_TRUE}));
    tx2.addInput(new TransactionInput(params,tx2,new byte[]{OP_TRUE},new TransactionOutPoint(params,0,tx1.getHash())));
    b67.addTransaction(tx2);
    Transaction tx3=new Transaction(params);
    tx3.addOutput(new TransactionOutput(params,tx3,out20.value,new byte[]{OP_TRUE}));
    tx3.addInput(new TransactionInput(params,tx3,new byte[]{OP_TRUE},new TransactionOutPoint(params,0,tx1.getHash())));
    b67.addTransaction(tx3);
  }
  b67.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b67,false,true,b65.getHash(),chainHeadHeight + 20,""String_Node_Str""));
  Block b68=createNextBlock(b65,chainHeadHeight + 21,null,BigInteger.TEN);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,out20.value.subtract(BigInteger.valueOf(9)),new byte[]{OP_TRUE}));
    addOnlyInputToTransaction(tx,out20,0);
    b68.addTransaction(tx);
  }
  b68.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b68,false,true,b65.getHash(),chainHeadHeight + 20,""String_Node_Str""));
  Block b69=createNextBlock(b65,chainHeadHeight + 21,null,BigInteger.TEN);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,out20.value.subtract(BigInteger.TEN),new byte[]{OP_TRUE}));
    addOnlyInputToTransaction(tx,out20,0);
    b69.addTransaction(tx);
  }
  b69.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b69,true,false,b69.getHash(),chainHeadHeight + 21,""String_Node_Str""));
  TransactionOutPointWithValue out21=spendableOutputs.poll();
  Preconditions.checkState(out21 != null);
  Block b70=createNextBlock(b69,chainHeadHeight + 22,out21,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.ZERO,new byte[]{OP_TRUE}));
    tx.addInput(new TransactionInput(params,tx,new byte[]{OP_TRUE},new TransactionOutPoint(params,0,new Sha256Hash(""String_Node_Str""))));
    b70.addTransaction(tx);
  }
  b70.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b70,false,true,b69.getHash(),chainHeadHeight + 21,""String_Node_Str""));
  Block b72=createNextBlock(b69,chainHeadHeight + 22,out21,null);
{
    Transaction tx=new Transaction(params);
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.ZERO,new byte[]{OP_TRUE}));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b72.getTransactions().get(1).getHash()),BigInteger.valueOf(1),b72.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b72.addTransaction(tx);
  }
  b72.solve();
  Block b71=new Block(params,b72.bitcoinSerialize());
  b71.addTransaction(b72.getTransactions().get(2));
  Preconditions.checkState(b71.getHash().equals(b72.getHash()));
  blocks.add(new BlockAndValidity(blockToHeightMap,b71,false,true,b69.getHash(),chainHeadHeight + 21,""String_Node_Str""));
  blocks.add(new BlockAndValidity(blockToHeightMap,b72,true,false,b72.getHash(),chainHeadHeight + 22,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b72.getTransactions().get(0).getHash()),b72.getTransactions().get(0).getOutputs().get(0).getValue(),b72.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out22=spendableOutputs.poll();
  Preconditions.checkState(out22 != null);
  Block b73=createNextBlock(b72,chainHeadHeight + 23,out22,null);
{
    int sigOps=0;
    for (    Transaction tx : b73.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + (int)Script.MAX_SCRIPT_ELEMENT_SIZE + 1 + 5 + 1];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps]=OP_PUSHDATA4;
    Utils.uint32ToByteArrayLE(Script.MAX_SCRIPT_ELEMENT_SIZE + 1,outputScript,Block.MAX_BLOCK_SIGOPS - sigOps + 1);
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b73.getTransactions().get(1).getHash()),BigInteger.valueOf(1),b73.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b73.addTransaction(tx);
  }
  b73.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b73,false,true,b72.getHash(),chainHeadHeight + 22,""String_Node_Str""));
  Block b74=createNextBlock(b72,chainHeadHeight + 23,out22,null);
{
    int sigOps=0;
    for (    Transaction tx : b74.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + (int)Script.MAX_SCRIPT_ELEMENT_SIZE + 42];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 1]=OP_PUSHDATA4;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 2]=(byte)0xfe;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 3]=(byte)0xff;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 4]=(byte)0xff;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 5]=(byte)0xff;
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b74.getTransactions().get(1).getHash()),BigInteger.valueOf(1),b74.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b74.addTransaction(tx);
  }
  b74.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b74,false,true,b72.getHash(),chainHeadHeight + 22,""String_Node_Str""));
  Block b75=createNextBlock(b72,chainHeadHeight + 23,out22,null);
{
    int sigOps=0;
    for (    Transaction tx : b75.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + (int)Script.MAX_SCRIPT_ELEMENT_SIZE + 42];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps]=OP_PUSHDATA4;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 1]=(byte)0xff;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 2]=(byte)0xff;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 3]=(byte)0xff;
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps + 4]=(byte)0xff;
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b75.getTransactions().get(1).getHash()),BigInteger.valueOf(1),b75.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b75.addTransaction(tx);
  }
  b75.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b75,true,false,b75.getHash(),chainHeadHeight + 23,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b75.getTransactions().get(0).getHash()),b75.getTransactions().get(0).getOutputs().get(0).getValue(),b75.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out23=spendableOutputs.poll();
  Preconditions.checkState(out23 != null);
  Block b76=createNextBlock(b75,chainHeadHeight + 24,out23,null);
{
    int sigOps=0;
    for (    Transaction tx : b76.transactions) {
      sigOps+=tx.getSigOpCount();
    }
    Transaction tx=new Transaction(params);
    byte[] outputScript=new byte[Block.MAX_BLOCK_SIGOPS - sigOps + (int)Script.MAX_SCRIPT_ELEMENT_SIZE + 1 + 5];
    Arrays.fill(outputScript,(byte)OP_CHECKSIG);
    outputScript[Block.MAX_BLOCK_SIGOPS - sigOps]=OP_PUSHDATA4;
    Utils.uint32ToByteArrayLE(Block.MAX_BLOCK_SIGOPS,outputScript,Block.MAX_BLOCK_SIGOPS - sigOps + 1);
    tx.addOutput(new TransactionOutput(params,tx,BigInteger.valueOf(1),outputScript));
    addOnlyInputToTransaction(tx,new TransactionOutPointWithValue(new TransactionOutPoint(params,1,b76.getTransactions().get(1).getHash()),BigInteger.valueOf(1),b76.getTransactions().get(1).getOutputs().get(1).getScriptPubKey()));
    b76.addTransaction(tx);
  }
  b76.solve();
  blocks.add(new BlockAndValidity(blockToHeightMap,b76,true,false,b76.getHash(),chainHeadHeight + 24,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b76.getTransactions().get(0).getHash()),b76.getTransactions().get(0).getOutputs().get(0).getValue(),b76.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  TransactionOutPointWithValue out24=spendableOutputs.poll();
  Preconditions.checkState(out24 != null);
  Block b1001=createNextBlock(b76,chainHeadHeight + 25,out24,null);
  blocks.add(new BlockAndValidity(blockToHeightMap,b1001,true,false,b1001.getHash(),chainHeadHeight + 25,""String_Node_Str""));
  spendableOutputs.offer(new TransactionOutPointWithValue(new TransactionOutPoint(params,0,b1001.getTransactions().get(0).getHash()),b1001.getTransactions().get(0).getOutputs().get(0).getValue(),b1001.getTransactions().get(0).getOutputs().get(0).getScriptPubKey()));
  if (runLargeReorgs) {
    Preconditions.checkArgument(blockStorageFile != null);
    Block lastBlock=b1001;
    int nextHeight=chainHeadHeight + 26;
    TransactionOutPoint lastOutput=new TransactionOutPoint(params,2,b1001.getTransactions().get(1).getHash());
    int blockCountAfter1001;
    List<Sha256Hash> hashesToSpend=new LinkedList<Sha256Hash>();
    final int TRANSACTION_CREATION_BLOCKS=100;
    for (blockCountAfter1001=0; blockCountAfter1001 < TRANSACTION_CREATION_BLOCKS; blockCountAfter1001++) {
      Block block=createNextBlock(lastBlock,nextHeight++,null,null);
      while (block.getMessageSize() < Block.MAX_BLOCK_SIZE - 500) {
        Transaction tx=new Transaction(params);
        tx.addInput(new TransactionInput(params,tx,new byte[]{OP_TRUE},lastOutput));
        tx.addOutput(new TransactionOutput(params,tx,BigInteger.ZERO,new byte[]{OP_TRUE}));
        tx.addOutput(new TransactionOutput(params,tx,BigInteger.ZERO,new byte[]{OP_TRUE}));
        lastOutput=new TransactionOutPoint(params,1,tx.getHash());
        hashesToSpend.add(tx.getHash());
        block.addTransaction(tx);
      }
      block.solve();
      blocks.add(new BlockAndValidity(blockToHeightMap,block,true,false,block.getHash(),nextHeight - 1,""String_Node_Str"" + blockCountAfter1001 + ""String_Node_Str""+ TRANSACTION_CREATION_BLOCKS));
      lastBlock=block;
    }
    Iterator<Sha256Hash> hashes=hashesToSpend.iterator();
    for (int i=0; hashes.hasNext(); i++) {
      Block block=createNextBlock(lastBlock,nextHeight++,null,null);
      while (block.getMessageSize() < Block.MAX_BLOCK_SIZE - 500 && hashes.hasNext()) {
        Transaction tx=new Transaction(params);
        tx.addInput(new TransactionInput(params,tx,new byte[]{OP_TRUE},new TransactionOutPoint(params,0,hashes.next())));
        tx.addOutput(new TransactionOutput(params,tx,BigInteger.ZERO,new byte[]{OP_TRUE}));
        block.addTransaction(tx);
      }
      block.solve();
      blocks.add(new BlockAndValidity(blockToHeightMap,block,true,false,block.getHash(),nextHeight - 1,""String_Node_Str"" + i));
      lastBlock=block;
      blockCountAfter1001++;
    }
    Sha256Hash firstHash=lastBlock.getHash();
    int height=nextHeight - 1;
    nextHeight=chainHeadHeight + 26;
    lastBlock=b1001;
    for (int i=0; i < blockCountAfter1001; i++) {
      Block block=createNextBlock(lastBlock,nextHeight++,null,null);
      blocks.add(new BlockAndValidity(blockToHeightMap,block,true,false,firstHash,height,""String_Node_Str"" + i + ""String_Node_Str""+ blockCountAfter1001));
      lastBlock=block;
    }
    Block b1002=createNextBlock(lastBlock,nextHeight,null,null);
{
      Transaction tx=new Transaction(params);
      tx.addInput(new TransactionInput(params,tx,new byte[]{OP_TRUE},new TransactionOutPoint(params,0,hashesToSpend.get(0))));
      tx.addOutput(new TransactionOutput(params,tx,BigInteger.ZERO,new byte[]{OP_TRUE}));
      b1002.addTransaction(tx);
    }
    b1002.solve();
    blocks.add(new BlockAndValidity(blockToHeightMap,b1002,false,true,firstHash,height,""String_Node_Str""));
    Block b1003=createNextBlock(lastBlock,nextHeight,null,null);
    blocks.add(new BlockAndValidity(blockToHeightMap,b1003,true,false,b1003.getHash(),nextHeight,""String_Node_Str""));
    Block b1004=createNextBlock(b1003,nextHeight + 1,null,null);
{
      Transaction tx=new Transaction(params);
      tx.addInput(new TransactionInput(params,tx,new byte[]{OP_TRUE},new TransactionOutPoint(params,0,hashesToSpend.get(0))));
      tx.addOutput(new TransactionOutput(params,tx,BigInteger.ZERO,new byte[]{OP_TRUE}));
      b1004.addTransaction(tx);
    }
    b1004.solve();
    blocks.add(new BlockAndValidity(blockToHeightMap,b1004,false,true,b1003.getHash(),nextHeight,""String_Node_Str""));
    ret.maximumReorgBlockCount=Math.max(ret.maximumReorgBlockCount,blockCountAfter1001);
  }
  if (outStream != null)   outStream.close();
  return ret;
}",0.952978951123796
85813,"private ListenableFuture<Object> downloadDependenciesInternal(final Transaction tx,final Object marker,final List<Transaction> results){
  final SettableFuture<Object> resultFuture=SettableFuture.create();
  final Sha256Hash rootTxHash=tx.getHash();
  Set<Transaction> dependencies=new CopyOnWriteArraySet<Transaction>();
  Set<Sha256Hash> needToRequest=new CopyOnWriteArraySet<Sha256Hash>();
  for (  TransactionInput input : tx.getInputs()) {
    Sha256Hash hash=input.getOutpoint().getHash();
    Transaction dep=memoryPool.get(hash);
    if (dep == null) {
      needToRequest.add(hash);
    }
 else {
      dependencies.add(dep);
    }
  }
  results.addAll(dependencies);
  lock.lock();
  try {
    List<ListenableFuture<Transaction>> futures=Lists.newArrayList();
    GetDataMessage getdata=new GetDataMessage(params);
    final long nonce=(long)(Math.random() * Long.MAX_VALUE);
    if (needToRequest.size() > 1)     log.info(""String_Node_Str"",needToRequest.size());
    for (    Sha256Hash hash : needToRequest) {
      getdata.addTransaction(hash);
      GetDataRequest req=new GetDataRequest();
      req.hash=hash;
      req.future=SettableFuture.create();
      if (!isNotFoundMessageSupported()) {
        req.nonce=nonce;
      }
      futures.add(req.future);
      getDataFutures.add(req);
    }
    for (    Transaction dep : dependencies) {
      futures.add(Futures.immediateFuture(dep));
    }
    ListenableFuture<List<Transaction>> successful=Futures.successfulAsList(futures);
    Futures.addCallback(successful,new FutureCallback<List<Transaction>>(){
      public void onSuccess(      List<Transaction> transactions){
        List<ListenableFuture<Object>> childFutures=Lists.newLinkedList();
        for (        Transaction tx : transactions) {
          if (tx == null)           continue;
          log.info(""String_Node_Str"",new Object[]{vAddress,rootTxHash,tx.getHashAsString()});
          results.add(tx);
          childFutures.add(downloadDependenciesInternal(tx,marker,results));
        }
        if (childFutures.size() == 0) {
          resultFuture.set(marker);
        }
 else {
          Futures.addCallback(Futures.successfulAsList(childFutures),new FutureCallback<List<Object>>(){
            public void onSuccess(            List<Object> objects){
              resultFuture.set(marker);
            }
            public void onFailure(            Throwable throwable){
              resultFuture.setException(throwable);
            }
          }
);
        }
      }
      public void onFailure(      Throwable throwable){
        resultFuture.setException(throwable);
      }
    }
);
    sendMessage(getdata);
    if (!isNotFoundMessageSupported()) {
      log.info(""String_Node_Str"",this,nonce);
      ping(nonce).addListener(new Runnable(){
        public void run(){
          for (          GetDataRequest req : getDataFutures) {
            if (req.nonce == nonce) {
              log.info(""String_Node_Str"",this,req.hash);
              req.future.cancel(true);
              getDataFutures.remove(req);
            }
          }
        }
      }
,MoreExecutors.sameThreadExecutor());
    }
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",this,tx.getHash());
    resultFuture.setException(e);
    return resultFuture;
  }
 finally {
    lock.unlock();
  }
  return resultFuture;
}","private ListenableFuture<Object> downloadDependenciesInternal(final Transaction tx,final Object marker,final List<Transaction> results){
  final SettableFuture<Object> resultFuture=SettableFuture.create();
  final Sha256Hash rootTxHash=tx.getHash();
  Set<Transaction> dependencies=new CopyOnWriteArraySet<Transaction>();
  Set<Sha256Hash> needToRequest=new CopyOnWriteArraySet<Sha256Hash>();
  for (  TransactionInput input : tx.getInputs()) {
    Sha256Hash hash=input.getOutpoint().getHash();
    Transaction dep=memoryPool.get(hash);
    if (dep == null) {
      needToRequest.add(hash);
    }
 else {
      dependencies.add(dep);
    }
  }
  results.addAll(dependencies);
  lock.lock();
  try {
    List<ListenableFuture<Transaction>> futures=Lists.newArrayList();
    GetDataMessage getdata=new GetDataMessage(params);
    final long nonce=(long)(Math.random() * Long.MAX_VALUE);
    if (needToRequest.size() > 1)     log.info(""String_Node_Str"",vAddress,needToRequest.size());
    for (    Sha256Hash hash : needToRequest) {
      getdata.addTransaction(hash);
      GetDataRequest req=new GetDataRequest();
      req.hash=hash;
      req.future=SettableFuture.create();
      if (!isNotFoundMessageSupported()) {
        req.nonce=nonce;
      }
      futures.add(req.future);
      getDataFutures.add(req);
    }
    for (    Transaction dep : dependencies) {
      futures.add(Futures.immediateFuture(dep));
    }
    ListenableFuture<List<Transaction>> successful=Futures.successfulAsList(futures);
    Futures.addCallback(successful,new FutureCallback<List<Transaction>>(){
      public void onSuccess(      List<Transaction> transactions){
        List<ListenableFuture<Object>> childFutures=Lists.newLinkedList();
        for (        Transaction tx : transactions) {
          if (tx == null)           continue;
          log.info(""String_Node_Str"",new Object[]{vAddress,rootTxHash,tx.getHashAsString()});
          results.add(tx);
          childFutures.add(downloadDependenciesInternal(tx,marker,results));
        }
        if (childFutures.size() == 0) {
          resultFuture.set(marker);
        }
 else {
          Futures.addCallback(Futures.successfulAsList(childFutures),new FutureCallback<List<Object>>(){
            public void onSuccess(            List<Object> objects){
              resultFuture.set(marker);
            }
            public void onFailure(            Throwable throwable){
              resultFuture.setException(throwable);
            }
          }
);
        }
      }
      public void onFailure(      Throwable throwable){
        resultFuture.setException(throwable);
      }
    }
);
    sendMessage(getdata);
    if (!isNotFoundMessageSupported()) {
      log.info(""String_Node_Str"",this,nonce);
      ping(nonce).addListener(new Runnable(){
        public void run(){
          for (          GetDataRequest req : getDataFutures) {
            if (req.nonce == nonce) {
              log.info(""String_Node_Str"",this,req.hash);
              req.future.cancel(true);
              getDataFutures.remove(req);
            }
          }
        }
      }
,MoreExecutors.sameThreadExecutor());
    }
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",this,tx.getHash());
    resultFuture.setException(e);
    return resultFuture;
  }
 finally {
    lock.unlock();
  }
  return resultFuture;
}",0.9986585184081084
85814,"/** 
 * Verifies that this script (interpreted as a scriptSig) correctly spends the given scriptPubKey.
 * @param txContainingThis The transaction in which this input scriptSig resides.Accessing txContainingThis from another thread while this method runs results in undefined behavior.
 * @param scriptSigIndex The index in txContainingThis of the scriptSig (note: NOT the index of the scriptPubKey).
 * @param scriptPubKey The connected scriptPubKey containing the conditions needed to claim the value.
 * @param enforceP2SH Whether ""pay to script hash"" rules should be enforced. If in doubt, set to true.
 */
public void correctlySpends(Transaction txContainingThis,long scriptSigIndex,Script scriptPubKey,boolean enforceP2SH) throws ScriptException {
  if (getProgram().length > 10000 || scriptPubKey.getProgram().length > 10000)   throw new ScriptException(""String_Node_Str"");
  LinkedList<byte[]> stack=new LinkedList<byte[]>();
  LinkedList<byte[]> p2shStack=null;
  executeScript(txContainingThis,scriptSigIndex,this,stack);
  if (enforceP2SH)   p2shStack=new LinkedList<byte[]>(stack);
  executeScript(txContainingThis,scriptSigIndex,scriptPubKey,stack);
  if (stack.size() == 0)   throw new ScriptException(""String_Node_Str"");
  if (!castToBool(stack.pollLast()))   throw new ScriptException(""String_Node_Str"");
  if (enforceP2SH && scriptPubKey.isPayToScriptHash()) {
    for (    ScriptChunk chunk : chunks)     if (chunk.isOpCode() && (chunk.data[0] & 0xff) > OP_16)     throw new ScriptException(""String_Node_Str"");
    byte[] scriptPubKeyBytes=p2shStack.pollLast();
    Script scriptPubKeyP2SH=new Script(scriptPubKeyBytes);
    executeScript(txContainingThis,scriptSigIndex,scriptPubKeyP2SH,p2shStack);
    if (p2shStack.size() == 0)     throw new ScriptException(""String_Node_Str"");
    if (!castToBool(p2shStack.pollLast()))     throw new ScriptException(""String_Node_Str"");
  }
}","/** 
 * Verifies that this script (interpreted as a scriptSig) correctly spends the given scriptPubKey.
 * @param txContainingThis The transaction in which this input scriptSig resides.Accessing txContainingThis from another thread while this method runs results in undefined behavior.
 * @param scriptSigIndex The index in txContainingThis of the scriptSig (note: NOT the index of the scriptPubKey).
 * @param scriptPubKey The connected scriptPubKey containing the conditions needed to claim the value.
 * @param enforceP2SH Whether ""pay to script hash"" rules should be enforced. If in doubt, set to true.
 */
public void correctlySpends(Transaction txContainingThis,long scriptSigIndex,Script scriptPubKey,boolean enforceP2SH) throws ScriptException {
  if (getProgram().length > 10000 || scriptPubKey.getProgram().length > 10000)   throw new ScriptException(""String_Node_Str"");
  LinkedList<byte[]> stack=new LinkedList<byte[]>();
  LinkedList<byte[]> p2shStack=null;
  executeScript(txContainingThis,scriptSigIndex,this,stack);
  if (enforceP2SH)   p2shStack=new LinkedList<byte[]>(stack);
  executeScript(txContainingThis,scriptSigIndex,scriptPubKey,stack);
  if (stack.size() == 0)   throw new ScriptException(""String_Node_Str"");
  if (!castToBool(stack.pollLast()))   throw new ScriptException(""String_Node_Str"" + stack);
  if (enforceP2SH && scriptPubKey.isPayToScriptHash()) {
    for (    ScriptChunk chunk : chunks)     if (chunk.isOpCode() && (chunk.data[0] & 0xff) > OP_16)     throw new ScriptException(""String_Node_Str"");
    byte[] scriptPubKeyBytes=p2shStack.pollLast();
    Script scriptPubKeyP2SH=new Script(scriptPubKeyBytes);
    executeScript(txContainingThis,scriptSigIndex,scriptPubKeyP2SH,p2shStack);
    if (p2shStack.size() == 0)     throw new ScriptException(""String_Node_Str"");
    if (!castToBool(p2shStack.pollLast()))     throw new ScriptException(""String_Node_Str"");
  }
}",0.9978958442924776
85815,"private static void executeScript(Transaction txContainingThis,long index,Script script,LinkedList<byte[]> stack) throws ScriptException {
  int opCount=0;
  int lastCodeSepLocation=0;
  LinkedList<byte[]> altstack=new LinkedList<byte[]>();
  LinkedList<Boolean> ifStack=new LinkedList<Boolean>();
  for (  ScriptChunk chunk : script.chunks) {
    boolean shouldExecute=!ifStack.contains(false);
    if (!chunk.isOpCode()) {
      if (!shouldExecute)       continue;
      stack.add(chunk.data);
    }
 else {
      int opcode=0xFF & chunk.data[0];
      if (opcode > OP_16) {
        opCount++;
        if (opCount > 201)         throw new ScriptException(""String_Node_Str"");
      }
      if (opcode == OP_VERIF || opcode == OP_VERNOTIF)       throw new ScriptException(""String_Node_Str"");
      if (opcode == OP_CAT || opcode == OP_SUBSTR || opcode == OP_LEFT || opcode == OP_RIGHT || opcode == OP_INVERT || opcode == OP_AND || opcode == OP_OR || opcode == OP_XOR || opcode == OP_2MUL || opcode == OP_2DIV || opcode == OP_MUL || opcode == OP_DIV || opcode == OP_MOD || opcode == OP_LSHIFT || opcode == OP_RSHIFT)       throw new ScriptException(""String_Node_Str"");
switch (opcode) {
case OP_IF:
        if (!shouldExecute) {
          ifStack.add(false);
          continue;
        }
      if (stack.size() < 1)       throw new ScriptException(""String_Node_Str"");
    ifStack.add(castToBool(stack.pollLast()));
  continue;
case OP_NOTIF:
if (!shouldExecute) {
  ifStack.add(false);
  continue;
}
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
ifStack.add(!castToBool(stack.pollLast()));
continue;
case OP_ELSE:
if (ifStack.isEmpty()) throw new ScriptException(""String_Node_Str"");
ifStack.add(!ifStack.pollLast());
continue;
case OP_ENDIF:
if (ifStack.isEmpty()) throw new ScriptException(""String_Node_Str"");
ifStack.pollLast();
continue;
}
if (!shouldExecute) continue;
switch (opcode) {
case OP_1NEGATE:
stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.ONE.negate(),false)));
break;
case OP_1:
case OP_2:
case OP_3:
case OP_4:
case OP_5:
case OP_6:
case OP_7:
case OP_8:
case OP_9:
case OP_10:
case OP_11:
case OP_12:
case OP_13:
case OP_14:
case OP_15:
case OP_16:
stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.valueOf(decodeFromOpN(opcode)),false)));
break;
case OP_NOP:
break;
case OP_VERIFY:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
if (!castToBool(stack.pollLast())) throw new ScriptException(""String_Node_Str"");
break;
case OP_RETURN:
throw new ScriptException(""String_Node_Str"");
case OP_TOALTSTACK:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
altstack.add(stack.pollLast());
break;
case OP_FROMALTSTACK:
if (altstack.size() < 1) throw new ScriptException(""String_Node_Str"");
stack.add(altstack.pollLast());
break;
case OP_2DROP:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
stack.pollLast();
stack.pollLast();
break;
case OP_2DUP:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
Iterator<byte[]> it2DUP=stack.descendingIterator();
byte[] OP2DUPtmpChunk2=it2DUP.next();
stack.add(it2DUP.next());
stack.add(OP2DUPtmpChunk2);
break;
case OP_3DUP:
if (stack.size() < 3) throw new ScriptException(""String_Node_Str"");
Iterator<byte[]> it3DUP=stack.descendingIterator();
byte[] OP3DUPtmpChunk3=it3DUP.next();
byte[] OP3DUPtmpChunk2=it3DUP.next();
stack.add(it3DUP.next());
stack.add(OP3DUPtmpChunk2);
stack.add(OP3DUPtmpChunk3);
break;
case OP_2OVER:
if (stack.size() < 4) throw new ScriptException(""String_Node_Str"");
Iterator<byte[]> it2OVER=stack.descendingIterator();
it2OVER.next();
it2OVER.next();
byte[] OP2OVERtmpChunk2=it2OVER.next();
stack.add(it2OVER.next());
stack.add(OP2OVERtmpChunk2);
break;
case OP_2ROT:
if (stack.size() < 6) throw new ScriptException(""String_Node_Str"");
byte[] OP2ROTtmpChunk6=stack.pollLast();
byte[] OP2ROTtmpChunk5=stack.pollLast();
byte[] OP2ROTtmpChunk4=stack.pollLast();
byte[] OP2ROTtmpChunk3=stack.pollLast();
byte[] OP2ROTtmpChunk2=stack.pollLast();
byte[] OP2ROTtmpChunk1=stack.pollLast();
stack.add(OP2ROTtmpChunk3);
stack.add(OP2ROTtmpChunk4);
stack.add(OP2ROTtmpChunk5);
stack.add(OP2ROTtmpChunk6);
stack.add(OP2ROTtmpChunk1);
stack.add(OP2ROTtmpChunk2);
break;
case OP_2SWAP:
if (stack.size() < 4) throw new ScriptException(""String_Node_Str"");
byte[] OP2SWAPtmpChunk4=stack.pollLast();
byte[] OP2SWAPtmpChunk3=stack.pollLast();
byte[] OP2SWAPtmpChunk2=stack.pollLast();
byte[] OP2SWAPtmpChunk1=stack.pollLast();
stack.add(OP2SWAPtmpChunk3);
stack.add(OP2SWAPtmpChunk4);
stack.add(OP2SWAPtmpChunk1);
stack.add(OP2SWAPtmpChunk2);
break;
case OP_IFDUP:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
if (castToBool(stack.getLast())) stack.add(stack.getLast());
break;
case OP_DEPTH:
stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.valueOf(stack.size()),false)));
break;
case OP_DROP:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
stack.pollLast();
break;
case OP_DUP:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
stack.add(stack.getLast());
break;
case OP_NIP:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
byte[] OPNIPtmpChunk=stack.pollLast();
stack.pollLast();
stack.add(OPNIPtmpChunk);
break;
case OP_OVER:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
Iterator<byte[]> itOVER=stack.descendingIterator();
itOVER.next();
stack.add(itOVER.next());
break;
case OP_PICK:
case OP_ROLL:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
long val=castToBigInteger(stack.pollLast()).longValue();
if (val < 0 || val >= stack.size()) throw new ScriptException(""String_Node_Str"");
Iterator<byte[]> itPICK=stack.descendingIterator();
for (long i=0; i < val; i++) itPICK.next();
byte[] OPROLLtmpChunk=itPICK.next();
if (opcode == OP_ROLL) itPICK.remove();
stack.add(OPROLLtmpChunk);
break;
case OP_ROT:
if (stack.size() < 3) throw new ScriptException(""String_Node_Str"");
byte[] OPROTtmpChunk3=stack.pollLast();
byte[] OPROTtmpChunk2=stack.pollLast();
byte[] OPROTtmpChunk1=stack.pollLast();
stack.add(OPROTtmpChunk2);
stack.add(OPROTtmpChunk3);
stack.add(OPROTtmpChunk1);
break;
case OP_SWAP:
case OP_TUCK:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
byte[] OPSWAPtmpChunk2=stack.pollLast();
byte[] OPSWAPtmpChunk1=stack.pollLast();
stack.add(OPSWAPtmpChunk2);
stack.add(OPSWAPtmpChunk1);
if (opcode == OP_TUCK) stack.add(OPSWAPtmpChunk2);
break;
case OP_CAT:
case OP_SUBSTR:
case OP_LEFT:
case OP_RIGHT:
throw new ScriptException(""String_Node_Str"");
case OP_SIZE:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.valueOf(stack.getLast().length),false)));
break;
case OP_INVERT:
case OP_AND:
case OP_OR:
case OP_XOR:
throw new ScriptException(""String_Node_Str"");
case OP_EQUAL:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
stack.add(Arrays.equals(stack.pollLast(),stack.pollLast()) ? new byte[]{1} : new byte[]{0});
break;
case OP_EQUALVERIFY:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
if (!Arrays.equals(stack.pollLast(),stack.pollLast())) throw new ScriptException(""String_Node_Str"");
break;
case OP_1ADD:
case OP_1SUB:
case OP_NEGATE:
case OP_ABS:
case OP_NOT:
case OP_0NOTEQUAL:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
BigInteger numericOPnum=castToBigInteger(stack.pollLast());
switch (opcode) {
case OP_1ADD:
numericOPnum=numericOPnum.add(BigInteger.ONE);
break;
case OP_1SUB:
numericOPnum=numericOPnum.subtract(BigInteger.ONE);
break;
case OP_NEGATE:
numericOPnum=numericOPnum.negate();
break;
case OP_ABS:
if (numericOPnum.compareTo(BigInteger.ZERO) < 0) numericOPnum=numericOPnum.negate();
break;
case OP_NOT:
if (numericOPnum.equals(BigInteger.ZERO)) numericOPnum=BigInteger.ONE;
 else numericOPnum=BigInteger.ZERO;
break;
case OP_0NOTEQUAL:
if (numericOPnum.equals(BigInteger.ZERO)) numericOPnum=BigInteger.ZERO;
 else numericOPnum=BigInteger.ONE;
break;
default :
throw new AssertionError(""String_Node_Str"");
}
stack.add(Utils.reverseBytes(Utils.encodeMPI(numericOPnum,false)));
break;
case OP_2MUL:
case OP_2DIV:
throw new ScriptException(""String_Node_Str"");
case OP_ADD:
case OP_SUB:
case OP_BOOLAND:
case OP_BOOLOR:
case OP_NUMEQUAL:
case OP_NUMNOTEQUAL:
case OP_LESSTHAN:
case OP_GREATERTHAN:
case OP_LESSTHANOREQUAL:
case OP_GREATERTHANOREQUAL:
case OP_MIN:
case OP_MAX:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
BigInteger numericOPnum2=castToBigInteger(stack.pollLast());
BigInteger numericOPnum1=castToBigInteger(stack.pollLast());
BigInteger numericOPresult;
switch (opcode) {
case OP_ADD:
numericOPresult=numericOPnum1.add(numericOPnum2);
break;
case OP_SUB:
numericOPresult=numericOPnum1.subtract(numericOPnum2);
break;
case OP_BOOLAND:
if (!numericOPnum1.equals(BigInteger.ZERO) && !numericOPnum2.equals(BigInteger.ZERO)) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_BOOLOR:
if (!numericOPnum1.equals(BigInteger.ZERO) || !numericOPnum2.equals(BigInteger.ZERO)) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_NUMEQUAL:
if (numericOPnum1.equals(numericOPnum2)) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_NUMNOTEQUAL:
if (!numericOPnum1.equals(numericOPnum2)) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_LESSTHAN:
if (numericOPnum1.compareTo(numericOPnum2) < 0) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_GREATERTHAN:
if (numericOPnum1.compareTo(numericOPnum2) > 0) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_LESSTHANOREQUAL:
if (numericOPnum1.compareTo(numericOPnum2) <= 0) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_GREATERTHANOREQUAL:
if (numericOPnum1.compareTo(numericOPnum2) >= 0) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_MIN:
if (numericOPnum1.compareTo(numericOPnum2) < 0) numericOPresult=numericOPnum1;
 else numericOPresult=numericOPnum2;
break;
case OP_MAX:
if (numericOPnum1.compareTo(numericOPnum2) > 0) numericOPresult=numericOPnum1;
 else numericOPresult=numericOPnum2;
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
stack.add(Utils.reverseBytes(Utils.encodeMPI(numericOPresult,false)));
break;
case OP_MUL:
case OP_DIV:
case OP_MOD:
case OP_LSHIFT:
case OP_RSHIFT:
throw new ScriptException(""String_Node_Str"");
case OP_NUMEQUALVERIFY:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
BigInteger OPNUMEQUALVERIFYnum2=castToBigInteger(stack.pollLast());
BigInteger OPNUMEQUALVERIFYnum1=castToBigInteger(stack.pollLast());
if (!OPNUMEQUALVERIFYnum1.equals(OPNUMEQUALVERIFYnum2)) throw new ScriptException(""String_Node_Str"");
break;
case OP_WITHIN:
if (stack.size() < 3) throw new ScriptException(""String_Node_Str"");
BigInteger OPWITHINnum3=castToBigInteger(stack.pollLast());
BigInteger OPWITHINnum2=castToBigInteger(stack.pollLast());
BigInteger OPWITHINnum1=castToBigInteger(stack.pollLast());
if (OPWITHINnum2.compareTo(OPWITHINnum1) <= 0 && OPWITHINnum1.compareTo(OPWITHINnum3) < 0) stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.ONE,false)));
 else stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.ZERO,false)));
break;
case OP_RIPEMD160:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
RIPEMD160Digest digest=new RIPEMD160Digest();
byte[] dataToHash=stack.pollLast();
digest.update(dataToHash,0,dataToHash.length);
byte[] ripmemdHash=new byte[20];
digest.doFinal(ripmemdHash,0);
stack.add(ripmemdHash);
break;
case OP_SHA1:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
try {
stack.add(MessageDigest.getInstance(""String_Node_Str"").digest(stack.pollLast()));
}
 catch (NoSuchAlgorithmException e) {
throw new RuntimeException(e);
}
break;
case OP_SHA256:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
try {
stack.add(MessageDigest.getInstance(""String_Node_Str"").digest(stack.pollLast()));
}
 catch (NoSuchAlgorithmException e) {
throw new RuntimeException(e);
}
break;
case OP_HASH160:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
stack.add(Utils.sha256hash160(stack.pollLast()));
break;
case OP_HASH256:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
stack.add(Utils.doubleDigest(stack.pollLast()));
break;
case OP_CODESEPARATOR:
lastCodeSepLocation=chunk.getStartLocationInProgram() + 1;
break;
case OP_CHECKSIG:
case OP_CHECKSIGVERIFY:
executeCheckSig(txContainingThis,(int)index,script,stack,lastCodeSepLocation,opcode);
break;
case OP_CHECKMULTISIG:
case OP_CHECKMULTISIGVERIFY:
opCount=executeMultiSig(txContainingThis,(int)index,script,stack,opCount,lastCodeSepLocation,opcode);
break;
case OP_NOP1:
case OP_NOP2:
case OP_NOP3:
case OP_NOP4:
case OP_NOP5:
case OP_NOP6:
case OP_NOP7:
case OP_NOP8:
case OP_NOP9:
case OP_NOP10:
break;
default :
throw new ScriptException(""String_Node_Str"");
}
}
if (stack.size() + altstack.size() > 1000 || stack.size() + altstack.size() < 0) throw new ScriptException(""String_Node_Str"");
}
if (!ifStack.isEmpty()) throw new ScriptException(""String_Node_Str"");
}","private static void executeScript(Transaction txContainingThis,long index,Script script,LinkedList<byte[]> stack) throws ScriptException {
  int opCount=0;
  int lastCodeSepLocation=0;
  LinkedList<byte[]> altstack=new LinkedList<byte[]>();
  LinkedList<Boolean> ifStack=new LinkedList<Boolean>();
  for (  ScriptChunk chunk : script.chunks) {
    boolean shouldExecute=!ifStack.contains(false);
    if (!chunk.isOpCode()) {
      if (!shouldExecute)       continue;
      stack.add(chunk.data);
    }
 else {
      int opcode=0xFF & chunk.data[0];
      if (opcode > OP_16) {
        opCount++;
        if (opCount > 201)         throw new ScriptException(""String_Node_Str"");
      }
      if (opcode == OP_VERIF || opcode == OP_VERNOTIF)       throw new ScriptException(""String_Node_Str"");
      if (opcode == OP_CAT || opcode == OP_SUBSTR || opcode == OP_LEFT || opcode == OP_RIGHT || opcode == OP_INVERT || opcode == OP_AND || opcode == OP_OR || opcode == OP_XOR || opcode == OP_2MUL || opcode == OP_2DIV || opcode == OP_MUL || opcode == OP_DIV || opcode == OP_MOD || opcode == OP_LSHIFT || opcode == OP_RSHIFT)       throw new ScriptException(""String_Node_Str"");
switch (opcode) {
case OP_IF:
        if (!shouldExecute) {
          ifStack.add(false);
          continue;
        }
      if (stack.size() < 1)       throw new ScriptException(""String_Node_Str"");
    ifStack.add(castToBool(stack.pollLast()));
  continue;
case OP_NOTIF:
if (!shouldExecute) {
  ifStack.add(false);
  continue;
}
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
ifStack.add(!castToBool(stack.pollLast()));
continue;
case OP_ELSE:
if (ifStack.isEmpty()) throw new ScriptException(""String_Node_Str"");
ifStack.add(!ifStack.pollLast());
continue;
case OP_ENDIF:
if (ifStack.isEmpty()) throw new ScriptException(""String_Node_Str"");
ifStack.pollLast();
continue;
}
if (!shouldExecute) continue;
switch (opcode) {
case OP_0:
stack.add(new byte[]{0});
break;
case OP_1NEGATE:
stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.ONE.negate(),false)));
break;
case OP_1:
case OP_2:
case OP_3:
case OP_4:
case OP_5:
case OP_6:
case OP_7:
case OP_8:
case OP_9:
case OP_10:
case OP_11:
case OP_12:
case OP_13:
case OP_14:
case OP_15:
case OP_16:
stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.valueOf(decodeFromOpN(opcode)),false)));
break;
case OP_NOP:
break;
case OP_VERIFY:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
if (!castToBool(stack.pollLast())) throw new ScriptException(""String_Node_Str"");
break;
case OP_RETURN:
throw new ScriptException(""String_Node_Str"");
case OP_TOALTSTACK:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
altstack.add(stack.pollLast());
break;
case OP_FROMALTSTACK:
if (altstack.size() < 1) throw new ScriptException(""String_Node_Str"");
stack.add(altstack.pollLast());
break;
case OP_2DROP:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
stack.pollLast();
stack.pollLast();
break;
case OP_2DUP:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
Iterator<byte[]> it2DUP=stack.descendingIterator();
byte[] OP2DUPtmpChunk2=it2DUP.next();
stack.add(it2DUP.next());
stack.add(OP2DUPtmpChunk2);
break;
case OP_3DUP:
if (stack.size() < 3) throw new ScriptException(""String_Node_Str"");
Iterator<byte[]> it3DUP=stack.descendingIterator();
byte[] OP3DUPtmpChunk3=it3DUP.next();
byte[] OP3DUPtmpChunk2=it3DUP.next();
stack.add(it3DUP.next());
stack.add(OP3DUPtmpChunk2);
stack.add(OP3DUPtmpChunk3);
break;
case OP_2OVER:
if (stack.size() < 4) throw new ScriptException(""String_Node_Str"");
Iterator<byte[]> it2OVER=stack.descendingIterator();
it2OVER.next();
it2OVER.next();
byte[] OP2OVERtmpChunk2=it2OVER.next();
stack.add(it2OVER.next());
stack.add(OP2OVERtmpChunk2);
break;
case OP_2ROT:
if (stack.size() < 6) throw new ScriptException(""String_Node_Str"");
byte[] OP2ROTtmpChunk6=stack.pollLast();
byte[] OP2ROTtmpChunk5=stack.pollLast();
byte[] OP2ROTtmpChunk4=stack.pollLast();
byte[] OP2ROTtmpChunk3=stack.pollLast();
byte[] OP2ROTtmpChunk2=stack.pollLast();
byte[] OP2ROTtmpChunk1=stack.pollLast();
stack.add(OP2ROTtmpChunk3);
stack.add(OP2ROTtmpChunk4);
stack.add(OP2ROTtmpChunk5);
stack.add(OP2ROTtmpChunk6);
stack.add(OP2ROTtmpChunk1);
stack.add(OP2ROTtmpChunk2);
break;
case OP_2SWAP:
if (stack.size() < 4) throw new ScriptException(""String_Node_Str"");
byte[] OP2SWAPtmpChunk4=stack.pollLast();
byte[] OP2SWAPtmpChunk3=stack.pollLast();
byte[] OP2SWAPtmpChunk2=stack.pollLast();
byte[] OP2SWAPtmpChunk1=stack.pollLast();
stack.add(OP2SWAPtmpChunk3);
stack.add(OP2SWAPtmpChunk4);
stack.add(OP2SWAPtmpChunk1);
stack.add(OP2SWAPtmpChunk2);
break;
case OP_IFDUP:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
if (castToBool(stack.getLast())) stack.add(stack.getLast());
break;
case OP_DEPTH:
stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.valueOf(stack.size()),false)));
break;
case OP_DROP:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
stack.pollLast();
break;
case OP_DUP:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
stack.add(stack.getLast());
break;
case OP_NIP:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
byte[] OPNIPtmpChunk=stack.pollLast();
stack.pollLast();
stack.add(OPNIPtmpChunk);
break;
case OP_OVER:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
Iterator<byte[]> itOVER=stack.descendingIterator();
itOVER.next();
stack.add(itOVER.next());
break;
case OP_PICK:
case OP_ROLL:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
long val=castToBigInteger(stack.pollLast()).longValue();
if (val < 0 || val >= stack.size()) throw new ScriptException(""String_Node_Str"");
Iterator<byte[]> itPICK=stack.descendingIterator();
for (long i=0; i < val; i++) itPICK.next();
byte[] OPROLLtmpChunk=itPICK.next();
if (opcode == OP_ROLL) itPICK.remove();
stack.add(OPROLLtmpChunk);
break;
case OP_ROT:
if (stack.size() < 3) throw new ScriptException(""String_Node_Str"");
byte[] OPROTtmpChunk3=stack.pollLast();
byte[] OPROTtmpChunk2=stack.pollLast();
byte[] OPROTtmpChunk1=stack.pollLast();
stack.add(OPROTtmpChunk2);
stack.add(OPROTtmpChunk3);
stack.add(OPROTtmpChunk1);
break;
case OP_SWAP:
case OP_TUCK:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
byte[] OPSWAPtmpChunk2=stack.pollLast();
byte[] OPSWAPtmpChunk1=stack.pollLast();
stack.add(OPSWAPtmpChunk2);
stack.add(OPSWAPtmpChunk1);
if (opcode == OP_TUCK) stack.add(OPSWAPtmpChunk2);
break;
case OP_CAT:
case OP_SUBSTR:
case OP_LEFT:
case OP_RIGHT:
throw new ScriptException(""String_Node_Str"");
case OP_SIZE:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.valueOf(stack.getLast().length),false)));
break;
case OP_INVERT:
case OP_AND:
case OP_OR:
case OP_XOR:
throw new ScriptException(""String_Node_Str"");
case OP_EQUAL:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
stack.add(Arrays.equals(stack.pollLast(),stack.pollLast()) ? new byte[]{1} : new byte[]{0});
break;
case OP_EQUALVERIFY:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
if (!Arrays.equals(stack.pollLast(),stack.pollLast())) throw new ScriptException(""String_Node_Str"");
break;
case OP_1ADD:
case OP_1SUB:
case OP_NEGATE:
case OP_ABS:
case OP_NOT:
case OP_0NOTEQUAL:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
BigInteger numericOPnum=castToBigInteger(stack.pollLast());
switch (opcode) {
case OP_1ADD:
numericOPnum=numericOPnum.add(BigInteger.ONE);
break;
case OP_1SUB:
numericOPnum=numericOPnum.subtract(BigInteger.ONE);
break;
case OP_NEGATE:
numericOPnum=numericOPnum.negate();
break;
case OP_ABS:
if (numericOPnum.compareTo(BigInteger.ZERO) < 0) numericOPnum=numericOPnum.negate();
break;
case OP_NOT:
if (numericOPnum.equals(BigInteger.ZERO)) numericOPnum=BigInteger.ONE;
 else numericOPnum=BigInteger.ZERO;
break;
case OP_0NOTEQUAL:
if (numericOPnum.equals(BigInteger.ZERO)) numericOPnum=BigInteger.ZERO;
 else numericOPnum=BigInteger.ONE;
break;
default :
throw new AssertionError(""String_Node_Str"");
}
stack.add(Utils.reverseBytes(Utils.encodeMPI(numericOPnum,false)));
break;
case OP_2MUL:
case OP_2DIV:
throw new ScriptException(""String_Node_Str"");
case OP_ADD:
case OP_SUB:
case OP_BOOLAND:
case OP_BOOLOR:
case OP_NUMEQUAL:
case OP_NUMNOTEQUAL:
case OP_LESSTHAN:
case OP_GREATERTHAN:
case OP_LESSTHANOREQUAL:
case OP_GREATERTHANOREQUAL:
case OP_MIN:
case OP_MAX:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
BigInteger numericOPnum2=castToBigInteger(stack.pollLast());
BigInteger numericOPnum1=castToBigInteger(stack.pollLast());
BigInteger numericOPresult;
switch (opcode) {
case OP_ADD:
numericOPresult=numericOPnum1.add(numericOPnum2);
break;
case OP_SUB:
numericOPresult=numericOPnum1.subtract(numericOPnum2);
break;
case OP_BOOLAND:
if (!numericOPnum1.equals(BigInteger.ZERO) && !numericOPnum2.equals(BigInteger.ZERO)) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_BOOLOR:
if (!numericOPnum1.equals(BigInteger.ZERO) || !numericOPnum2.equals(BigInteger.ZERO)) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_NUMEQUAL:
if (numericOPnum1.equals(numericOPnum2)) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_NUMNOTEQUAL:
if (!numericOPnum1.equals(numericOPnum2)) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_LESSTHAN:
if (numericOPnum1.compareTo(numericOPnum2) < 0) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_GREATERTHAN:
if (numericOPnum1.compareTo(numericOPnum2) > 0) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_LESSTHANOREQUAL:
if (numericOPnum1.compareTo(numericOPnum2) <= 0) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_GREATERTHANOREQUAL:
if (numericOPnum1.compareTo(numericOPnum2) >= 0) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_MIN:
if (numericOPnum1.compareTo(numericOPnum2) < 0) numericOPresult=numericOPnum1;
 else numericOPresult=numericOPnum2;
break;
case OP_MAX:
if (numericOPnum1.compareTo(numericOPnum2) > 0) numericOPresult=numericOPnum1;
 else numericOPresult=numericOPnum2;
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
stack.add(Utils.reverseBytes(Utils.encodeMPI(numericOPresult,false)));
break;
case OP_MUL:
case OP_DIV:
case OP_MOD:
case OP_LSHIFT:
case OP_RSHIFT:
throw new ScriptException(""String_Node_Str"");
case OP_NUMEQUALVERIFY:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
BigInteger OPNUMEQUALVERIFYnum2=castToBigInteger(stack.pollLast());
BigInteger OPNUMEQUALVERIFYnum1=castToBigInteger(stack.pollLast());
if (!OPNUMEQUALVERIFYnum1.equals(OPNUMEQUALVERIFYnum2)) throw new ScriptException(""String_Node_Str"");
break;
case OP_WITHIN:
if (stack.size() < 3) throw new ScriptException(""String_Node_Str"");
BigInteger OPWITHINnum3=castToBigInteger(stack.pollLast());
BigInteger OPWITHINnum2=castToBigInteger(stack.pollLast());
BigInteger OPWITHINnum1=castToBigInteger(stack.pollLast());
if (OPWITHINnum2.compareTo(OPWITHINnum1) <= 0 && OPWITHINnum1.compareTo(OPWITHINnum3) < 0) stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.ONE,false)));
 else stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.ZERO,false)));
break;
case OP_RIPEMD160:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
RIPEMD160Digest digest=new RIPEMD160Digest();
byte[] dataToHash=stack.pollLast();
digest.update(dataToHash,0,dataToHash.length);
byte[] ripmemdHash=new byte[20];
digest.doFinal(ripmemdHash,0);
stack.add(ripmemdHash);
break;
case OP_SHA1:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
try {
stack.add(MessageDigest.getInstance(""String_Node_Str"").digest(stack.pollLast()));
}
 catch (NoSuchAlgorithmException e) {
throw new RuntimeException(e);
}
break;
case OP_SHA256:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
try {
stack.add(MessageDigest.getInstance(""String_Node_Str"").digest(stack.pollLast()));
}
 catch (NoSuchAlgorithmException e) {
throw new RuntimeException(e);
}
break;
case OP_HASH160:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
stack.add(Utils.sha256hash160(stack.pollLast()));
break;
case OP_HASH256:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
stack.add(Utils.doubleDigest(stack.pollLast()));
break;
case OP_CODESEPARATOR:
lastCodeSepLocation=chunk.getStartLocationInProgram() + 1;
break;
case OP_CHECKSIG:
case OP_CHECKSIGVERIFY:
executeCheckSig(txContainingThis,(int)index,script,stack,lastCodeSepLocation,opcode);
break;
case OP_CHECKMULTISIG:
case OP_CHECKMULTISIGVERIFY:
opCount=executeMultiSig(txContainingThis,(int)index,script,stack,opCount,lastCodeSepLocation,opcode);
break;
case OP_NOP1:
case OP_NOP2:
case OP_NOP3:
case OP_NOP4:
case OP_NOP5:
case OP_NOP6:
case OP_NOP7:
case OP_NOP8:
case OP_NOP9:
case OP_NOP10:
break;
default :
throw new ScriptException(""String_Node_Str"" + opcode);
}
}
if (stack.size() + altstack.size() > 1000 || stack.size() + altstack.size() < 0) throw new ScriptException(""String_Node_Str"");
}
if (!ifStack.isEmpty()) throw new ScriptException(""String_Node_Str"");
}",0.9980195059975338
85816,"/** 
 * Work around lack of unsigned types in Java.
 */
public static boolean isLessThanUnsigned(long n1,long n2){
  return (n1 < n2) ^ ((n1 < 0) != (n2 < 0));
}","/** 
 * Work around lack of unsigned types in Java.
 */
public static boolean isLessThanUnsigned(long n1,long n2){
  return UnsignedLongs.compare(n1,n2) < 0;
}",0.85625
85817,"/** 
 * Gets the minimum encoded size of the given value.
 */
public static int sizeOf(long value){
  if (isLessThanUnsigned(value,253))   return 1;
 else   if (isLessThanUnsigned(value,65536))   return 3;
 else   if (isLessThanUnsigned(value,4294967296L))   return 5;
 else   return 9;
}","/** 
 * Gets the minimum encoded size of the given value.
 */
public static int sizeOf(long value){
  if (isLessThanUnsigned(value,253))   return 1;
 else   if (isLessThanUnsigned(value,65536))   return 3;
 else   if (isLessThanUnsigned(value,UnsignedInteger.MAX_VALUE.longValue()))   return 5;
 else   return 9;
}",0.9235880398671096
85818,"public byte[] encodeBE(){
  if (isLessThanUnsigned(value,253)) {
    return new byte[]{(byte)value};
  }
 else   if (isLessThanUnsigned(value,65536)) {
    return new byte[]{(byte)253,(byte)(value),(byte)(value >> 8)};
  }
 else   if (isLessThanUnsigned(value,4294967295L)) {
    byte[] bytes=new byte[5];
    bytes[0]=(byte)254;
    Utils.uint32ToByteArrayLE(value,bytes,1);
    return bytes;
  }
 else {
    byte[] bytes=new byte[9];
    bytes[0]=(byte)255;
    Utils.uint32ToByteArrayLE(value,bytes,1);
    Utils.uint32ToByteArrayLE(value >>> 32,bytes,5);
    return bytes;
  }
}","public byte[] encodeBE(){
  if (isLessThanUnsigned(value,253)) {
    return new byte[]{(byte)value};
  }
 else   if (isLessThanUnsigned(value,65536)) {
    return new byte[]{(byte)253,(byte)(value),(byte)(value >> 8)};
  }
 else   if (isLessThanUnsigned(value,UnsignedInteger.MAX_VALUE.longValue())) {
    byte[] bytes=new byte[5];
    bytes[0]=(byte)254;
    Utils.uint32ToByteArrayLE(value,bytes,1);
    return bytes;
  }
 else {
    byte[] bytes=new byte[9];
    bytes[0]=(byte)255;
    Utils.uint32ToByteArrayLE(value,bytes,1);
    Utils.uint32ToByteArrayLE(value >>> 32,bytes,5);
    return bytes;
  }
}",0.961344537815126
85819,"/** 
 * Handle when a transaction becomes newly active on the best chain, either due to receiving a new block or a re-org making inactive transactions active.
 */
private void processTxFromBestChain(Transaction tx) throws VerificationException {
  checkState(lock.isLocked());
  boolean isDeadCoinbase=tx.isCoinBase() && dead.containsKey(tx.getHash());
  if (isDeadCoinbase) {
    log.info(""String_Node_Str"",tx.getHashAsString(),tx.getConfidence().getConfidenceType().name());
    dead.remove(tx.getHash());
  }
  if (inactive.containsKey(tx.getHash())) {
    log.info(""String_Node_Str"",tx.getHashAsString());
    inactive.remove(tx.getHash());
  }
  updateForSpends(tx,true);
  boolean hasOutputsToMe=tx.getValueSentToMe(this,true).compareTo(BigInteger.ZERO) > 0;
  if (hasOutputsToMe) {
    if (tx.isEveryOwnedOutputSpent(this)) {
      log.info(""String_Node_Str"",tx.getHashAsString());
      addWalletTransaction(Pool.SPENT,tx);
    }
 else {
      log.info(""String_Node_Str"",tx.getHashAsString());
      addWalletTransaction(Pool.UNSPENT,tx);
    }
  }
 else   if (tx.getValueSentFromMe(this).compareTo(BigInteger.ZERO) > 0) {
    log.info(""String_Node_Str"",tx.getHashAsString());
    addWalletTransaction(Pool.SPENT,tx);
  }
  TransactionInput doubleSpent=findDoubleSpendAgainstPending(tx);
  if (doubleSpent != null) {
    killTx(tx,doubleSpent,doubleSpent.getParentTransaction());
  }
}","/** 
 * Handle when a transaction becomes newly active on the best chain, either due to receiving a new block or a re-org making inactive transactions active.
 */
private void processTxFromBestChain(Transaction tx) throws VerificationException {
  checkState(lock.isLocked());
  boolean isDeadCoinbase=tx.isCoinBase() && dead.containsKey(tx.getHash());
  if (isDeadCoinbase) {
    log.info(""String_Node_Str"",tx.getHashAsString(),tx.getConfidence().getConfidenceType().name());
    dead.remove(tx.getHash());
  }
  if (inactive.containsKey(tx.getHash())) {
    log.info(""String_Node_Str"",tx.getHashAsString());
    inactive.remove(tx.getHash());
  }
  updateForSpends(tx,true);
  boolean hasOutputsToMe=tx.getValueSentToMe(this,true).compareTo(BigInteger.ZERO) > 0;
  if (hasOutputsToMe) {
    if (tx.isEveryOwnedOutputSpent(this)) {
      log.info(""String_Node_Str"",tx.getHashAsString());
      addWalletTransaction(Pool.SPENT,tx);
    }
 else {
      log.info(""String_Node_Str"",tx.getHashAsString());
      addWalletTransaction(Pool.UNSPENT,tx);
    }
  }
 else   if (tx.getValueSentFromMe(this).compareTo(BigInteger.ZERO) > 0) {
    log.info(""String_Node_Str"",tx.getHashAsString());
    addWalletTransaction(Pool.SPENT,tx);
  }
  checkForDoubleSpendAgainstPending(tx,true);
}",0.9400749063670412
85820,"private void killTx(Transaction overridingTx,TransactionInput overridingInput,Transaction killedTx){
  TransactionOutPoint overriddenOutPoint=overridingInput.getOutpoint();
  log.warn(""String_Node_Str"",overriddenOutPoint,killedTx.getHashAsString());
  log.warn(""String_Node_Str"",overridingTx.getHashAsString());
  checkState(overridingInput.connect(overridingTx,TransactionInput.ConnectMode.DISCONNECT_ON_CONFLICT) == TransactionInput.ConnectionResult.SUCCESS);
  pending.remove(killedTx.getHash());
  addWalletTransaction(Pool.DEAD,killedTx);
  for (  TransactionInput deadInput : killedTx.getInputs())   deadInput.disconnect();
  killedTx.getConfidence().setOverridingTransaction(overridingTx);
}","private void killTx(Transaction overridingTx,TransactionInput overridingInput,Transaction killedTx){
  TransactionOutPoint overriddenOutPoint=overridingInput.getOutpoint();
  log.warn(""String_Node_Str"",overriddenOutPoint,killedTx.getHashAsString());
  log.warn(""String_Node_Str"",overridingTx.getHashAsString());
  pending.remove(killedTx.getHash());
  addWalletTransaction(Pool.DEAD,killedTx);
  log.info(""String_Node_Str"");
  for (  TransactionInput deadInput : killedTx.getInputs()) {
    Transaction connected=deadInput.getOutpoint().fromTx;
    if (connected == null)     continue;
    deadInput.disconnect();
    maybeMovePool(connected,""String_Node_Str"");
  }
  log.info(""String_Node_Str"");
  TransactionInput.ConnectionResult result=overridingInput.connect(unspent,TransactionInput.ConnectMode.DISCONNECT_ON_CONFLICT);
  if (result == TransactionInput.ConnectionResult.SUCCESS) {
    maybeMovePool(overridingInput.getOutpoint().fromTx,""String_Node_Str"");
  }
 else {
    result=overridingInput.connect(spent,TransactionInput.ConnectMode.DISCONNECT_ON_CONFLICT);
    if (result == TransactionInput.ConnectionResult.SUCCESS) {
      maybeMovePool(overridingInput.getOutpoint().fromTx,""String_Node_Str"");
    }
  }
  log.info(""String_Node_Str"");
  killedTx.getConfidence().setOverridingTransaction(overridingTx);
}",0.5208333333333334
85821,"/** 
 * Given a spend request containing an incomplete transaction, makes it valid by adding inputs and outputs according to the instructions in the request. The transaction in the request is modified by this method.
 * @param req a SendRequest that contains the incomplete transaction and details for how to make it valid.
 * @throws IllegalArgumentException if you try and complete the same SendRequest twice.
 * @return False if we cannot afford this send, true otherwise.
 */
public boolean completeTx(SendRequest req){
  lock.lock();
  try {
    Preconditions.checkArgument(!req.completed,""String_Node_Str"");
    BigInteger value=BigInteger.ZERO;
    for (    TransactionOutput output : req.tx.getOutputs()) {
      value=value.add(output.getValue());
    }
    value=value.add(req.fee);
    log.info(""String_Node_Str"",req.tx.getOutputs().size(),bitcoinValueToFriendlyString(value));
    LinkedList<TransactionOutput> candidates=calculateSpendCandidates(true);
    CoinSelection selection=coinSelector.select(value,candidates);
    if (selection.valueGathered.compareTo(value) < 0) {
      log.warn(""String_Node_Str"" + bitcoinValueToFriendlyString(value.subtract(selection.valueGathered)));
      return false;
    }
    checkState(selection.gathered.size() > 0);
    req.tx.getConfidence().setConfidenceType(ConfidenceType.NOT_SEEN_IN_CHAIN);
    BigInteger change=selection.valueGathered.subtract(value);
    if (change.compareTo(BigInteger.ZERO) > 0) {
      Address changeAddress=req.changeAddress != null ? req.changeAddress : getChangeAddress();
      log.info(""String_Node_Str"",bitcoinValueToFriendlyString(change));
      req.tx.addOutput(new TransactionOutput(params,req.tx,change,changeAddress));
    }
    for (    TransactionOutput output : selection.gathered) {
      req.tx.addInput(output);
    }
    try {
      req.tx.signInputs(Transaction.SigHash.ALL,this,req.aesKey);
    }
 catch (    ScriptException e) {
      throw new RuntimeException(e);
    }
    int size=req.tx.bitcoinSerialize().length;
    if (size > Transaction.MAX_STANDARD_TX_SIZE) {
      log.error(""String_Node_Str"",size,Transaction.MAX_STANDARD_TX_SIZE);
      return false;
    }
    req.tx.getConfidence().setSource(TransactionConfidence.Source.SELF);
    req.completed=true;
    log.info(""String_Node_Str"",req.tx.getHashAsString());
    return true;
  }
  finally {
    lock.unlock();
  }
}","/** 
 * Given a spend request containing an incomplete transaction, makes it valid by adding inputs and outputs according to the instructions in the request. The transaction in the request is modified by this method.
 * @param req a SendRequest that contains the incomplete transaction and details for how to make it valid.
 * @throws IllegalArgumentException if you try and complete the same SendRequest twice.
 * @return False if we cannot afford this send, true otherwise.
 */
public boolean completeTx(SendRequest req){
  lock.lock();
  try {
    Preconditions.checkArgument(!req.completed,""String_Node_Str"");
    BigInteger value=BigInteger.ZERO;
    for (    TransactionOutput output : req.tx.getOutputs()) {
      value=value.add(output.getValue());
    }
    value=value.add(req.fee);
    log.info(""String_Node_Str"",req.tx.getOutputs().size(),bitcoinValueToFriendlyString(value));
    LinkedList<TransactionOutput> candidates=calculateSpendCandidates(true);
    CoinSelection selection=coinSelector.select(value,candidates);
    if (selection.valueGathered.compareTo(value) < 0) {
      log.warn(""String_Node_Str"" + bitcoinValueToFriendlyString(value.subtract(selection.valueGathered)));
      return false;
    }
    checkState(selection.gathered.size() > 0);
    req.tx.getConfidence().setConfidenceType(ConfidenceType.NOT_SEEN_IN_CHAIN);
    BigInteger change=selection.valueGathered.subtract(value);
    if (change.compareTo(BigInteger.ZERO) > 0) {
      Address changeAddress=req.changeAddress != null ? req.changeAddress : getChangeAddress();
      log.info(""String_Node_Str"",bitcoinValueToFriendlyString(change));
      req.tx.addOutput(new TransactionOutput(params,req.tx,change,changeAddress));
    }
    for (    TransactionOutput output : selection.gathered) {
      req.tx.addInput(output);
    }
    try {
      req.tx.signInputs(Transaction.SigHash.ALL,this,req.aesKey);
    }
 catch (    ScriptException e) {
      throw new RuntimeException(e);
    }
    int size=req.tx.bitcoinSerialize().length;
    if (size > Transaction.MAX_STANDARD_TX_SIZE) {
      log.error(""String_Node_Str"",size,Transaction.MAX_STANDARD_TX_SIZE);
      return false;
    }
    req.tx.getConfidence().setSource(TransactionConfidence.Source.SELF);
    req.completed=true;
    log.info(""String_Node_Str"",req.tx.getHashAsString(),req.tx.getInputs().size());
    return true;
  }
  finally {
    lock.unlock();
  }
}",0.9945788156797332
85822,"/** 
 * <p>Returns true if the given transaction sends coins to any of our keys, or has inputs spending any of our outputs, and if includeDoubleSpending is true, also returns true if tx has inputs that are spending outputs which are not ours but which are spent by pending transactions.</p> <p>Note that if the tx has inputs containing one of our keys, but the connected transaction is not in the wallet, it will not be considered relevant.</p>
 */
public boolean isTransactionRelevant(Transaction tx) throws ScriptException {
  lock.lock();
  try {
    return tx.getValueSentFromMe(this).compareTo(BigInteger.ZERO) > 0 || tx.getValueSentToMe(this).compareTo(BigInteger.ZERO) > 0 || findDoubleSpendAgainstPending(tx) != null;
  }
  finally {
    lock.unlock();
  }
}","/** 
 * <p>Returns true if the given transaction sends coins to any of our keys, or has inputs spending any of our outputs, and if includeDoubleSpending is true, also returns true if tx has inputs that are spending outputs which are not ours but which are spent by pending transactions.</p> <p>Note that if the tx has inputs containing one of our keys, but the connected transaction is not in the wallet, it will not be considered relevant.</p>
 */
public boolean isTransactionRelevant(Transaction tx) throws ScriptException {
  lock.lock();
  try {
    return tx.getValueSentFromMe(this).compareTo(BigInteger.ZERO) > 0 || tx.getValueSentToMe(this).compareTo(BigInteger.ZERO) > 0 || checkForDoubleSpendAgainstPending(tx,false);
  }
  finally {
    lock.unlock();
  }
}",0.9830508474576272
85823,"public boolean isConsistent(){
  lock.lock();
  try {
    boolean success=true;
    HashSet<Transaction> pendingInactive=new HashSet<Transaction>();
    pendingInactive.addAll(pending.values());
    pendingInactive.addAll(inactive.values());
    Set<Transaction> transactions=getTransactions(true,true);
    Set<Sha256Hash> hashes=new HashSet<Sha256Hash>();
    for (    Transaction tx : transactions) {
      hashes.add(tx.getHash());
    }
    int size1=transactions.size();
    if (size1 != hashes.size()) {
      log.error(""String_Node_Str"");
      success=false;
    }
    int size2=unspent.size() + spent.size() + pendingInactive.size()+ dead.size();
    if (size1 != size2) {
      log.error(""String_Node_Str"",size1,size2);
      success=false;
    }
    for (    Transaction tx : unspent.values()) {
      if (!tx.isConsistent(this,false)) {
        success=false;
        log.error(""String_Node_Str"",tx.getHashAsString());
      }
    }
    for (    Transaction tx : spent.values()) {
      if (!tx.isConsistent(this,true)) {
        success=false;
        log.error(""String_Node_Str"",tx.getHashAsString());
      }
    }
    return success;
  }
  finally {
    lock.unlock();
  }
}","public boolean isConsistent(){
  lock.lock();
  try {
    boolean success=true;
    HashSet<Transaction> pendingInactive=new HashSet<Transaction>();
    pendingInactive.addAll(pending.values());
    pendingInactive.addAll(inactive.values());
    Set<Transaction> transactions=getTransactions(true,true);
    Set<Sha256Hash> hashes=new HashSet<Sha256Hash>();
    for (    Transaction tx : transactions) {
      hashes.add(tx.getHash());
    }
    int size1=transactions.size();
    if (size1 != hashes.size()) {
      log.error(""String_Node_Str"");
      success=false;
    }
    int size2=unspent.size() + spent.size() + pendingInactive.size()+ dead.size();
    if (size1 != size2) {
      log.error(""String_Node_Str"",size1,size2);
      success=false;
    }
    for (    Transaction tx : unspent.values()) {
      if (!tx.isConsistent(this,false)) {
        success=false;
        log.error(""String_Node_Str"",tx.getHashAsString());
      }
    }
    for (    Transaction tx : spent.values()) {
      if (!tx.isConsistent(this,true)) {
        success=false;
        log.error(""String_Node_Str"",tx.getHashAsString());
      }
    }
    if (!success)     log.error(toString());
    return success;
  }
  finally {
    lock.unlock();
  }
}",0.9814585908529048
85824,"/** 
 * <p>Updates the wallet by checking if this TX spends any of our outputs, and marking them as spent if so. If fromChain is true, also checks to see if any pending transaction spends outputs of this transaction and marks the spent flags appropriately.</p> <p>It can be called in two contexts. One is when we receive a transaction on the best chain but it wasn't pending, this most commonly happens when we have a set of keys but the wallet transactions were wiped and we are catching up with the block chain. It can also happen if a block includes a transaction we never saw at broadcast time. If this tx double spends, it takes precedence over our pending transactions and the pending tx goes dead.</p> <p>The other context it can be called is from   {@link Wallet#receivePending(Transaction,java.util.List)}, ie we saw a tx be broadcast or one was submitted directly that spends our own coins. If this tx double spends it does NOT take precedence because the winner will be resolved by the miners - we assume that our version will win, if we are wrong then when a block appears the tx will go dead.</p>
 * @param tx The transaction which is being updated.
 * @param fromChain If true, the tx appeared on the current best chain, if false it was pending.
 */
private void updateForSpends(Transaction tx,boolean fromChain) throws VerificationException {
  checkState(lock.isLocked());
  for (  TransactionInput input : tx.getInputs()) {
    TransactionInput.ConnectionResult result=input.connect(unspent,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
    if (result == TransactionInput.ConnectionResult.NO_SUCH_TX) {
      result=input.connect(spent,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
      if (result == TransactionInput.ConnectionResult.NO_SUCH_TX) {
        result=input.connect(pending,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
        if (result == TransactionInput.ConnectionResult.NO_SUCH_TX) {
          continue;
        }
      }
    }
    if (result == TransactionInput.ConnectionResult.ALREADY_SPENT) {
      if (fromChain) {
      }
 else {
        log.warn(""String_Node_Str"",tx.getHashAsString());
        log.warn(""String_Node_Str"",tx.getInputs().indexOf(input));
      }
    }
 else     if (result == TransactionInput.ConnectionResult.SUCCESS) {
      Transaction connected=checkNotNull(input.getOutpoint().fromTx);
      maybeMoveTxToSpent(connected,""String_Node_Str"");
    }
  }
  if (fromChain) {
    for (    Transaction pendingTx : pending.values()) {
      for (      TransactionInput input : pendingTx.getInputs()) {
        TransactionInput.ConnectionResult result=input.connect(tx,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
        checkState(result != TransactionInput.ConnectionResult.ALREADY_SPENT);
        if (result == TransactionInput.ConnectionResult.SUCCESS) {
          log.info(""String_Node_Str"",pendingTx.getHashAsString(),pendingTx.getInputs().indexOf(input));
        }
      }
    }
  }
}","/** 
 * <p>Updates the wallet by checking if this TX spends any of our outputs, and marking them as spent if so. If fromChain is true, also checks to see if any pending transaction spends outputs of this transaction and marks the spent flags appropriately.</p> <p>It can be called in two contexts. One is when we receive a transaction on the best chain but it wasn't pending, this most commonly happens when we have a set of keys but the wallet transactions were wiped and we are catching up with the block chain. It can also happen if a block includes a transaction we never saw at broadcast time. If this tx double spends, it takes precedence over our pending transactions and the pending tx goes dead.</p> <p>The other context it can be called is from   {@link Wallet#receivePending(Transaction,java.util.List)}, ie we saw a tx be broadcast or one was submitted directly that spends our own coins. If this tx double spends it does NOT take precedence because the winner will be resolved by the miners - we assume that our version will win, if we are wrong then when a block appears the tx will go dead.</p>
 * @param tx The transaction which is being updated.
 * @param fromChain If true, the tx appeared on the current best chain, if false it was pending.
 */
private void updateForSpends(Transaction tx,boolean fromChain) throws VerificationException {
  checkState(lock.isLocked());
  for (  TransactionInput input : tx.getInputs()) {
    TransactionInput.ConnectionResult result=input.connect(unspent,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
    if (result == TransactionInput.ConnectionResult.NO_SUCH_TX) {
      result=input.connect(spent,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
      if (result == TransactionInput.ConnectionResult.NO_SUCH_TX) {
        result=input.connect(pending,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
        if (result == TransactionInput.ConnectionResult.NO_SUCH_TX) {
          continue;
        }
      }
    }
    if (result == TransactionInput.ConnectionResult.ALREADY_SPENT) {
      if (fromChain) {
      }
 else {
        log.warn(""String_Node_Str"",tx.getHashAsString());
        log.warn(""String_Node_Str"",tx.getInputs().indexOf(input));
      }
    }
 else     if (result == TransactionInput.ConnectionResult.SUCCESS) {
      Transaction connected=checkNotNull(input.getOutpoint().fromTx);
      maybeMovePool(connected,""String_Node_Str"");
    }
  }
  if (fromChain) {
    for (    Transaction pendingTx : pending.values()) {
      for (      TransactionInput input : pendingTx.getInputs()) {
        TransactionInput.ConnectionResult result=input.connect(tx,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
        checkState(result != TransactionInput.ConnectionResult.ALREADY_SPENT);
        if (result == TransactionInput.ConnectionResult.SUCCESS) {
          log.info(""String_Node_Str"",pendingTx.getHashAsString(),pendingTx.getInputs().indexOf(input));
        }
      }
    }
  }
}",0.9978029406793985
85825,"private void reprocessUnincludedTxAfterReorg(Map<Sha256Hash,Transaction> pool,Transaction tx){
  checkState(lock.isLocked());
  log.info(""String_Node_Str"",tx.getHashAsString() + ""String_Node_Str"" + tx.getConfidence().getConfidenceType().name());
  boolean isDeadCoinbase=tx.isCoinBase() && ConfidenceType.DEAD == tx.getConfidence().getConfidenceType();
  if (isDeadCoinbase) {
    return;
  }
  int numInputs=tx.getInputs().size();
  int noSuchTx=0;
  int success=0;
  boolean isDead=false;
  Set<Transaction> connectedTransactions=new HashSet<Transaction>();
  for (  TransactionInput input : tx.getInputs()) {
    TransactionInput.ConnectionResult result=input.connect(pool,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
    if (result == TransactionInput.ConnectionResult.SUCCESS) {
      success++;
      TransactionOutput connectedOutput=checkNotNull(input.getConnectedOutput(pool));
      connectedTransactions.add(checkNotNull(connectedOutput.parentTransaction));
    }
 else     if (result == TransactionInput.ConnectionResult.NO_SUCH_TX) {
      noSuchTx++;
    }
 else     if (result == TransactionInput.ConnectionResult.ALREADY_SPENT) {
      isDead=true;
      log.info(""String_Node_Str"",tx.getHashAsString());
      TransactionOutput doubleSpent=input.getConnectedOutput(pool);
      Transaction replacement=doubleSpent.getSpentBy().getParentTransaction();
      dead.put(tx.getHash(),tx);
      pending.remove(tx.getHash());
      tx.getConfidence().setOverridingTransaction(replacement);
      break;
    }
  }
  if (isDead)   return;
  if (noSuchTx == numInputs) {
    log.info(""String_Node_Str"",tx.getHashAsString() + ""String_Node_Str"" + tx.getConfidence().getConfidenceType().name());
    inactive.put(tx.getHash(),tx);
    dead.remove(tx.getHash());
  }
 else   if (success == numInputs - noSuchTx) {
    log.info(""String_Node_Str"",tx.getHashAsString() + ""String_Node_Str"" + tx.getConfidence().getConfidenceType().name());
    pending.put(tx.getHash(),tx);
    dead.remove(tx.getHash());
  }
  for (  Transaction maybeSpent : connectedTransactions) {
    maybeMoveTxToSpent(maybeSpent,""String_Node_Str"");
  }
}","private void reprocessUnincludedTxAfterReorg(Map<Sha256Hash,Transaction> pool,Transaction tx){
  checkState(lock.isLocked());
  log.info(""String_Node_Str"",tx.getHashAsString() + ""String_Node_Str"" + tx.getConfidence().getConfidenceType().name());
  boolean isDeadCoinbase=tx.isCoinBase() && ConfidenceType.DEAD == tx.getConfidence().getConfidenceType();
  if (isDeadCoinbase) {
    return;
  }
  int numInputs=tx.getInputs().size();
  int noSuchTx=0;
  int success=0;
  boolean isDead=false;
  Set<Transaction> connectedTransactions=new HashSet<Transaction>();
  for (  TransactionInput input : tx.getInputs()) {
    TransactionInput.ConnectionResult result=input.connect(pool,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
    if (result == TransactionInput.ConnectionResult.SUCCESS) {
      success++;
      TransactionOutput connectedOutput=checkNotNull(input.getConnectedOutput(pool));
      connectedTransactions.add(checkNotNull(connectedOutput.parentTransaction));
    }
 else     if (result == TransactionInput.ConnectionResult.NO_SUCH_TX) {
      noSuchTx++;
    }
 else     if (result == TransactionInput.ConnectionResult.ALREADY_SPENT) {
      isDead=true;
      log.info(""String_Node_Str"",tx.getHashAsString());
      TransactionOutput doubleSpent=input.getConnectedOutput(pool);
      Transaction replacement=doubleSpent.getSpentBy().getParentTransaction();
      dead.put(tx.getHash(),tx);
      pending.remove(tx.getHash());
      tx.getConfidence().setOverridingTransaction(replacement);
      break;
    }
  }
  if (isDead)   return;
  if (noSuchTx == numInputs) {
    log.info(""String_Node_Str"",tx.getHashAsString() + ""String_Node_Str"" + tx.getConfidence().getConfidenceType().name());
    inactive.put(tx.getHash(),tx);
    dead.remove(tx.getHash());
  }
 else   if (success == numInputs - noSuchTx) {
    log.info(""String_Node_Str"",tx.getHashAsString() + ""String_Node_Str"" + tx.getConfidence().getConfidenceType().name());
    pending.put(tx.getHash(),tx);
    dead.remove(tx.getHash());
  }
  for (  Transaction maybeSpent : connectedTransactions) {
    maybeMovePool(maybeSpent,""String_Node_Str"");
  }
}",0.9969462062485318
85826,"@Test public void doubleSpendFinneyAttack() throws Exception {
  final Transaction[] eventDead=new Transaction[1];
  final Transaction[] eventReplacement=new Transaction[1];
  final int[] eventWalletChanged=new int[1];
  wallet.addEventListener(new AbstractWalletEventListener(){
    @Override public void onTransactionConfidenceChanged(    Wallet wallet,    Transaction tx){
      super.onTransactionConfidenceChanged(wallet,tx);
      if (tx.getConfidence().getConfidenceType() == TransactionConfidence.ConfidenceType.DEAD) {
        eventDead[0]=tx;
        eventReplacement[0]=tx.getConfidence().getOverridingTransaction();
      }
    }
    @Override public void onWalletChanged(    Wallet wallet){
      eventWalletChanged[0]++;
    }
  }
);
  BigInteger nanos=Utils.toNanoCoins(1,0);
  sendMoneyToWallet(nanos,AbstractBlockChain.NewBlockType.BEST_CHAIN);
  Transaction send1=wallet.createSend(new ECKey().toAddress(params),toNanoCoins(0,50));
  Transaction send2=wallet.createSend(new ECKey().toAddress(params),toNanoCoins(0,50));
  send2=new Transaction(params,send2.bitcoinSerialize());
  wallet.commitTx(send1);
  sendMoneyToWallet(send2,AbstractBlockChain.NewBlockType.BEST_CHAIN);
  assertEquals(send1,eventDead[0]);
  assertEquals(send2,eventReplacement[0]);
  assertEquals(TransactionConfidence.ConfidenceType.DEAD,send1.getConfidence().getConfidenceType());
  TestUtils.DoubleSpends doubleSpends=TestUtils.createFakeDoubleSpendTxns(params,myAddress);
  wallet.receivePending(doubleSpends.t1,null);
  assertEquals(TransactionConfidence.ConfidenceType.NOT_SEEN_IN_CHAIN,doubleSpends.t1.getConfidence().getConfidenceType());
  sendMoneyToWallet(doubleSpends.t2,AbstractBlockChain.NewBlockType.BEST_CHAIN);
  assertEquals(TransactionConfidence.ConfidenceType.DEAD,doubleSpends.t1.getConfidence().getConfidenceType());
  assertEquals(doubleSpends.t2,doubleSpends.t1.getConfidence().getOverridingTransaction());
  assertEquals(5,eventWalletChanged[0]);
}","@Test public void doubleSpendFinneyAttack() throws Exception {
  final Transaction[] eventDead=new Transaction[1];
  final Transaction[] eventReplacement=new Transaction[1];
  final int[] eventWalletChanged=new int[1];
  wallet.addEventListener(new AbstractWalletEventListener(){
    @Override public void onTransactionConfidenceChanged(    Wallet wallet,    Transaction tx){
      super.onTransactionConfidenceChanged(wallet,tx);
      if (tx.getConfidence().getConfidenceType() == TransactionConfidence.ConfidenceType.DEAD) {
        eventDead[0]=tx;
        eventReplacement[0]=tx.getConfidence().getOverridingTransaction();
      }
    }
    @Override public void onWalletChanged(    Wallet wallet){
      eventWalletChanged[0]++;
    }
  }
);
  BigInteger nanos=Utils.toNanoCoins(1,0);
  sendMoneyToWallet(nanos,AbstractBlockChain.NewBlockType.BEST_CHAIN);
  Transaction received=wallet.getTransactions(false,false).iterator().next();
  Transaction send1=wallet.createSend(new ECKey().toAddress(params),toNanoCoins(0,50));
  Transaction send2=wallet.createSend(new ECKey().toAddress(params),toNanoCoins(0,50));
  send2=new Transaction(params,send2.bitcoinSerialize());
  wallet.commitTx(send1);
  assertEquals(send1,received.getOutput(0).getSpentBy().getParentTransaction());
  sendMoneyToWallet(send2,AbstractBlockChain.NewBlockType.BEST_CHAIN);
  assertEquals(send1,eventDead[0]);
  assertEquals(send2,eventReplacement[0]);
  assertEquals(TransactionConfidence.ConfidenceType.DEAD,send1.getConfidence().getConfidenceType());
  assertEquals(send2,received.getOutput(0).getSpentBy().getParentTransaction());
  TestUtils.DoubleSpends doubleSpends=TestUtils.createFakeDoubleSpendTxns(params,myAddress);
  wallet.receivePending(doubleSpends.t1,null);
  assertEquals(TransactionConfidence.ConfidenceType.NOT_SEEN_IN_CHAIN,doubleSpends.t1.getConfidence().getConfidenceType());
  sendMoneyToWallet(doubleSpends.t2,AbstractBlockChain.NewBlockType.BEST_CHAIN);
  assertEquals(TransactionConfidence.ConfidenceType.DEAD,doubleSpends.t1.getConfidence().getConfidenceType());
  assertEquals(doubleSpends.t2,doubleSpends.t1.getConfidence().getOverridingTransaction());
  assertEquals(5,eventWalletChanged[0]);
}",0.942390782525204
85827,"private void processInv(InventoryMessage inv) throws IOException {
  List<InventoryItem> items=inv.getItems();
  List<InventoryItem> transactions=new LinkedList<InventoryItem>();
  List<InventoryItem> blocks=new LinkedList<InventoryItem>();
  for (  InventoryItem item : items) {
switch (item.type) {
case Transaction:
      transactions.add(item);
    break;
case Block:
  blocks.add(item);
break;
default :
throw new IllegalStateException(""String_Node_Str"" + item.type);
}
}
final boolean downloadData=this.vDownloadData;
if (transactions.size() == 0 && blocks.size() == 1) {
if (downloadData) {
if (!blockChain.isOrphan(blocks.get(0).hash)) {
blocksAnnounced.incrementAndGet();
}
}
 else {
blocksAnnounced.incrementAndGet();
}
}
GetDataMessage getdata=new GetDataMessage(params);
Iterator<InventoryItem> it=transactions.iterator();
while (it.hasNext()) {
InventoryItem item=it.next();
if (memoryPool == null) {
if (downloadData) {
getdata.addItem(item);
}
}
 else {
if (memoryPool.maybeWasSeen(item.hash)) {
it.remove();
}
 else {
log.debug(""String_Node_Str"",vAddress,item.hash);
getdata.addItem(item);
}
memoryPool.seen(item.hash,this.getAddress());
}
}
boolean pingAfterGetData=false;
lock.lock();
try {
if (blocks.size() > 0 && downloadData && blockChain != null) {
for (InventoryItem item : blocks) {
if (blockChain.isOrphan(item.hash) && downloadBlockBodies) {
blockChainDownload(blockChain.getOrphanRoot(item.hash).getHash());
}
 else {
if (!pendingBlockDownloads.contains(item.hash)) {
  if (vPeerVersionMessage.isBloomFilteringSupported() && useFilteredBlocks) {
    getdata.addItem(new InventoryItem(InventoryItem.Type.FilteredBlock,item.hash));
    pingAfterGetData=true;
  }
 else {
    getdata.addItem(item);
  }
  pendingBlockDownloads.add(item.hash);
}
}
}
}
}
  finally {
lock.unlock();
}
if (!getdata.getItems().isEmpty()) {
sendMessage(getdata);
}
if (pingAfterGetData) sendMessage(new Ping((long)Math.random() * Long.MAX_VALUE));
}","private void processInv(InventoryMessage inv) throws IOException {
  List<InventoryItem> items=inv.getItems();
  List<InventoryItem> transactions=new LinkedList<InventoryItem>();
  List<InventoryItem> blocks=new LinkedList<InventoryItem>();
  for (  InventoryItem item : items) {
switch (item.type) {
case Transaction:
      transactions.add(item);
    break;
case Block:
  blocks.add(item);
break;
default :
throw new IllegalStateException(""String_Node_Str"" + item.type);
}
}
final boolean downloadData=this.vDownloadData;
if (transactions.size() == 0 && blocks.size() == 1) {
if (downloadData) {
if (!blockChain.isOrphan(blocks.get(0).hash)) {
blocksAnnounced.incrementAndGet();
}
}
 else {
blocksAnnounced.incrementAndGet();
}
}
GetDataMessage getdata=new GetDataMessage(params);
Iterator<InventoryItem> it=transactions.iterator();
while (it.hasNext()) {
InventoryItem item=it.next();
if (memoryPool == null) {
if (downloadData) {
getdata.addItem(item);
}
}
 else {
if (memoryPool.maybeWasSeen(item.hash)) {
it.remove();
}
 else {
log.debug(""String_Node_Str"",vAddress,item.hash);
getdata.addItem(item);
}
memoryPool.seen(item.hash,this.getAddress());
}
}
boolean pingAfterGetData=false;
lock.lock();
try {
if (blocks.size() > 0 && downloadData && blockChain != null) {
for (InventoryItem item : blocks) {
if (blockChain.isOrphan(item.hash) && downloadBlockBodies) {
blockChainDownload(blockChain.getOrphanRoot(item.hash).getHash());
}
 else {
if (!pendingBlockDownloads.contains(item.hash)) {
  if (vPeerVersionMessage.isBloomFilteringSupported() && useFilteredBlocks) {
    getdata.addItem(new InventoryItem(InventoryItem.Type.FilteredBlock,item.hash));
    pingAfterGetData=true;
  }
 else {
    getdata.addItem(item);
  }
  pendingBlockDownloads.add(item.hash);
}
}
}
}
}
  finally {
lock.unlock();
}
if (!getdata.getItems().isEmpty()) {
sendMessage(getdata);
}
if (pingAfterGetData) sendMessage(new Ping((long)(Math.random() * Long.MAX_VALUE)));
}",0.9979518689196109
85828,"private void processPong(Pong m){
  log.info(""String_Node_Str"",this,m.getNonce());
  for (  PendingPing ping : pendingPings) {
    if (m.getNonce() == ping.nonce) {
      pendingPings.remove(ping);
      ping.complete();
      return;
    }
  }
}","private void processPong(Pong m){
  for (  PendingPing ping : pendingPings) {
    if (m.getNonce() == ping.nonce) {
      pendingPings.remove(ping);
      ping.complete();
      return;
    }
  }
}",0.8893905191873589
85829,"public void run(){
  for (  GetDataRequest req : getDataFutures) {
    if (req.nonce == nonce) {
      req.future.cancel(true);
      getDataFutures.remove(req);
      break;
    }
  }
}","public void run(){
  for (  GetDataRequest req : getDataFutures) {
    if (req.nonce == nonce) {
      log.info(""String_Node_Str"",this,req.hash);
      req.future.cancel(true);
      getDataFutures.remove(req);
    }
  }
}",0.7450980392156863
85830,"private ListenableFuture<Object> downloadDependenciesInternal(final Transaction tx,final Object marker,final List<Transaction> results){
  final SettableFuture<Object> resultFuture=SettableFuture.create();
  final Sha256Hash rootTxHash=tx.getHash();
  Set<Transaction> dependencies=new CopyOnWriteArraySet<Transaction>();
  Set<Sha256Hash> needToRequest=new CopyOnWriteArraySet<Sha256Hash>();
  for (  TransactionInput input : tx.getInputs()) {
    Sha256Hash hash=input.getOutpoint().getHash();
    Transaction dep=memoryPool.get(hash);
    if (dep == null) {
      needToRequest.add(hash);
    }
 else {
      dependencies.add(dep);
    }
  }
  results.addAll(dependencies);
  lock.lock();
  try {
    List<ListenableFuture<Transaction>> futures=Lists.newArrayList();
    GetDataMessage getdata=new GetDataMessage(params);
    final long nonce=(long)(Math.random() * Long.MAX_VALUE);
    for (    Sha256Hash hash : needToRequest) {
      getdata.addTransaction(hash);
      GetDataRequest req=new GetDataRequest();
      req.hash=hash;
      req.future=SettableFuture.create();
      if (!isNotFoundMessageSupported()) {
        req.nonce=nonce;
      }
      futures.add(req.future);
      getDataFutures.add(req);
    }
    for (    Transaction dep : dependencies) {
      futures.add(Futures.immediateFuture(dep));
    }
    ListenableFuture<List<Transaction>> successful=Futures.successfulAsList(futures);
    Futures.addCallback(successful,new FutureCallback<List<Transaction>>(){
      public void onSuccess(      List<Transaction> transactions){
        List<ListenableFuture<Object>> childFutures=Lists.newLinkedList();
        for (        Transaction tx : transactions) {
          if (tx == null)           continue;
          log.info(""String_Node_Str"",new Object[]{vAddress,rootTxHash,tx.getHashAsString()});
          results.add(tx);
          childFutures.add(downloadDependenciesInternal(tx,marker,results));
        }
        if (childFutures.size() == 0) {
          resultFuture.set(marker);
        }
 else {
          Futures.addCallback(Futures.successfulAsList(childFutures),new FutureCallback<List<Object>>(){
            public void onSuccess(            List<Object> objects){
              resultFuture.set(marker);
            }
            public void onFailure(            Throwable throwable){
              resultFuture.setException(throwable);
            }
          }
);
        }
      }
      public void onFailure(      Throwable throwable){
        resultFuture.setException(throwable);
      }
    }
);
    sendMessage(getdata);
    if (!isNotFoundMessageSupported()) {
      ping(nonce).addListener(new Runnable(){
        public void run(){
          for (          GetDataRequest req : getDataFutures) {
            if (req.nonce == nonce) {
              req.future.cancel(true);
              getDataFutures.remove(req);
              break;
            }
          }
        }
      }
,MoreExecutors.sameThreadExecutor());
    }
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",tx.getHash());
    resultFuture.setException(e);
    return resultFuture;
  }
 finally {
    lock.unlock();
  }
  return resultFuture;
}","private ListenableFuture<Object> downloadDependenciesInternal(final Transaction tx,final Object marker,final List<Transaction> results){
  final SettableFuture<Object> resultFuture=SettableFuture.create();
  final Sha256Hash rootTxHash=tx.getHash();
  Set<Transaction> dependencies=new CopyOnWriteArraySet<Transaction>();
  Set<Sha256Hash> needToRequest=new CopyOnWriteArraySet<Sha256Hash>();
  for (  TransactionInput input : tx.getInputs()) {
    Sha256Hash hash=input.getOutpoint().getHash();
    Transaction dep=memoryPool.get(hash);
    if (dep == null) {
      needToRequest.add(hash);
    }
 else {
      dependencies.add(dep);
    }
  }
  results.addAll(dependencies);
  lock.lock();
  try {
    List<ListenableFuture<Transaction>> futures=Lists.newArrayList();
    GetDataMessage getdata=new GetDataMessage(params);
    final long nonce=(long)(Math.random() * Long.MAX_VALUE);
    if (needToRequest.size() > 1)     log.info(""String_Node_Str"",needToRequest.size());
    for (    Sha256Hash hash : needToRequest) {
      getdata.addTransaction(hash);
      GetDataRequest req=new GetDataRequest();
      req.hash=hash;
      req.future=SettableFuture.create();
      if (!isNotFoundMessageSupported()) {
        req.nonce=nonce;
      }
      futures.add(req.future);
      getDataFutures.add(req);
    }
    for (    Transaction dep : dependencies) {
      futures.add(Futures.immediateFuture(dep));
    }
    ListenableFuture<List<Transaction>> successful=Futures.successfulAsList(futures);
    Futures.addCallback(successful,new FutureCallback<List<Transaction>>(){
      public void onSuccess(      List<Transaction> transactions){
        List<ListenableFuture<Object>> childFutures=Lists.newLinkedList();
        for (        Transaction tx : transactions) {
          if (tx == null)           continue;
          log.info(""String_Node_Str"",new Object[]{vAddress,rootTxHash,tx.getHashAsString()});
          results.add(tx);
          childFutures.add(downloadDependenciesInternal(tx,marker,results));
        }
        if (childFutures.size() == 0) {
          resultFuture.set(marker);
        }
 else {
          Futures.addCallback(Futures.successfulAsList(childFutures),new FutureCallback<List<Object>>(){
            public void onSuccess(            List<Object> objects){
              resultFuture.set(marker);
            }
            public void onFailure(            Throwable throwable){
              resultFuture.setException(throwable);
            }
          }
);
        }
      }
      public void onFailure(      Throwable throwable){
        resultFuture.setException(throwable);
      }
    }
);
    sendMessage(getdata);
    if (!isNotFoundMessageSupported()) {
      log.info(""String_Node_Str"",this,nonce);
      ping(nonce).addListener(new Runnable(){
        public void run(){
          for (          GetDataRequest req : getDataFutures) {
            if (req.nonce == nonce) {
              log.info(""String_Node_Str"",this,req.hash);
              req.future.cancel(true);
              getDataFutures.remove(req);
            }
          }
        }
      }
,MoreExecutors.sameThreadExecutor());
    }
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",this,tx.getHash());
    resultFuture.setException(e);
    return resultFuture;
  }
 finally {
    lock.unlock();
  }
  return resultFuture;
}",0.8383141762452108
85831,"private void processNotFoundMessage(NotFoundMessage m){
  for (  GetDataRequest req : getDataFutures) {
    for (    InventoryItem item : m.getItems()) {
      if (item.hash.equals(req.hash)) {
        req.future.cancel(true);
        getDataFutures.remove(req);
        break;
      }
    }
  }
}","private void processNotFoundMessage(NotFoundMessage m){
  for (  GetDataRequest req : getDataFutures) {
    for (    InventoryItem item : m.getItems()) {
      if (item.hash.equals(req.hash)) {
        log.info(""String_Node_Str"",this,req.hash);
        req.future.cancel(true);
        getDataFutures.remove(req);
        break;
      }
    }
  }
}",0.9209302325581395
85832,"@Override public String toString(){
  PeerAddress addr=vAddress;
  if (addr == null) {
    return ""String_Node_Str"";
  }
 else {
    return ""String_Node_Str"" + addr.getAddr() + ""String_Node_Str""+ addr.getPort()+ ""String_Node_Str"";
  }
}","@Override public String toString(){
  PeerAddress addr=vAddress;
  if (addr == null) {
    return ""String_Node_Str"";
  }
 else {
    return addr.toString();
  }
}",0.7788944723618091
85833,"private void checkTimeLockedDependency(boolean shouldAccept) throws Exception {
  control.replay();
  connect();
  ECKey key=new ECKey();
  Wallet wallet=new Wallet(unitTestParams);
  wallet.addKey(key);
  wallet.setAcceptTimeLockedTransactions(shouldAccept);
  peer.addWallet(wallet);
  final Transaction[] vtx=new Transaction[1];
  wallet.addEventListener(new AbstractWalletEventListener(){
    @Override public void onCoinsReceived(    Wallet wallet,    Transaction tx,    BigInteger prevBalance,    BigInteger newBalance){
      vtx[0]=tx;
    }
  }
);
  Transaction t2=new Transaction(unitTestParams);
  t2.setLockTime(999999);
  Sha256Hash t3=Sha256Hash.create(""String_Node_Str"".getBytes(Charset.forName(""String_Node_Str"")));
  t2.addInput(new TransactionInput(unitTestParams,t2,new byte[]{},new TransactionOutPoint(unitTestParams,0,t3)));
  t2.addOutput(Utils.toNanoCoins(1,0),new ECKey());
  Transaction t1=new Transaction(unitTestParams);
  t1.addInput(t2.getOutput(0));
  t1.addOutput(Utils.toNanoCoins(1,0),key);
  InventoryMessage inv=new InventoryMessage(unitTestParams);
  inv.addTransaction(t1);
  inbound(peer,inv);
  GetDataMessage getdata=(GetDataMessage)outbound();
  assertEquals(t1.getHash(),getdata.getItems().get(0).hash);
  inbound(peer,t1);
  assertNull(vtx[0]);
  getdata=(GetDataMessage)outbound();
  assertEquals(t2.getHash(),getdata.getItems().get(0).hash);
  inbound(peer,t2);
  getdata=(GetDataMessage)outbound();
  assertEquals(t3,getdata.getItems().get(0).hash);
  NotFoundMessage notFound=new NotFoundMessage(unitTestParams);
  notFound.addItem(new InventoryItem(InventoryItem.Type.Transaction,t3));
  inbound(peer,notFound);
  if (shouldAccept)   assertNotNull(vtx[0]);
 else   assertNull(vtx[0]);
}","private void checkTimeLockedDependency(boolean shouldAccept,boolean useNotFound) throws Exception {
  control.replay();
  connectWithVersion(useNotFound ? 70001 : 60001);
  ECKey key=new ECKey();
  Wallet wallet=new Wallet(unitTestParams);
  wallet.addKey(key);
  wallet.setAcceptTimeLockedTransactions(shouldAccept);
  peer.addWallet(wallet);
  final Transaction[] vtx=new Transaction[1];
  wallet.addEventListener(new AbstractWalletEventListener(){
    @Override public void onCoinsReceived(    Wallet wallet,    Transaction tx,    BigInteger prevBalance,    BigInteger newBalance){
      vtx[0]=tx;
    }
  }
);
  Transaction t2=new Transaction(unitTestParams);
  t2.setLockTime(999999);
  Sha256Hash t3=Sha256Hash.create(""String_Node_Str"".getBytes(Charset.forName(""String_Node_Str"")));
  t2.addInput(new TransactionInput(unitTestParams,t2,new byte[]{},new TransactionOutPoint(unitTestParams,0,t3)));
  t2.addOutput(Utils.toNanoCoins(1,0),new ECKey());
  Transaction t1=new Transaction(unitTestParams);
  t1.addInput(t2.getOutput(0));
  t1.addOutput(Utils.toNanoCoins(1,0),key);
  InventoryMessage inv=new InventoryMessage(unitTestParams);
  inv.addTransaction(t1);
  inbound(peer,inv);
  GetDataMessage getdata=(GetDataMessage)outbound();
  assertEquals(t1.getHash(),getdata.getItems().get(0).hash);
  inbound(peer,t1);
  assertNull(vtx[0]);
  getdata=(GetDataMessage)outbound();
  assertEquals(t2.getHash(),getdata.getItems().get(0).hash);
  inbound(peer,t2);
  if (!useNotFound)   bouncePing();
  getdata=(GetDataMessage)outbound();
  assertEquals(t3,getdata.getItems().get(0).hash);
  if (useNotFound) {
    NotFoundMessage notFound=new NotFoundMessage(unitTestParams);
    notFound.addItem(new InventoryItem(InventoryItem.Type.Transaction,t3));
    inbound(peer,notFound);
  }
 else {
    bouncePing();
  }
  if (shouldAccept)   assertNotNull(vtx[0]);
 else   assertNull(vtx[0]);
}",0.9566657466188242
85834,"@Test public void timeLockedTransaction() throws Exception {
  control.replay();
  connect();
  ECKey key=new ECKey();
  Wallet wallet=new Wallet(unitTestParams);
  wallet.addKey(key);
  peer.addWallet(wallet);
  final Transaction[] vtx=new Transaction[1];
  wallet.addEventListener(new AbstractWalletEventListener(){
    @Override public void onCoinsReceived(    Wallet wallet,    Transaction tx,    BigInteger prevBalance,    BigInteger newBalance){
      vtx[0]=tx;
    }
  }
);
  Transaction t1=TestUtils.createFakeTx(unitTestParams,Utils.toNanoCoins(1,0),key);
  inbound(peer,t1);
  GetDataMessage getdata=(GetDataMessage)outbound();
  inbound(peer,new NotFoundMessage(unitTestParams,getdata.getItems()));
  assertNotNull(vtx[0]);
  vtx[0]=null;
  Transaction t2=TestUtils.createFakeTx(unitTestParams,Utils.toNanoCoins(2,0),key);
  t2.setLockTime(999999);
  inbound(peer,t2);
  assertNull(vtx[0]);
  wallet.setAcceptTimeLockedTransactions(true);
  inbound(peer,t2);
  getdata=(GetDataMessage)outbound();
  inbound(peer,new NotFoundMessage(unitTestParams,getdata.getItems()));
  assertEquals(t2,vtx[0]);
}","public void timeLockedTransaction(boolean useNotFound) throws Exception {
  control.replay();
  connectWithVersion(useNotFound ? 70001 : 60001);
  ECKey key=new ECKey();
  Wallet wallet=new Wallet(unitTestParams);
  wallet.addKey(key);
  peer.addWallet(wallet);
  final Transaction[] vtx=new Transaction[1];
  wallet.addEventListener(new AbstractWalletEventListener(){
    @Override public void onCoinsReceived(    Wallet wallet,    Transaction tx,    BigInteger prevBalance,    BigInteger newBalance){
      vtx[0]=tx;
    }
  }
);
  Transaction t1=TestUtils.createFakeTx(unitTestParams,Utils.toNanoCoins(1,0),key);
  inbound(peer,t1);
  GetDataMessage getdata=(GetDataMessage)outbound();
  if (useNotFound) {
    inbound(peer,new NotFoundMessage(unitTestParams,getdata.getItems()));
  }
 else {
    bouncePing();
  }
  assertNotNull(vtx[0]);
  vtx[0]=null;
  Transaction t2=TestUtils.createFakeTx(unitTestParams,Utils.toNanoCoins(2,0),key);
  t2.setLockTime(999999);
  inbound(peer,t2);
  assertNull(vtx[0]);
  wallet.setAcceptTimeLockedTransactions(true);
  inbound(peer,t2);
  getdata=(GetDataMessage)outbound();
  if (useNotFound) {
    inbound(peer,new NotFoundMessage(unitTestParams,getdata.getItems()));
  }
 else {
    bouncePing();
  }
  assertEquals(t2,vtx[0]);
}",0.9248845992446496
85835,"private void connect(PeerHandler handler,Channel channel,ChannelHandlerContext ctx) throws Exception {
  handler.connectRequested(ctx,new UpstreamChannelStateEvent(channel,ChannelState.CONNECTED,socketAddress));
  VersionMessage peerVersion=new VersionMessage(unitTestParams,OTHER_PEER_CHAIN_HEIGHT);
  peerVersion.clientVersion=70001;
  DownstreamMessageEvent versionEvent=new DownstreamMessageEvent(channel,Channels.future(channel),peerVersion,null);
  handler.messageReceived(ctx,versionEvent);
}","private void connect(PeerHandler handler,Channel channel,ChannelHandlerContext ctx,int version) throws Exception {
  handler.connectRequested(ctx,new UpstreamChannelStateEvent(channel,ChannelState.CONNECTED,socketAddress));
  VersionMessage peerVersion=new VersionMessage(unitTestParams,OTHER_PEER_CHAIN_HEIGHT);
  peerVersion.clientVersion=version;
  DownstreamMessageEvent versionEvent=new DownstreamMessageEvent(channel,Channels.future(channel),peerVersion,null);
  handler.messageReceived(ctx,versionEvent);
}",0.9762845849802372
85836,"@Test public void invDownloadTxMultiPeer() throws Exception {
  ChannelHandlerContext ctx2=createChannelHandlerContext();
  Channel channel2=createChannel();
  createPipeline(channel2);
  control.replay();
  MockNetworkConnection conn2=createMockNetworkConnection();
  VersionMessage ver=new VersionMessage(unitTestParams,100);
  Peer peer2=new Peer(unitTestParams,blockChain,ver,memoryPool);
  peer2.addWallet(wallet);
  connect();
  connect(peer2.getHandler(),channel2,ctx2);
  BigInteger value=Utils.toNanoCoins(1,0);
  Transaction tx=createFakeTx(unitTestParams,value,address);
  InventoryMessage inv=new InventoryMessage(unitTestParams);
  InventoryItem item=new InventoryItem(InventoryItem.Type.Transaction,tx.getHash());
  inv.addItem(item);
  inbound(peer,inv);
  GetDataMessage message=(GetDataMessage)outbound();
  assertEquals(1,message.getItems().size());
  assertEquals(tx.getHash(),message.getItems().get(0).hash);
  assertTrue(memoryPool.maybeWasSeen(tx.getHash()));
  conn2.inbound(inv);
  assertFalse(event.hasCaptured());
}","@Test public void invDownloadTxMultiPeer() throws Exception {
  ChannelHandlerContext ctx2=createChannelHandlerContext();
  Channel channel2=createChannel();
  createPipeline(channel2);
  control.replay();
  MockNetworkConnection conn2=createMockNetworkConnection();
  VersionMessage ver=new VersionMessage(unitTestParams,100);
  Peer peer2=new Peer(unitTestParams,blockChain,ver,memoryPool);
  peer2.addWallet(wallet);
  connect();
  connect(peer2.getHandler(),channel2,ctx2,70001);
  BigInteger value=Utils.toNanoCoins(1,0);
  Transaction tx=createFakeTx(unitTestParams,value,address);
  InventoryMessage inv=new InventoryMessage(unitTestParams);
  InventoryItem item=new InventoryItem(InventoryItem.Type.Transaction,tx.getHash());
  inv.addItem(item);
  inbound(peer,inv);
  GetDataMessage message=(GetDataMessage)outbound();
  assertEquals(1,message.getItems().size());
  assertEquals(tx.getHash(),message.getItems().get(0).hash);
  assertTrue(memoryPool.maybeWasSeen(tx.getHash()));
  conn2.inbound(inv);
  assertFalse(event.hasCaptured());
}",0.9971264367816092
85837,"@Test public void recursiveDownload() throws Exception {
  ECKey to=new ECKey();
  control.replay();
  connect();
  final Transaction[] onTx=new Transaction[1];
  peer.addEventListener(new AbstractPeerEventListener(){
    @Override public void onTransaction(    Peer peer1,    Transaction t){
      onTx[0]=t;
    }
  }
);
  Transaction t2=TestUtils.createFakeTx(unitTestParams,Utils.toNanoCoins(1,0),to);
  Sha256Hash t5=t2.getInput(0).getOutpoint().getHash();
  Transaction t4=TestUtils.createFakeTx(unitTestParams,Utils.toNanoCoins(1,0),new ECKey());
  Sha256Hash t6=t4.getInput(0).getOutpoint().getHash();
  t4.addOutput(Utils.toNanoCoins(1,0),new ECKey());
  Transaction t3=new Transaction(unitTestParams);
  t3.addInput(t4.getOutput(0));
  t3.addOutput(Utils.toNanoCoins(1,0),new ECKey());
  Transaction t1=new Transaction(unitTestParams);
  t1.addInput(t2.getOutput(0));
  t1.addInput(t3.getOutput(0));
  t1.addOutput(Utils.toNanoCoins(1,0),to);
  t1=TestUtils.roundTripTransaction(unitTestParams,t1);
  t2=TestUtils.roundTripTransaction(unitTestParams,t2);
  t3=TestUtils.roundTripTransaction(unitTestParams,t3);
  t4=TestUtils.roundTripTransaction(unitTestParams,t4);
  InventoryMessage inv=new InventoryMessage(unitTestParams);
  inv.addTransaction(t1);
  inbound(peer,inv);
  GetDataMessage getdata=(GetDataMessage)outbound();
  assertEquals(t1.getHash(),getdata.getItems().get(0).hash);
  inbound(peer,t1);
  assertEquals(t1,onTx[0]);
  ListenableFuture<List<Transaction>> futures=peer.downloadDependencies(t1);
  assertFalse(futures.isDone());
  getdata=(GetDataMessage)outbound();
  assertEquals(t2.getHash(),getdata.getItems().get(0).hash);
  assertEquals(t3.getHash(),getdata.getItems().get(1).hash);
  inbound(peer,t4);
  inbound(peer,t2);
  inbound(peer,t3);
  assertFalse(futures.isDone());
  getdata=(GetDataMessage)outbound();
  assertEquals(getdata.getItems().get(0).hash,t2.getInput(0).getOutpoint().getHash());
  NotFoundMessage notFound=new NotFoundMessage(unitTestParams);
  notFound.addItem(new InventoryItem(InventoryItem.Type.Transaction,t5));
  inbound(peer,notFound);
  assertFalse(futures.isDone());
  getdata=(GetDataMessage)outbound();
  assertEquals(t6,getdata.getItems().get(0).hash);
  notFound=new NotFoundMessage(unitTestParams);
  notFound.addItem(new InventoryItem(InventoryItem.Type.Transaction,t6));
  inbound(peer,notFound);
  assertTrue(futures.isDone());
  List<Transaction> results=futures.get();
  assertTrue(results.contains(t2));
  assertTrue(results.contains(t3));
  assertTrue(results.contains(t4));
}","public void recursiveDownload(boolean useNotFound) throws Exception {
  control.replay();
  connectWithVersion(useNotFound ? 70001 : 60001);
  ECKey to=new ECKey();
  final Transaction[] onTx=new Transaction[1];
  peer.addEventListener(new AbstractPeerEventListener(){
    @Override public void onTransaction(    Peer peer1,    Transaction t){
      onTx[0]=t;
    }
  }
);
  Transaction t2=TestUtils.createFakeTx(unitTestParams,Utils.toNanoCoins(1,0),to);
  Sha256Hash t5=t2.getInput(0).getOutpoint().getHash();
  Transaction t4=TestUtils.createFakeTx(unitTestParams,Utils.toNanoCoins(1,0),new ECKey());
  Sha256Hash t6=t4.getInput(0).getOutpoint().getHash();
  t4.addOutput(Utils.toNanoCoins(1,0),new ECKey());
  Transaction t3=new Transaction(unitTestParams);
  t3.addInput(t4.getOutput(0));
  t3.addOutput(Utils.toNanoCoins(1,0),new ECKey());
  Transaction t1=new Transaction(unitTestParams);
  t1.addInput(t2.getOutput(0));
  t1.addInput(t3.getOutput(0));
  Sha256Hash someHash=new Sha256Hash(""String_Node_Str"");
  t1.addInput(new TransactionInput(unitTestParams,t1,new byte[]{},new TransactionOutPoint(unitTestParams,0,someHash)));
  Sha256Hash anotherHash=new Sha256Hash(""String_Node_Str"");
  t1.addInput(new TransactionInput(unitTestParams,t1,new byte[]{},new TransactionOutPoint(unitTestParams,1,anotherHash)));
  t1.addOutput(Utils.toNanoCoins(1,0),to);
  t1=TestUtils.roundTripTransaction(unitTestParams,t1);
  t2=TestUtils.roundTripTransaction(unitTestParams,t2);
  t3=TestUtils.roundTripTransaction(unitTestParams,t3);
  t4=TestUtils.roundTripTransaction(unitTestParams,t4);
  InventoryMessage inv=new InventoryMessage(unitTestParams);
  inv.addTransaction(t1);
  inbound(peer,inv);
  GetDataMessage getdata=(GetDataMessage)outbound();
  assertEquals(t1.getHash(),getdata.getItems().get(0).hash);
  inbound(peer,t1);
  assertEquals(t1,onTx[0]);
  ListenableFuture<List<Transaction>> futures=peer.downloadDependencies(t1);
  assertFalse(futures.isDone());
  getdata=(GetDataMessage)outbound();
  assertEquals(4,getdata.getItems().size());
  assertEquals(t2.getHash(),getdata.getItems().get(0).hash);
  assertEquals(t3.getHash(),getdata.getItems().get(1).hash);
  assertEquals(someHash,getdata.getItems().get(2).hash);
  assertEquals(anotherHash,getdata.getItems().get(3).hash);
  long nonce=-1;
  if (!useNotFound)   nonce=((Ping)outbound()).getNonce();
  inbound(peer,t4);
  inbound(peer,t2);
  inbound(peer,t3);
  if (useNotFound) {
    NotFoundMessage notFound=new NotFoundMessage(unitTestParams);
    notFound.addItem(new InventoryItem(InventoryItem.Type.Transaction,someHash));
    notFound.addItem(new InventoryItem(InventoryItem.Type.Transaction,anotherHash));
    inbound(peer,notFound);
  }
 else {
    inbound(peer,new Pong(nonce));
  }
  assertFalse(futures.isDone());
  getdata=(GetDataMessage)outbound();
  assertEquals(getdata.getItems().get(0).hash,t2.getInput(0).getOutpoint().getHash());
  if (useNotFound) {
    NotFoundMessage notFound=new NotFoundMessage(unitTestParams);
    notFound.addItem(new InventoryItem(InventoryItem.Type.Transaction,t5));
    inbound(peer,notFound);
  }
 else {
    bouncePing();
  }
  assertFalse(futures.isDone());
  getdata=(GetDataMessage)outbound();
  assertEquals(t6,getdata.getItems().get(0).hash);
  if (useNotFound) {
    NotFoundMessage notFound=new NotFoundMessage(unitTestParams);
    notFound.addItem(new InventoryItem(InventoryItem.Type.Transaction,t6));
    inbound(peer,notFound);
  }
 else {
    bouncePing();
  }
  assertTrue(futures.isDone());
  List<Transaction> results=futures.get();
  assertTrue(results.contains(t2));
  assertTrue(results.contains(t3));
  assertTrue(results.contains(t4));
}",0.6543527144233858
85838,"private void processPong(Pong m){
  PendingPing ping=null;
  for (  PendingPing pendingPing : pendingPings) {
    ping=pendingPing;
    if (m.getNonce() == ping.nonce) {
      pendingPings.remove(ping);
      break;
    }
  }
  if (ping != null)   ping.complete();
}","private void processPong(Pong m){
  log.info(""String_Node_Str"",this,m.getNonce());
  for (  PendingPing ping : pendingPings) {
    if (m.getNonce() == ping.nonce) {
      pendingPings.remove(ping);
      ping.complete();
      return;
    }
  }
}",0.58984375
85839,"public void complete(){
  Preconditions.checkNotNull(future,""String_Node_Str"");
  Long elapsed=Utils.now().getTime() - startTimeMsec;
  Peer.this.addPingTimeData(elapsed);
  log.debug(""String_Node_Str"",Peer.this.toString(),elapsed);
  future.set(elapsed);
  future=null;
}","public void complete(){
  checkNotNull(future,""String_Node_Str"");
  Long elapsed=Utils.now().getTime() - startTimeMsec;
  Peer.this.addPingTimeData(elapsed);
  log.debug(""String_Node_Str"",Peer.this.toString(),elapsed);
  future.set(elapsed);
  future=null;
}",0.9735849056603774
85840,"@Test public void pingPong() throws Exception {
  control.replay();
  connect();
  Utils.rollMockClock(0);
  assertEquals(Long.MAX_VALUE,peer.getLastPingTime());
  assertEquals(Long.MAX_VALUE,peer.getPingTime());
  ListenableFuture<Long> future=peer.ping();
  Ping pingMsg=(Ping)outbound();
  assertEquals(Long.MAX_VALUE,peer.getLastPingTime());
  assertEquals(Long.MAX_VALUE,peer.getPingTime());
  assertFalse(future.isDone());
  Utils.rollMockClock(5);
  inbound(peer,new Pong(pingMsg.getNonce()));
  assertTrue(future.isDone());
  long elapsed=future.get();
  assertTrue(""String_Node_Str"" + elapsed,elapsed > 1000);
  assertEquals(elapsed,peer.getLastPingTime());
  assertEquals(elapsed,peer.getPingTime());
  future=peer.ping();
  outbound();
  Utils.rollMockClock(50);
  inbound(peer,new Pong(pingMsg.getNonce()));
  elapsed=future.get();
  assertEquals(elapsed,peer.getLastPingTime());
  assertEquals(7250,peer.getPingTime());
}","@Test public void pingPong() throws Exception {
  control.replay();
  connect();
  Utils.rollMockClock(0);
  assertEquals(Long.MAX_VALUE,peer.getLastPingTime());
  assertEquals(Long.MAX_VALUE,peer.getPingTime());
  ListenableFuture<Long> future=peer.ping();
  Ping pingMsg=(Ping)outbound();
  assertEquals(Long.MAX_VALUE,peer.getLastPingTime());
  assertEquals(Long.MAX_VALUE,peer.getPingTime());
  assertFalse(future.isDone());
  Utils.rollMockClock(5);
  inbound(peer,new Pong(pingMsg.getNonce()));
  assertTrue(future.isDone());
  long elapsed=future.get();
  assertTrue(""String_Node_Str"" + elapsed,elapsed > 1000);
  assertEquals(elapsed,peer.getLastPingTime());
  assertEquals(elapsed,peer.getPingTime());
  future=peer.ping();
  pingMsg=(Ping)outbound();
  Utils.rollMockClock(50);
  inbound(peer,new Pong(pingMsg.getNonce()));
  elapsed=future.get();
  assertEquals(elapsed,peer.getLastPingTime());
  assertEquals(7250,peer.getPingTime());
}",0.9925611052072264
85841,"private void setupPingingForNewPeer(final Peer peer){
  if (peer.getPeerVersionMessage().clientVersion < Pong.MIN_PROTOCOL_VERSION)   return;
  if (getPingIntervalMsec() <= 0)   return;
  new Runnable(){
    private boolean firstRun=true;
    public void run(){
      if (firstRun) {
        firstRun=false;
        try {
          peer.ping().addListener(this,MoreExecutors.sameThreadExecutor());
        }
 catch (        Exception e) {
          log.warn(""String_Node_Str"",peer,e.toString());
          return;
        }
        return;
      }
      final long interval=getPingIntervalMsec();
      if (interval <= 0)       return;
      pingTimer.schedule(new TimerTask(){
        @Override public void run(){
          try {
            if (!peers.contains(peer) || !PeerGroup.this.isRunning())             return;
            peer.ping().addListener(this,MoreExecutors.sameThreadExecutor());
          }
 catch (          Exception e) {
            log.warn(""String_Node_Str"",peer,e.toString());
          }
        }
      }
,interval);
    }
  }
.run();
}","private void setupPingingForNewPeer(final Peer peer){
  if (peer.getPeerVersionMessage().clientVersion < Pong.MIN_PROTOCOL_VERSION)   return;
  if (getPingIntervalMsec() <= 0)   return;
  final Runnable[] pingRunnable=new Runnable[1];
  pingRunnable[0]=new Runnable(){
    private boolean firstRun=true;
    public void run(){
      if (firstRun) {
        firstRun=false;
        try {
          peer.ping().addListener(this,MoreExecutors.sameThreadExecutor());
        }
 catch (        Exception e) {
          log.warn(""String_Node_Str"",peer,e.toString());
          return;
        }
        return;
      }
      final long interval=getPingIntervalMsec();
      if (interval <= 0)       return;
      pingTimer.schedule(new TimerTask(){
        @Override public void run(){
          try {
            if (!peers.contains(peer) || !PeerGroup.this.isRunning())             return;
            peer.ping().addListener(pingRunnable[0],MoreExecutors.sameThreadExecutor());
          }
 catch (          Exception e) {
            log.warn(""String_Node_Str"",peer,e.toString());
          }
        }
      }
,interval);
    }
  }
;
  pingRunnable[0].run();
}",0.9536662168241116
85842,"public static void write(FileChannel channel,StoredBlock block) throws IOException {
  ByteBuffer buf=ByteBuffer.allocate(Record.SIZE);
  buf.putInt(block.getHeight());
  byte[] chainWorkBytes=block.getChainWork().toByteArray();
  checkState(chainWorkBytes.length <= CHAIN_WORK_BYTES,""String_Node_Str"");
  if (chainWorkBytes.length < CHAIN_WORK_BYTES) {
    buf.put(EMPTY_BYTES,0,CHAIN_WORK_BYTES - chainWorkBytes.length);
  }
  buf.put(chainWorkBytes);
  buf.put(block.getHeader().bitcoinSerialize());
  buf.position(0);
  channel.position(channel.size());
  if (channel.write(buf) < Record.SIZE)   throw new IOException(""String_Node_Str"");
  channel.position(channel.size() - Record.SIZE);
}","public static void write(FileChannel channel,StoredBlock block) throws IOException {
  ByteBuffer buf=ByteBuffer.allocate(Record.SIZE);
  buf.putInt(block.getHeight());
  byte[] chainWorkBytes=block.getChainWork().toByteArray();
  checkState(chainWorkBytes.length <= CHAIN_WORK_BYTES,""String_Node_Str"");
  if (chainWorkBytes.length < CHAIN_WORK_BYTES) {
    buf.put(EMPTY_BYTES,0,CHAIN_WORK_BYTES - chainWorkBytes.length);
  }
  buf.put(chainWorkBytes);
  buf.put(block.getHeader().cloneAsHeader().bitcoinSerialize());
  buf.position(0);
  channel.position(channel.size());
  if (channel.write(buf) < Record.SIZE)   throw new IOException(""String_Node_Str"");
  channel.position(channel.size() - Record.SIZE);
}",0.9885877318116976
85843,"/** 
 * Returns the number of peers that have seen the given hash recently.
 */
public synchronized int numBroadcastPeers(Sha256Hash txHash){
  cleanPool();
  Entry entry=memoryPool.get(txHash);
  if (entry == null) {
    return 0;
  }
 else   if (entry.tx == null) {
    Preconditions.checkNotNull(entry.addresses);
    return entry.addresses.size();
  }
 else   if (entry.tx.get() == null) {
    memoryPool.remove(txHash);
    return 0;
  }
 else {
    Preconditions.checkState(entry.addresses == null);
    return entry.tx.get().getConfidence().numBroadcastPeers();
  }
}","/** 
 * Returns the number of peers that have seen the given hash recently.
 */
public synchronized int numBroadcastPeers(Sha256Hash txHash){
  cleanPool();
  Entry entry=memoryPool.get(txHash);
  if (entry == null) {
    return 0;
  }
 else   if (entry.tx == null) {
    Preconditions.checkNotNull(entry.addresses);
    return entry.addresses.size();
  }
 else {
    final Transaction tx=entry.tx.get();
    if (tx == null) {
      memoryPool.remove(txHash);
      return 0;
    }
 else {
      Preconditions.checkState(entry.addresses == null);
      return tx.getConfidence().numBroadcastPeers();
    }
  }
}",0.9282700421940928
85844,"public boolean hasUnspentOutputs(Sha256Hash hash,int numOutputs) throws BlockStoreException {
  for (int i=0; i < numOutputs; i++)   if (getTransactionOutput(hash,i) != null)   return true;
  return false;
}","public synchronized boolean hasUnspentOutputs(Sha256Hash hash,int numOutputs) throws BlockStoreException {
  for (int i=0; i < numOutputs; i++)   if (getTransactionOutput(hash,i) != null)   return true;
  return false;
}",0.9695550351288056
85845,"public StoredBlock getVerifiedChainHead() throws BlockStoreException {
  Preconditions.checkNotNull(blockMap,""String_Node_Str"");
  return verifiedChainHead;
}","public synchronized StoredBlock getVerifiedChainHead() throws BlockStoreException {
  Preconditions.checkNotNull(blockMap,""String_Node_Str"");
  return verifiedChainHead;
}",0.96048632218845
85846,"public void setVerifiedChainHead(StoredBlock chainHead) throws BlockStoreException {
  Preconditions.checkNotNull(blockMap,""String_Node_Str"");
  this.verifiedChainHead=chainHead;
  if (this.chainHead.getHeight() < chainHead.getHeight())   setChainHead(chainHead);
  fullBlockMap.removeByMultiKey(chainHead.getHeight() - fullStoreDepth);
}","public synchronized void setVerifiedChainHead(StoredBlock chainHead) throws BlockStoreException {
  Preconditions.checkNotNull(blockMap,""String_Node_Str"");
  this.verifiedChainHead=chainHead;
  if (this.chainHead.getHeight() < chainHead.getHeight())   setChainHead(chainHead);
  fullBlockMap.removeByMultiKey(chainHead.getHeight() - fullStoreDepth);
}",0.981132075471698
85847,"public StoredBlock getChainHead() throws BlockStoreException {
  Preconditions.checkNotNull(blockMap,""String_Node_Str"");
  return chainHead;
}","public synchronized StoredBlock getChainHead() throws BlockStoreException {
  Preconditions.checkNotNull(blockMap,""String_Node_Str"");
  return chainHead;
}",0.9562289562289562
85848,"public StoredBlock getOnceUndoableStoredBlock(Sha256Hash hash) throws BlockStoreException {
  Preconditions.checkNotNull(blockMap,""String_Node_Str"");
  StoredBlockAndWasUndoableFlag storedBlock=blockMap.get(hash);
  return (storedBlock != null && storedBlock.wasUndoable) ? storedBlock.block : null;
}","public synchronized StoredBlock getOnceUndoableStoredBlock(Sha256Hash hash) throws BlockStoreException {
  Preconditions.checkNotNull(blockMap,""String_Node_Str"");
  StoredBlockAndWasUndoableFlag storedBlock=blockMap.get(hash);
  return (storedBlock != null && storedBlock.wasUndoable) ? storedBlock.block : null;
}",0.9788617886178862
85849,"@Test public void testFinalizedBlocks() throws Exception {
  ECKey outKey=new ECKey();
  Block rollingBlock=unitTestParams.genesisBlock.createNextBlockWithCoinbase(outKey.getPubKey());
  chain.add(rollingBlock);
  TransactionOutPoint spendableOutput=new TransactionOutPoint(unitTestParams,0,rollingBlock.getTransactions().get(0).getHash());
  byte[] spendableOutputScriptPubKey=rollingBlock.getTransactions().get(0).getOutputs().get(0).getScriptBytes();
  for (int i=1; i < unitTestParams.getSpendableCoinbaseDepth(); i++) {
    rollingBlock=rollingBlock.createNextBlockWithCoinbase(outKey.getPubKey());
    chain.add(rollingBlock);
  }
  WeakReference<StoredTransactionOutput> out=new WeakReference<StoredTransactionOutput>(store.getTransactionOutput(spendableOutput.getHash(),spendableOutput.getIndex()));
  rollingBlock=rollingBlock.createNextBlock(null);
  Transaction t=new Transaction(unitTestParams);
  t.addOutput(new TransactionOutput(unitTestParams,t,Utils.toNanoCoins(50,0),new byte[]{}));
  addInputToTransaction(t,spendableOutput,spendableOutputScriptPubKey,outKey);
  rollingBlock.addTransaction(t);
  rollingBlock.solve();
  chain.add(rollingBlock);
  WeakReference<StoredUndoableBlock> undoBlock=new WeakReference<StoredUndoableBlock>(store.getUndoBlock(rollingBlock.getHash()));
  assertTrue(undoBlock.get() != null);
  assertTrue(undoBlock.get().getTransactions() == null);
  WeakReference<TransactionOutputChanges> changes=new WeakReference<TransactionOutputChanges>(undoBlock.get().getTxOutChanges());
  assertTrue(changes.get() != null);
  for (int i=0; i < UNDOABLE_BLOCKS_STORED; i++) {
    rollingBlock=rollingBlock.createNextBlock(null);
    chain.add(rollingBlock);
  }
  System.gc();
  assertTrue(undoBlock.get() == null);
  assertTrue(changes.get() == null);
  assertTrue(out.get() == null);
}","@Test public void testFinalizedBlocks() throws Exception {
  ECKey outKey=new ECKey();
  Block rollingBlock=unitTestParams.genesisBlock.createNextBlockWithCoinbase(outKey.getPubKey());
  chain.add(rollingBlock);
  TransactionOutPoint spendableOutput=new TransactionOutPoint(unitTestParams,0,rollingBlock.getTransactions().get(0).getHash());
  byte[] spendableOutputScriptPubKey=rollingBlock.getTransactions().get(0).getOutputs().get(0).getScriptBytes();
  for (int i=1; i < unitTestParams.getSpendableCoinbaseDepth(); i++) {
    rollingBlock=rollingBlock.createNextBlockWithCoinbase(outKey.getPubKey());
    chain.add(rollingBlock);
  }
  WeakReference<StoredTransactionOutput> out=new WeakReference<StoredTransactionOutput>(store.getTransactionOutput(spendableOutput.getHash(),spendableOutput.getIndex()));
  rollingBlock=rollingBlock.createNextBlock(null);
  Transaction t=new Transaction(unitTestParams);
  t.addOutput(new TransactionOutput(unitTestParams,t,Utils.toNanoCoins(50,0),new byte[]{}));
  addInputToTransaction(t,spendableOutput,spendableOutputScriptPubKey,outKey);
  rollingBlock.addTransaction(t);
  rollingBlock.solve();
  chain.add(rollingBlock);
  WeakReference<StoredUndoableBlock> undoBlock=new WeakReference<StoredUndoableBlock>(store.getUndoBlock(rollingBlock.getHash()));
  StoredUndoableBlock storedUndoableBlock=undoBlock.get();
  assertTrue(storedUndoableBlock != null);
  assertTrue(storedUndoableBlock.getTransactions() == null);
  WeakReference<TransactionOutputChanges> changes=new WeakReference<TransactionOutputChanges>(storedUndoableBlock.getTxOutChanges());
  assertTrue(changes.get() != null);
  storedUndoableBlock=null;
  for (int i=0; i < UNDOABLE_BLOCKS_STORED; i++) {
    rollingBlock=rollingBlock.createNextBlock(null);
    chain.add(rollingBlock);
  }
  System.gc();
  assertTrue(undoBlock.get() == null);
  assertTrue(changes.get() == null);
  assertTrue(out.get() == null);
}",0.9435979684576316
85850,"public VersionMessage(NetworkParameters params,int newBestHeight,boolean relayTxesBeforeFilter){
  super(params);
  clientVersion=NetworkParameters.PROTOCOL_VERSION;
  localServices=0;
  time=System.currentTimeMillis() / 1000;
  try {
    final byte[] localhost=new byte[]{127,0,0,1};
    myAddr=new PeerAddress(InetAddress.getByAddress(localhost),params.port,0);
    theirAddr=new PeerAddress(InetAddress.getByAddress(localhost),params.port,0);
  }
 catch (  UnknownHostException e) {
    throw new RuntimeException(e);
  }
  subVer=LIBRARY_SUBVER;
  bestHeight=newBestHeight;
  this.relayTxesBeforeFilter=relayTxesBeforeFilter;
  length=85;
  if (protocolVersion > 31402)   length+=8;
  length+=subVer == null ? 1 : VarInt.sizeOf(subVer.length()) + subVer.length();
}","public VersionMessage(NetworkParameters params,int newBestHeight,boolean relayTxesBeforeFilter){
  super(params);
  clientVersion=NetworkParameters.PROTOCOL_VERSION;
  localServices=0;
  time=System.currentTimeMillis() / 1000;
  try {
    final byte[] localhost=new byte[]{127,0,0,1};
    myAddr=new PeerAddress(InetAddress.getByAddress(localhost),params.port,0);
    theirAddr=new PeerAddress(InetAddress.getByAddress(localhost),params.port,0);
  }
 catch (  UnknownHostException e) {
    throw new RuntimeException(e);
  }
  subVer=LIBRARY_SUBVER;
  bestHeight=newBestHeight;
  this.relayTxesBeforeFilter=relayTxesBeforeFilter;
  length=85;
  if (protocolVersion > 31402)   length+=8;
  length+=VarInt.sizeOf(subVer.length()) + subVer.length();
}",0.950560316413975
85851,"/** 
 * <p>Constructs a new Bloom Filter which will provide approximately the given false positive rate when the given number of elements have been inserted.</p> <p>If the filter would otherwise be larger than the maximum allowed size, it will be automatically downsized to the maximum size.</p> <p>To check the theoretical false positive rate of a given filter, use   {@link BloomFilter#getFalsePositiveRate(int)}</p> <p>The anonymity of which coins are yours to any peer which you send a BloomFilter to is controlled by the false positive rate.</p> <p>For reference, as of block 187,000, the total number of addresses used in the chain was roughly 4.5 million.</p> <p>Thus, if you use a false positive rate of 0.001 (0.1%), there will be, on average, 4,500 distinct public keys/addresses which will be thought to be yours by nodes which have your bloom filter, but which are not actually yours.</p> <p>Keep in mind that a remote node can do a pretty good job estimating the order of magnitude of the false positive rate of a given filter you provide it when considering the anonymity of a given filter.</p> <p>In order for filtered block download to function efficiently, the number of matched transactions in any given block should be less than (with some headroom) the maximum size of the MemoryPool used by the Peer doing the downloading (default is   {@link MemoryPool#MAX_SIZE}). See the comment in processBlock(FilteredBlock) for more information on this restriction.</p> <p>randomNonce is a tweak for the hash function used to prevent some theoretical DoS attacks. It should be a random value, however secureness of the random value is of no great consequence.</p> <p>updateFlag is used to control filter behavior</p>
 */
public BloomFilter(int elements,double falsePositiveRate,long randomNonce,bloomUpdate updateFlag){
  int size=Math.min((int)(-1 / (Math.pow(Math.log(2),2)) * elements * Math.log(falsePositiveRate)),(int)MAX_FILTER_SIZE * 8) / 8;
  data=new byte[size <= 0 ? 1 : size];
  hashFuncs=Math.min((int)(data.length * 8 / elements * Math.log(2)),MAX_HASH_FUNCS);
  this.nTweak=randomNonce;
  this.nFlags=(byte)(0xff & updateFlag.ordinal());
}","/** 
 * <p>Constructs a new Bloom Filter which will provide approximately the given false positive rate when the given number of elements have been inserted.</p> <p>If the filter would otherwise be larger than the maximum allowed size, it will be automatically downsized to the maximum size.</p> <p>To check the theoretical false positive rate of a given filter, use   {@link BloomFilter#getFalsePositiveRate(int)}</p> <p>The anonymity of which coins are yours to any peer which you send a BloomFilter to is controlled by the false positive rate.</p> <p>For reference, as of block 187,000, the total number of addresses used in the chain was roughly 4.5 million.</p> <p>Thus, if you use a false positive rate of 0.001 (0.1%), there will be, on average, 4,500 distinct public keys/addresses which will be thought to be yours by nodes which have your bloom filter, but which are not actually yours.</p> <p>Keep in mind that a remote node can do a pretty good job estimating the order of magnitude of the false positive rate of a given filter you provide it when considering the anonymity of a given filter.</p> <p>In order for filtered block download to function efficiently, the number of matched transactions in any given block should be less than (with some headroom) the maximum size of the MemoryPool used by the Peer doing the downloading (default is   {@link MemoryPool#MAX_SIZE}). See the comment in processBlock(FilteredBlock) for more information on this restriction.</p> <p>randomNonce is a tweak for the hash function used to prevent some theoretical DoS attacks. It should be a random value, however secureness of the random value is of no great consequence.</p> <p>updateFlag is used to control filter behavior</p>
 */
public BloomFilter(int elements,double falsePositiveRate,long randomNonce,BloomUpdate updateFlag){
  int size=Math.min((int)(-1 / (Math.pow(Math.log(2),2)) * elements * Math.log(falsePositiveRate)),(int)MAX_FILTER_SIZE * 8) / 8;
  data=new byte[size <= 0 ? 1 : size];
  hashFuncs=Math.min((int)(data.length * 8 / (double)elements * Math.log(2)),MAX_HASH_FUNCS);
  this.nTweak=randomNonce;
  this.nFlags=(byte)(0xff & updateFlag.ordinal());
}",0.9976937269372692
85852,"private void createTransientState(){
  eventListeners=new ArrayList<WalletEventListener>();
  ignoreNextNewBlock=new HashSet<Sha256Hash>();
  txConfidenceListener=new TransactionConfidence.Listener(){
    public void onConfidenceChanged(    Transaction tx){
      invokeOnTransactionConfidenceChanged(tx);
      invokeOnWalletChanged();
    }
  }
;
  acceptTimeLockedTransactions=false;
}","private synchronized void createTransientState(){
  eventListeners=new ArrayList<WalletEventListener>();
  ignoreNextNewBlock=new HashSet<Sha256Hash>();
  txConfidenceListener=new TransactionConfidence.Listener(){
    public void onConfidenceChanged(    Transaction tx){
      invokeOnTransactionConfidenceChanged(tx);
      invokeOnWalletChanged();
    }
  }
;
  acceptTimeLockedTransactions=false;
}",0.9835234474017744
85853,"@Test public void insertSerializeTest(){
  BloomFilter filter=new BloomFilter(3,0.01,0,BloomFilter.bloomUpdate.UPDATE_ALL);
  filter.insert(Hex.decode(""String_Node_Str""));
  assertTrue(filter.contains(Hex.decode(""String_Node_Str"")));
  assertFalse(filter.contains(Hex.decode(""String_Node_Str"")));
  filter.insert(Hex.decode(""String_Node_Str""));
  assertTrue(filter.contains(Hex.decode(""String_Node_Str"")));
  filter.insert(Hex.decode(""String_Node_Str""));
  assertTrue(filter.contains(Hex.decode(""String_Node_Str"")));
  assertTrue(Arrays.equals(Hex.decode(""String_Node_Str""),filter.bitcoinSerialize()));
}","@Test public void insertSerializeTest(){
  BloomFilter filter=new BloomFilter(3,0.01,0,BloomFilter.BloomUpdate.UPDATE_ALL);
  filter.insert(Hex.decode(""String_Node_Str""));
  assertTrue(filter.contains(Hex.decode(""String_Node_Str"")));
  assertFalse(filter.contains(Hex.decode(""String_Node_Str"")));
  filter.insert(Hex.decode(""String_Node_Str""));
  assertTrue(filter.contains(Hex.decode(""String_Node_Str"")));
  filter.insert(Hex.decode(""String_Node_Str""));
  assertTrue(filter.contains(Hex.decode(""String_Node_Str"")));
  assertTrue(Arrays.equals(Hex.decode(""String_Node_Str""),filter.bitcoinSerialize()));
}",0.9983443708609272
85854,"private int hash(int hashNum,byte[] object){
  int h1=(int)((hashNum * 0xFBA4C795L + nTweak) & 0xFFFFFFFF);
  final int c1=0xcc9e2d51;
  final int c2=0x1b873593;
  int numBlocks=(object.length / 4) * 4;
  for (int i=0; i < numBlocks; i+=4) {
    int k1=(object[i] & 0xFF) | ((object[i + 1] & 0xFF) << 8) | ((object[i + 2] & 0xFF) << 16)| ((object[i + 3] & 0xFF) << 24);
    k1*=c1;
    k1=ROTL32(k1,15);
    k1*=c2;
    h1^=k1;
    h1=ROTL32(h1,13);
    h1=h1 * 5 + 0xe6546b64;
  }
  int k1=0;
switch (object.length & 3) {
case 3:
    k1^=(object[numBlocks + 2] & 0xff) << 16;
case 2:
  k1^=(object[numBlocks + 1] & 0xff) << 8;
case 1:
k1^=(object[numBlocks] & 0xff);
k1*=c1;
k1=ROTL32(k1,15);
k1*=c2;
h1^=k1;
}
;
h1^=object.length;
h1^=h1 >>> 16;
h1*=0x85ebca6b;
h1^=h1 >>> 13;
h1*=0xc2b2ae35;
h1^=h1 >>> 16;
return (int)((h1 & 0xFFFFFFFFL) % (data.length * 8));
}","private int hash(int hashNum,byte[] object){
  int h1=(int)((hashNum * 0xFBA4C795L + nTweak) & 0xFFFFFFFF);
  final int c1=0xcc9e2d51;
  final int c2=0x1b873593;
  int numBlocks=(object.length / 4) * 4;
  for (int i=0; i < numBlocks; i+=4) {
    int k1=(object[i] & 0xFF) | ((object[i + 1] & 0xFF) << 8) | ((object[i + 2] & 0xFF) << 16)| ((object[i + 3] & 0xFF) << 24);
    k1*=c1;
    k1=ROTL32(k1,15);
    k1*=c2;
    h1^=k1;
    h1=ROTL32(h1,13);
    h1=h1 * 5 + 0xe6546b64;
  }
  int k1=0;
switch (object.length & 3) {
case 3:
    k1^=(object[numBlocks + 2] & 0xff) << 16;
case 2:
  k1^=(object[numBlocks + 1] & 0xff) << 8;
case 1:
k1^=(object[numBlocks] & 0xff);
k1*=c1;
k1=ROTL32(k1,15);
k1*=c2;
h1^=k1;
default :
break;
}
;
h1^=object.length;
h1^=h1 >>> 16;
h1*=0x85ebca6b;
h1^=h1 >>> 13;
h1*=0xc2b2ae35;
h1^=h1 >>> 16;
return (int)((h1 & 0xFFFFFFFFL) % (data.length * 8));
}",0.9902690326273612
85855,"/** 
 * <p>Given the components of a signature and a selector value, recover and return the public key that generated the signature according to the algorithm in SEC1v2 section 4.1.6.</p> <p>The recId is an index from 0 to 3 which indicates which of the 4 possible keys is the correct one. Because the key recovery operation yields multiple potential keys, the correct key must either be stored alongside the signature, or you must be willing to try each recId in turn until you find one that outputs the key you are expecting.</p> <p>If this method returns null it means recovery was not possible and recId should be iterated.</p> <p>Given the above two points, a correct usage of this method is inside a for loop from 0 to 3, and if the output is null OR a key that is not the one you expect, you try again with the next recId.</p>
 * @param recId Which possible key to recover.
 * @param r The R component of the signature.
 * @param s The S component of the signature.
 * @param message Hash of the data that was signed.
 * @param compressed Whether or not the original pubkey was compressed.
 * @return An ECKey containing only the public part, or null if recovery wasn't possible.
 */
public static ECKey recoverFromSignature(int recId,ECDSASignature sig,Sha256Hash message,boolean compressed){
  Preconditions.checkArgument(recId >= 0,""String_Node_Str"");
  Preconditions.checkArgument(sig.r.compareTo(BigInteger.ZERO) >= 0,""String_Node_Str"");
  Preconditions.checkArgument(sig.s.compareTo(BigInteger.ZERO) >= 0,""String_Node_Str"");
  Preconditions.checkNotNull(message);
  BigInteger n=ecParams.getN();
  BigInteger i=BigInteger.valueOf((long)recId / 2);
  BigInteger x=sig.r.add(i.multiply(n));
  ECCurve.Fp curve=(ECCurve.Fp)ecParams.getCurve();
  BigInteger prime=curve.getQ();
  if (x.compareTo(prime) >= 0) {
    return null;
  }
  ECPoint R=decompressKey(x,recId % 2 == 1);
  if (!R.multiply(n).isInfinity())   return null;
  BigInteger e=message.toBigInteger();
  BigInteger eInv=BigInteger.ZERO.subtract(e).mod(n);
  BigInteger rInv=sig.r.modInverse(n);
  BigInteger srInv=rInv.multiply(sig.s).mod(n);
  BigInteger eInvrInv=rInv.multiply(eInv).mod(n);
  ECPoint p1=ecParams.getG().multiply(eInvrInv);
  ECPoint p2=R.multiply(srInv);
  ECPoint.Fp q=(ECPoint.Fp)p2.add(p1);
  if (compressed) {
    q=new ECPoint.Fp(curve,q.getX(),q.getY(),true);
  }
  return new ECKey((byte[])null,q.getEncoded());
}","/** 
 * <p>Given the components of a signature and a selector value, recover and return the public key that generated the signature according to the algorithm in SEC1v2 section 4.1.6.</p> <p>The recId is an index from 0 to 3 which indicates which of the 4 possible keys is the correct one. Because the key recovery operation yields multiple potential keys, the correct key must either be stored alongside the signature, or you must be willing to try each recId in turn until you find one that outputs the key you are expecting.</p> <p>If this method returns null it means recovery was not possible and recId should be iterated.</p> <p>Given the above two points, a correct usage of this method is inside a for loop from 0 to 3, and if the output is null OR a key that is not the one you expect, you try again with the next recId.</p>
 * @param recId Which possible key to recover.
 * @param r The R component of the signature.
 * @param s The S component of the signature.
 * @param message Hash of the data that was signed.
 * @param compressed Whether or not the original pubkey was compressed.
 * @return An ECKey containing only the public part, or null if recovery wasn't possible.
 */
public static ECKey recoverFromSignature(int recId,ECDSASignature sig,Sha256Hash message,boolean compressed){
  Preconditions.checkArgument(recId >= 0,""String_Node_Str"");
  Preconditions.checkArgument(sig.r.compareTo(BigInteger.ZERO) >= 0,""String_Node_Str"");
  Preconditions.checkArgument(sig.s.compareTo(BigInteger.ZERO) >= 0,""String_Node_Str"");
  Preconditions.checkNotNull(message);
  BigInteger n=ecParams.getN();
  BigInteger i=BigInteger.valueOf((long)recId / 2);
  BigInteger x=sig.r.add(i.multiply(n));
  ECCurve.Fp curve=(ECCurve.Fp)ecParams.getCurve();
  BigInteger prime=curve.getQ();
  if (x.compareTo(prime) >= 0) {
    return null;
  }
  ECPoint R=decompressKey(x,(recId & 1) == 1);
  if (!R.multiply(n).isInfinity())   return null;
  BigInteger e=message.toBigInteger();
  BigInteger eInv=BigInteger.ZERO.subtract(e).mod(n);
  BigInteger rInv=sig.r.modInverse(n);
  BigInteger srInv=rInv.multiply(sig.s).mod(n);
  BigInteger eInvrInv=rInv.multiply(eInv).mod(n);
  ECPoint p1=ecParams.getG().multiply(eInvrInv);
  ECPoint p2=R.multiply(srInv);
  ECPoint.Fp q=(ECPoint.Fp)p2.add(p1);
  if (compressed) {
    q=new ECPoint.Fp(curve,q.getX(),q.getY(),true);
  }
  return new ECKey((byte[])null,q.getEncoded());
}",0.9958557811852464
85856,"/** 
 * Returns true if the given height has a recorded checkpoint.
 * @param height
 * @return
 */
public boolean isCheckpoint(int height){
  Sha256Hash checkpointHash=checkpoints.get(new Integer(height));
  if (checkpointHash != null)   return true;
  return false;
}","/** 
 * Returns true if the given height has a recorded checkpoint.
 * @param height
 * @return
 */
public boolean isCheckpoint(int height){
  Sha256Hash checkpointHash=checkpoints.get(Integer.valueOf(height));
  if (checkpointHash != null)   return true;
  return false;
}",0.977859778597786
85857,"/** 
 * Returns true if the block height is either not a checkpoint, or is a checkpoint and the hash matches.
 */
public boolean passesCheckpoint(int height,Sha256Hash hash){
  Sha256Hash checkpointHash=checkpoints.get(new Integer(height));
  if (checkpointHash != null)   return checkpointHash.equals(hash);
  return true;
}","/** 
 * Returns true if the block height is either not a checkpoint, or is a checkpoint and the hash matches.
 */
public boolean passesCheckpoint(int height,Sha256Hash hash){
  Sha256Hash checkpointHash=checkpoints.get(Integer.valueOf(height));
  if (checkpointHash != null)   return checkpointHash.equals(hash);
  return true;
}",0.981651376146789
85858,"private static void executeScript(Transaction txContainingThis,long index,Script script,LinkedList<byte[]> stack) throws ScriptException {
  int opCount=0;
  int lastCodeSepLocation=0;
  LinkedList<byte[]> altstack=new LinkedList<byte[]>();
  LinkedList<Boolean> ifStack=new LinkedList<Boolean>();
  for (  ScriptChunk chunk : script.chunks) {
    boolean shouldExecute=!ifStack.contains(false);
    if (!chunk.isOpCode) {
      if (chunk.data.length > 520)       throw new ScriptException(""String_Node_Str"");
      if (!shouldExecute)       continue;
      stack.add(chunk.data);
    }
 else {
      int opcode=0xFF & chunk.data[0];
      if (opcode > OP_16) {
        opCount++;
        if (opCount > 201)         throw new ScriptException(""String_Node_Str"");
      }
      if (opcode == OP_VERIF || opcode == OP_VERNOTIF)       throw new ScriptException(""String_Node_Str"");
      if (opcode == OP_CAT || opcode == OP_SUBSTR || opcode == OP_LEFT || opcode == OP_RIGHT || opcode == OP_INVERT || opcode == OP_AND || opcode == OP_OR || opcode == OP_XOR || opcode == OP_2MUL || opcode == OP_2DIV || opcode == OP_MUL || opcode == OP_DIV || opcode == OP_MOD || opcode == OP_LSHIFT || opcode == OP_RSHIFT)       throw new ScriptException(""String_Node_Str"");
switch (opcode) {
case OP_IF:
        if (!shouldExecute) {
          ifStack.add(false);
          continue;
        }
      if (stack.size() < 1)       throw new ScriptException(""String_Node_Str"");
    ifStack.add(castToBool(stack.pollLast()));
  continue;
case OP_NOTIF:
if (!shouldExecute) {
  ifStack.add(false);
  continue;
}
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
ifStack.add(!castToBool(stack.pollLast()));
continue;
case OP_ELSE:
if (ifStack.isEmpty()) throw new ScriptException(""String_Node_Str"");
ifStack.add(!ifStack.pollLast());
continue;
case OP_ENDIF:
if (ifStack.isEmpty()) throw new ScriptException(""String_Node_Str"");
ifStack.pollLast();
continue;
}
if (!shouldExecute) continue;
switch (opcode) {
case OP_1NEGATE:
stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.ONE.negate(),false)));
break;
case OP_1:
case OP_2:
case OP_3:
case OP_4:
case OP_5:
case OP_6:
case OP_7:
case OP_8:
case OP_9:
case OP_10:
case OP_11:
case OP_12:
case OP_13:
case OP_14:
case OP_15:
case OP_16:
stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.valueOf(getOpNValue(opcode)),false)));
break;
case OP_NOP:
break;
case OP_VERIFY:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
if (!castToBool(stack.pollLast())) throw new ScriptException(""String_Node_Str"");
break;
case OP_RETURN:
throw new ScriptException(""String_Node_Str"");
case OP_TOALTSTACK:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
altstack.add(stack.pollLast());
break;
case OP_FROMALTSTACK:
if (altstack.size() < 1) throw new ScriptException(""String_Node_Str"");
stack.add(altstack.pollLast());
break;
case OP_2DROP:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
stack.pollLast();
stack.pollLast();
break;
case OP_2DUP:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
Iterator<byte[]> it2DUP=stack.descendingIterator();
byte[] OP2DUPtmpChunk2=it2DUP.next();
stack.add(it2DUP.next());
stack.add(OP2DUPtmpChunk2);
break;
case OP_3DUP:
if (stack.size() < 3) throw new ScriptException(""String_Node_Str"");
Iterator<byte[]> it3DUP=stack.descendingIterator();
byte[] OP3DUPtmpChunk3=it3DUP.next();
byte[] OP3DUPtmpChunk2=it3DUP.next();
stack.add(it3DUP.next());
stack.add(OP3DUPtmpChunk2);
stack.add(OP3DUPtmpChunk3);
break;
case OP_2OVER:
if (stack.size() < 4) throw new ScriptException(""String_Node_Str"");
Iterator<byte[]> it2OVER=stack.descendingIterator();
it2OVER.next();
it2OVER.next();
byte[] OP2OVERtmpChunk2=it2OVER.next();
stack.add(it2OVER.next());
stack.add(OP2OVERtmpChunk2);
break;
case OP_2ROT:
if (stack.size() < 6) throw new ScriptException(""String_Node_Str"");
byte[] OP2ROTtmpChunk6=stack.pollLast();
byte[] OP2ROTtmpChunk5=stack.pollLast();
byte[] OP2ROTtmpChunk4=stack.pollLast();
byte[] OP2ROTtmpChunk3=stack.pollLast();
byte[] OP2ROTtmpChunk2=stack.pollLast();
byte[] OP2ROTtmpChunk1=stack.pollLast();
stack.add(OP2ROTtmpChunk3);
stack.add(OP2ROTtmpChunk4);
stack.add(OP2ROTtmpChunk5);
stack.add(OP2ROTtmpChunk6);
stack.add(OP2ROTtmpChunk1);
stack.add(OP2ROTtmpChunk2);
break;
case OP_2SWAP:
if (stack.size() < 4) throw new ScriptException(""String_Node_Str"");
byte[] OP2SWAPtmpChunk4=stack.pollLast();
byte[] OP2SWAPtmpChunk3=stack.pollLast();
byte[] OP2SWAPtmpChunk2=stack.pollLast();
byte[] OP2SWAPtmpChunk1=stack.pollLast();
stack.add(OP2SWAPtmpChunk3);
stack.add(OP2SWAPtmpChunk4);
stack.add(OP2SWAPtmpChunk1);
stack.add(OP2SWAPtmpChunk2);
break;
case OP_IFDUP:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
if (castToBool(stack.getLast())) stack.add(stack.getLast());
break;
case OP_DEPTH:
stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.valueOf(stack.size()),false)));
break;
case OP_DROP:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
stack.pollLast();
break;
case OP_DUP:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
stack.add(stack.getLast());
break;
case OP_NIP:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
byte[] OPNIPtmpChunk=stack.pollLast();
stack.pollLast();
stack.add(OPNIPtmpChunk);
break;
case OP_OVER:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
Iterator<byte[]> itOVER=stack.descendingIterator();
itOVER.next();
stack.add(itOVER.next());
break;
case OP_PICK:
case OP_ROLL:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
long val=castToBigInteger(stack.pollLast()).longValue();
if (val < 0 || val >= stack.size()) throw new ScriptException(""String_Node_Str"");
Iterator<byte[]> itPICK=stack.descendingIterator();
for (long i=0; i < val; i++) itPICK.next();
byte[] OPROLLtmpChunk=itPICK.next();
if (opcode == OP_ROLL) itPICK.remove();
stack.add(OPROLLtmpChunk);
break;
case OP_ROT:
if (stack.size() < 3) throw new ScriptException(""String_Node_Str"");
byte[] OPROTtmpChunk3=stack.pollLast();
byte[] OPROTtmpChunk2=stack.pollLast();
byte[] OPROTtmpChunk1=stack.pollLast();
stack.add(OPROTtmpChunk2);
stack.add(OPROTtmpChunk3);
stack.add(OPROTtmpChunk1);
break;
case OP_SWAP:
case OP_TUCK:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
byte[] OPSWAPtmpChunk2=stack.pollLast();
byte[] OPSWAPtmpChunk1=stack.pollLast();
stack.add(OPSWAPtmpChunk2);
stack.add(OPSWAPtmpChunk1);
if (opcode == OP_TUCK) stack.add(OPSWAPtmpChunk2);
break;
case OP_CAT:
case OP_SUBSTR:
case OP_LEFT:
case OP_RIGHT:
throw new ScriptException(""String_Node_Str"");
case OP_SIZE:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.valueOf(stack.getLast().length),false)));
break;
case OP_INVERT:
case OP_AND:
case OP_OR:
case OP_XOR:
throw new ScriptException(""String_Node_Str"");
case OP_EQUAL:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
stack.add(Arrays.equals(stack.pollLast(),stack.pollLast()) ? new byte[]{1} : new byte[]{0});
break;
case OP_EQUALVERIFY:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
if (!Arrays.equals(stack.pollLast(),stack.pollLast())) throw new ScriptException(""String_Node_Str"");
break;
case OP_1ADD:
case OP_1SUB:
case OP_NEGATE:
case OP_ABS:
case OP_NOT:
case OP_0NOTEQUAL:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
BigInteger numericOPnum=castToBigInteger(stack.pollLast());
switch (opcode) {
case OP_1ADD:
numericOPnum=numericOPnum.add(BigInteger.ONE);
break;
case OP_1SUB:
numericOPnum=numericOPnum.subtract(BigInteger.ONE);
break;
case OP_NEGATE:
numericOPnum=numericOPnum.negate();
break;
case OP_ABS:
if (numericOPnum.compareTo(BigInteger.ZERO) < 0) numericOPnum=numericOPnum.negate();
break;
case OP_NOT:
if (numericOPnum.equals(BigInteger.ZERO)) numericOPnum=BigInteger.ONE;
 else numericOPnum=BigInteger.ZERO;
break;
case OP_0NOTEQUAL:
if (numericOPnum.equals(BigInteger.ZERO)) numericOPnum=BigInteger.ZERO;
 else numericOPnum=BigInteger.ONE;
break;
}
stack.add(Utils.reverseBytes(Utils.encodeMPI(numericOPnum,false)));
break;
case OP_2MUL:
case OP_2DIV:
throw new ScriptException(""String_Node_Str"");
case OP_ADD:
case OP_SUB:
case OP_BOOLAND:
case OP_BOOLOR:
case OP_NUMEQUAL:
case OP_NUMNOTEQUAL:
case OP_LESSTHAN:
case OP_GREATERTHAN:
case OP_LESSTHANOREQUAL:
case OP_GREATERTHANOREQUAL:
case OP_MIN:
case OP_MAX:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
BigInteger numericOPnum2=castToBigInteger(stack.pollLast());
BigInteger numericOPnum1=castToBigInteger(stack.pollLast());
BigInteger numericOPresult;
switch (opcode) {
case OP_ADD:
numericOPresult=numericOPnum1.add(numericOPnum2);
break;
case OP_SUB:
numericOPresult=numericOPnum1.subtract(numericOPnum2);
break;
case OP_BOOLAND:
if (!numericOPnum1.equals(BigInteger.ZERO) && !numericOPnum2.equals(BigInteger.ZERO)) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_BOOLOR:
if (!numericOPnum1.equals(BigInteger.ZERO) || !numericOPnum2.equals(BigInteger.ZERO)) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_NUMEQUAL:
if (numericOPnum1.equals(numericOPnum2)) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_NUMNOTEQUAL:
if (!numericOPnum1.equals(numericOPnum2)) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_LESSTHAN:
if (numericOPnum1.compareTo(numericOPnum2) < 0) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_GREATERTHAN:
if (numericOPnum1.compareTo(numericOPnum2) > 0) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_LESSTHANOREQUAL:
if (numericOPnum1.compareTo(numericOPnum2) <= 0) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_GREATERTHANOREQUAL:
if (numericOPnum1.compareTo(numericOPnum2) >= 0) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_MIN:
if (numericOPnum1.compareTo(numericOPnum2) < 0) numericOPresult=numericOPnum1;
 else numericOPresult=numericOPnum2;
break;
case OP_MAX:
if (numericOPnum1.compareTo(numericOPnum2) > 0) numericOPresult=numericOPnum1;
 else numericOPresult=numericOPnum2;
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
stack.add(Utils.reverseBytes(Utils.encodeMPI(numericOPresult,false)));
break;
case OP_MUL:
case OP_DIV:
case OP_MOD:
case OP_LSHIFT:
case OP_RSHIFT:
throw new ScriptException(""String_Node_Str"");
case OP_NUMEQUALVERIFY:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
BigInteger OPNUMEQUALVERIFYnum2=castToBigInteger(stack.pollLast());
BigInteger OPNUMEQUALVERIFYnum1=castToBigInteger(stack.pollLast());
if (!OPNUMEQUALVERIFYnum1.equals(OPNUMEQUALVERIFYnum2)) throw new ScriptException(""String_Node_Str"");
break;
case OP_WITHIN:
if (stack.size() < 3) throw new ScriptException(""String_Node_Str"");
BigInteger OPWITHINnum3=castToBigInteger(stack.pollLast());
BigInteger OPWITHINnum2=castToBigInteger(stack.pollLast());
BigInteger OPWITHINnum1=castToBigInteger(stack.pollLast());
if (OPWITHINnum2.compareTo(OPWITHINnum1) <= 0 && OPWITHINnum1.compareTo(OPWITHINnum3) < 0) stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.ONE,false)));
 else stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.ZERO,false)));
break;
case OP_RIPEMD160:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
RIPEMD160Digest digest=new RIPEMD160Digest();
byte[] dataToHash=stack.pollLast();
digest.update(dataToHash,0,dataToHash.length);
byte[] ripmemdHash=new byte[20];
digest.doFinal(ripmemdHash,0);
stack.add(ripmemdHash);
break;
case OP_SHA1:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
try {
stack.add(MessageDigest.getInstance(""String_Node_Str"").digest(stack.pollLast()));
}
 catch (NoSuchAlgorithmException e) {
throw new RuntimeException(e);
}
break;
case OP_SHA256:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
try {
stack.add(MessageDigest.getInstance(""String_Node_Str"").digest(stack.pollLast()));
}
 catch (NoSuchAlgorithmException e) {
throw new RuntimeException(e);
}
break;
case OP_HASH160:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
stack.add(Utils.sha256hash160(stack.pollLast()));
break;
case OP_HASH256:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
stack.add(Utils.doubleDigest(stack.pollLast()));
break;
case OP_CODESEPARATOR:
lastCodeSepLocation=chunk.startLocationInProgram + 1;
break;
case OP_CHECKSIG:
case OP_CHECKSIGVERIFY:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
byte[] CHECKSIGpubKey=stack.pollLast();
byte[] CHECKSIGsig=stack.pollLast();
byte[] CHECKSIGconnectedScript=Arrays.copyOfRange(script.program,lastCodeSepLocation,script.program.length);
UnsafeByteArrayOutputStream OPCHECKSIGOutStream=new UnsafeByteArrayOutputStream(CHECKSIGsig.length + 1);
try {
writeBytes(OPCHECKSIGOutStream,CHECKSIGsig);
}
 catch (IOException e) {
throw new RuntimeException(e);
}
CHECKSIGconnectedScript=removeAllInstancesOf(CHECKSIGconnectedScript,OPCHECKSIGOutStream.toByteArray());
Sha256Hash CHECKSIGhash=txContainingThis.hashTransactionForSignature((int)index,CHECKSIGconnectedScript,CHECKSIGsig[CHECKSIGsig.length - 1]);
boolean CHECKSIGsigValid;
try {
CHECKSIGsigValid=ECKey.verify(CHECKSIGhash.getBytes(),Arrays.copyOf(CHECKSIGsig,CHECKSIGsig.length - 1),CHECKSIGpubKey);
}
 catch (Exception e1) {
CHECKSIGsigValid=false;
}
if (opcode == OP_CHECKSIG) stack.add(CHECKSIGsigValid ? new byte[]{1} : new byte[]{0});
 else if (opcode == OP_CHECKSIGVERIFY) if (!CHECKSIGsigValid) throw new ScriptException(""String_Node_Str"");
break;
case OP_CHECKMULTISIG:
case OP_CHECKMULTISIGVERIFY:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
int CHECKMULTISIGpubKeyCount=castToBigInteger(stack.pollLast()).intValue();
if (CHECKMULTISIGpubKeyCount < 0 || CHECKMULTISIGpubKeyCount > 20) throw new ScriptException(""String_Node_Str"");
opCount+=CHECKMULTISIGpubKeyCount;
if (opCount > 201) throw new ScriptException(""String_Node_Str"");
if (stack.size() < CHECKMULTISIGpubKeyCount + 1) throw new ScriptException(""String_Node_Str"");
LinkedList<byte[]> CHECKMULTISIGpubkeys=new LinkedList<byte[]>();
for (int i=0; i < CHECKMULTISIGpubKeyCount; i++) CHECKMULTISIGpubkeys.add(stack.pollLast());
int CHECKMULTISIGsigCount=castToBigInteger(stack.pollLast()).intValue();
if (CHECKMULTISIGsigCount < 0 || CHECKMULTISIGsigCount > CHECKMULTISIGpubKeyCount) throw new ScriptException(""String_Node_Str"");
if (stack.size() < CHECKMULTISIGsigCount + 1) throw new ScriptException(""String_Node_Str"");
LinkedList<byte[]> CHECKMULTISIGsigs=new LinkedList<byte[]>();
for (int i=0; i < CHECKMULTISIGsigCount; i++) CHECKMULTISIGsigs.add(stack.pollLast());
byte[] CHECKMULTISIGconnectedScript=Arrays.copyOfRange(script.program,lastCodeSepLocation,script.program.length);
for (byte[] CHECKMULTISIGsig : CHECKMULTISIGsigs) {
UnsafeByteArrayOutputStream OPCHECKMULTISIGOutStream=new UnsafeByteArrayOutputStream(CHECKMULTISIGsig.length + 1);
try {
writeBytes(OPCHECKMULTISIGOutStream,CHECKMULTISIGsig);
}
 catch (IOException e) {
throw new RuntimeException(e);
}
CHECKMULTISIGconnectedScript=removeAllInstancesOf(CHECKMULTISIGconnectedScript,OPCHECKMULTISIGOutStream.toByteArray());
}
boolean CHECKMULTISIGValid=true;
while (CHECKMULTISIGsigs.size() > 0) {
byte[] CHECKMULTISIGsig=CHECKMULTISIGsigs.getFirst();
byte[] CHECKMULTISIGpubKey=CHECKMULTISIGpubkeys.pollFirst();
Sha256Hash CHECKMULTISIGhash=txContainingThis.hashTransactionForSignature((int)index,CHECKMULTISIGconnectedScript,CHECKMULTISIGsig[CHECKMULTISIGsig.length - 1]);
try {
if (ECKey.verify(CHECKMULTISIGhash.getBytes(),Arrays.copyOf(CHECKMULTISIGsig,CHECKMULTISIGsig.length - 1),CHECKMULTISIGpubKey)) CHECKMULTISIGsigs.pollFirst();
}
 catch (Exception e) {
}
if (CHECKMULTISIGsigs.size() > CHECKMULTISIGpubkeys.size()) {
CHECKMULTISIGValid=false;
break;
}
}
stack.pollLast();
if (opcode == OP_CHECKMULTISIG) stack.add(CHECKMULTISIGValid ? new byte[]{1} : new byte[]{0});
 else if (opcode == OP_CHECKMULTISIGVERIFY) if (!CHECKMULTISIGValid) throw new ScriptException(""String_Node_Str"");
break;
case OP_NOP1:
case OP_NOP2:
case OP_NOP3:
case OP_NOP4:
case OP_NOP5:
case OP_NOP6:
case OP_NOP7:
case OP_NOP8:
case OP_NOP9:
case OP_NOP10:
break;
default :
throw new ScriptException(""String_Node_Str"");
}
}
if (stack.size() + altstack.size() > 1000 || stack.size() + altstack.size() < 0) throw new ScriptException(""String_Node_Str"");
}
if (!ifStack.isEmpty()) throw new ScriptException(""String_Node_Str"");
}","private static void executeScript(Transaction txContainingThis,long index,Script script,LinkedList<byte[]> stack) throws ScriptException {
  int opCount=0;
  int lastCodeSepLocation=0;
  LinkedList<byte[]> altstack=new LinkedList<byte[]>();
  LinkedList<Boolean> ifStack=new LinkedList<Boolean>();
  for (  ScriptChunk chunk : script.chunks) {
    boolean shouldExecute=!ifStack.contains(false);
    if (!chunk.isOpCode) {
      if (chunk.data.length > 520)       throw new ScriptException(""String_Node_Str"");
      if (!shouldExecute)       continue;
      stack.add(chunk.data);
    }
 else {
      int opcode=0xFF & chunk.data[0];
      if (opcode > OP_16) {
        opCount++;
        if (opCount > 201)         throw new ScriptException(""String_Node_Str"");
      }
      if (opcode == OP_VERIF || opcode == OP_VERNOTIF)       throw new ScriptException(""String_Node_Str"");
      if (opcode == OP_CAT || opcode == OP_SUBSTR || opcode == OP_LEFT || opcode == OP_RIGHT || opcode == OP_INVERT || opcode == OP_AND || opcode == OP_OR || opcode == OP_XOR || opcode == OP_2MUL || opcode == OP_2DIV || opcode == OP_MUL || opcode == OP_DIV || opcode == OP_MOD || opcode == OP_LSHIFT || opcode == OP_RSHIFT)       throw new ScriptException(""String_Node_Str"");
switch (opcode) {
case OP_IF:
        if (!shouldExecute) {
          ifStack.add(false);
          continue;
        }
      if (stack.size() < 1)       throw new ScriptException(""String_Node_Str"");
    ifStack.add(castToBool(stack.pollLast()));
  continue;
case OP_NOTIF:
if (!shouldExecute) {
  ifStack.add(false);
  continue;
}
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
ifStack.add(!castToBool(stack.pollLast()));
continue;
case OP_ELSE:
if (ifStack.isEmpty()) throw new ScriptException(""String_Node_Str"");
ifStack.add(!ifStack.pollLast());
continue;
case OP_ENDIF:
if (ifStack.isEmpty()) throw new ScriptException(""String_Node_Str"");
ifStack.pollLast();
continue;
}
if (!shouldExecute) continue;
switch (opcode) {
case OP_1NEGATE:
stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.ONE.negate(),false)));
break;
case OP_1:
case OP_2:
case OP_3:
case OP_4:
case OP_5:
case OP_6:
case OP_7:
case OP_8:
case OP_9:
case OP_10:
case OP_11:
case OP_12:
case OP_13:
case OP_14:
case OP_15:
case OP_16:
stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.valueOf(getOpNValue(opcode)),false)));
break;
case OP_NOP:
break;
case OP_VERIFY:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
if (!castToBool(stack.pollLast())) throw new ScriptException(""String_Node_Str"");
break;
case OP_RETURN:
throw new ScriptException(""String_Node_Str"");
case OP_TOALTSTACK:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
altstack.add(stack.pollLast());
break;
case OP_FROMALTSTACK:
if (altstack.size() < 1) throw new ScriptException(""String_Node_Str"");
stack.add(altstack.pollLast());
break;
case OP_2DROP:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
stack.pollLast();
stack.pollLast();
break;
case OP_2DUP:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
Iterator<byte[]> it2DUP=stack.descendingIterator();
byte[] OP2DUPtmpChunk2=it2DUP.next();
stack.add(it2DUP.next());
stack.add(OP2DUPtmpChunk2);
break;
case OP_3DUP:
if (stack.size() < 3) throw new ScriptException(""String_Node_Str"");
Iterator<byte[]> it3DUP=stack.descendingIterator();
byte[] OP3DUPtmpChunk3=it3DUP.next();
byte[] OP3DUPtmpChunk2=it3DUP.next();
stack.add(it3DUP.next());
stack.add(OP3DUPtmpChunk2);
stack.add(OP3DUPtmpChunk3);
break;
case OP_2OVER:
if (stack.size() < 4) throw new ScriptException(""String_Node_Str"");
Iterator<byte[]> it2OVER=stack.descendingIterator();
it2OVER.next();
it2OVER.next();
byte[] OP2OVERtmpChunk2=it2OVER.next();
stack.add(it2OVER.next());
stack.add(OP2OVERtmpChunk2);
break;
case OP_2ROT:
if (stack.size() < 6) throw new ScriptException(""String_Node_Str"");
byte[] OP2ROTtmpChunk6=stack.pollLast();
byte[] OP2ROTtmpChunk5=stack.pollLast();
byte[] OP2ROTtmpChunk4=stack.pollLast();
byte[] OP2ROTtmpChunk3=stack.pollLast();
byte[] OP2ROTtmpChunk2=stack.pollLast();
byte[] OP2ROTtmpChunk1=stack.pollLast();
stack.add(OP2ROTtmpChunk3);
stack.add(OP2ROTtmpChunk4);
stack.add(OP2ROTtmpChunk5);
stack.add(OP2ROTtmpChunk6);
stack.add(OP2ROTtmpChunk1);
stack.add(OP2ROTtmpChunk2);
break;
case OP_2SWAP:
if (stack.size() < 4) throw new ScriptException(""String_Node_Str"");
byte[] OP2SWAPtmpChunk4=stack.pollLast();
byte[] OP2SWAPtmpChunk3=stack.pollLast();
byte[] OP2SWAPtmpChunk2=stack.pollLast();
byte[] OP2SWAPtmpChunk1=stack.pollLast();
stack.add(OP2SWAPtmpChunk3);
stack.add(OP2SWAPtmpChunk4);
stack.add(OP2SWAPtmpChunk1);
stack.add(OP2SWAPtmpChunk2);
break;
case OP_IFDUP:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
if (castToBool(stack.getLast())) stack.add(stack.getLast());
break;
case OP_DEPTH:
stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.valueOf(stack.size()),false)));
break;
case OP_DROP:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
stack.pollLast();
break;
case OP_DUP:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
stack.add(stack.getLast());
break;
case OP_NIP:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
byte[] OPNIPtmpChunk=stack.pollLast();
stack.pollLast();
stack.add(OPNIPtmpChunk);
break;
case OP_OVER:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
Iterator<byte[]> itOVER=stack.descendingIterator();
itOVER.next();
stack.add(itOVER.next());
break;
case OP_PICK:
case OP_ROLL:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
long val=castToBigInteger(stack.pollLast()).longValue();
if (val < 0 || val >= stack.size()) throw new ScriptException(""String_Node_Str"");
Iterator<byte[]> itPICK=stack.descendingIterator();
for (long i=0; i < val; i++) itPICK.next();
byte[] OPROLLtmpChunk=itPICK.next();
if (opcode == OP_ROLL) itPICK.remove();
stack.add(OPROLLtmpChunk);
break;
case OP_ROT:
if (stack.size() < 3) throw new ScriptException(""String_Node_Str"");
byte[] OPROTtmpChunk3=stack.pollLast();
byte[] OPROTtmpChunk2=stack.pollLast();
byte[] OPROTtmpChunk1=stack.pollLast();
stack.add(OPROTtmpChunk2);
stack.add(OPROTtmpChunk3);
stack.add(OPROTtmpChunk1);
break;
case OP_SWAP:
case OP_TUCK:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
byte[] OPSWAPtmpChunk2=stack.pollLast();
byte[] OPSWAPtmpChunk1=stack.pollLast();
stack.add(OPSWAPtmpChunk2);
stack.add(OPSWAPtmpChunk1);
if (opcode == OP_TUCK) stack.add(OPSWAPtmpChunk2);
break;
case OP_CAT:
case OP_SUBSTR:
case OP_LEFT:
case OP_RIGHT:
throw new ScriptException(""String_Node_Str"");
case OP_SIZE:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.valueOf(stack.getLast().length),false)));
break;
case OP_INVERT:
case OP_AND:
case OP_OR:
case OP_XOR:
throw new ScriptException(""String_Node_Str"");
case OP_EQUAL:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
stack.add(Arrays.equals(stack.pollLast(),stack.pollLast()) ? new byte[]{1} : new byte[]{0});
break;
case OP_EQUALVERIFY:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
if (!Arrays.equals(stack.pollLast(),stack.pollLast())) throw new ScriptException(""String_Node_Str"");
break;
case OP_1ADD:
case OP_1SUB:
case OP_NEGATE:
case OP_ABS:
case OP_NOT:
case OP_0NOTEQUAL:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
BigInteger numericOPnum=castToBigInteger(stack.pollLast());
switch (opcode) {
case OP_1ADD:
numericOPnum=numericOPnum.add(BigInteger.ONE);
break;
case OP_1SUB:
numericOPnum=numericOPnum.subtract(BigInteger.ONE);
break;
case OP_NEGATE:
numericOPnum=numericOPnum.negate();
break;
case OP_ABS:
if (numericOPnum.compareTo(BigInteger.ZERO) < 0) numericOPnum=numericOPnum.negate();
break;
case OP_NOT:
if (numericOPnum.equals(BigInteger.ZERO)) numericOPnum=BigInteger.ONE;
 else numericOPnum=BigInteger.ZERO;
break;
case OP_0NOTEQUAL:
if (numericOPnum.equals(BigInteger.ZERO)) numericOPnum=BigInteger.ZERO;
 else numericOPnum=BigInteger.ONE;
break;
default :
throw new AssertionError(""String_Node_Str"");
}
stack.add(Utils.reverseBytes(Utils.encodeMPI(numericOPnum,false)));
break;
case OP_2MUL:
case OP_2DIV:
throw new ScriptException(""String_Node_Str"");
case OP_ADD:
case OP_SUB:
case OP_BOOLAND:
case OP_BOOLOR:
case OP_NUMEQUAL:
case OP_NUMNOTEQUAL:
case OP_LESSTHAN:
case OP_GREATERTHAN:
case OP_LESSTHANOREQUAL:
case OP_GREATERTHANOREQUAL:
case OP_MIN:
case OP_MAX:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
BigInteger numericOPnum2=castToBigInteger(stack.pollLast());
BigInteger numericOPnum1=castToBigInteger(stack.pollLast());
BigInteger numericOPresult;
switch (opcode) {
case OP_ADD:
numericOPresult=numericOPnum1.add(numericOPnum2);
break;
case OP_SUB:
numericOPresult=numericOPnum1.subtract(numericOPnum2);
break;
case OP_BOOLAND:
if (!numericOPnum1.equals(BigInteger.ZERO) && !numericOPnum2.equals(BigInteger.ZERO)) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_BOOLOR:
if (!numericOPnum1.equals(BigInteger.ZERO) || !numericOPnum2.equals(BigInteger.ZERO)) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_NUMEQUAL:
if (numericOPnum1.equals(numericOPnum2)) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_NUMNOTEQUAL:
if (!numericOPnum1.equals(numericOPnum2)) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_LESSTHAN:
if (numericOPnum1.compareTo(numericOPnum2) < 0) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_GREATERTHAN:
if (numericOPnum1.compareTo(numericOPnum2) > 0) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_LESSTHANOREQUAL:
if (numericOPnum1.compareTo(numericOPnum2) <= 0) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_GREATERTHANOREQUAL:
if (numericOPnum1.compareTo(numericOPnum2) >= 0) numericOPresult=BigInteger.ONE;
 else numericOPresult=BigInteger.ZERO;
break;
case OP_MIN:
if (numericOPnum1.compareTo(numericOPnum2) < 0) numericOPresult=numericOPnum1;
 else numericOPresult=numericOPnum2;
break;
case OP_MAX:
if (numericOPnum1.compareTo(numericOPnum2) > 0) numericOPresult=numericOPnum1;
 else numericOPresult=numericOPnum2;
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
stack.add(Utils.reverseBytes(Utils.encodeMPI(numericOPresult,false)));
break;
case OP_MUL:
case OP_DIV:
case OP_MOD:
case OP_LSHIFT:
case OP_RSHIFT:
throw new ScriptException(""String_Node_Str"");
case OP_NUMEQUALVERIFY:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
BigInteger OPNUMEQUALVERIFYnum2=castToBigInteger(stack.pollLast());
BigInteger OPNUMEQUALVERIFYnum1=castToBigInteger(stack.pollLast());
if (!OPNUMEQUALVERIFYnum1.equals(OPNUMEQUALVERIFYnum2)) throw new ScriptException(""String_Node_Str"");
break;
case OP_WITHIN:
if (stack.size() < 3) throw new ScriptException(""String_Node_Str"");
BigInteger OPWITHINnum3=castToBigInteger(stack.pollLast());
BigInteger OPWITHINnum2=castToBigInteger(stack.pollLast());
BigInteger OPWITHINnum1=castToBigInteger(stack.pollLast());
if (OPWITHINnum2.compareTo(OPWITHINnum1) <= 0 && OPWITHINnum1.compareTo(OPWITHINnum3) < 0) stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.ONE,false)));
 else stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.ZERO,false)));
break;
case OP_RIPEMD160:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
RIPEMD160Digest digest=new RIPEMD160Digest();
byte[] dataToHash=stack.pollLast();
digest.update(dataToHash,0,dataToHash.length);
byte[] ripmemdHash=new byte[20];
digest.doFinal(ripmemdHash,0);
stack.add(ripmemdHash);
break;
case OP_SHA1:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
try {
stack.add(MessageDigest.getInstance(""String_Node_Str"").digest(stack.pollLast()));
}
 catch (NoSuchAlgorithmException e) {
throw new RuntimeException(e);
}
break;
case OP_SHA256:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
try {
stack.add(MessageDigest.getInstance(""String_Node_Str"").digest(stack.pollLast()));
}
 catch (NoSuchAlgorithmException e) {
throw new RuntimeException(e);
}
break;
case OP_HASH160:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
stack.add(Utils.sha256hash160(stack.pollLast()));
break;
case OP_HASH256:
if (stack.size() < 1) throw new ScriptException(""String_Node_Str"");
stack.add(Utils.doubleDigest(stack.pollLast()));
break;
case OP_CODESEPARATOR:
lastCodeSepLocation=chunk.startLocationInProgram + 1;
break;
case OP_CHECKSIG:
case OP_CHECKSIGVERIFY:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
byte[] CHECKSIGpubKey=stack.pollLast();
byte[] CHECKSIGsig=stack.pollLast();
byte[] CHECKSIGconnectedScript=Arrays.copyOfRange(script.program,lastCodeSepLocation,script.program.length);
UnsafeByteArrayOutputStream OPCHECKSIGOutStream=new UnsafeByteArrayOutputStream(CHECKSIGsig.length + 1);
try {
writeBytes(OPCHECKSIGOutStream,CHECKSIGsig);
}
 catch (IOException e) {
throw new RuntimeException(e);
}
CHECKSIGconnectedScript=removeAllInstancesOf(CHECKSIGconnectedScript,OPCHECKSIGOutStream.toByteArray());
Sha256Hash CHECKSIGhash=txContainingThis.hashTransactionForSignature((int)index,CHECKSIGconnectedScript,CHECKSIGsig[CHECKSIGsig.length - 1]);
boolean CHECKSIGsigValid;
try {
CHECKSIGsigValid=ECKey.verify(CHECKSIGhash.getBytes(),Arrays.copyOf(CHECKSIGsig,CHECKSIGsig.length - 1),CHECKSIGpubKey);
}
 catch (Exception e1) {
CHECKSIGsigValid=false;
}
if (opcode == OP_CHECKSIG) stack.add(CHECKSIGsigValid ? new byte[]{1} : new byte[]{0});
 else if (opcode == OP_CHECKSIGVERIFY) if (!CHECKSIGsigValid) throw new ScriptException(""String_Node_Str"");
break;
case OP_CHECKMULTISIG:
case OP_CHECKMULTISIGVERIFY:
if (stack.size() < 2) throw new ScriptException(""String_Node_Str"");
int CHECKMULTISIGpubKeyCount=castToBigInteger(stack.pollLast()).intValue();
if (CHECKMULTISIGpubKeyCount < 0 || CHECKMULTISIGpubKeyCount > 20) throw new ScriptException(""String_Node_Str"");
opCount+=CHECKMULTISIGpubKeyCount;
if (opCount > 201) throw new ScriptException(""String_Node_Str"");
if (stack.size() < CHECKMULTISIGpubKeyCount + 1) throw new ScriptException(""String_Node_Str"");
LinkedList<byte[]> CHECKMULTISIGpubkeys=new LinkedList<byte[]>();
for (int i=0; i < CHECKMULTISIGpubKeyCount; i++) CHECKMULTISIGpubkeys.add(stack.pollLast());
int CHECKMULTISIGsigCount=castToBigInteger(stack.pollLast()).intValue();
if (CHECKMULTISIGsigCount < 0 || CHECKMULTISIGsigCount > CHECKMULTISIGpubKeyCount) throw new ScriptException(""String_Node_Str"");
if (stack.size() < CHECKMULTISIGsigCount + 1) throw new ScriptException(""String_Node_Str"");
LinkedList<byte[]> CHECKMULTISIGsigs=new LinkedList<byte[]>();
for (int i=0; i < CHECKMULTISIGsigCount; i++) CHECKMULTISIGsigs.add(stack.pollLast());
byte[] CHECKMULTISIGconnectedScript=Arrays.copyOfRange(script.program,lastCodeSepLocation,script.program.length);
for (byte[] CHECKMULTISIGsig : CHECKMULTISIGsigs) {
UnsafeByteArrayOutputStream OPCHECKMULTISIGOutStream=new UnsafeByteArrayOutputStream(CHECKMULTISIGsig.length + 1);
try {
writeBytes(OPCHECKMULTISIGOutStream,CHECKMULTISIGsig);
}
 catch (IOException e) {
throw new RuntimeException(e);
}
CHECKMULTISIGconnectedScript=removeAllInstancesOf(CHECKMULTISIGconnectedScript,OPCHECKMULTISIGOutStream.toByteArray());
}
boolean CHECKMULTISIGValid=true;
while (CHECKMULTISIGsigs.size() > 0) {
byte[] CHECKMULTISIGsig=CHECKMULTISIGsigs.getFirst();
byte[] CHECKMULTISIGpubKey=CHECKMULTISIGpubkeys.pollFirst();
Sha256Hash CHECKMULTISIGhash=txContainingThis.hashTransactionForSignature((int)index,CHECKMULTISIGconnectedScript,CHECKMULTISIGsig[CHECKMULTISIGsig.length - 1]);
try {
if (ECKey.verify(CHECKMULTISIGhash.getBytes(),Arrays.copyOf(CHECKMULTISIGsig,CHECKMULTISIGsig.length - 1),CHECKMULTISIGpubKey)) CHECKMULTISIGsigs.pollFirst();
}
 catch (Exception e) {
}
if (CHECKMULTISIGsigs.size() > CHECKMULTISIGpubkeys.size()) {
CHECKMULTISIGValid=false;
break;
}
}
stack.pollLast();
if (opcode == OP_CHECKMULTISIG) stack.add(CHECKMULTISIGValid ? new byte[]{1} : new byte[]{0});
 else if (opcode == OP_CHECKMULTISIGVERIFY) if (!CHECKMULTISIGValid) throw new ScriptException(""String_Node_Str"");
break;
case OP_NOP1:
case OP_NOP2:
case OP_NOP3:
case OP_NOP4:
case OP_NOP5:
case OP_NOP6:
case OP_NOP7:
case OP_NOP8:
case OP_NOP9:
case OP_NOP10:
break;
default :
throw new ScriptException(""String_Node_Str"");
}
}
if (stack.size() + altstack.size() > 1000 || stack.size() + altstack.size() < 0) throw new ScriptException(""String_Node_Str"");
}
if (!ifStack.isEmpty()) throw new ScriptException(""String_Node_Str"");
}",0.9983612907070286
85859,"public void serializeToStream(OutputStream bos) throws IOException {
  Utils.uint64ToByteStreamLE(value,bos);
  bos.write((int)(0xFF & (scriptBytes.length >> 0)));
  bos.write((int)(0xFF & (scriptBytes.length >> 8)));
  bos.write((int)(0xFF & (scriptBytes.length >> 16)));
  bos.write((int)(0xFF & (scriptBytes.length >> 24)));
  bos.write(scriptBytes);
  bos.write(hash.getBytes());
  Utils.uint32ToByteStreamLE(index,bos);
  bos.write((int)(0xFF & (height >> 0)));
  bos.write((int)(0xFF & (height >> 8)));
  bos.write((int)(0xFF & (height >> 16)));
  bos.write((int)(0xFF & (height >> 24)));
}","public void serializeToStream(OutputStream bos) throws IOException {
  Utils.uint64ToByteStreamLE(value,bos);
  bos.write(0xFF & scriptBytes.length >> 0);
  bos.write(0xFF & scriptBytes.length >> 8);
  bos.write(0xFF & (scriptBytes.length >> 16));
  bos.write(0xFF & (scriptBytes.length >> 24));
  bos.write(scriptBytes);
  bos.write(hash.getBytes());
  Utils.uint32ToByteStreamLE(index,bos);
  bos.write(0xFF & (height >> 0));
  bos.write(0xFF & (height >> 8));
  bos.write(0xFF & (height >> 16));
  bos.write(0xFF & (height >> 24));
}",0.7031802120141343
85860,"public StoredTransactionOutput(InputStream in) throws IOException {
  byte[] valueBytes=new byte[8];
  in.read(valueBytes,0,8);
  value=BigInteger.valueOf(Utils.readInt64(valueBytes,0));
  int scriptBytesLength=((in.read() & 0xFF) << 0) | ((in.read() & 0xFF) << 8) | ((in.read() & 0xFF) << 16)| ((in.read() & 0xFF) << 24);
  scriptBytes=new byte[scriptBytesLength];
  if (in.read(scriptBytes) != scriptBytesLength)   throw new EOFException();
  byte[] hashBytes=new byte[32];
  if (in.read(hashBytes) != 32)   throw new EOFException();
  hash=new Sha256Hash(hashBytes);
  byte[] indexBytes=new byte[4];
  if (in.read(indexBytes) != 4)   throw new EOFException();
  index=Utils.readUint32(indexBytes,0);
  height=((in.read() & 0xFF) << 0) | ((in.read() & 0xFF) << 8) | ((in.read() & 0xFF) << 16)| ((in.read() & 0xFF) << 24);
}","public StoredTransactionOutput(InputStream in) throws IOException {
  byte[] valueBytes=new byte[8];
  if (in.read(valueBytes,0,8) != 8)   throw new EOFException();
  value=BigInteger.valueOf(Utils.readInt64(valueBytes,0));
  int scriptBytesLength=((in.read() & 0xFF) << 0) | ((in.read() & 0xFF) << 8) | ((in.read() & 0xFF) << 16)| ((in.read() & 0xFF) << 24);
  scriptBytes=new byte[scriptBytesLength];
  if (in.read(scriptBytes) != scriptBytesLength)   throw new EOFException();
  byte[] hashBytes=new byte[32];
  if (in.read(hashBytes) != 32)   throw new EOFException();
  hash=new Sha256Hash(hashBytes);
  byte[] indexBytes=new byte[4];
  if (in.read(indexBytes) != 4)   throw new EOFException();
  index=Utils.readUint32(indexBytes,0);
  height=((in.read() & 0xFF) << 0) | ((in.read() & 0xFF) << 8) | ((in.read() & 0xFF) << 16)| ((in.read() & 0xFF) << 24);
}",0.978067575577949
85861,"public void serializeToStream(OutputStream bos) throws IOException {
  int numOutsCreated=txOutsCreated.size();
  bos.write((int)(0xFF & (numOutsCreated >> 0)));
  bos.write((int)(0xFF & (numOutsCreated >> 8)));
  bos.write((int)(0xFF & (numOutsCreated >> 16)));
  bos.write((int)(0xFF & (numOutsCreated >> 24)));
  for (  StoredTransactionOutput output : txOutsCreated) {
    output.serializeToStream(bos);
  }
  int numOutsSpent=txOutsSpent.size();
  bos.write((int)(0xFF & (numOutsSpent >> 0)));
  bos.write((int)(0xFF & (numOutsSpent >> 8)));
  bos.write((int)(0xFF & (numOutsSpent >> 16)));
  bos.write((int)(0xFF & (numOutsSpent >> 24)));
  for (  StoredTransactionOutput output : txOutsSpent) {
    output.serializeToStream(bos);
  }
}","public void serializeToStream(OutputStream bos) throws IOException {
  int numOutsCreated=txOutsCreated.size();
  bos.write(0xFF & (numOutsCreated >> 0));
  bos.write(0xFF & (numOutsCreated >> 8));
  bos.write(0xFF & (numOutsCreated >> 16));
  bos.write(0xFF & (numOutsCreated >> 24));
  for (  StoredTransactionOutput output : txOutsCreated) {
    output.serializeToStream(bos);
  }
  int numOutsSpent=txOutsSpent.size();
  bos.write(0xFF & (numOutsSpent >> 0));
  bos.write(0xFF & (numOutsSpent >> 8));
  bos.write(0xFF & (numOutsSpent >> 16));
  bos.write(0xFF & (numOutsSpent >> 24));
  for (  StoredTransactionOutput output : txOutsSpent) {
    output.serializeToStream(bos);
  }
}",0.8137254901960784
85862,"@Test public void badDifficulty() throws Exception {
  assertTrue(testNetChain.add(getBlock1()));
  Block b2=getBlock2();
  assertTrue(testNetChain.add(b2));
  NetworkParameters params2=NetworkParameters.testNet();
  Block bad=new Block(params2);
  bad.setMerkleRoot(new Sha256Hash(""String_Node_Str""));
  bad.setNonce(140548933);
  bad.setTime(1279242649);
  bad.setPrevBlockHash(b2.getHash());
  bad.setDifficultyTarget(Block.EASIEST_DIFFICULTY_TARGET);
  try {
    testNetChain.add(bad);
    fail();
  }
 catch (  VerificationException e) {
    assertTrue(e.getMessage(),e.getCause().getMessage().indexOf(""String_Node_Str"") >= 0);
  }
  params2.proofOfWorkLimit=new BigInteger(""String_Node_Str"",16);
  try {
    testNetChain.add(bad);
    fail();
  }
 catch (  VerificationException e) {
    assertTrue(e.getMessage(),e.getCause().getMessage().indexOf(""String_Node_Str"") >= 0);
  }
}","@Test public void badDifficulty() throws Exception {
  assertTrue(testNetChain.add(getBlock1()));
  Block b2=getBlock2();
  assertTrue(testNetChain.add(b2));
  Block bad=new Block(testNet);
  bad.setMerkleRoot(new Sha256Hash(""String_Node_Str""));
  bad.setNonce(140548933);
  bad.setTime(1279242649);
  bad.setPrevBlockHash(b2.getHash());
  bad.setDifficultyTarget(Block.EASIEST_DIFFICULTY_TARGET);
  try {
    testNetChain.add(bad);
    fail();
  }
 catch (  VerificationException e) {
    assertTrue(e.getMessage(),e.getCause().getMessage().indexOf(""String_Node_Str"") >= 0);
  }
  BigInteger oldVal=testNet.proofOfWorkLimit;
  testNet.proofOfWorkLimit=new BigInteger(""String_Node_Str"",16);
  try {
    testNetChain.add(bad);
    fail();
  }
 catch (  VerificationException e) {
    assertTrue(e.getMessage(),e.getCause().getMessage().indexOf(""String_Node_Str"") >= 0);
  }
  testNet.proofOfWorkLimit=oldVal;
}",0.89520624303233
85863,"@Before public void setUp() throws Exception {
  BriefLogFormatter.init();
  unitTestParams=NetworkParameters.unitTests();
  unitTestParams.interval=10000;
  store=new MemoryFullPrunedBlockStore(unitTestParams,UNDOABLE_BLOCKS_STORED);
  chain=new FullPrunedBlockChain(unitTestParams,store);
}","@Before public void setUp() throws Exception {
  BriefLogFormatter.init();
  unitTestParams=NetworkParameters.unitTests();
  oldInterval=unitTestParams.interval;
  unitTestParams.interval=10000;
  store=new MemoryFullPrunedBlockStore(unitTestParams,UNDOABLE_BLOCKS_STORED);
  chain=new FullPrunedBlockChain(unitTestParams,store);
}",0.9373996789727128
85864,"/** 
 * Catch any exceptions, logging them and then closing the channel. 
 */
@Override public void exceptionCaught(ChannelHandlerContext ctx,ExceptionEvent e) throws Exception {
  String s;
  PeerAddress addr=address.get();
  s=address == null ? ""String_Node_Str"" : address.toString();
  if (e.getCause() instanceof ConnectException || e.getCause() instanceof IOException) {
    log.info(s + ""String_Node_Str"" + e.getCause().getMessage());
  }
 else {
    log.warn(s + ""String_Node_Str"",e.getCause());
  }
  e.getChannel().close();
}","/** 
 * Catch any exceptions, logging them and then closing the channel. 
 */
@Override public void exceptionCaught(ChannelHandlerContext ctx,ExceptionEvent e) throws Exception {
  String s;
  PeerAddress addr=address.get();
  s=addr == null ? ""String_Node_Str"" : addr.toString();
  if (e.getCause() instanceof ConnectException || e.getCause() instanceof IOException) {
    log.info(s + ""String_Node_Str"" + e.getCause().getMessage());
  }
 else {
    log.warn(s + ""String_Node_Str"",e.getCause());
  }
  e.getChannel().close();
}",0.9943502824858758
85865,"private synchronized void processHeaders(HeadersMessage m) throws IOException, ProtocolException {
  Preconditions.checkState(!downloadBlockBodies,toString());
  try {
    for (int i=0; i < m.getBlockHeaders().size(); i++) {
      Block header=m.getBlockHeaders().get(i);
      if (header.getTimeSeconds() < fastCatchupTimeSecs) {
        if (blockChain.add(header)) {
          invokeOnBlocksDownloaded(header);
        }
 else {
          throw new ProtocolException(""String_Node_Str"" + header.getHashAsString());
        }
      }
 else {
        log.info(""String_Node_Str"",m.getBlockHeaders().size() - i);
        downloadBlockBodies=true;
        lastGetBlocksBegin=Sha256Hash.ZERO_HASH;
        blockChainDownload(Sha256Hash.ZERO_HASH);
        return;
      }
    }
    if (m.getBlockHeaders().size() >= HeadersMessage.MAX_HEADERS)     blockChainDownload(Sha256Hash.ZERO_HASH);
  }
 catch (  VerificationException e) {
    log.warn(""String_Node_Str"",e);
  }
catch (  PrunedException e) {
    throw new RuntimeException(e);
  }
}","private synchronized void processHeaders(HeadersMessage m) throws IOException, ProtocolException {
  Preconditions.checkState(!downloadBlockBodies,toString());
  try {
    for (int i=0; i < m.getBlockHeaders().size(); i++) {
      Block header=m.getBlockHeaders().get(i);
      if (header.getTimeSeconds() < fastCatchupTimeSecs) {
        if (!downloadData.get()) {
          log.info(""String_Node_Str"");
          return;
        }
        if (blockChain.add(header)) {
          invokeOnBlocksDownloaded(header);
        }
 else {
          throw new ProtocolException(""String_Node_Str"" + header.getHashAsString());
        }
      }
 else {
        log.info(""String_Node_Str"",m.getBlockHeaders().size() - i);
        downloadBlockBodies=true;
        lastGetBlocksBegin=Sha256Hash.ZERO_HASH;
        blockChainDownload(Sha256Hash.ZERO_HASH);
        return;
      }
    }
    if (m.getBlockHeaders().size() >= HeadersMessage.MAX_HEADERS)     blockChainDownload(Sha256Hash.ZERO_HASH);
  }
 catch (  VerificationException e) {
    log.warn(""String_Node_Str"",e);
  }
catch (  PrunedException e) {
    throw new RuntimeException(e);
  }
}",0.9530386740331492
85866,"/** 
 * Handle when a transaction becomes newly active on the best chain, either due to receiving a new block or a re-org making inactive transactions active.
 */
private void processTxFromBestChain(Transaction tx) throws VerificationException {
  boolean isDeadCoinbase=tx.isCoinBase() && dead.containsKey(tx.getHash());
  if (isDeadCoinbase) {
    log.info(""String_Node_Str"",tx.getHashAsString(),tx.getConfidence().getConfidenceType().name());
    dead.remove(tx.getHash());
  }
  if (inactive.containsKey(tx.getHash())) {
    log.info(""String_Node_Str"",tx.getHashAsString());
    inactive.remove(tx.getHash());
  }
  updateForSpends(tx,true);
  if (!tx.getValueSentToMe(this).equals(BigInteger.ZERO)) {
    log.info(""String_Node_Str"",tx.getHashAsString());
    addWalletTransaction(Pool.UNSPENT,tx);
  }
 else   if (!tx.getValueSentFromMe(this).equals(BigInteger.ZERO)) {
    log.info(""String_Node_Str"",tx.getHashAsString());
    addWalletTransaction(Pool.SPENT,tx);
  }
 else {
    Transaction doubleSpend=findDoubleSpendAgainstPending(tx);
    if (doubleSpend == null)     throw new IllegalStateException(""String_Node_Str"");
    log.warn(""String_Node_Str"",doubleSpend.getHashAsString());
    log.warn(""String_Node_Str"");
    pending.remove(doubleSpend.getHash());
    addWalletTransaction(Pool.DEAD,doubleSpend);
    doubleSpend.getConfidence().setOverridingTransaction(tx);
  }
}","/** 
 * Handle when a transaction becomes newly active on the best chain, either due to receiving a new block or a re-org making inactive transactions active.
 */
private void processTxFromBestChain(Transaction tx) throws VerificationException {
  boolean isDeadCoinbase=tx.isCoinBase() && dead.containsKey(tx.getHash());
  if (isDeadCoinbase) {
    log.info(""String_Node_Str"",tx.getHashAsString(),tx.getConfidence().getConfidenceType().name());
    dead.remove(tx.getHash());
  }
  if (inactive.containsKey(tx.getHash())) {
    log.info(""String_Node_Str"",tx.getHashAsString());
    inactive.remove(tx.getHash());
  }
  updateForSpends(tx,true);
  if (!tx.isEveryOwnedOutputSpent(this)) {
    log.info(""String_Node_Str"",tx.getHashAsString());
    addWalletTransaction(Pool.UNSPENT,tx);
  }
 else   if (!tx.getValueSentFromMe(this).equals(BigInteger.ZERO)) {
    log.info(""String_Node_Str"",tx.getHashAsString());
    addWalletTransaction(Pool.SPENT,tx);
  }
 else {
    Transaction doubleSpend=findDoubleSpendAgainstPending(tx);
    if (doubleSpend == null)     throw new IllegalStateException(""String_Node_Str"");
    log.warn(""String_Node_Str"",doubleSpend.getHashAsString());
    log.warn(""String_Node_Str"");
    pending.remove(doubleSpend.getHash());
    addWalletTransaction(Pool.DEAD,doubleSpend);
    doubleSpend.getConfidence().setOverridingTransaction(tx);
  }
}",0.9749364329822012
85867,"private synchronized void receive(Transaction tx,StoredBlock block,BlockChain.NewBlockType blockType,boolean reorg) throws VerificationException {
  BigInteger prevBalance=getBalance();
  Sha256Hash txHash=tx.getHash();
  boolean bestChain=blockType == BlockChain.NewBlockType.BEST_CHAIN;
  boolean sideChain=blockType == BlockChain.NewBlockType.SIDE_CHAIN;
  BigInteger valueSentFromMe=tx.getValueSentFromMe(this);
  BigInteger valueSentToMe=tx.getValueSentToMe(this);
  BigInteger valueDifference=valueSentToMe.subtract(valueSentFromMe);
  if (!reorg) {
    log.info(""String_Node_Str"",new Object[]{sideChain ? ""String_Node_Str"" : ""String_Node_Str"",bitcoinValueToFriendlyString(valueDifference),tx.getHashAsString()});
  }
  onWalletChangedSuppressions++;
  Transaction wtx;
  if ((wtx=pending.remove(txHash)) != null) {
    tx=wtx;
    log.info(""String_Node_Str"");
    if (bestChain) {
      if (valueSentToMe.equals(BigInteger.ZERO)) {
        log.info(""String_Node_Str"");
        addWalletTransaction(Pool.SPENT,tx);
      }
 else {
        log.info(""String_Node_Str"");
        addWalletTransaction(Pool.UNSPENT,tx);
      }
    }
 else     if (sideChain) {
      log.info(""String_Node_Str"");
      boolean alreadyPresent=inactive.put(tx.getHash(),tx) != null;
      if (alreadyPresent)       log.info(""String_Node_Str"");
      pending.put(tx.getHash(),tx);
    }
  }
 else {
    if (sideChain) {
      if (unspent.containsKey(tx.getHash()) || spent.containsKey(tx.getHash())) {
      }
 else {
        log.info(""String_Node_Str"");
        addWalletTransaction(Pool.INACTIVE,tx);
      }
    }
 else     if (bestChain) {
      processTxFromBestChain(tx);
    }
  }
  log.info(""String_Node_Str"" + bitcoinValueToFriendlyString(getBalance()));
  if (block != null) {
    tx.setBlockAppearance(block,bestChain);
    if (bestChain) {
      ignoreNextNewBlock.add(txHash);
    }
  }
  boolean wasPending=wtx != null;
  if (!reorg && bestChain && !wasPending) {
    BigInteger newBalance=getBalance();
    int diff=valueDifference.compareTo(BigInteger.ZERO);
    if (diff > 0) {
      invokeOnCoinsReceived(tx,prevBalance,newBalance);
    }
 else     if (diff == 0) {
      invokeOnCoinsSent(tx,prevBalance,newBalance);
    }
 else {
      invokeOnCoinsSent(tx,prevBalance,newBalance);
    }
  }
  onWalletChangedSuppressions--;
  checkState(isConsistent());
  queueAutoSave();
}","private synchronized void receive(Transaction tx,StoredBlock block,BlockChain.NewBlockType blockType,boolean reorg) throws VerificationException {
  BigInteger prevBalance=getBalance();
  Sha256Hash txHash=tx.getHash();
  boolean bestChain=blockType == BlockChain.NewBlockType.BEST_CHAIN;
  boolean sideChain=blockType == BlockChain.NewBlockType.SIDE_CHAIN;
  BigInteger valueSentFromMe=tx.getValueSentFromMe(this);
  BigInteger valueSentToMe=tx.getValueSentToMe(this);
  BigInteger valueDifference=valueSentToMe.subtract(valueSentFromMe);
  if (!reorg) {
    log.info(""String_Node_Str"",new Object[]{sideChain ? ""String_Node_Str"" : ""String_Node_Str"",bitcoinValueToFriendlyString(valueDifference),tx.getHashAsString()});
  }
  onWalletChangedSuppressions++;
  Transaction wtx;
  if ((wtx=pending.remove(txHash)) != null) {
    tx=wtx;
    log.info(""String_Node_Str"");
    if (bestChain) {
      if (tx.isEveryOwnedOutputSpent(this)) {
        log.info(""String_Node_Str"");
        addWalletTransaction(Pool.SPENT,tx);
      }
 else {
        log.info(""String_Node_Str"");
        addWalletTransaction(Pool.UNSPENT,tx);
      }
    }
 else     if (sideChain) {
      log.info(""String_Node_Str"");
      boolean alreadyPresent=inactive.put(tx.getHash(),tx) != null;
      if (alreadyPresent)       log.info(""String_Node_Str"");
      pending.put(tx.getHash(),tx);
    }
  }
 else {
    if (sideChain) {
      if (unspent.containsKey(tx.getHash()) || spent.containsKey(tx.getHash())) {
      }
 else {
        log.info(""String_Node_Str"");
        addWalletTransaction(Pool.INACTIVE,tx);
      }
    }
 else     if (bestChain) {
      processTxFromBestChain(tx);
    }
  }
  log.info(""String_Node_Str"" + bitcoinValueToFriendlyString(getBalance()));
  if (block != null) {
    tx.setBlockAppearance(block,bestChain);
    if (bestChain) {
      ignoreNextNewBlock.add(txHash);
    }
  }
  boolean wasPending=wtx != null;
  if (!reorg && bestChain && !wasPending) {
    BigInteger newBalance=getBalance();
    int diff=valueDifference.compareTo(BigInteger.ZERO);
    if (diff > 0) {
      invokeOnCoinsReceived(tx,prevBalance,newBalance);
    }
 else     if (diff == 0) {
      invokeOnCoinsSent(tx,prevBalance,newBalance);
    }
 else {
      invokeOnCoinsSent(tx,prevBalance,newBalance);
    }
  }
  onWalletChangedSuppressions--;
  checkState(isConsistent());
  queueAutoSave();
}",0.9867284600800506
85868,"@Test public void basicSpending() throws Exception {
  BigInteger v1=Utils.toNanoCoins(1,0);
  Transaction t1=sendMoneyToWallet(v1,null);
  assertEquals(BigInteger.ZERO,wallet.getBalance());
  assertEquals(v1,wallet.getBalance(Wallet.BalanceType.ESTIMATED));
  assertEquals(1,wallet.getPoolSize(Pool.PENDING));
  assertEquals(0,wallet.getPoolSize(WalletTransaction.Pool.UNSPENT));
  sendMoneyToWallet(t1,AbstractBlockChain.NewBlockType.BEST_CHAIN);
  assertEquals(v1,wallet.getBalance());
  assertEquals(1,wallet.getPoolSize(WalletTransaction.Pool.UNSPENT));
  assertEquals(1,wallet.getPoolSize(WalletTransaction.Pool.ALL));
  Address destination=new ECKey().toAddress(params);
  BigInteger v2=toNanoCoins(0,50);
  Wallet.SendRequest req=Wallet.SendRequest.to(destination,v2);
  req.fee=toNanoCoins(0,1);
  wallet.completeTx(req);
  Transaction t2=req.tx;
  assertEquals(1,wallet.getPoolSize(WalletTransaction.Pool.UNSPENT));
  assertEquals(1,wallet.getPoolSize(WalletTransaction.Pool.ALL));
  assertEquals(TransactionConfidence.Source.SELF,t2.getConfidence().getSource());
  assertEquals(1,t2.getInputs().size());
  assertEquals(myAddress,t2.getInputs().get(0).getScriptSig().getFromAddress());
  assertEquals(t2.getConfidence().getConfidenceType(),TransactionConfidence.ConfidenceType.NOT_SEEN_IN_CHAIN);
  assertEquals(2,t2.getOutputs().size());
  assertEquals(destination,t2.getOutputs().get(0).getScriptPubKey().getToAddress());
  assertEquals(wallet.getChangeAddress(),t2.getOutputs().get(1).getScriptPubKey().getToAddress());
  BigInteger v3=toNanoCoins(0,49);
  assertEquals(v3,t2.getOutputs().get(1).getValue());
  t2.getInputs().get(0).verify();
  final LinkedList<Transaction> txns=Lists.newLinkedList();
  wallet.addEventListener(new AbstractWalletEventListener(){
    @Override public void onCoinsSent(    Wallet wallet,    Transaction tx,    BigInteger prevBalance,    BigInteger newBalance){
      txns.add(tx);
    }
  }
);
  t2.getConfidence().markBroadcastBy(new PeerAddress(InetAddress.getByAddress(new byte[]{1,2,3,4})));
  t2.getConfidence().markBroadcastBy(new PeerAddress(InetAddress.getByAddress(new byte[]{10,2,3,4})));
  wallet.commitTx(t2);
  assertEquals(1,wallet.getPoolSize(WalletTransaction.Pool.PENDING));
  assertEquals(1,wallet.getPoolSize(WalletTransaction.Pool.SPENT));
  assertEquals(2,wallet.getPoolSize(WalletTransaction.Pool.ALL));
  assertEquals(t2,txns.getFirst());
  assertEquals(1,txns.size());
  assertEquals(v3,wallet.getBalance());
  Transaction t3=wallet.createSend(new ECKey().toAddress(params),v3);
  assertNotNull(t3);
}","@Test public void basicSpending() throws Exception {
  BigInteger v1=Utils.toNanoCoins(1,0);
  Transaction t1=sendMoneyToWallet(v1,null);
  assertEquals(BigInteger.ZERO,wallet.getBalance());
  assertEquals(v1,wallet.getBalance(Wallet.BalanceType.ESTIMATED));
  assertEquals(1,wallet.getPoolSize(Pool.PENDING));
  assertEquals(0,wallet.getPoolSize(WalletTransaction.Pool.UNSPENT));
  sendMoneyToWallet(t1,AbstractBlockChain.NewBlockType.BEST_CHAIN);
  assertEquals(v1,wallet.getBalance());
  assertEquals(1,wallet.getPoolSize(WalletTransaction.Pool.UNSPENT));
  assertEquals(1,wallet.getPoolSize(WalletTransaction.Pool.ALL));
  Address destination=new ECKey().toAddress(params);
  BigInteger v2=toNanoCoins(0,50);
  Wallet.SendRequest req=Wallet.SendRequest.to(destination,v2);
  req.fee=toNanoCoins(0,1);
  wallet.completeTx(req);
  Transaction t2=req.tx;
  assertEquals(1,wallet.getPoolSize(WalletTransaction.Pool.UNSPENT));
  assertEquals(1,wallet.getPoolSize(WalletTransaction.Pool.ALL));
  assertEquals(TransactionConfidence.Source.SELF,t2.getConfidence().getSource());
  assertEquals(1,t2.getInputs().size());
  assertEquals(myAddress,t2.getInputs().get(0).getScriptSig().getFromAddress());
  assertEquals(t2.getConfidence().getConfidenceType(),TransactionConfidence.ConfidenceType.NOT_SEEN_IN_CHAIN);
  assertEquals(2,t2.getOutputs().size());
  assertEquals(destination,t2.getOutputs().get(0).getScriptPubKey().getToAddress());
  assertEquals(wallet.getChangeAddress(),t2.getOutputs().get(1).getScriptPubKey().getToAddress());
  BigInteger v3=toNanoCoins(0,49);
  assertEquals(v3,t2.getOutputs().get(1).getValue());
  t2.getInputs().get(0).verify();
  final LinkedList<Transaction> txns=Lists.newLinkedList();
  wallet.addEventListener(new AbstractWalletEventListener(){
    @Override public void onCoinsSent(    Wallet wallet,    Transaction tx,    BigInteger prevBalance,    BigInteger newBalance){
      txns.add(tx);
    }
  }
);
  t2.getConfidence().markBroadcastBy(new PeerAddress(InetAddress.getByAddress(new byte[]{1,2,3,4})));
  t2.getConfidence().markBroadcastBy(new PeerAddress(InetAddress.getByAddress(new byte[]{10,2,3,4})));
  wallet.commitTx(t2);
  assertEquals(1,wallet.getPoolSize(WalletTransaction.Pool.PENDING));
  assertEquals(1,wallet.getPoolSize(WalletTransaction.Pool.SPENT));
  assertEquals(2,wallet.getPoolSize(WalletTransaction.Pool.ALL));
  assertEquals(t2,txns.getFirst());
  assertEquals(1,txns.size());
  assertEquals(v3,wallet.getBalance());
  Transaction t3=wallet.createSend(new ECKey().toAddress(params),v3);
  assertNotNull(t3);
  wallet.commitTx(t3);
  assertTrue(wallet.isConsistent());
  BlockPair bp=createFakeBlock(blockStore,t2,t3);
  wallet.receiveFromBlock(t2,bp.storedBlock,AbstractBlockChain.NewBlockType.BEST_CHAIN);
  wallet.receiveFromBlock(t3,bp.storedBlock,AbstractBlockChain.NewBlockType.BEST_CHAIN);
  wallet.notifyNewBestBlock(bp.block);
  assertTrue(wallet.isConsistent());
}",0.9338903014892844
85869,"/** 
 * Returns a list of peers that were found in the IRC channel. Note that just because a peer appears in the list does not mean it is accepting connections. The given time out value is applied for every IP returned by DNS for the given server, so a timeout value of 1 second may result in 5 seconds delay if 5 servers are advertised.
 */
public InetSocketAddress[] getPeers(long timeoutValue,TimeUnit timeoutUnit) throws PeerDiscoveryException {
  ArrayList<InetSocketAddress> addresses=new ArrayList<InetSocketAddress>();
  connection=null;
  BufferedReader reader=null;
  try {
    InetAddress[] ips=InetAddress.getAllByName(server);
    int ipCursorStart=(int)(Math.random() * ips.length);
    int ipCursor=ipCursorStart;
    do {
      connection=new Socket();
      try {
        InetAddress ip=ips[ipCursor];
        long timeoutMsec=TimeUnit.MILLISECONDS.convert(timeoutValue,timeoutUnit);
        log.info(""String_Node_Str"" + ip);
        connection.connect(new InetSocketAddress(ip,port),(int)timeoutMsec);
      }
 catch (      SocketTimeoutException e) {
        connection=null;
      }
catch (      IOException e) {
        connection=null;
      }
      ipCursor=(ipCursor + 1) % ips.length;
      if (ipCursor == ipCursorStart) {
        throw new PeerDiscoveryException(""String_Node_Str"" + server);
      }
    }
 while (connection == null);
    writer=new BufferedWriter(new OutputStreamWriter(connection.getOutputStream(),""String_Node_Str""));
    reader=new BufferedReader(new InputStreamReader(connection.getInputStream(),""String_Node_Str""));
    String nickRnd=String.format(""String_Node_Str"",new Random().nextInt(Integer.MAX_VALUE));
    String command=""String_Node_Str"" + nickRnd;
    logAndSend(command);
    command=""String_Node_Str"" + nickRnd + ""String_Node_Str""+ nickRnd;
    logAndSend(command);
    writer.flush();
    String currLine;
    while ((currLine=reader.readLine()) != null) {
      onIRCReceive(currLine);
      if (checkLineStatus(""String_Node_Str"",currLine)) {
        break;
      }
    }
    logAndSend(""String_Node_Str"" + channel);
    logAndSend(""String_Node_Str"" + channel);
    writer.flush();
    while ((currLine=reader.readLine()) != null) {
      onIRCReceive(currLine);
      if (checkLineStatus(""String_Node_Str"",currLine)) {
        int subIndex=0;
        if (currLine.startsWith(""String_Node_Str"")) {
          subIndex=1;
        }
        String spacedList=currLine.substring(currLine.indexOf(""String_Node_Str"",subIndex));
        addresses.addAll(parseUserList(spacedList.substring(1).split(""String_Node_Str"")));
      }
 else       if (checkLineStatus(""String_Node_Str"",currLine)) {
        break;
      }
    }
    logAndSend(""String_Node_Str"" + channel);
    logAndSend(""String_Node_Str"");
    writer.flush();
  }
 catch (  Exception e) {
    throw new PeerDiscoveryException(e.getMessage(),e);
  }
 finally {
    try {
      if (reader != null)       reader.close();
      if (writer != null)       writer.close();
      if (connection != null)       connection.close();
    }
 catch (    IOException e) {
      log.warn(""String_Node_Str"" + e.toString());
    }
  }
  return addresses.toArray(new InetSocketAddress[]{});
}","/** 
 * Returns a list of peers that were found in the IRC channel. Note that just because a peer appears in the list does not mean it is accepting connections. The given time out value is applied for every IP returned by DNS for the given server, so a timeout value of 1 second may result in 5 seconds delay if 5 servers are advertised.
 */
public InetSocketAddress[] getPeers(long timeoutValue,TimeUnit timeoutUnit) throws PeerDiscoveryException {
  ArrayList<InetSocketAddress> addresses=new ArrayList<InetSocketAddress>();
  connection=null;
  BufferedReader reader=null;
  try {
    InetAddress[] ips=InetAddress.getAllByName(server);
    int ipCursorStart=(int)(Math.random() * ips.length);
    int ipCursor=ipCursorStart;
    do {
      connection=new Socket();
      int timeoutMsec=(int)TimeUnit.MILLISECONDS.convert(timeoutValue,timeoutUnit);
      connection.setSoTimeout(timeoutMsec);
      try {
        InetAddress ip=ips[ipCursor];
        log.info(""String_Node_Str"" + ip);
        connection.connect(new InetSocketAddress(ip,port),timeoutMsec);
      }
 catch (      SocketTimeoutException e) {
        connection=null;
      }
catch (      IOException e) {
        connection=null;
      }
      ipCursor=(ipCursor + 1) % ips.length;
      if (ipCursor == ipCursorStart) {
        throw new PeerDiscoveryException(""String_Node_Str"" + server);
      }
    }
 while (connection == null);
    writer=new BufferedWriter(new OutputStreamWriter(connection.getOutputStream(),""String_Node_Str""));
    reader=new BufferedReader(new InputStreamReader(connection.getInputStream(),""String_Node_Str""));
    String nickRnd=String.format(""String_Node_Str"",new Random().nextInt(Integer.MAX_VALUE));
    String command=""String_Node_Str"" + nickRnd;
    logAndSend(command);
    command=""String_Node_Str"" + nickRnd + ""String_Node_Str""+ nickRnd;
    logAndSend(command);
    writer.flush();
    String currLine;
    while ((currLine=reader.readLine()) != null) {
      onIRCReceive(currLine);
      if (checkLineStatus(""String_Node_Str"",currLine)) {
        break;
      }
    }
    logAndSend(""String_Node_Str"" + channel);
    logAndSend(""String_Node_Str"" + channel);
    writer.flush();
    while ((currLine=reader.readLine()) != null) {
      onIRCReceive(currLine);
      if (checkLineStatus(""String_Node_Str"",currLine)) {
        int subIndex=0;
        if (currLine.startsWith(""String_Node_Str"")) {
          subIndex=1;
        }
        String spacedList=currLine.substring(currLine.indexOf(""String_Node_Str"",subIndex));
        addresses.addAll(parseUserList(spacedList.substring(1).split(""String_Node_Str"")));
      }
 else       if (checkLineStatus(""String_Node_Str"",currLine)) {
        break;
      }
    }
    logAndSend(""String_Node_Str"" + channel);
    logAndSend(""String_Node_Str"");
    writer.flush();
  }
 catch (  Exception e) {
    throw new PeerDiscoveryException(e.getMessage(),e);
  }
 finally {
    try {
      if (reader != null)       reader.close();
      if (writer != null)       writer.close();
      if (connection != null)       connection.close();
    }
 catch (    IOException e) {
      log.warn(""String_Node_Str"" + e.toString());
    }
  }
  return addresses.toArray(new InetSocketAddress[]{});
}",0.97086773640754
85870,"/** 
 * A human readable version of the transaction useful for debugging. The format is not guaranteed to be stable.
 * @param chain If provided, will be used to estimate lock times (if set). Can be null.
 */
public String toString(AbstractBlockChain chain){
  StringBuffer s=new StringBuffer();
  s.append(String.format(""String_Node_Str"",getHashAsString(),getConfidence()));
  if (lockTime > 0) {
    String time;
    if (lockTime < LOCKTIME_THRESHOLD) {
      time=""String_Node_Str"" + lockTime;
      if (chain != null) {
        time=time + ""String_Node_Str"" + chain.estimateBlockTime((int)lockTime).toString()+ ""String_Node_Str"";
      }
    }
 else {
      time=new Date(lockTime).toString();
    }
    s.append(String.format(""String_Node_Str"",time));
  }
  if (inputs.size() == 0) {
    s.append(String.format(""String_Node_Str""));
    return s.toString();
  }
  if (isCoinBase()) {
    String script;
    String script2;
    try {
      script=inputs.get(0).getScriptSig().toString();
      script2=outputs.get(0).getScriptPubKey().toString();
    }
 catch (    ScriptException e) {
      script=""String_Node_Str"";
      script2=""String_Node_Str"";
    }
    return ""String_Node_Str"" + script + ""String_Node_Str""+ script2+ ""String_Node_Str"";
  }
  for (  TransactionInput in : inputs) {
    s.append(""String_Node_Str"");
    s.append(""String_Node_Str"");
    try {
      Script scriptSig=in.getScriptSig();
      if (scriptSig.chunks.size() == 2)       s.append(scriptSig.getFromAddress().toString());
 else       if (scriptSig.chunks.size() == 1)       s.append(""String_Node_Str"" + bytesToHexString(scriptSig.getPubKey()) + ""String_Node_Str"");
 else       s.append(""String_Node_Str"");
      s.append(""String_Node_Str"");
      s.append(in.getOutpoint().toString());
    }
 catch (    Exception e) {
      s.append(""String_Node_Str"").append(e.getMessage()).append(""String_Node_Str"");
    }
    s.append(String.format(""String_Node_Str""));
  }
  for (  TransactionOutput out : outputs) {
    s.append(""String_Node_Str"");
    s.append(""String_Node_Str"");
    try {
      Script scriptPubKey=out.getScriptPubKey();
      if (scriptPubKey.isSentToAddress()) {
        s.append(scriptPubKey.getToAddress().toString());
      }
 else       if (scriptPubKey.isSentToRawPubKey()) {
        s.append(""String_Node_Str"");
        s.append(bytesToHexString(scriptPubKey.getPubKey()));
        s.append(""String_Node_Str"");
      }
      s.append(""String_Node_Str"");
      s.append(bitcoinValueToFriendlyString(out.getValue()));
      s.append(""String_Node_Str"");
      if (!out.isAvailableForSpending()) {
        s.append(""String_Node_Str"");
      }
      if (out.getSpentBy() != null) {
        s.append(""String_Node_Str"");
        s.append(out.getSpentBy().getParentTransaction().getHashAsString());
      }
    }
 catch (    Exception e) {
      s.append(""String_Node_Str"").append(e.getMessage()).append(""String_Node_Str"");
    }
    s.append(String.format(""String_Node_Str""));
  }
  return s.toString();
}","/** 
 * A human readable version of the transaction useful for debugging. The format is not guaranteed to be stable.
 * @param chain If provided, will be used to estimate lock times (if set). Can be null.
 */
public String toString(AbstractBlockChain chain){
  StringBuffer s=new StringBuffer();
  s.append(String.format(""String_Node_Str"",getHashAsString(),getConfidence()));
  if (lockTime > 0) {
    String time;
    if (lockTime < LOCKTIME_THRESHOLD) {
      time=""String_Node_Str"" + lockTime;
      if (chain != null) {
        time=time + ""String_Node_Str"" + chain.estimateBlockTime((int)lockTime).toString()+ ""String_Node_Str"";
      }
    }
 else {
      time=new Date(lockTime).toString();
    }
    s.append(String.format(""String_Node_Str"",time));
  }
  if (inputs.size() == 0) {
    s.append(String.format(""String_Node_Str""));
    return s.toString();
  }
  if (isCoinBase()) {
    String script;
    String script2;
    try {
      script=inputs.get(0).getScriptSig().toString();
      script2=outputs.get(0).getScriptPubKey().toString();
    }
 catch (    ScriptException e) {
      script=""String_Node_Str"";
      script2=""String_Node_Str"";
    }
    return ""String_Node_Str"" + script + ""String_Node_Str""+ script2+ ""String_Node_Str"";
  }
  for (  TransactionInput in : inputs) {
    s.append(""String_Node_Str"");
    s.append(""String_Node_Str"");
    try {
      Script scriptSig=in.getScriptSig();
      if (scriptSig.chunks.size() == 2)       s.append(scriptSig.getFromAddress().toString());
 else       if (scriptSig.chunks.size() == 1)       s.append(""String_Node_Str"" + bytesToHexString(scriptSig.chunks.get(0).data) + ""String_Node_Str"");
 else       s.append(""String_Node_Str"");
      s.append(""String_Node_Str"");
      s.append(in.getOutpoint().toString());
    }
 catch (    Exception e) {
      s.append(""String_Node_Str"").append(e.getMessage()).append(""String_Node_Str"");
    }
    s.append(String.format(""String_Node_Str""));
  }
  for (  TransactionOutput out : outputs) {
    s.append(""String_Node_Str"");
    s.append(""String_Node_Str"");
    try {
      Script scriptPubKey=out.getScriptPubKey();
      if (scriptPubKey.isSentToAddress()) {
        s.append(scriptPubKey.getToAddress().toString());
      }
 else       if (scriptPubKey.isSentToRawPubKey()) {
        s.append(""String_Node_Str"");
        s.append(bytesToHexString(scriptPubKey.getPubKey()));
        s.append(""String_Node_Str"");
      }
      s.append(""String_Node_Str"");
      s.append(bitcoinValueToFriendlyString(out.getValue()));
      s.append(""String_Node_Str"");
      if (!out.isAvailableForSpending()) {
        s.append(""String_Node_Str"");
      }
      if (out.getSpentBy() != null) {
        s.append(""String_Node_Str"");
        s.append(out.getSpentBy().getParentTransaction().getHashAsString());
      }
    }
 catch (    Exception e) {
      s.append(""String_Node_Str"").append(e.getMessage()).append(""String_Node_Str"");
    }
    s.append(String.format(""String_Node_Str""));
  }
  return s.toString();
}",0.6320173246709978
85871,"protected synchronized void handleNewPeer(final Peer peer){
  log.info(""String_Node_Str"",peer);
  try {
    if (bloomFilter != null)     peer.sendMessage(bloomFilter);
  }
 catch (  IOException e) {
  }
  peer.setMemoryPool(memoryPool);
  peer.setDownloadData(false);
  if (downloadListener != null && downloadPeer == null && chain != null) {
    log.info(""String_Node_Str"");
    startBlockChainDownloadFromPeer(peer);
  }
 else {
    Peer newDownloadPeer=selectDownloadPeer(peers);
    if (downloadPeer != newDownloadPeer) {
      setDownloadPeer(newDownloadPeer);
    }
  }
  peer.addEventListener(getDataListener);
  announcePendingWalletTransactions(wallets,Collections.singletonList(peer));
  for (  PeerEventListener listener : peerEventListeners) {
    peer.addEventListener(listener);
  }
  setupPingingForNewPeer(peer);
  EventListenerInvoker.invoke(peerEventListeners,new EventListenerInvoker<PeerEventListener>(){
    @Override public void invoke(    PeerEventListener listener){
      listener.onPeerConnected(peer,peers.size());
    }
  }
);
  final PeerGroup thisGroup=this;
  peer.addEventListener(new AbstractPeerEventListener(){
    int filteredBlocksReceivedFromPeer=0;
    @Override public Message onPreMessageReceived(    Peer peer,    Message m){
      if (m instanceof FilteredBlock) {
        filteredBlocksReceivedFromPeer++;
        if (filteredBlocksReceivedFromPeer % RESEND_BLOOM_FILTER_BLOCK_COUNT == RESEND_BLOOM_FILTER_BLOCK_COUNT - 1) {
          try {
synchronized (thisGroup) {
              peer.sendMessage(bloomFilter);
            }
          }
 catch (          IOException e) {
            throw new RuntimeException(e);
          }
        }
      }
      return m;
    }
  }
);
}","protected synchronized void handleNewPeer(final Peer peer){
  log.info(""String_Node_Str"",peer);
  try {
    if (bloomFilter != null)     peer.sendMessage(bloomFilter);
  }
 catch (  IOException e) {
  }
  peer.setMemoryPool(memoryPool);
  peer.setDownloadData(false);
  Peer newDownloadPeer=selectDownloadPeer(peers);
  if (downloadPeer != newDownloadPeer) {
    setDownloadPeer(newDownloadPeer);
    boolean shouldDownloadChain=downloadListener != null && chain != null;
    if (shouldDownloadChain) {
      startBlockChainDownloadFromPeer(downloadPeer);
    }
  }
  peer.addEventListener(getDataListener);
  announcePendingWalletTransactions(wallets,Collections.singletonList(peer));
  for (  PeerEventListener listener : peerEventListeners) {
    peer.addEventListener(listener);
  }
  setupPingingForNewPeer(peer);
  EventListenerInvoker.invoke(peerEventListeners,new EventListenerInvoker<PeerEventListener>(){
    @Override public void invoke(    PeerEventListener listener){
      listener.onPeerConnected(peer,peers.size());
    }
  }
);
  final PeerGroup thisGroup=this;
  peer.addEventListener(new AbstractPeerEventListener(){
    int filteredBlocksReceivedFromPeer=0;
    @Override public Message onPreMessageReceived(    Peer peer,    Message m){
      if (m instanceof FilteredBlock) {
        filteredBlocksReceivedFromPeer++;
        if (filteredBlocksReceivedFromPeer % RESEND_BLOOM_FILTER_BLOCK_COUNT == RESEND_BLOOM_FILTER_BLOCK_COUNT - 1) {
          try {
synchronized (thisGroup) {
              peer.sendMessage(bloomFilter);
            }
          }
 catch (          IOException e) {
            throw new RuntimeException(e);
          }
        }
      }
      return m;
    }
  }
);
}",0.8857808857808858
85872,"private synchronized void setDownloadPeer(Peer peer){
  if (chain == null) {
    downloadPeer=peer;
    return;
  }
  if (downloadPeer != null) {
    log.info(""String_Node_Str"",downloadPeer);
    downloadPeer.setDownloadData(false);
    for (    Wallet wallet : wallets)     downloadPeer.removeWallet(wallet);
  }
  downloadPeer=peer;
  if (downloadPeer != null) {
    log.info(""String_Node_Str"",downloadPeer);
    downloadPeer.setDownloadData(true);
    downloadPeer.setDownloadParameters(fastCatchupTimeSecs,bloomFilter != null);
    for (    Wallet wallet : wallets)     downloadPeer.addWallet(wallet);
  }
}","private synchronized void setDownloadPeer(Peer peer){
  if (downloadPeer == peer) {
    return;
  }
  if (chain == null) {
    downloadPeer=peer;
    return;
  }
  if (downloadPeer != null) {
    log.info(""String_Node_Str"",downloadPeer);
    downloadPeer.setDownloadData(false);
    for (    Wallet wallet : wallets)     downloadPeer.removeWallet(wallet);
  }
  downloadPeer=peer;
  if (downloadPeer != null) {
    log.info(""String_Node_Str"",downloadPeer);
    downloadPeer.setDownloadData(true);
    downloadPeer.setDownloadParameters(fastCatchupTimeSecs,bloomFilter != null);
    for (    Wallet wallet : wallets)     downloadPeer.addWallet(wallet);
  }
}",0.9637223974763408
85873,"/** 
 * This is required for signatures which use a sigHashType which cannot be represented using SigHash and anyoneCanPay See transaction c99c49da4c38af669dea436d3e73780dfdb6c1ecf9958baa52960e8baee30e73, which has sigHashType 0
 */
synchronized Sha256Hash hashTransactionForSignature(int inputIndex,byte[] connectedScript,byte sigHashType) throws ScriptException {
  try {
    byte[][] inputScripts=new byte[inputs.size()][];
    long[] inputSequenceNumbers=new long[inputs.size()];
    for (int i=0; i < inputs.size(); i++) {
      inputScripts[i]=inputs.get(i).getScriptBytes();
      inputSequenceNumbers[i]=inputs.get(i).getSequenceNumber();
      inputs.get(i).setScriptBytes(TransactionInput.EMPTY_ARRAY);
    }
    connectedScript=Script.removeAllInstancesOfOp(connectedScript,Script.OP_CODESEPARATOR);
    TransactionInput input=inputs.get(inputIndex);
    input.setScriptBytes(connectedScript);
    ArrayList<TransactionOutput> outputs=this.outputs;
    if ((sigHashType & 0x1f) == (SigHash.NONE.ordinal() + 1)) {
      this.outputs=new ArrayList<TransactionOutput>(0);
      for (int i=0; i < inputs.size(); i++)       if (i != inputIndex)       inputs.get(i).setSequenceNumber(0);
    }
 else     if ((sigHashType & 0x1f) == (SigHash.SINGLE.ordinal() + 1)) {
      if (inputIndex >= this.outputs.size()) {
        for (int i=0; i < inputs.size(); i++) {
          inputs.get(i).setScriptBytes(inputScripts[i]);
          inputs.get(i).setSequenceNumber(inputSequenceNumbers[i]);
        }
        this.outputs=outputs;
        return new Sha256Hash(""String_Node_Str"");
      }
      this.outputs=new ArrayList<TransactionOutput>(this.outputs.subList(0,inputIndex));
      for (int i=0; i < inputIndex; i++)       this.outputs.set(i,new TransactionOutput(params,this,BigInteger.valueOf(-1),new byte[]{}));
      for (int i=0; i < inputs.size(); i++)       if (i != inputIndex)       inputs.get(i).setSequenceNumber(0);
    }
    ArrayList<TransactionInput> inputs=this.inputs;
    if ((sigHashType & 0x80) == 0x80) {
      this.inputs=new ArrayList<TransactionInput>();
      this.inputs.add(input);
    }
    ByteArrayOutputStream bos=new UnsafeByteArrayOutputStream(length == UNKNOWN_LENGTH ? 256 : length + 4);
    bitcoinSerialize(bos);
    uint32ToByteStreamLE(0x000000ff & sigHashType,bos);
    Sha256Hash hash=new Sha256Hash(doubleDigest(bos.toByteArray()));
    bos.close();
    this.inputs=inputs;
    for (int i=0; i < inputs.size(); i++) {
      inputs.get(i).setScriptBytes(inputScripts[i]);
      inputs.get(i).setSequenceNumber(inputSequenceNumbers[i]);
    }
    this.outputs=outputs;
    return hash;
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","/** 
 * This is required for signatures which use a sigHashType which cannot be represented using SigHash and anyoneCanPay See transaction c99c49da4c38af669dea436d3e73780dfdb6c1ecf9958baa52960e8baee30e73, which has sigHashType 0
 */
synchronized Sha256Hash hashTransactionForSignature(int inputIndex,byte[] connectedScript,byte sigHashType) throws ScriptException {
  try {
    byte[][] inputScripts=new byte[inputs.size()][];
    long[] inputSequenceNumbers=new long[inputs.size()];
    for (int i=0; i < inputs.size(); i++) {
      inputScripts[i]=inputs.get(i).getScriptBytes();
      inputSequenceNumbers[i]=inputs.get(i).getSequenceNumber();
      inputs.get(i).setScriptBytes(TransactionInput.EMPTY_ARRAY);
    }
    connectedScript=Script.removeAllInstancesOfOp(connectedScript,Script.OP_CODESEPARATOR);
    TransactionInput input=inputs.get(inputIndex);
    input.setScriptBytes(connectedScript);
    ArrayList<TransactionOutput> outputs=this.outputs;
    if ((sigHashType & 0x1f) == (SigHash.NONE.ordinal() + 1)) {
      this.outputs=new ArrayList<TransactionOutput>(0);
      for (int i=0; i < inputs.size(); i++)       if (i != inputIndex)       inputs.get(i).setSequenceNumber(0);
    }
 else     if ((sigHashType & 0x1f) == (SigHash.SINGLE.ordinal() + 1)) {
      if (inputIndex >= this.outputs.size()) {
        for (int i=0; i < inputs.size(); i++) {
          inputs.get(i).setScriptBytes(inputScripts[i]);
          inputs.get(i).setSequenceNumber(inputSequenceNumbers[i]);
        }
        this.outputs=outputs;
        return new Sha256Hash(""String_Node_Str"");
      }
      this.outputs=new ArrayList<TransactionOutput>(this.outputs.subList(0,inputIndex + 1));
      for (int i=0; i < inputIndex; i++)       this.outputs.set(i,new TransactionOutput(params,this,BigInteger.valueOf(-1),new byte[]{}));
      for (int i=0; i < inputs.size(); i++)       if (i != inputIndex)       inputs.get(i).setSequenceNumber(0);
    }
    ArrayList<TransactionInput> inputs=this.inputs;
    if ((sigHashType & 0x80) == 0x80) {
      this.inputs=new ArrayList<TransactionInput>();
      this.inputs.add(input);
    }
    ByteArrayOutputStream bos=new UnsafeByteArrayOutputStream(length == UNKNOWN_LENGTH ? 256 : length + 4);
    bitcoinSerialize(bos);
    uint32ToByteStreamLE(0x000000ff & sigHashType,bos);
    Sha256Hash hash=new Sha256Hash(doubleDigest(bos.toByteArray()));
    bos.close();
    this.inputs=inputs;
    for (int i=0; i < inputs.size(); i++) {
      inputs.get(i).setScriptBytes(inputScripts[i]);
      inputs.get(i).setSequenceNumber(inputSequenceNumbers[i]);
    }
    this.outputs=outputs;
    return hash;
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}",0.9992595335061089
85874,"/** 
 * <p>Link the given wallet to this PeerGroup. This is used for three purposes:</p> <ol> <li>So the wallet receives broadcast transactions.</li> <li>Announcing pending transactions that didn't get into the chain yet to our peers.</li> <li>Set the fast catchup time using   {@link PeerGroup#setFastCatchupTimeSecs(long)}, to optimize chain download.</li> </ol> <p>Note that this should be done before chain download commences because if you add a wallet with keys earlier than the current chain head, the relevant parts of the chain won't be redownloaded for you.</p>
 */
public synchronized void addWallet(Wallet wallet){
  Preconditions.checkNotNull(wallet);
  wallets.add(wallet);
  announcePendingWalletTransactions(Collections.singletonList(wallet),peers);
  wallet.addEventListener(new AbstractWalletEventListener(){
    @Override public void onKeyAdded(    ECKey key){
      recalculateFastCatchupAndFilter();
    }
  }
);
  recalculateFastCatchupAndFilter();
  updateVersionMessageRelayTxesBeforeFilter(getVersionMessage());
}","/** 
 * <p>Link the given wallet to this PeerGroup. This is used for three purposes:</p> <ol> <li>So the wallet receives broadcast transactions.</li> <li>Announcing pending transactions that didn't get into the chain yet to our peers.</li> <li>Set the fast catchup time using   {@link PeerGroup#setFastCatchupTimeSecs(long)}, to optimize chain download.</li> </ol> <p>Note that this should be done before chain download commences because if you add a wallet with keys earlier than the current chain head, the relevant parts of the chain won't be redownloaded for you.</p>
 */
public synchronized void addWallet(Wallet wallet){
  Preconditions.checkNotNull(wallet);
  Preconditions.checkState(!wallets.contains(wallet));
  wallets.add(wallet);
  announcePendingWalletTransactions(Collections.singletonList(wallet),peers);
  wallet.addEventListener(new AbstractWalletEventListener(){
    @Override public void onKeyAdded(    ECKey key){
      recalculateFastCatchupAndFilter();
    }
  }
);
  recalculateFastCatchupAndFilter();
  updateVersionMessageRelayTxesBeforeFilter(getVersionMessage());
}",0.9741905208822148
85875,"protected synchronized void handleNewPeer(final Peer peer){
  log.info(""String_Node_Str"",peer);
  try {
    if (bloomFilter != null)     peer.sendMessage(bloomFilter);
  }
 catch (  IOException e) {
  }
  peer.setMemoryPool(memoryPool);
  peer.setDownloadData(false);
  Peer newDownloadPeer=selectDownloadPeer(peers);
  if (downloadPeer != newDownloadPeer) {
    setDownloadPeer(newDownloadPeer);
    boolean shouldDownloadChain=downloadListener != null && chain != null;
    if (shouldDownloadChain) {
      startBlockChainDownloadFromPeer(downloadPeer);
    }
  }
  peer.addEventListener(getDataListener);
  announcePendingWalletTransactions(wallets,Collections.singletonList(peer));
  for (  PeerEventListener listener : peerEventListeners) {
    peer.addEventListener(listener);
  }
  setupPingingForNewPeer(peer);
  EventListenerInvoker.invoke(peerEventListeners,new EventListenerInvoker<PeerEventListener>(){
    @Override public void invoke(    PeerEventListener listener){
      listener.onPeerConnected(peer,peers.size());
    }
  }
);
  final PeerGroup thisGroup=this;
  peer.addEventListener(new AbstractPeerEventListener(){
    int filteredBlocksReceivedFromPeer=0;
    @Override public Message onPreMessageReceived(    Peer peer,    Message m){
      if (m instanceof FilteredBlock) {
        filteredBlocksReceivedFromPeer++;
        if (filteredBlocksReceivedFromPeer % RESEND_BLOOM_FILTER_BLOCK_COUNT == RESEND_BLOOM_FILTER_BLOCK_COUNT - 1) {
          try {
synchronized (thisGroup) {
              peer.sendMessage(bloomFilter);
            }
          }
 catch (          IOException e) {
            throw new RuntimeException(e);
          }
        }
      }
      return m;
    }
  }
);
}","protected synchronized void handleNewPeer(final Peer peer){
  log.info(""String_Node_Str"",peer);
  try {
    if (bloomFilter != null)     peer.sendMessage(bloomFilter);
  }
 catch (  IOException e) {
  }
  peer.setMemoryPool(memoryPool);
  peer.setDownloadData(false);
  for (  Wallet wallet : wallets)   peer.addWallet(wallet);
  Peer newDownloadPeer=selectDownloadPeer(peers);
  if (downloadPeer != newDownloadPeer) {
    setDownloadPeer(newDownloadPeer);
    boolean shouldDownloadChain=downloadListener != null && chain != null;
    if (shouldDownloadChain) {
      startBlockChainDownloadFromPeer(downloadPeer);
    }
  }
  peer.addEventListener(getDataListener);
  announcePendingWalletTransactions(wallets,Collections.singletonList(peer));
  for (  PeerEventListener listener : peerEventListeners) {
    peer.addEventListener(listener);
  }
  setupPingingForNewPeer(peer);
  EventListenerInvoker.invoke(peerEventListeners,new EventListenerInvoker<PeerEventListener>(){
    @Override public void invoke(    PeerEventListener listener){
      listener.onPeerConnected(peer,peers.size());
    }
  }
);
  final PeerGroup thisGroup=this;
  peer.addEventListener(new AbstractPeerEventListener(){
    int filteredBlocksReceivedFromPeer=0;
    @Override public Message onPreMessageReceived(    Peer peer,    Message m){
      if (m instanceof FilteredBlock) {
        filteredBlocksReceivedFromPeer++;
        if (filteredBlocksReceivedFromPeer % RESEND_BLOOM_FILTER_BLOCK_COUNT == RESEND_BLOOM_FILTER_BLOCK_COUNT - 1) {
          try {
synchronized (thisGroup) {
              peer.sendMessage(bloomFilter);
            }
          }
 catch (          IOException e) {
            throw new RuntimeException(e);
          }
        }
      }
      return m;
    }
  }
);
}",0.9827685238368754
85876,"protected void handlePeerDeath(final Peer peer){
  if (state() != State.RUNNING && state() != State.STARTING)   return;
  checkArgument(!peers.contains(peer));
  final Peer downloadPeer;
  final PeerEventListener downloadListener;
synchronized (this) {
    downloadPeer=this.downloadPeer;
    downloadListener=this.downloadListener;
  }
  if (peer == downloadPeer) {
    log.info(""String_Node_Str"");
    setDownloadPeer(null);
synchronized (peers) {
      Peer newDownloadPeer=selectDownloadPeer(peers);
      if (newDownloadPeer != null) {
        setDownloadPeer(newDownloadPeer);
        if (downloadListener != null) {
          startBlockChainDownloadFromPeer(newDownloadPeer);
        }
      }
    }
  }
  if (peers.size() + pendingPeers.size() < getMaxConnections()) {
    try {
      connectToAnyPeer();
    }
 catch (    PeerDiscoveryException e) {
      log.error(e.getMessage());
    }
  }
  peer.removeEventListener(getDataListener);
  EventListenerInvoker.invoke(peerEventListeners,new EventListenerInvoker<PeerEventListener>(){
    @Override public void invoke(    PeerEventListener listener){
      listener.onPeerDisconnected(peer,peers.size());
    }
  }
);
}","protected void handlePeerDeath(final Peer peer){
  if (state() != State.RUNNING && state() != State.STARTING)   return;
  checkArgument(!peers.contains(peer));
  final Peer downloadPeer;
  final PeerEventListener downloadListener;
synchronized (this) {
    downloadPeer=this.downloadPeer;
    downloadListener=this.downloadListener;
  }
  if (peer == downloadPeer) {
    log.info(""String_Node_Str"");
    setDownloadPeer(null);
synchronized (peers) {
      Peer newDownloadPeer=selectDownloadPeer(peers);
      if (newDownloadPeer != null) {
        setDownloadPeer(newDownloadPeer);
        if (downloadListener != null) {
          startBlockChainDownloadFromPeer(newDownloadPeer);
        }
      }
    }
  }
  if (peers.size() + pendingPeers.size() < getMaxConnections()) {
    try {
      connectToAnyPeer();
    }
 catch (    PeerDiscoveryException e) {
      log.error(e.getMessage());
    }
  }
  peer.removeEventListener(getDataListener);
  for (  Wallet wallet : wallets)   peer.removeWallet(wallet);
  EventListenerInvoker.invoke(peerEventListeners,new EventListenerInvoker<PeerEventListener>(){
    @Override public void invoke(    PeerEventListener listener){
      listener.onPeerDisconnected(peer,peers.size());
    }
  }
);
}",0.9739346297062474
85877,"private synchronized void setDownloadPeer(Peer peer){
  if (downloadPeer == peer) {
    return;
  }
  if (chain == null) {
    downloadPeer=peer;
    return;
  }
  if (downloadPeer != null) {
    log.info(""String_Node_Str"",downloadPeer);
    downloadPeer.setDownloadData(false);
    for (    Wallet wallet : wallets)     downloadPeer.removeWallet(wallet);
  }
  downloadPeer=peer;
  if (downloadPeer != null) {
    log.info(""String_Node_Str"",downloadPeer);
    downloadPeer.setDownloadData(true);
    downloadPeer.setDownloadParameters(fastCatchupTimeSecs,bloomFilter != null);
    for (    Wallet wallet : wallets)     downloadPeer.addWallet(wallet);
  }
}","private synchronized void setDownloadPeer(Peer peer){
  if (downloadPeer == peer) {
    return;
  }
  if (chain == null) {
    downloadPeer=peer;
    return;
  }
  if (downloadPeer != null) {
    log.info(""String_Node_Str"",downloadPeer);
    downloadPeer.setDownloadData(false);
  }
  downloadPeer=peer;
  if (downloadPeer != null) {
    log.info(""String_Node_Str"",downloadPeer);
    downloadPeer.setDownloadData(true);
    downloadPeer.setDownloadParameters(fastCatchupTimeSecs,bloomFilter != null);
  }
}",0.8701633705932932
85878,"@Test public void receiveTxBroadcast() throws Exception {
  peerGroup.startAndWait();
  peerGroup.addWallet(wallet);
  FakeChannel p1=connectPeer(1);
  FakeChannel p2=connectPeer(2);
  assertEquals(2,peerGroup.numConnectedPeers());
  Set<Peer> tmp=new HashSet<Peer>(peerGroup.getConnectedPeers());
  Set<Peer> expectedPeers=new HashSet<Peer>();
  expectedPeers.add(peerOf(p1));
  expectedPeers.add(peerOf(p2));
  assertEquals(tmp,expectedPeers);
  BigInteger value=Utils.toNanoCoins(1,0);
  Transaction t1=TestUtils.createFakeTx(unitTestParams,value,address);
  InventoryMessage inv=new InventoryMessage(unitTestParams);
  inv.addTransaction(t1);
  inbound(p1,inv);
  assertTrue(outbound(p1) instanceof BloomFilter);
  assertTrue(outbound(p1) instanceof GetDataMessage);
  inbound(p2,inv);
  assertTrue(outbound(p2) instanceof BloomFilter);
  assertNull(outbound(p2));
  inbound(p1,t1);
  assertNull(outbound(p2));
  GetDataMessage getdata=(GetDataMessage)outbound(p1);
  inbound(p1,new NotFoundMessage(unitTestParams,getdata.getItems()));
  assertEquals(value,wallet.getBalance(Wallet.BalanceType.ESTIMATED));
  peerGroup.stop();
}","@Test public void receiveTxBroadcast() throws Exception {
  peerGroup.startAndWait();
  FakeChannel p1=connectPeer(1);
  FakeChannel p2=connectPeer(2);
  assertEquals(2,peerGroup.numConnectedPeers());
  Set<Peer> tmp=new HashSet<Peer>(peerGroup.getConnectedPeers());
  Set<Peer> expectedPeers=new HashSet<Peer>();
  expectedPeers.add(peerOf(p1));
  expectedPeers.add(peerOf(p2));
  assertEquals(tmp,expectedPeers);
  BigInteger value=Utils.toNanoCoins(1,0);
  Transaction t1=TestUtils.createFakeTx(unitTestParams,value,address);
  InventoryMessage inv=new InventoryMessage(unitTestParams);
  inv.addTransaction(t1);
  inbound(p2,inv);
  assertTrue(outbound(p2) instanceof BloomFilter);
  assertTrue(outbound(p2) instanceof GetDataMessage);
  inbound(p1,inv);
  assertTrue(outbound(p1) instanceof BloomFilter);
  assertNull(outbound(p1));
  inbound(p2,t1);
  assertNull(outbound(p1));
  GetDataMessage getdata=(GetDataMessage)outbound(p2);
  assertNotNull(getdata);
  inbound(p2,new NotFoundMessage(unitTestParams,getdata.getItems()));
  assertEquals(value,wallet.getBalance(Wallet.BalanceType.ESTIMATED));
  peerGroup.stopAndWait();
}",0.7987643424536628
85879,"@Test public void transactionConfidence() throws Exception {
  final Transaction[] event=new Transaction[2];
  peerGroup.addEventListener(new AbstractPeerEventListener(){
    @Override public void onTransaction(    Peer peer,    Transaction t){
      event[0]=t;
    }
  }
);
  FakeChannel p1=connectPeer(1);
  FakeChannel p2=connectPeer(2);
  FakeChannel p3=connectPeer(3);
  Transaction tx=TestUtils.createFakeTx(params,Utils.toNanoCoins(20,0),address);
  InventoryMessage inv=new InventoryMessage(params);
  inv.addTransaction(tx);
  inbound(p2,inv);
  assertTrue(outbound(p2) instanceof BloomFilter);
  assertTrue(outbound(p2) instanceof GetDataMessage);
  assertEquals(0,tx.getConfidence().numBroadcastPeers());
  assertTrue(peerGroup.getMemoryPool().maybeWasSeen(tx.getHash()));
  assertNull(event[0]);
  inbound(p1,inv);
  assertTrue(outbound(p1) instanceof BloomFilter);
  assertNull(outbound(p1));
  inbound(p2,tx);
  assertNull(outbound(p2));
  tx=event[0];
  assertNotNull(tx);
  event[0]=null;
  inbound(p1,inv);
  inbound(p1,tx);
  assertEquals(2,tx.getConfidence().numBroadcastPeers());
  assertTrue(tx.getConfidence().wasBroadcastBy(peerOf(p1).getAddress()));
  assertTrue(tx.getConfidence().wasBroadcastBy(peerOf(p2).getAddress()));
  tx.getConfidence().addEventListener(new TransactionConfidence.Listener(){
    public void onConfidenceChanged(    Transaction tx){
      event[1]=tx;
    }
  }
);
  inbound(p3,inv);
  assertEquals(tx,event[1]);
  assertEquals(3,tx.getConfidence().numBroadcastPeers());
  assertTrue(tx.getConfidence().wasBroadcastBy(peerOf(p3).getAddress()));
}","@Test public void transactionConfidence() throws Exception {
  final Transaction[] event=new Transaction[2];
  peerGroup.addEventListener(new AbstractPeerEventListener(){
    @Override public void onTransaction(    Peer peer,    Transaction t){
      event[0]=t;
    }
  }
);
  FakeChannel p1=connectPeer(1);
  FakeChannel p2=connectPeer(2);
  FakeChannel p3=connectPeer(3);
  Transaction tx=TestUtils.createFakeTx(params,Utils.toNanoCoins(20,0),address);
  InventoryMessage inv=new InventoryMessage(params);
  inv.addTransaction(tx);
  inbound(p2,inv);
  assertTrue(outbound(p2) instanceof BloomFilter);
  assertTrue(outbound(p2) instanceof GetDataMessage);
  assertEquals(0,tx.getConfidence().numBroadcastPeers());
  assertTrue(peerGroup.getMemoryPool().maybeWasSeen(tx.getHash()));
  assertNull(event[0]);
  inbound(p1,inv);
  assertTrue(outbound(p1) instanceof BloomFilter);
  assertNull(outbound(p1));
  inbound(p2,tx);
  assertTrue(outbound(p2) instanceof GetDataMessage);
  tx=event[0];
  assertNotNull(tx);
  event[0]=null;
  inbound(p1,inv);
  inbound(p1,tx);
  assertEquals(2,tx.getConfidence().numBroadcastPeers());
  assertTrue(tx.getConfidence().wasBroadcastBy(peerOf(p1).getAddress()));
  assertTrue(tx.getConfidence().wasBroadcastBy(peerOf(p2).getAddress()));
  tx.getConfidence().addEventListener(new TransactionConfidence.Listener(){
    public void onConfidenceChanged(    Transaction tx){
      event[1]=tx;
    }
  }
);
  inbound(p3,inv);
  assertEquals(tx,event[1]);
  assertEquals(3,tx.getConfidence().numBroadcastPeers());
  assertTrue(tx.getConfidence().wasBroadcastBy(peerOf(p3).getAddress()));
}",0.9894278606965174
85880,"/** 
 * Returns the given value in nanocoins as a 0.12 type string. More digits after the decimal place will be used if necessary, but two will always be present.
 */
public static String bitcoinValueToFriendlyString(BigInteger value){
  boolean negative=value.compareTo(BigInteger.ZERO) < 0;
  if (negative)   value=value.negate();
  BigDecimal bd=new BigDecimal(value,8);
  String formatted=bd.toPlainString();
  int toDelete=0;
  for (int i=formatted.length() - 1; i > 1; i--) {
    if (formatted.charAt(i) == '0')     toDelete++;
 else     break;
  }
  return (negative ? ""String_Node_Str"" : ""String_Node_Str"") + formatted.substring(0,formatted.length() - toDelete);
}","/** 
 * Returns the given value in nanocoins as a 0.12 type string. More digits after the decimal place will be used if necessary, but two will always be present.
 */
public static String bitcoinValueToFriendlyString(BigInteger value){
  boolean negative=value.compareTo(BigInteger.ZERO) < 0;
  if (negative)   value=value.negate();
  BigDecimal bd=new BigDecimal(value,8);
  String formatted=bd.toPlainString();
  int decimalPoint=formatted.indexOf(""String_Node_Str"");
  int toDelete=0;
  for (int i=formatted.length() - 1; i > decimalPoint + 2; i--) {
    if (formatted.charAt(i) == '0')     toDelete++;
 else     break;
  }
  return (negative ? ""String_Node_Str"" : ""String_Node_Str"") + formatted.substring(0,formatted.length() - toDelete);
}",0.9477401129943502
85881,"@Test public void testFormatting(){
  assertEquals(""String_Node_Str"",bitcoinValueToFriendlyString(toNanoCoins(1,23)));
  assertEquals(""String_Node_Str"",bitcoinValueToFriendlyString(BigInteger.valueOf(COIN.longValue() / 1000)));
  assertEquals(""String_Node_Str"",bitcoinValueToFriendlyString(toNanoCoins(1,23).negate()));
}","@Test public void testFormatting(){
  assertEquals(""String_Node_Str"",bitcoinValueToFriendlyString(toNanoCoins(1,0)));
  assertEquals(""String_Node_Str"",bitcoinValueToFriendlyString(toNanoCoins(1,23)));
  assertEquals(""String_Node_Str"",bitcoinValueToFriendlyString(BigInteger.valueOf(COIN.longValue() / 1000)));
  assertEquals(""String_Node_Str"",bitcoinValueToFriendlyString(toNanoCoins(1,23).negate()));
}",0.8867403314917127
85882,"/** 
 * Creates an ECKey given only the private key bytes. This is the same as using the BigInteger constructor, but is more convenient if you are importing a key from elsewhere. The public key will be automatically derived from the private key.
 */
public ECKey(byte[] privKeyBytes,byte[] pubKey){
  this(privKeyBytes == null ? null : new BigInteger(1,privKeyBytes),pubKey);
}","/** 
 * Creates an ECKey given only the private key bytes. This is the same as using the BigInteger constructor, but is more convenient if you are importing a key from elsewhere. If not provided the public key will be automatically derived from the private key.
 */
public ECKey(byte[] privKeyBytes,byte[] pubKey){
  this(privKeyBytes == null ? null : new BigInteger(1,privKeyBytes),pubKey);
}",0.9766233766233766
85883,"/** 
 * Returns whether this key is using the compressed form or not. Compressed pubkeys are only 35 bytes, not 64.
 */
public boolean isCompressed(){
  return pub.length == 35;
}","/** 
 * Returns whether this key is using the compressed form or not. Compressed pubkeys are only 33 bytes, not 64.
 */
public boolean isCompressed(){
  return pub.length == 33;
}",0.988826815642458
85884,"/** 
 * Output this ECKey as an ASN.1 encoded private key, as understood by OpenSSL or used by the BitCoin reference implementation in its wallet storage format.
 */
public byte[] toASN1(){
  try {
    ByteArrayOutputStream baos=new ByteArrayOutputStream(400);
    DERSequenceGenerator seq=new DERSequenceGenerator(baos);
    seq.addObject(new ASN1Integer(1));
    seq.addObject(new DEROctetString(priv.toByteArray()));
    seq.addObject(new DERTaggedObject(0,SECNamedCurves.getByName(""String_Node_Str"").toASN1Primitive()));
    seq.addObject(new DERTaggedObject(1,new DERBitString(getPubKey())));
    seq.close();
    return baos.toByteArray();
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","/** 
 * Output this ECKey as an ASN.1 encoded private key, as understood by OpenSSL or used by the Bitcoin reference implementation in its wallet storage format.
 */
public byte[] toASN1(){
  try {
    ByteArrayOutputStream baos=new ByteArrayOutputStream(400);
    DERSequenceGenerator seq=new DERSequenceGenerator(baos);
    seq.addObject(new ASN1Integer(1));
    seq.addObject(new DEROctetString(priv.toByteArray()));
    seq.addObject(new DERTaggedObject(0,SECNamedCurves.getByName(""String_Node_Str"").toASN1Primitive()));
    seq.addObject(new DERTaggedObject(1,new DERBitString(getPubKey())));
    seq.close();
    return baos.toByteArray();
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}",0.99860529986053
85885,"@Test public void keyRecovery() throws Exception {
  ECKey key=new ECKey();
  String message=""String_Node_Str"";
  Sha256Hash hash=Sha256Hash.create(message.getBytes());
  ECKey.ECDSASignature sig=key.sign(hash);
  key=new ECKey(null,key.getPubKey());
  boolean found=false;
  for (int i=0; i < 4; i++) {
    ECKey key2=ECKey.recoverFromSignature(i,sig,hash,false);
    assertNotNull(""String_Node_Str"",key2);
    if (key.equals(key2)) {
      found=true;
      break;
    }
  }
  assertTrue(found);
}","@Test public void keyRecovery() throws Exception {
  ECKey key=new ECKey();
  String message=""String_Node_Str"";
  Sha256Hash hash=Sha256Hash.create(message.getBytes());
  ECKey.ECDSASignature sig=key.sign(hash);
  key=new ECKey(null,key.getPubKey());
  boolean found=false;
  for (int i=0; i < 4; i++) {
    ECKey key2=ECKey.recoverFromSignature(i,sig,hash,true);
    if (key.equals(key2)) {
      found=true;
      break;
    }
  }
  assertTrue(found);
}",0.7631027253668763
85886,"protected void handlePeerDeath(final Peer peer){
  if (!isRunning())   return;
  checkArgument(!peers.contains(peer));
  final Peer downloadPeer;
  final PeerEventListener downloadListener;
synchronized (this) {
    downloadPeer=this.downloadPeer;
    downloadListener=this.downloadListener;
  }
  if (peer == downloadPeer) {
    log.info(""String_Node_Str"");
    setDownloadPeer(null);
synchronized (peers) {
      Peer newDownloadPeer=selectDownloadPeer(peers);
      if (newDownloadPeer != null) {
        setDownloadPeer(newDownloadPeer);
        if (downloadListener != null) {
          startBlockChainDownloadFromPeer(newDownloadPeer);
        }
      }
    }
  }
  if (peers.size() + pendingPeers.size() < getMaxConnections()) {
    try {
      connectToAnyPeer();
    }
 catch (    PeerDiscoveryException e) {
      log.error(e.getMessage());
    }
  }
  peer.removeEventListener(getDataListener);
  EventListenerInvoker.invoke(peerEventListeners,new EventListenerInvoker<PeerEventListener>(){
    @Override public void invoke(    PeerEventListener listener){
      listener.onPeerDisconnected(peer,peers.size());
    }
  }
);
}","protected void handlePeerDeath(final Peer peer){
  if (state() != State.RUNNING && state() != State.STARTING)   return;
  checkArgument(!peers.contains(peer));
  final Peer downloadPeer;
  final PeerEventListener downloadListener;
synchronized (this) {
    downloadPeer=this.downloadPeer;
    downloadListener=this.downloadListener;
  }
  if (peer == downloadPeer) {
    log.info(""String_Node_Str"");
    setDownloadPeer(null);
synchronized (peers) {
      Peer newDownloadPeer=selectDownloadPeer(peers);
      if (newDownloadPeer != null) {
        setDownloadPeer(newDownloadPeer);
        if (downloadListener != null) {
          startBlockChainDownloadFromPeer(newDownloadPeer);
        }
      }
    }
  }
  if (peers.size() + pendingPeers.size() < getMaxConnections()) {
    try {
      connectToAnyPeer();
    }
 catch (    PeerDiscoveryException e) {
      log.error(e.getMessage());
    }
  }
  peer.removeEventListener(getDataListener);
  EventListenerInvoker.invoke(peerEventListeners,new EventListenerInvoker<PeerEventListener>(){
    @Override public void invoke(    PeerEventListener listener){
      listener.onPeerDisconnected(peer,peers.size());
    }
  }
);
}",0.9736273238218764
85887,"/** 
 * Catch any exceptions, logging them and then closing the channel. 
 */
@Override public void exceptionCaught(ChannelHandlerContext ctx,ExceptionEvent e) throws Exception {
  String s=address == null ? ""String_Node_Str"" : address.toString();
  if (e.getCause() instanceof ConnectException || e.getCause() instanceof IOException) {
    log.info(s + ""String_Node_Str"" + e.getCause().getMessage());
  }
 else {
    log.warn(s + ""String_Node_Str"",e.getCause());
  }
  e.getChannel().close();
}","/** 
 * Catch any exceptions, logging them and then closing the channel. 
 */
@Override public void exceptionCaught(ChannelHandlerContext ctx,ExceptionEvent e) throws Exception {
  String s;
synchronized (Peer.this) {
    s=address == null ? ""String_Node_Str"" : address.toString();
  }
  if (e.getCause() instanceof ConnectException || e.getCause() instanceof IOException) {
    log.info(s + ""String_Node_Str"" + e.getCause().getMessage());
  }
 else {
    log.warn(s + ""String_Node_Str"",e.getCause());
  }
  e.getChannel().close();
}",0.9630350194552528
85888,"/** 
 * @return various version numbers we claim.
 */
public VersionMessage getVersionMessage(){
  return versionMessage;
}","/** 
 * @return various version numbers we claim.
 */
public synchronized VersionMessage getVersionMessage(){
  return versionMessage;
}",0.9498069498069498
85889,"/** 
 * When downloading the block chain, the bodies will be skipped for blocks created before the given date. Any transactions relevant to the wallet will therefore not be found, but if you know your wallet has no such transactions it doesn't matter and can save a lot of bandwidth and processing time. Note that the times of blocks isn't known until their headers are available and they are requested in chunks, so some headers may be downloaded twice using this scheme, but this optimization can still be a large win for newly created wallets.
 * @param secondsSinceEpoch Time in seconds since the epoch or 0 to reset to always downloading block bodies.
 */
public void setFastCatchupTime(long secondsSinceEpoch){
  Preconditions.checkNotNull(blockChain);
  if (secondsSinceEpoch == 0) {
    fastCatchupTimeSecs=params.genesisBlock.getTimeSeconds();
    downloadBlockBodies=true;
  }
 else {
    fastCatchupTimeSecs=secondsSinceEpoch;
    if (fastCatchupTimeSecs > blockChain.getChainHead().getHeader().getTimeSeconds()) {
      downloadBlockBodies=false;
    }
  }
}","/** 
 * When downloading the block chain, the bodies will be skipped for blocks created before the given date. Any transactions relevant to the wallet will therefore not be found, but if you know your wallet has no such transactions it doesn't matter and can save a lot of bandwidth and processing time. Note that the times of blocks isn't known until their headers are available and they are requested in chunks, so some headers may be downloaded twice using this scheme, but this optimization can still be a large win for newly created wallets.
 * @param secondsSinceEpoch Time in seconds since the epoch or 0 to reset to always downloading block bodies.
 */
public synchronized void setFastCatchupTime(long secondsSinceEpoch){
  Preconditions.checkNotNull(blockChain);
  if (secondsSinceEpoch == 0) {
    fastCatchupTimeSecs=params.genesisBlock.getTimeSeconds();
    downloadBlockBodies=true;
  }
 else {
    fastCatchupTimeSecs=secondsSinceEpoch;
    if (fastCatchupTimeSecs > blockChain.getChainHead().getHeader().getTimeSeconds()) {
      downloadBlockBodies=false;
    }
  }
}",0.9939619136089178
85890,"private void processAlert(AlertMessage m){
  try {
    if (m.isSignatureValid()) {
      log.info(""String_Node_Str"",toString(),m.getStatusBar());
    }
 else {
      log.warn(""String_Node_Str"",toString(),m.getStatusBar());
    }
  }
 catch (  Throwable t) {
    log.error(""String_Node_Str"",t);
  }
}","private synchronized void processAlert(AlertMessage m){
  try {
    if (m.isSignatureValid()) {
      log.info(""String_Node_Str"",toString(),m.getStatusBar());
    }
 else {
      log.warn(""String_Node_Str"",toString(),m.getStatusBar());
    }
  }
 catch (  Throwable t) {
    log.error(""String_Node_Str"",t);
  }
}",0.23240589198036
85891,"private void processPong(Pong m){
  ListIterator<PendingPing> it=pendingPings.listIterator();
  PendingPing ping=null;
  while (it.hasNext()) {
    ping=it.next();
    if (m.getNonce() == ping.nonce) {
      it.remove();
      break;
    }
  }
  if (ping != null)   ping.complete();
}","private synchronized void processPong(Pong m){
  ListIterator<PendingPing> it=pendingPings.listIterator();
  PendingPing ping=null;
  while (it.hasNext()) {
    ping=it.next();
    if (m.getNonce() == ping.nonce) {
      it.remove();
      break;
    }
  }
  if (ping != null)   ping.complete();
}",0.9776247848537004
85892,"/** 
 * If set to false, the peer won't try and fetch blocks and transactions it hears about. Normally, only one peer should download missing blocks. Defaults to true.
 */
public void setDownloadData(boolean downloadData){
  this.downloadData=downloadData;
}","/** 
 * If set to false, the peer won't try and fetch blocks and transactions it hears about. Normally, only one peer should download missing blocks. Defaults to true.
 */
public synchronized void setDownloadData(boolean downloadData){
  this.downloadData=downloadData;
}",0.9754253308128544
85893,"private void processInv(InventoryMessage inv) throws IOException {
  List<InventoryItem> items=inv.getItems();
  List<InventoryItem> transactions=new LinkedList<InventoryItem>();
  List<InventoryItem> blocks=new LinkedList<InventoryItem>();
  for (  InventoryItem item : items) {
switch (item.type) {
case Transaction:
      transactions.add(item);
    break;
case Block:
  blocks.add(item);
break;
default :
throw new IllegalStateException(""String_Node_Str"" + item.type);
}
}
if (transactions.size() == 0 && blocks.size() == 1) {
if (downloadData) {
if (!blockChain.isOrphan(blocks.get(0).hash)) {
blocksAnnounced++;
}
}
 else {
blocksAnnounced++;
}
}
GetDataMessage getdata=new GetDataMessage(params);
Iterator<InventoryItem> it=transactions.iterator();
while (it.hasNext()) {
InventoryItem item=it.next();
if (memoryPool == null) {
if (downloadData) {
getdata.addItem(item);
}
}
 else {
if (memoryPool.maybeWasSeen(item.hash)) {
it.remove();
}
 else {
log.debug(""String_Node_Str"",address,item.hash);
getdata.addItem(item);
}
memoryPool.seen(item.hash,this.getAddress());
}
}
if (blocks.size() > 0 && downloadData && blockChain != null) {
for (InventoryItem item : blocks) {
if (blockChain.isOrphan(item.hash)) {
blockChainDownload(blockChain.getOrphanRoot(item.hash).getHash());
}
 else {
if (!pendingBlockDownloads.contains(item.hash)) {
getdata.addItem(item);
pendingBlockDownloads.add(item.hash);
}
}
}
}
if (!getdata.getItems().isEmpty()) {
sendMessage(getdata);
}
}","private synchronized void processInv(InventoryMessage inv) throws IOException {
  List<InventoryItem> items=inv.getItems();
  List<InventoryItem> transactions=new LinkedList<InventoryItem>();
  List<InventoryItem> blocks=new LinkedList<InventoryItem>();
  for (  InventoryItem item : items) {
switch (item.type) {
case Transaction:
      transactions.add(item);
    break;
case Block:
  blocks.add(item);
break;
default :
throw new IllegalStateException(""String_Node_Str"" + item.type);
}
}
if (transactions.size() == 0 && blocks.size() == 1) {
if (downloadData) {
if (!blockChain.isOrphan(blocks.get(0).hash)) {
blocksAnnounced++;
}
}
 else {
blocksAnnounced++;
}
}
GetDataMessage getdata=new GetDataMessage(params);
Iterator<InventoryItem> it=transactions.iterator();
while (it.hasNext()) {
InventoryItem item=it.next();
if (memoryPool == null) {
if (downloadData) {
getdata.addItem(item);
}
}
 else {
if (memoryPool.maybeWasSeen(item.hash)) {
it.remove();
}
 else {
log.debug(""String_Node_Str"",address,item.hash);
getdata.addItem(item);
}
memoryPool.seen(item.hash,this.getAddress());
}
}
if (blocks.size() > 0 && downloadData && blockChain != null) {
for (InventoryItem item : blocks) {
if (blockChain.isOrphan(item.hash)) {
blockChainDownload(blockChain.getOrphanRoot(item.hash).getHash());
}
 else {
if (!pendingBlockDownloads.contains(item.hash)) {
getdata.addItem(item);
pendingBlockDownloads.add(item.hash);
}
}
}
}
if (!getdata.getItems().isEmpty()) {
sendMessage(getdata);
}
}",0.995606623859412
85894,"private void blockChainDownload(Sha256Hash toHash) throws IOException {
  List<Sha256Hash> blockLocator=new ArrayList<Sha256Hash>(51);
  BlockStore store=blockChain.getBlockStore();
  StoredBlock chainHead=blockChain.getChainHead();
  Sha256Hash chainHeadHash=chainHead.getHeader().getHash();
  if (Objects.equal(lastGetBlocksBegin,chainHeadHash) && Objects.equal(lastGetBlocksEnd,toHash)) {
    log.info(""String_Node_Str"",toHash.toString());
    return;
  }
  log.info(""String_Node_Str"",new Object[]{toString(),toHash.toString(),chainHead.getHeader().getHashAsString()});
  StoredBlock cursor=chainHead;
  for (int i=100; cursor != null && i > 0; i--) {
    blockLocator.add(cursor.getHeader().getHash());
    try {
      cursor=cursor.getPrev(store);
    }
 catch (    BlockStoreException e) {
      log.error(""String_Node_Str"");
      throw new RuntimeException(e);
    }
  }
  if (cursor != null) {
    blockLocator.add(params.genesisBlock.getHash());
  }
  lastGetBlocksBegin=chainHeadHash;
  lastGetBlocksEnd=toHash;
  if (downloadBlockBodies) {
    GetBlocksMessage message=new GetBlocksMessage(params,blockLocator,toHash);
    sendMessage(message);
  }
 else {
    GetHeadersMessage message=new GetHeadersMessage(params,blockLocator,toHash);
    sendMessage(message);
  }
}","private synchronized void blockChainDownload(Sha256Hash toHash) throws IOException {
  List<Sha256Hash> blockLocator=new ArrayList<Sha256Hash>(51);
  BlockStore store=blockChain.getBlockStore();
  StoredBlock chainHead=blockChain.getChainHead();
  Sha256Hash chainHeadHash=chainHead.getHeader().getHash();
  if (Objects.equal(lastGetBlocksBegin,chainHeadHash) && Objects.equal(lastGetBlocksEnd,toHash)) {
    log.info(""String_Node_Str"",toHash.toString());
    return;
  }
  log.info(""String_Node_Str"",new Object[]{toString(),toHash.toString(),chainHead.getHeader().getHashAsString()});
  StoredBlock cursor=chainHead;
  for (int i=100; cursor != null && i > 0; i--) {
    blockLocator.add(cursor.getHeader().getHash());
    try {
      cursor=cursor.getPrev(store);
    }
 catch (    BlockStoreException e) {
      log.error(""String_Node_Str"");
      throw new RuntimeException(e);
    }
  }
  if (cursor != null) {
    blockLocator.add(params.genesisBlock.getHash());
  }
  lastGetBlocksBegin=chainHeadHash;
  lastGetBlocksEnd=toHash;
  if (downloadBlockBodies) {
    GetBlocksMessage message=new GetBlocksMessage(params,blockLocator,toHash);
    sendMessage(message);
  }
 else {
    GetHeadersMessage message=new GetHeadersMessage(params,blockLocator,toHash);
    sendMessage(message);
  }
}",0.9949514563106796
85895,"/** 
 * Returns the difference between our best chain height and the peers, which can either be positive if we are behind the peer, or negative if the peer is ahead of us.
 */
public int getPeerBlockHeightDifference(){
  int chainHeight=(int)getBestHeight();
  Preconditions.checkState(params.allowEmptyPeerChains || chainHeight > 0,""String_Node_Str"",chainHeight);
  return chainHeight - blockChain.getChainHead().getHeight();
}","/** 
 * Returns the difference between our best chain height and the peers, which can either be positive if we are behind the peer, or negative if the peer is ahead of us.
 */
public synchronized int getPeerBlockHeightDifference(){
  int chainHeight=(int)getBestHeight();
  Preconditions.checkState(params.allowEmptyPeerChains || chainHeight > 0,""String_Node_Str"",chainHeight);
  return chainHeight - blockChain.getChainHead().getHeight();
}",0.9850402761795168
85896,"/** 
 * @return various version numbers claimed by peer.
 */
public VersionMessage getPeerVersionMessage(){
  return peerVersionMessage;
}","/** 
 * @return various version numbers claimed by peer.
 */
public synchronized VersionMessage getPeerVersionMessage(){
  return peerVersionMessage;
}",0.9550173010380624
85897,"private void processHeaders(HeadersMessage m) throws IOException, ProtocolException {
  Preconditions.checkState(!downloadBlockBodies,toString());
  try {
    for (int i=0; i < m.getBlockHeaders().size(); i++) {
      Block header=m.getBlockHeaders().get(i);
      if (header.getTimeSeconds() < fastCatchupTimeSecs) {
        if (blockChain.add(header)) {
          invokeOnBlocksDownloaded(header);
        }
 else {
          throw new ProtocolException(""String_Node_Str"" + header.getHashAsString());
        }
      }
 else {
        log.info(""String_Node_Str"",m.getBlockHeaders().size() - i);
        downloadBlockBodies=true;
        lastGetBlocksBegin=Sha256Hash.ZERO_HASH;
        blockChainDownload(Sha256Hash.ZERO_HASH);
        return;
      }
    }
    if (m.getBlockHeaders().size() >= HeadersMessage.MAX_HEADERS)     blockChainDownload(Sha256Hash.ZERO_HASH);
  }
 catch (  VerificationException e) {
    log.warn(""String_Node_Str"",e);
  }
catch (  PrunedException e) {
    throw new RuntimeException(e);
  }
}","private synchronized void processHeaders(HeadersMessage m) throws IOException, ProtocolException {
  Preconditions.checkState(!downloadBlockBodies,toString());
  try {
    for (int i=0; i < m.getBlockHeaders().size(); i++) {
      Block header=m.getBlockHeaders().get(i);
      if (header.getTimeSeconds() < fastCatchupTimeSecs) {
        if (blockChain.add(header)) {
          invokeOnBlocksDownloaded(header);
        }
 else {
          throw new ProtocolException(""String_Node_Str"" + header.getHashAsString());
        }
      }
 else {
        log.info(""String_Node_Str"",m.getBlockHeaders().size() - i);
        downloadBlockBodies=true;
        lastGetBlocksBegin=Sha256Hash.ZERO_HASH;
        blockChainDownload(Sha256Hash.ZERO_HASH);
        return;
      }
    }
    if (m.getBlockHeaders().size() >= HeadersMessage.MAX_HEADERS)     blockChainDownload(Sha256Hash.ZERO_HASH);
  }
 catch (  VerificationException e) {
    log.warn(""String_Node_Str"",e);
  }
catch (  PrunedException e) {
    throw new RuntimeException(e);
  }
}",0.9936801166747692
85898,"/** 
 * Sends the peer a ping message and returns a future that will be invoked when the pong is received back. The future provides a number which is the number of milliseconds elapsed between the ping and the pong. Once the pong is received the value returned by   {@link com.google.bitcoin.core.Peer#getLastPingTime()} isupdated.
 * @throws ProtocolException if the peer version is too low to support measurable pings.
 */
public ListenableFuture<Long> ping() throws IOException, ProtocolException {
  int peerVersion=getPeerVersionMessage().clientVersion;
  if (peerVersion < Pong.MIN_PROTOCOL_VERSION)   throw new ProtocolException(""String_Node_Str"" + peerVersion);
  PendingPing pendingPing=new PendingPing();
  pendingPings.add(pendingPing);
  sendMessage(new Ping(pendingPing.nonce));
  return pendingPing.future;
}","/** 
 * Sends the peer a ping message and returns a future that will be invoked when the pong is received back. The future provides a number which is the number of milliseconds elapsed between the ping and the pong. Once the pong is received the value returned by   {@link com.google.bitcoin.core.Peer#getLastPingTime()} isupdated.
 * @throws ProtocolException if the peer version is too low to support measurable pings.
 */
public synchronized ListenableFuture<Long> ping() throws IOException, ProtocolException {
  int peerVersion=getPeerVersionMessage().clientVersion;
  if (peerVersion < Pong.MIN_PROTOCOL_VERSION)   throw new ProtocolException(""String_Node_Str"" + peerVersion);
  PendingPing pendingPing=new PendingPing();
  pendingPings.add(pendingPing);
  sendMessage(new Ping(pendingPing.nonce));
  return pendingPing.future;
}",0.992154496077248
85899,"/** 
 * Returns true if this peer will try and download things it is sent in ""inv"" messages. Normally you only need one peer to be downloading data. Defaults to true.
 */
public boolean getDownloadData(){
  return downloadData;
}","/** 
 * Returns true if this peer will try and download things it is sent in ""inv"" messages. Normally you only need one peer to be downloading data. Defaults to true.
 */
public synchronized boolean getDownloadData(){
  return downloadData;
}",0.9723991507430998
85900,"/** 
 * @return the height of the best chain as claimed by peer: sum of its ver announcement and blocks announced since.
 */
public long getBestHeight(){
  return peerVersionMessage.bestHeight + blocksAnnounced;
}","/** 
 * @return the height of the best chain as claimed by peer: sum of its ver announcement and blocks announced since.
 */
public synchronized long getBestHeight(){
  return peerVersionMessage.bestHeight + blocksAnnounced;
}",0.9703872437357632
85901,"/** 
 * @return the IP address and port of peer.
 */
public PeerAddress getAddress(){
  return address;
}","/** 
 * @return the IP address and port of peer.
 */
public synchronized PeerAddress getAddress(){
  return address;
}",0.9417040358744396
85902,"@Override public void connectRequested(ChannelHandlerContext ctx,ChannelStateEvent e) throws Exception {
  address=new PeerAddress((InetSocketAddress)e.getValue());
  channel=e.getChannel();
  super.connectRequested(ctx,e);
}","@Override public void connectRequested(ChannelHandlerContext ctx,ChannelStateEvent e) throws Exception {
synchronized (Peer.this) {
    address=new PeerAddress((InetSocketAddress)e.getValue());
  }
  channel=e.getChannel();
  super.connectRequested(ctx,e);
}",0.9316770186335404
85903,"private void processBlock(Block m) throws IOException {
  log.debug(""String_Node_Str"",address,m.getHashAsString());
  try {
synchronized (pendingGetBlockFutures) {
      for (int i=0; i < pendingGetBlockFutures.size(); i++) {
        GetDataFuture<Block> f=pendingGetBlockFutures.get(i);
        if (f.getItem().hash.equals(m.getHash())) {
          f.setResult(m);
          pendingGetBlockFutures.remove(i);
          return;
        }
      }
    }
    if (!downloadData) {
      log.warn(""String_Node_Str"",m.getHashAsString());
      return;
    }
    pendingBlockDownloads.remove(m.getHash());
    if (blockChain.add(m)) {
      invokeOnBlocksDownloaded(m);
    }
 else {
      blockChainDownload(blockChain.getOrphanRoot(m.getHash()).getHash());
    }
  }
 catch (  VerificationException e) {
    log.warn(""String_Node_Str"",e);
  }
catch (  PrunedException e) {
    throw new RuntimeException(e);
  }
}","private synchronized void processBlock(Block m) throws IOException {
  log.debug(""String_Node_Str"",address,m.getHashAsString());
  try {
synchronized (pendingGetBlockFutures) {
      for (int i=0; i < pendingGetBlockFutures.size(); i++) {
        GetDataFuture<Block> f=pendingGetBlockFutures.get(i);
        if (f.getItem().hash.equals(m.getHash())) {
          f.setResult(m);
          pendingGetBlockFutures.remove(i);
          return;
        }
      }
    }
    if (!downloadData) {
      log.warn(""String_Node_Str"",m.getHashAsString());
      return;
    }
    pendingBlockDownloads.remove(m.getHash());
    if (blockChain.add(m)) {
      invokeOnBlocksDownloaded(m);
    }
 else {
      blockChainDownload(blockChain.getOrphanRoot(m.getHash()).getHash());
    }
  }
 catch (  VerificationException e) {
    log.warn(""String_Node_Str"",e);
  }
catch (  PrunedException e) {
    throw new RuntimeException(e);
  }
}",0.9928922908693276
85904,"@Override public String toString(){
  if (address == null) {
    return ""String_Node_Str"";
  }
 else {
    return ""String_Node_Str"" + address.getAddr() + ""String_Node_Str""+ address.getPort()+ ""String_Node_Str"";
  }
}","@Override public synchronized String toString(){
  if (address == null) {
    return ""String_Node_Str"";
  }
 else {
    return ""String_Node_Str"" + address.getAddr() + ""String_Node_Str""+ address.getPort()+ ""String_Node_Str"";
  }
}",0.9707865168539326
85905,"/** 
 * Throws an exception if the blocks difficulty is not correct.
 */
private void checkDifficultyTransitions(StoredBlock storedPrev,Block nextBlock) throws BlockStoreException, VerificationException {
  Block prev=storedPrev.getHeader();
  if ((storedPrev.getHeight() + 1) % params.interval != 0) {
    if (params.getId().equals(NetworkParameters.ID_TESTNET) && nextBlock.getTime().after(testnetDiffDate)) {
      checkTestnetDifficulty(storedPrev,prev,nextBlock);
      return;
    }
    if (nextBlock.getDifficultyTarget() != prev.getDifficultyTarget())     throw new VerificationException(""String_Node_Str"" + storedPrev.getHeight() + ""String_Node_Str""+ Long.toHexString(nextBlock.getDifficultyTarget())+ ""String_Node_Str""+ Long.toHexString(prev.getDifficultyTarget()));
    return;
  }
  long now=System.currentTimeMillis();
  StoredBlock cursor=blockStore.get(prev.getHash());
  for (int i=0; i < params.interval - 1; i++) {
    if (cursor == null) {
      throw new VerificationException(""String_Node_Str"");
    }
    cursor=blockStore.get(cursor.getHeader().getPrevBlockHash());
  }
  log.info(""String_Node_Str"",System.currentTimeMillis() - now);
  Block blockIntervalAgo=cursor.getHeader();
  int timespan=(int)(prev.getTimeSeconds() - blockIntervalAgo.getTimeSeconds());
  if (timespan < params.targetTimespan / 4)   timespan=params.targetTimespan / 4;
  if (timespan > params.targetTimespan * 4)   timespan=params.targetTimespan * 4;
  BigInteger newDifficulty=Utils.decodeCompactBits(blockIntervalAgo.getDifficultyTarget());
  newDifficulty=newDifficulty.multiply(BigInteger.valueOf(timespan));
  newDifficulty=newDifficulty.divide(BigInteger.valueOf(params.targetTimespan));
  if (newDifficulty.compareTo(params.proofOfWorkLimit) > 0) {
    log.info(""String_Node_Str"",newDifficulty.toString(16));
    newDifficulty=params.proofOfWorkLimit;
  }
  int accuracyBytes=(int)(nextBlock.getDifficultyTarget() >>> 24) - 3;
  BigInteger receivedDifficulty=nextBlock.getDifficultyTargetAsInteger();
  BigInteger mask=BigInteger.valueOf(0xFFFFFFL).shiftLeft(accuracyBytes * 8);
  newDifficulty=newDifficulty.and(mask);
  if (newDifficulty.compareTo(receivedDifficulty) != 0)   throw new VerificationException(""String_Node_Str"" + receivedDifficulty.toString(16) + ""String_Node_Str""+ newDifficulty.toString(16));
}","/** 
 * Throws an exception if the blocks difficulty is not correct.
 */
private void checkDifficultyTransitions(StoredBlock storedPrev,Block nextBlock) throws BlockStoreException, VerificationException {
  Block prev=storedPrev.getHeader();
  if ((storedPrev.getHeight() + 1) % params.interval != 0) {
    if (params.getId().equals(NetworkParameters.ID_TESTNET) && nextBlock.getTime().after(testnetDiffDate)) {
      checkTestnetDifficulty(storedPrev,prev,nextBlock);
      return;
    }
    if (nextBlock.getDifficultyTarget() != prev.getDifficultyTarget())     throw new VerificationException(""String_Node_Str"" + storedPrev.getHeight() + ""String_Node_Str""+ Long.toHexString(nextBlock.getDifficultyTarget())+ ""String_Node_Str""+ Long.toHexString(prev.getDifficultyTarget()));
    return;
  }
  long now=System.currentTimeMillis();
  StoredBlock cursor=blockStore.get(prev.getHash());
  for (int i=0; i < params.interval - 1; i++) {
    if (cursor == null) {
      throw new VerificationException(""String_Node_Str"");
    }
    cursor=blockStore.get(cursor.getHeader().getPrevBlockHash());
  }
  log.info(""String_Node_Str"",System.currentTimeMillis() - now);
  Block blockIntervalAgo=cursor.getHeader();
  int timespan=(int)(prev.getTimeSeconds() - blockIntervalAgo.getTimeSeconds());
  if (timespan < params.targetTimespan / 4)   timespan=params.targetTimespan / 4;
  if (timespan > params.targetTimespan * 4)   timespan=params.targetTimespan * 4;
  BigInteger newDifficulty=Utils.decodeCompactBits(prev.getDifficultyTarget());
  newDifficulty=newDifficulty.multiply(BigInteger.valueOf(timespan));
  newDifficulty=newDifficulty.divide(BigInteger.valueOf(params.targetTimespan));
  if (newDifficulty.compareTo(params.proofOfWorkLimit) > 0) {
    log.info(""String_Node_Str"",newDifficulty.toString(16));
    newDifficulty=params.proofOfWorkLimit;
  }
  int accuracyBytes=(int)(nextBlock.getDifficultyTarget() >>> 24) - 3;
  BigInteger receivedDifficulty=nextBlock.getDifficultyTargetAsInteger();
  BigInteger mask=BigInteger.valueOf(0xFFFFFFL).shiftLeft(accuracyBytes * 8);
  newDifficulty=newDifficulty.and(mask);
  if (newDifficulty.compareTo(receivedDifficulty) != 0)   throw new VerificationException(""String_Node_Str"" + receivedDifficulty.toString(16) + ""String_Node_Str""+ newDifficulty.toString(16));
}",0.9956709956709956
85906,"protected void discoverPeers() throws PeerDiscoveryException {
  long start=System.currentTimeMillis();
  for (  PeerDiscovery peerDiscovery : peerDiscoverers) {
    InetSocketAddress[] addresses;
    addresses=peerDiscovery.getPeers(10,TimeUnit.SECONDS);
synchronized (inactives) {
      for (int i=0; i < addresses.length; i++) {
        inactives.add(new PeerAddress(addresses[i]));
      }
      if (inactives.size() > 0)       break;
    }
  }
  log.info(""String_Node_Str"",System.currentTimeMillis() - start);
}","protected void discoverPeers() throws PeerDiscoveryException {
  long start=System.currentTimeMillis();
  Set<PeerAddress> addressSet=Sets.newHashSet();
  for (  PeerDiscovery peerDiscovery : peerDiscoverers) {
    InetSocketAddress[] addresses;
    addresses=peerDiscovery.getPeers(10,TimeUnit.SECONDS);
    for (int i=0; i < addresses.length; i++)     addressSet.add(new PeerAddress(addresses[i]));
    if (addressSet.size() > 0)     break;
  }
synchronized (inactives) {
    inactives.addAll(addressSet);
  }
  log.info(""String_Node_Str"",System.currentTimeMillis() - start);
}",0.6940639269406392
85907,"private void processInv(InventoryMessage inv) throws IOException {
  List<InventoryItem> items=inv.getItems();
  List<InventoryItem> transactions=new LinkedList<InventoryItem>();
  List<InventoryItem> blocks=new LinkedList<InventoryItem>();
  for (  InventoryItem item : items) {
switch (item.type) {
case Transaction:
      transactions.add(item);
    break;
case Block:
  blocks.add(item);
break;
default :
throw new IllegalStateException(""String_Node_Str"" + item.type);
}
}
GetDataMessage getdata=new GetDataMessage(params);
Iterator<InventoryItem> it=transactions.iterator();
while (it.hasNext()) {
InventoryItem item=it.next();
if (memoryPool == null) {
if (downloadData) {
getdata.addItem(item);
}
}
 else {
if (memoryPool.maybeWasSeen(item.hash)) {
it.remove();
}
 else {
log.debug(""String_Node_Str"",address,item.hash);
getdata.addItem(item);
}
memoryPool.seen(item.hash,this.getAddress());
}
}
if (blocks.size() > 0 && downloadData && blockChain != null) {
for (InventoryItem item : blocks) {
if (blockChain.isOrphan(item.hash)) {
blockChainDownload(blockChain.getOrphanRoot(item.hash).getHash());
}
 else {
if (!pendingBlockDownloads.contains(item.hash)) {
getdata.addItem(item);
pendingBlockDownloads.add(item.hash);
}
}
}
}
if (!getdata.getItems().isEmpty()) {
sendMessage(getdata);
}
}","private void processInv(InventoryMessage inv) throws IOException {
  List<InventoryItem> items=inv.getItems();
  List<InventoryItem> transactions=new LinkedList<InventoryItem>();
  List<InventoryItem> blocks=new LinkedList<InventoryItem>();
  for (  InventoryItem item : items) {
switch (item.type) {
case Transaction:
      transactions.add(item);
    break;
case Block:
  blocks.add(item);
break;
default :
throw new IllegalStateException(""String_Node_Str"" + item.type);
}
}
if (transactions.size() == 0 && blocks.size() == 1) {
if (downloadData) {
if (!blockChain.isOrphan(blocks.get(0).hash)) {
blocksAnnounced++;
}
}
 else {
blocksAnnounced++;
}
}
GetDataMessage getdata=new GetDataMessage(params);
Iterator<InventoryItem> it=transactions.iterator();
while (it.hasNext()) {
InventoryItem item=it.next();
if (memoryPool == null) {
if (downloadData) {
getdata.addItem(item);
}
}
 else {
if (memoryPool.maybeWasSeen(item.hash)) {
it.remove();
}
 else {
log.debug(""String_Node_Str"",address,item.hash);
getdata.addItem(item);
}
memoryPool.seen(item.hash,this.getAddress());
}
}
if (blocks.size() > 0 && downloadData && blockChain != null) {
for (InventoryItem item : blocks) {
if (blockChain.isOrphan(item.hash)) {
blockChainDownload(blockChain.getOrphanRoot(item.hash).getHash());
}
 else {
if (!pendingBlockDownloads.contains(item.hash)) {
getdata.addItem(item);
pendingBlockDownloads.add(item.hash);
}
}
}
}
if (!getdata.getItems().isEmpty()) {
sendMessage(getdata);
}
}",0.8166064981949458
85908,"/** 
 * Returns the difference between our best chain height and the peers, which can either be positive if we are behind the peer, or negative if the peer is ahead of us.
 */
public int getPeerBlockHeightDifference(){
  int chainHeight=(int)peerVersionMessage.bestHeight;
  Preconditions.checkState(params.allowEmptyPeerChains || chainHeight > 0,""String_Node_Str"",chainHeight);
  return chainHeight - blockChain.getChainHead().getHeight();
}","/** 
 * Returns the difference between our best chain height and the peers, which can either be positive if we are behind the peer, or negative if the peer is ahead of us.
 */
public int getPeerBlockHeightDifference(){
  int chainHeight=(int)getBestHeight();
  Preconditions.checkState(params.allowEmptyPeerChains || chainHeight > 0,""String_Node_Str"",chainHeight);
  return chainHeight - blockChain.getChainHead().getHeight();
}",0.9494252873563218
85909,"/** 
 * @return the height of the best chain as claimed by peer.
 */
public long getBestHeight(){
  return peerVersionMessage.bestHeight;
}","/** 
 * @return the height of the best chain as claimed by peer: sum of its ver announcement and blocks announced since.
 */
public long getBestHeight(){
  return peerVersionMessage.bestHeight + blocksAnnounced;
}",0.7897727272727273
85910,"private synchronized void setDownloadPeer(Peer peer){
  if (downloadPeer != null) {
    log.info(""String_Node_Str"",downloadPeer);
    downloadPeer.setDownloadData(false);
  }
  downloadPeer=peer;
  if (downloadPeer != null) {
    log.info(""String_Node_Str"",downloadPeer);
    downloadPeer.setDownloadData(true);
    if (chain != null)     downloadPeer.setFastCatchupTime(fastCatchupTimeSecs);
  }
}","private synchronized void setDownloadPeer(Peer peer){
  if (chain == null)   return;
  if (downloadPeer != null) {
    log.info(""String_Node_Str"",downloadPeer);
    downloadPeer.setDownloadData(false);
  }
  downloadPeer=peer;
  if (downloadPeer != null) {
    log.info(""String_Node_Str"",downloadPeer);
    downloadPeer.setDownloadData(true);
    if (chain != null)     downloadPeer.setFastCatchupTime(fastCatchupTimeSecs);
  }
}",0.9625151148730352
85911,"/** 
 * Helper method that just sets up a normal Netty ClientBootstrap using the default options, except for a custom thread factory that gives worker threads useful names and lowers their priority (to avoid competing with UI threads). You don't normally need to call this - if you aren't sure what it does, just use the regular constructors for   {@link PeerGroup} that don't take a ClientBootstrap object.
 */
public static ClientBootstrap createClientBootstrap(){
  ExecutorService bossExecutor=Executors.newCachedThreadPool(new PeerGroupThreadFactory());
  ExecutorService workerExecutor=Executors.newCachedThreadPool(new PeerGroupThreadFactory());
  NioClientSocketChannelFactory channelFactory=new NioClientSocketChannelFactory(bossExecutor,workerExecutor);
  ClientBootstrap bs=new ClientBootstrap(channelFactory);
  return bs;
}","/** 
 * Helper method that just sets up a normal Netty ClientBootstrap using the default options, except for a custom thread factory that gives worker threads useful names and lowers their priority (to avoid competing with UI threads). You don't normally need to call this - if you aren't sure what it does, just use the regular constructors for   {@link PeerGroup} that don't take a ClientBootstrap object.
 */
public static ClientBootstrap createClientBootstrap(){
  ExecutorService bossExecutor=Executors.newCachedThreadPool(new PeerGroupThreadFactory());
  ExecutorService workerExecutor=Executors.newCachedThreadPool(new PeerGroupThreadFactory());
  NioClientSocketChannelFactory channelFactory=new NioClientSocketChannelFactory(bossExecutor,workerExecutor);
  ClientBootstrap bs=new ClientBootstrap(channelFactory);
  bs.setOption(""String_Node_Str"",2000);
  return bs;
}",0.9684579439252337
85912,"@Test public void newBlock() throws Exception {
  PeerEventListener listener=control.createMock(PeerEventListener.class);
  Block b1=createFakeBlock(unitTestParams,blockStore).block;
  blockChain.add(b1);
  Block b2=makeSolvedTestBlock(unitTestParams,b1);
  InventoryMessage inv=new InventoryMessage(unitTestParams);
  InventoryItem item=new InventoryItem(InventoryItem.Type.Block,b2.getHash());
  inv.addItem(item);
  expect(listener.onPreMessageReceived(eq(peer),eq(inv))).andReturn(inv);
  expect(listener.onPreMessageReceived(eq(peer),eq(b2))).andReturn(b2);
  listener.onBlocksDownloaded(eq(peer),anyObject(Block.class),eq(108));
  expectLastCall();
  control.replay();
  connect();
  peer.addEventListener(listener);
  inbound(peer,inv);
  inbound(peer,b2);
  control.verify();
  GetDataMessage getdata=(GetDataMessage)event.getValue().getMessage();
  List<InventoryItem> items=getdata.getItems();
  assertEquals(1,items.size());
  assertEquals(b2.getHash(),items.get(0).hash);
  assertEquals(InventoryItem.Type.Block,items.get(0).type);
}","@Test public void newBlock() throws Exception {
  PeerEventListener listener=control.createMock(PeerEventListener.class);
  Block b1=createFakeBlock(unitTestParams,blockStore).block;
  blockChain.add(b1);
  Block b2=makeSolvedTestBlock(unitTestParams,b1);
  InventoryMessage inv=new InventoryMessage(unitTestParams);
  InventoryItem item=new InventoryItem(InventoryItem.Type.Block,b2.getHash());
  inv.addItem(item);
  expect(listener.onPreMessageReceived(eq(peer),eq(inv))).andReturn(inv);
  expect(listener.onPreMessageReceived(eq(peer),eq(b2))).andReturn(b2);
  listener.onBlocksDownloaded(eq(peer),anyObject(Block.class),eq(OTHER_PEER_CHAIN_HEIGHT + 1 - 2));
  expectLastCall();
  control.replay();
  connect();
  peer.addEventListener(listener);
  long height=peer.getBestHeight();
  inbound(peer,inv);
  assertEquals(height + 1,peer.getBestHeight());
  inbound(peer,b2);
  control.verify();
  GetDataMessage getdata=(GetDataMessage)event.getValue().getMessage();
  List<InventoryItem> items=getdata.getItems();
  assertEquals(1,items.size());
  assertEquals(b2.getHash(),items.get(0).hash);
  assertEquals(InventoryItem.Type.Block,items.get(0).type);
}",0.7498865183840218
85913,"private void connect(PeerHandler handler,Channel channel,ChannelHandlerContext ctx) throws Exception {
  handler.connectRequested(ctx,new UpstreamChannelStateEvent(channel,ChannelState.CONNECTED,socketAddress));
  VersionMessage peerVersion=new VersionMessage(unitTestParams,110);
  DownstreamMessageEvent versionEvent=new DownstreamMessageEvent(channel,Channels.future(channel),peerVersion,null);
  handler.messageReceived(ctx,versionEvent);
}","private void connect(PeerHandler handler,Channel channel,ChannelHandlerContext ctx) throws Exception {
  handler.connectRequested(ctx,new UpstreamChannelStateEvent(channel,ChannelState.CONNECTED,socketAddress));
  VersionMessage peerVersion=new VersionMessage(unitTestParams,OTHER_PEER_CHAIN_HEIGHT);
  DownstreamMessageEvent versionEvent=new DownstreamMessageEvent(channel,Channels.future(channel),peerVersion,null);
  handler.messageReceived(ctx,versionEvent);
}",0.9713656387665198
85914,"@Test public void pingPong() throws Exception {
  control.replay();
  connect();
  Utils.rollMockClock(0);
  assertEquals(Long.MAX_VALUE,peer.getLastPingTime());
  assertEquals(Long.MAX_VALUE,peer.getPingTime());
  ListenableFuture<Long> future=peer.ping();
  Ping pingMsg=(Ping)outbound();
  assertEquals(Long.MAX_VALUE,peer.getLastPingTime());
  assertEquals(Long.MAX_VALUE,peer.getPingTime());
  assertFalse(future.isDone());
  Utils.rollMockClock(5);
  inbound(peer,new Pong(pingMsg.getNonce()));
  assertTrue(future.isDone());
  long elapsed=future.get();
  assertTrue(""String_Node_Str"" + elapsed,elapsed > 1000);
  assertEquals(elapsed,peer.getLastPingTime());
  assertEquals(elapsed,peer.getPingTime());
  future=peer.ping();
  outbound();
  Utils.rollMockClock(50);
  inbound(peer,new Pong(pingMsg.getNonce()));
  elapsed=future.get();
  assertEquals(elapsed,peer.getLastPingTime());
  assertEquals(14000,peer.getPingTime());
}","@Test public void pingPong() throws Exception {
  control.replay();
  connect();
  Utils.rollMockClock(0);
  assertEquals(Long.MAX_VALUE,peer.getLastPingTime());
  assertEquals(Long.MAX_VALUE,peer.getPingTime());
  ListenableFuture<Long> future=peer.ping();
  Ping pingMsg=(Ping)outbound();
  assertEquals(Long.MAX_VALUE,peer.getLastPingTime());
  assertEquals(Long.MAX_VALUE,peer.getPingTime());
  assertFalse(future.isDone());
  Utils.rollMockClock(5);
  inbound(peer,new Pong(pingMsg.getNonce()));
  assertTrue(future.isDone());
  long elapsed=future.get();
  assertTrue(""String_Node_Str"" + elapsed,elapsed > 1000);
  assertEquals(elapsed,peer.getLastPingTime());
  assertEquals(elapsed,peer.getPingTime());
  future=peer.ping();
  outbound();
  Utils.rollMockClock(50);
  inbound(peer,new Pong(pingMsg.getNonce()));
  elapsed=future.get();
  assertEquals(elapsed,peer.getLastPingTime());
  assertEquals(7250,peer.getPingTime());
}",0.99625468164794
85915,"/** 
 * Adds a transaction to this block. The nonce and merkle root are invalid after this. 
 */
public void addTransaction(Transaction t){
  unCacheTransactions();
  if (transactions == null) {
    transactions=new ArrayList<Transaction>();
  }
  t.setParent(this);
  if (transactions.size() == 0 && !t.isCoinBase())   throw new RuntimeException(""String_Node_Str"" + t);
 else   if (transactions.size() > 0 && t.isCoinBase())   throw new RuntimeException(""String_Node_Str"" + t);
  transactions.add(t);
  adjustLength(t.length);
  merkleRoot=null;
  hash=null;
}","/** 
 * Adds a transaction to this block. The nonce and merkle root are invalid after this. 
 */
public void addTransaction(Transaction t){
  unCacheTransactions();
  if (transactions == null) {
    transactions=new ArrayList<Transaction>();
  }
  t.setParent(this);
  if (transactions.size() == 0 && !t.isCoinBase())   throw new RuntimeException(""String_Node_Str"" + t);
 else   if (transactions.size() > 0 && t.isCoinBase())   throw new RuntimeException(""String_Node_Str"" + t);
  transactions.add(t);
  adjustLength(transactions.size(),t.length);
  merkleRoot=null;
  hash=null;
}",0.9824868651488616
85916,"/** 
 * Adds a coinbase transaction to the block. This exists for unit tests. 
 */
void addCoinbaseTransaction(byte[] pubKeyTo){
  unCacheTransactions();
  transactions=new ArrayList<Transaction>();
  Transaction coinbase=new Transaction(params);
  coinbase.addInput(new TransactionInput(params,coinbase,new byte[]{(byte)txCounter++}));
  coinbase.addOutput(new TransactionOutput(params,coinbase,Script.createOutputScript(pubKeyTo)));
  transactions.add(coinbase);
}","/** 
 * Adds a coinbase transaction to the block. This exists for unit tests. 
 */
void addCoinbaseTransaction(byte[] pubKeyTo){
  unCacheTransactions();
  transactions=new ArrayList<Transaction>();
  Transaction coinbase=new Transaction(params);
  coinbase.addInput(new TransactionInput(params,coinbase,new byte[]{(byte)txCounter++}));
  coinbase.addOutput(new TransactionOutput(params,coinbase,Script.createOutputScript(pubKeyTo)));
  transactions.add(coinbase);
  coinbase.setParent(this);
  coinbase.length=coinbase.bitcoinSerialize().length;
  adjustLength(transactions.size(),coinbase.length);
}",0.8734770384254921
85917,"protected void adjustLength(int adjustment){
  if (length != UNKNOWN_LENGTH)   length+=adjustment;
  if (parent != null)   parent.adjustLength(adjustment);
}","protected void adjustLength(int newArraySize,int adjustment){
  super.adjustLength(newArraySize,adjustment);
  if (parent != null)   parent.adjustLength(newArraySize,adjustment);
}",0.7299703264094956
85918,"protected void adjustLength(int adjustment){
  if (length != UNKNOWN_LENGTH)   length=adjustment == UNKNOWN_LENGTH ? UNKNOWN_LENGTH : length + adjustment;
}","protected void adjustLength(int newArraySize,int adjustment){
  if (length == UNKNOWN_LENGTH)   return;
  if (adjustment == UNKNOWN_LENGTH) {
    length=UNKNOWN_LENGTH;
    return;
  }
  length+=adjustment;
  if (newArraySize == 1)   length++;
 else   if (newArraySize != 0)   length+=VarInt.sizeOf(newArraySize) - VarInt.sizeOf(newArraySize - 1);
}",0.5306930693069307
85919,"/** 
 * Adds an input directly, with no checking that it's valid.
 */
public void addInput(TransactionInput input){
  unCache();
  input.setParent(this);
  inputs.add(input);
  adjustLength(input.length);
}","/** 
 * Adds an input directly, with no checking that it's valid.
 */
public void addInput(TransactionInput input){
  unCache();
  input.setParent(this);
  inputs.add(input);
  adjustLength(inputs.size(),input.length);
}",0.9671361502347418
85920,"private void readConfidence(Transaction tx,Protos.TransactionConfidence confidenceProto,TransactionConfidence confidence){
  if (!confidenceProto.hasType()) {
    log.warn(""String_Node_Str"",tx.getHashAsString());
    return;
  }
  ConfidenceType confidenceType=TransactionConfidence.ConfidenceType.valueOf(confidenceProto.getType().getNumber());
  confidence.setConfidenceType(confidenceType);
  if (confidenceProto.hasAppearedAtHeight()) {
    if (confidence.getConfidenceType() != ConfidenceType.BUILDING) {
      log.warn(""String_Node_Str"",tx.getHashAsString());
      return;
    }
    confidence.setAppearedAtChainHeight(confidenceProto.getAppearedAtHeight());
  }
  if (confidenceProto.hasDepth()) {
    if (confidence.getConfidenceType() != ConfidenceType.BUILDING) {
      log.warn(""String_Node_Str"",tx.getHashAsString());
      return;
    }
    confidence.setDepthInBlocks(confidenceProto.getDepth());
  }
 else {
    if (chainHeight != 0) {
      confidence.setDepthInBlocks(chainHeight - confidence.getAppearedAtChainHeight() + 1);
    }
  }
  if (confidenceProto.hasWorkDone()) {
    if (confidence.getConfidenceType() != ConfidenceType.BUILDING) {
      log.warn(""String_Node_Str"",tx.getHashAsString());
      return;
    }
    confidence.setWorkDone(BigInteger.valueOf(confidenceProto.getWorkDone()));
  }
  if (confidenceProto.hasOverridingTransaction()) {
    if (confidence.getConfidenceType() != ConfidenceType.DEAD) {
      log.warn(""String_Node_Str"",tx.getHashAsString());
      return;
    }
    Transaction overridingTransaction=txMap.get(confidenceProto.getOverridingTransaction());
    if (overridingTransaction == null) {
      log.warn(""String_Node_Str"",tx.getHashAsString());
      return;
    }
    confidence.setOverridingTransaction(overridingTransaction);
  }
  for (  Protos.PeerAddress proto : confidenceProto.getBroadcastByList()) {
    InetAddress ip;
    try {
      ip=InetAddress.getByAddress(proto.getIpAddress().toByteArray());
    }
 catch (    UnknownHostException e) {
      throw new RuntimeException(e);
    }
    int port=proto.getPort();
    PeerAddress address=new PeerAddress(ip,port);
    address.setServices(BigInteger.valueOf(proto.getServices()));
    confidence.markBroadcastBy(address);
  }
}","private void readConfidence(Transaction tx,Protos.TransactionConfidence confidenceProto,TransactionConfidence confidence){
  if (!confidenceProto.hasType()) {
    log.warn(""String_Node_Str"",tx.getHashAsString());
    return;
  }
  ConfidenceType confidenceType=TransactionConfidence.ConfidenceType.valueOf(confidenceProto.getType().getNumber());
  confidence.setConfidenceType(confidenceType);
  if (confidenceProto.hasAppearedAtHeight()) {
    if (confidence.getConfidenceType() != ConfidenceType.BUILDING) {
      log.warn(""String_Node_Str"",tx.getHashAsString());
      return;
    }
    confidence.setAppearedAtChainHeight(confidenceProto.getAppearedAtHeight());
  }
  if (confidenceProto.hasDepth()) {
    if (confidence.getConfidenceType() != ConfidenceType.BUILDING) {
      log.warn(""String_Node_Str"",tx.getHashAsString());
      return;
    }
    confidence.setDepthInBlocks(confidenceProto.getDepth());
  }
 else {
    if (chainHeight != 0 && confidenceProto.hasAppearedAtHeight()) {
      confidence.setDepthInBlocks(chainHeight - confidence.getAppearedAtChainHeight() + 1);
    }
  }
  if (confidenceProto.hasWorkDone()) {
    if (confidence.getConfidenceType() != ConfidenceType.BUILDING) {
      log.warn(""String_Node_Str"",tx.getHashAsString());
      return;
    }
    confidence.setWorkDone(BigInteger.valueOf(confidenceProto.getWorkDone()));
  }
  if (confidenceProto.hasOverridingTransaction()) {
    if (confidence.getConfidenceType() != ConfidenceType.DEAD) {
      log.warn(""String_Node_Str"",tx.getHashAsString());
      return;
    }
    Transaction overridingTransaction=txMap.get(confidenceProto.getOverridingTransaction());
    if (overridingTransaction == null) {
      log.warn(""String_Node_Str"",tx.getHashAsString());
      return;
    }
    confidence.setOverridingTransaction(overridingTransaction);
  }
  for (  Protos.PeerAddress proto : confidenceProto.getBroadcastByList()) {
    InetAddress ip;
    try {
      ip=InetAddress.getByAddress(proto.getIpAddress().toByteArray());
    }
 catch (    UnknownHostException e) {
      throw new RuntimeException(e);
    }
    int port=proto.getPort();
    PeerAddress address=new PeerAddress(ip,port);
    address.setServices(BigInteger.valueOf(proto.getServices()));
    confidence.markBroadcastBy(address);
  }
}",0.9909631915362574
85921,"private void processHeaders(HeadersMessage m) throws IOException, ProtocolException {
  Preconditions.checkState(!downloadBlockBodies,toString());
  try {
    for (int i=0; i < m.getBlockHeaders().size(); i++) {
      Block header=m.getBlockHeaders().get(i);
      if (header.getTimeSeconds() < fastCatchupTimeSecs) {
        if (blockChain.add(header)) {
          invokeOnBlocksDownloaded(header);
        }
 else {
          throw new ProtocolException(""String_Node_Str"" + header.getHashAsString());
        }
      }
 else {
        log.info(""String_Node_Str"",m.getBlockHeaders().size() - i);
        downloadBlockBodies=true;
        blockChainDownload(header.getHash());
        return;
      }
    }
    if (m.getBlockHeaders().size() >= HeadersMessage.MAX_HEADERS)     blockChainDownload(Sha256Hash.ZERO_HASH);
  }
 catch (  VerificationException e) {
    log.warn(""String_Node_Str"",e);
  }
catch (  ScriptException e) {
    throw new RuntimeException(e);
  }
}","private void processHeaders(HeadersMessage m) throws IOException, ProtocolException {
  Preconditions.checkState(!downloadBlockBodies,toString());
  try {
    for (int i=0; i < m.getBlockHeaders().size(); i++) {
      Block header=m.getBlockHeaders().get(i);
      if (header.getTimeSeconds() < fastCatchupTimeSecs) {
        if (blockChain.add(header)) {
          invokeOnBlocksDownloaded(header);
        }
 else {
          throw new ProtocolException(""String_Node_Str"" + header.getHashAsString());
        }
      }
 else {
        log.info(""String_Node_Str"",m.getBlockHeaders().size() - i);
        downloadBlockBodies=true;
        lastGetBlocksBegin=Sha256Hash.ZERO_HASH;
        blockChainDownload(Sha256Hash.ZERO_HASH);
        return;
      }
    }
    if (m.getBlockHeaders().size() >= HeadersMessage.MAX_HEADERS)     blockChainDownload(Sha256Hash.ZERO_HASH);
  }
 catch (  VerificationException e) {
    log.warn(""String_Node_Str"",e);
  }
catch (  ScriptException e) {
    throw new RuntimeException(e);
  }
}",0.957307885484681
85922,"@Test public void fastCatchup() throws Exception {
  control.replay();
  connect();
  Block b1=createFakeBlock(unitTestParams,blockStore).block;
  blockChain.add(b1);
  Utils.rollMockClock(60 * 10);
  Block b2=makeSolvedTestBlock(unitTestParams,b1);
  Utils.rollMockClock(60 * 10);
  Block b3=makeSolvedTestBlock(unitTestParams,b2);
  Utils.rollMockClock(60 * 10);
  Block b4=makeSolvedTestBlock(unitTestParams,b3);
  peer.setFastCatchupTime((Utils.now().getTime() / 1000) - (600 * 2) + 1);
  peer.startBlockChainDownload();
  GetHeadersMessage getheaders=(GetHeadersMessage)event.getValue().getMessage();
  List<Sha256Hash> expectedLocator=new ArrayList<Sha256Hash>();
  expectedLocator.add(b1.getHash());
  expectedLocator.add(unitTestParams.genesisBlock.getHash());
  assertEquals(getheaders.getLocator(),expectedLocator);
  assertEquals(getheaders.getStopHash(),Sha256Hash.ZERO_HASH);
  HeadersMessage headers=new HeadersMessage(unitTestParams,b2.cloneAsHeader(),b3.cloneAsHeader(),b4.cloneAsHeader());
  expectedLocator.clear();
  expectedLocator.add(b2.getHash());
  expectedLocator.add(b1.getHash());
  expectedLocator.add(unitTestParams.genesisBlock.getHash());
  inbound(peer,headers);
  GetBlocksMessage getblocks=(GetBlocksMessage)event.getValue().getMessage();
  assertEquals(expectedLocator,getblocks.getLocator());
  assertEquals(b3.getHash(),getblocks.getStopHash());
  InventoryMessage inv=new InventoryMessage(unitTestParams);
  inv.addItem(new InventoryItem(InventoryItem.Type.Block,b3.getHash()));
  inbound(peer,inv);
  GetDataMessage getdata=(GetDataMessage)event.getValue().getMessage();
  assertEquals(b3.getHash(),getdata.getItems().get(0).hash);
  inbound(peer,b3);
}","@Test public void fastCatchup() throws Exception {
  control.replay();
  connect();
  Block b1=createFakeBlock(unitTestParams,blockStore).block;
  blockChain.add(b1);
  Utils.rollMockClock(60 * 10);
  Block b2=makeSolvedTestBlock(unitTestParams,b1);
  Utils.rollMockClock(60 * 10);
  Block b3=makeSolvedTestBlock(unitTestParams,b2);
  Utils.rollMockClock(60 * 10);
  Block b4=makeSolvedTestBlock(unitTestParams,b3);
  peer.setFastCatchupTime((Utils.now().getTime() / 1000) - (600 * 2) + 1);
  peer.startBlockChainDownload();
  GetHeadersMessage getheaders=(GetHeadersMessage)event.getValue().getMessage();
  List<Sha256Hash> expectedLocator=new ArrayList<Sha256Hash>();
  expectedLocator.add(b1.getHash());
  expectedLocator.add(unitTestParams.genesisBlock.getHash());
  assertEquals(getheaders.getLocator(),expectedLocator);
  assertEquals(getheaders.getStopHash(),Sha256Hash.ZERO_HASH);
  HeadersMessage headers=new HeadersMessage(unitTestParams,b2.cloneAsHeader(),b3.cloneAsHeader(),b4.cloneAsHeader());
  expectedLocator.clear();
  expectedLocator.add(b2.getHash());
  expectedLocator.add(b1.getHash());
  expectedLocator.add(unitTestParams.genesisBlock.getHash());
  inbound(peer,headers);
  GetBlocksMessage getblocks=(GetBlocksMessage)event.getValue().getMessage();
  assertEquals(expectedLocator,getblocks.getLocator());
  assertEquals(Sha256Hash.ZERO_HASH,getblocks.getStopHash());
  InventoryMessage inv=new InventoryMessage(unitTestParams);
  inv.addItem(new InventoryItem(InventoryItem.Type.Block,b3.getHash()));
  inbound(peer,inv);
  GetDataMessage getdata=(GetDataMessage)event.getValue().getMessage();
  assertEquals(b3.getHash(),getdata.getItems().get(0).hash);
  inbound(peer,b3);
}",0.9905660377358492
85923,"private void reprocessUnincludedTxAfterReorg(Map<Sha256Hash,Transaction> pool,Transaction tx){
  log.info(""String_Node_Str"",tx.getHashAsString() + ""String_Node_Str"" + tx.getConfidence().getConfidenceType().name());
  boolean isDeadCoinbase=tx.isCoinBase() && ConfidenceType.DEAD == tx.getConfidence().getConfidenceType();
  if (isDeadCoinbase) {
    return;
  }
  int numInputs=tx.getInputs().size();
  int noSuchTx=0;
  int success=0;
  boolean isDead=false;
  Set<Transaction> connectedTransactions=new TreeSet<Transaction>();
  for (  TransactionInput input : tx.getInputs()) {
    TransactionInput.ConnectionResult result=input.connect(pool,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
    if (result == TransactionInput.ConnectionResult.SUCCESS) {
      success++;
      TransactionOutput connectedOutput=checkNotNull(input.getConnectedOutput(pool));
      connectedTransactions.add(checkNotNull(connectedOutput.parentTransaction));
    }
 else     if (result == TransactionInput.ConnectionResult.NO_SUCH_TX) {
      noSuchTx++;
    }
 else     if (result == TransactionInput.ConnectionResult.ALREADY_SPENT) {
      isDead=true;
      log.info(""String_Node_Str"",tx.getHashAsString());
      TransactionOutput doubleSpent=input.getConnectedOutput(pool);
      Transaction replacement=doubleSpent.getSpentBy().getParentTransaction();
      dead.put(tx.getHash(),tx);
      pending.remove(tx.getHash());
      tx.getConfidence().setOverridingTransaction(replacement);
      break;
    }
  }
  if (isDead)   return;
  if (noSuchTx == numInputs) {
    log.info(""String_Node_Str"",tx.getHashAsString() + ""String_Node_Str"" + tx.getConfidence().getConfidenceType().name());
    inactive.put(tx.getHash(),tx);
    dead.remove(tx.getHash());
  }
 else   if (success == numInputs - noSuchTx) {
    log.info(""String_Node_Str"",tx.getHashAsString() + ""String_Node_Str"" + tx.getConfidence().getConfidenceType().name());
    pending.put(tx.getHash(),tx);
    dead.remove(tx.getHash());
  }
  for (  Transaction maybeSpent : connectedTransactions) {
    maybeMoveTxToSpent(maybeSpent,""String_Node_Str"");
  }
}","private void reprocessUnincludedTxAfterReorg(Map<Sha256Hash,Transaction> pool,Transaction tx){
  log.info(""String_Node_Str"",tx.getHashAsString() + ""String_Node_Str"" + tx.getConfidence().getConfidenceType().name());
  boolean isDeadCoinbase=tx.isCoinBase() && ConfidenceType.DEAD == tx.getConfidence().getConfidenceType();
  if (isDeadCoinbase) {
    return;
  }
  int numInputs=tx.getInputs().size();
  int noSuchTx=0;
  int success=0;
  boolean isDead=false;
  Set<Transaction> connectedTransactions=new HashSet<Transaction>();
  for (  TransactionInput input : tx.getInputs()) {
    TransactionInput.ConnectionResult result=input.connect(pool,TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
    if (result == TransactionInput.ConnectionResult.SUCCESS) {
      success++;
      TransactionOutput connectedOutput=checkNotNull(input.getConnectedOutput(pool));
      connectedTransactions.add(checkNotNull(connectedOutput.parentTransaction));
    }
 else     if (result == TransactionInput.ConnectionResult.NO_SUCH_TX) {
      noSuchTx++;
    }
 else     if (result == TransactionInput.ConnectionResult.ALREADY_SPENT) {
      isDead=true;
      log.info(""String_Node_Str"",tx.getHashAsString());
      TransactionOutput doubleSpent=input.getConnectedOutput(pool);
      Transaction replacement=doubleSpent.getSpentBy().getParentTransaction();
      dead.put(tx.getHash(),tx);
      pending.remove(tx.getHash());
      tx.getConfidence().setOverridingTransaction(replacement);
      break;
    }
  }
  if (isDead)   return;
  if (noSuchTx == numInputs) {
    log.info(""String_Node_Str"",tx.getHashAsString() + ""String_Node_Str"" + tx.getConfidence().getConfidenceType().name());
    inactive.put(tx.getHash(),tx);
    dead.remove(tx.getHash());
  }
 else   if (success == numInputs - noSuchTx) {
    log.info(""String_Node_Str"",tx.getHashAsString() + ""String_Node_Str"" + tx.getConfidence().getConfidenceType().name());
    pending.put(tx.getHash(),tx);
    dead.remove(tx.getHash());
  }
  for (  Transaction maybeSpent : connectedTransactions) {
    maybeMoveTxToSpent(maybeSpent,""String_Node_Str"");
  }
}",0.998095238095238
85924,"public void run(){
  log.info(""String_Node_Str"");
  while (true) {
    try {
      WalletSaveRequest req=walletRefs.poll(5,TimeUnit.SECONDS);
      if (req == null && walletRefs.size() == 0) {
        break;
      }
synchronized (req.wallet) {
        if (req.wallet.dirty) {
          if (req.wallet.autoSave()) {
            break;
          }
        }
      }
    }
 catch (    InterruptedException e) {
      break;
    }
  }
  log.info(""String_Node_Str"");
synchronized (AutosaveThread.class) {
    Preconditions.checkState(globalThread == this);
    globalThread=null;
  }
}","public void run(){
  log.info(""String_Node_Str"");
  while (true) {
    try {
      WalletSaveRequest req=walletRefs.poll(5,TimeUnit.SECONDS);
      if (req == null) {
        if (walletRefs.size() == 0) {
          break;
        }
 else {
          continue;
        }
      }
synchronized (req.wallet) {
        if (req.wallet.dirty) {
          if (req.wallet.autoSave()) {
            break;
          }
        }
      }
    }
 catch (    InterruptedException e) {
      log.error(""String_Node_Str"",e);
      break;
    }
  }
  log.info(""String_Node_Str"");
synchronized (AutosaveThread.class) {
    Preconditions.checkState(globalThread == this);
    globalThread=null;
  }
  maybeStart();
}",0.8589341692789969
85925,"/** 
 * Called by a wallet when it's become dirty (changed). Will start the background thread if needed. 
 */
public static void registerForSave(Wallet wallet,long delayMsec){
  AutosaveThread ats=get();
  ats.walletRefs.put(new WalletSaveRequest(wallet,delayMsec));
}","/** 
 * Called by a wallet when it's become dirty (changed). Will start the background thread if needed. 
 */
public static void registerForSave(Wallet wallet,long delayMsec){
  walletRefs.add(new WalletSaveRequest(wallet,delayMsec));
  maybeStart();
}",0.8615384615384616
85926,"/** 
 * <p>Sets up the wallet to auto-save itself to the given file, using temp files with atomic renames to ensure consistency. After connecting to a file, you no longer need to save the wallet manually, it will do it whenever necessary. Protocol buffer serialization will be used.</p> <p>If delayTime is set, a background thread will be created and the wallet will only be saved to disk every so many time units. If no changes have occurred for the given time period, nothing will be written. In this way disk IO can be rate limited. It's a good idea to set this as otherwise the wallet can change very frequently, eg if there are a lot of transactions in it or a busy key, and there will be a lot of redundant writes. Note that when a new key is added, that always results in an immediate save regardless of delayTime.</p> <p>An event listener can be provided. If a delay >0 was specified, it will be called on a background thread with the wallet locked when an auto-save occurs. If delay is zero or you do something that always triggers an immediate save, like adding a key, the event listener will be invoked on the calling threads. There is an important detail to get right here. The background thread that performs auto-saving keeps a weak reference to the wallet and shuts itself down if the wallet is garbage collected, so you don't have to think about it. If you provide an event listener however, it'd be very easy to accidentally hold a strong reference from your event listener to the wallet, meaning that the background thread will transitively keep your wallet object alive and un-collectable. So be careful to use a static inner class for this to avoid that problem, unless you don't care about keeping wallets alive indefinitely.</p>
 * @param f The destination file to save to.
 * @param delayTime How many time units to wait until saving the wallet on a background thread.
 * @param timeUnit the unit of measurement for delayTime.
 * @param eventListener callback to be informed when the auto-save thread does things, or null
 * @throws IOException
 */
public synchronized void autosaveToFile(File f,long delayTime,TimeUnit timeUnit,AutosaveEventListener eventListener){
  Preconditions.checkArgument(delayTime >= 0);
  autosaveToFile=Preconditions.checkNotNull(f);
  if (delayTime > 0) {
    autosaveEventListener=eventListener;
    autosaveDelayMs=TimeUnit.MILLISECONDS.convert(delayTime,timeUnit);
  }
}","/** 
 * <p>Sets up the wallet to auto-save itself to the given file, using temp files with atomic renames to ensure consistency. After connecting to a file, you no longer need to save the wallet manually, it will do it whenever necessary. Protocol buffer serialization will be used.</p> <p>If delayTime is set, a background thread will be created and the wallet will only be saved to disk every so many time units. If no changes have occurred for the given time period, nothing will be written. In this way disk IO can be rate limited. It's a good idea to set this as otherwise the wallet can change very frequently, eg if there are a lot of transactions in it or during block sync, and there will be a lot of redundant writes. Note that when a new key is added, that always results in an immediate save regardless of delayTime. <b>You should still save the wallet manually when your program is about to shut down as the JVM will not wait for the background thread.</b></p> <p>An event listener can be provided. If a delay >0 was specified, it will be called on a background thread with the wallet locked when an auto-save occurs. If delay is zero or you do something that always triggers an immediate save, like adding a key, the event listener will be invoked on the calling threads.</p>
 * @param f The destination file to save to.
 * @param delayTime How many time units to wait until saving the wallet on a background thread.
 * @param timeUnit the unit of measurement for delayTime.
 * @param eventListener callback to be informed when the auto-save thread does things, or null
 * @throws IOException
 */
public synchronized void autosaveToFile(File f,long delayTime,TimeUnit timeUnit,AutosaveEventListener eventListener){
  Preconditions.checkArgument(delayTime >= 0);
  autosaveToFile=Preconditions.checkNotNull(f);
  if (delayTime > 0) {
    autosaveEventListener=eventListener;
    autosaveDelayMs=TimeUnit.MILLISECONDS.convert(delayTime,timeUnit);
  }
}",0.8234221918432445
85927,"private AutosaveThread(){
  this.walletRefs=new DelayQueue<WalletSaveRequest>();
  setDaemon(true);
  setName(""String_Node_Str"");
  setPriority(Thread.MIN_PRIORITY);
}","private AutosaveThread(){
  setDaemon(true);
  setName(""String_Node_Str"");
  setPriority(Thread.MIN_PRIORITY);
}",0.8028673835125448
85928,"public static void main(String[] args) throws Exception {
  OptionParser parser=new OptionParser();
  parser.accepts(""String_Node_Str"");
  parser.accepts(""String_Node_Str"");
  parser.accepts(""String_Node_Str"");
  walletFileName=parser.accepts(""String_Node_Str"").withRequiredArg().defaultsTo(""String_Node_Str"");
  actionFlag=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(ActionEnum.class);
  netFlag=parser.accepts(""String_Node_Str"").withOptionalArg().ofType(NetworkEnum.class).defaultsTo(NetworkEnum.PROD);
  dateFlag=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(Date.class).withValuesConvertedBy(DateConverter.datePattern(""String_Node_Str""));
  waitForFlag=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(WaitForEnum.class);
  OptionSpec<String> chainFlag=parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  OptionSpec<String> outputFlag=parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  conditionFlag=parser.accepts(""String_Node_Str"").withRequiredArg();
  options=parser.parse(args);
  if (args.length == 0 || options.has(""String_Node_Str"") || options.nonOptionArguments().size() > 0) {
    System.out.println(HELP_TEXT);
    return;
  }
  if (options.has(""String_Node_Str"")) {
    BriefLogFormatter.init();
    log.info(""String_Node_Str"");
  }
 else {
    logger=LogManager.getLogManager().getLogger(""String_Node_Str"");
    logger.setLevel(Level.SEVERE);
  }
switch (netFlag.value(options)) {
case PROD:
    params=NetworkParameters.prodNet();
  chainFileName=new File(""String_Node_Str"");
discovery=new DnsDiscovery(params);
break;
case TEST:
params=NetworkParameters.testNet();
chainFileName=new File(""String_Node_Str"");
discovery=new IrcDiscovery(""String_Node_Str"");
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
if (options.has(chainFlag)) {
chainFileName=new File(chainFlag.value(options));
}
if (options.has(""String_Node_Str"")) {
condition=new Condition(conditionFlag.value(options));
}
ActionEnum action=ActionEnum.NONE;
if (options.has(actionFlag)) action=actionFlag.value(options);
walletFile=new File(walletFileName.value(options));
if (action == ActionEnum.CREATE) {
createWallet(options,params,walletFile);
return;
}
if (!walletFile.exists()) {
System.err.println(""String_Node_Str"" + walletFile + ""String_Node_Str"");
return;
}
if (action == ActionEnum.RAW_DUMP) {
FileInputStream stream=new FileInputStream(walletFile);
try {
Protos.Wallet proto=WalletProtobufSerializer.parseToProto(stream);
System.out.println(proto.toString());
return;
}
  finally {
stream.close();
}
}
try {
wallet=Wallet.loadFromFile(walletFile);
if (!wallet.getParams().equals(params)) {
System.err.println(""String_Node_Str"" + wallet.getParams().getId() + ""String_Node_Str""+ params.getId());
return;
}
}
 catch (Exception e) {
System.err.println(""String_Node_Str"" + walletFile + ""String_Node_Str""+ e.getMessage());
e.printStackTrace();
return;
}
switch (action) {
case DUMP:
dumpWallet();
break;
case ADD_KEY:
addKey();
break;
case DELETE_KEY:
deleteKey();
break;
case RESET:
reset();
break;
case SYNC:
syncChain();
break;
case SEND:
if (!options.has(outputFlag)) {
System.err.println(""String_Node_Str"");
return;
}
send(outputFlag.values(options));
break;
}
if (!wallet.isConsistent()) {
System.err.println(""String_Node_Str"");
return;
}
saveWallet(walletFile);
if (options.has(waitForFlag)) {
wait(waitForFlag.value(options));
if (!wallet.isConsistent()) {
System.err.println(""String_Node_Str"");
return;
}
saveWallet(walletFile);
}
 else {
shutdown();
}
}","public static void main(String[] args) throws Exception {
  OptionParser parser=new OptionParser();
  parser.accepts(""String_Node_Str"");
  parser.accepts(""String_Node_Str"");
  parser.accepts(""String_Node_Str"");
  walletFileName=parser.accepts(""String_Node_Str"").withRequiredArg().defaultsTo(""String_Node_Str"");
  actionFlag=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(ActionEnum.class);
  netFlag=parser.accepts(""String_Node_Str"").withOptionalArg().ofType(NetworkEnum.class).defaultsTo(NetworkEnum.PROD);
  dateFlag=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(Date.class).withValuesConvertedBy(DateConverter.datePattern(""String_Node_Str""));
  waitForFlag=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(WaitForEnum.class);
  OptionSpec<String> chainFlag=parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  OptionSpec<String> outputFlag=parser.accepts(""String_Node_Str"").withRequiredArg();
  parser.accepts(""String_Node_Str"").withRequiredArg();
  conditionFlag=parser.accepts(""String_Node_Str"").withRequiredArg();
  options=parser.parse(args);
  if (args.length == 0 || options.has(""String_Node_Str"") || options.nonOptionArguments().size() > 0) {
    System.out.println(HELP_TEXT);
    return;
  }
  if (options.has(""String_Node_Str"")) {
    BriefLogFormatter.init();
    log.info(""String_Node_Str"");
  }
 else {
    logger=LogManager.getLogManager().getLogger(""String_Node_Str"");
    logger.setLevel(Level.SEVERE);
  }
switch (netFlag.value(options)) {
case PROD:
    params=NetworkParameters.prodNet();
  chainFileName=new File(""String_Node_Str"");
discovery=new DnsDiscovery(params);
break;
case TEST:
params=NetworkParameters.testNet();
chainFileName=new File(""String_Node_Str"");
discovery=new IrcDiscovery(""String_Node_Str"");
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
if (options.has(chainFlag)) {
chainFileName=new File(chainFlag.value(options));
}
if (options.has(""String_Node_Str"")) {
condition=new Condition(conditionFlag.value(options));
}
ActionEnum action=ActionEnum.NONE;
if (options.has(actionFlag)) action=actionFlag.value(options);
walletFile=new File(walletFileName.value(options));
if (action == ActionEnum.CREATE) {
createWallet(options,params,walletFile);
return;
}
if (!walletFile.exists()) {
System.err.println(""String_Node_Str"" + walletFile + ""String_Node_Str"");
return;
}
if (action == ActionEnum.RAW_DUMP) {
FileInputStream stream=new FileInputStream(walletFile);
try {
Protos.Wallet proto=WalletProtobufSerializer.parseToProto(stream);
System.out.println(proto.toString());
return;
}
  finally {
stream.close();
}
}
try {
wallet=Wallet.loadFromFile(walletFile);
if (!wallet.getParams().equals(params)) {
System.err.println(""String_Node_Str"" + wallet.getParams().getId() + ""String_Node_Str""+ params.getId());
return;
}
}
 catch (Exception e) {
System.err.println(""String_Node_Str"" + walletFile + ""String_Node_Str""+ e.getMessage());
e.printStackTrace();
return;
}
switch (action) {
case DUMP:
dumpWallet();
break;
case ADD_KEY:
addKey();
break;
case DELETE_KEY:
deleteKey();
break;
case RESET:
reset();
break;
case SYNC:
syncChain();
break;
case SEND:
if (!options.has(outputFlag)) {
System.err.println(""String_Node_Str"");
return;
}
send(outputFlag.values(options));
break;
}
if (!wallet.isConsistent()) {
System.err.println(""String_Node_Str"");
return;
}
saveWallet(walletFile);
if (options.has(waitForFlag)) {
wait(waitForFlag.value(options));
if (!wallet.isConsistent()) {
System.err.println(""String_Node_Str"");
return;
}
saveWallet(walletFile);
}
shutdown();
}",0.9986765484383272
85929,"private static void shutdown(){
  try {
    if (peers == null)     return;
    peers.stop();
    saveWallet(walletFile);
    store.close();
  }
 catch (  BlockStoreException e) {
    throw new RuntimeException(e);
  }
}","private static void shutdown(){
  try {
    if (peers == null)     return;
    peers.stop();
    saveWallet(walletFile);
    store.close();
    wallet=null;
  }
 catch (  BlockStoreException e) {
    throw new RuntimeException(e);
  }
}",0.9626373626373628
85930,"private void readConfidence(Transaction tx,Protos.TransactionConfidence confidenceProto,TransactionConfidence confidence){
  if (!confidenceProto.hasType()) {
    log.warn(""String_Node_Str"",tx.getHashAsString());
    return;
  }
  ConfidenceType confidenceType=TransactionConfidence.ConfidenceType.valueOf(confidenceProto.getType().getNumber());
  confidence.setConfidenceType(confidenceType);
  if (confidenceProto.hasAppearedAtHeight()) {
    if (confidence.getConfidenceType() != ConfidenceType.BUILDING) {
      log.warn(""String_Node_Str"",tx.getHashAsString());
      return;
    }
    confidence.setAppearedAtChainHeight(confidenceProto.getAppearedAtHeight());
  }
  if (confidenceProto.hasDepth()) {
    if (confidence.getConfidenceType() != ConfidenceType.BUILDING) {
      log.warn(""String_Node_Str"",tx.getHashAsString());
      return;
    }
    confidence.setDepthInBlocks(confidenceProto.getDepth());
  }
 else {
    if (chainHeight != 0) {
      confidence.setDepthInBlocks(chainHeight - confidence.getAppearedAtChainHeight());
    }
  }
  if (confidenceProto.hasWorkDone()) {
    if (confidence.getConfidenceType() != ConfidenceType.BUILDING) {
      log.warn(""String_Node_Str"",tx.getHashAsString());
      return;
    }
    confidence.setWorkDone(BigInteger.valueOf(confidenceProto.getWorkDone()));
  }
  if (confidenceProto.hasOverridingTransaction()) {
    if (confidence.getConfidenceType() != ConfidenceType.DEAD) {
      log.warn(""String_Node_Str"",tx.getHashAsString());
      return;
    }
    Transaction overridingTransaction=txMap.get(confidenceProto.getOverridingTransaction());
    if (overridingTransaction == null) {
      log.warn(""String_Node_Str"",tx.getHashAsString());
      return;
    }
    confidence.setOverridingTransaction(overridingTransaction);
  }
  for (  Protos.PeerAddress proto : confidenceProto.getBroadcastByList()) {
    InetAddress ip;
    try {
      ip=InetAddress.getByAddress(proto.getIpAddress().toByteArray());
    }
 catch (    UnknownHostException e) {
      throw new RuntimeException(e);
    }
    int port=proto.getPort();
    PeerAddress address=new PeerAddress(ip,port);
    address.setServices(BigInteger.valueOf(proto.getServices()));
    confidence.markBroadcastBy(address);
  }
}","private void readConfidence(Transaction tx,Protos.TransactionConfidence confidenceProto,TransactionConfidence confidence){
  if (!confidenceProto.hasType()) {
    log.warn(""String_Node_Str"",tx.getHashAsString());
    return;
  }
  ConfidenceType confidenceType=TransactionConfidence.ConfidenceType.valueOf(confidenceProto.getType().getNumber());
  confidence.setConfidenceType(confidenceType);
  if (confidenceProto.hasAppearedAtHeight()) {
    if (confidence.getConfidenceType() != ConfidenceType.BUILDING) {
      log.warn(""String_Node_Str"",tx.getHashAsString());
      return;
    }
    confidence.setAppearedAtChainHeight(confidenceProto.getAppearedAtHeight());
  }
  if (confidenceProto.hasDepth()) {
    if (confidence.getConfidenceType() != ConfidenceType.BUILDING) {
      log.warn(""String_Node_Str"",tx.getHashAsString());
      return;
    }
    confidence.setDepthInBlocks(confidenceProto.getDepth());
  }
 else {
    if (chainHeight != 0) {
      confidence.setDepthInBlocks(chainHeight - confidence.getAppearedAtChainHeight() + 1);
    }
  }
  if (confidenceProto.hasWorkDone()) {
    if (confidence.getConfidenceType() != ConfidenceType.BUILDING) {
      log.warn(""String_Node_Str"",tx.getHashAsString());
      return;
    }
    confidence.setWorkDone(BigInteger.valueOf(confidenceProto.getWorkDone()));
  }
  if (confidenceProto.hasOverridingTransaction()) {
    if (confidence.getConfidenceType() != ConfidenceType.DEAD) {
      log.warn(""String_Node_Str"",tx.getHashAsString());
      return;
    }
    Transaction overridingTransaction=txMap.get(confidenceProto.getOverridingTransaction());
    if (overridingTransaction == null) {
      log.warn(""String_Node_Str"",tx.getHashAsString());
      return;
    }
    confidence.setOverridingTransaction(overridingTransaction);
  }
  for (  Protos.PeerAddress proto : confidenceProto.getBroadcastByList()) {
    InetAddress ip;
    try {
      ip=InetAddress.getByAddress(proto.getIpAddress().toByteArray());
    }
 catch (    UnknownHostException e) {
      throw new RuntimeException(e);
    }
    int port=proto.getPort();
    PeerAddress address=new PeerAddress(ip,port);
    address.setServices(BigInteger.valueOf(proto.getServices()));
    confidence.markBroadcastBy(address);
  }
}",0.9991095280498664
85931,"/** 
 * Calculates a signature hash, that is, a hash of a simplified form of the transaction. How exactly the transaction is simplified is specified by the type and anyoneCanPay parameters.<p> You don't normally ever need to call this yourself. It will become more useful in future as the contracts features of Bitcoin are developed.
 * @param inputIndex input the signature is being calculated for. Tx signatures are always relative to an input.
 * @param connectedScript the bytes that should be in the given input during signing.
 * @param type Should be SigHash.ALL
 * @param anyoneCanPay should be false.
 */
public synchronized Sha256Hash hashTransactionForSignature(int inputIndex,byte[] connectedScript,SigHash type,boolean anyoneCanPay){
  try {
    byte[][] scripts=new byte[inputs.size()][];
    for (int i=0; i < inputs.size(); i++) {
      scripts[i]=inputs.get(i).getScriptBytes();
      inputs.get(i).setScriptBytes(TransactionInput.EMPTY_ARRAY);
    }
    TransactionInput input=inputs.get(inputIndex);
    input.setScriptBytes(connectedScript);
    ByteArrayOutputStream bos=new UnsafeByteArrayOutputStream(length == UNKNOWN_LENGTH ? 256 : length + 4);
    bitcoinSerialize(bos);
    int hashType=type.ordinal() + 1;
    if (anyoneCanPay)     hashType|=0x80;
    uint32ToByteStreamLE(hashType,bos);
    Sha256Hash hash=new Sha256Hash(doubleDigest(bos.toByteArray()));
    for (int i=0; i < inputs.size(); i++) {
      inputs.get(i).setScriptBytes(scripts[i]);
    }
    return hash;
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","/** 
 * Calculates a signature hash, that is, a hash of a simplified form of the transaction. How exactly the transaction is simplified is specified by the type and anyoneCanPay parameters.<p> You don't normally ever need to call this yourself. It will become more useful in future as the contracts features of Bitcoin are developed.
 * @param inputIndex input the signature is being calculated for. Tx signatures are always relative to an input.
 * @param connectedScript the bytes that should be in the given input during signing.
 * @param type Should be SigHash.ALL
 * @param anyoneCanPay should be false.
 */
public synchronized Sha256Hash hashTransactionForSignature(int inputIndex,byte[] connectedScript,SigHash type,boolean anyoneCanPay){
  try {
    byte[][] scripts=new byte[inputs.size()][];
    for (int i=0; i < inputs.size(); i++) {
      scripts[i]=inputs.get(i).getScriptBytes();
      inputs.get(i).setScriptBytes(TransactionInput.EMPTY_ARRAY);
    }
    TransactionInput input=inputs.get(inputIndex);
    input.setScriptBytes(connectedScript);
    ByteArrayOutputStream bos=new UnsafeByteArrayOutputStream(length == UNKNOWN_LENGTH ? 256 : length + 4);
    bitcoinSerialize(bos);
    int hashType=type.ordinal() + 1;
    if (anyoneCanPay)     hashType|=0x80;
    uint32ToByteStreamLE(hashType,bos);
    Sha256Hash hash=new Sha256Hash(doubleDigest(bos.toByteArray()));
    bos.close();
    for (int i=0; i < inputs.size(); i++) {
      inputs.get(i).setScriptBytes(scripts[i]);
    }
    return hash;
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}",0.9946185501741056
85932,"/** 
 * Once a transaction has some inputs and outputs added, the signatures in the inputs can be calculated. The signature is over the transaction itself, to prove the redeemer actually created that transaction, so we have to do this step last.<p> <p/> This method is similar to SignatureHash in script.cpp
 * @param hashType This should always be set to SigHash.ALL currently. Other types are unused.
 * @param wallet   A wallet is required to fetch the keys needed for signing.
 */
public synchronized void signInputs(SigHash hashType,Wallet wallet) throws ScriptException {
  Preconditions.checkState(inputs.size() > 0);
  Preconditions.checkState(outputs.size() > 0);
  Preconditions.checkArgument(hashType == SigHash.ALL,""String_Node_Str"");
  byte[][] signatures=new byte[inputs.size()][];
  ECKey[] signingKeys=new ECKey[inputs.size()];
  for (int i=0; i < inputs.size(); i++) {
    TransactionInput input=inputs.get(i);
    Preconditions.checkState(input.getScriptBytes().length == 0,""String_Node_Str"");
    ECKey key=input.getOutpoint().getConnectedKey(wallet);
    Preconditions.checkNotNull(key,""String_Node_Str"",input.getOutpoint().getHash());
    signingKeys[i]=key;
    boolean anyoneCanPay=false;
    byte[] connectedPubKeyScript=input.getOutpoint().getConnectedPubKeyScript();
    Sha256Hash hash=hashTransactionForSignature(i,connectedPubKeyScript,hashType,anyoneCanPay);
    try {
      ByteArrayOutputStream bos=new UnsafeByteArrayOutputStream(73);
      bos.write(key.sign(hash.getBytes()));
      bos.write((hashType.ordinal() + 1) | (anyoneCanPay ? 0x80 : 0));
      signatures[i]=bos.toByteArray();
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
  }
  for (int i=0; i < inputs.size(); i++) {
    TransactionInput input=inputs.get(i);
    Preconditions.checkState(input.getScriptBytes().length == 0);
    ECKey key=signingKeys[i];
    Script scriptPubKey=input.getOutpoint().getConnectedOutput().getScriptPubKey();
    if (scriptPubKey.isSentToAddress()) {
      input.setScriptBytes(Script.createInputScript(signatures[i],key.getPubKey()));
    }
 else     if (scriptPubKey.isSentToRawPubKey()) {
      input.setScriptBytes(Script.createInputScript(signatures[i]));
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + scriptPubKey);
    }
  }
}","/** 
 * Once a transaction has some inputs and outputs added, the signatures in the inputs can be calculated. The signature is over the transaction itself, to prove the redeemer actually created that transaction, so we have to do this step last.<p> <p/> This method is similar to SignatureHash in script.cpp
 * @param hashType This should always be set to SigHash.ALL currently. Other types are unused.
 * @param wallet   A wallet is required to fetch the keys needed for signing.
 */
public synchronized void signInputs(SigHash hashType,Wallet wallet) throws ScriptException {
  Preconditions.checkState(inputs.size() > 0);
  Preconditions.checkState(outputs.size() > 0);
  Preconditions.checkArgument(hashType == SigHash.ALL,""String_Node_Str"");
  byte[][] signatures=new byte[inputs.size()][];
  ECKey[] signingKeys=new ECKey[inputs.size()];
  for (int i=0; i < inputs.size(); i++) {
    TransactionInput input=inputs.get(i);
    Preconditions.checkState(input.getScriptBytes().length == 0,""String_Node_Str"");
    ECKey key=input.getOutpoint().getConnectedKey(wallet);
    Preconditions.checkNotNull(key,""String_Node_Str"",input.getOutpoint().getHash());
    signingKeys[i]=key;
    boolean anyoneCanPay=false;
    byte[] connectedPubKeyScript=input.getOutpoint().getConnectedPubKeyScript();
    Sha256Hash hash=hashTransactionForSignature(i,connectedPubKeyScript,hashType,anyoneCanPay);
    try {
      ByteArrayOutputStream bos=new UnsafeByteArrayOutputStream(73);
      bos.write(key.sign(hash.getBytes()));
      bos.write((hashType.ordinal() + 1) | (anyoneCanPay ? 0x80 : 0));
      signatures[i]=bos.toByteArray();
      bos.close();
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
  }
  for (int i=0; i < inputs.size(); i++) {
    TransactionInput input=inputs.get(i);
    Preconditions.checkState(input.getScriptBytes().length == 0);
    ECKey key=signingKeys[i];
    Script scriptPubKey=input.getOutpoint().getConnectedOutput().getScriptPubKey();
    if (scriptPubKey.isSentToAddress()) {
      input.setScriptBytes(Script.createInputScript(signatures[i],key.getPubKey()));
    }
 else     if (scriptPubKey.isSentToRawPubKey()) {
      input.setScriptBytes(Script.createInputScript(signatures[i]));
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + scriptPubKey);
    }
  }
}",0.9959095801937567
85933,"public void run(){
  log.info(""String_Node_Str"");
  while (true) {
    try {
      Thread.sleep(delayMs);
    }
 catch (    InterruptedException e) {
    }
    Wallet wallet=walletRef.get();
    if (wallet == null)     break;
synchronized (wallet) {
      if (wallet.dirty) {
        if (wallet.autoSave())         break;
      }
    }
  }
}","public void run(){
  log.info(""String_Node_Str"");
  while (true) {
    try {
      WalletSaveRequest req=walletRefs.poll(5,TimeUnit.SECONDS);
      if (req == null && walletRefs.size() == 0) {
        break;
      }
synchronized (req.wallet) {
        if (req.wallet.dirty) {
          if (req.wallet.autoSave()) {
            break;
          }
        }
      }
    }
 catch (    InterruptedException e) {
      break;
    }
  }
  log.info(""String_Node_Str"");
synchronized (AutosaveThread.class) {
    Preconditions.checkState(globalThread == this);
    globalThread=null;
  }
}",0.2975027144408252
85934,"private synchronized void queueAutoSave(){
  if (this.autosaveToFile == null)   return;
  if (autosaveThread == null) {
    try {
      saveToFile(autosaveToFile);
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
  }
 else {
    dirty=true;
  }
}","private synchronized void queueAutoSave(){
  if (this.autosaveToFile == null)   return;
  if (autosaveDelayMs == 0) {
    try {
      saveToFile(autosaveToFile);
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
  }
 else {
    if (!dirty) {
      dirty=true;
      AutosaveThread.registerForSave(this,autosaveDelayMs);
    }
  }
}",0.7697160883280757
85935,"/** 
 * <p>Sets up the wallet to auto-save itself to the given file, using temp files with atomic renames to ensure consistency. After connecting to a file, you no longer need to save the wallet manually, it will do it whenever necessary. Protocol buffer serialization will be used.</p> <p>If delayTime is set, a background thread will be created and the wallet will only be saved to disk every so many time units. If no changes have occurred for the given time period, nothing will be written. In this way disk IO can be rate limited. It's a good idea to set this as otherwise the wallet can change very frequently, eg if there are a lot of transactions in it or a busy key, and there will be a lot of redundant writes. Note that when a new key is added, that always results in an immediate save regardless of delayTime.</p> <p>An event listener can be provided. If a delay >0 was specified, it will be called on a background thread with the wallet locked when an auto-save occurs. If delay is zero or you do something that always triggers an immediate save, like adding a key, the event listener will be invoked on the calling threads. There is an important detail to get right here. The background thread that performs auto-saving keeps a weak reference to the wallet and shuts itself down if the wallet is garbage collected, so you don't have to think about it. If you provide an event listener however, it'd be very easy to accidentally hold a strong reference from your event listener to the wallet, meaning that the background thread will transitively keep your wallet object alive and un-collectable. So be careful to use a static inner class for this to avoid that problem, unless you don't care about keeping wallets alive indefinitely.</p>
 * @param f The destination file to save to.
 * @param delayTime How many time units to wait until saving the wallet on a background thread.
 * @param timeUnit the unit of measurement for delayTime.
 * @param eventListener callback to be informed when the auto-save thread does things, or null
 * @throws IOException
 */
public synchronized void autosaveToFile(File f,long delayTime,TimeUnit timeUnit,AutosaveEventListener eventListener){
  Preconditions.checkArgument(delayTime >= 0);
  autosaveToFile=Preconditions.checkNotNull(f);
  if (delayTime > 0) {
    autosaveEventListener=eventListener;
    autosaveThread=new AutosaveThread(this,TimeUnit.MILLISECONDS.convert(delayTime,timeUnit));
  }
}","/** 
 * <p>Sets up the wallet to auto-save itself to the given file, using temp files with atomic renames to ensure consistency. After connecting to a file, you no longer need to save the wallet manually, it will do it whenever necessary. Protocol buffer serialization will be used.</p> <p>If delayTime is set, a background thread will be created and the wallet will only be saved to disk every so many time units. If no changes have occurred for the given time period, nothing will be written. In this way disk IO can be rate limited. It's a good idea to set this as otherwise the wallet can change very frequently, eg if there are a lot of transactions in it or a busy key, and there will be a lot of redundant writes. Note that when a new key is added, that always results in an immediate save regardless of delayTime.</p> <p>An event listener can be provided. If a delay >0 was specified, it will be called on a background thread with the wallet locked when an auto-save occurs. If delay is zero or you do something that always triggers an immediate save, like adding a key, the event listener will be invoked on the calling threads. There is an important detail to get right here. The background thread that performs auto-saving keeps a weak reference to the wallet and shuts itself down if the wallet is garbage collected, so you don't have to think about it. If you provide an event listener however, it'd be very easy to accidentally hold a strong reference from your event listener to the wallet, meaning that the background thread will transitively keep your wallet object alive and un-collectable. So be careful to use a static inner class for this to avoid that problem, unless you don't care about keeping wallets alive indefinitely.</p>
 * @param f The destination file to save to.
 * @param delayTime How many time units to wait until saving the wallet on a background thread.
 * @param timeUnit the unit of measurement for delayTime.
 * @param eventListener callback to be informed when the auto-save thread does things, or null
 * @throws IOException
 */
public synchronized void autosaveToFile(File f,long delayTime,TimeUnit timeUnit,AutosaveEventListener eventListener){
  Preconditions.checkArgument(delayTime >= 0);
  autosaveToFile=Preconditions.checkNotNull(f);
  if (delayTime > 0) {
    autosaveEventListener=eventListener;
    autosaveDelayMs=TimeUnit.MILLISECONDS.convert(delayTime,timeUnit);
  }
}",0.9922035289290112
85936,"public AutosaveThread(Wallet wallet,long delayMs){
  this.walletRef=new WeakReference<Wallet>(wallet);
  this.delayMs=delayMs;
  setDaemon(true);
  start();
}","private AutosaveThread(){
  this.walletRefs=new DelayQueue<WalletSaveRequest>();
  setDaemon(true);
  setName(""String_Node_Str"");
  setPriority(Thread.MIN_PRIORITY);
}",0.5476923076923077
85937,"/** 
 * To run a script, first we parse it which breaks it up into chunks representing pushes of data or logical opcodes. Then we can run the parsed chunks. <p/> The reason for this split, instead of just interpreting directly, is to make it easier to reach into a programs structure and pull out bits of data without having to run it. This is necessary to render the to/from addresses of transactions in a user interface. The official client does something similar.
 */
private void parse(byte[] programBytes,int offset,int length) throws ScriptException {
  program=new byte[length];
  System.arraycopy(programBytes,offset,program,0,length);
  offset=0;
  chunks=new ArrayList<ScriptChunk>(10);
  cursor=offset;
  while (cursor < offset + length) {
    int opcode=readByte();
    if (opcode > 0 && opcode < OP_PUSHDATA1) {
      chunks.add(new ScriptChunk(false,getData(opcode)));
    }
 else     if (opcode == OP_PUSHDATA1) {
      int len=readByte();
      chunks.add(new ScriptChunk(false,getData(len)));
    }
 else     if (opcode == OP_PUSHDATA2) {
      int len=readByte() | (readByte() << 8);
      chunks.add(new ScriptChunk(false,getData(len)));
    }
 else     if (opcode == OP_PUSHDATA4) {
      log.error(""String_Node_Str"");
    }
 else {
      chunks.add(new ScriptChunk(true,new byte[]{(byte)opcode}));
    }
  }
}","/** 
 * To run a script, first we parse it which breaks it up into chunks representing pushes of data or logical opcodes. Then we can run the parsed chunks. <p/> The reason for this split, instead of just interpreting directly, is to make it easier to reach into a programs structure and pull out bits of data without having to run it. This is necessary to render the to/from addresses of transactions in a user interface. The official client does something similar.
 */
private void parse(byte[] programBytes,int offset,int length) throws ScriptException {
  program=new byte[length];
  System.arraycopy(programBytes,offset,program,0,length);
  offset=0;
  chunks=new ArrayList<ScriptChunk>(10);
  cursor=offset;
  while (cursor < offset + length) {
    int opcode=readByte();
    if (opcode >= 0 && opcode < OP_PUSHDATA1) {
      chunks.add(new ScriptChunk(false,getData(opcode)));
    }
 else     if (opcode == OP_PUSHDATA1) {
      int len=readByte();
      chunks.add(new ScriptChunk(false,getData(len)));
    }
 else     if (opcode == OP_PUSHDATA2) {
      int len=readByte() | (readByte() << 8);
      chunks.add(new ScriptChunk(false,getData(len)));
    }
 else     if (opcode == OP_PUSHDATA4) {
      log.error(""String_Node_Str"");
    }
 else {
      chunks.add(new ScriptChunk(true,new byte[]{(byte)opcode}));
    }
  }
}",0.9996242014280344
85938,"public static <E>void invoke(List<E> listeners,EventListenerInvoker<E> invoker){
  if (listeners == null)   return;
synchronized (listeners) {
    for (int i=0; i < listeners.size(); i++) {
      E l=listeners.get(i);
synchronized (l) {
        invoker.invoke(l);
      }
      if (listeners.get(i) != l) {
        i--;
      }
    }
  }
}","public static <E>void invoke(List<E> listeners,EventListenerInvoker<E> invoker){
  if (listeners == null)   return;
synchronized (listeners) {
    for (int i=0; i < listeners.size(); i++) {
      E l=listeners.get(i);
synchronized (l) {
        invoker.invoke(l);
      }
      if (i == listeners.size()) {
        break;
      }
 else       if (listeners.get(i) != l) {
        i--;
      }
    }
  }
}",0.9137466307277629
85939,"/** 
 * Uses protobuf serialization to save the wallet to the given file. To learn more about this file format, see  {@link WalletProtobufSerializer}. Writes out first to a temporary file in the same directory and then renames once written.
 */
public synchronized void saveToFile(File f) throws IOException {
  FileOutputStream stream=null;
  File temp;
  try {
    File directory=f.getAbsoluteFile().getParentFile();
    temp=File.createTempFile(""String_Node_Str"",null,directory);
    stream=new FileOutputStream(temp);
    saveToFileStream(stream);
    stream.flush();
    stream.getFD().sync();
    if (!temp.renameTo(f)) {
      if (System.getProperty(""String_Node_Str"").toLowerCase().indexOf(""String_Node_Str"") >= 0) {
        if (f.delete() && temp.renameTo(f))         return;
      }
      throw new IOException(""String_Node_Str"" + temp + ""String_Node_Str""+ f);
    }
  }
  finally {
    if (stream != null) {
      stream.close();
    }
  }
}","/** 
 * Uses protobuf serialization to save the wallet to the given file. To learn more about this file format, see  {@link WalletProtobufSerializer}. Writes out first to a temporary file in the same directory and then renames once written.
 */
public synchronized void saveToFile(File f) throws IOException {
  FileOutputStream stream=null;
  File temp;
  try {
    File directory=f.getAbsoluteFile().getParentFile();
    temp=File.createTempFile(""String_Node_Str"",null,directory);
    stream=new FileOutputStream(temp);
    saveToFileStream(stream);
    stream.flush();
    stream.getFD().sync();
    stream.close();
    stream=null;
    if (!temp.renameTo(f)) {
      if (System.getProperty(""String_Node_Str"").toLowerCase().indexOf(""String_Node_Str"") >= 0) {
        if (f.delete() && temp.renameTo(f))         return;
      }
      throw new IOException(""String_Node_Str"" + temp + ""String_Node_Str""+ f);
    }
  }
  finally {
    if (stream != null) {
      stream.close();
    }
  }
}",0.9809376609994848
85940,"/** 
 * Adds a transaction to this block. 
 */
void addTransaction(Transaction t){
  unCacheTransactions();
  if (transactions == null) {
    transactions=new ArrayList<Transaction>();
  }
  t.setParent(this);
  transactions.add(t);
  adjustLength(t.length);
  merkleRoot=null;
  hash=null;
}","/** 
 * Adds a transaction to this block. The nonce and merkle root are invalid after this. 
 */
public void addTransaction(Transaction t){
  unCacheTransactions();
  if (transactions == null) {
    transactions=new ArrayList<Transaction>();
  }
  t.setParent(this);
  if (transactions.size() == 0 && !t.isCoinBase())   throw new RuntimeException(""String_Node_Str"" + t);
 else   if (transactions.size() > 0 && t.isCoinBase())   throw new RuntimeException(""String_Node_Str"" + t);
  transactions.add(t);
  adjustLength(t.length);
  merkleRoot=null;
  hash=null;
}",0.6846424384525205
85941,"private synchronized void receive(Transaction tx,StoredBlock block,BlockChain.NewBlockType blockType,boolean reorg) throws VerificationException, ScriptException {
  BigInteger prevBalance=getBalance();
  Sha256Hash txHash=tx.getHash();
  boolean bestChain=blockType == BlockChain.NewBlockType.BEST_CHAIN;
  boolean sideChain=blockType == BlockChain.NewBlockType.SIDE_CHAIN;
  BigInteger valueSentFromMe=tx.getValueSentFromMe(this);
  BigInteger valueSentToMe=tx.getValueSentToMe(this);
  BigInteger valueDifference=valueSentToMe.subtract(valueSentFromMe);
  if (!reorg) {
    log.info(""String_Node_Str"",new Object[]{sideChain ? ""String_Node_Str"" : ""String_Node_Str"",bitcoinValueToFriendlyString(valueDifference),tx.getHashAsString()});
  }
  Transaction wtx;
  if ((wtx=pending.remove(txHash)) != null) {
    tx=wtx;
    log.info(""String_Node_Str"");
    if (bestChain) {
      if (valueSentToMe.equals(BigInteger.ZERO)) {
        log.info(""String_Node_Str"");
        boolean alreadyPresent=spent.put(tx.getHash(),tx) != null;
        checkState(!alreadyPresent,""String_Node_Str"");
      }
 else {
        log.info(""String_Node_Str"");
        boolean alreadyPresent=unspent.put(tx.getHash(),tx) != null;
        checkState(!alreadyPresent,""String_Node_Str"");
      }
    }
 else     if (sideChain) {
      log.info(""String_Node_Str"");
      boolean alreadyPresent=inactive.put(tx.getHash(),tx) != null;
      if (alreadyPresent)       log.info(""String_Node_Str"");
      pending.put(tx.getHash(),tx);
    }
  }
 else {
    if (sideChain) {
      log.info(""String_Node_Str"");
      inactive.put(tx.getHash(),tx);
    }
 else     if (bestChain) {
      processTxFromBestChain(tx);
    }
  }
  log.info(""String_Node_Str"" + bitcoinValueToFriendlyString(getBalance()));
  if (block != null) {
    tx.setBlockAppearance(block,bestChain);
  }
  boolean wasPending=wtx != null;
  if (!reorg && bestChain && !wasPending) {
    BigInteger newBalance=getBalance();
    int diff=valueDifference.compareTo(BigInteger.ZERO);
    if (diff > 0) {
      invokeOnCoinsReceived(tx,prevBalance,newBalance);
    }
 else     if (diff == 0) {
      invokeOnCoinsSent(tx,prevBalance,newBalance);
    }
 else {
      invokeOnCoinsSent(tx,prevBalance,newBalance);
    }
  }
  checkState(isConsistent());
}","private synchronized void receive(Transaction tx,StoredBlock block,BlockChain.NewBlockType blockType,boolean reorg) throws VerificationException, ScriptException {
  BigInteger prevBalance=getBalance();
  Sha256Hash txHash=tx.getHash();
  boolean bestChain=blockType == BlockChain.NewBlockType.BEST_CHAIN;
  boolean sideChain=blockType == BlockChain.NewBlockType.SIDE_CHAIN;
  BigInteger valueSentFromMe=tx.getValueSentFromMe(this);
  BigInteger valueSentToMe=tx.getValueSentToMe(this);
  BigInteger valueDifference=valueSentToMe.subtract(valueSentFromMe);
  if (!reorg) {
    log.info(""String_Node_Str"",new Object[]{sideChain ? ""String_Node_Str"" : ""String_Node_Str"",bitcoinValueToFriendlyString(valueDifference),tx.getHashAsString()});
  }
  Transaction wtx;
  if ((wtx=pending.remove(txHash)) != null) {
    tx=wtx;
    log.info(""String_Node_Str"");
    if (bestChain) {
      if (valueSentToMe.equals(BigInteger.ZERO)) {
        log.info(""String_Node_Str"");
        boolean alreadyPresent=spent.put(tx.getHash(),tx) != null;
        checkState(!alreadyPresent,""String_Node_Str"");
      }
 else {
        log.info(""String_Node_Str"");
        boolean alreadyPresent=unspent.put(tx.getHash(),tx) != null;
        checkState(!alreadyPresent,""String_Node_Str"");
      }
    }
 else     if (sideChain) {
      log.info(""String_Node_Str"");
      boolean alreadyPresent=inactive.put(tx.getHash(),tx) != null;
      if (alreadyPresent)       log.info(""String_Node_Str"");
      pending.put(tx.getHash(),tx);
    }
  }
 else {
    if (sideChain) {
      if (unspent.containsKey(tx.getHash()) || spent.containsKey(tx.getHash())) {
      }
 else {
        log.info(""String_Node_Str"");
        inactive.put(tx.getHash(),tx);
      }
    }
 else     if (bestChain) {
      processTxFromBestChain(tx);
    }
  }
  log.info(""String_Node_Str"" + bitcoinValueToFriendlyString(getBalance()));
  if (block != null) {
    tx.setBlockAppearance(block,bestChain);
  }
  boolean wasPending=wtx != null;
  if (!reorg && bestChain && !wasPending) {
    BigInteger newBalance=getBalance();
    int diff=valueDifference.compareTo(BigInteger.ZERO);
    if (diff > 0) {
      invokeOnCoinsReceived(tx,prevBalance,newBalance);
    }
 else     if (diff == 0) {
      invokeOnCoinsSent(tx,prevBalance,newBalance);
    }
 else {
      invokeOnCoinsSent(tx,prevBalance,newBalance);
    }
  }
  checkState(isConsistent());
}",0.9764252036005144
85942,"@Test public void isConsistent_duplicates() throws Exception {
  Transaction tx=createFakeTx(params,Utils.toNanoCoins(1,0),myAddress);
  Address someOtherGuy=new ECKey().toAddress(params);
  TransactionOutput output=new TransactionOutput(params,tx,Utils.toNanoCoins(0,5),someOtherGuy);
  tx.addOutput(output);
  wallet.receiveFromBlock(tx,null,BlockChain.NewBlockType.BEST_CHAIN);
  assertTrue(wallet.isConsistent());
  Transaction txClone=new Transaction(params,tx.bitcoinSerialize());
  try {
    wallet.receiveFromBlock(txClone,null,BlockChain.NewBlockType.SIDE_CHAIN);
    fail();
  }
 catch (  IllegalStateException ex) {
  }
}","@Test public void isConsistent_duplicates() throws Exception {
  Transaction tx=createFakeTx(params,Utils.toNanoCoins(1,0),myAddress);
  Address someOtherGuy=new ECKey().toAddress(params);
  TransactionOutput output=new TransactionOutput(params,tx,Utils.toNanoCoins(0,5),someOtherGuy);
  tx.addOutput(output);
  wallet.receiveFromBlock(tx,null,BlockChain.NewBlockType.BEST_CHAIN);
  assertTrue(wallet.isConsistent());
  Transaction txClone=new Transaction(params,tx.bitcoinSerialize());
  try {
    wallet.receiveFromBlock(txClone,null,BlockChain.NewBlockType.BEST_CHAIN);
    fail();
  }
 catch (  IllegalStateException ex) {
  }
}",0.995253164556962
85943,"/** 
 * Connect to a peer by creating a Netty channel to the destination address.
 * @param address destination IP and port
 * @return a ChannelFuture that can be used to wait for the socket to connect.  A socketconnection does not mean that protocol handshake has occured.
 */
public ChannelFuture connectTo(SocketAddress address){
  ChannelFuture future=bootstrap.connect(address);
  TCPNetworkConnection connection=(TCPNetworkConnection)future.getChannel().getPipeline().get(""String_Node_Str"");
  if (connection != null)   connection.setRemoteAddress(address);
  Peer peer=peerFromChannelFuture(future);
  channelFutures.put(peer,future);
  return future;
}","/** 
 * Connect to a peer by creating a Netty channel to the destination address.
 * @param address destination IP and port
 * @return a ChannelFuture that can be used to wait for the socket to connect.  A socketconnection does not mean that protocol handshake has occured.
 */
public ChannelFuture connectTo(SocketAddress address){
  ChannelFuture future=bootstrap.connect(address);
  TCPNetworkConnection.NetworkHandler networkHandler=(TCPNetworkConnection.NetworkHandler)future.getChannel().getPipeline().get(""String_Node_Str"");
  if (networkHandler != null) {
    networkHandler.getOwnerObject().setRemoteAddress(address);
  }
  Peer peer=peerFromChannelFuture(future);
  channelFutures.put(peer,future);
  return future;
}",0.9041095890410958
85944,"/** 
 * If the transactions outputs are all marked as spent, and it's in the unspent map, move it.
 */
private void maybeMoveTxToSpent(Transaction tx,String context){
  if (tx.isEveryOwnedOutputSpent(this)) {
    if (unspent.remove(tx.getHash()) != null) {
      if (log.isInfoEnabled()) {
        log.info(""String_Node_Str"" + context + ""String_Node_Str"");
        log.info(""String_Node_Str"" + context + ""String_Node_Str"");
      }
      spent.put(tx.getHash(),tx);
    }
  }
}","/** 
 * If the transactions outputs are all marked as spent, and it's in the unspent map, move it.
 */
private void maybeMoveTxToSpent(Transaction tx,String context){
  if (tx.isEveryOwnedOutputSpent(this)) {
    if (unspent.remove(tx.getHash()) != null) {
      if (log.isInfoEnabled()) {
        log.info(""String_Node_Str"",tx.getHashAsString(),context);
        log.info(""String_Node_Str"",tx.getHashAsString(),context);
      }
      spent.put(tx.getHash(),tx);
    }
  }
}",0.7794117647058824
85945,"/** 
 * Called by the   {@link BlockChain} when the best chain (representing total work done) has changed. In this case,we need to go through our transactions and find out if any have become invalid. It's possible for our balance to go down in this case: money we thought we had can suddenly vanish if the rest of the network agrees it should be so.<p> The oldBlocks/newBlocks lists are ordered height-wise from top first to bottom last.
 */
synchronized void reorganize(List<StoredBlock> oldBlocks,List<StoredBlock> newBlocks) throws VerificationException {
  List<Sha256Hash> oldBlockHashes=new ArrayList<Sha256Hash>(oldBlocks.size());
  List<Sha256Hash> newBlockHashes=new ArrayList<Sha256Hash>(newBlocks.size());
  log.info(""String_Node_Str"");
  for (  StoredBlock b : oldBlocks) {
    log.info(""String_Node_Str"",b.getHeader().getHashAsString());
    oldBlockHashes.add(b.getHeader().getHash());
  }
  log.info(""String_Node_Str"");
  for (  StoredBlock b : newBlocks) {
    log.info(""String_Node_Str"",b.getHeader().getHashAsString());
    newBlockHashes.add(b.getHeader().getHash());
  }
  Map<Sha256Hash,Transaction> oldChainTransactions=new HashMap<Sha256Hash,Transaction>();
  Map<Sha256Hash,Transaction> onlyOldChainTransactions=new HashMap<Sha256Hash,Transaction>();
  Map<Sha256Hash,Transaction> newChainTransactions=new HashMap<Sha256Hash,Transaction>();
  Map<Sha256Hash,Transaction> commonChainTransactions=new HashMap<Sha256Hash,Transaction>();
  Map<Sha256Hash,Transaction> all=new HashMap<Sha256Hash,Transaction>();
  all.putAll(unspent);
  all.putAll(spent);
  all.putAll(inactive);
  for (  Transaction tx : all.values()) {
    Collection<Sha256Hash> appearsIn=tx.getAppearsInHashes();
    checkNotNull(appearsIn);
    boolean inOldSection=!Collections.disjoint(appearsIn,oldBlockHashes);
    boolean inNewSection=!Collections.disjoint(appearsIn,newBlockHashes);
    boolean inCommonSection=!inNewSection && !inOldSection;
    if (inCommonSection) {
      boolean alreadyPresent=commonChainTransactions.put(tx.getHash(),tx) != null;
      checkState(!alreadyPresent,""String_Node_Str"");
    }
 else {
      if (inOldSection) {
        boolean alreadyPresent=oldChainTransactions.put(tx.getHash(),tx) != null;
        checkState(!alreadyPresent,""String_Node_Str"");
        if (!inNewSection) {
          alreadyPresent=onlyOldChainTransactions.put(tx.getHash(),tx) != null;
          checkState(!alreadyPresent,""String_Node_Str"");
        }
      }
      if (inNewSection) {
        boolean alreadyPresent=newChainTransactions.put(tx.getHash(),tx) != null;
        checkState(!alreadyPresent,""String_Node_Str"");
      }
    }
  }
  boolean affectedUs=!oldChainTransactions.equals(newChainTransactions);
  log.info(affectedUs ? ""String_Node_Str"" : ""String_Node_Str"");
  if (!affectedUs)   return;
  for (  Transaction tx : onlyOldChainTransactions.values())   log.info(""String_Node_Str"",tx.getHashAsString());
  for (  Transaction tx : oldChainTransactions.values())   log.info(""String_Node_Str"",tx.getHashAsString());
  for (  Transaction tx : newChainTransactions.values())   log.info(""String_Node_Str"",tx.getHashAsString());
  for (  Transaction tx : all.values())   tx.disconnectInputs();
  for (  Transaction tx : pending.values())   tx.disconnectInputs();
  for (  Transaction tx : commonChainTransactions.values()) {
    TransactionInput badInput=tx.connectForReorganize(all);
    checkState(badInput == null,""String_Node_Str"",tx.getHashAsString(),badInput == null ? ""String_Node_Str"" : badInput.toString());
  }
  log.info(""String_Node_Str"");
  unspent.clear();
  spent.clear();
  inactive.clear();
  for (  Transaction tx : commonChainTransactions.values()) {
    int unspentOutputs=0;
    for (    TransactionOutput output : tx.getOutputs()) {
      if (output.isAvailableForSpending())       unspentOutputs++;
    }
    if (unspentOutputs > 0) {
      log.info(""String_Node_Str"",tx.getHashAsString());
      unspent.put(tx.getHash(),tx);
    }
 else {
      log.info(""String_Node_Str"",tx.getHashAsString());
      spent.put(tx.getHash(),tx);
    }
  }
  for (  Transaction tx : onlyOldChainTransactions.values()) {
    tx.notifyNotOnBestChain();
  }
  Collections.reverse(newBlocks);
  for (  StoredBlock b : newBlocks) {
    log.info(""String_Node_Str"",b.getHeader().getHashAsString());
    Set<Transaction> txns=new HashSet<Transaction>();
    Sha256Hash blockHash=b.getHeader().getHash();
    for (    Transaction tx : newChainTransactions.values()) {
      if (tx.getAppearsInHashes().contains(blockHash)) {
        txns.add(tx);
        log.info(""String_Node_Str"",tx.getHashAsString());
      }
    }
    for (    Transaction t : txns) {
      try {
        receive(t,b,BlockChain.NewBlockType.BEST_CHAIN,true);
      }
 catch (      ScriptException e) {
        throw new RuntimeException(e);
      }
    }
  }
  Map<Sha256Hash,Transaction> pool=new HashMap<Sha256Hash,Transaction>();
  pool.putAll(unspent);
  pool.putAll(spent);
  pool.putAll(pending);
  Map<Sha256Hash,Transaction> toReprocess=new HashMap<Sha256Hash,Transaction>();
  toReprocess.putAll(onlyOldChainTransactions);
  toReprocess.putAll(pending);
  log.info(""String_Node_Str"");
  for (  Transaction tx : dead.values()) {
    reprocessTxAfterReorg(pool,tx);
  }
  for (  Transaction tx : toReprocess.values()) {
    reprocessTxAfterReorg(pool,tx);
  }
  log.info(""String_Node_Str"",Utils.bitcoinValueToFriendlyString(getBalance()));
  EventListenerInvoker.invoke(eventListeners,new EventListenerInvoker<WalletEventListener>(){
    @Override public void invoke(    WalletEventListener listener){
      listener.onReorganize(Wallet.this);
    }
  }
);
  checkState(isConsistent());
}","/** 
 * Called by the   {@link BlockChain} when the best chain (representing total work done) has changed. In this case,we need to go through our transactions and find out if any have become invalid. It's possible for our balance to go down in this case: money we thought we had can suddenly vanish if the rest of the network agrees it should be so.<p> The oldBlocks/newBlocks lists are ordered height-wise from top first to bottom last.
 */
synchronized void reorganize(List<StoredBlock> oldBlocks,List<StoredBlock> newBlocks) throws VerificationException {
  List<Sha256Hash> oldBlockHashes=new ArrayList<Sha256Hash>(oldBlocks.size());
  List<Sha256Hash> newBlockHashes=new ArrayList<Sha256Hash>(newBlocks.size());
  log.info(""String_Node_Str"");
  for (  StoredBlock b : oldBlocks) {
    log.info(""String_Node_Str"",b.getHeader().getHashAsString());
    oldBlockHashes.add(b.getHeader().getHash());
  }
  log.info(""String_Node_Str"");
  for (  StoredBlock b : newBlocks) {
    log.info(""String_Node_Str"",b.getHeader().getHashAsString());
    newBlockHashes.add(b.getHeader().getHash());
  }
  Map<Sha256Hash,Transaction> oldChainTransactions=new HashMap<Sha256Hash,Transaction>();
  Map<Sha256Hash,Transaction> onlyOldChainTransactions=new HashMap<Sha256Hash,Transaction>();
  Map<Sha256Hash,Transaction> newChainTransactions=new HashMap<Sha256Hash,Transaction>();
  Map<Sha256Hash,Transaction> commonChainTransactions=new HashMap<Sha256Hash,Transaction>();
  Map<Sha256Hash,Transaction> all=new HashMap<Sha256Hash,Transaction>();
  all.putAll(unspent);
  all.putAll(spent);
  all.putAll(inactive);
  for (  Transaction tx : all.values()) {
    Collection<Sha256Hash> appearsIn=tx.getAppearsInHashes();
    checkNotNull(appearsIn);
    boolean inOldSection=!Collections.disjoint(appearsIn,oldBlockHashes);
    boolean inNewSection=!Collections.disjoint(appearsIn,newBlockHashes);
    boolean inCommonSection=!inNewSection && !inOldSection;
    if (inCommonSection) {
      boolean alreadyPresent=commonChainTransactions.put(tx.getHash(),tx) != null;
      checkState(!alreadyPresent,""String_Node_Str"");
    }
 else {
      if (inOldSection) {
        boolean alreadyPresent=oldChainTransactions.put(tx.getHash(),tx) != null;
        checkState(!alreadyPresent,""String_Node_Str"");
        if (!inNewSection) {
          alreadyPresent=onlyOldChainTransactions.put(tx.getHash(),tx) != null;
          checkState(!alreadyPresent,""String_Node_Str"");
        }
      }
      if (inNewSection) {
        boolean alreadyPresent=newChainTransactions.put(tx.getHash(),tx) != null;
        checkState(!alreadyPresent,""String_Node_Str"");
      }
    }
  }
  boolean affectedUs=!oldChainTransactions.equals(newChainTransactions);
  log.info(affectedUs ? ""String_Node_Str"" : ""String_Node_Str"");
  if (!affectedUs)   return;
  for (  Transaction tx : onlyOldChainTransactions.values())   log.info(""String_Node_Str"",tx.getHashAsString());
  for (  Transaction tx : oldChainTransactions.values())   log.info(""String_Node_Str"",tx.getHashAsString());
  for (  Transaction tx : newChainTransactions.values())   log.info(""String_Node_Str"",tx.getHashAsString());
  for (  Transaction tx : all.values())   tx.disconnectInputs();
  for (  Transaction tx : pending.values())   tx.disconnectInputs();
  for (  Transaction tx : commonChainTransactions.values()) {
    TransactionInput badInput=tx.connectForReorganize(all);
    checkState(badInput == null,""String_Node_Str"",tx.getHashAsString(),badInput == null ? ""String_Node_Str"" : badInput.toString());
  }
  log.info(""String_Node_Str"");
  unspent.clear();
  spent.clear();
  inactive.clear();
  for (  Transaction tx : commonChainTransactions.values()) {
    int unspentOutputs=0;
    for (    TransactionOutput output : tx.getOutputs()) {
      if (output.isAvailableForSpending() && output.isMine(this))       unspentOutputs++;
    }
    if (unspentOutputs > 0) {
      log.info(""String_Node_Str"",tx.getHashAsString());
      unspent.put(tx.getHash(),tx);
    }
 else {
      log.info(""String_Node_Str"",tx.getHashAsString());
      spent.put(tx.getHash(),tx);
    }
  }
  for (  Transaction tx : onlyOldChainTransactions.values()) {
    tx.notifyNotOnBestChain();
  }
  Collections.reverse(newBlocks);
  for (  StoredBlock b : newBlocks) {
    log.info(""String_Node_Str"",b.getHeader().getHashAsString());
    Set<Transaction> txns=new HashSet<Transaction>();
    Sha256Hash blockHash=b.getHeader().getHash();
    for (    Transaction tx : newChainTransactions.values()) {
      if (tx.getAppearsInHashes().contains(blockHash)) {
        txns.add(tx);
        log.info(""String_Node_Str"",tx.getHashAsString());
      }
    }
    for (    Transaction t : txns) {
      try {
        receive(t,b,BlockChain.NewBlockType.BEST_CHAIN,true);
      }
 catch (      ScriptException e) {
        throw new RuntimeException(e);
      }
    }
  }
  Map<Sha256Hash,Transaction> pool=new HashMap<Sha256Hash,Transaction>();
  pool.putAll(unspent);
  pool.putAll(spent);
  pool.putAll(pending);
  Map<Sha256Hash,Transaction> toReprocess=new HashMap<Sha256Hash,Transaction>();
  toReprocess.putAll(onlyOldChainTransactions);
  toReprocess.putAll(pending);
  log.info(""String_Node_Str"");
  for (  Transaction tx : dead.values()) {
    reprocessUnincludedTxAfterReorg(pool,tx);
  }
  for (  Transaction tx : toReprocess.values()) {
    reprocessUnincludedTxAfterReorg(pool,tx);
  }
  log.info(""String_Node_Str"",Utils.bitcoinValueToFriendlyString(getBalance()));
  EventListenerInvoker.invoke(eventListeners,new EventListenerInvoker<WalletEventListener>(){
    @Override public void invoke(    WalletEventListener listener){
      listener.onReorganize(Wallet.this);
    }
  }
);
  checkState(isConsistent());
}",0.996227077301044
85946,"/** 
 * Returns the   {@link StoredBlock} that represents the top of the chain of greatest total work.
 */
StoredBlock getChainHead() throws BlockStoreException ;","/** 
 * Returns the   {@link StoredBlock} that represents the top of the chain of greatest total work. Note that thiscan be arbitrarily expensive, you probably should use  {@link com.google.bitcoin.core.BlockChain#getChainHead()}or perhaps   {@link com.google.bitcoin.core.BlockChain#getBestChainHeight()} which will run in constant time andnot take any heavyweight locks.
 */
StoredBlock getChainHead() throws BlockStoreException ;",0.5454545454545454
85947,"private synchronized boolean add(Block block,boolean tryConnecting) throws BlockStoreException, VerificationException, ScriptException {
  if (System.currentTimeMillis() - statsLastTime > 1000) {
    if (statsBlocksAdded > 1)     log.info(""String_Node_Str"",statsBlocksAdded);
    statsLastTime=System.currentTimeMillis();
    statsBlocksAdded=0;
  }
  if (block.equals(getChainHead().getHeader())) {
    log.debug(""String_Node_Str"",block.getHash());
    return true;
  }
  boolean contentsImportant=false;
  if (block.transactions != null) {
    contentsImportant=containsRelevantTransactions(block);
  }
  try {
    block.verifyHeader();
    if (contentsImportant)     block.verifyTransactions();
  }
 catch (  VerificationException e) {
    log.error(""String_Node_Str"",e);
    log.error(block.getHashAsString());
    throw e;
  }
  StoredBlock storedPrev=blockStore.get(block.getPrevBlockHash());
  if (storedPrev == null) {
    checkState(tryConnecting,""String_Node_Str"");
    log.warn(""String_Node_Str"",block.getHashAsString());
    unconnectedBlocks.add(block);
    return false;
  }
 else {
    StoredBlock newStoredBlock=storedPrev.build(block);
    if (params.checkBlockDifficulty)     checkDifficultyTransitions(storedPrev,newStoredBlock);
    blockStore.put(newStoredBlock);
    connectBlock(newStoredBlock,storedPrev,block.transactions);
  }
  if (tryConnecting)   tryConnectingUnconnected();
  statsBlocksAdded++;
  return true;
}","private synchronized boolean add(Block block,boolean tryConnecting) throws BlockStoreException, VerificationException, ScriptException {
  if (System.currentTimeMillis() - statsLastTime > 1000) {
    if (statsBlocksAdded > 1)     log.info(""String_Node_Str"",statsBlocksAdded);
    statsLastTime=System.currentTimeMillis();
    statsBlocksAdded=0;
  }
  if (block.equals(getChainHead().getHeader())) {
    log.debug(""String_Node_Str"",block.getHash());
    return true;
  }
  boolean contentsImportant=false;
  if (block.transactions != null) {
    contentsImportant=containsRelevantTransactions(block);
  }
  try {
    block.verifyHeader();
    if (contentsImportant)     block.verifyTransactions();
  }
 catch (  VerificationException e) {
    log.error(""String_Node_Str"",e);
    log.error(block.getHashAsString());
    throw e;
  }
  StoredBlock storedPrev=blockStore.get(block.getPrevBlockHash());
  if (storedPrev == null) {
    checkState(tryConnecting,""String_Node_Str"");
    log.warn(""String_Node_Str"",block.getHashAsString(),block.getPrevBlockHash());
    unconnectedBlocks.add(block);
    return false;
  }
 else {
    StoredBlock newStoredBlock=storedPrev.build(block);
    checkDifficultyTransitions(storedPrev,newStoredBlock);
    blockStore.put(newStoredBlock);
    connectBlock(newStoredBlock,storedPrev,block.transactions);
  }
  if (tryConnecting)   tryConnectingUnconnected();
  statsBlocksAdded++;
  return true;
}",0.9784122562674096
85948,"/** 
 * Throws an exception if the blocks difficulty is not correct.
 */
private void checkDifficultyTransitions(StoredBlock storedPrev,StoredBlock storedNext) throws BlockStoreException, VerificationException {
  Block prev=storedPrev.getHeader();
  Block next=storedNext.getHeader();
  if ((storedPrev.getHeight() + 1) % params.interval != 0) {
    if (next.getDifficultyTarget() != prev.getDifficultyTarget())     throw new VerificationException(""String_Node_Str"" + storedPrev.getHeight() + ""String_Node_Str""+ Long.toHexString(next.getDifficultyTarget())+ ""String_Node_Str""+ Long.toHexString(prev.getDifficultyTarget()));
    return;
  }
  long now=System.currentTimeMillis();
  StoredBlock cursor=blockStore.get(prev.getHash());
  for (int i=0; i < params.interval - 1; i++) {
    if (cursor == null) {
      throw new VerificationException(""String_Node_Str"");
    }
    cursor=blockStore.get(cursor.getHeader().getPrevBlockHash());
  }
  log.debug(""String_Node_Str"",System.currentTimeMillis() - now);
  Block blockIntervalAgo=cursor.getHeader();
  int timespan=(int)(prev.getTimeSeconds() - blockIntervalAgo.getTimeSeconds());
  if (timespan < params.targetTimespan / 4)   timespan=params.targetTimespan / 4;
  if (timespan > params.targetTimespan * 4)   timespan=params.targetTimespan * 4;
  BigInteger newDifficulty=Utils.decodeCompactBits(blockIntervalAgo.getDifficultyTarget());
  newDifficulty=newDifficulty.multiply(BigInteger.valueOf(timespan));
  newDifficulty=newDifficulty.divide(BigInteger.valueOf(params.targetTimespan));
  if (newDifficulty.compareTo(params.proofOfWorkLimit) > 0) {
    log.debug(""String_Node_Str"",newDifficulty.toString(16));
    newDifficulty=params.proofOfWorkLimit;
  }
  int accuracyBytes=(int)(next.getDifficultyTarget() >>> 24) - 3;
  BigInteger receivedDifficulty=next.getDifficultyTargetAsInteger();
  BigInteger mask=BigInteger.valueOf(0xFFFFFFL).shiftLeft(accuracyBytes * 8);
  newDifficulty=newDifficulty.and(mask);
  if (newDifficulty.compareTo(receivedDifficulty) != 0)   throw new VerificationException(""String_Node_Str"" + receivedDifficulty.toString(16) + ""String_Node_Str""+ newDifficulty.toString(16));
}","/** 
 * Throws an exception if the blocks difficulty is not correct.
 */
private void checkDifficultyTransitions(StoredBlock storedPrev,StoredBlock storedNext) throws BlockStoreException, VerificationException {
  Block prev=storedPrev.getHeader();
  Block next=storedNext.getHeader();
  if ((storedPrev.getHeight() + 1) % params.interval != 0) {
    if (params.getId().equals(NetworkParameters.ID_TESTNET) && next.getTime().after(testnetDiffDate)) {
      checkTestnetDifficulty(storedPrev,prev,next);
      return;
    }
    if (next.getDifficultyTarget() != prev.getDifficultyTarget())     throw new VerificationException(""String_Node_Str"" + storedPrev.getHeight() + ""String_Node_Str""+ Long.toHexString(next.getDifficultyTarget())+ ""String_Node_Str""+ Long.toHexString(prev.getDifficultyTarget()));
    return;
  }
  long now=System.currentTimeMillis();
  StoredBlock cursor=blockStore.get(prev.getHash());
  for (int i=0; i < params.interval - 1; i++) {
    if (cursor == null) {
      throw new VerificationException(""String_Node_Str"");
    }
    cursor=blockStore.get(cursor.getHeader().getPrevBlockHash());
  }
  log.info(""String_Node_Str"",System.currentTimeMillis() - now);
  Block blockIntervalAgo=cursor.getHeader();
  int timespan=(int)(prev.getTimeSeconds() - blockIntervalAgo.getTimeSeconds());
  if (timespan < params.targetTimespan / 4)   timespan=params.targetTimespan / 4;
  if (timespan > params.targetTimespan * 4)   timespan=params.targetTimespan * 4;
  BigInteger newDifficulty=Utils.decodeCompactBits(blockIntervalAgo.getDifficultyTarget());
  newDifficulty=newDifficulty.multiply(BigInteger.valueOf(timespan));
  newDifficulty=newDifficulty.divide(BigInteger.valueOf(params.targetTimespan));
  if (newDifficulty.compareTo(params.proofOfWorkLimit) > 0) {
    log.info(""String_Node_Str"",newDifficulty.toString(16));
    newDifficulty=params.proofOfWorkLimit;
  }
  int accuracyBytes=(int)(next.getDifficultyTarget() >>> 24) - 3;
  BigInteger receivedDifficulty=next.getDifficultyTargetAsInteger();
  BigInteger mask=BigInteger.valueOf(0xFFFFFFL).shiftLeft(accuracyBytes * 8);
  newDifficulty=newDifficulty.and(mask);
  if (newDifficulty.compareTo(receivedDifficulty) != 0)   throw new VerificationException(""String_Node_Str"" + receivedDifficulty.toString(16) + ""String_Node_Str""+ newDifficulty.toString(16));
}",0.956754346856888
85949,"/** 
 * Sets up the given NetworkParameters with testnet values. 
 */
private static NetworkParameters createTestNet(NetworkParameters n){
  n.proofOfWorkLimit=new BigInteger(""String_Node_Str"",16);
  n.packetMagic=0xfabfb5daL;
  n.port=18333;
  n.addressHeader=111;
  n.acceptableAddressCodes=new int[]{111};
  n.dumpedPrivateKeyHeader=239;
  n.interval=INTERVAL;
  n.targetTimespan=TARGET_TIMESPAN;
  n.alertSigningKey=SATOSHI_KEY;
  n.genesisBlock=createGenesis(n);
  n.genesisBlock.setTime(1296688602L);
  n.genesisBlock.setDifficultyTarget(0x1d07fff8L);
  n.genesisBlock.setNonce(384568319);
  n.id=ID_TESTNET;
  n.checkBlockDifficulty=false;
  String genesisHash=n.genesisBlock.getHashAsString();
  checkState(genesisHash.equals(""String_Node_Str""),genesisHash);
  return n;
}","/** 
 * Sets up the given NetworkParameters with testnet values. 
 */
private static NetworkParameters createTestNet(NetworkParameters n){
  n.proofOfWorkLimit=Utils.decodeCompactBits(0x1d0fffffL);
  n.packetMagic=0xfabfb5daL;
  n.port=18333;
  n.addressHeader=111;
  n.acceptableAddressCodes=new int[]{111};
  n.dumpedPrivateKeyHeader=239;
  n.interval=INTERVAL;
  n.targetTimespan=TARGET_TIMESPAN;
  n.alertSigningKey=SATOSHI_KEY;
  n.genesisBlock=createGenesis(n);
  n.genesisBlock.setTime(1296688602L);
  n.genesisBlock.setDifficultyTarget(0x1d07fff8L);
  n.genesisBlock.setNonce(384568319);
  n.id=ID_TESTNET;
  String genesisHash=n.genesisBlock.getHashAsString();
  checkState(genesisHash.equals(""String_Node_Str""),genesisHash);
  return n;
}",0.9358638743455496
85950,"/** 
 * Returns a testnet params modified to allow any difficulty target. 
 */
public static NetworkParameters unitTests(){
  NetworkParameters n=new NetworkParameters();
  n=createTestNet(n);
  n.proofOfWorkLimit=new BigInteger(""String_Node_Str"",16);
  n.genesisBlock.setNonce(2);
  n.genesisBlock.setDifficultyTarget(Block.EASIEST_DIFFICULTY_TARGET);
  n.interval=10;
  n.targetTimespan=200000000;
  n.checkBlockDifficulty=true;
  n.id=""String_Node_Str"";
  return n;
}","/** 
 * Returns a testnet params modified to allow any difficulty target. 
 */
public static NetworkParameters unitTests(){
  NetworkParameters n=new NetworkParameters();
  n=createTestNet(n);
  n.proofOfWorkLimit=new BigInteger(""String_Node_Str"",16);
  n.genesisBlock.setNonce(2);
  n.genesisBlock.setDifficultyTarget(Block.EASIEST_DIFFICULTY_TARGET);
  n.interval=10;
  n.targetTimespan=200000000;
  n.id=""String_Node_Str"";
  return n;
}",0.965896589658966
85951,"/** 
 * The primary BitCoin chain created by Satoshi. 
 */
public static NetworkParameters prodNet(){
  NetworkParameters n=new NetworkParameters();
  n.proofOfWorkLimit=new BigInteger(""String_Node_Str"",16);
  n.port=8333;
  n.packetMagic=0xf9beb4d9L;
  n.addressHeader=0;
  n.acceptableAddressCodes=new int[]{0};
  n.dumpedPrivateKeyHeader=128;
  n.interval=INTERVAL;
  n.targetTimespan=TARGET_TIMESPAN;
  n.alertSigningKey=SATOSHI_KEY;
  n.genesisBlock=createGenesis(n);
  n.genesisBlock.setDifficultyTarget(0x1d00ffffL);
  n.genesisBlock.setTime(1231006505L);
  n.genesisBlock.setNonce(2083236893);
  n.id=ID_PRODNET;
  n.checkBlockDifficulty=true;
  String genesisHash=n.genesisBlock.getHashAsString();
  checkState(genesisHash.equals(""String_Node_Str""),genesisHash);
  return n;
}","/** 
 * The primary BitCoin chain created by Satoshi. 
 */
public static NetworkParameters prodNet(){
  NetworkParameters n=new NetworkParameters();
  n.proofOfWorkLimit=Utils.decodeCompactBits(0x1d00ffffL);
  n.port=8333;
  n.packetMagic=0xf9beb4d9L;
  n.addressHeader=0;
  n.acceptableAddressCodes=new int[]{0};
  n.dumpedPrivateKeyHeader=128;
  n.interval=INTERVAL;
  n.targetTimespan=TARGET_TIMESPAN;
  n.alertSigningKey=SATOSHI_KEY;
  n.genesisBlock=createGenesis(n);
  n.genesisBlock.setDifficultyTarget(0x1d00ffffL);
  n.genesisBlock.setTime(1231006505L);
  n.genesisBlock.setNonce(2083236893);
  n.id=ID_PRODNET;
  String genesisHash=n.genesisBlock.getHashAsString();
  checkState(genesisHash.equals(""String_Node_Str""),genesisHash);
  return n;
}",0.9382716049382716
85952,"private void processBlock(Block m) throws IOException {
  log.info(""String_Node_Str"",m.getHashAsString());
  try {
synchronized (pendingGetBlockFutures) {
      for (int i=0; i < pendingGetBlockFutures.size(); i++) {
        GetDataFuture<Block> f=pendingGetBlockFutures.get(i);
        if (f.getItem().hash.equals(m.getHash())) {
          f.setResult(m);
          pendingGetBlockFutures.remove(i);
          return;
        }
      }
    }
    if (blockChain.add(m)) {
      invokeOnBlocksDownloaded(m);
    }
 else {
      blockChainDownload(m.getHash());
    }
  }
 catch (  VerificationException e) {
    log.warn(""String_Node_Str"",e);
  }
catch (  ScriptException e) {
    log.warn(""String_Node_Str"",e);
  }
}","private void processBlock(Block m) throws IOException {
  log.debug(""String_Node_Str"",m.getHashAsString());
  try {
synchronized (pendingGetBlockFutures) {
      for (int i=0; i < pendingGetBlockFutures.size(); i++) {
        GetDataFuture<Block> f=pendingGetBlockFutures.get(i);
        if (f.getItem().hash.equals(m.getHash())) {
          f.setResult(m);
          pendingGetBlockFutures.remove(i);
          return;
        }
      }
    }
    if (blockChain.add(m)) {
      invokeOnBlocksDownloaded(m);
    }
 else {
      blockChainDownload(m.getHash());
    }
  }
 catch (  VerificationException e) {
    log.warn(""String_Node_Str"",e);
  }
catch (  ScriptException e) {
    log.warn(""String_Node_Str"",e);
  }
}",0.9937194696441032
85953,"@Before public void setUp() throws Exception {
  BriefLogFormatter.initVerbose();
  testNetChain=new BlockChain(testNet,new Wallet(testNet),new MemoryBlockStore(testNet));
  unitTestParams=NetworkParameters.unitTests();
  wallet=new Wallet(unitTestParams){
    @Override public void receiveFromBlock(    Transaction tx,    StoredBlock block,    BlockChain.NewBlockType blockType) throws VerificationException, ScriptException {
      super.receiveFromBlock(tx,block,blockType);
      BlockChainTest.this.block[0]=block;
    }
  }
;
  wallet.addKey(new ECKey());
  resetBlockStore();
  chain=new BlockChain(unitTestParams,wallet,blockStore);
  coinbaseTo=wallet.keychain.get(0).toAddress(unitTestParams);
  testNet.checkBlockDifficulty=true;
}","@Before public void setUp() throws Exception {
  BriefLogFormatter.initVerbose();
  testNetChain=new BlockChain(testNet,new Wallet(testNet),new MemoryBlockStore(testNet));
  unitTestParams=NetworkParameters.unitTests();
  wallet=new Wallet(unitTestParams){
    @Override public void receiveFromBlock(    Transaction tx,    StoredBlock block,    BlockChain.NewBlockType blockType) throws VerificationException, ScriptException {
      super.receiveFromBlock(tx,block,blockType);
      BlockChainTest.this.block[0]=block;
    }
  }
;
  wallet.addKey(new ECKey());
  resetBlockStore();
  chain=new BlockChain(unitTestParams,wallet,blockStore);
  coinbaseTo=wallet.keychain.get(0).toAddress(unitTestParams);
}",0.9744298548721492
85954,"private synchronized boolean add(Block block,boolean tryConnecting) throws BlockStoreException, VerificationException, ScriptException {
  if (System.currentTimeMillis() - statsLastTime > 1000) {
    if (statsBlocksAdded > 1)     log.info(""String_Node_Str"",statsBlocksAdded);
    statsLastTime=System.currentTimeMillis();
    statsBlocksAdded=0;
  }
  if (block.equals(getChainHead().getHeader())) {
    log.debug(""String_Node_Str"",block.getHash());
    return true;
  }
  boolean contentsImportant=false;
  HashMap<Wallet,List<Transaction>> walletToTxMap=new HashMap<Wallet,List<Transaction>>();
  if (block.transactions != null) {
    scanTransactions(block,walletToTxMap);
    contentsImportant=walletToTxMap.size() > 0;
  }
  try {
    block.verifyHeader();
    if (contentsImportant)     block.verifyTransactions();
  }
 catch (  VerificationException e) {
    log.error(""String_Node_Str"",e);
    log.error(block.getHashAsString());
    throw e;
  }
  StoredBlock storedPrev=blockStore.get(block.getPrevBlockHash());
  if (storedPrev == null) {
    checkState(tryConnecting,""String_Node_Str"");
    log.warn(""String_Node_Str"",block.getHashAsString());
    unconnectedBlocks.add(block);
    return false;
  }
 else {
    StoredBlock newStoredBlock=storedPrev.build(block);
    checkDifficultyTransitions(storedPrev,newStoredBlock);
    blockStore.put(newStoredBlock);
    connectBlock(newStoredBlock,storedPrev,walletToTxMap);
  }
  if (tryConnecting)   tryConnectingUnconnected();
  statsBlocksAdded++;
  return true;
}","private synchronized boolean add(Block block,boolean tryConnecting) throws BlockStoreException, VerificationException, ScriptException {
  if (System.currentTimeMillis() - statsLastTime > 1000) {
    if (statsBlocksAdded > 1)     log.info(""String_Node_Str"",statsBlocksAdded);
    statsLastTime=System.currentTimeMillis();
    statsBlocksAdded=0;
  }
  if (block.equals(getChainHead().getHeader())) {
    log.debug(""String_Node_Str"",block.getHash());
    return true;
  }
  boolean contentsImportant=false;
  if (block.transactions != null) {
    contentsImportant=containsRelevantTransactions(block);
  }
  try {
    block.verifyHeader();
    if (contentsImportant)     block.verifyTransactions();
  }
 catch (  VerificationException e) {
    log.error(""String_Node_Str"",e);
    log.error(block.getHashAsString());
    throw e;
  }
  StoredBlock storedPrev=blockStore.get(block.getPrevBlockHash());
  if (storedPrev == null) {
    checkState(tryConnecting,""String_Node_Str"");
    log.warn(""String_Node_Str"",block.getHashAsString());
    unconnectedBlocks.add(block);
    return false;
  }
 else {
    StoredBlock newStoredBlock=storedPrev.build(block);
    checkDifficultyTransitions(storedPrev,newStoredBlock);
    blockStore.put(newStoredBlock);
    connectBlock(newStoredBlock,storedPrev,block.transactions);
  }
  if (tryConnecting)   tryConnectingUnconnected();
  statsBlocksAdded++;
  return true;
}",0.924863387978142
85955,"private void connectBlock(StoredBlock newStoredBlock,StoredBlock storedPrev,HashMap<Wallet,List<Transaction>> newTransactions) throws BlockStoreException, VerificationException {
  StoredBlock head=getChainHead();
  if (storedPrev.equals(head)) {
    setChainHead(newStoredBlock);
    log.debug(""String_Node_Str"",newStoredBlock.getHeight());
    if (newTransactions != null)     sendTransactionsToWallet(newStoredBlock,NewBlockType.BEST_CHAIN,newTransactions);
  }
 else {
    boolean haveNewBestChain=newStoredBlock.moreWorkThan(head);
    if (haveNewBestChain) {
      log.info(""String_Node_Str"");
    }
 else {
      StoredBlock splitPoint=findSplit(newStoredBlock,head);
      if (splitPoint == newStoredBlock) {
        log.debug(""String_Node_Str"",newStoredBlock.getHeight(),newStoredBlock.getHeader().getHash());
        return;
      }
      if (splitPoint == null) {
        log.error(""String_Node_Str"");
      }
 else {
        int splitPointHeight=splitPoint.getHeight();
        String splitPointHash=splitPoint.getHeader().getHashAsString();
        log.info(""String_Node_Str"",new Object[]{splitPointHeight,splitPointHash,newStoredBlock});
      }
    }
    if (newTransactions != null) {
      sendTransactionsToWallet(newStoredBlock,NewBlockType.SIDE_CHAIN,newTransactions);
    }
    if (haveNewBestChain)     handleNewBestChain(newStoredBlock);
  }
}","private void connectBlock(StoredBlock newStoredBlock,StoredBlock storedPrev,List<Transaction> transactions) throws BlockStoreException, VerificationException {
  StoredBlock head=getChainHead();
  if (storedPrev.equals(head)) {
    setChainHead(newStoredBlock);
    log.debug(""String_Node_Str"",newStoredBlock.getHeight());
    if (transactions != null)     sendTransactionsToWallet(newStoredBlock,NewBlockType.BEST_CHAIN,transactions);
  }
 else {
    boolean haveNewBestChain=newStoredBlock.moreWorkThan(head);
    if (haveNewBestChain) {
      log.info(""String_Node_Str"");
    }
 else {
      StoredBlock splitPoint=findSplit(newStoredBlock,head);
      if (splitPoint == newStoredBlock) {
        log.warn(""String_Node_Str"",newStoredBlock.getHeight(),newStoredBlock.getHeader().getHash());
        return;
      }
      if (splitPoint == null) {
        log.error(""String_Node_Str"");
      }
 else {
        int splitPointHeight=splitPoint.getHeight();
        String splitPointHash=splitPoint.getHeader().getHashAsString();
        log.info(""String_Node_Str"",new Object[]{splitPointHeight,splitPointHash,newStoredBlock});
      }
    }
    if (transactions != null) {
      sendTransactionsToWallet(newStoredBlock,NewBlockType.SIDE_CHAIN,transactions);
    }
    if (haveNewBestChain)     handleNewBestChain(newStoredBlock);
  }
}",0.9807407407407408
85956,"private void sendTransactionsToWallet(StoredBlock block,NewBlockType blockType,HashMap<Wallet,List<Transaction>> newTransactions) throws VerificationException {
  for (  Map.Entry<Wallet,List<Transaction>> entry : newTransactions.entrySet()) {
    try {
      List<Transaction> txns=entry.getValue();
      for (      Transaction tx : txns) {
        entry.getKey().receiveFromBlock(tx,block,blockType);
      }
    }
 catch (    ScriptException e) {
      log.warn(""String_Node_Str"" + e.toString());
    }
  }
}","private void sendTransactionsToWallet(StoredBlock block,NewBlockType blockType,List<Transaction> transactions) throws VerificationException {
  for (  Transaction tx : transactions) {
    for (    Wallet wallet : wallets) {
      try {
        if (wallet.isTransactionRelevant(tx,true))         wallet.receiveFromBlock(tx,block,blockType);
      }
 catch (      ScriptException e) {
        log.warn(""String_Node_Str"" + e.toString());
      }
    }
  }
}",0.6004140786749482
85957,"@Test public void testStorage() throws Exception {
  File temp=File.createTempFile(""String_Node_Str"",null,null);
  System.out.println(temp.getAbsolutePath());
  temp.deleteOnExit();
  NetworkParameters params=NetworkParameters.unitTests();
  Address to=new ECKey().toAddress(params);
  BoundedOverheadBlockStore store=new BoundedOverheadBlockStore(params,temp);
  StoredBlock genesis=store.getChainHead();
  assertEquals(params.genesisBlock,genesis.getHeader());
  StoredBlock b1=genesis.build(genesis.getHeader().createNextBlock(to).cloneAsHeader());
  store.put(b1);
  store.setChainHead(b1);
  store.close();
  store=new BoundedOverheadBlockStore(params,temp);
  StoredBlock b2=store.get(b1.getHeader().getHash());
  assertEquals(b1,b2);
  assertEquals(b1,store.getChainHead());
}","@Test public void testStorage() throws Exception {
  File temp=folder.newFile(""String_Node_Str"");
  System.out.println(temp.getAbsolutePath());
  NetworkParameters params=NetworkParameters.unitTests();
  Address to=new ECKey().toAddress(params);
  BoundedOverheadBlockStore store=new BoundedOverheadBlockStore(params,temp);
  StoredBlock genesis=store.getChainHead();
  assertEquals(params.genesisBlock,genesis.getHeader());
  StoredBlock b1=genesis.build(genesis.getHeader().createNextBlock(to).cloneAsHeader());
  store.put(b1);
  store.setChainHead(b1);
  store.close();
  store=new BoundedOverheadBlockStore(params,temp);
  StoredBlock b2=store.get(b1.getHeader().getHash());
  assertEquals(b1,b2);
  assertEquals(b1,store.getChainHead());
}",0.962041884816754
85958,"@Test public void testLocking() throws Exception {
  File temp=File.createTempFile(""String_Node_Str"",null,null);
  System.out.println(temp.getAbsolutePath());
  temp.deleteOnExit();
  NetworkParameters params=NetworkParameters.unitTests();
  BoundedOverheadBlockStore store=new BoundedOverheadBlockStore(params,temp);
  try {
    BoundedOverheadBlockStore store1=new BoundedOverheadBlockStore(params,temp);
    fail();
  }
 catch (  BlockStoreException e) {
  }
}","@Test public void testLocking() throws Exception {
  File temp=folder.newFile(""String_Node_Str"");
  System.out.println(temp.getAbsolutePath());
  NetworkParameters params=NetworkParameters.unitTests();
  BoundedOverheadBlockStore store=new BoundedOverheadBlockStore(params,temp);
  try {
    BoundedOverheadBlockStore store1=new BoundedOverheadBlockStore(params,temp);
    fail();
  }
 catch (  BlockStoreException e) {
  }
}",0.3355855855855856
85959,"@Test public void testStorage() throws Exception {
  deleteRecursively(new File(DB_NAME));
  NetworkParameters params=NetworkParameters.unitTests();
  Address to=new ECKey().toAddress(params);
  DerbyBlockStore store=new DerbyBlockStore(params,DB_NAME);
  store.resetStore();
  store.dump();
  StoredBlock genesis=store.getChainHead();
  assertEquals(params.genesisBlock,genesis.getHeader());
  StoredBlock b1=genesis.build(genesis.getHeader().createNextBlock(to).cloneAsHeader());
  store.put(b1);
  store.setChainHead(b1);
  store.dump();
  store=new DerbyBlockStore(params,DB_NAME);
  StoredBlock b2=store.get(b1.getHeader().getHash());
  assertEquals(b1,b2);
  assertEquals(b1,store.getChainHead());
  StoredBlock g1=store.get(params.genesisBlock.getHash());
  assertEquals(params.genesisBlock,g1.getHeader());
  store.dump();
  store.close();
}","@Test public void testStorage() throws Exception {
  File file=new File(folder.getRoot(),""String_Node_Str"");
  String path=file.getAbsolutePath();
  NetworkParameters params=NetworkParameters.unitTests();
  Address to=new ECKey().toAddress(params);
  DerbyBlockStore store=new DerbyBlockStore(params,path);
  store.resetStore();
  store.dump();
  StoredBlock genesis=store.getChainHead();
  assertEquals(params.genesisBlock,genesis.getHeader());
  StoredBlock b1=genesis.build(genesis.getHeader().createNextBlock(to).cloneAsHeader());
  store.put(b1);
  store.setChainHead(b1);
  store.dump();
  store=new DerbyBlockStore(params,path);
  StoredBlock b2=store.get(b1.getHeader().getHash());
  assertEquals(b1,b2);
  assertEquals(b1,store.getChainHead());
  StoredBlock g1=store.get(params.genesisBlock.getHash());
  assertEquals(params.genesisBlock,g1.getHeader());
  store.dump();
  store.close();
}",0.919908466819222
85960,"@Before public void setUp() throws IOException {
  temp=File.createTempFile(""String_Node_Str"",null,null);
  System.out.println(temp.getAbsolutePath());
  params=NetworkParameters.unitTests();
  to=new ECKey().toAddress(params);
}","@Before public void setUp() throws IOException {
  temp=folder.newFile(""String_Node_Str"");
  System.out.println(temp.getAbsolutePath());
  params=NetworkParameters.unitTests();
  to=new ECKey().toAddress(params);
}",0.9209932279909706
85961,"@Override public void onTransactionConfidenceChanged(Wallet wallet,Transaction tx){
  super.onTransactionConfidenceChanged(wallet,tx);
  eventDead[0]=tx;
  eventReplacement[0]=tx.getConfidence().getOverridingTransaction();
}","@Override public void onTransactionConfidenceChanged(Wallet wallet,Transaction tx){
  super.onTransactionConfidenceChanged(wallet,tx);
  if (tx.getConfidence().getConfidenceType() == TransactionConfidence.ConfidenceType.OVERRIDDEN_BY_DOUBLE_SPEND) {
    eventDead[0]=tx;
    eventReplacement[0]=tx.getConfidence().getOverridingTransaction();
  }
}",0.7845884413309983
85962,"@Test public void testDoubleSpendOnForkPending() throws Exception {
  final Transaction[] eventDead=new Transaction[1];
  final Transaction[] eventReplacement=new Transaction[1];
  wallet.addEventListener(new AbstractWalletEventListener(){
    @Override public void onTransactionConfidenceChanged(    Wallet wallet,    Transaction tx){
      super.onTransactionConfidenceChanged(wallet,tx);
      eventDead[0]=tx;
      eventReplacement[0]=tx.getConfidence().getOverridingTransaction();
    }
  }
);
  Block b1=unitTestParams.genesisBlock.createNextBlock(coinsTo);
  chain.add(b1);
  Transaction t1=wallet.createSend(someOtherGuy,Utils.toNanoCoins(10,0));
  Address yetAnotherGuy=new ECKey().toAddress(unitTestParams);
  Transaction t2=wallet.createSend(yetAnotherGuy,Utils.toNanoCoins(20,0));
  wallet.commitTx(t1);
  Block b2=b1.createNextBlock(new ECKey().toAddress(unitTestParams));
  chain.add(b2);
  assertEquals(Utils.toNanoCoins(0,0),wallet.getBalance());
  assertEquals(Utils.toNanoCoins(40,0),wallet.getBalance(Wallet.BalanceType.ESTIMATED));
  Block b3=b1.createNextBlock(new ECKey().toAddress(unitTestParams));
  b3.addTransaction(t2);
  b3.solve();
  chain.add(b3);
  Block b4=b3.createNextBlock(new ECKey().toAddress(unitTestParams));
  chain.add(b4);
  assertEquals(t1,eventDead[0]);
  assertEquals(t2,eventReplacement[0]);
  assertEquals(Utils.toNanoCoins(30,0),wallet.getBalance());
  Block b5=b2.createNextBlock(new ECKey().toAddress(unitTestParams));
  chain.add(b5);
  Block b6=b5.createNextBlock(new ECKey().toAddress(unitTestParams));
  chain.add(b6);
  assertEquals(Utils.toNanoCoins(0,0),wallet.getBalance());
  assertEquals(Utils.toNanoCoins(40,0),wallet.getBalance(Wallet.BalanceType.ESTIMATED));
}","@Test public void testDoubleSpendOnForkPending() throws Exception {
  final Transaction[] eventDead=new Transaction[1];
  final Transaction[] eventReplacement=new Transaction[1];
  wallet.addEventListener(new AbstractWalletEventListener(){
    @Override public void onTransactionConfidenceChanged(    Wallet wallet,    Transaction tx){
      super.onTransactionConfidenceChanged(wallet,tx);
      if (tx.getConfidence().getConfidenceType() == TransactionConfidence.ConfidenceType.OVERRIDDEN_BY_DOUBLE_SPEND) {
        eventDead[0]=tx;
        eventReplacement[0]=tx.getConfidence().getOverridingTransaction();
      }
    }
  }
);
  Block b1=unitTestParams.genesisBlock.createNextBlock(coinsTo);
  chain.add(b1);
  Transaction t1=wallet.createSend(someOtherGuy,Utils.toNanoCoins(10,0));
  Address yetAnotherGuy=new ECKey().toAddress(unitTestParams);
  Transaction t2=wallet.createSend(yetAnotherGuy,Utils.toNanoCoins(20,0));
  wallet.commitTx(t1);
  Block b2=b1.createNextBlock(new ECKey().toAddress(unitTestParams));
  chain.add(b2);
  assertEquals(Utils.toNanoCoins(0,0),wallet.getBalance());
  assertEquals(Utils.toNanoCoins(40,0),wallet.getBalance(Wallet.BalanceType.ESTIMATED));
  Block b3=b1.createNextBlock(new ECKey().toAddress(unitTestParams));
  b3.addTransaction(t2);
  b3.solve();
  chain.add(b3);
  Block b4=b3.createNextBlock(new ECKey().toAddress(unitTestParams));
  chain.add(b4);
  assertEquals(t1,eventDead[0]);
  assertEquals(t2,eventReplacement[0]);
  assertEquals(Utils.toNanoCoins(30,0),wallet.getBalance());
  Block b5=b2.createNextBlock(new ECKey().toAddress(unitTestParams));
  chain.add(b5);
  Block b6=b5.createNextBlock(new ECKey().toAddress(unitTestParams));
  chain.add(b6);
  assertEquals(Utils.toNanoCoins(0,0),wallet.getBalance());
  assertEquals(Utils.toNanoCoins(40,0),wallet.getBalance(Wallet.BalanceType.ESTIMATED));
}",0.9633975970941604
85963,"private synchronized boolean add(Block block,boolean tryConnecting) throws BlockStoreException, VerificationException, ScriptException {
  if (System.currentTimeMillis() - statsLastTime > 1000) {
    if (statsBlocksAdded > 1)     log.info(""String_Node_Str"",statsBlocksAdded);
    statsLastTime=System.currentTimeMillis();
    statsBlocksAdded=0;
  }
  if (block.equals(chainHead.getHeader())) {
    return true;
  }
  boolean contentsImportant=false;
  HashMap<Wallet,List<Transaction>> walletToTxMap=new HashMap<Wallet,List<Transaction>>();
  if (block.transactions != null) {
    scanTransactions(block,walletToTxMap);
    contentsImportant=walletToTxMap.size() > 0;
  }
  try {
    block.verifyHeader();
    if (contentsImportant)     block.verifyTransactions();
  }
 catch (  VerificationException e) {
    log.error(""String_Node_Str"",e);
    log.error(block.getHashAsString());
    throw e;
  }
  StoredBlock storedPrev=blockStore.get(block.getPrevBlockHash());
  if (storedPrev == null) {
    log.warn(""String_Node_Str"",block.getHashAsString());
    unconnectedBlocks.add(block);
    return false;
  }
 else {
    StoredBlock newStoredBlock=storedPrev.build(block);
    checkDifficultyTransitions(storedPrev,newStoredBlock);
    blockStore.put(newStoredBlock);
    connectBlock(newStoredBlock,storedPrev,walletToTxMap);
  }
  if (tryConnecting)   tryConnectingUnconnected();
  statsBlocksAdded++;
  return true;
}","private synchronized boolean add(Block block,boolean tryConnecting) throws BlockStoreException, VerificationException, ScriptException {
}",0.1772639691714836
85964,"/** 
 * For each block in unconnectedBlocks, see if we can now fit it on top of the chain and if so, do so.
 */
private void tryConnectingUnconnected() throws VerificationException, ScriptException, BlockStoreException {
  int blocksConnectedThisRound;
  do {
    blocksConnectedThisRound=0;
    Iterator<Block> iter=unconnectedBlocks.iterator();
    while (iter.hasNext()) {
      Block block=iter.next();
      StoredBlock prev=blockStore.get(block.getPrevBlockHash());
      if (prev == null) {
        continue;
      }
      add(block,false);
      iter.remove();
      blocksConnectedThisRound++;
    }
    if (blocksConnectedThisRound > 0) {
      log.info(""String_Node_Str"",blocksConnectedThisRound);
    }
  }
 while (blocksConnectedThisRound > 0);
}","/** 
 * For each block in unconnectedBlocks, see if we can now fit it on top of the chain and if so, do so.
 */
private void tryConnectingUnconnected() throws VerificationException, ScriptException, BlockStoreException {
  int blocksConnectedThisRound;
  do {
    blocksConnectedThisRound=0;
    Iterator<Block> iter=unconnectedBlocks.iterator();
    while (iter.hasNext()) {
      Block block=iter.next();
      log.debug(""String_Node_Str"",block.getHash());
      StoredBlock prev=blockStore.get(block.getPrevBlockHash());
      if (prev == null) {
        log.debug(""String_Node_Str"");
        continue;
      }
      add(block,false);
      iter.remove();
      blocksConnectedThisRound++;
    }
    if (blocksConnectedThisRound > 0) {
      log.info(""String_Node_Str"",blocksConnectedThisRound);
    }
  }
 while (blocksConnectedThisRound > 0);
}",0.9440298507462688
85965,"/** 
 * Locates the point in the chain at which newStoredBlock and chainHead diverge. Returns null if no split point was found (ie they are part of the same chain).
 */
private StoredBlock findSplit(StoredBlock newChainHead,StoredBlock chainHead) throws BlockStoreException {
}","/** 
 * Locates the point in the chain at which newStoredBlock and chainHead diverge. Returns null if no split point was found (ie they are not part of the same chain). Returns newChainHead or chainHead if they don't actually diverge but are part of the same chain.
 */
private StoredBlock findSplit(StoredBlock newChainHead,StoredBlock chainHead) throws BlockStoreException {
}",0.8458015267175573
85966,"private void connectBlock(StoredBlock newStoredBlock,StoredBlock storedPrev,HashMap<Wallet,List<Transaction>> newTransactions) throws BlockStoreException, VerificationException {
  if (storedPrev.equals(chainHead)) {
    setChainHead(newStoredBlock);
    log.debug(""String_Node_Str"",chainHead.getHeight());
    if (newTransactions != null)     sendTransactionsToWallet(newStoredBlock,NewBlockType.BEST_CHAIN,newTransactions);
  }
 else {
    boolean haveNewBestChain=newStoredBlock.moreWorkThan(chainHead);
    if (haveNewBestChain) {
      log.info(""String_Node_Str"");
    }
 else {
      StoredBlock splitPoint=findSplit(newStoredBlock,chainHead);
      String splitPointHash=splitPoint != null ? splitPoint.getHeader().getHashAsString() : ""String_Node_Str"";
      log.info(""String_Node_Str"",splitPointHash,newStoredBlock);
    }
    if (newTransactions != null) {
      sendTransactionsToWallet(newStoredBlock,NewBlockType.SIDE_CHAIN,newTransactions);
    }
    if (haveNewBestChain)     handleNewBestChain(newStoredBlock);
  }
}","private void connectBlock(StoredBlock newStoredBlock,StoredBlock storedPrev,HashMap<Wallet,List<Transaction>> newTransactions) throws BlockStoreException, VerificationException {
  if (storedPrev.equals(chainHead)) {
    setChainHead(newStoredBlock);
    log.debug(""String_Node_Str"",chainHead.getHeight());
    if (newTransactions != null)     sendTransactionsToWallet(newStoredBlock,NewBlockType.BEST_CHAIN,newTransactions);
  }
 else {
    boolean haveNewBestChain=newStoredBlock.moreWorkThan(chainHead);
    if (haveNewBestChain) {
      log.info(""String_Node_Str"");
    }
 else {
      StoredBlock splitPoint=findSplit(newStoredBlock,chainHead);
      if (splitPoint == newStoredBlock) {
        log.debug(""String_Node_Str"",newStoredBlock.getHeight(),newStoredBlock.getHeader().getHash());
        return;
      }
      int splitPointHeight=splitPoint != null ? splitPoint.getHeight() : -1;
      String splitPointHash=splitPoint != null ? splitPoint.getHeader().getHashAsString() : ""String_Node_Str"";
      log.info(""String_Node_Str"",new Object[]{splitPointHeight,splitPointHash,newStoredBlock});
    }
    if (newTransactions != null) {
      sendTransactionsToWallet(newStoredBlock,NewBlockType.SIDE_CHAIN,newTransactions);
    }
    if (haveNewBestChain)     handleNewBestChain(newStoredBlock);
  }
}",0.8572649572649572
85967,"@Before public void setUp() throws Exception {
  testNetChain=new BlockChain(testNet,new Wallet(testNet),new MemoryBlockStore(testNet));
  unitTestParams=NetworkParameters.unitTests();
  wallet=new Wallet(unitTestParams);
  wallet.addKey(new ECKey());
  resetBlockStore();
  chain=new BlockChain(unitTestParams,wallet,blockStore);
  coinbaseTo=wallet.keychain.get(0).toAddress(unitTestParams);
}","@Before public void setUp() throws Exception {
  BriefLogFormatter.initVerbose();
  testNetChain=new BlockChain(testNet,new Wallet(testNet),new MemoryBlockStore(testNet));
  unitTestParams=NetworkParameters.unitTests();
  wallet=new Wallet(unitTestParams){
    @Override public void receiveFromBlock(    Transaction tx,    StoredBlock block,    BlockChain.NewBlockType blockType) throws VerificationException, ScriptException {
      super.receiveFromBlock(tx,block,blockType);
      BlockChainTest.this.block[0]=block;
    }
  }
;
  wallet.addKey(new ECKey());
  resetBlockStore();
  chain=new BlockChain(unitTestParams,wallet,blockStore);
  coinbaseTo=wallet.keychain.get(0).toAddress(unitTestParams);
}",0.7181818181818181
85968,"private void blockChainDownload(Sha256Hash toHash) throws IOException {
  log.info(""String_Node_Str"",toHash.toString());
  List<Sha256Hash> blockLocator=new LinkedList<Sha256Hash>();
  blockLocator.add(params.genesisBlock.getHash());
  Block topBlock=blockChain.getChainHead().getHeader();
  if (!topBlock.equals(params.genesisBlock)) {
    if (!topBlock.getPrevBlockHash().equals(params.genesisBlock)) {
      blockLocator.add(0,topBlock.getPrevBlockHash());
    }
    blockLocator.add(0,topBlock.getHash());
  }
  if (downloadBlockBodies) {
    GetBlocksMessage message=new GetBlocksMessage(params,blockLocator,toHash);
    conn.writeMessage(message);
  }
 else {
    GetHeadersMessage message=new GetHeadersMessage(params,blockLocator,toHash);
    conn.writeMessage(message);
  }
}","private void blockChainDownload(Sha256Hash toHash) throws IOException {
  log.info(""String_Node_Str"",toHash.toString());
  List<Sha256Hash> blockLocator=new LinkedList<Sha256Hash>();
  blockLocator.add(params.genesisBlock.getHash());
  Block topBlock=blockChain.getChainHead().getHeader();
  if (!topBlock.equals(params.genesisBlock)) {
    if (!topBlock.getPrevBlockHash().equals(params.genesisBlock.getHash())) {
      blockLocator.add(0,topBlock.getPrevBlockHash());
    }
    blockLocator.add(0,topBlock.getHash());
  }
  if (downloadBlockBodies) {
    GetBlocksMessage message=new GetBlocksMessage(params,blockLocator,toHash);
    conn.writeMessage(message);
  }
 else {
    GetHeadersMessage message=new GetHeadersMessage(params,blockLocator,toHash);
    conn.writeMessage(message);
  }
}",0.9936628643852978
85969,"@Test public void fastCatchup() throws Exception {
  Block b1=TestUtils.createFakeBlock(unitTestParams,blockStore).block;
  blockChain.add(b1);
  Utils.rollMockClock(60 * 10);
  Block b2=TestUtils.makeSolvedTestBlock(unitTestParams,b1);
  Utils.rollMockClock(60 * 10);
  Block b3=TestUtils.makeSolvedTestBlock(unitTestParams,b2);
  Utils.rollMockClock(60 * 10);
  Block b4=TestUtils.makeSolvedTestBlock(unitTestParams,b3);
  conn.setVersionMessageForHeight(unitTestParams,4);
  peer.setFastCatchupTime((Utils.now().getTime() / 1000) - (600 * 2) + 1);
  runPeerAsync(peer,conn);
  peer.startBlockChainDownload();
  GetHeadersMessage getheaders=(GetHeadersMessage)conn.outbound();
  List<Sha256Hash> expectedLocator=new ArrayList<Sha256Hash>();
  expectedLocator.add(b1.getHash());
  expectedLocator.add(b1.getPrevBlockHash());
  expectedLocator.add(unitTestParams.genesisBlock.getHash());
  assertEquals(getheaders.getLocator(),expectedLocator);
  assertEquals(getheaders.getStopHash(),Sha256Hash.ZERO_HASH);
  HeadersMessage headers=new HeadersMessage(unitTestParams,b2.cloneAsHeader(),b3.cloneAsHeader(),b4.cloneAsHeader());
  expectedLocator.clear();
  expectedLocator.add(b2.getHash());
  expectedLocator.add(b1.getHash());
  expectedLocator.add(unitTestParams.genesisBlock.getHash());
  GetBlocksMessage getblocks=(GetBlocksMessage)conn.exchange(headers);
  assertEquals(expectedLocator,getblocks.getLocator());
  assertEquals(b3.getHash(),getblocks.getStopHash());
  InventoryMessage inv=new InventoryMessage(unitTestParams);
  inv.addItem(new InventoryItem(InventoryItem.Type.Block,b3.getHash()));
  GetDataMessage getdata=(GetDataMessage)conn.exchange(inv);
  assertEquals(b3.getHash(),getdata.getItems().get(0).hash);
  assertEquals(null,conn.exchange(b3));
}","@Test public void fastCatchup() throws Exception {
  Block b1=TestUtils.createFakeBlock(unitTestParams,blockStore).block;
  blockChain.add(b1);
  Utils.rollMockClock(60 * 10);
  Block b2=TestUtils.makeSolvedTestBlock(unitTestParams,b1);
  Utils.rollMockClock(60 * 10);
  Block b3=TestUtils.makeSolvedTestBlock(unitTestParams,b2);
  Utils.rollMockClock(60 * 10);
  Block b4=TestUtils.makeSolvedTestBlock(unitTestParams,b3);
  conn.setVersionMessageForHeight(unitTestParams,4);
  peer.setFastCatchupTime((Utils.now().getTime() / 1000) - (600 * 2) + 1);
  runPeerAsync(peer,conn);
  peer.startBlockChainDownload();
  GetHeadersMessage getheaders=(GetHeadersMessage)conn.outbound();
  List<Sha256Hash> expectedLocator=new ArrayList<Sha256Hash>();
  expectedLocator.add(b1.getHash());
  expectedLocator.add(unitTestParams.genesisBlock.getHash());
  assertEquals(getheaders.getLocator(),expectedLocator);
  assertEquals(getheaders.getStopHash(),Sha256Hash.ZERO_HASH);
  HeadersMessage headers=new HeadersMessage(unitTestParams,b2.cloneAsHeader(),b3.cloneAsHeader(),b4.cloneAsHeader());
  expectedLocator.clear();
  expectedLocator.add(b2.getHash());
  expectedLocator.add(b1.getHash());
  expectedLocator.add(unitTestParams.genesisBlock.getHash());
  GetBlocksMessage getblocks=(GetBlocksMessage)conn.exchange(headers);
  assertEquals(expectedLocator,getblocks.getLocator());
  assertEquals(b3.getHash(),getblocks.getStopHash());
  InventoryMessage inv=new InventoryMessage(unitTestParams);
  inv.addItem(new InventoryItem(InventoryItem.Type.Block,b3.getHash()));
  GetDataMessage getdata=(GetDataMessage)conn.exchange(inv);
  assertEquals(b3.getHash(),getdata.getItems().get(0).hash);
  assertEquals(null,conn.exchange(b3));
}",0.9868119266055044
85970,"@Test public void unconnectedBlock() throws Exception {
  Block b1=TestUtils.createFakeBlock(unitTestParams,blockStore).block;
  blockChain.add(b1);
  Block b2=TestUtils.makeSolvedTestBlock(unitTestParams,b1);
  Block b3=TestUtils.makeSolvedTestBlock(unitTestParams,b2);
  conn.inbound(b3);
  runPeer(peer,conn);
  GetBlocksMessage getblocks=(GetBlocksMessage)conn.popOutbound();
  List<Sha256Hash> expectedLocator=new ArrayList<Sha256Hash>();
  expectedLocator.add(b1.getHash());
  expectedLocator.add(b1.getPrevBlockHash());
  expectedLocator.add(unitTestParams.genesisBlock.getHash());
  assertEquals(getblocks.getLocator(),expectedLocator);
  assertEquals(getblocks.getStopHash(),b3.getHash());
}","@Test public void unconnectedBlock() throws Exception {
  Block b1=TestUtils.createFakeBlock(unitTestParams,blockStore).block;
  blockChain.add(b1);
  Block b2=TestUtils.makeSolvedTestBlock(unitTestParams,b1);
  blockChain.add(b2);
  Block b3=TestUtils.makeSolvedTestBlock(unitTestParams,b2);
  Block b4=TestUtils.makeSolvedTestBlock(unitTestParams,b3);
  conn.inbound(b4);
  runPeer(peer,conn);
  GetBlocksMessage getblocks=(GetBlocksMessage)conn.popOutbound();
  List<Sha256Hash> expectedLocator=new ArrayList<Sha256Hash>();
  expectedLocator.add(b2.getHash());
  expectedLocator.add(b2.getPrevBlockHash());
  expectedLocator.add(unitTestParams.genesisBlock.getHash());
  assertEquals(expectedLocator,getblocks.getLocator());
  assertEquals(b4.getHash(),getblocks.getStopHash());
}",0.8752528658125421
85971,"@Test public void invTickle() throws Exception {
  Block b1=TestUtils.createFakeBlock(unitTestParams,blockStore).block;
  blockChain.add(b1);
  Block b2=TestUtils.makeSolvedTestBlock(unitTestParams,b1);
  Block b3=TestUtils.makeSolvedTestBlock(unitTestParams,b2);
  conn.inbound(b3);
  InventoryMessage inv=new InventoryMessage(unitTestParams);
  InventoryItem item=new InventoryItem(InventoryItem.Type.Block,b3.getHash());
  inv.addItem(item);
  conn.inbound(inv);
  runPeer(peer,conn);
  GetBlocksMessage getblocks=(GetBlocksMessage)conn.popOutbound();
  List<Sha256Hash> expectedLocator=new ArrayList<Sha256Hash>();
  expectedLocator.add(b1.getHash());
  expectedLocator.add(b1.getPrevBlockHash());
  expectedLocator.add(unitTestParams.genesisBlock.getHash());
  assertEquals(getblocks.getLocator(),expectedLocator);
  assertEquals(getblocks.getStopHash(),b3.getHash());
}","@Test public void invTickle() throws Exception {
  Block b1=TestUtils.createFakeBlock(unitTestParams,blockStore).block;
  blockChain.add(b1);
  Block b2=TestUtils.makeSolvedTestBlock(unitTestParams,b1);
  Block b3=TestUtils.makeSolvedTestBlock(unitTestParams,b2);
  conn.inbound(b3);
  InventoryMessage inv=new InventoryMessage(unitTestParams);
  InventoryItem item=new InventoryItem(InventoryItem.Type.Block,b3.getHash());
  inv.addItem(item);
  conn.inbound(inv);
  runPeer(peer,conn);
  GetBlocksMessage getblocks=(GetBlocksMessage)conn.popOutbound();
  List<Sha256Hash> expectedLocator=new ArrayList<Sha256Hash>();
  expectedLocator.add(b1.getHash());
  expectedLocator.add(unitTestParams.genesisBlock.getHash());
  assertEquals(getblocks.getLocator(),expectedLocator);
  assertEquals(getblocks.getStopHash(),b3.getHash());
}",0.9730046948356808
85972,"/** 
 * Returns the time at which the block was solved and broadcast, according to the clock of the solving node.
 */
public Date getTime(){
  return new Date(getTimeSeconds());
}","/** 
 * Returns the time at which the block was solved and broadcast, according to the clock of the solving node.
 */
public Date getTime(){
  return new Date(getTimeSeconds() * 1000);
}",0.9808219178082191
85973,"/** 
 * @return true if every output is marked as spent.
 */
public boolean isEveryOutputSpent(){
  maybeParse();
  for (  TransactionOutput output : outputs) {
    if (output.isAvailableForSpending())     return false;
  }
  return true;
}","/** 
 * Returns true if every output is marked as spent.
 */
public boolean isEveryOutputSpent(){
  maybeParse();
  for (  TransactionOutput output : outputs) {
    if (output.isAvailableForSpending())     return false;
  }
  return true;
}",0.9708333333333332
85974,"/** 
 * If the transactions outputs are all marked as spent, and it's in the unspent map, move it.
 */
private void maybeMoveTxToSpent(Transaction tx,String context){
  if (tx.isEveryOutputSpent()) {
    if (unspent.remove(tx.getHash()) != null) {
      if (log.isInfoEnabled()) {
        log.info(""String_Node_Str"" + context + ""String_Node_Str"");
        log.info(""String_Node_Str"" + context + ""String_Node_Str"");
      }
      spent.put(tx.getHash(),tx);
    }
  }
}","/** 
 * If the transactions outputs are all marked as spent, and it's in the unspent map, move it.
 */
private void maybeMoveTxToSpent(Transaction tx,String context){
  if (tx.isEveryOwnedOutputSpent(this)) {
    if (unspent.remove(tx.getHash()) != null) {
      if (log.isInfoEnabled()) {
        log.info(""String_Node_Str"" + context + ""String_Node_Str"");
        log.info(""String_Node_Str"" + context + ""String_Node_Str"");
      }
      spent.put(tx.getHash(),tx);
    }
  }
}",0.9671957671957672
85975,"public static Transaction createFakeTx(NetworkParameters params,BigInteger nanocoins,Address to){
  Transaction t=new Transaction(params);
  TransactionOutput o1=new TransactionOutput(params,t,nanocoins,to);
  t.addOutput(o1);
  Transaction prevTx=new Transaction(params);
  TransactionOutput prevOut=new TransactionOutput(params,prevTx,nanocoins,to);
  prevTx.addOutput(prevOut);
  t.addInput(prevOut);
  return t;
}","public static Transaction createFakeTx(NetworkParameters params,BigInteger nanocoins,Address to){
  Transaction t=new Transaction(params);
  TransactionOutput outputToMe=new TransactionOutput(params,t,nanocoins,to);
  t.addOutput(outputToMe);
  TransactionOutput change=new TransactionOutput(params,t,Utils.toNanoCoins(1,11),new ECKey().toAddress(params));
  t.addOutput(change);
  Transaction prevTx=new Transaction(params);
  TransactionOutput prevOut=new TransactionOutput(params,prevTx,nanocoins,to);
  prevTx.addOutput(prevOut);
  t.addInput(prevOut);
  return t;
}",0.7193515704154002
85976,"@Test public void balance() throws Exception {
  BigInteger v1=toNanoCoins(5,0);
  BigInteger v2=toNanoCoins(0,50);
  Transaction t1=createFakeTx(params,v1,myAddress);
  Transaction t2=createFakeTx(params,v2,myAddress);
  StoredBlock b1=createFakeBlock(params,blockStore,t1).storedBlock;
  StoredBlock b2=createFakeBlock(params,blockStore,t2).storedBlock;
  BigInteger expected=toNanoCoins(5,50);
  wallet.receive(t1,b1,BlockChain.NewBlockType.BEST_CHAIN);
  wallet.receive(t2,b2,BlockChain.NewBlockType.BEST_CHAIN);
  assertEquals(expected,wallet.getBalance());
  BigInteger v3=toNanoCoins(1,0);
  Transaction spend=wallet.createSend(new ECKey().toAddress(params),v3);
  wallet.confirmSend(spend);
  assertEquals(toNanoCoins(4,50),wallet.getBalance(Wallet.BalanceType.ESTIMATED));
  assertFalse(wallet.getBalance(Wallet.BalanceType.AVAILABLE).equals(wallet.getBalance(Wallet.BalanceType.ESTIMATED)));
  StoredBlock b3=createFakeBlock(params,blockStore,spend).storedBlock;
  wallet.receive(spend,b3,BlockChain.NewBlockType.BEST_CHAIN);
  BigInteger v4=toNanoCoins(4,50);
  assertEquals(v4,wallet.getBalance(Wallet.BalanceType.AVAILABLE));
}","@Test public void balance() throws Exception {
  BigInteger v1=toNanoCoins(5,0);
  BigInteger v2=toNanoCoins(0,50);
  Transaction t1=createFakeTx(params,v1,myAddress);
  Transaction t2=createFakeTx(params,v2,myAddress);
  StoredBlock b1=createFakeBlock(params,blockStore,t1).storedBlock;
  StoredBlock b2=createFakeBlock(params,blockStore,t2).storedBlock;
  BigInteger expected=toNanoCoins(5,50);
  assertEquals(0,wallet.getPoolSize(Wallet.Pool.ALL));
  wallet.receive(t1,b1,BlockChain.NewBlockType.BEST_CHAIN);
  assertEquals(1,wallet.getPoolSize(Wallet.Pool.UNSPENT));
  wallet.receive(t2,b2,BlockChain.NewBlockType.BEST_CHAIN);
  assertEquals(2,wallet.getPoolSize(Wallet.Pool.UNSPENT));
  assertEquals(expected,wallet.getBalance());
  BigInteger v3=toNanoCoins(1,0);
  Transaction spend=wallet.createSend(new ECKey().toAddress(params),v3);
  wallet.confirmSend(spend);
  assertEquals(1,wallet.getPoolSize(Wallet.Pool.UNSPENT));
  assertEquals(1,wallet.getPoolSize(Wallet.Pool.SPENT));
  assertEquals(1,wallet.getPoolSize(Wallet.Pool.PENDING));
  assertEquals(toNanoCoins(4,50),wallet.getBalance(Wallet.BalanceType.ESTIMATED));
  assertFalse(wallet.getBalance(Wallet.BalanceType.AVAILABLE).equals(wallet.getBalance(Wallet.BalanceType.ESTIMATED)));
  StoredBlock b3=createFakeBlock(params,blockStore,spend).storedBlock;
  wallet.receive(spend,b3,BlockChain.NewBlockType.BEST_CHAIN);
  BigInteger v4=toNanoCoins(4,50);
  assertEquals(v4,wallet.getBalance(Wallet.BalanceType.AVAILABLE));
}",0.867579908675799
85977,"private void runListeners(){
  for (int i=0; i < listeners.size(); i++) {
    Listener l=listeners.get(i);
synchronized (l) {
      l.onConfidenceChanged(transaction);
    }
    if (listeners.get(i) != l) {
      i--;
    }
  }
}","private void runListeners(){
  if (listeners == null)   return;
  for (int i=0; i < listeners.size(); i++) {
    Listener l=listeners.get(i);
synchronized (l) {
      l.onConfidenceChanged(transaction);
    }
    if (listeners.get(i) != l) {
      i--;
    }
  }
}",0.9290060851926978
85978,"/** 
 * <p>Adds an event listener that will be run when this confidence object is updated. The listener will be locked and is likely to be invoked on a peer thread.</p> <p>Note that this is NOT called when every block is arrived. Instead it is called when the transaction  transitions between confidence states, ie, from not being seen in the chain to being seen (not necessarily in  the best chain). If you want to know when the transaction gets buried under another block, listen for new block events using   {@link PeerEventListener#onBlocksDownloaded(Peer,Block,int)} and then use the getters on theconfidence object to determine the new depth.</p>
 */
public synchronized void addEventListener(Listener listener){
  if (listener == null)   throw new IllegalArgumentException(""String_Node_Str"");
  listeners.add(listener);
}","/** 
 * <p>Adds an event listener that will be run when this confidence object is updated. The listener will be locked and is likely to be invoked on a peer thread.</p> <p>Note that this is NOT called when every block is arrived. Instead it is called when the transaction  transitions between confidence states, ie, from not being seen in the chain to being seen (not necessarily in  the best chain). If you want to know when the transaction gets buried under another block, listen for new block events using   {@link PeerEventListener#onBlocksDownloaded(Peer,Block,int)} and then use the getters on theconfidence object to determine the new depth.</p>
 */
public synchronized void addEventListener(Listener listener){
  if (listener == null)   throw new IllegalArgumentException(""String_Node_Str"");
  if (listeners == null)   listeners=new ArrayList<Listener>(1);
  listeners.add(listener);
}",0.9622312608948286
85979,"public void run(){
  try {
    if (shouldConnect) {
      log.info(""String_Node_Str"" + peer);
      peer.connect();
    }
    peers.add(peer);
    handleNewPeer(peer);
    if (blockUntilRunning == ExecuteBlockMode.WAIT_FOR_STARTUP)     latch.countDown();
    peer.run();
  }
 catch (  PeerException ex) {
    final Throwable cause=ex.getCause();
    if (cause instanceof SocketTimeoutException) {
      log.info(""String_Node_Str"" + peer + ""String_Node_Str""+ cause.getMessage());
    }
 else     if (cause instanceof ConnectException) {
      log.info(""String_Node_Str"" + peer + ""String_Node_Str""+ cause.getMessage());
    }
 else     if (cause instanceof IOException) {
      log.info(""String_Node_Str"" + peer + ""String_Node_Str""+ cause.getMessage());
    }
 else {
      log.error(""String_Node_Str"" + peer,ex);
    }
  }
 finally {
    if (!running)     return;
    peer.disconnect();
    if (address != null)     inactives.add(address);
    if (peers.remove(peer))     handlePeerDeath(peer);
  }
}","public void run(){
  try {
    if (shouldConnect) {
      log.info(""String_Node_Str"" + peer);
      peer.connect();
    }
synchronized (PeerGroup.this) {
      if (!running) {
        peer.disconnect();
        return;
      }
      peers.add(peer);
    }
    handleNewPeer(peer);
    if (blockUntilRunning == ExecuteBlockMode.WAIT_FOR_STARTUP)     latch.countDown();
    peer.run();
  }
 catch (  PeerException ex) {
    final Throwable cause=ex.getCause();
    if (cause instanceof SocketTimeoutException) {
      log.info(""String_Node_Str"" + peer + ""String_Node_Str""+ cause.getMessage());
    }
 else     if (cause instanceof ConnectException) {
      log.info(""String_Node_Str"" + peer + ""String_Node_Str""+ cause.getMessage());
    }
 else     if (cause instanceof IOException) {
      log.info(""String_Node_Str"" + peer + ""String_Node_Str""+ cause.getMessage());
    }
 else {
      log.error(""String_Node_Str"" + peer,ex);
    }
  }
 finally {
    if (!running)     return;
    peer.disconnect();
    if (address != null)     inactives.add(address);
    if (peers.remove(peer))     handlePeerDeath(peer);
  }
}",0.9275225011842728
85980,"private void executePeer(final PeerAddress address,final Peer peer,final boolean shouldConnect,final ExecuteBlockMode blockUntilRunning){
  final CountDownLatch latch=new CountDownLatch(1);
  peerPool.execute(new Runnable(){
    public void run(){
      try {
        if (shouldConnect) {
          log.info(""String_Node_Str"" + peer);
          peer.connect();
        }
        peers.add(peer);
        handleNewPeer(peer);
        if (blockUntilRunning == ExecuteBlockMode.WAIT_FOR_STARTUP)         latch.countDown();
        peer.run();
      }
 catch (      PeerException ex) {
        final Throwable cause=ex.getCause();
        if (cause instanceof SocketTimeoutException) {
          log.info(""String_Node_Str"" + peer + ""String_Node_Str""+ cause.getMessage());
        }
 else         if (cause instanceof ConnectException) {
          log.info(""String_Node_Str"" + peer + ""String_Node_Str""+ cause.getMessage());
        }
 else         if (cause instanceof IOException) {
          log.info(""String_Node_Str"" + peer + ""String_Node_Str""+ cause.getMessage());
        }
 else {
          log.error(""String_Node_Str"" + peer,ex);
        }
      }
 finally {
        if (!running)         return;
        peer.disconnect();
        if (address != null)         inactives.add(address);
        if (peers.remove(peer))         handlePeerDeath(peer);
      }
    }
  }
);
  if (blockUntilRunning == ExecuteBlockMode.WAIT_FOR_STARTUP) {
    try {
      latch.await();
    }
 catch (    InterruptedException e) {
    }
  }
}","private void executePeer(final PeerAddress address,final Peer peer,final boolean shouldConnect,final ExecuteBlockMode blockUntilRunning){
  final CountDownLatch latch=new CountDownLatch(1);
  peerPool.execute(new Runnable(){
    public void run(){
      try {
        if (shouldConnect) {
          log.info(""String_Node_Str"" + peer);
          peer.connect();
        }
synchronized (PeerGroup.this) {
          if (!running) {
            peer.disconnect();
            return;
          }
          peers.add(peer);
        }
        handleNewPeer(peer);
        if (blockUntilRunning == ExecuteBlockMode.WAIT_FOR_STARTUP)         latch.countDown();
        peer.run();
      }
 catch (      PeerException ex) {
        final Throwable cause=ex.getCause();
        if (cause instanceof SocketTimeoutException) {
          log.info(""String_Node_Str"" + peer + ""String_Node_Str""+ cause.getMessage());
        }
 else         if (cause instanceof ConnectException) {
          log.info(""String_Node_Str"" + peer + ""String_Node_Str""+ cause.getMessage());
        }
 else         if (cause instanceof IOException) {
          log.info(""String_Node_Str"" + peer + ""String_Node_Str""+ cause.getMessage());
        }
 else {
          log.error(""String_Node_Str"" + peer,ex);
        }
      }
 finally {
        if (!running)         return;
        peer.disconnect();
        if (address != null)         inactives.add(address);
        if (peers.remove(peer))         handlePeerDeath(peer);
      }
    }
  }
);
  if (blockUntilRunning == ExecuteBlockMode.WAIT_FOR_STARTUP) {
    try {
      latch.await();
    }
 catch (    InterruptedException e) {
    }
  }
}",0.9430280138495436
85981,"static BigInteger decodeCompactBits(long compact){
  int size=((int)(compact >> 24)) & 0xFF;
  byte[] bytes=new byte[4 + size];
  bytes[3]=(byte)size;
  if (size >= 1)   bytes[4]=(byte)((compact >> 16) & 0xFF);
  if (size >= 2)   bytes[5]=(byte)((compact >> 8) & 0xFF);
  if (size >= 3)   bytes[6]=(byte)((compact >> 0) & 0xFF);
  return decodeMPI(bytes);
}","public static BigInteger decodeCompactBits(long compact){
  int size=((int)(compact >> 24)) & 0xFF;
  byte[] bytes=new byte[4 + size];
  bytes[3]=(byte)size;
  if (size >= 1)   bytes[4]=(byte)((compact >> 16) & 0xFF);
  if (size >= 2)   bytes[5]=(byte)((compact >> 8) & 0xFF);
  if (size >= 3)   bytes[6]=(byte)((compact >> 0) & 0xFF);
  return decodeMPI(bytes);
}",0.9902912621359224
85982,"@Override public void onChainDownloadStarted(Peer peer,int blocksLeft){
  startDownload(blocksLeft);
  originalBlocksLeft=blocksLeft;
}","@Override public void onChainDownloadStarted(Peer peer,int blocksLeft){
  startDownload(blocksLeft);
  originalBlocksLeft=blocksLeft;
  if (blocksLeft == 0) {
    doneDownload();
    done.release();
  }
}",0.7964601769911505
85983,"/** 
 * Starts an asynchronous download of the block chain. The chain download is deemed to be complete once we've downloaded the same number of blocks that the peer advertised having in its version handshake message.
 */
public void startBlockChainDownload() throws IOException {
  setDownloadData(true);
  if (getPeerBlocksToGet() > 0) {
    for (    PeerEventListener listener : eventListeners) {
synchronized (listener) {
        listener.onChainDownloadStarted(this,getPeerBlocksToGet());
      }
    }
    blockChainDownload(Sha256Hash.ZERO_HASH);
  }
}","/** 
 * Starts an asynchronous download of the block chain. The chain download is deemed to be complete once we've downloaded the same number of blocks that the peer advertised having in its version handshake message.
 */
public void startBlockChainDownload() throws IOException {
  setDownloadData(true);
  if (getPeerBlocksToGet() >= 0) {
    for (    PeerEventListener listener : eventListeners) {
synchronized (listener) {
        listener.onChainDownloadStarted(this,getPeerBlocksToGet());
      }
    }
    blockChainDownload(Sha256Hash.ZERO_HASH);
  }
}",0.9991063449508488
85984,"/** 
 * Depending on the environment, this should normally be between 1 and 10, default is 4.
 * @param maxConnections the maximum number of peer connections that this group will try to make.
 */
public synchronized void setMaxConnections(int maxConnections){
  peerPool.setMaximumPoolSize(maxConnections);
}","/** 
 * Depending on the environment, this should normally be between 1 and 10, default is 4.
 * @param maxConnections the maximum number of peer connections that this group will try to make.
 */
public synchronized void setMaxConnections(int maxConnections){
  peerPool.setCorePoolSize(Math.min(maxConnections,DEFAULT_CONNECTIONS));
  peerPool.setMaximumPoolSize(maxConnections);
}",0.8144927536231884
85985,"@Test public void singleDownloadPeer2() throws Exception {
  MockNetworkConnection n1=createMockNetworkConnection();
  Peer p1=new Peer(params,blockChain,n1);
  MockNetworkConnection n2=createMockNetworkConnection();
  Peer p2=new Peer(params,blockChain,n2);
  peerGroup.start();
  peerGroup.addPeer(p1);
  Block b1=TestUtils.createFakeBlock(params,blockStore).block;
  Block b2=TestUtils.makeSolvedTestBlock(params,b1);
  Block b3=TestUtils.makeSolvedTestBlock(params,b2);
  n1.setVersionMessageForHeight(params,3);
  n2.setVersionMessageForHeight(params,3);
  peerGroup.startBlockChainDownload(new AbstractPeerEventListener(){
  }
);
  GetBlocksMessage getblocks=(GetBlocksMessage)n1.outbound();
  assertEquals(Sha256Hash.ZERO_HASH,getblocks.getStopHash());
  InventoryMessage inv=new InventoryMessage(params);
  inv.addItem(new InventoryItem(InventoryItem.Type.Block,b1.getHash()));
  inv.addItem(new InventoryItem(InventoryItem.Type.Block,b2.getHash()));
  inv.addItem(new InventoryItem(InventoryItem.Type.Block,b3.getHash()));
  n1.inbound(inv);
  GetDataMessage getdata=(GetDataMessage)n1.outbound();
  n1.inbound(b1);
  peerGroup.addPeer(p2);
  Message message=n2.outbound();
  assertNull(message == null ? ""String_Node_Str"" : message.toString(),message);
}","@Test public void singleDownloadPeer2() throws Exception {
  MockNetworkConnection n1=createMockNetworkConnection();
  Peer p1=new Peer(params,blockChain,n1);
  MockNetworkConnection n2=createMockNetworkConnection();
  Peer p2=new Peer(params,blockChain,n2);
  peerGroup.start();
  peerGroup.addPeer(p1);
  Block b1=TestUtils.createFakeBlock(params,blockStore).block;
  Block b2=TestUtils.makeSolvedTestBlock(params,b1);
  Block b3=TestUtils.makeSolvedTestBlock(params,b2);
  n1.setVersionMessageForHeight(params,3);
  n2.setVersionMessageForHeight(params,3);
  peerGroup.startBlockChainDownload(new AbstractPeerEventListener(){
  }
);
  GetBlocksMessage getblocks=(GetBlocksMessage)n1.outbound();
  assertEquals(Sha256Hash.ZERO_HASH,getblocks.getStopHash());
  InventoryMessage inv=new InventoryMessage(params);
  inv.addItem(new InventoryItem(InventoryItem.Type.Block,b1.getHash()));
  inv.addItem(new InventoryItem(InventoryItem.Type.Block,b2.getHash()));
  inv.addItem(new InventoryItem(InventoryItem.Type.Block,b3.getHash()));
  n1.inbound(inv);
  @SuppressWarnings(""String_Node_Str"") GetDataMessage getdata=(GetDataMessage)n1.outbound();
  n1.inbound(b1);
  peerGroup.addPeer(p2);
  Message message=n2.outbound();
  assertNull(message == null ? ""String_Node_Str"" : message.toString(),message);
}",0.9855750487329434
85986,"@Test public void singleDownloadPeer1() throws Exception {
  MockNetworkConnection n1=createMockNetworkConnection();
  Peer p1=new Peer(params,blockChain,n1);
  MockNetworkConnection n2=createMockNetworkConnection();
  Peer p2=new Peer(params,blockChain,n2);
  peerGroup.start();
  peerGroup.addPeer(p1);
  peerGroup.addPeer(p2);
  Block b1=TestUtils.createFakeBlock(params,blockStore).block;
  blockChain.add(b1);
  Block b2=TestUtils.makeSolvedTestBlock(params,b1);
  Block b3=TestUtils.makeSolvedTestBlock(params,b2);
  InventoryMessage inv=new InventoryMessage(params);
  inv.addItem(new InventoryItem(InventoryItem.Type.Block,b3.getHash()));
  n1.inbound(inv);
  n2.inbound(inv);
  assertTrue(n1.outbound() instanceof GetDataMessage);
  assertNull(n2.outbound());
  disconnectAndWait(n1);
  n2.inbound(inv);
  assertTrue(n2.outbound() instanceof GetDataMessage);
  peerGroup.stop();
}","@Test public void singleDownloadPeer1() throws Exception {
  MockNetworkConnection n1=createMockNetworkConnection();
  Peer p1=new Peer(params,blockChain,n1);
  MockNetworkConnection n2=createMockNetworkConnection();
  Peer p2=new Peer(params,blockChain,n2);
  peerGroup.start();
  peerGroup.addPeer(p1);
  peerGroup.addPeer(p2);
  assertEquals(2,peerGroup.numPeers());
  List<Peer> tmp=peerGroup.getPeers();
  assertEquals(p1,tmp.get(0));
  assertEquals(p2,tmp.get(1));
  Block b1=TestUtils.createFakeBlock(params,blockStore).block;
  blockChain.add(b1);
  Block b2=TestUtils.makeSolvedTestBlock(params,b1);
  Block b3=TestUtils.makeSolvedTestBlock(params,b2);
  InventoryMessage inv=new InventoryMessage(params);
  inv.addItem(new InventoryItem(InventoryItem.Type.Block,b3.getHash()));
  n1.inbound(inv);
  n2.inbound(inv);
  assertTrue(n1.outbound() instanceof GetDataMessage);
  assertNull(n2.outbound());
  disconnectAndWait(n1);
  n2.inbound(inv);
  assertTrue(n2.outbound() instanceof GetDataMessage);
  peerGroup.stop();
}",0.9265242313705054
85987,"public void run(){
  try {
    if (shouldConnect) {
      log.info(""String_Node_Str"" + peer);
      peer.connect();
    }
    peers.add(peer);
    handleNewPeer(peer);
    peer.run();
  }
 catch (  PeerException ex) {
    final Throwable cause=ex.getCause();
    if (cause instanceof SocketTimeoutException) {
      log.info(""String_Node_Str"" + peer + ""String_Node_Str""+ cause.getMessage());
    }
 else     if (cause instanceof ConnectException) {
      log.info(""String_Node_Str"" + peer + ""String_Node_Str""+ cause.getMessage());
    }
 else     if (cause instanceof IOException) {
      log.info(""String_Node_Str"" + peer + ""String_Node_Str""+ cause.getMessage());
    }
 else {
      log.error(""String_Node_Str"" + peer,ex);
    }
  }
 finally {
    if (!running)     return;
    peer.disconnect();
    if (address != null)     inactives.add(address);
    if (peers.remove(peer))     handlePeerDeath(peer);
  }
}","public void run(){
  try {
    if (shouldConnect) {
      log.info(""String_Node_Str"" + peer);
      peer.connect();
    }
    peers.add(peer);
    handleNewPeer(peer);
    if (blockUntilRunning == ExecuteBlockMode.WAIT_FOR_STARTUP)     latch.countDown();
    peer.run();
  }
 catch (  PeerException ex) {
    final Throwable cause=ex.getCause();
    if (cause instanceof SocketTimeoutException) {
      log.info(""String_Node_Str"" + peer + ""String_Node_Str""+ cause.getMessage());
    }
 else     if (cause instanceof ConnectException) {
      log.info(""String_Node_Str"" + peer + ""String_Node_Str""+ cause.getMessage());
    }
 else     if (cause instanceof IOException) {
      log.info(""String_Node_Str"" + peer + ""String_Node_Str""+ cause.getMessage());
    }
 else {
      log.error(""String_Node_Str"" + peer,ex);
    }
  }
 finally {
    if (!running)     return;
    peer.disconnect();
    if (address != null)     inactives.add(address);
    if (peers.remove(peer))     handlePeerDeath(peer);
  }
}",0.9544740973312402
85988,"/** 
 * Use this to directly add an already initialized and connected   {@link Peer} object. Normally, you would preferto use  {@link PeerGroup#addAddress(PeerAddress)} and let this object handle construction of the peer for you.This method is useful when you are working closely with the network code (and in unit tests).<p> Note that if this peer group already has the maximum number of peers running (see  {@link PeerGroup#DEFAULT_CONNECTIONS}) then this method will block until other peers are disconnected.<p> Calling this will result in calls to any registered   {@link PeerEventListener}s. Block chain download may occur.
 */
public synchronized void addPeer(Peer peer){
  if (!running)   throw new IllegalStateException(""String_Node_Str"");
  log.info(""String_Node_Str"",peer);
  peer.setDownloadData(false);
  executePeer(null,peer,false);
  handleNewPeer(peer);
}","/** 
 * Use this to directly add an already initialized and connected   {@link Peer} object. Normally, you would preferto use  {@link PeerGroup#addAddress(PeerAddress)} and let this object handle construction of the peer for you.This method is useful when you are working closely with the network code (and in unit tests).<p> Note that if this peer group already has the maximum number of peers running (see  {@link PeerGroup#DEFAULT_CONNECTIONS}) then this method will block until other peers are disconnected.<p> Calling this will result in calls to any registered   {@link PeerEventListener}s. Block chain download may occur.
 */
public void addPeer(Peer peer){
synchronized (this) {
    if (!running)     throw new IllegalStateException(""String_Node_Str"");
    log.info(""String_Node_Str"",peer);
  }
  executePeer(null,peer,false,ExecuteBlockMode.WAIT_FOR_STARTUP);
}",0.9282021826536472
85989,"private void executePeer(final PeerAddress address,final Peer peer,final boolean shouldConnect){
  peerPool.execute(new Runnable(){
    public void run(){
      try {
        if (shouldConnect) {
          log.info(""String_Node_Str"" + peer);
          peer.connect();
        }
        peers.add(peer);
        handleNewPeer(peer);
        peer.run();
      }
 catch (      PeerException ex) {
        final Throwable cause=ex.getCause();
        if (cause instanceof SocketTimeoutException) {
          log.info(""String_Node_Str"" + peer + ""String_Node_Str""+ cause.getMessage());
        }
 else         if (cause instanceof ConnectException) {
          log.info(""String_Node_Str"" + peer + ""String_Node_Str""+ cause.getMessage());
        }
 else         if (cause instanceof IOException) {
          log.info(""String_Node_Str"" + peer + ""String_Node_Str""+ cause.getMessage());
        }
 else {
          log.error(""String_Node_Str"" + peer,ex);
        }
      }
 finally {
        if (!running)         return;
        peer.disconnect();
        if (address != null)         inactives.add(address);
        if (peers.remove(peer))         handlePeerDeath(peer);
      }
    }
  }
);
}","private void executePeer(final PeerAddress address,final Peer peer,final boolean shouldConnect,final ExecuteBlockMode blockUntilRunning){
  final CountDownLatch latch=new CountDownLatch(1);
  peerPool.execute(new Runnable(){
    public void run(){
      try {
        if (shouldConnect) {
          log.info(""String_Node_Str"" + peer);
          peer.connect();
        }
        peers.add(peer);
        handleNewPeer(peer);
        if (blockUntilRunning == ExecuteBlockMode.WAIT_FOR_STARTUP)         latch.countDown();
        peer.run();
      }
 catch (      PeerException ex) {
        final Throwable cause=ex.getCause();
        if (cause instanceof SocketTimeoutException) {
          log.info(""String_Node_Str"" + peer + ""String_Node_Str""+ cause.getMessage());
        }
 else         if (cause instanceof ConnectException) {
          log.info(""String_Node_Str"" + peer + ""String_Node_Str""+ cause.getMessage());
        }
 else         if (cause instanceof IOException) {
          log.info(""String_Node_Str"" + peer + ""String_Node_Str""+ cause.getMessage());
        }
 else {
          log.error(""String_Node_Str"" + peer,ex);
        }
      }
 finally {
        if (!running)         return;
        peer.disconnect();
        if (address != null)         inactives.add(address);
        if (peers.remove(peer))         handlePeerDeath(peer);
      }
    }
  }
);
  if (blockUntilRunning == ExecuteBlockMode.WAIT_FOR_STARTUP) {
    try {
      latch.await();
    }
 catch (    InterruptedException e) {
    }
  }
}",0.8755079423716291
85990,"private void setDownloadPeer(Peer peer){
  if (downloadPeer != null) {
    downloadPeer.setDownloadData(false);
  }
  downloadPeer=peer;
  if (downloadPeer != null) {
    downloadPeer.setDownloadData(true);
  }
}","private synchronized void setDownloadPeer(Peer peer){
  if (downloadPeer != null) {
    downloadPeer.setDownloadData(false);
  }
  downloadPeer=peer;
  if (downloadPeer != null) {
    downloadPeer.setDownloadData(true);
  }
}",0.9702517162471396
85991,"/** 
 * Try connecting to a peer.  If we exceed the number of connections, delay and try again.
 */
private void tryNextPeer() throws InterruptedException {
  final PeerAddress address=inactives.take();
  while (true) {
    try {
      Peer peer=new Peer(params,address,blockStore.getChainHead().getHeight(),chain);
      executePeer(address,peer,true);
      break;
    }
 catch (    RejectedExecutionException e) {
    }
catch (    BlockStoreException e) {
      log.error(""String_Node_Str"",e);
      running=false;
      throw new RuntimeException(e);
    }
    Thread.sleep(connectionDelayMillis);
  }
}","/** 
 * Try connecting to a peer.  If we exceed the number of connections, delay and try again.
 */
private void tryNextPeer() throws InterruptedException {
  final PeerAddress address=inactives.take();
  while (true) {
    try {
      Peer peer=new Peer(params,address,blockStore.getChainHead().getHeight(),chain);
      executePeer(address,peer,true,ExecuteBlockMode.RETURN_IMMEDIATELY);
      break;
    }
 catch (    RejectedExecutionException e) {
    }
catch (    BlockStoreException e) {
      log.error(""String_Node_Str"",e);
      running=false;
      throw new RuntimeException(e);
    }
    Thread.sleep(connectionDelayMillis);
  }
}",0.9712
85992,"protected synchronized void handleNewPeer(Peer peer){
  log.info(""String_Node_Str"",peer);
  if (downloadListener != null && downloadPeer == null) {
    log.info(""String_Node_Str"");
    startBlockChainDownloadFromPeer(peer);
  }
 else   if (downloadPeer == null) {
    setDownloadPeer(peer);
  }
synchronized (peerEventListeners) {
    for (    PeerEventListener listener : peerEventListeners) {
synchronized (listener) {
        listener.onPeerConnected(peer,peers.size());
      }
    }
  }
}","protected synchronized void handleNewPeer(Peer peer){
  log.info(""String_Node_Str"",peer);
  if (downloadListener != null && downloadPeer == null) {
    log.info(""String_Node_Str"");
    startBlockChainDownloadFromPeer(peer);
  }
 else   if (downloadPeer == null) {
    setDownloadPeer(peer);
  }
 else {
    peer.setDownloadData(false);
  }
synchronized (peerEventListeners) {
    for (    PeerEventListener listener : peerEventListeners) {
synchronized (listener) {
        listener.onPeerConnected(peer,peers.size());
      }
    }
  }
}",0.95635305528613
85993,"public static byte[] copyOf(byte[] in,int length){
  byte[] out=new byte[length];
  System.arraycopy(in,0,out,0,length);
  return out;
}","public static byte[] copyOf(byte[] in,int length){
  byte[] out=new byte[length];
  System.arraycopy(in,0,out,0,Math.min(length,in.length));
  Arrays.copyOf(in,6);
  return out;
}",0.8634920634920635
85994,"protected void parseLite() throws ProtocolException {
  if (length == UNKNOWN_LENGTH) {
    log.warn(""String_Node_Str"");
    parseTransactions();
    length=cursor - offset;
  }
 else {
    transactionBytesValid=!transactionsParsed || parseRetain && length > 80;
  }
  headerBytesValid=!headerParsed || parseRetain && length >= 80;
}","protected void parseLite() throws ProtocolException {
}",0.2835051546391752
85995,"/** 
 * Perform the most minimal parse possible to calculate the length of the message. This is only required for subclasses of ChildClass as root level messages will have their length passed into the constructor. <p/> It is expected that the length field will be set before this method returns.
 * @return
 * @throws ProtocolException
 */
protected abstract void parseLite() throws ProtocolException ;","/** 
 * Perform the most minimal parse possible to calculate the length of the message. This is only required for subclasses of ChildClass as root level messages will have their length passed into the constructor. <p/> Implementations should adhere to the following contract:  If parseLazy = true the 'length' field must be set before returning.  If parseLazy = false the length field must be set either within the parseLite() method OR the parse() method.  The overriding requirement is that length must be set to non UNKNOWN_MESSAGE value by the time the constructor exits.
 * @return
 * @throws ProtocolException
 */
protected abstract void parseLite() throws ProtocolException ;",0.6125461254612546
85996,"/** 
 * This should be overridden to extract correct message size in the case of lazy parsing.  Until this method is implemented in a subclass of ChildMessage lazy parsing may have no effect. This default implementation is a safe fall back that will ensure it returns a correct value by parsing the message.
 * @return
 */
int getMessageSize(){
  if (length != UNKNOWN_LENGTH)   return length;
  checkParse();
  if (length != UNKNOWN_LENGTH)   length=cursor - offset;
  return length;
}","/** 
 * This should be overridden to extract correct message size in the case of lazy parsing.  Until this method is implemented in a subclass of ChildMessage lazy parsing may have no effect. This default implementation is a safe fall back that will ensure it returns a correct value by parsing the message.
 * @return
 */
int getMessageSize(){
}",0.8317307692307693
85997,"/** 
 * Writes out the given byte buffer to the output stream with the correct opcode prefix 
 */
static void writeBytes(OutputStream os,byte[] buf) throws IOException {
  if (buf.length < OP_PUSHDATA1) {
    os.write(buf.length);
    os.write(buf);
  }
 else   if (buf.length < 256) {
    os.write(OP_PUSHDATA1);
    os.write(buf.length);
    os.write(buf);
  }
 else   if (buf.length < 65536) {
    os.write(OP_PUSHDATA2);
    os.write(0xFF & (buf.length));
    os.write(0xFF & (buf.length >> 8));
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
}","/** 
 * Writes out the given byte buffer to the output stream with the correct opcode prefix 
 */
static void writeBytes(OutputStream os,byte[] buf) throws IOException {
  if (buf.length < OP_PUSHDATA1) {
    os.write(buf.length);
    os.write(buf);
  }
 else   if (buf.length < 256) {
    os.write(OP_PUSHDATA1);
    os.write(buf.length);
    os.write(buf);
  }
 else   if (buf.length < 65536) {
    os.write(OP_PUSHDATA2);
    os.write(0xFF & (buf.length));
    os.write(0xFF & (buf.length >> 8));
    os.write(buf);
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
}",0.9835497835497836
85998,"public Thread newThread(Runnable r){
  Thread t=new Thread(group,r,namePrefix + threadNumber.getAndIncrement(),0);
  t.setPriority(Math.max(Thread.MIN_PRIORITY,group.getMaxPriority() - 1));
  t.setDaemon(true);
  return t;
}","public Thread newThread(Runnable r){
  Thread t=new Thread(group,r,namePrefix + threadNumber.getAndIncrement(),0);
  t.setPriority(Math.max(Thread.MIN_PRIORITY,Thread.currentThread().getPriority() - 1));
  t.setDaemon(true);
  return t;
}",0.922077922077922
85999,"/** 
 * Terminates the network connection and stops the message handling loop.
 */
public void disconnect(){
synchronized (this) {
    running=false;
  }
  try {
    conn.shutdown();
  }
 catch (  IOException e) {
  }
}","/** 
 * Terminates the network connection and stops the message handling loop.
 */
public void disconnect(){
synchronized (this) {
    running=false;
  }
  try {
    if (conn != null)     conn.shutdown();
  }
 catch (  IOException e) {
  }
}",0.9521739130434784
86000,"/** 
 * Runs in the peers network loop and manages communication with the peer. <p>connect() must be called first
 */
public void run(){
  if (conn == null)   throw new RuntimeException(""String_Node_Str"");
  running=true;
  try {
    while (true) {
      Message m=conn.readMessage();
      if (m instanceof InventoryMessage) {
        processInv((InventoryMessage)m);
      }
 else       if (m instanceof Block) {
        processBlock((Block)m);
      }
 else       if (m instanceof AddressMessage) {
      }
 else {
        log.warn(""String_Node_Str"",m);
      }
    }
  }
 catch (  Exception e) {
    if (e instanceof IOException && !running) {
      log.info(""String_Node_Str"");
    }
 else {
      e.printStackTrace();
    }
  }
  try {
    conn.shutdown();
  }
 catch (  IOException e) {
  }
synchronized (this) {
    running=false;
  }
}","/** 
 * Runs in the peers network loop and manages communication with the peer. <p>connect() must be called first
 * @throws PeerException when there is a temporary problem with the peer and we should retry later
 */
public void run() throws PeerException {
  if (conn == null)   throw new RuntimeException(""String_Node_Str"");
  running=true;
  try {
    while (true) {
      Message m=conn.readMessage();
      if (m instanceof InventoryMessage) {
        processInv((InventoryMessage)m);
      }
 else       if (m instanceof Block) {
        processBlock((Block)m);
      }
 else       if (m instanceof AddressMessage) {
      }
 else {
        log.warn(""String_Node_Str"",m);
      }
    }
  }
 catch (  IOException e) {
    disconnect();
    if (!running) {
      log.info(""String_Node_Str"");
    }
 else {
      throw new PeerException(e);
    }
  }
catch (  ProtocolException e) {
    disconnect();
    throw new PeerException(e);
  }
catch (  RuntimeException e) {
    disconnect();
    log.error(""String_Node_Str"",e);
    throw e;
  }
  disconnect();
}",0.7073042564372044
